{"sha": "1079d2c187d78c2d3a974c42c56bb274bbde9da8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3OWQyYzE4N2Q3OGMyZDNhOTc0YzQyYzU2YmIyNzRiYmRlOWRhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:01:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:01:52Z"}, "message": "poly_int: decode_addr_const\n\nThis patch makes the varasm-local addr_const track polynomial offsets.\nI'm not sure how useful this is, but it was easier to convert than not.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* varasm.c (addr_const::offset): Change from HOST_WIDE_INT\n\tto poly_int64.\n\t(decode_addr_const): Update accordingly.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255927", "tree": {"sha": "15e7e5d8c516d1128d947e73f8d5e4409ac914b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e7e5d8c516d1128d947e73f8d5e4409ac914b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1079d2c187d78c2d3a974c42c56bb274bbde9da8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1079d2c187d78c2d3a974c42c56bb274bbde9da8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1079d2c187d78c2d3a974c42c56bb274bbde9da8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1079d2c187d78c2d3a974c42c56bb274bbde9da8/comments", "author": null, "committer": null, "parents": [{"sha": "e7301f5fcbfa649beb05da1e3508db7fc7c4d26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7301f5fcbfa649beb05da1e3508db7fc7c4d26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7301f5fcbfa649beb05da1e3508db7fc7c4d26b"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "26b35ab7c71f3fe149adc12b327428f6f4fa0f26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1079d2c187d78c2d3a974c42c56bb274bbde9da8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1079d2c187d78c2d3a974c42c56bb274bbde9da8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1079d2c187d78c2d3a974c42c56bb274bbde9da8", "patch": "@@ -1,3 +1,11 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* varasm.c (addr_const::offset): Change from HOST_WIDE_INT\n+\tto poly_int64.\n+\t(decode_addr_const): Update accordingly.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "2b2cde972700fe8f4a002995f96cefad58ed5d3a", "filename": "gcc/varasm.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1079d2c187d78c2d3a974c42c56bb274bbde9da8/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1079d2c187d78c2d3a974c42c56bb274bbde9da8/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=1079d2c187d78c2d3a974c42c56bb274bbde9da8", "patch": "@@ -2872,30 +2872,33 @@ assemble_real (REAL_VALUE_TYPE d, scalar_float_mode mode, unsigned int align,\n \n struct addr_const {\n   rtx base;\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n };\n \n static void\n decode_addr_const (tree exp, struct addr_const *value)\n {\n   tree target = TREE_OPERAND (exp, 0);\n-  HOST_WIDE_INT offset = 0;\n+  poly_int64 offset = 0;\n   rtx x;\n \n   while (1)\n     {\n+      poly_int64 bytepos;\n       if (TREE_CODE (target) == COMPONENT_REF\n-\t  && tree_fits_shwi_p (byte_position (TREE_OPERAND (target, 1))))\n+\t  && poly_int_tree_p (byte_position (TREE_OPERAND (target, 1)),\n+\t\t\t      &bytepos))\n \t{\n-\t  offset += int_byte_position (TREE_OPERAND (target, 1));\n+\t  offset += bytepos;\n \t  target = TREE_OPERAND (target, 0);\n \t}\n       else if (TREE_CODE (target) == ARRAY_REF\n \t       || TREE_CODE (target) == ARRAY_RANGE_REF)\n \t{\n \t  /* Truncate big offset.  */\n-\t  offset += (TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (target)))\n-\t\t     * TREE_INT_CST_LOW (TREE_OPERAND (target, 1)));\n+\t  offset\n+\t    += (TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (target)))\n+\t\t* wi::to_poly_widest (TREE_OPERAND (target, 1)).force_shwi ());\n \t  target = TREE_OPERAND (target, 0);\n \t}\n       else if (TREE_CODE (target) == MEM_REF\n@@ -3040,14 +3043,14 @@ const_hash_1 (const tree exp)\n \t  case SYMBOL_REF:\n \t    /* Don't hash the address of the SYMBOL_REF;\n \t       only use the offset and the symbol name.  */\n-\t    hi = value.offset;\n+\t    hi = value.offset.coeffs[0];\n \t    p = XSTR (value.base, 0);\n \t    for (i = 0; p[i] != 0; i++)\n \t      hi = ((hi * 613) + (unsigned) (p[i]));\n \t    break;\n \n \t  case LABEL_REF:\n-\t    hi = (value.offset\n+\t    hi = (value.offset.coeffs[0]\n \t\t  + CODE_LABEL_NUMBER (label_ref_label (value.base)) * 13);\n \t    break;\n \n@@ -3233,7 +3236,7 @@ compare_constant (const tree t1, const tree t2)\n \tdecode_addr_const (t1, &value1);\n \tdecode_addr_const (t2, &value2);\n \n-\tif (value1.offset != value2.offset)\n+\tif (maybe_ne (value1.offset, value2.offset))\n \t  return 0;\n \n \tcode = GET_CODE (value1.base);"}]}