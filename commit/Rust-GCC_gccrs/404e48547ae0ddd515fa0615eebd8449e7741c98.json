{"sha": "404e48547ae0ddd515fa0615eebd8449e7741c98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA0ZTQ4NTQ3YWUwZGRkNTE1ZmEwNjE1ZWViZDg0NDllNzc0MWM5OA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-07-15T15:13:52Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-07-15T15:13:52Z"}, "message": "Warning patch:\n\n\t* mips.c (function_arg_pass_by_reference): Don't do automatic\n\taggregate initialization.\n\t(machine_dependent_reorg): Initialize variable `mode'.\n\n\t* mips.md (absdi2): Change variable `regno1' to unsigned int.\n\t(reload_indi): Rename loword/hiword to lo_word/hi_word to avoid\n\tconflicts with sys/param.h macro of the same name.\n\t(reload_outdi): Likewise.\n\nFrom-SVN: r35047", "tree": {"sha": "4beadd9e2e22de216ff4d48ff5bba7df301cf627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4beadd9e2e22de216ff4d48ff5bba7df301cf627"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/404e48547ae0ddd515fa0615eebd8449e7741c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/404e48547ae0ddd515fa0615eebd8449e7741c98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/404e48547ae0ddd515fa0615eebd8449e7741c98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/404e48547ae0ddd515fa0615eebd8449e7741c98/comments", "author": null, "committer": null, "parents": [{"sha": "4d06bcc527aca789f9282167528aa02f77cdd6ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d06bcc527aca789f9282167528aa02f77cdd6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d06bcc527aca789f9282167528aa02f77cdd6ca"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "66391fdd57c952cca828316ee1bdfc8f85989c91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404e48547ae0ddd515fa0615eebd8449e7741c98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404e48547ae0ddd515fa0615eebd8449e7741c98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=404e48547ae0ddd515fa0615eebd8449e7741c98", "patch": "@@ -1,3 +1,14 @@\n+2000-07-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* mips.c (function_arg_pass_by_reference): Don't do automatic\n+\taggregate initialization.\n+\t(machine_dependent_reorg): Initialize variable `mode'.\n+\t\n+\t* mips.md (absdi2): Change variable `regno1' to unsigned int.\n+\t(reload_indi): Rename loword/hiword to lo_word/hi_word to avoid\n+\tconflicts with sys/param.h macro of the same name.\n+\t(reload_outdi): Likewise.\n+\n 2000-07-15  Michael Meissner  <meissner@redhat.com>\n \n \t* fold-const.c (fold): When optimizing FOO++ == CONST into ++FOO"}, {"sha": "8d9c55ead27a8e4ec98ed487de93c61b936f09bc", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404e48547ae0ddd515fa0615eebd8449e7741c98/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404e48547ae0ddd515fa0615eebd8449e7741c98/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=404e48547ae0ddd515fa0615eebd8449e7741c98", "patch": "@@ -7784,7 +7784,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n         /* Don't pass the actual CUM to FUNCTION_ARG, because we would \n            get double copies of any offsets generated for small structs \n            passed in registers. */\n-        CUMULATIVE_ARGS temp = *cum;\n+        CUMULATIVE_ARGS temp;\n+        temp = *cum;\n         if (FUNCTION_ARG (temp, mode, type, named) != 0)\n            return 1;\n      }\n@@ -9097,7 +9098,7 @@ machine_dependent_reorg (first)\n \t  && GET_CODE (PATTERN (insn)) == SET)\n \t{\n \t  rtx val, src;\n-\t  enum machine_mode mode;\n+\t  enum machine_mode mode = VOIDmode;\n \n \t  val = NULL_RTX;\n \t  src = mips_find_symbol (SET_SRC (PATTERN (insn)));"}, {"sha": "92f5beac9fa447e4b2a0f1290a40e49b46005432", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404e48547ae0ddd515fa0615eebd8449e7741c98/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404e48547ae0ddd515fa0615eebd8449e7741c98/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=404e48547ae0ddd515fa0615eebd8449e7741c98", "patch": "@@ -2838,7 +2838,7 @@\n   \"TARGET_64BIT && !TARGET_MIPS16\"\n   \"*\n {\n-  int regno1;\n+  unsigned int regno1;\n   dslots_jump_total++;\n   dslots_jump_filled++;\n   operands[2] = const0_rtx;\n@@ -4988,7 +4988,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     {\n       if (GET_CODE (operands[1]) == MEM)\n \t{\n-\t  rtx memword, offword, hiword, loword;\n+\t  rtx memword, offword, hi_word, lo_word;\n \t  rtx addr = find_replacement (&XEXP (operands[1], 0));\n \t  rtx op1 = change_address (operands[1], VOIDmode, addr);\n \n@@ -4998,17 +4998,17 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t\t\t    SImode, NULL_RTX);\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n-\t      hiword = memword;\n-\t      loword = offword;\n+\t      hi_word = memword;\n+\t      lo_word = offword;\n \t    }\n \t  else\n \t    {\n-\t      hiword = offword;\n-\t      loword = memword;\n+\t      hi_word = offword;\n+\t      lo_word = memword;\n \t    }\n-\t  emit_move_insn (scratch, hiword);\n+\t  emit_move_insn (scratch, hi_word);\n \t  emit_move_insn (gen_rtx_REG (SImode, 64), scratch);\n-\t  emit_move_insn (scratch, loword);\n+\t  emit_move_insn (scratch, lo_word);\n \t  emit_move_insn (gen_rtx (REG, SImode, 65), scratch);\n           emit_insn (gen_rtx_USE (VOIDmode, operands[0]));\n \t}\n@@ -5068,7 +5068,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     {\n       if (GET_CODE (operands[0]) == MEM)\n \t{\n-\t  rtx scratch, memword, offword, hiword, loword;\n+\t  rtx scratch, memword, offword, hi_word, lo_word;\n \t  rtx addr = find_replacement (&XEXP (operands[0], 0));\n \t  rtx op0 = change_address (operands[0], VOIDmode, addr);\n \n@@ -5078,18 +5078,18 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t\t\t    SImode, NULL_RTX);\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n-\t      hiword = memword;\n-\t      loword = offword;\n+\t      hi_word = memword;\n+\t      lo_word = offword;\n \t    }\n \t  else\n \t    {\n-\t      hiword = offword;\n-\t      loword = memword;\n+\t      hi_word = offword;\n+\t      lo_word = memword;\n \t    }\n \t  emit_move_insn (scratch, gen_rtx_REG (SImode, 64));\n-\t  emit_move_insn (hiword, scratch);\n+\t  emit_move_insn (hi_word, scratch);\n \t  emit_move_insn (scratch, gen_rtx_REG (SImode, 65));\n-\t  emit_move_insn (loword, scratch);\n+\t  emit_move_insn (lo_word, scratch);\n \t  emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n \t}\n       else if (TARGET_MIPS16 && ! M16_REG_P (REGNO (operands[0])))"}]}