{"sha": "d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlMTA5MGFlNmI3NjdmNWNlMGYwMjM3YTk3NjNiZWQyNDU0NWRkMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-01-19T11:37:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-19T11:37:39Z"}, "message": "exp_ch6.adb (Expand_N_Subprogram_Body): Mark the spec as returning by reference not just for subprogram body stubs...\n\n2017-01-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): Mark the spec as\n\treturning by reference not just for subprogram body stubs,\n\tbut for all subprogram cases.\n\t* sem_util.adb: Code reformatting.\n\t(Requires_Transient_Scope): Update the call to Results_Differ.\n\t(Results_Differ): Update the parameter profile and the associated\n\tcomment on usage.\n\nFrom-SVN: r244616", "tree": {"sha": "c902415ecc44040cdfb956d141e9bbc066273bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c902415ecc44040cdfb956d141e9bbc066273bbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de01377ca91e88226f919c84677d82c65dec6adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de01377ca91e88226f919c84677d82c65dec6adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de01377ca91e88226f919c84677d82c65dec6adf"}], "stats": {"total": 743, "additions": 380, "deletions": 363}, "files": [{"sha": "ee40173e1455ce8be61d1b432bd6ed892489e06c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "patch": "@@ -1,3 +1,13 @@\n+2017-01-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Subprogram_Body): Mark the spec as\n+\treturning by reference not just for subprogram body stubs,\n+\tbut for all subprogram cases.\n+\t* sem_util.adb: Code reformatting.\n+\t(Requires_Transient_Scope): Update the call to Results_Differ.\n+\t(Results_Differ): Update the parameter profile and the associated\n+\tcomment on usage.\n+\n 2017-01-19  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_dim.adb (Analyze_Dimension): Analyze object declaration and"}, {"sha": "4e03bd10df59a294805d4a37539ea77705598479", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "patch": "@@ -5542,13 +5542,7 @@ package body Exp_Ch6 is\n          Utyp : constant Entity_Id := Underlying_Type (Typ);\n \n       begin\n-         if not Acts_As_Spec (N)\n-           and then Nkind (Parent (Parent (Spec_Id))) /=\n-                      N_Subprogram_Body_Stub\n-         then\n-            null;\n-\n-         elsif Is_Limited_View (Typ) then\n+         if Is_Limited_View (Typ) then\n             Set_Returns_By_Ref (Spec_Id);\n \n          elsif Present (Utyp) and then CW_Or_Has_Controlled_Part (Utyp) then\n@@ -7306,9 +7300,11 @@ package body Exp_Ch6 is\n       declare\n          Typ  : constant Entity_Id := Etype (Subp);\n          Utyp : constant Entity_Id := Underlying_Type (Typ);\n+\n       begin\n          if Is_Limited_View (Typ) then\n             Set_Returns_By_Ref (Subp);\n+\n          elsif Present (Utyp) and then CW_Or_Has_Controlled_Part (Utyp) then\n             Set_Returns_By_Ref (Subp);\n          end if;"}, {"sha": "b3a6b5b75096905d194c4c61c8affa935f01f45a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 367, "deletions": 356, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e1090ae6b767f5ce0f0237a9763bed24545dd1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d6e1090ae6b767f5ce0f0237a9763bed24545dd1", "patch": "@@ -129,6 +129,24 @@ package body Sem_Util is\n    --  components in the selected variant to determine whether all of them\n    --  have a default.\n \n+   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n+   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n+   --  ???We retain the old and new algorithms for Requires_Transient_Scope for\n+   --  the time being. New_Requires_Transient_Scope is used by default; the\n+   --  debug switch -gnatdQ can be used to do Old_Requires_Transient_Scope\n+   --  instead. The intent is to use this temporarily to measure before/after\n+   --  efficiency. Note: when this temporary code is removed, the documentation\n+   --  of dQ in debug.adb should be removed.\n+\n+   procedure Results_Differ\n+     (Id      : Entity_Id;\n+      Old_Val : Boolean;\n+      New_Val : Boolean);\n+   --  ???Debugging code. Called when the Old_Val and New_Val differ. This\n+   --  routine will be removed eventially when New_Requires_Transient_Scope\n+   --  becomes Requires_Transient_Scope and Old_Requires_Transient_Scope is\n+   --  eliminated.\n+\n    ------------------------------\n    --  Abstract_Interface_List --\n    ------------------------------\n@@ -17013,6 +17031,232 @@ package body Sem_Util is\n       Actual_Id := Next_Actual (Actual_Id);\n    end Next_Actual;\n \n+   ----------------------------------\n+   -- New_Requires_Transient_Scope --\n+   ----------------------------------\n+\n+   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n+      --  This is called for untagged records and protected types, with\n+      --  nondefaulted discriminants. Returns True if the size of function\n+      --  results is known at the call site, False otherwise. Returns False\n+      --  if there is a variant part that depends on the discriminants of\n+      --  this type, or if there is an array constrained by the discriminants\n+      --  of this type. ???Currently, this is overly conservative (the array\n+      --  could be nested inside some other record that is constrained by\n+      --  nondiscriminants). That is, the recursive calls are too conservative.\n+\n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n+      --  Returns True if Typ is a nonlimited record with defaulted\n+      --  discriminants whose max size makes it unsuitable for allocating on\n+      --  the primary stack.\n+\n+      ------------------------------\n+      -- Caller_Known_Size_Record --\n+      ------------------------------\n+\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+      begin\n+         if Has_Variant_Part (Typ) and then not Is_Definite_Subtype (Typ) then\n+            return False;\n+         end if;\n+\n+         declare\n+            Comp : Entity_Id;\n+\n+         begin\n+            Comp := First_Entity (Typ);\n+            while Present (Comp) loop\n+\n+               --  Only look at E_Component entities. No need to look at\n+               --  E_Discriminant entities, and we must ignore internal\n+               --  subtypes generated for constrained components.\n+\n+               if Ekind (Comp) = E_Component then\n+                  declare\n+                     Comp_Type : constant Entity_Id :=\n+                                   Underlying_Type (Etype (Comp));\n+\n+                  begin\n+                     if Is_Record_Type (Comp_Type)\n+                           or else\n+                        Is_Protected_Type (Comp_Type)\n+                     then\n+                        if not Caller_Known_Size_Record (Comp_Type) then\n+                           return False;\n+                        end if;\n+\n+                     elsif Is_Array_Type (Comp_Type) then\n+                        if Size_Depends_On_Discriminant (Comp_Type) then\n+                           return False;\n+                        end if;\n+                     end if;\n+                  end;\n+               end if;\n+\n+               Next_Entity (Comp);\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Caller_Known_Size_Record;\n+\n+      ------------------------------\n+      -- Large_Max_Size_Mutable --\n+      ------------------------------\n+\n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n+         --  Returns true if the discrete type T has a large range\n+\n+         ----------------------------\n+         -- Is_Large_Discrete_Type --\n+         ----------------------------\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n+            Threshold : constant Int := 16;\n+            --  Arbitrary threshold above which we consider it \"large\". We want\n+            --  a fairly large threshold, because these large types really\n+            --  shouldn't have default discriminants in the first place, in\n+            --  most cases.\n+\n+         begin\n+            return UI_To_Int (RM_Size (T)) > Threshold;\n+         end Is_Large_Discrete_Type;\n+\n+      --  Start of processing for Large_Max_Size_Mutable\n+\n+      begin\n+         if Is_Record_Type (Typ)\n+           and then not Is_Limited_View (Typ)\n+           and then Has_Defaulted_Discriminants (Typ)\n+         then\n+            --  Loop through the components, looking for an array whose upper\n+            --  bound(s) depends on discriminants, where both the subtype of\n+            --  the discriminant and the index subtype are too large.\n+\n+            declare\n+               Comp : Entity_Id;\n+\n+            begin\n+               Comp := First_Entity (Typ);\n+               while Present (Comp) loop\n+                  if Ekind (Comp) = E_Component then\n+                     declare\n+                        Comp_Type : constant Entity_Id :=\n+                                      Underlying_Type (Etype (Comp));\n+\n+                        Hi   : Node_Id;\n+                        Indx : Node_Id;\n+                        Ityp : Entity_Id;\n+\n+                     begin\n+                        if Is_Array_Type (Comp_Type) then\n+                           Indx := First_Index (Comp_Type);\n+\n+                           while Present (Indx) loop\n+                              Ityp := Etype (Indx);\n+                              Hi := Type_High_Bound (Ityp);\n+\n+                              if Nkind (Hi) = N_Identifier\n+                                and then Ekind (Entity (Hi)) = E_Discriminant\n+                                and then Is_Large_Discrete_Type (Ityp)\n+                                and then Is_Large_Discrete_Type\n+                                           (Etype (Entity (Hi)))\n+                              then\n+                                 return True;\n+                              end if;\n+\n+                              Next_Index (Indx);\n+                           end loop;\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  Next_Entity (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Large_Max_Size_Mutable;\n+\n+      --  Local declarations\n+\n+      Typ : constant Entity_Id := Underlying_Type (Id);\n+\n+   --  Start of processing for New_Requires_Transient_Scope\n+\n+   begin\n+      --  This is a private type which is not completed yet. This can only\n+      --  happen in a default expression (of a formal parameter or of a\n+      --  record component). Do not expand transient scope in this case.\n+\n+      if No (Typ) then\n+         return False;\n+\n+      --  Do not expand transient scope for non-existent procedure return or\n+      --  string literal types.\n+\n+      elsif Typ = Standard_Void_Type\n+        or else Ekind (Typ) = E_String_Literal_Subtype\n+      then\n+         return False;\n+\n+      --  If Typ is a generic formal incomplete type, then we want to look at\n+      --  the actual type.\n+\n+      elsif Ekind (Typ) = E_Record_Subtype\n+        and then Present (Cloned_Subtype (Typ))\n+      then\n+         return New_Requires_Transient_Scope (Cloned_Subtype (Typ));\n+\n+      --  Functions returning specific tagged types may dispatch on result, so\n+      --  their returned value is allocated on the secondary stack, even in the\n+      --  definite case. We must treat nondispatching functions the same way,\n+      --  because access-to-function types can point at both, so the calling\n+      --  conventions must be compatible. Is_Tagged_Type includes controlled\n+      --  types and class-wide types. Controlled type temporaries need\n+      --  finalization.\n+\n+      --  ???It's not clear why we need to return noncontrolled types with\n+      --  controlled components on the secondary stack.\n+\n+      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n+         return True;\n+\n+      --  Untagged definite subtypes are known size. This includes all\n+      --  elementary [sub]types. Tasks are known size even if they have\n+      --  discriminants. So we return False here, with one exception:\n+      --  For a type like:\n+      --    type T (Last : Natural := 0) is\n+      --       X : String (1 .. Last);\n+      --    end record;\n+      --  we return True. That's because for \"P(F(...));\", where F returns T,\n+      --  we don't know the size of the result at the call site, so if we\n+      --  allocated it on the primary stack, we would have to allocate the\n+      --  maximum size, which is way too big.\n+\n+      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n+         return Large_Max_Size_Mutable (Typ);\n+\n+      --  Indefinite (discriminated) untagged record or protected type\n+\n+      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n+         return not Caller_Known_Size_Record (Typ);\n+\n+      --  Unconstrained array\n+\n+      else\n+         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n+         return True;\n+      end if;\n+   end New_Requires_Transient_Scope;\n+\n    -----------------------\n    -- Normalize_Actuals --\n    -----------------------\n@@ -17889,21 +18133,120 @@ package body Sem_Util is\n       end if;\n    end Object_Access_Level;\n \n-   ---------------------------------\n-   -- Original_Aspect_Pragma_Name --\n-   ---------------------------------\n+   ----------------------------------\n+   -- Old_Requires_Transient_Scope --\n+   ----------------------------------\n \n-   function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id is\n-      Item     : Node_Id;\n-      Item_Nam : Name_Id;\n+   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n+      Typ : constant Entity_Id := Underlying_Type (Id);\n \n    begin\n-      pragma Assert (Nkind_In (N, N_Aspect_Specification, N_Pragma));\n+      --  This is a private type which is not completed yet. This can only\n+      --  happen in a default expression (of a formal parameter or of a\n+      --  record component). Do not expand transient scope in this case.\n \n-      Item := N;\n+      if No (Typ) then\n+         return False;\n \n-      --  The pragma was generated to emulate an aspect, use the original\n-      --  aspect specification.\n+      --  Do not expand transient scope for non-existent procedure return\n+\n+      elsif Typ = Standard_Void_Type then\n+         return False;\n+\n+      --  Elementary types do not require a transient scope\n+\n+      elsif Is_Elementary_Type (Typ) then\n+         return False;\n+\n+      --  Generally, indefinite subtypes require a transient scope, since the\n+      --  back end cannot generate temporaries, since this is not a valid type\n+      --  for declaring an object. It might be possible to relax this in the\n+      --  future, e.g. by declaring the maximum possible space for the type.\n+\n+      elsif not Is_Definite_Subtype (Typ) then\n+         return True;\n+\n+      --  Functions returning tagged types may dispatch on result so their\n+      --  returned value is allocated on the secondary stack. Controlled\n+      --  type temporaries need finalization.\n+\n+      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n+         return True;\n+\n+      --  Record type\n+\n+      elsif Is_Record_Type (Typ) then\n+         declare\n+            Comp : Entity_Id;\n+\n+         begin\n+            Comp := First_Entity (Typ);\n+            while Present (Comp) loop\n+               if Ekind (Comp) = E_Component then\n+\n+                  --  ???It's not clear we need a full recursive call to\n+                  --  Old_Requires_Transient_Scope here. Note that the\n+                  --  following can't happen.\n+\n+                  pragma Assert (Is_Definite_Subtype (Etype (Comp)));\n+                  pragma Assert (not Has_Controlled_Component (Etype (Comp)));\n+\n+                  if Old_Requires_Transient_Scope (Etype (Comp)) then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               Next_Entity (Comp);\n+            end loop;\n+         end;\n+\n+         return False;\n+\n+      --  String literal types never require transient scope\n+\n+      elsif Ekind (Typ) = E_String_Literal_Subtype then\n+         return False;\n+\n+      --  Array type. Note that we already know that this is a constrained\n+      --  array, since unconstrained arrays will fail the indefinite test.\n+\n+      elsif Is_Array_Type (Typ) then\n+\n+         --  If component type requires a transient scope, the array does too\n+\n+         if Old_Requires_Transient_Scope (Component_Type (Typ)) then\n+            return True;\n+\n+         --  Otherwise, we only need a transient scope if the size depends on\n+         --  the value of one or more discriminants.\n+\n+         else\n+            return Size_Depends_On_Discriminant (Typ);\n+         end if;\n+\n+      --  All other cases do not require a transient scope\n+\n+      else\n+         pragma Assert (Is_Protected_Type (Typ) or else Is_Task_Type (Typ));\n+         return False;\n+      end if;\n+   end Old_Requires_Transient_Scope;\n+\n+   ---------------------------------\n+   -- Original_Aspect_Pragma_Name --\n+   ---------------------------------\n+\n+   function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id is\n+      Item     : Node_Id;\n+      Item_Nam : Name_Id;\n+\n+   begin\n+      pragma Assert (Nkind_In (N, N_Aspect_Specification, N_Pragma));\n+\n+      Item := N;\n+\n+      --  The pragma was generated to emulate an aspect, use the original\n+      --  aspect specification.\n \n       if Nkind (Item) = N_Pragma and then From_Aspect_Specification (Item) then\n          Item := Corresponding_Aspect (Item);\n@@ -18855,33 +19198,6 @@ package body Sem_Util is\n    --  allocated on the secondary stack, or when finalization actions must be\n    --  generated before the next instruction.\n \n-   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n-   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n-   --  ???We retain the old and new algorithms for Requires_Transient_Scope for\n-   --  the time being. New_Requires_Transient_Scope is used by default; the\n-   --  debug switch -gnatdQ can be used to do Old_Requires_Transient_Scope\n-   --  instead. The intent is to use this temporarily to measure before/after\n-   --  efficiency. Note: when this temporary code is removed, the documentation\n-   --  of dQ in debug.adb should be removed.\n-\n-   procedure Results_Differ (Id : Entity_Id);\n-   --  ???Debugging code. Called when the Old_ and New_ results differ. Will be\n-   --  removed when New_Requires_Transient_Scope becomes\n-   --  Requires_Transient_Scope and Old_Requires_Transient_Scope is eliminated.\n-\n-   procedure Results_Differ (Id : Entity_Id) is\n-   begin\n-      if False then -- False to disable; True for debugging\n-         Treepr.Print_Tree_Node (Id);\n-\n-         if Old_Requires_Transient_Scope (Id) =\n-           New_Requires_Transient_Scope (Id)\n-         then\n-            raise Program_Error;\n-         end if;\n-      end if;\n-   end Results_Differ;\n-\n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n       Old_Result : constant Boolean := Old_Requires_Transient_Scope (Id);\n \n@@ -18904,342 +19220,37 @@ package body Sem_Util is\n          end if;\n \n          if New_Result /= Old_Result then\n-            Results_Differ (Id);\n+            Results_Differ (Id, Old_Result, New_Result);\n          end if;\n \n          return New_Result;\n       end;\n    end Requires_Transient_Scope;\n \n-   ----------------------------------\n-   -- Old_Requires_Transient_Scope --\n-   ----------------------------------\n-\n-   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n-      Typ : constant Entity_Id := Underlying_Type (Id);\n+   --------------------\n+   -- Results_Differ --\n+   --------------------\n \n+   procedure Results_Differ\n+     (Id      : Entity_Id;\n+      Old_Val : Boolean;\n+      New_Val : Boolean)\n+   is\n    begin\n-      --  This is a private type which is not completed yet. This can only\n-      --  happen in a default expression (of a formal parameter or of a\n-      --  record component). Do not expand transient scope in this case.\n-\n-      if No (Typ) then\n-         return False;\n-\n-      --  Do not expand transient scope for non-existent procedure return\n-\n-      elsif Typ = Standard_Void_Type then\n-         return False;\n-\n-      --  Elementary types do not require a transient scope\n-\n-      elsif Is_Elementary_Type (Typ) then\n-         return False;\n-\n-      --  Generally, indefinite subtypes require a transient scope, since the\n-      --  back end cannot generate temporaries, since this is not a valid type\n-      --  for declaring an object. It might be possible to relax this in the\n-      --  future, e.g. by declaring the maximum possible space for the type.\n-\n-      elsif not Is_Definite_Subtype (Typ) then\n-         return True;\n-\n-      --  Functions returning tagged types may dispatch on result so their\n-      --  returned value is allocated on the secondary stack. Controlled\n-      --  type temporaries need finalization.\n-\n-      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n-         return True;\n-\n-      --  Record type\n-\n-      elsif Is_Record_Type (Typ) then\n-         declare\n-            Comp : Entity_Id;\n-\n-         begin\n-            Comp := First_Entity (Typ);\n-            while Present (Comp) loop\n-               if Ekind (Comp) = E_Component then\n-\n-                  --  ???It's not clear we need a full recursive call to\n-                  --  Old_Requires_Transient_Scope here. Note that the\n-                  --  following can't happen.\n-\n-                  pragma Assert (Is_Definite_Subtype (Etype (Comp)));\n-                  pragma Assert (not Has_Controlled_Component (Etype (Comp)));\n-\n-                  if Old_Requires_Transient_Scope (Etype (Comp)) then\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next_Entity (Comp);\n-            end loop;\n-         end;\n-\n-         return False;\n-\n-      --  String literal types never require transient scope\n-\n-      elsif Ekind (Typ) = E_String_Literal_Subtype then\n-         return False;\n-\n-      --  Array type. Note that we already know that this is a constrained\n-      --  array, since unconstrained arrays will fail the indefinite test.\n-\n-      elsif Is_Array_Type (Typ) then\n-\n-         --  If component type requires a transient scope, the array does too\n-\n-         if Old_Requires_Transient_Scope (Component_Type (Typ)) then\n-            return True;\n-\n-         --  Otherwise, we only need a transient scope if the size depends on\n-         --  the value of one or more discriminants.\n-\n-         else\n-            return Size_Depends_On_Discriminant (Typ);\n-         end if;\n-\n-      --  All other cases do not require a transient scope\n-\n-      else\n-         pragma Assert (Is_Protected_Type (Typ) or else Is_Task_Type (Typ));\n-         return False;\n-      end if;\n-   end Old_Requires_Transient_Scope;\n-\n-   ----------------------------------\n-   -- New_Requires_Transient_Scope --\n-   ----------------------------------\n-\n-   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n-\n-      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n-      --  This is called for untagged records and protected types, with\n-      --  nondefaulted discriminants. Returns True if the size of function\n-      --  results is known at the call site, False otherwise. Returns False\n-      --  if there is a variant part that depends on the discriminants of\n-      --  this type, or if there is an array constrained by the discriminants\n-      --  of this type. ???Currently, this is overly conservative (the array\n-      --  could be nested inside some other record that is constrained by\n-      --  nondiscriminants). That is, the recursive calls are too conservative.\n-\n-      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n-      --  Returns True if Typ is a nonlimited record with defaulted\n-      --  discriminants whose max size makes it unsuitable for allocating on\n-      --  the primary stack.\n-\n-      ------------------------------\n-      -- Caller_Known_Size_Record --\n-      ------------------------------\n-\n-      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n-         pragma Assert (Typ = Underlying_Type (Typ));\n-\n-      begin\n-         if Has_Variant_Part (Typ) and then not Is_Definite_Subtype (Typ) then\n-            return False;\n-         end if;\n-\n-         declare\n-            Comp : Entity_Id;\n-\n-         begin\n-            Comp := First_Entity (Typ);\n-            while Present (Comp) loop\n-\n-               --  Only look at E_Component entities. No need to look at\n-               --  E_Discriminant entities, and we must ignore internal\n-               --  subtypes generated for constrained components.\n-\n-               if Ekind (Comp) = E_Component then\n-                  declare\n-                     Comp_Type : constant Entity_Id :=\n-                                   Underlying_Type (Etype (Comp));\n-\n-                  begin\n-                     if Is_Record_Type (Comp_Type)\n-                           or else\n-                        Is_Protected_Type (Comp_Type)\n-                     then\n-                        if not Caller_Known_Size_Record (Comp_Type) then\n-                           return False;\n-                        end if;\n-\n-                     elsif Is_Array_Type (Comp_Type) then\n-                        if Size_Depends_On_Discriminant (Comp_Type) then\n-                           return False;\n-                        end if;\n-                     end if;\n-                  end;\n-               end if;\n-\n-               Next_Entity (Comp);\n-            end loop;\n-         end;\n-\n-         return True;\n-      end Caller_Known_Size_Record;\n-\n-      ------------------------------\n-      -- Large_Max_Size_Mutable --\n-      ------------------------------\n-\n-      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n-         pragma Assert (Typ = Underlying_Type (Typ));\n-\n-         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n-         --  Returns true if the discrete type T has a large range\n-\n-         ----------------------------\n-         -- Is_Large_Discrete_Type --\n-         ----------------------------\n-\n-         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n-            Threshold : constant Int := 16;\n-            --  Arbitrary threshold above which we consider it \"large\". We want\n-            --  a fairly large threshold, because these large types really\n-            --  shouldn't have default discriminants in the first place, in\n-            --  most cases.\n-\n-         begin\n-            return UI_To_Int (RM_Size (T)) > Threshold;\n-         end Is_Large_Discrete_Type;\n-\n-      begin\n-         if Is_Record_Type (Typ)\n-           and then not Is_Limited_View (Typ)\n-           and then Has_Defaulted_Discriminants (Typ)\n-         then\n-            --  Loop through the components, looking for an array whose upper\n-            --  bound(s) depends on discriminants, where both the subtype of\n-            --  the discriminant and the index subtype are too large.\n-\n-            declare\n-               Comp : Entity_Id;\n-\n-            begin\n-               Comp := First_Entity (Typ);\n-               while Present (Comp) loop\n-                  if Ekind (Comp) = E_Component then\n-                     declare\n-                        Comp_Type : constant Entity_Id :=\n-                                      Underlying_Type (Etype (Comp));\n-                        Indx : Node_Id;\n-                        Ityp : Entity_Id;\n-                        Hi   : Node_Id;\n-\n-                     begin\n-                        if Is_Array_Type (Comp_Type) then\n-                           Indx := First_Index (Comp_Type);\n-\n-                           while Present (Indx) loop\n-                              Ityp := Etype (Indx);\n-                              Hi := Type_High_Bound (Ityp);\n-\n-                              if Nkind (Hi) = N_Identifier\n-                                and then Ekind (Entity (Hi)) = E_Discriminant\n-                                and then Is_Large_Discrete_Type (Ityp)\n-                                and then Is_Large_Discrete_Type\n-                                           (Etype (Entity (Hi)))\n-                              then\n-                                 return True;\n-                              end if;\n-\n-                              Next_Index (Indx);\n-                           end loop;\n-                        end if;\n-                     end;\n-                  end if;\n+      if False then -- False to disable; True for debugging\n+         Treepr.Print_Tree_Node (Id);\n \n-                  Next_Entity (Comp);\n-               end loop;\n-            end;\n+         if Old_Val = New_Val then\n+            raise Program_Error;\n          end if;\n-\n-         return False;\n-      end Large_Max_Size_Mutable;\n-\n-      --  Local declarations\n-\n-      Typ : constant Entity_Id := Underlying_Type (Id);\n-\n-   --  Start of processing for New_Requires_Transient_Scope\n-\n-   begin\n-      --  This is a private type which is not completed yet. This can only\n-      --  happen in a default expression (of a formal parameter or of a\n-      --  record component). Do not expand transient scope in this case.\n-\n-      if No (Typ) then\n-         return False;\n-\n-      --  Do not expand transient scope for non-existent procedure return or\n-      --  string literal types.\n-\n-      elsif Typ = Standard_Void_Type\n-        or else Ekind (Typ) = E_String_Literal_Subtype\n-      then\n-         return False;\n-\n-      --  If Typ is a generic formal incomplete type, then we want to look at\n-      --  the actual type.\n-\n-      elsif Ekind (Typ) = E_Record_Subtype\n-        and then Present (Cloned_Subtype (Typ))\n-      then\n-         return New_Requires_Transient_Scope (Cloned_Subtype (Typ));\n-\n-      --  Functions returning specific tagged types may dispatch on result, so\n-      --  their returned value is allocated on the secondary stack, even in the\n-      --  definite case. We must treat nondispatching functions the same way,\n-      --  because access-to-function types can point at both, so the calling\n-      --  conventions must be compatible. Is_Tagged_Type includes controlled\n-      --  types and class-wide types. Controlled type temporaries need\n-      --  finalization.\n-\n-      --  ???It's not clear why we need to return noncontrolled types with\n-      --  controlled components on the secondary stack.\n-\n-      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n-         return True;\n-\n-      --  Untagged definite subtypes are known size. This includes all\n-      --  elementary [sub]types. Tasks are known size even if they have\n-      --  discriminants. So we return False here, with one exception:\n-      --  For a type like:\n-      --    type T (Last : Natural := 0) is\n-      --       X : String (1 .. Last);\n-      --    end record;\n-      --  we return True. That's because for \"P(F(...));\", where F returns T,\n-      --  we don't know the size of the result at the call site, so if we\n-      --  allocated it on the primary stack, we would have to allocate the\n-      --  maximum size, which is way too big.\n-\n-      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n-         return Large_Max_Size_Mutable (Typ);\n-\n-      --  Indefinite (discriminated) untagged record or protected type\n-\n-      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n-         return not Caller_Known_Size_Record (Typ);\n-\n-      --  Unconstrained array\n-\n-      else\n-         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n-         return True;\n       end if;\n-   end New_Requires_Transient_Scope;\n+   end Results_Differ;\n \n    --------------------------\n    -- Reset_Analyzed_Flags --\n    --------------------------\n \n    procedure Reset_Analyzed_Flags (N : Node_Id) is\n-\n       function Clear_Analyzed (N : Node_Id) return Traverse_Result;\n       --  Function used to reset Analyzed flags in tree. Note that we do\n       --  not reset Analyzed flags in entities, since there is no need to"}]}