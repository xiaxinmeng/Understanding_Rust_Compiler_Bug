{"sha": "599eabdb42d10c1404f13d21137c85946d7fbd92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5ZWFiZGI0MmQxMGMxNDA0ZjEzZDIxMTM3Yzg1OTQ2ZDdmYmQ5Mg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-09-08T15:28:56Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-09-08T15:28:56Z"}, "message": "Makefile.in (tree-loop-linear.o): Added.\n\n2004-09-08  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* Makefile.in (tree-loop-linear.o): Added.\n\t(OBJS-common): Add tree-loop-linear.o\n\t* common.opt: New flag, ftree-loop-linear.\n\t* timevar.def: New timevar, TV_TREE_LOOP_LINEAR.\n\t* tree-flow.h: Add prototype for linear_transform_loops.\n\t* tree-optimize.c: Add linear transform after vectorization.\n\t* tree-pass.h: Add struct pass_linear_transform.\n\t* tree-ssa-loop.c: Add pass_linear_transform.\n\t* tree-loop-linear.c: New file.\n\t* lambda-code.c: gcc_assertify.\n\t(gcc_loop_to_lambda_loop): Handle all exit tests.\n\tHandle case where we have (invariant >= induction var).\n\t(find_induction_var_from_exit_cond): Ditto.\n\nFrom-SVN: r87190", "tree": {"sha": "23362687866b29177d4928c3a31cb6b30a4946d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23362687866b29177d4928c3a31cb6b30a4946d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599eabdb42d10c1404f13d21137c85946d7fbd92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599eabdb42d10c1404f13d21137c85946d7fbd92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599eabdb42d10c1404f13d21137c85946d7fbd92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599eabdb42d10c1404f13d21137c85946d7fbd92/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e45f57bf38ac4ca36f085a27729ebc25856333e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e45f57bf38ac4ca36f085a27729ebc25856333e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e45f57bf38ac4ca36f085a27729ebc25856333e"}], "stats": {"total": 460, "additions": 413, "deletions": 47}, "files": [{"sha": "7ef63e067575b8d517be6bfc082c2612e3320a96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -1,3 +1,19 @@\n+2004-09-08  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Makefile.in (tree-loop-linear.o): Added.\n+\t(OBJS-common): Add tree-loop-linear.o\n+\t* common.opt: New flag, ftree-loop-linear.\n+\t* timevar.def: New timevar, TV_TREE_LOOP_LINEAR.\n+\t* tree-flow.h: Add prototype for linear_transform_loops.\n+\t* tree-optimize.c: Add linear transform after vectorization.\n+\t* tree-pass.h: Add struct pass_linear_transform.\n+\t* tree-ssa-loop.c: Add pass_linear_transform.\n+\t* tree-loop-linear.c: New file.\n+\t* lambda-code.c: gcc_assertify.\n+\t(gcc_loop_to_lambda_loop): Handle all exit tests.\n+\tHandle case where we have (invariant >= induction var).\n+\t(find_induction_var_from_exit_cond): Ditto.\n+\t\n 2004-09-08  Jie Zhang  <zhangjie@magima.com.cn>\n \n \t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type"}, {"sha": "e76aa11c2f7863eb6b3e59df5b9891d2ff5e4a7e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -927,7 +927,7 @@ OBJS-common = \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n- lambda-trans.o\tlambda-code.o\n+ lambda-trans.o\tlambda-code.o tree-loop-linear.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1774,6 +1774,10 @@ tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n    errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h tree-pass.h \\\n    tree-vectorizer.h tree-data-ref.h $(SCEV_H)\n+tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h tree-pass.h \\\n+   $(TREE_DATA_REF_H) $(SCEV_H)\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\"}, {"sha": "77862f07e34e36d9006893f79d48e6bb4f5cc3ad", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -864,6 +864,10 @@ ftree-loop-im\n Common Report Var(flag_tree_loop_im) Init(1)\n Enable loop invariant motion on trees\n \n+ftree-loop-linear\n+Common Report Var(flag_tree_loop_linear)\n+Enable linear loop transforms on trees\n+\n ftree-loop-ivcanon\n Common Report Var(flag_tree_loop_ivcanon)\n Create canonical induction variables in loops"}, {"sha": "f1fdc30652657dcc3df8f0c88f451ced04b1823f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -316,7 +316,7 @@ Objective-C and Objective-C++ Dialects}.\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n--ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n+-ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol\n --param @var{name}=@var{value}\n@@ -4610,6 +4610,10 @@ usually increases code size.\n Perform loop optimizations on trees.  This flag is enabled by default at -O\n and higher.\n \n+@item -ftree-loop-linear\n+Perform linear loop transformations on tree. This flag can improve cache \n+performance and allow further loop optimizations to take place.\n+\n @item -ftree-lim\n Perform loop invariant motion on trees.  This pass moves only invartiants that\n would be hard to handle on rtl level (function calls, operations that expand to"}, {"sha": "6ae4cb2228e5978a5fbe44174d1d110d7516b2a1", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -169,8 +169,7 @@ lambda_body_vector_compute_new (lambda_trans_matrix transform,\n   int depth;\n \n   /* Make sure the matrix is square.  */\n-  if (LTM_ROWSIZE (transform) != LTM_COLSIZE (transform))\n-    abort ();\n+  gcc_assert (LTM_ROWSIZE (transform) == LTM_COLSIZE (transform));\n \n   depth = LTM_ROWSIZE (transform);\n \n@@ -297,8 +296,7 @@ print_lambda_loop (FILE * outfile, lambda_loop loop, int depth,\n   int step;\n   lambda_linear_expression expr;\n \n-  if (!loop)\n-    abort ();\n+  gcc_assert (loop);\n \n   expr = LL_LINEAR_OFFSET (loop);\n   step = LL_STEP (loop);\n@@ -393,8 +391,7 @@ lambda_lattice_compute_base (lambda_loopnest nest)\n   for (i = 0; i < depth; i++)\n     {\n       loop = LN_LOOPS (nest)[i];\n-      if (!loop)\n-\tabort ();\n+      gcc_assert (loop);\n       step = LL_STEP (loop);\n       /* If we have a step of 1, then the base is one, and the\n          origin and invariant coefficients are 0.  */\n@@ -412,9 +409,8 @@ lambda_lattice_compute_base (lambda_loopnest nest)\n \t  /* Otherwise, we need the lower bound expression (which must\n \t     be an affine function)  to determine the base.  */\n \t  expression = LL_LOWER_BOUND (loop);\n-\t  if (!expression\n-\t      || LLE_NEXT (expression) || LLE_DENOMINATOR (expression) != 1)\n-\t    abort ();\n+\t  gcc_assert (expression && LLE_NEXT (expression) \n+\t\t      && LLE_DENOMINATOR (expression) == 1);\n \n \t  /* The lower triangular portion of the base is going to be the\n \t     coefficient times the step */\n@@ -556,8 +552,8 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n \n \t  size++;\n \t  /* Need to increase matrix sizes above.  */\n-\t  if (size > 127)\n-\t    abort ();\n+\t  gcc_assert (size <= 127);\n+\t  \n \t}\n \n       /* Then do the exact same thing for the upper bounds.  */\n@@ -585,8 +581,8 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n \t  A[size][i] = LLE_DENOMINATOR (expression);\n \t  size++;\n \t  /* Need to increase matrix sizes above.  */\n-\t  if (size > 127)\n-\t    abort ();\n+\t  gcc_assert (size <= 127);\n+\n \t}\n     }\n \n@@ -1205,7 +1201,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   tree test;\n   int stepint;\n   int extra = 0;\n-\n+  tree uboundvar;\n   use_optype uses;\n \n   /* Find out induction var and set the pointer so that the caller can\n@@ -1225,19 +1221,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n     }\n \n   test = TREE_OPERAND (exit_cond, 0);\n-  if (TREE_CODE (test) != LE_EXPR\n-      && TREE_CODE (test) != LT_EXPR && TREE_CODE (test) != NE_EXPR)\n-    {\n \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file,\n-\t\t   \"Unable to convert loop: Loop exit test uses unhandled test condition:\");\n-\t  print_generic_stmt (dump_file, test, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      return NULL;\n-    }\n   if (SSA_NAME_DEF_STMT (inductionvar) == NULL_TREE)\n     {\n \n@@ -1349,25 +1333,39 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \n       return NULL;\n     }\n-  if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME)\n-    if (invariant_in_loop (loop, TREE_OPERAND (test, 1)))\n-      VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 1));\n+  /* One part of the test may be a loop invariant tree.  */\n+  if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME\n+      && invariant_in_loop (loop, TREE_OPERAND (test, 1)))\n+    VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 1));\n+  else if (TREE_CODE (TREE_OPERAND (test, 0)) == SSA_NAME\n+\t   && invariant_in_loop (loop, TREE_OPERAND (test, 0)))\n+    VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 0));\n+  \n+  /* The non-induction variable part of the test is the upper bound variable.\n+   */\n+  if (TREE_OPERAND (test, 0) == inductionvar)\n+    uboundvar = TREE_OPERAND (test, 1);\n+  else\n+    uboundvar = TREE_OPERAND (test, 0);\n+    \n \n   /* We only size the vectors assuming we have, at max, 2 times as many\n      invariants as we do loops (one for each bound).\n      This is just an arbitrary number, but it has to be matched against the\n      code below.  */\n-  if (VEC_length (tree, *invariants) > (unsigned int) (2 * depth))\n-    abort ();\n+  gcc_assert (VEC_length (tree, *invariants) <= (unsigned int) (2 * depth));\n+  \n \n   /* We might have some leftover.  */\n   if (TREE_CODE (test) == LT_EXPR)\n     extra = -1 * stepint;\n   else if (TREE_CODE (test) == NE_EXPR)\n     extra = -1 * stepint;\n+  else if (TREE_CODE (test) == GT_EXPR)\n+    extra = -1 * stepint;\n \n   ubound = gcc_tree_to_linear_expression (depth,\n-\t\t\t\t\t  TREE_OPERAND (test, 1),\n+\t\t\t\t\t  uboundvar,\n \t\t\t\t\t  outerinductionvars,\n \t\t\t\t\t  *invariants, extra);\n   if (!ubound)\n@@ -1393,6 +1391,7 @@ static tree\n find_induction_var_from_exit_cond (struct loop *loop)\n {\n   tree expr = get_loop_exit_condition (loop);\n+  tree ivarop;\n   tree test;\n   if (expr == NULL_TREE)\n     return NULL_TREE;\n@@ -1401,9 +1400,28 @@ find_induction_var_from_exit_cond (struct loop *loop)\n   test = TREE_OPERAND (expr, 0);\n   if (TREE_CODE_CLASS (TREE_CODE (test)) != '<')\n     return NULL_TREE;\n-  if (TREE_CODE (TREE_OPERAND (test, 0)) != SSA_NAME)\n+ /* This is a guess.  We say that for a <,!=,<= b, a is the induction\n+     variable.\n+     For >, >=, we guess b is the induction variable.\n+     If we are wrong, it'll fail the rest of the induction variable tests, and\n+     everything will be fine anyway.  */\n+  switch (TREE_CODE (test))\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case NE_EXPR:\n+      ivarop = TREE_OPERAND (test, 0);\n+      break;\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      ivarop = TREE_OPERAND (test, 1);\n+      break;\n+    default:\n+      gcc_unreachable();\n+    }\n+  if (TREE_CODE (ivarop) != SSA_NAME)\n     return NULL_TREE;\n-  return TREE_OPERAND (test, 0);\n+  return ivarop;\n }\n \n DEF_VEC_GC_P(lambda_loop);\n@@ -1693,7 +1711,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t\t\t name, build_int_cst (integer_type_node,\n \t\t\t\t\t\t      LLE_DENOMINATOR (lle))));\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable();\n \n \t  /* name = {ceil, floor}(name/denominator) */\n \t  name = make_ssa_name (resvar, stmt);\n@@ -1706,9 +1724,8 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \n   /* Again, out of laziness, we don't handle this case yet.  It's not\n      hard, it just hasn't occurred.  */\n-  if (VEC_length (tree, results) > 2)\n-    abort ();\n-\n+  gcc_assert (VEC_length (tree, results) <= 2);\n+  \n   /* We may need to wrap the results in a MAX_EXPR or MIN_EXPR.  */\n   if (VEC_length (tree, results) > 1)\n     {\n@@ -1788,10 +1805,9 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n          cases for now.  */\n       offset = LL_LINEAR_OFFSET (newloop);\n \n-      if (LLE_DENOMINATOR (offset) != 1\n-\t  || !lambda_vector_zerop (LLE_COEFFICIENTS (offset), depth))\n-\tabort ();\n-\n+      gcc_assert (LLE_DENOMINATOR (offset) == 1 &&\n+\t\t  lambda_vector_zerop (LLE_COEFFICIENTS (offset), depth));\n+      \n       /* Now build the  new lower bounds, and insert the statements\n          necessary to generate it on the loop preheader.  */\n       newlowerbound = lle_to_gcc_expression (LL_LOWER_BOUND (newloop),\n@@ -1929,8 +1945,8 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n   struct data_dependence_relation *ddr;\n \n #if defined ENABLE_CHECKING\n-  if (LTM_COLSIZE (trans) != nb_loops || LTM_ROWSIZE (trans) != nb_loops)\n-    abort ();\n+  gcc_assert (LTM_COLSIZE (trans) == nb_loops \n+\t      && LTM_ROWSIZE (trans) == nb_loops);\n #endif\n \n   /* When there is an unknown relation in the dependence_relations, we"}, {"sha": "87108b803d8925c14a6a11ca982b9dafc8753e6d", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -86,6 +86,7 @@ DEFTIMEVAR (TV_LIM                   , \"loop invariant motion\")\n DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv creation\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree loop vectorization\")\n+DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear transforms\")\n DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")\n DEFTIMEVAR (TV_TREE_CH\t\t     , \"tree copy headers\")\n DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , \"tree SSA to normal\")"}, {"sha": "837aaf9420a30cacc151766256d715f05299a053", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -719,6 +719,9 @@ void insert_edge_copies (tree stmt, basic_block bb);\n extern void build_ssa_operands (tree, stmt_ann_t, stmt_operands_p, \n \t\t\t\tstmt_operands_p);\n \n+/* In tree-loop-linear.c  */\n+extern void linear_transform_loops (struct loops *);\n+\n /* In gimplify.c  */\n \n tree force_gimple_operand (tree, tree *, bool, tree);"}, {"sha": "856867e9b668a10dc6d6c9a35c87dacec426bb42", "filename": "gcc/tree-loop-linear.c", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -0,0 +1,282 @@\n+/* Linear Loop transforms\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dberlin@dberlin.org>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"varray.h\"\n+#include \"lambda.h\"\n+\n+/* Linear loop transforms include any composition of interchange,\n+   scaling, skewing, and reversal.  They are used to change the\n+   iteration order of loop nests in order to optimize data locality of\n+   traversals, or remove dependences that prevent\n+   parallelization/vectorization/etc.  \n+\n+   TODO: Determine reuse vectors/matrix and use it to determine optimal\n+   transform matrix for locality purposes.\n+   TODO: Completion of partial transforms.  */\n+\n+/* Gather statistics for loop interchange.  Initializes SUM the sum of\n+   all the data dependence distances carried by loop LOOP_NUMBER.\n+   NB_DEPS_NOT_CARRIED_BY_LOOP is initialized to the number of\n+   dependence relations for which the loop LOOP_NUMBER is not carrying\n+   any dependence.  */\n+\n+static void\n+gather_interchange_stats (varray_type dependence_relations, \n+\t\t\t  unsigned int loop_number, \n+\t\t\t  unsigned int *sum, \n+\t\t\t  unsigned int *nb_deps_not_carried_by_loop)\n+{\n+  unsigned int i;\n+\n+  *sum = 0;\n+  *nb_deps_not_carried_by_loop = 0;\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+    {\n+      int dist;\n+      struct data_dependence_relation *ddr = \n+\t(struct data_dependence_relation *) \n+\tVARRAY_GENERIC_PTR (dependence_relations, i);\n+\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\t{\n+\t  /* Some constants will need tweaking, but not something that should\n+\t     be user-accessible.  Thus, no --param.  */\n+\t  *sum += 100;\n+\t  continue;\n+\t}\n+\n+      /* When we know that there is no dependence, we know that there\n+\t is no reuse of the data.  */\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\t{\n+\t  /* Ditto on the no --param here */\n+\t  *sum += 1000;\n+\t  continue;\n+\t}\n+\n+      dist = DDR_DIST_VECT (ddr)[loop_number];\n+      if (dist == 0)\n+\t*nb_deps_not_carried_by_loop++;\n+      else if (dist < 0)\n+\t*sum += -dist;\n+      else\n+\t*sum += dist;\n+    }\n+}\n+\n+/* Apply to TRANS any loop interchange that minimize inner loop steps.\n+   DEPTH is the depth of the loop nest, and DEPENDENCE_RELATIONS is an array\n+   of dependence relations.\n+   Returns the new transform matrix.  The smaller the reuse vector\n+   distances in the inner loops, the fewer the cache misses.  */\n+\n+static lambda_trans_matrix\n+try_interchange_loops (lambda_trans_matrix trans, \n+\t\t       unsigned int depth,\t\t       \n+\t\t       varray_type dependence_relations)\n+{\n+  unsigned int loop_i, loop_j;\n+  unsigned int steps_i, steps_j;\n+  unsigned int nb_deps_not_carried_by_i, nb_deps_not_carried_by_j;\n+  struct data_dependence_relation *ddr;\n+\n+  /* When there is an unknown relation in the dependence_relations, we\n+     know that it is no worth looking at this loop nest: give up.  */\n+  ddr = (struct data_dependence_relation *) \n+    VARRAY_GENERIC_PTR (dependence_relations, 0);\n+  if (ddr == NULL || DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+    return trans;\n+  \n+  /* LOOP_I is always the outer loop.  */\n+  for (loop_j = 1; loop_j < depth; loop_j++)\n+    for (loop_i = 0; loop_i < loop_j; loop_i++)\n+      {\n+\tgather_interchange_stats (dependence_relations, loop_i, &steps_i, \n+\t\t\t\t  &nb_deps_not_carried_by_i);\n+\tgather_interchange_stats (dependence_relations, loop_j, &steps_j, \n+\t\t\t\t  &nb_deps_not_carried_by_j);\n+\t\n+\t/* Heuristics for loop interchange profitability:\n+\t   1. Inner loops should have smallest steps.\n+\t   2. Inner loops should contain more dependence relations not\n+\t   carried by the loop.\n+\t*/\n+\tif (steps_i < steps_j \n+\t    || nb_deps_not_carried_by_i > nb_deps_not_carried_by_j)\n+\t  {\n+\t    lambda_matrix_row_exchange (LTM_MATRIX (trans), loop_i, loop_j);\n+\t\n+\t    /* Validate the resulting matrix.  When the transformation\n+\t       is not valid, reverse to the previous matrix.  \n+\t       \n+\t       FIXME: In this case of transformation it could be\n+\t       faster to verify the validity of the interchange\n+\t       without applying the transform to the matrix.  But for\n+\t       the moment do it cleanly: this is just a prototype.  */\n+\t    if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n+\t      lambda_matrix_row_exchange (LTM_MATRIX (trans), loop_i, loop_j);\n+\t  }\n+      }\n+  \n+  return trans;\n+}\n+\n+/* Perform a set of linear transforms on LOOPS.  */\n+\n+void\n+linear_transform_loops (struct loops *loops)\n+{\n+  unsigned int i;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      unsigned int depth = 0;\n+      varray_type datarefs;\n+      varray_type dependence_relations;\n+      struct loop *loop_nest = loops->parray[i];\n+      struct loop *temp;\n+      VEC (tree) *oldivs;\n+      VEC (tree) *invariants;\n+      lambda_loopnest before, after;\n+      lambda_trans_matrix trans;\n+      bool problem = false;\n+      /* If it's not a loop nest, we don't want it.\n+         We also don't handle sibling loops properly, \n+         which are loops of the following form:\n+         for (i = 0; i < 50; i++)\n+           {\n+             for (j = 0; j < 50; j++)\n+               {\n+\t        ...\n+               }\n+           for (j = 0; j < 50; j++)\n+               {\n+                ...\n+               }\n+           } */\n+      if (!loop_nest->inner)\n+\tcontinue;\n+      for (temp = loop_nest; temp; temp = temp->inner)\n+\t{\n+\t  flow_loop_scan (temp, LOOP_ALL);\n+\t  /* If we have a sibling loop or multiple exit edges, jump ship.  */\n+\t  if (temp->next || temp->num_exits != 1)\n+\t    {\n+\t      problem = true;\n+\t      break;\n+\t    }\n+\t  depth ++;\n+\t}\n+      if (problem)\n+\tcontinue;\n+\n+      /* Analyze data references and dependence relations using scev.  */      \n+ \n+      VARRAY_GENERIC_PTR_INIT (datarefs, 10, \"datarefs\");\n+      VARRAY_GENERIC_PTR_INIT (dependence_relations, 10,\n+\t\t\t       \"dependence_relations\");\n+      \n+  \n+      compute_data_dependences_for_loop (depth, loop_nest,\n+\t\t\t\t\t &datarefs, &dependence_relations);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  unsigned int j;\n+\t  for (j = 0; j < VARRAY_ACTIVE_SIZE (dependence_relations); j++)\n+\t    {\n+\t      struct data_dependence_relation *ddr = \n+\t\t(struct data_dependence_relation *) \n+\t\tVARRAY_GENERIC_PTR (dependence_relations, j);\n+\n+\t      if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+\t\t{\n+\t\t  fprintf (dump_file, \"DISTANCE_V (\");\n+\t\t  print_lambda_vector (dump_file, DDR_DIST_VECT (ddr), \n+\t\t\t\t       loops->num);\n+\t\t  fprintf (dump_file, \")\\n\");\n+\t\t  fprintf (dump_file, \"DIRECTION_V (\");\n+\t\t  print_lambda_vector (dump_file, DDR_DIR_VECT (ddr), \n+\t\t\t\t       loops->num);\n+\t\t  fprintf (dump_file, \")\\n\");\n+\t\t}\n+\t    }\n+\t  fprintf (dump_file, \"\\n\\n\");\n+\t}\n+      /* Build the transformation matrix.  */\n+      trans = lambda_trans_matrix_new (depth, depth);\n+      lambda_matrix_id (LTM_MATRIX (trans), depth);\n+      trans = try_interchange_loops (trans, depth, dependence_relations);\n+\n+      /* Check whether the transformation is legal.  */\n+      if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Can't transform loop, transform is illegal:\\n\");\n+\t  continue;\n+\t}\n+      before = gcc_loopnest_to_lambda_loopnest (loop_nest, &oldivs, \n+\t\t\t\t\t\t&invariants);\n+      if (!before)\n+\tcontinue;\n+            \n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Before:\\n\");\n+\t  print_lambda_loopnest (dump_file, before, 'i');\n+\t}\n+  \n+      after = lambda_loopnest_transform (before, trans);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"After:\\n\");\n+\t  print_lambda_loopnest (dump_file, after, 'u');\n+\t}\n+      lambda_loopnest_to_gcc_loopnest (loop_nest, oldivs, invariants,\n+\t\t\t\t       after, trans);\n+      oldivs = NULL;\n+      invariants = NULL;\n+      free_dependence_relations (dependence_relations);\n+      free_data_refs (datarefs);\n+    }\n+}"}, {"sha": "5ad189139c9ed97e22b92454477b213af4efa8d8", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -397,6 +397,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);\n+  NEXT_PASS (pass_linear_transform);\n   NEXT_PASS (pass_complete_unroll);\n   NEXT_PASS (pass_iv_optimize);\n   NEXT_PASS (pass_loop_done);"}, {"sha": "a7445cddda628f9874961993de07f38c8820213a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -160,6 +160,6 @@ extern struct tree_opt_pass pass_rename_ssa_copies;\n extern struct tree_opt_pass pass_expand;\n extern struct tree_opt_pass pass_rest_of_compilation;\n extern struct tree_opt_pass pass_fre;\n-\n+extern struct tree_opt_pass pass_linear_transform;\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "2f87d87bacd5725c92edd77a38572ca11165aa4c", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599eabdb42d10c1404f13d21137c85946d7fbd92/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=599eabdb42d10c1404f13d21137c85946d7fbd92", "patch": "@@ -194,6 +194,41 @@ struct tree_opt_pass pass_vectorize =\n   0\t\t\t\t\t/* letter */\n };\n \n+\n+/* Loop nest optimizations.  */\n+\n+static void\n+tree_linear_transform (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  linear_transform_loops (current_loops);\n+}\n+\n+static bool\n+gate_tree_linear_transform (void)\n+{\n+  return flag_tree_loop_linear != 0;\n+}\n+\n+struct tree_opt_pass pass_linear_transform =\n+{\n+  \"ltrans\",\t\t\t\t/* name */\n+  gate_tree_linear_transform,\t\t/* gate */\n+  tree_linear_transform,       \t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_LINEAR_TRANSFORM,  \t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,                \t/* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\t\n+};\n+\n /* Canonical induction variable creation pass.  */\n \n static void"}]}