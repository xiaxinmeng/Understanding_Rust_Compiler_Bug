{"sha": "85bc75f87b45903d46555d0e1c013242de5c7c48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViYzc1Zjg3YjQ1OTAzZDQ2NTU1ZDBlMWMwMTMyNDJkZTVjN2M0OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-09-13T14:15:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-09-13T14:15:41Z"}, "message": "re PR tree-optimization/87263 (ICE on valid code at -O1: verify_ssa failed)\n\n2018-09-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/87263\n\t* tree-ssa-sccvn.c (visit_phi): Revert some earlier changes.\n\t(struct unwind_state): Add max_rpo field.\n\t(do_rpo_vn): Allow up-to-date loop state to be used when not iterating.\n\tCompute max_rpo, the max RPO number a block can be backwards reached\n\tfrom.  Re-write non-iterating mode to a RPO ordered worklist approach,\n\tseparating it from the iterating mode.\n\n\t* gcc.dg/torture/pr87263.c: New testcase.\n\t* gcc.dg/torture/ssa-fre-2.c: Likewise.\n\t* gcc.dg/torture/ssa-fre-3.c: Likewise.\n\t* gcc.dg/torture/ssa-fre-4.c: Likewise.\n\nFrom-SVN: r264273", "tree": {"sha": "a1bc2b4e51f781ccbbd40d033593d3e6d0561f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1bc2b4e51f781ccbbd40d033593d3e6d0561f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85bc75f87b45903d46555d0e1c013242de5c7c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bc75f87b45903d46555d0e1c013242de5c7c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85bc75f87b45903d46555d0e1c013242de5c7c48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bc75f87b45903d46555d0e1c013242de5c7c48/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08233f0d6eae9d780d787e8c61cbc051bfe6af43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08233f0d6eae9d780d787e8c61cbc051bfe6af43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08233f0d6eae9d780d787e8c61cbc051bfe6af43"}], "stats": {"total": 382, "additions": 266, "deletions": 116}, "files": [{"sha": "da616e4481786c267994b4f11a316b10328a36e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -1,3 +1,13 @@\n+2018-09-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87263\n+\t* tree-ssa-sccvn.c (visit_phi): Revert some earlier changes.\n+\t(struct unwind_state): Add max_rpo field.\n+\t(do_rpo_vn): Allow up-to-date loop state to be used when not iterating.\n+\tCompute max_rpo, the max RPO number a block can be backwards reached\n+\tfrom.  Re-write non-iterating mode to a RPO ordered worklist approach,\n+\tseparating it from the iterating mode.\n+\n 2018-09-13  Vlad Lazar  <vlad.lazar@arm.com>\n \n \t* haifa-sched.c (rank_for_schedule): Schedule by INSN_COST."}, {"sha": "f6b0e64133369a7dd796a63f6fcf928d5661fc95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -1,3 +1,11 @@\n+2018-09-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87263\n+\t* gcc.dg/torture/pr87263.c: New testcase.\n+\t* gcc.dg/torture/ssa-fre-2.c: Likewise.\n+\t* gcc.dg/torture/ssa-fre-3.c: Likewise.\n+\t* gcc.dg/torture/ssa-fre-4.c: Likewise.\n+\n 2018-09-13  Omar Sandoval  <osandov@osandov.com>\n \t    Tom de Vries  <tdevries@suse.de>\n "}, {"sha": "3d6a0d7d8922422e736b4a5aec127404588a0ae0", "filename": "gcc/testsuite/gcc.dg/torture/pr87263.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr87263.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr87263.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr87263.c?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+int a, b, c;\n+\n+int main ()\n+{ \n+  int g, *h[3] = {&g, &g, &g};\n+  if (h[2] == 0)\n+    ;\n+  else\n+    { \n+      int i[1];\n+      if (a)\n+\twhile (a)\n+\t  L:;\n+      else\n+\t{\n+\t  int k = b;\n+\t}\n+    }\n+  if ((b < c) > b)\n+    goto L;\n+  return 0;\n+}"}, {"sha": "5ce47d2158726d29973201006c7f1e76cfff8b7b", "filename": "gcc/testsuite/gcc.dg/torture/ssa-fre-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-2.c?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+\n+int x;\n+int main()\n+{\n+  int i = 0;\n+  x = 0;\n+  if (x)\n+    {\n+      for (; i < 10; ++i)\n+\t{\n+doit:\n+\t  x = i;\n+\t}\n+    }\n+  if (!x)\n+    goto doit;\n+  if (x != 9)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "2ec1c28375e5b591a201d142188325cdf2949b53", "filename": "gcc/testsuite/gcc.dg/torture/ssa-fre-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-3.c?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-additional-options \"-fdump-tree-fre1\" } */\n+\n+int x;\n+int main()\n+{\n+  x = 0;\n+  int z = x;\n+  int w = 1;\n+  for (int i = 0; i < 32; ++i)\n+    {\n+      if (z)\n+\tw = 2;\n+      else\n+\tw = 1;\n+      if (w == 2)\n+\t__builtin_abort ();\n+    }\n+  return w;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"fre1\" } } */"}, {"sha": "d09af7819a8b460d6e2e8866a8ad4be0a5e3e3a0", "filename": "gcc/testsuite/gcc.dg/torture/ssa-fre-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-fre-4.c?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-additional-options \"-fdump-tree-fre1\" } */\n+\n+int x;\n+int main()\n+{\n+  x = 0;\n+  if (x)\n+    {\n+      for (int i = 0; i < 10; ++i)\n+\tx = i;\n+    }\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 0;\" \"fre1\" } } */"}, {"sha": "1c95306fd821bb200c9cebd84eae1ec2f68f963d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 163, "deletions": 116, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bc75f87b45903d46555d0e1c013242de5c7c48/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=85bc75f87b45903d46555d0e1c013242de5c7c48", "patch": "@@ -4196,20 +4196,15 @@ visit_phi (gimple *phi, bool *inserted, bool backedges_varying_p)\n \t  }\n       }\n \n-  /* If the value we want to use is the backedge and that wasn't visited\n-     yet or if we should take it as VARYING but it has a non-VARYING\n-     value drop to VARYING.  This only happens when not iterating.\n-     If we value-number a virtual operand never value-number to the\n+  /* If we value-number a virtual operand never value-number to the\n      value from the backedge as that confuses the alias-walking code.\n      See gcc.dg/torture/pr87176.c.  If the value is the same on a\n      non-backedge everything is OK though.  */\n   if (backedge_val\n       && !seen_non_backedge\n       && TREE_CODE (backedge_val) == SSA_NAME\n       && sameval == backedge_val\n-      && (SSA_NAME_IS_VIRTUAL_OPERAND (backedge_val)\n-\t  || !SSA_VISITED (backedge_val)\n-\t  || SSA_VAL (backedge_val) != backedge_val))\n+      && SSA_NAME_IS_VIRTUAL_OPERAND (backedge_val))\n     /* Note this just drops to VARYING without inserting the PHI into\n        the hashes.  */\n     result = PHI_RESULT (phi);\n@@ -6224,6 +6219,9 @@ struct unwind_state\n   /* Whether to handle this as iteration point or whether to treat\n      incoming backedge PHI values as varying.  */\n   bool iterate;\n+  /* Maximum RPO index this block is reachable from.  */\n+  int max_rpo;\n+  /* Unwind state.  */\n   void *ob_top;\n   vn_reference_t ref_top;\n   vn_phi_t phi_top;\n@@ -6309,8 +6307,8 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n     }\n \n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS);\n-  int n = rev_post_order_and_mark_dfs_back_seme (fn, entry, exit_bbs,\n-\t\t\t\t\t\t iterate, rpo);\n+  int n = rev_post_order_and_mark_dfs_back_seme\n+    (fn, entry, exit_bbs, !loops_state_satisfies_p (LOOPS_NEED_FIXUP), rpo);\n   /* rev_post_order_and_mark_dfs_back_seme fills RPO in reverse order.  */\n   for (int i = 0; i < n / 2; ++i)\n     std::swap (rpo[i], rpo[n-i-1]);\n@@ -6380,6 +6378,7 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);\n       rpo_state[i].visited = 0;\n+      rpo_state[i].max_rpo = i;\n       bb->flags &= ~BB_EXECUTABLE;\n       bool has_backedges = false;\n       edge e;\n@@ -6389,15 +6388,18 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t  if (e->flags & EDGE_DFS_BACK)\n \t    has_backedges = true;\n \t  if (! iterate && (e->flags & EDGE_DFS_BACK))\n-\t    {\n-\t      e->flags |= EDGE_EXECUTABLE;\n-\t      /* ???  Strictly speaking we only need to unconditionally\n-\t\t process a block when it is in an irreducible region,\n-\t\t thus when it may be reachable via the backedge only.  */\n-\t      bb->flags |= BB_EXECUTABLE;\n-\t    }\n+\t    e->flags |= EDGE_EXECUTABLE;\n \t  else\n \t    e->flags &= ~EDGE_EXECUTABLE;\n+\t  if (e == entry)\n+\t    continue;\n+\t  if (bb_to_rpo[e->src->index] > i)\n+\t    rpo_state[i].max_rpo = MAX (rpo_state[i].max_rpo,\n+\t\t\t\t\tbb_to_rpo[e->src->index]);\n+\t  else\n+\t    rpo_state[i].max_rpo\n+\t      = MAX (rpo_state[i].max_rpo,\n+\t\t     rpo_state[bb_to_rpo[e->src->index]].max_rpo);\n \t}\n       rpo_state[i].iterate = iterate && has_backedges;\n     }\n@@ -6440,120 +6442,165 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t    }\n     }\n \n-  /* Go and process all blocks, iterating as necessary.  */\n-  int idx = 0;\n   uint64_t nblk = 0;\n-  do\n+  int idx = 0;\n+  if (iterate)\n+    /* Go and process all blocks, iterating as necessary.  */\n+    do\n+      {\n+\tbasic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[idx]);\n+\n+\t/* If the block has incoming backedges remember unwind state.  This\n+\t   is required even for non-executable blocks since in irreducible\n+\t   regions we might reach them via the backedge and re-start iterating\n+\t   from there.\n+\t   Note we can individually mark blocks with incoming backedges to\n+\t   not iterate where we then handle PHIs conservatively.  We do that\n+\t   heuristically to reduce compile-time for degenerate cases.  */\n+\tif (rpo_state[idx].iterate)\n+\t  {\n+\t    rpo_state[idx].ob_top = obstack_alloc (&vn_tables_obstack, 0);\n+\t    rpo_state[idx].ref_top = last_inserted_ref;\n+\t    rpo_state[idx].phi_top = last_inserted_phi;\n+\t    rpo_state[idx].nary_top = last_inserted_nary;\n+\t  }\n+\n+\tif (!(bb->flags & BB_EXECUTABLE))\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"Block %d: BB%d found not executable\\n\",\n+\t\t       idx, bb->index);\n+\t    idx++;\n+\t    continue;\n+\t  }\n+\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"Processing block %d: BB%d\\n\", idx, bb->index);\n+\tnblk++;\n+\ttodo |= process_bb (avail, bb,\n+\t\t\t    rpo_state[idx].visited != 0,\n+\t\t\t    rpo_state[idx].iterate,\n+\t\t\t    iterate, eliminate, do_region, exit_bbs);\n+\trpo_state[idx].visited++;\n+\n+\t/* Verify if changed values flow over executable outgoing backedges\n+\t   and those change destination PHI values (that's the thing we\n+\t   can easily verify).  Reduce over all such edges to the farthest\n+\t   away PHI.  */\n+\tint iterate_to = -1;\n+\tedge_iterator ei;\n+\tedge e;\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if ((e->flags & (EDGE_DFS_BACK|EDGE_EXECUTABLE))\n+\t      == (EDGE_DFS_BACK|EDGE_EXECUTABLE)\n+\t      && rpo_state[bb_to_rpo[e->dest->index]].iterate)\n+\t    {\n+\t      int destidx = bb_to_rpo[e->dest->index];\n+\t      if (!rpo_state[destidx].visited)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Unvisited destination %d\\n\",\n+\t\t\t     e->dest->index);\n+\t\t  if (iterate_to == -1 || destidx < iterate_to)\n+\t\t    iterate_to = destidx;\n+\t\t  continue;\n+\t\t}\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Looking for changed values of backedge\"\n+\t\t\t \" %d->%d destination PHIs\\n\",\n+\t\t\t e->src->index, e->dest->index);\n+\t      vn_context_bb = e->dest;\n+\t      gphi_iterator gsi;\n+\t      for (gsi = gsi_start_phis (e->dest);\n+\t\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\t{\n+\t\t  bool inserted = false;\n+\t\t  /* While we'd ideally just iterate on value changes\n+\t\t     we CSE PHIs and do that even across basic-block\n+\t\t     boundaries.  So even hashtable state changes can\n+\t\t     be important (which is roughly equivalent to\n+\t\t     PHI argument value changes).  To not excessively\n+\t\t     iterate because of that we track whether a PHI\n+\t\t     was CSEd to with GF_PLF_1.  */\n+\t\t  bool phival_changed;\n+\t\t  if ((phival_changed = visit_phi (gsi.phi (),\n+\t\t\t\t\t\t   &inserted, false))\n+\t\t      || (inserted && gimple_plf (gsi.phi (), GF_PLF_1)))\n+\t\t    {\n+\t\t      if (!phival_changed\n+\t\t\t  && dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file, \"PHI was CSEd and hashtable \"\n+\t\t\t\t \"state (changed)\\n\");\n+\t\t      if (iterate_to == -1 || destidx < iterate_to)\n+\t\t\titerate_to = destidx;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      vn_context_bb = NULL;\n+\t    }\n+\tif (iterate_to != -1)\n+\t  {\n+\t    do_unwind (&rpo_state[iterate_to], iterate_to, avail, bb_to_rpo);\n+\t    idx = iterate_to;\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"Iterating to %d BB%d\\n\",\n+\t\t       iterate_to, rpo[iterate_to]);\n+\t    continue;\n+\t  }\n+\n+\tidx++;\n+      }\n+    while (idx < n);\n+\n+  else /* !iterate */\n     {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[idx]);\n-\n-      /* If the block has incoming backedges remember unwind state.  This\n-         is required even for non-executable blocks since in irreducible\n-\t regions we might reach them via the backedge and re-start iterating\n-\t from there.\n-\t Note we can individually mark blocks with incoming backedges to\n-\t not iterate where we then handle PHIs conservatively.  We do that\n-\t heuristically to reduce compile-time for degenerate cases.  */\n-      if (rpo_state[idx].iterate)\n+      /* Process all blocks greedily with a worklist that enforces RPO\n+         processing of reachable blocks.  */\n+      auto_bitmap worklist;\n+      bitmap_set_bit (worklist, 0);\n+      while (!bitmap_empty_p (worklist))\n \t{\n-\t  rpo_state[idx].ob_top = obstack_alloc (&vn_tables_obstack, 0);\n-\t  rpo_state[idx].ref_top = last_inserted_ref;\n-\t  rpo_state[idx].phi_top = last_inserted_phi;\n-\t  rpo_state[idx].nary_top = last_inserted_nary;\n-\t}\n+\t  int idx = bitmap_first_set_bit (worklist);\n+\t  bitmap_clear_bit (worklist, idx);\n+\t  basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[idx]);\n+\t  gcc_assert ((bb->flags & BB_EXECUTABLE)\n+\t\t      && !rpo_state[idx].visited);\n \n-      if (!(bb->flags & BB_EXECUTABLE))\n-\t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Block %d: BB%d found not executable\\n\",\n-\t\t     idx, bb->index);\n-\t  idx++;\n-\t  continue;\n-\t}\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Processing block %d: BB%d\\n\", idx, bb->index);\n-      nblk++;\n-      todo |= process_bb (avail, bb,\n-\t\t\t  rpo_state[idx].visited != 0,\n-\t\t\t  rpo_state[idx].iterate,\n-\t\t\t  iterate, eliminate, do_region, exit_bbs);\n-      rpo_state[idx].visited++;\n+\t    fprintf (dump_file, \"Processing block %d: BB%d\\n\", idx, bb->index);\n \n-      if (iterate)\n-\t{\n-\t  /* Verify if changed values flow over executable outgoing backedges\n-\t     and those change destination PHI values (that's the thing we\n-\t     can easily verify).  Reduce over all such edges to the farthest\n-\t     away PHI.  */\n-\t  int iterate_to = -1;\n+\t  /* When we run into predecessor edges where we cannot trust its\n+\t     executable state mark them executable so PHI processing will\n+\t     be conservative.\n+\t     ???  Do we need to force arguments flowing over that edge\n+\t     to be varying or will they even always be?  */\n \t  edge_iterator ei;\n \t  edge e;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if ((e->flags & (EDGE_DFS_BACK|EDGE_EXECUTABLE))\n-\t\t== (EDGE_DFS_BACK|EDGE_EXECUTABLE)\n-\t\t&& rpo_state[bb_to_rpo[e->dest->index]].iterate)\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (!(e->flags & EDGE_EXECUTABLE)\n+\t\t&& !rpo_state[bb_to_rpo[e->src->index]].visited\n+\t\t&& rpo_state[bb_to_rpo[e->src->index]].max_rpo >= (int)idx)\n \t      {\n-\t\tint destidx = bb_to_rpo[e->dest->index];\n-\t\tif (!rpo_state[destidx].visited)\n-\t\t  {\n-\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t      fprintf (dump_file, \"Unvisited destination %d\\n\",\n-\t\t\t       e->dest->index);\n-\t\t    if (iterate_to == -1\n-\t\t\t|| destidx < iterate_to)\n-\t\t      iterate_to = destidx;\n-\t\t    continue;\n-\t\t  }\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  fprintf (dump_file, \"Looking for changed values of backedge \"\n-\t\t\t   \"%d->%d destination PHIs\\n\",\n+\t\t  fprintf (dump_file, \"Cannot trust state of predecessor \"\n+\t\t\t   \"edge %d -> %d, marking executable\\n\",\n \t\t\t   e->src->index, e->dest->index);\n-\t\tvn_context_bb = e->dest;\n-\t\tgphi_iterator gsi;\n-\t\tfor (gsi = gsi_start_phis (e->dest);\n-\t\t     !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t  {\n-\t\t    bool inserted = false;\n-\t\t    /* While we'd ideally just iterate on value changes\n-\t\t       we CSE PHIs and do that even across basic-block\n-\t\t       boundaries.  So even hashtable state changes can\n-\t\t       be important (which is roughly equivalent to\n-\t\t       PHI argument value changes).  To not excessively\n-\t\t       iterate because of that we track whether a PHI\n-\t\t       was CSEd to with GF_PLF_1.  */\n-\t\t    bool phival_changed;\n-\t\t    if ((phival_changed = visit_phi (gsi.phi (),\n-\t\t\t\t\t\t     &inserted, false))\n-\t\t\t|| (inserted && gimple_plf (gsi.phi (), GF_PLF_1)))\n-\t\t      {\n-\t\t\tif (!phival_changed\n-\t\t\t    && dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t  fprintf (dump_file, \"PHI was CSEd and hashtable \"\n-\t\t\t\t   \"state (changed)\\n\");\n-\t\t\tif (iterate_to == -1\n-\t\t\t    || destidx < iterate_to)\n-\t\t\t  iterate_to = destidx;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\tvn_context_bb = NULL;\n+\t\te->flags |= EDGE_EXECUTABLE;\n \t      }\n-\t  if (iterate_to != -1)\n-\t    {\n-\t      do_unwind (&rpo_state[iterate_to], iterate_to,\n-\t\t\t avail, bb_to_rpo);\n-\t      idx = iterate_to;\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"Iterating to %d BB%d\\n\",\n-\t\t\t iterate_to, rpo[iterate_to]);\n-\t      continue;\n-\t    }\n-\t}\n \n-      idx++;\n+\t  nblk++;\n+\t  todo |= process_bb (avail, bb, false, false, false, eliminate,\n+\t\t\t      do_region, exit_bbs);\n+\t  rpo_state[idx].visited++;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    if ((e->flags & EDGE_EXECUTABLE)\n+\t\t&& e->dest->index != EXIT_BLOCK\n+\t\t&& (!do_region || !bitmap_bit_p (exit_bbs, e->dest->index))\n+\t\t&& !rpo_state[bb_to_rpo[e->dest->index]].visited)\n+\t      bitmap_set_bit (worklist, bb_to_rpo[e->dest->index]);\n+\t}\n     }\n-  while (idx < n);\n \n   /* If statistics or dump file active.  */\n   int nex = 0;"}]}