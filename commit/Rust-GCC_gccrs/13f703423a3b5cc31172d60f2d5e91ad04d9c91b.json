{"sha": "13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNmNzAzNDIzYTNiNWNjMzExNzJkNjBmMmQ1ZTkxYWQwNGQ5YzkxYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-24T19:28:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-24T19:28:37Z"}, "message": "constraints.md: New file.\n\n        * config/ia64/constraints.md: New file.\n        * config/ia64/predicates.md: Replace CONST_OK_FOR_? with\n        satisfies_constraint_?.\n        * config/ia64/ia64.c (ia64_move_ok, ia64_legitimate_constant_p,\n        ia64_reload_gp, spill_restore_mem, ia64_expand_prologue,\n        ia64_expand_epilogue, ia64_split_return_addr_rtx, ia64_rtx_costs,\n        ia64_output_mi_thunk): Likewise.\n        (ia64_const_ok_for_letter_p): Remove.\n        (ia64_const_double_ok_for_letter_p): Remove. \n        (ia64_extra_constraint): Remove.\n        * config/ia64/ia64.h (REG_CLASS_FROM_LETTER): Remove.\n        (CONST_OK_FOR_I, CONST_OK_FOR_J, CONST_OK_FOR_K, CONST_OK_FOR_L,\n        CONST_OK_FOR_M, CONST_OK_FOR_N, CONST_OK_FOR_O, CONST_OK_FOR_P,\n        CONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_G,\n        CONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT,\n        EXTRA_MEMORY_CONSTRAINT): Remove.\n        * config/ia64/ia64.md: Include constriants.md.  Replace\n        CONST_OK_FOR_? with satisfies_constraint_?.\n\nFrom-SVN: r123186", "tree": {"sha": "2cf72e2ee49c9ec77a29f5e27afdb371b1a77f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cf72e2ee49c9ec77a29f5e27afdb371b1a77f63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/comments", "author": null, "committer": null, "parents": [{"sha": "79b87c74d764bd42703818289685e48996b54eb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b87c74d764bd42703818289685e48996b54eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79b87c74d764bd42703818289685e48996b54eb8"}], "stats": {"total": 421, "additions": 209, "deletions": 212}, "files": [{"sha": "acb54aec2a381996a585e88678b958e257b1e264", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -1,3 +1,24 @@\n+2007-03-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/constraints.md: New file.\n+\t* config/ia64/predicates.md: Replace CONST_OK_FOR_? with\n+\tsatisfies_constraint_?.\n+\t* config/ia64/ia64.c (ia64_move_ok, ia64_legitimate_constant_p,\n+\tia64_reload_gp, spill_restore_mem, ia64_expand_prologue,\n+\tia64_expand_epilogue, ia64_split_return_addr_rtx, ia64_rtx_costs,\n+\tia64_output_mi_thunk): Likewise.\n+\t(ia64_const_ok_for_letter_p): Remove.\n+\t(ia64_const_double_ok_for_letter_p): Remove.\n+\t(ia64_extra_constraint): Remove.\n+\t* config/ia64/ia64.h (REG_CLASS_FROM_LETTER): Remove.\n+\t(CONST_OK_FOR_I, CONST_OK_FOR_J, CONST_OK_FOR_K, CONST_OK_FOR_L,\n+\tCONST_OK_FOR_M, CONST_OK_FOR_N, CONST_OK_FOR_O, CONST_OK_FOR_P,\n+\tCONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_G,\n+\tCONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT,\n+\tEXTRA_MEMORY_CONSTRAINT): Remove.\n+\t* config/ia64/ia64.md: Include constriants.md.  Replace\n+\tCONST_OK_FOR_? with satisfies_constraint_?.\n+\n 2007-03-23  Michael Meissner  <michael.meissner@amd.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "a3d84d923d979c2260387f38e9c00543f8ecd5ac", "filename": "gcc/config/ia64/constraints.md", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fconstraints.md?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -0,0 +1,139 @@\n+;; Constraint definitions for IA-64\n+;; Copyright (C) 2006 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;; Register constraints\n+\n+(define_register_constraint \"a\" \"ADDL_REGS\"\n+  \"addl register\")\n+\n+(define_register_constraint \"b\" \"BR_REGS\"\n+  \"branch register\")\n+\n+(define_register_constraint \"c\" \"PR_REGS\"\n+  \"predicate register\")\n+\n+(define_register_constraint \"d\" \"AR_M_REGS\"\n+  \"memory pipeline application register\")\n+\n+(define_register_constraint \"e\" \"AR_I_REGS\"\n+  \"integer pipeline application register\")\n+\n+(define_register_constraint \"f\" \"FR_REGS\"\n+  \"floating-point register\")\n+\n+(define_register_constraint \"x\" \"FP_REGS\"\n+  \"floating-point register, excluding f31 and f127, used for fldp\")\n+\n+;; Integer constraints\n+\n+(define_constraint \"I\"\n+  \"14 bit signed immediate for arithmetic instructions\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)ival + 0x2000 < 0x4000\")))\n+\n+(define_constraint \"J\"\n+  \"22 bit signed immediate for arith instructions with r0/r1/r2/r3 source\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)ival + 0x200000 < 0x400000\")))\n+\n+(define_constraint \"K\"\n+  \"8 bit signed immediate for logical instructions\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)ival + 0x80 < 0x100\")))\n+\n+(define_constraint \"L\"\n+  \"8 bit adjusted signed immediate for compare pseudo-ops\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)ival + 0x7F < 0x100\")))\n+\n+(define_constraint \"M\"\n+  \"6 bit unsigned immediate for shift counts\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)ival < 0x40\")))\n+\n+(define_constraint \"N\"\n+  \"9 bit signed immediate for load/store post-increments\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned HOST_WIDE_INT)ival + 0x100 < 0x200\")))\n+\n+(define_constraint \"O\"\n+  \"constant zero\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"P\"\n+  \"0 or -1 for dep instruction\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0 || ival == -1\")))\n+\n+;; Floating-point constraints\n+\n+(define_constraint \"G\"\n+  \"0.0 and 1.0 for fr0 and fr1\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode) || op == CONST1_RTX (mode)\")))\n+\n+;; Extra constraints\n+\n+;; Note that while this accepts mem, it only accepts non-volatile mem,\n+;; and so cannot be \"fixed\" by adjusting the address.  Thus it cannot\n+;; and does not use define_memory_constraint.\n+(define_constraint \"Q\"\n+  \"Non-volatile memory for FP_REG loads/stores\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (match_test \"!MEM_VOLATILE_P (op)\")))\n+\n+(define_constraint \"R\"\n+  \"1..4 for shladd arguments\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 1 && ival <= 4\")))\n+\n+(define_constraint \"T\"\n+  \"Symbol ref to small-address-area\"\n+  (match_operand 0 \"small_addr_symbolic_operand\"))\n+\n+;; ??? Original definition didn't test for vector only.  \n+;; Need to verify that only used in vector context.\n+(define_constraint \"U\"\n+  \"vector zero constant\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+(define_constraint \"W\"\n+  \"An integer vector, such that conversion to an integer yields a\n+   value appropriate for an integer 'J' constraint.\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"GET_MODE_CLASS (mode) == MODE_VECTOR_INT\")\n+       (match_test\n+\t\"satisfies_constraint_J (simplify_subreg (DImode, op, mode, 0))\")))\n+\n+(define_constraint \"Y\"\n+  \"A V2SF vector containing elements that satisfy 'G'\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"mode == V2SFmode\")\n+       (match_test \"satisfies_constraint_G (XVECEXP (op, 0, 0))\")\n+       (match_test \"satisfies_constraint_G (XVECEXP (op, 0, 1))\")))\n+\n+;; Memory constraints\n+\n+(define_memory_constraint \"S\"\n+  \"Non-post-inc memory for asms and other unsavory creatures\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))"}, {"sha": "555038b30fcd6ab602babe23fec2bdf9b1bae4f0", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -34,9 +34,6 @@ extern int ia64_st_address_bypass_p (rtx, rtx);\n extern int ia64_ld_address_bypass_p (rtx, rtx);\n extern int ia64_produce_address_p (rtx);\n \n-extern bool ia64_const_ok_for_letter_p (HOST_WIDE_INT, char);\n-extern bool ia64_const_double_ok_for_letter_p (rtx, char);\n-extern bool ia64_extra_constraint (rtx, char);\n extern bool ia64_legitimate_constant_p (rtx);\n \n extern rtx ia64_expand_move (rtx, rtx);"}, {"sha": "2bbd6819f7bd137612078383ba1a06beeb1b1a87", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 34, "deletions": 128, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -55,6 +55,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"intl.h\"\n #include \"debug.h\"\n #include \"params.h\"\n+#include \"tm-constrs.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -602,102 +603,6 @@ ia64_encode_section_info (tree decl, rtx rtl, int first)\n     ia64_encode_addr_area (decl, XEXP (rtl, 0));\n }\n \f\n-/* Implement CONST_OK_FOR_LETTER_P.  */\n-\n-bool\n-ia64_const_ok_for_letter_p (HOST_WIDE_INT value, char c)\n-{\n-  switch (c)\n-    {\n-    case 'I':\n-      return CONST_OK_FOR_I (value);\n-    case 'J':\n-      return CONST_OK_FOR_J (value);\n-    case 'K':\n-      return CONST_OK_FOR_K (value);\n-    case 'L':\n-      return CONST_OK_FOR_L (value);\n-    case 'M':\n-      return CONST_OK_FOR_M (value);\n-    case 'N':\n-      return CONST_OK_FOR_N (value);\n-    case 'O':\n-      return CONST_OK_FOR_O (value);\n-    case 'P':\n-      return CONST_OK_FOR_P (value);\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Implement CONST_DOUBLE_OK_FOR_LETTER_P.  */\n-\n-bool\n-ia64_const_double_ok_for_letter_p (rtx value, char c)\n-{\n-  switch (c)\n-    {\n-    case 'G':\n-      return CONST_DOUBLE_OK_FOR_G (value);\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Implement EXTRA_CONSTRAINT.  */\n-\n-bool\n-ia64_extra_constraint (rtx value, char c)\n-{\n-  switch (c)\n-    {\n-    case 'Q':\n-      /* Non-volatile memory for FP_REG loads/stores.  */\n-      return memory_operand(value, VOIDmode) && !MEM_VOLATILE_P (value);\n-\n-    case 'R':\n-      /* 1..4 for shladd arguments.  */\n-      return (GET_CODE (value) == CONST_INT\n-\t      && INTVAL (value) >= 1 && INTVAL (value) <= 4);\n-\n-    case 'S':\n-      /* Non-post-inc memory for asms and other unsavory creatures.  */\n-      return (GET_CODE (value) == MEM\n-\t      && GET_RTX_CLASS (GET_CODE (XEXP (value, 0))) != RTX_AUTOINC\n-\t      && (reload_in_progress || memory_operand (value, VOIDmode)));\n-\n-    case 'T':\n-      /* Symbol ref to small-address-area.  */\n-      return small_addr_symbolic_operand (value, VOIDmode);\n-\n-    case 'U':\n-      /* Vector zero.  */\n-      return value == CONST0_RTX (GET_MODE (value));\n-\n-    case 'W':\n-      /* An integer vector, such that conversion to an integer yields a\n-\t value appropriate for an integer 'J' constraint.  */\n-      if (GET_CODE (value) == CONST_VECTOR\n-\t  && GET_MODE_CLASS (GET_MODE (value)) == MODE_VECTOR_INT)\n-\t{\n-\t  value = simplify_subreg (DImode, value, GET_MODE (value), 0);\n-\t  return ia64_const_ok_for_letter_p (INTVAL (value), 'J');\n-\t}\n-      return false;\n-\n-    case 'Y':\n-      /* A V2SF vector containing elements that satisfy 'G'.  */\n-      return\n-\t(GET_CODE (value) == CONST_VECTOR\n-\t && GET_MODE (value) == V2SFmode\n-\t && ia64_const_double_ok_for_letter_p (XVECEXP (value, 0, 0), 'G')\n-\t && ia64_const_double_ok_for_letter_p (XVECEXP (value, 0, 1), 'G'));\n-\n-    default:\n-      return false;\n-    }\n-}\n-\f\n /* Return 1 if the operands of a move are ok.  */\n \n int\n@@ -718,7 +623,7 @@ ia64_move_ok (rtx dst, rtx src)\n   if (INTEGRAL_MODE_P (GET_MODE (dst)))\n     return src == const0_rtx;\n   else\n-    return GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src);\n+    return satisfies_constraint_G (src);\n }\n \n /* Return 1 if the operands are ok for a floating point load pair.  */\n@@ -809,7 +714,7 @@ ia64_legitimate_constant_p (rtx x)\n     case CONST_DOUBLE:\n       if (GET_MODE (x) == VOIDmode)\n \treturn true;\n-      return CONST_DOUBLE_OK_FOR_G (x);\n+      return satisfies_constraint_G (x);\n \n     case CONST:\n     case SYMBOL_REF:\n@@ -843,7 +748,7 @@ ia64_legitimate_constant_p (rtx x)\n \tenum machine_mode mode = GET_MODE (x);\n \n \tif (mode == V2SFmode)\n-\t  return ia64_extra_constraint (x, 'Y');\n+\t  return satisfies_constraint_Y (x);\n \n \treturn (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n \t\t&& GET_MODE_SIZE (mode) <= 8);\n@@ -1977,6 +1882,7 @@ ia64_reload_gp (void)\n   else\n     {\n       HOST_WIDE_INT offset;\n+      rtx offset_r;\n \n       offset = (current_frame_info.spill_cfa_off\n \t        + current_frame_info.spill_size);\n@@ -1991,12 +1897,12 @@ ia64_reload_gp (void)\n           offset = current_frame_info.total_size - offset;\n         }\n \n-      if (CONST_OK_FOR_I (offset))\n-        emit_insn (gen_adddi3 (pic_offset_table_rtx,\n-\t\t\t       tmp, GEN_INT (offset)));\n+      offset_r = GEN_INT (offset);\n+      if (satisfies_constraint_I (offset_r))\n+        emit_insn (gen_adddi3 (pic_offset_table_rtx, tmp, offset_r));\n       else\n         {\n-          emit_move_insn (pic_offset_table_rtx, GEN_INT (offset));\n+          emit_move_insn (pic_offset_table_rtx, offset_r);\n           emit_insn (gen_adddi3 (pic_offset_table_rtx,\n \t\t\t         pic_offset_table_rtx, tmp));\n         }\n@@ -2733,7 +2639,7 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n \n   if (spill_fill_data.prev_addr[iter])\n     {\n-      if (CONST_OK_FOR_N (disp))\n+      if (satisfies_constraint_N (disp_rtx))\n \t{\n \t  *spill_fill_data.prev_addr[iter]\n \t    = gen_rtx_POST_MODIFY (DImode, spill_fill_data.iter_reg[iter],\n@@ -2747,7 +2653,7 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n       else\n \t{\n \t  /* ??? Could use register post_modify for loads.  */\n-\t  if (! CONST_OK_FOR_I (disp))\n+\t  if (!satisfies_constraint_I (disp_rtx))\n \t    {\n \t      rtx tmp = gen_rtx_REG (DImode, next_scratch_gr_reg ());\n \t      emit_move_insn (tmp, disp_rtx);\n@@ -2780,7 +2686,7 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n \t{\n \t  start_sequence ();\n \n-\t  if (! CONST_OK_FOR_I (disp))\n+\t  if (!satisfies_constraint_I (disp_rtx))\n \t    {\n \t      rtx tmp = gen_rtx_REG (DImode, next_scratch_gr_reg ());\n \t      emit_move_insn (tmp, disp_rtx);\n@@ -3040,7 +2946,7 @@ ia64_expand_prologue (void)\n       rtx frame_size_rtx = GEN_INT (- current_frame_info.total_size);\n       rtx offset;\n \n-      if (CONST_OK_FOR_I (- current_frame_info.total_size))\n+      if (satisfies_constraint_I (frame_size_rtx))\n \toffset = frame_size_rtx;\n       else\n \t{\n@@ -3464,7 +3370,7 @@ ia64_expand_epilogue (int sibcall_p)\n       rtx offset, frame_size_rtx;\n \n       frame_size_rtx = GEN_INT (current_frame_info.total_size);\n-      if (CONST_OK_FOR_I (current_frame_info.total_size))\n+      if (satisfies_constraint_I (frame_size_rtx))\n \toffset = frame_size_rtx;\n       else\n \t{\n@@ -3572,6 +3478,7 @@ ia64_split_return_addr_rtx (rtx dest)\n \t{\n \t  HOST_WIDE_INT off;\n \t  unsigned int regno;\n+\t  rtx off_r;\n \n \t  /* Compute offset from CFA for BR0.  */\n \t  /* ??? Must be kept in sync with ia64_expand_prologue.  */\n@@ -3591,11 +3498,12 @@ ia64_split_return_addr_rtx (rtx dest)\n \t    }\n \n \t  /* Load address into scratch register.  */\n-\t  if (CONST_OK_FOR_I (off))\n-\t    emit_insn (gen_adddi3 (dest, src, GEN_INT (off)));\n+\t  off_r = GEN_INT (off);\n+\t  if (satisfies_constraint_I (off_r))\n+\t    emit_insn (gen_adddi3 (dest, src, off_r));\n \t  else\n \t    {\n-\t      emit_move_insn (dest, GEN_INT (off));\n+\t      emit_move_insn (dest, off_r);\n \t      emit_insn (gen_adddi3 (dest, src, dest));\n \t    }\n \n@@ -4786,18 +4694,18 @@ ia64_rtx_costs (rtx x, int code, int outer_code, int *total)\n       switch (outer_code)\n         {\n         case SET:\n-\t  *total = CONST_OK_FOR_J (INTVAL (x)) ? 0 : COSTS_N_INSNS (1);\n+\t  *total = satisfies_constraint_J (x) ? 0 : COSTS_N_INSNS (1);\n \t  return true;\n         case PLUS:\n-\t  if (CONST_OK_FOR_I (INTVAL (x)))\n+\t  if (satisfies_constraint_I (x))\n \t    *total = 0;\n-\t  else if (CONST_OK_FOR_J (INTVAL (x)))\n+\t  else if (satisfies_constraint_J (x))\n \t    *total = 1;\n \t  else\n \t    *total = COSTS_N_INSNS (1);\n \t  return true;\n         default:\n-\t  if (CONST_OK_FOR_K (INTVAL (x)) || CONST_OK_FOR_L (INTVAL (x)))\n+\t  if (satisfies_constraint_K (x) || satisfies_constraint_L (x))\n \t    *total = 0;\n \t  else\n \t    *total = COSTS_N_INSNS (1);\n@@ -9457,6 +9365,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   rtx this, insn, funexp;\n   unsigned int this_parmno;\n   unsigned int this_regno;\n+  rtx delta_rtx;\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n@@ -9485,25 +9394,24 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n     reg_names[this_regno] = ia64_reg_numbers[this_parmno];\n \n   this = gen_rtx_REG (Pmode, this_regno);\n+\n+  /* Apply the constant offset, if required.  */\n+  delta_rtx = GEN_INT (delta);\n   if (TARGET_ILP32)\n     {\n       rtx tmp = gen_rtx_REG (ptr_mode, this_regno);\n       REG_POINTER (tmp) = 1;\n-      if (delta && CONST_OK_FOR_I (delta))\n+      if (delta && satisfies_constraint_I (delta_rtx))\n \t{\n-\t  emit_insn (gen_ptr_extend_plus_imm (this, tmp, GEN_INT (delta)));\n+\t  emit_insn (gen_ptr_extend_plus_imm (this, tmp, delta_rtx));\n \t  delta = 0;\n \t}\n       else\n \temit_insn (gen_ptr_extend (this, tmp));\n     }\n-\n-  /* Apply the constant offset, if required.  */\n   if (delta)\n     {\n-      rtx delta_rtx = GEN_INT (delta);\n-\n-      if (!CONST_OK_FOR_I (delta))\n+      if (!satisfies_constraint_I (delta_rtx))\n \t{\n \t  rtx tmp = gen_rtx_REG (Pmode, 2);\n \t  emit_move_insn (tmp, delta_rtx);\n@@ -9523,10 +9431,9 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t  rtx t = gen_rtx_REG (ptr_mode, 2);\n \t  REG_POINTER (t) = 1;\n \t  emit_move_insn (t, gen_rtx_MEM (ptr_mode, this));\n-\t  if (CONST_OK_FOR_I (vcall_offset))\n+\t  if (satisfies_constraint_I (vcall_offset_rtx))\n \t    {\n-\t      emit_insn (gen_ptr_extend_plus_imm (tmp, t, \n-\t\t\t\t\t\t  vcall_offset_rtx));\n+\t      emit_insn (gen_ptr_extend_plus_imm (tmp, t, vcall_offset_rtx));\n \t      vcall_offset = 0;\n \t    }\n \t  else\n@@ -9537,7 +9444,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n       if (vcall_offset)\n \t{\n-\t  if (!CONST_OK_FOR_J (vcall_offset))\n+\t  if (!satisfies_constraint_J (vcall_offset_rtx))\n \t    {\n \t      rtx tmp2 = gen_rtx_REG (Pmode, next_scratch_gr_reg ());\n \t      emit_move_insn (tmp2, vcall_offset_rtx);\n@@ -9547,8 +9454,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t}\n \n       if (TARGET_ILP32)\n-\temit_move_insn (gen_rtx_REG (ptr_mode, 2), \n-\t\t\tgen_rtx_MEM (ptr_mode, tmp));\n+\temit_insn (gen_zero_extendsidi2 (tmp, gen_rtx_MEM (ptr_mode, tmp)));\n       else\n \temit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp));\n "}, {"sha": "951fb57a28acb664d05cbcac15e162b90b87dec2", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -825,22 +825,6 @@ enum reg_class\n    (as well as added to a displacement).  This is needed for POST_MODIFY.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n \n-/* A C expression which defines the machine-dependent operand constraint\n-   letters for register classes.  If CHAR is such a letter, the value should be\n-   the register class corresponding to it.  Otherwise, the value should be\n-   `NO_REGS'.  The register letter `r', corresponding to class `GENERAL_REGS',\n-   will not be passed to this macro; you do not need to handle it.  */\n-\n-#define REG_CLASS_FROM_LETTER(CHAR) \\\n-((CHAR) == 'f' ? FR_REGS\t\t\\\n- : (CHAR) == 'a' ? ADDL_REGS\t\t\\\n- : (CHAR) == 'b' ? BR_REGS\t\t\\\n- : (CHAR) == 'c' ? PR_REGS\t\t\\\n- : (CHAR) == 'd' ? AR_M_REGS\t\t\\\n- : (CHAR) == 'e' ? AR_I_REGS\t\t\\\n- : (CHAR) == 'x' ? FP_REGS\t\t\\\n- : NO_REGS)\n-\n /* A C expression which is nonzero if register number NUM is suitable for use\n    as a base register in operand addresses.  It may be either a suitable hard\n    register or a pseudo register that has been allocated such a hard reg.  */\n@@ -905,57 +889,6 @@ enum reg_class\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \t\t\\\n   (SCALAR_FLOAT_MODE_P (FROM) != SCALAR_FLOAT_MODE_P (TO)\t\\\n    ? reg_classes_intersect_p (CLASS, FR_REGS) : 0)\n-\n-/* A C expression that defines the machine-dependent operand constraint\n-   letters (`I', `J', `K', .. 'P') that specify particular ranges of\n-   integer values.  */\n-\n-/* 14-bit signed immediate for arithmetic instructions.  */\n-#define CONST_OK_FOR_I(VALUE) \\\n-  ((unsigned HOST_WIDE_INT)(VALUE) + 0x2000 < 0x4000)\n-/* 22-bit signed immediate for arith instructions with r0/r1/r2/r3 source.  */\n-#define CONST_OK_FOR_J(VALUE) \\\n-  ((unsigned HOST_WIDE_INT)(VALUE) + 0x200000 < 0x400000)\n-/* 8-bit signed immediate for logical instructions.  */\n-#define CONST_OK_FOR_K(VALUE) ((unsigned HOST_WIDE_INT)(VALUE) + 0x80 < 0x100)\n-/* 8-bit adjusted signed immediate for compare pseudo-ops.  */\n-#define CONST_OK_FOR_L(VALUE) ((unsigned HOST_WIDE_INT)(VALUE) + 0x7F < 0x100)\n-/* 6-bit unsigned immediate for shift counts.  */\n-#define CONST_OK_FOR_M(VALUE) ((unsigned HOST_WIDE_INT)(VALUE) < 0x40)\n-/* 9-bit signed immediate for load/store post-increments.  */\n-#define CONST_OK_FOR_N(VALUE) ((unsigned HOST_WIDE_INT)(VALUE) + 0x100 < 0x200)\n-/* 0 for r0.  Used by Linux kernel, do not change.  */\n-#define CONST_OK_FOR_O(VALUE) ((VALUE) == 0)\n-/* 0 or -1 for dep instruction.  */\n-#define CONST_OK_FOR_P(VALUE) ((VALUE) == 0 || (VALUE) == -1)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-  ia64_const_ok_for_letter_p (VALUE, C)\n-\n-/* A C expression that defines the machine-dependent operand constraint letters\n-   (`G', `H') that specify particular ranges of `const_double' values.  */\n-\n-/* 0.0 and 1.0 for fr0 and fr1.  */\n-#define CONST_DOUBLE_OK_FOR_G(VALUE) \\\n-  ((VALUE) == CONST0_RTX (GET_MODE (VALUE))\t\\\n-   || (VALUE) == CONST1_RTX (GET_MODE (VALUE)))\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-  ia64_const_double_ok_for_letter_p (VALUE, C)\n-\n-/* A C expression that defines the optional machine-dependent constraint\n-   letters (`Q', `R', `S', `T', `U') that can be used to segregate specific\n-   types of operands, usually memory references, for the target machine.  */\n-\n-#define EXTRA_CONSTRAINT(VALUE, C) \\\n-  ia64_extra_constraint (VALUE, C)\n-\n-/* Document the constraints that can accept reloaded memory operands.  This is\n-   needed by the extended asm support, and by reload.  'Q' accepts mem, but\n-   only non-volatile mem.  Since we can't reload a volatile mem into a\n-   non-volatile mem, it can not be listed here.  */\n-\n-#define EXTRA_MEMORY_CONSTRAINT(C, STR)  ((C) == 'S')\n \f\n /* Basic Stack Layout */\n "}, {"sha": "b9c35d6a7fa048e509fc162482f5856ece448892", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -101,6 +101,7 @@\n   ])\n \n (include \"predicates.md\")\n+(include \"constraints.md\")\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1346,9 +1347,9 @@\n (define_insn \"*depz_internal\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n \t(and:DI (ashift:DI (match_operand:DI 1 \"gr_register_operand\" \"r\")\n-\t\t\t   (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t\t   (match_operand:DI 2 \"const_int_operand\" \"M\"))\n \t\t(match_operand:DI 3 \"const_int_operand\" \"n\")))]\n-  \"CONST_OK_FOR_M (INTVAL (operands[2]))\n+  \"satisfies_constraint_M (operands[2])\n    && ia64_depz_field_mask (operands[3], operands[2]) > 0\"\n {\n   operands[3] = GEN_INT (ia64_depz_field_mask (operands[3], operands[2]));\n@@ -2809,7 +2810,7 @@\n \t(minus:TI (match_operand:TI 1 \"immediate_operand\" \"\")\n \t\t  (match_operand:TI 2 \"register_operand\" \"\")))\n    (clobber (match_scratch:BI 3 \"=&c\"))]\n-  \"reload_completed && CONST_OK_FOR_K (INTVAL (operands[1]))\"\n+  \"reload_completed && satisfies_constraint_K (operands[1])\"\n   [(set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))\n    (set (match_dup 3) (gtu:BI (match_dup 0) (match_dup 1)))\n    (cond_exec (ne (match_dup 3) (const_int 0))"}, {"sha": "dbf8bb218f3a6c6b1b6127352c12c6563226f473", "filename": "gcc/config/ia64/predicates.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f703423a3b5cc31172d60f2d5e91ad04d9c91b/gcc%2Fconfig%2Fia64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fpredicates.md?ref=13f703423a3b5cc31172d60f2d5e91ad04d9c91b", "patch": "@@ -434,25 +434,25 @@\n (define_predicate \"gr_reg_or_6bit_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_M (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_M (op)\"))))\n \n ;; True if OP is a GR register operand, or an 8-bit immediate operand.\n (define_predicate \"gr_reg_or_8bit_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_K (op)\"))))\n \n ;; True if OP is a GR/FR register operand, or an 8-bit immediate operand.\n (define_predicate \"grfr_reg_or_8bit_operand\"\n   (ior (match_operand 0 \"grfr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_K (op)\"))))\n \n ;; True if OP is a register operand, or an 8-bit adjusted immediate operand.\n (define_predicate \"gr_reg_or_8bit_adjusted_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_L (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_L (op)\"))))\n \n ;; True if OP is a register operand, or is valid for both an 8-bit\n ;; immediate and an 8-bit adjusted immediate operand.  This is necessary\n@@ -461,20 +461,20 @@\n (define_predicate \"gr_reg_or_8bit_and_adjusted_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\n-                         && CONST_OK_FOR_L (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_K (op)\n+                         && satisfies_constraint_L (op)\"))))\n \n ;; True if OP is a register operand, or a 14-bit immediate operand.\n (define_predicate \"gr_reg_or_14bit_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_I (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_I (op)\"))))\n \n ;;  True if OP is a register operand, or a 22-bit immediate operand.\n (define_predicate \"gr_reg_or_22bit_operand\"\n   (ior (match_operand 0 \"gr_register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_J (INTVAL (op))\"))))\n+\t    (match_test \"satisfies_constraint_J (op)\"))))\n \n ;; True if OP is a 7-bit immediate operand.\n (define_predicate \"dshift_count_operand\"\n@@ -484,12 +484,12 @@\n ;; True if OP is a 6-bit immediate operand.\n (define_predicate \"shift_count_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"CONST_OK_FOR_M (INTVAL (op))\")))\n+       (match_test \"satisfies_constraint_M (op)\")))\n \n ;; True if OP-1 is a 6-bit immediate operand, used in extr instruction.\n (define_predicate \"extr_len_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"CONST_OK_FOR_M (INTVAL (op) - 1)\")))\n+       (match_test \"satisfies_constraint_M (GEN_INT (INTVAL (op) - 1))\")))\n \n ;; True if OP is a 5-bit immediate operand.\n (define_predicate \"shift_32bit_count_operand\"\n@@ -524,7 +524,7 @@\n (define_predicate \"fr_reg_or_fp01_operand\"\n   (ior (match_operand 0 \"fr_register_operand\")\n        (and (match_code \"const_double\")\n-\t    (match_test \"CONST_DOUBLE_OK_FOR_G (op)\"))))\n+\t    (match_test \"satisfies_constraint_G (op)\"))))\n \n ;; Like fr_reg_or_fp01_operand, but don't allow any SUBREGs.\n (define_predicate \"xfreg_or_fp01_operand\""}]}