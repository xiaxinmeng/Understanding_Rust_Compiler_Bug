{"sha": "389fdba06a4469967a53ea92ffa86d1d090e3a7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg5ZmRiYTA2YTQ0Njk5NjdhNTNlYTkyZmZhODZkMWQwOTBlM2E3Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-18T08:25:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-18T08:25:01Z"}, "message": "rtl.h (MEM_READONLY_P): Replace RTX_UNCHANGING_P.\n\n\t* rtl.h (MEM_READONLY_P): Replace RTX_UNCHANGING_P.\n\t* alias.c (true_dependence): Update to match new semantics.\n\t(canon_true_dependence, write_dependence_p): Likewise.\n\t(anti_dependence, output_dependence): Update write_dependence_p args.\n\t(unchanging_anti_dependence): Remove.\n\t* calls.c (purge_mem_unchanging_flag): Remove.\n\t(fixup_tail_calls): Don't call it.\n\t(expand_call): Don't add unchanging memory to function usage.\n\t* expr.c (emit_block_move_via_libcall): Likewise.\n\t(clear_storage_via_libcall): Don't clobber RTX_UNCHANGING_P mems.\n\t(get_subtarget): Don't use RTX_UNCHANGING_P.\n\t(expand_assignment, store_constructor, expand_expr_real_1): Likewise.\n\t(do_tablejump): Set MEM_READONLY_P, not RTX_UNCHANGING_P.\n\t* combine.c (get_last_value_validate): Use MEM_READONLY_P.\n\t* cse.c (insert): Don't use RTX_UNCHANGING_P.\n\t(cse_insn, canon_hash): Use MEM_READONLY_P.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Use MEM_READONLY_P\n\tinstead of RTX_UNCHANGING_P.\n\t* explow.c (maybe_set_unchanging): Remove.\n\t* expr.h (maybe_set_unchanging): Remove.\n\t* flow.c (insn_dead_p, mark_used_regs): Use anti_dependence.\n\t* function.c (assign_stack_temp_for_type): Don't use RTX_UNCHANGING_P.\n\t(assign_parm_setup_reg, expand_function_start): Likewise.\n\t* integrate.c (copy_rtx_and_substitute): Likewise.\n\t* ra-rewrite.c (emit_colors): Likewise.\n\t* regmove.c (copy_src_to_dest, regmove_optimize): Likewise.\n\t(fixup_match_1): Likewise.\n\t* reload1.c (reload, alter_reg): Likewise.\n\t* local-alloc.c (validate_equiv_mem): Check MEM_READONLY_P,\n\tnot RTX_UNCHANGING_P.\n\t(equiv_init_varies_p): Likewise.\n\t* loop-invariant.c (check_maybe_invariant): Likewise.\n\t* resource.c (mark_referenced_resources, mark_set_resources): Likewise.\n\t* loop.c (note_addr_stored): Likewise.\n\t(prescan_loop): Likewise. Don't check function usage for clobbered\n\tunchanging memory.\n\t* rtlanal.c (rtx_unstable_p): Check MEM_READONLY_P,\n        not RTX_UNCHANGING_P.\n\t(rtx_varies_p, modified_between_p, modified_in_p): Likewise.\n\t* varasm.c (force_const_mem): Likewise.\n\t* stmt.c (expand_decl): Don't set RTX_UNCHANGING_P.\n\t* web.c (entry_register): Likewise.\n\t* tree-gimple.h (get_base_address): Move decl ...\n\t* tree.h: ... here.\n\t* doc/rtl.texi (MEM_READONLY_P): Replace RTX_UNCHANGING_P.\n\n\t* config/alpha/alpha.c (alpha_set_memflags_1): Rewrite to be\n\tcalled via for_each_rtx.  Copy MEM_SCALAR_P, MEM_NOTRAP_P too.\n\t(alpha_set_memflags): Update to match.\n\n\t* config/darwin.c (machopic_indirect_data_reference): Set\n\tMEM_READONLY_P instead of RTX_UNCHANGING_P.\n\t(machopic_indirect_call_target): Likewise.\n\t(machopic_legitimize_pic_address): Likewise.\n\t* config/arm/arm.c (legitimize_pic_address, arm_gen_load_multiple,\n\tarm_gen_store_multiple, arm_gen_movmemqi): Likewise.\n\t* config/arm/arm.md (load_multiple, store_multiple): Likewise.\n\t* config/frv/frv.md (symGOT2reg): Likewise.\n\t* config/i386/i386.c (legitimize_pic_address,\n\tlegitimize_tls_address, ix86_split_to_parts): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_tls_address): Likewise.\n\t* config/ia64/ia64.md (load_fptr): Likewise.\n\t* config/m32r/m32r.c (m32r_legitimize_pic_address): Likewise.\n\t* config/m68k/m68k.c (legitimize_pic_address): Likewise.\n\t* config/mcore/mcore.c (block_move_sequence): Likewise.\n\t* config/mn10300/mn10300.md (symGOT2reg): Likewise.\n\t* config/pa/pa.c (legitimize_pic_address): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t* config/s390/s390.c (legitimize_pic_address): Likewise.\n\t(legitimize_tls_address): Likewise.\n\t* config/s390/s390.md (casesi): Likewise.\n\t* config/sh/sh.c (prepare_move_operands, sh_reorg): Likewise.\n\t* config/sh/sh.md (symGOT2reg): Likewise.\n\t* config/sparc/sparc.c (legitimize_pic_address): Likewise.\n\t* config/v850/v850.md (casesi): Likewise.\n\n\t* config/ia64/ia64.c (gen_thread_pointer): Don't set RTX_UNCHANGING_P.\n\t* config/iq2000/iq2000.c (save_restore_insns): Likewise.\n\t* config/mips/mips.c (mips_restore_gp): Likewise.\n\t(mips_save_restore_reg, mips16_gp_pseudo_reg): Likewise.\n\t* config/sh/sh.c (sh_reorg): Likewise.\n\nFrom-SVN: r86178", "tree": {"sha": "c1f08db698e4a92a83942e9db41831c4c159bfb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1f08db698e4a92a83942e9db41831c4c159bfb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/389fdba06a4469967a53ea92ffa86d1d090e3a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/389fdba06a4469967a53ea92ffa86d1d090e3a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/389fdba06a4469967a53ea92ffa86d1d090e3a7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/389fdba06a4469967a53ea92ffa86d1d090e3a7f/comments", "author": null, "committer": null, "parents": [{"sha": "17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ad5b5ec26d9c6d7edc84c89d69931552d138ff"}], "stats": {"total": 696, "additions": 238, "deletions": 458}, "files": [{"sha": "1a88c7f441be37d32bbe4bccacd8c17ec7471d44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1,3 +1,88 @@\n+2004-08-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (MEM_READONLY_P): Replace RTX_UNCHANGING_P.\n+\t* alias.c (true_dependence): Update to match new semantics.\n+\t(canon_true_dependence, write_dependence_p): Likewise.\n+\t(anti_dependence, output_dependence): Update write_dependence_p args.\n+\t(unchanging_anti_dependence): Remove.\n+\t* calls.c (purge_mem_unchanging_flag): Remove.\n+\t(fixup_tail_calls): Don't call it.\n+\t(expand_call): Don't add unchanging memory to function usage.\n+\t* expr.c (emit_block_move_via_libcall): Likewise.\n+\t(clear_storage_via_libcall): Don't clobber RTX_UNCHANGING_P mems.\n+\t(get_subtarget): Don't use RTX_UNCHANGING_P.\n+\t(expand_assignment, store_constructor, expand_expr_real_1): Likewise.\n+\t(do_tablejump): Set MEM_READONLY_P, not RTX_UNCHANGING_P.\n+\t* combine.c (get_last_value_validate): Use MEM_READONLY_P.\n+\t* cse.c (insert): Don't use RTX_UNCHANGING_P.\n+\t(cse_insn, canon_hash): Use MEM_READONLY_P.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Use MEM_READONLY_P\n+\tinstead of RTX_UNCHANGING_P.\n+\t* explow.c (maybe_set_unchanging): Remove.\n+\t* expr.h (maybe_set_unchanging): Remove.\n+\t* flow.c (insn_dead_p, mark_used_regs): Use anti_dependence.\n+\t* function.c (assign_stack_temp_for_type): Don't use RTX_UNCHANGING_P.\n+\t(assign_parm_setup_reg, expand_function_start): Likewise.\n+\t* integrate.c (copy_rtx_and_substitute): Likewise.\n+\t* ra-rewrite.c (emit_colors): Likewise.\n+\t* regmove.c (copy_src_to_dest, regmove_optimize): Likewise.\n+\t(fixup_match_1): Likewise.\n+\t* reload1.c (reload, alter_reg): Likewise.\n+\t* local-alloc.c (validate_equiv_mem): Check MEM_READONLY_P,\n+\tnot RTX_UNCHANGING_P.\n+\t(equiv_init_varies_p): Likewise.\n+\t* loop-invariant.c (check_maybe_invariant): Likewise.\n+\t* resource.c (mark_referenced_resources, mark_set_resources): Likewise.\n+\t* loop.c (note_addr_stored): Likewise.\n+\t(prescan_loop): Likewise. Don't check function usage for clobbered\n+\tunchanging memory.\n+\t* rtlanal.c (rtx_unstable_p): Check MEM_READONLY_P,\n+        not RTX_UNCHANGING_P.\n+\t(rtx_varies_p, modified_between_p, modified_in_p): Likewise.\n+\t* varasm.c (force_const_mem): Likewise.\n+\t* stmt.c (expand_decl): Don't set RTX_UNCHANGING_P.\n+\t* web.c (entry_register): Likewise.\n+\t* tree-gimple.h (get_base_address): Move decl ...\n+\t* tree.h: ... here.\n+\t* doc/rtl.texi (MEM_READONLY_P): Replace RTX_UNCHANGING_P.\n+\n+\t* config/alpha/alpha.c (alpha_set_memflags_1): Rewrite to be\n+\tcalled via for_each_rtx.  Copy MEM_SCALAR_P, MEM_NOTRAP_P too.\n+\t(alpha_set_memflags): Update to match.\n+\n+\t* config/darwin.c (machopic_indirect_data_reference): Set\n+\tMEM_READONLY_P instead of RTX_UNCHANGING_P.\n+\t(machopic_indirect_call_target): Likewise.\n+\t(machopic_legitimize_pic_address): Likewise.\n+\t* config/arm/arm.c (legitimize_pic_address, arm_gen_load_multiple, \n+\tarm_gen_store_multiple, arm_gen_movmemqi): Likewise.\n+\t* config/arm/arm.md (load_multiple, store_multiple): Likewise.\n+\t* config/frv/frv.md (symGOT2reg): Likewise.\n+\t* config/i386/i386.c (legitimize_pic_address,\n+\tlegitimize_tls_address, ix86_split_to_parts): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_tls_address): Likewise.\n+\t* config/ia64/ia64.md (load_fptr): Likewise.\n+\t* config/m32r/m32r.c (m32r_legitimize_pic_address): Likewise.\n+\t* config/m68k/m68k.c (legitimize_pic_address): Likewise.\n+\t* config/mcore/mcore.c (block_move_sequence): Likewise.\n+\t* config/mn10300/mn10300.md (symGOT2reg): Likewise.\n+\t* config/pa/pa.c (legitimize_pic_address): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_tls_address): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t* config/s390/s390.c (legitimize_pic_address): Likewise.\n+\t(legitimize_tls_address): Likewise.\n+\t* config/s390/s390.md (casesi): Likewise.\n+\t* config/sh/sh.c (prepare_move_operands, sh_reorg): Likewise.\n+\t* config/sh/sh.md (symGOT2reg): Likewise.\n+\t* config/sparc/sparc.c (legitimize_pic_address): Likewise.\n+\t* config/v850/v850.md (casesi): Likewise.\n+\n+\t* config/ia64/ia64.c (gen_thread_pointer): Don't set RTX_UNCHANGING_P.\n+\t* config/iq2000/iq2000.c (save_restore_insns): Likewise.\n+\t* config/mips/mips.c (mips_restore_gp): Likewise.\n+\t(mips_save_restore_reg, mips16_gp_pseudo_reg): Likewise.\n+\t* config/sh/sh.c (sh_reorg): Likewise.\n+\n 2004-08-18  Richard Henderson  <rth@redhat.com>\n \n \t* tree.h (struct tree_decl): Add gimple_formal_temp."}, {"sha": "57bc38d3c5927c86a84f35002ea10ea8a16fcb43", "filename": "gcc/alias.c", "status": "modified", "additions": 16, "deletions": 46, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -113,7 +113,7 @@ static bool nonoverlapping_component_refs_p (tree, tree);\n static tree decl_for_component_ref (tree);\n static rtx adjust_offset_for_component_ref (tree, rtx);\n static int nonoverlapping_memrefs_p (rtx, rtx);\n-static int write_dependence_p (rtx, rtx, int, int);\n+static int write_dependence_p (rtx, rtx, int);\n \n static int nonlocal_mentioned_p_1 (rtx *, void *);\n static int nonlocal_mentioned_p (rtx);\n@@ -2173,17 +2173,10 @@ true_dependence (rtx mem, enum machine_mode mem_mode, rtx x,\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n-  /* Unchanging memory can't conflict with non-unchanging memory.\n-     A non-unchanging read can conflict with a non-unchanging write.\n-     An unchanging read can conflict with an unchanging write since\n-     there may be a single store to this address to initialize it.\n-     Note that an unchanging store can conflict with a non-unchanging read\n-     since we have to make conservative assumptions when we have a\n-     record with readonly fields and we are copying the whole thing.\n-     Just fall through to the code below to resolve potential conflicts.\n-     This won't handle all cases optimally, but the possible performance\n-     loss should be negligible.  */\n-  if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n+  /* Read-only memory is by definition never modified, and therefore can't\n+     conflict with anything.  We don't expect to find read-only set on MEM,\n+     but stupid user tricks can produce them, so don't abort.  */\n+  if (MEM_READONLY_P (x))\n     return 0;\n \n   if (nonoverlapping_memrefs_p (mem, x))\n@@ -2253,14 +2246,10 @@ canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n-  /* If X is an unchanging read, then it can't possibly conflict with any\n-     non-unchanging store.  It may conflict with an unchanging write though,\n-     because there may be a single store to this address to initialize it.\n-     Just fall through to the code below to resolve the case where we have\n-     both an unchanging read and an unchanging write.  This won't handle all\n-     cases optimally, but the possible performance loss should be\n-     negligible.  */\n-  if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n+  /* Read-only memory is by definition never modified, and therefore can't\n+     conflict with anything.  We don't expect to find read-only set on MEM,\n+     but stupid user tricks can produce them, so don't abort.  */\n+  if (MEM_READONLY_P (x))\n     return 0;\n \n   if (nonoverlapping_memrefs_p (x, mem))\n@@ -2294,11 +2283,10 @@ canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n }\n \n /* Returns nonzero if a write to X might alias a previous read from\n-   (or, if WRITEP is nonzero, a write to) MEM.  If CONSTP is nonzero,\n-   honor the RTX_UNCHANGING_P flags on X and MEM.  */\n+   (or, if WRITEP is nonzero, a write to) MEM.  */\n \n static int\n-write_dependence_p (rtx mem, rtx x, int writep, int constp)\n+write_dependence_p (rtx mem, rtx x, int writep)\n {\n   rtx x_addr, mem_addr;\n   rtx fixed_scalar;\n@@ -2317,18 +2305,9 @@ write_dependence_p (rtx mem, rtx x, int writep, int constp)\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n-  if (constp)\n-    {\n-      /* Unchanging memory can't conflict with non-unchanging memory.  */\n-      if (RTX_UNCHANGING_P (x) != RTX_UNCHANGING_P (mem))\n-\treturn 0;\n-\n-      /* If MEM is an unchanging read, then it can't possibly conflict with\n-\t the store to X, because there is at most one store to MEM, and it\n-\t must have occurred somewhere before MEM.  */\n-      if (! writep && RTX_UNCHANGING_P (mem))\n-\treturn 0;\n-    }\n+  /* A read from read-only memory can't conflict with read-write memory.  */\n+  if (!writep && MEM_READONLY_P (mem))\n+    return 0;\n \n   if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n@@ -2369,24 +2348,15 @@ write_dependence_p (rtx mem, rtx x, int writep, int constp)\n int\n anti_dependence (rtx mem, rtx x)\n {\n-  return write_dependence_p (mem, x, /*writep=*/0, /*constp*/1);\n+  return write_dependence_p (mem, x, /*writep=*/0);\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n \n int\n output_dependence (rtx mem, rtx x)\n {\n-  return write_dependence_p (mem, x, /*writep=*/1, /*constp*/1);\n-}\n-\n-/* Unchanging anti dependence: Like anti_dependence but ignores\n-   the UNCHANGING_RTX_P property on const variable references.  */\n-\n-int\n-unchanging_anti_dependence (rtx mem, rtx x)\n-{\n-  return write_dependence_p (mem, x, /*writep=*/0, /*constp*/0);\n+  return write_dependence_p (mem, x, /*writep=*/1);\n }\n \f\n /* A subroutine of nonlocal_mentioned_p, returns 1 if *LOC mentions"}, {"sha": "592f8bc2bf65ce47d86e8aa200f03bb5db1900f7", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1785,45 +1785,6 @@ purge_reg_equiv_notes (void)\n     }\n }\n \n-/* Clear RTX_UNCHANGING_P flag of incoming argument MEMs.  */\n-\n-static void\n-purge_mem_unchanging_flag (rtx x)\n-{\n-  RTX_CODE code;\n-  int i, j;\n-  const char *fmt;\n-\n-  if (x == NULL_RTX)\n-    return;\n-\n-  code = GET_CODE (x);\n-\n-  if (code == MEM)\n-    {\n-      if (RTX_UNCHANGING_P (x)\n-\t  && (XEXP (x, 0) == current_function_internal_arg_pointer\n-\t      || (GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t  && XEXP (XEXP (x, 0), 0) ==\n-\t\t     current_function_internal_arg_pointer\n-\t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n-\tRTX_UNCHANGING_P (x) = 0;\n-      return;\n-    }\n-\n-  /* Scan all subexpressions.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n-    {\n-      if (*fmt == 'e')\n-\tpurge_mem_unchanging_flag (XEXP (x, i));\n-      else if (*fmt == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  purge_mem_unchanging_flag (XVECEXP (x, i, j));\n-    }\n-}\n-\n-\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -3004,22 +2965,6 @@ expand_call (tree exp, rtx target, int ignore)\n \tif (args[i].aligned_regs)\n \t  free (args[i].aligned_regs);\n \n-      /* If this function is returning into a memory location marked as\n-\t readonly, it means it is initializing that location. We normally treat\n-\t functions as not clobbering such locations, so we need to specify that\n-\t this one does. We do this by adding the appropriate CLOBBER to the\n-\t CALL_INSN function usage list.  This cannot be done by emitting a\n-\t standalone CLOBBER after the call because the latter would be ignored\n-\t by at least the delay slot scheduling pass. We do this now instead of\n-\t adding to call_fusage before the call to emit_call_1 because TARGET\n-\t may be modified in the meantime.  */\n-      if (structure_value_addr != 0 && target != 0\n-\t  && MEM_P (target) && RTX_UNCHANGING_P (target))\n-\tadd_function_usage_to\n-\t  (last_call_insn (),\n-\t   gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_CLOBBER (VOIDmode, target),\n-\t\t\t      NULL_RTX));\n-\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -3100,32 +3045,7 @@ expand_call (tree exp, rtx target, int ignore)\n void\n fixup_tail_calls (void)\n {\n-  rtx insn;\n-  tree arg;\n-\n   purge_reg_equiv_notes ();\n-\n-  /* A sibling call sequence also may invalidate RTX_UNCHANGING_P\n-     flag of some incoming arguments MEM RTLs, because it can write into\n-     those slots.  We clear all those bits now.\n-\n-     This is (slight) overkill, we could keep track of which arguments\n-     we actually write into.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\tpurge_mem_unchanging_flag (PATTERN (insn));\n-    }\n-\n-  /* Similarly, invalidate RTX_UNCHANGING_P for any incoming\n-     arguments passed in registers.  */\n-  for (arg = DECL_ARGUMENTS (current_function_decl);\n-       arg;\n-       arg = TREE_CHAIN (arg))\n-    {\n-      if (REG_P (DECL_RTL (arg)))\n-\tRTX_UNCHANGING_P (DECL_RTL (arg)) = false;\n-    }\n }\n \n /* Traverse an argument list in VALUES and expand all complex"}, {"sha": "3db1d7d25027704b9cb7e9cfeed83b28af2674f3", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -11053,7 +11053,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n   /* If this is a memory reference, make sure that there were\n      no stores after it that might have clobbered the value.  We don't\n      have alias info, so we assume any store invalidates it.  */\n-  else if (MEM_P (x) && ! RTX_UNCHANGING_P (x)\n+  else if (MEM_P (x) && !MEM_READONLY_P (x)\n \t   && INSN_CUID (insn) <= mem_last_set)\n     {\n       if (replace)"}, {"sha": "6252e888c800e777081467803a46ead1f1f3fa79", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1589,48 +1589,27 @@ secondary_reload_class (enum reg_class class, enum machine_mode mode,\n /* Subfunction of the following function.  Update the flags of any MEM\n    found in part of X.  */\n \n-static void\n-alpha_set_memflags_1 (rtx x, int in_struct_p, int volatile_p, int unchanging_p)\n+static int\n+alpha_set_memflags_1 (rtx *xp, void *data)\n {\n-  int i;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SEQUENCE:\n-      abort ();\n-\n-    case PARALLEL:\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\talpha_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p,\n-\t\t\t      unchanging_p);\n-      break;\n+  rtx x = *xp, orig = (rtx) data;\n \n-    case INSN:\n-      alpha_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p);\n-      break;\n+  if (GET_CODE (x) != MEM)\n+    return 0;\n \n-    case SET:\n-      alpha_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p);\n-      alpha_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p);\n-      break;\n+  MEM_VOLATILE_P (x) = MEM_VOLATILE_P (orig);\n+  MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (orig);\n+  MEM_SCALAR_P (x) = MEM_SCALAR_P (orig);\n+  MEM_NOTRAP_P (x) = MEM_NOTRAP_P (orig);\n+  MEM_READONLY_P (x) = MEM_READONLY_P (orig);\n \n-    case MEM:\n-      MEM_IN_STRUCT_P (x) = in_struct_p;\n-      MEM_VOLATILE_P (x) = volatile_p;\n-      RTX_UNCHANGING_P (x) = unchanging_p;\n-      /* Sadly, we cannot use alias sets because the extra aliasing\n-\t produced by the AND interferes.  Given that two-byte quantities\n-\t are the only thing we would be able to differentiate anyway,\n-\t there does not seem to be any point in convoluting the early\n-\t out of the alias check.  */\n-      break;\n+  /* Sadly, we cannot use alias sets because the extra aliasing\n+     produced by the AND interferes.  Given that two-byte quantities\n+     are the only thing we would be able to differentiate anyway,\n+     there does not seem to be any point in convoluting the early\n+     out of the alias check.  */\n \n-    default:\n-      break;\n-    }\n+  return -1;\n }\n \n /* Given INSN, which is an INSN list or the PATTERN of a single insn\n@@ -1642,22 +1621,26 @@ alpha_set_memflags_1 (rtx x, int in_struct_p, int volatile_p, int unchanging_p)\n void\n alpha_set_memflags (rtx insn, rtx ref)\n {\n-  int in_struct_p, volatile_p, unchanging_p;\n+  rtx *base_ptr;\n \n   if (GET_CODE (ref) != MEM)\n     return;\n \n-  in_struct_p = MEM_IN_STRUCT_P (ref);\n-  volatile_p = MEM_VOLATILE_P (ref);\n-  unchanging_p = RTX_UNCHANGING_P (ref);\n-\n   /* This is only called from alpha.md, after having had something \n      generated from one of the insn patterns.  So if everything is\n      zero, the pattern is already up-to-date.  */\n-  if (! in_struct_p && ! volatile_p && ! unchanging_p)\n+  if (!MEM_VOLATILE_P (ref)\n+      && !MEM_IN_STRUCT_P (ref)\n+      && !MEM_SCALAR_P (ref)\n+      && !MEM_NOTRAP_P (ref)\n+      && !MEM_READONLY_P (ref))\n     return;\n \n-  alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p);\n+  if (INSN_P (insn))\n+    base_ptr = &PATTERN (insn);\n+  else\n+    base_ptr = &insn;\n+  for_each_rtx (base_ptr, alpha_set_memflags_1, (void *) ref);\n }\n \f\n /* Internal routine for alpha_emit_set_const to check for N or below insns.  */"}, {"sha": "fb96c38ab5245c517e58655d5a5648033805a92f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2924,7 +2924,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t  pic_ref = gen_rtx_MEM (Pmode,\n \t\t\t\t gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n \t\t\t\t\t       address));\n-\t  RTX_UNCHANGING_P (pic_ref) = 1;\n+\t  MEM_READONLY_P (pic_ref) = 1;\n \t}\n \n       insn = emit_move_insn (reg, pic_ref);\n@@ -5939,7 +5939,7 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n       for (i = 0; i < count; i++)\n \t{\n \t  mem = gen_rtx_MEM (SImode, plus_constant (from, i * 4 * sign));\n-\t  RTX_UNCHANGING_P (mem) = unchanging_p;\n+\t  MEM_READONLY_P (mem) = unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = in_struct_p;\n \t  MEM_SCALAR_P (mem) = scalar_p;\n \t  emit_move_insn (gen_rtx_REG (SImode, base_regno + i), mem);\n@@ -5968,7 +5968,7 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n   for (j = 0; i < count; i++, j++)\n     {\n       mem = gen_rtx_MEM (SImode, plus_constant (from, j * 4 * sign));\n-      RTX_UNCHANGING_P (mem) = unchanging_p;\n+      MEM_READONLY_P (mem) = unchanging_p;\n       MEM_IN_STRUCT_P (mem) = in_struct_p;\n       MEM_SCALAR_P (mem) = scalar_p;\n       XVECEXP (result, 0, i)\n@@ -5999,7 +5999,7 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n       for (i = 0; i < count; i++)\n \t{\n \t  mem = gen_rtx_MEM (SImode, plus_constant (to, i * 4 * sign));\n-\t  RTX_UNCHANGING_P (mem) = unchanging_p;\n+\t  MEM_READONLY_P (mem) = unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = in_struct_p;\n \t  MEM_SCALAR_P (mem) = scalar_p;\n \t  emit_move_insn (mem, gen_rtx_REG (SImode, base_regno + i));\n@@ -6028,7 +6028,7 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n   for (j = 0; i < count; i++, j++)\n     {\n       mem = gen_rtx_MEM (SImode, plus_constant (to, j * 4 * sign));\n-      RTX_UNCHANGING_P (mem) = unchanging_p;\n+      MEM_READONLY_P (mem) = unchanging_p;\n       MEM_IN_STRUCT_P (mem) = in_struct_p;\n       MEM_SCALAR_P (mem) = scalar_p;\n \n@@ -6060,10 +6060,10 @@ arm_gen_movmemqi (rtx *operands)\n   st_dst = XEXP (operands[0], 0);\n   st_src = XEXP (operands[1], 0);\n \n-  dst_unchanging_p = RTX_UNCHANGING_P (operands[0]);\n+  dst_unchanging_p = MEM_READONLY_P (operands[0]);\n   dst_in_struct_p = MEM_IN_STRUCT_P (operands[0]);\n   dst_scalar_p = MEM_SCALAR_P (operands[0]);\n-  src_unchanging_p = RTX_UNCHANGING_P (operands[1]);\n+  src_unchanging_p = MEM_READONLY_P (operands[1]);\n   src_in_struct_p = MEM_IN_STRUCT_P (operands[1]);\n   src_scalar_p = MEM_SCALAR_P (operands[1]);\n \n@@ -6107,7 +6107,7 @@ arm_gen_movmemqi (rtx *operands)\n \t  else\n \t    {\n \t      mem = gen_rtx_MEM (SImode, dst);\n-\t      RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t      MEM_READONLY_P (mem) = dst_unchanging_p;\n \t      MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n \t      MEM_SCALAR_P (mem) = dst_scalar_p;\n \t      emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n@@ -6126,14 +6126,14 @@ arm_gen_movmemqi (rtx *operands)\n       rtx sreg;\n       \n       mem = gen_rtx_MEM (SImode, src);\n-      RTX_UNCHANGING_P (mem) = src_unchanging_p;\n+      MEM_READONLY_P (mem) = src_unchanging_p;\n       MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n       MEM_SCALAR_P (mem) = src_scalar_p;\n       emit_move_insn (sreg = gen_reg_rtx (SImode), mem);\n       emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n       \n       mem = gen_rtx_MEM (SImode, dst);\n-      RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+      MEM_READONLY_P (mem) = dst_unchanging_p;\n       MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n       MEM_SCALAR_P (mem) = dst_scalar_p;\n       emit_move_insn (mem, sreg);\n@@ -6150,7 +6150,7 @@ arm_gen_movmemqi (rtx *operands)\n \tabort ();\n \n       mem = gen_rtx_MEM (SImode, src);\n-      RTX_UNCHANGING_P (mem) = src_unchanging_p;\n+      MEM_READONLY_P (mem) = src_unchanging_p;\n       MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n       MEM_SCALAR_P (mem) = src_scalar_p;\n       part_bytes_reg = copy_to_mode_reg (SImode, mem);\n@@ -6171,7 +6171,7 @@ arm_gen_movmemqi (rtx *operands)\n       while (last_bytes)\n \t{\n \t  mem = gen_rtx_MEM (QImode, plus_constant (dst, last_bytes - 1));\n-\t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t  MEM_READONLY_P (mem) = dst_unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n \t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_lowpart (QImode, part_bytes_reg));\n@@ -6190,7 +6190,7 @@ arm_gen_movmemqi (rtx *operands)\n       if (last_bytes > 1)\n \t{\n \t  mem = gen_rtx_MEM (HImode, dst);\n-\t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t  MEM_READONLY_P (mem) = dst_unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n \t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_lowpart (HImode, part_bytes_reg));\n@@ -6208,7 +6208,7 @@ arm_gen_movmemqi (rtx *operands)\n       if (last_bytes)\n \t{\n \t  mem = gen_rtx_MEM (QImode, dst);\n-\t  RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+\t  MEM_READONLY_P (mem) = dst_unchanging_p;\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n \t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_lowpart (QImode, part_bytes_reg));"}, {"sha": "6346960330dfe296ddefda47a07f3db1ffdae620", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -5258,8 +5258,8 @@\n   operands[3]\n     = arm_gen_load_multiple (REGNO (operands[0]), INTVAL (operands[2]),\n \t\t\t     force_reg (SImode, XEXP (operands[1], 0)),\n-\t\t\t     TRUE, FALSE, RTX_UNCHANGING_P(operands[1]),\n-\t\t\t     MEM_IN_STRUCT_P(operands[1]),\n+\t\t\t     TRUE, FALSE, MEM_READONLY_P (operands[1]),\n+\t\t\t     MEM_IN_STRUCT_P (operands[1]),\n \t                     MEM_SCALAR_P (operands[1]));\n   \"\n )\n@@ -5380,8 +5380,8 @@\n   operands[3]\n     = arm_gen_store_multiple (REGNO (operands[1]), INTVAL (operands[2]),\n \t\t\t      force_reg (SImode, XEXP (operands[0], 0)),\n-\t\t\t      TRUE, FALSE, RTX_UNCHANGING_P (operands[0]),\n-\t\t\t      MEM_IN_STRUCT_P(operands[0]), \n+\t\t\t      TRUE, FALSE, MEM_READONLY_P (operands[0]),\n+\t\t\t      MEM_IN_STRUCT_P (operands[0]), \n \t                      MEM_SCALAR_P (operands[0]));\n   \"\n )"}, {"sha": "e3a4cfd82e5dccefa72d4686c98dc0f4668a05ce", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -385,7 +385,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n      SYMBOL_REF_DECL (ptr_ref) = SYMBOL_REF_DECL (orig);\n \n       ptr_ref = gen_rtx_MEM (Pmode, ptr_ref);\n-      RTX_UNCHANGING_P (ptr_ref) = 1;\n+      MEM_READONLY_P (ptr_ref) = 1;\n \n       return ptr_ref;\n     }\n@@ -469,7 +469,7 @@ machopic_indirect_call_target (rtx target)\n       \n       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);\n       SYMBOL_REF_DECL (XEXP (target, 0)) = decl;\n-      RTX_UNCHANGING_P (target) = 1;\n+      MEM_READONLY_P (target) = 1;\n     }\n \n   return target;\n@@ -532,7 +532,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t      emit_insn (gen_macho_high (temp_reg, asym));\n \t      mem = gen_rtx_MEM (GET_MODE (orig),\n \t\t\t\t gen_rtx_LO_SUM (Pmode, temp_reg, asym));\n-\t      RTX_UNCHANGING_P (mem) = 1;\n+\t      MEM_READONLY_P (mem) = 1;\n \t      emit_insn (gen_rtx_SET (VOIDmode, reg, mem));\n #else\n \t      /* Some other CPU -- WriteMe! but right now there are no other platform that can use dynamic-no-pic  */\n@@ -565,7 +565,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t      mem = gen_rtx_MEM (GET_MODE (orig),\n \t\t\t\t gen_rtx_LO_SUM (Pmode, \n \t\t\t\t\t\t hi_sum_reg, offset));\n-\t      RTX_UNCHANGING_P (mem) = 1;\n+\t      MEM_READONLY_P (mem) = 1;\n \t      insn = emit_insn (gen_rtx_SET (VOIDmode, reg, mem));\n \t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, pic_ref, \n \t\t\t\t\t\t    REG_NOTES (insn));\n@@ -614,7 +614,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t  emit_move_insn (reg, pic_ref);\n \t  pic_ref = gen_rtx_MEM (GET_MODE (orig), reg);\n #endif\n-\t  RTX_UNCHANGING_P (pic_ref) = 1;\n+\t  MEM_READONLY_P (pic_ref) = 1;\n \t}\n       else\n \t{\n@@ -650,15 +650,13 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t\t\t      gen_rtx_LO_SUM (Pmode,\n \t\t\t\t\t\t      hi_sum_reg, offset)));\n \t      pic_ref = reg;\n-\t      RTX_UNCHANGING_P (pic_ref) = 1;\n #else\n \t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t\t      gen_rtx_HIGH (Pmode, offset)));\n \t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t\t      gen_rtx_LO_SUM (Pmode, reg, offset)));\n \t      pic_ref = gen_rtx_PLUS (Pmode,\n \t\t\t\t      pic_offset_table_rtx, reg);\n-\t      RTX_UNCHANGING_P (pic_ref) = 1;\n #endif\n \t    }\n \t  else\n@@ -732,9 +730,6 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       else\n \tpic_ref = gen_rtx_PLUS (Pmode, base, orig);\n \n-      if (RTX_UNCHANGING_P (base) && RTX_UNCHANGING_P (orig))\n-\tRTX_UNCHANGING_P (pic_ref) = 1;\n-\n       if (reg && is_complex)\n \t{\n \t  emit_move_insn (reg, pic_ref);\n@@ -752,9 +747,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t   && GET_CODE (XEXP (orig, 0)) == SYMBOL_REF)\n     {\n       rtx addr = machopic_legitimize_pic_address (XEXP (orig, 0), Pmode, reg);\n-\n-      addr = gen_rtx_MEM (GET_MODE (orig), addr);\n-      RTX_UNCHANGING_P (addr) = RTX_UNCHANGING_P (orig);\n+      addr = replace_equiv_address (orig, addr);\n       emit_move_insn (reg, addr);\n       pic_ref = reg;\n     }"}, {"sha": "c77472d89014013975b4234fc11b29a9a1ae6047", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -7719,7 +7719,7 @@\n \n   insn = emit_insn (gen_symGOT2reg_i (operands[0], operands[1], operands[2], operands[3]));\n \n-  RTX_UNCHANGING_P (SET_SRC (PATTERN (insn))) = 1;\n+  MEM_READONLY_P (SET_SRC (PATTERN (insn))) = 1;\n \n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n \t\t\t\t\tREG_NOTES (insn));"}, {"sha": "908076721699883f69c963ea57fc63ce7fd5949c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -5307,7 +5307,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTPCREL);\n \t  new = gen_rtx_CONST (Pmode, new);\n \t  new = gen_rtx_MEM (Pmode, new);\n-\t  RTX_UNCHANGING_P (new) = 1;\n+\t  MEM_READONLY_P (new) = 1;\n \t  set_mem_alias_set (new, ix86_GOT_alias_set ());\n \n \t  if (reg == 0)\n@@ -5329,7 +5329,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  new = gen_rtx_CONST (Pmode, new);\n \t  new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \t  new = gen_rtx_MEM (Pmode, new);\n-\t  RTX_UNCHANGING_P (new) = 1;\n+\t  MEM_READONLY_P (new) = 1;\n \t  set_mem_alias_set (new, ix86_GOT_alias_set ());\n \n \t  if (reg == 0)\n@@ -5509,7 +5509,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n       if (pic)\n \toff = gen_rtx_PLUS (Pmode, pic, off);\n       off = gen_rtx_MEM (Pmode, off);\n-      RTX_UNCHANGING_P (off) = 1;\n+      MEM_READONLY_P (off) = 1;\n       set_mem_alias_set (off, ix86_GOT_alias_set ());\n \n       if (TARGET_64BIT || TARGET_GNU_TLS)\n@@ -9552,7 +9552,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \n   /* Optimize constant pool reference to immediates.  This is used by fp\n      moves, that force all constants to memory to allow combining.  */\n-  if (GET_CODE (operand) == MEM && RTX_UNCHANGING_P (operand))\n+  if (GET_CODE (operand) == MEM && MEM_READONLY_P (operand))\n     {\n       rtx tmp = maybe_get_pool_constant (operand);\n       if (tmp)"}, {"sha": "f786f335404d1a9e2d7aeef5c300fb7547bf303e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -669,10 +669,7 @@ static rtx\n gen_thread_pointer (void)\n {\n   if (!thread_pointer_rtx)\n-    {\n-      thread_pointer_rtx = gen_rtx_REG (Pmode, 13);\n-      RTX_UNCHANGING_P (thread_pointer_rtx) = 1;\n-    }\n+    thread_pointer_rtx = gen_rtx_REG (Pmode, 13);\n   return thread_pointer_rtx;\n }\n \n@@ -690,12 +687,12 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n       tga_op1 = gen_reg_rtx (Pmode);\n       emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n       tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n-      RTX_UNCHANGING_P (tga_op1) = 1;\n+      MEM_READONLY_P (tga_op1) = 1;\n \n       tga_op2 = gen_reg_rtx (Pmode);\n       emit_insn (gen_load_ltoff_dtprel (tga_op2, op1));\n       tga_op2 = gen_rtx_MEM (Pmode, tga_op2);\n-      RTX_UNCHANGING_P (tga_op2) = 1;\n+      MEM_READONLY_P (tga_op2) = 1;\n \n       tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n \t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n@@ -719,7 +716,7 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n       tga_op1 = gen_reg_rtx (Pmode);\n       emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n       tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n-      RTX_UNCHANGING_P (tga_op1) = 1;\n+      MEM_READONLY_P (tga_op1) = 1;\n \n       tga_op2 = const0_rtx;\n \n@@ -750,7 +747,7 @@ ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1)\n       tmp = gen_reg_rtx (Pmode);\n       emit_insn (gen_load_ltoff_tprel (tmp, op1));\n       tmp = gen_rtx_MEM (Pmode, tmp);\n-      RTX_UNCHANGING_P (tmp) = 1;\n+      MEM_READONLY_P (tmp) = 1;\n       tmp = force_reg (Pmode, tmp);\n \n       if (!register_operand (op0, Pmode))"}, {"sha": "8b3cfdbdbf6db4752b74946868dc6a6655276b5c", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -719,7 +719,7 @@\n {\n   operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (DImode);\n   operands[3] = gen_rtx_MEM (DImode, operands[2]);\n-  RTX_UNCHANGING_P (operands[3]) = 1;\n+  MEM_READONLY_P (operands[3]) = 1;\n })\n \n (define_insn \"*load_fptr_internal1\""}, {"sha": "ece7021b1616b9afc8b696b61c04f9e201a9c80e", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2084,9 +2084,6 @@ save_restore_insns (int store_p)\n \t\t       gen_rtx_PLUS (Pmode, base_reg_rtx,\n \t\t\t\tGEN_INT (gp_offset - base_offset)));\n \n-\t  if (! current_function_calls_eh_return)\n-\t    RTX_UNCHANGING_P (mem_rtx) = 1;\n-\n \t  reg_rtx = gen_rtx_REG (gpr_mode, regno);\n \n \t  if (store_p)"}, {"sha": "191d0a73640a3e77e8633a24cc9b409da32657d7", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1995,7 +1995,7 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n       emit_insn (gen_addsi3 (address, address, pic_offset_table_rtx));\n       pic_ref = gen_rtx_MEM (Pmode, address);\n \n-      RTX_UNCHANGING_P (pic_ref) = 1;\n+      MEM_READONLY_P (pic_ref) = 1;\n       insn = emit_move_insn (reg, pic_ref);\n       current_function_uses_pic_offset_table = 1;\n #if 0"}, {"sha": "088714c4a6986eaeea6caf18153a14ae1fa04519", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1383,7 +1383,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     gen_rtx_PLUS (Pmode,\n \t\t\t\t\t   pic_offset_table_rtx, orig));\n       current_function_uses_pic_offset_table = 1;\n-      RTX_UNCHANGING_P (pic_ref) = 1;\n+      MEM_READONLY_P (pic_ref) = 1;\n       emit_move_insn (reg, pic_ref);\n       return reg;\n     }"}, {"sha": "3d9d6d88ee0588f7e7a6aa22b4775062cee9d4c9", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1882,7 +1882,7 @@ block_move_sequence (rtx dest, rtx dst_mem, rtx src, rtx src_mem,\n #endif\n \t\t\t  gen_rtx_PLUS (Pmode, src, GEN_INT (offset_ld)));\n \t  \n-\t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n+\t  MEM_READONLY_P (srcp) = MEM_READONLY_P (src_mem);\n \t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n \t  MEM_IN_STRUCT_P (srcp) = 1;\n \t  emit_insn (gen_rtx_SET (VOIDmode, temp[next], srcp));\n@@ -1902,7 +1902,7 @@ block_move_sequence (rtx dest, rtx dst_mem, rtx src, rtx src_mem,\n #endif\n \t\t\t  gen_rtx_PLUS (Pmode, dest, GEN_INT (offset_st)));\n \t  \n-\t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dst_mem);\n+\t  MEM_READONLY_P (dstp) = MEM_READONLY_P (dst_mem);\n \t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dst_mem);\n \t  MEM_IN_STRUCT_P (dstp) = 1;\n \t  emit_insn (gen_rtx_SET (VOIDmode, dstp, temp[phase]));"}, {"sha": "08e38caa708e014cfa194e39b2f942bd146d2b9d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2342,7 +2342,6 @@ mips_restore_gp (void)\n \t\t\t     : stack_pointer_rtx,\n \t\t\t     current_function_outgoing_args_size);\n   slot = gen_rtx_MEM (Pmode, address);\n-  RTX_UNCHANGING_P (slot) = 1;\n \n   emit_move_insn (pic_offset_table_rtx, slot);\n   if (!TARGET_EXPLICIT_RELOCS)\n@@ -5801,8 +5800,6 @@ mips_save_restore_reg (enum machine_mode mode, int regno,\n   rtx mem;\n \n   mem = gen_rtx_MEM (mode, plus_constant (stack_pointer_rtx, offset));\n-  if (!current_function_calls_eh_return)\n-    RTX_UNCHANGING_P (mem) = 1;\n \n   fn (gen_rtx_REG (mode, regno), mem);\n }\n@@ -6980,7 +6977,6 @@ mips16_gp_pseudo_reg (void)\n       rtx insn, scan;\n \n       cfun->machine->mips16_gp_pseudo_rtx = gen_reg_rtx (Pmode);\n-      RTX_UNCHANGING_P (cfun->machine->mips16_gp_pseudo_rtx) = 1;\n \n       /* We want to initialize this to a value which gcc will believe\n          is constant.  */"}, {"sha": "d6bf5409928ab6e9ee4c74c9df6d18c3a1a7d2ca", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2633,7 +2633,7 @@\n {\n   rtx insn = emit_insn (gen_symGOT2reg_i (operands[0], operands[1]));\n \n-  RTX_UNCHANGING_P (SET_SRC (PATTERN (insn))) = 1;\n+  MEM_READONLY_P (SET_SRC (PATTERN (insn))) = 1;\n \n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n \t\t\t\t\tREG_NOTES (insn));"}, {"sha": "d1ed7182e7a0f58145ebd800c97f3609d1d11ac2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1021,7 +1021,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n       current_function_uses_pic_offset_table = 1;\n       MEM_NOTRAP_P (pic_ref) = 1;\n-      RTX_UNCHANGING_P (pic_ref) = 1;\n+      MEM_READONLY_P (pic_ref) = 1;\n       mark_reg_pointer (reg, BITS_PER_UNIT);\n       insn = emit_move_insn (reg, pic_ref);\n "}, {"sha": "0c38a602f9ced8b9bbccfd68c13cde40c15b9dd4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -3458,7 +3458,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t\t  tmp2 = gen_reg_rtx (Pmode);\n \t\t  tmp3 = gen_reg_rtx (Pmode);\n \t\t  mem = gen_rtx_MEM (Pmode, tmp1);\n-\t\t  RTX_UNCHANGING_P (mem) = 1;\n+\t\t  MEM_READONLY_P (mem) = 1;\n \n \t\t  first = emit_insn (gen_load_toc_v4_PIC_1b (tempLR, lab,\n \t\t\t\t\t\t\t     gsym));\n@@ -4410,7 +4410,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t= gen_rtx_MEM (mode,\n \t\t\t       create_TOC_reference (XEXP (operands[1], 0)));\n \t      set_mem_alias_set (operands[1], get_TOC_alias_set ());\n-\t      RTX_UNCHANGING_P (operands[1]) = 1;\n+\t      MEM_READONLY_P (operands[1]) = 1;\n \t    }\n \t}\n       break;"}, {"sha": "49d4a24d8c84eddac58540e426415c8052d9f90f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2605,7 +2605,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n           new = gen_rtx_CONST (Pmode, new);\n           new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n           new = gen_rtx_MEM (Pmode, new);\n-          RTX_UNCHANGING_P (new) = 1;\n+\t  MEM_READONLY_P (new) = 1;\n           emit_move_insn (reg, new);\n           new = reg;\n         }\n@@ -2621,7 +2621,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n           emit_move_insn (temp, new);\n \n           new = gen_rtx_MEM (Pmode, temp);\n-          RTX_UNCHANGING_P (new) = 1;\n+\t  MEM_READONLY_P (new) = 1;\n           emit_move_insn (reg, new);\n           new = reg;\n         }\n@@ -2642,7 +2642,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n           new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n           new = gen_rtx_MEM (Pmode, new);\n-          RTX_UNCHANGING_P (new) = 1;\n+\t  MEM_READONLY_P (new) = 1;\n           emit_move_insn (reg, new);\n           new = reg;\n         }\n@@ -2933,7 +2933,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    new = gen_rtx_CONST (Pmode, new);\n \t    new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \t    new = gen_rtx_MEM (Pmode, new);\n-\t    RTX_UNCHANGING_P (new) = 1;\n+\t    MEM_READONLY_P (new) = 1;\n \t    temp = gen_reg_rtx (Pmode);\n \t    emit_move_insn (temp, new);\n \t  }\n@@ -2948,7 +2948,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    emit_move_insn (temp, new);\n \n \t    new = gen_rtx_MEM (Pmode, temp);\n-\t    RTX_UNCHANGING_P (new) = 1;\n+\t    MEM_READONLY_P (new) = 1;\n \t    temp = gen_reg_rtx (Pmode);\n \t    emit_move_insn (temp, new);\n \t  }\n@@ -2968,7 +2968,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \n             new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n \t    new = gen_rtx_MEM (Pmode, new);\n-\t    RTX_UNCHANGING_P (new) = 1;\n+\t    MEM_READONLY_P (new) = 1;\n \n \t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new, addr), UNSPEC_TLS_LOAD);\n \t    temp = gen_reg_rtx (Pmode);\n@@ -2987,7 +2987,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \n \t    new = temp;\n \t    new = gen_rtx_MEM (Pmode, new);\n-\t    RTX_UNCHANGING_P (new) = 1;\n+\t    MEM_READONLY_P (new) = 1;\n \n \t    new = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new, addr), UNSPEC_TLS_LOAD);\n \t    temp = gen_reg_rtx (Pmode);"}, {"sha": "0cbcc0a257443bab93f3bcb6c0362cebc3053cf2", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -6841,7 +6841,7 @@\n    emit_move_insn (base, gen_rtx_LABEL_REF (Pmode, operands[3]));\n \n    index = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, base, index));\n-   RTX_UNCHANGING_P (index) = 1;\n+   MEM_READONLY_P (index) = 1;\n    MEM_NOTRAP_P (index) = 1;\n    emit_move_insn (target, index);\n "}, {"sha": "6b72e491288cc32da30b64853ef633cde651140b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1042,7 +1042,7 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t      emit_insn (gen_load_gbr (tmp2));\n \t      tmp = gen_reg_rtx (Pmode);\n \t      emit_insn (gen_symTPOFF2reg (tmp, op1));\n-\t      RTX_UNCHANGING_P (tmp) = 1;\n+\t      MEM_READONLY_P (tmp) = 1;\n \n \t      if (register_operand (op0, Pmode))\n \t\top1 = op0;\n@@ -4383,7 +4383,6 @@ sh_reorg (void)\n \t\t      /* Remove the clobber of r0.  */\n \t\t      *clobberp = gen_rtx_CLOBBER (GET_MODE (clobber),\n \t\t\t\t\t\t   gen_rtx_SCRATCH (Pmode));\n-\t\t      RTX_UNCHANGING_P (newsrc) = 1;\n \t\t    }\n \t\t  /* This is a mova needing a label.  Create it.  */\n \t\t  else if (GET_CODE (src) == UNSPEC\n@@ -4401,7 +4400,7 @@ sh_reorg (void)\n \t\t      lab = add_constant (src, mode, 0);\n \t\t      newsrc = gen_rtx_MEM (mode,\n \t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab));\n-\t\t      RTX_UNCHANGING_P (newsrc) = 1;\n+\t\t      MEM_READONLY_P (newsrc) = 1;\n \t\t    }\n \t\t  *patp = gen_rtx_SET (VOIDmode, dst, newsrc);\n \t\t  INSN_CODE (scan) = -1;"}, {"sha": "45b48eb96d6c154a0d91ea9038936f14ad4332dc", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -6766,7 +6766,7 @@\n   PUT_MODE (gotsym, Pmode);\n   insn = emit_insn (gen_symGOT_load (operands[0], gotsym));\n \n-  RTX_UNCHANGING_P (SET_SRC (PATTERN (insn))) = 1;\n+  MEM_READONLY_P (SET_SRC (PATTERN (insn))) = 1;\n \n   DONE;\n }\")"}, {"sha": "f1f2b211ca4112aa73430c36629fec5a70537e82", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -3809,7 +3809,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t     gen_rtx_PLUS (Pmode,\n \t\t\t\t\t   pic_offset_table_rtx, address));\n       current_function_uses_pic_offset_table = 1;\n-      RTX_UNCHANGING_P (pic_ref) = 1;\n+      MEM_READONLY_P (pic_ref) = 1;\n       insn = emit_move_insn (reg, pic_ref);\n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n \t by loop.  */"}, {"sha": "900f1e31a2da369f00d1fe9b7827d665eac52e93", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1321,7 +1321,7 @@\n   emit_insn (gen_addsi3 (reg, reg, tableaddress));\n   /* Load the table entry.  */\n   mem = gen_rtx_MEM (CASE_VECTOR_MODE, reg);\n-  RTX_UNCHANGING_P (mem) = 1;\n+  MEM_READONLY_P (mem) = 1;\n   if (! TARGET_BIG_SWITCH)\n     {\n       rtx reg2 = gen_reg_rtx (HImode);"}, {"sha": "15e2dc8e60b01469f2e2cfa3f6cb84f311a0f97f", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1461,13 +1461,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n   elt->related_value = 0;\n   elt->in_memory = 0;\n   elt->mode = mode;\n-  elt->is_const = (CONSTANT_P (x)\n-\t\t   /* GNU C++ takes advantage of this for `this'\n-\t\t      (and other const values).  */\n-\t\t   || (REG_P (x)\n-\t\t       && RTX_UNCHANGING_P (x)\n-\t\t       && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-\t\t   || fixed_base_plus_p (x));\n+  elt->is_const = (CONSTANT_P (x) || fixed_base_plus_p (x));\n \n   if (table[hash])\n     table[hash]->prev_same_hash = elt;\n@@ -2094,7 +2088,7 @@ canon_hash_string (const char *ps)\n    Store 1 in do_not_record if any subexpression is volatile.\n \n    Store 1 in hash_arg_in_memory if X contains a MEM rtx\n-   which does not have the RTX_UNCHANGING_P bit set.\n+   which does not have the MEM_READONLY_P bit set.\n \n    Note that cse_insn knows that the hash code of a MEM expression\n    is just (int) MEM plus the hash code of the address.  */\n@@ -2229,7 +2223,7 @@ canon_hash (rtx x, enum machine_mode mode)\n \t  do_not_record = 1;\n \t  return 0;\n \t}\n-      if (! RTX_UNCHANGING_P (x) || fixed_base_plus_p (XEXP (x, 0)))\n+      if (!MEM_READONLY_P (x))\n \thash_arg_in_memory = 1;\n \n       /* Now that we have already found this special case,\n@@ -2249,7 +2243,7 @@ canon_hash (rtx x, enum machine_mode mode)\n \t  hash += (unsigned) USE;\n \t  x = XEXP (x, 0);\n \n-\t  if (! RTX_UNCHANGING_P (x) || fixed_base_plus_p (XEXP (x, 0)))\n+\t  if (!MEM_READONLY_P (x))\n \t    hash_arg_in_memory = 1;\n \n \t  /* Now that we have already found this special case,\n@@ -5974,9 +5968,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t      sets[i].dest_hash, GET_MODE (dest));\n \n \telt->in_memory = (MEM_P (sets[i].inner_dest)\n-\t\t\t  && (! RTX_UNCHANGING_P (sets[i].inner_dest)\n-\t\t\t      || fixed_base_plus_p (XEXP (sets[i].inner_dest,\n-\t\t\t\t\t\t\t  0))));\n+\t\t\t  && !MEM_READONLY_P (sets[i].inner_dest));\n \n \t/* If we have (set (subreg:m1 (reg:m2 foo) 0) (bar:m1)), M1 is no\n \t   narrower than M2, and both M1 and M2 are the same number of words,"}, {"sha": "a2dcfe7db4ef2d720dd78c0af78bfc0297405025", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -735,27 +735,18 @@ prologues.\n resulted from an in-line function call.\n Stored in the @code{integrated} field and printed as @samp{/i}.\n \n-@findex RTX_UNCHANGING_P\n-@cindex @code{reg} and @samp{/u}\n+@findex MEM_READONLY_P\n @cindex @code{mem} and @samp{/u}\n-@cindex @code{concat} and @samp{/u}\n-@cindex @code{unchanging}, in @code{reg} and @code{mem}\n-@item RTX_UNCHANGING_P (@var{x})\n-Nonzero in a @code{reg}, @code{mem}, or @code{concat} if the register or\n-memory is set at most once, anywhere.  This does not mean that it is\n-function invariant.\n-\n-GCC uses this flag to determine whether two references conflict.  As\n-implemented by @code{true_dependence} in @file{alias.c} for memory\n-references, unchanging memory can't conflict with non-unchanging memory;\n-a non-unchanging read can conflict with a non-unchanging write; an\n-unchanging read can conflict with an unchanging write (since there may\n-be a single store to this address to initialize it); and an unchanging\n-store can conflict with a non-unchanging read.  This means we must make\n-conservative assumptions when choosing the value of this flag for a\n-memory reference to an object containing both unchanging and\n-non-unchanging fields: we must set the flag when writing to the object\n-and clear it when reading from the object.\n+@cindex @code{unchanging}, in @code{mem}\n+@item MEM_READONLY_P (@var{x})\n+Nonzero in a @code{mem}, if the memory is statically allocated and read-only.\n+\n+Read-only in this context never modified during the lifetime of the\n+program, not necessarily in ROM or in write-disabled pages.  A common\n+example of the later is a shared library's global offset table.  This\n+table is initialized by the runtime loader, so the memory is technically\n+writable, but after control is transfered from the runtime loader to the\n+application, this memory will never be subsequently modified.\n \n Stored in the @code{unchanging} field and printed as @samp{/u}.\n "}, {"sha": "1137c45986b357d3b8a324bb68319bfdb6084874", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1538,10 +1538,6 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n   MEM_VOLATILE_P (ref) |= TYPE_VOLATILE (type);\n   MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n-  RTX_UNCHANGING_P (ref)\n-    |= ((lang_hooks.honor_readonly\n-\t && (TYPE_READONLY (type) || (t != type && TREE_READONLY (t))))\n-\t|| (! TYPE_P (t) && TREE_CONSTANT (t)));\n   MEM_POINTER (ref) = POINTER_TYPE_P (type);\n   MEM_NOTRAP_P (ref) = TREE_THIS_NOTRAP (t);\n \n@@ -1563,7 +1559,12 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n      the expression.  */\n   if (! TYPE_P (t))\n     {\n-      maybe_set_unchanging (ref, t);\n+      tree base = get_base_address (t);\n+      if (base && DECL_P (base)\n+\t  && TREE_READONLY (base)\n+\t  && (TREE_STATIC (base) || DECL_EXTERNAL (base)))\n+\tMEM_READONLY_P (ref) = 1;\n+\n       if (TREE_THIS_VOLATILE (t))\n \tMEM_VOLATILE_P (ref) = 1;\n "}, {"sha": "47cb8671e27490883de3f465480a167ab8935d76", "filename": "gcc/explow.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -577,34 +577,6 @@ validize_mem (rtx ref)\n   return replace_equiv_address (ref, XEXP (ref, 0));\n }\n \f\n-/* Given REF, either a MEM or a REG, and T, either the type of X or\n-   the expression corresponding to REF, set RTX_UNCHANGING_P if\n-   appropriate.  */\n-\n-void\n-maybe_set_unchanging (rtx ref, tree t)\n-{\n-  /* We can set RTX_UNCHANGING_P from TREE_READONLY for decls whose\n-     initialization is only executed once, or whose initializer always\n-     has the same value.  Currently we simplify this to PARM_DECLs in the\n-     first case, and decls with TREE_CONSTANT initializers in the second.\n-\n-     We cannot do this for non-static aggregates, because of the double\n-     writes that can be generated by store_constructor, depending on the\n-     contents of the initializer.  Yes, this does eliminate a good fraction\n-     of the number of uses of RTX_UNCHANGING_P for a language like Ada.\n-     It also eliminates a good quantity of bugs.  Let this be incentive to\n-     eliminate RTX_UNCHANGING_P entirely in favor of a more reliable\n-     solution, perhaps based on alias sets.  */\n-\n-  if ((TREE_READONLY (t) && DECL_P (t)\n-       && (TREE_STATIC (t) || ! AGGREGATE_TYPE_P (TREE_TYPE (t)))\n-       && (TREE_CODE (t) == PARM_DECL\n-\t   || (DECL_INITIAL (t) && TREE_CONSTANT (DECL_INITIAL (t)))))\n-      || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n-    RTX_UNCHANGING_P (ref) = 1;\n-}\n-\f\n /* Return a modified copy of X with its memory address copied\n    into a temporary register to protect it from side effects.\n    If X is not a MEM, it is returned unchanged (and not copied)."}, {"sha": "a6c7e8e580e007bb05b9d06b3e5395c11e6871e6", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1359,16 +1359,6 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n \n   retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n \n-  /* If we are initializing a readonly value, show the above call clobbered\n-     it. Otherwise, a load from it may erroneously be hoisted from a loop, or\n-     the delay slot scheduler might overlook conflicts and take nasty\n-     decisions.  */\n-  if (RTX_UNCHANGING_P (dst))\n-    add_function_usage_to\n-      (last_call_insn (), gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t     gen_rtx_CLOBBER (VOIDmode, dst),\n-\t\t\t\t\t     NULL_RTX));\n-\n   return retval;\n }\n \n@@ -2453,12 +2443,6 @@ clear_storage_via_libcall (rtx object, rtx size)\n \n   retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n \n-  /* If we are initializing a readonly value, show the above call\n-     clobbered it.  Otherwise, a load from it may erroneously be\n-     hoisted from a loop.  */\n-  if (RTX_UNCHANGING_P (object))\n-    emit_insn (gen_rtx_CLOBBER (VOIDmode, object));\n-\n   return retval;\n }\n \n@@ -3449,8 +3433,6 @@ get_subtarget (rtx x)\n           || x == 0\n \t   /* Only registers can be subtargets.  */\n \t   || !REG_P (x)\n-\t   /* If the register is readonly, it can't be set more than once.  */\n-\t   || RTX_UNCHANGING_P (x)\n \t   /* Don't use hard regs to avoid extending their life.  */\n \t   || REGNO (x) < FIRST_PSEUDO_REGISTER\n \t  ? 0 : x);\n@@ -3557,18 +3539,6 @@ expand_assignment (tree to, tree from, int want_value)\n \t  MEM_VOLATILE_P (to_rtx) = 1;\n \t}\n \n-      if (TREE_CODE (to) == COMPONENT_REF\n-\t  && TREE_READONLY (TREE_OPERAND (to, 1))\n-\t  /* We can't assert that a MEM won't be set more than once\n-\t     if the component is not addressable because another\n-\t     non-addressable component may be referenced by the same MEM.  */\n-\t  && ! (MEM_P (to_rtx) && ! can_address_p (to)))\n-\t{\n-\t  if (to_rtx == orig_to_rtx)\n-\t    to_rtx = copy_rtx (to_rtx);\n-\t  RTX_UNCHANGING_P (to_rtx) = 1;\n-\t}\n-\n       if (MEM_P (to_rtx) && ! can_address_p (to))\n \t{\n \t  if (to_rtx == orig_to_rtx)\n@@ -4469,15 +4439,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t   || ((HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (target))\n \t\t       == size)))\n \t{\n-\t  rtx xtarget = target;\n-\n-\t  if (readonly_fields_p (type))\n-\t    {\n-\t      xtarget = copy_rtx (xtarget);\n-\t      RTX_UNCHANGING_P (xtarget) = 1;\n-\t    }\n-\n-\t  clear_storage (xtarget, GEN_INT (size));\n+\t  clear_storage (target, GEN_INT (size));\n \t  cleared = 1;\n \t}\n \n@@ -4550,14 +4512,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t       highest_pow2_factor (offset));\n \t    }\n \n-\t  if (TREE_READONLY (field))\n-\t    {\n-\t      if (MEM_P (to_rtx))\n-\t\tto_rtx = copy_rtx (to_rtx);\n-\n-\t      RTX_UNCHANGING_P (to_rtx) = 1;\n-\t    }\n-\n #ifdef WORD_REGISTER_OPERATIONS\n \t  /* If this initializes a field that is smaller than a word, at the\n \t     start of a word, try to widen it to a full word.\n@@ -6655,12 +6609,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);\n \n-\t/* If we are writing to this object and its type is a record with\n-\t   readonly fields, we must mark it as readonly so it will\n-\t   conflict with readonly references to those fields.  */\n-\tif (modifier == EXPAND_WRITE && readonly_fields_p (type))\n-\t  RTX_UNCHANGING_P (temp) = 1;\n-\n \treturn temp;\n       }\n \n@@ -8790,7 +8738,7 @@ do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n     index = memory_address_noforce (CASE_VECTOR_MODE, index);\n   temp = gen_reg_rtx (CASE_VECTOR_MODE);\n   vector = gen_rtx_MEM (CASE_VECTOR_MODE, index);\n-  RTX_UNCHANGING_P (vector) = 1;\n+  MEM_READONLY_P (vector) = 1;\n   MEM_NOTRAP_P (vector) = 1;\n   convert_move (temp, vector, 0);\n "}, {"sha": "a3276299e498b6d8c7cbcc0d684eb12c78a46a43", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -648,11 +648,6 @@ extern rtx widen_memory_access (rtx, enum machine_mode, HOST_WIDE_INT);\n    valid address.  */\n extern rtx validize_mem (rtx);\n \n-/* Given REF, either a MEM or a REG, and T, either the type of X or\n-   the expression corresponding to REF, set RTX_UNCHANGING_P if\n-   appropriate.  */\n-extern void maybe_set_unchanging (rtx, tree);\n-\n /* Given REF, a MEM, and T, either the type of X or the expression\n    corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n    if we are making a new object of this type.  */"}, {"sha": "3db96daf4eac85f2f5d74737e6d59799575f64a0", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2123,7 +2123,7 @@ insn_dead_p (struct propagate_block_info *pbi, rtx x, int call_ok,\n \t     rtx_equal_p does not check the alias set or flags, we also\n \t     must have the potential for them to conflict (anti_dependence).  */\n \t  for (temp = pbi->mem_set_list; temp != 0; temp = XEXP (temp, 1))\n-\t    if (unchanging_anti_dependence (r, XEXP (temp, 0)))\n+\t    if (anti_dependence (r, XEXP (temp, 0)))\n \t      {\n \t\trtx mem = XEXP (temp, 0);\n \n@@ -3756,7 +3756,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \t      while (temp)\n \t\t{\n \t\t  next = XEXP (temp, 1);\n-\t\t  if (unchanging_anti_dependence (XEXP (temp, 0), x))\n+\t\t  if (anti_dependence (XEXP (temp, 0), x))\n \t\t    {\n \t\t      /* Splice temp out of the list.  */\n \t\t      if (prev)"}, {"sha": "b6f5a79c661346473f70f19941647210364db5ae", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -754,8 +754,6 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n   /* If a type is specified, set the relevant flags.  */\n   if (type != 0)\n     {\n-      RTX_UNCHANGING_P (slot) = (lang_hooks.honor_readonly\n-\t\t\t\t && TYPE_READONLY (type));\n       MEM_VOLATILE_P (slot) = TYPE_VOLATILE (type);\n       MEM_SET_IN_STRUCT_P (slot, AGGREGATE_TYPE_P (type));\n     }\n@@ -2667,10 +2665,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n       SET_DECL_RTL (parm, x);\n     }\n   else\n-    {\n-      SET_DECL_RTL (parm, parmreg);\n-      maybe_set_unchanging (DECL_RTL (parm), parm);\n-    }\n+    SET_DECL_RTL (parm, parmreg);\n \n   /* Copy the value into the register.  */\n   if (data->nominal_mode != data->passed_mode\n@@ -4056,7 +4051,6 @@ expand_function_start (tree subr)\n \n       set_decl_incoming_rtl (parm, static_chain_incoming_rtx);\n       SET_DECL_RTL (parm, local);\n-      maybe_set_unchanging (local, parm);\n       mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n \n       emit_move_insn (local, static_chain_incoming_rtx);"}, {"sha": "fed0a2736d62703fd519b128fab7e0c6b5c5df16", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -191,9 +191,7 @@ varray_type global_const_equiv_varray;\n    rtl is ever emitted.\n \n    If FOR_LHS is nonzero, if means we are processing something that will\n-   be the LHS of a SET.  In that case, we copy RTX_UNCHANGING_P even if\n-   inlining since we need to be conservative in how it is set for\n-   such cases.\n+   be the LHS of a SET.\n \n    Handle constants that need to be placed in the constant pool by\n    calling `force_const_mem'.  */\n@@ -317,7 +315,6 @@ copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n \t  map->reg_map[regno] = gen_reg_rtx (mode);\n \t  REG_USERVAR_P (map->reg_map[regno]) = REG_USERVAR_P (orig);\n \t  REG_LOOP_TEST_P (map->reg_map[regno]) = REG_LOOP_TEST_P (orig);\n-\t  RTX_UNCHANGING_P (map->reg_map[regno]) = RTX_UNCHANGING_P (orig);\n \t  /* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */\n \n \t  if (REG_POINTER (map->x_regno_reg_rtx[regno]))"}, {"sha": "a01b99a04250d7740e4897d5f9e8b3dc3b2ca431", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -484,7 +484,7 @@ validate_equiv_mem (rtx start, rtx reg, rtx memref)\n       if (find_reg_note (insn, REG_DEAD, reg))\n \treturn 1;\n \n-      if (CALL_P (insn) && ! RTX_UNCHANGING_P (memref)\n+      if (CALL_P (insn) && ! MEM_READONLY_P (memref)\n \t  && ! CONST_OR_PURE_CALL_P (insn))\n \treturn 0;\n \n@@ -518,7 +518,7 @@ equiv_init_varies_p (rtx x)\n   switch (code)\n     {\n     case MEM:\n-      return ! RTX_UNCHANGING_P (x) || equiv_init_varies_p (XEXP (x, 0));\n+      return !MEM_READONLY_P (x) || equiv_init_varies_p (XEXP (x, 0));\n \n     case CONST:\n     case CONST_INT:"}, {"sha": "2004dbf1df3ce88675a6e49daff833202e2fb942", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -154,7 +154,7 @@ check_maybe_invariant (rtx x)\n \n       /* Just handle the most trivial case where we load from an unchanging\n \t location (most importantly, pic tables).  */\n-      if (RTX_UNCHANGING_P (x))\n+      if (MEM_READONLY_P (x))\n \tbreak;\n \n       return false;"}, {"sha": "49f86c2887a7269b205bc9bf789a0bca0a201563", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -2577,30 +2577,6 @@ prescan_loop (struct loop *loop)\n \t  loop_info->has_call = 1;\n \t  if (can_throw_internal (insn))\n \t    loop_info->has_multiple_exit_targets = 1;\n-\n-\t  /* Calls initializing constant objects have CLOBBER of MEM /u in the\n-\t     attached FUNCTION_USAGE expression list, not accounted for by the\n-\t     code above. We should note these to avoid missing dependencies in\n-\t     later references.  */\n-\t  {\n-\t    rtx fusage_entry;\n-\n-\t    for (fusage_entry = CALL_INSN_FUNCTION_USAGE (insn);\n-\t\t fusage_entry; fusage_entry = XEXP (fusage_entry, 1))\n-\t      {\n-\t\trtx fusage = XEXP (fusage_entry, 0);\n-\n-\t\tif (GET_CODE (fusage) == CLOBBER\n-\t\t    && MEM_P (XEXP (fusage, 0))\n-\t\t    && RTX_UNCHANGING_P (XEXP (fusage, 0)))\n-\t\t  {\n-\t\t    note_stores (fusage, note_addr_stored, loop_info);\n-\t\t    if (! loop_info->first_loop_store_insn\n-\t\t\t&& loop_info->store_mems)\n-\t\t      loop_info->first_loop_store_insn = insn;\n-\t\t  }\n-\t      }\n-\t  }\n \t  break;\n \n \tcase JUMP_INSN:\n@@ -2707,8 +2683,7 @@ prescan_loop (struct loop *loop)\n   if (loop_info->unknown_constant_address_altered)\n     {\n       rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n-\n-      RTX_UNCHANGING_P (mem) = 1;\n+      MEM_READONLY_P (mem) = 1;\n       loop_info->store_mems\n \t= gen_rtx_EXPR_LIST (VOIDmode, mem, loop_info->store_mems);\n     }\n@@ -3241,7 +3216,7 @@ note_addr_stored (rtx x, rtx y ATTRIBUTE_UNUSED,\n   /* BLKmode MEM means all memory is clobbered.  */\n   if (GET_MODE (x) == BLKmode)\n     {\n-      if (RTX_UNCHANGING_P (x))\n+      if (MEM_READONLY_P (x))\n \tloop_info->unknown_constant_address_altered = 1;\n       else\n \tloop_info->unknown_address_altered = 1;\n@@ -3333,9 +3308,6 @@ loop_invariant_p (const struct loop *loop, rtx x)\n       return 0;\n \n     case REG:\n-      /* We used to check RTX_UNCHANGING_P (x) here, but that is invalid\n-\t since the reg might be set by initialization within the loop.  */\n-\n       if ((x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n \t   || x == arg_pointer_rtx || x == pic_offset_table_rtx)\n \t  && ! current_function_has_nonlocal_goto)"}, {"sha": "8a418ac0ec0c2769b8307598130d92e50634bb53", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1690,8 +1690,6 @@ emit_colors (struct df *df)\n \t      place = assign_stack_local (PSEUDO_REGNO_MODE (web->regno),\n \t\t\t\t\t  total_size,\n \t\t\t\t\t  inherent_size == total_size ? 0 : -1);\n-\t      RTX_UNCHANGING_P (place) =\n-\t\t  RTX_UNCHANGING_P (regno_reg_rtx[web->regno]);\n \t      set_mem_alias_set (place, new_alias_set ());\n \t    }\n \t  else"}, {"sha": "587b5767e3cb4f5807581285154da5cf6fded816", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -758,7 +758,6 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n   if (REG_P (src)\n       && REG_LIVE_LENGTH (REGNO (src)) > 0\n       && REG_P (dest)\n-      && !RTX_UNCHANGING_P (dest)\n       && REG_LIVE_LENGTH (REGNO (dest)) > 0\n       && (set = single_set (insn)) != NULL_RTX\n       && !reg_mentioned_p (dest, SET_SRC (set))\n@@ -1262,7 +1261,6 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t      if (!REG_P (dst)\n \t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER\n \t\t  || REG_LIVE_LENGTH (REGNO (dst)) < 0\n-\t\t  || RTX_UNCHANGING_P (dst)\n \t\t  || GET_MODE (src) != GET_MODE (dst))\n \t\tcontinue;\n \n@@ -1657,12 +1655,6 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n   rtx src_note = find_reg_note (insn, REG_DEAD, src), dst_note = NULL_RTX;\n   int length, s_length;\n \n-  /* If SRC is marked as unchanging, we may not change it.\n-     ??? Maybe we could get better code by removing the unchanging bit\n-     instead, and changing it back if we don't succeed?  */\n-  if (RTX_UNCHANGING_P (src))\n-    return 0;\n-\n   if (! src_note)\n     {\n       /* Look for (set (regX) (op regA constX))\n@@ -2039,10 +2031,7 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n    mentioning SRC or mentioning / changing DST .  If in doubt, presume\n    it is unstable.\n    The rationale is that we want to check if we can move an insn easily\n-   while just paying attention to SRC and DST.  A register is considered\n-   stable if it has the RTX_UNCHANGING_P bit set, but that would still\n-   leave the burden to update REG_DEAD / REG_UNUSED notes, so we don't\n-   want any registers but SRC and DST.  */\n+   while just paying attention to SRC and DST.  */\n static int\n stable_and_no_regs_but_for_p (rtx x, rtx src, rtx dst)\n {"}, {"sha": "4dd1153dfd89e7f336d0706d2ec0cada0123fd19", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1129,8 +1129,7 @@ reload (rtx first, int global)\n \t\tMEM_COPY_ATTRIBUTES (reg, reg_equiv_memory_loc[i]);\n \t      else\n \t\t{\n-\t\t  RTX_UNCHANGING_P (reg) = MEM_IN_STRUCT_P (reg)\n-\t\t    = MEM_SCALAR_P (reg) = 0;\n+\t\t  MEM_IN_STRUCT_P (reg) = MEM_SCALAR_P (reg) = 0;\n \t\t  MEM_ATTRS (reg) = 0;\n \t\t}\n \t    }\n@@ -1965,8 +1964,6 @@ alter_reg (int i, int from_reg)\n \t       below.  */\n \t    adjust = inherent_size - total_size;\n \n-\t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[i]);\n-\n \t  /* Nothing can alias this slot except this pseudo.  */\n \t  set_mem_alias_set (x, new_alias_set ());\n \t}"}, {"sha": "05ab25b63c454a5ceede36cb5b9355a0bf255a69", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -256,7 +256,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n     case MEM:\n       /* If this memory shouldn't change, it really isn't referencing\n \t memory.  */\n-      if (RTX_UNCHANGING_P (x))\n+      if (MEM_READONLY_P (x))\n \tres->unch_memory = 1;\n       else\n \tres->memory = 1;\n@@ -753,7 +753,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n       if (in_dest)\n \t{\n \t  res->memory = 1;\n-\t  res->unch_memory |= RTX_UNCHANGING_P (x);\n+\t  res->unch_memory |= MEM_READONLY_P (x);\n \t  res->volatil |= MEM_VOLATILE_P (x);\n \t}\n "}, {"sha": "0b75b992be5ff4b7312197943658e30675db2772", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -676,8 +676,6 @@ do {\t\t\t\t\\\n    They are always in the same basic block as this insn.  */\n #define LOG_LINKS(INSN)\tXEXP(INSN, 7)\n \n-#define RTX_UNCHANGING_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"RTX_UNCHANGING_P\", (RTX), REG, MEM, CONCAT)->unchanging)\n #define RTX_FRAME_RELATED_P(RTX)\t\t\t\t\t\\\n   (RTL_FLAG_CHECK5(\"RTX_FRAME_RELATED_P\", (RTX), INSN, CALL_INSN,\t\\\n \t\t   JUMP_INSN, BARRIER, SET)->frame_related)\n@@ -1249,6 +1247,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT (RTX, 6, ASM_OPERANDS)\n #endif\n \n+/* 1 if RTX is a mem that is statically allocated in read-only memory.  */\n+#define MEM_READONLY_P(RTX) \\\n+  (RTL_FLAG_CHECK1(\"MEM_READONLY_P\", (RTX), MEM)->unchanging)\n+\n /* 1 if RTX is a mem and we should keep the alias set for this mem\n    unchanged when we access a component.  Set to 1, or example, when we\n    are already in a non-addressable component of an aggregate.  */\n@@ -1345,7 +1347,7 @@ do {\t\t\t\t\t\t\\\n    MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\t\\\n    MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\t\\\n    MEM_NOTRAP_P (LHS) = MEM_NOTRAP_P (RHS),\t\t\t\\\n-   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS),\t\t\\\n+   MEM_READONLY_P (LHS) = MEM_READONLY_P (RHS),\t\t\t\\\n    MEM_KEEP_ALIAS_SET_P (LHS) = MEM_KEEP_ALIAS_SET_P (RHS),\t\\\n    MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n \n@@ -2367,7 +2369,6 @@ extern int canon_true_dependence (rtx, enum machine_mode, rtx, rtx,\n extern int read_dependence (rtx, rtx);\n extern int anti_dependence (rtx, rtx);\n extern int output_dependence (rtx, rtx);\n-extern int unchanging_anti_dependence (rtx, rtx);\n extern void mark_constant_function (void);\n extern void init_alias_once (void);\n extern void init_alias_analysis (void);"}, {"sha": "91fe437a97361609ae42f001e1df6971760a9af0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -81,7 +81,7 @@ rtx_unstable_p (rtx x)\n   switch (code)\n     {\n     case MEM:\n-      return ! RTX_UNCHANGING_P (x) || rtx_unstable_p (XEXP (x, 0));\n+      return !MEM_READONLY_P (x) || rtx_unstable_p (XEXP (x, 0));\n \n     case CONST:\n     case CONST_INT:\n@@ -95,8 +95,7 @@ rtx_unstable_p (rtx x)\n       /* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */\n       if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n \t  /* The arg pointer varies if it is not a fixed register.  */\n-\t  || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM])\n-\t  || RTX_UNCHANGING_P (x))\n+\t  || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))\n \treturn 0;\n #ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n       /* ??? When call-clobbered, the value is stable modulo the restore\n@@ -156,7 +155,7 @@ rtx_varies_p (rtx x, int for_alias)\n   switch (code)\n     {\n     case MEM:\n-      return ! RTX_UNCHANGING_P (x) || rtx_varies_p (XEXP (x, 0), for_alias);\n+      return !MEM_READONLY_P (x) || rtx_varies_p (XEXP (x, 0), for_alias);\n \n     case CONST:\n     case CONST_INT:\n@@ -1027,7 +1026,7 @@ modified_between_p (rtx x, rtx start, rtx end)\n       return 1;\n \n     case MEM:\n-      if (RTX_UNCHANGING_P (x))\n+      if (MEM_READONLY_P (x))\n \treturn 0;\n       if (modified_between_p (XEXP (x, 0), start, end))\n \treturn 1;\n@@ -1085,7 +1084,7 @@ modified_in_p (rtx x, rtx insn)\n       return 1;\n \n     case MEM:\n-      if (RTX_UNCHANGING_P (x))\n+      if (MEM_READONLY_P (x))\n \treturn 0;\n       if (modified_in_p (XEXP (x, 0), insn))\n \treturn 1;"}, {"sha": "81274377d766756d49e61e97ab63d9ebe7cd0671", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -1956,8 +1956,6 @@ expand_decl (tree decl)\n \t    mark_reg_pointer (DECL_RTL (decl),\n \t\t\t      TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n \t}\n-\n-      maybe_set_unchanging (DECL_RTL (decl), decl);\n     }\n \n   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST"}, {"sha": "d0f8ff5ed909d9be6bbaa51d3c7083fbf10e8f59", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -120,7 +120,6 @@ extern void pop_gimplify_context (tree);\n extern void gimplify_and_add (tree, tree *);\n \n /* Miscellaneous helpers.  */\n-extern tree get_base_address (tree t);\n extern void gimple_add_tmp_var (tree);\n extern tree gimple_current_bind_expr (void);\n extern void gimple_push_bind_expr (tree);"}, {"sha": "4afe608cf529cfc57fbfa38704ebaf4b3b82c8d0", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -3781,11 +3781,13 @@ extern int tree_node_sizes[];\n extern bool in_gimple_form;\n \n /* In tree-ssa-loop-niter.c.  */\n-\n tree lower_bound_in_type (tree, tree);\n tree upper_bound_in_type (tree, tree);\n \n /* In tree-ssa-threadupdate.c.  */\n extern bool thread_through_all_blocks (void);\n \n+/* In tree-gimple.c.  */\n+extern tree get_base_address (tree t);\n+\n #endif  /* GCC_TREE_H  */"}, {"sha": "a8d23f20207abfe4cd1f4217a44d4287c0374b94", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -118,12 +118,8 @@ char *unlikely_section_label = NULL;\n \n char *unlikely_text_section_name = NULL;\n \n-/* RTX_UNCHANGING_P in a MEM can mean it is stored into, for initialization.\n-   So giving constant the alias set for the type will allow such\n-   initializations to appear to conflict with the load of the constant.  We\n-   avoid this by giving all constants an alias set for just constants.\n-   Since there will be no stores to that alias set, nothing will ever\n-   conflict with them.  */\n+/* We give all constants their own alias set.  Perhaps redundant with\n+   MEM_READONLY_P, but pre-dates it.  */\n \n static HOST_WIDE_INT const_alias_set;\n \n@@ -2947,7 +2943,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   /* Construct the MEM.  */\n   desc->mem = def = gen_rtx_MEM (mode, symbol);\n   set_mem_attributes (def, lang_hooks.types.type_for_mode (mode, 0), 1);\n-  RTX_UNCHANGING_P (def) = 1;\n+  MEM_READONLY_P (def) = 1;\n \n   /* If we're dropping a label to the constant pool, make sure we\n      don't delete it.  */"}, {"sha": "2683511617242dde0db3ed1fa1c3599c48f2f64f", "filename": "gcc/web.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/389fdba06a4469967a53ea92ffa86d1d090e3a7f/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=389fdba06a4469967a53ea92ffa86d1d090e3a7f", "patch": "@@ -202,7 +202,6 @@ entry_register (struct web_entry *entry, struct ref *ref, char *used)\n       REG_USERVAR_P (newreg) = REG_USERVAR_P (reg);\n       REG_POINTER (newreg) = REG_POINTER (reg);\n       REG_LOOP_TEST_P (newreg) = REG_LOOP_TEST_P (reg);\n-      RTX_UNCHANGING_P (newreg) = RTX_UNCHANGING_P (reg);\n       REG_ATTRS (newreg) = REG_ATTRS (reg);\n       if (dump_file)\n \tfprintf (dump_file, \"Web oldreg=%i newreg=%i\\n\", REGNO (reg),"}]}