{"sha": "5a6ccc943fa6c7f121a47e96a19d73a7531de311", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE2Y2NjOTQzZmE2YzdmMTIxYTQ3ZTk2YTE5ZDczYTc1MzFkZTMxMQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2013-03-29T16:09:35Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-03-29T16:09:35Z"}, "message": "tree.h (VAR_P): New.\n\n\t* tree.h (VAR_P): New.\ncp/\n\t* call.c (build_java_interface_fn_ref): Likewise.\n\t(make_temporary_var_for_ref_to_temp): Likewise.\n\t* class.c (check_field_decls): Likewise.\n\t(layout_class_type): Likewise.\n\t(finish_struct_1): Likewise.\n\t(fixed_type_or_null): Likewise.\n\t(get_vtbl_decl_for_binfo): Likewise.\n\t* cp-gimplify.c (omp_var_to_track): Likewise.\n\t(cp_genericize_r): Likewise.\n\t* cp-objcp-common.c (cxx_warn_unused_global_decl): Likewise.\n\t* cp-tree.h (LANG_DECL_HAS_MIN): Likewise.\n\t(DECL_DISCRIMINATOR_P): Likewise.\n\t* decl.c (poplevel): Likewise.\n\t(decls_match): Likewise.\n\t(duplicate_decls): Likewise.\n\t(decl_jump_unsafe): Likewise.\n\t(start_decl): Likewise.\n\t(check_for_uninitialized_const_var): Likewise.\n\t(make_rtl_for_nonlocal_decl): Likewise.\n\t(cp_finish_decl): Likewise.\n\t(expand_static_init): Likewise.\n\t(local_variable_p): Likewise.\n\t(maybe_register_incomplete_var): Likewise.\n\t* decl2.c (grokfield): Likewise.\n\t(comdat_linkage): Likewise.\n\t(determine_visibility): Likewise.\n\t(import_export_decl): Likewise.\n\t(prune_vars_needing_no_initialization): Likewise.\n\t(decl_maybe_constant_var_p): Likewise.\n\t* error.c (dump_simple_decl): Likewise.\n\t(dump_template_decl): Likewise.\n\t(cp_printer): Likewise.\n\t* except.c (build_throw): Likewise.\n\t* init.c (build_vtbl_address): Likewise.\n\t(member_init_ok_or_else): Likewise.\n\t(build_aggr_init): Likewise.\n\t(expand_aggr_init_1): Likewise.\n\t(build_offset_ref): Likewise.\n\t(constant_value_1): Likewise.\n\t* mangle.c (write_mangled_name): Likewise.\n\t(write_prefix): Likewise.\n\t* name-lookup.c (supplement_binding_1): Likewise.\n\t(add_decl_to_level): Likewise.\n\t(pushdecl_maybe_friend_1): Likewise.\n\t(check_for_out_of_scope_variable): Likewise.\n\t(validate_nonmember_using_decl): Likewise.\n\t(lookup_name_innermost_nonclass_level_1): Likewise.\n\t(lookup_arg_dependent_1): Likewise.\n\t* parser.c (cp_parser_lambda_introducer): Likewise.\n\t(cp_parser_template_argument): Likewise.\n\t(cp_parser_single_declaration): Likewise.\n\t* pt.c (convert_nontype_argument): Likewise.\n\t(instantiate_class_template_1): Likewise.\n\t(tsubst_decl): Likewise.\n\t(tsubst_expr): Likewise.\n\t(do_decl_instantiation): Likewise.\n\t(do_type_instantiation): Likewise.\n\t(regenerate_decl_from_template): Likewise.\n\t(always_instantiate_p): Likewise.\n\t(instantiate_decl): Likewise.\n\t(type_dependent_expression_p): Likewise.\n\t(build_non_dependent_expr): Likewise.\n\t* repo.c (repo_emit_p): Likewise.\n\t* rtti.c (build_dynamic_cast_1): Likewise.\n\t* search.c (shared_member_p): Likewise.\n\t* semantics.c (outer_var_p): Likewise.\n\t(finish_id_expression): Likewise.\n\t(finish_omp_clauses): Likewise.\n\t(finish_decltype_type): Likewise.\n\t(ensure_literal_type_for_constexpr_object): Likewise.\n\t* tree.c (lvalue_kind): Likewise.\n\t(bot_replace): Likewise.\n\t(cp_tree_equal): Likewise.\n\t(handle_init_priority_attribute): Likewise.\n\t(decl_storage_duration): Likewise.\n\t* typeck.c (cxx_sizeof_expr): Likewise.\n\t(cxx_alignof_expr): Likewise.\n\t(decay_conversion): Likewise.\n\t(build_class_member_access_expr): Likewise.\n\t(cp_build_array_ref): Likewise.\n\t(cxx_mark_addressable): Likewise.\n\t(maybe_warn_about_returning_address_of_local): Likewise.\n\t(check_return_expr): Likewise.\n\t* typeck2.c (cxx_readonly_error): Likewise.\n\t(abstract_virtuals_error_sfinae): Likewise.\n\t(cxx_incomplete_type_diagnostic): Likewise.\n\nFrom-SVN: r197240", "tree": {"sha": "effb9d381a62e67766863cbbe83fd7aac2b98280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/effb9d381a62e67766863cbbe83fd7aac2b98280"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a6ccc943fa6c7f121a47e96a19d73a7531de311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a6ccc943fa6c7f121a47e96a19d73a7531de311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a6ccc943fa6c7f121a47e96a19d73a7531de311", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a6ccc943fa6c7f121a47e96a19d73a7531de311/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "39385fa637d08b4e64f9c70f690954a302928ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39385fa637d08b4e64f9c70f690954a302928ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39385fa637d08b4e64f9c70f690954a302928ce0"}], "stats": {"total": 417, "additions": 256, "deletions": 161}, "files": [{"sha": "0fd0f954e413fe59bcdae929a63ec912a8e270be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -1,3 +1,7 @@\n+2013-03-29  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* tree.h (VAR_P): New.\n+\n 2013-03-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR lto/56777"}, {"sha": "224c5a2fe2e3f5347df34f4a48d5fe5af1783523", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -1,3 +1,92 @@\n+2013-03-29  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* call.c (build_java_interface_fn_ref): Likewise.\n+\t(make_temporary_var_for_ref_to_temp): Likewise.\n+\t* class.c (check_field_decls): Likewise.\n+\t(layout_class_type): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t(fixed_type_or_null): Likewise.\n+\t(get_vtbl_decl_for_binfo): Likewise.\n+\t* cp-gimplify.c (omp_var_to_track): Likewise.\n+\t(cp_genericize_r): Likewise.\n+\t* cp-objcp-common.c (cxx_warn_unused_global_decl): Likewise.\n+\t* cp-tree.h (LANG_DECL_HAS_MIN): Likewise.\n+\t(DECL_DISCRIMINATOR_P): Likewise.\n+\t* decl.c (poplevel): Likewise.\n+\t(decls_match): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(decl_jump_unsafe): Likewise.\n+\t(start_decl): Likewise.\n+\t(check_for_uninitialized_const_var): Likewise.\n+\t(make_rtl_for_nonlocal_decl): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(expand_static_init): Likewise.\n+\t(local_variable_p): Likewise.\n+\t(maybe_register_incomplete_var): Likewise.\n+\t* decl2.c (grokfield): Likewise.\n+\t(comdat_linkage): Likewise.\n+\t(determine_visibility): Likewise.\n+\t(import_export_decl): Likewise.\n+\t(prune_vars_needing_no_initialization): Likewise.\n+\t(decl_maybe_constant_var_p): Likewise.\n+\t* error.c (dump_simple_decl): Likewise.\n+\t(dump_template_decl): Likewise.\n+\t(cp_printer): Likewise.\n+\t* except.c (build_throw): Likewise.\n+\t* init.c (build_vtbl_address): Likewise.\n+\t(member_init_ok_or_else): Likewise.\n+\t(build_aggr_init): Likewise.\n+\t(expand_aggr_init_1): Likewise.\n+\t(build_offset_ref): Likewise.\n+\t(constant_value_1): Likewise.\n+\t* mangle.c (write_mangled_name): Likewise.\n+\t(write_prefix): Likewise.\n+\t* name-lookup.c (supplement_binding_1): Likewise.\n+\t(add_decl_to_level): Likewise.\n+\t(pushdecl_maybe_friend_1): Likewise.\n+\t(check_for_out_of_scope_variable): Likewise.\n+\t(validate_nonmember_using_decl): Likewise.\n+\t(lookup_name_innermost_nonclass_level_1): Likewise.\n+\t(lookup_arg_dependent_1): Likewise.\n+\t* parser.c (cp_parser_lambda_introducer): Likewise.\n+\t(cp_parser_template_argument): Likewise.\n+\t(cp_parser_single_declaration): Likewise.\n+\t* pt.c (convert_nontype_argument): Likewise.\n+\t(instantiate_class_template_1): Likewise.\n+\t(tsubst_decl): Likewise.\n+\t(tsubst_expr): Likewise.\n+\t(do_decl_instantiation): Likewise.\n+\t(do_type_instantiation): Likewise.\n+\t(regenerate_decl_from_template): Likewise.\n+\t(always_instantiate_p): Likewise.\n+\t(instantiate_decl): Likewise.\n+\t(type_dependent_expression_p): Likewise.\n+\t(build_non_dependent_expr): Likewise.\n+\t* repo.c (repo_emit_p): Likewise.\n+\t* rtti.c (build_dynamic_cast_1): Likewise.\n+\t* search.c (shared_member_p): Likewise.\n+\t* semantics.c (outer_var_p): Likewise.\n+\t(finish_id_expression): Likewise.\n+\t(finish_omp_clauses): Likewise.\n+\t(finish_decltype_type): Likewise.\n+\t(ensure_literal_type_for_constexpr_object): Likewise.\n+\t* tree.c (lvalue_kind): Likewise.\n+\t(bot_replace): Likewise.\n+\t(cp_tree_equal): Likewise.\n+\t(handle_init_priority_attribute): Likewise.\n+\t(decl_storage_duration): Likewise.\n+\t* typeck.c (cxx_sizeof_expr): Likewise.\n+\t(cxx_alignof_expr): Likewise.\n+\t(decay_conversion): Likewise.\n+\t(build_class_member_access_expr): Likewise.\n+\t(cp_build_array_ref): Likewise.\n+\t(cxx_mark_addressable): Likewise.\n+\t(maybe_warn_about_returning_address_of_local): Likewise.\n+\t(check_return_expr): Likewise.\n+\t* typeck2.c (cxx_readonly_error): Likewise.\n+\t(abstract_virtuals_error_sfinae): Likewise.\n+\t(cxx_incomplete_type_diagnostic): Likewise.\n+\n 2013-03-28  Lawrence Crowl  <crowl@google.com>\n \n \t* Make-lang.in"}, {"sha": "d1777a0ce288350d2894997d08809eb384157f95", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -7162,7 +7162,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   /* Get the java.lang.Class pointer for the interface being called.  */\n   iface = DECL_CONTEXT (fn);\n   iface_ref = lookup_field (iface, get_identifier (\"class$\"), 0, false);\n-  if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n+  if (!iface_ref || !VAR_P (iface_ref)\n       || DECL_CONTEXT (iface_ref) != iface)\n     {\n       error (\"could not find class$ field in java interface type %qT\",\n@@ -9009,7 +9009,7 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n   var = create_temporary_var (type);\n \n   /* Register the variable.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && (TREE_STATIC (decl) || DECL_THREAD_LOCAL_P (decl)))\n     {\n       /* Namespace-scope or local static; give it a mangled name.  */"}, {"sha": "e9f8bbac3a594b1db65c8767df5950bcbe013e3e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -3327,7 +3327,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t     If a union contains a static data member, or a member of\n \t     reference type, the program is ill-formed.  */\n-\t  if (TREE_CODE (x) == VAR_DECL)\n+\t  if (VAR_P (x))\n \t    {\n \t      error (\"%q+D may not be static because it is a member of a union\", x);\n \t      continue;\n@@ -3359,7 +3359,7 @@ check_field_decls (tree t, tree *access_decls,\n       if (type == error_mark_node)\n \tcontinue;\n \n-      if (TREE_CODE (x) == CONST_DECL || TREE_CODE (x) == VAR_DECL)\n+      if (TREE_CODE (x) == CONST_DECL || VAR_P (x))\n \tcontinue;\n \n       /* Now it can only be a FIELD_DECL.  */\n@@ -5826,7 +5826,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \n \t     At this point, finish_record_layout will be called, but\n \t     S1 is still incomplete.)  */\n-\t  if (TREE_CODE (field) == VAR_DECL)\n+\t  if (VAR_P (field))\n \t    {\n \t      maybe_register_incomplete_var (field);\n \t      /* The visibility of static data members is determined\n@@ -6327,7 +6327,7 @@ finish_struct_1 (tree t)\n   /* Complete the rtl for any static member objects of the type we're\n      working on.  */\n   for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n-    if (TREE_CODE (x) == VAR_DECL && TREE_STATIC (x)\n+    if (VAR_P (x) && TREE_STATIC (x)\n         && TREE_TYPE (x) != error_mark_node\n \t&& same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (x)), t))\n       DECL_MODE (x) = TYPE_MODE (t);\n@@ -6700,7 +6700,7 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n \t  /* Enter the INSTANCE in a table to prevent recursion; a\n \t     variable's initializer may refer to the variable\n \t     itself.  */\n-\t  if (TREE_CODE (instance) == VAR_DECL\n+\t  if (VAR_P (instance)\n \t      && DECL_INITIAL (instance)\n \t      && !type_dependent_expression_p_push (DECL_INITIAL (instance))\n \t      && !fixed_type_or_null_ref_ht.find (instance))\n@@ -7766,7 +7766,7 @@ get_vtbl_decl_for_binfo (tree binfo)\n       decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n     }\n   if (decl)\n-    gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+    gcc_assert (VAR_P (decl));\n   return decl;\n }\n "}, {"sha": "38ef87868a8f6606e98a94ab4133d0f2ec55d10b", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -759,7 +759,7 @@ omp_var_to_track (tree decl)\n     type = TREE_TYPE (type);\n   if (type == error_mark_node || !CLASS_TYPE_P (type))\n     return false;\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+  if (VAR_P (decl) && DECL_THREAD_LOCAL_P (decl))\n     return false;\n   if (cxx_omp_predetermined_sharing (decl) != OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n     return false;\n@@ -838,7 +838,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   /* If in an OpenMP context, note var uses.  */\n   if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n-      && (TREE_CODE (stmt) == VAR_DECL\n+      && (VAR_P (stmt)\n \t  || TREE_CODE (stmt) == PARM_DECL\n \t  || TREE_CODE (stmt) == RESULT_DECL)\n       && omp_var_to_track (stmt))\n@@ -998,7 +998,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t{\n \t  tree decl;\n \t  for (decl = BIND_EXPR_VARS (stmt); decl; decl = DECL_CHAIN (decl))\n-\t    if (TREE_CODE (decl) == VAR_DECL\n+\t    if (VAR_P (decl)\n \t\t&& !DECL_EXTERNAL (decl)\n \t\t&& omp_var_to_track (decl))\n \t      {"}, {"sha": "bccd884f5c1e3f8f23b32ea9425d02b26ff307f2", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -62,7 +62,7 @@ cxx_warn_unused_global_decl (const_tree decl)\n     return false;\n \n   /* Const variables take the place of #defines in C++.  */\n-  if (TREE_CODE (decl) == VAR_DECL && TREE_READONLY (decl))\n+  if (VAR_P (decl) && TREE_READONLY (decl))\n     return false;\n \n   return true;"}, {"sha": "edf46d4c262ae373ad917750687d9032aa657878", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -1918,9 +1918,8 @@ struct GTY(()) lang_decl_base {\n \n /* True for DECL codes which have template info and access.  */\n #define LANG_DECL_HAS_MIN(NODE)\t\t\t\\\n-  (TREE_CODE (NODE) == FUNCTION_DECL\t\t\\\n+  (VAR_OR_FUNCTION_DECL_P (NODE)\t\t\\\n    || TREE_CODE (NODE) == FIELD_DECL\t\t\\\n-   || TREE_CODE (NODE) == VAR_DECL\t\t\\\n    || TREE_CODE (NODE) == CONST_DECL\t\t\\\n    || TREE_CODE (NODE) == TYPE_DECL\t\t\\\n    || TREE_CODE (NODE) == TEMPLATE_DECL\t\t\\\n@@ -2200,8 +2199,7 @@ struct GTY((variable_size)) lang_decl {\n \n /* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n #define DECL_DISCRIMINATOR_P(NODE)\t\\\n-  (TREE_CODE (NODE) == VAR_DECL\t\t\\\n-   && DECL_FUNCTION_SCOPE_P (NODE))\n+  (VAR_P (NODE) && DECL_FUNCTION_SCOPE_P (NODE))\n \n /* Discriminator for name mangling.  */\n #define DECL_DISCRIMINATOR(NODE) (LANG_DECL_U2_CHECK (NODE, 1)->discriminator)"}, {"sha": "25fa34b21492c5df712a83c54259cbae62360798", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -622,7 +622,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t   push_local_binding where the list of decls returned by\n \t   getdecls is built.  */\n \tdecl = TREE_CODE (d) == TREE_LIST ? TREE_VALUE (d) : d;\n-\tif (TREE_CODE (decl) == VAR_DECL\n+\tif (VAR_P (decl)\n \t    && (! TREE_USED (decl) || !DECL_READ_P (decl))\n \t    && ! DECL_IN_SYSTEM_HEADER (decl)\n \t    && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl)\n@@ -646,7 +646,7 @@ poplevel (int keep, int reverse, int functionbody)\n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n-      if (leaving_for_scope && TREE_CODE (link) == VAR_DECL\n+      if (leaving_for_scope && VAR_P (link)\n \t  /* It's hard to make this ARM compatibility hack play nicely with\n \t     lambdas, and it really isn't necessary in C++11 mode.  */\n \t  && cxx_dialect < cxx0x\n@@ -1084,7 +1084,7 @@ decls_match (tree newdecl, tree olddecl)\n     {\n       /* Need to check scope for variable declaration (VAR_DECL).\n \t For typedef (TYPE_DECL), scope is ignored.  */\n-      if (TREE_CODE (newdecl) == VAR_DECL\n+      if (VAR_P (newdecl)\n \t  && CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl)\n \t  /* [dcl.link]\n \t     Two declarations for an object with C language linkage\n@@ -1866,7 +1866,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  && newtype == DECL_ORIGINAL_TYPE (newdecl))\n \tnewtype = oldtype;\n \n-      if (TREE_CODE (newdecl) == VAR_DECL)\n+      if (VAR_P (newdecl))\n \t{\n \t  DECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n \t  DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);\n@@ -1903,7 +1903,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  && !(processing_template_decl && uses_template_parms (newdecl)))\n \tlayout_type (TREE_TYPE (newdecl));\n \n-      if ((TREE_CODE (newdecl) == VAR_DECL\n+      if ((VAR_P (newdecl)\n \t   || TREE_CODE (newdecl) == PARM_DECL\n \t   || TREE_CODE (newdecl) == RESULT_DECL\n \t   || TREE_CODE (newdecl) == FIELD_DECL\n@@ -1973,7 +1973,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  /* Keep the old RTL.  */\n \t  COPY_DECL_RTL (olddecl, newdecl);\n \t}\n-      else if (TREE_CODE (newdecl) == VAR_DECL\n+      else if (VAR_P (newdecl)\n \t       && (DECL_SIZE (olddecl) || !DECL_SIZE (newdecl)))\n \t{\n \t  /* Keep the old RTL.  We cannot keep the old RTL if the old\n@@ -2080,7 +2080,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    SET_DECL_THUNKS (newdecl, DECL_THUNKS (olddecl));\n \t}\n       /* Only variables have this field.  */\n-      else if (TREE_CODE (newdecl) == VAR_DECL\n+      else if (VAR_P (newdecl)\n \t       && VAR_HAD_UNKNOWN_BOUND (olddecl))\n \tSET_VAR_HAD_UNKNOWN_BOUND (newdecl);\n     }\n@@ -2256,7 +2256,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n     }\n   /* Init priority used to be merged from newdecl to olddecl by the memcpy,\n      so keep this behavior.  */\n-  if (TREE_CODE (newdecl) == VAR_DECL && DECL_HAS_INIT_PRIORITY_P (newdecl))\n+  if (VAR_P (newdecl) && DECL_HAS_INIT_PRIORITY_P (newdecl))\n     {\n       SET_DECL_INIT_PRIORITY (olddecl, DECL_INIT_PRIORITY (newdecl));\n       DECL_HAS_INIT_PRIORITY_P (olddecl) = 1;\n@@ -2285,7 +2285,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n     TREE_USED (newdecl) = 1;\n   else if (TREE_USED (newdecl))\n     TREE_USED (olddecl) = 1;\n-  if (TREE_CODE (newdecl) == VAR_DECL)\n+  if (VAR_P (newdecl))\n     {\n       if (DECL_READ_P (olddecl))\n \tDECL_READ_P (newdecl) = 1;\n@@ -2396,7 +2396,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n     flags and attributes.  */\n   if (DECL_RTL_SET_P (olddecl)\n       && (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  || (TREE_CODE (olddecl) == VAR_DECL\n+\t  || (VAR_P (olddecl)\n \t      && TREE_STATIC (olddecl))))\n     make_decl_rtl (olddecl);\n \n@@ -2539,7 +2539,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \n       return NULL;\n     }\n-  else if (TREE_CODE (newdecl) == VAR_DECL\n+  else if (VAR_P (newdecl)\n \t   && DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl)\n \t   && (! DECL_LANG_SPECIFIC (olddecl)\n \t       || ! CP_DECL_THREADPRIVATE_P (olddecl)\n@@ -2564,8 +2564,8 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t   union { int i; };\n \n \t   is invalid.  */\n-      if ((TREE_CODE (newdecl) == VAR_DECL && DECL_ANON_UNION_VAR_P (newdecl))\n-\t  || (TREE_CODE (olddecl) == VAR_DECL && DECL_ANON_UNION_VAR_P (olddecl)))\n+      if ((VAR_P (newdecl) && DECL_ANON_UNION_VAR_P (newdecl))\n+\t  || (VAR_P (olddecl) && DECL_ANON_UNION_VAR_P (olddecl)))\n \treturn G_(\"redeclaration of %q#D\");\n       /* If at least one declaration is a reference, there is no\n \t conflict.  For example:\n@@ -2717,7 +2717,7 @@ decl_jump_unsafe (tree decl)\n      preceding types and is declared without an initializer (8.5).  */\n   tree type = TREE_TYPE (decl);\n \n-  if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl)\n+  if (!VAR_P (decl) || TREE_STATIC (decl)\n       || type == error_mark_node)\n     return 0;\n \n@@ -4529,10 +4529,10 @@ start_decl (const cp_declarator *declarator,\n \n   if (TYPE_P (context) && COMPLETE_TYPE_P (complete_type (context)))\n     {\n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \t{\n \t  tree field = lookup_field (context, DECL_NAME (decl), 0, false);\n-\t  if (field == NULL_TREE || TREE_CODE (field) != VAR_DECL)\n+\t  if (field == NULL_TREE || !VAR_P (field))\n \t    error (\"%q#D is not a static member of %q#T\", decl, context);\n \t  else\n \t    {\n@@ -4609,7 +4609,7 @@ start_decl (const cp_declarator *declarator,\n   if (decl == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && DECL_NAMESPACE_SCOPE_P (decl) && !TREE_PUBLIC (decl) && !was_public\n       && !DECL_THIS_STATIC (decl) && !DECL_ARTIFICIAL (decl))\n     {\n@@ -4620,7 +4620,7 @@ start_decl (const cp_declarator *declarator,\n       DECL_THIS_STATIC (decl) = 1;\n     }\n \n-  if (!processing_template_decl && TREE_CODE (decl) == VAR_DECL)\n+  if (!processing_template_decl && VAR_P (decl))\n     start_decl_1 (decl, initialized);\n \n   return decl;\n@@ -4645,7 +4645,7 @@ start_decl_1 (tree decl, bool initialized)\n   if (error_operand_p (decl))\n     return;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n \n   type = TREE_TYPE (decl);\n   complete_p = COMPLETE_TYPE_P (type);\n@@ -4991,7 +4991,7 @@ check_for_uninitialized_const_var (tree decl)\n   /* ``Unless explicitly declared extern, a const object does not have\n      external linkage and must be initialized. ($8.4; $12.1)'' ARM\n      7.1.6 */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && TREE_CODE (type) != REFERENCE_TYPE\n       && CP_TYPE_CONST_P (type)\n       && !DECL_INITIAL (decl))\n@@ -5778,7 +5778,7 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n       /* The `register' keyword, when used together with an\n \t asm-specification, indicates that the variable should be\n \t placed in a particular register.  */\n-      if (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n+      if (VAR_P (decl) && DECL_REGISTER (decl))\n \t{\n \t  set_user_assembler_name (decl, asmspec);\n \t  DECL_HARD_REGISTER (decl) = 1;\n@@ -5793,7 +5793,7 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n     }\n \n   /* Handle non-variables up front.  */\n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     {\n       rest_of_decl_compilation (decl, toplev, at_eof);\n       return;\n@@ -5911,7 +5911,7 @@ initialize_local_var (tree decl, tree init)\n   tree cleanup;\n   int already_used;\n \n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n+  gcc_assert (VAR_P (decl)\n \t      || TREE_CODE (decl) == RESULT_DECL);\n   gcc_assert (!TREE_STATIC (decl));\n \n@@ -6147,7 +6147,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   if (!ensure_literal_type_for_constexpr_object (decl))\n     DECL_DECLARED_CONSTEXPR_P (decl) = 0;\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && DECL_CLASS_SCOPE_P (decl)\n       && DECL_INITIALIZED_IN_CLASS_P (decl))\n     check_static_variable_definition (decl, type);\n@@ -6178,7 +6178,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t}\n     }\n \n-  if (init && TREE_CODE (decl) == VAR_DECL)\n+  if (init && VAR_P (decl))\n     {\n       DECL_NONTRIVIALLY_INITIALIZED_P (decl) = 1;\n       /* If DECL is a reference, then we want to know whether init is a\n@@ -6217,7 +6217,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t then it can be used in future constant expressions, so its value\n \t must be available. */\n \n-      if (TREE_CODE (decl) != VAR_DECL || dependent_type_p (type))\n+      if (!VAR_P (decl) || dependent_type_p (type))\n \t/* We can't do anything if the decl has dependent type.  */;\n       else if (init\n \t       && init_const_expr_p\n@@ -6288,7 +6288,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       TREE_READONLY (decl) = 0;\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       /* If this is a local variable that will need a mangled name,\n \t register it now.  We must do this before processing the\n@@ -6409,7 +6409,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n      static data members in uninstantiated class templates.  */\n   if (VAR_OR_FUNCTION_DECL_P (decl))\n     {\n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \t{\n \t  layout_var_decl (decl);\n \t  maybe_commonize_var (decl);\n@@ -6875,7 +6875,7 @@ register_dtor_fn (tree decl)\n static void\n expand_static_init (tree decl, tree init)\n {\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n   gcc_assert (TREE_STATIC (decl));\n \n   /* Some variables require no dynamic initialization.  */\n@@ -10749,7 +10749,7 @@ grokdeclarator (const cp_declarator *declarator,\n       DECL_THIS_STATIC (decl) = 1;\n \n     /* Set constexpr flag on vars (functions got it in grokfndecl).  */\n-    if (constexpr_p && TREE_CODE (decl) == VAR_DECL)\n+    if (constexpr_p && VAR_P (decl))\n       DECL_DECLARED_CONSTEXPR_P (decl) = true;\n \n     /* Record constancy and volatility on the DECL itself .  There's\n@@ -10791,7 +10791,7 @@ require_complete_types_for_parms (tree parms)\n int\n local_variable_p (const_tree t)\n {\n-  if ((TREE_CODE (t) == VAR_DECL\n+  if ((VAR_P (t)\n        /* A VAR_DECL with a context that is a _TYPE is a static data\n \t  member.  */\n        && !TYPE_P (CP_DECL_CONTEXT (t))\n@@ -14036,7 +14036,7 @@ grokmethod (cp_decl_specifier_seq *declspecs,\n void\n maybe_register_incomplete_var (tree var)\n {\n-  gcc_assert (TREE_CODE (var) == VAR_DECL);\n+  gcc_assert (VAR_P (var));\n \n   /* Keep track of variables with incomplete types.  */\n   if (!processing_template_decl && TREE_TYPE (var) != error_mark_node\n@@ -14295,7 +14295,7 @@ cxx_comdat_group (tree decl)\n   /* Virtual tables, construction virtual tables, and virtual table\n      tables all go in a single COMDAT group, named after the primary\n      virtual table.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_VTABLE_OR_VTT_P (decl))\n+  if (VAR_P (decl) && DECL_VTABLE_OR_VTT_P (decl))\n     name = DECL_ASSEMBLER_NAME (CLASSTYPE_VTABLES (DECL_CONTEXT (decl)));\n   /* For all other DECLs, the COMDAT group is the mangled name of the\n      declaration itself.  */"}, {"sha": "ea290b9e6f4f705de6ba0a4aecfac9a2b2a0a549", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -931,7 +931,7 @@ grokfield (const cp_declarator *declarator,\n \t}\n       else if (TREE_CODE (value) == FIELD_DECL)\n \t/* C++11 NSDMI, keep going.  */;\n-      else if (TREE_CODE (value) != VAR_DECL)\n+      else if (!VAR_P (value))\n \tgcc_unreachable ();\n       else if (!processing_template_decl)\n \t{\n@@ -1603,7 +1603,7 @@ comdat_linkage (tree decl)\n   if (flag_weak)\n     make_decl_one_only (decl, cxx_comdat_group (decl));\n   else if (TREE_CODE (decl) == FUNCTION_DECL\n-\t   || (TREE_CODE (decl) == VAR_DECL && DECL_ARTIFICIAL (decl)))\n+\t   || (VAR_P (decl) && DECL_ARTIFICIAL (decl)))\n     /* We can just emit function and compiler-generated variables\n        statically; having multiple copies is (for the most part) only\n        a waste of space.\n@@ -1674,7 +1674,7 @@ maybe_make_one_only (tree decl)\n     {\n       make_decl_one_only (decl, cxx_comdat_group (decl));\n \n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \t{\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n@@ -2075,7 +2075,7 @@ determine_visibility (tree decl)\n \n       /* Virtual tables have DECL_CONTEXT set to their associated class,\n \t so they are automatically handled above.  */\n-      gcc_assert (TREE_CODE (decl) != VAR_DECL\n+      gcc_assert (!VAR_P (decl)\n \t\t  || !DECL_VTABLE_OR_VTT_P (decl));\n \n       if (DECL_FUNCTION_SCOPE_P (decl) && ! DECL_VISIBILITY_SPECIFIED (decl))\n@@ -2112,7 +2112,7 @@ determine_visibility (tree decl)\n \t     but have no TEMPLATE_INFO, so don't try to check it.  */\n \t  use_template = 0;\n \t}\n-      else if (TREE_CODE (decl) == VAR_DECL && DECL_TINFO_P (decl)\n+      else if (VAR_P (decl) && DECL_TINFO_P (decl)\n \t       && flag_visibility_ms_compat)\n \t{\n \t  /* Under -fvisibility-ms-compat, types are visible by default,\n@@ -2126,7 +2126,7 @@ determine_visibility (tree decl)\n \t  else\n \t    DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n \t}\n-      else if (TREE_CODE (decl) == VAR_DECL && DECL_TINFO_P (decl))\n+      else if (VAR_P (decl) && DECL_TINFO_P (decl))\n \t{\n \t  /* tinfo visibility is based on the type it's for.  */\n \t  constrain_visibility\n@@ -2244,7 +2244,7 @@ determine_visibility (tree decl)\n      symbol flags are updated.  */\n   if ((DECL_VISIBILITY (decl) != orig_visibility\n        || DECL_VISIBILITY_SPECIFIED (decl) != orig_visibility_specified)\n-      && ((TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+      && ((VAR_P (decl) && TREE_STATIC (decl))\n \t  || TREE_CODE (decl) == FUNCTION_DECL)\n       && DECL_RTL_SET_P (decl))\n     make_decl_rtl (decl);\n@@ -2271,7 +2271,7 @@ determine_visibility_from_class (tree decl, tree class_type)\n \n   /* Give the target a chance to override the visibility associated\n      with DECL.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && (DECL_TINFO_P (decl)\n \t  || (DECL_VTABLE_OR_VTT_P (decl)\n \t      /* Construction virtual tables are not exported because\n@@ -2447,7 +2447,7 @@ import_export_decl (tree decl)\n     {\n       /* The repository indicates that this entity should be defined\n \t here.  Make sure the back end honors that request.  */\n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \tmark_needed (decl);\n       else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)\n \t       || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n@@ -2468,7 +2468,7 @@ import_export_decl (tree decl)\n     /* We have already decided what to do with this DECL; there is no\n        need to check anything further.  */\n     ;\n-  else if (TREE_CODE (decl) == VAR_DECL && DECL_VTABLE_OR_VTT_P (decl))\n+  else if (VAR_P (decl) && DECL_VTABLE_OR_VTT_P (decl))\n     {\n       class_type = DECL_CONTEXT (decl);\n       import_export_class (class_type);\n@@ -2534,7 +2534,7 @@ import_export_decl (tree decl)\n       else\n \tcomdat_p = true;\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL && DECL_TINFO_P (decl))\n+  else if (VAR_P (decl) && DECL_TINFO_P (decl))\n     {\n       tree type = TREE_TYPE (DECL_NAME (decl));\n       if (CLASS_TYPE_P (type))\n@@ -3267,7 +3267,7 @@ fix_temporary_vars_context_r (tree *node,\n       tree var;\n \n       for (var = BIND_EXPR_VARS (*node); var; var = DECL_CHAIN (var))\n-\tif (TREE_CODE (var) == VAR_DECL\n+\tif (VAR_P (var)\n \t  && !DECL_NAME (var)\n \t  && DECL_ARTIFICIAL (var)\n \t  && !DECL_CONTEXT (var))\n@@ -3516,7 +3516,7 @@ prune_vars_needing_no_initialization (tree *vars)\n \t}\n \n       /* The only things that can be initialized are variables.  */\n-      gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+      gcc_assert (VAR_P (decl));\n \n       /* If this object is not defined, we don't need to do anything\n \t here.  */\n@@ -3796,7 +3796,7 @@ decl_defined_p (tree decl)\n     return (DECL_INITIAL (decl) != NULL_TREE);\n   else\n     {\n-      gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+      gcc_assert (VAR_P (decl));\n       return !DECL_EXTERNAL (decl);\n     }\n }\n@@ -3838,7 +3838,7 @@ bool\n decl_maybe_constant_var_p (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     return false;\n   if (DECL_DECLARED_CONSTEXPR_P (decl))\n     return true;"}, {"sha": "2af900ded8bba42d5fa3aefc7223df5cf4825609", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -916,7 +916,7 @@ dump_simple_decl (tree t, tree type, int flags)\n {\n   if (flags & TFF_DECL_SPECIFIERS)\n     {\n-      if (TREE_CODE (t) == VAR_DECL\n+      if (VAR_P (t)\n \t  && DECL_DECLARED_CONSTEXPR_P (t))\n \tpp_cxx_ws_string (cxx_pp, \"constexpr\");\n       dump_type_prefix (type, flags & ~TFF_UNQUALIFIED_NAME);\n@@ -1249,7 +1249,7 @@ dump_template_decl (tree t, int flags)\n \t       ((flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n \t\t| (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0)));\n   else if (DECL_TEMPLATE_RESULT (t)\n-           && (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL\n+           && (VAR_P (DECL_TEMPLATE_RESULT (t))\n \t       /* Alias template.  */\n \t       || DECL_TYPE_TEMPLATE_P (t)))\n     dump_decl (DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n@@ -3283,7 +3283,7 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n     case 'D':\n       {\n \ttree temp = next_tree;\n-\tif (TREE_CODE (temp) == VAR_DECL\n+\tif (VAR_P (temp)\n \t    && DECL_HAS_DEBUG_EXPR_P (temp))\n \t  {\n \t    temp = DECL_DEBUG_EXPR (temp);"}, {"sha": "0f295b006bc3d1af2475f59988ed007fd83c94de", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -828,7 +828,7 @@ build_throw (tree exp)\n \t     treated as an rvalue for the purposes of overload resolution\n \t     to favor move constructors over copy constructors.  */\n \t  if (/* Must be a local, automatic variable.  */\n-\t      TREE_CODE (exp) == VAR_DECL\n+\t      VAR_P (exp)\n \t      && DECL_CONTEXT (exp) == current_function_decl\n \t      && ! TREE_STATIC (exp)\n \t      /* The variable must not have the `volatile' qualifier.  */"}, {"sha": "000f514a43cf345268ff0d9b5d2d27dec3c67083", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -1131,7 +1131,7 @@ build_vtbl_address (tree binfo)\n \n   /* Now compute the address to use when initializing the vptr.  */\n   vtbl = unshare_expr (BINFO_VTABLE (binfo_for));\n-  if (TREE_CODE (vtbl) == VAR_DECL)\n+  if (VAR_P (vtbl))\n     vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n \n   return vtbl;\n@@ -1293,7 +1293,7 @@ member_init_ok_or_else (tree field, tree type, tree member_name)\n \t     member_name);\n       return 0;\n     }\n-  if (TREE_CODE (field) == VAR_DECL)\n+  if (VAR_P (field))\n     {\n       error (\"%q#D is a static data member; it can only be \"\n \t     \"initialized at its definition\",\n@@ -1515,7 +1515,7 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n       return stmt_expr;\n     }\n \n-  if (TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == PARM_DECL)\n+  if (VAR_P (exp) || TREE_CODE (exp) == PARM_DECL)\n     /* Just know that we've seen something for this node.  */\n     TREE_USED (exp) = 1;\n \n@@ -1728,7 +1728,7 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n      in and expand the constructor.  Constructors now come\n      as TARGET_EXPRs.  */\n \n-  if (init && TREE_CODE (exp) == VAR_DECL\n+  if (init && VAR_P (exp)\n       && COMPOUND_LITERAL_P (init))\n     {\n       vec<tree, va_gc> *cleanups = NULL;\n@@ -1849,7 +1849,7 @@ build_offset_ref (tree type, tree member, bool address_p)\n      processing.  */\n   if (TREE_CODE (member) == TYPE_DECL)\n     return member;\n-  if (TREE_CODE (member) == VAR_DECL || TREE_CODE (member) == CONST_DECL)\n+  if (VAR_P (member) || TREE_CODE (member) == CONST_DECL)\n     return convert_from_reference (member);\n \n   if (TREE_CODE (member) == FIELD_DECL && DECL_C_BIT_FIELD (member))\n@@ -1964,7 +1964,7 @@ constant_value_1 (tree decl, bool integral_p, bool return_aggregate_cst_ok_p)\n   while (TREE_CODE (decl) == CONST_DECL\n \t || (integral_p\n \t     ? decl_constant_var_p (decl)\n-\t     : (TREE_CODE (decl) == VAR_DECL\n+\t     : (VAR_P (decl)\n \t\t&& CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))))\n     {\n       tree init;"}, {"sha": "08bfa22e0fab67bf2e678c5e166827ca65aae0cb", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -663,7 +663,7 @@ write_mangled_name (const tree decl, bool top_level)\n \t  write_source_name (DECL_NAME (decl));\n \t}\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL\n+  else if (VAR_P (decl)\n \t   /* The names of non-static global variables aren't mangled.  */\n \t   && DECL_EXTERNAL_LINKAGE_P (decl)\n \t   && (CP_DECL_CONTEXT (decl) == global_namespace\n@@ -1042,7 +1042,7 @@ write_prefix (const tree node)\n     {\n       write_prefix (decl_mangling_context (decl));\n       write_unqualified_name (decl);\n-      if (TREE_CODE (decl) == VAR_DECL\n+      if (VAR_P (decl)\n \t  || TREE_CODE (decl) == FIELD_DECL)\n \t{\n \t  /* <data-member-prefix> := <member source-name> M */"}, {"sha": "b25db14f1e1f95baef25d2a10bd6dd4df25ad004", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -509,8 +509,8 @@ supplement_binding_1 (cxx_binding *binding, tree decl)\n \n        A member shall not be declared twice in the\n        member-specification.  */\n-  else if (TREE_CODE (target_decl) == VAR_DECL\n-\t   && TREE_CODE (target_bval) == VAR_DECL\n+  else if (VAR_P (target_decl)\n+\t   && VAR_P (target_bval)\n \t   && DECL_EXTERNAL (target_decl) && DECL_EXTERNAL (target_bval)\n \t   && !DECL_CLASS_SCOPE_P (target_decl))\n     {\n@@ -574,7 +574,7 @@ add_decl_to_level (tree decl, cp_binding_level *b)\n {\n   /* We used to record virtual tables as if they were ordinary\n      variables, but no longer do so.  */\n-  gcc_assert (!(TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl)));\n+  gcc_assert (!(VAR_P (decl) && DECL_VIRTUAL_P (decl)));\n \n   if (TREE_CODE (decl) == NAMESPACE_DECL\n       && !DECL_NAMESPACE_ALIAS (decl))\n@@ -594,7 +594,7 @@ add_decl_to_level (tree decl, cp_binding_level *b)\n \t static later.  It's OK for this list to contain a few false\n \t positives.  */\n       if (b->kind == sk_namespace)\n-\tif ((TREE_CODE (decl) == VAR_DECL\n+\tif ((VAR_P (decl)\n \t     && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t    || (TREE_CODE (decl) == FUNCTION_DECL\n \t\t&& (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl))))\n@@ -636,7 +636,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t  /* A local declaration for an `extern' variable is in the\n \t     scope of the current namespace, not the current\n \t     function.  */\n-\t  && !(TREE_CODE (x) == VAR_DECL && DECL_EXTERNAL (x))\n+\t  && !(VAR_P (x) && DECL_EXTERNAL (x))\n \t  /* When parsing the parameter list of a function declarator,\n \t     don't set DECL_CONTEXT to an enclosing function.  When we\n \t     push the PARM_DECLs in order to process the function body,\n@@ -973,7 +973,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n \t\t&& t != NULL_TREE)\n \t      && (TREE_CODE (x) == TYPE_DECL\n-\t\t  || TREE_CODE (x) == VAR_DECL\n+\t\t  || VAR_P (x)\n \t\t  || TREE_CODE (x) == NAMESPACE_DECL\n \t\t  || TREE_CODE (x) == CONST_DECL\n \t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n@@ -1021,7 +1021,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t      tree d = oldlocal;\n \n \t      while (oldlocal\n-\t\t     && TREE_CODE (oldlocal) == VAR_DECL\n+\t\t     && VAR_P (oldlocal)\n \t\t     && DECL_DEAD_FOR_LOCAL (oldlocal))\n \t\toldlocal = DECL_SHADOWED_FOR_VAR (oldlocal);\n \n@@ -1065,7 +1065,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t   /* Inline decls shadow nothing.  */\n \t\t   && !DECL_FROM_INLINE (x)\n \t\t   && (TREE_CODE (oldlocal) == PARM_DECL\n-\t\t       || TREE_CODE (oldlocal) == VAR_DECL\n+\t\t       || VAR_P (oldlocal)\n                        /* If the old decl is a type decl, only warn if the\n                           old decl is an explicit typedef or if both the old\n                           and new decls are type decls.  */\n@@ -1125,7 +1125,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t outermost block of the controlled statement.\n \t\t Redeclaring a variable from a for or while condition is\n \t\t detected elsewhere.  */\n-\t      else if (TREE_CODE (oldlocal) == VAR_DECL\n+\t      else if (VAR_P (oldlocal)\n \t\t       && oldscope == current_binding_level->level_chain\n \t\t       && (oldscope->kind == sk_cond\n \t\t\t   || oldscope->kind == sk_for))\n@@ -1179,7 +1179,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t\t   x);\n \t\t}\n \t      else if (oldglobal != NULL_TREE\n-\t\t       && (TREE_CODE (oldglobal) == VAR_DECL\n+\t\t       && (VAR_P (oldglobal)\n                            /* If the old decl is a type decl, only warn if the\n                               old decl is an explicit typedef or if both the\n                               old and new decls are type decls.  */\n@@ -1196,7 +1196,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t    }\n \t}\n \n-      if (TREE_CODE (x) == VAR_DECL)\n+      if (VAR_P (x))\n \tmaybe_register_incomplete_var (x);\n     }\n \n@@ -1309,12 +1309,12 @@ check_for_out_of_scope_variable (tree decl)\n   tree shadowed;\n \n   /* We only care about out of scope variables.  */\n-  if (!(TREE_CODE (decl) == VAR_DECL && DECL_DEAD_FOR_LOCAL (decl)))\n+  if (!(VAR_P (decl) && DECL_DEAD_FOR_LOCAL (decl)))\n     return decl;\n \n   shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (decl)\n     ? DECL_SHADOWED_FOR_VAR (decl) : NULL_TREE ;\n-  while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n+  while (shadowed != NULL_TREE && VAR_P (shadowed)\n \t && DECL_DEAD_FOR_LOCAL (shadowed))\n     shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (shadowed)\n       ? DECL_SHADOWED_FOR_VAR (shadowed) : NULL_TREE;\n@@ -2435,7 +2435,7 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n \n   if (using_decl == NULL_TREE\n       && at_function_scope_p ()\n-      && TREE_CODE (decl) == VAR_DECL)\n+      && VAR_P (decl))\n     /* C++11 7.3.3/10.  */\n     error (\"%qD is already declared in this scope\", name);\n   \n@@ -3061,7 +3061,7 @@ push_class_level_binding_1 (tree name, tree x)\n \n      (Non-static data members were also forbidden to have the same\n      name as T until TC1.)  */\n-  if ((TREE_CODE (x) == VAR_DECL\n+  if ((VAR_P (x)\n        || TREE_CODE (x) == CONST_DECL\n        || (TREE_CODE (x) == TYPE_DECL\n \t   && !DECL_SELF_REFERENCE_P (x))\n@@ -4955,7 +4955,7 @@ lookup_name_innermost_nonclass_level_1 (tree name)\n       while (1)\n \t{\n \t  if (binding->scope == b\n-\t      && !(TREE_CODE (binding->value) == VAR_DECL\n+\t      && !(VAR_P (binding->value)\n \t\t   && DECL_DEAD_FOR_LOCAL (binding->value)))\n \t    return binding->value;\n \n@@ -4994,7 +4994,7 @@ is_local_extern (tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     return DECL_LOCAL_FUNCTION_P (decl);\n \n-  if (TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_P (decl))\n     return false;\n   if (!current_function_decl)\n     return false;\n@@ -5554,7 +5554,7 @@ lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args,\n   fns = k.functions;\n   \n   if (fns\n-      && TREE_CODE (fns) != VAR_DECL\n+      && !VAR_P (fns)\n       && !is_overloaded_fn (fns))\n     {\n       error (\"argument dependent lookup finds %q+D\", fns);"}, {"sha": "09c5dff7ceadb2adca550a4ece8e5ddfb1bb2232", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -8479,7 +8479,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t      continue;\n \t    }\n \t  else if (DECL_P (capture_init_expr)\n-\t\t   && (TREE_CODE (capture_init_expr) != VAR_DECL\n+\t\t   && (!VAR_P (capture_init_expr)\n \t\t       && TREE_CODE (capture_init_expr) != PARM_DECL))\n \t    {\n \t      error_at (capture_token->location,\n@@ -8488,7 +8488,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t      inform (0, \"%q+#D declared here\", capture_init_expr);\n \t      continue;\n \t    }\n-\t  if (TREE_CODE (capture_init_expr) == VAR_DECL\n+\t  if (VAR_P (capture_init_expr)\n \t      && decl_storage_duration (capture_init_expr) != dk_auto)\n \t    {\n \t      pedwarn (capture_token->location, 0, \"capture of variable \"\n@@ -13332,7 +13332,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t  probe = argument;\n \t  if (TREE_CODE (probe) == SCOPE_REF)\n \t    probe = TREE_OPERAND (probe, 1);\n-\t  if (TREE_CODE (probe) == VAR_DECL)\n+\t  if (VAR_P (probe))\n \t    {\n \t      /* A variable without external linkage might still be a\n \t\t valid constant-expression, so no error is issued here\n@@ -22146,7 +22146,7 @@ cp_parser_single_declaration (cp_parser* parser,\n         decl = error_mark_node;\n       }\n \n-    if (decl && TREE_CODE (decl) == VAR_DECL)\n+    if (decl && VAR_P (decl))\n       check_template_variable (decl);\n     }\n "}, {"sha": "8468a84b285f8a3904b4515ccb8dff1ee2b8cce7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -5646,7 +5646,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       else if (TREE_CODE (expr) != ADDR_EXPR\n \t       && TREE_CODE (expr_type) != ARRAY_TYPE)\n \t{\n-\t  if (TREE_CODE (expr) == VAR_DECL)\n+\t  if (VAR_P (expr))\n \t    {\n \t      error (\"%qD is not a valid template argument \"\n \t\t     \"because %qD is a variable, not the address of \"\n@@ -5671,7 +5671,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n \t  decl = ((TREE_CODE (expr) == ADDR_EXPR)\n \t\t  ? TREE_OPERAND (expr, 0) : expr);\n-\t  if (TREE_CODE (decl) != VAR_DECL)\n+\t  if (!VAR_P (decl))\n \t    {\n \t      error (\"%qE is not a valid template argument of type %qT \"\n \t\t     \"because %qE is not a variable\",\n@@ -8837,7 +8837,7 @@ instantiate_class_template_1 (tree type)\n \t\t  r = tsubst (t, args, tf_warning_or_error, NULL_TREE);\n \t\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t\t    --processing_template_decl;\n-\t\t  if (TREE_CODE (r) == VAR_DECL)\n+\t\t  if (VAR_P (r))\n \t\t    {\n \t\t      /* In [temp.inst]:\n \n@@ -10639,7 +10639,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    break;\n \t  }\n \n-\tif (TREE_CODE (t) == VAR_DECL && DECL_ANON_UNION_VAR_P (t))\n+\tif (VAR_P (t) && DECL_ANON_UNION_VAR_P (t))\n \t  {\n \t    /* Just use name lookup to find a member alias for an anonymous\n \t       union, but then add it to the hash table.  */\n@@ -10657,13 +10657,13 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t      type = DECL_ORIGINAL_TYPE (t);\n \t    else\n \t      type = TREE_TYPE (t);\n-\t    if (TREE_CODE (t) == VAR_DECL\n+\t    if (VAR_P (t)\n \t\t&& VAR_HAD_UNKNOWN_BOUND (t)\n \t\t&& type != error_mark_node)\n \t      type = strip_array_domain (type);\n \t    type = tsubst (type, args, complain, in_decl);\n \t  }\n-\tif (TREE_CODE (r) == VAR_DECL)\n+\tif (VAR_P (r))\n \t  {\n \t    /* Even if the original location is out of scope, the\n \t       newly substituted one is not.  */\n@@ -10727,7 +10727,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_WRTL))\n \t  SET_DECL_RTL (r, NULL);\n \tDECL_SIZE (r) = DECL_SIZE_UNIT (r) = 0;\n-\tif (TREE_CODE (r) == VAR_DECL)\n+\tif (VAR_P (r))\n \t  {\n \t    /* Possibly limit visibility based on template args.  */\n \t    DECL_VISIBILITY (r) = VISIBILITY_DEFAULT;\n@@ -12897,9 +12897,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t   handle local variables, and since we've already done\n \t\t   all that needs to be done, that's the right thing to\n \t\t   do.  */\n-\t\tif (TREE_CODE (decl) == VAR_DECL)\n+\t\tif (VAR_P (decl))\n \t\t  DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n-\t\tif (TREE_CODE (decl) == VAR_DECL\n+\t\tif (VAR_P (decl)\n \t\t    && ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n \t\t  /* Anonymous aggregates are a special case.  */\n \t\t  finish_anon_union (decl);\n@@ -12920,7 +12920,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t  {\n \t\t    int const_init = false;\n \t\t    maybe_push_decl (decl);\n-\t\t    if (TREE_CODE (decl) == VAR_DECL\n+\t\t    if (VAR_P (decl)\n \t\t\t&& DECL_PRETTY_FUNCTION_P (decl))\n \t\t      {\n \t\t\t/* For __PRETTY_FUNCTION__ we have to adjust the\n@@ -12951,7 +12951,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t  init = t;\n \t\t      }\n \n-\t\t    if (TREE_CODE (decl) == VAR_DECL)\n+\t\t    if (VAR_P (decl))\n \t\t      const_init = (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P\n \t\t\t\t    (pattern_decl));\n \t\t    cp_finish_decl (decl, init, const_init, NULL_TREE, 0);\n@@ -18008,7 +18008,7 @@ do_decl_instantiation (tree decl, tree storage)\n       error (\"explicit instantiation of non-template %q#D\", decl);\n       return;\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_P (decl))\n     {\n       /* There is an asymmetry here in the way VAR_DECLs and\n \t FUNCTION_DECLs are handled by grokdeclarator.  In the case of\n@@ -18024,7 +18024,7 @@ do_decl_instantiation (tree decl, tree storage)\n \t  return;\n \t}\n       result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, false);\n-      if (!result || TREE_CODE (result) != VAR_DECL)\n+      if (!result || !VAR_P (result))\n \t{\n \t  error (\"no matching template for %qD found\", decl);\n \t  return;\n@@ -18286,7 +18286,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t  instantiate_class_member (tmp, extern_p);\n \n     for (tmp = TYPE_FIELDS (t); tmp; tmp = DECL_CHAIN (tmp))\n-      if (TREE_CODE (tmp) == VAR_DECL && DECL_TEMPLATE_INSTANTIATION (tmp))\n+      if (VAR_P (tmp) && DECL_TEMPLATE_INSTANTIATION (tmp))\n \tinstantiate_class_member (tmp, extern_p);\n \n     if (CLASSTYPE_NESTED_UTDS (t))\n@@ -18415,7 +18415,7 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n \t  && !DECL_DECLARED_INLINE_P (decl))\n \tDECL_DECLARED_INLINE_P (decl) = 1;\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n+  else if (VAR_P (decl))\n     {\n       DECL_INITIAL (decl) =\n \ttsubst_expr (DECL_INITIAL (code_pattern), args,\n@@ -18479,7 +18479,7 @@ template_for_substitution (tree decl)\n \t cannot restructure the loop to just keep going until we find\n \t a template with a definition, since that might go too far if\n \t a specialization was declared, but not defined.  */\n-      gcc_assert (TREE_CODE (decl) != VAR_DECL\n+      gcc_assert (!VAR_P (decl)\n \t\t  || DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (tmpl)));\n \n       /* Fetch the more general template.  */\n@@ -18507,7 +18507,7 @@ always_instantiate_p (tree decl)\n \t  /* And we need to instantiate static data members so that\n \t     their initializers are available in integral constant\n \t     expressions.  */\n-\t  || (TREE_CODE (decl) == VAR_DECL\n+\t  || (VAR_P (decl)\n \t      && decl_maybe_constant_var_p (decl)));\n }\n \n@@ -18611,7 +18611,7 @@ instantiate_decl (tree d, int defer_ok,\n      case that an expression refers to the value of the variable --\n      if the variable has a constant value the referring expression can\n      take advantage of that fact.  */\n-  if (TREE_CODE (d) == VAR_DECL\n+  if (VAR_P (d)\n       || DECL_DECLARED_CONSTEXPR_P (d))\n     defer_ok = 0;\n \n@@ -18730,11 +18730,11 @@ instantiate_decl (tree d, int defer_ok,\n \t elsewhere, we don't want to instantiate the entire data\n \t member, but we do want to instantiate the initializer so that\n \t we can substitute that elsewhere.  */\n-      || (external_p && TREE_CODE (d) == VAR_DECL))\n+      || (external_p && VAR_P (d)))\n     {\n       /* The definition of the static data member is now required so\n \t we must substitute the initializer.  */\n-      if (TREE_CODE (d) == VAR_DECL\n+      if (VAR_P (d)\n \t  && !DECL_INITIAL (d)\n \t  && DECL_INITIAL (code_pattern))\n \t{\n@@ -18784,7 +18784,7 @@ instantiate_decl (tree d, int defer_ok,\n \tgoto out;\n       /* ??? Historically, we have instantiated inline functions, even\n \t when marked as \"extern template\".  */\n-      if (!(external_p && TREE_CODE (d) == VAR_DECL))\n+      if (!(external_p && VAR_P (d)))\n \tadd_pending_template (d);\n       goto out;\n     }\n@@ -18824,7 +18824,7 @@ instantiate_decl (tree d, int defer_ok,\n      they changed as a result of calling regenerate_decl_from_template.  */\n   input_location = DECL_SOURCE_LOCATION (d);\n \n-  if (TREE_CODE (d) == VAR_DECL)\n+  if (VAR_P (d))\n     {\n       tree init;\n       bool const_init = false;\n@@ -19873,7 +19873,7 @@ type_dependent_expression_p (tree expression)\n   /* A static data member of the current instantiation with incomplete\n      array type is type-dependent, as the definition and specializations\n      can have different bounds.  */\n-  if (TREE_CODE (expression) == VAR_DECL\n+  if (VAR_P (expression)\n       && DECL_CLASS_SCOPE_P (expression)\n       && dependent_type_p (DECL_CONTEXT (expression))\n       && VAR_HAD_UNKNOWN_BOUND (expression))\n@@ -20467,7 +20467,7 @@ build_non_dependent_expr (tree expr)\n       || TREE_CODE (inner_expr) == OFFSET_REF)\n     return expr;\n   /* There is no need to return a proxy for a variable.  */\n-  if (TREE_CODE (expr) == VAR_DECL)\n+  if (VAR_P (expr))\n     return expr;\n   /* Preserve string constants; conversions from string constants to\n      \"char *\" are allowed, even though normally a \"const char *\""}, {"sha": "7b6f7b8ce1bd557e0bd7a6a6329096e918765c1c", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -302,7 +302,7 @@ repo_emit_p (tree decl)\n      is an artificial restriction; the code in the prelinker and here\n      will work fine if all entities with vague linkage are managed by\n      the repository.  */\n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       tree type = NULL_TREE;\n       if (DECL_VTABLE_OR_VTT_P (decl))"}, {"sha": "b6a9a2edb4a8e13bd9b513183db5dda04461cc53", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -635,7 +635,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t{\n \t  /* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */\n \t  if (TREE_CODE (expr) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (expr, 0)) == VAR_DECL\n+\t      && VAR_P (TREE_OPERAND (expr, 0))\n \t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE)\n \t    return build1 (NOP_EXPR, type, expr);\n \n@@ -658,7 +658,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n \t  if (tc == REFERENCE_TYPE)\n \t    {\n-\t      if (TREE_CODE (old_expr) == VAR_DECL\n+\t      if (VAR_P (old_expr)\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n \t\t{\n \t\t  tree expr = throw_bad_cast ();\n@@ -674,7 +674,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t  else if (TREE_CODE (expr) == ADDR_EXPR)\n \t    {\n \t      tree op = TREE_OPERAND (expr, 0);\n-\t      if (TREE_CODE (op) == VAR_DECL\n+\t      if (VAR_P (op)\n \t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n \t\t{\n                   if (complain & tf_warning)"}, {"sha": "19a4c43ff0d3df90383412564968258baa495c84", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -983,7 +983,7 @@ struct lookup_field_info {\n int\n shared_member_p (tree t)\n {\n-  if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == TYPE_DECL \\\n+  if (VAR_P (t) || TREE_CODE (t) == TYPE_DECL \\\n       || TREE_CODE (t) == CONST_DECL)\n     return 1;\n   if (is_overloaded_fn (t))"}, {"sha": "8bd76120fc70b328705f28954bd7978754f6631b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -2887,7 +2887,7 @@ baselink_for_fns (tree fns)\n static bool\n outer_var_p (tree decl)\n {\n-  return ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+  return ((VAR_P (decl) || TREE_CODE (decl) == PARM_DECL)\n \t  && DECL_FUNCTION_SCOPE_P (decl)\n \t  && (DECL_CONTEXT (decl) != current_function_decl\n \t      || parsing_nsdmi ()));\n@@ -3083,7 +3083,7 @@ finish_id_expression (tree id_expression,\n \t    }\n \t  else\n \t    {\n-\t      error (TREE_CODE (decl) == VAR_DECL\n+\t      error (VAR_P (decl)\n \t\t     ? G_(\"use of local variable with automatic storage from containing function\")\n \t\t     : G_(\"use of parameter from containing function\"));\n \t      error (\"  %q+#D declared here\", decl);\n@@ -3259,7 +3259,7 @@ finish_id_expression (tree id_expression,\n \t  /* If we found a variable, then name lookup during the\n \t     instantiation will always resolve to the same VAR_DECL\n \t     (or an instantiation thereof).  */\n-\t  if (TREE_CODE (decl) == VAR_DECL\n+\t  if (VAR_P (decl)\n \t      || TREE_CODE (decl) == PARM_DECL)\n \t    {\n \t      mark_used (decl);\n@@ -3303,7 +3303,7 @@ finish_id_expression (tree id_expression,\n \n       /* Mark variable-like entities as used.  Functions are similarly\n \t marked either below or after overload resolution.  */\n-      if ((TREE_CODE (decl) == VAR_DECL\n+      if ((VAR_P (decl)\n \t   || TREE_CODE (decl) == PARM_DECL\n \t   || TREE_CODE (decl) == CONST_DECL\n \t   || TREE_CODE (decl) == RESULT_DECL)\n@@ -3328,7 +3328,7 @@ finish_id_expression (tree id_expression,\n \t}\n \n       tree wrap;\n-      if (TREE_CODE (decl) == VAR_DECL\n+      if (VAR_P (decl)\n \t  && !cp_unevaluated_operand\n \t  && DECL_THREAD_LOCAL_P (decl)\n \t  && (wrap = get_tls_wrapper_fn (decl)))\n@@ -4061,7 +4061,7 @@ finish_omp_clauses (tree clauses)\n \t  goto check_dup_generic;\n \tcheck_dup_generic:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -4084,7 +4084,7 @@ finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -4106,7 +4106,7 @@ finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl)\n \t\tbreak;\n@@ -4258,7 +4258,7 @@ finish_omp_clauses (tree clauses)\n \n       t = OMP_CLAUSE_DECL (c);\n       if (processing_template_decl\n-\t  && TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  && !VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t{\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n@@ -4298,7 +4298,7 @@ finish_omp_clauses (tree clauses)\n \t  break;\n \n \tcase OMP_CLAUSE_COPYIN:\n-\t  if (TREE_CODE (t) != VAR_DECL || !DECL_THREAD_LOCAL_P (t))\n+\t  if (!VAR_P (t) || !DECL_THREAD_LOCAL_P (t))\n \t    {\n \t      error (\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n \t      remove = true;\n@@ -4325,7 +4325,7 @@ finish_omp_clauses (tree clauses)\n \t{\n \t  const char *share_name = NULL;\n \n-\t  if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t  if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))\n \t    share_name = \"threadprivate\";\n \t  else switch (cxx_omp_predetermined_sharing (t))\n \t    {\n@@ -4392,7 +4392,7 @@ finish_omp_threadprivate (tree vars)\n \n       if (error_operand_p (v))\n \t;\n-      else if (TREE_CODE (v) != VAR_DECL)\n+      else if (!VAR_P (v))\n \terror (\"%<threadprivate%> %qD is not file, namespace \"\n \t       \"or block scope variable\", v);\n       /* If V had already been marked threadprivate, it doesn't matter\n@@ -5295,7 +5295,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n \n   /* To get the size of a static data member declared as an array of\n      unknown bound, we need to instantiate it.  */\n-  if (TREE_CODE (expr) == VAR_DECL\n+  if (VAR_P (expr)\n       && VAR_HAD_UNKNOWN_BOUND (expr)\n       && DECL_TEMPLATE_INSTANTIATION (expr))\n     instantiate_decl (expr, /*defer_ok*/true, /*expl_inst_mem*/false);\n@@ -5727,7 +5727,7 @@ tree\n ensure_literal_type_for_constexpr_object (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_DECLARED_CONSTEXPR_P (decl)\n+  if (VAR_P (decl) && DECL_DECLARED_CONSTEXPR_P (decl)\n       && !processing_template_decl)\n     {\n       if (CLASS_TYPE_P (type) && !COMPLETE_TYPE_P (complete_type (type)))\n@@ -9200,7 +9200,7 @@ capture_decltype (tree decl)\n bool\n is_capture_proxy (tree decl)\n {\n-  return (TREE_CODE (decl) == VAR_DECL\n+  return (VAR_P (decl)\n \t  && DECL_HAS_VALUE_EXPR_P (decl)\n \t  && !DECL_ANON_UNION_VAR_P (decl)\n \t  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));"}, {"sha": "8faf566c3f3191582ae333896206c186b0c8630a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -70,7 +70,7 @@ lvalue_kind (const_tree ref)\n       /* unnamed rvalue references are rvalues */\n       if (TYPE_REF_IS_RVALUE (TREE_TYPE (ref))\n \t  && TREE_CODE (ref) != PARM_DECL\n-\t  && TREE_CODE (ref) != VAR_DECL\n+\t  && !VAR_P (ref)\n \t  && TREE_CODE (ref) != COMPONENT_REF\n \t  /* Functions are always lvalues.  */\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (ref))) != FUNCTION_TYPE)\n@@ -2219,7 +2219,7 @@ bot_replace (tree* t, int* /*walk_subtrees*/, void* data)\n {\n   splay_tree target_remap = ((splay_tree) data);\n \n-  if (TREE_CODE (*t) == VAR_DECL)\n+  if (VAR_P (*t))\n     {\n       splay_tree_node n = splay_tree_lookup (target_remap,\n \t\t\t\t\t     (splay_tree_key) *t);\n@@ -2584,10 +2584,10 @@ cp_tree_equal (tree t1, tree t2)\n \t   it means that it's going to be unified with whatever the\n \t   TARGET_EXPR is really supposed to initialize, so treat it\n \t   as being equivalent to anything.  */\n-\tif (TREE_CODE (o1) == VAR_DECL && DECL_NAME (o1) == NULL_TREE\n+\tif (VAR_P (o1) && DECL_NAME (o1) == NULL_TREE\n \t    && !DECL_RTL_SET_P (o1))\n \t  /*Nop*/;\n-\telse if (TREE_CODE (o2) == VAR_DECL && DECL_NAME (o2) == NULL_TREE\n+\telse if (VAR_P (o2) && DECL_NAME (o2) == NULL_TREE\n \t\t && !DECL_RTL_SET_P (o2))\n \t  /*Nop*/;\n \telse if (!cp_tree_equal (o1, o2))\n@@ -3149,7 +3149,7 @@ handle_init_priority_attribute (tree* node,\n   type = strip_array_types (type);\n \n   if (decl == NULL_TREE\n-      || TREE_CODE (decl) != VAR_DECL\n+      || !VAR_P (decl)\n       || !TREE_STATIC (decl)\n       || DECL_EXTERNAL (decl)\n       || (TREE_CODE (type) != RECORD_TYPE\n@@ -3618,7 +3618,7 @@ decl_storage_duration (tree decl)\n     return dk_auto;\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     return dk_static;\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (VAR_P (decl));\n   if (!TREE_STATIC (decl)\n       && !DECL_EXTERNAL (decl))\n     return dk_auto;"}, {"sha": "34263b716dda532649f2dd85cf66ba969792f765", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -1581,7 +1581,7 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n \n   /* To get the size of a static data member declared as an array of\n      unknown bound, we need to instantiate it.  */\n-  if (TREE_CODE (e) == VAR_DECL\n+  if (VAR_P (e)\n       && VAR_HAD_UNKNOWN_BOUND (e)\n       && DECL_TEMPLATE_INSTANTIATION (e))\n     instantiate_decl (e, /*defer_ok*/true, /*expl_inst_mem*/false);\n@@ -1645,7 +1645,7 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n \n   e = mark_type_use (e);\n \n-  if (TREE_CODE (e) == VAR_DECL)\n+  if (VAR_P (e))\n     t = size_int (DECL_ALIGN_UNIT (e));\n   else if (TREE_CODE (e) == COMPONENT_REF\n \t   && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n@@ -1950,7 +1950,7 @@ decay_conversion (tree exp, tsubst_flags_t complain)\n \n       ptrtype = build_pointer_type (TREE_TYPE (type));\n \n-      if (TREE_CODE (exp) == VAR_DECL)\n+      if (VAR_P (exp))\n \t{\n \t  if (!cxx_mark_addressable (exp))\n \t    return error_mark_node;\n@@ -2280,7 +2280,7 @@ build_class_member_access_expr (tree object, tree member,\n \n   /* In [expr.ref], there is an explicit list of the valid choices for\n      MEMBER.  We check for each of those cases here.  */\n-  if (TREE_CODE (member) == VAR_DECL)\n+  if (VAR_P (member))\n     {\n       /* A static data member.  */\n       result = member;\n@@ -3054,7 +3054,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \t  tree foo = array;\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n-\t  if (TREE_CODE (foo) == VAR_DECL && DECL_REGISTER (foo)\n+\t  if (VAR_P (foo) && DECL_REGISTER (foo)\n \t      && (complain & tf_warning))\n \t    warning_at (loc, OPT_Wextra,\n \t\t\t\"subscripting array declared %<register%>\");\n@@ -5772,7 +5772,7 @@ cxx_mark_addressable (tree exp)\n \tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n \t    && !DECL_ARTIFICIAL (x))\n \t  {\n-\t    if (TREE_CODE (x) == VAR_DECL && DECL_HARD_REGISTER (x))\n+\t    if (VAR_P (x) && DECL_HARD_REGISTER (x))\n \t      {\n \t\terror\n \t\t  (\"address of explicit register variable %qD requested\", x);\n@@ -8050,7 +8050,7 @@ maybe_warn_about_returning_address_of_local (tree retval)\n \t  warning (OPT_Wreturn_local_addr, \"returning reference to temporary\");\n \t  return;\n \t}\n-      if (TREE_CODE (whats_returned) == VAR_DECL\n+      if (VAR_P (whats_returned)\n \t  && DECL_NAME (whats_returned)\n \t  && TEMP_NAME_P (DECL_NAME (whats_returned)))\n \t{\n@@ -8288,7 +8288,7 @@ check_return_expr (tree retval, bool *no_warning)\n   named_return_value_okay_p = \n     (retval != NULL_TREE\n      /* Must be a local, automatic variable.  */\n-     && TREE_CODE (retval) == VAR_DECL\n+     && VAR_P (retval)\n      && DECL_CONTEXT (retval) == current_function_decl\n      && ! TREE_STATIC (retval)\n      && ! DECL_ANON_UNION_VAR_P (retval)\n@@ -8336,7 +8336,7 @@ check_return_expr (tree retval, bool *no_warning)\n          Note that these conditions are similar to, but not as strict as,\n \t the conditions for the named return value optimization.  */\n       if ((cxx_dialect != cxx98)\n-          && (TREE_CODE (retval) == VAR_DECL\n+          && (VAR_P (retval)\n \t      || TREE_CODE (retval) == PARM_DECL)\n \t  && DECL_CONTEXT (retval) == current_function_decl\n \t  && !TREE_STATIC (retval)"}, {"sha": "e97bb3aee6cd851e3bcd1c1a148cd20858c53609", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -98,7 +98,7 @@ cxx_readonly_error (tree arg, enum lvalue_use errstring)\n \n   /* Handle C++-specific things first.  */\n \n-  if (TREE_CODE (arg) == VAR_DECL\n+  if (VAR_P (arg)\n       && DECL_LANG_SPECIFIC (arg)\n       && DECL_IN_AGGR_P (arg)\n       && !TREE_STATIC (arg))\n@@ -113,7 +113,7 @@ cxx_readonly_error (tree arg, enum lvalue_use errstring)\n \t\t\t  arg);\n   else if (INDIRECT_REF_P (arg)\n \t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n-\t   && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n+\t   && (VAR_P (TREE_OPERAND (arg, 0))\n \t       || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n     ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n                              \"read-only reference %qD\"),\n@@ -315,7 +315,7 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n \n   if (decl)\n     {\n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \terror (\"cannot declare variable %q+D to be of abstract \"\n \t       \"type %qT\", decl, type);\n       else if (TREE_CODE (decl) == PARM_DECL)\n@@ -441,7 +441,7 @@ cxx_incomplete_type_diagnostic (const_tree value, const_tree type,\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n-  if (value != 0 && (TREE_CODE (value) == VAR_DECL\n+  if (value != 0 && (VAR_P (value)\n \t\t     || TREE_CODE (value) == PARM_DECL\n \t\t     || TREE_CODE (value) == FIELD_DECL))\n     {"}, {"sha": "985512acf28dfd8fc0e8f8436ecb338b7b63f9f5", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a6ccc943fa6c7f121a47e96a19d73a7531de311/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5a6ccc943fa6c7f121a47e96a19d73a7531de311", "patch": "@@ -165,6 +165,10 @@ extern const enum tree_code_class tree_code_type[];\n #define DECL_P(CODE)\\\n         (TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_declaration)\n \n+/* True if NODE designates a variable declaration.  */\n+#define VAR_P(NODE) \\\n+  (TREE_CODE (NODE) == VAR_DECL)\n+\n /* Nonzero if DECL represents a VAR_DECL or FUNCTION_DECL.  */\n \n #define VAR_OR_FUNCTION_DECL_P(DECL)\\"}]}