{"sha": "0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUyNGM5MWQxZWVlNmRjMmYxNjI5MTYwZWQzMDlhNTQ0MWZiM2JkZA==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2004-06-03T23:15:01Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2004-06-03T23:15:01Z"}, "message": "re PR c++/15428 (vtables shouldn't always be weak on Darwin)\n\n\tPR c++/15428\n\t* default.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): New name\n\tfor TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY, with reversed sense.\n\t* config/darwin.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): Likewise.\n\t* doc/tm.texi (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): Rewrite\n\tdocumentation to reflect the new macro name and to clarify its\n\tmeaning.\n\t* cp/decl2.c (maybe_emit_vtables): If TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n\tis nonzero, and if we see a noninline definition of a key method,\n\tmake the vtables nonweak.\n\nFrom-SVN: r82610", "tree": {"sha": "4dfc88aeb614a38019098dbdc178d9f2bfbb2b83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dfc88aeb614a38019098dbdc178d9f2bfbb2b83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/comments", "author": null, "committer": null, "parents": [{"sha": "c073ab616f5692283e12bc93b82a14aad88adf9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c073ab616f5692283e12bc93b82a14aad88adf9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c073ab616f5692283e12bc93b82a14aad88adf9e"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "614337b6c942b17881d0e5b9949a91d11fab1ced", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "patch": "@@ -1,3 +1,13 @@\n+2004-06-03  Matt Austern  <austern@apple.com>\n+\n+\tPR c++/15428\n+\t* default.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): New name\n+\tfor TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY, with reversed sense.\n+\t* config/darwin.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): Likewise.\n+\t* doc/tm.texi (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): Rewrite\n+\tdocumentation to reflect the new macro name and to clarify its \n+\tmeaning.\n+\t\n 2004-06-04  Steven Bosscher  <stevenb@suse.de>\n \n \t* rtl.def (VAR_LOCATION): Make RTX_EXTRA."}, {"sha": "37122e6253c27d8dc4edb20d5a58e8c5e86ba1af", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "patch": "@@ -358,11 +358,10 @@ do { text_section ();\t\t\t\t\t\t\t\\\n #undef USE_COMMON_FOR_ONE_ONLY\n #define USE_COMMON_FOR_ONE_ONLY 0\n \n-/* The Darwin linker doesn't like explicit template instantiations to be\n-   coalesced, because it doesn't want coalesced symbols to appear in\n+/* The Darwin linker doesn't want coalesced symbols to appear in\n    a static archive's table of contents. */\n-#undef TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n-#define TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY 0\n+#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n+#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1\n \n /* We make exception information linkonce. */\n #undef TARGET_USES_WEAK_UNWIND_INFO"}, {"sha": "652dc09a09e4e3794d78389f6b8e72f596e7a2c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "patch": "@@ -1,3 +1,10 @@\n+2004-06-03  Matt Austern  <austern@apple.com>\n+\n+\tPR c++/15428\n+\t* decl2.c (maybe_emit_vtables): If TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n+\tis nonzero, and if we see a noninline definition of a key method,\n+\tmake the vtables nonweak.\n+\t\n 2004-06-02  Matt Austern  <austern@apple.com>\n \n \t* cp-tree.h (instantiate_decl): new boolean parameter,"}, {"sha": "038fea00879669923dce363f14753aecf07f7554", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "patch": "@@ -1441,7 +1441,7 @@ maybe_make_one_only (tree decl)\n      to for variables so that cp_finish_decl will update their linkage,\n      because their DECL_INITIAL may not have been set properly yet.  */\n \n-  if (TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+  if (!TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n       || (! DECL_EXPLICIT_INSTANTIATION (decl)\n \t  && ! DECL_TEMPLATE_SPECIALIZATION (decl)))\n     {\n@@ -1582,6 +1582,7 @@ maybe_emit_vtables (tree ctype)\n   tree vtbl;\n   tree primary_vtbl;\n   bool needed = false;\n+  bool weaken_vtables;\n \n   /* If the vtables for this class have already been emitted there is\n      nothing more to do.  */\n@@ -1612,6 +1613,29 @@ maybe_emit_vtables (tree ctype)\n   else if (TREE_PUBLIC (vtbl) && !DECL_COMDAT (vtbl))\n     needed = true;\n   \n+  /* Determine whether to make vtables weak.  The ABI requires that we\n+      do so.  There are two cases in which we have to violate the ABI\n+      specification: targets where we don't have weak symbols\n+      (obviously), and targets where weak symbols don't appear in\n+      static archives' tables of contents.  On such targets, avoiding\n+      undefined symbol link errors requires that we only make a symbol\n+      weak if we know that it will be emitted everywhere it's needed.\n+      So on such targets we don't make vtables weak in the common case\n+      where we're emitting a vtable of a nontemplate class in the \n+      translation unit containing the definition of a noninline key\n+      method. */\n+  if (flag_weak && !TARGET_WEAK_NOT_IN_ARCHIVE_TOC)\n+    weaken_vtables = true;\n+  else if (flag_weak)\n+    {\n+      if (CLASSTYPE_USE_TEMPLATE (ctype))\n+ \tweaken_vtables = CLASSTYPE_IMPLICIT_INSTANTIATION (ctype);\n+      else\n+ \tweaken_vtables = !CLASSTYPE_KEY_METHOD (ctype)\n+ \t  || DECL_DECLARED_INLINE_P (CLASSTYPE_KEY_METHOD (ctype));\n+    }\n+  else\n+    weaken_vtables = false;\n \n   /* The ABI requires that we emit all of the vtables if we emit any\n      of them.  */\n@@ -1658,8 +1682,8 @@ maybe_emit_vtables (tree ctype)\n \t  DECL_IGNORED_P (vtbl) = 1;\n \t}\n \n-      /* Always make vtables weak.  */\n-      if (flag_weak)\n+      /* Always make vtables weak.  Or at least almost always; see above. */\n+      if (weaken_vtables)\n \tcomdat_linkage (vtbl);\n \n       rest_of_decl_compilation (vtbl, NULL, 1, 1);"}, {"sha": "e479affa4eff425562d36dcf9eba4caf9be44f51", "filename": "gcc/defaults.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "patch": "@@ -238,11 +238,13 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #endif\n #endif\n \n-/* Determines whether explicit template instantiations should\n-   be given link-once semantics. The C++ ABI requires this \n-   macro to be nonzero; see the documentation.  */\n-#ifndef TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n-# define TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY 1\n+/* This determines whether weak symbols must be left out of a static\n+   archive's table of contents.  Defining this macro to be nonzero has\n+   the consequence that certain symbols will not be made weak that\n+   otherwise would be.  The C++ ABI requires this macro to be zero;\n+   see the documentation. */ \n+#ifndef TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n+#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 0\n #endif\n \n /* This determines whether or not we need linkonce unwind information */"}, {"sha": "082de59446cb831a127b811c2869a0a249d5c396", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0524c91d1eee6dc2f1629160ed309a5441fb3bdd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0524c91d1eee6dc2f1629160ed309a5441fb3bdd", "patch": "@@ -6753,13 +6753,23 @@ commands that will make the symbol(s) associated with @var{decl} have\n hidden, protected or internal visibility as specified by @var{visibility}.\n @end deftypefn\n \n-@defmac TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+@defmac TARGET_WEAK_NOT_IN_ARCHIVE_TOC\n A C expression that evaluates to true if the target's linker expects\n-explicit template specializations, as well as implicit, to be given\n-linkonce semantics.  The default is @code{1}.  The C++ ABI requires\n-this macro to be nonzero.  Define this macro for targets where full\n-C++ ABI compliance is impossible and where explicit and implicit \n-template specialization must be treated differently.\n+that weak symbols do not appear in a static archive's table of contents.\n+The default is @code{0}.  \n+\n+Leaving weak symbols out of an archive's table of contents means that,\n+if a symbol will only have a definition in one translation unit and\n+will have undefined references from other translation units, that\n+symbol should not be weak.  Defining this macro to be nonzero will\n+thus have the effect that certain symbols that would normally be weak\n+(explicit template instantiations, and vtables for polymorphic classes\n+with noninline key methods) will instead be nonweak.\n+\n+The C++ ABI requires this macro to be zero.  Define this macro for\n+targets where full C++ ABI compliance is impossible and where linker\n+restrictions require weak symbols to be left out of a static archive's\n+table of contents.\n @end defmac\n \n @defmac TARGET_SUPPORTS_HIDDEN"}]}