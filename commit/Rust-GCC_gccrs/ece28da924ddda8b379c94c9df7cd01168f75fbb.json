{"sha": "ece28da924ddda8b379c94c9df7cd01168f75fbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlMjhkYTkyNGRkZGE4YjM3OWM5NGM5ZGY3Y2QwMTE2OGY3NWZiYg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-09-01T19:46:19Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-09-01T19:46:19Z"}, "message": "Enable ranger and caching in pass_waccess.\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-warn-access.cc (get_size_range): Add argument.\n\t(check_access): Pass additional argument.\n\t(check_memop_access): Remove template and make a member function.\n\t(maybe_check_dealloc_call): Make a pass_waccess member function.\n\t(class pass_waccess): Add, rename, and remove members.\n\t(pass_waccess::pass_waccess): Adjust to name change.\n\t(pass_waccess::~pass_waccess): Same.\n\t(check_alloca): Make a member function.\n\t(check_alloc_size_call): Same.\n\t(check_strcat): Same.\n\t(check_strncat): Same.\n\t(check_stxcpy): Same.\n\t(check_stxncpy): Same.\n\t(check_strncmp): Same.\n\t(maybe_warn_rdwr_sizes): Rename...\n\t(pass_waccess::maybe_check_access_sizes): ...to this.\n\t(pass_waccess::check_call): Adjust to name changes.\n\t(pass_waccess::maybe_check_dealloc_call): Make a pass_waccess member\n\tfunction.\n\t(pass_waccess::execute): Adjust to name changes.\n\t* gimple-ssa-warn-access.h (check_memop_access): Remove.\n\t* pointer-query.cc (access_ref::phi): Handle null pointer.\n\t(access_ref::inform_access): Same.\n\t(pointer_query::put_ref): Modify a cached value, not a copy of it.\n\t(pointer_query::dump): New function.\n\t(compute_objsize_r): Avoid overwriting access_ref::bndrng.  Cache\n\tmore results.\n\t* pointer-query.h (pointer_query::dump): Declare.\n\t* tree-ssa-strlen.c (get_range): Simplify.  Use function query.\n\t(dump_strlen_info): Use function query.\n\t(printf_strlen_execute): Factor code out into pointer_query::put_ref.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/Wstringop-overflow-11.c: Remove xfails.\n\t* gcc.dg/Wstringop-overflow-12.c: Same.\n\t* gcc.dg/Wstringop-overflow-43.c: Add xfails.\n\t* gcc.dg/Wstringop-overflow-73.c: New test.", "tree": {"sha": "439ad27f308cff8d6f4133e4cabf184815d73675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/439ad27f308cff8d6f4133e4cabf184815d73675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ece28da924ddda8b379c94c9df7cd01168f75fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece28da924ddda8b379c94c9df7cd01168f75fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece28da924ddda8b379c94c9df7cd01168f75fbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece28da924ddda8b379c94c9df7cd01168f75fbb/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac6e77aacfb6581f5e84e4430628152b9b98da2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6e77aacfb6581f5e84e4430628152b9b98da2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6e77aacfb6581f5e84e4430628152b9b98da2e"}], "stats": {"total": 700, "additions": 405, "deletions": 295}, "files": [{"sha": "00c3ea0f505017d141dae35871051dc81a1ca299", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 224, "deletions": 213, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -1190,10 +1190,11 @@ warn_for_access (location_t loc, tree func, tree expr, int opt,\n    by BNDRNG if nonnull and valid.  */\n \n static void\n-get_size_range (tree bound, tree range[2], const offset_int bndrng[2])\n+get_size_range (range_query *query, tree bound, tree range[2],\n+\t\tconst offset_int bndrng[2])\n {\n   if (bound)\n-    get_size_range (bound, range);\n+    get_size_range (query, bound, NULL, range);\n \n   if (!bndrng || (bndrng[0] == 0 && bndrng[1] == HOST_WIDE_INT_M1U))\n     return;\n@@ -1337,7 +1338,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n \n   /* Set RANGE to that of DSTWRITE if non-null, bounded by PAD->DST.BNDRNG\n      if valid.  */\n-  get_size_range (dstwrite, range, pad ? pad->dst.bndrng : NULL);\n+  get_size_range (NULL, dstwrite, range, pad ? pad->dst.bndrng : NULL);\n \n   tree func = get_callee_fndecl (exp);\n   /* Read vs write access by built-ins can be determined from the const\n@@ -1431,7 +1432,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n     {\n       /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n-      get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n+      get_size_range (NULL, maxread, range, pad ? pad->src.bndrng : NULL);\n \n       location_t loc = get_location (exp);\n       tree size = dstsize;\n@@ -1478,7 +1479,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n     {\n       /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n-      get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n+      get_size_range (NULL, maxread, range, pad ? pad->src.bndrng : NULL);\n       /* Set OVERREAD for reads starting just past the end of an object.  */\n       overread = pad->src.sizrng[1] - pad->src.offrng[0] < pad->src.bndrng[0];\n       range[0] = wide_int_to_tree (sizetype, pad->src.bndrng[0]);\n@@ -1529,41 +1530,6 @@ check_access (tree expr, tree dstwrite,\n \t\t\t    mode, pad);\n }\n \n-/* Helper to determine and check the sizes of the source and the destination\n-   of calls to __builtin_{bzero,memcpy,mempcpy,memset} calls.  EXP is the\n-   call expression, DEST is the destination argument, SRC is the source\n-   argument or null, and LEN is the number of bytes.  Use Object Size type-0\n-   regardless of the OPT_Wstringop_overflow_ setting.  Return true on success\n-   (no overflow or invalid sizes), false otherwise.  */\n-\n-template <class GimpleOrTree>\n-static bool\n-check_memop_access (GimpleOrTree expr, tree dest, tree src, tree size)\n-{\n-  /* For functions like memset and memcpy that operate on raw memory\n-     try to determine the size of the largest source and destination\n-     object using type-0 Object Size regardless of the object size\n-     type specified by the option.  */\n-  access_data data (expr, access_read_write);\n-  tree srcsize = src ? compute_objsize (src, 0, &data.src) : NULL_TREE;\n-  tree dstsize = compute_objsize (dest, 0, &data.dst);\n-\n-  return check_access (expr, size, /*maxread=*/NULL_TREE,\n-\t\t       srcsize, dstsize, data.mode, &data);\n-}\n-\n-bool\n-check_memop_access (gimple *stmt, tree dest, tree src, tree size)\n-{\n-  return check_memop_access<gimple *>(stmt, dest, src, size);\n-}\n-\n-bool\n-check_memop_access (tree expr, tree dest, tree src, tree size)\n-{\n-  return check_memop_access<tree>(expr, dest, src, size);\n-}\n-\n /* A convenience wrapper for check_access above to check access\n    by a read-only function like puts.  */\n \n@@ -2111,135 +2077,6 @@ warn_dealloc_offset (location_t loc, gimple *call, const access_ref &aref)\n   return true;\n }\n \n-/* Issue a warning if a deallocation function such as free, realloc,\n-   or C++ operator delete is called with an argument not returned by\n-   a matching allocation function such as malloc or the corresponding\n-   form of C++ operatorn new.  */\n-\n-static void\n-maybe_check_dealloc_call (gcall *call)\n-{\n-  tree fndecl = gimple_call_fndecl (call);\n-  if (!fndecl)\n-    return;\n-\n-  unsigned argno = fndecl_dealloc_argno (fndecl);\n-  if ((unsigned) call_nargs (call) <= argno)\n-    return;\n-\n-  tree ptr = gimple_call_arg (call, argno);\n-  if (integer_zerop (ptr))\n-    return;\n-\n-  access_ref aref;\n-  if (!compute_objsize (ptr, 0, &aref))\n-    return;\n-\n-  tree ref = aref.ref;\n-  if (integer_zerop (ref))\n-    return;\n-\n-  tree dealloc_decl = fndecl;\n-  location_t loc = gimple_location (call);\n-\n-  if (DECL_P (ref) || EXPR_P (ref))\n-    {\n-      /* Diagnose freeing a declared object.  */\n-      if (aref.ref_declared ()\n-\t  && warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t\t \"%qD called on unallocated object %qD\",\n-\t\t\t dealloc_decl, ref))\n-\t{\n-\t  inform (get_location (ref), \"declared here\");\n-\t  return;\n-\t}\n-\n-      /* Diagnose freeing a pointer that includes a positive offset.\n-\t Such a pointer cannot refer to the beginning of an allocated\n-\t object.  A negative offset may refer to it.  */\n-      if (aref.sizrng[0] != aref.sizrng[1]\n-\t  && warn_dealloc_offset (loc, call, aref))\n-\treturn;\n-    }\n-  else if (CONSTANT_CLASS_P (ref))\n-    {\n-      if (warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t      \"%qD called on a pointer to an unallocated \"\n-\t\t      \"object %qE\", dealloc_decl, ref))\n-\t{\n-\t  if (TREE_CODE (ptr) == SSA_NAME)\n-\t    {\n-\t      gimple *def_stmt = SSA_NAME_DEF_STMT (ptr);\n-\t      if (is_gimple_assign (def_stmt))\n-\t\t{\n-\t\t  location_t loc = gimple_location (def_stmt);\n-\t\t  inform (loc, \"assigned here\");\n-\t\t}\n-\t    }\n-\t  return;\n-\t}\n-    }\n-  else if (TREE_CODE (ref) == SSA_NAME)\n-    {\n-      /* Also warn if the pointer argument refers to the result\n-\t of an allocation call like alloca or VLA.  */\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (ref);\n-      if (is_gimple_call (def_stmt))\n-\t{\n-\t  bool warned = false;\n-\t  if (gimple_call_alloc_p (def_stmt))\n-\t    {\n-\t      if (matching_alloc_calls_p (def_stmt, dealloc_decl))\n-\t\t{\n-\t\t  if (warn_dealloc_offset (loc, call, aref))\n-\t\t    return;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n-\t\t  const opt_code opt =\n-\t\t    (DECL_IS_OPERATOR_NEW_P (alloc_decl)\n-\t\t     || DECL_IS_OPERATOR_DELETE_P (dealloc_decl)\n-\t\t     ? OPT_Wmismatched_new_delete\n-\t\t     : OPT_Wmismatched_dealloc);\n-\t\t  warned = warning_at (loc, opt,\n-\t\t\t\t       \"%qD called on pointer returned \"\n-\t\t\t\t       \"from a mismatched allocation \"\n-\t\t\t\t       \"function\", dealloc_decl);\n-\t\t}\n-\t    }\n-\t  else if (gimple_call_builtin_p (def_stmt, BUILT_IN_ALLOCA)\n-\t\t   || gimple_call_builtin_p (def_stmt,\n-\t\t\t\t\t     BUILT_IN_ALLOCA_WITH_ALIGN))\n-\t    warned = warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t\t\t \"%qD called on pointer to \"\n-\t\t\t\t \"an unallocated object\",\n-\t\t\t\t dealloc_decl);\n-\t  else if (warn_dealloc_offset (loc, call, aref))\n-\t    return;\n-\n-\t  if (warned)\n-\t    {\n-\t      tree fndecl = gimple_call_fndecl (def_stmt);\n-\t      inform (gimple_location (def_stmt),\n-\t\t      \"returned from %qD\", fndecl);\n-\t      return;\n-\t    }\n-\t}\n-      else if (gimple_nop_p (def_stmt))\n-\t{\n-\t  ref = SSA_NAME_VAR (ref);\n-\t  /* Diagnose freeing a pointer that includes a positive offset.  */\n-\t  if (TREE_CODE (ref) == PARM_DECL\n-\t      && !aref.deref\n-\t      && aref.sizrng[0] != aref.sizrng[1]\n-\t      && aref.offrng[0] > 0 && aref.offrng[1] > 0\n-\t      && warn_dealloc_offset (loc, call, aref))\n-\t    return;\n-\t}\n-    }\n-}\n-\n namespace {\n \n const pass_data pass_data_waccess = {\n@@ -2267,6 +2104,11 @@ class pass_waccess : public gimple_opt_pass\n   virtual bool gate (function *);\n   virtual unsigned int execute (function *);\n \n+private:\n+  /* Not copyable or assignable.  */\n+  pass_waccess (pass_waccess &) = delete;\n+  void operator= (pass_waccess &) = delete;\n+\n   /* Check a call to a built-in function.  */\n   bool check_builtin (gcall *);\n \n@@ -2277,36 +2119,41 @@ class pass_waccess : public gimple_opt_pass\n   void check (basic_block);\n \n   /* Check a call to a function.  */\n- void check (gcall *);\n+  void check (gcall *);\n \n-private:\n-  /* Not copyable or assignable.  */\n-  pass_waccess (pass_waccess &) = delete;\n-  void operator= (pass_waccess &) = delete;\n+  /* Check a call to the named built-in function.  */\n+  void check_alloca (gcall *);\n+  void check_alloc_size_call (gcall *);\n+  void check_strcat (gcall *);\n+  void check_strncat (gcall *);\n+  void check_stxcpy (gcall *);\n+  void check_stxncpy (gcall *);\n+  void check_strncmp (gcall *);\n+  void check_memop_access (gimple *, tree, tree, tree);\n+\n+  void maybe_check_dealloc_call (gcall *);\n+  void maybe_check_access_sizes (rdwr_map *, tree, tree, gimple *);\n \n   /* A pointer_query object and its cache to store information about\n      pointers and their targets in.  */\n-  pointer_query ptr_qry;\n-  pointer_query::cache_type var_cache;\n-\n-  gimple_ranger *m_ranger;\n+  pointer_query m_ptr_qry;\n+  pointer_query::cache_type m_var_cache;\n };\n \n /* Construct the pass.  */\n \n pass_waccess::pass_waccess (gcc::context *ctxt)\n   : gimple_opt_pass (pass_data_waccess, ctxt),\n-    ptr_qry (m_ranger, &var_cache),\n-    var_cache (),\n-    m_ranger ()\n+    m_ptr_qry (NULL, &m_var_cache),\n+    m_var_cache ()\n {\n }\n \n /* Release pointer_query cache.  */\n \n pass_waccess::~pass_waccess ()\n {\n-  ptr_qry.flush_cache ();\n+  m_ptr_qry.flush_cache ();\n }\n \n /* Return true when any checks performed by the pass are enabled.  */\n@@ -2494,8 +2341,8 @@ maybe_warn_alloc_args_overflow (gimple *stmt, const tree args[2],\n \n /* Check a call to an alloca function for an excessive size.  */\n \n-static void\n-check_alloca (gimple *stmt)\n+void\n+pass_waccess::check_alloca (gcall *stmt)\n {\n   if ((warn_vla_limit >= HOST_WIDE_INT_MAX\n        && warn_alloc_size_limit < warn_vla_limit)\n@@ -2515,8 +2362,8 @@ check_alloca (gimple *stmt)\n \n /* Check a call to an allocation function for an excessive size.  */\n \n-static void\n-check_alloc_size_call (gimple *stmt)\n+void\n+pass_waccess::check_alloc_size_call (gcall *stmt)\n {\n   if (gimple_call_num_args (stmt) < 1)\n     /* Avoid invalid calls to functions without a prototype.  */\n@@ -2565,8 +2412,8 @@ check_alloc_size_call (gimple *stmt)\n \n /* Check a call STMT to strcat() for overflow and warn if it does.  */\n \n-static void\n-check_strcat (gimple *stmt)\n+void\n+pass_waccess::check_strcat (gcall *stmt)\n {\n   if (!warn_stringop_overflow && !warn_stringop_overread)\n     return;\n@@ -2581,17 +2428,17 @@ check_strcat (gimple *stmt)\n   access_data data (stmt, access_read_write, NULL_TREE, true,\n \t\t    NULL_TREE, true);\n   const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-  compute_objsize (src, ost, &data.src);\n-  tree destsize = compute_objsize (dest, ost, &data.dst);\n+  compute_objsize (src, ost, &data.src, &m_ptr_qry);\n+  tree destsize = compute_objsize (dest, ost, &data.dst, &m_ptr_qry);\n \n   check_access (stmt, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n \t\tsrc, destsize, data.mode, &data);\n }\n \n /* Check a call STMT to strcat() for overflow and warn if it does.  */\n \n-static void\n-check_strncat (gimple *stmt)\n+void\n+pass_waccess::check_strncat (gcall *stmt)\n {\n   if (!warn_stringop_overflow && !warn_stringop_overread)\n     return;\n@@ -2623,7 +2470,8 @@ check_strncat (gimple *stmt)\n   /* Try to verify that the destination is big enough for the shortest\n      string.  First try to determine the size of the destination object\n      into which the source is being copied.  */\n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n+  const int ost = warn_stringop_overflow - 1;\n+  tree destsize = compute_objsize (dest, ost, &data.dst, &m_ptr_qry);\n \n   /* Add one for the terminating nul.  */\n   tree srclen = (maxlen\n@@ -2658,8 +2506,8 @@ check_strncat (gimple *stmt)\n /* Check a call STMT to stpcpy() or strcpy() for overflow and warn\n    if it does.  */\n \n-static void\n-check_stxcpy (gimple *stmt)\n+void\n+pass_waccess::check_stxcpy (gcall *stmt)\n {\n   tree dst = call_arg (stmt, 0);\n   tree src = call_arg (stmt, 1);\n@@ -2679,8 +2527,8 @@ check_stxcpy (gimple *stmt)\n       access_data data (stmt, access_read_write, NULL_TREE, true,\n \t\t\tNULL_TREE, true);\n       const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-      compute_objsize (src, ost, &data.src);\n-      tree dstsize = compute_objsize (dst, ost, &data.dst);\n+      compute_objsize (src, ost, &data.src, &m_ptr_qry);\n+      tree dstsize = compute_objsize (dst, ost, &data.dst, &m_ptr_qry);\n       check_access (stmt, /*dstwrite=*/ NULL_TREE,\n \t\t    /*maxread=*/ NULL_TREE, /*srcstr=*/ src,\n \t\t    dstsize, data.mode, &data);\n@@ -2696,8 +2544,8 @@ check_stxcpy (gimple *stmt)\n /* Check a call STMT to stpncpy() or strncpy() for overflow and warn\n    if it does.  */\n \n-static void\n-check_stxncpy (gimple *stmt)\n+void\n+pass_waccess::check_stxncpy (gcall *stmt)\n {\n   if (!warn_stringop_overflow)\n     return;\n@@ -2709,8 +2557,8 @@ check_stxncpy (gimple *stmt)\n \n   access_data data (stmt, access_read_write, len, true, len, true);\n   const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-  compute_objsize (src, ost, &data.src);\n-  tree dstsize = compute_objsize (dst, ost, &data.dst);\n+  compute_objsize (src, ost, &data.src, &m_ptr_qry);\n+  tree dstsize = compute_objsize (dst, ost, &data.dst, &m_ptr_qry);\n \n   check_access (stmt, /*dstwrite=*/len,\n \t\t/*maxread=*/len, src, dstsize, data.mode, &data);\n@@ -2719,8 +2567,8 @@ check_stxncpy (gimple *stmt)\n /* Check a call STMT to stpncpy() or strncpy() for overflow and warn\n    if it does.  */\n \n-static void\n-check_strncmp (gimple *stmt)\n+void\n+pass_waccess::check_strncmp (gcall *stmt)\n {\n   if (!warn_stringop_overread)\n     return;\n@@ -2764,7 +2612,7 @@ check_strncmp (gimple *stmt)\n   /* Determine the range of the bound first and bail if it fails; it's\n      cheaper than computing the size of the objects.  */\n   tree bndrng[2] = { NULL_TREE, NULL_TREE };\n-  get_size_range (bound, bndrng, adata1.src.bndrng);\n+  get_size_range (m_ptr_qry.rvals, bound, bndrng, adata1.src.bndrng);\n   if (!bndrng[0] || integer_zerop (bndrng[0]))\n     return;\n \n@@ -2775,8 +2623,8 @@ check_strncmp (gimple *stmt)\n \n   /* compute_objsize almost never fails (and ultimately should never\n      fail).  Don't bother to handle the rare case when it does.  */\n-  if (!compute_objsize (arg1, 1, &adata1.src)\n-      || !compute_objsize (arg2, 1, &adata2.src))\n+  if (!compute_objsize (arg1, 1, &adata1.src, &m_ptr_qry)\n+      || !compute_objsize (arg2, 1, &adata2.src, &m_ptr_qry))\n     return;\n \n   /* Compute the size of the remaining space in each array after\n@@ -2810,6 +2658,29 @@ check_strncmp (gimple *stmt)\n     }\n }\n \n+/* Determine and check the sizes of the source and the destination\n+   of calls to __builtin_{bzero,memcpy,mempcpy,memset} calls.  STMT is\n+   the call statement, DEST is the destination argument, SRC is the source\n+   argument or null, and SIZE is the number of bytes being accessed.  Use\n+   Object Size type-0 regardless of the OPT_Wstringop_overflow_ setting.\n+   Return true on success (no overflow or invalid sizes), false otherwise.  */\n+\n+void\n+pass_waccess::check_memop_access (gimple *stmt, tree dest, tree src, tree size)\n+{\n+  /* For functions like memset and memcpy that operate on raw memory\n+     try to determine the size of the largest source and destination\n+     object using type-0 Object Size regardless of the object size\n+     type specified by the option.  */\n+  access_data data (stmt, access_read_write);\n+  tree srcsize\n+    = src ? compute_objsize (src, 0, &data.src, &m_ptr_qry) : NULL_TREE;\n+  tree dstsize = compute_objsize (dest, 0, &data.dst, &m_ptr_qry);\n+\n+  check_access (stmt, size, /*maxread=*/NULL_TREE,\n+\t\tsrcsize, dstsize, data.mode, &data);\n+}\n+\n /* Check call STMT to a built-in function for invalid accesses.  Return\n    true if a call has been handled.  */\n \n@@ -2968,8 +2839,9 @@ append_attrname (const std::pair<int, attr_access> &access,\n    arguments and diagnose past-the-end accesses and related problems\n    in the function call EXP.  */\n \n-static void\n-maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, gimple *stmt)\n+void\n+pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n+\t\t\t\t\tgimple *stmt)\n {\n   auto_diagnostic_group adg;\n \n@@ -3028,7 +2900,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, gimple *stmt)\n       /* Format the value or range to avoid an explosion of messages.  */\n       char sizstr[80];\n       tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n-      if (get_size_range (access_size, sizrng, true))\n+      if (get_size_range (m_ptr_qry.rvals, access_size, NULL, sizrng, 1))\n \t{\n \t  char *s0 = print_generic_expr_to_str (sizrng[0]);\n \t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n@@ -3160,7 +3032,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, gimple *stmt)\n \t\t\tNULL_TREE, false);\n       access_ref* const pobj = (access.second.mode == access_write_only\n \t\t\t\t? &data.dst : &data.src);\n-      tree objsize = compute_objsize (ptr, 1, pobj);\n+      tree objsize = compute_objsize (ptr, 1, pobj, &m_ptr_qry);\n \n       /* The size of the destination or source object.  */\n       tree dstsize = NULL_TREE, srcsize = NULL_TREE;\n@@ -3276,7 +3148,7 @@ pass_waccess::check_call (gcall *stmt)\n \n   /* Check attribute access arguments.  */\n   tree fndecl = gimple_call_fndecl (stmt);\n-  maybe_warn_rdwr_sizes (&rdwr_idx, fndecl, fntype, stmt);\n+  maybe_check_access_sizes (&rdwr_idx, fndecl, fntype, stmt);\n \n   check_alloc_size_call (stmt);\n   return true;\n@@ -3294,6 +3166,138 @@ check_nonstring_args (gcall *stmt)\n   maybe_warn_nonstring_arg (fndecl, stmt);\n }\n \n+/* Issue a warning if a deallocation function such as free, realloc,\n+   or C++ operator delete is called with an argument not returned by\n+   a matching allocation function such as malloc or the corresponding\n+   form of C++ operatorn new.  */\n+\n+void\n+pass_waccess::maybe_check_dealloc_call (gcall *call)\n+{\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return;\n+\n+  unsigned argno = fndecl_dealloc_argno (fndecl);\n+  if ((unsigned) call_nargs (call) <= argno)\n+    return;\n+\n+  tree ptr = gimple_call_arg (call, argno);\n+  if (integer_zerop (ptr))\n+    return;\n+\n+  access_ref aref;\n+  if (!compute_objsize (ptr, 0, &aref, &m_ptr_qry))\n+    return;\n+\n+  tree ref = aref.ref;\n+  if (integer_zerop (ref))\n+    return;\n+\n+  tree dealloc_decl = fndecl;\n+  location_t loc = gimple_location (call);\n+\n+  if (DECL_P (ref) || EXPR_P (ref))\n+    {\n+      /* Diagnose freeing a declared object.  */\n+      if (aref.ref_declared ()\n+\t  && warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t\t \"%qD called on unallocated object %qD\",\n+\t\t\t dealloc_decl, ref))\n+\t{\n+\t  inform (get_location (ref), \"declared here\");\n+\t  return;\n+\t}\n+\n+      /* Diagnose freeing a pointer that includes a positive offset.\n+\t Such a pointer cannot refer to the beginning of an allocated\n+\t object.  A negative offset may refer to it.  */\n+      if (aref.sizrng[0] != aref.sizrng[1]\n+\t  && warn_dealloc_offset (loc, call, aref))\n+\treturn;\n+    }\n+  else if (CONSTANT_CLASS_P (ref))\n+    {\n+      if (warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t      \"%qD called on a pointer to an unallocated \"\n+\t\t      \"object %qE\", dealloc_decl, ref))\n+\t{\n+\t  if (TREE_CODE (ptr) == SSA_NAME)\n+\t    {\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (ptr);\n+\t      if (is_gimple_assign (def_stmt))\n+\t\t{\n+\t\t  location_t loc = gimple_location (def_stmt);\n+\t\t  inform (loc, \"assigned here\");\n+\t\t}\n+\t    }\n+\t  return;\n+\t}\n+    }\n+  else if (TREE_CODE (ref) == SSA_NAME)\n+    {\n+      /* Also warn if the pointer argument refers to the result\n+\t of an allocation call like alloca or VLA.  */\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (ref);\n+      if (!def_stmt)\n+\treturn;\n+\n+      if (is_gimple_call (def_stmt))\n+\t{\n+\t  bool warned = false;\n+\t  if (gimple_call_alloc_p (def_stmt))\n+\t    {\n+\t      if (matching_alloc_calls_p (def_stmt, dealloc_decl))\n+\t\t{\n+\t\t  if (warn_dealloc_offset (loc, call, aref))\n+\t\t    return;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n+\t\t  const opt_code opt =\n+\t\t    (DECL_IS_OPERATOR_NEW_P (alloc_decl)\n+\t\t     || DECL_IS_OPERATOR_DELETE_P (dealloc_decl)\n+\t\t     ? OPT_Wmismatched_new_delete\n+\t\t     : OPT_Wmismatched_dealloc);\n+\t\t  warned = warning_at (loc, opt,\n+\t\t\t\t       \"%qD called on pointer returned \"\n+\t\t\t\t       \"from a mismatched allocation \"\n+\t\t\t\t       \"function\", dealloc_decl);\n+\t\t}\n+\t    }\n+\t  else if (gimple_call_builtin_p (def_stmt, BUILT_IN_ALLOCA)\n+\t\t   || gimple_call_builtin_p (def_stmt,\n+\t\t\t\t\t     BUILT_IN_ALLOCA_WITH_ALIGN))\n+\t    warned = warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t\t\t \"%qD called on pointer to \"\n+\t\t\t\t \"an unallocated object\",\n+\t\t\t\t dealloc_decl);\n+\t  else if (warn_dealloc_offset (loc, call, aref))\n+\t    return;\n+\n+\t  if (warned)\n+\t    {\n+\t      tree fndecl = gimple_call_fndecl (def_stmt);\n+\t      inform (gimple_location (def_stmt),\n+\t\t      \"returned from %qD\", fndecl);\n+\t      return;\n+\t    }\n+\t}\n+      else if (gimple_nop_p (def_stmt))\n+\t{\n+\t  ref = SSA_NAME_VAR (ref);\n+\t  /* Diagnose freeing a pointer that includes a positive offset.  */\n+\t  if (TREE_CODE (ref) == PARM_DECL\n+\t      && !aref.deref\n+\t      && aref.sizrng[0] != aref.sizrng[1]\n+\t      && aref.offrng[0] > 0 && aref.offrng[1] > 0\n+\t      && warn_dealloc_offset (loc, call, aref))\n+\t    return;\n+\t}\n+    }\n+}\n+\n /* Check call STMT for invalid accesses.  */\n \n void\n@@ -3329,14 +3333,21 @@ unsigned\n pass_waccess::execute (function *fun)\n {\n   /* Create a new ranger instance and associate it with FUN.  */\n-  m_ranger = enable_ranger (fun);\n+  m_ptr_qry.rvals = enable_ranger (fun);\n \n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     check (bb);\n \n-  /* Release the ranger instance and replace it with a global ranger.  */\n+  if (dump_file)\n+    m_ptr_qry.dump (dump_file, (dump_flags & TDF_DETAILS) != 0);\n+\n+  m_ptr_qry.flush_cache ();\n+\n+  /* Release the ranger instance and replace it with a global ranger.\n+     Also reset the pointer since calling disable_ranger() deletes it.  */\n   disable_ranger (fun);\n+  m_ptr_qry.rvals = NULL;\n \n   return 0;\n }"}, {"sha": "00f5bb1a7b2a74ca216223033a2e4a14bdd1d02b", "filename": "gcc/gimple-ssa-warn-access.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fgimple-ssa-warn-access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fgimple-ssa-warn-access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.h?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -45,7 +45,6 @@ class access_data;\n extern bool check_access (tree, tree, tree, tree, tree, access_mode,\n \t\t\t  const access_data * = NULL);\n \n-extern bool check_memop_access (tree, tree, tree, tree);\n extern bool check_read_access (gimple *, tree, tree = NULL_TREE, int ost = 1);\n extern bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n "}, {"sha": "4ad28796e57633f5a27111045872cb612cf115ba", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 120, "deletions": 7, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -34,10 +34,13 @@\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"gimple-fold.h\"\n+#include \"gimple-ssa.h\"\n #include \"intl.h\"\n #include \"attr-fnspec.h\"\n #include \"gimple-range.h\"\n #include \"pointer-query.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tree-ssanames.h\"\n \n static bool compute_objsize_r (tree, int, access_ref *, ssa_name_limit_t &,\n \t\t\t       pointer_query *);\n@@ -307,7 +310,7 @@ get_size_range (range_query *query, tree exp, gimple *stmt, tree range[2],\n   enum value_range_kind range_type;\n \n   if (!query)\n-    query = get_global_range_query ();\n+    query = get_range_query (cfun);\n \n   if (integral)\n     {\n@@ -628,7 +631,7 @@ access_ref::phi () const\n     return NULL;\n \n   gimple *def_stmt = SSA_NAME_DEF_STMT (ref);\n-  if (gimple_code (def_stmt) != GIMPLE_PHI)\n+  if (!def_stmt || gimple_code (def_stmt) != GIMPLE_PHI)\n     return NULL;\n \n   return as_a <gphi *> (def_stmt);\n@@ -1038,6 +1041,9 @@ access_ref::inform_access (access_mode mode) const\n   if (TREE_CODE (ref) == SSA_NAME)\n     {\n       gimple *stmt = SSA_NAME_DEF_STMT (ref);\n+      if (!stmt)\n+\treturn;\n+\n       if (is_gimple_call (stmt))\n \t{\n \t  loc = gimple_location (stmt);\n@@ -1339,7 +1345,7 @@ pointer_query::put_ref (tree ptr, const access_ref &ref, int ostype /* = 1 */)\n   if (var_cache->access_refs.length () <= cache_idx)\n     var_cache->access_refs.safe_grow_cleared (cache_idx + 1);\n \n-  access_ref cache_ref = var_cache->access_refs[cache_idx - 1];\n+  access_ref &cache_ref = var_cache->access_refs[cache_idx];\n   if (cache_ref.ref)\n   {\n     gcc_checking_assert (cache_ref.ref == ref.ref);\n@@ -1360,6 +1366,102 @@ pointer_query::flush_cache ()\n   var_cache->access_refs.release ();\n }\n \n+/* Dump statistics and, optionally, cache contents to DUMP_FILE.  */\n+\n+void\n+pointer_query::dump (FILE *dump_file, bool contents /* = false */)\n+{\n+  unsigned nused = 0, nrefs = 0;\n+  unsigned nidxs = var_cache->indices.length ();\n+  for (unsigned i = 0; i != nidxs; ++i)\n+    {\n+      unsigned ari = var_cache->indices[i];\n+      if (!ari)\n+\tcontinue;\n+\n+      ++nused;\n+\n+      const access_ref &aref = var_cache->access_refs[ari];\n+      if (!aref.ref)\n+\tcontinue;\n+\n+      ++nrefs;\n+    }\n+\n+  fprintf (dump_file, \"pointer_query counters:\\n\"\n+\t   \"  index cache size:   %u\\n\"\n+\t   \"  index entries:      %u\\n\"\n+\t   \"  access cache size:  %u\\n\"\n+\t   \"  access entries:     %u\\n\"\n+\t   \"  hits:               %u\\n\"\n+\t   \"  misses:             %u\\n\"\n+\t   \"  failures:           %u\\n\"\n+\t   \"  max_depth:          %u\\n\",\n+\t   nidxs, nused,\n+\t   var_cache->access_refs.length (), nrefs,\n+\t   hits, misses, failures, max_depth);\n+\n+  if (!contents || !nidxs)\n+    return;\n+\n+  fputs (\"\\npointer_query cache contents:\\n\", dump_file);\n+\n+  for (unsigned i = 0; i != nidxs; ++i)\n+    {\n+      unsigned ari = var_cache->indices[i];\n+      if (!ari)\n+\tcontinue;\n+\n+      const access_ref &aref = var_cache->access_refs[ari];\n+      if (!aref.ref)\n+\tcontinue;\n+\n+      /* The level-1 cache index corresponds to the SSA_NAME_VERSION\n+\t shifted left by one and ORed with the Object Size Type in\n+\t the lowest bit.  Print the two separately.  */\n+      unsigned ver = i >> 1;\n+      unsigned ost = i & 1;\n+\n+      fprintf (dump_file, \"  %u.%u[%u]: \", ver, ost, ari);\n+      if (tree name = ssa_name (ver))\n+\t{\n+\t  print_generic_expr (dump_file, name);\n+\t  fputs (\" = \", dump_file);\n+\t}\n+      else\n+\tfprintf (dump_file, \"  _%u = \", ver);\n+\n+      if (gphi *phi = aref.phi ())\n+\t{\n+\t  fputs (\"PHI <\", dump_file);\n+\t  unsigned nargs = gimple_phi_num_args (phi);\n+\t  for (unsigned i = 0; i != nargs; ++i)\n+\t    {\n+\t      tree arg = gimple_phi_arg_def (phi, i);\n+\t      print_generic_expr (dump_file, arg);\n+\t      if (i + 1 < nargs)\n+\t\tfputs (\", \", dump_file);\n+\t    }\n+\t  fputc ('>', dump_file);\n+\t}\n+      else\n+\tprint_generic_expr (dump_file, aref.ref);\n+\n+      if (aref.offrng[0] != aref.offrng[1])\n+\tfprintf (dump_file, \" + [%lli, %lli]\",\n+\t\t (long long) aref.offrng[0].to_shwi (),\n+\t\t (long long) aref.offrng[1].to_shwi ());\n+      else if (aref.offrng[0] != 0)\n+\tfprintf (dump_file, \" %c %lli\",\n+\t\t aref.offrng[0] < 0 ? '-' : '+',\n+\t\t (long long) aref.offrng[0].to_shwi ());\n+\n+      fputc ('\\n', dump_file);\n+    }\n+\n+  fputc ('\\n', dump_file);\n+}\n+\n /* A helper of compute_objsize_r() to determine the size from an assignment\n    statement STMT with the RHS of either MIN_EXPR or MAX_EXPR.  */\n \n@@ -1782,8 +1884,14 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \t  if (const access_ref *cache_ref = qry->get_ref (ptr))\n \t    {\n \t      /* If the pointer is in the cache set *PREF to what it refers\n-\t\t to and return success.  */\n+\t\t to and return success.\n+\t\t FIXME: BNDRNG is determined by each access and so it doesn't\n+\t\t belong in access_ref.  Until the design is changed, keep it\n+\t\t unchanged here.  */\n+\t      const offset_int bndrng[2] = { pref->bndrng[0], pref->bndrng[1] };\n \t      *pref = *cache_ref;\n+\t      pref->bndrng[0] = bndrng[0];\n+\t      pref->bndrng[1] = bndrng[1];\n \t      return true;\n \t    }\n \t}\n@@ -1928,13 +2036,18 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \t    pref->add_offset (orng[0], orng[1]);\n \t  else\n \t    pref->add_max_offset ();\n+\n \t  qry->put_ref (ptr, *pref);\n \t  return true;\n \t}\n \n-      if (code == ADDR_EXPR\n-\t  || code == SSA_NAME)\n-\treturn compute_objsize_r (rhs, ostype, pref, snlim, qry);\n+      if (code == ADDR_EXPR || code == SSA_NAME)\n+\t{\n+\t  if (!compute_objsize_r (rhs, ostype, pref, snlim, qry))\n+\t    return false;\n+\t  qry->put_ref (ptr, *pref);\n+\t  return true;\n+\t}\n \n       /* (This could also be an assignment from a nonlocal pointer.)  Save\n \t PTR to mention in diagnostics but otherwise treat it as a pointer"}, {"sha": "3c8172c652dda27806b72ca0d4bd924222738bfe", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -186,6 +186,9 @@ class pointer_query\n   /* Flush the cache.  */\n   void flush_cache ();\n \n+  /* Dump statistics and optionally cache contents to DUMP_FILE.  */\n+  void dump (FILE *, bool = false);\n+\n   /* A Ranger instance.  May be null to use global ranges.  */\n   range_query *rvals;\n   /* Cache of SSA_NAMEs.  May be null to disable caching.  */"}, {"sha": "cf536527fb9aade3218657c2e0a93170d32f4555", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-11.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -56,7 +56,7 @@ void test_memset_array_cst_range_off (void)\n   T (2, SR ( 1, 2), 4);\n   T (2, SR ( 1, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n \n-  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (2, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n   T (7, UR (-7, 0), 7);\n   T (7, UR (-7, 0), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n@@ -134,7 +134,7 @@ void test_memcpy_array_cst_range_off (const void *s)\n   T (2, SR ( 1, 2), 4);\n   T (2, SR ( 1, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n \n-  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (2, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n   T (7, UR (-7, 0), 7);\n   T (7, UR (-7, 0), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n@@ -211,7 +211,7 @@ void test_strcpy_array_cst_range_off (void)\n   T (2, SR ( 1, 2), 3);\n   T (2, SR ( 1, 2), 4);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n \n-  T (2, SR ( 0, 1), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, SR ( 0, 1), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (2, UR ( 1, 2), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n   T (7, UR (-7, 0), 6);\n   T (7, UR (-7, 0), 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n@@ -277,7 +277,7 @@ void test_strncpy_array_cst_range_off (const char *s)\n   T (2, SR ( 1, 2), 4);\n   T (2, SR ( 1, 2), 5);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n \n-  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-* } } */\n+  T (2, SR ( 0, 1), 6);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (2, UR ( 1, 2), 7);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n   T (7, UR (-7, 0), 7);\n   T (7, UR (-7, 0), 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */"}, {"sha": "1ba77209887331ed875315df593e63eb81935342", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-12.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -25,9 +25,7 @@ void test_memcpy_array_cst_range_off (const void *s)\n   T (d + UR (1, 2), 5);\n \n   T (d + UR (0, 1), 6);\n-  /* The warning below should be \"writing\" but the [0, 1] range\n-     is somehow lost and get_range_info() returns VR_VARYING.  */\n-  T (d + UR (0, 1), 7);       /* { dg-warning \".memcpy. writing 7 bytes into a region of size 6 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n+  T (d + UR (0, 1), 7);       /* { dg-warning \".memcpy. writing 7 bytes into a region of size 6 overflows the destination\" \"pr89428\" } */\n   T (d + UR (1, 2), 6);       /* { dg-warning \".memcpy. writing 6 bytes into a region of size 5 overflows the destination\" } */\n   T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n \n@@ -66,7 +64,7 @@ void test_memset_array_unsigned_off (void)\n   T (d + UR (1, 2), 5);\n \n   T (d + UR (0, 1), 6);\n-  T (d + UR (0, 1), 7);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n+  T (d + UR (0, 1), 7);       /* { dg-warning \".memset. writing 7 bytes into a region of size 6 overflows the destination\" \"pr89428\" } */\n   T (d + UR (1, 2), 6);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" } */\n   T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n "}, {"sha": "91006618fa614d4f3c95eb01f05f6c439be4aa92", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-43.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -161,16 +161,19 @@ void warn_memset_reversed_range (void)\n \n   /* Since the offset is excessive, either starting before &a11[0]\n      ot just past &a[11], the region size in the warning should\n-     probably be zero, but accept other sizes too.  */\n-  T1 (p, SAR (INT_MIN, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size \\\\d+\" }\n+     probably be zero, but accept other sizes too.\n+\n+     The problem isn't detected anymore because the offset is in\n+     the anti-range ~[INT_MIN, -11] which isn't handled.  */\n+  T1 (p, SAR (INT_MIN, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size \\\\d+\" \"\" { xfail *-*-* } }\n \n   /* The following are represented as ordinary ranges with reversed bounds\n      and those are handled. */\n   T1 (p, SAR (INT_MIN,  11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   T1 (p, SAR (INT_MIN,   1), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   T1 (p, SAR (INT_MIN,   0), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   /* Also represented as a true anti-range.  */\n-  T1 (p, SAR (    -12, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size \\\\d+\" }\n+  T1 (p, SAR (    -12, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size \\\\d+\" \"\" { xfail *-*-* } }\n   T1 (p, SAR (    -12,  -1), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   T1 (p, SAR (    -11,   0), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   T1 (p, SAR (    -11,  11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }"}, {"sha": "0bb4afecc7e06a057a3fb279d2dcb44c90feb617", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-73.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-73.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-73.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-73.c?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -0,0 +1,35 @@\n+/*\n+  { dg-do compile }\n+  { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+int memcmp (const void*, const void*, size_t);\n+int strncmp (const char*, const char*, size_t);\n+char* stpncpy (char*, const char*, size_t);\n+char* strncpy (char*, const char*, size_t);\n+\n+extern char a4[4], b5[5];\n+\n+struct A { char a4[4]; };\n+\n+extern volatile int i;\n+extern void* volatile ptr;\n+\n+void test_stpncpy (struct A *p)\n+{\n+  ptr = stpncpy (a4, b5, 4);\n+  ptr = stpncpy (a4, b5, 5);      // { dg-warning \"writing 5 bytes\" }\n+\n+  ptr = stpncpy (p->a4, b5, 4);\n+  ptr = stpncpy (p->a4, b5, 5);   // { dg-warning \"writing 5 bytes\" }\n+}\n+\n+void test_strncpy (struct A *p)\n+{\n+  ptr = strncpy (a4, b5, 4);\n+  ptr = strncpy (a4, b5, 5);      // { dg-warning \"writing 5 bytes\" }\n+\n+  ptr = strncpy (p->a4, b5, 4);\n+  ptr = strncpy (p->a4, b5, 5);   // { dg-warning \"writing 5 bytes\" }\n+}"}, {"sha": "7c93958e9addcdc1cefd8947c7a16f7af5224080", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 11, "deletions": 63, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece28da924ddda8b379c94c9df7cd01168f75fbb/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=ece28da924ddda8b379c94c9df7cd01168f75fbb", "patch": "@@ -200,61 +200,29 @@ static bool handle_assign (gimple_stmt_iterator *, tree, bool *,\n /* Sets MINMAX to either the constant value or the range VAL is in\n    and returns either the constant value or VAL on success or null\n    when the range couldn't be determined.  Uses RVALS when nonnull\n-   to determine the range, otherwise uses global range info.  */\n+   to determine the range, otherwise uses CFUN or global range info,\n+   whichever is nonnull.  */\n \n tree\n get_range (tree val, gimple *stmt, wide_int minmax[2],\n \t   range_query *rvals /* = NULL */)\n {\n-  if (TREE_CODE (val) == INTEGER_CST)\n-    {\n-      minmax[0] = minmax[1] = wi::to_wide (val);\n-      return val;\n-    }\n-\n-  if (TREE_CODE (val) != SSA_NAME)\n-    return NULL_TREE;\n+  if (!rvals)\n+    rvals = get_range_query (cfun);\n \n   value_range vr;\n-  if (rvals && stmt)\n-    {\n-      if (!rvals->range_of_expr (vr, val, stmt))\n-\treturn NULL_TREE;\n-      value_range_kind rng = vr.kind ();\n-      if (rng != VR_RANGE)\n-\treturn NULL_TREE;\n-\n-      minmax[0] = wi::to_wide (vr.min ());\n-      minmax[1] = wi::to_wide (vr.max ());\n-      return val;\n-    }\n-\n-  // ?? This entire function should use get_range_query or get_global_range_query (),\n-  // instead of doing something different for RVALS and global ranges.\n-\n-  if (!get_global_range_query ()->range_of_expr (vr, val) || vr.undefined_p ())\n+  if (!rvals->range_of_expr (vr, val, stmt))\n     return NULL_TREE;\n \n-  minmax[0] = wi::to_wide (vr.min ());\n-  minmax[1] = wi::to_wide (vr.max ());\n   value_range_kind rng = vr.kind ();\n   if (rng == VR_RANGE)\n-    /* This may be an inverted range whose MINMAX[1] < MINMAX[0].  */\n-    return val;\n-\n-  if (rng == VR_ANTI_RANGE)\n     {\n-      /* An anti-range is the same as an ordinary range with inverted\n-\t bounds (where MINMAX[1] < MINMAX[0] is true) that may result\n-\t from the conversion of a signed anti-range to unsigned.  */\n-      wide_int tmp = minmax[0];\n-      minmax[0] = minmax[1] + 1;\n-      minmax[1] = wi::sub (tmp, 1);\n+      /* Only handle straight ranges.  */\n+      minmax[0] = wi::to_wide (vr.min ());\n+      minmax[1] = wi::to_wide (vr.max ());\n       return val;\n     }\n \n-  /* Do not handle anti-ranges and instead make use of the on-demand\n-     VRP if/when it becomes available (hopefully in GCC 11).  */\n   return NULL_TREE;\n }\n \n@@ -943,8 +911,8 @@ dump_strlen_info (FILE *fp, gimple *stmt, range_query *rvals)\n \t\t      else\n \t\t\t{\n \t\t\t  value_range vr;\n-\t\t\t  get_global_range_query ()->range_of_expr (vr,\n-\t\t\t\t\t\t\t     si->nonzero_chars);\n+\t\t\t  get_range_query (cfun)\n+\t\t\t    ->range_of_expr (vr, si->nonzero_chars);\n \t\t\t  rng = vr.kind ();\n \t\t\t  if (!vr.undefined_p ())\n \t\t\t    {\n@@ -5820,27 +5788,7 @@ printf_strlen_execute (function *fun, bool warn_only)\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      unsigned nused = 0;\n-      unsigned nidxs = walker.ptr_qry.var_cache->indices.length ();\n-      for (unsigned i = 0; i != nidxs; ++i)\n-\tif (walker.ptr_qry.var_cache->indices[i])\n-\t  ++nused;\n-\n-      fprintf (dump_file, \"pointer_query counters\\n\"\n-\t       \"  index cache size:  %u\\n\"\n-\t       \"  utilization:       %u%%\\n\"\n-\t       \"  access cache size: %u\\n\"\n-\t       \"  hits:              %u\\n\"\n-\t       \"  misses:            %u\\n\"\n-\t       \"  failures:          %u\\n\"\n-\t       \"  max_depth:         %u\\n\",\n-\t       nidxs,\n-\t       nidxs == 0 ? 0 : (nused * 100) / nidxs,\n-\t       walker.ptr_qry.var_cache->access_refs.length (),\n-\t       walker.ptr_qry.hits, walker.ptr_qry.misses,\n-\t       walker.ptr_qry.failures, walker.ptr_qry.max_depth);\n-    }\n+    walker.ptr_qry.dump (dump_file);\n \n   ssa_ver_to_stridx.release ();\n   strinfo_pool.release ();"}]}