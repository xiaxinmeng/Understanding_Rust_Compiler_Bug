{"sha": "d604bca36430702c878d4e4cca1e8e0ccee35124", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwNGJjYTM2NDMwNzAyYzg3OGQ0ZTRjY2ExZThlMGNjZWUzNTEyNA==", "commit": {"author": {"name": "Matt Hiller", "email": "hiller@redhat.com", "date": "2002-04-25T19:31:45Z"}, "committer": {"name": "Matthew Hiller", "email": "hiller@gcc.gnu.org", "date": "2002-04-25T19:31:45Z"}, "message": "mips.c (mips_class_max_nregs, [...]): New functions.\n\n2002-04-24  Matt Hiller  <hiller@redhat.com>\n\n\t* mips.c (mips_class_max_nregs, mips_register_move_cost): New\n\tfunctions.\n\t* mips.h (CLASS_MAX_NREGS, REGISTER_MOVE_COST): Redefine as calls\n\tof the corresponding functions.\n\t* mips-protos.h (mips_class_max_nregs, mips_register_move_cost):\n\tNew prototypes.\n\n2002-04-24  Matt Hiller  <hiller@redhat.com>\n\n\t* config/mips/mips.h (mips_sw_reg_names): Declare as extern.\n\n\t(ALL_COP_ADDITIONAL_REGISTER_NAMES): New macro.\n\t(FIRST_PSEUDO_REGISTER): Redefine considering coprocessor\n\tregisters, adjust comment accordingly.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS,\n\treg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS, REGISTER_NAMES,\n\tDEBUG_REGISTER_NAMES, REG_ALLOC_ORDER): Adjust to include entries\n\tfor coprocessor registers.\n\t(ADDITIONAL_REGISTER_NAMES): Include\n\tALL_COP_ADDITIONAL_REGISTER_NAMES.\n\n\t(COP0_REG_FIRST, COP0_REG_LAST, COP0_REG_NUM,\n\tCOP2_REG_FIRST, COP2_REG_LAST, COP2_REG_NUM,\n\tCOP3_REG_FIRST, COP3_REG_LAST, COP3_REG_NUM,\n\tCOP0_REG_P, COP2_REG_P, COP3_REG_P, ALL_COP_REG_P,\n\tCOPNUM_AS_CHAR_FROM_REGNUM, COP_REG_CLASS_P): New macros.\n\n\t(mips_char_to_class): Adjust comment to include coprocessor\n\tconstraint letters.\n\n\t* config/mips/mips.c (coprocessor_operand, coprocessor2_operand):\n\tNew functions.\n\t(mips_reg_names, mips_regno_to_class): Include coprocessor\n\tinformation.\n\t(mips_sw_reg_names): Ditto, make non-static.\n\t(mips_move_1word): Handle moves to and from coprocessor registers.\n\t(mips_move_2words): Handle moves to and from coprocessor\n\tregisters.\n\t(mips_class_max_nregs, mips_register_move_cost): Handle\n\tcoprocessor register classes.\n\t(override_options): Initialize mips_char_to_class and\n\tmips_hard_regno_mode_ok properly for coprocessor registers.\n\n\t* config/mips/mips.md (movdi_internal, movdi_internal2,\n\tmovsi_internal1, movsi_internal2): Add constraint-sets for\n\tcoprocessor registers.\n\t* testsuite/gcc.c-torture/mipscop-1.c: New testcase.\n\t* testsuite/gcc.c-torture/mipscop-1.x: Disable above if target\n\tisn't mips.\n\t* testsuite/gcc.c-torture/mipscop-2.c: New testcase.\n\t* testsuite/gcc.c-torture/mipscop-2.x: Disable above if target\n\tisn't mips.\n\t* testsuite/gcc.c-torture/mipscop-3.c: New testcase.\n\t* testsuite/gcc.c-torture/mipscop-3.x: Disable above if target\n\tisn't mips.\n\t* testsuite/gcc.c-torture/mipscop-4.c: New testcase.\n\t* testsuite/gcc.c-torture/mipscop-4.x: Disable above if target\n\tisn't mips.\n\n\t* doc/tm.texi: Document feature.\n\nFrom-SVN: r52765", "tree": {"sha": "3f73c185f3047203d3682074bdd5aa45213cb02e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f73c185f3047203d3682074bdd5aa45213cb02e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d604bca36430702c878d4e4cca1e8e0ccee35124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d604bca36430702c878d4e4cca1e8e0ccee35124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d604bca36430702c878d4e4cca1e8e0ccee35124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d604bca36430702c878d4e4cca1e8e0ccee35124/comments", "author": null, "committer": null, "parents": [{"sha": "b9a26d0920dd12f8595a1f193c7db2045f9eb7d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a26d0920dd12f8595a1f193c7db2045f9eb7d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a26d0920dd12f8595a1f193c7db2045f9eb7d0"}], "stats": {"total": 841, "additions": 753, "deletions": 88}, "files": [{"sha": "855042cd5d2b8646a8375644e3f95cd9c9f6448c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -1,3 +1,66 @@\n+2002-04-25  Matt Hiller  <hiller@redhat.com>\n+\n+\t* mips.c (mips_class_max_nregs, mips_register_move_cost): New\n+\tfunctions.\n+\t* mips.h (CLASS_MAX_NREGS, REGISTER_MOVE_COST): Redefine as calls\n+\tof the corresponding functions.\n+\t* mips-protos.h (mips_class_max_nregs, mips_register_move_cost):\n+\tNew prototypes.\n+\t\n+2002-04-25  Matt Hiller  <hiller@redhat.com>\n+\n+\t* config/mips/mips.h (mips_sw_reg_names): Declare as extern.\n+\n+\t(ALL_COP_ADDITIONAL_REGISTER_NAMES): New macro.\n+\t(FIRST_PSEUDO_REGISTER): Redefine considering coprocessor\n+\tregisters, adjust comment accordingly.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS,\n+\treg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS, REGISTER_NAMES,\n+\tDEBUG_REGISTER_NAMES, REG_ALLOC_ORDER): Adjust to include entries\n+\tfor coprocessor registers.\n+\t(ADDITIONAL_REGISTER_NAMES): Include\n+\tALL_COP_ADDITIONAL_REGISTER_NAMES.\n+\t\n+\t(COP0_REG_FIRST, COP0_REG_LAST, COP0_REG_NUM,\n+\tCOP2_REG_FIRST, COP2_REG_LAST, COP2_REG_NUM,\n+\tCOP3_REG_FIRST, COP3_REG_LAST, COP3_REG_NUM,\n+\tCOP0_REG_P, COP2_REG_P, COP3_REG_P, ALL_COP_REG_P,\n+\tCOPNUM_AS_CHAR_FROM_REGNUM, COP_REG_CLASS_P): New macros.\n+\n+\t(mips_char_to_class): Adjust comment to include coprocessor\n+\tconstraint letters.\n+\n+\t* config/mips/mips.c (coprocessor_operand, coprocessor2_operand):\n+\tNew functions.\n+\t(mips_reg_names, mips_regno_to_class): Include coprocessor\n+\tinformation.\n+\t(mips_sw_reg_names): Ditto, make non-static.\n+\t(mips_move_1word): Handle moves to and from coprocessor registers.\n+\t(mips_move_2words): Handle moves to and from coprocessor\n+\tregisters.\n+\t(mips_class_max_nregs, mips_register_move_cost): Handle\n+\tcoprocessor register classes.\n+\t(override_options): Initialize mips_char_to_class and\n+\tmips_hard_regno_mode_ok properly for coprocessor registers.\n+\n+\t* config/mips/mips.md (movdi_internal, movdi_internal2,\n+\tmovsi_internal1, movsi_internal2): Add constraint-sets for\n+\tcoprocessor registers.\n+\t* testsuite/gcc.c-torture/mipscop-1.c: New testcase.\n+\t* testsuite/gcc.c-torture/mipscop-1.x: Disable above if target\n+\tisn't mips.\n+\t* testsuite/gcc.c-torture/mipscop-2.c: New testcase.\n+\t* testsuite/gcc.c-torture/mipscop-2.x: Disable above if target\n+\tisn't mips.\n+\t* testsuite/gcc.c-torture/mipscop-3.c: New testcase.\n+\t* testsuite/gcc.c-torture/mipscop-3.x: Disable above if target\n+\tisn't mips.\n+\t* testsuite/gcc.c-torture/mipscop-4.c: New testcase.\n+\t* testsuite/gcc.c-torture/mipscop-4.x: Disable above if target\n+\tisn't mips.\n+\t\n+\t* doc/tm.texi: Document feature.\n+\n 2002-04-25  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* integrate.c (function_attribute_inlinable_p): Simplify."}, {"sha": "29854f03a01b3a049e6b77e1100ea6af6a50ed4d", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -117,6 +117,11 @@ extern int              mips_adjust_insn_length PARAMS ((rtx, int));\n extern enum reg_class\tmips_secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t\t\t     rtx, int));\n+extern int              mips_class_max_nregs PARAMS ((enum reg_class,\n+\t\t\t\t\t\t      enum machine_mode));\n+extern int              mips_register_move_cost PARAMS ((enum machine_mode,\n+\t\t\t\t\t\t\t enum reg_class,\n+\t\t\t\t\t\t\t enum reg_class));\n extern void\t\tmips_select_rtx_section PARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t rtx));\n "}, {"sha": "a02dc6a42a063c6862e807cd8b13c7becf85349e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 281, "deletions": 4, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -90,6 +90,10 @@ struct mips_arg_info;\n static enum internal_test map_test_to_internal_test\tPARAMS ((enum rtx_code));\n static int mips16_simple_memory_operand\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\tenum machine_mode));\n+int coprocessor_operand \t\t\tPARAMS ((rtx,\n+\t\t\t\t\t\t\tenum machine_mode));\n+int coprocessor2_operand \t\t\tPARAMS ((rtx,\n+\t\t\t\t\t\t\tenum machine_mode));\n static int m16_check_op\t\t\t\tPARAMS ((rtx, int, int, int));\n static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t unsigned int,\n@@ -383,13 +387,25 @@ char mips_reg_names[][8] =\n  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n  \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n  \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n- \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\"\n+ \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\", \"\",     \"\",     \"\",     \"\",\n+ \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\n+ \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\n+ \"$c0r16\",\"$c0r17\",\"$c0r18\",\"$c0r19\",\"$c0r20\",\"$c0r21\",\"$c0r22\",\"$c0r23\",\n+ \"$c0r24\",\"$c0r25\",\"$c0r26\",\"$c0r27\",\"$c0r28\",\"$c0r29\",\"$c0r30\",\"$c0r31\",\n+ \"$c2r0\", \"$c2r1\", \"$c2r2\", \"$c2r3\", \"$c2r4\", \"$c2r5\", \"$c2r6\", \"$c2r7\",\n+ \"$c2r8\", \"$c2r9\", \"$c2r10\",\"$c2r11\",\"$c2r12\",\"$c2r13\",\"$c2r14\",\"$c2r15\",\n+ \"$c2r16\",\"$c2r17\",\"$c2r18\",\"$c2r19\",\"$c2r20\",\"$c2r21\",\"$c2r22\",\"$c2r23\",\n+ \"$c2r24\",\"$c2r25\",\"$c2r26\",\"$c2r27\",\"$c2r28\",\"$c2r29\",\"$c2r30\",\"$c2r31\",\n+ \"$c3r0\", \"$c3r1\", \"$c3r2\", \"$c3r3\", \"$c3r4\", \"$c3r5\", \"$c3r6\", \"$c3r7\",\n+ \"$c3r8\", \"$c3r9\", \"$c3r10\",\"$c3r11\",\"$c3r12\",\"$c3r13\",\"$c3r14\",\"$c3r15\",\n+ \"$c3r16\",\"$c3r17\",\"$c3r18\",\"$c3r19\",\"$c3r20\",\"$c3r21\",\"$c3r22\",\"$c3r23\",\n+ \"$c3r24\",\"$c3r25\",\"$c3r26\",\"$c3r27\",\"$c3r28\",\"$c3r29\",\"$c3r30\",\"$c3r31\"\n };\n \n /* Mips software names for the registers, used to overwrite the\n    mips_reg_names array.  */\n \n-static const char mips_sw_reg_names[][8] =\n+char mips_sw_reg_names[][8] =\n {\n   \"$zero\",\"$at\",  \"$v0\",  \"$v1\",  \"$a0\",  \"$a1\",  \"$a2\",  \"$a3\",\n   \"$t0\",  \"$t1\",  \"$t2\",  \"$t3\",  \"$t4\",  \"$t5\",  \"$t6\",  \"$t7\",\n@@ -400,7 +416,19 @@ static const char mips_sw_reg_names[][8] =\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n   \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n-  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\"\n+  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\", \"\",     \"\",     \"\",     \"\",\n+  \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\n+  \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\n+  \"$c0r16\",\"$c0r17\",\"$c0r18\",\"$c0r19\",\"$c0r20\",\"$c0r21\",\"$c0r22\",\"$c0r23\",\n+  \"$c0r24\",\"$c0r25\",\"$c0r26\",\"$c0r27\",\"$c0r28\",\"$c0r29\",\"$c0r30\",\"$c0r31\",\n+  \"$c2r0\", \"$c2r1\", \"$c2r2\", \"$c2r3\", \"$c2r4\", \"$c2r5\", \"$c2r6\", \"$c2r7\",\n+  \"$c2r8\", \"$c2r9\", \"$c2r10\",\"$c2r11\",\"$c2r12\",\"$c2r13\",\"$c2r14\",\"$c2r15\",\n+  \"$c2r16\",\"$c2r17\",\"$c2r18\",\"$c2r19\",\"$c2r20\",\"$c2r21\",\"$c2r22\",\"$c2r23\",\n+  \"$c2r24\",\"$c2r25\",\"$c2r26\",\"$c2r27\",\"$c2r28\",\"$c2r29\",\"$c2r30\",\"$c2r31\",\n+  \"$c3r0\", \"$c3r1\", \"$c3r2\", \"$c3r3\", \"$c3r4\", \"$c3r5\", \"$c3r6\", \"$c3r7\",\n+  \"$c3r8\", \"$c3r9\", \"$c3r10\",\"$c3r11\",\"$c3r12\",\"$c3r13\",\"$c3r14\",\"$c3r15\",\n+  \"$c3r16\",\"$c3r17\",\"$c3r18\",\"$c3r19\",\"$c3r20\",\"$c3r21\",\"$c3r22\",\"$c3r23\",\n+  \"$c3r24\",\"$c3r25\",\"$c3r26\",\"$c3r27\",\"$c3r28\",\"$c3r29\",\"$c3r30\",\"$c3r31\"\n };\n \n /* Map hard register number to register class */\n@@ -424,7 +452,32 @@ const enum reg_class mips_regno_to_class[] =\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   HI_REG,\tLO_REG,\t\tHILO_REG,\tST_REGS,\n   ST_REGS,\tST_REGS,\tST_REGS,\tST_REGS,\n-  ST_REGS,\tST_REGS,\tST_REGS,\tGR_REGS\n+  ST_REGS,\tST_REGS,\tST_REGS,\tGR_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\tCOP0_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\tCOP2_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS\n };\n \n /* Map register constraint character to register class.  */\n@@ -1284,6 +1337,29 @@ consttable_operand (op, mode)\n   return CONSTANT_P (op);\n }\n \n+/* Coprocessor operand; return true if rtx is a REG and refers to a\n+   coprocessor.  */\n+\n+int\n+coprocessor_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == REG\n+\t  && COP0_REG_FIRST <= REGNO (op)\n+\t  && REGNO (op) <= COP3_REG_LAST);\n+}\n+\n+int\n+coprocessor2_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == REG\n+\t  && COP2_REG_FIRST <= REGNO (op)\n+\t  && REGNO (op) <= COP2_REG_LAST);\n+}\n+\n /* Return nonzero if we split the address into high and low parts.  */\n \n /* ??? We should also handle reg+array somewhere.  We get four\n@@ -1995,7 +2071,13 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t  delay = DELAY_LOAD;\n \t\t  if (FP_REG_P (regno1))\n \t\t    ret = \"mfc1\\t%0,%1\";\n+\t\t  else if (ALL_COP_REG_P (regno1))\n+\t\t    {\n+\t\t      static char retval[] = \"mfc_\\t%0,%1\";\n \n+\t\t      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n+\t\t      ret = retval;\n+\t\t    }\n \t\t  else if (regno1 == FPSW_REGNUM && ! ISA_HAS_8CC)\n \t\t    ret = \"cfc1\\t%0,$31\";\n \t\t}\n@@ -2031,6 +2113,21 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t  ret = \"ctc1\\t%0,$31\";\n \t\t}\n \t    }\n+\t  else if (ALL_COP_REG_P (regno0))\n+\t    {\n+\t      if (GP_REG_P (regno1))\n+\t\t{\n+\t\t  static char retval[] = \"mtc_\\t%1,%0\";\n+\t\t  char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n+\n+\t\t  if (cop == '0')\n+\t\t    abort_with_insn (insn,\n+\t\t\t\t     \"mtc0 not supported; it disturbs virtual address translation\");\n+\t\t  delay = DELAY_LOAD;\n+\t\t  retval[3] = cop;\n+\t\t  ret = retval;\n+\t\t}\n+\t    }\n \t}\n \n       else if (code1 == MEM)\n@@ -2069,6 +2166,19 @@ mips_move_1word (operands, insn, unsignedp)\n \t  else if (FP_REG_P (regno0) && (mode == SImode || mode == SFmode))\n \t    ret = \"l.s\\t%0,%1\";\n \n+\t  else if (ALL_COP_REG_P (regno0))\n+\t    {\n+\t      static char retval[] = \"lwc_\\t%0,%1\";\n+\t      char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n+\n+\t      if (cop == '0')\n+\t\tabort_with_insn (insn,\n+\t\t\t\t \"loads from memory to COP0 are illegal\");\n+\t      delay = DELAY_LOAD;\n+\t      retval[3] = cop;\n+\t      ret = retval;\n+\t    }\n+\n \t  if (ret != (char *)0 && MEM_VOLATILE_P (op1))\n \t    {\n \t      size_t i = strlen (ret);\n@@ -2267,6 +2377,13 @@ mips_move_1word (operands, insn, unsignedp)\n \n \t  else if (FP_REG_P (regno1) && (mode == SImode || mode == SFmode))\n \t    ret = \"s.s\\t%1,%0\";\n+\t  else if (ALL_COP_REG_P (regno1))\n+\t    {\n+\t      static char retval[] = \"swc_\\t%1,%0\";\n+\n+\t      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n+\t      ret = retval;\n+\t    }\n \t}\n \n       else if (code1 == CONST_INT && INTVAL (op1) == 0)\n@@ -2453,7 +2570,28 @@ mips_move_2words (operands, insn)\n \t      else\n \t\tret = \"mfhi\\t%M0\\n\\tmflo\\t%L0\";\n \t    }\n+\t  else if (GP_REG_P (regno0) && ALL_COP_REG_P (regno1)\n+\t\t   && TARGET_64BIT)\n+\t    {\n+\t      static char retval[] = \"dmfc_\\t%0,%1\";\n+\n+\t      delay = DELAY_LOAD;\n+\t      retval[4] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n+\t      ret = retval;\n+\t    }\n+\t  else if (ALL_COP_REG_P (regno0) && GP_REG_P (regno1)\n+\t\t   && TARGET_64BIT)\n+\t    {\n+\t      static char retval[] = \"dmtc_\\t%1,%0\";\n+\t      char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n \n+\t      if (cop == '0')\n+\t\tabort_with_insn (insn,\n+\t\t\t\t \"dmtc0 not supported; it disturbs virtual address translation\");\n+\t      delay = DELAY_LOAD;\n+\t      retval[4] = cop;\n+\t      ret = retval;\n+\t    }\n \t  else if (TARGET_64BIT)\n \t    ret = \"move\\t%0,%1\";\n \n@@ -2634,6 +2772,19 @@ mips_move_2words (operands, insn)\n \t  if (FP_REG_P (regno0))\n \t    ret = \"l.d\\t%0,%1\";\n \n+\t  else if (ALL_COP_REG_P (regno0) && TARGET_64BIT)\n+\t    {\n+\t      static char retval[] = \"ldc_\\t%0,%1\";\n+\t      char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n+\n+\t      if (cop == '0')\n+\t\tabort_with_insn (insn,\n+\t\t\t\t \"loads from memory to COP0 are illegal\");\n+\t      delay = DELAY_LOAD;\n+\t      retval[3] = cop;\n+\t      ret = retval;\n+\t    }\n+\n \t  else if (TARGET_64BIT)\n \t    {\n \n@@ -2727,6 +2878,13 @@ mips_move_2words (operands, insn)\n \t  if (FP_REG_P (regno1))\n \t    ret = \"s.d\\t%1,%0\";\n \n+\t  else if (ALL_COP_REG_P (regno1) && TARGET_64BIT)\n+\t    {\n+\t      static char retval[] = \"sdc_\\t%1,%0\";\n+\n+\t      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n+\t      ret = retval;\n+\t    }\n \t  else if (TARGET_64BIT)\n \t    {\n \n@@ -5172,6 +5330,9 @@ override_options ()\n   mips_char_to_class['b'] = ALL_REGS;\n   mips_char_to_class['y'] = GR_REGS;\n   mips_char_to_class['z'] = ST_REGS;\n+  mips_char_to_class['B'] = COP0_REGS;\n+  mips_char_to_class['C'] = COP2_REGS;\n+  mips_char_to_class['D'] = COP3_REGS;\n \n   /* Set up array to map GCC register number to debug register number.\n      Ignore the special purpose register numbers.  */\n@@ -5237,6 +5398,8 @@ override_options ()\n \t\t\t|| (regno == MD_REG_FIRST\n \t\t\t    && size == 2 * UNITS_PER_WORD)));\n \n+\t  else if (ALL_COP_REG_P (regno))\n+\t    temp = (class == MODE_INT && size <= UNITS_PER_WORD);\n \t  else\n \t    temp = 0;\n \n@@ -8215,6 +8378,20 @@ mips_secondary_reload_class (class, mode, x, in_p)\n \n   return NO_REGS;\n }\n+\n+/* This function returns the maximum number of consecutive registers\n+   needed to represent mode MODE in registers of class CLASS.  */\n+\n+int\n+mips_class_max_nregs (class, mode)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+{\n+  if (class == FP_REGS)\n+    return FP_INC;\n+  else\n+    return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n \f\n /* For each mips16 function which refers to GP relative symbols, we\n    use a pseudo register, initialized at the start of the function, to\n@@ -9529,6 +9706,106 @@ highpart_shift_operator (x, mode)\n \t  || code == ROTATE);\n }\n \n+/* Return a number assessing the cost of moving a register in class\n+   FROM to class TO.  The classes are expressed using the enumeration\n+   values such as `GENERAL_REGS'.  A value of 2 is the default; other\n+   values are interpreted relative to that.\n+\n+   It is not required that the cost always equal 2 when FROM is the\n+   same as TO; on some machines it is expensive to move between\n+   registers if they are not general registers.\n+\n+   If reload sees an insn consisting of a single `set' between two\n+   hard registers, and if `REGISTER_MOVE_COST' applied to their\n+   classes returns a value of 2, reload does not check to ensure that\n+   the constraints of the insn are met.  Setting a cost of other than\n+   2 will allow reload to verify that the constraints are met.  You\n+   should do this if the `movM' pattern's constraints do not allow\n+   such copying.\n+\n+   ??? We make make the cost of moving from HI/LO/HILO/MD into general\n+   registers the same as for one of moving general registers to\n+   HI/LO/HILO/MD for TARGET_MIPS16 in order to prevent allocating a\n+   pseudo to HI/LO/HILO/MD.  This might hurt optimizations though, it\n+   isn't clear if it is wise.  And it might not work in all cases.  We\n+   could solve the DImode LO reg problem by using a multiply, just\n+   like reload_{in,out}si.  We could solve the SImode/HImode HI reg\n+   problem by using divide instructions.  divu puts the remainder in\n+   the HI reg, so doing a divide by -1 will move the value in the HI\n+   reg for all values except -1.  We could handle that case by using a\n+   signed divide, e.g.  -1 / 2 (or maybe 1 / -2?).  We'd have to emit\n+   a compare/branch to test the input value to see which instruction\n+   we need to use.  This gets pretty messy, but it is feasible.  */\n+\n+int\n+mips_register_move_cost (mode, to, from)\n+     enum machine_mode mode;\n+     enum reg_class to, from;\n+{\n+  if (from == M16_REGS && GR_REG_CLASS_P (to))\n+    return 2;\n+  else if (from == M16_NA_REGS && GR_REG_CLASS_P (to))\n+    return 2;\n+  else if (GR_REG_CLASS_P (from))\n+    {\n+      if (to == M16_REGS)\n+\treturn 2;\n+      else if (to == M16_NA_REGS)\n+\treturn 2;\n+      else if (GR_REG_CLASS_P (to))\n+\t{\n+\t  if (TARGET_MIPS16)\n+\t    return 4;\n+\t  else\n+\t    return 2;\n+\t}\n+      else if (to == FP_REGS)\n+\treturn 4;\n+      else if (to == HI_REG || to == LO_REG || to == MD_REGS\n+\t       || to == HILO_REG)\n+\t{\n+\t  if (TARGET_MIPS16)\n+\t    return 12;\n+\t  else\n+\t    return 6;\n+\t}\n+      else if (COP_REG_CLASS_P (to))\n+\t{\n+\t  return 5;\n+\t}\n+    }  /* GR_REG_CLASS_P (from) */\n+  else if (from == FP_REGS)\n+    {\n+      if (GR_REG_CLASS_P (to))\n+\treturn 4;\n+      else if (to == FP_REGS)\n+\treturn 2;\n+      else if (to == ST_REGS)\n+\treturn 8;\n+    }  /* from == FP_REGS */\n+  else if (from == HI_REG || from == LO_REG || from == MD_REGS\n+\t   || from == HILO_REG)\n+    {\n+      if (GR_REG_CLASS_P (to))\n+\t{\n+\t  if (TARGET_MIPS16)\n+\t    return 12;\n+\t  else\n+\t    return 6;\n+\t}\n+    }  /* from == HI_REG, etc. */\n+  else if (from == ST_REGS && GR_REG_CLASS_P (to))\n+    return 4;\n+  else if (COP_REG_CLASS_P (from))\n+    {\n+      return 5;\n+    }  /* COP_REG_CLASS_P (from) */\n+\n+  /* fallthru */\n+\n+  return 12;\n+}\n+\n /* Return the length of INSN.  LENGTH is the initial length computed by\n    attributes in the machine-description file.  */\n "}, {"sha": "670b4137a467a0d5277ea2aa6b97c730047c1cda", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 253, "deletions": 68, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -1795,28 +1795,44 @@ do {\t\t\t\t\t\t\t\\\n \n    On the Mips, we have 32 integer registers, 32 floating point\n    registers, 8 condition code registers, and the special registers\n-   hi, lo, hilo, and rap.  The 8 condition code registers are only\n-   used if mips_isa >= 4.  The hilo register is only used in 64 bit\n-   mode.  It represents a 64 bit value stored as two 32 bit values in\n-   the hi and lo registers; this is the result of the mult\n-   instruction.  rap is a pointer to the stack where the return\n-   address reg ($31) was stored.  This is needed for C++ exception\n-   handling.  */\n+   hi, lo, hilo, and rap.  Afetr that we have 32 COP0 registers, 32\n+   COP2 registers, and 32 COp3 registers.  (COP1 is the floating-point\n+   processor.)  The 8 condition code registers are only used if\n+   mips_isa >= 4.  The hilo register is only used in 64 bit mode.  It\n+   represents a 64 bit value stored as two 32 bit values in the hi and\n+   lo registers; this is the result of the mult instruction.  rap is a\n+   pointer to the stack where the return address reg ($31) was stored.\n+   This is needed for C++ exception handling.  */\n \n-#define FIRST_PSEUDO_REGISTER 76\n+#define FIRST_PSEUDO_REGISTER 176\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n \n    On the MIPS, see conventions, page D-2  */\n \n+/* Regarding coprocessor registers: without evidence to the contrary,\n+   it's best to assume that each coprocessor register has a unique\n+   use.  This can be overridden, in, e.g., override_options() or\n+   CONDITIONAL_REGISTER_USAGE should the assumption be inappropriate\n+   for a particular target.  */\n+\n #define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\t\t\t\\\n+  /* COP0 registers */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* COP2 registers */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* COP3 registers */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\\\n }\n \n \n@@ -1833,7 +1849,16 @@ do {\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\t\t\t\\\n+  /* COP0 registers */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* COP2 registers */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* COP3 registers */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\\\n }\n \n /* Like `CALL_USED_REGISTERS' but used to overcome a historical\n@@ -1853,7 +1878,16 @@ do {\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   /* Others.  */                                                        \\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\t\t\t\\\n+  /* COP0 registers */\t\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* COP2 registers */\t\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* COP3 registers */\t\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t\t\t\\\n }\n \n /* Internal macros to classify a register number as to whether it's a\n@@ -1880,6 +1914,20 @@ do {\t\t\t\t\t\t\t\\\n \n #define RAP_REG_NUM   75\n \n+#define COP0_REG_FIRST 80\n+#define COP0_REG_LAST 111\n+#define COP0_REG_NUM (COP0_REG_LAST - COP0_REG_FIRST + 1)\n+\n+#define COP2_REG_FIRST 112\n+#define COP2_REG_LAST 143\n+#define COP2_REG_NUM (COP2_REG_LAST - COP2_REG_FIRST + 1)\n+\n+#define COP3_REG_FIRST 144\n+#define COP3_REG_LAST 175\n+#define COP3_REG_NUM (COP3_REG_LAST - COP3_REG_FIRST + 1)\n+/* ALL_COP_REG_NUM assumes that COP0,2,and 3 are numbered consecutively.  */\n+#define ALL_COP_REG_NUM (COP3_REG_LAST - COP0_REG_FIRST + 1)\n+\n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n@@ -1900,6 +1948,20 @@ do {\t\t\t\t\t\t\t\\\n   ((unsigned int) ((int) (REGNO) - MD_REG_FIRST) < MD_REG_NUM)\n #define ST_REG_P(REGNO) \\\n   ((unsigned int) ((int) (REGNO) - ST_REG_FIRST) < ST_REG_NUM)\n+#define COP0_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - COP0_REG_FIRST) < COP0_REG_NUM)\n+#define COP2_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - COP2_REG_FIRST) < COP2_REG_NUM)\n+#define COP3_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - COP3_REG_FIRST) < COP3_REG_NUM)\n+#define ALL_COP_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - COP0_REG_FIRST) < ALL_COP_REG_NUM)\n+\n+/* Return coprocessor number from register number.  */\n+\n+#define COPNUM_AS_CHAR_FROM_REGNUM(REGNO) \t\t\t\t\\\n+  (COP0_REG_P (REGNO) ? '0' : COP2_REG_P (REGNO) ? '2'\t\t\t\\\n+   : COP3_REG_P (REGNO) ? '3' : '?')\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -2051,10 +2113,18 @@ enum reg_class\n   LO_REG,\t\t\t/* lo register */\n   HILO_REG,\t\t\t/* hilo register pair for 64 bit mode mult */\n   MD_REGS,\t\t\t/* multiply/divide registers (hi/lo) */\n+  COP0_REGS,\t\t\t/* generic coprocessor classes */\n+  COP2_REGS,\n+  COP3_REGS,\n   HI_AND_GR_REGS,\t\t/* union classes */\n   LO_AND_GR_REGS,\n   HILO_AND_GR_REGS,\n   HI_AND_FP_REGS,\n+  COP0_AND_GR_REGS,\n+  COP2_AND_GR_REGS,\n+  COP3_AND_GR_REGS,\n+  ALL_COP_REGS,\n+  ALL_COP_AND_GR_REGS,\n   ST_REGS,\t\t\t/* status registers (fp status) */\n   ALL_REGS,\t\t\t/* all registers */\n   LIM_REG_CLASSES\t\t/* max value + 1 */\n@@ -2081,10 +2151,19 @@ enum reg_class\n   \"LO_REG\",\t\t\t\t\t\t\t\t\\\n   \"HILO_REG\",\t\t\t\t\t\t\t\t\\\n   \"MD_REGS\",\t\t\t\t\t\t\t\t\\\n+  /* coprocessor registers */\t\t\t\t\t\t\\\n+  \"COP0_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"COP2_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"COP3_REGS\",\t\t\t\t\t\t\t\t\\\n   \"HI_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"LO_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"HILO_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n   \"HI_AND_FP_REGS\",\t\t\t\t\t\t\t\\\n+  \"COP0_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n+  \"COP2_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n+  \"COP3_AND_GR_REGS\",\t\t\t\t\t\t\t\\\n+  \"ALL_COP_REGS\",\t\t\t\t\t\t\t\\\n+  \"ALL_COP_AND_GR_REGS\",\t\t\t\t\t\t\\\n   \"ST_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n }\n@@ -2102,23 +2181,31 @@ enum reg_class\n \n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x00000000 },\t/* no registers */\t\\\n-  { 0x0003000c, 0x00000000, 0x00000000 },\t/* mips16 nonarg regs */\\\n-  { 0x000300fc, 0x00000000, 0x00000000 },\t/* mips16 registers */\t\\\n-  { 0x01000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n-  { 0x010300fc, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n-  { 0xffffffff, 0x00000000, 0x00000000 },\t/* integer registers */\t\\\n-  { 0x00000000, 0xffffffff, 0x00000000 },\t/* floating registers*/\t\\\n-  { 0x00000000, 0x00000000, 0x00000001 },\t/* hi register */\t\\\n-  { 0x00000000, 0x00000000, 0x00000002 },\t/* lo register */\t\\\n-  { 0x00000000, 0x00000000, 0x00000004 },\t/* hilo register */\t\\\n-  { 0x00000000, 0x00000000, 0x00000003 },\t/* mul/div registers */\t\\\n-  { 0xffffffff, 0x00000000, 0x00000001 },\t/* union classes */     \\\n-  { 0xffffffff, 0x00000000, 0x00000002 },\t\t\t\t\\\n-  { 0xffffffff, 0x00000000, 0x00000004 },\t\t\t\t\\\n-  { 0x00000000, 0xffffffff, 0x00000001 },\t\t\t\t\\\n-  { 0x00000000, 0x00000000, 0x000007f8 },\t/* status registers */\t\\\n-  { 0xffffffff, 0xffffffff, 0x000007ff }\t/* all registers */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* no registers */\t\\\n+  { 0x0003000c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 nonarg regs */\\\n+  { 0x000300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 registers */\t\\\n+  { 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n+  { 0x010300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* integer registers */\t\\\n+  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* floating registers*/\t\\\n+  { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* hi register */\t\\\n+  { 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },\t/* lo register */\t\\\n+  { 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000 },\t/* hilo register */\t\\\n+  { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x00000000 },\t/* mul/div registers */\t\\\n+  { 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 }, /* cop0 registers */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 }, /* cop2 registers */ \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff }, /* cop3 registers */ \\\n+  { 0xffffffff, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* union classes */     \\\n+  { 0xffffffff, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n+  { 0xffffffff, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n+  { 0x00000000, 0xffffffff, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n+  { 0xffffffff, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 },\t\t\t\\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 },\t\\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff }, \\\n+  { 0x00000000, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff }, \\\n+  { 0xffffffff, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff }, \\\n+  { 0x00000000, 0x00000000, 0x000007f8, 0x00000000, 0x00000000, 0x00000000 },\t/* status registers */\t\\\n+  { 0xffffffff, 0xffffffff, 0xffff07ff, 0xffffffff, 0xffffffff, 0x0000ffff }\t/* all registers */\t\\\n }\n \n \n@@ -2157,6 +2244,10 @@ extern const enum reg_class mips_regno_to_class[];\n   ((CLASS) == GR_REGS || (CLASS) == M16_REGS || (CLASS) == T_REG\t\\\n    || (CLASS) == M16_T_REGS || (CLASS) == M16_NA_REGS)\n \n+/* This macro is also used later on in the file.  */\n+#define COP_REG_CLASS_P(CLASS)\t\t\t\t\t\t\\\n+  ((CLASS)  == COP0_REGS || (CLASS) == COP2_REGS || (CLASS) == COP3_REGS)\n+\n /* REG_ALLOC_ORDER is to order in which to allocate registers.  This\n    is the default value (allocate the registers in numeric order).  We\n    define it just so that we can override it for the mips16 target in\n@@ -2167,7 +2258,13 @@ extern const enum reg_class mips_regno_to_class[];\n   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\t\\\n   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\t\\\n   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\t\\\n-  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75\t\t\t\\\n+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\t\\\n+  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\t\\\n+  96, 97, 98, 99, 100,101,102,103,104,105,106,107,108,109,110,111,\t\\\n+  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,\t\\\n+  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\t\\\n+  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\t\\\n+  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175\t\\\n }\n \n /* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order\n@@ -2195,6 +2292,9 @@ extern const enum reg_class mips_regno_to_class[];\n    'x'\tMultiply/divide registers\n    'a'\tHILO_REG\n    'z'\tFP Status register\n+   'B'  Cop0 register\n+   'C'  Cop2 register\n+   'D'  Cop3 register\n    'b'\tAll registers */\n \n extern enum reg_class mips_char_to_class[256];\n@@ -2333,10 +2433,7 @@ extern enum reg_class mips_char_to_class[256];\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n \n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS\t\t\t\t\t\t\t\\\n-   ? FP_INC\t\t\t\t\t\t\t\t\\\n-   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define CLASS_MAX_NREGS(CLASS, MODE) mips_class_max_nregs (CLASS, MODE)\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.\n@@ -3939,40 +4036,10 @@ while (0)\n    that the constraints of the insn are met.  Setting a cost of\n    other than 2 will allow reload to verify that the constraints are\n    met.  You should do this if the `movM' pattern's constraints do\n-   not allow such copying.\n-\n-   ??? We make make the cost of moving from HI/LO/HILO/MD into general\n-   registers the same as for one of moving general registers to\n-   HI/LO/HILO/MD for TARGET_MIPS16 in order to prevent allocating a\n-   pseudo to HI/LO/HILO/MD.  This might hurt optimizations though, it\n-   isn't clear if it is wise.  And it might not work in all cases.  We\n-   could solve the DImode LO reg problem by using a multiply, just like\n-   reload_{in,out}si.  We could solve the SImode/HImode HI reg problem\n-   by using divide instructions.  divu puts the remainder in the HI\n-   reg, so doing a divide by -1 will move the value in the HI reg for\n-   all values except -1.  We could handle that case by using a signed\n-   divide, e.g.  -1 / 2 (or maybe 1 / -2?).  We'd have to emit a\n-   compare/branch to test the input value to see which instruction we\n-   need to use.  This gets pretty messy, but it is feasible.  */\n-\n-#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\\\n-  ((FROM) == M16_REGS && GR_REG_CLASS_P (TO) ? 2\t\t\t\\\n-   : (FROM) == M16_NA_REGS && GR_REG_CLASS_P (TO) ? 2\t\t\t\\\n-   : GR_REG_CLASS_P (FROM) && (TO) == M16_REGS ? 2\t\t\t\\\n-   : GR_REG_CLASS_P (FROM) && (TO) == M16_NA_REGS ? 2\t\t\t\\\n-   : GR_REG_CLASS_P (FROM) && GR_REG_CLASS_P (TO) ? (TARGET_MIPS16 ? 4 : 2) \\\n-   : (FROM) == FP_REGS && (TO) == FP_REGS ? 2\t\t\t\t\\\n-   : GR_REG_CLASS_P (FROM) && (TO) == FP_REGS ? 4\t\t\t\\\n-   : (FROM) == FP_REGS && GR_REG_CLASS_P (TO) ? 4\t\t\t\\\n-   : (((FROM) == HI_REG || (FROM) == LO_REG\t\t\t\t\\\n-       || (FROM) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n-      && GR_REG_CLASS_P (TO)) ? (TARGET_MIPS16 ? 12 : 6)\t\t\\\n-   : (((TO) == HI_REG || (TO) == LO_REG\t\t\t\t\t\\\n-       || (TO) == MD_REGS || (TO) == HILO_REG)\t\t\t\t\\\n-      && GR_REG_CLASS_P (FROM)) ? (TARGET_MIPS16 ? 12 : 6)\t\t\\\n-   : (FROM) == ST_REGS && GR_REG_CLASS_P (TO) ? 4\t\t\t\\\n-   : (FROM) == FP_REGS && (TO) == ST_REGS ? 8\t\t\t\t\\\n-   : 12)\n+   not allow such copying. */\n+\n+#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\t\t\\\n+  mips_register_move_cost (MODE, FROM, TO)\n \n /* ??? Fix this to be right for the R8000.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,TO_P) \\\n@@ -4201,6 +4268,106 @@ while (0)\n   &mips_reg_names[73][0],\t\t\t\t\t\t\\\n   &mips_reg_names[74][0],\t\t\t\t\t\t\\\n   &mips_reg_names[75][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[76][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[77][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[78][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[79][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[80][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[81][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[82][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[83][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[84][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[85][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[86][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[87][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[88][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[89][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[90][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[91][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[92][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[93][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[94][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[95][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[96][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[97][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[98][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[99][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[100][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[101][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[102][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[103][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[104][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[105][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[106][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[107][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[108][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[109][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[110][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[111][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[112][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[113][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[114][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[115][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[116][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[117][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[118][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[119][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[120][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[121][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[122][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[123][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[124][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[125][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[126][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[127][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[128][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[129][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[130][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[131][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[132][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[133][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[134][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[135][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[136][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[137][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[138][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[139][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[140][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[141][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[142][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[143][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[144][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[145][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[146][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[147][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[148][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[149][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[150][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[151][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[152][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[153][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[154][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[155][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[156][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[157][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[158][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[159][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[160][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[161][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[162][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[163][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[164][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[165][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[166][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[167][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[168][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[169][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[170][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[171][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[172][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[173][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[174][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[175][0]\t\t\t\t\t\t\\\n }\n \n /* print-rtl.c can't use REGISTER_NAMES, since it depends on mips.c.\n@@ -4216,7 +4383,19 @@ while (0)\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t\\\n   \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\t\\\n-  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\"\t\t\t\t\t\\\n+  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\", \"\",     \"\",     \"\",     \"\",\t\t\\\n+  \"$c0r0\", \"$c0r1\", \"$c0r2\", \"$c0r3\", \"$c0r4\", \"$c0r5\", \"$c0r6\", \"$c0r7\",\\\n+  \"$c0r8\", \"$c0r9\", \"$c0r10\",\"$c0r11\",\"$c0r12\",\"$c0r13\",\"$c0r14\",\"$c0r15\",\\\n+  \"$c0r16\",\"$c0r17\",\"$c0r18\",\"$c0r19\",\"$c0r20\",\"$c0r21\",\"$c0r22\",\"$c0r23\",\\\n+  \"$c0r24\",\"$c0r25\",\"$c0r26\",\"$c0r27\",\"$c0r28\",\"$c0r29\",\"$c0r30\",\"$c0r31\",\\\n+  \"$c2r0\", \"$c2r1\", \"$c2r2\", \"$c2r3\", \"$c2r4\", \"$c2r5\", \"$c2r6\", \"$c2r7\",\\\n+  \"$c2r8\", \"$c2r9\", \"$c2r10\",\"$c2r11\",\"$c2r12\",\"$c2r13\",\"$c2r14\",\"$c2r15\",\\\n+  \"$c2r16\",\"$c2r17\",\"$c2r18\",\"$c2r19\",\"$c2r20\",\"$c2r21\",\"$c2r22\",\"$c2r23\",\\\n+  \"$c2r24\",\"$c2r25\",\"$c2r26\",\"$c2r27\",\"$c2r28\",\"$c2r29\",\"$c2r30\",\"$c2r31\",\\\n+  \"$c3r0\", \"$c3r1\", \"$c3r2\", \"$c3r3\", \"$c3r4\", \"$c3r5\", \"$c3r6\", \"$c3r7\",\\\n+  \"$c3r8\", \"$c3r9\", \"$c3r10\",\"$c3r11\",\"$c3r12\",\"$c3r13\",\"$c3r14\",\"$c3r15\",\\\n+  \"$c3r16\",\"$c3r17\",\"$c3r18\",\"$c3r19\",\"$c3r20\",\"$c3r21\",\"$c3r22\",\"$c3r23\",\\\n+  \"$c3r24\",\"$c3r25\",\"$c3r26\",\"$c3r27\",\"$c3r28\",\"$c3r29\",\"$c3r30\",\"$c3r31\"\\\n }\n \n /* If defined, a C initializer for an array of structures\n@@ -4296,8 +4475,14 @@ while (0)\n   { \"ra\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n   { \"$sp\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n   { \"$fp\",\t30 + GP_REG_FIRST }\t\t\t\t\t\\\n+  ALL_COP_ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n }\n \n+/* This is meant to be redefined in the host dependent files.  It is a \n+   set of alternative names and regnums for mips coprocessors.  */\n+\n+#define ALL_COP_ADDITIONAL_REGISTER_NAMES\n+\n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand X.  X is an RTL\n    expression."}, {"sha": "2229f55f6169900db852a583e269a830b6847784", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -5092,17 +5092,17 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"length\"\t\"4,8\")])\n \n (define_insn \"movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,o,*x,*d,*x\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,iF,R,o,d,d,J,*x,*d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,o,*x,*d,*x,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:DI 1 \"general_operand\" \"d,iF,R,o,d,d,J,*x,*d,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"!TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,arith,load,load,store,store,hilo,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,arith,load,load,store,store,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"   \"8,16,8,16,8,16,8,8,8\")])\n+   (set_attr \"length\"   \"8,16,8,16,8,16,8,8,8,8,8,8,8,8,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,R,To,*d\")\n@@ -5128,17 +5128,17 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\")\n \n (define_insn \"movdi_internal2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*x,*d,*x,*a\")\n-\t(match_operand:DI 1 \"movdi_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,J,*x,*d,*J\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*x,*d,*x,*a,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:DI 1 \"movdi_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,J,*x,*d,*J,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || se_register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,hilo,hilo,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,8\")])\n+   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,8,8,8,8,8,8,8\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,R,m,*d\")\n@@ -5524,28 +5524,28 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"movsi_internal1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,J,*d,*x,*a\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,J,*d,*x,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,8,4,8,4,4,4,4\")])\n+   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,8,4,8,4,4,4,4,4,4,8,4,4,8\")])\n \n (define_insn \"movsi_internal2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,J,*x,*d,*a\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,J,*x,*d,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"!TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,4,4\")])\n+   (set_attr \"length\"\t\"4,8,4,8,4,8,4,8,4,4,4,4,4,4,4,4,8,4,4,8\")])\n \n ;; This is the mips16 movsi instruction.  We accept a small integer as\n ;; the source if the destination is a GP memory reference.  This is"}, {"sha": "f3243b22c6f0ddd30de96060ce5bd96ce32bbf85", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -49,6 +49,7 @@ through the macros defined in the @file{.h} file.\n * Floating Point::      Handling floating point for cross-compilers.\n * Mode Switching::      Insertion of mode-switching instructions.\n * Target Attributes::   Defining target-specific uses of @code{__attribute__}.\n+* MIPS Coprocessors::   MIPS coprocessor support and how to customize it.\n * Misc::                Everything else.\n @end menu\n \n@@ -8039,6 +8040,50 @@ attributes, @code{false} otherwise.  By default, if a function has a\n target specific attribute attached to it, it will not be inlined.\n @end deftypefn\n \n+@node MIPS Coprocessors\n+@section Defining coprocessor specifics for MIPS targets.\n+@cindex MIPS coprocessor-definition macros\n+\n+The MIPS specification allows MIPS implementations to have as many as 4\n+coprocessors, each with as many as 32 private registers.  gcc supports\n+accessing these registers and transferring values between the registers\n+and memory using asm-ized variables.  For example:\n+\n+@smallexample\n+  register unsigned int cp0count asm (\"c0r1\");\n+  unsigned int d;\n+\n+  d = cp0count + 3;\n+@end smallexample\n+\n+(``c0r1'' is the default name of register 1 in coprocessor 0; alternate\n+names may be added as described below, or the default names may be\n+overridden entirely in @code{SUBTARGET_CONDITIONAL_REGISTER_USAGE}.)\n+\n+Coprocessor registers are assumed to be epilogue-used; sets to them will\n+be preserved even if it does not appear that the register is used again\n+later in the function.\n+\n+Another note: according to the MIPS spec, coprocessor 1 (if present) is\n+the FPU.  One accesses COP1 registers through standard mips\n+floating-point support; they are not included in this mechanism.\n+\n+There is one macro used in defining the MIPS coprocessor interface which\n+you may want to override in subtargets; it is described below.\n+\n+@table @code\n+\n+@item ALL_COP_ADDITIONAL_REGISTER_NAMES\n+@findex ALL_COP_ADDITIONAL_REGISTER_NAMES\n+A comma-separated list (with leading comma) of pairs describing the\n+alternate names of coprocessor registers.  The format of each entry should be\n+@smallexample\n+@{ @var{alternatename}, @var{register_number}@}\n+@end smallexample\n+Default: empty.\n+\n+@end table\n+\n @node Misc\n @section Miscellaneous Parameters\n @cindex parameters, miscellaneous"}, {"sha": "13be5142d944057d87356f2c0e9313b99e277461", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-1.c?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,10 @@\n+register unsigned int cp0count asm (\"$c0r1\");\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  unsigned int d;\n+\n+  d = cp0count + 3;\n+  printf (\"%d\\n\", d);\n+}"}, {"sha": "3d780ad1e7e7c2d0b6479250f18c882de705edf7", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-1.x", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-1.x?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,8 @@\n+global target_triplet\n+\n+if { ![istarget \"*mips*\"] } {\n+\treturn 1\n+}\n+\n+return 0\n+"}, {"sha": "88e95db12cc74b4efcc0e96bf72f2ea8b76657c9", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-2.c?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,16 @@\n+register unsigned int c3r1 asm (\"$c3r1\");\n+\n+extern unsigned int b, c;\n+\n+void\n+foo ()\n+{\n+  unsigned int a, d;\n+\n+  c3r1 = a;\n+  b = c3r1;\n+\n+  c3r1 = c;\n+  d = c3r1;\n+  printf (\"%d\\n\", d);\n+}"}, {"sha": "3d780ad1e7e7c2d0b6479250f18c882de705edf7", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-2.x", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-2.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-2.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-2.x?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,8 @@\n+global target_triplet\n+\n+if { ![istarget \"*mips*\"] } {\n+\treturn 1\n+}\n+\n+return 0\n+"}, {"sha": "eb602c8a54f60864cea48e45d3da5a266f62290f", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-3.c?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,16 @@\n+register unsigned int c3r1 asm (\"$c3r1\"), c3r2 asm (\"$c3r2\");\n+\n+extern unsigned int b, c;\n+\n+void\n+foo ()\n+{\n+  unsigned int a, d;\n+\n+  c3r1 = a;\n+  b = c3r1;\n+\n+  c3r2 = c;\n+  d = c3r1;\n+  printf (\"%d\\n\", d);\n+}"}, {"sha": "3d780ad1e7e7c2d0b6479250f18c882de705edf7", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-3.x", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-3.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-3.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-3.x?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,8 @@\n+global target_triplet\n+\n+if { ![istarget \"*mips*\"] } {\n+\treturn 1\n+}\n+\n+return 0\n+"}, {"sha": "368db5e90dcf39daa291e038c10fded9ecc5c4d4", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-4.c?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,16 @@\n+register unsigned long c3r1 asm (\"$c3r1\"), c3r2 asm (\"$c3r2\");\n+\n+extern unsigned long b, c;\n+\n+void\n+foo ()\n+{\n+  unsigned long a, d;\n+\n+  c3r1 = a;\n+  b = c3r1;\n+\n+  c3r2 = c;\n+  d = c3r1;\n+  printf (\"%d\\n\", d);\n+}"}, {"sha": "3d780ad1e7e7c2d0b6479250f18c882de705edf7", "filename": "gcc/testsuite/gcc.c-torture/compile/mipscop-4.x", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-4.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d604bca36430702c878d4e4cca1e8e0ccee35124/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-4.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fmipscop-4.x?ref=d604bca36430702c878d4e4cca1e8e0ccee35124", "patch": "@@ -0,0 +1,8 @@\n+global target_triplet\n+\n+if { ![istarget \"*mips*\"] } {\n+\treturn 1\n+}\n+\n+return 0\n+"}]}