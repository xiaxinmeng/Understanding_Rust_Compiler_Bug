{"sha": "f368417601b68ff10406320472a60193dc741f60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM2ODQxNzYwMWI2OGZmMTA0MDYzMjA0NzJhNjAxOTNkYzc0MWY2MA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-07T19:13:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-07T19:13:09Z"}, "message": "entered into RCS\n\nFrom-SVN: r2710", "tree": {"sha": "9f459490399966015d5d40e79ac67b34ac9861e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f459490399966015d5d40e79ac67b34ac9861e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f368417601b68ff10406320472a60193dc741f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f368417601b68ff10406320472a60193dc741f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f368417601b68ff10406320472a60193dc741f60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f368417601b68ff10406320472a60193dc741f60/comments", "author": null, "committer": null, "parents": [{"sha": "a63067c24870d211f8a9398743920fc35cf71326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a63067c24870d211f8a9398743920fc35cf71326", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a63067c24870d211f8a9398743920fc35cf71326"}], "stats": {"total": 126, "additions": 126, "deletions": 0}, "files": [{"sha": "9bb743362f5539bcfe9013701c04f63d7591c9a7", "filename": "gcc/config/elxsi/elxsi.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f368417601b68ff10406320472a60193dc741f60/gcc%2Fconfig%2Felxsi%2Felxsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f368417601b68ff10406320472a60193dc741f60/gcc%2Fconfig%2Felxsi%2Felxsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.c?ref=f368417601b68ff10406320472a60193dc741f60", "patch": "@@ -0,0 +1,126 @@\n+/* Subroutines for insn-output.c for GNU compiler.  Elxsi version.\n+   Copyright (C) 1987, 1992 Free Software Foundation, Inc\n+   This port, done by Mike Stump <mrs@cygnus.com> in 1988, and is the first\n+   64 bit port of GNU CC.\n+   Based upon the VAX port.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+\n+extern char *reg_names[];\n+rtx cmp_op0=0, cmp_op1=0;\n+\n+/* table of relations for compares and branches */\n+char *cmp_tab[] = {\n+    \"gt\", \"gt\", \"eq\", \"eq\", \"ge\", \"ge\", \"lt\", \"lt\", \"ne\", \"ne\",\n+    \"le\", \"le\" };\n+\n+/* type is the index into the above table */\n+/* s is \"\" for signed, or \"u\" for unsigned */\n+char *cmp_jmp(s, type, where) char *s; rtx where; {\n+    rtx br_ops[3];\n+    char template[50];\n+    char *f = \"\";\n+    char *bits = \"64\";\n+    if (GET_MODE (cmp_op0) == SFmode) f = \"f\", bits = \"32\";\n+    if (GET_MODE (cmp_op0) == DFmode) f = \"f\";\n+    br_ops[0] = where;\n+    br_ops[1] = cmp_op0;\n+    br_ops[2] = cmp_op1;\n+    if (cmp_op1)\n+\tsprintf(template, \"%scmp%s.br.%s\\t%%1,%%2:j%s\\t%%l0\",\n+\t\tf, s, bits, cmp_tab[type]);\n+    else if (*f)\n+\tsprintf(template, \"fcmp.br.%s\\t%%1,=0:j%s\\t%%l0\",\n+\t\tbits, cmp_tab[type]);\n+    else if (*s) /* can turn the below in to a jmp ... */\n+\tsprintf(template, \"cmpu.br.64\\t%%1,=0:j%s\\t%%l0\", s, cmp_tab[type]);\n+    else\n+\tsprintf(template, \"jmp.%s\\t%%1,%%l0\", cmp_tab[type+1]);\n+    output_asm_insn(template, br_ops);\n+    return \"\";\n+}\n+\n+char *cmp_set(s, type, reg) char *s, *type; rtx reg; {\n+    rtx br_ops[3];\n+    char template[50];\n+    char *f = \"\";\n+    char *bits = \"64\";\n+    if (GET_MODE (cmp_op0) == SFmode) f = \"f\", bits = \"32\";\n+    else if (GET_MODE (cmp_op0) == DFmode) f = \"f\";\n+    else if (GET_MODE (cmp_op0) == SImode) bits = \"32\";\n+    else if (GET_MODE (cmp_op0) == HImode) bits = \"16\";\n+    else if (GET_MODE (cmp_op0) == QImode) bits = \"8\";\n+    br_ops[0] = reg;\n+    br_ops[1] = cmp_op0;\n+    br_ops[2] = cmp_op1;\n+    if (cmp_op1)\n+\tsprintf(template, \"%scmp%s.%s\\t%%0,%%1,%%2:%s\",\n+\t\tf, s, bits, type);\n+    else\n+\tsprintf(template, \"%scmp%s.%s\\t%%0,%%1,=0:%s\",\n+\t\tf, s, bits, type);\n+    output_asm_insn(template, br_ops);\n+    return \"\";\n+}\n+\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  register rtx reg1, reg2, breg, ireg;\n+  rtx offset;\n+\n+ retry:\n+  switch (GET_CODE (addr))\n+    {\n+\n+    case MEM:\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+        fprintf (file, \"%s\", reg_names[REGNO (addr)]);\n+      else abort();\n+      break;\n+\n+    case REG:\n+      fprintf (file, \"[%s]\", reg_names[REGNO (addr)]);\n+      break;\n+\n+    case PLUS:\n+      reg1 = 0;\treg2 = 0;\n+      ireg = 0;\tbreg = 0;\n+      offset = 0;\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t{\n+\t  offset = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      fprintf (file, \"[%s]\", reg_names[REGNO (addr)]);\n+      output_address (offset);\n+      break;\n+\n+    default:\n+      output_addr_const (file, addr);\n+    }\n+}"}]}