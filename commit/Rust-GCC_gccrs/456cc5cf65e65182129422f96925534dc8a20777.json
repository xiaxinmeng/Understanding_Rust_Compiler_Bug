{"sha": "456cc5cf65e65182129422f96925534dc8a20777", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2Y2M1Y2Y2NWU2NTE4MjEyOTQyMmY5NjkyNTUzNGRjOGEyMDc3Nw==", "commit": {"author": {"name": "Simon Baldwin", "email": "simonb@google.com", "date": "2007-01-29T20:07:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-01-29T20:07:49Z"}, "message": "demangle.h: New cplus_demangle_print_callback...\n\ninclude/:\n\t* demangle.h: New cplus_demangle_print_callback,\n\tcplus_demangle_v3_callback, and java_demangle_v3_callback function\n\tprototypes, and demangle_callbackref type definition.\nlibiberty/:\n\t* cp-demangle.h (cplus_demangle_operators): External definition\n\tsuppressed if not building for libstdc++.\n\t* cp-demangle.c (__gcclibcxx_demangle_callback): Augmented interface\n\tto demangling, provides a malloc-less version of __cxa_demangle.\n\t(cplus_demangle_print_callback): Public callback version of\n\tcplus_demangle_print.\n\t(struct d_growable_string): New growable string structure.\n\t(d_growable_string_init): New function, provides support for\n\tgrowable strings separate from print info.\n\t(d_growable_string_resize): Likewise.\n\t(d_growable_string_append_buffer): Likewise.\n\t(d_growable_string_callback_adapter):): Likewise.\n\t(d_print_init): New print info initialization function.\n\t(d_print_error): Macro replace by inline function.\n\t(d_print_saw_error): Likewise.\n\t(d_append_char): Likewise.\n\t(d_append_buffer): Likewise.\n\t(d_append_string): New inline function, replaces the\n\td_append_string_constant macro.\n\t(d_flush_buffer): New function, flushes buffer to callback.\n\t(d_demangle_callback, is_ctor_or_dtor): Malloc-based fallback\n\tfor unsupported dynamic arrays replaced by alloca().\n\t(d_demangle): Return string length estimating removed.\n\t(d_dump): Moved error case handling from call site into function.\n\t(d_print_resize): Function removed.\n\t(d_print_append_char): Likewise.\n\t(d_print_append_buffer): Likewise.\n\t(d_print_error): Likewise.\n\t(d_print_comp): Added special case handling for Java arrays.\n\t(java_demangle_v3): Removed string post-processing for Java arrays,\n\tnow replaced by special case handling in d_print_comp.\n\t(cplus_demangle_v3_callback): Augmented interface to demangling,\n\tprovides a malloc-less version of cplus_demangle_v3.\n\t(java_demangle_v3_callback): Augmented interface to demangling,\n\tprovides a malloc-less version of java_demangle_v3.\n\nFrom-SVN: r121305", "tree": {"sha": "0de29b23b81ceb6063231181db49a4a5fb6d4d18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0de29b23b81ceb6063231181db49a4a5fb6d4d18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/456cc5cf65e65182129422f96925534dc8a20777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456cc5cf65e65182129422f96925534dc8a20777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/456cc5cf65e65182129422f96925534dc8a20777", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456cc5cf65e65182129422f96925534dc8a20777/comments", "author": null, "committer": null, "parents": [{"sha": "306219a28de461c81501a32d77d3e0b1cce832c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/306219a28de461c81501a32d77d3e0b1cce832c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/306219a28de461c81501a32d77d3e0b1cce832c8"}], "stats": {"total": 848, "additions": 528, "deletions": 320}, "files": [{"sha": "0e8b1500ca86d5853664879090e6fc2f310f61d7", "filename": "include/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cc5cf65e65182129422f96925534dc8a20777/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cc5cf65e65182129422f96925534dc8a20777/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=456cc5cf65e65182129422f96925534dc8a20777", "patch": "@@ -1,3 +1,9 @@\n+2007-01-29  Simon Baldwin <simonb@google.com>\n+\n+\t* demangle.h: New cplus_demangle_print_callback,\n+\tcplus_demangle_v3_callback, and java_demangle_v3_callback function\n+\tprototypes, and demangle_callbackref type definition.\n+\n 2006-12-06  Nick Clifton  <nickc@redhat.com>\n \n \t* ansidecl.h (ATTRIBUTE_PACKED): Define."}, {"sha": "360538cf397c2f71c6be24086540d72671f59e8a", "filename": "include/demangle.h", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cc5cf65e65182129422f96925534dc8a20777/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cc5cf65e65182129422f96925534dc8a20777/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=456cc5cf65e65182129422f96925534dc8a20777", "patch": "@@ -1,6 +1,6 @@\n /* Defs for interface to demanglers.\n    Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002,\n-   2003, 2004 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n    \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -131,13 +131,25 @@ cplus_demangle_set_style (enum demangling_styles style);\n extern enum demangling_styles \n cplus_demangle_name_to_style (const char *name);\n \n-/* V3 ABI demangling entry points, defined in cp-demangle.c.  */\n-extern char*\n-cplus_demangle_v3 (const char* mangled, int options);\n+/* Callback typedef for allocation-less demangler interfaces. */\n+typedef void (*demangle_callbackref) (const char *, size_t, void *);\n+\n+/* V3 ABI demangling entry points, defined in cp-demangle.c.  Callback\n+   variants return non-zero on success, zero on error.  char* variants\n+   return a string allocated by malloc on success, NULL on error.  */\n+extern int\n+cplus_demangle_v3_callback (const char *mangled, int options,\n+                            demangle_callbackref callback, void *opaque);\n \n extern char*\n-java_demangle_v3 (const char* mangled);\n+cplus_demangle_v3 (const char *mangled, int options);\n \n+extern int\n+java_demangle_v3_callback (const char *mangled,\n+                           demangle_callbackref callback, void *opaque);\n+\n+extern char*\n+java_demangle_v3 (const char *mangled);\n \n enum gnu_v3_ctor_kinds {\n   gnu_v3_complete_object_ctor = 1,\n@@ -529,6 +541,25 @@ cplus_demangle_print (int options,\n                       int estimated_length,\n                       size_t *p_allocated_size);\n \n+/* This function takes a struct demangle_component tree and passes back\n+   a demangled string in one or more calls to a callback function.\n+   The first argument is DMGL_* options.  The second is the tree to\n+   demangle.  The third is a pointer to a callback function; on each call\n+   this receives an element of the demangled string, its length, and an\n+   opaque value.  The fourth is the opaque value passed to the callback.\n+   The callback is called once or more to return the full demangled\n+   string.  The demangled element string is always nul-terminated, though\n+   its length is also provided for convenience.  In contrast to\n+   cplus_demangle_print(), this function does not allocate heap memory\n+   to grow output strings (except perhaps where alloca() is implemented\n+   by malloc()), and so is normally safe for use where the heap has been\n+   corrupted.  On success, this function returns 1; on failure, 0.  */\n+\n+extern int\n+cplus_demangle_print_callback (int options,\n+                               const struct demangle_component *tree,\n+                               demangle_callbackref callback, void *opaque);\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "09c8c75148617b7a59c74ecbb31a999efda96ba0", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cc5cf65e65182129422f96925534dc8a20777/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cc5cf65e65182129422f96925534dc8a20777/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=456cc5cf65e65182129422f96925534dc8a20777", "patch": "@@ -1,3 +1,41 @@\n+2007-01-29  Simon Baldwin <simonb@google.com>\n+\n+\t* cp-demangle.h (cplus_demangle_operators): External definition\n+\tsuppressed if not building for libstdc++.\n+\t* cp-demangle.c (__gcclibcxx_demangle_callback): Augmented interface\n+\tto demangling, provides a malloc-less version of __cxa_demangle.\n+\t(cplus_demangle_print_callback): Public callback version of\n+\tcplus_demangle_print.\n+\t(struct d_growable_string): New growable string structure.\n+\t(d_growable_string_init): New function, provides support for\n+\tgrowable strings separate from print info.\n+\t(d_growable_string_resize): Likewise.\n+\t(d_growable_string_append_buffer): Likewise.\n+\t(d_growable_string_callback_adapter):): Likewise.\n+\t(d_print_init): New print info initialization function.\n+\t(d_print_error): Macro replace by inline function.\n+\t(d_print_saw_error): Likewise.\n+\t(d_append_char): Likewise.\n+\t(d_append_buffer): Likewise.\n+\t(d_append_string): New inline function, replaces the\n+\td_append_string_constant macro.\n+\t(d_flush_buffer): New function, flushes buffer to callback.\n+\t(d_demangle_callback, is_ctor_or_dtor): Malloc-based fallback\n+\tfor unsupported dynamic arrays replaced by alloca().\n+\t(d_demangle): Return string length estimating removed.\n+\t(d_dump): Moved error case handling from call site into function.\n+\t(d_print_resize): Function removed.\n+\t(d_print_append_char): Likewise.\n+\t(d_print_append_buffer): Likewise.\n+\t(d_print_error): Likewise.\n+\t(d_print_comp): Added special case handling for Java arrays.\n+\t(java_demangle_v3): Removed string post-processing for Java arrays,\n+\tnow replaced by special case handling in d_print_comp.\n+\t(cplus_demangle_v3_callback): Augmented interface to demangling,\n+\tprovides a malloc-less version of cplus_demangle_v3.\n+\t(java_demangle_v3_callback): Augmented interface to demangling,\n+\tprovides a malloc-less version of java_demangle_v3.\n+\n 2007-01-12  Ben Elliston  <bje@au.ibm.com>\n \n \t* pex-unix.c (writeerr): Cast write result to void."}, {"sha": "1e775d9a9c1d8c4df4ece5724797ea86e0d3e181", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 444, "deletions": 312, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cc5cf65e65182129422f96925534dc8a20777/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cc5cf65e65182129422f96925534dc8a20777/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=456cc5cf65e65182129422f96925534dc8a20777", "patch": "@@ -1,5 +1,5 @@\n /* Demangler for g++ V3 ABI.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Written by Ian Lance Taylor <ian@wasabisystems.com>.\n \n    This file is part of the libiberty library, which is part of GCC.\n@@ -42,6 +42,10 @@\n    This file will normally define the following functions, q.v.:\n       char *cplus_demangle_v3(const char *mangled, int options)\n       char *java_demangle_v3(const char *mangled)\n+      int cplus_demangle_v3_callback(const char *mangled, int options,\n+                                     demangle_callbackref callback)\n+      int java_demangle_v3_callback(const char *mangled,\n+                                    demangle_callbackref callback)\n       enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor (const char *name)\n       enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor (const char *name)\n \n@@ -50,12 +54,14 @@\n    defined in demangle.h:\n       enum demangle_component_type\n       struct demangle_component\n+      demangle_callbackref\n    and these functions defined in this file:\n       cplus_demangle_fill_name\n       cplus_demangle_fill_extended_operator\n       cplus_demangle_fill_ctor\n       cplus_demangle_fill_dtor\n       cplus_demangle_print\n+      cplus_demangle_print_callback\n    and other functions defined in the file cp-demint.c.\n \n    This file also defines some other functions and variables which are\n@@ -64,14 +70,20 @@\n    Preprocessor macros you can define while compiling this file:\n \n    IN_LIBGCC2\n-      If defined, this file defines the following function, q.v.:\n+      If defined, this file defines the following functions, q.v.:\n          char *__cxa_demangle (const char *mangled, char *buf, size_t *len,\n                                int *status)\n-      instead of cplus_demangle_v3() and java_demangle_v3().\n+         int __gcclibcxx_demangle_callback (const char *,\n+                                            void (*)\n+                                              (const char *, size_t, void *),\n+                                            void *)\n+      instead of cplus_demangle_v3[_callback]() and\n+      java_demangle_v3[_callback]().\n \n    IN_GLIBCPP_V3\n-      If defined, this file defines only __cxa_demangle(), and no other\n-      publically visible functions or variables.\n+      If defined, this file defines only __cxa_demangle() and\n+      __gcclibcxx_demangle_callback(), and no other publically visible\n+      functions or variables.\n \n    STANDALONE_DEMANGLER\n       If defined, this file defines a main() function which demangles\n@@ -82,6 +94,10 @@\n       stdout about the mangled string.  This is not generally useful.\n */\n \n+#if defined (_AIX) && !defined (__GNUC__)\n+ #pragma alloca\n+#endif\n+\n #ifdef HAVE_CONFIG_H\n #include \"config.h\"\n #endif\n@@ -95,6 +111,18 @@\n #include <string.h>\n #endif\n \n+#ifdef HAVE_ALLOCA_H\n+# include <alloca.h>\n+#else\n+# ifndef alloca\n+#  ifdef __GNUC__\n+#   define alloca __builtin_alloca\n+#  else\n+extern char *alloca ();\n+#  endif /* __GNUC__ */\n+# endif /* alloca */\n+#endif /* HAVE_ALLOCA_H */\n+\n #include \"ansidecl.h\"\n #include \"libiberty.h\"\n #include \"demangle.h\"\n@@ -135,6 +163,10 @@ static struct demangle_component *d_type (struct d_info *);\n #define cplus_demangle_print d_print\n static char *d_print (int, const struct demangle_component *, int, size_t *);\n \n+#define cplus_demangle_print_callback d_print_callback\n+static int d_print_callback (int, const struct demangle_component *,\n+                             demangle_callbackref, void *);\n+\n #define cplus_demangle_init_info d_init_info\n static void d_init_info (const char *, int, size_t, struct d_info *);\n \n@@ -162,8 +194,8 @@ static void d_init_info (const char *, int, size_t, struct d_info *);\n    V3 demangler code.\n \n    As of this writing this file has the following undefined references\n-   when compiled with -DIN_GLIBCPP_V3: malloc, realloc, free, memcpy,\n-   strcpy, strcat, strlen.  */\n+   when compiled with -DIN_GLIBCPP_V3: realloc, free, memcpy, strcpy,\n+   strcat, strlen.  */\n \n #define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')\n #define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')\n@@ -228,58 +260,46 @@ struct d_print_mod\n   struct d_print_template *templates;\n };\n \n-/* We use this structure to hold information during printing.  */\n+/* We use these structures to hold information during printing.  */\n \n-struct d_print_info\n+struct d_growable_string\n {\n-  /* The options passed to the demangler.  */\n-  int options;\n   /* Buffer holding the result.  */\n   char *buf;\n   /* Current length of data in buffer.  */\n   size_t len;\n   /* Allocated size of buffer.  */\n   size_t alc;\n+  /* Set to 1 if we had a memory allocation failure.  */\n+  int allocation_failure;\n+};\n+\n+enum { D_PRINT_BUFFER_LENGTH = 256 };\n+struct d_print_info\n+{\n+  /* The options passed to the demangler.  */\n+  int options;\n+  /* Fixed-length allocated buffer for demangled data, flushed to the\n+     callback with a NUL termination once full.  */\n+  char buf[D_PRINT_BUFFER_LENGTH];\n+  /* Current length of data in buffer.  */\n+  size_t len;\n+  /* The last character printed, saved individually so that it survives\n+     any buffer flush.  */\n+  char last_char;\n+  /* Callback function to handle demangled buffer flush.  */\n+  demangle_callbackref callback;\n+  /* Opaque callback argument.  */\n+  void *opaque;\n   /* The current list of templates, if any.  */\n   struct d_print_template *templates;\n   /* The current list of modifiers (e.g., pointer, reference, etc.),\n      if any.  */\n   struct d_print_mod *modifiers;\n-  /* Set to 1 if we had a memory allocation failure.  */\n-  int allocation_failure;\n+  /* Set to 1 if we saw a demangling error.  */\n+  int demangle_failure;\n };\n \n-#define d_print_saw_error(dpi) ((dpi)->buf == NULL)\n-\n-#define d_append_char(dpi, c) \\\n-  do \\\n-    { \\\n-      if ((dpi)->buf != NULL && (dpi)->len < (dpi)->alc) \\\n-        (dpi)->buf[(dpi)->len++] = (c); \\\n-      else \\\n-        d_print_append_char ((dpi), (c)); \\\n-    } \\\n-  while (0)\n-\n-#define d_append_buffer(dpi, s, l) \\\n-  do \\\n-    { \\\n-      if ((dpi)->buf != NULL && (dpi)->len + (l) <= (dpi)->alc) \\\n-        { \\\n-          memcpy ((dpi)->buf + (dpi)->len, (s), (l)); \\\n-          (dpi)->len += l; \\\n-        } \\\n-      else \\\n-        d_print_append_buffer ((dpi), (s), (l)); \\\n-    } \\\n-  while (0)\n-\n-#define d_append_string_constant(dpi, s) \\\n-  d_append_buffer (dpi, (s), sizeof (s) - 1)\n-\n-#define d_last_char(dpi) \\\n-  ((dpi)->buf == NULL || (dpi)->len == 0 ? '\\0' : (dpi)->buf[(dpi)->len - 1])\n-\n #ifdef CP_DEMANGLE_DEBUG\n static void d_dump (struct demangle_component *, int);\n #endif\n@@ -389,14 +409,34 @@ d_add_substitution (struct d_info *, struct demangle_component *);\n \n static struct demangle_component *d_substitution (struct d_info *, int);\n \n-static void d_print_resize (struct d_print_info *, size_t);\n+static void d_growable_string_init (struct d_growable_string *, size_t);\n \n-static void d_print_append_char (struct d_print_info *, int);\n+static inline void\n+d_growable_string_resize (struct d_growable_string *, size_t);\n \n+static inline void\n+d_growable_string_append_buffer (struct d_growable_string *,\n+                                 const char *, size_t);\n static void\n-d_print_append_buffer (struct d_print_info *, const char *, size_t);\n+d_growable_string_callback_adapter (const char *, size_t, void *);\n+\n+static void\n+d_print_init (struct d_print_info *, int, demangle_callbackref, void *);\n+\n+static inline void d_print_error (struct d_print_info *);\n+\n+static inline int d_print_saw_error (struct d_print_info *);\n+\n+static inline void d_print_flush (struct d_print_info *);\n+\n+static inline void d_append_char (struct d_print_info *, char);\n \n-static void d_print_error (struct d_print_info *);\n+static inline void d_append_buffer (struct d_print_info *,\n+                                    const char *, size_t);\n+\n+static inline void d_append_string (struct d_print_info *, const char *);\n+\n+static inline char d_last_char (struct d_print_info *);\n \n static void\n d_print_comp (struct d_print_info *, const struct demangle_component *);\n@@ -426,6 +466,8 @@ d_print_expr_op (struct d_print_info *, const struct demangle_component *);\n static void\n d_print_cast (struct d_print_info *, const struct demangle_component *);\n \n+static int d_demangle_callback (const char *, int,\n+                                demangle_callbackref, void *);\n static char *d_demangle (const char *, int, size_t *);\n \n #ifdef CP_DEMANGLE_DEBUG\n@@ -436,7 +478,11 @@ d_dump (struct demangle_component *dc, int indent)\n   int i;\n \n   if (dc == NULL)\n-    return;\n+    {\n+      if (indent == 0)\n+        printf (\"failed demangling\\n\");\n+      return;\n+    }\n \n   for (i = 0; i < indent; ++i)\n     putchar (' ');\n@@ -2567,80 +2613,181 @@ d_substitution (struct d_info *di, int prefix)\n     }\n }\n \n-/* Resize the print buffer.  */\n+/* Initialize a growable string.  */\n \n static void\n-d_print_resize (struct d_print_info *dpi, size_t add)\n+d_growable_string_init (struct d_growable_string *dgs, size_t estimate)\n {\n-  size_t need;\n+  dgs->buf = NULL;\n+  dgs->len = 0;\n+  dgs->alc = 0;\n+  dgs->allocation_failure = 0;\n \n-  if (dpi->buf == NULL)\n+  if (estimate > 0)\n+    d_growable_string_resize (dgs, estimate);\n+}\n+\n+/* Grow a growable string to a given size.  */\n+\n+static inline void\n+d_growable_string_resize (struct d_growable_string *dgs, size_t need)\n+{\n+  size_t newalc;\n+  char *newbuf;\n+\n+  if (dgs->allocation_failure)\n     return;\n-  need = dpi->len + add;\n-  while (need > dpi->alc)\n-    {\n-      size_t newalc;\n-      char *newbuf;\n \n-      newalc = dpi->alc * 2;\n-      newbuf = (char *) realloc (dpi->buf, newalc);\n-      if (newbuf == NULL)\n-\t{\n-\t  free (dpi->buf);\n-\t  dpi->buf = NULL;\n-\t  dpi->allocation_failure = 1;\n-\t  return;\n-\t}\n-      dpi->buf = newbuf;\n-      dpi->alc = newalc;\n+  /* Start allocation at two bytes to avoid any possibility of confusion\n+     with the special value of 1 used as a return in *palc to indicate\n+     allocation failures.  */\n+  newalc = dgs->alc > 0 ? dgs->alc : 2;\n+  while (newalc < need)\n+    newalc <<= 1;\n+\n+  newbuf = (char *) realloc (dgs->buf, newalc);\n+  if (newbuf == NULL)\n+    {\n+      free (dgs->buf);\n+      dgs->buf = NULL;\n+      dgs->len = 0;\n+      dgs->alc = 0;\n+      dgs->allocation_failure = 1;\n+      return;\n     }\n+  dgs->buf = newbuf;\n+  dgs->alc = newalc;\n }\n \n-/* Append a character to the print buffer.  */\n+/* Append a buffer to a growable string.  */\n \n-static void\n-d_print_append_char (struct d_print_info *dpi, int c)\n+static inline void\n+d_growable_string_append_buffer (struct d_growable_string *dgs,\n+                                 const char *s, size_t l)\n {\n-  if (dpi->buf != NULL)\n-    {\n-      if (dpi->len >= dpi->alc)\n-\t{\n-\t  d_print_resize (dpi, 1);\n-\t  if (dpi->buf == NULL)\n-\t    return;\n-\t}\n+  size_t need;\n \n-      dpi->buf[dpi->len] = c;\n-      ++dpi->len;\n-    }\n+  need = dgs->len + l + 1;\n+  if (need > dgs->alc)\n+    d_growable_string_resize (dgs, need);\n+\n+  if (dgs->allocation_failure)\n+    return;\n+\n+  memcpy (dgs->buf + dgs->len, s, l);\n+  dgs->buf[dgs->len + l] = '\\0';\n+  dgs->len += l;\n }\n \n-/* Append a buffer to the print buffer.  */\n+/* Bridge growable strings to the callback mechanism.  */\n \n static void\n-d_print_append_buffer (struct d_print_info *dpi, const char *s, size_t l)\n+d_growable_string_callback_adapter (const char *s, size_t l, void *opaque)\n {\n-  if (dpi->buf != NULL)\n-    {\n-      if (dpi->len + l > dpi->alc)\n-\t{\n-\t  d_print_resize (dpi, l);\n-\t  if (dpi->buf == NULL)\n-\t    return;\n-\t}\n+  struct d_growable_string *dgs = (struct d_growable_string*) opaque;\n \n-      memcpy (dpi->buf + dpi->len, s, l);\n-      dpi->len += l;\n-    }\n+  d_growable_string_append_buffer (dgs, s, l);\n }\n \n-/* Indicate that an error occurred during printing.  */\n+/* Initialize a print information structure.  */\n \n static void\n+d_print_init (struct d_print_info *dpi, int options,\n+              demangle_callbackref callback, void *opaque)\n+{\n+  dpi->options = options;\n+  dpi->len = 0;\n+  dpi->last_char = '\\0';\n+  dpi->templates = NULL;\n+  dpi->modifiers = NULL;\n+\n+  dpi->callback = callback;\n+  dpi->opaque = opaque;\n+\n+  dpi->demangle_failure = 0;\n+}\n+\n+/* Indicate that an error occurred during printing, and test for error.  */\n+\n+static inline void\n d_print_error (struct d_print_info *dpi)\n {\n-  free (dpi->buf);\n-  dpi->buf = NULL;\n+  dpi->demangle_failure = 1;\n+}\n+\n+static inline int\n+d_print_saw_error (struct d_print_info *dpi)\n+{\n+  return dpi->demangle_failure != 0;\n+}\n+\n+/* Flush buffered characters to the callback.  */\n+\n+static inline void\n+d_print_flush (struct d_print_info *dpi)\n+{\n+  dpi->buf[dpi->len] = '\\0';\n+  dpi->callback (dpi->buf, dpi->len, dpi->opaque);\n+  dpi->len = 0;\n+}\n+\n+/* Append characters and buffers for printing.  */\n+\n+static inline void\n+d_append_char (struct d_print_info *dpi, char c)\n+{\n+  if (dpi->len == sizeof (dpi->buf) - 1)\n+    d_print_flush (dpi);\n+\n+  dpi->buf[dpi->len++] = c;\n+  dpi->last_char = c;\n+}\n+\n+static inline void\n+d_append_buffer (struct d_print_info *dpi, const char *s, size_t l)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < l; i++)\n+    d_append_char (dpi, s[i]);\n+}\n+\n+static inline void\n+d_append_string (struct d_print_info *dpi, const char *s)\n+{\n+  d_append_buffer (dpi, s, strlen (s));\n+}\n+\n+static inline char\n+d_last_char (struct d_print_info *dpi)\n+{\n+  return dpi->last_char;\n+}\n+\n+/* Turn components into a human readable string.  OPTIONS is the\n+   options bits passed to the demangler.  DC is the tree to print.\n+   CALLBACK is a function to call to flush demangled string segments\n+   as they fill the intermediate buffer, and OPAQUE is a generalized\n+   callback argument.  On success, this returns 1.  On failure,\n+   it returns 0, indicating a bad parse.  It does not use heap\n+   memory to build an output string, so cannot encounter memory\n+   allocation failure.  */\n+\n+CP_STATIC_IF_GLIBCPP_V3\n+int\n+cplus_demangle_print_callback (int options,\n+                               const struct demangle_component *dc,\n+                               demangle_callbackref callback, void *opaque)\n+{\n+  struct d_print_info dpi;\n+\n+  d_print_init (&dpi, options, callback, opaque);\n+\n+  d_print_comp (&dpi, dc);\n+\n+  d_print_flush (&dpi);\n+\n+  return ! d_print_saw_error (&dpi);\n }\n \n /* Turn components into a human readable string.  OPTIONS is the\n@@ -2656,34 +2803,21 @@ char *\n cplus_demangle_print (int options, const struct demangle_component *dc,\n                       int estimate, size_t *palc)\n {\n-  struct d_print_info dpi;\n+  struct d_growable_string dgs;\n \n-  dpi.options = options;\n+  d_growable_string_init (&dgs, estimate);\n \n-  dpi.alc = estimate + 1;\n-  dpi.buf = (char *) malloc (dpi.alc);\n-  if (dpi.buf == NULL)\n+  if (! cplus_demangle_print_callback (options, dc,\n+                                       d_growable_string_callback_adapter,\n+                                       &dgs))\n     {\n-      *palc = 1;\n+      free (dgs.buf);\n+      *palc = 0;\n       return NULL;\n     }\n \n-  dpi.len = 0;\n-  dpi.templates = NULL;\n-  dpi.modifiers = NULL;\n-\n-  dpi.allocation_failure = 0;\n-\n-  d_print_comp (&dpi, dc);\n-\n-  d_append_char (&dpi, '\\0');\n-\n-  if (dpi.buf != NULL)\n-    *palc = dpi.alc;\n-  else\n-    *palc = dpi.allocation_failure;\n-\n-  return dpi.buf;\n+  *palc = dgs.allocation_failure ? 1 : dgs.alc;\n+  return dgs.buf;\n }\n \n /* Subroutine to handle components.  */\n@@ -2713,7 +2847,7 @@ d_print_comp (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_LOCAL_NAME:\n       d_print_comp (dpi, d_left (dc));\n       if ((dpi->options & DMGL_JAVA) == 0)\n-\td_append_string_constant (dpi, \"::\");\n+\td_append_string (dpi, \"::\");\n       else\n \td_append_char (dpi, '.');\n       d_print_comp (dpi, d_right (dc));\n@@ -2822,6 +2956,7 @@ d_print_comp (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_TEMPLATE:\n       {\n \tstruct d_print_mod *hold_dpm;\n+\tstruct demangle_component *dcl;\n \n \t/* Don't push modifiers into a template definition.  Doing so\n \t   could give the wrong definition for a template argument.\n@@ -2830,16 +2965,32 @@ d_print_comp (struct d_print_info *dpi,\n \thold_dpm = dpi->modifiers;\n \tdpi->modifiers = NULL;\n \n-\td_print_comp (dpi, d_left (dc));\n-\tif (d_last_char (dpi) == '<')\n-\t  d_append_char (dpi, ' ');\n-\td_append_char (dpi, '<');\n-\td_print_comp (dpi, d_right (dc));\n-\t/* Avoid generating two consecutive '>' characters, to avoid\n-\t   the C++ syntactic ambiguity.  */\n-\tif (d_last_char (dpi) == '>')\n-\t  d_append_char (dpi, ' ');\n-\td_append_char (dpi, '>');\n+        dcl = d_left (dc);\n+\n+        if ((dpi->options & DMGL_JAVA) != 0\n+            && dcl->type == DEMANGLE_COMPONENT_NAME\n+            && dcl->u.s_name.len == 6\n+            && strncmp (dcl->u.s_name.s, \"JArray\", 6) == 0)\n+          {\n+            /* Special-case Java arrays, so that JArray<TYPE> appears\n+               instead as TYPE[].  */\n+\n+            d_print_comp (dpi, d_right (dc));\n+            d_append_string (dpi, \"[]\");\n+          }\n+        else\n+          {\n+\t    d_print_comp (dpi, dcl);\n+\t    if (d_last_char (dpi) == '<')\n+\t      d_append_char (dpi, ' ');\n+\t    d_append_char (dpi, '<');\n+\t    d_print_comp (dpi, d_right (dc));\n+\t    /* Avoid generating two consecutive '>' characters, to avoid\n+\t       the C++ syntactic ambiguity.  */\n+\t    if (d_last_char (dpi) == '>')\n+\t      d_append_char (dpi, ' ');\n+\t    d_append_char (dpi, '>');\n+          }\n \n \tdpi->modifiers = hold_dpm;\n \n@@ -2902,69 +3053,69 @@ d_print_comp (struct d_print_info *dpi,\n       return;\n \n     case DEMANGLE_COMPONENT_VTABLE:\n-      d_append_string_constant (dpi, \"vtable for \");\n+      d_append_string (dpi, \"vtable for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_VTT:\n-      d_append_string_constant (dpi, \"VTT for \");\n+      d_append_string (dpi, \"VTT for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n-      d_append_string_constant (dpi, \"construction vtable for \");\n+      d_append_string (dpi, \"construction vtable for \");\n       d_print_comp (dpi, d_left (dc));\n-      d_append_string_constant (dpi, \"-in-\");\n+      d_append_string (dpi, \"-in-\");\n       d_print_comp (dpi, d_right (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_TYPEINFO:\n-      d_append_string_constant (dpi, \"typeinfo for \");\n+      d_append_string (dpi, \"typeinfo for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n-      d_append_string_constant (dpi, \"typeinfo name for \");\n+      d_append_string (dpi, \"typeinfo name for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_TYPEINFO_FN:\n-      d_append_string_constant (dpi, \"typeinfo fn for \");\n+      d_append_string (dpi, \"typeinfo fn for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_THUNK:\n-      d_append_string_constant (dpi, \"non-virtual thunk to \");\n+      d_append_string (dpi, \"non-virtual thunk to \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n-      d_append_string_constant (dpi, \"virtual thunk to \");\n+      d_append_string (dpi, \"virtual thunk to \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n-      d_append_string_constant (dpi, \"covariant return thunk to \");\n+      d_append_string (dpi, \"covariant return thunk to \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_JAVA_CLASS:\n-      d_append_string_constant (dpi, \"java Class for \");\n+      d_append_string (dpi, \"java Class for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_GUARD:\n-      d_append_string_constant (dpi, \"guard variable for \");\n+      d_append_string (dpi, \"guard variable for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_REFTEMP:\n-      d_append_string_constant (dpi, \"reference temporary for \");\n+      d_append_string (dpi, \"reference temporary for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n-      d_append_string_constant (dpi, \"hidden alias for \");\n+      d_append_string (dpi, \"hidden alias for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n@@ -3163,7 +3314,7 @@ d_print_comp (struct d_print_info *dpi,\n \t  {\n \t    d_append_char (dpi, ' ');\n \t    d_print_comp (dpi, d_left (dc));\n-\t    d_append_string_constant (dpi, \"::*\");\n+\t    d_append_string (dpi, \"::*\");\n \t  }\n \n \tdpi->modifiers = dpm.next;\n@@ -3176,7 +3327,7 @@ d_print_comp (struct d_print_info *dpi,\n       d_print_comp (dpi, d_left (dc));\n       if (d_right (dc) != NULL)\n \t{\n-\t  d_append_string_constant (dpi, \", \");\n+\t  d_append_string (dpi, \", \");\n \t  d_print_comp (dpi, d_right (dc));\n \t}\n       return;\n@@ -3185,7 +3336,7 @@ d_print_comp (struct d_print_info *dpi,\n       {\n \tchar c;\n \n-\td_append_string_constant (dpi, \"operator\");\n+\td_append_string (dpi, \"operator\");\n \tc = dc->u.s_operator.op->name[0];\n \tif (IS_LOWER (c))\n \t  d_append_char (dpi, ' ');\n@@ -3195,12 +3346,12 @@ d_print_comp (struct d_print_info *dpi,\n       }\n \n     case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n-      d_append_string_constant (dpi, \"operator \");\n+      d_append_string (dpi, \"operator \");\n       d_print_comp (dpi, dc->u.s_extended_operator.name);\n       return;\n \n     case DEMANGLE_COMPONENT_CAST:\n-      d_append_string_constant (dpi, \"operator \");\n+      d_append_string (dpi, \"operator \");\n       d_print_cast (dpi, dc);\n       return;\n \n@@ -3235,9 +3386,9 @@ d_print_comp (struct d_print_info *dpi,\n \n       d_append_char (dpi, '(');\n       d_print_comp (dpi, d_left (d_right (dc)));\n-      d_append_string_constant (dpi, \") \");\n+      d_append_string (dpi, \") \");\n       d_print_expr_op (dpi, d_left (dc));\n-      d_append_string_constant (dpi, \" (\");\n+      d_append_string (dpi, \" (\");\n       d_print_comp (dpi, d_right (d_right (dc)));\n       d_append_char (dpi, ')');\n \n@@ -3262,11 +3413,11 @@ d_print_comp (struct d_print_info *dpi,\n \t}\n       d_append_char (dpi, '(');\n       d_print_comp (dpi, d_left (d_right (dc)));\n-      d_append_string_constant (dpi, \") \");\n+      d_append_string (dpi, \") \");\n       d_print_expr_op (dpi, d_left (dc));\n-      d_append_string_constant (dpi, \" (\");\n+      d_append_string (dpi, \" (\");\n       d_print_comp (dpi, d_left (d_right (d_right (dc))));\n-      d_append_string_constant (dpi, \") : (\");\n+      d_append_string (dpi, \") : (\");\n       d_print_comp (dpi, d_right (d_right (d_right (dc))));\n       d_append_char (dpi, ')');\n       return;\n@@ -3311,13 +3462,13 @@ d_print_comp (struct d_print_info *dpi,\n \t\t\td_append_char (dpi, 'l');\n \t\t\tbreak;\n \t\t      case D_PRINT_UNSIGNED_LONG:\n-\t\t\td_append_string_constant (dpi, \"ul\");\n+\t\t\td_append_string (dpi, \"ul\");\n \t\t\tbreak;\n \t\t      case D_PRINT_LONG_LONG:\n-\t\t\td_append_string_constant (dpi, \"ll\");\n+\t\t\td_append_string (dpi, \"ll\");\n \t\t\tbreak;\n \t\t      case D_PRINT_UNSIGNED_LONG_LONG:\n-\t\t\td_append_string_constant (dpi, \"ull\");\n+\t\t\td_append_string (dpi, \"ull\");\n \t\t\tbreak;\n \t\t      }\n \t\t    return;\n@@ -3332,10 +3483,10 @@ d_print_comp (struct d_print_info *dpi,\n \t\t    switch (d_right (dc)->u.s_name.s[0])\n \t\t      {\n \t\t      case '0':\n-\t\t\td_append_string_constant (dpi, \"false\");\n+\t\t\td_append_string (dpi, \"false\");\n \t\t\treturn;\n \t\t      case '1':\n-\t\t\td_append_string_constant (dpi, \"true\");\n+\t\t\td_append_string (dpi, \"true\");\n \t\t\treturn;\n \t\t      default:\n \t\t\tbreak;\n@@ -3474,7 +3625,7 @@ d_print_mod_list (struct d_print_info *dpi,\n       dpi->modifiers = hold_modifiers;\n \n       if ((dpi->options & DMGL_JAVA) == 0)\n-\td_append_string_constant (dpi, \"::\");\n+\td_append_string (dpi, \"::\");\n       else\n \td_append_char (dpi, '.');\n \n@@ -3507,15 +3658,15 @@ d_print_mod (struct d_print_info *dpi,\n     {\n     case DEMANGLE_COMPONENT_RESTRICT:\n     case DEMANGLE_COMPONENT_RESTRICT_THIS:\n-      d_append_string_constant (dpi, \" restrict\");\n+      d_append_string (dpi, \" restrict\");\n       return;\n     case DEMANGLE_COMPONENT_VOLATILE:\n     case DEMANGLE_COMPONENT_VOLATILE_THIS:\n-      d_append_string_constant (dpi, \" volatile\");\n+      d_append_string (dpi, \" volatile\");\n       return;\n     case DEMANGLE_COMPONENT_CONST:\n     case DEMANGLE_COMPONENT_CONST_THIS:\n-      d_append_string_constant (dpi, \" const\");\n+      d_append_string (dpi, \" const\");\n       return;\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n       d_append_char (dpi, ' ');\n@@ -3530,16 +3681,16 @@ d_print_mod (struct d_print_info *dpi,\n       d_append_char (dpi, '&');\n       return;\n     case DEMANGLE_COMPONENT_COMPLEX:\n-      d_append_string_constant (dpi, \"complex \");\n+      d_append_string (dpi, \"complex \");\n       return;\n     case DEMANGLE_COMPONENT_IMAGINARY:\n-      d_append_string_constant (dpi, \"imaginary \");\n+      d_append_string (dpi, \"imaginary \");\n       return;\n     case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n       if (d_last_char (dpi) != '(')\n \td_append_char (dpi, ' ');\n       d_print_comp (dpi, d_left (mod));\n-      d_append_string_constant (dpi, \"::*\");\n+      d_append_string (dpi, \"::*\");\n       return;\n     case DEMANGLE_COMPONENT_TYPED_NAME:\n       d_print_comp (dpi, d_left (mod));\n@@ -3672,7 +3823,7 @@ d_print_array_type (struct d_print_info *dpi,\n \t}\n \n       if (need_paren)\n-\td_append_string_constant (dpi, \" (\");\n+\td_append_string (dpi, \" (\");\n \n       d_print_mod_list (dpi, mods, 0);\n \n@@ -3778,26 +3929,19 @@ cplus_demangle_init_info (const char *mangled, int options, size_t len,\n   di->expansion = 0;\n }\n \n-/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled\n-   name, return a buffer allocated with malloc holding the demangled\n-   name.  OPTIONS is the usual libiberty demangler options.  On\n-   success, this sets *PALC to the allocated size of the returned\n-   buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for\n-   a memory allocation failure.  On failure, this returns NULL.  */\n+/* Internal implementation for the demangler.  If MANGLED is a g++ v3 ABI\n+   mangled name, return strings in repeated callback giving the demangled\n+   name.  OPTIONS is the usual libiberty demangler options.  On success,\n+   this returns 1.  On failure, returns 0.  */\n \n-static char *\n-d_demangle (const char* mangled, int options, size_t *palc)\n+static int\n+d_demangle_callback (const char *mangled, int options,\n+                     demangle_callbackref callback, void *opaque)\n {\n-  size_t len;\n   int type;\n   struct d_info di;\n   struct demangle_component *dc;\n-  int estimate;\n-  char *ret;\n-\n-  *palc = 0;\n-\n-  len = strlen (mangled);\n+  int status;\n \n   if (mangled[0] == '_' && mangled[1] == 'Z')\n     type = 0;\n@@ -3806,57 +3950,41 @@ d_demangle (const char* mangled, int options, size_t *palc)\n \t   && (mangled[9] == 'D' || mangled[9] == 'I')\n \t   && mangled[10] == '_')\n     {\n-      char *r;\n+      const char *intro;\n \n-      r = (char *) malloc (40 + len - 11);\n-      if (r == NULL)\n-\t*palc = 1;\n-      else\n-\t{\n-\t  if (mangled[9] == 'I')\n-\t    strcpy (r, \"global constructors keyed to \");\n-\t  else\n-\t    strcpy (r, \"global destructors keyed to \");\n-\t  strcat (r, mangled + 11);\n-\t}\n-      return r;\n+      intro = (mangled[9] == 'I')\n+              ? \"global constructors keyed to \"\n+              : \"global destructors keyed to \";\n+\n+      callback (intro, strlen (intro), opaque);\n+      callback (mangled + 11, strlen (mangled + 11), opaque);\n+      return 1;\n     }\n   else\n     {\n       if ((options & DMGL_TYPES) == 0)\n-\treturn NULL;\n+\treturn 0;\n       type = 1;\n     }\n \n-  cplus_demangle_init_info (mangled, options, len, &di);\n+  cplus_demangle_init_info (mangled, options, strlen (mangled), &di);\n \n   {\n #ifdef CP_DYNAMIC_ARRAYS\n     __extension__ struct demangle_component comps[di.num_comps];\n     __extension__ struct demangle_component *subs[di.num_subs];\n \n-    di.comps = &comps[0];\n-    di.subs = &subs[0];\n+    di.comps = comps;\n+    di.subs = subs;\n #else\n-    di.comps = ((struct demangle_component *)\n-\t\tmalloc (di.num_comps * sizeof (struct demangle_component)));\n-    di.subs = ((struct demangle_component **)\n-\t       malloc (di.num_subs * sizeof (struct demangle_component *)));\n-    if (di.comps == NULL || di.subs == NULL)\n-      {\n-\tif (di.comps != NULL)\n-\t  free (di.comps);\n-\tif (di.subs != NULL)\n-\t  free (di.subs);\n-\t*palc = 1;\n-\treturn NULL;\n-      }\n+    di.comps = alloca (di.num_comps * sizeof (*di.comps));\n+    di.subs = alloca (di.num_subs * sizeof (*di.subs));\n #endif\n \n-    if (! type)\n-      dc = cplus_demangle_mangled_name (&di, 1);\n-    else\n+    if (type)\n       dc = cplus_demangle_type (&di);\n+    else\n+      dc = cplus_demangle_mangled_name (&di, 1);\n \n     /* If DMGL_PARAMS is set, then if we didn't consume the entire\n        mangled string, then we didn't successfully demangle it.  If\n@@ -3866,46 +3994,43 @@ d_demangle (const char* mangled, int options, size_t *palc)\n       dc = NULL;\n \n #ifdef CP_DEMANGLE_DEBUG\n-    if (dc == NULL)\n-      printf (\"failed demangling\\n\");\n-    else\n-      d_dump (dc, 0);\n+    d_dump (dc, 0);\n #endif\n \n-    /* We try to guess the length of the demangled string, to minimize\n-       calls to realloc during demangling.  */\n-    estimate = len + di.expansion + 10 * di.did_subs;\n-    estimate += estimate / 8;\n+    status = (dc != NULL)\n+             ? cplus_demangle_print_callback (options, dc, callback, opaque)\n+             : 0;\n+  }\n \n-    ret = NULL;\n-    if (dc != NULL)\n-      ret = cplus_demangle_print (options, dc, estimate, palc);\n+  return status;\n+}\n \n-#ifndef CP_DYNAMIC_ARRAYS\n-    free (di.comps);\n-    free (di.subs);\n-#endif\n+/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled\n+   name, return a buffer allocated with malloc holding the demangled\n+   name.  OPTIONS is the usual libiberty demangler options.  On\n+   success, this sets *PALC to the allocated size of the returned\n+   buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for\n+   a memory allocation failure, and returns NULL.  */\n \n-#ifdef CP_DEMANGLE_DEBUG\n-    if (ret != NULL)\n-      {\n-\tint rlen;\n-\n-\trlen = strlen (ret);\n-\tif (rlen > 2 * estimate)\n-\t  printf (\"*** Length %d much greater than estimate %d\\n\",\n-\t\t  rlen, estimate);\n-\telse if (rlen > estimate)\n-\t  printf (\"*** Length %d greater than estimate %d\\n\",\n-\t\t  rlen, estimate);\n-\telse if (rlen < estimate / 2)\n-\t  printf (\"*** Length %d much less than estimate %d\\n\",\n-\t\t  rlen, estimate);\n-      }\n-#endif\n-  }\n+static char *\n+d_demangle (const char *mangled, int options, size_t *palc)\n+{\n+  struct d_growable_string dgs;\n+  int status;\n \n-  return ret;\n+  d_growable_string_init (&dgs, 0);\n+\n+  status = d_demangle_callback (mangled, options,\n+                                d_growable_string_callback_adapter, &dgs);\n+  if (status == 0)\n+    {\n+      free (dgs.buf);\n+      *palc = 0;\n+      return NULL;\n+    }\n+\n+  *palc = dgs.allocation_failure ? 1 : 0;\n+  return dgs.buf;\n }\n \n #if defined(IN_LIBGCC2) || defined(IN_GLIBCPP_V3)\n@@ -3922,7 +4047,7 @@ extern char *__cxa_demangle (const char *, char *, size_t *, int *);\n    OUTPUT_BUFFER may instead be NULL; in that case, the demangled name\n    is placed in a region of memory allocated with malloc.\n \n-   If LENGTH is non-NULL, the length of the buffer conaining the\n+   If LENGTH is non-NULL, the length of the buffer containing the\n    demangled name, is placed in *LENGTH.\n \n    The return value is a pointer to the start of the NUL-terminated\n@@ -3999,68 +4124,90 @@ __cxa_demangle (const char *mangled_name, char *output_buffer,\n   return demangled;\n }\n \n+extern int __gcclibcxx_demangle_callback (const char *,\n+                                          void (*)\n+                                            (const char *, size_t, void *),\n+                                          void *);\n+\n+/* Alternative, allocationless entry point in the C++ runtime library\n+   for performing demangling.  MANGLED_NAME is a NUL-terminated character\n+   string containing the name to be demangled.\n+\n+   CALLBACK is a callback function, called with demangled string\n+   segments as demangling progresses; it is called at least once,\n+   but may be called more than once.  OPAQUE is a generalized pointer\n+   used as a callback argument.\n+\n+   The return code is one of the following values, equivalent to\n+   the STATUS values of __cxa_demangle() (excluding -1, since this\n+   function performs no memory allocations):\n+      0: The demangling operation succeeded.\n+     -2: MANGLED_NAME is not a valid name under the C++ ABI mangling rules.\n+     -3: One of the arguments is invalid.\n+\n+   The demangling is performed using the C++ ABI mangling rules, with\n+   GNU extensions.  */\n+\n+int\n+__gcclibcxx_demangle_callback (const char *mangled_name,\n+                               void (*callback) (const char *, size_t, void *),\n+                               void *opaque)\n+{\n+  int status;\n+\n+  if (mangled_name == NULL || callback == NULL)\n+    return -3;\n+\n+  status = d_demangle_callback (mangled_name, DMGL_PARAMS | DMGL_TYPES,\n+                                callback, opaque);\n+  if (status == 0)\n+    return -2;\n+\n+  return 0;\n+}\n+\n #else /* ! (IN_LIBGCC2 || IN_GLIBCPP_V3) */\n \n /* Entry point for libiberty demangler.  If MANGLED is a g++ v3 ABI\n    mangled name, return a buffer allocated with malloc holding the\n    demangled name.  Otherwise, return NULL.  */\n \n char *\n-cplus_demangle_v3 (const char* mangled, int options)\n+cplus_demangle_v3 (const char *mangled, int options)\n {\n   size_t alc;\n \n   return d_demangle (mangled, options, &alc);\n }\n \n+int\n+cplus_demangle_v3_callback (const char *mangled, int options,\n+                            demangle_callbackref callback, void *opaque)\n+{\n+  return d_demangle_callback (mangled, options, callback, opaque);\n+}\n+\n /* Demangle a Java symbol.  Java uses a subset of the V3 ABI C++ mangling \n    conventions, but the output formatting is a little different.\n-   This instructs the C++ demangler not to emit pointer characters (\"*\"), and \n-   to use Java's namespace separator symbol (\".\" instead of \"::\").  It then \n-   does an additional pass over the demangled output to replace instances \n-   of JArray<TYPE> with TYPE[].  */\n+   This instructs the C++ demangler not to emit pointer characters (\"*\"), to\n+   use Java's namespace separator symbol (\".\" instead of \"::\"), and to output\n+   JArray<TYPE> as TYPE[].  */\n \n char *\n-java_demangle_v3 (const char* mangled)\n+java_demangle_v3 (const char *mangled)\n {\n   size_t alc;\n-  char *demangled;\n-  int nesting;\n-  char *from;\n-  char *to;\n-\n-  demangled = d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS | DMGL_RET_POSTFIX, \n-\t\t\t  &alc);\n-\n-  if (demangled == NULL)\n-    return NULL;\n-\n-  nesting = 0;\n-  from = demangled;\n-  to = from;\n-  while (*from != '\\0')\n-    {\n-      if (strncmp (from, \"JArray<\", 7) == 0)\n-\t{\n-\t  from += 7;\n-\t  ++nesting;\n-\t}\n-      else if (nesting > 0 && *from == '>')\n-\t{\n-\t  while (to > demangled && to[-1] == ' ')\n-\t    --to;\n-\t  *to++ = '[';\n-\t  *to++ = ']';\n-\t  --nesting;\n-\t  ++from;\n-\t}\n-      else\n-\t*to++ = *from++;\n-    }\n \n-  *to = '\\0';\n+  return d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS | DMGL_RET_POSTFIX, &alc);\n+}\n \n-  return demangled;\n+int\n+java_demangle_v3_callback (const char *mangled,\n+                           demangle_callbackref callback, void *opaque)\n+{\n+  return d_demangle_callback (mangled,\n+                              DMGL_JAVA | DMGL_PARAMS | DMGL_RET_POSTFIX,\n+                              callback, opaque);\n }\n \n #endif /* IN_LIBGCC2 || IN_GLIBCPP_V3 */\n@@ -4090,21 +4237,11 @@ is_ctor_or_dtor (const char *mangled,\n     __extension__ struct demangle_component comps[di.num_comps];\n     __extension__ struct demangle_component *subs[di.num_subs];\n \n-    di.comps = &comps[0];\n-    di.subs = &subs[0];\n+    di.comps = comps;\n+    di.subs = subs;\n #else\n-    di.comps = ((struct demangle_component *)\n-\t\tmalloc (di.num_comps * sizeof (struct demangle_component)));\n-    di.subs = ((struct demangle_component **)\n-\t       malloc (di.num_subs * sizeof (struct demangle_component *)));\n-    if (di.comps == NULL || di.subs == NULL)\n-      {\n-\tif (di.comps != NULL)\n-\t  free (di.comps);\n-\tif (di.subs != NULL)\n-\t  free (di.subs);\n-\treturn 0;\n-      }\n+    di.comps = alloca (di.num_comps * sizeof (*di.comps));\n+    di.subs = alloca (di.num_subs * sizeof (*di.subs));\n #endif\n \n     dc = cplus_demangle_mangled_name (&di, 1);\n@@ -4143,11 +4280,6 @@ is_ctor_or_dtor (const char *mangled,\n \t    break;\n \t  }\n       }\n-\n-#ifndef CP_DYNAMIC_ARRAYS\n-    free (di.subs);\n-    free (di.comps);\n-#endif\n   }\n \n   return ret;"}, {"sha": "8622f29ca89ea8c1a2a0d5a13a4751c016be4002", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cc5cf65e65182129422f96925534dc8a20777/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cc5cf65e65182129422f96925534dc8a20777/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=456cc5cf65e65182129422f96925534dc8a20777", "patch": "@@ -1,5 +1,5 @@\n /* Internal demangler interface for g++ V3 ABI.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Written by Ian Lance Taylor <ian@wasabisystems.com>.\n \n    This file is part of the libiberty library, which is part of GCC.\n@@ -143,8 +143,9 @@ struct d_info\n #define CP_STATIC_IF_GLIBCPP_V3 extern\n #endif\n \n-CP_STATIC_IF_GLIBCPP_V3\n-const struct demangle_operator_info cplus_demangle_operators[];\n+#ifndef IN_GLIBCPP_V3\n+extern const struct demangle_operator_info cplus_demangle_operators[];\n+#endif\n \n #define D_BUILTIN_TYPE_COUNT (26)\n "}]}