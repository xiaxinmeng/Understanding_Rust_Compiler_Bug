{"sha": "b0cc341fd953d45f6418b2cbc646706eb3ad3bc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjYzM0MWZkOTUzZDQ1ZjY0MThiMmNiYzY0NjcwNmViM2FkM2JjNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-20T11:08:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-20T11:08:30Z"}, "message": "gimple.c (gimple_types_compatible_p): Simplify.\n\n2009-10-20  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gimple_types_compatible_p): Simplify.  Move\n\tcheap checks before hashtable queries.  Add checks for\n\tTYPE_NONALIASED_COMPONENT and DECL_NONADDRESSABLE_P.\n\nFrom-SVN: r153010", "tree": {"sha": "15e07df0ee5584959d0495ab360916b560328424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e07df0ee5584959d0495ab360916b560328424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1aa17011f52bffc0f3022bc32d87222270dfb8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1aa17011f52bffc0f3022bc32d87222270dfb8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1aa17011f52bffc0f3022bc32d87222270dfb8b"}], "stats": {"total": 179, "additions": 90, "deletions": 89}, "files": [{"sha": "a631aaa738d13bab456ba155055573ebfe5e27aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0cc341fd953d45f6418b2cbc646706eb3ad3bc5", "patch": "@@ -1,3 +1,9 @@\n+2009-10-20  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_types_compatible_p): Simplify.  Move\n+\tcheap checks before hashtable queries.  Add checks for\n+\tTYPE_NONALIASED_COMPONENT and DECL_NONADDRESSABLE_P.\n+\n 2009-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-sra.c (build_ref_for_offset_1) <RECORD_TYPE>: Skip fields"}, {"sha": "d5b1cf7f1c7739fda8a402371f680d27e22554e2", "filename": "gcc/gimple.c", "status": "modified", "additions": 84, "deletions": 89, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc341fd953d45f6418b2cbc646706eb3ad3bc5/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b0cc341fd953d45f6418b2cbc646706eb3ad3bc5", "patch": "@@ -3174,23 +3174,57 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n-    goto same_types;\n+    return 1;\n \n   /* Check that we have two types to compare.  */\n   if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    goto different_types;\n+    return 0;\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n-    goto different_types;\n+    return 0;\n+\n+  /* Can't be the same type if they have different CV qualifiers.  */\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n+    return 0;\n \n   /* Void types are always the same.  */\n   if (TREE_CODE (t1) == VOID_TYPE)\n-    goto same_types;\n+    return 1;\n \n-  /* Can't be the same type if they have different CV qualifiers.  */\n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    goto different_types;\n+  /* For numerical types do some simple checks before doing three\n+     hashtable queries.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE)\n+    {\n+      /* Can't be the same type if they have different alignment,\n+\t sign, precision or mode.  */\n+      if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn 0;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n+\t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n+\treturn 0;\n+\n+      /* That's all we need to check for float and fixed-point types.  */\n+      if (SCALAR_FLOAT_TYPE_P (t1)\n+\t  || FIXED_POINT_TYPE_P (t1))\n+\treturn 1;\n+\n+      /* Perform cheap tail-recursion for vector and complex types.  */\n+      if (TREE_CODE (t1) == VECTOR_TYPE\n+\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n+\treturn gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+\n+      /* For integral types fall thru to more complex checks.  */\n+    }\n \n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n@@ -3223,79 +3257,15 @@ gimple_types_compatible_p (tree t1, tree t2)\n   if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n     goto different_types;\n \n-  /* For numerical types, the bounds must coincide.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different size, alignment,\n-\t sign, precision or mode.  Note that from now on, comparisons\n-\t between *_CST nodes must be done using tree_int_cst_equal because\n-\t we cannot assume that constants from T1 and T2 will be shared\n-\t since T1 and T2 are distinct pointers.  */\n-      if (!tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n-\t  || !tree_int_cst_equal (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2))\n-\t  || TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-\t  || TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_MODE (t1) != TYPE_MODE (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\tgoto different_types;\n-\n-      /* For non-enumeral types, check type bounds.  FIXME lto, we\n-\t cannot check bounds on enumeral types because different front\n-\t ends will produce different values.  In C, enumeral types are\n-\t integers, while in C++ each element will have its own\n-\t symbolic value.  We should decide how enums are to be\n-\t represented in GIMPLE and have each front end lower to that.  */\n-      if (TREE_CODE (t1) != ENUMERAL_TYPE)\n-\t{\n-\t  tree min1 = TYPE_MIN_VALUE (t1);\n-\t  tree max1 = TYPE_MAX_VALUE (t1);\n-\t  tree min2 = TYPE_MIN_VALUE (t2);\n-\t  tree max2 = TYPE_MAX_VALUE (t2);\n-\t  bool min_equal_p = false;\n-\t  bool max_equal_p = false;\n-\n-\t  /* If either type has a minimum value, the other type must\n-\t     have the same.  */\n-\t  if (min1 == NULL_TREE && min2 == NULL_TREE)\n-\t    min_equal_p = true;\n-\t  else if (min1 && min2 && operand_equal_p (min1, min2, 0))\n-\t    min_equal_p = true;\n-\n-\t  /* Likewise, if either type has a maximum value, the other\n-\t     type must have the same.  */\n-\t  if (max1 == NULL_TREE && max2 == NULL_TREE)\n-\t    max_equal_p = true;\n-\t  else if (max1 && max2 && operand_equal_p (max1, max2, 0))\n-\t    max_equal_p = true;\n-\n-\t  if (!min_equal_p || !max_equal_p)\n-\t    goto different_types;\n-\t}\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE)\n-\t{\n-\t  if (TYPE_IS_SIZETYPE (t1) == TYPE_IS_SIZETYPE (t2)\n-\t      && TYPE_STRING_FLAG (t1) == TYPE_STRING_FLAG (t2))\n-\t    goto same_types;\n-\t  else\n-\t    goto different_types;\n-\t}\n-      else if (TREE_CODE (t1) == BOOLEAN_TYPE)\n-\tgoto same_types;\n-      else if (TREE_CODE (t1) == REAL_TYPE)\n-\tgoto same_types;\n-    }\n-\n   /* Do type-specific comparisons.  */\n   switch (TREE_CODE (t1))\n     {\n     case ARRAY_TYPE:\n       /* Array types are the same if the element types are the same and\n \t the number of elements are the same.  */\n       if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n+\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n+\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n \tgoto different_types;\n       else\n \t{\n@@ -3406,11 +3376,47 @@ gimple_types_compatible_p (tree t1, tree t2)\n \tgoto different_types;\n       }\n \n+    case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n+      {\n+\ttree min1 = TYPE_MIN_VALUE (t1);\n+\ttree max1 = TYPE_MAX_VALUE (t1);\n+\ttree min2 = TYPE_MIN_VALUE (t2);\n+\ttree max2 = TYPE_MAX_VALUE (t2);\n+\tbool min_equal_p = false;\n+\tbool max_equal_p = false;\n+\n+\t/* If either type has a minimum value, the other type must\n+\t   have the same.  */\n+\tif (min1 == NULL_TREE && min2 == NULL_TREE)\n+\t  min_equal_p = true;\n+\telse if (min1 && min2 && operand_equal_p (min1, min2, 0))\n+\t  min_equal_p = true;\n+\n+\t/* Likewise, if either type has a maximum value, the other\n+\t   type must have the same.  */\n+\tif (max1 == NULL_TREE && max2 == NULL_TREE)\n+\t  max_equal_p = true;\n+\telse if (max1 && max2 && operand_equal_p (max1, max2, 0))\n+\t  max_equal_p = true;\n+\n+\tif (!min_equal_p || !max_equal_p)\n+\t  goto different_types;\n+\n+\tgoto same_types;\n+      }\n+\n     case ENUMERAL_TYPE:\n       {\n-\t/* For enumeral types, all the values must be the same.  */\n+\t/* FIXME lto, we cannot check bounds on enumeral types because\n+\t   different front ends will produce different values.\n+\t   In C, enumeral types are integers, while in C++ each element\n+\t   will have its own symbolic value.  We should decide how enums\n+\t   are to be represented in GIMPLE and have each front end lower\n+\t   to that.  */\n \ttree v1, v2;\n \n+\t/* For enumeral types, all the values must be the same.  */\n \tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n \t  goto same_types;\n \n@@ -3463,6 +3469,7 @@ gimple_types_compatible_p (tree t1, tree t2)\n \t  {\n \t    /* The fields must have the same name, offset and type.  */\n \t    if (DECL_NAME (f1) != DECL_NAME (f2)\n+\t\t|| DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n \t\t|| !compare_field_offset (f1, f2)\n \t\t|| !gimple_types_compatible_p (TREE_TYPE (f1),\n \t\t\t\t\t       TREE_TYPE (f2)))\n@@ -3477,30 +3484,18 @@ gimple_types_compatible_p (tree t1, tree t2)\n \tgoto same_types;\n       }\n \n-    case VECTOR_TYPE:\n-      if (TYPE_VECTOR_SUBPARTS (t1) != TYPE_VECTOR_SUBPARTS (t2))\n-\tgoto different_types;\n-\n-      /* Fallthru  */\n-    case COMPLEX_TYPE:\n-      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\tgoto different_types;\n-      goto same_types;\n-\n     default:\n-      goto different_types;\n+      gcc_unreachable ();\n     }\n \n   /* Common exit path for types that are not compatible.  */\n different_types:\n-  if (p)\n-    p->same_p = 0;\n+  p->same_p = 0;\n   return 0;\n \n   /* Common exit path for types that are compatible.  */\n same_types:\n-  if (p)\n-    p->same_p = 1;\n+  p->same_p = 1;\n   return 1;\n }\n "}]}