{"sha": "09fe1c496d81c3732f3bb99664e770255ffc0cc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlmZTFjNDk2ZDgxYzM3MzJmM2JiOTk2NjRlNzcwMjU1ZmZjMGNjNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-12-19T04:35:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-12-19T04:35:31Z"}, "message": "alpha.c (alpha_emit_conditional_move): If TARGET_FIX, handle cmove with mismatched test and data modes.\n\n        * alpha.c (alpha_emit_conditional_move): If TARGET_FIX, handle\n        cmove with mismatched test and data modes.\n\nFrom-SVN: r31021", "tree": {"sha": "274b64d942ed15f9fd76faee4d05b2fd3b4f584e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/274b64d942ed15f9fd76faee4d05b2fd3b4f584e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09fe1c496d81c3732f3bb99664e770255ffc0cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09fe1c496d81c3732f3bb99664e770255ffc0cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09fe1c496d81c3732f3bb99664e770255ffc0cc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09fe1c496d81c3732f3bb99664e770255ffc0cc7/comments", "author": null, "committer": null, "parents": [{"sha": "b00c3006c87cb01e2f7575ca8de478a130e4eb94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00c3006c87cb01e2f7575ca8de478a130e4eb94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00c3006c87cb01e2f7575ca8de478a130e4eb94"}], "stats": {"total": 56, "additions": 53, "deletions": 3}, "files": [{"sha": "fc6058ad16399a0da4a77d0f8a45e124bb5ac15f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09fe1c496d81c3732f3bb99664e770255ffc0cc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09fe1c496d81c3732f3bb99664e770255ffc0cc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09fe1c496d81c3732f3bb99664e770255ffc0cc7", "patch": "@@ -1,3 +1,8 @@\n+Sat Dec 18 20:34:00 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_emit_conditional_move): If TARGET_FIX, handle\n+\tcmove with mismatched test and data modes.\n+\n Sat Dec 18 20:30:15 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* c-typeck.c (c_expand_start_case): Don't warn for long switch"}, {"sha": "9dc2f733fbc2a454b66435ef5a3414be172021c1", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09fe1c496d81c3732f3bb99664e770255ffc0cc7/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09fe1c496d81c3732f3bb99664e770255ffc0cc7/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=09fe1c496d81c3732f3bb99664e770255ffc0cc7", "patch": "@@ -1580,18 +1580,63 @@ alpha_emit_conditional_move (cmp, mode)\n     = (GET_MODE (op0) == VOIDmode ? DImode : GET_MODE (op0));\n   enum machine_mode cmp_op_mode = fp_p ? DFmode : DImode;\n   enum machine_mode cmov_mode = VOIDmode;\n+  int local_fast_math = flag_fast_math;\n   rtx tem;\n \n   /* Zero the operands.  */\n   memset (&alpha_compare, 0, sizeof (alpha_compare));\n \n   if (fp_p != FLOAT_MODE_P (mode))\n-    return 0;\n+    {\n+      enum rtx_code cmp_code;\n+\n+      if (! TARGET_FIX)\n+\treturn 0;\n+\n+      /* If we have fp<->int register move instructions, do a cmov by\n+\t performing the comparison in fp registers, and move the\n+\t zero/non-zero value to integer registers, where we can then\n+\t use a normal cmov, or vice-versa.  */\n+\n+      switch (code)\n+\t{\n+\tcase EQ: case LE: case LT: case LEU: case LTU:\n+\t  /* We have these compares.  */\n+\t  cmp_code = code, code = NE;\n+\t  break;\n+\n+\tcase NE:\n+\t  /* This must be reversed.  */\n+\t  cmp_code = EQ, code = EQ;\n+\t  break;\n+\n+\tcase GE: case GT: case GEU: case GTU:\n+\t  /* These must be swapped.  */\n+\t  cmp_code = swap_condition (code);\n+\t  code = NE;\n+\t  tem = op0, op0 = op1, op1 = tem;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      tem = gen_reg_rtx (cmp_op_mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, tem,\n+\t\t\t      gen_rtx_fmt_ee (cmp_code, cmp_op_mode,\n+\t\t\t\t\t      op0, op1)));\n+\n+      cmp_mode = cmp_op_mode = fp_p ? DImode : DFmode;\n+      op0 = gen_lowpart (cmp_op_mode, tem);\n+      op1 = CONST0_RTX (cmp_op_mode);\n+      fp_p = !fp_p;\n+      local_fast_math = 1;\n+    }\n \n   /* We may be able to use a conditional move directly.\n      This avoids emitting spurious compares. */\n   if (signed_comparison_operator (cmp, cmp_op_mode)\n-      && (!fp_p || flag_fast_math)\n+      && (!fp_p || local_fast_math)\n       && (op0 == CONST0_RTX (cmp_mode) || op1 == CONST0_RTX (cmp_mode)))\n     return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n \n@@ -1627,7 +1672,7 @@ alpha_emit_conditional_move (cmp, mode)\n   /* ??? We mark the branch mode to be CCmode to prevent the compare\n      and cmov from being combined, since the compare insn follows IEEE\n      rules that the cmov does not.  */\n-  if (fp_p && !flag_fast_math)\n+  if (fp_p && !local_fast_math)\n     cmov_mode = CCmode;\n \n   tem = gen_reg_rtx (cmp_op_mode);"}]}