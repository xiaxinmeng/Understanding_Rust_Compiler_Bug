{"sha": "0dd3962da5d80217c1cb377ce3d89e197731a33c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRkMzk2MmRhNWQ4MDIxN2MxY2IzNzdjZTNkODllMTk3NzMxYTMzYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-06T17:41:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-06T17:41:36Z"}, "message": "cp-tree.h (struct lang_type): Add anon_union field.\n\n\t* cp-tree.h (struct lang_type): Add anon_union field.\n\t(ANON_UNION_TYPE_P): Use it instead of examining type.\n\t(SET_ANON_UNION_TYPE_P): New macro.\n\t* decl.c (check_tag_decl): Use it.\n\t* search.c (compute_access): Handle non-type contexts earlier, and\n\thandle NULL_TREE.\n\t* tree.c (build_exception_variant): Use copy_to_permanent.\n\nFrom-SVN: r25618", "tree": {"sha": "bb5f97adf94cf69be51009038a3222072a5d44a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb5f97adf94cf69be51009038a3222072a5d44a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dd3962da5d80217c1cb377ce3d89e197731a33c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd3962da5d80217c1cb377ce3d89e197731a33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dd3962da5d80217c1cb377ce3d89e197731a33c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd3962da5d80217c1cb377ce3d89e197731a33c/comments", "author": null, "committer": null, "parents": [{"sha": "4b523fc4951bf74a441c9a4c08bd4ab1428b3e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b523fc4951bf74a441c9a4c08bd4ab1428b3e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b523fc4951bf74a441c9a4c08bd4ab1428b3e3c"}], "stats": {"total": 61, "additions": 41, "deletions": 20}, "files": [{"sha": "602fa44b875c3a1faee20648e2f279bd8fcc7d80", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0dd3962da5d80217c1cb377ce3d89e197731a33c", "patch": "@@ -1,5 +1,15 @@\n 1999-03-06  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* cp-tree.h (struct lang_type): Add anon_union field.\n+\t(ANON_UNION_TYPE_P): Use it instead of examining type.\n+\t(SET_ANON_UNION_TYPE_P): New macro.\n+\t* decl.c (check_tag_decl): Use it.\n+\n+\t* search.c (compute_access): Handle non-type contexts earlier, and\n+\thandle NULL_TREE.\n+\n+\t* tree.c (build_exception_variant): Use copy_to_permanent.\n+\n \t* decl2.c (setup_initp): Give statics with no priority the default\n \tpriority here.\n \t(do_dtors, do_ctors, finish_file): Remove special handling of"}, {"sha": "fdc981f91e93ef0cb91c5dc673f01dc156566fc8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0dd3962da5d80217c1cb377ce3d89e197731a33c", "patch": "@@ -725,11 +725,12 @@ struct lang_type\n       unsigned non_aggregate : 1;\n       unsigned is_partial_instantiation : 1;\n       unsigned has_mutable : 1;\n+      unsigned anon_union : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 10;\n+      unsigned dummy : 9;\n     } type_flags;\n \n   int n_ancestors;\n@@ -1708,13 +1709,14 @@ extern int flag_new_for_scope;\n \n #define ANON_UNION_P(NODE) (DECL_NAME (NODE) == 0)\n \n-/* Nonzero if TYPE is an anonymous union type.  We're careful\n-   accessing TYPE_IDENTIFIER because some built-in types, like\n-   pointer-to-member types, do not have TYPE_NAME.  */\n-#define ANON_UNION_TYPE_P(TYPE) \\\n-  (TREE_CODE (TYPE) == UNION_TYPE \\\n-   && TYPE_NAME (TYPE) \\\n-   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TYPE)))\n+/* Nonzero if TYPE is an anonymous union type.  We have to use a flag for\n+   this because \"A union for which objects or pointers are declared is not\n+   an anonymous union\" [class.union].  */\n+#define ANON_UNION_TYPE_P(NODE)\t\t\t\t\\\n+  (TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\\\n+   && TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_union)\n+#define SET_ANON_UNION_TYPE_P(NODE)\t\t\t\t\\\n+  (TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_union = 1)\n \n #define UNKNOWN_TYPE LANG_TYPE\n "}, {"sha": "a386735b082b0c9bc090497fb731c6da91ed7eec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0dd3962da5d80217c1cb377ce3d89e197731a33c", "patch": "@@ -6740,8 +6740,18 @@ check_tag_decl (declspecs)\n      Until we have a good way of detecting the latter, don't warn.  */\n   if (t == NULL_TREE && ! current_class_type)\n     pedwarn (\"declaration does not declare anything\");\n-  else if (t && ANON_UNION_TYPE_P (t))\n-    /* Anonymous unions are objects, so they can have specifiers.  */;\n+\n+  /* Check for an anonymous union.  We're careful\n+     accessing TYPE_IDENTIFIER because some built-in types, like\n+     pointer-to-member types, do not have TYPE_NAME.  */\n+  else if (t && TREE_CODE (t) == UNION_TYPE\n+\t   && TYPE_NAME (t)\n+\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+    {\n+      /* Anonymous unions are objects, so they can have specifiers.  */;\n+      SET_ANON_UNION_TYPE_P (t);\n+    }\n+\n   else if (ob_modifier)\n     {\n       if (ob_modifier == ridpointers[(int) RID_INLINE]"}, {"sha": "369a06f84b513d1dcbd6439f6b7641b289269984", "filename": "gcc/cp/search.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=0dd3962da5d80217c1cb377ce3d89e197731a33c", "patch": "@@ -1,6 +1,6 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n-   Copyright (C) 1987, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -667,6 +667,11 @@ compute_access (basetype_path, field)\n       && TREE_CODE (field) == FIELD_DECL)\n     context = TYPE_CONTEXT (context);\n \n+  /* If we aren't a real class member (e.g. we're from a namespace-scope\n+     anonymous union), there's no access control.  */\n+  if (context == NULL_TREE || ! TYPE_P (context))\n+    PUBLIC_RETURN;\n+\n   /* Virtual function tables are never private.  But we should know that\n      we are looking for this, and not even try to hide it.  */\n   if (DECL_NAME (field) && VFIELD_NAME_P (DECL_NAME (field)) == 1)\n@@ -677,7 +682,7 @@ compute_access (basetype_path, field)\n     {\n       /* Are we (or an enclosing scope) friends with the class that has\n          FIELD? */\n-      if (TYPE_P (context) && is_friend (context, previous_scope))\n+      if (is_friend (context, previous_scope))\n \tPUBLIC_RETURN;\n \n       /* If it's private, it's private, you letch.  */\n@@ -693,7 +698,6 @@ compute_access (basetype_path, field)\n \t{\n \t  if (current_class_type\n \t      && (static_mem || DECL_CONSTRUCTOR_P (field))\n-\t      && TYPE_P (context)\n \t      && ACCESSIBLY_DERIVED_FROM_P (context, current_class_type))\n \t    PUBLIC_RETURN;\n \t  else\n@@ -755,7 +759,7 @@ compute_access (basetype_path, field)\n \n   if (access == access_default_node)\n     {\n-      if (TYPE_P (context) && is_friend (context, previous_scope))\n+      if (is_friend (context, previous_scope))\n \taccess = access_public_node;\n       else if (TREE_PRIVATE (field))\n \taccess = access_private_node;"}, {"sha": "b93d9bd6fd0207fa9a718a4b182fd665efb327cf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd3962da5d80217c1cb377ce3d89e197731a33c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0dd3962da5d80217c1cb377ce3d89e197731a33c", "patch": "@@ -1517,12 +1517,7 @@ build_exception_variant (type, raises)\n   v = build_type_copy (type);\n \n   if (raises && ! TREE_PERMANENT (raises))\n-    {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      raises = copy_list (raises);\n-      pop_obstacks ();\n-    }\n+    raises = copy_to_permanent (raises);\n \n   TYPE_RAISES_EXCEPTIONS (v) = raises;\n   return v;"}]}