{"sha": "8c9b38d73852158959ca7c3a1d53948d76df7434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM5YjM4ZDczODUyMTU4OTU5Y2E3YzNhMWQ1Mzk0OGQ3NmRmNzQzNA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-05-04T05:34:13Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-05-04T05:34:13Z"}, "message": "builtins.c (expand_builtin_constant_p, [...]): Update prototypes.\n\n\t* builtins.c (expand_builtin_constant_p, expand_builtin_strlen,\n\texpand_builtin_frame_address): Update prototypes.\n\t(expand_builtin_constant_p, expand_builtin_strlen,\n\texpand_builtin_strcpy, expand_builtin_memset,\n\texpand_builtin_bzero, expand_builtin_args_info,\n\texpand_builtin_frame_address): Pass in just the argument(s)\n\tneeded, not the entire expression `exp'.\n\t(expand_builtin): Update all calls to these functions.\n\nFrom-SVN: r66448", "tree": {"sha": "64298069607c40d24b1ee53915fad1ddd0905fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64298069607c40d24b1ee53915fad1ddd0905fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c9b38d73852158959ca7c3a1d53948d76df7434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c9b38d73852158959ca7c3a1d53948d76df7434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c9b38d73852158959ca7c3a1d53948d76df7434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c9b38d73852158959ca7c3a1d53948d76df7434/comments", "author": null, "committer": null, "parents": [{"sha": "9c80ff25b7e9542a7166ac213eddfa42be5183bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c80ff25b7e9542a7166ac213eddfa42be5183bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c80ff25b7e9542a7166ac213eddfa42be5183bc"}], "stats": {"total": 93, "additions": 43, "deletions": 50}, "files": [{"sha": "9fa33cdec1ee095d372c7f10412b5a7a1839e6a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c9b38d73852158959ca7c3a1d53948d76df7434/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c9b38d73852158959ca7c3a1d53948d76df7434/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c9b38d73852158959ca7c3a1d53948d76df7434", "patch": "@@ -1,3 +1,14 @@\n+2003-05-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (expand_builtin_constant_p, expand_builtin_strlen,\n+\texpand_builtin_frame_address): Update prototypes.\n+\t(expand_builtin_constant_p, expand_builtin_strlen,\n+\texpand_builtin_strcpy, expand_builtin_memset,\n+\texpand_builtin_bzero, expand_builtin_args_info,\n+\texpand_builtin_frame_address): Pass in just the argument(s)\n+\tneeded, not the entire expression `exp'.\n+\t(expand_builtin): Update all calls to these functions.\n+\n 2003-05-03  Richard Henderson  <rth@redhat.com>\n \n \t* builtins.c (expand_builtin) <BUILT_IN_DWARF_FP_REGNUM>: Remove."}, {"sha": "e0a6dea3ce710ba2de5e6cc5ae39434f87ed953d", "filename": "gcc/builtins.c", "status": "modified", "additions": 32, "deletions": 50, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c9b38d73852158959ca7c3a1d53948d76df7434/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c9b38d73852158959ca7c3a1d53948d76df7434/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8c9b38d73852158959ca7c3a1d53948d76df7434", "patch": "@@ -102,7 +102,7 @@ static rtx expand_builtin_classify_type\tPARAMS ((tree));\n static void expand_errno_check\t\tPARAMS ((tree, rtx));\n static rtx expand_builtin_mathfn\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_mathfn_2\tPARAMS ((tree, rtx, rtx));\n-static rtx expand_builtin_constant_p\tPARAMS ((tree));\n+static rtx expand_builtin_constant_p\tPARAMS ((tree, enum machine_mode));\n static rtx expand_builtin_args_info\tPARAMS ((tree));\n static rtx expand_builtin_next_arg\tPARAMS ((tree));\n static rtx expand_builtin_va_start\tPARAMS ((tree));\n@@ -144,7 +144,7 @@ static rtx builtin_memset_gen_str\tPARAMS ((PTR, HOST_WIDE_INT,\n static rtx expand_builtin_memset\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_bzero\t\tPARAMS ((tree));\n-static rtx expand_builtin_strlen\tPARAMS ((tree, rtx));\n+static rtx expand_builtin_strlen\tPARAMS ((tree, rtx, enum machine_mode));\n static rtx expand_builtin_strstr\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strpbrk\tPARAMS ((tree, rtx,\n@@ -156,7 +156,7 @@ static rtx expand_builtin_strrchr\tPARAMS ((tree, rtx,\n static rtx expand_builtin_alloca\tPARAMS ((tree, rtx));\n static rtx expand_builtin_unop\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t tree, rtx, rtx, optab));\n-static rtx expand_builtin_frame_address\tPARAMS ((tree));\n+static rtx expand_builtin_frame_address\tPARAMS ((tree, tree));\n static rtx expand_builtin_fputs\t\tPARAMS ((tree, int, int));\n static tree stabilize_va_list\t\tPARAMS ((tree, int));\n static rtx expand_builtin_expect\tPARAMS ((tree, rtx));\n@@ -1443,11 +1443,10 @@ expand_builtin_classify_type (arglist)\n /* Expand expression EXP, which is a call to __builtin_constant_p.  */\n \n static rtx\n-expand_builtin_constant_p (exp)\n-     tree exp;\n+expand_builtin_constant_p (arglist, target_mode)\n+     tree arglist;\n+     enum machine_mode target_mode;\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n   rtx tmp;\n \n   if (arglist == 0)\n@@ -1461,7 +1460,7 @@ expand_builtin_constant_p (exp)\n   current_function_calls_constant_p = 1;\n \n   tmp = expand_expr (arglist, NULL_RTX, VOIDmode, 0);\n-  tmp = gen_rtx_CONSTANT_P_RTX (value_mode, tmp);\n+  tmp = gen_rtx_CONSTANT_P_RTX (target_mode, tmp);\n   return tmp;\n }\n \n@@ -1907,28 +1906,26 @@ expand_builtin_mathfn_2 (exp, target, subtarget)\n    try to get the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strlen (exp, target)\n-     tree exp;\n+expand_builtin_strlen (arglist, target, target_mode)\n+     tree arglist;\n      rtx target;\n+     enum machine_mode target_mode;\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n-\n   if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n     return 0;\n   else\n     {\n       rtx pat;\n       tree len, src = TREE_VALUE (arglist);\n       rtx result, src_reg, char_rtx, before_strlen;\n-      enum machine_mode insn_mode = value_mode, char_mode;\n+      enum machine_mode insn_mode = target_mode, char_mode;\n       enum insn_code icode = CODE_FOR_nothing;\n       int align;\n \n       /* If the length can be computed at compile-time, return it.  */\n       len = c_strlen (src);\n       if (len)\n-\treturn expand_expr (len, target, value_mode, EXPAND_NORMAL);\n+\treturn expand_expr (len, target, target_mode, EXPAND_NORMAL);\n \n       align = get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n \n@@ -1992,12 +1989,12 @@ expand_builtin_strlen (exp, target)\n \temit_insn_before (pat, get_insns ());\n \n       /* Return the value in the proper mode for this function.  */\n-      if (GET_MODE (result) == value_mode)\n+      if (GET_MODE (result) == target_mode)\n \ttarget = result;\n       else if (target != 0)\n \tconvert_move (target, result, 0);\n       else\n-\ttarget = convert_to_mode (value_mode, result, 0);\n+\ttarget = convert_to_mode (target_mode, result, 0);\n \n       return target;\n     }\n@@ -2432,12 +2429,11 @@ expand_builtin_bcopy (arglist)\n    convenient).  */\n \n static rtx\n-expand_builtin_strcpy (exp, target, mode)\n-     tree exp;\n+expand_builtin_strcpy (arglist, target, mode)\n+     tree arglist;\n      rtx target;\n      enum machine_mode mode;\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n   tree fn, len;\n \n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n@@ -2632,13 +2628,11 @@ builtin_memset_gen_str (data, offset, mode)\n    convenient).  */\n \n static rtx\n-expand_builtin_memset (exp, target, mode)\n-     tree exp;\n+expand_builtin_memset (arglist, target, mode)\n+     tree arglist;\n      rtx target;\n      enum machine_mode mode;\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n-\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -2748,12 +2742,10 @@ expand_builtin_memset (exp, target, mode)\n    if we failed the caller should emit a normal call.  */\n \n static rtx\n-expand_builtin_bzero (exp)\n-     tree exp;\n+expand_builtin_bzero (arglist)\n+     tree arglist;\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n   tree dest, size, newarglist;\n-  rtx result;\n \n   if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n@@ -2770,13 +2762,7 @@ expand_builtin_bzero (exp)\n   newarglist = tree_cons (NULL_TREE, integer_zero_node, newarglist);\n   newarglist = tree_cons (NULL_TREE, dest, newarglist);\n \n-  TREE_OPERAND (exp, 1) = newarglist;\n-  result = expand_builtin_memset (exp, const0_rtx, VOIDmode);\n-\n-  /* Always restore the original arguments.  */\n-  TREE_OPERAND (exp, 1) = arglist;\n-\n-  return result;\n+  return expand_builtin_memset (newarglist, const0_rtx, VOIDmode);\n }\n \n /* Expand expression EXP, which is a call to the memcmp built-in function.\n@@ -3410,10 +3396,9 @@ expand_builtin_saveregs ()\n    is controlled by the definition of CUMULATIVE_ARGS.  */\n \n static rtx\n-expand_builtin_args_info (exp)\n-     tree exp;\n+expand_builtin_args_info (arglist)\n+     tree arglist;\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n   int nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n   int *word_ptr = (int *) &current_function_args_info;\n \n@@ -3817,12 +3802,9 @@ expand_builtin_va_copy (arglist)\n    __builtin_return_address.  */\n \n static rtx\n-expand_builtin_frame_address (exp)\n-     tree exp;\n+expand_builtin_frame_address (fndecl, arglist)\n+     tree fndecl, arglist;\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n-\n   /* The argument must be a nonnegative integer constant.\n      It counts the number of frames to scan up the stack.\n      The value is the return address saved in that frame.  */\n@@ -4446,7 +4428,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_builtin_saveregs ();\n \n     case BUILT_IN_ARGS_INFO:\n-      return expand_builtin_args_info (exp);\n+      return expand_builtin_args_info (arglist);\n \n       /* Return the address of the first anonymous stack arg.  */\n     case BUILT_IN_NEXT_ARG:\n@@ -4456,11 +4438,11 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_builtin_classify_type (arglist);\n \n     case BUILT_IN_CONSTANT_P:\n-      return expand_builtin_constant_p (exp);\n+      return expand_builtin_constant_p (arglist, target_mode);\n \n     case BUILT_IN_FRAME_ADDRESS:\n     case BUILT_IN_RETURN_ADDRESS:\n-      return expand_builtin_frame_address (exp);\n+      return expand_builtin_frame_address (fndecl, arglist);\n \n     /* Returns the address of the area where the structure is returned.\n        0 otherwise.  */\n@@ -4524,13 +4506,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n \n     case BUILT_IN_STRLEN:\n-      target = expand_builtin_strlen (exp, target);\n+      target = expand_builtin_strlen (arglist, target, target_mode);\n       if (target)\n \treturn target;\n       break;\n \n     case BUILT_IN_STRCPY:\n-      target = expand_builtin_strcpy (exp, target, mode);\n+      target = expand_builtin_strcpy (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n@@ -4622,13 +4604,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n \n     case BUILT_IN_MEMSET:\n-      target = expand_builtin_memset (exp, target, mode);\n+      target = expand_builtin_memset (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n \n     case BUILT_IN_BZERO:\n-      target = expand_builtin_bzero (exp);\n+      target = expand_builtin_bzero (arglist);\n       if (target)\n \treturn target;\n       break;"}]}