{"sha": "921186579c3ba7d4e1fea8e967ec7d0f804167bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIxMTg2NTc5YzNiYTdkNGUxZmVhOGU5NjdlYzdkMGY4MDQxNjdiZg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-12-11T11:12:37Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-12-11T11:12:37Z"}, "message": "[Ada] Spurious error with pragma Thread_Local_Storage\n\nThe following patch modifies the checks related to pragma\nThread_Local_Storage to correct a confusion in semantics which led to\nspurious errors.\n\n------------\n-- Source --\n------------\n\n--  pack.ads\n\npackage Pack is\n   type Arr is array (1 .. 5) of Boolean;\n\n   type Arr_With_Default is array (1 .. 5) of Boolean\n     with Default_Component_Value => False;\n\n   type Int is new Integer range 1 .. 5;\n\n   type Int_With_Default is new Integer range 1 .. 5\n     with Default_Value => 1;\n\n   protected type Prot_Typ is\n      entry E;\n   end Prot_Typ;\n\n   type Rec_1 is record\n      Comp : Integer;\n   end record;\n\n   type Rec_2 is record\n      Comp : Int;\n   end record;\n\n   type Rec_3 is record\n      Comp : Int_With_Default;\n   end record;\n\n   task type Task_Typ is\n      entry E;\n   end Task_Typ;\nend Pack;\n\n--  pack.adb\n\npackage body Pack is\n   function F (Val : Int) return Int is\n   begin\n      if Val <= 1 then\n         return 1;\n      else\n         return F (Val - 1) * Val;\n      end if;\n   end F;\n\n   function F (Val : Int_With_Default) return Int_With_Default is\n   begin\n      if Val <= 1 then\n         return 1;\n      else\n         return F (Val - 1) * Val;\n      end if;\n   end F;\n\n   function F (Val : Integer) return Integer is\n   begin\n      if Val <= 1 then\n         return 1;\n      else\n         return F (Val - 1) * Val;\n      end if;\n   end F;\n\n   protected body Prot_Typ is\n      entry E when True is begin null; end E;\n   end Prot_Typ;\n\n   task body Task_Typ is\n   begin\n      accept E;\n   end Task_Typ;\n\n   Obj_1 : Arr;                                                      --  OK\n   pragma Thread_Local_Storage (Obj_1);\n\n   Obj_2 : Arr := (others => True);                                  --  OK\n   pragma Thread_Local_Storage (Obj_2);\n\n   Obj_3 : Arr := (others => F (2) = Integer (3));                   --  ERROR\n   pragma Thread_Local_Storage (Obj_3);\n\n   Obj_4 : Arr_With_Default;                                         --  ERROR\n   pragma Thread_Local_Storage (Obj_4);\n\n   Obj_5 : Arr_With_Default := (others => True);                     --  OK\n   pragma Thread_Local_Storage (Obj_5);\n\n   Obj_6 : Arr_With_Default := (others => F (2) = Integer (3));      --  ERROR\n   pragma Thread_Local_Storage (Obj_6);\n\n   Obj_7 : Integer;                                                  --  OK\n   pragma Thread_Local_Storage (Obj_7);\n\n   Obj_8 : Integer := 1;                                             --  OK\n   pragma Thread_Local_Storage (Obj_8);\n\n   Obj_9 : Integer := F (2);                                         --  ERROR\n   pragma Thread_Local_Storage (Obj_9);\n\n   Obj_10 : Int;                                                     --  OK\n   pragma Thread_Local_Storage (Obj_10);\n\n   Obj_11 : Int := 1;                                                --  OK\n   pragma Thread_Local_Storage (Obj_11);\n\n   Obj_12 : Int := F (2);                                            --  ERROR\n   pragma Thread_Local_Storage (Obj_12);\n\n   Obj_13 : Int_With_Default;                                        --  ERROR\n   pragma Thread_Local_Storage (Obj_13);\n\n   Obj_14 : Int_With_Default := 1;                                   --  OK\n   pragma Thread_Local_Storage (Obj_14);\n\n   Obj_15 : Int_With_Default := F (2);                               --  ERROR\n   pragma Thread_Local_Storage (Obj_15);\n\n   Obj_16 : Prot_Typ;                                                --  ERROR\n   pragma Thread_Local_Storage (Obj_16);\n\n   Obj_17 : Rec_1;                                                   --  OK\n   pragma Thread_Local_Storage (Obj_17);\n\n   Obj_18 : Rec_1 := (others => 1);                                  --  OK\n   pragma Thread_Local_Storage (Obj_18);\n\n   Obj_19 : Rec_1 := (others => F (2));                              --  ERROR\n   pragma Thread_Local_Storage (Obj_19);\n\n   Obj_20 : Rec_2;                                                   --  OK\n   pragma Thread_Local_Storage (Obj_20);\n\n   Obj_21 : Rec_2 := (others => 1);                                  --  OK\n   pragma Thread_Local_Storage (Obj_21);\n\n   Obj_22 : Rec_2 := (others => F (2));                              --  ERROR\n   pragma Thread_Local_Storage (Obj_22);\n\n   Obj_23 : Rec_3;                                                   --  ERROR\n   pragma Thread_Local_Storage (Obj_23);\n\n   Obj_24 : Rec_3 := (others => 1);                                  --  OK\n   pragma Thread_Local_Storage (Obj_24);\n\n   Obj_25 : Rec_3 := (others => F (2));                              --  ERROR\n   pragma Thread_Local_Storage (Obj_25);\n\n   Obj_26 : Task_Typ;                                                --  ERROR\n   pragma Thread_Local_Storage (Obj_26);\nend Pack;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gcc -c pack.adb\npack.adb:47:04: Thread_Local_Storage variable \"Obj_4\" is improperly\n  initialized\npack.adb:47:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:62:04: Thread_Local_Storage variable \"Obj_9\" is improperly\n  initialized\npack.adb:62:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:71:04: Thread_Local_Storage variable \"Obj_12\" is improperly\n  initialized\npack.adb:71:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:74:04: Thread_Local_Storage variable \"Obj_13\" is improperly\n  initialized\npack.adb:74:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:80:04: Thread_Local_Storage variable \"Obj_15\" is improperly\n  initialized\npack.adb:80:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:83:04: Thread_Local_Storage variable \"Obj_16\" is improperly\n  initialized\npack.adb:83:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:92:04: Thread_Local_Storage variable \"Obj_19\" is improperly\n  initialized\npack.adb:92:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:101:04: Thread_Local_Storage variable \"Obj_22\" is improperly\n  initialized\npack.adb:101:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:104:04: Thread_Local_Storage variable \"Obj_23\" is improperly\n  initialized\npack.adb:104:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:110:04: Thread_Local_Storage variable \"Obj_25\" is improperly\n  initialized\npack.adb:110:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\npack.adb:113:04: Thread_Local_Storage variable \"Obj_26\" is improperly\n  initialized\npack.adb:113:04: only allowed initialization is explicit \"null\", static\n  expression or static aggregate\n\n2018-12-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* freeze.adb (Check_Pragma_Thread_Local_Storage): Use the\n\tviolating set to diagnose detect an illegal initialization,\n\trather than the complement of the OK set.\n\t(Freeze_Object_Declaration): Factorize code in\n\tHas_Default_Initialization.\n\t(Has_Default_Initialization, Has_Incompatible_Initialization):\n\tNew routines.\n\nFrom-SVN: r267017", "tree": {"sha": "1459a2aae4aeb7d057d678441dc17721515b7a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1459a2aae4aeb7d057d678441dc17721515b7a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/921186579c3ba7d4e1fea8e967ec7d0f804167bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921186579c3ba7d4e1fea8e967ec7d0f804167bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/921186579c3ba7d4e1fea8e967ec7d0f804167bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921186579c3ba7d4e1fea8e967ec7d0f804167bf/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "759f1648029eef1fde1c66e342b033438c44e3b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/759f1648029eef1fde1c66e342b033438c44e3b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/759f1648029eef1fde1c66e342b033438c44e3b5"}], "stats": {"total": 149, "additions": 109, "deletions": 40}, "files": [{"sha": "c08199bbcf5ac53dfbb60c56439d925c0784ec25", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921186579c3ba7d4e1fea8e967ec7d0f804167bf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921186579c3ba7d4e1fea8e967ec7d0f804167bf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=921186579c3ba7d4e1fea8e967ec7d0f804167bf", "patch": "@@ -1,3 +1,13 @@\n+2018-12-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* freeze.adb (Check_Pragma_Thread_Local_Storage): Use the\n+\tviolating set to diagnose detect an illegal initialization,\n+\trather than the complement of the OK set.\n+\t(Freeze_Object_Declaration): Factorize code in\n+\tHas_Default_Initialization.\n+\t(Has_Default_Initialization, Has_Incompatible_Initialization):\n+\tNew routines.\n+\n 2018-12-11  Dmitriy Anisimkov  <anisimko@adacore.com>\n \n \t* libgnat/g-socket.ads (Family_Type): Add new enumerated value"}, {"sha": "0573949e68dfd409ada5a4e76f3844ff8ffabffa", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 99, "deletions": 40, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921186579c3ba7d4e1fea8e967ec7d0f804167bf/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921186579c3ba7d4e1fea8e967ec7d0f804167bf/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=921186579c3ba7d4e1fea8e967ec7d0f804167bf", "patch": "@@ -3187,8 +3187,13 @@ package body Freeze is\n          --  length of the array, or its corresponding attribute.\n \n          procedure Check_Pragma_Thread_Local_Storage (Var_Id : Entity_Id);\n-         --  Ensure that the initialization state of variable Var_Id subject to\n-         --  pragma Thread_Local_Storage satisfies the semantics of the pragma.\n+         --  Ensure that the initialization state of variable Var_Id subject\n+         --  to pragma Thread_Local_Storage agrees with the semantics of the\n+         --  pragma.\n+\n+         function Has_Default_Initialization\n+           (Obj_Id : Entity_Id) return Boolean;\n+         --  Determine whether object Obj_Id default initialized\n \n          -------------------------------\n          -- Check_Large_Modular_Array --\n@@ -3274,53 +3279,117 @@ package body Freeze is\n          ---------------------------------------\n \n          procedure Check_Pragma_Thread_Local_Storage (Var_Id : Entity_Id) is\n-            Decl : constant Node_Id := Declaration_Node (Var_Id);\n-            Expr : constant Node_Id := Expression (Decl);\n+            function Has_Incompatible_Initialization\n+              (Var_Decl : Node_Id) return Boolean;\n+            --  Determine whether variable Var_Id with declaration Var_Decl is\n+            --  initialized with a value that violates the semantics of pragma\n+            --  Thread_Local_Storage.\n \n-         begin\n-            --  A variable whose initialization is suppressed lacks default\n-            --  initialization.\n+            -------------------------------------\n+            -- Has_Incompatible_Initialization --\n+            -------------------------------------\n \n-            if Suppress_Initialization (Var_Id) then\n-               null;\n+            function Has_Incompatible_Initialization\n+              (Var_Decl : Node_Id) return Boolean\n+            is\n+               Init_Expr : constant Node_Id := Expression (Var_Decl);\n \n-            --  The variable has some form of initialization. Check whether it\n-            --  is compatible with the semantics of the pragma.\n+            begin\n+               --  The variable is default-initialized. This directly violates\n+               --  the semantics of the pragma.\n \n-            elsif Has_Init_Expression (Decl)\n-              and then Present (Expr)\n-              and then\n+               if Has_Default_Initialization (Var_Id) then\n+                  return True;\n \n-               --  The variable is initialized with \"null\"\n+               --  The variable has explicit initialization. In this case only\n+               --  a handful of values satisfy the semantics of the pragma.\n \n-                (Nkind (Expr) = N_Null\n-                   or else\n+               elsif Has_Init_Expression (Var_Decl)\n+                 and then Present (Init_Expr)\n+               then\n+                  --  \"null\" is a legal form of initialization\n+\n+                  if Nkind (Init_Expr) = N_Null then\n+                     return False;\n \n-               --  The variable is initialized with a static constant\n+                  --  A static expression is a legal form of initialization\n \n-                 Is_OK_Static_Expression (Expr)\n-                   or else\n+                  elsif Is_Static_Expression (Init_Expr) then\n+                     return False;\n \n-               --  The variable is initialized with a static aggregate\n+                  --  A static aggregate is a legal form of initialization\n \n-                (Nkind (Expr) = N_Aggregate\n-                   and then Compile_Time_Known_Aggregate (Expr)))\n-            then\n+                  elsif Nkind (Init_Expr) = N_Aggregate\n+                    and then Compile_Time_Known_Aggregate (Init_Expr)\n+                  then\n+                     return False;\n+\n+                  --  All other initialization expressions violate the semantic\n+                  --  of the pragma.\n+\n+                  else\n+                     return True;\n+                  end if;\n+\n+               --  The variable lacks any kind of initialization, which agrees\n+               --  with the semantics of the pragma.\n+\n+               else\n+                  return False;\n+               end if;\n+            end Has_Incompatible_Initialization;\n+\n+            --  Local declarations\n+\n+            Var_Decl : constant Node_Id := Declaration_Node (Var_Id);\n+\n+         --  Start of processing for Check_Pragma_Thread_Local_Storage\n+\n+         begin\n+            --  A variable whose initialization is suppressed lacks any kind of\n+            --  initialization.\n+\n+            if Suppress_Initialization (Var_Id) then\n                null;\n \n-            --  Otherwise the initialization of the variable violates the\n-            --  semantics of pragma Thread_Local_Storage.\n+            --  The variable has default initialization, or is explicitly\n+            --  initialized to a value other than null, static expression,\n+            --  or a static aggregate.\n \n-            else\n+            elsif Has_Incompatible_Initialization (Var_Decl) then\n                Error_Msg_NE\n                  (\"Thread_Local_Storage variable& is improperly initialized\",\n-                  Decl, Var_Id);\n+                  Var_Decl, Var_Id);\n                Error_Msg_NE\n                  (\"\\only allowed initialization is explicit NULL, static \"\n-                  & \"expression or static aggregate\", Decl, Var_Id);\n+                  & \"expression or static aggregate\", Var_Decl, Var_Id);\n             end if;\n          end Check_Pragma_Thread_Local_Storage;\n \n+         --------------------------------\n+         -- Has_Default_Initialization --\n+         --------------------------------\n+\n+         function Has_Default_Initialization\n+           (Obj_Id : Entity_Id) return Boolean\n+         is\n+            Obj_Decl : constant Node_Id   := Declaration_Node (Obj_Id);\n+            Obj_Typ  : constant Entity_Id := Etype (Obj_Id);\n+\n+         begin\n+            return\n+              Comes_From_Source (Obj_Id)\n+                and then not Is_Imported (Obj_Id)\n+                and then not Has_Init_Expression (Obj_Decl)\n+                and then\n+                  ((Has_Non_Null_Base_Init_Proc (Obj_Typ)\n+                     and then not No_Initialization (Obj_Decl)\n+                     and then not Initialization_Suppressed (Obj_Typ))\n+                   or else\n+                     (Needs_Simple_Initialization (Obj_Typ)\n+                       and then not Is_Internal (Obj_Id)));\n+         end Has_Default_Initialization;\n+\n          --  Local variables\n \n          Typ : constant Entity_Id := Etype (E);\n@@ -3438,17 +3507,7 @@ package body Freeze is\n          if Ekind (E) = E_Constant and then Present (Full_View (E)) then\n             null;\n \n-         elsif Comes_From_Source (E)\n-           and then not Is_Imported (E)\n-           and then not Has_Init_Expression (Declaration_Node (E))\n-           and then\n-             ((Has_Non_Null_Base_Init_Proc (Typ)\n-                and then not No_Initialization (Declaration_Node (E))\n-                and then not Initialization_Suppressed (Typ))\n-              or else\n-                (Needs_Simple_Initialization (Typ)\n-                  and then not Is_Internal (E)))\n-         then\n+         elsif Has_Default_Initialization (E) then\n             Check_Restriction\n               (No_Default_Initialization, Declaration_Node (E));\n          end if;"}]}