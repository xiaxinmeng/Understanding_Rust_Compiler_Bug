{"sha": "0ef33d44629066e33ffdc46014374a3ef5c5f009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVmMzNkNDQ2MjkwNjZlMzNmZmRjNDYwMTQzNzRhM2VmNWM1ZjAwOQ==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-10-26T12:11:44Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-10-26T12:11:44Z"}, "message": "New I/O specifiers CARRIAGECONTROL, READONLY, SHARE with -fdec.\n\n\tgcc/fortran/\n\t* gfortran.texi: Document.\n\t* frontend-passes.c (gfc_code_walker): Add SHARE and CARRIAGECONTROL.\n\t* io.c (gfc_free_open, gfc_resolve_open, gfc_match_open): Ditto.\n\t* gfortran.h (gfc_open): Add SHARE, CARRIAGECONTROL, and READONLY.\n\t* io.c (io_tag, match_open_element): Ditto.\n\t* ioparm.def: Ditto.\n\t* trans-io.c (gfc_trans_open): Ditto.\n\t* io.c (match_dec_etag, match_dec_ftag): New functions.\n\n\tlibgfortran/io/\n\t* libgfortran.h (IOPARM_OPEN_HAS_READONLY, IOPARM_OPEN_HAS_SHARE,\n\tIOPARM_OPEN_HAS_CC): New for READONLY, SHARE, and CARRIAGECONTROL.\n\t* close.c (st_close): Support READONLY.\n\t* io.h (st_parameter_open, unit_flags): Support SHARE, CARRIAGECONTROL,\n\tand READONLY.\n\t* open.c (st_open): Ditto.\n\t* transfer.c (data_transfer_init): Ditto.\n\t* io.h (st_parameter_dt): New member 'cc' for CARRIAGECONTROL.\n\t* write.c (write_check_cc, write_cc): New functions for CARRIAGECONTROL.\n\t* transfer.c (next_record_cc): Ditto.\n\t* file_pos.c (st_endfile): Support SHARE and CARRIAGECONTROL.\n\t* io.h (st_parameter_inquire): Ditto.\n\t* open.c (edit_modes, new_unit): Ditto.\n\t* inquire.c (inquire_via_unit, inquire_via_filename): Ditto.\n\t* io.h (unit_share, unit_cc, cc_fortran, IOPARM_INQUIRE_HAS_SHARE,\n\tIOPARM_INQUIRE_HAS_CC): New for SHARE and CARRIAGECONTROL.\n\t* open.c (share_opt, cc_opt): Ditto.\n\t* read.c (read_x): Support CARRIAGECONTROL.\n\t* transfer.c (read_sf, next_record_r, next_record_w): Ditto.\n\t* write.c (list_formatted_write_scalar, write_a): Ditto.\n\t* unix.h (close_share): New prototype.\n\t* unix.c (open_share, close_share): New functions to handle SHARE.\n\t* unix.c (open_external): Handle READONLY. Call open_share.\n\t* close.c (st_close): Call close_share.\n\n\tgcc/testsuite/\n\t* dec_io_1.f90: New test.\n        * dec_io_2.f90: New test.\n        * dec_io_3.f90: New test.\n        * dec_io_4.f90: New test.\n        * dec_io_5.f90: New test.\n        * dec_io_6.f90: New test.\n\nFrom-SVN: r241550", "tree": {"sha": "45d5f5c66da6b5b2820d025ba02eb604ab6a5b91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45d5f5c66da6b5b2820d025ba02eb604ab6a5b91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ef33d44629066e33ffdc46014374a3ef5c5f009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef33d44629066e33ffdc46014374a3ef5c5f009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef33d44629066e33ffdc46014374a3ef5c5f009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef33d44629066e33ffdc46014374a3ef5c5f009/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dbe100a4157843d12b192e4aae504b43af4774b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dbe100a4157843d12b192e4aae504b43af4774b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dbe100a4157843d12b192e4aae504b43af4774b"}], "stats": {"total": 1094, "additions": 1072, "deletions": 22}, "files": [{"sha": "65911dc7302fa31ce866703613907d11aa313b14", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1,3 +1,14 @@\n+2016-10-26  Fritz Reese <fritzoreese@gmail.com>\n+\n+\t* frontend-passes.c (gfc_code_walker): Add SHARE and CARRIAGECONTROL.\n+\t* io.c (gfc_free_open, gfc_resolve_open, gfc_match_open): Ditto.\n+\t* gfortran.h (gfc_open): Add SHARE, CARRIAGECONTROL, and READONLY.\n+\t* io.c (io_tag, match_open_element): Ditto.\n+\t* ioparm.def: Ditto.\n+\t* trans-io.c (gfc_trans_open): Ditto.\n+\t* io.c (match_dec_etag, match_dec_ftag): New functions.\n+\t* gfortran.texi: Document.\n+\n 2016-10-25  Fritz Reese <fritzoreese@gmail.com>\n \n \t* gfortran.texi: Document."}, {"sha": "e61673fc6e46eb39e970a41f9b18c539bf50eac0", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -3540,6 +3540,8 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      WALK_SUBEXPR (co->ext.open->asynchronous);\n \t      WALK_SUBEXPR (co->ext.open->id);\n \t      WALK_SUBEXPR (co->ext.open->newunit);\n+\t      WALK_SUBEXPR (co->ext.open->share);\n+\t      WALK_SUBEXPR (co->ext.open->cc);\n \t      break;\n \n \t    case EXEC_CLOSE:"}, {"sha": "ea4437c5d833e139202c85ebacb4c12784bf5c8f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -2284,7 +2284,9 @@ typedef struct\n {\n   gfc_expr *unit, *file, *status, *access, *form, *recl,\n     *blank, *position, *action, *delim, *pad, *iostat, *iomsg, *convert,\n-    *decimal, *encoding, *round, *sign, *asynchronous, *id, *newunit;\n+    *decimal, *encoding, *round, *sign, *asynchronous, *id, *newunit,\n+    *share, *cc;\n+  char readonly;\n   gfc_st_label *err;\n }\n gfc_open;\n@@ -2313,7 +2315,7 @@ typedef struct\n     *unformatted, *recl, *nextrec, *blank, *position, *action, *read,\n     *write, *readwrite, *delim, *pad, *iolength, *iomsg, *convert, *strm_pos,\n     *asynchronous, *decimal, *encoding, *pending, *round, *sign, *size, *id,\n-    *iqstream;\n+    *iqstream, *share, *cc;\n \n   gfc_st_label *err;\n "}, {"sha": "e65c2decad2cd08d7d211cd41fcd8551b7413291", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1470,6 +1470,7 @@ compatibility extensions along with those enabled by @option{-std=legacy}.\n * %LOC as an rvalue::\n * .XOR. operator::\n * Bitwise logical operators::\n+* Extended I/O specifiers::\n @end menu\n \n @node Old-style kind specifications\n@@ -2605,6 +2606,95 @@ Here is the mapping of logical operator to bitwise intrinsic used with\n @item @code{.EQV.} @tab @code{@ref{NOT}(@ref{IEOR})} @tab complement of exclusive or\n @end multitable\n \n+@node Extended I/O specifiers\n+@subsection Extended I/O specifiers\n+@cindex @code{CARRIAGECONTROL}\n+@cindex @code{READONLY}\n+@cindex @code{SHARE}\n+@cindex @code{SHARED}\n+@cindex @code{NOSHARED}\n+@cindex I/O specifiers\n+\n+GNU Fortran supports the additional legacy I/O specifiers\n+@code{CARRIAGECONTROL}, @code{READONLY}, and @code{SHARE} with the\n+compile flag @option{-fdec}, for compatibility.\n+\n+@table @code\n+@item CARRIAGECONTROL\n+The @code{CARRIAGECONTROL} specifier allows a user to control line\n+termination settings between output records for an I/O unit. The specifier has\n+no meaning for readonly files. When @code{CARRAIGECONTROL} is specified upon\n+opening a unit for formatted writing, the exact @code{CARRIAGECONTROL} setting\n+determines what characters to write between output records. The syntax is:\n+\n+@smallexample\n+OPEN(..., CARRIAGECONTROL=cc)\n+@end smallexample\n+\n+Where @emph{cc} is a character expression that evaluates to one of the\n+following values:\n+\n+@multitable @columnfractions .2 .8\n+@item @code{'LIST'} @tab One line feed between records (default)\n+@item @code{'FORTRAN'} @tab Legacy interpretation of the first character (see below)\n+@item @code{'NONE'} @tab No separator between records\n+@end multitable\n+\n+With @code{CARRIAGECONTROL='FORTRAN'}, when a record is written, the first\n+character of the input record is not written, and instead determines the output\n+record separator as follows:\n+\n+@multitable @columnfractions .3 .3 .4\n+@headitem Leading character @tab Meaning @tab Output separating character(s)\n+@item @code{'+'} @tab Overprinting @tab Carriage return only\n+@item @code{'-'} @tab New line @tab Line feed and carriage return\n+@item @code{'0'} @tab Skip line @tab Two line feeds and carriage return\n+@item @code{'1'} @tab New page @tab Form feed and carriage return\n+@item @code{'$'} @tab Prompting @tab Line feed (no carriage return)\n+@item @code{CHAR(0)} @tab Overprinting (no advance) @tab None\n+@end multitable\n+\n+@item READONLY\n+The @code{READONLY} specifier may be given upon opening a unit, and is\n+equivalent to specifying @code{ACTION='READ'}, except that the file may not be\n+deleted on close (i.e. @code{CLOSE} with @code{STATUS=\"DELETE\"}). The syntax\n+is:\n+\n+@smallexample\n+@code{OPEN(..., READONLY)}\n+@end smallexample\n+\n+@item SHARE\n+The @code{SHARE} specifier allows system-level locking on a unit upon opening\n+it for controlled access from multiple processes/threads. The @code{SHARE}\n+specifier has several forms:\n+\n+@smallexample\n+OPEN(..., SHARE=sh)\n+OPEN(..., SHARED)\n+OPEN(..., NOSHARED)\n+@end smallexample\n+\n+Where @emph{sh} in the first form is a character expression that evaluates to\n+a value as seen in the table below. The latter two forms are aliases\n+for particular values of @emph{sh}:\n+\n+@multitable @columnfractions .3 .3 .4\n+@headitem Explicit form @tab Short form @tab Meaning\n+@item @code{SHARE='DENYRW'} @tab @code{NOSHARED} @tab Exclusive (write) lock\n+@item @code{SHARE='DENYNONE'} @tab @code{SHARED} @tab Shared (read) lock\n+@end multitable\n+\n+In general only one process may hold an exclusive (write) lock for a given file\n+at a time, whereas many processes may hold shared (read) locks for the same\n+file.\n+\n+The behavior of locking may vary with your operating system. On POSIX systems,\n+locking is implemented with @code{fcntl}. Consult your corresponding operating\n+system's manual pages for further details. Locking via @code{SHARE=} is not\n+supported on other systems.\n+\n+@end table\n \n @node Extensions not implemented in GNU Fortran\n @section Extensions not implemented in GNU Fortran\n@@ -2629,7 +2719,7 @@ code that uses them running with the GNU Fortran compiler.\n * Variable FORMAT expressions::\n @c * Q edit descriptor::\n @c * TYPE and ACCEPT I/O Statements::\n-@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::\n+@c * DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::\n @c * Omitted arguments in procedure call::\n * Alternate complex function syntax::\n * Volatile COMMON blocks::"}, {"sha": "dce0f7cd97008e8ee7a4aeff4478bdf64c2f28b6", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 175, "deletions": 2, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -38,6 +38,15 @@ typedef struct\n io_tag;\n \n static const io_tag\n+\ttag_readonly\t= {\"READONLY\", \" readonly\", NULL, BT_UNKNOWN },\n+\ttag_shared\t= {\"SHARE\", \" shared\", NULL, BT_UNKNOWN },\n+\ttag_noshared\t= {\"SHARE\", \" noshared\", NULL, BT_UNKNOWN },\n+\ttag_e_share\t= {\"SHARE\", \" share =\", \" %e\", BT_CHARACTER },\n+\ttag_v_share\t= {\"SHARE\", \" share =\", \" %v\", BT_CHARACTER },\n+\ttag_cc\t\t= {\"CARRIAGECONTROL\", \" carriagecontrol =\", \" %e\",\n+\t\t\t   BT_CHARACTER },\n+\ttag_v_cc\t= {\"CARRIAGECONTROL\", \" carriagecontrol =\", \" %v\",\n+\t\t\t   BT_CHARACTER },\n \ttag_file\t= {\"FILE\", \" file =\", \" %e\", BT_CHARACTER },\n \ttag_status\t= {\"STATUS\", \" status =\", \" %e\", BT_CHARACTER},\n \ttag_e_access\t= {\"ACCESS\", \" access =\", \" %e\", BT_CHARACTER},\n@@ -1495,6 +1504,97 @@ match_ltag (const io_tag *tag, gfc_st_label ** label)\n }\n \n \n+/* Match a tag using match_etag, but only if -fdec is enabled.  */\n+static match\n+match_dec_etag (const io_tag *tag, gfc_expr **e)\n+{\n+  match m = match_etag (tag, e);\n+  if (flag_dec && m != MATCH_NO)\n+    return m;\n+  else if (m != MATCH_NO)\n+    {\n+      gfc_error (\"%s is a DEC extension at %C, re-compile with \"\n+\t  \"-fdec to enable\", tag->name);\n+      return MATCH_ERROR;\n+    }\n+  return m;\n+}\n+\n+\n+/* Match a tag using match_vtag, but only if -fdec is enabled.  */\n+static match\n+match_dec_vtag (const io_tag *tag, gfc_expr **e)\n+{\n+  match m = match_vtag(tag, e);\n+  if (flag_dec && m != MATCH_NO)\n+    return m;\n+  else if (m != MATCH_NO)\n+    {\n+      gfc_error (\"%s is a DEC extension at %C, re-compile with \"\n+\t  \"-fdec to enable\", tag->name);\n+      return MATCH_ERROR;\n+    }\n+  return m;\n+}\n+\n+\n+/* Match a DEC I/O flag tag - a tag with no expression such as READONLY.  */\n+\n+static match\n+match_dec_ftag (const io_tag *tag, gfc_open *o)\n+{\n+  match m;\n+\n+  m = gfc_match (tag->spec);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (!flag_dec)\n+    {\n+      gfc_error (\"%s is a DEC extension at %C, re-compile with \"\n+\t\t \"-fdec to enable\", tag->name);\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Just set the READONLY flag, which we use at runtime to avoid delete on\n+     close.  */\n+  if (tag == &tag_readonly)\n+    {\n+      o->readonly |= 1;\n+      return MATCH_YES;\n+    }\n+\n+  /* Interpret SHARED as SHARE='DENYNONE' (read lock).  */\n+  else if (tag == &tag_shared)\n+    {\n+      if (o->share != NULL)\n+\t{\n+\t  gfc_error (\"Duplicate %s specification at %C\", tag->name);\n+\t  return MATCH_ERROR;\n+\t}\n+      o->share = gfc_get_character_expr (gfc_default_character_kind,\n+\t  &gfc_current_locus, \"denynone\", 8);\n+      return MATCH_YES;\n+    }\n+\n+  /* Interpret NOSHARED as SHARE='DENYRW' (exclusive lock).  */\n+  else if (tag == &tag_noshared)\n+    {\n+      if (o->share != NULL)\n+\t{\n+\t  gfc_error (\"Duplicate %s specification at %C\", tag->name);\n+\t  return MATCH_ERROR;\n+\t}\n+      o->share = gfc_get_character_expr (gfc_default_character_kind,\n+\t  &gfc_current_locus, \"denyrw\", 6);\n+      return MATCH_YES;\n+    }\n+\n+  /* We handle all DEC tags above.  */\n+  gcc_unreachable ();\n+}\n+\n+\n /* Resolution of the FORMAT tag, to be called from resolve_tag.  */\n \n static bool\n@@ -1743,6 +1843,23 @@ match_open_element (gfc_open *open)\n   if (m != MATCH_NO)\n     return m;\n \n+  /* The following are extensions enabled with -fdec.  */\n+  m = match_dec_etag (&tag_e_share, &open->share);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_dec_etag (&tag_cc, &open->cc);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_dec_ftag (&tag_readonly, open);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_dec_ftag (&tag_shared, open);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_dec_ftag (&tag_noshared, open);\n+  if (m != MATCH_NO)\n+    return m;\n+\n   return MATCH_NO;\n }\n \n@@ -1775,6 +1892,8 @@ gfc_free_open (gfc_open *open)\n   gfc_free_expr (open->convert);\n   gfc_free_expr (open->asynchronous);\n   gfc_free_expr (open->newunit);\n+  gfc_free_expr (open->share);\n+  gfc_free_expr (open->cc);\n   free (open);\n }\n \n@@ -1805,6 +1924,8 @@ gfc_resolve_open (gfc_open *open)\n   RESOLVE_TAG (&tag_e_sign, open->sign);\n   RESOLVE_TAG (&tag_convert, open->convert);\n   RESOLVE_TAG (&tag_newunit, open->newunit);\n+  RESOLVE_TAG (&tag_e_share, open->share);\n+  RESOLVE_TAG (&tag_cc, open->cc);\n \n   if (!gfc_reference_st_label (open->err, ST_LABEL_TARGET))\n     return false;\n@@ -2014,15 +2135,29 @@ gfc_match_open (void)\n   /* Checks on the ACTION specifier.  */\n   if (open->action && open->action->expr_type == EXPR_CONSTANT)\n     {\n+      gfc_char_t *str = open->action->value.character.string;\n       static const char *action[] = { \"READ\", \"WRITE\", \"READWRITE\", NULL };\n \n       if (!is_char_type (\"ACTION\", open->action))\n \tgoto cleanup;\n \n       if (!compare_to_allowed_values (\"ACTION\", action, NULL, NULL,\n-\t\t\t\t      open->action->value.character.string,\n-\t\t\t\t      \"OPEN\", warn))\n+\t\t\t\t      str, \"OPEN\", warn))\n \tgoto cleanup;\n+\n+      /* With READONLY, only allow ACTION='READ'.  */\n+      if (open->readonly && (gfc_wide_strlen (str) != 4\n+\t\t\t     || gfc_wide_strncasecmp (str, \"READ\", 4) != 0))\n+\t{\n+\t  gfc_error (\"ACTION type conflicts with READONLY specifier at %C\");\n+\t  goto cleanup;\n+\t}\n+    }\n+  /* If we see READONLY and no ACTION, set ACTION='READ'.  */\n+  else if (open->readonly && open->action == NULL)\n+    {\n+      open->action = gfc_get_character_expr (gfc_default_character_kind,\n+\t\t\t\t\t     &gfc_current_locus, \"read\", 4);\n     }\n \n   /* Checks on the ASYNCHRONOUS specifier.  */\n@@ -2067,6 +2202,22 @@ gfc_match_open (void)\n \t}\n     }\n \n+  /* Checks on the CARRIAGECONTROL specifier.  */\n+  if (open->cc)\n+    {\n+      if (!is_char_type (\"CARRIAGECONTROL\", open->cc))\n+\tgoto cleanup;\n+\n+      if (open->cc->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char *cc[] = { \"LIST\", \"FORTRAN\", \"NONE\", NULL };\n+\t  if (!compare_to_allowed_values (\"CARRIAGECONTROL\", cc, NULL, NULL,\n+\t\t\t\t\t  open->cc->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t    goto cleanup;\n+\t}\n+    }\n+\n   /* Checks on the DECIMAL specifier.  */\n   if (open->decimal)\n     {\n@@ -2191,6 +2342,22 @@ gfc_match_open (void)\n \t}\n     }\n \n+  /* Checks on the SHARE specifier.  */\n+  if (open->share)\n+    {\n+      if (!is_char_type (\"SHARE\", open->share))\n+\tgoto cleanup;\n+\n+      if (open->share->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  static const char *share[] = { \"DENYNONE\", \"DENYRW\", NULL };\n+\t  if (!compare_to_allowed_values (\"SHARE\", share, NULL, NULL,\n+\t\t\t\t\t  open->share->value.character.string,\n+\t\t\t\t\t  \"OPEN\", warn))\n+\t    goto cleanup;\n+\t}\n+    }\n+\n   /* Checks on the SIGN specifier.  */\n   if (open->sign) \n     {\n@@ -4102,6 +4269,8 @@ gfc_free_inquire (gfc_inquire *inquire)\n   gfc_free_expr (inquire->sign);\n   gfc_free_expr (inquire->size);\n   gfc_free_expr (inquire->round);\n+  gfc_free_expr (inquire->share);\n+  gfc_free_expr (inquire->cc);\n   free (inquire);\n }\n \n@@ -4157,6 +4326,8 @@ match_inquire_element (gfc_inquire *inquire)\n   RETM m = match_vtag (&tag_pending, &inquire->pending);\n   RETM m = match_vtag (&tag_id, &inquire->id);\n   RETM m = match_vtag (&tag_s_iqstream, &inquire->iqstream);\n+  RETM m = match_dec_vtag (&tag_v_share, &inquire->share);\n+  RETM m = match_dec_vtag (&tag_v_cc, &inquire->cc);\n   RETM return MATCH_NO;\n }\n \n@@ -4354,6 +4525,8 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n   INQUIRE_RESOLVE_TAG (&tag_size, inquire->size);\n   INQUIRE_RESOLVE_TAG (&tag_s_decimal, inquire->decimal);\n   INQUIRE_RESOLVE_TAG (&tag_s_iqstream, inquire->iqstream);\n+  INQUIRE_RESOLVE_TAG (&tag_v_share, inquire->share);\n+  INQUIRE_RESOLVE_TAG (&tag_v_cc, inquire->cc);\n #undef INQUIRE_RESOLVE_TAG\n \n   if (!gfc_reference_st_label (inquire->err, ST_LABEL_TARGET))"}, {"sha": "f1bf7330fd0dac0672280970ed2dedc075e9fe14", "filename": "gcc/fortran/ioparm.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -16,6 +16,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* Make sure to keep in sync with libgfortran/io/io.h (st_parameter_*).  */\n #ifndef IOPARM_common_libreturn_mask\n #define IOPARM_common_libreturn_mask\t3\n #define IOPARM_common_libreturn_ok\t0\n@@ -50,6 +51,9 @@ IOPARM (open,    round,\t\t1 << 20, char2)\n IOPARM (open,    sign,\t\t1 << 21, char1)\n IOPARM (open,    asynchronous,\t1 << 22, char2)\n IOPARM (open,    newunit,\t1 << 23, pint4)\n+IOPARM (open,    readonly,\t1 << 24, int4)\n+IOPARM (open,    cc,\t\t1 << 25, char2)\n+IOPARM (open,    share,\t\t1 << 26, char1)\n IOPARM (close,   common,\t0,\t common)\n IOPARM (close,   status,\t1 << 7,  char1)\n IOPARM (filepos, common,\t0,\t common)\n@@ -88,6 +92,8 @@ IOPARM (inquire, pending,\t1 << 5,  pint4)\n IOPARM (inquire, size,\t\t1 << 6,  pintio)\n IOPARM (inquire, id,\t\t1 << 7,  pint4)\n IOPARM (inquire, iqstream,\t1 << 8,  char1)\n+IOPARM (inquire, share,\t\t1 << 9,  char2)\n+IOPARM (inquire, cc,\t\t1 << 10, char1)\n IOPARM (wait,    common,\t0,\t common)\n IOPARM (wait,    id,\t\t1 << 7,  pint4)\n IOPARM (dt,      common,\t0,\t common)"}, {"sha": "285e551585c01d814bf0bd9d7b15ded5852b3c01", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1123,6 +1123,14 @@ gfc_trans_open (gfc_code * code)\n     mask |= set_parameter_ref (&block, &post_block, var, IOPARM_open_newunit,\n \t\t\t       p->newunit);\n \n+  if (p->cc)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_cc, p->cc);\n+\n+  if (p->share)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_share, p->share);\n+\n+  mask |= set_parameter_const (&block, var, IOPARM_open_readonly, p->readonly);\n+\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n@@ -1450,6 +1458,13 @@ gfc_trans_inquire (gfc_code * code)\n     mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_iqstream,\n \t\t\t p->iqstream);\n \n+  if (p->share)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_share,\n+\t\t\t p->share);\n+\n+  if (p->cc)\n+    mask2 |= set_string (&block, &post_block, var, IOPARM_inquire_cc, p->cc);\n+\n   if (mask2)\n     mask |= set_parameter_const (&block, var, IOPARM_inquire_flags2, mask2);\n "}, {"sha": "d27d57addd5923e51acc7d88df2cc66f7b40daf0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1,3 +1,12 @@\n+2016-10-26  Fritz Reese <fritzoreese@gmail.com>\n+\n+\t* gfortran.dg/dec_io_1.f90: New test.\n+\t* gfortran.dg/dec_io_2.f90: New test.\n+\t* gfortran.dg/dec_io_3.f90: New test.\n+\t* gfortran.dg/dec_io_4.f90: New test.\n+\t* gfortran.dg/dec_io_5.f90: New test.\n+\t* gfortran.dg/dec_io_6.f90: New test.\n+\n 2016-10-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/78106"}, {"sha": "c7f59d69a2b31ccde3f2ea89be6b53e4816edcc3", "filename": "gcc/testsuite/gfortran.dg/dec_io_1.f90", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_1.f90?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -0,0 +1,101 @@\n+! { dg-do run }\n+! { dg-options \"-fdec\" }\n+!\n+! Run-time tests for values of DEC I/O parameters (doesn't test functionality).\n+!\n+\n+subroutine check_cc (fd, cc)\n+  implicit none\n+  character(*), intent(in) :: cc\n+  integer, intent(in) :: fd\n+  character(20) :: cc_inq\n+  inquire(unit=fd, carriagecontrol=cc_inq)\n+  if (cc_inq .ne. cc) then\n+    print *, '(', fd, ') cc expected ', cc, ' was ', cc_inq\n+    call abort()\n+  endif\n+endsubroutine\n+\n+subroutine check_share (fd, share)\n+  implicit none\n+  character(*), intent(in) :: share\n+  integer, intent(in) :: fd\n+  character(20) :: share_inq\n+  inquire(unit=fd, share=share_inq)\n+  if (share_inq .ne. share) then\n+    print *, '(', fd, ') share expected ', share, ' was ', share_inq\n+    call abort()\n+  endif\n+endsubroutine\n+\n+subroutine check_action (fd, acc)\n+  implicit none\n+  character(*), intent(in) :: acc\n+  integer, intent(in) :: fd\n+  character(20) acc_inq\n+  inquire(unit=fd, action=acc_inq)\n+  if (acc_inq .ne. acc) then\n+    print *, '(', fd, ') access expected ', acc, ' was ', acc_inq\n+    call abort()\n+  endif\n+endsubroutine\n+\n+implicit none\n+\n+integer, parameter :: fd=3\n+character(*), parameter :: fname  = 'dec_io_1.txt'\n+\n+!!!! <default>\n+\n+open(unit=fd,  file=fname, action='WRITE')\n+call check_cc(fd, 'LIST')\n+call check_share(fd, 'NODENY')\n+write (fd,*) 'test'\n+close(unit=fd)\n+\n+!!!! READONLY\n+\n+open (unit=fd, file=fname, readonly)\n+call check_action(fd, 'READ')\n+close (unit=fd)\n+\n+!!!! SHARED / SHARE='DENYNONE'\n+\n+open (unit=fd, file=fname, action='read', shared)\n+call check_share(fd, 'DENYNONE')\n+close (unit=fd)\n+\n+open (unit=fd, file=fname, action='read', share='DENYNONE')\n+call check_share(fd, 'DENYNONE')\n+close (unit=fd)\n+\n+!!!! NOSHARED / SHARE='DENYRW'\n+\n+open (unit=fd, file=fname, action='write', noshared)\n+call check_share(fd, 'DENYRW')\n+close (unit=fd)\n+\n+open (unit=fd, file=fname, action='write', share='DENYRW')\n+call check_share(fd, 'DENYRW')\n+close (unit=fd)\n+\n+!!!! CC=FORTRAN\n+\n+open(unit=fd,  file=fname, action ='WRITE', carriagecontrol='FORTRAN')\n+call check_cc(fd, 'FORTRAN')\n+close(unit=fd)\n+\n+!!!! CC=LIST\n+\n+open(unit=fd,  file=fname, action ='WRITE', carriagecontrol='LIST')\n+call check_cc(fd, 'LIST')\n+close(unit=fd)\n+\n+!!!! CC=NONE\n+\n+open(unit=fd,  file=fname, action ='WRITE', carriagecontrol='NONE')\n+call check_cc(fd, 'NONE')\n+close(unit=fd, status='delete') ! cleanup temp file\n+\n+\n+end"}, {"sha": "9adc4f4003f8a46687739ce5c7510fa9451cb415", "filename": "gcc/testsuite/gfortran.dg/dec_io_2.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_2.f90?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -0,0 +1,104 @@\n+! { dg-do run }\n+! { dg-options \"-fdec\" }\n+!\n+! Run-time tests for various carriagecontrol parameters with DEC I/O.\n+! Ensures the output is as defined.\n+!\n+\n+subroutine write_lines(fd)\n+  implicit none\n+  integer, intent(in) :: fd\n+  write(fd, '(A)') \"+ first\"\n+  write(fd, '(A)') \"-second line\"\n+  write(fd, '(A)') \"0now you know\"\n+  write(fd, '(A)') \"1this is the fourth line\"\n+  write(fd, '(A)') \"$finally we have a new challenger for the final line\"\n+  write(fd, '(A)') CHAR(0)//\"this is the end\"\n+  write(fd, '(A)') \" this is a plain old line\"\n+endsubroutine\n+\n+subroutine check_cc (cc, fname, expected)\n+  implicit none\n+  ! carraigecontrol type, file name to write to\n+  character(*), intent(in) :: cc, fname\n+  ! expected output\n+  character(*), intent(in) :: expected\n+\n+  ! read buffer, line number, unit, status\n+  character(len=:), allocatable :: buf\n+  integer :: i, fd, siz\n+  fd = 3\n+\n+  ! write lines using carriagecontrol setting\n+  open(unit=fd, file=fname, action='write', carriagecontrol=cc)\n+  call write_lines(fd)\n+  close(unit=fd)\n+\n+  open(unit=fd, file=fname, action='readwrite', &\n+       form='unformatted', access='stream')\n+  call fseek(fd, 0, 0)\n+  inquire(file=fname, size=siz)\n+  allocate(character(len=siz) :: buf)\n+  read(unit=fd, pos=1) buf\n+  if (buf .ne. expected) then\n+    print *, '=================> ',cc,' <================='\n+    print *, '*****  actual  *****'\n+    print *, buf\n+    print *, '***** expected *****'\n+    print *, expected\n+    deallocate(buf)\n+    close(unit=fd)\n+    call abort()\n+  else\n+    deallocate(buf)\n+    close(unit=fd, status='delete')\n+  endif\n+endsubroutine\n+\n+implicit none\n+\n+character(*), parameter :: fname  = 'dec_io_2.txt'\n+\n+!! In NONE mode, there are no line breaks between records.\n+character(*), parameter :: output_ccnone = &\n+  \"+ first\"//&\n+  \"-second line\"//&\n+  \"0now you know\"//&\n+  \"1this is the fourth line\"//&\n+  \"$finally we have a new challenger for the final line\"//&\n+  CHAR(0)//\"this is the end\"//&\n+  \" this is a plain old line\"\n+\n+!! In LIST mode, each record is terminated with a newline.\n+character(*), parameter :: output_cclist = &\n+  \"+ first\"//CHAR(10)//&\n+  \"-second line\"//CHAR(10)//&\n+  \"0now you know\"//CHAR(10)//&\n+  \"1this is the fourth line\"//CHAR(10)//&\n+  \"$finally we have a new challenger for the final line\"//CHAR(10)//&\n+  CHAR(0)//\"this is the end\"//CHAR(10)//&\n+  \" this is a plain old line\"//CHAR(10)\n+\n+!! In FORTRAN mode, the default record break is CR, and the first character\n+!! implies the start- and end-of-record formatting.\n+! '+' Overprinting: <text> CR\n+! '-' One line feed: NL <text> CR\n+! '0' Two line feeds: NL NL <text> CR\n+! '1' Next page: FF <text> CR\n+! '$' Prompting: NL <text>\n+!'\\0' Overprinting with no advance: <text>\n+!     Other: defaults to Overprinting <text> CR\n+character(*), parameter :: output_ccfort = \"\"//&\n+  \" first\"//CHAR(13)//&\n+  CHAR(10)//\"second line\"//CHAR(13)//&\n+  CHAR(10)//CHAR(10)//\"now you know\"//CHAR(13)//&\n+  CHAR(12)//\"this is the fourth line\"//CHAR(13)//&\n+  CHAR(10)//\"finally we have a new challenger for the final line\"//&\n+  \"this is the end\"//&\n+  CHAR(10)//\"this is a plain old line\"//CHAR(13)\n+\n+call check_cc('none',    fname, output_ccnone)\n+call check_cc('list',    fname, output_cclist)\n+call check_cc('fortran', fname, output_ccfort)\n+\n+end"}, {"sha": "d37961c735a10baabadb6d29d4830d15814b2399", "filename": "gcc/testsuite/gfortran.dg/dec_io_3.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_3.f90?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"\" }\n+!\n+! Test compile-time errors for DEC I/O intrinsics without -fdec.\n+!\n+\n+integer :: fd\n+open (unit=fd, carriagecontrol='cc') ! { dg-error \"is a DEC extension\" }\n+open (unit=fd, share='cc')           ! { dg-error \"is a DEC extension\" }\n+open (unit=fd, shared)               ! { dg-error \"is a DEC extension\" }\n+open (unit=fd, noshared)             ! { dg-error \"is a DEC extension\" }\n+open (unit=fd, readonly)             ! { dg-error \"is a DEC extension\" }\n+close (unit=fd, status='delete')\n+\n+end"}, {"sha": "9b8fbc9f7679dd51a01a3b320da62cd3dbc9e8e1", "filename": "gcc/testsuite/gfortran.dg/dec_io_4.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_4.f90?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-fdec\" }\n+!\n+! Test compile-time errors for DEC I/O intrinsics with -fdec.\n+!\n+\n+integer :: fd\n+open (unit=fd, readonly, action='read') ! these are okay\n+open (unit=fd, action='read', readonly)\n+open (unit=fd, readonly, action='write') ! { dg-error \"ACTION type conflicts\" }\n+open (unit=fd, action='readwrite', readonly) ! { dg-error \"ACTION type conflicts\" }\n+open (unit=fd, shared, shared)             ! { dg-error \"Duplicate SHARE\" }\n+open (unit=fd, noshared, shared)             ! { dg-error \"Duplicate SHARE\" }\n+open (unit=fd, share='denyrw', share='denynone') ! { dg-error \"Duplicate SHARE\" }\n+open (unit=fd, carriagecontrol='fortran', carriagecontrol='none') ! { dg-error \"Duplicate CARRIAGECONTROL\" }\n+\n+end"}, {"sha": "9d44c6e79742e50265783fe5318d3c455033e136", "filename": "gcc/testsuite/gfortran.dg/dec_io_5.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_5.f90?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run \"xfail *-*-*\" }\n+! { dg-options \"-fdec\" }\n+!\n+! Test that we get a run-time error for opening a READONLY file with\n+! ACTION='WRITE'.\n+!\n+\n+implicit none\n+\n+integer :: fd = 8\n+character(*), parameter :: f = \"test.txt\"\n+character(10), volatile :: c\n+c = 'write'\n+\n+open(unit=fd,file=f,action=c,readonly) ! XFAIL \"ACTION conflicts with READONLY\"\n+\n+end"}, {"sha": "a0c025680fbe7b9c6fc47967f0c8300bc3b2dad2", "filename": "gcc/testsuite/gfortran.dg/dec_io_6.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_io_6.f90?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run \"xfail *-*-*\" }\n+! { dg-options \"-fdec\" }\n+!\n+! Test that we get a run-time error for close-on-delete with READONLY.\n+!\n+\n+implicit none\n+\n+integer :: fd = 8\n+character(*), parameter :: f = \"test.txt\"\n+\n+open(unit=fd,file=f,action='read',readonly)\n+close(unit=fd,status='delete') ! XFAIL \"protected by READONLY\"\n+\n+end"}, {"sha": "107372340ed13103530d0dc05cf6ea96e10c74d5", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1,3 +1,31 @@\n+2016-10-26  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\t* libgfortran.h (IOPARM_OPEN_HAS_READONLY, IOPARM_OPEN_HAS_SHARE,\n+\tIOPARM_OPEN_HAS_CC): New for READONLY, SHARE, and CARRIAGECONTROL.\n+\t* io/close.c (st_close): Support READONLY.\n+\t* io/io.h (st_parameter_open, unit_flags): Support SHARE,\n+\tCARRIAGECONTROL, and READONLY.\n+\t* io/open.c (st_open): Ditto.\n+\t* io/transfer.c (data_transfer_init): Ditto.\n+\t* io/io.h (st_parameter_dt): New member 'cc' for CARRIAGECONTROL.\n+\t* io/write.c (write_check_cc, write_cc): New functions for\n+\tCARRIAGECONTROL.\n+\t* io/transfer.c (next_record_cc): Ditto.\n+\t* io/file_pos.c (st_endfile): Support SHARE and CARRIAGECONTROL.\n+\t* io/io.h (st_parameter_inquire): Ditto.\n+\t* io/open.c (edit_modes, new_unit): Ditto.\n+\t* io/inquire.c (inquire_via_unit, inquire_via_filename): Ditto.\n+\t* io/io.h (unit_share, unit_cc, cc_fortran, IOPARM_INQUIRE_HAS_SHARE,\n+\tIOPARM_INQUIRE_HAS_CC): New for SHARE and CARRIAGECONTROL.\n+\t* io/open.c (share_opt, cc_opt): Ditto.\n+\t* io/read.c (read_x): Support CARRIAGECONTROL.\n+\t* io/transfer.c (read_sf, next_record_r, next_record_w): Ditto.\n+\t* io/write.c (list_formatted_write_scalar, write_a): Ditto.\n+\t* io/unix.h (close_share): New prototype.\n+\t* io/unix.c (open_share, close_share): New functions to handle SHARE.\n+\t* io/unix.c (open_external): Handle READONLY. Call open_share.\n+\t* io/close.c (st_close): Call close_share.\n+\n 2016-10-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/77828"}, {"sha": "8fbfe8221704cd7ba2b9e39f8762a2648691c966", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -66,6 +66,8 @@ st_close (st_parameter_close *clp)\n   u = find_unit (clp->common.unit);\n   if (u != NULL)\n     {\n+      if (close_share (u) < 0)\n+\tgenerate_error (&clp->common, LIBERROR_OS, \"Problem in CLOSE\");\n       if (u->flags.status == STATUS_SCRATCH)\n \t{\n \t  if (status == CLOSE_KEEP)\n@@ -78,13 +80,19 @@ st_close (st_parameter_close *clp)\n       else\n \t{\n \t  if (status == CLOSE_DELETE)\n-            {\n+\t    {\n+\t      if (u->flags.readonly)\n+\t\tgenerate_warning (&clp->common, \"STATUS set to DELETE on CLOSE\"\n+\t\t\t\t  \" but file protected by READONLY specifier\");\n+\t      else\n+\t\t{\n #if HAVE_UNLINK_OPEN_FILE\n-\t      remove (u->filename);\n+\t\t  remove (u->filename);\n #else\n-\t      path = strdup (u->filename);\n+\t\t  path = strdup (u->filename);\n #endif\n-            }\n+\t\t}\n+\t    }\n \t}\n \n       close_unit (u);"}, {"sha": "6611a8daa63fd455f7fa8197d13d35dcddb9ab6a", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -362,6 +362,8 @@ st_endfile (st_parameter_filepos *fpp)\n \t  u_flags.sign = SIGN_UNSPECIFIED;\n \t  u_flags.status = STATUS_UNKNOWN;\n \t  u_flags.convert = GFC_CONVERT_NATIVE;\n+\t  u_flags.share = SHARE_UNSPECIFIED;\n+\t  u_flags.cc = CC_UNSPECIFIED;\n \n \t  opp.common = fpp->common;\n \t  opp.common.flags &= IOPARM_COMMON_MASK;"}, {"sha": "7e013e01e8f390658052d7b9993ef9e9bd619739", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -428,6 +428,58 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n     \n \t  cf_strcpy (iqp->iqstream, iqp->iqstream_len, p);\n \t}\n+\n+      if ((cf2 & IOPARM_INQUIRE_HAS_SHARE) != 0)\n+\t{\n+\t  if (u == NULL)\n+\t    p = \"UNKNOWN\";\n+\t  else\n+\t    switch (u->flags.share)\n+\t      {\n+\t\tcase SHARE_DENYRW:\n+\t\t  p = \"DENYRW\";\n+\t\t  break;\n+\t\tcase SHARE_DENYNONE:\n+\t\t  p = \"DENYNONE\";\n+\t\t  break;\n+\t\tcase SHARE_UNSPECIFIED:\n+\t\t  p = \"NODENY\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  internal_error (&iqp->common,\n+\t\t      \"inquire_via_unit(): Bad share\");\n+\t\t  break;\n+\t      }\n+\n+\t  cf_strcpy (iqp->share, iqp->share_len, p);\n+\t}\n+\n+      if ((cf2 & IOPARM_INQUIRE_HAS_CC) != 0)\n+\t{\n+\t  if (u == NULL)\n+\t    p = \"UNKNOWN\";\n+\t  else\n+\t    switch (u->flags.cc)\n+\t      {\n+\t\tcase CC_FORTRAN:\n+\t\t  p = \"FORTRAN\";\n+\t\t  break;\n+\t\tcase CC_LIST:\n+\t\t  p = \"LIST\";\n+\t\t  break;\n+\t\tcase CC_NONE:\n+\t\t  p = \"NONE\";\n+\t\t  break;\n+\t\tcase CC_UNSPECIFIED:\n+\t\t  p = \"UNKNOWN\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  internal_error (&iqp->common, \"inquire_via_unit(): Bad cc\");\n+\t\t  break;\n+\t      }\n+\n+\t  cf_strcpy (iqp->cc, iqp->cc_len, p);\n+\t}\n     }\n \n   if ((cf & IOPARM_INQUIRE_HAS_POSITION) != 0)\n@@ -671,6 +723,12 @@ inquire_via_filename (st_parameter_inquire *iqp)\n \n       if ((cf2 & IOPARM_INQUIRE_HAS_IQSTREAM) != 0)\n \tcf_strcpy (iqp->iqstream, iqp->iqstream_len, \"UNKNOWN\");\n+\n+      if ((cf2 & IOPARM_INQUIRE_HAS_SHARE) != 0)\n+\tcf_strcpy (iqp->share, iqp->share_len, \"UNKNOWN\");\n+\n+      if ((cf2 & IOPARM_INQUIRE_HAS_CC) != 0)\n+\tcf_strcpy (iqp->cc, iqp->cc_len, \"UNKNOWN\");\n     }\n \n   if ((cf & IOPARM_INQUIRE_HAS_POSITION) != 0)"}, {"sha": "7a548497af9dcbe954dca45e19f9c63638bfa1d9", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -268,10 +268,36 @@ typedef enum\n { ASYNC_YES, ASYNC_NO, ASYNC_UNSPECIFIED }\n unit_async;\n \n+typedef enum\n+{ SHARE_DENYRW, SHARE_DENYNONE,\n+  SHARE_UNSPECIFIED\n+}\n+unit_share;\n+\n+typedef enum\n+{ CC_LIST, CC_FORTRAN, CC_NONE,\n+  CC_UNSPECIFIED\n+}\n+unit_cc;\n+\n+/* End-of-record types for CC_FORTRAN.  */\n+typedef enum\n+{ CCF_DEFAULT=0x0,\n+  CCF_OVERPRINT=0x1,\n+  CCF_ONE_LF=0x2,\n+  CCF_TWO_LF=0x4,\n+  CCF_PAGE_FEED=0x8,\n+  CCF_PROMPT=0x10,\n+  CCF_OVERPRINT_NOA=0x20,\n+} /* 6 bits */\n+cc_fortran;\n+\n typedef enum\n { SIGN_S, SIGN_SS, SIGN_SP }\n unit_sign_s;\n \n+/* Make sure to keep st_parameter_* in sync with gcc/fortran/ioparm.def.  */\n+\n #define CHARACTER1(name) \\\n \t      char * name; \\\n \t      gfc_charlen_type name ## _len\n@@ -299,6 +325,9 @@ typedef struct\n   CHARACTER1 (sign);\n   CHARACTER2 (asynchronous);\n   GFC_INTEGER_4 *newunit;\n+  GFC_INTEGER_4 readonly;\n+  CHARACTER2 (cc);\n+  CHARACTER1 (share);\n }\n st_parameter_open;\n \n@@ -352,6 +381,8 @@ st_parameter_filepos;\n #define IOPARM_INQUIRE_HAS_SIZE\t\t(1 << 6)\n #define IOPARM_INQUIRE_HAS_ID\t\t(1 << 7)\n #define IOPARM_INQUIRE_HAS_IQSTREAM\t(1 << 8)\n+#define IOPARM_INQUIRE_HAS_SHARE\t(1 << 9)\n+#define IOPARM_INQUIRE_HAS_CC\t\t(1 << 10)\n \n typedef struct\n {\n@@ -386,6 +417,8 @@ typedef struct\n   GFC_IO_INT *size;\n   GFC_INTEGER_4 *id;\n   CHARACTER1 (iqstream);\n+  CHARACTER2 (share);\n+  CHARACTER1 (cc);\n }\n st_parameter_inquire;\n \n@@ -526,6 +559,21 @@ typedef struct st_parameter_dt\n \t  GFC_IO_INT not_used; /* Needed for alignment. */\n \t  formatted_dtio fdtio_ptr;\n \t  unformatted_dtio ufdtio_ptr;\n+\t  /* With CC_FORTRAN, the first character of a record determines the\n+\t     style of record end (and start) to use. We must mark down the type\n+\t     when we write first in write_a so we remember the end type later in\n+\t     next_record_w.  */\n+\t  struct\n+\t    {\n+\t      unsigned type : 6; /* See enum cc_fortran.  */\n+\t      unsigned len  : 2; /* Always 0, 1, or 2.  */\n+\t      /* The union is updated after start-of-record is written.  */\n+\t      union\n+\t\t{\n+\t\t  char start; /* Output character for start of record.  */\n+\t\t  char end;   /* Output character for end of record.  */\n+\t\t} u;\n+\t    } cc;\n \t} p;\n       /* This pad size must be equal to the pad_size declared in\n \t trans-io.c (gfc_build_io_library_fndecls).  The above structure\n@@ -571,6 +619,9 @@ typedef struct\n   unit_round round;\n   unit_sign sign;\n   unit_async async;\n+  unit_share share;\n+  unit_cc cc;\n+  int readonly;\n }\n unit_flags;\n "}, {"sha": "b0f1009deeb8be92ab138f0044e5f17305bb6adf", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -52,6 +52,21 @@ static const st_option action_opt[] =\n   { NULL, 0}\n };\n \n+static const st_option share_opt[] =\n+{\n+  { \"denyrw\", SHARE_DENYRW },\n+  { \"denynone\", SHARE_DENYNONE },\n+  { NULL, 0}\n+};\n+\n+static const st_option cc_opt[] =\n+{\n+  { \"list\", CC_LIST },\n+  { \"fortran\", CC_FORTRAN },\n+  { \"none\", CC_NONE },\n+  { NULL, 0}\n+};\n+\n static const st_option blank_opt[] =\n {\n   { \"null\", BLANK_NULL},\n@@ -195,6 +210,14 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n     generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot change ACTION parameter in OPEN statement\");\n \n+  if (flags->share != SHARE_UNSPECIFIED && u->flags.share != flags->share)\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n+\t\t    \"Cannot change SHARE parameter in OPEN statement\");\n+\n+  if (flags->cc != CC_UNSPECIFIED && u->flags.cc != flags->cc)\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n+\t\t  \"Cannot change CARRIAGECONTROL parameter in OPEN statement\");\n+\n   /* Status must be OLD if present.  */\n \n   if (flags->status != STATUS_UNSPECIFIED && flags->status != STATUS_OLD &&\n@@ -330,6 +353,16 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   if (flags->status == STATUS_UNSPECIFIED)\n     flags->status = STATUS_UNKNOWN;\n \n+  if (flags->cc == CC_UNSPECIFIED)\n+    flags->cc = flags->form == FORM_UNFORMATTED ? CC_NONE : CC_LIST;\n+  else if (flags->form == FORM_UNFORMATTED && flags->cc != CC_NONE)\n+    {\n+      generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t  \"CARRIAGECONTROL parameter conflicts with UNFORMATTED form in \"\n+\t  \"OPEN statement\");\n+      goto fail;\n+    }\n+\n   /* Checks.  */\n \n   if (flags->delim != DELIM_UNSPECIFIED\n@@ -695,6 +728,7 @@ st_open (st_parameter_open *opp)\n   library_start (&opp->common);\n \n   /* Decode options.  */\n+  flags.readonly = !(cf & IOPARM_OPEN_HAS_READONLY) ? 0 : opp->readonly;\n \n   flags.access = !(cf & IOPARM_OPEN_HAS_ACCESS) ? ACCESS_UNSPECIFIED :\n     find_option (&opp->common, opp->access, opp->access_len,\n@@ -704,6 +738,14 @@ st_open (st_parameter_open *opp)\n     find_option (&opp->common, opp->action, opp->action_len,\n \t\t action_opt, \"Bad ACTION parameter in OPEN statement\");\n \n+  flags.cc = !(cf & IOPARM_OPEN_HAS_CC) ? CC_UNSPECIFIED :\n+    find_option (&opp->common, opp->cc, opp->cc_len,\n+\t\t cc_opt, \"Bad CARRIAGECONTROL parameter in OPEN statement\");\n+\n+  flags.share = !(cf & IOPARM_OPEN_HAS_SHARE) ? SHARE_UNSPECIFIED :\n+    find_option (&opp->common, opp->share, opp->share_len,\n+\t\t share_opt, \"Bad SHARE parameter in OPEN statement\");\n+\n   flags.blank = !(cf & IOPARM_OPEN_HAS_BLANK) ? BLANK_UNSPECIFIED :\n     find_option (&opp->common, opp->blank, opp->blank_len,\n \t\t blank_opt, \"Bad BLANK parameter in OPEN statement\");\n@@ -792,6 +834,11 @@ st_open (st_parameter_open *opp)\n     generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot use POSITION with direct access files\");\n \n+  if (flags.readonly\n+      && flags.action != ACTION_UNSPECIFIED && flags.action != ACTION_READ)\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n+\t\t    \"ACTION conflicts with READONLY in OPEN statement\");\n+\n   if (flags.access == ACCESS_APPEND)\n     {\n       if (flags.position != POSITION_UNSPECIFIED"}, {"sha": "23b6f644429331d31dc85c6b3d5fee19c49a61f1", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1256,7 +1256,8 @@ read_x (st_parameter_dt *dtp, int n)\n       q = fbuf_getc (dtp->u.p.current_unit);\n       if (q == EOF)\n \tbreak;\n-      else if (q == '\\n' || q == '\\r')\n+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE\n+\t       && (q == '\\n' || q == '\\r'))\n \t{\n \t  /* Unexpected end of line. Set the position.  */\n \t  dtp->u.p.sf_seen_eor = 1;"}, {"sha": "b8eb5eda20f6c249014c627dac5b67769d04bd4f", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -316,7 +316,8 @@ read_sf (st_parameter_dt *dtp, int * length)\n       q = fbuf_getc (dtp->u.p.current_unit);\n       if (q == EOF)\n \tbreak;\n-      else if (q == '\\n' || q == '\\r')\n+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE\n+\t       && (q == '\\n' || q == '\\r'))\n \t{\n \t  /* Unexpected end of line. Set the position.  */\n \t  dtp->u.p.sf_seen_eor = 1;\n@@ -2598,6 +2599,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   dtp->u.p.ionml = ionml;\n   dtp->u.p.mode = read_flag ? READING : WRITING;\n \n+  dtp->u.p.cc.len = 0;\n+\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n@@ -2636,6 +2639,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       u_flags.async = ASYNC_UNSPECIFIED;\n       u_flags.round = ROUND_UNSPECIFIED;\n       u_flags.sign = SIGN_UNSPECIFIED;\n+      u_flags.share = SHARE_UNSPECIFIED;\n+      u_flags.cc = CC_UNSPECIFIED;\n+      u_flags.readonly = 0;\n \n       u_flags.status = STATUS_UNKNOWN;\n \n@@ -3349,7 +3355,7 @@ next_record_r (st_parameter_dt *dtp, int done)\n \t    }\n \t  break;\n \t}\n-      else\n+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE)\n \t{\n \t  do\n \t    {\n@@ -3531,6 +3537,30 @@ sset (stream * s, int c, ssize_t nbyte)\n }\n \n \n+/* Finish up a record according to the legacy carriagecontrol type, based\n+   on the first character in the record.  */\n+\n+static void\n+next_record_cc (st_parameter_dt *dtp)\n+{\n+  /* Only valid with CARRIAGECONTROL=FORTRAN.  */\n+  if (dtp->u.p.current_unit->flags.cc != CC_FORTRAN)\n+    return;\n+\n+  fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n+  if (dtp->u.p.cc.len > 0)\n+    {\n+      char * p = fbuf_alloc (dtp->u.p.current_unit, dtp->u.p.cc.len);\n+      if (!p)\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n+\n+      /* Output CR for the first character with default CC setting.  */\n+      *(p++) = dtp->u.p.cc.u.end;\n+      if (dtp->u.p.cc.len > 1)\n+\t*p = dtp->u.p.cc.u.end;\n+    }\n+}\n+\n /* Position to the next record in write mode.  */\n \n static void\n@@ -3677,21 +3707,30 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t}\n \t    }\n \t}\n+      /* Handle legacy CARRIAGECONTROL line endings.  */\n+      else if (dtp->u.p.current_unit->flags.cc == CC_FORTRAN)\n+\tnext_record_cc (dtp);\n       else\n \t{\n+\t  /* Skip newlines for CC=CC_NONE.  */\n+\t  const int len = (dtp->u.p.current_unit->flags.cc == CC_NONE)\n+\t    ? 0\n #ifdef HAVE_CRLF\n-\t  const int len = 2;\n+\t    : 2;\n #else\n-\t  const int len = 1;\n+\t    : 1;\n #endif\n-          fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n-          char * p = fbuf_alloc (dtp->u.p.current_unit, len);\n-          if (!p)\n-            goto io_error;\n+\t  fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n+\t  if (dtp->u.p.current_unit->flags.cc != CC_NONE)\n+\t    {\n+\t      char * p = fbuf_alloc (dtp->u.p.current_unit, len);\n+\t      if (!p)\n+\t\tgoto io_error;\n #ifdef HAVE_CRLF\n-          *(p++) = '\\r';\n+\t      *(p++) = '\\r';\n #endif\n-          *p = '\\n';\n+\t      *p = '\\n';\n+\t    }\n \t  if (is_stream_io (dtp))\n \t    {\n \t      dtp->u.p.current_unit->strm_pos += len;"}, {"sha": "6fa264c4e5c4129e03e460b2ef7297242969bd7b", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -652,6 +652,8 @@ init_units (void)\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n       u->flags.round = ROUND_UNSPECIFIED;\n+      u->flags.share = SHARE_UNSPECIFIED;\n+      u->flags.cc = CC_LIST;\n \n       u->recl = options.default_recl;\n       u->endfile = NO_ENDFILE;\n@@ -681,6 +683,8 @@ init_units (void)\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n       u->flags.round = ROUND_UNSPECIFIED;\n+      u->flags.share = SHARE_UNSPECIFIED;\n+      u->flags.cc = CC_LIST;\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;\n@@ -709,6 +713,8 @@ init_units (void)\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n       u->flags.round = ROUND_UNSPECIFIED;\n+      u->flags.share = SHARE_UNSPECIFIED;\n+      u->flags.cc = CC_LIST;\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;"}, {"sha": "5301b8478405e994ba20b3f1b93dfbd7cc82a01c", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -1425,6 +1425,56 @@ regular_file2 (const char *path, st_parameter_open *opp, unit_flags *flags)\n }\n \n \n+/* Lock the file, if necessary, based on SHARE flags.  */\n+\n+#if defined(HAVE_FCNTL) && defined(F_SETLK) && defined(F_UNLCK)\n+static int\n+open_share (st_parameter_open *opp, int fd, unit_flags *flags)\n+{\n+  int r = 0;\n+  struct flock f;\n+  if (fd == STDOUT_FILENO || fd == STDERR_FILENO || fd == STDIN_FILENO)\n+    return 0;\n+\n+  f.l_start = 0;\n+  f.l_len = 0;\n+  f.l_whence = SEEK_SET;\n+\n+  switch (flags->share)\n+  {\n+    case SHARE_DENYNONE:\n+      f.l_type = F_RDLCK;\n+      r = fcntl (fd, F_SETLK, &f);\n+      break;\n+    case SHARE_DENYRW:\n+      /* Must be writable to hold write lock.  */\n+      if (flags->action == ACTION_READ)\n+\t{\n+\t  generate_error (&opp->common, LIBERROR_BAD_ACTION,\n+\t      \"Cannot set write lock on file opened for READ\");\n+\t  return -1;\n+\t}\n+      f.l_type = F_WRLCK;\n+      r = fcntl (fd, F_SETLK, &f);\n+      break;\n+    case SHARE_UNSPECIFIED:\n+    default:\n+      break;\n+  }\n+\n+  return r;\n+}\n+#else\n+static int\n+open_share (st_parameter_open *opp __attribute__ ((unused)),\n+    int fd __attribute__ ((unused)),\n+    unit_flags *flags __attribute__ ((unused)))\n+{\n+  return 0;\n+}\n+#endif /* defined(HAVE_FCNTL) ... */\n+\n+\n /* Wrapper around regular_file2, to make sure we free the path after\n    we're done.  */\n \n@@ -1450,7 +1500,7 @@ open_external (st_parameter_open *opp, unit_flags *flags)\n     {\n       fd = tempfile (opp);\n       if (flags->action == ACTION_UNSPECIFIED)\n-\tflags->action = ACTION_READWRITE;\n+\tflags->action = flags->readonly ? ACTION_READ : ACTION_READWRITE;\n \n #if HAVE_UNLINK_OPEN_FILE\n       /* We can unlink scratch files now and it will go away when closed. */\n@@ -1472,6 +1522,9 @@ open_external (st_parameter_open *opp, unit_flags *flags)\n     return NULL;\n   fd = fix_fd (fd);\n \n+  if (open_share (opp, fd, flags) < 0)\n+    return NULL;\n+\n   return fd_to_stream (fd, flags->form == FORM_UNFORMATTED);\n }\n \n@@ -1752,6 +1805,40 @@ flush_all_units (void)\n }\n \n \n+/* Unlock the unit if necessary, based on SHARE flags.  */\n+\n+int\n+close_share (gfc_unit *u __attribute__ ((unused)))\n+{\n+  int r = 0;\n+#if defined(HAVE_FCNTL) && defined(F_SETLK) && defined(F_UNLCK)\n+  unix_stream *s = (unix_stream *) u->s;\n+  int fd = s->fd;\n+  struct flock f;\n+\n+  switch (u->flags.share)\n+  {\n+    case SHARE_DENYRW:\n+    case SHARE_DENYNONE:\n+      if (fd != STDOUT_FILENO && fd != STDERR_FILENO && fd != STDIN_FILENO)\n+\t{\n+\t  f.l_start = 0;\n+\t  f.l_len = 0;\n+\t  f.l_whence = SEEK_SET;\n+\t  f.l_type = F_UNLCK;\n+\t  r = fcntl (fd, F_SETLK, &f);\n+\t}\n+      break;\n+    case SHARE_UNSPECIFIED:\n+    default:\n+      break;\n+  }\n+\n+#endif\n+  return r;\n+}\n+\n+\n /* file_exists()-- Returns nonzero if the current filename exists on\n  * the system */\n "}, {"sha": "3d4de2614941f578a3ed9adde360e4c1578a996b", "filename": "libgfortran/io/unix.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.h?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -141,6 +141,9 @@ internal_proto(compare_file_filename);\n extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);\n internal_proto(find_file);\n \n+extern int close_share (gfc_unit *);\n+internal_proto(close_share);\n+\n extern int file_exists (const char *file, gfc_charlen_type file_len);\n internal_proto(file_exists);\n "}, {"sha": "c8bba3c0bb8774c57e7544149e9d4d1373a5c2d4", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 140, "deletions": 1, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -228,6 +228,138 @@ write_utf8_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n }\n \n \n+/* Check the first character in source if we are using CC_FORTRAN\n+   and set the cc.type appropriately.   The cc.type is used later by write_cc\n+   to determine the output start-of-record, and next_record_cc to determine the\n+   output end-of-record.\n+   This function is called before the output buffer is allocated, so alloc_len\n+   is set to the appropriate size to allocate.  */\n+\n+static void\n+write_check_cc (st_parameter_dt *dtp, const char **source, int *alloc_len)\n+{\n+  /* Only valid for CARRIAGECONTROL=FORTRAN.  */\n+  if (dtp->u.p.current_unit->flags.cc != CC_FORTRAN\n+      || alloc_len == NULL || source == NULL)\n+    return;\n+\n+  /* Peek at the first character.  */\n+  int c = (*alloc_len > 0) ? (*source)[0] : EOF;\n+  if (c != EOF)\n+    {\n+      /* The start-of-record character which will be printed.  */\n+      dtp->u.p.cc.u.start = '\\n';\n+      /* The number of characters to print at the start-of-record.\n+\t len  > 1 means copy the SOR character multiple times.\n+\t len == 0 means no SOR will be output.  */\n+      dtp->u.p.cc.len = 1;\n+\n+      switch (c)\n+\t{\n+\tcase '+':\n+\t  dtp->u.p.cc.type = CCF_OVERPRINT;\n+\t  dtp->u.p.cc.len = 0;\n+\t  break;\n+\tcase '-':\n+\t  dtp->u.p.cc.type = CCF_ONE_LF;\n+\t  dtp->u.p.cc.len = 1;\n+\t  break;\n+\tcase '0':\n+\t  dtp->u.p.cc.type = CCF_TWO_LF;\n+\t  dtp->u.p.cc.len = 2;\n+\t  break;\n+\tcase '1':\n+\t  dtp->u.p.cc.type = CCF_PAGE_FEED;\n+\t  dtp->u.p.cc.len = 1;\n+\t  dtp->u.p.cc.u.start = '\\f';\n+\t  break;\n+\tcase '$':\n+\t  dtp->u.p.cc.type = CCF_PROMPT;\n+\t  dtp->u.p.cc.len = 1;\n+\t  break;\n+\tcase '\\0':\n+\t  dtp->u.p.cc.type = CCF_OVERPRINT_NOA;\n+\t  dtp->u.p.cc.len = 0;\n+\t  break;\n+\tdefault:\n+\t  /* In the default case we copy ONE_LF.  */\n+\t  dtp->u.p.cc.type = CCF_DEFAULT;\n+\t  dtp->u.p.cc.len = 1;\n+\t  break;\n+      }\n+\n+      /* We add n-1 to alloc_len so our write buffer is the right size.\n+\t We are replacing the first character, and possibly prepending some\n+\t additional characters.  Note for n==0, we actually subtract one from\n+\t alloc_len, which is correct, since that character is skipped.  */\n+      if (*alloc_len > 0)\n+\t{\n+\t  *source += 1;\n+\t  *alloc_len += dtp->u.p.cc.len - 1;\n+\t}\n+      /* If we have no input, there is no first character to replace.  Make\n+\t sure we still allocate enough space for the start-of-record string.  */\n+      else\n+\t*alloc_len = dtp->u.p.cc.len;\n+    }\n+}\n+\n+\n+/* Write the start-of-record character(s) for CC_FORTRAN.\n+   Also adjusts the 'cc' struct to contain the end-of-record character\n+   for next_record_cc.\n+   The source_len is set to the remaining length to copy from the source,\n+   after the start-of-record string was inserted.  */\n+\n+static char *\n+write_cc (st_parameter_dt *dtp, char *p, int *source_len)\n+{\n+  /* Only valid for CARRIAGECONTROL=FORTRAN.  */\n+  if (dtp->u.p.current_unit->flags.cc != CC_FORTRAN || source_len == NULL)\n+    return p;\n+\n+  /* Write the start-of-record string to the output buffer.  Note that len is\n+     never more than 2.  */\n+  if (dtp->u.p.cc.len > 0)\n+    {\n+      *(p++) = dtp->u.p.cc.u.start;\n+      if (dtp->u.p.cc.len > 1)\n+\t  *(p++) = dtp->u.p.cc.u.start;\n+\n+      /* source_len comes from write_check_cc where it is set to the full\n+\t allocated length of the output buffer. Therefore we subtract off the\n+\t length of the SOR string to obtain the remaining source length.  */\n+      *source_len -= dtp->u.p.cc.len;\n+    }\n+\n+  /* Common case.  */\n+  dtp->u.p.cc.len = 1;\n+  dtp->u.p.cc.u.end = '\\r';\n+\n+  /* Update end-of-record character for next_record_w.  */\n+  switch (dtp->u.p.cc.type)\n+    {\n+    case CCF_PROMPT:\n+    case CCF_OVERPRINT_NOA:\n+      /* No end-of-record.  */\n+      dtp->u.p.cc.len = 0;\n+      dtp->u.p.cc.u.end = '\\0';\n+      break;\n+    case CCF_OVERPRINT:\n+    case CCF_ONE_LF:\n+    case CCF_TWO_LF:\n+    case CCF_PAGE_FEED:\n+    case CCF_DEFAULT:\n+    default:\n+      /* Carriage return.  */\n+      dtp->u.p.cc.len = 1;\n+      dtp->u.p.cc.u.end = '\\r';\n+      break;\n+    }\n+\n+  return p;\n+}\n+\n void\n write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n@@ -296,10 +428,16 @@ write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n   else\n     {\n #endif\n+      if (dtp->u.p.current_unit->flags.cc == CC_FORTRAN)\n+\twrite_check_cc (dtp, &source, &wlen);\n+\n       p = write_block (dtp, wlen);\n       if (p == NULL)\n \treturn;\n \n+      if (dtp->u.p.current_unit->flags.cc == CC_FORTRAN)\n+\tp = write_cc (dtp, p, &wlen);\n+\n       if (unlikely (is_char4_unit (dtp)))\n \t{\n \t  gfc_char4_t *p4 = (gfc_char4_t *) p;\n@@ -1726,7 +1864,8 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   if (dtp->u.p.first_item)\n     {\n       dtp->u.p.first_item = 0;\n-      write_char (dtp, ' ');\n+      if (dtp->u.p.current_unit->flags.cc != CC_FORTRAN)\n+\twrite_char (dtp, ' ');\n     }\n   else\n     {"}, {"sha": "b9f24715daae5680ff47ed7b9d28e5c97dd38ea1", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef33d44629066e33ffdc46014374a3ef5c5f009/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=0ef33d44629066e33ffdc46014374a3ef5c5f009", "patch": "@@ -609,6 +609,7 @@ st_parameter_common;\n \n #define IOPARM_COMMON_MASK              ((1 << 7) - 1)\n \n+/* Make sure to keep in sync with io/io.h (st_parameter_open).  */\n #define IOPARM_OPEN_HAS_RECL_IN         (1 << 7)\n #define IOPARM_OPEN_HAS_FILE            (1 << 8)\n #define IOPARM_OPEN_HAS_STATUS          (1 << 9)\n@@ -626,6 +627,9 @@ st_parameter_common;\n #define IOPARM_OPEN_HAS_SIGN\t\t(1 << 21)\n #define IOPARM_OPEN_HAS_ASYNCHRONOUS\t(1 << 22)\n #define IOPARM_OPEN_HAS_NEWUNIT\t\t(1 << 23)\n+#define IOPARM_OPEN_HAS_READONLY\t(1 << 24)\n+#define IOPARM_OPEN_HAS_CC              (1 << 25)\n+#define IOPARM_OPEN_HAS_SHARE           (1 << 26)\n \n /* library start function and end macro.  These can be expanded if needed\n    in the future.  cmp is st_parameter_common *cmp  */"}]}