{"sha": "f6288c243153b97fb009a53a927c60dc30d4dd84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyODhjMjQzMTUzYjk3ZmIwMDlhNTNhOTI3YzYwZGMzMGQ0ZGQ4NA==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-05-07T23:16:23Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2016-05-07T23:16:23Z"}, "message": "re PR fortran/56226 (Add support for DEC UNION and MAP extensions)\n\n2016-05-07  Fritz Reese  <fritzoreese@gmail.com>\n\n\tPR fortran/56226\n\t* module.c (dt_upper_string): Rename to gfc_dt_upper_string\n\t(dt_lower_string): Likewise.\n\t* gfortran.h: Make new gfc_dt_upper/lower_string global.\n\t* class.c: Use gfc_dt_upper_string.\n\t* decl.c: Likewise.\n\t* symbol.c: Likewise.\n\t* resolve.c (resolve_component): New function.\n\t(resolve_fl_derived0): Move component loop code to resolve_component.\n\t* parse.c (check_component): New function.\n\t(parse_derived): Move loop code to check_component.\n\t* lang.opt, invoke.texi, options.c : New option -fdec-structure.\n\t* libgfortran.h (bt): New basic type BT_UNION.\n\t* gfortran.h (gfc_option): New option -fdec-structure.\n\t(gfc_get_union_type, gfc_compare_union_types): New prototypes.\n\t(gfc_bt_struct, gfc_fl_struct, case_bt_struct, case_fl_struct): New\n\tmacros.\n\t(gfc_find_component): Change prototype.\n\t* match.h (gfc_match_member_sep, gfc_match_map, gfc_match_union,\n\tgfc_match_structure_decl): New prototypes.\n\t* parse.h (gfc_comp_struct): New macro.\n\t* symbol.c (gfc_find_component): Search for components in nested unions\n\t* class.c (insert_component_ref, gfc_add_component_ref, add_proc_comp,\n\tcopy_vtab_proc_comps): Update calls to gfc_find_component.\n\t* primary.c (gfc_convert_to_structure_constructor): Likewise.\n\t* symbol.c (gfc_add_component): Likewise.\n\t* resolve.c (resolve_typebound_function, resolve_typebound_subroutine,\n\tresolve_typebound_procedure, resolve_component, resolve_fl_derived):\n\tLikewise.\n\t* expr.c (get_union_init, component_init): New functions.\n\t* decl.c (match_clist_expr, match_record_decl, get_struct_decl,\n\tgfc_match_map, gfc_match_union, gfc_match_structure_decl): Likewise.\n\t* interface.c (compare_components, gfc_compare_union_types): Likewise.\n\t* match.c (gfc_match_member_sep): Likewise.\n\t* parse.c (check_component, parse_union, parse_struct_map): Likewise.\n\t* resolve.c (resolve_fl_struct): Likewise.\n\t* symbol.c (find_union_component): Likewise.\n\t* trans-types.c (gfc_get_union_type): Likewise.\n\t* parse.c (parse_derived): Use new functions.\n\t* interface.c (gfc_compare_derived_types, gfc_compare_types): Likewise.\n\t* expr.c (gfc_default_initializer): Likewise.\n\t* gfortran.texi: Support for DEC structures, unions, and maps.\n\t* gfortran.h (gfc_statement, sym_flavor): Likewise.\n\t* check.c (gfc_check_kill_sub): Likewise.\n\t* expr.c (gfc_copy_expr, simplify_const_ref,\n\tgfc_has_default_initializer): Likewise.\n\t* decl.c (build_sym, match_data_constant, add_init_expr_to_sym,\n\tmatch_pointer_init, build_struct, variable_decl,\n\tgfc_match_decl_type_spec, gfc_mach_data-decl, gfc_match_entry,\n\tgfc_match_end, gfc_match_derived_decl): Likewise.\n\t* interface.c (check_interface0, check_interface1,\n\tgfc_search_interface): Likewise.\n\t* misc.c (gfc_basic_typename, gfc_typename): Likewise.\n\t* module.c (add_true_name, build_tnt, bt_types, mio_typespec,\n\tfix_mio_expr, load_needed, mio_symbol, read_module, write_symbol,\n\tgfc_get_module_backend_decl): Likewise.\n\t* parse.h (gfc_compile_state): Likewise.\n\t* parse.c (decode_specification_statement, decode_statement,\n\tgfc_ascii_statement, verify_st_order, parse_spec): Likewise.\n\t* primary.c (gfc_match_varspec, gfc_match_structure_constructor,\n\tgfc_match_rvalue, match_variable): Likewise.\n\t* resolve.c (find_arglists, resolve_structure_cons,\n\tis_illegal_recursion, resolve_generic_f, get_declared_from_expr,\n\tresolve_typebound_subroutine, resolve_allocate_expr,\n\tnonscalar_typebound_assign, generate_component_assignments,\n\tresolve_fl_variable_derived, check_defined_assignments,\n\tresolve_component, resolve_symbol, resolve_equivalence_derived):\n\tLikewise.\n\t* symbol.c (flavors, check_conflict, gfc_add_flavor, gfc_use_derived,\n\tgfc_restore_last_undo_checkpoint, gfc_type_compatible,\n\tgfc_find_dt_in_generic): Likewise.\n\t* trans-decl.c (gfc_get_module_backend_decl, create_function_arglist,\n\tgfc_create_module_variable, check_constant_initializer): Likewise.\n\t* trans-expr.c (gfc_conv_component_ref, gfc_conv_initializer,\n\tgfc_trans_alloc_subarray_assign, gfc_trans_subcomponent_assign,\n\tgfc_conv_structure, gfc_trans_scalar_assign, copyable_array_p):\n\tLikewise.\n\t* trans-io.c (transfer_namelist_element, transfer_expr,\n\tgfc_trans_transfer): Likewise.\n\t* trans-stmt.c (gfc_trans_deallocate): Likewise.\n\t* trans-types.c (gfc_typenode_for_spec, gfc_copy_dt_decls_ifequal,\n\tgfc_get_derived_type): Likewise.\n\n2016-05-07  Fritz Reese  <fritzoreese@gmail.com>\n\n\tPR fortran/56226\n\t* gfortran.dg/dec_structure_1.f90: New testcase.\n\t* gfortran.dg/dec_structure_2.f90: Ditto.\n\t* gfortran.dg/dec_structure_3.f90: Ditto.\n\t* gfortran.dg/dec_structure_4.f90: Ditto.\n\t* gfortran.dg/dec_structure_5.f90: Ditto.\n\t* gfortran.dg/dec_structure_6.f90: Ditto.\n\t* gfortran.dg/dec_structure_7.f90: Ditto.\n\t* gfortran.dg/dec_structure_8.f90: Ditto.\n\t* gfortran.dg/dec_structure_9.f90: Ditto.\n\t* gfortran.dg/dec_structure_10.f90: Ditto.\n\t* gfortran.dg/dec_structure_11.f90: Ditto.\n\t* gfortran.dg/dec_union_1.f90: Ditto.\n\t* gfortran.dg/dec_union_2.f90: Ditto.\n\t* gfortran.dg/dec_union_3.f90: Ditto.\n\t* gfortran.dg/dec_union_4.f90: Ditto.\n\t* gfortran.dg/dec_union_5.f90: Ditto.\n\t* gfortran.dg/dec_union_6.f90: Ditto.\n\t* gfortran.dg/dec_union_7.f90: Ditto.\n\nFrom-SVN: r235999", "tree": {"sha": "a65661cab4eb4b920474fe382dad70d9c34d6756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a65661cab4eb4b920474fe382dad70d9c34d6756"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6288c243153b97fb009a53a927c60dc30d4dd84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6288c243153b97fb009a53a927c60dc30d4dd84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6288c243153b97fb009a53a927c60dc30d4dd84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6288c243153b97fb009a53a927c60dc30d4dd84/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c76623e712f6dda96c179a6f0a04f5b62df30cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76623e712f6dda96c179a6f0a04f5b62df30cef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c76623e712f6dda96c179a6f0a04f5b62df30cef"}], "stats": {"total": 4265, "additions": 3443, "deletions": 822}, "files": [{"sha": "bad524c82ea879385ae08a4a6893f9d5cf8aaa6c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -1,3 +1,88 @@\n+2016-05-07  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tPR fortran/56226\n+\t* module.c (dt_upper_string): Rename to gfc_dt_upper_string\n+\t(dt_lower_string): Likewise.\n+\t* gfortran.h: Make new gfc_dt_upper/lower_string global.\n+\t* class.c: Use gfc_dt_upper_string.\n+\t* decl.c: Likewise.\n+\t* symbol.c: Likewise.\n+\t* resolve.c (resolve_component): New function.\n+\t(resolve_fl_derived0): Move component loop code to resolve_component.\n+\t* parse.c (check_component): New function.\n+\t(parse_derived): Move loop code to check_component.\n+\t* lang.opt, invoke.texi, options.c : New option -fdec-structure.\n+\t* libgfortran.h (bt): New basic type BT_UNION.\n+\t* gfortran.h (gfc_option): New option -fdec-structure.\n+\t(gfc_get_union_type, gfc_compare_union_types): New prototypes.\n+\t(gfc_bt_struct, gfc_fl_struct, case_bt_struct, case_fl_struct): New\n+\tmacros.\n+\t(gfc_find_component): Change prototype.\n+\t* match.h (gfc_match_member_sep, gfc_match_map, gfc_match_union,\n+\tgfc_match_structure_decl): New prototypes.\n+\t* parse.h (gfc_comp_struct): New macro.\n+\t* symbol.c (gfc_find_component): Search for components in nested unions\n+\t* class.c (insert_component_ref, gfc_add_component_ref, add_proc_comp,\n+\tcopy_vtab_proc_comps): Update calls to gfc_find_component.\n+\t* primary.c (gfc_convert_to_structure_constructor): Likewise.\n+\t* symbol.c (gfc_add_component): Likewise.\n+\t* resolve.c (resolve_typebound_function, resolve_typebound_subroutine,\n+\tresolve_typebound_procedure, resolve_component, resolve_fl_derived):\n+\tLikewise.\n+\t* expr.c (get_union_init, component_init): New functions.\n+\t* decl.c (match_clist_expr, match_record_decl, get_struct_decl,\n+\tgfc_match_map, gfc_match_union, gfc_match_structure_decl): Likewise.\n+\t* interface.c (compare_components, gfc_compare_union_types): Likewise.\n+\t* match.c (gfc_match_member_sep): Likewise.\n+\t* parse.c (check_component, parse_union, parse_struct_map): Likewise.\n+\t* resolve.c (resolve_fl_struct): Likewise.\n+\t* symbol.c (find_union_component): Likewise.\n+\t* trans-types.c (gfc_get_union_type): Likewise.\n+\t* parse.c (parse_derived): Use new functions.\n+\t* interface.c (gfc_compare_derived_types, gfc_compare_types): Likewise.\n+\t* expr.c (gfc_default_initializer): Likewise.\n+\t* gfortran.texi: Support for DEC structures, unions, and maps.\n+\t* gfortran.h (gfc_statement, sym_flavor): Likewise.\n+\t* check.c (gfc_check_kill_sub): Likewise.\n+\t* expr.c (gfc_copy_expr, simplify_const_ref,\n+\tgfc_has_default_initializer): Likewise.\n+\t* decl.c (build_sym, match_data_constant, add_init_expr_to_sym,\n+\tmatch_pointer_init, build_struct, variable_decl,\n+\tgfc_match_decl_type_spec, gfc_mach_data-decl, gfc_match_entry,\n+\tgfc_match_end, gfc_match_derived_decl): Likewise.\n+\t* interface.c (check_interface0, check_interface1,\n+\tgfc_search_interface): Likewise.\n+\t* misc.c (gfc_basic_typename, gfc_typename): Likewise.\n+\t* module.c (add_true_name, build_tnt, bt_types, mio_typespec,\n+\tfix_mio_expr, load_needed, mio_symbol, read_module, write_symbol,\n+\tgfc_get_module_backend_decl): Likewise.\n+\t* parse.h (gfc_compile_state): Likewise.\n+\t* parse.c (decode_specification_statement, decode_statement,\n+\tgfc_ascii_statement, verify_st_order, parse_spec): Likewise.\n+\t* primary.c (gfc_match_varspec, gfc_match_structure_constructor,\n+\tgfc_match_rvalue, match_variable): Likewise.\n+\t* resolve.c (find_arglists, resolve_structure_cons,\n+\tis_illegal_recursion, resolve_generic_f, get_declared_from_expr,\n+\tresolve_typebound_subroutine, resolve_allocate_expr,\n+\tnonscalar_typebound_assign, generate_component_assignments,\n+\tresolve_fl_variable_derived, check_defined_assignments,\n+\tresolve_component, resolve_symbol, resolve_equivalence_derived):\n+\tLikewise.\n+\t* symbol.c (flavors, check_conflict, gfc_add_flavor, gfc_use_derived,\n+\tgfc_restore_last_undo_checkpoint, gfc_type_compatible,\n+\tgfc_find_dt_in_generic): Likewise.\n+\t* trans-decl.c (gfc_get_module_backend_decl, create_function_arglist,\n+\tgfc_create_module_variable, check_constant_initializer): Likewise.\n+\t* trans-expr.c (gfc_conv_component_ref, gfc_conv_initializer,\n+\tgfc_trans_alloc_subarray_assign, gfc_trans_subcomponent_assign,\n+\tgfc_conv_structure, gfc_trans_scalar_assign, copyable_array_p):\n+\tLikewise.\n+\t* trans-io.c (transfer_namelist_element, transfer_expr,\n+\tgfc_trans_transfer): Likewise.\n+\t* trans-stmt.c (gfc_trans_deallocate): Likewise.\n+\t* trans-types.c (gfc_typenode_for_spec, gfc_copy_dt_decls_ifequal,\n+\tgfc_get_derived_type): Likewise.\n+\n 2016-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* openmp.c (gfc_match_omp_clauses): Restructuralize, so that clause"}, {"sha": "d26e45ec406d6c595188569aa19748fa36eb9742", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -2592,7 +2592,7 @@ gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)\n bool\n gfc_check_kind (gfc_expr *x)\n {\n-  if (x->ts.type == BT_DERIVED || x->ts.type == BT_CLASS)\n+  if (gfc_bt_struct (x->ts.type) || x->ts.type == BT_CLASS)\n     {\n       gfc_error (\"%qs argument of %qs intrinsic at %L must be of \"\n \t\t \"intrinsic type\", gfc_current_intrinsic_arg[0]->name,"}, {"sha": "3627828d21f991869278ffb6a675b9f4b4d3746a", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -78,12 +78,11 @@ insert_component_ref (gfc_typespec *ts, gfc_ref **ref, const char * const name)\n   gcc_assert (ts->type == BT_DERIVED || ts->type == BT_CLASS);\n   type_sym = ts->u.derived;\n \n-  new_ref = gfc_get_ref ();\n-  new_ref->type = REF_COMPONENT;\n-  new_ref->next = *ref;\n-  new_ref->u.c.sym = type_sym;\n-  new_ref->u.c.component = gfc_find_component (type_sym, name, true, true);\n+  gfc_find_component (type_sym, name, true, true, &new_ref);\n   gcc_assert (new_ref->u.c.component);\n+  while (new_ref->next)\n+    new_ref = new_ref->next;\n+  new_ref->next = *ref;\n \n   if (new_ref->next)\n     {\n@@ -206,8 +205,9 @@ gfc_fix_class_refs (gfc_expr *e)\n void\n gfc_add_component_ref (gfc_expr *e, const char *name)\n {\n+  gfc_component *c;\n   gfc_ref **tail = &(e->ref);\n-  gfc_ref *next = NULL;\n+  gfc_ref *ref, *next = NULL;\n   gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;\n   while (*tail != NULL)\n     {\n@@ -237,14 +237,13 @@ gfc_add_component_ref (gfc_expr *e, const char *name)\n   else\n     /* Avoid losing memory.  */\n     gfc_free_ref_list (*tail);\n-  (*tail) = gfc_get_ref();\n-  (*tail)->next = next;\n-  (*tail)->type = REF_COMPONENT;\n-  (*tail)->u.c.sym = derived;\n-  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);\n-  gcc_assert((*tail)->u.c.component);\n+  c = gfc_find_component (derived, name, true, true, tail);\n+  gcc_assert (c);\n+  for (ref = *tail; ref->next; ref = ref->next)\n+    ;\n+  ref->next = next;\n   if (!next)\n-    e->ts = (*tail)->u.c.component->ts;\n+    e->ts = c->ts;\n }\n \n \n@@ -477,8 +476,7 @@ get_unique_type_string (char *string, gfc_symbol *derived)\n   if (derived->attr.unlimited_polymorphic)\n     strcpy (dt_name, \"STAR\");\n   else\n-    strcpy (dt_name, derived->name);\n-  dt_name[0] = TOUPPER (dt_name[0]);\n+    strcpy (dt_name, gfc_dt_upper_string (derived->name));\n   if (derived->attr.unlimited_polymorphic)\n     sprintf (string, \"_%s\", dt_name);\n   else if (derived->module)\n@@ -751,7 +749,7 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)\n   if (tb->non_overridable)\n     return;\n \n-  c = gfc_find_component (vtype, name, true, true);\n+  c = gfc_find_component (vtype, name, true, true, NULL);\n \n   if (c == NULL)\n     {\n@@ -820,7 +818,7 @@ copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype)\n \n   for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)\n     {\n-      if (gfc_find_component (vtype, cmp->name, true, true))\n+      if (gfc_find_component (vtype, cmp->name, true, true, NULL))\n \tcontinue;\n \n       add_proc_comp (vtype, cmp->name, cmp->tb);"}, {"sha": "0b8787ac2b2ec4f4e3db0af769ee0b8e68286a8a", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 535, "deletions": 33, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -391,13 +391,13 @@ match_data_constant (gfc_expr **result)\n \n   if (sym == NULL\n       || (sym->attr.flavor != FL_PARAMETER\n-\t  && (!dt_sym || dt_sym->attr.flavor != FL_DERIVED)))\n+\t  && (!dt_sym || !gfc_fl_struct (dt_sym->attr.flavor))))\n     {\n       gfc_error (\"Symbol %qs must be a PARAMETER in DATA statement at %C\",\n \t\t name);\n       return MATCH_ERROR;\n     }\n-  else if (dt_sym && dt_sym->attr.flavor == FL_DERIVED)\n+  else if (dt_sym && gfc_fl_struct (dt_sym->attr.flavor))\n     return gfc_match_structure_constructor (dt_sym, result);\n \n   /* Check to see if the value is an initialization array expression.  */\n@@ -606,6 +606,161 @@ gfc_match_data (void)\n /************************ Declaration statements *********************/\n \n \n+/* Like gfc_match_init_expr, but matches a 'clist' (old-style initialization\n+   list). The difference here is the expression is a list of constants\n+   and is surrounded by '/'. \n+   The typespec ts must match the typespec of the variable which the\n+   clist is initializing.\n+   The arrayspec tells whether this should match a list of constants \n+   corresponding to array elements or a scalar (as == NULL).  */\n+\n+static match\n+match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)\n+{\n+  gfc_constructor_base array_head = NULL;\n+  gfc_expr *expr = NULL;\n+  match m;\n+  locus where;\n+  mpz_t repeat, size;\n+  bool scalar;\n+  int cmp;\n+\n+  gcc_assert (ts);\n+\n+  mpz_init_set_ui (repeat, 0);\n+  mpz_init (size);\n+  scalar = !as || !as->rank;\n+\n+  /* We have already matched '/' - now look for a constant list, as with\n+     top_val_list from decl.c, but append the result to an array.  */\n+  if (gfc_match (\"/\") == MATCH_YES)\n+    {\n+      gfc_error (\"Empty old style initializer list at %C\");\n+      goto cleanup;\n+    }\n+\n+  where = gfc_current_locus;\n+  for (;;)\n+    {\n+      m = match_data_constant (&expr);\n+      if (m != MATCH_YES)\n+        expr = NULL; /* match_data_constant may set expr to garbage */\n+      if (m == MATCH_NO)\n+        goto syntax;\n+      if (m == MATCH_ERROR)\n+        goto cleanup;\n+\n+      /* Found r in repeat spec r*c; look for the constant to repeat.  */\n+      if ( gfc_match_char ('*') == MATCH_YES)\n+        {\n+          if (scalar)\n+            {\n+              gfc_error (\"Repeat spec invalid in scalar initializer at %C\");\n+              goto cleanup;\n+            }\n+          if (expr->ts.type != BT_INTEGER)\n+            {\n+              gfc_error (\"Repeat spec must be an integer at %C\");\n+              goto cleanup;\n+            }\n+          mpz_set (repeat, expr->value.integer);\n+          gfc_free_expr (expr);\n+          expr = NULL;\n+\n+          m = match_data_constant (&expr);\n+          if (m == MATCH_NO)\n+            gfc_error (\"Expected data constant after repeat spec at %C\");\n+          if (m != MATCH_YES)\n+            goto cleanup;\n+        }\n+      /* No repeat spec, we matched the data constant itself. */\n+      else\n+        mpz_set_ui (repeat, 1);\n+\n+      if (!scalar)\n+        {\n+          /* Add the constant initializer as many times as repeated. */\n+          for (; mpz_cmp_ui (repeat, 0) > 0; mpz_sub_ui (repeat, repeat, 1))\n+            {\n+              /* Make sure types of elements match */\n+              if(ts && !gfc_compare_types (&expr->ts, ts)\n+                    && !gfc_convert_type (expr, ts, 1))\n+                goto cleanup;\n+\n+              gfc_constructor_append_expr (&array_head,\n+                  gfc_copy_expr (expr), &gfc_current_locus);\n+            }\n+\n+          gfc_free_expr (expr);\n+          expr = NULL;\n+        }\n+\n+      /* For scalar initializers quit after one element.  */\n+      else\n+        {\n+          if(gfc_match_char ('/') != MATCH_YES)\n+            {\n+              gfc_error (\"End of scalar initializer expected at %C\");\n+              goto cleanup;\n+            }\n+          break;\n+        }\n+\n+      if (gfc_match_char ('/') == MATCH_YES)\n+        break;\n+      if (gfc_match_char (',') == MATCH_NO)\n+        goto syntax;\n+    }\n+\n+  /* Set up expr as an array constructor. */\n+  if (!scalar)\n+    {\n+      expr = gfc_get_array_expr (ts->type, ts->kind, &where);\n+      expr->ts = *ts;\n+      expr->value.constructor = array_head;\n+\n+      expr->rank = as->rank;\n+      expr->shape = gfc_get_shape (expr->rank);\n+\n+      /* Validate sizes. */\n+      gcc_assert (gfc_array_size (expr, &size));\n+      gcc_assert (spec_size (as, &repeat));\n+      cmp = mpz_cmp (size, repeat);\n+      if (cmp < 0)\n+        gfc_error (\"Not enough elements in array initializer at %C\");\n+      else if (cmp > 0)\n+        gfc_error (\"Too many elements in array initializer at %C\");\n+      if (cmp)\n+        goto cleanup;\n+    }\n+\n+  /* Make sure scalar types match. */\n+  else if (!gfc_compare_types (&expr->ts, ts)\n+           && !gfc_convert_type (expr, ts, 1))\n+    goto cleanup;\n+\n+  if (expr->ts.u.cl)\n+    expr->ts.u.cl->length_from_typespec = 1;\n+\n+  *result = expr;\n+  mpz_clear (size);\n+  mpz_clear (repeat);\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in old style initializer list at %C\");\n+\n+cleanup:\n+  if (expr)\n+    expr->value.constructor = NULL;\n+  gfc_free_expr (expr);\n+  gfc_constructor_free (array_head);\n+  mpz_clear (size);\n+  mpz_clear (repeat);\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */\n \n static bool\n@@ -1239,7 +1394,8 @@ build_sym (const char *name, gfc_charlen *cl, bool cl_deferred,\n \n       st = gfc_find_symtree (gfc_current_ns->sym_root, u_name);\n \n-      if (st != 0)\n+      /* STRUCTURE types can alias symbol names */\n+      if (st != 0 && st->n.sym->attr.flavor != FL_STRUCT)\n \t{\n \t  gfc_error (\"Symbol %qs at %C also declared as a type at %L\", name,\n \t\t     &st->n.sym->declared_at);\n@@ -1469,7 +1625,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \n       /* Check if the assignment can happen. This has to be put off\n \t until later for derived type variables and procedure pointers.  */\n-      if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED\n+      if (!gfc_bt_struct (sym->ts.type) && !gfc_bt_struct (init->ts.type)\n \t  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS\n \t  && !sym->attr.proc_pointer\n \t  && !gfc_check_assign_symbol (sym, NULL, init))\n@@ -1608,7 +1764,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t If we mark my_int as iso_c (since we can see it's value\n \t is equal to one of the named constants), then my_int_2\n \t will be considered C interoperable.  */\n-      if (sym->ts.type != BT_CHARACTER && sym->ts.type != BT_DERIVED)\n+      if (sym->ts.type != BT_CHARACTER && !gfc_bt_struct (sym->ts.type))\n \t{\n \t  sym->ts.is_iso_c |= init->ts.is_iso_c;\n \t  sym->ts.is_c_interop |= init->ts.is_c_interop;\n@@ -1666,6 +1822,7 @@ static bool\n build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t      gfc_array_spec **as)\n {\n+  gfc_state_data *s;\n   gfc_component *c;\n   bool t = true;\n \n@@ -1689,6 +1846,35 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t}\n     }\n \n+  /* If we are in a nested union/map definition, gfc_add_component will not\n+     properly find repeated components because:\n+       (i) gfc_add_component does a flat search, where components of unions \n+           and maps are implicity chained so nested components may conflict.\n+      (ii) Unions and maps are not linked as components of their parent\n+           structures until after they are parsed.\n+     For (i) we use gfc_find_component which searches recursively, and for (ii)\n+     we search each block directly from the parse stack until we find the top\n+     level structure.  */\n+\n+  s = gfc_state_stack;\n+  if (s->state == COMP_UNION || s->state == COMP_MAP)\n+    {\n+      while (s->state == COMP_UNION || gfc_comp_struct (s->state))\n+        {\n+          c = gfc_find_component (s->sym, name, true, true, NULL);\n+          if (c != NULL)\n+            {\n+              gfc_error_now (\"Component '%s' at %C already declared at %L\",\n+                             name, &c->loc);\n+              return false;\n+            }\n+          /* Break after we've searched the entire chain.  */\n+          if (s->state == COMP_DERIVED || s->state == COMP_STRUCTURE)\n+            break;\n+          s = s->previous;\n+        }\n+    }\n+\n   if (!gfc_add_component (gfc_current_block(), name, &c))\n     return false;\n \n@@ -1868,7 +2054,7 @@ match_pointer_init (gfc_expr **init, int procptr)\n {\n   match m;\n \n-  if (gfc_pure (NULL) && gfc_state_stack->state != COMP_DERIVED)\n+  if (gfc_pure (NULL) && !gfc_comp_struct (gfc_state_stack->state))\n     {\n       gfc_error (\"Initialization of pointer at %C is not allowed in \"\n \t\t \"a PURE procedure\");\n@@ -2062,7 +2248,7 @@ variable_decl (int elem)\n   /*  If this symbol has already shown up in a Cray Pointer declaration,\n       and this is not a component declaration,\n       then we want to set the type & bail out.  */\n-  if (flag_cray_pointer && gfc_current_state () != COMP_DERIVED)\n+  if (flag_cray_pointer && !gfc_comp_struct (gfc_current_state ()))\n     {\n       gfc_find_symbol (name, gfc_current_ns, 1, &sym);\n       if (sym != NULL && sym->attr.cray_pointee)\n@@ -2127,7 +2313,7 @@ variable_decl (int elem)\n      For components of derived types, it is not true, so we don't\n      create a symbol for those yet.  If we fail to create the symbol,\n      bail out.  */\n-  if (gfc_current_state () != COMP_DERIVED\n+  if (!gfc_comp_struct (gfc_current_state ())\n       && !build_sym (name, cl, cl_deferred, &as, &var_locus))\n     {\n       m = MATCH_ERROR;\n@@ -2154,6 +2340,9 @@ variable_decl (int elem)\n       if (!gfc_notify_std (GFC_STD_GNU, \"Old-style \"\n \t\t\t   \"initialization at %C\"))\n \treturn MATCH_ERROR;\n+\n+      /* Allow old style initializations for components of STRUCTUREs and MAPs\n+         but not components of derived types.  */\n       else if (gfc_current_state () == COMP_DERIVED)\n \t{\n \t  gfc_error (\"Invalid old style initialization for derived type \"\n@@ -2162,7 +2351,23 @@ variable_decl (int elem)\n \t  goto cleanup;\n \t}\n \n-      return match_old_style_init (name);\n+      /* For structure components, read the initializer as a special\n+         expression and let the rest of this function apply the initializer\n+         as usual.  */\n+      else if (gfc_comp_struct (gfc_current_state ()))\n+        {\n+          m = match_clist_expr (&initializer, &current_ts, as);\n+          if (m == MATCH_NO)\n+            gfc_error (\"Syntax error in old style initialization of %s at %C\",\n+                       name);\n+          if (m != MATCH_YES)\n+            goto cleanup;\n+        }\n+\n+      /* Otherwise we treat the old style initialization just like a\n+         DATA declaration for the current variable.  */\n+      else\n+        return match_old_style_init (name);\n     }\n \n   /* The double colon must be present in order to have initializers.\n@@ -2200,15 +2405,15 @@ variable_decl (int elem)\n \t    }\n \n \t  if (current_attr.flavor != FL_PARAMETER && gfc_pure (NULL)\n-\t      && gfc_state_stack->state != COMP_DERIVED)\n+\t      && !gfc_comp_struct (gfc_state_stack->state))\n \t    {\n \t      gfc_error (\"Initialization of variable at %C is not allowed in \"\n \t\t\t \"a PURE procedure\");\n \t      m = MATCH_ERROR;\n \t    }\n \n \t  if (current_attr.flavor != FL_PARAMETER\n-\t      && gfc_state_stack->state != COMP_DERIVED)\n+\t      && !gfc_comp_struct (gfc_state_stack->state))\n \t    gfc_unset_implicit_pure (gfc_current_ns->proc_name);\n \n \t  if (m != MATCH_YES)\n@@ -2217,7 +2422,7 @@ variable_decl (int elem)\n     }\n \n   if (initializer != NULL && current_attr.allocatable\n-\t&& gfc_current_state () == COMP_DERIVED)\n+\t&& gfc_comp_struct (gfc_current_state ()))\n     {\n       gfc_error (\"Initialization of allocatable component at %C is not \"\n \t\t \"allowed\");\n@@ -2228,14 +2433,20 @@ variable_decl (int elem)\n   /* Add the initializer.  Note that it is fine if initializer is\n      NULL here, because we sometimes also need to check if a\n      declaration *must* have an initialization expression.  */\n-  if (gfc_current_state () != COMP_DERIVED)\n+  if (!gfc_comp_struct (gfc_current_state ()))\n     t = add_init_expr_to_sym (name, &initializer, &var_locus);\n   else\n     {\n       if (current_ts.type == BT_DERIVED\n \t  && !current_attr.pointer && !initializer)\n \tinitializer = gfc_default_initializer (&current_ts);\n       t = build_struct (name, cl, &initializer, &as);\n+\n+      /* If we match a nested structure definition we expect to see the\n+       * body even if the variable declarations blow up, so we need to keep\n+       * the structure declaration around.  */\n+      if (gfc_new_block && gfc_new_block->attr.flavor == FL_STRUCT)\n+        gfc_commit_symbol (gfc_new_block);\n     }\n \n   m = (t) ? MATCH_YES : MATCH_ERROR;\n@@ -2724,6 +2935,36 @@ gfc_match_char_spec (gfc_typespec *ts)\n }\n \n \n+/* Matches a RECORD declaration. */\n+\n+static match\n+match_record_decl (const char *name)\n+{\n+    locus old_loc;\n+    old_loc = gfc_current_locus;\n+\n+    if (gfc_match (\" record\") == MATCH_YES)\n+      {\n+          if (!gfc_option.flag_dec_structure)\n+            {\n+                gfc_current_locus = old_loc;\n+                gfc_error (\"RECORD at %C is an extension, enable it with \"\n+                           \"-fdec-structure\");\n+                return MATCH_ERROR;\n+            }\n+          if (gfc_match (\" /%n/\", name) != MATCH_YES)\n+            {\n+                gfc_error (\"Structure name expected after RECORD at %C\");\n+                gfc_current_locus = old_loc;\n+                return MATCH_ERROR;\n+            }\n+          return MATCH_YES;\n+      }\n+\n+    gfc_current_locus = old_loc;\n+    return MATCH_NO;\n+}\n+\n /* Matches a declaration-type-spec (F03:R502).  If successful, sets the ts\n    structure to the matched specification.  This is necessary for FUNCTION and\n    IMPLICIT statements.\n@@ -2781,7 +3022,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t{\n \t  if ((m = gfc_match (\"*)\")) != MATCH_YES)\n \t    return m;\n-\t  if (gfc_current_state () == COMP_DERIVED)\n+\t  if (gfc_comp_struct (gfc_current_state ()))\n \t    {\n \t      gfc_error (\"Assumed type at %C is not allowed for components\");\n \t      return MATCH_ERROR;\n@@ -2892,10 +3133,51 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n   if (matched_type)\n     m = gfc_match_char (')');\n \n-  if (m == MATCH_YES)\n-    ts->type = BT_DERIVED;\n+  if (m != MATCH_YES)\n+    m = match_record_decl (name);\n+\n+  if (matched_type || m == MATCH_YES)\n+    {\n+      ts->type = BT_DERIVED;\n+      /* We accept record/s/ or type(s) where s is a structure, but we\n+       * don't need all the extra derived-type stuff for structures.  */\n+      if (gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &sym))\n+        {\n+          gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+          return MATCH_ERROR;\n+        }\n+      if (sym && sym->attr.flavor == FL_STRUCT)\n+        {\n+          ts->u.derived = sym;\n+          return MATCH_YES;\n+        }\n+      /* Actually a derived type.  */\n+    }\n+\n   else\n     {\n+      /* Match nested STRUCTURE declarations; only valid within another\n+         structure declaration.  */\n+      m = gfc_match (\" structure\");\n+      if (m == MATCH_ERROR)\n+        return MATCH_ERROR;\n+      else if (m == MATCH_YES)\n+        {\n+          if (   gfc_current_state () != COMP_STRUCTURE\n+              && gfc_current_state () != COMP_MAP)\n+              return MATCH_ERROR;\n+\n+          m = gfc_match_structure_decl ();\n+          if (m == MATCH_YES)\n+            {\n+              /* gfc_new_block is updated by match_structure_decl.  */\n+              ts->type = BT_DERIVED;\n+              ts->u.derived = gfc_new_block;\n+              return MATCH_YES;\n+            }\n+          return MATCH_ERROR;\n+        }\n+\n       /* Match CLASS declarations.  */\n       m = gfc_match (\" class ( * )\");\n       if (m == MATCH_ERROR)\n@@ -2964,9 +3246,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n      stored in a symtree with the first letter of the name capitalized; the\n      symtree with the all lower-case name contains the associated\n      generic function.  */\n-  dt_name = gfc_get_string (\"%c%s\",\n-\t\t\t    (char) TOUPPER ((unsigned char) name[0]),\n-\t\t\t    (const char*)&name[1]);\n+  dt_name = gfc_dt_upper_string (name);\n   sym = NULL;\n   dt_sym = NULL;\n   if (ts->kind != -1)\n@@ -2998,7 +3278,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \treturn MATCH_NO;\n     }\n \n-  if ((sym->attr.flavor != FL_UNKNOWN\n+  if ((sym->attr.flavor != FL_UNKNOWN && sym->attr.flavor != FL_STRUCT\n        && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))\n       || sym->attr.subroutine)\n     {\n@@ -3038,7 +3318,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   gfc_set_sym_referenced (dt_sym);\n \n-  if (dt_sym->attr.flavor != FL_DERIVED\n+  if (dt_sym->attr.flavor != FL_DERIVED && dt_sym->attr.flavor != FL_STRUCT\n       && !gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL))\n     return MATCH_ERROR;\n \n@@ -3480,9 +3760,7 @@ gfc_match_import (void)\n \t\t letter of the name capitalized; the symtree with the all\n \t\t lower-case name contains the associated generic function.  */\n \t      st = gfc_new_symtree (&gfc_current_ns->sym_root,\n-\t\t\tgfc_get_string (\"%c%s\",\n-\t\t\t\t(char) TOUPPER ((unsigned char) name[0]),\n-\t\t\t\t&name[1]));\n+                                    gfc_dt_upper_string (name));\n \t      st->n.sym = sym;\n \t      sym->refs++;\n \t      sym->attr.imported = 1;\n@@ -4497,7 +4775,7 @@ gfc_match_data_decl (void)\n     return m;\n \n   if ((current_ts.type == BT_DERIVED || current_ts.type == BT_CLASS)\n-\t&& gfc_current_state () != COMP_DERIVED)\n+\t&& !gfc_comp_struct (gfc_current_state ()))\n     {\n       sym = gfc_use_derived (current_ts.u.derived);\n \n@@ -4526,17 +4804,19 @@ gfc_match_data_decl (void)\n       && !current_ts.u.derived->attr.zero_comp)\n     {\n \n-      if (current_attr.pointer && gfc_current_state () == COMP_DERIVED)\n+      if (current_attr.pointer && gfc_comp_struct (gfc_current_state ()))\n \tgoto ok;\n \n       gfc_find_symbol (current_ts.u.derived->name,\n \t\t       current_ts.u.derived->ns, 1, &sym);\n \n       /* Any symbol that we find had better be a type definition\n-\t which has its components defined.  */\n-      if (sym != NULL && sym->attr.flavor == FL_DERIVED\n+\t which has its components defined, or be a structure definition\n+         actively being parsed.  */\n+      if (sym != NULL && gfc_fl_struct (sym->attr.flavor)\n \t  && (current_ts.u.derived->components != NULL\n-\t      || current_ts.u.derived->attr.zero_comp))\n+\t      || current_ts.u.derived->attr.zero_comp\n+\t      || current_ts.u.derived == gfc_new_block))\n \tgoto ok;\n \n       gfc_error (\"Derived type at %C has not been previously defined \"\n@@ -5791,6 +6071,10 @@ gfc_match_entry (void)\n \t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n \t\t       \"an INTERFACE\");\n \t    break;\n+          case COMP_STRUCTURE:\n+            gfc_error (\"ENTRY statement at %C cannot appear within \"\n+                       \"a STRUCTURE block\");\n+            break;\n \t  case COMP_DERIVED:\n \t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n \t\t       \"a DERIVED TYPE block\");\n@@ -6450,6 +6734,24 @@ gfc_match_end (gfc_statement *st)\n       eos_ok = 0;\n       break;\n \n+    case COMP_MAP:\n+      *st = ST_END_MAP;\n+      target = \" map\";\n+      eos_ok = 0;\n+      break;\n+\n+    case COMP_UNION:\n+      *st = ST_END_UNION;\n+      target = \" union\";\n+      eos_ok = 0;\n+      break;\n+\n+    case COMP_STRUCTURE:\n+      *st = ST_END_STRUCTURE;\n+      target = \" structure\";\n+      eos_ok = 0;\n+      break;\n+\n     case COMP_DERIVED:\n     case COMP_DERIVED_CONTAINS:\n       *st = ST_END_TYPE;\n@@ -8020,6 +8322,208 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n }\n \n \n+/* Common function for type declaration blocks similar to derived types, such\n+   as STRUCTURES and MAPs. Unlike derived types, a structure type\n+   does NOT have a generic symbol matching the name given by the user.\n+   STRUCTUREs can share names with variables and PARAMETERs so we must allow\n+   for the creation of an independent symbol.\n+   Other parameters are a message to prefix errors with, the name of the new \n+   type to be created, and the flavor to add to the resulting symbol. */\n+\n+static bool\n+get_struct_decl (const char *name, sym_flavor fl, locus *decl,\n+                 gfc_symbol **result)\n+{\n+  gfc_symbol *sym;\n+  locus where;\n+\n+  gcc_assert (name[0] == (char) TOUPPER (name[0]));\n+\n+  if (decl)\n+    where = *decl;\n+  else\n+    where = gfc_current_locus;\n+\n+  if (gfc_get_symbol (name, NULL, &sym))\n+    return false;\n+\n+  if (!sym)\n+    {\n+      gfc_internal_error (\"Failed to create structure type '%s' at %C\", name);\n+      return false;\n+    }\n+\n+  if (sym->components != NULL || sym->attr.zero_comp)\n+    {\n+      gfc_error (\"Type definition of '%s' at %C was already defined at %L\", \n+                 sym->name, &sym->declared_at);\n+      return false;\n+    }\n+\n+  sym->declared_at = where;\n+\n+  if (sym->attr.flavor != fl\n+      && !gfc_add_flavor (&sym->attr, fl, sym->name, NULL))\n+    return false;\n+\n+  if (!sym->hash_value)\n+      /* Set the hash for the compound name for this type.  */\n+    sym->hash_value = gfc_hash_value (sym);\n+\n+  /* Normally the type is expected to have been completely parsed by the time\n+     a field declaration with this type is seen. For unions, maps, and nested\n+     structure declarations, we need to indicate that it is okay that we\n+     haven't seen any components yet. This will be updated after the structure\n+     is fully parsed. */\n+  sym->attr.zero_comp = 0;\n+\n+  /* Structures always act like derived-types with the SEQUENCE attribute */\n+  gfc_add_sequence (&sym->attr, sym->name, NULL);\n+\n+  if (result) *result = sym;\n+\n+  return true;\n+}\n+\n+\n+/* Match the opening of a MAP block. Like a struct within a union in C;\n+   behaves identical to STRUCTURE blocks.  */\n+\n+match\n+gfc_match_map (void)\n+{\n+    /* Counter used to give unique internal names to map structures. */\n+    static unsigned int gfc_map_id = 0;\n+    char name[GFC_MAX_SYMBOL_LEN + 1];\n+    gfc_symbol *sym;\n+    locus old_loc;\n+\n+    old_loc = gfc_current_locus;\n+\n+    if (gfc_match_eos () != MATCH_YES)\n+      {\n+          gfc_error (\"Junk after MAP statement at %C\");\n+          gfc_current_locus = old_loc;\n+          return MATCH_ERROR;\n+      }\n+\n+    /* Map blocks are anonymous so we make up unique names for the symbol table\n+       which are invalid Fortran identifiers.  */\n+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"MM$%u\", gfc_map_id++);\n+\n+    if (!get_struct_decl (name, FL_STRUCT, &old_loc, &sym))\n+      return MATCH_ERROR;\n+\n+    gfc_new_block = sym;\n+\n+    return MATCH_YES;\n+}\n+\n+\n+/* Match the opening of a UNION block.  */\n+\n+match\n+gfc_match_union (void)\n+{\n+    /* Counter used to give unique internal names to union types. */\n+    static unsigned int gfc_union_id = 0;\n+    char name[GFC_MAX_SYMBOL_LEN + 1];\n+    gfc_symbol *sym;\n+    locus old_loc;\n+\n+    old_loc = gfc_current_locus;\n+\n+    if (gfc_match_eos () != MATCH_YES)\n+      {\n+          gfc_error (\"Junk after UNION statement at %C\");\n+          gfc_current_locus = old_loc;\n+          return MATCH_ERROR;\n+      }\n+\n+    /* Unions are anonymous so we make up unique names for the symbol table\n+       which are invalid Fortran identifiers.  */\n+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"UU$%u\", gfc_union_id++);\n+\n+    if (!get_struct_decl (name, FL_UNION, &old_loc, &sym))\n+      return MATCH_ERROR;\n+\n+    gfc_new_block = sym;\n+\n+    return MATCH_YES;\n+}\n+\n+\n+/* Match the beginning of a STRUCTURE declaration. This is similar to\n+   matching the beginning of a derived type declaration with a few\n+   twists. The resulting type symbol has no access control or other\n+   interesting attributes.  */\n+\n+match\n+gfc_match_structure_decl (void)\n+{\n+    /* Counter used to give unique internal names to anonymous structures.  */\n+    int gfc_structure_id = 0;\n+    char name[GFC_MAX_SYMBOL_LEN + 1];\n+    gfc_symbol *sym;\n+    match m;\n+    locus where;\n+\n+    if(!gfc_option.flag_dec_structure)\n+      {\n+          gfc_error (\"STRUCTURE at %C is a DEC extension, enable with \"\n+                     \"-fdec-structure\");\n+          return MATCH_ERROR;\n+      }\n+\n+    name[0] = '\\0';\n+\n+    m = gfc_match (\" /%n/\", name);\n+    if (m != MATCH_YES)\n+      {\n+          /* Non-nested structure declarations require a structure name.  */\n+          if (!gfc_comp_struct (gfc_current_state ()))\n+            {\n+                gfc_error (\"Structure name expected in non-nested structure \"\n+                           \"declaration at %C\");\n+                return MATCH_ERROR;\n+            }\n+          /* This is an anonymous structure; make up a unique name for it\n+             (upper-case letters never make it to symbol names from the source).\n+             The important thing is initializing the type variable\n+             and setting gfc_new_symbol, which is immediately used by\n+             parse_structure () and variable_decl () to add components of\n+             this type.  */\n+          snprintf (name, GFC_MAX_SYMBOL_LEN + 1, \"SS$%u\", gfc_structure_id++);\n+      }\n+\n+    where = gfc_current_locus;\n+    /* No field list allowed after non-nested structure declaration.  */\n+    if (!gfc_comp_struct (gfc_current_state ())\n+        && gfc_match_eos () != MATCH_YES)\n+      {\n+          gfc_error (\"Junk after non-nested STRUCTURE statement at %C\");\n+          return MATCH_ERROR;\n+      }\n+\n+    /* Make sure the name is not the name of an intrinsic type.  */\n+    if (gfc_is_intrinsic_typename (name))\n+      {\n+        gfc_error (\"Structure name '%s' at %C cannot be the same as an\"\n+                   \" intrinsic type\", name);\n+        return MATCH_ERROR;\n+      }\n+\n+    /* Store the actual type symbol for the structure with an upper-case first\n+       letter (an invalid Fortran identifier).  */\n+\n+    sprintf (name, gfc_dt_upper_string (name));\n+    if (!get_struct_decl (name, FL_STRUCT, &where, &sym))\n+      return MATCH_ERROR;\n+\n+    gfc_new_block = sym;\n+    return MATCH_YES;\n+}\n+\n /* Match the beginning of a derived type declaration.  If a type name\n    was the result of a function, then it is possible to have a symbol\n    already to be known as a derived type yet have no components.  */\n@@ -8037,7 +8541,7 @@ gfc_match_derived_decl (void)\n   bool seen_attr = false;\n   gfc_interface *intr = NULL, *head;\n \n-  if (gfc_current_state () == COMP_DERIVED)\n+  if (gfc_comp_struct (gfc_current_state ()))\n     return MATCH_NO;\n \n   name[0] = '\\0';\n@@ -8111,9 +8615,7 @@ gfc_match_derived_decl (void)\n   if (!sym)\n     {\n       /* Use upper case to save the actual derived-type symbol.  */\n-      gfc_get_symbol (gfc_get_string (\"%c%s\",\n-\t\t\t(char) TOUPPER ((unsigned char) gensym->name[0]),\n-\t\t\t&gensym->name[1]), NULL, &sym);\n+      gfc_get_symbol (gfc_dt_upper_string (gensym->name), NULL, &sym);\n       sym->name = gfc_get_string (gensym->name);\n       head = gensym->generic;\n       intr = gfc_get_interface ();"}, {"sha": "f50743475d303e204439de078a5ca2eefdb008fc", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -106,6 +106,7 @@ show_typespec (gfc_typespec *ts)\n     {\n     case BT_DERIVED:\n     case BT_CLASS:\n+    case BT_UNION:\n       fprintf (dumpfile, \"%s\", ts->u.derived->name);\n       break;\n "}, {"sha": "6ebe08b75386ac393772c2b7cce8c23564ac4671", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -335,7 +335,7 @@ gfc_copy_expr (gfc_expr *p)\n \n \tcase BT_HOLLERITH:\n \tcase BT_LOGICAL:\n-\tcase BT_DERIVED:\n+\tcase_bt_struct:\n \tcase BT_CLASS:\n \tcase BT_ASSUMED:\n \t  break;\t\t/* Already done.  */\n@@ -1279,7 +1279,7 @@ find_component_ref (gfc_constructor_base base, gfc_ref *ref)\n   /* For extended types, check if the desired component is in one of the\n    * parent types.  */\n   while (ext > 0 && gfc_find_component (dt->components->ts.u.derived,\n-\t\t\t\t\tpick->name, true, true))\n+\t\t\t\t\tpick->name, true, true, NULL))\n     {\n       dt = dt->components->ts.u.derived;\n       c = gfc_constructor_first (c->expr->value.constructor);\n@@ -1649,7 +1649,7 @@ simplify_const_ref (gfc_expr *p)\n \n \t    case AR_FULL:\n \t      if (p->ref->next != NULL\n-\t\t  && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))\n+\t\t  && (p->ts.type == BT_CHARACTER || gfc_bt_struct (p->ts.type)))\n \t\t{\n \t\t  for (c = gfc_constructor_first (p->value.constructor);\n \t\t       c; c = gfc_constructor_next (c))\n@@ -1659,7 +1659,7 @@ simplify_const_ref (gfc_expr *p)\n \t\t\treturn false;\n \t\t    }\n \n-\t\t  if (p->ts.type == BT_DERIVED\n+\t\t  if (gfc_bt_struct (p->ts.type)\n \t\t\t&& p->ref->next\n \t\t\t&& (c = gfc_constructor_first (p->value.constructor)))\n \t\t    {\n@@ -3926,9 +3926,9 @@ gfc_has_default_initializer (gfc_symbol *der)\n {\n   gfc_component *c;\n \n-  gcc_assert (der->attr.flavor == FL_DERIVED);\n+  gcc_assert (gfc_fl_struct (der->attr.flavor));\n   for (c = der->components; c; c = c->next)\n-    if (c->ts.type == BT_DERIVED)\n+    if (gfc_bt_struct (c->ts.type))\n       {\n         if (!c->attr.pointer && !c->attr.proc_pointer\n \t     && gfc_has_default_initializer (c->ts.u.derived))\n@@ -3975,6 +3975,7 @@ gfc_default_initializer (gfc_typespec *ts)\n \n       if (comp->initializer)\n \t{\n+          ctor->n.component = comp;\n \t  ctor->expr = gfc_copy_expr (comp->initializer);\n \t  if ((comp->ts.type != comp->initializer->ts.type\n \t       || comp->ts.kind != comp->initializer->ts.kind)"}, {"sha": "0bb71cb184d195842ebcc12a8cd5358e56f28423", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -62,6 +62,15 @@ not after.\n \n #define gfc_is_whitespace(c) ((c==' ') || (c=='\\t'))\n \n+/* Macros to check for groups of structure-like types and flavors since\n+   derived types, structures, maps, unions are often treated similarly. */\n+#define gfc_bt_struct(t) \\\n+  ((t) == BT_DERIVED || (t) == BT_UNION)\n+#define gfc_fl_struct(f) \\\n+  ((f) == FL_DERIVED || (f) == FL_UNION || (f) == FL_STRUCT)\n+#define case_bt_struct case BT_DERIVED: case BT_UNION\n+#define case_fl_struct case FL_DERIVED: case FL_UNION: case FL_STRUCT\n+\n /* Stringization.  */\n #define stringize(x) expand_macro(x)\n #define expand_macro(x) # x\n@@ -203,6 +212,8 @@ enum gfc_statement\n   ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE, ST_SIMPLE_IF,\n   ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT, ST_ENUM,\n   ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n+  ST_STRUCTURE_DECL, ST_END_STRUCTURE,\n+  ST_UNION, ST_END_UNION, ST_MAP, ST_END_MAP,\n   ST_OACC_PARALLEL_LOOP, ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL,\n   ST_OACC_END_PARALLEL, ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,\n   ST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,\n@@ -254,12 +265,12 @@ enum interface_type\n };\n \n /* Symbol flavors: these are all mutually exclusive.\n-   10 elements = 4 bits.  */\n+   12 elements = 4 bits.  */\n enum sym_flavor\n {\n   FL_UNKNOWN = 0, FL_PROGRAM, FL_BLOCK_DATA, FL_MODULE, FL_VARIABLE,\n   FL_PARAMETER, FL_LABEL, FL_PROCEDURE, FL_DERIVED, FL_NAMELIST,\n-  FL_VOID\n+  FL_UNION, FL_STRUCT, FL_VOID\n };\n \n /* Procedure types.  7 elements = 3 bits.  */\n@@ -2523,6 +2534,8 @@ typedef struct\n   int flag_init_character;\n   char flag_init_character_value;\n \n+  int flag_dec_structure;\n+\n   int fpe;\n   int fpe_summary;\n   int rtcheck;\n@@ -2743,6 +2756,7 @@ bool gfc_check_any_c_kind (gfc_typespec *);\n int gfc_validate_kind (bt, int, bool);\n int gfc_get_int_kind_from_width_isofortranenv (int size);\n int gfc_get_real_kind_from_width_isofortranenv (int size);\n+tree gfc_get_union_type (gfc_symbol *);\n tree gfc_get_derived_type (gfc_symbol * derived);\n extern int gfc_index_integer_kind;\n extern int gfc_default_integer_kind;\n@@ -2831,7 +2845,8 @@ int gfc_copy_dummy_sym (gfc_symbol **, gfc_symbol *, int);\n bool gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n gfc_symbol *gfc_use_derived (gfc_symbol *);\n gfc_symtree *gfc_use_derived_tree (gfc_symtree *);\n-gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool);\n+gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool,\n+                                   gfc_ref **);\n \n gfc_st_label *gfc_get_st_label (int);\n void gfc_free_st_label (gfc_st_label *);\n@@ -3174,6 +3189,8 @@ void gfc_module_done_2 (void);\n void gfc_dump_module (const char *, int);\n bool gfc_check_symbol_access (gfc_symbol *);\n void gfc_free_use_stmts (gfc_use_list *);\n+const char *gfc_dt_lower_string (const char *);\n+const char *gfc_dt_upper_string (const char *);\n \n /* primary.c */\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);"}, {"sha": "9d7d3d4b34b14d3836231b2304145cdd8737acbf", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 215, "deletions": 46, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -474,9 +474,9 @@ The GNU Fortran compiler is able to compile nearly all\n standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,\n including a number of standard and non-standard extensions, and can be\n used on real-world programs.  In particular, the supported extensions\n-include OpenMP, Cray-style pointers, and several Fortran 2003 and Fortran\n-2008 features, including TR 15581.  However, it is still under\n-development and has a few remaining rough edges.\n+include OpenMP, Cray-style pointers, some old vendor extensions, and several\n+Fortran 2003 and Fortran 2008 features, including TR 15581.  However, it is\n+still under development and has a few remaining rough edges.\n There also is initial support for OpenACC.\n Note that this is an experimental feature, incomplete, and subject to\n change in future versions of GCC.  See\n@@ -1459,6 +1459,8 @@ without warning.\n * OpenACC::\n * Argument list functions::\n * Read/Write after EOF marker::\n+* STRUCTURE and RECORD::\n+* UNION and MAP::\n @end menu\n \n @node Old-style kind specifications\n@@ -2117,40 +2119,6 @@ consider @code{BACKSPACE} or @code{REWIND} to properly position\n the file before the EOF marker.  As an extension, the run-time error may\n be disabled using -std=legacy.\n \n-@node Extensions not implemented in GNU Fortran\n-@section Extensions not implemented in GNU Fortran\n-@cindex extensions, not implemented\n-\n-The long history of the Fortran language, its wide use and broad\n-userbase, the large number of different compiler vendors and the lack of\n-some features crucial to users in the first standards have lead to the\n-existence of a number of important extensions to the language.  While\n-some of the most useful or popular extensions are supported by the GNU\n-Fortran compiler, not all existing extensions are supported.  This section\n-aims at listing these extensions and offering advice on how best make\n-code that uses them running with the GNU Fortran compiler.\n-\n-@c More can be found here:\n-@c   -- https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html\n-@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:\n-@c      http://tinyurl.com/2u4h5y\n-\n-@menu\n-* STRUCTURE and RECORD::\n-@c * UNION and MAP::\n-* ENCODE and DECODE statements::\n-* Variable FORMAT expressions::\n-@c * Q edit descriptor::\n-@c * AUTOMATIC statement::\n-@c * TYPE and ACCEPT I/O Statements::\n-@c * .XOR. operator::\n-@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::\n-@c * Omitted arguments in procedure call::\n-* Alternate complex function syntax::\n-* Volatile COMMON blocks::\n-* OPEN( ... NAME=)::\n-@end menu\n-\n \n @node STRUCTURE and RECORD\n @subsection @code{STRUCTURE} and @code{RECORD}\n@@ -2226,16 +2194,218 @@ store_catalog(12) = pear\n print *, store_catalog(12)\n @end example\n \n+@noindent\n+GNU Fortran implements STRUCTURES like derived types with the following\n+rules and exceptions:\n+\n+@itemize @bullet\n+@item Structures act like derived types with the @code{SEQUENCE} attribute.\n+Otherwise they may contain no specifiers.\n+\n+@item Structures may share names with other symbols. For example, the following\n+is invalid for derived types, but valid for structures:\n+\n+@smallexample\n+structure /header/\n+  ! ...\n+end structure\n+record /header/ header\n+@end smallexample\n+\n+@item Structure types may be declared nested within another parent structure.\n+The syntax is:\n+@smallexample\n+structure /type-name/\n+    ...\n+    structure [/<type-name>/] <field-list>\n+...\n+@end smallexample\n+\n+The type name may be ommitted, in which case the structure type itself is\n+anonymous, and other structures of the same type cannot be instantiated. The\n+following shows some examples:\n+\n+@example\n+structure /appointment/\n+  ! nested structure definition: app_time is an array of two 'time'\n+  structure /time/ app_time (2) \n+    integer(1) hour, minute\n+  end structure\n+  character(10) memo\n+end structure\n+\n+! The 'time' structure is still usable\n+record /time/ now\n+now = time(5, 30)\n+\n+...\n+\n+structure /appointment/\n+  ! anonymous nested structure definition\n+  structure start, end\n+    integer(1) hour, minute\n+  end structure\n+  character(10) memo\n+end structure\n+@end example\n+\n+@item Structures may contain @code{UNION} blocks. For more detail see the\n+section on @ref{UNION and MAP}.\n \n-@c @node UNION and MAP\n-@c @subsection @code{UNION} and @code{MAP}\n-@c @cindex @code{UNION}\n-@c @cindex @code{MAP}\n-@c\n-@c For help writing this one, see\n-@c http://www.eng.umd.edu/~nsw/ench250/fortran1.htm#UNION and\n-@c http://www.tacc.utexas.edu/services/userguides/pgi/pgiws_ug/pgi32u06.htm\n+@item Structures support old-style initialization of components, like\n+those described in @ref{Old-style variable initialization}. For array\n+initializers, an initializer may contain a repeat specification of the form\n+@code{<literal-integer> * <constant-initializer>}. The value of the integer\n+indicates the number of times to repeat the constant initializer when expanding\n+the initializer list.\n+@end itemize\n+\n+@node UNION and MAP\n+@subsection @code{UNION} and @code{MAP}\n+@cindex @code{UNION}\n+@cindex @code{MAP}\n+\n+Unions are an old vendor extension which were commonly used with the\n+non-standard @ref{STRUCTURE and RECORD} extensions. Use of @code{UNION} and\n+@code{MAP} is automatically enabled with @option{-fdec-structure}.\n+\n+A @code{UNION} declaration occurs within a structure; within the definition of\n+each union is a number of @code{MAP} blocks. Each @code{MAP} shares storage\n+with its sibling maps (in the same union), and the size of the union is the\n+size of the largest map within it, just as with unions in C. The major\n+difference is that component references do not indicate which union or map the\n+component is in (the compiler gets to figure that out).\n+\n+Here is a small example:\n+@smallexample\n+structure /myunion/\n+union\n+  map\n+    integer(2) w, x, y, z\n+  end map\n+  map\n+    integer(4) wx, yz\n+  end map\n+end union\n+end structure\n+\n+record /myunion/ rec\n+! After these assignments...\n+rec.wx = z'0DEDBEEF'\n+rec.y  = z'0BAD'\n+rec.z  = z'0FAD'\n+\n+! The following is true:\n+! rec.w  === z'0DED'\n+! rec.x  === z'BEEF'\n+! rec.yz === z'0BAD0FAD'\n+@end smallexample\n+\n+The two maps share memory, and the size of the union is ultimately six bytes\n+(subject to alignment):\n+\n+@example\n+0    1    2    3    4   5   6     Byte offset\n+-------------------------------\n+|    |    |    |    |    |    |\n+-------------------------------\n+\n+^    W0   ^    W1   ^    W2   ^\n+ \\-------/ \\-------/ \\-------/\n+\n+^       LONG        ^  unused ^\n+ \\-----------------/ \\-------/\n+@end example\n+\n+Following is an example mirroring the layout of an Intel x86_64 register:\n+\n+@example\n+structure /reg/\n+  union    ! rax\n+    map\n+      integer*8 rx         ! rax\n+    end map\n+    map\n+      integer*4 rh         ! rah\n+      union   ! eax\n+        map\n+          integer*4 rl     ! ral\n+        end map\n+        map\n+          integer*4 ex     ! eax\n+        end map\n+        map\n+          integer*2 eh     ! eah\n+          union     ! ax\n+            map\n+              integer*2 el ! eal\n+            end map\n+            map\n+              integer*2 x  ! ax\n+            end map\n+            map\n+              integer*1 h  ! ah\n+              integer*1 l  ! al\n+            end map\n+          end union ! ax\n+        end map\n+      end union ! eax\n+    end map\n+  end union ! rax\n+end structure\n+\n+record /reg/ a\n+\n+! After this assignment...\n+a.rx = z'AABBCCCCFFFFFFFF'\n+\n+! The following is true:\n+!\n+! a.rx == z'AABBCCCCFFFFFFFF'\n+! a.rh ==         z'FFFFFFFF'\n+! a.rl == z'AABBCCCC'\n+!\n+! a.ex == z'AABBCCCC'\n+! a.eh ==     z'CCCC'\n+! a.el == z'AABB'\n+!\n+!  a.x == z'AABB'\n+!  a.h ==   z'BB'\n+!  a.l == z'AA'\n+@end example\n+\n+\n+@node Extensions not implemented in GNU Fortran\n+@section Extensions not implemented in GNU Fortran\n+@cindex extensions, not implemented\n+\n+The long history of the Fortran language, its wide use and broad\n+userbase, the large number of different compiler vendors and the lack of\n+some features crucial to users in the first standards have lead to the\n+existence of a number of important extensions to the language.  While\n+some of the most useful or popular extensions are supported by the GNU\n+Fortran compiler, not all existing extensions are supported.  This section\n+aims at listing these extensions and offering advice on how best make\n+code that uses them running with the GNU Fortran compiler.\n \n+@c More can be found here:\n+@c   -- https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html\n+@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:\n+@c      http://tinyurl.com/2u4h5y\n+\n+@menu\n+* ENCODE and DECODE statements::\n+* Variable FORMAT expressions::\n+@c * Q edit descriptor::\n+@c * AUTOMATIC statement::\n+@c * TYPE and ACCEPT I/O Statements::\n+@c * .XOR. operator::\n+@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::\n+@c * Omitted arguments in procedure call::\n+* Alternate complex function syntax::\n+* Volatile COMMON blocks::\n+* OPEN( ... NAME=)::\n+@end menu\n \n @node ENCODE and DECODE statements\n @subsection @code{ENCODE} and @code{DECODE} statements\n@@ -2355,7 +2525,6 @@ invalid standard Fortran syntax and is not supported by\n @code{VOLATILE} variables in @code{COMMON} blocks since revision 4.3.\n \n \n-\n @node OPEN( ... NAME=)\n @subsection @code{OPEN( ... NAME=)}\n @cindex @code{NAM}"}, {"sha": "b981e7c09913fcb8422c806476d748231c1c8ccd", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 161, "deletions": 54, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -387,19 +387,147 @@ gfc_match_end_interface (void)\n }\n \n \n+/* Compare components according to 4.4.2 of the Fortran standard.  */\n+\n+static int\n+compare_components (gfc_component *cmp1, gfc_component *cmp2,\n+    gfc_symbol *derived1, gfc_symbol *derived2)\n+{\n+  gfc_symbol *d1, *d2;\n+  bool anonymous = false;\n+\n+  /* Unions, maps, and anonymous structures all have names like \"[xX]X$\\d+\"\n+     which should not be compared.  */\n+  d1 = cmp1->ts.u.derived;\n+  d2 = cmp2->ts.u.derived;\n+  if (   (d1 && (d1->attr.flavor == FL_STRUCT || d1->attr.flavor == FL_UNION)\n+          && ISUPPER (cmp1->name[1]))\n+      || (d2 && (d2->attr.flavor == FL_STRUCT || d2->attr.flavor == FL_UNION)\n+          && ISUPPER (cmp1->name[1])))\n+    anonymous = true;\n+\n+  if (!anonymous && strcmp (cmp1->name, cmp2->name) != 0)\n+    return 0;\n+\n+  if (cmp1->attr.access != cmp2->attr.access)\n+    return 0;\n+\n+  if (cmp1->attr.pointer != cmp2->attr.pointer)\n+    return 0;\n+\n+  if (cmp1->attr.dimension != cmp2->attr.dimension)\n+    return 0;\n+\n+  if (cmp1->attr.allocatable != cmp2->attr.allocatable)\n+    return 0;\n+\n+  if (cmp1->attr.dimension && gfc_compare_array_spec (cmp1->as, cmp2->as) == 0)\n+    return 0;\n+\n+  /* Make sure that link lists do not put this function into an\n+     endless recursive loop!  */\n+  if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)\n+      && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived)\n+      && gfc_compare_types (&cmp1->ts, &cmp2->ts) == 0)\n+    return 0;\n+\n+  else if ( (cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)\n+        && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))\n+    return 0;\n+\n+  else if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)\n+        &&  (cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+\n+/* Compare two union types by comparing the components of their maps.\n+   Because unions and maps are anonymous their types get special internal\n+   names; therefore the usual derived type comparison will fail on them.\n+\n+   Returns nonzero if equal, as with gfc_compare_derived_types. Also as with\n+   gfc_compare_derived_types, 'equal' is closer to meaning 'duplicate\n+   definitions' than 'equivalent structure'. */\n+\n+int\n+gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)\n+{\n+  gfc_component *map1, *map2, *cmp1, *cmp2;\n+\n+  if (un1->attr.flavor != FL_UNION || un2->attr.flavor != FL_UNION)\n+    return 0;\n+\n+  map1 = un1->components;\n+  map2 = un2->components;\n+\n+  /* In terms of 'equality' here we are worried about types which are\n+     declared the same in two places, not types that represent equivalent\n+     structures. (This is common because of FORTRAN's weird scoping rules.)\n+     Though two unions with their maps in different orders could be equivalent,\n+     we will say they are not equal for the purposes of this test; therefore\n+     we compare the maps sequentially. */\n+  for (;;)\n+  {\n+    cmp1 = map1->ts.u.derived->components;\n+    cmp2 = map2->ts.u.derived->components;\n+    for (;;)\n+    {\n+      /* No two fields will ever point to the same map type unless they are\n+         the same component, because one map field is created with its type\n+         declaration. Therefore don't worry about recursion here. */\n+      /* TODO: worry about recursion into parent types of the unions? */\n+      if (compare_components (cmp1, cmp2,\n+            map1->ts.u.derived, map2->ts.u.derived) == 0)\n+        return 0;\n+\n+      cmp1 = cmp1->next;\n+      cmp2 = cmp2->next;\n+\n+      if (cmp1 == NULL && cmp2 == NULL)\n+        break;\n+      if (cmp1 == NULL || cmp2 == NULL)\n+        return 0;\n+    }\n+\n+    map1 = map1->next;\n+    map2 = map2->next;\n+\n+    if (map1 == NULL && map2 == NULL)\n+      break;\n+    if (map1 == NULL || map2 == NULL)\n+      return 0;\n+  }\n+\n+  return 1;\n+}\n+\n+\n+\n /* Compare two derived types using the criteria in 4.4.2 of the standard,\n    recursing through gfc_compare_types for the components.  */\n \n int\n gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n {\n-  gfc_component *dt1, *dt2;\n+  gfc_component *cmp1, *cmp2;\n+  bool anonymous = false;\n \n   if (derived1 == derived2)\n     return 1;\n \n   gcc_assert (derived1 && derived2);\n \n+  /* MAP and anonymous STRUCTURE types have internal names of the form\n+     mM* and sS* (we can get away this this because source names are converted\n+     to lowerase). Compare anonymous type names specially because each\n+     gets a unique name when it is declared. */\n+  anonymous = (derived1->name[0] == derived2->name[0]\n+      && derived1->name[1] && derived2->name[1] && derived2->name[2]\n+      && derived1->name[1] == (char) TOUPPER (derived1->name[0])\n+      && derived2->name[2] == (char) TOUPPER (derived2->name[0]));\n+\n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n@@ -409,9 +537,11 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n     return 1;\n \n   /* Compare type via the rules of the standard.  Both types must have\n-     the SEQUENCE or BIND(C) attribute to be equal.  */\n+     the SEQUENCE or BIND(C) attribute to be equal. STRUCTUREs are special\n+     because they can be anonymous; therefore two structures with different\n+     names may be equal.  */\n \n-  if (strcmp (derived1->name, derived2->name))\n+  if (strcmp (derived1->name, derived2->name) != 0 && !anonymous)\n     return 0;\n \n   if (derived1->component_access == ACCESS_PRIVATE\n@@ -422,53 +552,30 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n       && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c))\n     return 0;\n \n-  dt1 = derived1->components;\n-  dt2 = derived2->components;\n+  /* Protect against null components.  */\n+  if (derived1->attr.zero_comp != derived2->attr.zero_comp)\n+    return 0;\n+\n+  if (derived1->attr.zero_comp)\n+    return 1;\n+\n+  cmp1 = derived1->components;\n+  cmp2 = derived2->components;\n \n   /* Since subtypes of SEQUENCE types must be SEQUENCE types as well, a\n      simple test can speed things up.  Otherwise, lots of things have to\n      match.  */\n   for (;;)\n     {\n-      if (strcmp (dt1->name, dt2->name) != 0)\n-\treturn 0;\n-\n-      if (dt1->attr.access != dt2->attr.access)\n-\treturn 0;\n-\n-      if (dt1->attr.pointer != dt2->attr.pointer)\n-\treturn 0;\n-\n-      if (dt1->attr.dimension != dt2->attr.dimension)\n-\treturn 0;\n+      if (!compare_components (cmp1, cmp2, derived1, derived2))\n+        return 0;\n \n-     if (dt1->attr.allocatable != dt2->attr.allocatable)\n-\treturn 0;\n-\n-      if (dt1->attr.dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)\n-\treturn 0;\n-\n-      /* Make sure that link lists do not put this function into an\n-\t endless recursive loop!  */\n-      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n-\t    && !(dt2->ts.type == BT_DERIVED && derived2 == dt2->ts.u.derived)\n-\t    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)\n-\treturn 0;\n+      cmp1 = cmp1->next;\n+      cmp2 = cmp2->next;\n \n-      else if ((dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n-\t\t&& !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))\n-\treturn 0;\n-\n-      else if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n-\t\t&& (dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))\n-\treturn 0;\n-\n-      dt1 = dt1->next;\n-      dt2 = dt2->next;\n-\n-      if (dt1 == NULL && dt2 == NULL)\n+      if (cmp1 == NULL && cmp2 == NULL)\n \tbreak;\n-      if (dt1 == NULL || dt2 == NULL)\n+      if (cmp1 == NULL || cmp2 == NULL)\n \treturn 0;\n     }\n \n@@ -509,18 +616,18 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n       && (ts1->u.derived->attr.sequence || ts1->u.derived->attr.is_bind_c))\n     return 1;\n \n+  if (ts1->type == BT_UNION && ts2->type == BT_UNION)\n+    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);\n+\n   if (ts1->type != ts2->type\n-      && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n-\t  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))\n+      && ((!gfc_bt_struct (ts1->type) && ts1->type != BT_CLASS)\n+\t  || (!gfc_bt_struct (ts2->type) && ts2->type != BT_CLASS)))\n     return 0;\n   if (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n     return (ts1->kind == ts2->kind);\n \n   /* Compare derived types.  */\n-  if (gfc_type_compatible (ts1, ts2))\n-    return 1;\n-\n-  return gfc_compare_derived_types (ts1->u.derived ,ts2->u.derived);\n+  return gfc_type_compatible (ts1, ts2);\n }\n \n \n@@ -1585,7 +1692,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t functions or subroutines.  */\n       if (((!p->sym->attr.function && !p->sym->attr.subroutine)\n \t   || !p->sym->attr.if_source)\n-\t  && p->sym->attr.flavor != FL_DERIVED)\n+\t  && !gfc_fl_struct (p->sym->attr.flavor))\n \t{\n \t  if (p->sym->attr.external)\n \t    gfc_error (\"Procedure %qs in %s at %L has no explicit interface\",\n@@ -1599,14 +1706,14 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \n       /* Verify that procedures are either all SUBROUTINEs or all FUNCTIONs.  */\n       if ((psave->sym->attr.function && !p->sym->attr.function\n-\t   && p->sym->attr.flavor != FL_DERIVED)\n+\t   && !gfc_fl_struct (p->sym->attr.flavor))\n \t  || (psave->sym->attr.subroutine && !p->sym->attr.subroutine))\n \t{\n-\t  if (p->sym->attr.flavor != FL_DERIVED)\n+\t  if (!gfc_fl_struct (p->sym->attr.flavor))\n \t    gfc_error (\"In %s at %L procedures must be either all SUBROUTINEs\"\n \t\t       \" or all FUNCTIONs\", interface_name,\n \t\t       &p->sym->declared_at);\n-\t  else\n+\t  else if (p->sym->attr.flavor == FL_DERIVED)\n \t    gfc_error (\"In %s at %L procedures must be all FUNCTIONs as the \"\n \t\t       \"generic name is also the name of a derived type\",\n \t\t       interface_name, &p->sym->declared_at);\n@@ -1666,8 +1773,8 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \tif (p->sym->name == q->sym->name && p->sym->module == q->sym->module)\n \t  continue;\n \n-\tif (p->sym->attr.flavor != FL_DERIVED\n-\t    && q->sym->attr.flavor != FL_DERIVED\n+\tif (!gfc_fl_struct (p->sym->attr.flavor)\n+\t    && !gfc_fl_struct (q->sym->attr.flavor)\n \t    && gfc_compare_interfaces (p->sym, q->sym, q->sym->name,\n \t\t\t\t       generic_flag, 0, NULL, 0, NULL, NULL))\n \t  {\n@@ -3550,7 +3657,7 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,\n \n   for (; intr; intr = intr->next)\n     {\n-      if (intr->sym->attr.flavor == FL_DERIVED)\n+      if (gfc_fl_struct (intr->sym->attr.flavor))\n \tcontinue;\n       if (sub_flag && intr->sym->attr.function)\n \tcontinue;"}, {"sha": "e8b8409319e485b1f3fa381e4626e4a0f1018911", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -115,7 +115,8 @@ by type.  Explanations are in the following sections.\n @item Fortran Language Options\n @xref{Fortran Dialect Options,,Options controlling Fortran dialect}.\n @gccoptlist{-fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code @gol\n--fd-lines-as-comments -fdefault-double-8 -fdefault-integer-8 @gol\n+-fd-lines-as-comments @gol\n+-fdec -fdec-structure -fdefault-double-8 -fdefault-integer-8 @gol\n -fdefault-real-8 -fdollar-ok -ffixed-line-length-@var{n} @gol\n -ffixed-line-length-none -ffree-form -ffree-line-length-@var{n} @gol\n -ffree-line-length-none -fimplicit-none -finteger-4-integer-8 @gol\n@@ -228,6 +229,24 @@ given they are treated as if the first column contained a blank.  If the\n @option{-fd-lines-as-comments} option is given, they are treated as\n comment lines.\n \n+@item -fdec\n+@opindex @code{fdec}\n+DEC compatibility mode. Enables extensions and other features that mimic\n+the default behavior of older compilers (such as DEC).\n+These features are non-standard and should be avoided at all costs.\n+For details on GNU Fortran's implementation of these extensions see the \n+full documentation.\n+\n+Other flags enabled by this switch are:\n+@option{-fdollar-ok} @option{-fcray-pointer} @option{-fdec-structure}\n+\n+@item -fdec-structure\n+@opindex @code{fdec-structure}\n+Enable DEC @code{STRUCTURE} and @code{RECORD} as well as @code{UNION},\n+@code{MAP}, and dot ('.') as a member separator (in addition to '%'). This is\n+provided for compatibility only; Fortran 90 derived types should be used\n+instead where possible.\n+\n @item -fdollar-ok\n @opindex @code{fdollar-ok}\n @cindex @code{$}"}, {"sha": "bdf5fa5fb4a1cd88c19406280b944db5d5bf11ab", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -416,6 +416,14 @@ fd-lines-as-comments\n Fortran RejectNegative\n Treat lines with 'D' in column one as comments.\n \n+fdec\n+Fortran\n+Enable all DEC language extensions.\n+\n+fdec-structure\n+Fortran\n+Enable support for DEC STRUCTURE/RECORD.\n+\n fdefault-double-8\n Fortran Var(flag_default_double)\n Set the default double precision kind to an 8 byte wide type."}, {"sha": "e913250636700a3ebca5caffc3bbeee16c40c338", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -164,6 +164,6 @@ typedef enum\n typedef enum\n { BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,\n   BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,\n-  BT_ASSUMED\n+  BT_ASSUMED, BT_UNION\n }\n bt;"}, {"sha": "f3a4a43a34c8e5548a3a4172bd2ef66aaa9ac398", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -113,6 +113,128 @@ gfc_op2string (gfc_intrinsic_op op)\n \n /******************** Generic matching subroutines ************************/\n \n+/* Matches a member separator. With standard FORTRAN this is '%', but with\n+   DEC structures we must carefully match dot ('.').\n+   Because operators are spelled \".op.\", a dotted string such as \"x.y.z...\"\n+   can be either a component reference chain or a combination of binary\n+   operations.\n+   There is no real way to win because the string may be grammatically\n+   ambiguous. The following rules help avoid ambiguities - they match\n+   some behavior of other (older) compilers. If the rules here are changed\n+   the test cases should be updated. If the user has problems with these rules\n+   they probably deserve the consequences. Consider \"x.y.z\":\n+     (1) If any user defined operator \".y.\" exists, this is always y(x,z)\n+         (even if \".y.\" is the wrong type and/or x has a member y).\n+     (2) Otherwise if x has a member y, and y is itself a derived type,\n+         this is (x->y)->z, even if an intrinsic operator exists which \n+         can handle (x,z). \n+     (3) If x has no member y or (x->y) is not a derived type but \".y.\" \n+         is an intrinsic operator (such as \".eq.\"), this is y(x,z).\n+     (4) Lastly if there is no operator \".y.\" and x has no member \"y\", it is an\n+         error.  \n+   It is worth noting that the logic here does not support mixed use of member\n+   accessors within a single string. That is, even if x has component y and y\n+   has component z, the following are all syntax errors:\n+         \"x%y.z\"  \"x.y%z\" \"(x.y).z\"  \"(x%y)%z\"\n+ */\n+\n+match\n+gfc_match_member_sep(gfc_symbol *sym)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  locus dot_loc, start_loc;\n+  gfc_intrinsic_op iop;\n+  match m;\n+  gfc_symbol *tsym;\n+  gfc_component *c = NULL;\n+\n+  /* What a relief: '%' is an unambiguous member separator.  */\n+  if (gfc_match_char ('%') == MATCH_YES)\n+    return MATCH_YES;\n+\n+  /* Beware ye who enter here.  */\n+  if (!gfc_option.flag_dec_structure || !sym)\n+    return MATCH_NO;\n+\n+  tsym = NULL;\n+\n+  /* We may be given either a derived type variable or the derived type\n+    declaration itself (which actually contains the components); \n+    we need the latter to search for components.  */\n+  if (gfc_fl_struct (sym->attr.flavor))\n+    tsym = sym;\n+  else if (gfc_bt_struct (sym->ts.type))\n+    tsym = sym->ts.u.derived;\n+\n+  iop = INTRINSIC_NONE;\n+  name[0] = '\\0';\n+  m = MATCH_NO;\n+\n+  /* If we have to reject come back here later.  */\n+  start_loc = gfc_current_locus;\n+\n+  /* Look for a component access next.  */\n+  if (gfc_match_char ('.') != MATCH_YES)\n+    return MATCH_NO;\n+\n+  /* If we accept, come back here.  */\n+  dot_loc = gfc_current_locus;\n+\n+  /* Try to match a symbol name following the dot.  */\n+  if (gfc_match_name (name) != MATCH_YES)\n+    {\n+      gfc_error (\"Expected structure component or operator name \"\n+                 \"after '.' at %C\");\n+      goto error;\n+    }\n+\n+  /* If no dot follows we have \"x.y\" which should be a component access.  */\n+  if (gfc_match_char ('.') != MATCH_YES)\n+    goto yes;\n+\n+  /* Now we have a string \"x.y.z\" which could be a nested member access\n+    (x->y)->z or a binary operation y on x and z.  */\n+\n+  /* First use any user-defined operators \".y.\"  */\n+  if (gfc_find_uop (name, sym->ns) != NULL)\n+    goto no;\n+\n+  /* Match accesses to existing derived-type components for \n+    derived-type vars: \"x.y.z\" = (x->y)->z  */\n+  c = gfc_find_component(tsym, name, false, true, NULL);\n+  if (c && (gfc_bt_struct (c->ts.type) || c->ts.type == BT_CLASS))\n+    goto yes;\n+\n+  /* If y is not a component or has no members, try intrinsic operators.  */\n+  gfc_current_locus = start_loc;\n+  if (gfc_match_intrinsic_op (&iop) != MATCH_YES)\n+    {\n+      /* If \".y.\" is not an intrinsic operator but y was a valid non-\n+        structure component, match and leave the trailing dot to be \n+        dealt with later.  */\n+      if (c)\n+        goto yes;\n+\n+      gfc_error (\"'%s' is neither a defined operator nor a \"\n+                 \"structure component in dotted string at %C\", name);\n+      goto error;\n+    }\n+\n+  /* .y. is an intrinsic operator, overriding any possible member access.  */\n+  goto no;\n+\n+  /* Return keeping the current locus consistent with the match result.  */\n+error:\n+  m = MATCH_ERROR;\n+no:\n+  gfc_current_locus = start_loc;\n+  return m;\n+yes:\n+  gfc_current_locus = dot_loc;\n+  return MATCH_YES;\n+}\n+\n+\n /* This function scans the current statement counting the opened and closed\n    parenthesis to make sure they are balanced.  */\n "}, {"sha": "348ca701c92d3547d70e6fdef03f36486c2c08f1", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -60,6 +60,7 @@ match gfc_match (const char *, ...);\n match gfc_match_iterator (gfc_iterator *, int);\n match gfc_match_parens (void);\n match gfc_match_type_spec (gfc_typespec *);\n+match gfc_match_member_sep(gfc_symbol *);\n \n \n /* Statement matchers.  */\n@@ -208,6 +209,9 @@ match gfc_match_function_decl (void);\n match gfc_match_entry (void);\n match gfc_match_subroutine (void);\n match gfc_match_submod_proc (void);\n+match gfc_match_map (void);\n+match gfc_match_union (void);\n+match gfc_match_structure_decl (void);\n match gfc_match_derived_decl (void);\n match gfc_match_final_decl (void);\n "}, {"sha": "1747ff2ac7461b23693721dc9e109ede31acfab7", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -83,6 +83,9 @@ gfc_basic_typename (bt type)\n     case BT_HOLLERITH:\n       p = \"HOLLERITH\";\n       break;\n+    case BT_UNION:\n+      p = \"UNION\";\n+      break;\n     case BT_DERIVED:\n       p = \"DERIVED\";\n       break;\n@@ -144,6 +147,9 @@ gfc_typename (gfc_typespec *ts)\n     case BT_HOLLERITH:\n       sprintf (buffer, \"HOLLERITH\");\n       break;\n+    case BT_UNION:\n+      sprintf (buffer, \"UNION(%s)\", ts->u.derived->name);\n+      break;\n     case BT_DERIVED:\n       sprintf (buffer, \"TYPE(%s)\", ts->u.derived->name);\n       break;"}, {"sha": "6d3860ef826e0165318fbe7a287ba6a81d078a76", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -422,8 +422,8 @@ resolve_fixups (fixup_t *f, void *gp)\n    to convert the symtree name of a derived-type to the symbol name or to\n    the name of the associated generic function.  */\n \n-static const char *\n-dt_lower_string (const char *name)\n+const char *\n+gfc_dt_lower_string (const char *name)\n {\n   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))\n     return gfc_get_string (\"%c%s\", (char) TOLOWER ((unsigned char) name[0]),\n@@ -437,8 +437,8 @@ dt_lower_string (const char *name)\n    symtree/symbol name of the associated generic function start with a lower-\n    case character.  */\n \n-static const char *\n-dt_upper_string (const char *name)\n+const char *\n+gfc_dt_upper_string (const char *name)\n {\n   if (name[0] != (char) TOUPPER ((unsigned char) name[0]))\n     return gfc_get_string (\"%c%s\", (char) TOUPPER ((unsigned char) name[0]),\n@@ -832,7 +832,7 @@ find_use_name_n (const char *name, int *inst, bool interface)\n \n   /* For derived types.  */\n   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))\n-    low_name = dt_lower_string (name);\n+    low_name = gfc_dt_lower_string (name);\n \n   i = 0;\n   for (u = gfc_rename_list; u; u = u->next)\n@@ -861,7 +861,7 @@ find_use_name_n (const char *name, int *inst, bool interface)\n     {\n       if (u->local_name[0] == '\\0')\n \treturn name;\n-      return dt_upper_string (u->local_name);\n+      return gfc_dt_upper_string (u->local_name);\n     }\n \n   return (u->local_name[0] != '\\0') ? u->local_name : name;\n@@ -989,8 +989,8 @@ add_true_name (gfc_symbol *sym)\n \n   t = XCNEW (true_name);\n   t->sym = sym;\n-  if (sym->attr.flavor == FL_DERIVED)\n-    t->name = dt_upper_string (sym->name);\n+  if (gfc_fl_struct (sym->attr.flavor))\n+    t->name = gfc_dt_upper_string (sym->name);\n   else\n     t->name = sym->name;\n \n@@ -1011,8 +1011,8 @@ build_tnt (gfc_symtree *st)\n   build_tnt (st->left);\n   build_tnt (st->right);\n \n-  if (st->n.sym->attr.flavor == FL_DERIVED)\n-    name = dt_upper_string (st->n.sym->name);\n+  if (gfc_fl_struct (st->n.sym->attr.flavor))\n+    name = gfc_dt_upper_string (st->n.sym->name);\n   else\n     name = st->n.sym->name;\n \n@@ -2452,6 +2452,7 @@ static const mstring bt_types[] = {\n     minit (\"COMPLEX\", BT_COMPLEX),\n     minit (\"LOGICAL\", BT_LOGICAL),\n     minit (\"CHARACTER\", BT_CHARACTER),\n+    minit (\"UNION\", BT_UNION),\n     minit (\"DERIVED\", BT_DERIVED),\n     minit (\"CLASS\", BT_CLASS),\n     minit (\"PROCEDURE\", BT_PROCEDURE),\n@@ -2505,7 +2506,7 @@ mio_typespec (gfc_typespec *ts)\n \n   ts->type = MIO_NAME (bt) (ts->type, bt_types);\n \n-  if (ts->type != BT_DERIVED && ts->type != BT_CLASS)\n+  if (!gfc_bt_struct (ts->type) && ts->type != BT_CLASS)\n     mio_integer (&ts->kind);\n   else\n     mio_symbol_ref (&ts->u.derived);\n@@ -3322,8 +3323,8 @@ fix_mio_expr (gfc_expr *e)\n       if (e->symtree->n.sym && check_unique_name (e->symtree->name))\n \t{\n           const char *name = e->symtree->n.sym->name;\n-\t  if (e->symtree->n.sym->attr.flavor == FL_DERIVED)\n-\t    name = dt_upper_string (name);\n+\t  if (gfc_fl_struct (e->symtree->n.sym->attr.flavor))\n+\t    name = gfc_dt_upper_string (name);\n \t  ns_st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n \t}\n \n@@ -4265,7 +4266,7 @@ mio_symbol (gfc_symbol *sym)\n \n   mio_integer (&(sym->intmod_sym_id));\n \n-  if (sym->attr.flavor == FL_DERIVED)\n+  if (gfc_fl_struct (sym->attr.flavor))\n     mio_integer (&(sym->hash_value));\n \n   if (sym->formal_ns\n@@ -4845,7 +4846,7 @@ load_needed (pointer_info *p)\n \t\t\t\t 1, &ns->proc_name);\n \n       sym = gfc_new_symbol (p->u.rsym.true_name, ns);\n-      sym->name = dt_lower_string (p->u.rsym.true_name);\n+      sym->name = gfc_dt_lower_string (p->u.rsym.true_name);\n       sym->module = gfc_get_string (p->u.rsym.module);\n       if (p->u.rsym.binding_label)\n \tsym->binding_label = IDENTIFIER_POINTER (get_identifier\n@@ -4857,6 +4858,12 @@ load_needed (pointer_info *p)\n   mio_symbol (sym);\n   sym->attr.use_assoc = 1;\n \n+  /* Unliked derived types, a STRUCTURE may share names with other symbols.\n+     We greedily converted the the symbol name to lowercase before we knew its\n+     type, so now we must fix it. */\n+  if (sym->attr.flavor == FL_STRUCT)\n+    sym->name = gfc_dt_upper_string (sym->name);\n+\n   /* Mark as only or rename for later diagnosis for explicitly imported\n      but not used warnings; don't mark internal symbols such as __vtab,\n      __def_init etc. Only mark them if they have been explicitly loaded.  */\n@@ -5059,7 +5066,7 @@ read_module (void)\n \t can be used in expressions in the module.  To avoid the module loading\n \t failing, we need to associate the module's component pointer indexes\n \t with the existing symbol's component pointers.  */\n-      if (sym->attr.flavor == FL_DERIVED)\n+      if (gfc_fl_struct (sym->attr.flavor))\n \t{\n \t  gfc_component *c;\n \n@@ -5213,7 +5220,7 @@ read_module (void)\n \t\t{\n \t\t  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,\n \t\t\t\t\t\t     gfc_current_ns);\n-\t\t  info->u.rsym.sym->name = dt_lower_string (info->u.rsym.true_name);\n+\t\t  info->u.rsym.sym->name = gfc_dt_lower_string (info->u.rsym.true_name);\n \t\t  sym = info->u.rsym.sym;\n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n \n@@ -5557,10 +5564,10 @@ write_symbol (int n, gfc_symbol *sym)\n \n   mio_integer (&n);\n \n-  if (sym->attr.flavor == FL_DERIVED)\n+  if (gfc_fl_struct (sym->attr.flavor))\n     {\n       const char *name;\n-      name = dt_upper_string (sym->name);\n+      name = gfc_dt_upper_string (sym->name);\n       mio_pool_string (&name);\n     }\n   else\n@@ -6568,7 +6575,7 @@ create_derived_type (const char *name, const char *modname,\n   sym->attr.function = 1;\n   sym->attr.generic = 1;\n \n-  gfc_get_sym_tree (dt_upper_string (sym->name),\n+  gfc_get_sym_tree (gfc_dt_upper_string (sym->name),\n \t\t    gfc_current_ns, &tmp_symtree, false);\n   dt_sym = tmp_symtree->n.sym;\n   dt_sym->name = gfc_get_string (sym->name);"}, {"sha": "5a91ec1b2095eec5e65546e6e081cca56b512a04", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -47,6 +47,15 @@ set_default_std_flags (void)\n }\n \n \n+/* Set all the DEC extension flags. */\n+\n+static void\n+set_dec_flags (int value)\n+{\n+    gfc_option.flag_dec_structure  = value;\n+}\n+\n+\n /* Return language mask for Fortran options.  */\n \n unsigned int\n@@ -102,6 +111,8 @@ gfc_init_options (unsigned int decoded_options_count,\n   if (!global_options_set.x_cpp_warn_missing_include_dirs)\n     global_options.x_cpp_warn_missing_include_dirs = 1;\n \n+  set_dec_flags (0);\n+\n   set_default_std_flags ();\n \n   /* Initialize cpp-related options.  */\n@@ -709,6 +720,15 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n     case OPT_fcheck_:\n       gfc_handle_runtime_check_option (arg);\n       break;\n+\n+    case OPT_fdec:\n+      /* Enable all DEC extensions.  */\n+      set_dec_flags (1);\n+      break;\n+\n+    case OPT_fdec_structure:\n+      gfc_option.flag_dec_structure = 1;\n+      break;\n     }\n \n   Fortran_handle_option_auto (&global_options, &global_options_set, "}, {"sha": "dd7aa6a4e13b23531a226bdd547e732eddff0596", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 381, "deletions": 164, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -256,6 +256,7 @@ decode_specification_statement (void)\n \n     case 's':\n       match (\"save\", gfc_match_save, ST_ATTR_DECL);\n+      match (\"structure\", gfc_match_structure_decl, ST_STRUCTURE_DECL);\n       break;\n \n     case 't':\n@@ -507,6 +508,7 @@ decode_statement (void)\n       break;\n \n     case 'm':\n+      match (\"map\", gfc_match_map, ST_MAP);\n       match (\"module% procedure\", gfc_match_modproc, ST_MODULE_PROC);\n       match (\"module\", gfc_match_module, ST_MODULE);\n       break;\n@@ -542,6 +544,7 @@ decode_statement (void)\n       break;\n \n     case 's':\n+      match (\"structure\", gfc_match_structure_decl, ST_STRUCTURE_DECL);\n       match (\"sequence\", gfc_match_eos, ST_SEQUENCE);\n       match (\"stop\", gfc_match_stop, ST_STOP);\n       match (\"save\", gfc_match_save, ST_ATTR_DECL);\n@@ -558,6 +561,7 @@ decode_statement (void)\n       break;\n \n     case 'u':\n+      match (\"union\", gfc_match_union, ST_UNION);\n       match (\"unlock\", gfc_match_unlock, ST_UNLOCK);\n       break;\n \n@@ -1642,6 +1646,15 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_DEALLOCATE:\n       p = \"DEALLOCATE\";\n       break;\n+    case ST_MAP:\n+      p = \"MAP\";\n+      break;\n+    case ST_UNION:\n+      p = \"UNION\";\n+      break;\n+    case ST_STRUCTURE_DECL:\n+      p = \"STRUCTURE\";\n+      break;\n     case ST_DERIVED_DECL:\n       p = _(\"derived type declaration\");\n       break;\n@@ -1711,6 +1724,15 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_END_WHERE:\n       p = \"END WHERE\";\n       break;\n+    case ST_END_STRUCTURE:\n+      p = \"END STRUCTURE\";\n+      break;\n+    case ST_END_UNION:\n+      p = \"END UNION\";\n+      break;\n+    case ST_END_MAP:\n+      p = \"END MAP\";\n+      break;\n     case ST_END_TYPE:\n       p = \"END TYPE\";\n       break;\n@@ -2457,6 +2479,7 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)\n \n     case ST_PUBLIC:\n     case ST_PRIVATE:\n+    case ST_STRUCTURE_DECL:\n     case ST_DERIVED_DECL:\n     case_decl:\n       if (p->state >= ORDER_EXEC)\n@@ -2646,6 +2669,358 @@ parse_derived_contains (void)\n }\n \n \n+/* Set attributes for the parent symbol based on the attributes of a component\n+   and raise errors if conflicting attributes are found for the component.  */\n+\n+static void\n+check_component (gfc_symbol *sym, gfc_component *c, gfc_component **lockp,\n+    gfc_component **eventp)\n+{\n+  bool coarray, lock_type, event_type, allocatable, pointer;\n+  coarray = lock_type = event_type = allocatable = pointer = false;\n+  gfc_component *lock_comp = NULL, *event_comp = NULL;\n+\n+  if (lockp) lock_comp = *lockp;\n+  if (eventp) event_comp = *eventp;\n+\n+  /* Look for allocatable components.  */\n+  if (c->attr.allocatable\n+      || (c->ts.type == BT_CLASS && c->attr.class_ok\n+          && CLASS_DATA (c)->attr.allocatable)\n+      || (c->ts.type == BT_DERIVED && !c->attr.pointer\n+          && c->ts.u.derived->attr.alloc_comp))\n+    {\n+      allocatable = true;\n+      sym->attr.alloc_comp = 1;\n+    }\n+\n+  /* Look for pointer components.  */\n+  if (c->attr.pointer\n+      || (c->ts.type == BT_CLASS && c->attr.class_ok\n+          && CLASS_DATA (c)->attr.class_pointer)\n+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))\n+    {\n+      pointer = true;\n+      sym->attr.pointer_comp = 1;\n+    }\n+\n+  /* Look for procedure pointer components.  */\n+  if (c->attr.proc_pointer\n+      || (c->ts.type == BT_DERIVED\n+          && c->ts.u.derived->attr.proc_pointer_comp))\n+    sym->attr.proc_pointer_comp = 1;\n+\n+  /* Looking for coarray components.  */\n+  if (c->attr.codimension\n+      || (c->ts.type == BT_CLASS && c->attr.class_ok\n+          && CLASS_DATA (c)->attr.codimension))\n+    {\n+      coarray = true;\n+      sym->attr.coarray_comp = 1;\n+    }\n+ \n+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n+      && !c->attr.pointer)\n+    {\n+      coarray = true;\n+      sym->attr.coarray_comp = 1;\n+    }\n+\n+  /* Looking for lock_type components.  */\n+  if ((c->ts.type == BT_DERIVED\n+          && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+          && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n+      || (c->ts.type == BT_CLASS && c->attr.class_ok\n+          && CLASS_DATA (c)->ts.u.derived->from_intmod\n+             == INTMOD_ISO_FORTRAN_ENV\n+          && CLASS_DATA (c)->ts.u.derived->intmod_sym_id\n+             == ISOFORTRAN_LOCK_TYPE)\n+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp\n+          && !allocatable && !pointer))\n+    {\n+      lock_type = 1;\n+      lock_comp = c;\n+      sym->attr.lock_comp = 1;\n+    }\n+\n+    /* Looking for event_type components.  */\n+    if ((c->ts.type == BT_DERIVED\n+            && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+            && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+        || (c->ts.type == BT_CLASS && c->attr.class_ok\n+            && CLASS_DATA (c)->ts.u.derived->from_intmod\n+               == INTMOD_ISO_FORTRAN_ENV\n+            && CLASS_DATA (c)->ts.u.derived->intmod_sym_id\n+               == ISOFORTRAN_EVENT_TYPE)\n+        || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.event_comp\n+            && !allocatable && !pointer))\n+      {\n+        event_type = 1;\n+        event_comp = c;\n+        sym->attr.event_comp = 1;\n+      }\n+\n+  /* Check for F2008, C1302 - and recall that pointers may not be coarrays\n+     (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),\n+     unless there are nondirect [allocatable or pointer] components\n+     involved (cf. 1.3.33.1 and 1.3.33.3).  */\n+\n+  if (pointer && !coarray && lock_type)\n+    gfc_error (\"Component %s at %L of type LOCK_TYPE must have a \"\n+               \"codimension or be a subcomponent of a coarray, \"\n+               \"which is not possible as the component has the \"\n+               \"pointer attribute\", c->name, &c->loc);\n+  else if (pointer && !coarray && c->ts.type == BT_DERIVED\n+           && c->ts.u.derived->attr.lock_comp)\n+    gfc_error (\"Pointer component %s at %L has a noncoarray subcomponent \"\n+               \"of type LOCK_TYPE, which must have a codimension or be a \"\n+               \"subcomponent of a coarray\", c->name, &c->loc);\n+\n+  if (lock_type && allocatable && !coarray)\n+    gfc_error (\"Allocatable component %s at %L of type LOCK_TYPE must have \"\n+               \"a codimension\", c->name, &c->loc);\n+  else if (lock_type && allocatable && c->ts.type == BT_DERIVED\n+           && c->ts.u.derived->attr.lock_comp)\n+    gfc_error (\"Allocatable component %s at %L must have a codimension as \"\n+               \"it has a noncoarray subcomponent of type LOCK_TYPE\",\n+               c->name, &c->loc);\n+\n+  if (sym->attr.coarray_comp && !coarray && lock_type)\n+    gfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n+               \"subcomponent of type LOCK_TYPE must have a codimension or \"\n+               \"be a subcomponent of a coarray. (Variables of type %s may \"\n+               \"not have a codimension as already a coarray \"\n+               \"subcomponent exists)\", c->name, &c->loc, sym->name);\n+\n+  if (sym->attr.lock_comp && coarray && !lock_type)\n+    gfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n+               \"subcomponent of type LOCK_TYPE must have a codimension or \"\n+               \"be a subcomponent of a coarray. (Variables of type %s may \"\n+               \"not have a codimension as %s at %L has a codimension or a \"\n+               \"coarray subcomponent)\", lock_comp->name, &lock_comp->loc,\n+               sym->name, c->name, &c->loc);\n+\n+  /* Similarly for EVENT TYPE.  */\n+\n+  if (pointer && !coarray && event_type)\n+    gfc_error (\"Component %s at %L of type EVENT_TYPE must have a \"\n+               \"codimension or be a subcomponent of a coarray, \"\n+               \"which is not possible as the component has the \"\n+               \"pointer attribute\", c->name, &c->loc);\n+  else if (pointer && !coarray && c->ts.type == BT_DERIVED\n+           && c->ts.u.derived->attr.event_comp)\n+    gfc_error (\"Pointer component %s at %L has a noncoarray subcomponent \"\n+               \"of type EVENT_TYPE, which must have a codimension or be a \"\n+               \"subcomponent of a coarray\", c->name, &c->loc);\n+\n+  if (event_type && allocatable && !coarray)\n+    gfc_error (\"Allocatable component %s at %L of type EVENT_TYPE must have \"\n+               \"a codimension\", c->name, &c->loc);\n+  else if (event_type && allocatable && c->ts.type == BT_DERIVED\n+           && c->ts.u.derived->attr.event_comp)\n+    gfc_error (\"Allocatable component %s at %L must have a codimension as \"\n+               \"it has a noncoarray subcomponent of type EVENT_TYPE\",\n+               c->name, &c->loc);\n+\n+  if (sym->attr.coarray_comp && !coarray && event_type)\n+    gfc_error (\"Noncoarray component %s at %L of type EVENT_TYPE or with \"\n+               \"subcomponent of type EVENT_TYPE must have a codimension or \"\n+               \"be a subcomponent of a coarray. (Variables of type %s may \"\n+               \"not have a codimension as already a coarray \"\n+               \"subcomponent exists)\", c->name, &c->loc, sym->name);\n+\n+  if (sym->attr.event_comp && coarray && !event_type)\n+    gfc_error (\"Noncoarray component %s at %L of type EVENT_TYPE or with \"\n+               \"subcomponent of type EVENT_TYPE must have a codimension or \"\n+               \"be a subcomponent of a coarray. (Variables of type %s may \"\n+               \"not have a codimension as %s at %L has a codimension or a \"\n+               \"coarray subcomponent)\", event_comp->name, &event_comp->loc,\n+               sym->name, c->name, &c->loc);\n+\n+  /* Look for private components.  */\n+  if (sym->component_access == ACCESS_PRIVATE\n+      || c->attr.access == ACCESS_PRIVATE\n+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))\n+    sym->attr.private_comp = 1;\n+\n+  if (lockp) *lockp = lock_comp;\n+  if (eventp) *eventp = event_comp;\n+}\n+\n+\n+static void parse_struct_map (gfc_statement);\n+\n+/* Parse a union component definition within a structure definition.  */\n+\n+static void\n+parse_union (void)\n+{\n+  int compiling;\n+  gfc_statement st;\n+  gfc_state_data s;\n+  gfc_component *c, *lock_comp = NULL, *event_comp = NULL;\n+  gfc_symbol *un;\n+\n+  accept_statement(ST_UNION);\n+  push_state (&s, COMP_UNION, gfc_new_block);\n+  un = gfc_new_block;\n+\n+  compiling = 1;\n+\n+  while (compiling)\n+    {\n+      st = next_statement ();\n+      /* Only MAP declarations valid within a union. */\n+      switch (st)\n+        {\n+        case ST_NONE:\n+          unexpected_eof ();\n+\n+        case ST_MAP:\n+          accept_statement (ST_MAP);\n+          parse_struct_map (ST_MAP);\n+          /* Add a component to the union for each map. */\n+          if (!gfc_add_component (un, gfc_new_block->name, &c))\n+            {\n+              gfc_internal_error (\"failed to create map component '%s'\", \n+                  gfc_new_block->name);\n+              reject_statement ();\n+              return;\n+            }\n+          c->ts.type = BT_DERIVED;\n+          c->ts.u.derived = gfc_new_block;\n+          /* Normally components get their initialization expressions when they\n+             are created in decl.c (build_struct) so we can look through the\n+             flat component list for initializers during resolution. Unions and\n+             maps create components along with their type definitions so we\n+             have to generate initializers here. */\n+          c->initializer = gfc_default_initializer (&c->ts);\n+          break;\n+\n+        case ST_END_UNION:\n+          compiling = 0;\n+          accept_statement (ST_END_UNION);\n+          break;\n+\n+        default:\n+          unexpected_statement (st);\n+          break;\n+        }\n+    }\n+\n+  for (c = un->components; c; c = c->next)\n+    check_component (un, c, &lock_comp, &event_comp);\n+\n+  /* Add the union as a component in its parent structure.  */\n+  pop_state ();\n+  if (!gfc_add_component (gfc_current_block (), un->name, &c))\n+    {\n+      gfc_internal_error (\"failed to create union component '%s'\", un->name);\n+      reject_statement ();\n+      return;\n+    }\n+  c->ts.type = BT_UNION;\n+  c->ts.u.derived = un;\n+  c->initializer = gfc_default_initializer (&c->ts);\n+\n+  un->attr.zero_comp = un->components == NULL;\n+}\n+\n+\n+/* Parse a STRUCTURE or MAP.  */\n+\n+static void\n+parse_struct_map (gfc_statement block)\n+{\n+  int compiling_type;\n+  gfc_statement st;\n+  gfc_state_data s;\n+  gfc_symbol *sym;\n+  gfc_component *c, *lock_comp = NULL, *event_comp = NULL;\n+  gfc_compile_state comp;\n+  gfc_statement ends;\n+\n+  if (block == ST_STRUCTURE_DECL)\n+    {\n+      comp = COMP_STRUCTURE;\n+      ends = ST_END_STRUCTURE;\n+    }\n+  else\n+    {\n+      gcc_assert (block == ST_MAP);\n+      comp = COMP_MAP;\n+      ends = ST_END_MAP;\n+    }\n+\n+  accept_statement(block);\n+  push_state (&s, comp, gfc_new_block);\n+\n+  gfc_new_block->component_access = ACCESS_PUBLIC;\n+  compiling_type = 1;\n+\n+  while (compiling_type)\n+    {\n+      st = next_statement ();\n+      switch (st)\n+        {\n+        case ST_NONE:\n+          unexpected_eof ();\n+\n+        /* Nested structure declarations will be captured as ST_DATA_DECL.  */\n+        case ST_STRUCTURE_DECL:\n+          /* Let a more specific error make it to decode_statement().  */\n+          if (gfc_error_check () == 0)\n+            gfc_error (\"Syntax error in nested structure declaration at %C\");\n+          reject_statement ();\n+          /* Skip the rest of this statement.  */\n+          gfc_error_recovery ();\n+          break;\n+\n+        case ST_UNION:\n+          accept_statement (ST_UNION);\n+          parse_union ();\n+          break;\n+\n+        case ST_DATA_DECL:\n+          /* The data declaration was a nested/ad-hoc STRUCTURE field.  */\n+          accept_statement (ST_DATA_DECL);\n+          if (gfc_new_block && gfc_new_block != gfc_current_block ()\n+                            && gfc_new_block->attr.flavor == FL_STRUCT)\n+              parse_struct_map (ST_STRUCTURE_DECL);\n+          break;\n+\n+        case ST_END_STRUCTURE:\n+        case ST_END_MAP:\n+          if (st == ends)\n+            {\n+              accept_statement (st);\n+              compiling_type = 0;\n+            }\n+          else\n+            unexpected_statement (st);\n+          break;\n+\n+        default:\n+          unexpected_statement (st);\n+          break;\n+        }\n+    }\n+\n+  /* Validate each component.  */\n+  sym = gfc_current_block ();\n+  for (c = sym->components; c; c = c->next)\n+    check_component (sym, c, &lock_comp, &event_comp);\n+\n+  sym->attr.zero_comp = (sym->components == NULL);\n+\n+  /* Allow parse_union to find this structure to add to its list of maps.  */\n+  if (block == ST_MAP)\n+    gfc_new_block = gfc_current_block ();\n+\n+  pop_state ();\n+}\n+\n+\n /* Parse a derived type.  */\n \n static void\n@@ -2762,170 +3137,7 @@ parse_derived (void)\n    */\n   sym = gfc_current_block ();\n   for (c = sym->components; c; c = c->next)\n-    {\n-      bool coarray, lock_type, event_type, allocatable, pointer;\n-      coarray = lock_type = event_type = allocatable = pointer = false;\n-\n-      /* Look for allocatable components.  */\n-      if (c->attr.allocatable\n-\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t      && CLASS_DATA (c)->attr.allocatable)\n-\t  || (c->ts.type == BT_DERIVED && !c->attr.pointer\n-\t      && c->ts.u.derived->attr.alloc_comp))\n-\t{\n-\t  allocatable = true;\n-\t  sym->attr.alloc_comp = 1;\n-\t}\n-\n-      /* Look for pointer components.  */\n-      if (c->attr.pointer\n-\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t      && CLASS_DATA (c)->attr.class_pointer)\n-\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))\n-\t{\n-\t  pointer = true;\n-\t  sym->attr.pointer_comp = 1;\n-\t}\n-\n-      /* Look for procedure pointer components.  */\n-      if (c->attr.proc_pointer\n-\t  || (c->ts.type == BT_DERIVED\n-\t      && c->ts.u.derived->attr.proc_pointer_comp))\n-\tsym->attr.proc_pointer_comp = 1;\n-\n-      /* Looking for coarray components.  */\n-      if (c->attr.codimension\n-\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t      && CLASS_DATA (c)->attr.codimension))\n-\t{\n-\t  coarray = true;\n-\t  sym->attr.coarray_comp = 1;\n-\t}\n-\n-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n-\t  && !c->attr.pointer)\n-\t{\n-\t  coarray = true;\n-\t  sym->attr.coarray_comp = 1;\n-\t}\n-\n-      /* Looking for lock_type components.  */\n-      if ((c->ts.type == BT_DERIVED\n-\t      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n-\t      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n-\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t      && CLASS_DATA (c)->ts.u.derived->from_intmod\n-\t\t == INTMOD_ISO_FORTRAN_ENV\n-\t      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id\n-\t\t == ISOFORTRAN_LOCK_TYPE)\n-\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp\n-\t      && !allocatable && !pointer))\n-\t{\n-\t  lock_type = 1;\n-\t  lock_comp = c;\n-\t  sym->attr.lock_comp = 1;\n-\t}\n-\n-      /* Looking for event_type components.  */\n-      if ((c->ts.type == BT_DERIVED\n-\t      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n-\t      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n-\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t      && CLASS_DATA (c)->ts.u.derived->from_intmod\n-\t\t == INTMOD_ISO_FORTRAN_ENV\n-\t      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id\n-\t\t == ISOFORTRAN_EVENT_TYPE)\n-\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.event_comp\n-\t      && !allocatable && !pointer))\n-\t{\n-\t  event_type = 1;\n-\t  event_comp = c;\n-\t  sym->attr.event_comp = 1;\n-\t}\n-\n-      /* Check for F2008, C1302 - and recall that pointers may not be coarrays\n-\t (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),\n-\t unless there are nondirect [allocatable or pointer] components\n-\t involved (cf. 1.3.33.1 and 1.3.33.3).  */\n-\n-      if (pointer && !coarray && lock_type)\n-\tgfc_error (\"Component %s at %L of type LOCK_TYPE must have a \"\n-\t\t   \"codimension or be a subcomponent of a coarray, \"\n-\t\t   \"which is not possible as the component has the \"\n-\t\t   \"pointer attribute\", c->name, &c->loc);\n-      else if (pointer && !coarray && c->ts.type == BT_DERIVED\n-\t       && c->ts.u.derived->attr.lock_comp)\n-\tgfc_error (\"Pointer component %s at %L has a noncoarray subcomponent \"\n-\t\t   \"of type LOCK_TYPE, which must have a codimension or be a \"\n-\t\t   \"subcomponent of a coarray\", c->name, &c->loc);\n-\n-      if (lock_type && allocatable && !coarray)\n-\tgfc_error (\"Allocatable component %s at %L of type LOCK_TYPE must have \"\n-\t\t   \"a codimension\", c->name, &c->loc);\n-      else if (lock_type && allocatable && c->ts.type == BT_DERIVED\n-\t       && c->ts.u.derived->attr.lock_comp)\n-\tgfc_error (\"Allocatable component %s at %L must have a codimension as \"\n-\t\t   \"it has a noncoarray subcomponent of type LOCK_TYPE\",\n-\t\t   c->name, &c->loc);\n-\n-      if (sym->attr.coarray_comp && !coarray && lock_type)\n-\tgfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n-\t\t   \"subcomponent of type LOCK_TYPE must have a codimension or \"\n-\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n-\t\t   \"not have a codimension as already a coarray \"\n-\t\t   \"subcomponent exists)\", c->name, &c->loc, sym->name);\n-\n-      if (sym->attr.lock_comp && coarray && !lock_type)\n-\tgfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n-\t\t   \"subcomponent of type LOCK_TYPE must have a codimension or \"\n-\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n-\t\t   \"not have a codimension as %s at %L has a codimension or a \"\n-\t\t   \"coarray subcomponent)\", lock_comp->name, &lock_comp->loc,\n-\t\t   sym->name, c->name, &c->loc);\n-\n-      /* Similarly for EVENT TYPE.  */\n-\n-      if (pointer && !coarray && event_type)\n-\tgfc_error (\"Component %s at %L of type EVENT_TYPE must have a \"\n-\t\t   \"codimension or be a subcomponent of a coarray, \"\n-\t\t   \"which is not possible as the component has the \"\n-\t\t   \"pointer attribute\", c->name, &c->loc);\n-      else if (pointer && !coarray && c->ts.type == BT_DERIVED\n-\t       && c->ts.u.derived->attr.event_comp)\n-\tgfc_error (\"Pointer component %s at %L has a noncoarray subcomponent \"\n-\t\t   \"of type EVENT_TYPE, which must have a codimension or be a \"\n-\t\t   \"subcomponent of a coarray\", c->name, &c->loc);\n-\n-      if (event_type && allocatable && !coarray)\n-\tgfc_error (\"Allocatable component %s at %L of type EVENT_TYPE must have \"\n-\t\t   \"a codimension\", c->name, &c->loc);\n-      else if (event_type && allocatable && c->ts.type == BT_DERIVED\n-\t       && c->ts.u.derived->attr.event_comp)\n-\tgfc_error (\"Allocatable component %s at %L must have a codimension as \"\n-\t\t   \"it has a noncoarray subcomponent of type EVENT_TYPE\",\n-\t\t   c->name, &c->loc);\n-\n-      if (sym->attr.coarray_comp && !coarray && event_type)\n-\tgfc_error (\"Noncoarray component %s at %L of type EVENT_TYPE or with \"\n-\t\t   \"subcomponent of type EVENT_TYPE must have a codimension or \"\n-\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n-\t\t   \"not have a codimension as already a coarray \"\n-\t\t   \"subcomponent exists)\", c->name, &c->loc, sym->name);\n-\n-      if (sym->attr.event_comp && coarray && !event_type)\n-\tgfc_error (\"Noncoarray component %s at %L of type EVENT_TYPE or with \"\n-\t\t   \"subcomponent of type EVENT_TYPE must have a codimension or \"\n-\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n-\t\t   \"not have a codimension as %s at %L has a codimension or a \"\n-\t\t   \"coarray subcomponent)\", event_comp->name, &event_comp->loc,\n-\t\t   sym->name, c->name, &c->loc);\n-\n-      /* Look for private components.  */\n-      if (sym->component_access == ACCESS_PRIVATE\n-\t  || c->attr.access == ACCESS_PRIVATE\n-\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))\n-\tsym->attr.private_comp = 1;\n-    }\n+    check_component (sym, c, &lock_comp, &event_comp);\n \n   if (!seen_component)\n     sym->attr.zero_comp = 1;\n@@ -3348,6 +3560,7 @@ parse_spec (gfc_statement st)\n     case ST_PARAMETER:\n     case ST_PUBLIC:\n     case ST_PRIVATE:\n+    case ST_STRUCTURE_DECL:\n     case ST_DERIVED_DECL:\n     case_decl:\n declSt:\n@@ -3364,6 +3577,10 @@ parse_spec (gfc_statement st)\n \t  parse_interface ();\n \t  break;\n \n+        case ST_STRUCTURE_DECL:\n+          parse_struct_map (ST_STRUCTURE_DECL);\n+          break;\n+\n \tcase ST_DERIVED_DECL:\n \t  parse_derived ();\n \t  break;"}, {"sha": "e8f71cf30356638ce6b14645fc6e33b9c597fd3a", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -28,6 +28,7 @@ enum gfc_compile_state\n   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBMODULE, COMP_SUBROUTINE,\n   COMP_FUNCTION, COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED,\n   COMP_DERIVED_CONTAINS, COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,\n+  COMP_STRUCTURE, COMP_UNION, COMP_MAP,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n   COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT\n };\n@@ -58,6 +59,8 @@ extern gfc_state_data *gfc_state_stack;\n \n #define gfc_current_block() (gfc_state_stack->sym)\n #define gfc_current_state() (gfc_state_stack->state)\n+#define gfc_comp_struct(s) \\\n+  ((s) == COMP_DERIVED || (s) == COMP_STRUCTURE || (s) == COMP_MAP)\n \n int gfc_check_do_variable (gfc_symtree *);\n bool gfc_find_state (gfc_compile_state);"}, {"sha": "c2faa0f3e10bf7c5942e2b18c536a1d2f765f842", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 84, "deletions": 32, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -1883,11 +1883,12 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t\t   bool ppc_arg)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  gfc_ref *substring, *tail;\n+  gfc_ref *substring, *tail, *tmp;\n   gfc_component *component;\n   gfc_symbol *sym = primary->symtree->n.sym;\n   match m;\n   bool unknown;\n+  char sep;\n \n   tail = NULL;\n \n@@ -1972,25 +1973,31 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   if (equiv_flag)\n     return MATCH_YES;\n \n-  if (sym->ts.type == BT_UNKNOWN && gfc_peek_ascii_char () == '%'\n+  /* With DEC extensions, member separator may be '.' or '%'.  */\n+  sep = gfc_peek_ascii_char ();\n+  m = gfc_match_member_sep (sym);\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES\n       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n     gfc_set_default_type (sym, 0, sym->ns);\n \n-  if (sym->ts.type == BT_UNKNOWN && gfc_match_char ('%') == MATCH_YES)\n+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES)\n     {\n       gfc_error (\"Symbol %qs at %C has no IMPLICIT type\", sym->name);\n       return MATCH_ERROR;\n     }\n   else if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)\n-\t   && gfc_match_char ('%') == MATCH_YES)\n+           && m == MATCH_YES)\n     {\n-      gfc_error (\"Unexpected %<%%%> for nonderived-type variable %qs at %C\",\n-\t\t sym->name);\n+      gfc_error (\"Unexpected %<%c%> for nonderived-type variable %qs at %C\",\n+\t\t sep, sym->name);\n       return MATCH_ERROR;\n     }\n \n   if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)\n-      || gfc_match_char ('%') != MATCH_YES)\n+      || m != MATCH_YES)\n     goto check_substring;\n \n   sym = sym->ts.u.derived;\n@@ -2061,15 +2068,24 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  break;\n \t}\n \n-      component = gfc_find_component (sym, name, false, false);\n+      component = gfc_find_component (sym, name, false, false, &tmp);\n       if (component == NULL)\n \treturn MATCH_ERROR;\n \n-      tail = extend_ref (primary, tail);\n-      tail->type = REF_COMPONENT;\n+      /* Extend the reference chain determined by gfc_find_component.  */\n+      if (primary->ref == NULL)\n+        primary->ref = tmp;\n+      else\n+        {\n+          /* Set by the for loop below for the last component ref.  */\n+          gcc_assert (tail != NULL);\n+          tail->next = tmp;\n+        }\n \n-      tail->u.c.component = component;\n-      tail->u.c.sym = sym;\n+      /* The reference chain may be longer than one hop for union\n+         subcomponents; find the new tail.  */\n+      for (tail = tmp; tail->next; tail = tail->next)\n+        ;\n \n       primary->ts = component->ts;\n \n@@ -2119,15 +2135,15 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t}\n \n       if ((component->ts.type != BT_DERIVED && component->ts.type != BT_CLASS)\n-\t  || gfc_match_char ('%') != MATCH_YES)\n+\t  || gfc_match_member_sep (component->ts.u.derived) != MATCH_YES)\n \tbreak;\n \n       sym = component->ts.u.derived;\n     }\n \n check_substring:\n   unknown = false;\n-  if (primary->ts.type == BT_UNKNOWN && sym->attr.flavor != FL_DERIVED)\n+  if (primary->ts.type == BT_UNKNOWN && !gfc_fl_struct (sym->attr.flavor))\n     {\n       if (gfc_get_default_type (sym->name, sym->ns)->type == BT_CHARACTER)\n        {\n@@ -2548,11 +2564,11 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n       /* Find the current component in the structure definition and check\n \t     its access is not private.  */\n       if (comp)\n-\tthis_comp = gfc_find_component (sym, comp->name, false, false);\n+\tthis_comp = gfc_find_component (sym, comp->name, false, false, NULL);\n       else\n \t{\n \t  this_comp = gfc_find_component (sym, (const char *)comp_tail->name,\n-\t\t\t\t\t  false, false);\n+\t\t\t\t\t  false, false, NULL);\n \t  comp = NULL; /* Reset needed!  */\n \t}\n \n@@ -2596,7 +2612,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n           if (comp && comp == sym->components\n                 && sym->attr.extension\n \t\t&& comp_tail->val\n-                && (comp_tail->val->ts.type != BT_DERIVED\n+                && (!gfc_bt_struct (comp_tail->val->ts.type)\n                       ||\n                     comp_tail->val->ts.u.derived != this_comp->ts.u.derived))\n             {\n@@ -2697,7 +2713,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n   e->symtree = symtree;\n   e->expr_type = EXPR_FUNCTION;\n \n-  gcc_assert (sym->attr.flavor == FL_DERIVED\n+  gcc_assert (gfc_fl_struct (sym->attr.flavor)\n \t      && symtree->n.sym->attr.flavor == FL_PROCEDURE);\n   e->value.function.esym = sym;\n   e->symtree->n.sym->attr.generic = 1;\n@@ -2795,15 +2811,29 @@ gfc_match_rvalue (gfc_expr **result)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_find_state (COMP_INTERFACE)\n-      && !gfc_current_ns->has_import_set)\n-    i = gfc_get_sym_tree (name, NULL, &symtree, false);\n-  else\n-    i = gfc_get_ha_sym_tree (name, &symtree);\n-\n-  if (i)\n+  /* Check if the symbol exists.  */\n+  if (gfc_find_sym_tree (name, NULL, 1, &symtree))\n     return MATCH_ERROR;\n \n+  /* If the symbol doesn't exist, create it unless the name matches a FL_STRUCT\n+     type. For derived types we create a generic symbol which links to the\n+     derived type symbol; STRUCTUREs are simpler and must not conflict with\n+     variables.  */\n+  if (!symtree)\n+    if (gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree))\n+      return MATCH_ERROR;\n+  if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)\n+    {\n+      if (gfc_find_state (COMP_INTERFACE)\n+          && !gfc_current_ns->has_import_set)\n+        i = gfc_get_sym_tree (name, NULL, &symtree, false);\n+      else\n+        i = gfc_get_ha_sym_tree (name, &symtree);\n+      if (i)\n+        return MATCH_ERROR;\n+    }\n+\n+\n   sym = symtree->n.sym;\n   e = NULL;\n   where = gfc_current_locus;\n@@ -2914,6 +2944,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n       break;\n \n+    case FL_STRUCT:\n     case FL_DERIVED:\n       sym = gfc_use_derived (sym);\n       if (sym == NULL)\n@@ -3054,10 +3085,12 @@ gfc_match_rvalue (gfc_expr **result)\n \t via an IMPLICIT statement.  This can't wait for the\n \t resolution phase.  */\n \n-      if (gfc_peek_ascii_char () == '%'\n+      old_loc = gfc_current_locus;\n+      if (gfc_match_member_sep (sym) == MATCH_YES\n \t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, sym->ns);\n+      gfc_current_locus = old_loc;\n \n       /* If the symbol has a (co)dimension attribute, the expression is a\n \t variable.  */\n@@ -3210,13 +3243,19 @@ gfc_match_rvalue (gfc_expr **result)\n       break;\n \n     generic_function:\n-      gfc_get_sym_tree (name, NULL, &symtree, false);\t/* Can't fail */\n+      /* Look for symbol first; if not found, look for STRUCTURE type symbol\n+         specially. Creates a generic symbol for derived types.  */\n+      gfc_find_sym_tree (name, NULL, 1, &symtree);\n+      if (!symtree)\n+        gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree);\n+      if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)\n+        gfc_get_sym_tree (name, NULL, &symtree, false); /* Can't fail */\n \n       e = gfc_get_expr ();\n       e->symtree = symtree;\n       e->expr_type = EXPR_FUNCTION;\n \n-      if (sym->attr.flavor == FL_DERIVED)\n+      if (gfc_fl_struct (sym->attr.flavor))\n \t{\n \t  e->value.function.esym = sym;\n \t  e->symtree->n.sym->attr.generic = 1;\n@@ -3260,10 +3299,10 @@ gfc_match_rvalue (gfc_expr **result)\n static match\n match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n {\n-  gfc_symbol *sym;\n+  gfc_symbol *sym, *dt_sym;\n   gfc_symtree *st;\n   gfc_expr *expr;\n-  locus where;\n+  locus where, old_loc;\n   match m;\n \n   /* Since nothing has any business being an lvalue in a module\n@@ -3294,6 +3333,17 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n   sym->attr.implied_index = 0;\n \n   gfc_set_sym_referenced (sym);\n+\n+  /* STRUCTUREs may share names with variables, but derived types may not.  */\n+  if (sym->attr.flavor == FL_PROCEDURE && sym->generic\n+      && (dt_sym = gfc_find_dt_in_generic (sym)))\n+    {\n+      if (dt_sym->attr.flavor == FL_DERIVED)\n+        gfc_error (\"Derived type '%s' cannot be used as a variable at %C\",\n+                   sym->name);\n+      return MATCH_ERROR;\n+    }\n+\n   switch (sym->attr.flavor)\n     {\n     case FL_VARIABLE:\n@@ -3379,11 +3429,13 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \timplicit_ns = gfc_current_ns;\n       else\n \timplicit_ns = sym->ns;\n-\n-      if (gfc_peek_ascii_char () == '%'\n+\t\n+      old_loc = gfc_current_locus;\n+      if (gfc_match_member_sep (sym) == MATCH_YES\n \t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym->name, implicit_ns)->type == BT_DERIVED)\n \tgfc_set_default_type (sym, 0, implicit_ns);\n+      gfc_current_locus = old_loc;\n     }\n \n   expr = gfc_get_expr ();"}, {"sha": "2c68af2b7e83c766dca87be109e65c8bbadd4673", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 476, "deletions": 397, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -535,7 +535,7 @@ static void\n find_arglists (gfc_symbol *sym)\n {\n   if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns\n-      || sym->attr.flavor == FL_DERIVED || sym->attr.intrinsic)\n+      || gfc_fl_struct (sym->attr.flavor) || sym->attr.intrinsic)\n     return;\n \n   resolve_formal_arglist (sym);\n@@ -1116,6 +1116,7 @@ resolve_contained_functions (gfc_namespace *ns)\n \n \n static bool resolve_fl_derived0 (gfc_symbol *sym);\n+static bool resolve_fl_struct (gfc_symbol *sym);\n \n \n /* Resolve all of the elements of a structure constructor and make sure that\n@@ -1132,8 +1133,13 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \n   t = true;\n \n-  if (expr->ts.type == BT_DERIVED)\n-    resolve_fl_derived0 (expr->ts.u.derived);\n+  if (expr->ts.type == BT_DERIVED || expr->ts.type == BT_UNION)\n+    {\n+      if (expr->ts.u.derived->attr.flavor == FL_DERIVED)\n+        resolve_fl_derived0 (expr->ts.u.derived);\n+      else\n+        resolve_fl_struct (expr->ts.u.derived);\n+    }\n \n   cons = gfc_constructor_first (expr->value.constructor);\n \n@@ -1561,7 +1567,7 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)\n   gfc_namespace* real_context;\n \n   if (sym->attr.flavor == FL_PROGRAM\n-      || sym->attr.flavor == FL_DERIVED)\n+      || gfc_fl_struct (sym->attr.flavor))\n     return false;\n \n   gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n@@ -2548,7 +2554,7 @@ resolve_generic_f (gfc_expr *expr)\n generic:\n       if (!intr)\n \tfor (intr = sym->generic; intr; intr = intr->next)\n-\t  if (intr->sym->attr.flavor == FL_DERIVED)\n+\t  if (gfc_fl_struct (intr->sym->attr.flavor))\n \t    break;\n \n       if (sym->ns->parent == NULL)\n@@ -5715,7 +5721,7 @@ get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n \tcontinue;\n \n       if ((ref->u.c.component->ts.type == BT_CLASS\n-\t     || (check_types && ref->u.c.component->ts.type == BT_DERIVED))\n+\t     || (check_types && gfc_bt_struct (ref->u.c.component->ts.type)))\n \t  && ref->u.c.component->attr.flavor != FL_PROCEDURE)\n \t{\n \t  declared = ref->u.c.component->ts.u.derived;\n@@ -5978,7 +5984,7 @@ resolve_typebound_function (gfc_expr* e)\n \t is present.  */\n       ts = expr->ts;\n       declared = ts.u.derived;\n-      c = gfc_find_component (declared, \"_vptr\", true, true);\n+      c = gfc_find_component (declared, \"_vptr\", true, true, NULL);\n       if (c->ts.u.derived == NULL)\n \tc->ts.u.derived = gfc_find_derived_vtab (declared);\n \n@@ -6025,14 +6031,14 @@ resolve_typebound_function (gfc_expr* e)\n     return false;\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))\n \t || (!class_ref && st->n.sym->ts.type != BT_CLASS))\n     {\n       gfc_free_ref_list (new_ref);\n       return resolve_compcall (e, NULL);\n     }\n \n-  c = gfc_find_component (declared, \"_data\", true, true);\n+  c = gfc_find_component (declared, \"_data\", true, true, NULL);\n   declared = c->ts.u.derived;\n \n   /* Treat the call as if it is a typebound procedure, in order to roll\n@@ -6111,7 +6117,7 @@ resolve_typebound_subroutine (gfc_code *code)\n \t that any delays in resolution are corrected and that the vtab\n \t is present.  */\n       declared = expr->ts.u.derived;\n-      c = gfc_find_component (declared, \"_vptr\", true, true);\n+      c = gfc_find_component (declared, \"_vptr\", true, true, NULL);\n       if (c->ts.u.derived == NULL)\n \tc->ts.u.derived = gfc_find_derived_vtab (declared);\n \n@@ -6156,7 +6162,7 @@ resolve_typebound_subroutine (gfc_code *code)\n   get_declared_from_expr (&class_ref, &new_ref, code->expr1, true);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))\n \t || (!class_ref && st->n.sym->ts.type != BT_CLASS))\n     {\n       gfc_free_ref_list (new_ref);\n@@ -7140,15 +7146,15 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n       gfc_typespec ts;\n       gfc_expr *init_e;\n \n-      if (code->ext.alloc.ts.type == BT_DERIVED)\n+      if (gfc_bt_struct (code->ext.alloc.ts.type))\n \tts = code->ext.alloc.ts;\n       else\n \tts = e->ts;\n \n       if (ts.type == BT_CLASS)\n \tts = ts.u.derived->components->ts;\n \n-      if (ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&ts)))\n+      if (gfc_bt_struct (ts.type) && (init_e = gfc_default_initializer (&ts)))\n \t{\n \t  gfc_code *init_st = gfc_get_code (EXEC_INIT_ASSIGN);\n \t  init_st->loc = code->loc;\n@@ -7282,7 +7288,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n \t  sym = a->expr->symtree->n.sym;\n \n \t  /* TODO - check derived type components.  */\n-\t  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n+\t  if (gfc_bt_struct (sym->ts.type) || sym->ts.type == BT_CLASS)\n \t    continue;\n \n \t  if ((ar->start[i] != NULL\n@@ -8220,7 +8226,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \t  if (!gfc_build_class_symbol (&sym->ts, &attr, &as))\n \t    gcc_unreachable ();\n \t  /* Make sure the _vptr is set.  */\n-\t  c = gfc_find_component (sym->ts.u.derived, \"_vptr\", true, true);\n+\t  c = gfc_find_component (sym->ts.u.derived, \"_vptr\", true, true, NULL);\n \t  if (c->ts.u.derived == NULL)\n \t    c->ts.u.derived = gfc_find_derived_vtab (sym->ts.u.derived);\n \t  CLASS_DATA (sym)->attr.pointer = 1;\n@@ -9911,7 +9917,7 @@ nonscalar_typebound_assign (gfc_symbol *derived, int depth)\n \n   for (c= derived->components; c; c = c->next)\n     {\n-      if ((c->ts.type != BT_DERIVED\n+      if ((!gfc_bt_struct (c->ts.type)\n \t    || c->attr.pointer\n \t    || c->attr.allocatable\n \t    || c->attr.proc_pointer_comp\n@@ -10051,7 +10057,7 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \n       /* The intrinsic assignment does the right thing for pointers\n \t of all kinds and allocatable components.  */\n-      if (comp1->ts.type != BT_DERIVED\n+      if (!gfc_bt_struct (comp1->ts.type)\n \t  || comp1->attr.pointer\n \t  || comp1->attr.allocatable\n \t  || comp1->attr.proc_pointer_comp\n@@ -11433,7 +11439,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n       gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 0, &s);\n       if (s && s->attr.generic)\n \ts = gfc_find_dt_in_generic (s);\n-      if (s && s->attr.flavor != FL_DERIVED)\n+      if (s && !gfc_fl_struct (s->attr.flavor))\n \t{\n \t  gfc_error (\"The type %qs cannot be host associated at %L \"\n \t\t     \"because it is blocked by an incompatible object \"\n@@ -12733,7 +12739,8 @@ resolve_typebound_procedure (gfc_symtree* stree)\n       }\n \n   /* Try to find a name collision with an inherited component.  */\n-  if (super_type && gfc_find_component (super_type, stree->name, true, true))\n+  if (super_type && gfc_find_component (super_type, stree->name, true, true,\n+                                        NULL))\n     {\n       gfc_error (\"Procedure %qs at %L has the same name as an inherited\"\n \t\t \" component of %qs\",\n@@ -12881,7 +12888,7 @@ check_defined_assignments (gfc_symbol *derived)\n \n   for (c = derived->components; c; c = c->next)\n     {\n-      if (c->ts.type != BT_DERIVED\n+      if (!gfc_bt_struct (c->ts.type)\n \t  || c->attr.pointer\n \t  || c->attr.allocatable\n \t  || c->attr.proc_pointer_comp\n@@ -12907,435 +12914,498 @@ check_defined_assignments (gfc_symbol *derived)\n }\n \n \n-/* Resolve the components of a derived type. This does not have to wait until\n-   resolution stage, but can be done as soon as the dt declaration has been\n-   parsed.  */\n+/* Resolve a single component of a derived type or structure.  */\n \n static bool\n-resolve_fl_derived0 (gfc_symbol *sym)\n+resolve_component (gfc_component *c, gfc_symbol *sym)\n {\n-  gfc_symbol* super_type;\n-  gfc_component *c;\n+  gfc_symbol *super_type;\n \n-  if (sym->attr.unlimited_polymorphic)\n+  if (c->attr.artificial)\n     return true;\n \n-  super_type = gfc_get_derived_super_type (sym);\n+  /* F2008, C442.  */\n+  if ((!sym->attr.is_class || c != sym->components)\n+      && c->attr.codimension\n+      && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))\n+    {\n+      gfc_error (\"Coarray component %qs at %L must be allocatable with \"\n+                 \"deferred shape\", c->name, &c->loc);\n+      return false;\n+    }\n \n-  /* F2008, C432.  */\n-  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)\n+  /* F2008, C443.  */\n+  if (c->attr.codimension && c->ts.type == BT_DERIVED\n+      && c->ts.u.derived->ts.is_iso_c)\n     {\n-      gfc_error (\"As extending type %qs at %L has a coarray component, \"\n-\t\t \"parent type %qs shall also have one\", sym->name,\n-\t\t &sym->declared_at, super_type->name);\n+      gfc_error (\"Component %qs at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n+                 \"shall not be a coarray\", c->name, &c->loc);\n       return false;\n     }\n \n-  /* Ensure the extended type gets resolved before we do.  */\n-  if (super_type && !resolve_fl_derived0 (super_type))\n-    return false;\n+  /* F2008, C444.  */\n+  if (gfc_bt_struct (c->ts.type) && c->ts.u.derived->attr.coarray_comp\n+      && (c->attr.codimension || c->attr.pointer || c->attr.dimension\n+          || c->attr.allocatable))\n+    {\n+      gfc_error (\"Component %qs at %L with coarray component \"\n+                 \"shall be a nonpointer, nonallocatable scalar\",\n+                 c->name, &c->loc);\n+      return false;\n+    }\n \n-  /* An ABSTRACT type must be extensible.  */\n-  if (sym->attr.abstract && !gfc_type_is_extensible (sym))\n+  /* F2008, C448.  */\n+  if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))\n     {\n-      gfc_error (\"Non-extensible derived-type %qs at %L must not be ABSTRACT\",\n-\t\t sym->name, &sym->declared_at);\n+      gfc_error (\"Component %qs at %L has the CONTIGUOUS attribute but \"\n+                 \"is not an array pointer\", c->name, &c->loc);\n       return false;\n     }\n \n-  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components\n-\t\t\t   : sym->components;\n+  if (c->attr.proc_pointer && c->ts.interface)\n+    {\n+      gfc_symbol *ifc = c->ts.interface;\n \n-  bool success = true;\n+      if (!sym->attr.vtype && !check_proc_interface (ifc, &c->loc))\n+        {\n+          c->tb->error = 1;\n+          return false;\n+        }\n \n-  for ( ; c != NULL; c = c->next)\n+      if (ifc->attr.if_source || ifc->attr.intrinsic)\n+        {\n+          /* Resolve interface and copy attributes.  */\n+          if (ifc->formal && !ifc->formal_ns)\n+            resolve_symbol (ifc);\n+          if (ifc->attr.intrinsic)\n+            gfc_resolve_intrinsic (ifc, &ifc->declared_at);\n+\n+          if (ifc->result)\n+            {\n+              c->ts = ifc->result->ts;\n+              c->attr.allocatable = ifc->result->attr.allocatable;\n+              c->attr.pointer = ifc->result->attr.pointer;\n+              c->attr.dimension = ifc->result->attr.dimension;\n+              c->as = gfc_copy_array_spec (ifc->result->as);\n+              c->attr.class_ok = ifc->result->attr.class_ok;\n+            }\n+          else\n+            {\n+              c->ts = ifc->ts;\n+              c->attr.allocatable = ifc->attr.allocatable;\n+              c->attr.pointer = ifc->attr.pointer;\n+              c->attr.dimension = ifc->attr.dimension;\n+              c->as = gfc_copy_array_spec (ifc->as);\n+              c->attr.class_ok = ifc->attr.class_ok;\n+            }\n+          c->ts.interface = ifc;\n+          c->attr.function = ifc->attr.function;\n+          c->attr.subroutine = ifc->attr.subroutine;\n+\n+          c->attr.pure = ifc->attr.pure;\n+          c->attr.elemental = ifc->attr.elemental;\n+          c->attr.recursive = ifc->attr.recursive;\n+          c->attr.always_explicit = ifc->attr.always_explicit;\n+          c->attr.ext_attr |= ifc->attr.ext_attr;\n+          /* Copy char length.  */\n+          if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n+            {\n+              gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n+              if (cl->length && !cl->resolved\n+                  && !gfc_resolve_expr (cl->length))\n+                {\n+                  c->tb->error = 1;\n+                  return false;\n+                }\n+              c->ts.u.cl = cl;\n+            }\n+        }\n+    }\n+  else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)\n     {\n-      if (c->attr.artificial)\n-\tcontinue;\n+      /* Since PPCs are not implicitly typed, a PPC without an explicit\n+         interface must be a subroutine.  */\n+      gfc_add_subroutine (&c->attr, c->name, &c->loc);\n+    }\n \n-      /* F2008, C442.  */\n-      if ((!sym->attr.is_class || c != sym->components)\n-\t  && c->attr.codimension\n-\t  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))\n-\t{\n-\t  gfc_error (\"Coarray component %qs at %L must be allocatable with \"\n-\t\t     \"deferred shape\", c->name, &c->loc);\n-\t  success = false;\n-\t  continue;\n-\t}\n+  /* Procedure pointer components: Check PASS arg.  */\n+  if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0\n+      && !sym->attr.vtype)\n+    {\n+      gfc_symbol* me_arg;\n \n-      /* F2008, C443.  */\n-      if (c->attr.codimension && c->ts.type == BT_DERIVED\n-\t  && c->ts.u.derived->ts.is_iso_c)\n-\t{\n-\t  gfc_error (\"Component %qs at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n-\t\t     \"shall not be a coarray\", c->name, &c->loc);\n-\t  success = false;\n-\t  continue;\n-\t}\n+      if (c->tb->pass_arg)\n+        {\n+          gfc_formal_arglist* i;\n \n-      /* F2008, C444.  */\n-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n-\t  && (c->attr.codimension || c->attr.pointer || c->attr.dimension\n-\t      || c->attr.allocatable))\n-\t{\n-\t  gfc_error (\"Component %qs at %L with coarray component \"\n-\t\t     \"shall be a nonpointer, nonallocatable scalar\",\n-\t\t     c->name, &c->loc);\n-\t  success = false;\n-\t  continue;\n-\t}\n+          /* If an explicit passing argument name is given, walk the arg-list\n+            and look for it.  */\n \n-      /* F2008, C448.  */\n-      if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))\n-\t{\n-\t  gfc_error (\"Component %qs at %L has the CONTIGUOUS attribute but \"\n-\t\t     \"is not an array pointer\", c->name, &c->loc);\n-\t  success = false;\n-\t  continue;\n-\t}\n+          me_arg = NULL;\n+          c->tb->pass_arg_num = 1;\n+          for (i = c->ts.interface->formal; i; i = i->next)\n+            {\n+              if (!strcmp (i->sym->name, c->tb->pass_arg))\n+                {\n+                  me_arg = i->sym;\n+                  break;\n+                }\n+              c->tb->pass_arg_num++;\n+            }\n \n-      if (c->attr.proc_pointer && c->ts.interface)\n-\t{\n-\t  gfc_symbol *ifc = c->ts.interface;\n+          if (!me_arg)\n+            {\n+              gfc_error (\"Procedure pointer component %qs with PASS(%s) \"\n+                         \"at %L has no argument %qs\", c->name,\n+                         c->tb->pass_arg, &c->loc, c->tb->pass_arg);\n+              c->tb->error = 1;\n+              return false;\n+            }\n+        }\n+      else\n+        {\n+          /* Otherwise, take the first one; there should in fact be at least\n+            one.  */\n+          c->tb->pass_arg_num = 1;\n+          if (!c->ts.interface->formal)\n+            {\n+              gfc_error (\"Procedure pointer component %qs with PASS at %L \"\n+                         \"must have at least one argument\",\n+                         c->name, &c->loc);\n+              c->tb->error = 1;\n+              return false;\n+            }\n+          me_arg = c->ts.interface->formal->sym;\n+        }\n \n-\t  if (!sym->attr.vtype && !check_proc_interface (ifc, &c->loc))\n-\t    {\n-\t      c->tb->error = 1;\n-\t      success = false;\n-\t      continue;\n-\t    }\n+      /* Now check that the argument-type matches.  */\n+      gcc_assert (me_arg);\n+      if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)\n+          || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)\n+          || (me_arg->ts.type == BT_CLASS\n+              && CLASS_DATA (me_arg)->ts.u.derived != sym))\n+        {\n+          gfc_error (\"Argument %qs of %qs with PASS(%s) at %L must be of\"\n+                     \" the derived type %qs\", me_arg->name, c->name,\n+                     me_arg->name, &c->loc, sym->name);\n+          c->tb->error = 1;\n+          return false;\n+        }\n \n-\t  if (ifc->attr.if_source || ifc->attr.intrinsic)\n-\t    {\n-\t      /* Resolve interface and copy attributes.  */\n-\t      if (ifc->formal && !ifc->formal_ns)\n-\t\tresolve_symbol (ifc);\n-\t      if (ifc->attr.intrinsic)\n-\t\tgfc_resolve_intrinsic (ifc, &ifc->declared_at);\n+      /* Check for C453.  */\n+      if (me_arg->attr.dimension)\n+        {\n+          gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n+                     \"must be scalar\", me_arg->name, c->name, me_arg->name,\n+                     &c->loc);\n+          c->tb->error = 1;\n+          return false;\n+        }\n \n-\t      if (ifc->result)\n-\t\t{\n-\t\t  c->ts = ifc->result->ts;\n-\t\t  c->attr.allocatable = ifc->result->attr.allocatable;\n-\t\t  c->attr.pointer = ifc->result->attr.pointer;\n-\t\t  c->attr.dimension = ifc->result->attr.dimension;\n-\t\t  c->as = gfc_copy_array_spec (ifc->result->as);\n-\t\t  c->attr.class_ok = ifc->result->attr.class_ok;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  c->ts = ifc->ts;\n-\t\t  c->attr.allocatable = ifc->attr.allocatable;\n-\t\t  c->attr.pointer = ifc->attr.pointer;\n-\t\t  c->attr.dimension = ifc->attr.dimension;\n-\t\t  c->as = gfc_copy_array_spec (ifc->as);\n-\t\t  c->attr.class_ok = ifc->attr.class_ok;\n-\t\t}\n-\t      c->ts.interface = ifc;\n-\t      c->attr.function = ifc->attr.function;\n-\t      c->attr.subroutine = ifc->attr.subroutine;\n-\n-\t      c->attr.pure = ifc->attr.pure;\n-\t      c->attr.elemental = ifc->attr.elemental;\n-\t      c->attr.recursive = ifc->attr.recursive;\n-\t      c->attr.always_explicit = ifc->attr.always_explicit;\n-\t      c->attr.ext_attr |= ifc->attr.ext_attr;\n-\t      /* Copy char length.  */\n-\t      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n-\t\t{\n-\t\t  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n-\t\t  if (cl->length && !cl->resolved\n-\t\t      && !gfc_resolve_expr (cl->length))\n-\t\t    {\n-\t\t      c->tb->error = 1;\n-\t\t      success = false;\n-\t\t      continue;\n-\t\t    }\n-\t\t  c->ts.u.cl = cl;\n-\t\t}\n-\t    }\n-\t}\n-      else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)\n-\t{\n-\t  /* Since PPCs are not implicitly typed, a PPC without an explicit\n-\t     interface must be a subroutine.  */\n-\t  gfc_add_subroutine (&c->attr, c->name, &c->loc);\n-\t}\n+      if (me_arg->attr.pointer)\n+        {\n+          gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n+                     \"may not have the POINTER attribute\", me_arg->name,\n+                     c->name, me_arg->name, &c->loc);\n+          c->tb->error = 1;\n+          return false;\n+        }\n \n-      /* Procedure pointer components: Check PASS arg.  */\n-      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0\n-\t  && !sym->attr.vtype)\n-\t{\n-\t  gfc_symbol* me_arg;\n+      if (me_arg->attr.allocatable)\n+        {\n+          gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n+                     \"may not be ALLOCATABLE\", me_arg->name, c->name,\n+                     me_arg->name, &c->loc);\n+          c->tb->error = 1;\n+          return false;\n+        }\n \n-\t  if (c->tb->pass_arg)\n-\t    {\n-\t      gfc_formal_arglist* i;\n+      if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)\n+        {\n+          gfc_error (\"Non-polymorphic passed-object dummy argument of %qs\"\n+                     \" at %L\", c->name, &c->loc);\n+          return false;\n+        }\n \n-\t      /* If an explicit passing argument name is given, walk the arg-list\n-\t\tand look for it.  */\n+    }\n \n-\t      me_arg = NULL;\n-\t      c->tb->pass_arg_num = 1;\n-\t      for (i = c->ts.interface->formal; i; i = i->next)\n-\t\t{\n-\t\t  if (!strcmp (i->sym->name, c->tb->pass_arg))\n-\t\t    {\n-\t\t      me_arg = i->sym;\n-\t\t      break;\n-\t\t    }\n-\t\t  c->tb->pass_arg_num++;\n-\t\t}\n+  /* Check type-spec if this is not the parent-type component.  */\n+  if (((sym->attr.is_class\n+        && (!sym->components->ts.u.derived->attr.extension\n+            || c != sym->components->ts.u.derived->components))\n+       || (!sym->attr.is_class\n+           && (!sym->attr.extension || c != sym->components)))\n+      && !sym->attr.vtype\n+      && !resolve_typespec_used (&c->ts, &c->loc, c->name))\n+    return false;\n \n-\t      if (!me_arg)\n-\t\t{\n-\t\t  gfc_error (\"Procedure pointer component %qs with PASS(%s) \"\n-\t\t\t     \"at %L has no argument %qs\", c->name,\n-\t\t\t     c->tb->pass_arg, &c->loc, c->tb->pass_arg);\n-\t\t  c->tb->error = 1;\n-\t\t  success = false;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, take the first one; there should in fact be at least\n-\t\tone.  */\n-\t      c->tb->pass_arg_num = 1;\n-\t      if (!c->ts.interface->formal)\n-\t\t{\n-\t\t  gfc_error (\"Procedure pointer component %qs with PASS at %L \"\n-\t\t\t     \"must have at least one argument\",\n-\t\t\t     c->name, &c->loc);\n-\t\t  c->tb->error = 1;\n-\t\t  success = false;\n-\t\t  continue;\n-\t\t}\n-\t      me_arg = c->ts.interface->formal->sym;\n-\t    }\n+  super_type = gfc_get_derived_super_type (sym);\n \n-\t  /* Now check that the argument-type matches.  */\n-\t  gcc_assert (me_arg);\n-\t  if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)\n-\t      || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)\n-\t      || (me_arg->ts.type == BT_CLASS\n-\t\t  && CLASS_DATA (me_arg)->ts.u.derived != sym))\n-\t    {\n-\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L must be of\"\n-\t\t\t \" the derived type %qs\", me_arg->name, c->name,\n-\t\t\t me_arg->name, &c->loc, sym->name);\n-\t      c->tb->error = 1;\n-\t      success = false;\n-\t      continue;\n-\t    }\n+  /* If this type is an extension, set the accessibility of the parent\n+     component.  */\n+  if (super_type\n+      && ((sym->attr.is_class\n+           && c == sym->components->ts.u.derived->components)\n+          || (!sym->attr.is_class && c == sym->components))\n+      && strcmp (super_type->name, c->name) == 0)\n+    c->attr.access = super_type->attr.access;\n+\n+  /* If this type is an extension, see if this component has the same name\n+     as an inherited type-bound procedure.  */\n+  if (super_type && !sym->attr.is_class\n+      && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))\n+    {\n+      gfc_error (\"Component %qs of %qs at %L has the same name as an\"\n+                 \" inherited type-bound procedure\",\n+                 c->name, sym->name, &c->loc);\n+      return false;\n+    }\n \n-\t  /* Check for C453.  */\n-\t  if (me_arg->attr.dimension)\n-\t    {\n-\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n-\t\t\t \"must be scalar\", me_arg->name, c->name, me_arg->name,\n-\t\t\t &c->loc);\n-\t      c->tb->error = 1;\n-\t      success = false;\n-\t      continue;\n-\t    }\n+  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer\n+        && !c->ts.deferred)\n+    {\n+     if (c->ts.u.cl->length == NULL\n+         || (!resolve_charlen(c->ts.u.cl))\n+         || !gfc_is_constant_expr (c->ts.u.cl->length))\n+       {\n+         gfc_error (\"Character length of component %qs needs to \"\n+                    \"be a constant specification expression at %L\",\n+                    c->name,\n+                    c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);\n+         return false;\n+       }\n+    }\n \n-\t  if (me_arg->attr.pointer)\n-\t    {\n-\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n-\t\t\t \"may not have the POINTER attribute\", me_arg->name,\n-\t\t\t c->name, me_arg->name, &c->loc);\n-\t      c->tb->error = 1;\n-\t      success = false;\n-\t      continue;\n-\t    }\n+  if (c->ts.type == BT_CHARACTER && c->ts.deferred\n+      && !c->attr.pointer && !c->attr.allocatable)\n+    {\n+      gfc_error (\"Character component %qs of %qs at %L with deferred \"\n+                 \"length must be a POINTER or ALLOCATABLE\",\n+                 c->name, sym->name, &c->loc);\n+      return false;\n+    }\n \n-\t  if (me_arg->attr.allocatable)\n-\t    {\n-\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n-\t\t\t \"may not be ALLOCATABLE\", me_arg->name, c->name,\n-\t\t\t me_arg->name, &c->loc);\n-\t      c->tb->error = 1;\n-\t      success = false;\n-\t      continue;\n-\t    }\n+  /* Add the hidden deferred length field.  */\n+  if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function\n+      && !sym->attr.is_class)\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN+9];\n+      gfc_component *strlen;\n+      sprintf (name, \"_%s_length\", c->name);\n+      strlen = gfc_find_component (sym, name, true, true, NULL);\n+      if (strlen == NULL)\n+        {\n+          if (!gfc_add_component (sym, name, &strlen))\n+            return false;\n+          strlen->ts.type = BT_INTEGER;\n+          strlen->ts.kind = gfc_charlen_int_kind;\n+          strlen->attr.access = ACCESS_PRIVATE;\n+          strlen->attr.artificial = 1;\n+        }\n+    }\n \n-\t  if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)\n-\t    {\n-\t      gfc_error (\"Non-polymorphic passed-object dummy argument of %qs\"\n-\t\t\t \" at %L\", c->name, &c->loc);\n-\t      success = false;\n-\t      continue;\n-\t    }\n+  if (c->ts.type == BT_DERIVED\n+      && sym->component_access != ACCESS_PRIVATE\n+      && gfc_check_symbol_access (sym)\n+      && !is_sym_host_assoc (c->ts.u.derived, sym->ns)\n+      && !c->ts.u.derived->attr.use_assoc\n+      && !gfc_check_symbol_access (c->ts.u.derived)\n+      && !gfc_notify_std (GFC_STD_F2003, \"the component %qs is a \"\n+                          \"PRIVATE type and cannot be a component of \"\n+                          \"%qs, which is PUBLIC at %L\", c->name,\n+                          sym->name, &sym->declared_at))\n+    return false;\n \n-\t}\n+  if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)\n+    {\n+      gfc_error (\"Polymorphic component %s at %L in SEQUENCE or BIND(C) \"\n+                 \"type %s\", c->name, &c->loc, sym->name);\n+      return false;\n+    }\n \n-      /* Check type-spec if this is not the parent-type component.  */\n-      if (((sym->attr.is_class\n-\t    && (!sym->components->ts.u.derived->attr.extension\n-\t\t|| c != sym->components->ts.u.derived->components))\n-\t   || (!sym->attr.is_class\n-\t       && (!sym->attr.extension || c != sym->components)))\n-\t  && !sym->attr.vtype\n-\t  && !resolve_typespec_used (&c->ts, &c->loc, c->name))\n-\treturn false;\n+  if (sym->attr.sequence)\n+    {\n+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)\n+        {\n+          gfc_error (\"Component %s of SEQUENCE type declared at %L does \"\n+                     \"not have the SEQUENCE attribute\",\n+                     c->ts.u.derived->name, &sym->declared_at);\n+          return false;\n+        }\n+    }\n \n-      /* If this type is an extension, set the accessibility of the parent\n-\t component.  */\n-      if (super_type\n-\t  && ((sym->attr.is_class\n-\t       && c == sym->components->ts.u.derived->components)\n-\t      || (!sym->attr.is_class && c == sym->components))\n-\t  && strcmp (super_type->name, c->name) == 0)\n-\tc->attr.access = super_type->attr.access;\n-\n-      /* If this type is an extension, see if this component has the same name\n-\t as an inherited type-bound procedure.  */\n-      if (super_type && !sym->attr.is_class\n-\t  && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))\n-\t{\n-\t  gfc_error (\"Component %qs of %qs at %L has the same name as an\"\n-\t\t     \" inherited type-bound procedure\",\n-\t\t     c->name, sym->name, &c->loc);\n-\t  return false;\n-\t}\n+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)\n+    c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);\n+  else if (c->ts.type == BT_CLASS && c->attr.class_ok\n+           && CLASS_DATA (c)->ts.u.derived->attr.generic)\n+    CLASS_DATA (c)->ts.u.derived\n+                    = gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);\n \n-      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer\n-\t    && !c->ts.deferred)\n-\t{\n-\t if (c->ts.u.cl->length == NULL\n-\t     || (!resolve_charlen(c->ts.u.cl))\n-\t     || !gfc_is_constant_expr (c->ts.u.cl->length))\n-\t   {\n-\t     gfc_error (\"Character length of component %qs needs to \"\n-\t\t\t\"be a constant specification expression at %L\",\n-\t\t\tc->name,\n-\t\t\tc->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);\n-\t     return false;\n-\t   }\n-\t}\n+  if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype\n+      && c->attr.pointer && c->ts.u.derived->components == NULL\n+      && !c->ts.u.derived->attr.zero_comp)\n+    {\n+      gfc_error (\"The pointer component %qs of %qs at %L is a type \"\n+                 \"that has not been declared\", c->name, sym->name,\n+                 &c->loc);\n+      return false;\n+    }\n \n-      if (c->ts.type == BT_CHARACTER && c->ts.deferred\n-\t  && !c->attr.pointer && !c->attr.allocatable)\n-\t{\n-\t  gfc_error (\"Character component %qs of %qs at %L with deferred \"\n-\t\t     \"length must be a POINTER or ALLOCATABLE\",\n-\t\t     c->name, sym->name, &c->loc);\n-\t  return false;\n-\t}\n+  if (c->ts.type == BT_CLASS && c->attr.class_ok\n+      && CLASS_DATA (c)->attr.class_pointer\n+      && CLASS_DATA (c)->ts.u.derived->components == NULL\n+      && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp\n+      && !UNLIMITED_POLY (c))\n+    {\n+      gfc_error (\"The pointer component %qs of %qs at %L is a type \"\n+                 \"that has not been declared\", c->name, sym->name,\n+                 &c->loc);\n+      return false;\n+    }\n \n-      /* Add the hidden deferred length field.  */\n-      if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function\n-\t  && !sym->attr.is_class)\n-\t{\n-\t  char name[GFC_MAX_SYMBOL_LEN+9];\n-\t  gfc_component *strlen;\n-\t  sprintf (name, \"_%s_length\", c->name);\n-\t  strlen = gfc_find_component (sym, name, true, true);\n-\t  if (strlen == NULL)\n-\t    {\n-\t      if (!gfc_add_component (sym, name, &strlen))\n-\t\treturn false;\n-\t      strlen->ts.type = BT_INTEGER;\n-\t      strlen->ts.kind = gfc_charlen_int_kind;\n-\t      strlen->attr.access = ACCESS_PRIVATE;\n-\t      strlen->attr.artificial = 1;\n-\t    }\n-\t}\n+  /* C437.  */\n+  if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE\n+      && (!c->attr.class_ok\n+          || !(CLASS_DATA (c)->attr.class_pointer\n+               || CLASS_DATA (c)->attr.allocatable)))\n+    {\n+      gfc_error (\"Component %qs with CLASS at %L must be allocatable \"\n+                 \"or pointer\", c->name, &c->loc);\n+      /* Prevent a recurrence of the error.  */\n+      c->ts.type = BT_UNKNOWN;\n+      return false;\n+    }\n \n-      if (c->ts.type == BT_DERIVED\n-\t  && sym->component_access != ACCESS_PRIVATE\n-\t  && gfc_check_symbol_access (sym)\n-\t  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)\n-\t  && !c->ts.u.derived->attr.use_assoc\n-\t  && !gfc_check_symbol_access (c->ts.u.derived)\n-\t  && !gfc_notify_std (GFC_STD_F2003, \"the component %qs is a \"\n-\t\t\t      \"PRIVATE type and cannot be a component of \"\n-\t\t\t      \"%qs, which is PUBLIC at %L\", c->name,\n-\t\t\t      sym->name, &sym->declared_at))\n-\treturn false;\n+  /* Ensure that all the derived type components are put on the\n+     derived type list; even in formal namespaces, where derived type\n+     pointer components might not have been declared.  */\n+  if (c->ts.type == BT_DERIVED\n+        && c->ts.u.derived\n+        && c->ts.u.derived->components\n+        && c->attr.pointer\n+        && sym != c->ts.u.derived)\n+    add_dt_to_dt_list (c->ts.u.derived);\n \n-      if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)\n-\t{\n-\t  gfc_error (\"Polymorphic component %s at %L in SEQUENCE or BIND(C) \"\n-\t\t     \"type %s\", c->name, &c->loc, sym->name);\n-\t  return false;\n-\t}\n+  if (!gfc_resolve_array_spec (c->as,\n+                               !(c->attr.pointer || c->attr.proc_pointer\n+                                 || c->attr.allocatable)))\n+    return false;\n \n-      if (sym->attr.sequence)\n-\t{\n-\t  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)\n-\t    {\n-\t      gfc_error (\"Component %s of SEQUENCE type declared at %L does \"\n-\t\t\t \"not have the SEQUENCE attribute\",\n-\t\t\t c->ts.u.derived->name, &sym->declared_at);\n-\t      return false;\n-\t    }\n-\t}\n+  if (c->initializer && !sym->attr.vtype\n+      && !gfc_check_assign_symbol (sym, c, c->initializer))\n+    return false;\n \n-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)\n-\tc->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);\n-      else if (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t       && CLASS_DATA (c)->ts.u.derived->attr.generic)\n-\tCLASS_DATA (c)->ts.u.derived\n-\t\t\t= gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);\n+  return true;\n+}\n \n-      if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype\n-\t  && c->attr.pointer && c->ts.u.derived->components == NULL\n-\t  && !c->ts.u.derived->attr.zero_comp)\n-\t{\n-\t  gfc_error (\"The pointer component %qs of %qs at %L is a type \"\n-\t\t     \"that has not been declared\", c->name, sym->name,\n-\t\t     &c->loc);\n-\t  return false;\n-\t}\n \n-      if (c->ts.type == BT_CLASS && c->attr.class_ok\n-\t  && CLASS_DATA (c)->attr.class_pointer\n-\t  && CLASS_DATA (c)->ts.u.derived->components == NULL\n-\t  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp\n-\t  && !UNLIMITED_POLY (c))\n-\t{\n-\t  gfc_error (\"The pointer component %qs of %qs at %L is a type \"\n-\t\t     \"that has not been declared\", c->name, sym->name,\n-\t\t     &c->loc);\n-\t  return false;\n-\t}\n+/* Be nice about the locus for a structure expression - show the locus of the\n+   first non-null sub-expression if we can.  */\n \n-      /* C437.  */\n-      if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE\n-\t  && (!c->attr.class_ok\n-\t      || !(CLASS_DATA (c)->attr.class_pointer\n-\t\t   || CLASS_DATA (c)->attr.allocatable)))\n-\t{\n-\t  gfc_error (\"Component %qs with CLASS at %L must be allocatable \"\n-\t\t     \"or pointer\", c->name, &c->loc);\n-\t  /* Prevent a recurrence of the error.  */\n-\t  c->ts.type = BT_UNKNOWN;\n-\t  return false;\n-\t}\n+static locus *\n+cons_where (gfc_expr *struct_expr)\n+{\n+  gfc_constructor *cons;\n \n-      /* Ensure that all the derived type components are put on the\n-\t derived type list; even in formal namespaces, where derived type\n-\t pointer components might not have been declared.  */\n-      if (c->ts.type == BT_DERIVED\n-\t    && c->ts.u.derived\n-\t    && c->ts.u.derived->components\n-\t    && c->attr.pointer\n-\t    && sym != c->ts.u.derived)\n-\tadd_dt_to_dt_list (c->ts.u.derived);\n+  gcc_assert (struct_expr && struct_expr->expr_type == EXPR_STRUCTURE);\n \n-      if (!gfc_resolve_array_spec (c->as,\n-\t\t\t\t   !(c->attr.pointer || c->attr.proc_pointer\n-\t\t\t\t     || c->attr.allocatable)))\n-\treturn false;\n+  cons = gfc_constructor_first (struct_expr->value.constructor);\n+  for (; cons; cons = gfc_constructor_next (cons))\n+    {\n+      if (cons->expr && cons->expr->expr_type != EXPR_NULL)\n+        return &cons->expr->where;\n+    }\n \n-      if (c->initializer && !sym->attr.vtype\n-\t  && !gfc_check_assign_symbol (sym, c, c->initializer))\n-\treturn false;\n+  return &struct_expr->where;\n+}\n+\n+/* Resolve the components of a structure type. Much less work than derived\n+   types.  */\n+\n+static bool\n+resolve_fl_struct (gfc_symbol *sym)\n+{\n+  gfc_component *c;\n+  gfc_expr *init = NULL;\n+  bool success;\n+\n+  /* Make sure UNIONs do not have overlapping initializers.  */\n+  if (sym->attr.flavor == FL_UNION)\n+    {\n+      for (c = sym->components; c; c = c->next)\n+        {\n+          if (init && c->initializer)\n+            {\n+              gfc_error (\"Conflicting initializers in union at %L and %L\",\n+                         cons_where (init), cons_where (c->initializer));\n+              gfc_free_expr (c->initializer);\n+              c->initializer = NULL;\n+            }\n+          if (init == NULL)\n+            init = c->initializer;\n+        }\n     }\n \n+  success = true;\n+  for (c = sym->components; c; c = c->next)\n+    if (!resolve_component (c, sym))\n+      success = false;\n+\n+  if (!success)\n+    return false;\n+\n+  if (sym->components)\n+    add_dt_to_dt_list (sym);\n+\n+  return true;\n+}\n+\n+\n+/* Resolve the components of a derived type. This does not have to wait until\n+   resolution stage, but can be done as soon as the dt declaration has been\n+   parsed.  */\n+\n+static bool\n+resolve_fl_derived0 (gfc_symbol *sym)\n+{\n+  gfc_symbol* super_type;\n+  gfc_component *c;\n+  bool success;\n+\n+  if (sym->attr.unlimited_polymorphic)\n+    return true;\n+\n+  super_type = gfc_get_derived_super_type (sym);\n+\n+  /* F2008, C432.  */\n+  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)\n+    {\n+      gfc_error (\"As extending type %qs at %L has a coarray component, \"\n+\t\t \"parent type %qs shall also have one\", sym->name,\n+\t\t &sym->declared_at, super_type->name);\n+      return false;\n+    }\n+\n+  /* Ensure the extended type gets resolved before we do.  */\n+  if (super_type && !resolve_fl_derived0 (super_type))\n+    return false;\n+\n+  /* An ABSTRACT type must be extensible.  */\n+  if (sym->attr.abstract && !gfc_type_is_extensible (sym))\n+    {\n+      gfc_error (\"Non-extensible derived-type %qs at %L must not be ABSTRACT\",\n+\t\t sym->name, &sym->declared_at);\n+      return false;\n+    }\n+\n+  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components\n+\t\t\t   : sym->components;\n+\n+  success = true;\n+  for ( ; c != NULL; c = c->next)\n+    if (!resolve_component (c, sym))\n+      success = false;\n+\n   if (!success)\n     return false;\n \n@@ -13396,8 +13466,8 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (sym->attr.is_class && sym->ts.u.derived == NULL)\n     {\n       /* Fix up incomplete CLASS symbols.  */\n-      gfc_component *data = gfc_find_component (sym, \"_data\", true, true);\n-      gfc_component *vptr = gfc_find_component (sym, \"_vptr\", true, true);\n+      gfc_component *data = gfc_find_component (sym, \"_data\", true, true, NULL);\n+      gfc_component *vptr = gfc_find_component (sym, \"_vptr\", true, true, NULL);\n \n       /* Nothing more to do for unlimited polymorphic entities.  */\n       if (data->ts.u.derived->attr.unlimited_polymorphic)\n@@ -13616,6 +13686,11 @@ resolve_symbol (gfc_symbol *sym)\n     return;\n   sym->resolved = 1;\n \n+  /* No symbol will ever have union type; only components can be unions.\n+     Union type declaration symbols have type BT_UNKNOWN but flavor FL_UNION\n+     (just like derived type declaration symbols have flavor FL_DERIVED). */\n+  gcc_assert (sym->ts.type != BT_UNION);\n+\n   if (sym->attr.artificial)\n     return;\n \n@@ -13687,6 +13762,10 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->attr.flavor == FL_DERIVED && !resolve_fl_derived (sym))\n     return;\n \n+  else if ((sym->attr.flavor == FL_STRUCT || sym->attr.flavor == FL_UNION)\n+           && !resolve_fl_struct (sym))\n+    return;\n+\n   /* Symbols that are module procedures with results (functions) have\n      the types and array specification copied for type checking in\n      procedures that call them, as well as for saving to a module\n@@ -15030,7 +15109,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n \n   for (; c ; c = c->next)\n     {\n-      if (c->ts.type == BT_DERIVED\n+      if (gfc_bt_struct (c->ts.type)\n \t  && (!resolve_equivalence_derived(c->ts.u.derived, sym, e)))\n \treturn false;\n "}, {"sha": "0ee7decffd4b67e29d191fdd052d429bd3afabca", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 134, "deletions": 25, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -40,6 +40,7 @@ const mstring flavors[] =\n   minit (\"VARIABLE\", FL_VARIABLE), minit (\"PARAMETER\", FL_PARAMETER),\n   minit (\"LABEL\", FL_LABEL), minit (\"PROCEDURE\", FL_PROCEDURE),\n   minit (\"DERIVED\", FL_DERIVED), minit (\"NAMELIST\", FL_NAMELIST),\n+  minit (\"UNION\", FL_UNION), minit (\"STRUCTURE\", FL_STRUCT),\n   minit (NULL, -1)\n };\n \n@@ -444,7 +445,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  case FL_BLOCK_DATA:\n \t  case FL_MODULE:\n \t  case FL_LABEL:\n-\t  case FL_DERIVED:\n+\t  case_fl_struct:\n \t  case FL_PARAMETER:\n             a1 = gfc_code2string (flavors, attr->flavor);\n             a2 = save;\n@@ -740,7 +741,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n       break;\n \n-    case FL_DERIVED:\n+    case_fl_struct:\n       conf2 (dummy);\n       conf2 (pointer);\n       conf2 (target);\n@@ -1579,7 +1580,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n {\n \n   if ((f == FL_PROGRAM || f == FL_BLOCK_DATA || f == FL_MODULE\n-       || f == FL_PARAMETER || f == FL_LABEL || f == FL_DERIVED\n+       || f == FL_PARAMETER || f == FL_LABEL || gfc_fl_struct(f)\n        || f == FL_NAMELIST) && check_used (attr, name, where))\n     return false;\n \n@@ -2048,6 +2049,11 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n {\n   gfc_component *p, *tail;\n \n+  /* Check for existing components with the same name, but not for union\n+     components or containers. Unions and maps are anonymous so they have\n+     unique internal names which will never conflict.\n+     Don't use gfc_find_component here because it calls gfc_use_derived,\n+     but the derived type may not be fully defined yet. */\n   tail = NULL;\n \n   for (p = sym->components; p; p = p->next)\n@@ -2063,7 +2069,8 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n     }\n \n   if (sym->attr.extension\n-\t&& gfc_find_component (sym->components->ts.u.derived, name, true, true))\n+\t&& gfc_find_component (sym->components->ts.u.derived,\n+                               name, true, true, NULL))\n     {\n       gfc_error (\"Component %qs at %C already in the parent type \"\n \t\t \"at %L\", name, &sym->components->ts.u.derived->declared_at);\n@@ -2154,7 +2161,7 @@ gfc_use_derived (gfc_symbol *sym)\n       return NULL;\n     }\n \n-  if (s == NULL || s->attr.flavor != FL_DERIVED)\n+  if (s == NULL || !gfc_fl_struct (s->attr.flavor))\n     goto bad;\n \n   /* Get rid of symbol sym, translating all references to s.  */\n@@ -2188,28 +2195,113 @@ gfc_use_derived (gfc_symbol *sym)\n }\n \n \n+/* Find the component with the given name in the union type symbol.\n+   If ref is not NULL it will be set to the chain of components through which\n+   the component can actually be accessed. This is necessary for unions because\n+   intermediate structures may be maps, nested structures, or other unions,\n+   all of which may (or must) be 'anonymous' to user code.  */\n+\n+static gfc_component *\n+find_union_component (gfc_symbol *un, const char *name,\n+                      bool noaccess, gfc_ref **ref)\n+{\n+  gfc_component *m, *check;\n+  gfc_ref *sref, *tmp;\n+\n+  for (m = un->components; m; m = m->next)\n+    {\n+      check = gfc_find_component (m->ts.u.derived, name, noaccess, true, &tmp);\n+      if (check == NULL)\n+        continue;\n+\n+      /* Found component somewhere in m; chain the refs together.  */\n+      if (ref)\n+        {\n+          /* Map ref. */\n+          sref = gfc_get_ref ();\n+          sref->type = REF_COMPONENT;\n+          sref->u.c.component = m;\n+          sref->u.c.sym = m->ts.u.derived;\n+          sref->next = tmp;\n+\n+          *ref = sref;\n+        }\n+      /* Other checks (such as access) were done in the recursive calls.  */\n+      return check;\n+    }\n+  return NULL;\n+}\n+\n+\n /* Given a derived type node and a component name, try to locate the\n    component structure.  Returns the NULL pointer if the component is\n    not found or the components are private.  If noaccess is set, no access\n-   checks are done.  */\n+   checks are done.  If silent is set, an error will not be generated if\n+   the component cannot be found or accessed.\n+   \n+   If ref is not NULL, *ref is set to represent the chain of components\n+   required to get to the ultimate component.\n+\n+   If the component is simply a direct subcomponent, or is inherited from a\n+   parent derived type in the given derived type, this is a single ref with its\n+   component set to the returned component.\n+\n+   Otherwise, *ref is constructed as a chain of subcomponents. This occurs\n+   when the component is found through an implicit chain of nested union and\n+   map components. Unions and maps are \"anonymous\" substructures in FORTRAN\n+   which cannot be explicitly referenced, but the reference chain must be\n+   considered as in C for backend translation to correctly compute layouts.\n+   (For example, x.a may refer to x->(UNION)->(MAP)->(UNION)->(MAP)->a).  */\n \n gfc_component *\n gfc_find_component (gfc_symbol *sym, const char *name,\n-\t\t    bool noaccess, bool silent)\n+\t\t    bool noaccess, bool silent, gfc_ref **ref)\n {\n-  gfc_component *p;\n+  gfc_component *p, *check;\n+  gfc_ref *sref = NULL, *tmp = NULL;\n \n   if (name == NULL || sym == NULL)\n     return NULL;\n \n-  sym = gfc_use_derived (sym);\n+  if (sym->attr.flavor == FL_DERIVED)\n+    sym = gfc_use_derived (sym);\n+  else\n+    gcc_assert (gfc_fl_struct (sym->attr.flavor));\n \n   if (sym == NULL)\n     return NULL;\n \n+  /* Handle UNIONs specially - mutually recursive with gfc_find_component. */\n+  if (sym->attr.flavor == FL_UNION)\n+    return find_union_component (sym, name, noaccess, ref);\n+\n+  if (ref) *ref = NULL;\n   for (p = sym->components; p; p = p->next)\n-    if (strcmp (p->name, name) == 0)\n-      break;\n+    {\n+      /* Nest search into union's maps. */\n+      if (p->ts.type == BT_UNION)\n+        {\n+          check = find_union_component (p->ts.u.derived, name, noaccess, &tmp);\n+          if (check != NULL)\n+            {\n+              /* Union ref. */\n+              if (ref)\n+                {\n+                  sref = gfc_get_ref ();\n+                  sref->type = REF_COMPONENT;\n+                  sref->u.c.component = p;\n+                  sref->u.c.sym = p->ts.u.derived;\n+                  sref->next = tmp;\n+                  *ref = sref;\n+                }\n+              return check;\n+            }\n+        }\n+      else if (strcmp (p->name, name) == 0)\n+        break;\n+\n+      continue;\n+    }\n \n   if (p && sym->attr.use_assoc && !noaccess)\n     {\n@@ -2231,7 +2323,7 @@ gfc_find_component (gfc_symbol *sym, const char *name,\n \t&& sym->components->ts.type == BT_DERIVED)\n     {\n       p = gfc_find_component (sym->components->ts.u.derived, name,\n-\t\t\t      noaccess, silent);\n+\t\t\t      noaccess, silent, ref);\n       /* Do not overwrite the error.  */\n       if (p == NULL)\n \treturn p;\n@@ -2241,6 +2333,25 @@ gfc_find_component (gfc_symbol *sym, const char *name,\n     gfc_error (\"%qs at %C is not a member of the %qs structure\",\n \t       name, sym->name);\n \n+  /* Component was found; build the ultimate component reference. */\n+  if (p != NULL && ref)\n+    {\n+      tmp = gfc_get_ref ();\n+      tmp->type = REF_COMPONENT;\n+      tmp->u.c.component = p;\n+      tmp->u.c.sym = sym;\n+      /* Link the final component ref to the end of the chain of subrefs. */\n+      if (sref)\n+        {\n+          *ref = sref;\n+          for (; sref->next; sref = sref->next)\n+            ;\n+          sref->next = tmp;\n+        }\n+      else\n+        *ref = tmp;\n+    }\n+\n   return p;\n }\n \n@@ -3338,11 +3449,9 @@ gfc_restore_last_undo_checkpoint (void)\n \t  /* The derived type is saved in the symtree with the first\n \t     letter capitalized; the all lower-case version to the\n \t     derived type contains its associated generic function.  */\n-\t  if (p->attr.flavor == FL_DERIVED)\n-\t    gfc_delete_symtree (&p->ns->sym_root, gfc_get_string (\"%c%s\",\n-                        (char) TOUPPER ((unsigned char) p->name[0]),\n-                        &p->name[1]));\n-\t  else\n+\t  if (gfc_fl_struct (p->attr.flavor))\n+\t    gfc_delete_symtree (&p->ns->sym_root,gfc_dt_upper_string (p->name));\n+          else\n \t    gfc_delete_symtree (&p->ns->sym_root, p->name);\n \n \t  gfc_release_symbol (p);\n@@ -4526,10 +4635,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t      const char *hidden_name;\n \t      gfc_interface *intr, *head;\n \n-\t      hidden_name = gfc_get_string (\"%c%s\",\n-\t\t\t\t\t    (char) TOUPPER ((unsigned char)\n-\t\t\t\t\t\t\t      tmp_sym->name[0]),\n-\t\t\t\t\t    &tmp_sym->name[1]);\n+\t      hidden_name = gfc_dt_upper_string (tmp_sym->name);\n \t      tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,\n \t\t\t\t\t      hidden_name);\n \t      gcc_assert (tmp_symtree == NULL);\n@@ -4740,6 +4846,8 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n   bool is_class2 = (ts2->type == BT_CLASS);\n   bool is_derived1 = (ts1->type == BT_DERIVED);\n   bool is_derived2 = (ts2->type == BT_DERIVED);\n+  bool is_union1 = (ts1->type == BT_UNION);\n+  bool is_union2 = (ts2->type == BT_UNION);\n \n   if (is_class1\n       && ts1->u.derived->components\n@@ -4749,10 +4857,11 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n \t  || ts1->u.derived->attr.unlimited_polymorphic))\n     return 1;\n \n-  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2)\n+  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2\n+      && !is_union1 && !is_union2)\n     return (ts1->type == ts2->type);\n \n-  if (is_derived1 && is_derived2)\n+  if ((is_derived1 && is_derived2) || (is_union1 && is_union1))\n     return gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);\n \n   if (is_derived1 && is_class2)\n@@ -4821,12 +4930,12 @@ gfc_find_dt_in_generic (gfc_symbol *sym)\n {\n   gfc_interface *intr = NULL;\n \n-  if (!sym || sym->attr.flavor == FL_DERIVED)\n+  if (!sym || gfc_fl_struct (sym->attr.flavor))\n     return sym;\n \n   if (sym->attr.generic)\n     for (intr = sym->generic; intr; intr = intr->next)\n-      if (intr->sym->attr.flavor == FL_DERIVED)\n+      if (gfc_fl_struct (intr->sym->attr.flavor))\n         break;\n   return intr ? intr->sym : NULL;\n }"}, {"sha": "d4ea6c8ee681816af8a99b34e61ec2b98d7e9b8d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -732,6 +732,7 @@ gfc_get_module_backend_decl (gfc_symbol *sym)\n       st = NULL;\n       s = NULL;\n \n+      /* Check for a symbol with the same name. */\n       if (gsym)\n \tgfc_find_symbol (sym->name, gsym->ns, 0, &s);\n \n@@ -748,22 +749,37 @@ gfc_get_module_backend_decl (gfc_symbol *sym)\n \t  st->n.sym = sym;\n \t  sym->refs++;\n \t}\n-      else if (sym->attr.flavor == FL_DERIVED)\n+      else if (gfc_fl_struct (sym->attr.flavor))\n \t{\n \t  if (s && s->attr.flavor == FL_PROCEDURE)\n \t    {\n \t      gfc_interface *intr;\n \t      gcc_assert (s->attr.generic);\n \t      for (intr = s->generic; intr; intr = intr->next)\n-\t\tif (intr->sym->attr.flavor == FL_DERIVED)\n+\t\tif (gfc_fl_struct (intr->sym->attr.flavor))\n \t\t  {\n \t\t    s = intr->sym;\n \t\t    break;\n \t\t  }\n     \t    }\n \n-\t  if (!s->backend_decl)\n-\t    s->backend_decl = gfc_get_derived_type (s);\n+          /* Normally we can assume that s is a derived-type symbol since it\n+             shares a name with the derived-type sym. However if sym is a\n+             STRUCTURE, it may in fact share a name with any other basic type\n+             variable. If s is in fact of derived type then we can continue\n+             looking for a duplicate type declaration.  */\n+          if (sym->attr.flavor == FL_STRUCT && s->ts.type == BT_DERIVED)\n+            {\n+              s = s->ts.u.derived;\n+            }\n+\n+\t  if (gfc_fl_struct (s->attr.flavor) && !s->backend_decl)\n+            {\n+              if (s->attr.flavor == FL_UNION)\n+                s->backend_decl = gfc_get_union_type (s);\n+              else\n+                s->backend_decl = gfc_get_derived_type (s);\n+            }\n \t  gfc_copy_dt_decls_ifequal (s, sym, true);\n \t  return true;\n \t}\n@@ -2384,7 +2400,7 @@ create_function_arglist (gfc_symbol * sym)\n \t Thus, we will use a hidden argument in that case.  */\n       else if (f->sym->attr.optional && f->sym->attr.value\n \t       && !f->sym->attr.dimension && f->sym->ts.type != BT_CLASS\n-\t       && f->sym->ts.type != BT_DERIVED)\n+\t       && !gfc_bt_struct (f->sym->ts.type))\n \t{\n           tree tmp;\n           strcpy (&name[1], f->sym->name);\n@@ -4596,7 +4612,7 @@ gfc_create_module_variable (gfc_symbol * sym)\n       && sym->ts.type == BT_DERIVED)\n     sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));\n \n-  if (sym->attr.flavor == FL_DERIVED\n+  if (gfc_fl_struct (sym->attr.flavor)\n       && sym->backend_decl\n       && TREE_CODE (sym->backend_decl) == RECORD_TYPE)\n     {\n@@ -4839,7 +4855,7 @@ check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,\n     }\n   else switch (ts->type)\n     {\n-    case BT_DERIVED:\n+    case_bt_struct:\n       if (expr->expr_type != EXPR_STRUCTURE)\n \treturn false;\n       cm = expr->ts.u.derived->components;"}, {"sha": "8f84712931bbae45a70a8dee979cd60fd5be080f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -2297,6 +2297,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   tree tmp;\n   tree decl;\n   tree field;\n+  tree context;\n \n   c = ref->u.c.component;\n \n@@ -2307,15 +2308,20 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   field = c->backend_decl;\n   gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n+  context = DECL_FIELD_CONTEXT (field);\n \n   /* Components can correspond to fields of different containing\n      types, as components are created without context, whereas\n      a concrete use of a component has the type of decl as context.\n      So, if the type doesn't match, we search the corresponding\n      FIELD_DECL in the parent type.  To not waste too much time\n-     we cache this result in norestrict_decl.  */\n+     we cache this result in norestrict_decl.\n+     On the other hand, if the context is a UNION or a MAP (a\n+     RECORD_TYPE within a UNION_TYPE) always use the given FIELD_DECL.  */\n \n-  if (DECL_FIELD_CONTEXT (field) != TREE_TYPE (decl))\n+  if (context != TREE_TYPE (decl) \n+      && !(   TREE_CODE (TREE_TYPE (field)) == UNION_TYPE /* Field is union */\n+           || TREE_CODE (context) == UNION_TYPE))         /* Field is map */\n     {\n       tree f2 = c->norestrict_decl;\n       if (!f2 || DECL_FIELD_CONTEXT (f2) != TREE_TYPE (decl))\n@@ -6715,7 +6721,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n     {\n       switch (ts->type)\n \t{\n-\tcase BT_DERIVED:\n+\tcase_bt_struct:\n \tcase BT_CLASS:\n \t  gfc_init_se (&se, NULL);\n \t  if (ts->type == BT_CLASS && expr->expr_type == EXPR_NULL)\n@@ -6860,7 +6866,7 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n   gfc_add_modify (&block, dest, se.expr);\n \n   /* Deal with arrays of derived types with allocatable components.  */\n-  if (cm->ts.type == BT_DERIVED\n+  if (gfc_bt_struct (cm->ts.type)\n \t&& cm->ts.u.derived->attr.alloc_comp)\n     tmp = gfc_copy_alloc_comp (cm->ts.u.derived,\n \t\t\t       se.expr, dest,\n@@ -7033,7 +7039,7 @@ alloc_scalar_allocatable_for_subcomponent_assignment (stmtblock_t *block,\n       /* Ensure that cm->ts.u.cl->backend_decl is a componentref to _%s_length\n \t component.  */\n       sprintf (name, \"_%s_length\", cm->name);\n-      strlen = gfc_find_component (sym, name, true, true);\n+      strlen = gfc_find_component (sym, name, true, true, NULL);\n       lhs_cl_size = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t     gfc_charlen_type_node,\n \t\t\t\t     TREE_OPERAND (comp, 0),\n@@ -7245,7 +7251,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t\t\tfold_convert (TREE_TYPE (tmp), se.expr));\n       gfc_add_block_to_block (&block, &se.post);\n     }\n-  else if (expr->ts.type == BT_DERIVED && expr->ts.f90_type != BT_VOID)\n+  else if (gfc_bt_struct (expr->ts.type) && expr->ts.f90_type != BT_VOID)\n     {\n       if (expr->expr_type != EXPR_STRUCTURE)\n \t{\n@@ -7416,6 +7422,24 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       return;\n     }\n \n+  /* Though unions appear to have multiple map components, they must only\n+     have a single initializer since each map overlaps. TODO: squash map\n+     constructors?  */\n+  if (expr->ts.type == BT_UNION)\n+    {\n+      c = gfc_constructor_first (expr->value.constructor);\n+      cm = c->n.component;\n+      val = gfc_conv_initializer (c->expr, &expr->ts,\n+                                  TREE_TYPE (cm->backend_decl),\n+                                  cm->attr.dimension, cm->attr.pointer,\n+                                  cm->attr.proc_pointer);\n+      val = unshare_expr_without_location (val);\n+\n+      /* Append it to the constructor list.  */\n+      CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n+      goto finish;\n+    }\n+\n   cm = expr->ts.u.derived->components;\n \n   for (c = gfc_constructor_first (expr->value.constructor);\n@@ -7462,6 +7486,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n \t}\n     }\n+finish:\n   se->expr = build_constructor (type, v);\n   if (init)\n     TREE_CONSTANT (se->expr) = 1;\n@@ -8246,7 +8271,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,\n \t\t\t     rse->expr, ts.kind);\n     }\n-  else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n+  else if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)\n     {\n       tree tmp_var = NULL_TREE;\n       cond = NULL_TREE;\n@@ -8299,7 +8324,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }\n-  else if (ts.type == BT_DERIVED || ts.type == BT_CLASS)\n+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n@@ -9503,7 +9528,7 @@ copyable_array_p (gfc_expr * expr)\n     case BT_CHARACTER:\n       return false;\n \n-    case BT_DERIVED:\n+    case_bt_struct:\n       return !expr->ts.u.derived->attr.alloc_comp;\n \n     default:"}, {"sha": "aefa96dfbbbcbfab2ab82fddd4bd942fa0998767", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -1685,7 +1685,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n-  if (ts->type == BT_DERIVED && ts->u.derived->components)\n+  if (gfc_bt_struct (ts->type) && ts->u.derived->components)\n     {\n       gfc_component *cmp;\n \n@@ -2211,7 +2211,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n \n       break;\n \n-    case BT_DERIVED:\n+    case_bt_struct:\n       if (ts->u.derived->components == NULL)\n \treturn;\n \n@@ -2330,7 +2330,7 @@ gfc_trans_transfer (gfc_code * code)\n \t  gcc_assert (ref && ref->type == REF_ARRAY);\n \t}\n \n-      if (expr->ts.type != BT_DERIVED\n+      if (!gfc_bt_struct (expr->ts.type)\n \t    && ref && ref->next == NULL\n \t    && !is_subref_array (expr))\n \t{"}, {"sha": "7d3cf8cae5aef7c449179acfaa8bbf46e9bf8c13", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -6275,7 +6275,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t{\n \t  gfc_ref *ref;\n \n-\t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp\n+\t  if (gfc_bt_struct (expr->ts.type) && expr->ts.u.derived->attr.alloc_comp\n \t      && !gfc_is_finalizable (expr->ts.u.derived, NULL))\n \t    {\n \t      gfc_ref *last = NULL;"}, {"sha": "0079d6cd422cba82b103c87b6555f6598bf3a0f6", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -1102,6 +1102,10 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n \t\t\t\t\t     gfc_index_one_node);\n       break;\n \n+    case BT_UNION:\n+      basetype = gfc_get_union_type (spec->u.derived);\n+      break;\n+\n     case BT_DERIVED:\n     case BT_CLASS:\n       basetype = gfc_get_derived_type (spec->u.derived);\n@@ -2315,7 +2319,9 @@ gfc_copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to,\n   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n     {\n       to_cm->backend_decl = from_cm->backend_decl;\n-      if (from_cm->ts.type == BT_DERIVED\n+      if (from_cm->ts.type == BT_UNION)\n+        gfc_get_union_type (to_cm->ts.u.derived);\n+      else if (from_cm->ts.type == BT_DERIVED\n \t  && (!from_cm->attr.pointer || from_gsym))\n \tgfc_get_derived_type (to_cm->ts.u.derived);\n       else if (from_cm->ts.type == BT_CLASS\n@@ -2350,6 +2356,62 @@ gfc_get_ppc_type (gfc_component* c)\n }\n \n \n+/* Build a tree node for a union type. Requires building each map\n+   structure which is an element of the union. */\n+\n+tree\n+gfc_get_union_type (gfc_symbol *un)\n+{\n+    gfc_component *map = NULL;\n+    tree typenode = NULL, map_type = NULL, map_field = NULL;\n+    tree *chain = NULL;\n+\n+    if (un->backend_decl)\n+      {\n+        if (TYPE_FIELDS (un->backend_decl) || un->attr.proc_pointer_comp)\n+          return un->backend_decl;\n+        else\n+          typenode = un->backend_decl;\n+      }\n+    else\n+      {\n+        typenode = make_node (UNION_TYPE);\n+        TYPE_NAME (typenode) = get_identifier (un->name);\n+      }\n+\n+    /* Add each contained MAP as a field. */\n+    for (map = un->components; map; map = map->next)\n+      {\n+        gcc_assert (map->ts.type == BT_DERIVED);\n+\n+        /* The map's type node, which is defined within this union's context. */\n+        map_type = gfc_get_derived_type (map->ts.u.derived);\n+        TYPE_CONTEXT (map_type) = typenode;\n+\n+        /* The map field's declaration. */\n+        map_field = gfc_add_field_to_struct(typenode, get_identifier(map->name),\n+                                            map_type, &chain);\n+        if (map->loc.lb)\n+          gfc_set_decl_location (map_field, &map->loc);\n+        else if (un->declared_at.lb)\n+          gfc_set_decl_location (map_field, &un->declared_at);\n+\n+        DECL_PACKED (map_field) |= TYPE_PACKED (typenode);\n+        DECL_NAMELESS(map_field) = true;\n+\n+        /* We should never clobber another backend declaration for this map,\n+           because each map component is unique. */\n+        if (!map->backend_decl)\n+          map->backend_decl = map_field;\n+      }\n+\n+    un->backend_decl = typenode;\n+    gfc_finish_type (typenode);\n+\n+    return typenode;\n+}\n+\n+\n /* Build a tree node for a derived type.  If there are equal\n    derived types, with different local names, these are built\n    at the same time.  If an equal derived type has been built\n@@ -2492,6 +2554,9 @@ gfc_get_derived_type (gfc_symbol * derived)\n      will be built and so we can return the type.  */\n   for (c = derived->components; c; c = c->next)\n     {\n+      if (c->ts.type == BT_UNION && c->ts.u.derived->backend_decl == NULL)\n+        c->ts.u.derived->backend_decl = gfc_get_union_type (c->ts.u.derived);\n+\n       if (c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)\n \tcontinue;\n \n@@ -2521,7 +2586,10 @@ gfc_get_derived_type (gfc_symbol * derived)\n     return derived->backend_decl;\n \n   /* Build the type member list. Install the newly created RECORD_TYPE\n-     node as DECL_CONTEXT of each FIELD_DECL.  */\n+     node as DECL_CONTEXT of each FIELD_DECL. In this case we must go\n+     through only the top-level linked list of components so we correctly\n+     build UNION_TYPE nodes for BT_UNION components. MAPs and other nested\n+     types are built as part of gfc_get_union_type.  */\n   for (c = derived->components; c; c = c->next)\n     {\n       /* Prevent infinite recursion, when the procedure pointer type is"}, {"sha": "aab13e49b4a7cac24c16b8e47a94b2b97cafc061", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -1,3 +1,25 @@\n+2016-05-07  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tPR fortran/56226\n+\t* gfortran.dg/dec_structure_1.f90: New testcase.\n+\t* gfortran.dg/dec_structure_2.f90: Ditto.\n+\t* gfortran.dg/dec_structure_3.f90: Ditto.\n+\t* gfortran.dg/dec_structure_4.f90: Ditto.\n+\t* gfortran.dg/dec_structure_5.f90: Ditto.\n+\t* gfortran.dg/dec_structure_6.f90: Ditto.\n+\t* gfortran.dg/dec_structure_7.f90: Ditto.\n+\t* gfortran.dg/dec_structure_8.f90: Ditto.\n+\t* gfortran.dg/dec_structure_9.f90: Ditto.\n+\t* gfortran.dg/dec_structure_10.f90: Ditto.\n+\t* gfortran.dg/dec_structure_11.f90: Ditto.\n+\t* gfortran.dg/dec_union_1.f90: Ditto.\n+\t* gfortran.dg/dec_union_2.f90: Ditto.\n+\t* gfortran.dg/dec_union_3.f90: Ditto.\n+\t* gfortran.dg/dec_union_4.f90: Ditto.\n+\t* gfortran.dg/dec_union_5.f90: Ditto.\n+\t* gfortran.dg/dec_union_6.f90: Ditto.\n+\t* gfortran.dg/dec_union_7.f90: Ditto.\n+\n 2016-05-07  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/70956"}, {"sha": "4dfee3c602e7213afefac678cb9af2ccc6e2477a", "filename": "gcc/testsuite/gfortran.dg/dec_structure_1.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_1.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Basic STRUCTURE test.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Basic structure\n+structure /s1/                ! type s1\n+  integer i1\n+  logical l1\n+  real r1\n+  character c1\n+end structure                 ! end type s1\n+\n+record /s1/ r1                ! type (s1) r1\n+record /s1/ r1_a(3)           ! type (s1) r1_a(3)\n+\n+! Basic records\n+r1.i1 = 13579                  ! r1%i1 = ...\n+r1.l1 = .true.\n+r1.r1 = 13.579\n+r1.c1 = 'F'\n+r1_a(2) = r1\n+r1_a(3).r1 = 135.79\n+\n+if (r1.i1 .ne. 13579) then\n+  call aborts(\"r1.i1\")\n+endif\n+\n+if (r1.l1 .neqv. .true.) then\n+  call aborts(\"r1.l1\")\n+endif\n+\n+if (r1.r1 .ne. 13.579) then\n+  call aborts(\"r1.r1\")\n+endif\n+\n+if (r1.c1 .ne. 'F') then\n+  call aborts(\"r1.c1\")\n+endif\n+\n+if (r1_a(2).i1 .ne. 13579) then\n+  call aborts(\"r1_a(2).i1\")\n+endif\n+\n+if (r1_a(3).r1 .ne. 135.79) then\n+  call aborts(\"r1_a(3).r1\")\n+endif\n+\n+end"}, {"sha": "2d92b1ad8fd21e88d9ff952eac65695c8120b173", "filename": "gcc/testsuite/gfortran.dg/dec_structure_10.f90", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_10.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,119 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Runtime tests for rules governing dot ('.') as a member accessor, including\n+! voodoo with aliased user-defined vs. intrinsic operators and nested members.\n+! See gcc/fortran/match.c (gfc_match_member_sep).\n+!\n+\n+module dec_structure_10\n+  ! Operator overload tests with .ne. and constant member\n+  structure /s1/\n+    integer i\n+    integer ne\n+    logical b\n+  end structure\n+\n+  ! Operator overload tests with .eq., .test. and nested members\n+  structure /s2/\n+    record /s1/ eq\n+    record /s1/ test\n+    record /s1/ and\n+    integer i\n+  end structure\n+\n+  ! Deep nested access tests\n+  structure /s3/\n+    record /s2/ r2\n+  end structure\n+  structure /s4/\n+    record /s3/ r3\n+  end structure\n+  structure /s5/\n+    record /s4/ r4\n+  end structure\n+  structure /s6/\n+    record /s5/ r5\n+  end structure\n+  structure /s7/\n+    record /s6/ r6\n+  end structure\n+\n+  ! Operator overloads to mess with nested member accesses\n+  interface operator (.ne.)\n+    module procedure ne_func\n+  end interface operator (.ne.)\n+  interface operator (.eq.)\n+    module procedure eq_func\n+  end interface operator (.eq.)\n+  interface operator (.test.)\n+    module procedure tstfunc\n+  end interface operator (.test.)\n+  contains\n+  ! ne_func will be called on (x) .ne. (y)\n+  function ne_func (r, i)\n+    integer, intent(in) :: i\n+    type(s1), intent(in) :: r\n+    integer ne_func\n+    ne_func = r%i + i\n+  end function\n+  ! eq_func will be called on (x) .eq. (y)\n+  function eq_func (r, i)\n+    integer, intent(in) :: i\n+    type(s2), intent(in) :: r\n+    integer eq_func\n+    eq_func = r%eq%i + i\n+  end function eq_func\n+  ! tstfunc will be called on (x) .test. (y)\n+  function tstfunc (r, i)\n+    integer, intent(in) :: i\n+    type(s2), intent(in) :: r\n+    integer tstfunc\n+    tstfunc = r%i + i\n+  end function tstfunc\n+end module\n+\n+use dec_structure_10\n+\n+record /s1/ r\n+record /s2/ struct\n+record /s7/ r7\n+integer i, j\n+logical l\n+struct%eq%i = 5\n+i = -5\n+\n+! Nested access: struct has a member and which has a member b\n+l =  struct .and. b   ! struct%and%b\n+l =  struct .and. b .or. .false. ! (struct%and%b) .or. (.false.)\n+\n+! Intrinsic op: r has no member 'ne'\n+j =  r .ne. i         ! <intrinsic> ne(r, i)\n+j = (r) .ne. i        ! <intrinsic> ne(r, i)\n+\n+! Intrinsic op; r has a member 'ne' but it is not a record\n+j =  r .ne. i         ! <intrinsic> ne(r, i)\n+j = (r) .ne. i        ! <intrinsic> ne(r, i)\n+\n+! Nested access: struct has a member eq which has a member i\n+j =  struct .eq. i    ! struct%eq%i\n+if ( j .ne. struct%eq%i ) call abort()\n+\n+! User op: struct is compared to i with eq_func\n+j = (struct) .eq. i   ! eq_func(struct, i) -> struct%eq%i + i\n+if ( j .ne. struct%eq%i + i ) call abort()\n+\n+! User op: struct has a member test which has a member i, but test is a uop\n+j =  struct .test. i  ! tstfunc(struct, i) -> struct%i + i\n+if ( j .ne. struct%i + i ) call abort()\n+\n+! User op: struct is compared to i with eq_func\n+j = (struct) .test. i ! tstfunc(struct, i) -> struct%i + i\n+if ( j .ne. struct%i + i ) call abort()\n+\n+! Deep nested access tests\n+r7.r6.r5.r4.r3.r2.i = 1337\n+j = r7.r6.r5.r4.r3.r2.i\n+if ( j .ne. 1337 ) call abort()\n+\n+end"}, {"sha": "f6f5b6f9d13d49e8e134bb687420ea5302e91c33", "filename": "gcc/testsuite/gfortran.dg/dec_structure_11.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_11.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Tests for what CAN'T be done with dot ('.') as a member accessor.\n+!\n+\n+structure /s1/\n+  integer eq\n+end structure\n+\n+record /s1/ r\n+integer i, j, k\n+\n+j = i.j          ! { dg-error \"nonderived-type variable\" }\n+j = r .eq. i     ! { dg-error \"Operands of comparison\" }\n+j = r.i          ! { dg-error \"is not a member of\" }\n+j = r.           ! { dg-error \"Expected structure component or operator name\" }\n+j = .i           ! { dg-error \"Invalid character in name\" }\n+\n+end"}, {"sha": "18db719c14960b6a54c971cfff806a84ebd5761f", "filename": "gcc/testsuite/gfortran.dg/dec_structure_2.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_2.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test STRUCTUREs containin other STRUCTUREs.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Basic structure\n+structure /s1/\n+  integer i1\n+  logical l1\n+  real r1\n+  character c1\n+end structure\n+\n+structure /s2/\n+  integer i\n+  record /s1/ r1\n+endstructure\n+\n+record /s1/ r1\n+record /s2/ r2, r2_a(10)\n+\n+! Nested and array records\n+r2.r1.r1 = 135.79\n+r2_a(3).r1.i1 = -13579\n+\n+if (r2.r1.r1 .ne. 135.79) then\n+  call aborts(\"r1.r1.r1\")\n+endif\n+\n+if (r2_a(3).r1.i1 .ne. -13579) then\n+  call aborts(\"r2_a(3).r1.i1\")\n+endif\n+\n+end"}, {"sha": "9cb7adb6719a9faa64acfdaccf34f0afcf61c259", "filename": "gcc/testsuite/gfortran.dg/dec_structure_3.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_3.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test nested STRUCTURE definitions.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+structure /s3/\n+  real p\n+  structure /s4/ recrd, recrd_a(3)\n+    integer i, j\n+  end structure\n+  real q\n+end structure\n+\n+record /s3/ r3\n+record /s4/ r4\n+\n+r3.p = 1.3579\n+r4.i = 0\n+r4.j = 1\n+r3.recrd = r4\n+r3.recrd_a(1) = r3.recrd\n+r3.recrd_a(2).i = 1\n+r3.recrd_a(2).j = 0\n+\n+if (r3.p .ne. 1.3579) then\n+  call aborts(\"r3.p\")\n+endif\n+\n+if (r4.i .ne. 0) then\n+  call aborts(\"r4.i\")\n+endif\n+\n+if (r4.j .ne. 1) then\n+  call aborts(\"r4.j\")\n+endif\n+\n+if (r3.recrd.i .ne. 0 .or. r3.recrd.j .ne. 1) then\n+  call aborts(\"r3.recrd\")\n+endif\n+\n+if (r3.recrd_a(2).i .ne. 1 .or. r3.recrd_a(2).j .ne. 0) then\n+  call aborts(\"r3.recrd_a(2)\")\n+endif\n+\n+end"}, {"sha": "a941c220b7ebd1ac6aea65fae26c9bc23ef11fd9", "filename": "gcc/testsuite/gfortran.dg/dec_structure_4.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_4.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test anonymous STRUCTURE definitions.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+structure /s5/\n+  structure recrd, recrd_a(3)\n+    real x, y\n+  end structure\n+end structure\n+\n+record /s5/ r5\n+\n+r5.recrd.x = 1.3\n+r5.recrd.y = 5.7\n+r5.recrd_a(1) = r5.recrd\n+r5.recrd_a(2).x = 5.7\n+r5.recrd_a(2).y = 1.3\n+\n+if (r5.recrd.x .ne. 1.3) then\n+  call aborts(\"r5.recrd.x\")\n+endif\n+\n+if (r5.recrd.y .ne. 5.7) then\n+  call aborts(\"r5.recrd.y\")\n+endif\n+\n+if (r5.recrd_a(1).x .ne. 1.3 .or. r5.recrd_a(1).y .ne. 5.7) then\n+  call aborts(\"r5.recrd_a(1)\")\n+endif\n+\n+if (r5.recrd_a(2).x .ne. 5.7 .or. r5.recrd_a(2).y .ne. 1.3) then\n+  call aborts(\"r5.recrd_a(2)\")\n+endif\n+\n+end"}, {"sha": "abda3c3e9fbe0f6c314010a5cbbe6cc689058164", "filename": "gcc/testsuite/gfortran.dg/dec_structure_5.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_5.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test STRUCTUREs which share names with variables.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Special regression where shared names within a module caused an ICE\n+! from gfc_get_module_backend_decl\n+module dec_structure_5m\n+  structure /s6/\n+    integer i\n+  end structure\n+\n+  record /s6/ s6\n+end module\n+\n+program dec_structure_5\n+  use dec_structure_5m\n+\n+  structure /s7/\n+    real r\n+  end structure\n+\n+  record /s7/ s7(3)\n+\n+  s6.i = 0\n+  s7(1).r = 1.0\n+  s7(2).r = 2.0\n+  s7(3).r = 3.0\n+\n+  if (s6.i .ne. 0) then\n+    call aborts(\"s6.i\")\n+  endif\n+\n+  if (s7(1).r .ne. 1.0) then\n+    call aborts(\"s7(1).r\")\n+  endif\n+\n+  if (s7(2).r .ne. 2.0) then\n+    call aborts(\"s7(2).r\")\n+  endif\n+\n+end"}, {"sha": "6494d71fd1ca13a24f2a62ef82da2ccfe2845299", "filename": "gcc/testsuite/gfortran.dg/dec_structure_6.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_6.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test old-style CLIST initializers in STRUCTURE.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+integer, parameter :: as = 3\n+structure /s8/\n+  character*20 c /\"HELLO\"/  ! ok\n+  integer*2 j /300_4/       ! ok, converted\n+  integer   k /65536_8/     ! ok, implicit\n+  integer*4 l /200000/      ! ok, types match\n+  integer   m(5) /5,4,3,2,1/! ok\n+  integer   n(5) /1,3*2,1/  ! ok, with repeat spec (/1,2,2,2,1/)\n+  integer   o(as) /as*9/    ! ok, parameter array spec\n+  integer   p(2,2) /1,2,3,4/! ok\n+  real      q(3) /1_2,3.5,2.4E-12_8/ ! ok, with some implicit conversions\n+  integer :: canary = z'3D3D3D3D'\n+end structure\n+\n+record /s8/ r8\n+\n+! Old-style (clist) initializers in structures\n+if ( r8.c /= \"HELLO\" ) call aborts (\"r8.c\")\n+if ( r8.j /= 300 ) call aborts (\"r8.j\")\n+if ( r8.k /= 65536 ) call aborts (\"r8.k\")\n+if ( r8.l /= 200000 ) call aborts (\"r8.l\")\n+if (     r8.m(1) /= 5 .or. r8.m(2) /= 4 .or. r8.m(3) /= 3 &\n+    .or. r8.m(4) /= 2 .or. r8.m(5) /= 1) &\n+  call aborts (\"r8.m\")\n+if (     r8.n(1) /= 1 .or. r8.n(2) /= 2 .or. r8.n(3) /= 2 .or. r8.n(4) /= 2 &\n+    .or. r8.n(5) /= 1) &\n+  call aborts (\"r8.n\")\n+if ( r8.o(1) /= 9 .or. r8.o(2) /= 9 .or. r8.o(3) /= 9 ) call aborts (\"r8.o\")\n+if (     r8.p(1,1) /= 1 .or. r8.p(2,1) /= 2 .or. r8.p(1,2) /= 3 &\n+    .or. r8.p(2,2) /= 4) &\n+  call aborts (\"r8.p\")\n+if ( r8.canary /= z'3D3D3D3D' ) call aborts (\"r8.canary\")\n+\n+end"}, {"sha": "baba1ef2b5f720e7cc96d06d24ec8e7ed668eeaa", "filename": "gcc/testsuite/gfortran.dg/dec_structure_7.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_7.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test passing STRUCTUREs through functions and subroutines.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+module dec_structure_7m\n+  structure /s1/\n+    integer i1\n+    logical l1\n+    real r1\n+    character c1\n+  end structure\n+\n+  structure /s2/\n+    integer i\n+    record /s1/ r1\n+  endstructure\n+\n+contains\n+  ! Pass structure through subroutine\n+  subroutine sub (rec1, i)\n+    implicit none\n+    integer, intent(in) :: i\n+    record /s1/ rec1\n+    rec1.i1 = i\n+  end subroutine\n+\n+  ! Pass structure through function\n+  function func (rec2, r)\n+    implicit none\n+    real, intent(in) :: r\n+    record /s2/ rec2\n+    real func\n+    rec2.r1.r1 = r\n+    func = rec2.r1.r1\n+    return\n+  end function\n+end module\n+\n+program dec_structure_7\n+  use dec_structure_7m\n+\n+  implicit none\n+  record /s1/ r1\n+  record /s2/ r2\n+  real junk\n+\n+  ! Passing through functions and subroutines\n+  r1.i1 = 0\n+  call sub (r1, 10)\n+\n+  r2.r1.r1 = 0.0\n+  junk = func (r2, -20.14)\n+\n+  if (r1.i1 .ne. 10) then\n+    call aborts(\"sub(r1, 10)\")\n+  endif\n+\n+  if (r2.r1.r1 .ne. -20.14) then\n+    call aborts(\"func(r2, -20.14)\")\n+  endif\n+\n+  if (junk .ne. -20.14) then\n+    print *, junk\n+    call aborts(\"junk = func()\")\n+  endif\n+\n+end program"}, {"sha": "160b92a8b96996984d446a2a83adf45ff62c7dfe", "filename": "gcc/testsuite/gfortran.dg/dec_structure_8.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_8.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do compile }\n+! { dg-options \"-fdec-structure -fmax-errors=0\" }\n+!\n+! Comprehensive compile tests for what structures CAN'T do.\n+!\n+\n+! Old-style (clist) initialization\n+integer,parameter :: as = 3\n+structure /t1/\n+  integer*1 a /300_2/       ! { dg-error \"Arithmetic overflow\" }\n+  integer   b //            ! { dg-error \"Empty old style initializer list\" }\n+  integer   c /2*3/         ! { dg-error \"Repeat spec invalid in scalar\" }\n+  integer   d /1,2,3/       ! { dg-error \"End of scalar initializer expected\" }\n+  integer   e /\"HI\"/        ! { dg-error \"Can't convert\" }\n+  integer   f(as) /4*9/     ! { dg-error \"Too many elements\" }\n+  integer   g(3) /1,3/      ! { dg-error \"Not enough elements\" }\n+  integer   h(3) /1,3,5,7/  ! { dg-error \"Too many elements\" }\n+  integer   i(3) /2*1/      ! { dg-error \"Not enough elements\" }\n+  integer   j(3) /10*1/     ! { dg-error \"Too many elements\" }\n+  integer   k(3) /2.5*3/    ! { dg-error \"Repeat spec must be an integer\" }\n+  integer   l(2) /2*/       ! { dg-error \"Expected data constant\" }\n+  integer   m(1) /          ! { dg-error \"Syntax error in old style\" }\n+  integer   n(2) /1         ! { dg-error \"Syntax error in old style\" }\n+  integer   o(2) /1,        ! { dg-error \"Syntax error in old style\" }\n+  integer   p(1) /x/        ! { dg-error \"must be a PARAMETER\" }\n+end structure\n+\n+structure              ! { dg-error \"Structure name expected\" }\n+structure /            ! { dg-error \"Structure name expected\" }\n+structure //           ! { dg-error \"Structure name expected\" }\n+structure /.or./       ! { dg-error \"Structure name expected\" }\n+structure /integer/    ! { dg-error \"Structure name.*cannot be the same\" }\n+structure /foo/ bar    ! { dg-error \"Junk after\" }\n+structure /t1/         ! { dg-error \"Type definition.*T1\" }\n+\n+record                 ! { dg-error \"Structure name expected\" }\n+record bar             ! { dg-error \"Structure name expected\" }\n+record / bar           ! { dg-error \"Structure name expected\" }\n+record // bar          ! { dg-error \"Structure name expected\" }\n+record foo/ bar        ! { dg-error \"Structure name expected\" }\n+record /foo bar        ! { dg-error \"Structure name expected\" }\n+record /foo/ bar       ! { dg-error \"used before it is defined\" }\n+record /t1/            ! { dg-error \"Invalid character in name\" }\n+\n+structure /t2/\n+  ENTRY here           ! { dg-error \"ENTRY statement.*cannot appear\" }\n+  integer a\n+  integer a            ! { dg-error \"Component.*already declared\" }\n+  structure $z         ! { dg-error \"Invalid character in name\" }\n+  structure //         ! { dg-error \"Invalid character in name\" }\n+  structure // x       ! { dg-error \"Invalid character in name\" }\n+  structure /t3/       ! { dg-error \"Invalid character in name\" }\n+  structure /t3/ x,$y  ! { dg-error \"Invalid character in name\" }\n+  structure /t4/ y\n+    integer i, j, k\n+  end structure\n+  structure /t4/ z     ! { dg-error \"Type definition.*T4\" }\n+end structure\n+\n+end"}, {"sha": "34c46c61c1c37a143fc0814b670fd909cec68dfb", "filename": "gcc/testsuite/gfortran.dg/dec_structure_9.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_structure_9.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Basic compile tests for what CAN be done with dot ('.') as a member accessor.\n+!\n+\n+logical :: l, l2 = .true., l3 = .false., and\n+integer i\n+character(5) s\n+real r\n+\n+structure /s1/\n+  integer i\n+  character(5) s\n+  real r\n+end structure\n+\n+record /s1/ r1\n+\n+! Basic \n+l = l .and. l2 .or. l3\n+l = and .and. and .and. and\n+l =  l2 .eqv. l3\n+l = (l2) .eqv. l3\n+\n+! Integers\n+l = .not. (i .eq. 0)\n+l = .not. (0 .eq. i)\n+l = .not. (r1.i .eq. 0)\n+l = .not. (0 .eq. r1.i)\n+! Characters\n+l = .not. (s .eq. \"hello\")\n+l = .not. (\"hello\" .eq. s)\n+l = .not. (r1.s .eq. \"hello\")\n+l = .not. (\"hello\" .eq. r1.s)\n+! Reals\n+l = .not. (r .eq. 3.14)\n+l = .not. (3.14 .eq. r)\n+l = .not. (r1.r .eq. 3.14)\n+l = .not. (3.14 .eq. r1.r)\n+\n+end"}, {"sha": "36af53adfe1eeb785aadc8cf589dcaa499ccff2b", "filename": "gcc/testsuite/gfortran.dg/dec_union_1.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_1.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test whether union backend declarations are corrently _not_ copied when they\n+! are not in fact equal. The structure defined in sub() is seen later, but\n+! where siz has a different value.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+subroutine sub ()\n+  integer, parameter :: siz = 1024\n+  structure /s6/\n+    union ! U0\n+      map ! M0\n+        integer ibuf(siz)\n+      end map\n+      map ! M1\n+        character(8) cbuf(siz)\n+      end map\n+      map ! M2\n+        real rbuf(siz)\n+      end map\n+    end union\n+  end structure\n+  record /s6/ r6\n+  r6.ibuf(1) = z'badbeef'\n+  r6.ibuf(2) = z'badbeef'\n+end subroutine\n+\n+! Repeat definition from subroutine sub with different size parameter.\n+! If the structure definition is copied here the stack may get messed up.\n+integer, parameter :: siz = 65536\n+structure /s6/\n+  union ! U12\n+    map\n+      integer ibuf(siz)\n+    end map\n+    map\n+      character(8) cbuf(siz)\n+    end map\n+    map\n+      real rbuf(siz)\n+    end map\n+  end union\n+end structure\n+\n+record /s6/ r6\n+integer :: r6_canary = 0\n+\n+! Copied type declaration - this should not cause problems\n+i = 1\n+do while (i < siz)\n+  r6.ibuf(i) = z'badbeef'\n+  i = i + 1\n+end do\n+\n+if ( r6_canary .ne. 0 ) then\n+  call aborts ('copied decls: overflow')\n+endif\n+\n+end"}, {"sha": "61e4fd8bd8069aafff05f681a867c25b9cab790d", "filename": "gcc/testsuite/gfortran.dg/dec_union_2.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_2.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test basic UNION implementation.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Empty union\n+structure /s0/\n+  union ! U0\n+    map ! M0\n+    end map\n+    map ! M1\n+    end map\n+  end union\n+end structure\n+\n+! Basic unions\n+structure /s1/\n+  union ! U1\n+    map ! M2\n+      integer(4) a\n+    end map\n+    map ! M3\n+      real(4) b\n+    end map\n+  end union\n+end structure\n+structure /s2/\n+  union ! U2\n+    map ! M4\n+      integer(2) w1, w2\n+    end map\n+    map ! M5\n+      integer(4) long\n+    end map\n+  end union\n+end structure\n+\n+record /s1/ r1\n+record /s2/ r2\n+\n+! Basic unions\n+r1.a = 0\n+r1.b = 1.33e7\n+if ( r1.a .eq. 0 ) call aborts (\"basic union 1\")\n+\n+! Endian-agnostic runtime check\n+r2.long = z'12345678'\n+if (.not. (     (r2.w1 .eq. z'1234' .and. r2.w2 .eq. z'5678') &\n+           .or. (r2.w1 .eq. z'5678' .and. r2.w2 .eq. z'1234')) ) then\n+    call aborts (\"basic union 2\")\n+endif\n+\n+end"}, {"sha": "ce5ae79785942fa1e949fca18471de91b377c0ca", "filename": "gcc/testsuite/gfortran.dg/dec_union_3.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_3.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test UNIONs with initializations.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Initialization expressions\n+structure /s3/\n+  integer(4) :: i = 8\n+  union ! U7\n+    map\n+      integer(4) :: x = 1600\n+      integer(4) :: y = 1800\n+    end map\n+    map\n+      integer(2) a, b, c\n+    end map\n+  end union\n+end structure\n+\n+record /s3/ r3\n+\n+! Initialized unions\n+if ( r3.x .ne. 1600 .or. r3.y .ne. 1800) then\n+  r3.x = r3.y ! If r3 isn't used the initializations are optimized out\n+  call aborts (\"union initialization\")\n+endif\n+\n+end"}, {"sha": "3bf6d618a8e05a9e229e80e5f146865c33437eff", "filename": "gcc/testsuite/gfortran.dg/dec_union_4.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_4.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test nested UNIONs.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Nested unions\n+structure /s4/\n+  union ! U0                ! rax\n+    map\n+      integer(8) rx\n+    end map\n+    map\n+      integer(4) rh         ! rah\n+      union ! U1\n+        map\n+          integer(4) rl     ! ral\n+        end map\n+        map\n+          integer(4) ex     ! eax\n+        end map\n+        map\n+          integer(2) eh     ! eah\n+          union ! U2\n+            map\n+              integer(2) el ! eal\n+            end map\n+            map\n+              integer(2) x  ! ax\n+            end map\n+            map\n+              integer(1) h  ! ah\n+              integer(1) l  ! al\n+            end map\n+          end union\n+        end map\n+      end union\n+    end map\n+  end union\n+end structure\n+record /s4/ r4\n+\n+\n+! Nested unions\n+r4.rx     =     z'7A7B7CCC7FFFFFFF'\n+if ( r4.rx .ne. z'7A7B7CCC7FFFFFFF' ) call aborts (\"rax\")\n+if ( r4.rh .ne.         z'7FFFFFFF' ) call aborts (\"rah\")\n+if ( r4.rl .ne. z'7A7B7CCC'         ) call aborts (\"ral\")\n+if ( r4.ex .ne. z'7A7B7CCC'         ) call aborts (\"eax\")\n+if ( r4.eh .ne.     z'7CCC'         ) call aborts (\"eah\")\n+if ( r4.el .ne. z'7A7B'             ) call aborts (\"eal\")\n+if ( r4.x  .ne. z'7A7B'             ) call aborts (\"ax\")\n+if ( r4.h  .ne.   z'7B'             ) call aborts (\"ah\")\n+if ( r4.l  .ne. z'7A'               ) call aborts (\"al\")\n+\n+end"}, {"sha": "bb1611a02890817df6fd9a8d42544787349d47a7", "filename": "gcc/testsuite/gfortran.dg/dec_union_5.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_5.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Test UNIONs with array components.\n+!\n+\n+subroutine aborts (s)\n+  character(*), intent(in) :: s\n+  print *, s\n+  call abort()\n+end subroutine\n+\n+! Unions with arrays\n+structure /s5/\n+  union\n+    map\n+      character :: s(5)\n+    end map\n+    map\n+      integer(1) :: a(5)\n+    end map\n+  end union\n+end structure\n+\n+record /s5/ r5\n+\n+! Unions with arrays\n+r5.a(1) = z'41'\n+r5.a(2) = z'42'\n+r5.a(3) = z'43'\n+r5.a(4) = z'44'\n+r5.a(5) = z'45'\n+if (     r5.s(1) .ne. 'A' &\n+    .or. r5.s(2) .ne. 'B' &\n+    .or. r5.s(3) .ne. 'C' &\n+    .or. r5.s(4) .ne. 'D' &\n+    .or. r5.s(5) .ne. 'E') then\n+  call aborts (\"arrays\")\n+endif\n+\n+end"}, {"sha": "31059c468802308da683864d44119b7ec6a6ee69", "filename": "gcc/testsuite/gfortran.dg/dec_union_6.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_6.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! sub0 and sub1 test a regression where calling gfc_use_derived from\n+! gfc_find_component on the structure type symbol being parsed caused the\n+! symbol to be freed and swapped for the previously seen type symbol, leaving\n+! dangling pointers and causing all sorts of mayhem.\n+!\n+\n+subroutine sub0 (u)\n+  structure /s/\n+    union ! U0\n+      map ! M0\n+        integer i\n+      end map\n+    end union\n+  end structure\n+  record /s/ u\n+  u.i = 0\n+end subroutine sub0\n+\n+subroutine sub1 ()\n+  structure /s/\n+    union ! U1\n+      map ! M1\n+        integer i\n+      end map\n+    end union\n+  end structure\n+  record /s/ u\n+  interface ! matches the declaration of sub0 above\n+    subroutine sub0 (u)\n+      structure /s/\n+        union ! U2\n+          map ! M2\n+            integer i ! gfc_find_component should not call gfc_use_derived\n+          end map     ! here, otherwise this structure's type symbol is freed\n+        end union     ! out from under it\n+      end structure\n+      record /s/ u\n+    end subroutine sub0\n+  end interface\n+  call sub0(u)\n+end subroutine\n+\n+! If sub0 and sub1 aren't used they may be omitted\n+structure /s/\n+  union ! U1\n+    map ! M3\n+      integer i\n+    end map\n+  end union\n+end structure\n+record /s/ u\n+\n+call sub0(u)\n+call sub1()\n+\n+end"}, {"sha": "270f0fbd415729aa45b0d489367a368353bce15a", "filename": "gcc/testsuite/gfortran.dg/dec_union_7.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6288c243153b97fb009a53a927c60dc30d4dd84/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_union_7.f90?ref=f6288c243153b97fb009a53a927c60dc30d4dd84", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! { dg-options \"-fdec-structure\" }\n+!\n+! Comprehensive compile tests for what unions CAN'T do.\n+!\n+\n+! Syntax errors\n+structure /s0/\n+  union a b c      ! { dg-error \"Junk after UNION\" }\n+  union\n+    map a b c      ! { dg-error \"Junk after MAP\" }\n+    integer x      ! { dg-error \"Unexpected\" }\n+    structure /s2/ ! { dg-error \"Unexpected\" }\n+    map\n+      map          ! { dg-error \"Unexpected\" }\n+    end map\n+  end union\n+end structure\n+\n+! Initialization expressions\n+structure /s1/\n+  union\n+    map\n+      integer(4) :: x = 1600 ! { dg-error \"Conflicting initializers\" }\n+      integer(4) :: y = 1800\n+    end map\n+    map\n+      integer(2) a, b, c, d\n+      integer :: e = 0 ! { dg-error \"Conflicting initializers\" }\n+    end map\n+    map\n+      real :: p = 1.3, q = 3.7 ! { dg-error \"Conflicting initializers\" }\n+    end map\n+  end union\n+end structure\n+record /s1/ r1\n+\n+end"}]}