{"sha": "b405b27425b6d7a8e20cdf17f79ead9445592e82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwNWIyNzQyNWI2ZDdhOGUyMGNkZjE3Zjc5ZWFkOTQ0NTU5MmU4Mg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-04-05T17:24:06Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-04-05T17:24:06Z"}, "message": "combine.c: Include obstack.h.\n\n\t* combine.c: Include obstack.h.\n\t(struct insn_link): Define.\n\t(uid_log_links): Adjust type.\n\t(FOR_EACH_LOG_LINK): New macro.\n\t(insn_link_obstack): Declare.\n\t(alloc_insn_link): Define.\n\t(create_log_links): Call it.  Use FOR_EACH_LOG_LINK and adjust\n\ttype of link variables.\n\t(find_single_use, insn_a_feeds_b, combine_instructions): Likewise.\n\t(try_combine, record_promoted_values, distribute_notes): Likewise.\n\t(distribute_links): Likewise.  Tweak prototype.\n\t(clear_log_links): Delete.\n\t(adjust_for_new_dest): Call alloc_insn_link.\n\t* Makefile.in (combine.o): Depend on $(OBSTACK_H).\n\nFrom-SVN: r171993", "tree": {"sha": "b32d362826a8a36a09cfbfc1c9b1ecdbfe868db1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b32d362826a8a36a09cfbfc1c9b1ecdbfe868db1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b405b27425b6d7a8e20cdf17f79ead9445592e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b405b27425b6d7a8e20cdf17f79ead9445592e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b405b27425b6d7a8e20cdf17f79ead9445592e82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b405b27425b6d7a8e20cdf17f79ead9445592e82/comments", "author": null, "committer": null, "parents": [{"sha": "6409abe3abd76eb49daa2aaa039eaca605c68779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6409abe3abd76eb49daa2aaa039eaca605c68779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6409abe3abd76eb49daa2aaa039eaca605c68779"}], "stats": {"total": 278, "additions": 152, "deletions": 126}, "files": [{"sha": "b2e4a86f3c2a5bdeac7b9be129a4ea35f2924856", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b405b27425b6d7a8e20cdf17f79ead9445592e82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b405b27425b6d7a8e20cdf17f79ead9445592e82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b405b27425b6d7a8e20cdf17f79ead9445592e82", "patch": "@@ -1,3 +1,20 @@\n+2011-04-05  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* combine.c: Include obstack.h.\n+\t(struct insn_link): Define.\n+\t(uid_log_links): Adjust type.\n+\t(FOR_EACH_LOG_LINK): New macro.\n+\t(insn_link_obstack): Declare.\n+\t(alloc_insn_link): Define.\n+\t(create_log_links): Call it.  Use FOR_EACH_LOG_LINK and adjust\n+\ttype of link variables.\n+\t(find_single_use, insn_a_feeds_b, combine_instructions): Likewise.\n+\t(try_combine, record_promoted_values, distribute_notes): Likewise.\n+\t(distribute_links): Likewise.  Tweak prototype.\n+\t(clear_log_links): Delete.\n+\t(adjust_for_new_dest): Call alloc_insn_link.\n+\t* Makefile.in (combine.o): Depend on $(OBSTACK_H).\n+\n 2011-04-05  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gcse.c (modify_mem_list): Convert to an array of VECs."}, {"sha": "d47a69ee1be492c2f7086cb3c6f0e4cc4e6778bf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b405b27425b6d7a8e20cdf17f79ead9445592e82/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b405b27425b6d7a8e20cdf17f79ead9445592e82/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b405b27425b6d7a8e20cdf17f79ead9445592e82", "patch": "@@ -3247,7 +3247,8 @@ combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(FUNCTION_H) insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) hard-reg-set.h \\\n    $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(TREE_H) $(TARGET_H) output.h $(PARAMS_H) $(OPTABS_H) \\\n-   insn-codes.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) vecprim.h $(CGRAPH_H)\n+   insn-codes.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) vecprim.h $(CGRAPH_H) \\\n+   $(OBSTACK_H)\n reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) addresses.h $(REGS_H) \\\n    insn-config.h $(RECOG_H) reload.h $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "30b7fdd041d926f0b567d62f59e16ff6bdc15e56", "filename": "gcc/combine.c", "status": "modified", "additions": 133, "deletions": 125, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b405b27425b6d7a8e20cdf17f79ead9445592e82/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b405b27425b6d7a8e20cdf17f79ead9445592e82/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b405b27425b6d7a8e20cdf17f79ead9445592e82", "patch": "@@ -104,6 +104,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"cgraph.h\"\n+#include \"obstack.h\"\n \n /* Number of attempts to combine instructions in this function.  */\n \n@@ -309,13 +310,38 @@ static int max_uid_known;\n static int *uid_insn_cost;\n \n /* The following array records the LOG_LINKS for every insn in the\n-   instruction stream as an INSN_LIST rtx.  */\n+   instruction stream as struct insn_link pointers.  */\n \n-static rtx *uid_log_links;\n+struct insn_link {\n+  rtx insn;\n+  struct insn_link *next;\n+};\n+\n+static struct insn_link **uid_log_links;\n \n #define INSN_COST(INSN)\t\t(uid_insn_cost[INSN_UID (INSN)])\n #define LOG_LINKS(INSN)\t\t(uid_log_links[INSN_UID (INSN)])\n \n+#define FOR_EACH_LOG_LINK(L, INSN)\t\t\t\t\\\n+  for ((L) = LOG_LINKS (INSN); (L); (L) = (L)->next)\n+\n+/* Links for LOG_LINKS are allocated from this obstack.  */\n+\n+static struct obstack insn_link_obstack;\n+\n+/* Allocate a link.  */\n+\n+static inline struct insn_link *\n+alloc_insn_link (rtx insn, struct insn_link *next)\n+{\n+  struct insn_link *l\n+    = (struct insn_link *) obstack_alloc (&insn_link_obstack,\n+\t\t\t\t\t  sizeof (struct insn_link));\n+  l->insn = insn;\n+  l->next = next;\n+  return l;\n+}\n+\n /* Incremented for each basic block.  */\n \n static int label_tick;\n@@ -438,7 +464,7 @@ static int reg_dead_at_p (rtx, rtx);\n static void move_deaths (rtx, rtx, int, rtx, rtx *);\n static int reg_bitfield_target_p (rtx, rtx);\n static void distribute_notes (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n-static void distribute_links (rtx);\n+static void distribute_links (struct insn_link *);\n static void mark_used_regs_combine (rtx);\n static void record_promoted_value (rtx, rtx);\n static int unmentioned_reg_p_1 (rtx *, void *);\n@@ -609,7 +635,7 @@ find_single_use (rtx dest, rtx insn, rtx *ploc)\n   basic_block bb;\n   rtx next;\n   rtx *result;\n-  rtx link;\n+  struct insn_link *link;\n \n #ifdef HAVE_cc0\n   if (dest == cc0_rtx)\n@@ -635,8 +661,8 @@ find_single_use (rtx dest, rtx insn, rtx *ploc)\n        next = NEXT_INSN (next))\n     if (INSN_P (next) && dead_or_set_p (next, dest))\n       {\n-\tfor (link = LOG_LINKS (next); link; link = XEXP (link, 1))\n-\t  if (XEXP (link, 0) == insn)\n+\tFOR_EACH_LOG_LINK (link, next)\n+\t  if (link->insn == insn)\n \t    break;\n \n \tif (link)\n@@ -985,15 +1011,14 @@ create_log_links (void)\n                       || asm_noperands (PATTERN (use_insn)) < 0)\n \t\t    {\n \t\t      /* Don't add duplicate links between instructions.  */\n-\t\t      rtx links;\n-\t\t      for (links = LOG_LINKS (use_insn); links;\n-\t\t\t   links = XEXP (links, 1))\n-\t\t        if (insn == XEXP (links, 0))\n+\t\t      struct insn_link *links;\n+\t\t      FOR_EACH_LOG_LINK (links, use_insn)\n+\t\t        if (insn == links->insn)\n \t\t\t  break;\n \n \t\t      if (!links)\n-\t\t\tLOG_LINKS (use_insn) =\n-\t\t\t  alloc_INSN_LIST (insn, LOG_LINKS (use_insn));\n+\t\t\tLOG_LINKS (use_insn)\n+\t\t\t  = alloc_insn_link (insn, LOG_LINKS (use_insn));\n \t\t    }\n                 }\n               next_use[regno] = NULL_RTX;\n@@ -1017,18 +1042,6 @@ create_log_links (void)\n   free (next_use);\n }\n \n-/* Clear LOG_LINKS fields of insns.  */\n-\n-static void\n-clear_log_links (void)\n-{\n-  rtx insn;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      free_INSN_LIST_list (&LOG_LINKS (insn));\n-}\n-\n /* Walk the LOG_LINKS of insn B to see if we find a reference to A.  Return\n    true if we found a LOG_LINK that proves that A feeds B.  This only works\n    if there are no instructions between A and B which could have a link\n@@ -1039,9 +1052,9 @@ clear_log_links (void)\n static bool\n insn_a_feeds_b (rtx a, rtx b)\n {\n-  rtx links;\n-  for (links = LOG_LINKS (b); links; links = XEXP (links, 1))\n-    if (XEXP (links, 0) == a)\n+  struct insn_link *links;\n+  FOR_EACH_LOG_LINK (links, b)\n+    if (links->insn == a)\n       return true;\n #ifdef HAVE_cc0\n   if (sets_cc0_p (a))\n@@ -1062,7 +1075,7 @@ combine_instructions (rtx f, unsigned int nregs)\n #ifdef HAVE_cc0\n   rtx prev;\n #endif\n-  rtx links, nextlinks;\n+  struct insn_link *links, *nextlinks;\n   rtx first;\n   basic_block last_bb;\n \n@@ -1086,8 +1099,9 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   /* Allocate array for insn info.  */\n   max_uid_known = get_max_uid ();\n-  uid_log_links = XCNEWVEC (rtx, max_uid_known + 1);\n+  uid_log_links = XCNEWVEC (struct insn_link *, max_uid_known + 1);\n   uid_insn_cost = XCNEWVEC (int, max_uid_known + 1);\n+  gcc_obstack_init (&insn_link_obstack);\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n@@ -1188,26 +1202,24 @@ combine_instructions (rtx f, unsigned int nregs)\n \n \t      /* Try this insn with each insn it links back to.  */\n \n-\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t\tif ((next = try_combine (insn, XEXP (links, 0), NULL_RTX,\n+\t      FOR_EACH_LOG_LINK (links, insn)\n+\t\tif ((next = try_combine (insn, links->insn, NULL_RTX,\n \t\t\t\t\t NULL_RTX, &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n \n \t      /* Try each sequence of three linked insns ending with this one.  */\n \n-\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t      FOR_EACH_LOG_LINK (links, insn)\n \t\t{\n-\t\t  rtx link = XEXP (links, 0);\n+\t\t  rtx link = links->insn;\n \n \t\t  /* If the linked insn has been replaced by a note, then there\n \t\t     is no point in pursuing this chain any further.  */\n \t\t  if (NOTE_P (link))\n \t\t    continue;\n \n-\t\t  for (nextlinks = LOG_LINKS (link);\n-\t\t       nextlinks;\n-\t\t       nextlinks = XEXP (nextlinks, 1))\n-\t\t    if ((next = try_combine (insn, link, XEXP (nextlinks, 0),\n+\t\t  FOR_EACH_LOG_LINK (nextlinks, link)\n+\t\t    if ((next = try_combine (insn, link, nextlinks->insn,\n \t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t     &new_direct_jump_p)) != 0)\n \t\t      goto retry;\n@@ -1230,9 +1242,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n-\t\t  for (nextlinks = LOG_LINKS (prev); nextlinks;\n-\t\t       nextlinks = XEXP (nextlinks, 1))\n-\t\t    if ((next = try_combine (insn, prev, XEXP (nextlinks, 0),\n+\t\t  FOR_EACH_LOG_LINK (nextlinks, prev)\n+\t\t    if ((next = try_combine (insn, prev, nextlinks->insn,\n \t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t     &new_direct_jump_p)) != 0)\n \t\t      goto retry;\n@@ -1250,9 +1261,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n-\t\t  for (nextlinks = LOG_LINKS (prev); nextlinks;\n-\t\t       nextlinks = XEXP (nextlinks, 1))\n-\t\t    if ((next = try_combine (insn, prev, XEXP (nextlinks, 0),\n+\t\t  FOR_EACH_LOG_LINK (nextlinks, prev)\n+\t\t    if ((next = try_combine (insn, prev, nextlinks->insn,\n \t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t     &new_direct_jump_p)) != 0)\n \t\t      goto retry;\n@@ -1261,88 +1271,85 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      /* Finally, see if any of the insns that this insn links to\n \t\t explicitly references CC0.  If so, try this insn, that insn,\n \t\t and its predecessor if it sets CC0.  */\n-\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t\tif (NONJUMP_INSN_P (XEXP (links, 0))\n-\t\t    && GET_CODE (PATTERN (XEXP (links, 0))) == SET\n-\t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (XEXP (links, 0))))\n-\t\t    && (prev = prev_nonnote_insn (XEXP (links, 0))) != 0\n+\t      FOR_EACH_LOG_LINK (links, insn)\n+\t\tif (NONJUMP_INSN_P (links->insn)\n+\t\t    && GET_CODE (PATTERN (links->insn)) == SET\n+\t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (links->insn)))\n+\t\t    && (prev = prev_nonnote_insn (links->insn)) != 0\n \t\t    && NONJUMP_INSN_P (prev)\n \t\t    && sets_cc0_p (PATTERN (prev))\n-\t\t    && (next = try_combine (insn, XEXP (links, 0),\n+\t\t    && (next = try_combine (insn, links->insn,\n \t\t\t\t\t    prev, NULL_RTX,\n \t\t\t\t\t    &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n #endif\n \n \t      /* Try combining an insn with two different insns whose results it\n \t\t uses.  */\n-\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t\tfor (nextlinks = XEXP (links, 1); nextlinks;\n-\t\t     nextlinks = XEXP (nextlinks, 1))\n-\t\t  if ((next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t\t   XEXP (nextlinks, 0), NULL_RTX,\n+\t      FOR_EACH_LOG_LINK (links, insn)\n+\t\tfor (nextlinks = links->next; nextlinks;\n+\t\t     nextlinks = nextlinks->next)\n+\t\t  if ((next = try_combine (insn, links->insn,\n+\t\t\t\t\t   nextlinks->insn, NULL_RTX,\n \t\t\t\t\t   &new_direct_jump_p)) != 0)\n \t\t    goto retry;\n \n \t      /* Try four-instruction combinations.  */\n-\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t      FOR_EACH_LOG_LINK (links, insn)\n \t\t{\n-\t\t  rtx next1;\n-\t\t  rtx link = XEXP (links, 0);\n+\t\t  struct insn_link *next1;\n+\t\t  rtx link = links->insn;\n \n \t\t  /* If the linked insn has been replaced by a note, then there\n \t\t     is no point in pursuing this chain any further.  */\n \t\t  if (NOTE_P (link))\n \t\t    continue;\n \n-\t\t  for (next1 = LOG_LINKS (link); next1; next1 = XEXP (next1, 1))\n+\t\t  FOR_EACH_LOG_LINK (next1, link)\n \t\t    {\n-\t\t      rtx link1 = XEXP (next1, 0);\n+\t\t      rtx link1 = next1->insn;\n \t\t      if (NOTE_P (link1))\n \t\t\tcontinue;\n \t\t      /* I0 -> I1 -> I2 -> I3.  */\n-\t\t      for (nextlinks = LOG_LINKS (link1); nextlinks;\n-\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t      FOR_EACH_LOG_LINK (nextlinks, link1)\n \t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t nextlinks->insn,\n \t\t\t\t\t\t &new_direct_jump_p)) != 0)\n \t\t\t  goto retry;\n \t\t      /* I0, I1 -> I2, I2 -> I3.  */\n-\t\t      for (nextlinks = XEXP (next1, 1); nextlinks;\n-\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t      for (nextlinks = next1->next; nextlinks;\n+\t\t\t   nextlinks = nextlinks->next)\n \t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t nextlinks->insn,\n \t\t\t\t\t\t &new_direct_jump_p)) != 0)\n \t\t\t  goto retry;\n \t\t    }\n \n-\t\t  for (next1 = XEXP (links, 1); next1; next1 = XEXP (next1, 1))\n+\t\t  for (next1 = links->next; next1; next1 = next1->next)\n \t\t    {\n-\t\t      rtx link1 = XEXP (next1, 0);\n+\t\t      rtx link1 = next1->insn;\n \t\t      if (NOTE_P (link1))\n \t\t\tcontinue;\n \t\t      /* I0 -> I2; I1, I2 -> I3.  */\n-\t\t      for (nextlinks = LOG_LINKS (link); nextlinks;\n-\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t      FOR_EACH_LOG_LINK (nextlinks, link)\n \t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t nextlinks->insn,\n \t\t\t\t\t\t &new_direct_jump_p)) != 0)\n \t\t\t  goto retry;\n \t\t      /* I0 -> I1; I1, I2 -> I3.  */\n-\t\t      for (nextlinks = LOG_LINKS (link1); nextlinks;\n-\t\t\t   nextlinks = XEXP (nextlinks, 1))\n+\t\t      FOR_EACH_LOG_LINK (nextlinks, link1)\n \t\t\tif ((next = try_combine (insn, link, link1,\n-\t\t\t\t\t\t XEXP (nextlinks, 0),\n+\t\t\t\t\t\t nextlinks->insn,\n \t\t\t\t\t\t &new_direct_jump_p)) != 0)\n \t\t\t  goto retry;\n \t\t    }\n \t\t}\n \n \t      /* Try this insn with each REG_EQUAL note it links back to.  */\n-\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t      FOR_EACH_LOG_LINK (links, insn)\n \t\t{\n \t\t  rtx set, note;\n-\t\t  rtx temp = XEXP (links, 0);\n+\t\t  rtx temp = links->insn;\n \t\t  if ((set = single_set (temp)) != 0\n \t\t      && (note = find_reg_equal_equiv_note (temp)) != 0\n \t\t      && (note = XEXP (note, 0), GET_CODE (note)) != EXPR_LIST\n@@ -1380,12 +1387,12 @@ combine_instructions (rtx f, unsigned int nregs)\n     }\n \n   default_rtl_profile ();\n-  clear_log_links ();\n   clear_bb_flags ();\n   new_direct_jump_p |= purge_all_dead_edges ();\n   delete_noop_moves ();\n \n   /* Clean up.  */\n+  obstack_free (&insn_link_obstack, NULL);\n   free (uid_log_links);\n   free (uid_insn_cost);\n   VEC_free (reg_stat_type, heap, reg_stat);\n@@ -1556,13 +1563,11 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t  && !REGNO_REG_SET_P (DF_LR_IN (BLOCK_FOR_INSN (insn)),\n \t\t\t       REGNO (x)))\n \t{\n-\t  rtx link;\n+\t  struct insn_link *link;\n \n-\t  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\t    {\n-\t      if (dead_or_set_p (XEXP (link, 0), x))\n-\t\tbreak;\n-\t    }\n+\t  FOR_EACH_LOG_LINK (link, insn)\n+\t    if (dead_or_set_p (link->insn, x))\n+\t      break;\n \t  if (!link)\n \t    {\n \t      rsp->nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n@@ -2248,7 +2253,7 @@ adjust_for_new_dest (rtx insn)\n   /* The new insn will have a destination that was previously the destination\n      of an insn just above it.  Call distribute_links to make a LOG_LINK from\n      the next use of that destination.  */\n-  distribute_links (gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX));\n+  distribute_links (alloc_insn_link (insn, NULL));\n \n   df_insn_rescan (insn);\n }\n@@ -2547,7 +2552,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n   int maxreg;\n   rtx temp;\n-  rtx link;\n+  struct insn_link *link;\n   rtx other_pat = 0;\n   rtx new_other_notes;\n   int i;\n@@ -3929,7 +3934,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n   if (swap_i2i3)\n     {\n       rtx insn;\n-      rtx link;\n+      struct insn_link *link;\n       rtx ni2dest;\n \n       /* I3 now uses what used to be its destination and which is now\n@@ -3959,10 +3964,9 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t{\n \t  if (INSN_P (insn) && reg_referenced_p (ni2dest, PATTERN (insn)))\n \t    {\n-\t      for (link = LOG_LINKS (insn); link;\n-\t\t   link = XEXP (link, 1))\n-\t\tif (XEXP (link, 0) == i3)\n-\t\t  XEXP (link, 0) = i1;\n+\t      FOR_EACH_LOG_LINK (link, insn)\n+\t\tif (link->insn == i3)\n+\t\t  link->insn = i1;\n \n \t      break;\n \t    }\n@@ -3971,7 +3975,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n   {\n     rtx i3notes, i2notes, i1notes = 0, i0notes = 0;\n-    rtx i3links, i2links, i1links = 0, i0links = 0;\n+    struct insn_link *i3links, *i2links, *i1links = 0, *i0links = 0;\n     rtx midnotes = 0;\n     int from_luid;\n     /* Compute which registers we expect to eliminate.  newi2pat may be setting\n@@ -4074,9 +4078,9 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t\t\t  || BB_HEAD (this_basic_block) != temp);\n \t\t temp = NEXT_INSN (temp))\n \t      if (temp != i3 && INSN_P (temp))\n-\t\tfor (link = LOG_LINKS (temp); link; link = XEXP (link, 1))\n-\t\t  if (XEXP (link, 0) == i2)\n-\t\t    XEXP (link, 0) = i3;\n+\t\tFOR_EACH_LOG_LINK (link, temp)\n+\t\t  if (link->insn == i2)\n+\t\t    link->insn = i3;\n \n \tif (i3notes)\n \t  {\n@@ -4090,9 +4094,9 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \ti2notes = 0;\n       }\n \n-    LOG_LINKS (i3) = 0;\n+    LOG_LINKS (i3) = NULL;\n     REG_NOTES (i3) = 0;\n-    LOG_LINKS (i2) = 0;\n+    LOG_LINKS (i2) = NULL;\n     REG_NOTES (i2) = 0;\n \n     if (newi2pat)\n@@ -4111,7 +4115,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n     if (i1)\n       {\n-\tLOG_LINKS (i1) = 0;\n+\tLOG_LINKS (i1) = NULL;\n \tREG_NOTES (i1) = 0;\n \tif (MAY_HAVE_DEBUG_INSNS)\n \t  propagate_for_debug (i1, i3, i1dest, i1src);\n@@ -4120,7 +4124,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n     if (i0)\n       {\n-\tLOG_LINKS (i0) = 0;\n+\tLOG_LINKS (i0) = NULL;\n \tREG_NOTES (i0) = 0;\n \tif (MAY_HAVE_DEBUG_INSNS)\n \t  propagate_for_debug (i0, i3, i0dest, i0src);\n@@ -4231,7 +4235,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n     if (REG_P (i2dest))\n       {\n-\trtx link, i2_insn = 0, i2_val = 0, set;\n+\tstruct insn_link *link;\n+\trtx i2_insn = 0, i2_val = 0, set;\n \n \t/* The insn that used to set this register doesn't exist, and\n \t   this life of the register may not exist either.  See if one of\n@@ -4240,10 +4245,10 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t   this and I2 set the register to a value that depended on its old\n \t   contents, we will get confused.  If this insn is used, thing\n \t   will be set correctly in combine_instructions.  */\n-\tfor (link = LOG_LINKS (i3); link; link = XEXP (link, 1))\n-\t  if ((set = single_set (XEXP (link, 0))) != 0\n+\tFOR_EACH_LOG_LINK (link, i3)\n+\t  if ((set = single_set (link->insn)) != 0\n \t      && rtx_equal_p (i2dest, SET_DEST (set)))\n-\t    i2_insn = XEXP (link, 0), i2_val = SET_SRC (set);\n+\t    i2_insn = link->insn, i2_val = SET_SRC (set);\n \n \trecord_value_for_reg (i2dest, i2_insn, i2_val);\n \n@@ -4257,12 +4262,13 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n     if (i1 && REG_P (i1dest))\n       {\n-\trtx link, i1_insn = 0, i1_val = 0, set;\n+\tstruct insn_link *link;\n+\trtx i1_insn = 0, i1_val = 0, set;\n \n-\tfor (link = LOG_LINKS (i3); link; link = XEXP (link, 1))\n-\t  if ((set = single_set (XEXP (link, 0))) != 0\n+\tFOR_EACH_LOG_LINK (link, i3)\n+\t  if ((set = single_set (link->insn)) != 0\n \t      && rtx_equal_p (i1dest, SET_DEST (set)))\n-\t    i1_insn = XEXP (link, 0), i1_val = SET_SRC (set);\n+\t    i1_insn = link->insn, i1_val = SET_SRC (set);\n \n \trecord_value_for_reg (i1dest, i1_insn, i1_val);\n \n@@ -4272,12 +4278,13 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n     if (i0 && REG_P (i0dest))\n       {\n-\trtx link, i0_insn = 0, i0_val = 0, set;\n+\tstruct insn_link *link;\n+\trtx i0_insn = 0, i0_val = 0, set;\n \n-\tfor (link = LOG_LINKS (i3); link; link = XEXP (link, 1))\n-\t  if ((set = single_set (XEXP (link, 0))) != 0\n+\tFOR_EACH_LOG_LINK (link, i3)\n+\t  if ((set = single_set (link->insn)) != 0\n \t      && rtx_equal_p (i0dest, SET_DEST (set)))\n-\t    i0_insn = XEXP (link, 0), i0_val = SET_SRC (set);\n+\t    i0_insn = link->insn, i0_val = SET_SRC (set);\n \n \trecord_value_for_reg (i0dest, i0_insn, i0_val);\n \n@@ -12349,7 +12356,8 @@ record_dead_and_set_regs (rtx insn)\n static void\n record_promoted_value (rtx insn, rtx subreg)\n {\n-  rtx links, set;\n+  struct insn_link *links;\n+  rtx set;\n   unsigned int regno = REGNO (SUBREG_REG (subreg));\n   enum machine_mode mode = GET_MODE (subreg);\n \n@@ -12360,14 +12368,14 @@ record_promoted_value (rtx insn, rtx subreg)\n     {\n       reg_stat_type *rsp;\n \n-      insn = XEXP (links, 0);\n+      insn = links->insn;\n       set = single_set (insn);\n \n       if (! set || !REG_P (SET_DEST (set))\n \t  || REGNO (SET_DEST (set)) != regno\n \t  || GET_MODE (SET_DEST (set)) != GET_MODE (SUBREG_REG (subreg)))\n \t{\n-\t  links = XEXP (links, 1);\n+\t  links = links->next;\n \t  continue;\n \t}\n \n@@ -13500,8 +13508,8 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t  && DF_INSN_LUID (from_insn) > DF_INSN_LUID (i2)\n \t\t\t  && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n \t\t\t{\n-\t\t\t  rtx links = LOG_LINKS (place);\n-\t\t\t  LOG_LINKS (place) = 0;\n+\t\t\t  struct insn_link *links = LOG_LINKS (place);\n+\t\t\t  LOG_LINKS (place) = NULL;\n \t\t\t  distribute_links (links);\n \t\t\t}\n \t\t      break;\n@@ -13632,17 +13640,17 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n    pointing at I3 when I3's destination is changed.  */\n \n static void\n-distribute_links (rtx links)\n+distribute_links (struct insn_link *links)\n {\n-  rtx link, next_link;\n+  struct insn_link *link, *next_link;\n \n   for (link = links; link; link = next_link)\n     {\n       rtx place = 0;\n       rtx insn;\n       rtx set, reg;\n \n-      next_link = XEXP (link, 1);\n+      next_link = link->next;\n \n       /* If the insn that this link points to is a NOTE or isn't a single\n \t set, ignore it.  In the latter case, it isn't clear what we\n@@ -13655,8 +13663,8 @@ distribute_links (rtx links)\n \t replace I3, I2, and I1 by I3 and I2.  But in that case the\n \t destination of I2 also remains unchanged.  */\n \n-      if (NOTE_P (XEXP (link, 0))\n-\t  || (set = single_set (XEXP (link, 0))) == 0)\n+      if (NOTE_P (link->insn)\n+\t  || (set = single_set (link->insn)) == 0)\n \tcontinue;\n \n       reg = SET_DEST (set);\n@@ -13673,7 +13681,7 @@ distribute_links (rtx links)\n \t I3 to I2.  Also note that not much searching is typically done here\n \t since most links don't point very far away.  */\n \n-      for (insn = NEXT_INSN (XEXP (link, 0));\n+      for (insn = NEXT_INSN (link->insn);\n \t   (insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n \t\t     || BB_HEAD (this_basic_block->next_bb) != insn));\n \t   insn = NEXT_INSN (insn))\n@@ -13699,15 +13707,15 @@ distribute_links (rtx links)\n \n       if (place)\n \t{\n-\t  rtx link2;\n+\t  struct insn_link *link2;\n \n-\t  for (link2 = LOG_LINKS (place); link2; link2 = XEXP (link2, 1))\n-\t    if (XEXP (link2, 0) == XEXP (link, 0))\n+\t  FOR_EACH_LOG_LINK (link2, place)\n+\t    if (link2->insn == link->insn)\n \t      break;\n \n-\t  if (link2 == 0)\n+\t  if (link2 == NULL)\n \t    {\n-\t      XEXP (link, 1) = LOG_LINKS (place);\n+\t      link->next = LOG_LINKS (place);\n \t      LOG_LINKS (place) = link;\n \n \t      /* Set added_links_insn to the earliest insn we added a"}]}