{"sha": "76a696635de4e697b0c69393d78b71d0aba8d0c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZhNjk2NjM1ZGU0ZTY5N2IwYzY5MzkzZDc4YjcxZDBhYmE4ZDBjMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2008-03-26T07:42:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:42:14Z"}, "message": "sem_ch6.adb (Analyze_Subprogram_Body): Remove spurious check on operations that have an interface parameter.\n\n2008-03-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body): Remove spurious check on\n\toperations that have an interface parameter.\n\t(Analyze_Subprogram_Body): Set Is_Trivial_Subprogram flag\n\tDon't treat No_Return call as raise.\n\n\t* sem_disp.adb (Check_Dispatching_Operations): apply check for\n\tnon-primitive interface primitives to access parameters, not to all\n\tparameters of an access type.\n\nFrom-SVN: r133577", "tree": {"sha": "de0b45c6dbff9307a0ee153681df071f529aff2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de0b45c6dbff9307a0ee153681df071f529aff2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76a696635de4e697b0c69393d78b71d0aba8d0c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a696635de4e697b0c69393d78b71d0aba8d0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a696635de4e697b0c69393d78b71d0aba8d0c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a696635de4e697b0c69393d78b71d0aba8d0c2/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9f86c0c6cab087228394773d7b528c63e0a9969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f86c0c6cab087228394773d7b528c63e0a9969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9f86c0c6cab087228394773d7b528c63e0a9969"}], "stats": {"total": 167, "additions": 88, "deletions": 79}, "files": [{"sha": "8c038658c5408d6fece33b2fb1bdea17d16c4013", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 83, "deletions": 77, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a696635de4e697b0c69393d78b71d0aba8d0c2/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a696635de4e697b0c69393d78b71d0aba8d0c2/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=76a696635de4e697b0c69393d78b71d0aba8d0c2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1260,6 +1260,13 @@ package body Sem_Ch6 is\n       --  when the subprogram has a body that acts as spec. This is done for\n       --  some cases of inlining, and for private protected ops.\n \n+      procedure Set_Trivial_Subprogram (N : Node_Id);\n+      --  Sets the Is_Trivial_Subprogram flag in both spec and body of the\n+      --  subprogram whose body is being analyzed. N is the statement node\n+      --  causing the flag to be set, if the following statement is a return\n+      --  of an entity, we mark the entity as set in source to suppress any\n+      --  warning on the stylized use of function stubs with a dummy return.\n+\n       procedure Verify_Overriding_Indicator;\n       --  If there was a previous spec, the entity has been entered in the\n       --  current scope previously. If the body itself carries an overriding\n@@ -1329,10 +1336,10 @@ package body Sem_Ch6 is\n \n             if Nkind (Prag) = N_Pragma\n               and then\n-                 (Get_Pragma_Id (Chars (Prag)) = Pragma_Inline_Always\n-                  or else\n+                 (Pragma_Name (Prag) = Name_Inline_Always\n+                   or else\n                     (Front_End_Inlining\n-                     and then Get_Pragma_Id (Chars (Prag)) = Pragma_Inline))\n+                      and then Pragma_Name (Prag) = Name_Inline))\n               and then\n                  Chars\n                    (Expression (First (Pragma_Argument_Associations (Prag))))\n@@ -1378,7 +1385,7 @@ package body Sem_Ch6 is\n                   Analyze (Prag);\n                   Set_Has_Pragma_Inline (Subp);\n \n-                  if Get_Pragma_Id (Chars (Prag)) = Pragma_Inline_Always then\n+                  if Pragma_Name (Prag) = Name_Inline_Always then\n                      Set_Is_Inlined (Subp);\n                      Set_Next_Rep_Item (Prag, First_Rep_Item (Subp));\n                      Set_First_Rep_Item (Subp, Prag);\n@@ -1418,6 +1425,30 @@ package body Sem_Ch6 is\n          end loop;\n       end Copy_Parameter_List;\n \n+      ----------------------------\n+      -- Set_Trivial_Subprogram --\n+      ----------------------------\n+\n+      procedure Set_Trivial_Subprogram (N : Node_Id) is\n+         Nxt : constant Node_Id := Next (N);\n+\n+      begin\n+         Set_Is_Trivial_Subprogram (Body_Id);\n+\n+         if Present (Spec_Id) then\n+            Set_Is_Trivial_Subprogram (Spec_Id);\n+         end if;\n+\n+         if Present (Nxt)\n+           and then Nkind (Nxt) = N_Simple_Return_Statement\n+           and then No (Next (Nxt))\n+           and then Present (Expression (Nxt))\n+           and then Is_Entity_Name (Expression (Nxt))\n+         then\n+            Set_Never_Set_In_Source (Entity (Expression (Nxt)), False);\n+         end if;\n+      end Set_Trivial_Subprogram;\n+\n       ---------------------------------\n       -- Verify_Overriding_Indicator --\n       ---------------------------------\n@@ -1434,7 +1465,7 @@ package body Sem_Ch6 is\n             if Is_Overriding_Operation (Spec_Id) then\n                Error_Msg_NE\n                  (\"subprogram& overrides inherited operation\",\n-                    Body_Spec, Spec_Id);\n+                  Body_Spec, Spec_Id);\n \n             --  If this is not a primitive operation the overriding indicator\n             --  is altogether illegal.\n@@ -1519,8 +1550,7 @@ package body Sem_Ch6 is\n             --  subprogram will get frozen too late (there may be code within\n             --  the body that depends on the subprogram having been frozen,\n             --  such as uses of extra formals), so we force it to be frozen\n-            --  here. Same holds if the body and the spec are compilation\n-            --  units.\n+            --  here. Same holds if the body and spec are compilation units.\n \n             if No (Spec_Id) then\n                Freeze_Before (N, Body_Id);\n@@ -1710,10 +1740,11 @@ package body Sem_Ch6 is\n                                            N_Subprogram_Renaming_Declaration))\n             then\n                Conformant := True;\n+\n             else\n                Check_Conformance\n                  (Body_Id, Spec_Id,\n-                   Fully_Conformant, True, Conformant, Body_Id);\n+                  Fully_Conformant, True, Conformant, Body_Id);\n             end if;\n \n             --  If the body is not fully conformant, we have to decide if we\n@@ -1777,8 +1808,7 @@ package body Sem_Ch6 is\n                end;\n             end if;\n \n-            --  Now make the formals visible, and place subprogram\n-            --  on scope stack.\n+            --  Make the formals visible, and place subprogram on scope stack\n \n             Install_Formals (Spec_Id);\n             Last_Formal := Last_Entity (Spec_Id);\n@@ -1820,65 +1850,18 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  Ada 2005 (AI-251): Check wrong placement of abstract interface\n-      --  primitives, and update anonymous access returns with limited views.\n+      --  If the return type is an anonymous access type whose designated type\n+      --  is the limited view of a class-wide type and the non-limited view is\n+      --  available, update the return type accordingly.\n \n       if Ada_Version >= Ada_05\n         and then Comes_From_Source (N)\n       then\n          declare\n-            E    : Entity_Id;\n             Etyp : Entity_Id;\n             Rtyp : Entity_Id;\n \n          begin\n-            --  Check the type of the formals\n-\n-            E := First_Entity (Body_Id);\n-            while Present (E) loop\n-               Etyp := Etype (E);\n-\n-               if Is_Access_Type (Etyp) then\n-                  Etyp := Directly_Designated_Type (Etyp);\n-               end if;\n-\n-               if not Is_Class_Wide_Type (Etyp)\n-                 and then Is_Interface (Etyp)\n-               then\n-                  Error_Msg_Name_1 := Chars (Defining_Entity (N));\n-                  Error_Msg_N\n-                    (\"(Ada 2005) abstract interface primitives must be\" &\n-                     \" defined in package specs\", N);\n-                  exit;\n-               end if;\n-\n-               Next_Entity (E);\n-            end loop;\n-\n-            --  In case of functions, check the type of the result\n-\n-            if Ekind (Body_Id) = E_Function then\n-               Etyp := Etype (Body_Id);\n-\n-               if Is_Access_Type (Etyp) then\n-                  Etyp := Directly_Designated_Type (Etyp);\n-               end if;\n-\n-               if not Is_Class_Wide_Type (Etyp)\n-                 and then Is_Interface (Etyp)\n-               then\n-                  Error_Msg_Name_1 := Chars (Defining_Entity (N));\n-                  Error_Msg_N\n-                    (\"(Ada 2005) abstract interface primitives must be\" &\n-                     \" defined in package specs\", N);\n-               end if;\n-            end if;\n-\n-            --  If the return type is an anonymous access type whose\n-            --  designated type is the limited view of a class-wide type\n-            --  and the non-limited view is available. update the return\n-            --  type accordingly.\n-\n             Rtyp := Etype (Current_Scope);\n \n             if Ekind (Rtyp) = E_Anonymous_Access_Type then\n@@ -2069,7 +2052,12 @@ package body Sem_Ch6 is\n       end if;\n \n       --  Now we are going to check for variables that are never modified in\n-      --  the body of the procedure. We omit these checks if the first\n+      --  the body of the procedure. But first we deal with a special case\n+      --  where we want to modify this check. If the body of the subprogram\n+      --  starts with a raise statement or its equivalent, or if the body\n+      --  consists entirely of a null statement, then it is pretty obvious\n+      --  that it is OK to not reference the parameters. For example, this\n+      --  might be the following common idiom for a stubbed function:\n       --  statement of the procedure raises an exception. In particular this\n       --  deals with the common idiom of a stubbed function, which might\n       --  appear as something like\n@@ -2081,10 +2069,17 @@ package body Sem_Ch6 is\n       --        return X;\n       --     end F;\n \n-      --  Here the purpose of X is simply to satisfy the (annoying)\n-      --  requirement in Ada that there be at least one return, and we\n-      --  certainly do not want to go posting warnings on X that it is not\n-      --  initialized!\n+      --  Here the purpose of X is simply to satisfy the annoying requirement\n+      --  in Ada that there be at least one return, and we certainly do not\n+      --  want to go posting warnings on X that it is not initialized! On\n+      --  the other hand, if X is entirely unreferenced that should still\n+      --  get a warning.\n+\n+      --  What we do is to detect these cases, and if we find them, flag the\n+      --  subprogram as being Is_Trivial_Subprogram and then use that flag to\n+      --  suppress unwanted warnings. For the case of the function stub above\n+      --  we have a special test to set X as apparently assigned to suppress\n+      --  the warning.\n \n       declare\n          Stm : Node_Id;\n@@ -2107,10 +2102,18 @@ package body Sem_Ch6 is\n             Ostm : constant Node_Id := Original_Node (Stm);\n \n          begin\n-            --  If explicit raise statement, return with no checks\n+            --  If explicit raise statement, turn on flag\n \n             if Nkind (Ostm) = N_Raise_Statement then\n-               return;\n+               Set_Trivial_Subprogram (Stm);\n+\n+            --  If null statement, and no following statemennts, turn on flag\n+\n+            elsif Nkind (Stm) = N_Null_Statement\n+              and then Comes_From_Source (Stm)\n+              and then No (Next (Stm))\n+            then\n+               Set_Trivial_Subprogram (Stm);\n \n             --  Check for explicit call cases which likely raise an exception\n \n@@ -2122,22 +2125,23 @@ package body Sem_Ch6 is\n                   begin\n                      --  If the procedure is marked No_Return, then likely it\n                      --  raises an exception, but in any case it is not coming\n-                     --  back here, so no need to check beyond the call.\n+                     --  back here, so turn on the flag.\n \n                      if Ekind (Ent) = E_Procedure\n                        and then No_Return (Ent)\n                      then\n-                        return;\n+                        Set_Trivial_Subprogram (Stm);\n \n                      --  If the procedure name is Raise_Exception, then also\n                      --  assume that it raises an exception. The main target\n                      --  here is Ada.Exceptions.Raise_Exception, but this name\n                      --  is pretty evocative in any context! Note that the\n                      --  procedure in Ada.Exceptions is not marked No_Return\n-                     --  because of the annoying case of the null exception Id.\n+                     --  because of the annoying case of the null exception Id\n+                     --  when operating in Ada 95 mode.\n \n                      elsif Chars (Ent) = Name_Raise_Exception then\n-                        return;\n+                        Set_Trivial_Subprogram (Stm);\n                      end if;\n                   end;\n                end if;\n@@ -2453,10 +2457,10 @@ package body Sem_Ch6 is\n       --  variable as is done for other inlined calls.\n \n       procedure Remove_Pragmas;\n-      --  A pragma Unreferenced that mentions a formal parameter has no meaning\n-      --  when the body is inlined and the formals are rewritten. Remove it\n-      --  from body to inline. The analysis of the non-inlined body will handle\n-      --  the pragma properly.\n+      --  A pragma Unreferenced or pragma Unmodified that mentions a formal\n+      --  parameter has no meaning when the body is inlined and the formals\n+      --  are rewritten. Remove it from body to inline. The analysis of the\n+      --  non-inlined body will handle the pragma properly.\n \n       function Uses_Secondary_Stack (Bod : Node_Id) return Boolean;\n       --  If the body of the subprogram includes a call that returns an\n@@ -2709,7 +2713,9 @@ package body Sem_Ch6 is\n             Nxt := Next (Decl);\n \n             if Nkind (Decl) = N_Pragma\n-              and then Chars (Decl) = Name_Unreferenced\n+              and then (Pragma_Name (Decl) = Name_Unreferenced\n+                          or else\n+                        Pragma_Name (Decl) = Name_Unmodified)\n             then\n                Remove (Decl);\n             end if;"}, {"sha": "1652a82fc67f83ab71a057a6069bcb40639196a7", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76a696635de4e697b0c69393d78b71d0aba8d0c2/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76a696635de4e697b0c69393d78b71d0aba8d0c2/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=76a696635de4e697b0c69393d78b71d0aba8d0c2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -641,7 +641,10 @@ package body Sem_Disp is\n          begin\n             E := First_Entity (Subp);\n             while Present (E) loop\n-               if Is_Access_Type (Etype (E)) then\n+\n+               --  For an access parameter, check designated type.\n+\n+               if Ekind (Etype (E)) = E_Anonymous_Access_Type then\n                   Typ := Designated_Type (Etype (E));\n                else\n                   Typ := Etype (E);"}]}