{"sha": "63610db99bd3c25bc90e04e7f9faa7ef91db19c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2MTBkYjk5YmQzYzI1YmM5MGUwNGU3ZjlmYWE3ZWY5MWRiMTljMQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-06-05T09:52:14Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-06-05T09:52:14Z"}, "message": "(synth_mult): Move code to add or subtract at leftmost 1-bit to before...\n\n(synth_mult): Move code to add or subtract at\nleftmost 1-bit to before factoring code to decrease the allowed cost\nquickly.  Restrict it to handle only odd numbers.\n(init_expmed): Limit mult_cost to make synth_mult run faster.\n\nFrom-SVN: r4636", "tree": {"sha": "4ed6beb92cfd0bea04577df35af9dfbb0291be56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ed6beb92cfd0bea04577df35af9dfbb0291be56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63610db99bd3c25bc90e04e7f9faa7ef91db19c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63610db99bd3c25bc90e04e7f9faa7ef91db19c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63610db99bd3c25bc90e04e7f9faa7ef91db19c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63610db99bd3c25bc90e04e7f9faa7ef91db19c1/comments", "author": null, "committer": null, "parents": [{"sha": "f1b985b7e2807820ae8d7d1e710c84c76aca6594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b985b7e2807820ae8d7d1e710c84c76aca6594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b985b7e2807820ae8d7d1e710c84c76aca6594"}], "stats": {"total": 101, "additions": 49, "deletions": 52}, "files": [{"sha": "0e38db2666f325ab0ba0ce354f917a0ce8151292", "filename": "gcc/expmed.c", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63610db99bd3c25bc90e04e7f9faa7ef91db19c1/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63610db99bd3c25bc90e04e7f9faa7ef91db19c1/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=63610db99bd3c25bc90e04e7f9faa7ef91db19c1", "patch": "@@ -118,6 +118,9 @@ init_expmed ()\n     }\n \n   mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg), SET);\n+  /* For gcc 2.4 keep MULT_COST small to avoid really slow searches\n+     in synth_mult.  */\n+  mult_cost = MIN (12 * add_cost, mult_cost);\n   negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg), SET);\n \n   /* 999999 is chosen to avoid any plausible faster special case.  */\n@@ -1879,6 +1882,52 @@ synth_mult (t, cost_limit)\n \t}\n     }\n \n+  /* If we have an odd number, add or subtract one.  */\n+  if ((t & 1) != 0)\n+  {\n+    unsigned HOST_WIDE_INT w;\n+\n+    for (w = 1; (w & t) != 0; w <<= 1)\n+      ;\n+    if (w > 2\n+\t/* Reject the case where t is 3.\n+\t   Thus we prefer addition in that case.  */\n+\t&& t != 3)\n+      {\n+\t/* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n+\n+\tcost = add_cost;\n+\t*alg_in = synth_mult (t + 1, cost_limit - cost);\n+\n+\tcost += alg_in->cost;\n+\tif (cost < best_alg->cost)\n+\t  {\n+\t    struct algorithm *x;\n+\t    x = alg_in, alg_in = best_alg, best_alg = x;\n+\t    best_alg->log[best_alg->ops] = 0;\n+\t    best_alg->op[best_alg->ops++] = alg_sub_t_m2;\n+\t    best_alg->cost = cost_limit = cost;\n+\t  }\n+      }\n+    else\n+      {\n+\t/* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n+\n+\tcost = add_cost;\n+\t*alg_in = synth_mult (t - 1, cost_limit - cost);\n+\n+\tcost += alg_in->cost;\n+\tif (cost < best_alg->cost)\n+\t  {\n+\t    struct algorithm *x;\n+\t    x = alg_in, alg_in = best_alg, best_alg = x;\n+\t    best_alg->log[best_alg->ops] = 0;\n+\t    best_alg->op[best_alg->ops++] = alg_add_t_m2;\n+\t    best_alg->cost = cost_limit = cost;\n+\t  }\n+      }\n+  }\n+\n   /* Look for factors of t of the form\n      t = q(2**m +- 1), 2 <= m <= floor(log2(t - 1)).\n      If we find such a factor, we can multiply by t using an algorithm that\n@@ -1971,58 +2020,6 @@ synth_mult (t, cost_limit)\n \t}\n     }\n \n-  /* Now, use the simple method of adding or subtracting at the leftmost\n-     1-bit.  */\n-  {\n-    unsigned HOST_WIDE_INT w;\n-\n-    q = t & -t;\t\t\t/* get out lsb */\n-    for (w = q; (w & t) != 0; w <<= 1)\n-      ;\n-    if ((w > q << 1)\n-\t/* Reject the case where t has only two bits.\n-\t   Thus we prefer addition in that case.  */\n-\t&& !(t < w && w == q << 2))\n-      {\n-\t/* There are many bits in a row.  Make 'em by subtraction.  */\n-\n-\tm = exact_log2 (q);\n-\n-\t/* Don't use shiftsub_cost here, this operation\n-\t   scales wrong operand.  */\n-\tcost = add_cost + shift_cost[m];\n-\t*alg_in = synth_mult (t + q, cost_limit - cost);\n-\n-\tcost += alg_in->cost;\n-\tif (cost < best_alg->cost)\n-\t  {\n-\t    struct algorithm *x;\n-\t    x = alg_in, alg_in = best_alg, best_alg = x;\n-\t    best_alg->log[best_alg->ops] = m;\n-\t    best_alg->op[best_alg->ops++] = alg_sub_t_m2;\n-\t    best_alg->cost = cost_limit = cost;\n-\t  }\n-      }\n-    else\n-      {\n-\t/* There's only one or two bit at the left.  Make it by addition.  */\n-\n-\tm = exact_log2 (q);\n-\tcost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);\n-\t*alg_in = synth_mult (t - q, cost_limit - cost);\n-\n-\tcost += alg_in->cost;\n-\tif (cost < best_alg->cost)\n-\t  {\n-\t    struct algorithm *x;\n-\t    x = alg_in, alg_in = best_alg, best_alg = x;\n-\t    best_alg->log[best_alg->ops] = m;\n-\t    best_alg->op[best_alg->ops++] = alg_add_t_m2;\n-\t    best_alg->cost = cost_limit = cost;\n-\t  }\n-      }\n-  }\n-\n   /* If we are getting a too long sequence for `struct algorithm'\n      to record, store a fake cost to make this search fail.  */\n   if (best_alg->ops == MAX_BITS_PER_WORD)"}]}