{"sha": "0898049ad9bf6c46e510b18aaafca4946802749f", "node_id": "C_kwDOANBUbNoAKDA4OTgwNDlhZDliZjZjNDZlNTEwYjE4YWFhZmNhNDk0NjgwMjc0OWY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-01-26T08:35:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-02-04T13:38:47Z"}, "message": "tree-optimization/100499 - niter analysis and multiple_of_p\n\nniter analysis uses multiple_of_p which currently assumes\noperations like MULT_EXPR do not wrap.  We've got to rely on this\nfor optimizing size expressions like those in DECL_SIZE and those\ngenerally use unsigned arithmetic with no indication that they\nare not expected to wrap.  To preserve that the following adds\na parameter to multiple_of_p, defaulted to true, indicating that\nthe TOP expression is not expected to wrap for outer computations\nin TYPE.  This mostly follows a patch proposed by Bin last year\nwith the conversion behavior added.\n\nApplying to all users the new effect is that upon type conversions\nin the TOP expression the behavior will switch to honor\nTYPE_OVERFLOW_UNDEFINED for the converted sub-expressions.\n\nThe patch also changes the occurance in niter analysis that we\nknow is problematic and we have testcases for to pass false\nto multiple_of_p.  The patch also contains a change to the\nPR72817 fix from Bin to avoid regressing gcc.dg/tree-ssa/loop-42.c.\n\nThe intent for stage1 is to introduce a size_multiple_of_p and\ninternalize the added parameter so all multiple_of_p users will\nhonor TYPE_OVERFLOW_UNDEFINED and users dealing with size expressions\nneed to be switched to size_multiple_of_p.\n\n2022-01-26  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/100499\n\t* fold-const.h (multiple_of_p): Add nowrap parameter, defaulted\n\tto true.\n\t* fold-const.cc (multiple_of_p): Likewise.  Honor it for\n\tMULT_EXPR, PLUS_EXPR and MINUS_EXPR and pass it along,\n\tswitching to false for conversions.\n\t* tree-ssa-loop-niter.cc (number_of_iterations_ne): Do not\n\tclaim the outermost expression does not wrap when calling\n\tmultiple_of_p.  Refactor the check done to check the\n\toriginal IV, avoiding a bias that might wrap.\n\n\t* gcc.dg/torture/pr100499-1.c: New testcase.\n\t* gcc.dg/torture/pr100499-2.c: Likewise.\n\t* gcc.dg/torture/pr100499-3.c: Likewise.\n\nCo-authored-by: Bin Cheng  <bin.cheng@linux.alibaba.com>", "tree": {"sha": "14ebaafca33c719cbde7610151467bfac7e7f6ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14ebaafca33c719cbde7610151467bfac7e7f6ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0898049ad9bf6c46e510b18aaafca4946802749f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0898049ad9bf6c46e510b18aaafca4946802749f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0898049ad9bf6c46e510b18aaafca4946802749f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0898049ad9bf6c46e510b18aaafca4946802749f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d3236ff3791ea74e1bc1c293d82fee11b1a5e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d3236ff3791ea74e1bc1c293d82fee11b1a5e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d3236ff3791ea74e1bc1c293d82fee11b1a5e24"}], "stats": {"total": 191, "additions": 130, "deletions": 61}, "files": [{"sha": "2578a86ca1aa20f017f082a0a94d242bed26ee87", "filename": "gcc/fold-const.cc", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ffold-const.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ffold-const.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.cc?ref=0898049ad9bf6c46e510b18aaafca4946802749f", "patch": "@@ -14073,10 +14073,16 @@ fold_binary_initializer_loc (location_t loc, tree_code code, tree type,\n      SAVE_EXPR (I) * SAVE_EXPR (J)\n \n    (where the same SAVE_EXPR (J) is used in the original and the\n-   transformed version).  */\n+   transformed version).\n+\n+   NOWRAP specifies whether all outer operations in TYPE should\n+   be considered not wrapping.  Any type conversion within TOP acts\n+   as a barrier and we will fall back to NOWRAP being false.\n+   NOWRAP is mostly used to treat expressions in TYPE_SIZE and friends\n+   as not wrapping even though they are generally using unsigned arithmetic.  */\n \n int\n-multiple_of_p (tree type, const_tree top, const_tree bottom)\n+multiple_of_p (tree type, const_tree top, const_tree bottom, bool nowrap)\n {\n   gimple *stmt;\n   tree op1, op2;\n@@ -14094,10 +14100,17 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n \t a multiple of BOTTOM then TOP is a multiple of BOTTOM.  */\n       if (!integer_pow2p (bottom))\n \treturn 0;\n-      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom)\n-\t      || multiple_of_p (type, TREE_OPERAND (top, 0), bottom));\n+      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom, nowrap)\n+\t      || multiple_of_p (type, TREE_OPERAND (top, 0), bottom, nowrap));\n \n     case MULT_EXPR:\n+      /* If the multiplication can wrap we cannot recurse further unless\n+\t the bottom is a power of two which is where wrapping does not\n+\t matter.  */\n+      if (!nowrap\n+\t  && !TYPE_OVERFLOW_UNDEFINED (type)\n+\t  && !integer_pow2p (bottom))\n+\treturn 0;\n       if (TREE_CODE (bottom) == INTEGER_CST)\n \t{\n \t  op1 = TREE_OPERAND (top, 0);\n@@ -14106,24 +14119,24 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n \t    std::swap (op1, op2);\n \t  if (TREE_CODE (op2) == INTEGER_CST)\n \t    {\n-\t      if (multiple_of_p (type, op2, bottom))\n+\t      if (multiple_of_p (type, op2, bottom, nowrap))\n \t\treturn 1;\n \t      /* Handle multiple_of_p ((x * 2 + 2) * 4, 8).  */\n-\t      if (multiple_of_p (type, bottom, op2))\n+\t      if (multiple_of_p (type, bottom, op2, nowrap))\n \t\t{\n \t\t  widest_int w = wi::sdiv_trunc (wi::to_widest (bottom),\n \t\t\t\t\t\t wi::to_widest (op2));\n \t\t  if (wi::fits_to_tree_p (w, TREE_TYPE (bottom)))\n \t\t    {\n \t\t      op2 = wide_int_to_tree (TREE_TYPE (bottom), w);\n-\t\t      return multiple_of_p (type, op1, op2);\n+\t\t      return multiple_of_p (type, op1, op2, nowrap);\n \t\t    }\n \t\t}\n-\t      return multiple_of_p (type, op1, bottom);\n+\t      return multiple_of_p (type, op1, bottom, nowrap);\n \t    }\n \t}\n-      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom)\n-\t      || multiple_of_p (type, TREE_OPERAND (top, 0), bottom));\n+      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom, nowrap)\n+\t      || multiple_of_p (type, TREE_OPERAND (top, 0), bottom, nowrap));\n \n     case LSHIFT_EXPR:\n       /* Handle X << CST as X * (1 << CST) and only process the constant.  */\n@@ -14135,45 +14148,56 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n \t      wide_int mul_op\n \t\t= wi::one (TYPE_PRECISION (type)) << wi::to_wide (op1);\n \t      return multiple_of_p (type,\n-\t\t\t\t    wide_int_to_tree (type, mul_op), bottom);\n+\t\t\t\t    wide_int_to_tree (type, mul_op), bottom,\n+\t\t\t\t    nowrap);\n \t    }\n \t}\n       return 0;\n \n     case MINUS_EXPR:\n-      /* It is impossible to prove if op0 - op1 is multiple of bottom\n-\t precisely, so be conservative here checking if both op0 and op1\n-\t are multiple of bottom.  Note we check the second operand first\n-\t since it's usually simpler.  */\n-      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom)\n-\t      && multiple_of_p (type, TREE_OPERAND (top, 0), bottom));\n-\n     case PLUS_EXPR:\n-      /* The same as MINUS_EXPR, but handle cases like op0 + 0xfffffffd\n-\t as op0 - 3 if the expression has unsigned type.  For example,\n-\t (X / 3) + 0xfffffffd is multiple of 3, but 0xfffffffd is not.  */\n+      /* If the addition or subtraction can wrap we cannot recurse further\n+\t unless bottom is a power of two which is where wrapping does not\n+\t matter.  */\n+      if (!nowrap\n+\t  && !TYPE_OVERFLOW_UNDEFINED (type)\n+\t  && !integer_pow2p (bottom))\n+\treturn 0;\n+\n+      /* Handle cases like op0 + 0xfffffffd as op0 - 3 if the expression has\n+\t unsigned type.  For example, (X / 3) + 0xfffffffd is multiple of 3,\n+\t but 0xfffffffd is not.  */\n       op1 = TREE_OPERAND (top, 1);\n-      if (TYPE_UNSIGNED (type)\n+      if (TREE_CODE (top) == PLUS_EXPR\n+\t  && nowrap\n+\t  && TYPE_UNSIGNED (type)\n \t  && TREE_CODE (op1) == INTEGER_CST && tree_int_cst_sign_bit (op1))\n \top1 = fold_build1 (NEGATE_EXPR, type, op1);\n-      return (multiple_of_p (type, op1, bottom)\n-\t      && multiple_of_p (type, TREE_OPERAND (top, 0), bottom));\n+\n+      /* It is impossible to prove if op0 +- op1 is multiple of bottom\n+\t precisely, so be conservative here checking if both op0 and op1\n+\t are multiple of bottom.  Note we check the second operand first\n+\t since it's usually simpler.  */\n+      return (multiple_of_p (type, op1, bottom, nowrap)\n+\t      && multiple_of_p (type, TREE_OPERAND (top, 0), bottom, nowrap));\n \n     CASE_CONVERT:\n       /* Can't handle conversions from non-integral or wider integral type.  */\n       if ((TREE_CODE (TREE_TYPE (TREE_OPERAND (top, 0))) != INTEGER_TYPE)\n \t  || (TYPE_PRECISION (type)\n \t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (top, 0)))))\n \treturn 0;\n+      /* NOWRAP only extends to operations in the outermost type so\n+\t make sure to strip it off here.  */\n       return multiple_of_p (TREE_TYPE (TREE_OPERAND (top, 0)),\n-\t\t\t    TREE_OPERAND (top, 0), bottom);\n+\t\t\t    TREE_OPERAND (top, 0), bottom, false);\n \n     case SAVE_EXPR:\n-      return multiple_of_p (type, TREE_OPERAND (top, 0), bottom);\n+      return multiple_of_p (type, TREE_OPERAND (top, 0), bottom, nowrap);\n \n     case COND_EXPR:\n-      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom)\n-\t      && multiple_of_p (type, TREE_OPERAND (top, 2), bottom));\n+      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom, nowrap)\n+\t      && multiple_of_p (type, TREE_OPERAND (top, 2), bottom, nowrap));\n \n     case INTEGER_CST:\n       if (TREE_CODE (bottom) != INTEGER_CST"}, {"sha": "d36bfc813cf4f3a6cc7a7dbf4dfbd9e1cbdc6d80", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=0898049ad9bf6c46e510b18aaafca4946802749f", "patch": "@@ -96,7 +96,7 @@ extern void fold_overflow_warning (const char*, enum warn_strict_overflow_code);\n extern enum tree_code fold_div_compare (enum tree_code, tree, tree,\n \t\t\t\t\ttree *, tree *, bool *);\n extern bool operand_equal_p (const_tree, const_tree, unsigned int flags = 0);\n-extern int multiple_of_p (tree, const_tree, const_tree);\n+extern int multiple_of_p (tree, const_tree, const_tree, bool = true);\n #define omit_one_operand(T1,T2,T3)\\\n    omit_one_operand_loc (UNKNOWN_LOCATION, T1, T2, T3)\n extern tree omit_one_operand_loc (location_t, tree, tree, tree);"}, {"sha": "9511c323505aa9bd0a0e55b2ef63f873a48590a7", "filename": "gcc/testsuite/gcc.dg/torture/pr100499-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-1.c?ref=0898049ad9bf6c46e510b18aaafca4946802749f", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+\n+typedef __UINT16_TYPE__ uint16_t;\n+typedef __INT32_TYPE__ int32_t;\n+static uint16_t g_2823 = 0xEC75L;\n+static uint16_t g_116 = 0xBC07L;\n+\n+static uint16_t\n+safe_mul_func_uint16_t_u_u(uint16_t ui1, uint16_t ui2)\n+{\n+  return ((unsigned int)ui1) * ((unsigned int)ui2);\n+}\n+\n+int main ()\n+{\n+  uint16_t l_2815 = 0xffff;\n+  uint16_t *l_2821 = &g_116;\n+  uint16_t *l_2822 = &g_2823;\n+\n+lbl_2826:\n+  l_2815 &= 0x1eae;\n+  if (safe_mul_func_uint16_t_u_u(((*l_2821) = l_2815), (--(*l_2822))))\n+    goto lbl_2826;\n+  if (g_2823 != 32768)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "999f931806a000be1bf1c6d624e6c74796ca57fc", "filename": "gcc/testsuite/gcc.dg/torture/pr100499-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-2.c?ref=0898049ad9bf6c46e510b18aaafca4946802749f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+\n+unsigned char ag = 55;\n+unsigned i;\n+int main()\n+{\n+  unsigned char c;\n+  unsigned char a = ag;\n+d:\n+  c = a-- * 52;\n+  if (c)\n+    goto d;\n+  if (a != 255)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "01be1e5069090b3ba480edaa075a2b315fc7ebad", "filename": "gcc/testsuite/gcc.dg/torture/pr100499-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr100499-3.c?ref=0898049ad9bf6c46e510b18aaafca4946802749f", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run } */\n+\n+int a = 0;\n+unsigned char b = 0;\n+\n+int main() {\n+  a - 6;\n+  for (; a >= -13; a = a - 8)\n+    while((unsigned char)(b-- * 6))\n+      ;\n+  if (b != 127)\n+    __builtin_abort();\n+  return 0;\n+}"}, {"sha": "318d10c8fac921b1648090288c4e6a1e03b95e39", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0898049ad9bf6c46e510b18aaafca4946802749f/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=0898049ad9bf6c46e510b18aaafca4946802749f", "patch": "@@ -1042,17 +1042,21 @@ number_of_iterations_ne (class loop *loop, tree type, affine_iv *iv,\n \t    new_base = base - step > FINAL ; step < 0\n \t\t\t\t\t     && base - step doesn't overflow\n \n-       2') |FINAL - new_base| is an exact multiple of step.\n-\n-     Please refer to PR34114 as an example of loop-ch's impact, also refer\n-     to PR72817 as an example why condition 2') is necessary.\n+     Please refer to PR34114 as an example of loop-ch's impact.\n \n      Note, for NE_EXPR, base equals to FINAL is a special case, in\n-     which the loop exits immediately, and the iv does not overflow.  */\n+     which the loop exits immediately, and the iv does not overflow.\n+\n+     Also note, we prove condition 2) by checking base and final seperately\n+     along with condition 1) or 1').  */\n   if (!niter->control.no_overflow\n-      && (integer_onep (s) || multiple_of_p (type, c, s)))\n+      && (integer_onep (s)\n+\t  || (multiple_of_p (type, fold_convert (niter_type, iv->base), s,\n+\t\t\t     false)\n+\t      && multiple_of_p (type, fold_convert (niter_type, final), s,\n+\t\t\t\tfalse))))\n     {\n-      tree t, cond, new_c, relaxed_cond = boolean_false_node;\n+      tree t, cond, relaxed_cond = boolean_false_node;\n \n       if (tree_int_cst_sign_bit (iv->step))\n \t{\n@@ -1066,12 +1070,8 @@ number_of_iterations_ne (class loop *loop, tree type, affine_iv *iv,\n \t      if (integer_nonzerop (t))\n \t\t{\n \t\t  t = fold_build2 (MINUS_EXPR, type, iv->base, iv->step);\n-\t\t  new_c = fold_build2 (MINUS_EXPR, niter_type,\n-\t\t\t\t       fold_convert (niter_type, t),\n-\t\t\t\t       fold_convert (niter_type, final));\n-\t\t  if (multiple_of_p (type, new_c, s))\n-\t\t    relaxed_cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\t\tt, final);\n+\t\t  relaxed_cond = fold_build2 (GT_EXPR, boolean_type_node, t,\n+\t\t\t\t\t      final);\n \t\t}\n \t    }\n \t}\n@@ -1087,12 +1087,8 @@ number_of_iterations_ne (class loop *loop, tree type, affine_iv *iv,\n \t      if (integer_nonzerop (t))\n \t\t{\n \t\t  t = fold_build2 (MINUS_EXPR, type, iv->base, iv->step);\n-\t\t  new_c = fold_build2 (MINUS_EXPR, niter_type,\n-\t\t\t\t       fold_convert (niter_type, final),\n-\t\t\t\t       fold_convert (niter_type, t));\n-\t\t  if (multiple_of_p (type, new_c, s))\n-\t\t    relaxed_cond = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t\tt, final);\n+\t\t  relaxed_cond = fold_build2 (LT_EXPR, boolean_type_node, t,\n+\t\t\t\t\t      final);\n \t\t}\n \t    }\n \t}\n@@ -1102,19 +1098,11 @@ number_of_iterations_ne (class loop *loop, tree type, affine_iv *iv,\n \tt = simplify_using_initial_conditions (loop, relaxed_cond);\n \n       if (t && integer_onep (t))\n-\tniter->control.no_overflow = true;\n-    }\n-\n-  /* First the trivial cases -- when the step is 1.  */\n-  if (integer_onep (s))\n-    {\n-      niter->niter = c;\n-      return true;\n-    }\n-  if (niter->control.no_overflow && multiple_of_p (type, c, s))\n-    {\n-      niter->niter = fold_build2 (FLOOR_DIV_EXPR, niter_type, c, s);\n-      return true;\n+\t{\n+\t  niter->control.no_overflow = true;\n+\t  niter->niter = fold_build2 (EXACT_DIV_EXPR, niter_type, c, s);\n+\t  return true;\n+\t}\n     }\n \n   /* Let nsd (step, size of mode) = d.  If d does not divide c, the loop"}]}