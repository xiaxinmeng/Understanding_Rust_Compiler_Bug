{"sha": "03310c37cc1c1de0ee78a1518bd564b366a3328f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMzMTBjMzdjYzFjMWRlMGVlNzhhMTUxOGJkNTY0YjM2NmEzMzI4Zg==", "commit": {"author": {"name": "Cesar Philippidis", "email": "cesar@codesourcery.com", "date": "2015-11-10T05:23:04Z"}, "committer": {"name": "Cesar Philippidis", "email": "cesar@gcc.gnu.org", "date": "2015-11-10T05:23:04Z"}, "message": "parser.c (cp_finalize_oacc_routine): New boolean first argument.\n\n\tgcc/cp/\n\t* parser.c (cp_finalize_oacc_routine): New boolean first argument.\n\t(cp_ensure_no_oacc_routine): Update call to cp_finalize_oacc_routine.\n\t(cp_parser_simple_declaration): Maintain a boolean first to keep track\n\tof each new declarator.  Propagate it to cp_parser_init_declarator.\n\t(cp_parser_init_declarator): New boolean first argument.  Propagate it\n\tto cp_parser_save_member_function_body and cp_finalize_oacc_routine.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_single_declaration): Update call to\n\tcp_parser_init_declarator.\n\t(cp_parser_save_member_function_body): New boolean first_decl argument.\n\tPropagate it to cp_finalize_oacc_routine.\n\t(cp_parser_finish_oacc_routine): New boolean first argument.  Use it to\n\tdetermine if multiple declarators follow a routine construct.\n\t(cp_parser_oacc_routine): Update call to cp_parser_finish_oacc_routine.\n\n\tgcc/testsuite/\n\t* c-c++-common/goacc/routine-5.c: Enable c++ tests.\n\nFrom-SVN: r230082", "tree": {"sha": "0e436cca19dc5803f14d090dab354db4e74c4915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e436cca19dc5803f14d090dab354db4e74c4915"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03310c37cc1c1de0ee78a1518bd564b366a3328f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03310c37cc1c1de0ee78a1518bd564b366a3328f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03310c37cc1c1de0ee78a1518bd564b366a3328f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03310c37cc1c1de0ee78a1518bd564b366a3328f/comments", "author": {"login": "cesarjp", "id": 4576177, "node_id": "MDQ6VXNlcjQ1NzYxNzc=", "avatar_url": "https://avatars.githubusercontent.com/u/4576177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cesarjp", "html_url": "https://github.com/cesarjp", "followers_url": "https://api.github.com/users/cesarjp/followers", "following_url": "https://api.github.com/users/cesarjp/following{/other_user}", "gists_url": "https://api.github.com/users/cesarjp/gists{/gist_id}", "starred_url": "https://api.github.com/users/cesarjp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cesarjp/subscriptions", "organizations_url": "https://api.github.com/users/cesarjp/orgs", "repos_url": "https://api.github.com/users/cesarjp/repos", "events_url": "https://api.github.com/users/cesarjp/events{/privacy}", "received_events_url": "https://api.github.com/users/cesarjp/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685c8340ff7b5cfef7bf41c3b5e0d79ad7f7a37b"}], "stats": {"total": 98, "additions": 68, "deletions": 30}, "files": [{"sha": "859f3783e4ff8cda4d8c8b81eed2a0d12d2390e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03310c37cc1c1de0ee78a1518bd564b366a3328f", "patch": "@@ -1,3 +1,20 @@\n+2015-11-09  Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* parser.c (cp_finalize_oacc_routine): New boolean first argument.\n+\t(cp_ensure_no_oacc_routine): Update call to cp_finalize_oacc_routine.\n+\t(cp_parser_simple_declaration): Maintain a boolean first to keep track\n+\tof each new declarator.  Propagate it to cp_parser_init_declarator.\n+\t(cp_parser_init_declarator): New boolean first argument.  Propagate it\n+\tto cp_parser_save_member_function_body and cp_finalize_oacc_routine.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_single_declaration): Update call to\n+\tcp_parser_init_declarator.\n+\t(cp_parser_save_member_function_body): New boolean first_decl argument.\n+\tPropagate it to cp_finalize_oacc_routine.\n+\t(cp_parser_finish_oacc_routine): New boolean first argument.  Use it to\n+\tdetermine if multiple declarators follow a routine construct.\n+\t(cp_parser_oacc_routine): Update call to cp_parser_finish_oacc_routine.\n+\n 2015-10-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/67913"}, {"sha": "f3b4b467b583d20b3bf7e31355f0935c778b4dce", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=03310c37cc1c1de0ee78a1518bd564b366a3328f", "patch": "@@ -246,7 +246,7 @@ static bool cp_parser_omp_declare_reduction_exprs\n static tree cp_parser_cilk_simd_vectorlength \n   (cp_parser *, tree, bool);\n static void cp_finalize_oacc_routine\n-  (cp_parser *, tree, bool);\n+  (cp_parser *, tree, bool, bool);\n \n /* Manifest constants.  */\n #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))\n@@ -1329,7 +1329,7 @@ cp_finalize_omp_declare_simd (cp_parser *parser, tree fndecl)\n static inline void\n cp_ensure_no_oacc_routine (cp_parser *parser)\n {\n-  cp_finalize_oacc_routine (parser, NULL_TREE, false);\n+  cp_finalize_oacc_routine (parser, NULL_TREE, false, true);\n }\n \f\n /* Decl-specifiers.  */\n@@ -2135,7 +2135,7 @@ static tree cp_parser_decltype\n \n static tree cp_parser_init_declarator\n   (cp_parser *, cp_decl_specifier_seq *, vec<deferred_access_check, va_gc> *,\n-   bool, bool, int, bool *, tree *, location_t *);\n+   bool, bool, int, bool *, tree *, bool, location_t *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *, bool, bool);\n static cp_declarator *cp_parser_direct_declarator\n@@ -2445,7 +2445,7 @@ static tree cp_parser_single_declaration\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n-  (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree);\n+  (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree, bool);\n static tree cp_parser_save_nsdmi\n   (cp_parser *);\n static tree cp_parser_enclosed_template_argument_list\n@@ -11909,6 +11909,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n   bool saw_declarator;\n   location_t comma_loc = UNKNOWN_LOCATION;\n   location_t init_loc = UNKNOWN_LOCATION;\n+  bool first = true;\n \n   if (maybe_range_for_decl)\n     *maybe_range_for_decl = NULL_TREE;\n@@ -12005,7 +12006,10 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t\t\t\t\tdeclares_class_or_enum,\n \t\t\t\t\t&function_definition_p,\n \t\t\t\t\tmaybe_range_for_decl,\n+\t\t\t\t\tfirst,\n \t\t\t\t\t&init_loc);\n+      first = false;\n+\n       /* If an error occurred while parsing tentatively, exit quickly.\n \t (That usually happens when in the body of a function; each\n \t statement is treated as a declaration-statement until proven\n@@ -12104,6 +12108,9 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n  done:\n   pop_deferring_access_checks ();\n+\n+  /* Reset any acc routine clauses.  */\n+  parser->oacc_routine = NULL;\n }\n \n /* Parse a decl-specifier-seq.\n@@ -17843,6 +17850,8 @@ cp_parser_asm_definition (cp_parser* parser)\n    if present, will not be consumed.  If returned, this declarator will be\n    created with SD_INITIALIZED but will not call cp_finish_decl.\n \n+   FIRST indicates if this is the first declarator in a declaration sequence.\n+\n    If INIT_LOC is not NULL, and *INIT_LOC is equal to UNKNOWN_LOCATION,\n    and there is an initializer, the pointed location_t is set to the\n    location of the '=' or `(', or '{' in C++11 token introducing the\n@@ -17857,6 +17866,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   int declares_class_or_enum,\n \t\t\t   bool* function_definition_p,\n \t\t\t   tree* maybe_range_for_decl,\n+\t\t\t   bool first,\n \t\t\t   location_t* init_loc)\n {\n   cp_token *token = NULL, *asm_spec_start_token = NULL,\n@@ -17993,7 +18003,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \t    decl = cp_parser_save_member_function_body (parser,\n \t\t\t\t\t\t\tdecl_specifiers,\n \t\t\t\t\t\t\tdeclarator,\n-\t\t\t\t\t\t\tprefix_attributes);\n+\t\t\t\t\t\t\tprefix_attributes,\n+\t\t\t\t\t\t\ttrue);\n \t  else\n \t    decl =\n \t      (cp_parser_function_definition_from_specifiers_and_declarator\n@@ -18097,7 +18108,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t range_for_decl_p? SD_INITIALIZED : is_initialized,\n \t\t\t attributes, prefix_attributes, &pushed_scope);\n       cp_finalize_omp_declare_simd (parser, decl);\n-      cp_finalize_oacc_routine (parser, decl, false);\n+      cp_finalize_oacc_routine (parser, decl, false, first);\n       /* Adjust location of decl if declarator->id_loc is more appropriate:\n \t set, and decl wasn't merged with another decl, in which case its\n \t location would be different from input_location, and more accurate.  */\n@@ -18211,7 +18222,7 @@ cp_parser_init_declarator (cp_parser* parser,\n       if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \tcp_parser_save_default_args (parser, decl);\n       cp_finalize_omp_declare_simd (parser, decl);\n-      cp_finalize_oacc_routine (parser, decl, false);\n+      cp_finalize_oacc_routine (parser, decl, false, first);\n     }\n \n   /* Finish processing the declaration.  But, skip member\n@@ -21915,6 +21926,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   else\n     {\n       bool assume_semicolon = false;\n+      bool first = true;\n \n       /* Clear attributes from the decl_specifiers but keep them\n \t around as prefix attributes that apply them to the entity\n@@ -22102,7 +22114,10 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  decl = cp_parser_save_member_function_body (parser,\n \t\t\t\t\t\t\t      &decl_specifiers,\n \t\t\t\t\t\t\t      declarator,\n-\t\t\t\t\t\t\t      attributes);\n+\t\t\t\t\t\t\t      attributes,\n+\t\t\t\t\t\t\t      first);\n+\t\t  first = false;\n+\n \t\t  if (parser->fully_implicit_function_template_p)\n \t\t    decl = finish_fully_implicit_template (parser, decl);\n \t\t  /* If the member was not a friend, declare it here.  */\n@@ -22132,7 +22147,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t    }\n \n \t  cp_finalize_omp_declare_simd (parser, decl);\n-\t  cp_finalize_oacc_routine (parser, decl, false);\n+\t  cp_finalize_oacc_routine (parser, decl, false, first);\n+\t  first = false;\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n \t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n@@ -22195,6 +22211,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  if (assume_semicolon)\n \t    goto out;\n \t}\n+\n+      /* Reset any OpenACC routine clauses.  */\n+      parser->oacc_routine = NULL;\n     }\n \n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n@@ -24736,7 +24755,8 @@ cp_parser_function_definition_from_specifiers_and_declarator\n     {\n       cp_finalize_omp_declare_simd (parser, current_function_decl);\n       parser->omp_declare_simd = NULL;\n-      cp_finalize_oacc_routine (parser, current_function_decl, true);\n+      cp_finalize_oacc_routine (parser, current_function_decl, true, true);\n+      parser->oacc_routine = NULL;\n     }\n \n   if (!success_p)\n@@ -25301,7 +25321,7 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t\t        member_p,\n \t\t\t\t        declares_class_or_enum,\n \t\t\t\t        &function_definition_p,\n-\t\t\t\t\tNULL, NULL);\n+\t\t\t\t\tNULL, true, NULL);\n \n     /* 7.1.1-1 [dcl.stc]\n \n@@ -25403,14 +25423,15 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n /* Save the tokens that make up the body of a member function defined\n    in a class-specifier.  The DECL_SPECIFIERS and DECLARATOR have\n    already been parsed.  The ATTRIBUTES are any GNU \"__attribute__\"\n-   specifiers applied to the declaration.  Returns the FUNCTION_DECL\n-   for the member function.  */\n+   specifiers applied to the declaration. FIRST_DECL indicates if\n+   DECLARATOR is the first declarator in a declaration sequence.  Returns\n+   the FUNCTION_DECL for the member function.  */\n \n static tree\n cp_parser_save_member_function_body (cp_parser* parser,\n \t\t\t\t     cp_decl_specifier_seq *decl_specifiers,\n \t\t\t\t     cp_declarator *declarator,\n-\t\t\t\t     tree attributes)\n+\t\t\t\t     tree attributes, bool first_decl)\n {\n   cp_token *first;\n   cp_token *last;\n@@ -25419,7 +25440,7 @@ cp_parser_save_member_function_body (cp_parser* parser,\n   /* Create the FUNCTION_DECL.  */\n   fn = grokmethod (decl_specifiers, declarator, attributes);\n   cp_finalize_omp_declare_simd (parser, fn);\n-  cp_finalize_oacc_routine (parser, fn, true);\n+  cp_finalize_oacc_routine (parser, fn, true, first_decl);\n   /* If something went badly wrong, bail out now.  */\n   if (fn == error_mark_node)\n     {\n@@ -35625,7 +35646,8 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n \n static void\n cp_parser_finish_oacc_routine (cp_parser *ARG_UNUSED (parser), tree fndecl,\n-\t\t\t       tree clauses, bool named, bool is_defn)\n+\t\t\t       tree clauses, bool named, bool is_defn,\n+\t\t\t       bool first)\n {\n   location_t loc  = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n \n@@ -35637,7 +35659,8 @@ cp_parser_finish_oacc_routine (cp_parser *ARG_UNUSED (parser), tree fndecl,\n       return;\n     }\n \n-  if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL)\n+  if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL\n+      || (!named && !first))\n     {\n       error_at (loc, \"%<#pragma acc routine%> %s\",\n \t\tnamed ? \"does not refer to a function\"\n@@ -35728,7 +35751,7 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n   clauses = tree_cons (c_head, clauses, NULL_TREE);\n \n   if (decl)\n-    cp_parser_finish_oacc_routine (parser, decl, clauses, true, false);\n+    cp_parser_finish_oacc_routine (parser, decl, clauses, true, false, 0);\n   else\n     parser->oacc_routine = clauses;\n }\n@@ -35737,14 +35760,12 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n    declaration.  */\n \n static void\n-cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n+cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn,\n+\t\t\t  bool first)\n {\n   if (parser->oacc_routine)\n-    {\n-      cp_parser_finish_oacc_routine (parser, fndecl, parser->oacc_routine,\n-\t\t\t\t     false, is_defn);\n-      parser->oacc_routine = NULL_TREE;\n-    }\n+    cp_parser_finish_oacc_routine (parser, fndecl, parser->oacc_routine,\n+\t\t\t\t   false, is_defn, first);\n }\n \n /* Main entry point to OpenMP statement pragmas.  */"}, {"sha": "e9ddd72e3b96633d4727113b61cd491d470bf854", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03310c37cc1c1de0ee78a1518bd564b366a3328f", "patch": "@@ -1,3 +1,7 @@\n+2015-11-09  Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* c-c++-common/goacc/routine-5.c: Enable c++ tests.\n+\n 2015-10-19  Martin Sebor  <msebor@redhat.com>\n \n \t* init/new45.C: New test to verify that operator new is invoked"}, {"sha": "ccda0976a04a306d7e0c4595005bf8752d9b780a", "filename": "gcc/testsuite/c-c++-common/goacc/routine-5.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03310c37cc1c1de0ee78a1518bd564b366a3328f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Froutine-5.c?ref=03310c37cc1c1de0ee78a1518bd564b366a3328f", "patch": "@@ -3,18 +3,14 @@\n #pragma acc routine /* { dg-error \"not followed by\" } */\n int a;\n \n-#if 0 /* Disable for the moment.  */\n-#pragma acc routine /* dg-error \"not followed by\" */\n+#pragma acc routine /* { dg-error \"not followed by\" } */\n void fn1 (void), fn1b (void);\n-#endif\n \n #pragma acc routine /* { dg-error \"not followed by\" } */\n int b, fn2 (void);\n \n-#if 0 /* Disable for the moment.  */\n-#pragma acc routine /*  dg-error \"not followed by\"  */\n+#pragma acc routine /* { dg-error \"not followed by\" } */\n int fn3 (void), b2;\n-#endif\n \n #pragma acc routine /* { dg-error \"not followed by\" } */\n typedef struct c c;"}]}