{"sha": "d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ1Y2YyMTVlZTdjZWZlZjAwNDRhNmJkM2VlMWMyYzdiMjQ2NjAzOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:07:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:07:15Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r472", "tree": {"sha": "b51ea120d470bb8953e46b0885064feeb114b3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51ea120d470bb8953e46b0885064feeb114b3a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/comments", "author": null, "committer": null, "parents": [{"sha": "23b2ce53390902084893cd7eb735b2332c927b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b2ce53390902084893cd7eb735b2332c927b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b2ce53390902084893cd7eb735b2332c927b67"}], "stats": {"total": 858, "additions": 650, "deletions": 208}, "files": [{"sha": "16c3aec0c8903bdb75bdedd2730c3d3b1f1997e1", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -30,6 +30,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"c-tree.h\"\n \n+#ifndef errno\n+extern int errno;\n+#endif\n+\n extern char* xmalloc ();\n \n enum formals_style_enum {\n@@ -231,7 +235,7 @@ gen_formal_list_for_type (fntype, style)\n      more typing information (for the parameter list) should be added (by\n      hand) at some convenient moment.\n \n-     The string chozen here is a comment with question marks in it.  */\n+     The string chosen here is a comment with question marks in it.  */\n \n   if (!*formal_list)\n     {\n@@ -636,7 +640,7 @@ gen_aux_info_record (fndecl, is_definition, is_implicit, is_prototyped)\n \t    fprintf (aux_info_file, \"/* compiled from: %s */\\n\", wd);\n \t}\n \n-      /* Write the actual line of auxilliary info.  */\n+      /* Write the actual line of auxiliary info.  */\n \n       fprintf (aux_info_file, \"/* %s:%d:%c%c */ %s;\",\n \t       DECL_SOURCE_FILE (fndecl),"}, {"sha": "07bdf039b1b613e708a19e933b6b6b54e75da4de", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -1,4 +1,4 @@\n-/* Lexical analyser for C and Objective C.\n+/* Lexical analyzer for C and Objective C.\n    Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -152,11 +152,11 @@ is_reserved_word (str, len)\n   static struct resword wordlist[] =\n     {\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"asm\",  ASM, NORID},\n+      {\"asm\",  ASM_KEYWORD, NORID},\n       {\"\",}, \n-      {\"__asm\",  ASM, NORID},\n+      {\"__asm\",  ASM_KEYWORD, NORID},\n       {\"\",}, \n-      {\"__asm__\",  ASM, NORID},\n+      {\"__asm__\",  ASM_KEYWORD, NORID},\n       {\"break\",  BREAK, NORID},\n       {\"__typeof__\",  TYPEOF, NORID},\n       {\"\",}, \n@@ -1084,7 +1084,7 @@ yylex ()\n \n \t    /* Even if we decided to recognize asm, still perhaps warn.  */\n \t    if (pedantic\n-\t\t&& (value == ASM || value == TYPEOF\n+\t\t&& (value == ASM_KEYWORD || value == TYPEOF\n \t\t    || ptr->rid == RID_INLINE)\n \t\t&& token_buffer[0] != '_')\n \t      pedwarn (\"ANSI does not permit the keyword `%s'\",\n@@ -1934,7 +1934,7 @@ yylex ()\n   return value;\n }\n \n-/* Sets the value of the 'yydebug' varable to VALUE.\n+/* Sets the value of the 'yydebug' variable to VALUE.\n    This is a function so we don't have to have YYDEBUG defined\n    in order to build the compiler.  */\n "}, {"sha": "983b330dccf4638e2b1cef0c5f11eb84e0a73b62", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 350, "deletions": 130, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -47,6 +47,7 @@ static tree convert_sequence ();\n static tree unary_complex_lvalue ();\n static tree process_init_constructor ();\n static tree convert_arguments ();\n+static char *get_spelling ();\n tree digest_init ();\n static void pedantic_lvalue_warning ();\n tree truthvalue_conversion ();\n@@ -384,7 +385,7 @@ comptypes (type1, type2)\n   if (TYPE_VOLATILE (t1) != TYPE_VOLATILE (t2))\n     return 0;\n \n-  /* If generating auxilliary info, allow for two different type nodes which\n+  /* If generating auxiliary info, allow for two different type nodes which\n      have essentially the same definition.  */\n \n   if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n@@ -1101,7 +1102,7 @@ build_indirect_ref (ptr, errorstring)\n \t    return error_mark_node;\n \t  }\n \n-\t/* We *must* set TREE_READONLY when dereferencinga pointer to const,\n+\t/* We *must* set TREE_READONLY when dereferencing a pointer to const,\n \t   so that we get the proper error message if the result is used\n \t   to assign to.  Also, &* is supposed to be a no-op.\n \t   And ANSI C seems to specify that the type of the result\n@@ -1943,7 +1944,8 @@ convert_arguments (typelist, values, name)\n \t\t}\n #endif\n \n-\t      /* Optionally warn about conversions that can overflow.  */\n+\t      /* Optionally warn about conversions that\n+\t\t differ from the default conversions.  */\n \t      if (warn_conversion)\n \t\t{\n \t\t  int formal_prec = TYPE_PRECISION (type);\n@@ -1956,28 +1958,36 @@ convert_arguments (typelist, values, name)\n \t\t  else if (TREE_CODE (type) == REAL_TYPE\n \t\t      && TREE_CODE (TREE_TYPE (val)) != REAL_TYPE)\n \t\t    warning (\"integer argument converted to floating\");\n+\t\t  else if (TREE_CODE (type) == REAL_TYPE\n+\t\t\t   && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)\n+\t\t    {\n+\t\t      /* Warn if any argument is passed as `float',\n+\t\t\t since withtout a prototype it would be `double'.  */\n+\t\t      if (formal_prec == TYPE_PRECISION (float_type_node))\n+\t\t\twarning (\"floating argument passed as `float' rather than `double'\");\n+\t\t    }\n \t\t  /* Detect integer changing in width or signedness.  */\n \t\t  else if ((TREE_CODE (type) == INTEGER_TYPE\n \t\t\t    || TREE_CODE (type) == ENUMERAL_TYPE)\n \t\t\t   && (TREE_CODE (TREE_TYPE (val)) == INTEGER_TYPE\n-\t\t\t       || TREE_CODE (TREE_TYPE (val)) == ENUMERAL_TYPE)\n-\t\t\t   && ((TREE_UNSIGNED (type)\n-\t\t\t\t!= TREE_UNSIGNED (TREE_TYPE (val)))\n-\t\t\t       || (MAX (formal_prec, int_prec)\n-\t\t\t\t   != MAX (actual_prec, int_prec))))\n+\t\t\t       || TREE_CODE (TREE_TYPE (val)) == ENUMERAL_TYPE))\n \t\t    {\n-\t\t      if (MAX (formal_prec, int_prec)\n-\t\t\t  != MAX (actual_prec, int_prec))\n-\t\t\twarning (\"integer argument converted in width\");\n+\t\t      tree would_have_been = default_conversion (val);\n+\t\t      tree type1 = TREE_TYPE (would_have_been);\n+\n+\t\t      if (TYPE_PRECISION (type) != TYPE_PRECISION (type))\n+\t\t\twarning (\"prototype changes width used for integer argument\");\n+\t\t      else if (TREE_UNSIGNED (type) == TREE_UNSIGNED (type1))\n+\t\t\t;\n \t\t      else if (TREE_CODE (val) == INTEGER_CST\n \t\t\t       && int_fits_type_p (val, type))\n \t\t\t/* Change in signedness doesn't matter\n \t\t\t   if a constant value is unaffected.  */\n \t\t\t;\n \t\t      else if (TREE_UNSIGNED (type))\n-\t\t\twarning (\"signed argument converted to unsigned\");\n+\t\t\twarning (\"argument passed as unsigned due to prototype\");\n \t\t      else\n-\t\t\twarning (\"unsigned argument converted to signed\");\n+\t\t\twarning (\"argument passed as signed due to prototype\");\n \t\t    }\n \t\t}\n \n@@ -2315,18 +2325,18 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      if (TREE_INT_CST_LOW (op1) >= TYPE_PRECISION (type0))\n \t\twarning (\"shift count exceeds width of value shifted\");\n \t    }\n+\t  /* Use the type of the value to be shifted.\n+\t     This is what most traditional C compilers do.  */\n+\t  result_type = type0;\n \t  /* Unless traditional, convert the shift-count to an integer,\n \t     regardless of size of value being shifted.  */\n \t  if (! flag_traditional)\n \t    {\n-\t      result_type = type0;\n \t      if (TREE_TYPE (op1) != integer_type_node)\n \t\top1 = convert (integer_type_node, op1);\n \t      /* Avoid converting op1 to result_type later.  */\n \t      converted = 1;\n \t    }\n-\t  else\n-\t    common = 1;\n \t}\n       break;\n \n@@ -2339,18 +2349,18 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  if (TREE_CODE (op1) == INTEGER_CST\n \t      && TREE_INT_CST_LOW (op1) >= TYPE_PRECISION (type0))\n \t    warning (\"shift count exceeds width of value shifted\");\n+\t  /* Use the type of the value to be shifted.\n+\t     This is what most traditional C compilers do.  */\n+\t  result_type = type0;\n \t  /* Unless traditional, convert the shift-count to an integer,\n \t     regardless of size of value being shifted.  */\n \t  if (! flag_traditional)\n \t    {\n-\t      result_type = type0;\n \t      if (TREE_TYPE (op1) != integer_type_node)\n \t\top1 = convert (integer_type_node, op1);\n \t      /* Avoid converting op1 to result_type later.  */\n \t      converted = 1;\n \t    }\n-\t  else\n-\t    common = 1;\n \t}\n       break;\n \n@@ -2364,18 +2374,18 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  if (TREE_CODE (op1) == INTEGER_CST\n \t      && TREE_INT_CST_LOW (op1) >= TYPE_PRECISION (type0))\n \t    warning (\"shift count >= width of value shifted\");\n+\t  /* Use the type of the value to be shifted.\n+\t     This is what most traditional C compilers do.  */\n+\t  result_type = type0;\n \t  /* Unless traditional, convert the shift-count to an integer,\n \t     regardless of size of value being shifted.  */\n \t  if (! flag_traditional)\n \t    {\n-\t      result_type = type0;\n \t      if (TREE_TYPE (op1) != integer_type_node)\n \t\top1 = convert (integer_type_node, op1);\n \t      /* Avoid converting op1 to result_type later.  */\n \t      converted = 1;\n \t    }\n-\t  else\n-\t    common = 1;\n \t}\n       break;\n \n@@ -2748,10 +2758,15 @@ pointer_int_sum (resultcode, ptrop, intop)\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (intop, 0))) == INTEGER_TYPE)\n     {\n       enum tree_code subcode = resultcode;\n+      tree int_type = TREE_TYPE (intop);\n       if (TREE_CODE (intop) == MINUS_EXPR)\n \tsubcode = (subcode == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR);\n-      ptrop = build_binary_op (subcode, ptrop, TREE_OPERAND (intop, 1), 1);\n-      intop = TREE_OPERAND (intop, 0);\n+      /* Convert both subexpression types to the type of intop,\n+\t because weird cases involving pointer arithmetic\n+\t can result in a sum or difference with different type args.  */\n+      ptrop = build_binary_op (subcode, ptrop,\n+\t\t\t       convert (int_type, TREE_OPERAND (intop, 1)), 1);\n+      intop = convert (int_type, TREE_OPERAND (intop, 0));\n     }\n \n   /* Convert the integer argument to a type the same size as a pointer\n@@ -3621,7 +3636,7 @@ build_c_cast (type, expr)\n \tvalue = default_conversion (value);\n       otype = TREE_TYPE (value);\n \n-      /* Optionally warn about potentially worrysome casts.  */\n+      /* Optionally warn about potentially worrisome casts.  */\n \n       if (warn_cast_qual\n \t  && TREE_CODE (type) == POINTER_TYPE\n@@ -3636,15 +3651,13 @@ build_c_cast (type, expr)\n \t}\n \n       /* Warn about possible alignment problems.  */\n-#ifdef STRICT_ALIGNMENT\n-      if (warn_cast_align\n+      if (STRICT_ALIGNMENT && warn_cast_align\n \t  && TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n \t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n \twarning (\"cast increases required alignment of target type\");\n-#endif\n \n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n@@ -3829,7 +3842,9 @@ build_modify_expr (lhs, modifycode, rhs)\n    for assignments that are not allowed in C.\n    ERRTYPE is a string to use in error messages:\n    \"assignment\", \"return\", etc.  If it is null, this is parameter passing\n-   for a function call (and different error messages are output).\n+   for a function call (and different error messages are output).  Otherwise,\n+   it may be a name stored in the spelling stack and interpreted by\n+   get_spelling.\n \n    FUNNAME is the name of the function being called,\n    as an IDENTIFIER_NODE, or null.\n@@ -3900,18 +3915,18 @@ convert_for_assignment (type, rhs, errtype, funname, parmnum)\n \t\t   && !integer_zerop (rhs)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n \t    warn_for_assignment (\"ANSI forbids %s between function pointer and `void *'\",\n-\t\t\t\t errtype, funname, parmnum);\n+\t\t\t\t get_spelling (errtype), funname, parmnum);\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   || TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n \t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\twarn_for_assignment (\"%s discards `const' from pointer target type\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\twarn_for_assignment (\"%s discards `volatile' from pointer target type\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t    }\n \t  else\n \t    {\n@@ -3921,35 +3936,35 @@ convert_for_assignment (type, rhs, errtype, funname, parmnum)\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n \t\twarn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t      if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n \t\twarn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t    }\n \t}\n       else if (unsigned_type (TYPE_MAIN_VARIANT (ttl))\n \t       == unsigned_type (TYPE_MAIN_VARIANT (ttr)))\n \twarn_for_assignment (\"pointer targets in %s differ in signedness\",\n-\t\t\t     errtype, funname, parmnum);\n+\t\t\t     get_spelling (errtype), funname, parmnum);\n       else\n \twarn_for_assignment (\"%s from incompatible pointer type\",\n-\t\t\t     errtype, funname, parmnum);\n+\t\t\t     get_spelling (errtype), funname, parmnum);\n       return convert (type, rhs);\n     }\n   else if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n     {\n       if (! integer_zerop (rhs))\n \t{\n \t  warn_for_assignment (\"%s makes pointer from integer without a cast\",\n-\t\t\t       errtype, funname, parmnum);\n+\t\t\t       get_spelling (errtype), funname, parmnum);\n \t  return convert (type, rhs);\n \t}\n       return null_pointer_node;\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n       warn_for_assignment (\"%s makes integer from pointer without a cast\",\n-\t\t\t   errtype, funname, parmnum);\n+\t\t\t   get_spelling (errtype), funname, parmnum);\n       return convert (type, rhs);\n     }\n \n@@ -3963,7 +3978,7 @@ convert_for_assignment (type, rhs, errtype, funname, parmnum)\n \t       parmnum);\n     }\n   else\n-    error (\"incompatible types in %s\", errtype);\n+    error (\"incompatible types in %s\", get_spelling (errtype));\n \n   return error_mark_node;\n }\n@@ -4131,7 +4146,7 @@ store_init_value (decl, init)\n #if 0\n   /* Note that this is the only place we can detect the error\n      in a case such as   struct foo bar = (struct foo) { x, y };\n-     where there is one initial value which is a constuctor expression.  */\n+     where there is one initial value which is a constructor expression.  */\n   if (value == error_mark_node)\n     ;\n   else if (TREE_STATIC (decl) && ! TREE_CONSTANT (value))\n@@ -4160,18 +4175,190 @@ store_init_value (decl, init)\n   DECL_INITIAL (decl) = value;\n }\n \f\n+/* Methods for storing and printing names for error messages.\n+\n+/* Implement a spelling stack that allows components of a name to be pushed\n+   and popped.  Each element on the stack is this structure.  */\n+\n+struct spelling\n+{\n+  int kind;\n+  union\n+    {\n+      int i;\n+      char *s;\n+    } u;\n+};\n+\n+#define SPELLING_STRING 1\n+#define SPELLING_MEMBER 2\n+#define SPELLING_BOUNDS 3\n+\n+static struct spelling *spelling;\t/* Next stack element (unused).  */\n+static struct spelling *spelling_base;\t/* Spelling stack base.  */\n+static int spelling_size;\t\t/* Size of the spelling stack.  */\n+\n+/* Macros to save and restore the spelling stack around push_... functions.\n+   Alternative to SAVE_SPELLING_STACK.  */\n+\n+#define SPELLING_DEPTH() (spelling - spelling_base)\n+#define RESTORE_SPELLING_DEPTH(depth) (spelling = spelling_base + depth)\n+\n+/* Save and restore the spelling stack around arbitrary C code.  */\n+\n+#define SAVE_SPELLING_DEPTH(code)\t\t\\\n+{\t\t\t\t\t\t\\\n+  int __depth = SPELLING_DEPTH ();\t\t\\\n+  code;\t\t\t\t\t\t\\\n+  RESTORE_SPELLING_DEPTH (__depth);\t\t\\\n+}\n+\n+/* Push an element on the spelling stack with type KIND and assign VALUE\n+   to MEMBER.  */\n+\n+#define PUSH_SPELLING(KIND, VALUE, MEMBER)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int depth = SPELLING_DEPTH ();\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (depth >= spelling_size)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      spelling_size += 10;\t\t\t\t\t\t\\\n+      if (spelling_base == 0)\t\t\t\t\t\t\\\n+\tspelling_base\t\t\t\t\t\t\t\\\n+\t  = (struct spelling *) xmalloc (spelling_size * sizeof (struct spelling));\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        spelling_base\t\t\t\t\t\t\t\\\n+\t  = (struct spelling *) xrealloc (spelling_base,\t\t\\\n+\t\t\t\t\t  spelling_size * sizeof (struct spelling));\t\\\n+      RESTORE_SPELLING_DEPTH (depth);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  spelling->kind = (KIND);\t\t\t\t\t\t\\\n+  spelling->MEMBER = (VALUE);\t\t\t\t\t\t\\\n+  spelling++;\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Push STRING on the stack.  Printed literally.  */\n+\n+static void\n+push_string (string)\n+     char *string;\n+{\n+  PUSH_SPELLING (SPELLING_STRING, string, u.s);\n+}\n+\n+/* Push a member name on the stack.  Printed as '.' STRING.  */\n+\n+static void\n+push_member_name (string)\n+     char *string;\n+{\n+  PUSH_SPELLING (SPELLING_MEMBER, string, u.s);\n+}\n+\n+/* Push an array bounds on the stack.  Printed as [BOUNDS].  */\n+\n+static void\n+push_array_bounds (bounds)\n+     int bounds;\n+{\n+  PUSH_SPELLING (SPELLING_BOUNDS, bounds, u.i);\n+}\n+\n+/* Compute the maximum size in bytes of the printed spelling.  */\n+\n+static int\n+spelling_length ()\n+{\n+  register int size = 0;\n+  register struct spelling *p;\n+\n+  for (p = spelling_base; p < spelling; p++)\n+    {\n+      if (p->kind == SPELLING_BOUNDS)\n+\tsize += 25;\n+      else\n+\tsize += strlen (p->u.s) + 1;\n+    }\n+\n+  return size;\n+}\n+\n+/* Print the spelling to BUFFER and return it.  */\n+\n+static char *\n+print_spelling (buffer)\n+     register char *buffer;\n+{\n+  register char *d = buffer;\n+  register char *s;\n+  register struct spelling *p;\n+\n+  for (p = spelling_base; p < spelling; p++)\n+    if (p->kind == SPELLING_BOUNDS)\n+      {\n+\tsprintf (d, \"[%d]\", p->u.i);\n+\td += strlen (d);\n+      }\n+    else\n+      {\n+\tif (p->kind == SPELLING_MEMBER)\n+\t  *d++ = '.';\n+\tfor (s = p->u.s; *d = *s++; d++)\n+\t  ;\n+      }\n+  *d++ = '\\0';\n+  return buffer;\n+}\n+\n+/* Provide a means to pass component names derived from the spelling stack.  */\n+\n+char initialization_message;\n+\n+/* Interpret the spelling of the given ERRTYPE message.  */\n+\n+static char *\n+get_spelling (errtype)\n+     char *errtype;\n+{\n+  static char *buffer;\n+  static int size = -1;\n+\n+  if (errtype == &initialization_message)\n+    {\n+      /* Avoid counting chars */\n+      static char message[] = \"initialization of `%s'\";\n+      register int needed = sizeof (message) + spelling_length () + 1;\n+\n+      if (size < 0)\n+\tbuffer = (char *) xmalloc (size = needed);\n+      if (needed > size)\n+\tbuffer = (char *) xrealloc (buffer, size = needed);\n+\n+      sprintf (buffer, message, print_spelling (alloca (needed)));\n+      return buffer;\n+    }\n+\n+  return errtype;\n+}\n+\n /* Issue an error message for a bad initializer component.\n    FORMAT describes the message.  OFWHAT is the name for the component.\n    LOCAL is a format string for formatting the insertion of the name\n    into the message.\n \n-   If OFWHAT is a null string, then LOCAL is omitted entirely.  */\n+   If OFWHAT is null, the component name is stored on the spelling stack.\n+   If the compoment name is a null string, then LOCAL is omitted entirely.  */\n \n void\n error_init (format, local, ofwhat)\n      char *format, *local, *ofwhat;\n {\n-  char *buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n+  char *buffer;\n+\n+  if (ofwhat == 0)\n+    ofwhat = print_spelling (alloca (spelling_length () + 1));\n+  buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n \n   if (*ofwhat)\n     sprintf (buffer, local, ofwhat);\n@@ -4186,13 +4373,18 @@ error_init (format, local, ofwhat)\n    LOCAL is a format string for formatting the insertion of the name\n    into the message.\n \n-   If OFWHAT is a null string, then LOCAL is omitted entirely.  */\n+   If OFWHAT is null, the component name is stored on the spelling stack.\n+   If the compoment name is a null string, then LOCAL is omitted entirely.  */\n \n void\n pedwarn_init (format, local, ofwhat)\n      char *format, *local, *ofwhat;\n {\n-  char *buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n+  char *buffer;\n+\n+  if (ofwhat == 0)\n+    ofwhat = print_spelling (alloca (spelling_length () + 1));\n+  buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n \n   if (*ofwhat)\n     sprintf (buffer, local, ofwhat);\n@@ -4215,8 +4407,9 @@ pedwarn_init (format, local, ofwhat)\n    if non-constant initializers or elements are seen.  CONSTRUCTOR_CONSTANT\n    applies only to elements of constructors.\n \n-   If OFWHAT is nonzero, it specifies what we are initializing, for error\n-   messages.   Examples: variable name, variable.member, array[44].  */\n+   If OFWHAT is nonnull, it specifies what we are initializing, for error\n+   messages.   Examples: variable name, variable.member, array[44].\n+   If OFWHAT is null, the component name is stored on the spelling stack.  */\n \n tree\n digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n@@ -4227,7 +4420,6 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n   enum tree_code code = TREE_CODE (type);\n   tree element = 0;\n   tree old_tail_contents;\n-  char *member_str;\t\t/* For building strings about member names.  */\n   /* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR\n      tree node which has no TREE_TYPE.  */\n   int raw_constructor\n@@ -4404,23 +4596,29 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t  return error_mark_node;\n \t}\n \n-      /* Build the name of this member, with a \".\" for membership.  */\n-      member_str = (char *) alloca (strlen (ofwhat)\n-\t\t\t+ IDENTIFIER_LENGTH (DECL_NAME (field)) + 2);\n-      sprintf (member_str, \"%s.%s\", ofwhat, \n-\t\t\t  IDENTIFIER_POINTER (DECL_NAME (field)));\n+      SAVE_SPELLING_DEPTH\n+\t({\n+\t  if (ofwhat)\n+\t    push_string (ofwhat);\n+\t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n+\n+\t  if (raw_constructor)\n+\t    result = process_init_constructor (type, init, 0,\n+\t\t\t\t\t       require_constant,\n+\t\t\t\t\t       constructor_constant, 0);\n+\t  else if (tail != 0)\n+\t    {\n+\t      *tail = old_tail_contents;\n+\t      result = process_init_constructor (type, 0, tail,\n+\t\t\t\t\t\t require_constant,\n+\t\t\t\t\t\t constructor_constant, 0);\n+\t    }\n+\t  else\n+\t    result = 0;\n+\t});\n \n-      if (raw_constructor)\n-\treturn process_init_constructor (type, init, 0,\n-\t\t\t\t\t require_constant,\n-\t\t\t\t\t constructor_constant, member_str);\n-      else if (tail != 0)\n-\t{\n-\t  *tail = old_tail_contents;\n-\t  return process_init_constructor (type, 0, tail,\n-\t\t\t\t\t   require_constant,\n-\t\t\t\t\t   constructor_constant, member_str);\n-\t}\n+      if (result)\n+\treturn result;\n     }\n \n   /* Handle scalar types, including conversions.  */\n@@ -4449,16 +4647,13 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t}\n #endif\n \n-      /* Build the name of the member being initialized, for error msgs.  */\n-      {\n-\t/* Avoid counting chars */\n-\tstatic char message[] = \"initialization of `%s'\";\n-\tmember_str = (char *) alloca (strlen (ofwhat) + sizeof (message) + 1);\n-\tsprintf (member_str, message, ofwhat);\n-      }\n-\n-      init = convert_for_assignment (type, default_conversion (init),\n-\t\t\t\t     member_str, NULL_TREE, 0);\n+      SAVE_SPELLING_DEPTH\n+\t({\n+\t  if (ofwhat)\n+\t    push_string (ofwhat);\n+\t  init = convert_for_assignment (type, default_conversion (init),\n+\t\t\t\t\t &initialization_message, NULL_TREE, 0);\n+\t});\n \n       if (require_constant && ! TREE_CONSTANT (init))\n \t{\n@@ -4533,7 +4728,8 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \n    OFWHAT is a character string describing the object being initialized,\n    for error messages.  It might be \"variable\" or \"variable.member\"\n-   or \"variable[17].member[5]\".  */\n+   or \"variable[17].member[5]\".  If OFWHAT is null, the description string\n+   is stored on the spelling stack.  */\n \n static tree\n process_init_constructor (type, init, elts, constant_value, constant_element,\n@@ -4546,12 +4742,14 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n   /* List of the elements of the result constructor,\n      in reverse order.  */\n   register tree members = NULL;\n-  int members_length = 0;\n   tree result;\n   int allconstant = 1;\n   int allsimple = 1;\n   int erroneous = 0;\n-  char *member_str;\t\t/* String used to pass member names.  */\n+  int depth = SPELLING_DEPTH ();\n+\n+  if (ofwhat)\n+    push_string (ofwhat);\n \n   /* Make TAIL be the list of elements to use for the initialization,\n      no matter how the data was given to us.  */\n@@ -4567,21 +4765,34 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      tree domain = TYPE_DOMAIN (type);\n-      register long len;\n-      register int i;\n-\n-      if (domain)\n-\tlen = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain))\n-\t       - TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain))\n-\t       + 1);\n+      tree min_index, max_index, current_index, members_index;\n+      tree bound_type;\n+      tree one;\n+\n+      /* If we have array bounds, set our bounds from that.  Otherwise,\n+\t we have a lower bound of zero and an unknown upper bound.  Also\n+\t set the type of the bounds; use \"int\" as default.  */\n+      if (TYPE_DOMAIN (type))\n+\t{\n+\t  min_index = members_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+\t  max_index = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+\t  bound_type = TREE_TYPE (min_index);\n+\t}\n       else\n-\tlen = -1;  /* Take as many as there are */\n+\t{\n+\t  min_index = members_index = integer_zero_node;\n+\t  max_index = 0;\n+\t  bound_type = integer_type_node;\n+\t}\n+\n+      one = convert (bound_type, integer_one_node);\n \n-      /* Don't leave the loop based on i if the next item has an explicit\n-\t index value that will override i. */\n+      /* Don't leave the loop based on index if the next item has an explicit\n+\t index value that will override it. */\n \n-      for (i = 0; tail != 0; i++)\n+      for (current_index = min_index; tail != 0;\n+\t   current_index = fold (build (PLUS_EXPR, bound_type,\n+\t\t\t\t\tcurrent_index, one)))\n \t{\n \t  register tree next1;\n \n@@ -4595,45 +4806,45 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\terror (\"field name used as index in array initializer\");\n \t      else if (TREE_CODE (TREE_PURPOSE (tail)) != INTEGER_CST)\n \t\terror (\"non-constant array index in initializer\");\n-\t      else if (domain != 0\n-\t\t\t&& (tree_int_cst_lt (TREE_PURPOSE (tail),\n-\t\t\t\t\t     TYPE_MIN_VALUE (domain))\n-\t\t\t    || tree_int_cst_lt (TYPE_MAX_VALUE (domain),\n-\t\t\t\t\t\tTREE_PURPOSE (tail))))\n+\t      else if (tree_int_cst_lt (TREE_PURPOSE (tail), min_index)\n+\t\t       || (max_index && tree_int_cst_lt (max_index,\n+\t\t\t\t\t\t\t TREE_PURPOSE (tail))))\n \t\terror (\"array index out of range in initializer\");\n \t      else\n-\t\ti = TREE_INT_CST_LOW (TREE_PURPOSE (tail)), win = 1;\n+\t\tcurrent_index = TREE_PURPOSE (tail), win = 1;\n \n \t      if (!win)\n \t\tTREE_VALUE (tail) = error_mark_node;\n \t    }\n \n-\t  if (len >= 0 && i >= len)\n+\t  if (max_index && tree_int_cst_lt (max_index, current_index))\n \t    break;  /* Stop if we've indeed run out of elements. */\n \n \t  /* Now digest the value specified.  */\n \t  if (TREE_VALUE (tail) != 0)\n \t    {\n \t      tree tail1 = tail;\n \n-\t      /* Build the index of this member, with a \".\" for membership.  */\n-\t      member_str = (char *) alloca (25 + strlen (ofwhat));\n-\t      sprintf (member_str, \"%s[%d]\", ofwhat, i);\n-\n-\t      next1 = digest_init (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n-\t\t\t\t   TREE_VALUE (tail), &tail1,\n-\t\t\t\t   /* Both of these are the same because\n-\t\t\t\t      a value here is an elt overall.  */\n-\t\t\t\t   constant_element, constant_element,\n-\t\t\t\t   member_str);\n+\t      /* Build the element of this array, with \"[]\" notation.  For\n+\t\t error messages, we assume that the index fits within a\n+\t\t host int.  */\n+\t      SAVE_SPELLING_DEPTH\n+\t\t({\n+\t\t  push_array_bounds (TREE_INT_CST_LOW (current_index));\n+\t\t  next1 = digest_init (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n+\t\t\t\t       TREE_VALUE (tail), &tail1,\n+\t\t\t\t       /* Both of these are the same because\n+\t\t\t\t\t  a value here is an elt overall.  */\n+\t\t\t\t       constant_element, constant_element, 0);\n+\t\t});\n \n \t      if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n \t\tabort ();\n-\t      if (tail == tail1 && len < 0)\n+\t      if (tail == tail1 && TYPE_DOMAIN (type) == 0)\n \t\t{\n \t\t  error_init (\n \t\t    \"non-empty initializer for array%s of empty elements\",\n-\t\t    \" `%s'\", ofwhat);\n+\t\t    \" `%s'\", 0);\n \t\t  /* Just ignore what we were supposed to use.  */\n \t\t  tail1 = 0;\n \t\t}\n@@ -4654,17 +4865,22 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \n \t  /* Now store NEXT1 in the list, I elements from the *end*.\n \t     Make the list longer if necessary.  */\n-\t  while (i >= members_length)\n+\t  while (! tree_int_cst_lt (current_index, members_index))\n \t    {\n \t      members = tree_cons (NULL_TREE, NULL_TREE, members);\n-\t      members_length++;\n+\t      members_index = fold (build (PLUS_EXPR, bound_type,\n+\t\t\t\t\t   members_index, one));\n \t    }\n+\n \t  {\n \t    tree temp;\n-\t    int j;\n+\t    tree idx;\n \n \t    temp = members;\n-\t    for (j = members_length - 1; j > i; j--)\n+\t    for (idx = fold (build (MINUS_EXPR, bound_type,\n+\t\t\t\t    members_index, one));\n+\t\t tree_int_cst_lt (current_index, idx);\n+\t\t idx = fold (build (MINUS_EXPR, bound_type, idx, one)))\n \t      temp = TREE_CHAIN (temp);\n \t    TREE_VALUE (temp) = next1;\n \t  }\n@@ -4673,6 +4889,7 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n   if (TREE_CODE (type) == RECORD_TYPE)\n     {\n       register tree field;\n+      int members_length = 0;\n       int i;\n \n       /* Don't leave the loop based on field just yet; see if next item\n@@ -4721,15 +4938,13 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t      tree tail1 = tail;\n \n \t      /* Build the name of this member, with a \".\" for membership.  */\n-\t      member_str = (char *) alloca (strlen (ofwhat)\n-\t\t\t\t+ IDENTIFIER_LENGTH (DECL_NAME (field)) + 2);\n-\t      sprintf (member_str, \"%s.%s\", ofwhat, \n-\t\t\t\t  IDENTIFIER_POINTER (DECL_NAME (field)));\n-\n-\t      next1 = digest_init (TREE_TYPE (field),\n-\t\t\t\t   TREE_VALUE (tail), &tail1,\n-\t\t\t\t   constant_element, constant_element,\n-\t\t\t\t   member_str);\n+\t      SAVE_SPELLING_DEPTH\n+\t\t({\n+\t\t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n+\t\t  next1 = digest_init (TREE_TYPE (field),\n+\t\t\t\t       TREE_VALUE (tail), &tail1,\n+\t\t\t\t       constant_element, constant_element, 0);\n+\t\t});\n \t      if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n \t\tabort ();\n \t      tail = tail1;\n@@ -4807,14 +5022,13 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t  tree tail1 = tail;\n \n \t  /* Build the name of this member, with a \".\" for membership.  */\n-\t  member_str = (char *) alloca (strlen (ofwhat)\n-\t\t\t    + IDENTIFIER_LENGTH (DECL_NAME (field)) + 2);\n-\t  sprintf (member_str, \"%s.%s\", ofwhat, \n-\t\t\t      IDENTIFIER_POINTER (DECL_NAME (field)));\n-\n-\t  next1 = digest_init (TREE_TYPE (field),\n-\t\t\t       TREE_VALUE (tail), &tail1,\n-\t\t\t       constant_value, constant_element, member_str);\n+\t  SAVE_SPELLING_DEPTH\n+\t    ({\n+\t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n+\t      next1 = digest_init (TREE_TYPE (field),\n+\t\t\t\t   TREE_VALUE (tail), &tail1,\n+\t\t\t\t   constant_value, constant_element, 0);\n+\t    });\n \t  if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n \t    abort ();\n \t  tail = tail1;\n@@ -4844,15 +5058,21 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n       if (TREE_CODE (type) == UNION_TYPE)\n \t{\n \t  pedwarn_init (\"excess elements in union initializer%s\",\n-\t\t\t\" after `%s'\", ofwhat);\n+\t\t\t\" after `%s'\", 0);\n \t}\n       else\n \t{\n \t  pedwarn_init (\"excess elements in aggregate initializer%s\",\n-\t\t\t\" after `%s'\", ofwhat);\n+\t\t\t\" after `%s'\", 0);\n \t}\n     }\n \n+  /* It might be possible to use SAVE_SPELLING_DEPTH, but I suspect that\n+     some preprocessor somewhere won't accept that much text as an argument.\n+     It's also likely to make debugging difficult.  */\n+\n+  RESTORE_SPELLING_DEPTH (depth);\n+\n   if (erroneous)\n     return error_mark_node;\n "}, {"sha": "529c5bfe22b8c3f38d00590c182588cf6980cc98", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -508,7 +508,8 @@ expand_call (exp, target, ignore, modifier)\n \t      mark_addressable (fndecl);\n \t    }\n \n-\t  if (TREE_READONLY (fndecl) && ! TREE_THIS_VOLATILE (fndecl))\n+\t  if (TREE_READONLY (fndecl) && ! TREE_THIS_VOLATILE (fndecl)\n+\t      && TYPE_MODE (TREE_TYPE (exp)) != VOIDmode)\n \t    is_const = 1;\n \t}\n     }\n@@ -717,7 +718,7 @@ expand_call (exp, target, ignore, modifier)\n      If SETUP_INCOMING_VARARGS is defined, this machine will be able to\n      place unnamed args that were passed in registers into the stack.  So\n      treat all args as named.  This allows the insns emitting for a specific\n-     argument list to be independant of the function declaration.\n+     argument list to be independent of the function declaration.\n \n      If SETUP_INCOMING_VARARGS is not defined, we do not have any reliable\n      way to pass unnamed args in registers, so we must force them into\n@@ -1620,7 +1621,7 @@ target_for_arg (type, size, args_addr, offset)\n    *ARG describes the argument value and where to pass it.\n \n    ARGBLOCK is the address of the stack-block for all the arguments,\n-   or 0 on a machine where arguemnts are pushed individually.\n+   or 0 on a machine where arguments are pushed individually.\n \n    MAY_BE_ALLOCA nonzero says this could be a call to `alloca'\n    so must be careful about how the stack is used. "}, {"sha": "1f53d997e4a37ede7ffebdc9e7b5e50e38b2055c", "filename": "gcc/cse.c", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -96,7 +96,7 @@ Constants and quantity numbers\n    in the appropriate element of qty_const.  This is in addition to\n    putting the constant in the hash table as is usual for non-regs.\n \n-   Whether a reg or a constant is prefered is determined by the configuration\n+   Whether a reg or a constant is preferred is determined by the configuration\n    macro CONST_COSTS and will often depend on the constant value.  In any\n    event, expressions containing constants can be simplified, by fold_rtx.\n \n@@ -323,7 +323,7 @@ static int cse_basic_block_start;\n static int cse_basic_block_end;\n \n /* Vector mapping INSN_UIDs to cuids.\n-   The cuids are like uids but increase monononically always.\n+   The cuids are like uids but increase monotonically always.\n    We use them to see whether a reg is used outside a given basic block.  */\n \n static short *uid_cuid;\n@@ -2754,6 +2754,9 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t    return 0;\n \t  break;\n \n+\tcase SQRT:\n+\t  return 0;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -2814,6 +2817,9 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t    return 0;\n \t  break;\n \n+\tcase SQRT:\n+\t  return 0;\n+\n \tdefault:\n \t  return 0;\n \t}\n@@ -2866,6 +2872,9 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  d = (double) REAL_VALUE_UNSIGNED_FIX_TRUNCATE (d);\n \t  break;\n \n+\tcase SQRT:\n+\t  return 0;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -5504,6 +5513,49 @@ cse_insn (insn, in_libcall_block)\n \t    }\n         }\n \n+      /* Another possibility is that we have an AND with a constant in\n+\t a mode narrower than a word.  If so, it might have been generated\n+\t as part of an \"if\" which would narrow the AND.  If we already\n+\t have done the AND in a wider mode, we can use a SUBREG of that\n+\t value.  */\n+\n+      if (flag_expensive_optimizations && ! src_related\n+\t  && GET_CODE (src) == AND && GET_CODE (XEXP (src, 1)) == CONST_INT\n+\t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\t{\n+\t  enum machine_mode tmode;\n+\t  rtx new_and = gen_rtx (AND, VOIDmode, 0, XEXP (src, 1));\n+\n+\t  for (tmode = GET_MODE_WIDER_MODE (mode);\n+\t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n+\t       tmode = GET_MODE_WIDER_MODE (tmode))\n+\t    {\n+\t      rtx inner = gen_lowpart_if_possible (tmode, XEXP (src, 0));\n+\t      struct table_elt *larger_elt;\n+\n+\t      if (inner)\n+\t\t{\n+\t\t  PUT_MODE (new_and, tmode);\n+\t\t  XEXP (new_and, 0) = inner;\n+\t\t  larger_elt = lookup (new_and, HASH (new_and, tmode), tmode);\n+\t\t  if (larger_elt == 0)\n+\t\t    continue;\n+\n+\t\t  for (larger_elt = larger_elt->first_same_value;\n+\t\t       larger_elt; larger_elt = larger_elt->next_same_value)\n+\t\t    if (GET_CODE (larger_elt->exp) == REG)\n+\t\t      {\n+\t\t\tsrc_related\n+\t\t\t  = gen_lowpart_if_possible (mode, larger_elt->exp);\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t  if (src_related)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+\t\t  \n       if (src == src_folded)\n         src_folded = 0;\n \n@@ -5734,7 +5786,7 @@ cse_insn (insn, in_libcall_block)\n       /* If this is a single SET, we are setting a register, and we have an\n \t equivalent constant, we want to add a REG_NOTE.   We don't want\n \t to write a REG_EQUAL note for a constant pseudo since verifying that\n-\t that psuedo hasn't been eliminated is a pain.  Such a note also\n+\t that pseudo hasn't been eliminated is a pain.  Such a note also\n \t won't help anything.  */\n       if (n_sets == 1 && src_const && GET_CODE (dest) == REG\n \t  && GET_CODE (src_const) != REG)\n@@ -6761,7 +6813,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop)\n       /* If this is a conditional jump, we can follow it if -fcse-follow-jumps\n \t was specified, we haven't reached our maximum path length, there are\n \t insns following the target of the jump, this is the only use of the\n-\t jump label, and the target label is preceeded by a BARRIER.  */\n+\t jump label, and the target label is preceded by a BARRIER.  */\n       else if (follow_jumps && path_size < PATHLENGTH - 1\n \t       && GET_CODE (p) == JUMP_INSN\n       \t       && GET_CODE (PATTERN (p)) == SET\n@@ -7115,7 +7167,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n       /* See if it is ok to keep on going past the label\n \t which used to end our basic block.  Remember that we incremented\n-\t the count of that label, so we decremement it here.  If we made\n+\t the count of that label, so we decrement it here.  If we made\n \t a jump unconditional, TO_USAGE will be one; in that case, we don't\n \t want to count the use in that jump.  */\n \n@@ -7132,7 +7184,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t  /* Find the end of the following block.  Note that we won't be\n \t     following branches in this case.  If TO was the last insn\n \t     in the function, we are done.  Similarly, if we deleted the\n-\t     insn after TO, it must have been because it was preceeded by\n+\t     insn after TO, it must have been because it was preceded by\n \t     a BARRIER.  In that case, we are done with this block because it\n \t     has no continuation.  */\n \n@@ -7266,6 +7318,7 @@ delete_dead_from_cse (insns, nreg)\n {\n   int *counts = (int *) alloca (nreg * sizeof (int));\n   rtx insn;\n+  rtx tem;\n   int i;\n \n   /* First count the number of times each register is used.  */\n@@ -7287,6 +7340,14 @@ delete_dead_from_cse (insns, nreg)\n \t      && SET_DEST (PATTERN (insn)) == SET_SRC (PATTERN (insn)))\n \t    ;\n \n+#ifdef HAVE_cc0\n+\t  else if (GET_CODE (SET_DEST (PATTERN (insn))) == CC0\n+\t\t   && ! side_effects_p (SET_SRC (PATTERN (insn)))\n+\t\t   && ((tem = next_nonnote_insn (insn)) == 0\n+\t\t       || GET_RTX_CLASS (GET_CODE (tem)) != 'i'\n+\t\t       || ! reg_referenced_p (cc0_rtx, PATTERN (tem))))\n+\t    ;\n+#endif\n \t  else if (GET_CODE (SET_DEST (PATTERN (insn))) != REG\n \t\t   || REGNO (SET_DEST (PATTERN (insn))) < FIRST_PSEUDO_REGISTER\n \t\t   || counts[REGNO (SET_DEST (PATTERN (insn)))] != 0\n@@ -7304,6 +7365,14 @@ delete_dead_from_cse (insns, nreg)\n \t\t    && SET_DEST (elt) == SET_SRC (elt))\n \t\t  ;\n \n+#ifdef HAVE_cc0\n+\t\telse if (GET_CODE (SET_DEST (elt)) == CC0\n+\t\t\t && ! side_effects_p (SET_SRC (elt))\n+\t\t\t && ((tem = next_nonnote_insn (insn)) == 0\n+\t\t\t     || GET_RTX_CLASS (GET_CODE (tem)) != 'i'\n+\t\t\t     || ! reg_referenced_p (cc0_rtx, PATTERN (tem))))\n+\t\t  ;\n+#endif\n \t\telse if (GET_CODE (SET_DEST (elt)) != REG\n \t\t\t || REGNO (SET_DEST (elt)) < FIRST_PSEUDO_REGISTER\n \t\t\t || counts[REGNO (SET_DEST (elt))] != 0"}, {"sha": "747e7c40b2c96f6c95d614e16522de4a74232b86", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -25,7 +25,8 @@ enum debug_info_type\n   NO_DEBUG,\t    /* Write no debug info.  */\n   DBX_DEBUG,\t    /* Write BSD .stabs for DBX (using dbxout.c).  */\n   SDB_DEBUG,\t    /* Write COFF for (old) SDB (using sdbout.c).  */\n-  DWARF_DEBUG\t    /* Write Dwarf debug info (using dwarfout.c).  */\n+  DWARF_DEBUG,\t    /* Write Dwarf debug info (using dwarfout.c).  */\n+  XCOFF_DEBUG\t    /* Write IBM/Xcoff debug info (using dbxout.c).  */\n };\n \n /* Specify which kind of debugging info to generate.  */\n@@ -42,7 +43,7 @@ enum debug_info_level\n /* Specify how much debugging info to generate.  */\n extern enum debug_info_level debug_info_level;\n \n-#ifdef DBX_DEBUGGING_INFO\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n /* Nonzero means use GDB-only extensions of DBX format.  */\n extern int use_gdb_dbx_extensions;\n #endif\n@@ -242,7 +243,7 @@ extern int flag_no_inline;\n \n extern int flag_syntax_only;\n \n-/* Nonzero means we should save auxilliary info into a .X file.  */\n+/* Nonzero means we should save auxiliary info into a .X file.  */\n \n extern int flag_gen_aux_info;\n "}, {"sha": "c07c26bd63346fb838d8bc371df2a72becb86645", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -586,7 +586,7 @@ attr_string (str, len)\n   /* Search the table for the string.  */\n   for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n     if (h->hashcode == -hashcode\n-\t&& !strcmp (h->u.str, str))\n+\t&& !strncmp (h->u.str, str, len))\n       return h->u.str;\t\t\t/* <-- return if found.  */\n \n   /* Not found; create a permanent copy and add it to the hash table.  */\n@@ -2191,7 +2191,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n       /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n \t present on both sides, apply the distributive law since this will\n-\t yield simplications.  */\n+\t yield simplifications.  */\n       if ((GET_CODE (left) == IOR || GET_CODE (right) == IOR)\n \t  && compute_alternative_mask (left, IOR)\n \t  && compute_alternative_mask (right, IOR))"}, {"sha": "913c61eff5ef5523e8bda25f928c694f3ff6a80c", "filename": "gcc/global.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -542,7 +542,7 @@ global_alloc (file)\n \t for the sake of debugging information.  */\n   if (n_basic_blocks > 0)\n #endif\n-    reload (basic_block_head[0], 1, file);\n+    reload (get_insns (), 1, file);\n }\n \n /* Sort predicate for ordering the allocnos.\n@@ -778,7 +778,7 @@ prune_preferences ()\n   /* Scan least most important to most important.\n      For each allocno, remove from preferences registers that cannot be used,\n      either because of conflicts or register type.  Then compute all registers\n-     prefered by each lower-priority register that conflicts.  */\n+     preferred by each lower-priority register that conflicts.  */\n \n   for (i = max_allocno - 1; i >= 0; i--)\n     {\n@@ -875,7 +875,7 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered, retrying)\n   IOR_HARD_REG_SET (used1, hard_reg_conflicts[allocno]);\n \n   /* Try each hard reg to see if it fits.  Do this in two passes.\n-     In the first pass, skip registers that are prefered by some other pseudo\n+     In the first pass, skip registers that are preferred by some other pseudo\n      to give it a better chance of getting one of those registers.  Only if\n      we can't get a register when excluding those do we take one of them.\n      However, we never allocate a register for the first time in pass 0.  */"}, {"sha": "03cbaf4c4ccc5db295a913078456fa08da8b9f6b", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -508,6 +508,7 @@ save_for_inline_copying (fndecl)\n \n \tcase CODE_LABEL:\n \t  copy = label_map[CODE_LABEL_NUMBER (insn)];\n+\t  LABEL_NAME (copy) = LABEL_NAME (insn);\n \t  break;\n \n \tcase BARRIER:\n@@ -2101,7 +2102,7 @@ try_constants (insn, map)\n \f\n /* Substitute known constants for pseudo regs in the contents of LOC,\n    which are part of INSN.\n-   If INSN is zero, the substition should always be done (this is used to\n+   If INSN is zero, the substitution should always be done (this is used to\n    update DECL_RTL).\n    These changes are taken out by try_constants if the result is not valid.\n "}, {"sha": "1a745bb3bcf170e11aeb0d14c080e1c2e90015f5", "filename": "gcc/jump.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -640,7 +640,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      continue;\n \t    }\n \n-\t  /* If we have an unconditional jump preceeded by a USE, try to put\n+\t  /* If we have an unconditional jump preceded by a USE, try to put\n \t     the USE before the target and jump there.  This simplifies many\n \t     of the optimizations below since we don't have to worry about\n \t     dealing with these USE insns.  We only do this if the label\n@@ -690,7 +690,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t     We set:\n \n-\t     TEMP to the jump insn preceeding \"x = a;\"\n+\t     TEMP to the jump insn preceding \"x = a;\"\n \t     TEMP1 to X\n \t     TEMP2 to the insn that sets \"x = b;\"\n \t     TEMP3 to the insn that sets \"x = a;\"  */\n@@ -1418,11 +1418,13 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t\t\t/* Include in each range any line number before it.  */\n \t\t\twhile (PREV_INSN (range1beg)\n-\t\t\t       && GET_CODE (PREV_INSN (range1beg)) == NOTE)\n+\t\t\t       && GET_CODE (PREV_INSN (range1beg)) == NOTE\n+\t\t\t       && NOTE_LINE_NUMBER (PREV_INSN (range1beg)) > 0)\n \t\t\t  range1beg = PREV_INSN (range1beg);\n \n \t\t\twhile (PREV_INSN (range2beg)\n-\t\t\t       && GET_CODE (PREV_INSN (range2beg)) == NOTE)\n+\t\t\t       && GET_CODE (PREV_INSN (range2beg)) == NOTE\n+\t\t\t       && NOTE_LINE_NUMBER (PREV_INSN (range2beg)) > 0)\n \t\t\t  range2beg = PREV_INSN (range2beg);\n \n \t\t\t/* Don't move NOTEs for blocks or loops; shift them"}, {"sha": "90cac29b0a0474e313f8b00290dd259e17d2e1d4", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 90, "deletions": 3, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -368,7 +368,7 @@ local_alloc ()\n   update_equiv_regs ();\n \n   /* This sets the maximum number of quantities we can have.  Quantity\n-     numbers start at zero and we can have one for each psuedo plus the\n+     numbers start at zero and we can have one for each pseudo plus the\n      number of SCRATCHs in the largest block, in the worst case.  */\n   max_qty = (max_regno - FIRST_PSEUDO_REGISTER) + max_scratch;\n \n@@ -640,7 +640,7 @@ memref_used_between_p (memref, start, end)\n    register-register copy.  */\n \n static void\n-optimize_reg_copy (insn, dest, src)\n+optimize_reg_copy_1 (insn, dest, src)\n      rtx insn;\n      rtx dest;\n      rtx src;\n@@ -755,6 +755,85 @@ optimize_reg_copy (insn, dest, src)\n \t}\n     }\n }\n+\f\n+/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have\n+   a sequence of insns that modify DEST followed by an insn that sets\n+   SRC to DEST in which DEST dies, with no prior modification of DEST.\n+   (There is no need to check if the insns in between actually modify\n+   DEST.  We should not have cases where DEST is not modified, but\n+   the optimization is safe if no such modification is detected.)\n+   In that case, we can replace all uses of DEST, starting with INSN and\n+   ending with the set of SRC to DEST, with SRC.  We do not do this\n+   optimization if a CALL_INSN is crossed unless SRC already crosses a\n+   call.\n+\n+   It is assumed that DEST and SRC are pseudos; it is too complicated to do\n+   this for hard registers since the substitutions we may make might fail.  */\n+\n+static void\n+optimize_reg_copy_2 (insn, dest, src)\n+     rtx insn;\n+     rtx dest;\n+     rtx src;\n+{\n+  rtx p, q;\n+  rtx set;\n+  int sregno = REGNO (src);\n+  int dregno = REGNO (dest);\n+\n+  for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+    {\n+      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+\t  || (GET_CODE (p) == NOTE\n+\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\tbreak;\n+\n+      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\tcontinue;\n+\n+      set = single_set (p);\n+      if (set && SET_SRC (set) == dest && SET_DEST (set) == src\n+\t  && find_reg_note (p, REG_DEAD, dest))\n+\t{\n+\t  /* We can do the optimization.  Scan forward from INSN again,\n+\t     replacing regs as we go.  */\n+\n+\t  /* Set to stop at next insn.  */\n+\t  for (q = insn; q != NEXT_INSN (p); q = NEXT_INSN (q))\n+\t    if (GET_RTX_CLASS (GET_CODE (q)) == 'i')\n+\t      {\n+\t\tif (reg_mentioned_p (dest, PATTERN (q)))\n+\t\t  {\n+\t\t    PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n+\n+\t\t    /* We assume that a register is used exactly once per\n+\t\t       insn in the updates below.  If this is not correct,\n+\t\t       no great harm is done.  */\n+\t\t    reg_n_refs[sregno] -= loop_depth;\n+\t\t    reg_n_refs[dregno] += loop_depth;\n+\t\t  }\n+\n+\n+\t      if (GET_CODE (q) == CALL_INSN)\n+\t\t{\n+\t\t  reg_n_calls_crossed[dregno]--;\n+\t\t  reg_n_calls_crossed[sregno]++;\n+\t\t}\n+\t      }\n+\n+\t  remove_note (p, find_reg_note (p, REG_DEAD, dest));\n+\t  reg_n_deaths[dregno]--;\n+\t  remove_note (insn, find_reg_note (insn, REG_DEAD, src));\n+\t  reg_n_deaths[sregno]--;\n+\t  return;\n+\t}\n+\n+      if (reg_set_p (src, p)\n+\t  || (GET_CODE (p) == CALL_INSN && reg_n_calls_crossed[sregno] == 0))\n+\tbreak;\n+    }\n+}\n \f\t      \n /* Find registers that are equivalent to a single value throughout the\n    compilation (either because they can be referenced in memory or are set once\n@@ -825,7 +904,15 @@ update_equiv_regs ()\n       if (flag_expensive_optimizations && GET_CODE (dest) == REG\n \t  && GET_CODE (SET_SRC (set)) == REG\n \t  && ! find_reg_note (insn, REG_DEAD, SET_SRC (set)))\n-\toptimize_reg_copy (insn, dest, SET_SRC (set));\n+\toptimize_reg_copy_1 (insn, dest, SET_SRC (set));\n+\n+      /* Similarly for a pseudo-pseudo copy when SRC is dead.  */\n+      else if (flag_expensive_optimizations && GET_CODE (dest) == REG\n+\t       && REGNO (dest) >= FIRST_PSEUDO_REGISTER\n+\t       && GET_CODE (SET_SRC (set)) == REG\n+\t       && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n+\t       && find_reg_note (insn, REG_DEAD, SET_SRC (set)))\n+\toptimize_reg_copy_2 (insn, dest, SET_SRC (set));\n \n       /* Otherwise, we only handle the case of a pseudo register being set\n \t once.  */"}, {"sha": "60425cbe668efc12966085cc5a52e1a6def3dba3", "filename": "gcc/loop.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -48,7 +48,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"loop.h\"\n \n /* Vector mapping INSN_UIDs to luids.\n-   The luids are like uids but increase monononically always.\n+   The luids are like uids but increase monotonically always.\n    We use them to see whether a jump comes from outside a given loop.  */\n \n int *uid_luid;\n@@ -603,8 +603,7 @@ scan_loop (loop_start, end, nregs)\n     }\n \n   /* Scan through the loop finding insns that are safe to move.\n-     In each such insn, store QImode as the mode, to mark it.\n-     Then set n_times_set negative for the reg being set, so that\n+     Set n_times_set negative for the reg being set, so that\n      this reg will be considered invariant for subsequent insns.\n      We consider whether subsequent insns use the reg\n      in deciding whether it is worth actually moving.\n@@ -3276,7 +3275,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       else\n \t{\n \t  /* Biv initial value is not simple move,\n-\t     so let it keep intial value of \"itself\".  */\n+\t     so let it keep initial value of \"itself\".  */\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"is complex\\n\");\n@@ -3756,7 +3755,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t This won't work if ! all_reduced,\n \t since the givs we planned to use might not have been reduced.\n \n-\t We have to be careful that we didn't initially think we could elminate\n+\t We have to be careful that we didn't initially think we could eliminate\n \t this biv because of a giv that we now think may be dead and shouldn't\n \t be used as a biv replacement.  \n \n@@ -3863,7 +3862,7 @@ valid_initial_value_p (x, insn, call_seen, loop_start)\n   if (CONSTANT_P (x))\n     return 1;\n \n-  /* Only consider psuedos we know about initialized in insns whose luids\n+  /* Only consider pseudos we know about initialized in insns whose luids\n      we know.  */\n   if (GET_CODE (x) != REG\n       || REGNO (x) >= max_reg_before_loop)\n@@ -4106,7 +4105,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n      isn't computable if INSN insn't executed every iteration.\n      However, for a DEST_ADDR giv, INSN merely uses the value of the giv;\n      it does not compute a new value.  Hence the value is always computable\n-     irregardless of whether INSN is executed each iteration.  */\n+     regardless of whether INSN is executed each iteration.  */\n \n   if (type == DEST_ADDR)\n     v->always_computable = 1;\n@@ -5818,7 +5817,7 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t     Insert insns to calculate new compare value.  */\n \n \t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (CONSTANT_P (v->mult_val)\n+\t    if (CONSTANT_P (v->mult_val) && INTVAL (v->mult_val) > 0\n \t\t&& ! v->ignore && ! v->maybe_dead\n \t\t&& v->mode == mode)\n \t      {"}, {"sha": "d3bd54abd991dca6140e18d6e05d9bf364ef644e", "filename": "gcc/optabs.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -71,6 +71,7 @@ optab neg_optab;\n optab abs_optab;\n optab one_cmpl_optab;\n optab ffs_optab;\n+optab sqrt_optab;\n \n optab cmp_optab;\n optab ucmp_optab;  /* Used only for libcalls for unsigned comparisons.  */\n@@ -1183,7 +1184,7 @@ emit_unop_insn (icode, target, op0, code)\n /* Emit code to perform a series of operations on a multi-word quantity, one\n    word at a time.\n \n-   Such a block is preceeded by a CLOBBER of the output, consists of multiple\n+   Such a block is preceded by a CLOBBER of the output, consists of multiple\n    insns, each setting one word of the output, and followed by a SET copying\n    the output to itself.\n \n@@ -2829,6 +2830,7 @@ init_optabs ()\n   abs_optab = init_optab (ABS);\n   one_cmpl_optab = init_optab (NOT);\n   ffs_optab = init_optab (FFS);\n+  sqrt_optab = init_optab (SQRT);\n \n #ifdef HAVE_addqi3\n   if (HAVE_addqi3)\n@@ -3675,6 +3677,45 @@ init_optabs ()\n   /* No library calls here!  If there is no abs instruction,\n      expand_expr will generate a conditional negation.  */\n \n+#ifdef HAVE_sqrtqi2\n+  if (HAVE_sqrtqi2)\n+    sqrt_optab->handlers[(int) QImode].insn_code = CODE_FOR_sqrtqi2;\n+#endif\n+#ifdef HAVE_sqrthi2\n+  if (HAVE_sqrthi2)\n+    sqrt_optab->handlers[(int) HImode].insn_code = CODE_FOR_sqrthi2;\n+#endif\n+#ifdef HAVE_sqrtpsi2\n+  if (HAVE_sqrtpsi2)\n+    sqrt_optab->handlers[(int) PSImode].insn_code = CODE_FOR_sqrtpsi2;\n+#endif\n+#ifdef HAVE_sqrtsi2\n+  if (HAVE_sqrtsi2)\n+    sqrt_optab->handlers[(int) SImode].insn_code = CODE_FOR_sqrtsi2;\n+#endif\n+#ifdef HAVE_sqrtdi2\n+  if (HAVE_sqrtdi2)\n+    sqrt_optab->handlers[(int) DImode].insn_code = CODE_FOR_sqrtdi2;\n+#endif\n+#ifdef HAVE_sqrtti2\n+  if (HAVE_sqrtti2)\n+    sqrt_optab->handlers[(int) TImode].insn_code = CODE_FOR_sqrtti2;\n+#endif\n+#ifdef HAVE_sqrtsf2\n+  if (HAVE_sqrtsf2)\n+    sqrt_optab->handlers[(int) SFmode].insn_code = CODE_FOR_sqrtsf2;\n+#endif\n+#ifdef HAVE_sqrtdf2\n+  if (HAVE_sqrtdf2)\n+    sqrt_optab->handlers[(int) DFmode].insn_code = CODE_FOR_sqrtdf2;\n+#endif\n+#ifdef HAVE_sqrttf2\n+  if (HAVE_sqrttf2)\n+    sqrt_optab->handlers[(int) TFmode].insn_code = CODE_FOR_sqrttf2;\n+#endif\n+  /* No library calls here!  If there is no sqrt instruction expand_builtin\n+     should force the library call.  */\n+\n #ifdef HAVE_one_cmplqi2\n   if (HAVE_one_cmplqi2)\n     one_cmpl_optab->handlers[(int) QImode].insn_code = CODE_FOR_one_cmplqi2;"}, {"sha": "a3cae4ac31ebee3d303291bb367ed0fa584dc692", "filename": "gcc/protoize.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -1207,11 +1207,11 @@ abspath (cwd, rel_filename)\n   /* Setup the current working directory as needed.  */\n   const char *cwd2 = (cwd) ? cwd : cwd_buffer;\n   char *const abs_buffer\n-    = (char *) alloca (strlen (cwd2) + strlen (rel_filename) + 1);\n+    = (char *) alloca (strlen (cwd2) + strlen (rel_filename) + 2);\n   char *endp = abs_buffer;\n   char *outp, *inp;\n \n-  /* Copy the  filename (possibly preceeded by the current working\n+  /* Copy the  filename (possibly preceded by the current working\n      directory name) into the absolutization buffer.  */\n \n   {\n@@ -1501,7 +1501,7 @@ referenced_file_is_newer (l, aux_info_mtime)\n    a function definition or declaration.\n \n    Link this record onto the list of such records for the particular file in\n-   which it occured in proper (descending) line number order (for now).\n+   which it occurred in proper (descending) line number order (for now).\n \n    If there is an identical record already on the list for the file, throw\n    this one away.  Doing so takes care of the (useless and troublesome)\n@@ -1678,7 +1678,7 @@ save_def_or_dec (l, is_syscalls)\n          character of the name of the function that was declared/defined.\n          If p points to another right paren, then this indicates that we\n          are dealing with multiple formals lists.  In that case, there\n-         really should be another right paren preceeding this right paren.  */\n+         really should be another right paren preceding this right paren.  */\n \n       if (*p != ')')\n         break;\n@@ -2580,7 +2580,7 @@ connect_defs_and_decs (hp)\n      prototypes *should* all match exactly with one another and with the\n      prototype for the actual function definition.  We don't check for this\n      here however, since we assume that the compiler must have already done\n-     this consistancy checking when it was creating the .X files.  */\n+     this consistency checking when it was creating the .X files.  */\n \n   for (dd_p = hp->ddip; dd_p; dd_p = dd_p->next_for_func)\n     if (dd_p->prototyped)\n@@ -3418,7 +3418,7 @@ add_local_decl (def_dec_p, clean_text_p)\n       output_string (decl);\n     }\n \n-    /* Finally, write out a new indent string, just like the preceeding one\n+    /* Finally, write out a new indent string, just like the preceding one\n        that we found.  This will typically include a newline as the first\n        character of the indent string.  */\n "}, {"sha": "6a08d5b089f6f0b236160373ad8718d6c73ca162", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -241,10 +241,9 @@ static void change_stack ();\n static void convert_regs ();\n static void dump_stack_info ();\n \f\n-/* Return non-zero if any stack register is mentioned somewhere within\n-   PAT. */\n+/* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n \n-static int\n+int\n stack_regs_mentioned_p (pat)\n      register rtx pat;\n {\n@@ -1450,7 +1449,7 @@ stack_reg_life_analysis (first)\n }\n \f\n /*****************************************************************************\n-   This section deals with stack register substition, and forms the second\n+   This section deals with stack register substitution, and forms the second\n    pass over the RTL.\n  *****************************************************************************/\n \n@@ -2623,7 +2622,7 @@ goto_block_pat (insn, regstack, pat)\n }\n \f\n /* Traverse all basic blocks in a function, converting the register\n-   refereces in each insn from the \"flat\" register file that gcc uses, to\n+   references in each insn from the \"flat\" register file that gcc uses, to\n    the stack-like registers the 387 uses. */\n \n static void"}, {"sha": "78097ee16dc293c6fdee9947fc6e0da9f68bc4e9", "filename": "gcc/reload.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -284,6 +284,16 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n   enum machine_mode t_mode = VOIDmode;\n   enum insn_code t_icode = CODE_FOR_nothing;\n \n+  /* If X is a pseudo-register that has an equivalent MEM (actually, if it\n+     is still a pseudo-register by now, it *must* have an equivalent MEM\n+     but we don't want to assume that), use that equivalent when seeing if\n+     a secondary reload is needed since whether or not a reload is needed\n+     might be sensitive to the form of the MEM.  */\n+\n+  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && reg_equiv_mem[REGNO (x)] != 0)\n+    x = reg_equiv_mem[REGNO (x)];\n+\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n   if (in_p)\n     class = SECONDARY_INPUT_RELOAD_CLASS (reload_class, reload_mode, x);\n@@ -323,8 +333,10 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n \n+      char insn_letter = insn_operand_constraint[(int) icode][!in_p][in_p];\n       enum reg_class insn_class\n-\t= REG_CLASS_FROM_LETTER (insn_operand_constraint[(int) icode][!in_p][in_p]);\n+\t= (insn_letter == 'r' ? GENERAL_REGS\n+\t   : REG_CLASS_FROM_LETTER (insn_letter));\n \n       if (insn_class == NO_REGS\n \t  || (in_p && insn_operand_constraint[(int) icode][!in_p][0] != '=')\n@@ -337,10 +349,11 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n \tmode = insn_operand_mode[(int) icode][2];\n       else\n \t{\n+\t  char t_letter = insn_operand_constraint[(int) icode][2][2];\n \t  class = insn_class;\n \t  t_mode = insn_operand_mode[(int) icode][2];\n-\t  t_class\n-\t    = REG_CLASS_FROM_LETTER (insn_operand_constraint[(int) icode][2][2]);\n+\t  t_class = (t_letter == 'r' ? GENERAL_REGS\n+\t\t     : REG_CLASS_FROM_LETTER (t_letter));\n \t  t_icode = icode;\n \t  icode = CODE_FOR_nothing;\n \t}\n@@ -1831,7 +1844,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      bcopy (constraints, constraints1, noperands * sizeof (char *));\n \t      n_alternatives = n_occurrences (',', constraints[0]) + 1;\n \t      for (i = 1; i < noperands; i++)\n-\t\tif (n_alternatives != n_occurrences (',', constraints[0]) + 1)\n+\t\tif (n_alternatives != n_occurrences (',', constraints[i]) + 1)\n \t\t  {\n \t\t    error_for_asm (insn, \"operand constraints differ in number of alternatives\");\n \t\t    /* Avoid further trouble with this insn.  */\n@@ -2012,6 +2025,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n \t\t\t\t    recog_operand[i], ind_levels);\n \t      substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n+\n+\t      /* This is no longer a psuedo register.  To prevent later code\n+\t\t from thinking it still is, we must reset the preferred_class\n+\t\t to NO_REGS.  */\n+\t      preferred_class[i] = NO_REGS;\n \t    }\n \t}\n     }\n@@ -3403,7 +3421,7 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n      is that it is itself a MEM.  This can happen when the frame pointer is\n      being eliminated, a pseudo is not allocated to a hard register, and the\n      offset between the frame and stack pointers is not its initial value.\n-     In that case the psuedo will have been replaced by a MEM referring to\n+     In that case the pseudo will have been replaced by a MEM referring to\n      the stack pointer.  */\n   if (GET_CODE (ad) == MEM)\n     {"}, {"sha": "b94c453c95f6d691214eac6bee82af00a84f2994", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -236,7 +236,7 @@ int reload_in_progress = 0;\n enum insn_code reload_in_optab[NUM_MACHINE_MODES];\n enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n \n-/* This obstack is used for allocation of rtl during register elmination.\n+/* This obstack is used for allocation of rtl during register elimination.\n    The allocated storage can be freed once find_reloads has processed the\n    insn.  */\n \n@@ -744,7 +744,7 @@ reload (first, global, dumpfile)\n   /* This loop scans the entire function each go-round\n      and repeats until one repetition spills no additional hard regs.  */\n \n-  /* This flag is set when a psuedo reg is spilled,\n+  /* This flag is set when a pseudo reg is spilled,\n      to require another pass.  Note that getting an additional reload\n      reg does not necessarily imply any pseudo reg was spilled;\n      sometimes we find a reload reg that no pseudo reg was allocated in.  */\n@@ -880,7 +880,7 @@ reload (first, global, dumpfile)\n \t      }\n \t  }\n \n-      /* If we allocated another psuedo to the stack, redo elimination\n+      /* If we allocated another pseudo to the stack, redo elimination\n \t bookkeeping.  */\n       if (something_changed)\n \tcontinue;\n@@ -1188,7 +1188,7 @@ reload (first, global, dumpfile)\n \t\t of that class should be quite rare.\n \n \t\t If a group is needed, the size and mode of the group will\n-\t\t have been set up at the begining of this loop.  */\n+\t\t have been set up at the beginning of this loop.  */\n \n \t      if (GET_CODE (insn) == CALL_INSN\n \t\t  && caller_save_spill_class != NO_REGS)\n@@ -2171,7 +2171,7 @@ set_label_offsets (x, insn, initial_p)\n \t}\n \n       /* Otherwise, if this is the definition of a label and it is\n-\t preceeded by a BARRIER, set our offsets to the known offset of\n+\t preceded by a BARRIER, set our offsets to the known offset of\n \t that label.  */\n \n       else if (x == insn\n@@ -2579,7 +2579,7 @@ eliminate_regs (x, mem_mode, insn)\n \n     case CLOBBER:\n       /* If clobbering a register that is the replacement register for an\n-\t elimination we still think can be peformed, note that it cannot\n+\t elimination we still think can be performed, note that it cannot\n \t be performed.  Otherwise, we need not be concerned about it.  */\n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \tif (ep->to_rtx == XEXP (x, 0))\n@@ -4324,8 +4324,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t    {\n \t      int s = reload_order[i];\n \n-\t      if ((reload_in[s] == 0 && reload_out[s] == 0 &&\n-\t\t   ! reload_secondary_p[s])\n+\t      if ((reload_in[s] == 0 && reload_out[s] == 0\n+\t\t   && ! reload_secondary_p[s])\n \t\t  || reload_optional[s])\n \t\tcontinue;\n \n@@ -4479,7 +4479,7 @@ emit_reload_insns (insn)\n   /* Values to be put in spill_reg_store are put here first.  */\n   rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n \n-  /* If this is a CALL_INSN preceeded by USE insns, any reload insns\n+  /* If this is a CALL_INSN preceded by USE insns, any reload insns\n      must go in front of the first USE insn, not in front of INSN.  */\n \n   if (GET_CODE (insn) == CALL_INSN && GET_CODE (PREV_INSN (insn)) == INSN\n@@ -5637,9 +5637,9 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n     {\n       /* If incrementing a register, assume we can\n \t output an insn to increment it directly.  */\n-      if (GET_CODE (incloc) == REG &&\n-\t  (REGNO (incloc) < FIRST_PSEUDO_REGISTER\n-\t   || reg_renumber[REGNO (incloc)] >= 0))\n+      if (GET_CODE (incloc) == REG\n+\t  && (REGNO (incloc) < FIRST_PSEUDO_REGISTER\n+\t      || reg_renumber[REGNO (incloc)] >= 0))\n \t{\n \t  rtx first_new\n \t    = emit_insn_before (gen_add2_insn (incloc,\n@@ -5676,9 +5676,9 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n \n       /* If incrementing a register, assume we can\n \t output an insn to increment it directly.  */\n-      if (GET_CODE (incloc) == REG &&\n-\t  (REGNO (incloc) < FIRST_PSEUDO_REGISTER\n-\t   || reg_renumber[REGNO (incloc)] >= 0))\n+      if (GET_CODE (incloc) == REG\n+\t  && (REGNO (incloc) < FIRST_PSEUDO_REGISTER\n+\t      || reg_renumber[REGNO (incloc)] >= 0))\n \t{\n \t  emit_insn_before (gen_add2_insn (incloc,\n \t\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,"}, {"sha": "160e49a155620c62cd553bdbd3d7fe2b9d762455", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -95,7 +95,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n    On machines that use CC0, we are very conservative.  We will not make\n    a copy of an insn involving CC0 since we want to maintain a 1-1\n-   correspondance between the insn that sets and uses CC0.  The insns are\n+   correspondence between the insn that sets and uses CC0.  The insns are\n    allowed to be separated by placing an insn that sets CC0 (but not an insn\n    that uses CC0; we could do this, but it doesn't seem worthwhile) in a\n    delay slot.  In that case, we point each insn at the other with REG_CC_USER\n@@ -2666,7 +2666,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n      update THREAD and NEW_THREAD if it is done in the loop below.  Also\n      initialize NEW_THREAD.  */\n \n-  new_thread = thread = try_split (PATTERN (thread), thread);\n+  new_thread = thread = try_split (PATTERN (thread), thread, 0);\n \n   /* Scan insns at THREAD.  We are looking for an insn that can be removed\n      from THREAD (it neither sets nor references resources that were set"}, {"sha": "aa7171b69981f3645758ccfdf7cb3a92484b853d", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d45cf215ee7cefef0044a6bd3ee1c2c7b2466039/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d45cf215ee7cefef0044a6bd3ee1c2c7b2466039", "patch": "@@ -108,7 +108,7 @@ typedef struct rtx_def\n      1 in a LABEL_REF if this is a reference to a label outside the\n      current loop.\n      1 in an INSN, JUMP_INSN, or CALL_INSN if this insn must be scheduled\n-     together with the preceeding insn.  Valid only within sched.\n+     together with the preceding insn.  Valid only within sched.\n      1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n      from the target of a branch.  Valid from reorg until end of compilation;\n      cleared before used.  */\n@@ -271,7 +271,7 @@ typedef struct rtvec_def{\n      REG_LABEL points to a CODE_LABEL.  Used by non-JUMP_INSNs to\n    say that the CODE_LABEL contained in the REG_LABEL note is used\n    by the insn.\n-    REG_DEP_ANTI is used in LOG_LINKS which represent anti (write after read)\n+     REG_DEP_ANTI is used in LOG_LINKS which represent anti (write after read)\n    dependencies.  REG_DEP_OUTPUT is used in LOG_LINKS which represent output\n    (write after write) dependencies.  Data dependencies, which are the only\n    type of LOG_LINK created by flow, are represented by a 0 reg note kind.  */\n@@ -433,7 +433,7 @@ extern char *note_insn_name[];\n #define REG_LOOP_TEST_P(RTX) ((RTX)->in_struct)\n \n /* During sched, for an insn, 1 means that the insn must be scheduled together\n-   with the preceeding insn.  */\n+   with the preceding insn.  */\n #define SCHED_GROUP_P(INSN) ((INSN)->in_struct)\n \n /* For a SET rtx, SET_DEST is the place that is set"}]}