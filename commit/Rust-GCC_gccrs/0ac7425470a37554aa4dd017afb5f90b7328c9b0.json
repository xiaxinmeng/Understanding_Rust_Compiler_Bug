{"sha": "0ac7425470a37554aa4dd017afb5f90b7328c9b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFjNzQyNTQ3MGEzNzU1NGFhNGRkMDE3YWZiNWY5MGI3MzI4YzliMA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-12-03T20:14:05Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-12-03T20:14:05Z"}, "message": "re PR fortran/36313 ([F03] {MIN,MAX}{LOC,VAL} should accept character arguments)\n\n2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36313\n\t* check.c (gfc_check_minval_maxval): Use\n\tint_orLreal_or_char_check_f2003 for array argument.\n\t* iresolve.c (gfc_resolve_maxval): Insert number in\n\tfunction name for character arguments.\n\t(gfc_resolve_minval): Likewise.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc):\n\tFix comment.\n\t(gfc_conv_intrinsic_minmaxval): Resort arguments and call library\n\tfunction if dealing with a character function.\n\n2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36313\n\t* Makefile.am: Add new files for character-valued\n\tmaxval and minval.\n\t* Makefile.in: Regenerated.\n\t* gfortran.map: Add new functions.\n\t* m4/iforeach-s2.m4: New file.\n\t* m4/ifunction-s2.m4: New file.\n\t* m4/iparm.m4: Add intitval for minval and maxval.\n\t* m4/maxval0s.m4: New file.\n\t* m4/maxval1s.m4: New file.\n\t* m4/minval0s.m4: New file.\n\t* m4/minval1s.m4: New file.\n        * generated/maxval0_s1.c: New file.\n        * generated/maxval0_s4.c: New file.\n        * generated/maxval1_s1.c: New file.\n        * generated/maxval1_s4.c: New file.\n        * generated/minval0_s1.c: New file.\n        * generated/minval0_s4.c: New file.\n        * generated/minval1_s1.c: New file.\n        * generated/minval1_s4.c: New file.\n\n2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/36313\n\t* gfortran.dg/maxval_char_1.f90: New test.\n\t* gfortran.dg/maxval_char_2.f90: New test.\n\t* gfortran.dg/maxval_char_3.f90: New test.\n\t* gfortran.dg/maxval_char_4.f90: New test.\n\t* gfortran.dg/minval_char_1.f90: New test.\n\t* gfortran.dg/minval_char_2.f90: New test.\n\t* gfortran.dg/minval_char_3.f90: New test.\n\t* gfortran.dg/minval_char_4.f90: New test.\n\nFrom-SVN: r255367", "tree": {"sha": "b31908b5003acf7307242caf1ae5698a3d2a3fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b31908b5003acf7307242caf1ae5698a3d2a3fb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ac7425470a37554aa4dd017afb5f90b7328c9b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac7425470a37554aa4dd017afb5f90b7328c9b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac7425470a37554aa4dd017afb5f90b7328c9b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac7425470a37554aa4dd017afb5f90b7328c9b0/comments", "author": null, "committer": null, "parents": [{"sha": "af5ad1e2e56a91db15c1f714f5f513ad54a07eeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af5ad1e2e56a91db15c1f714f5f513ad54a07eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af5ad1e2e56a91db15c1f714f5f513ad54a07eeb"}], "stats": {"total": 5018, "additions": 4988, "deletions": 30}, "files": [{"sha": "e0dd79514e8bb5f20f7446143a14af9abe35c025", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -1,3 +1,16 @@\n+2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36313\n+\t* check.c (gfc_check_minval_maxval): Use\n+\tint_orLreal_or_char_check_f2003 for array argument.\n+\t* iresolve.c (gfc_resolve_maxval): Insert number in\n+\tfunction name for character arguments.\n+\t(gfc_resolve_minval): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc):\n+\tFix comment.\n+\t(gfc_conv_intrinsic_minmaxval): Resort arguments and call library\n+\tfunction if dealing with a character function.\n+\n 2017-12-01  Qing Zhao  <qing.zhao@oracle.com>\n \n \t* decl.c (gfc_get_pdt_instance): Adjust the call to sprintf"}, {"sha": "eda740793bb81b5291218180740dfa6064cdc401", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -3317,7 +3317,7 @@ check_reduction (gfc_actual_arglist *ap)\n bool\n gfc_check_minval_maxval (gfc_actual_arglist *ap)\n {\n-  if (!int_or_real_check (ap->expr, 0)\n+  if (!int_or_real_or_char_check_f2003 (ap->expr, 0)\n       || !array_check (ap->expr, 0))\n     return false;\n "}, {"sha": "3226a88832d44c0246e6c9adce5f1e8be24dc9c7", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -1823,9 +1823,14 @@ gfc_resolve_maxval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   else\n     name = \"maxval\";\n \n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n-\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n+  if (array->ts.type != BT_CHARACTER)\n+    f->value.function.name\n+      = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n+\t\t\tgfc_type_letter (array->ts.type), array->ts.kind);\n+  else\n+    f->value.function.name\n+      = gfc_get_string (PREFIX (\"%s%d_%c%d\"), name, f->rank != 0,\n+\t\t\tgfc_type_letter (array->ts.type), array->ts.kind);     \n }\n \n \n@@ -2023,9 +2028,14 @@ gfc_resolve_minval (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n   else\n     name = \"minval\";\n \n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n-\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n+  if (array->ts.type != BT_CHARACTER)\n+    f->value.function.name\n+      = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n+\t\t\tgfc_type_letter (array->ts.type), array->ts.kind);\n+  else\n+    f->value.function.name\n+      = gfc_get_string (PREFIX (\"%s%d_%c%d\"), name, f->rank != 0,\n+\t\t\tgfc_type_letter (array->ts.type), array->ts.kind);     \n }\n \n "}, {"sha": "c4aad1d345255558cfc19da1985208216a7778fa", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -4571,7 +4571,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   actual = expr->value.function.actual;\n   arrayexpr = actual->expr;\n \n-  /* Special case for character maxval.  Remove unneeded actual\n+  /* Special case for character maxloc.  Remove unneeded actual\n      arguments, then call a library function.  */\n   \n   if (arrayexpr->ts.type == BT_CHARACTER)\n@@ -5039,6 +5039,34 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       return;\n     }\n \n+  actual = expr->value.function.actual;\n+  arrayexpr = actual->expr;\n+\n+  if (arrayexpr->ts.type == BT_CHARACTER)\n+    {\n+      gfc_actual_arglist *a2, *a3;\n+      a2 = actual->next;  /* dim */\n+      a3 = a2->next;      /* mask */\n+      if (a2->expr == NULL || expr->rank == 0)\n+\t{\n+\t  if (a3->expr == NULL)\n+\t    actual->next = NULL;\n+\t  else\n+\t    {\n+\t      actual->next = a3;\n+\t      a2->next = NULL;\n+\t    }\n+\t  gfc_free_actual_arglist (a2);\n+\t}\n+      else\n+\tif (a3->expr == NULL)\n+\t  {\n+\t    a2->next = NULL;\n+\t    gfc_free_actual_arglist (a3);\n+\t  }\n+      gfc_conv_intrinsic_funcall (se, expr);\n+      return;\n+    }\n   type = gfc_typenode_for_spec (&expr->ts);\n   /* Initialize the result.  */\n   limit = gfc_create_var (type, \"limit\");\n@@ -5087,8 +5115,6 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_add_modify (&se->pre, limit, tmp);\n \n   /* Walk the arguments.  */\n-  actual = expr->value.function.actual;\n-  arrayexpr = actual->expr;\n   arrayss = gfc_walk_expr (arrayexpr);\n   gcc_assert (arrayss != gfc_ss_terminator);\n "}, {"sha": "de46b385fa7a53dd480dd581b03e3d3136b254da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -1,3 +1,15 @@\n+2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36313\n+\t* gfortran.dg/maxval_char_1.f90: New test.\n+\t* gfortran.dg/maxval_char_2.f90: New test.\n+\t* gfortran.dg/maxval_char_3.f90: New test.\n+\t* gfortran.dg/maxval_char_4.f90: New test.\n+\t* gfortran.dg/minval_char_1.f90: New test.\n+\t* gfortran.dg/minval_char_2.f90: New test.\n+\t* gfortran.dg/minval_char_3.f90: New test.\n+\t* gfortran.dg/minval_char_4.f90: New test.\n+\n 2017-12-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/831916"}, {"sha": "24b5336ca835c79af934c08dbd679fa7807735c9", "filename": "gcc/testsuite/gfortran.dg/maxval_char_1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_1.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5, m=3\n+  character(len=5), dimension(n) :: a\n+  character(len=5), dimension(n,m) :: b\n+  character(len=5) :: res\n+  integer, dimension(n,m) :: v\n+  real, dimension(n,m) :: r\n+  integer :: i,j\n+  logical, dimension(n,m) :: mask\n+  character(len=5), dimension(:,:), allocatable :: empty\n+  character(len=5) , parameter :: all_zero = achar(0) // achar(0) // achar(0) // achar(0) // achar(0)\n+  logical :: smask\n+  \n+  write (unit=a,fmt='(I5.5)') (21-i*i+6*i,i=1,n)\n+  res = maxval(a)\n+  if (res /= '00030') call abort\n+  res = maxval(a,dim=1)\n+  if (res /= '00030') call abort\n+  do\n+    call random_number(r)\n+    if (count(r>0.2) > 1) exit\n+  end do\n+  v = int(r * 100)\n+  write (unit=b,fmt='(I5.5)') v\n+  write (unit=res,fmt='(I5.5)') maxval(v)\n+  if (res /= maxval(b)) call abort\n+  smask = .true.\n+  if (res /= maxval(b, smask)) call abort\n+  smask = .false.\n+  if (all_zero /= maxval(b, smask)) call abort\n+\n+  mask = v < 30\n+  write (unit=res,fmt='(I5.5)') maxval(v,mask)\n+  if (res /= maxval(b, mask)) call abort\n+  mask = .false.\n+  if (maxval(b, mask) /= all_zero) call abort\n+  allocate (empty(0:3,0))\n+  res = maxval(empty)\n+  if (res /= all_zero) call abort\n+end program main"}, {"sha": "750d18e59a874d5ed4ee1b1b8f1724a9a79ec131", "filename": "gcc/testsuite/gfortran.dg/maxval_char_2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_2.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5, m=3\n+  character(kind=4,len=5), dimension(n) :: a\n+  character(kind=4,len=5), dimension(n,m) :: b\n+  character(kind=4,len=5) :: res\n+  integer, dimension(n,m) :: v\n+  real, dimension(n,m) :: r\n+  integer :: i,j\n+  logical, dimension(n,m) :: mask\n+  character(kind=4,len=5), dimension(:,:), allocatable :: empty\n+  character(kind=4,len=5) , parameter :: all_zero = achar(0) // achar(0) // achar(0) // achar(0) // achar(0)\n+  logical :: smask\n+  \n+  write (unit=a,fmt='(I5.5)') (21-i*i+6*i,i=1,n)\n+  res = maxval(a)\n+  if (res /= 4_'00030') call abort\n+  do\n+     call random_number(r)\n+     if (count(r>0.2) > 1) exit\n+  end do\n+   v = int(r * 100)\n+  write (unit=b,fmt='(I5.5)') v\n+  write (unit=res,fmt='(I5.5)') maxval(v)\n+  if (res /= maxval(b)) call abort\n+  smask = .true.\n+  if (res /= maxval(b, smask)) call abort\n+  smask = .false.\n+  if (all_zero /= maxval(b, smask)) call abort\n+\n+  mask = v < 30\n+  write (unit=res,fmt='(I5.5)') maxval(v,mask)\n+  if (res /= maxval(b, mask)) call abort\n+  mask = .false.\n+  if (maxval(b, mask) /= all_zero) call abort\n+  allocate (empty(0:3,0))\n+  res = maxval(empty)\n+  if (res /= all_zero) call abort\n+end program main"}, {"sha": "3fd5aa559d4302c4383f443f61b04b39c4a75f44", "filename": "gcc/testsuite/gfortran.dg/maxval_char_3.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_3.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5\n+  character(len=6), dimension(n,n) :: a\n+  integer, dimension(n,n) :: v\n+  character(len=6), dimension(n) :: r1, r2\n+  character(len=6), dimension(:,:), allocatable :: a_alloc\n+  integer, dimension(:,:), allocatable :: v_alloc\n+  character(len=6), parameter :: zero = achar(0) // achar(0) // achar(0) // achar(0) // achar(0) // achar(0)\n+  integer :: i\n+  character(len=6),dimension(1) :: ret\n+  logical, dimension(n,n) :: mask\n+  logical :: smask\n+\n+  v = reshape([(i*i+200-17*i,i=1,n*n)],shape(v))\n+  write (unit=a,fmt='(I6.6)') (i*i+200-17*i,i=1,n*n)\n+\n+  r1 =  maxval(a,dim=1)\n+  write (unit=r2,fmt='(I6.6)') maxval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 'x'\n+  write (unit=r1,fmt='(I6.6)') maxval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  r1 = 'y'\n+  r1 =  maxval(a,dim=2)\n+  write (unit=r2,fmt='(I6.6)') maxval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 'z'\n+  write (unit=r1,fmt='(I6.6)') maxval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+\n+  allocate (a_alloc(0,1), v_alloc(0,1))\n+  ret = 'what'\n+  ret = maxval(a_alloc,dim=1)\n+  if (ret(1) /= zero) call abort\n+  \n+  r1 = 'qq'\n+  r1 = maxval(a, dim=1, mask=a>\"000200\");\n+  if (any(r1 /= zero .neqv. maxval(v,dim=1, mask=v>200) > 0)) call abort\n+  if (any(maxval(a, dim=1, mask=a>\"000200\") /= zero .neqv. maxval(v,dim=1, mask=v>200) > 0)) call abort\n+\n+  r1 = 'rr'\n+  r1 = maxval(a, dim=2, mask=a>\"000200\");\n+  if (any(r1 /= zero .neqv. maxval(v,dim=2, mask=v>200) > 0)) call abort\n+  if (any(maxval(a, dim=2, mask=a>\"000200\") /= zero .neqv. maxval(v,dim=2, mask=v>200) > 0)) call abort\n+\n+  mask = .true.\n+  forall (i=1:n)\n+     mask(i,i) = .false.\n+  end forall\n+\n+  r1 = 'aa'\n+  r1 = maxval(a, dim=1, mask=mask)\n+  write(unit=r2,fmt='(I6.6)') maxval(v,dim=1, mask=mask)\n+  if (any(r1 /= r2)) call abort\n+\n+  r1 = 'xyz'\n+  smask = .true.\n+  r1 = maxval(a, dim=1, mask=smask)\n+  write (unit=r2,fmt='(I6.6)') maxval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  smask = .false.\n+  r1 = 'foobar'\n+  r1 = maxval(a, dim=1, mask=smask)\n+  if (any(r1 /= zero)) call abort\n+end program main"}, {"sha": "076fba51284134bdfce9ab60c6c739497471e3c1", "filename": "gcc/testsuite/gfortran.dg/maxval_char_4.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxval_char_4.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5\n+  character(kind=4,len=6), dimension(n,n) :: a\n+  integer, dimension(n,n) :: v\n+  character(kind=4,len=6), dimension(n) :: r1, r2\n+  character(kind=4,len=6), dimension(:,:), allocatable :: a_alloc\n+  integer, dimension(:,:), allocatable :: v_alloc\n+  character(kind=4,len=6), parameter :: zero = achar(0,4) // achar(0,4) // achar(0,4) // achar(0,4) // achar(0,4) // achar(0,4)\n+  integer :: i\n+  character(kind=4,len=6),dimension(1) :: ret\n+  logical, dimension(n,n) :: mask\n+  logical :: smask\n+\n+  v = reshape([(i*i+200-17*i,i=1,n*n)],shape(v))\n+  write (unit=a,fmt='(I6.6)') (i*i+200-17*i,i=1,n*n)\n+\n+  r1 =  maxval(a,dim=1)\n+  write (unit=r2,fmt='(I6.6)') maxval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 4_'x'\n+  write (unit=r1,fmt='(I6.6)') maxval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  r1 = 4_'y'\n+  r1 =  maxval(a,dim=2)\n+  write (unit=r2,fmt='(I6.6)') maxval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 4_'z'\n+  write (unit=r1,fmt='(I6.6)') maxval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+\n+  allocate (a_alloc(0,1), v_alloc(0,1))\n+  ret = 4_'what'\n+  ret = maxval(a_alloc,dim=1)\n+  if (ret(1) /= zero) call abort\n+  \n+  r1 = 4_'qq'\n+  r1 = maxval(a, dim=1, mask=a>4_\"000200\");\n+  if (any(r1 /= zero .neqv. maxval(v,dim=1, mask=v>200) > 0)) call abort\n+  if (any(maxval(a, dim=1, mask=a>4_\"000200\") /= zero .neqv. maxval(v,dim=1, mask=v>200) > 0)) call abort\n+\n+  r1 = 4_'rr'\n+  r1 = maxval(a, dim=2, mask=a>4_\"000200\");\n+  if (any(r1 /= zero .neqv. maxval(v,dim=2, mask=v>200) > 0)) call abort\n+  if (any(maxval(a, dim=2, mask=a>4_\"000200\") /= zero .neqv. maxval(v,dim=2, mask=v>200) > 0)) call abort\n+\n+  mask = .true.\n+  forall (i=1:n)\n+     mask(i,i) = .false.\n+  end forall\n+\n+  r1 = 4_'aa'\n+  r1 = maxval(a, dim=1, mask=mask)\n+  write(unit=r2,fmt='(I6.6)') maxval(v,dim=1, mask=mask)\n+  if (any(r1 /= r2)) call abort\n+\n+  r1 = 4_'xyz'\n+  smask = .true.\n+  r1 = maxval(a, dim=1, mask=smask)\n+  write (unit=r2,fmt='(I6.6)') maxval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  smask = .false.\n+  r1 = 4_'foobar'\n+  r1 = maxval(a, dim=1, mask=smask)\n+  if (any(r1 /= zero)) call abort\n+end program main"}, {"sha": "6ffab4e98ba14daac17f05e05cac0e129d6cb6da", "filename": "gcc/testsuite/gfortran.dg/minval_char_1.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_1.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5, m=3\n+  character(len=5), dimension(n) :: a\n+  character(len=5), dimension(n,m) :: b\n+  character(len=5) :: res\n+  integer, dimension(n,m) :: v\n+  real, dimension(n,m) :: r\n+  integer :: i,j\n+  logical, dimension(n,m) :: mask\n+  character(len=5), dimension(:,:), allocatable :: empty\n+  character(len=5) , parameter :: all_full = achar(255) // achar(255) // achar(255) // achar(255) // achar(255)\n+  logical :: smask\n+  \n+  write (unit=a,fmt='(I5.5)') (21-i*i+6*i,i=1,n)\n+  res = minval(a)\n+  if (res /= '00026') call abort\n+  do\n+    call random_number(r)\n+    if (count(r<0.2) > 1) exit\n+  end do\n+  v = int(r * 100)\n+  write (unit=b,fmt='(I5.5)') v\n+  write (unit=res,fmt='(I5.5)') minval(v)\n+  if (res /= minval(b)) call abort\n+  smask = .true.\n+  if (res /= minval(b, smask)) call abort\n+  smask = .false.\n+  if (all_full /= minval(b, smask)) call abort\n+\n+  mask = v < 30\n+  write (unit=res,fmt='(I5.5)') minval(v,mask)\n+  if (res /= minval(b, mask)) call abort\n+  mask = .false.\n+  if (minval(b, mask) /= all_full) call abort\n+  allocate (empty(0:3,0))\n+  res = minval(empty)\n+  if (res /= all_full) call abort\n+end program main"}, {"sha": "82661f015aff1dea0fa0cb490493c9e814a8438e", "filename": "gcc/testsuite/gfortran.dg/minval_char_2.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_2.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5, m=3\n+  character(kind=4,len=5), dimension(n) :: a\n+  character(kind=4,len=5), dimension(n,m) :: b\n+  character(kind=4,len=5) :: res\n+  integer, dimension(n,m) :: v\n+  real, dimension(n,m) :: r\n+  integer :: i,j\n+  logical, dimension(n,m) :: mask\n+  character(kind=4,len=5), dimension(:,:), allocatable :: empty\n+  integer(kind=4), dimension(5) :: kmin = [-1, -1, -1, -1, -1]\n+  character(kind=4,len=5) :: all_full\n+  logical :: smask\n+  \n+  all_full = transfer(kmin,all_full)\n+  write (unit=a,fmt='(I5.5)') (21-i*i+6*i,i=1,n)\n+  res = minval(a)\n+  if (res /= 4_'00026') call abort\n+  do\n+     call random_number(r)\n+     if (count(r>0.2) > 1) exit\n+  end do\n+  v = int(r * 100)\n+  write (unit=b,fmt='(I5.5)') v\n+  write (unit=res,fmt='(I5.5)') minval(v)\n+  if (res /= minval(b)) call abort\n+  smask = .true.\n+  if (res /= minval(b, smask)) call abort\n+  smask = .false.\n+  if (all_full /= minval(b, smask)) call abort\n+\n+  mask = v < 30\n+  write (unit=res,fmt='(I5.5)') minval(v,mask)\n+  if (res /= minval(b, mask)) call abort\n+  mask = .false.\n+  if (minval(b, mask) /= all_full) call abort\n+  allocate (empty(0:3,0))\n+  res = minval(empty)\n+  if (res /= all_full) call abort\n+end program main"}, {"sha": "eea9aa6cd4c93071ab407bf77f551c4feb69cfb4", "filename": "gcc/testsuite/gfortran.dg/minval_char_3.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_3.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5\n+  character(len=6), dimension(n,n) :: a\n+  integer, dimension(n,n) :: v\n+  character(len=6), dimension(n) :: r1, r2\n+  character(len=6), dimension(:,:), allocatable :: a_alloc\n+  integer, dimension(:,:), allocatable :: v_alloc\n+  character(len=6), parameter :: all_full = achar(255) // achar(255) // achar(255) // achar(255) // achar(255) // achar(255)\n+  integer :: i\n+  character(len=6),dimension(1) :: ret\n+  logical, dimension(n,n) :: mask\n+  logical :: smask\n+\n+  v = reshape([(i*i+200-17*i,i=1,n*n)],shape(v))\n+  write (unit=a,fmt='(I6.6)') (i*i+200-17*i,i=1,n*n)\n+\n+  r1 =  minval(a,dim=1)\n+  write (unit=r2,fmt='(I6.6)') minval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 'x'\n+  write (unit=r1,fmt='(I6.6)') minval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  r1 = 'y'\n+  r1 =  minval(a,dim=2)\n+  write (unit=r2,fmt='(I6.6)') minval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 'z'\n+  write (unit=r1,fmt='(I6.6)') minval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+\n+  allocate (a_alloc(0,1), v_alloc(0,1))\n+  ret = 'what'\n+  ret = minval(a_alloc,dim=1)\n+  if (ret(1) /= all_full) call abort\n+  \n+  r1 = 'qq'\n+  r1 = minval(a, dim=1, mask=a>\"000200\");\n+  if (any(r1 /= all_full .neqv. minval(v,dim=1, mask=v>200) < 1000)) call abort\n+  if (any(minval(a, dim=1, mask=a>\"000200\") /= all_full .neqv. minval(v,dim=1, mask=v>200) < 1000)) call abort\n+\n+  r1 = 'rr'\n+  r1 = minval(a, dim=2, mask=a>\"000200\");\n+  if (any(r1 /= all_full .neqv. minval(v,dim=2, mask=v>200) < 1000)) call abort\n+  if (any(minval(a, dim=2, mask=a>\"000200\") /= all_full .neqv. minval(v,dim=2, mask=v>200) < 1000)) call abort\n+\n+  mask = .true.\n+  forall (i=1:n)\n+     mask(i,i) = .false.\n+  end forall\n+\n+  r1 = 'aa'\n+  r1 = minval(a, dim=1, mask=mask)\n+  write(unit=r2,fmt='(I6.6)') minval(v,dim=1, mask=mask)\n+  if (any(r1 /= r2)) call abort\n+\n+  r1 = 'xyz'\n+  smask = .true.\n+  r1 = minval(a, dim=1, mask=smask)\n+  write (unit=r2,fmt='(I6.6)') minval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  smask = .false.\n+  r1 = 'foobar'\n+  r1 = minval(a, dim=1, mask=smask)\n+  if (any(r1 /= all_full)) call abort\n+end program main"}, {"sha": "49176be033adab7641727eb6083625cb9433ef06", "filename": "gcc/testsuite/gfortran.dg/minval_char_4.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminval_char_4.f90?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n=5\n+  character(len=6,kind=4), dimension(n,n) :: a\n+  integer, dimension(n,n) :: v\n+  character(len=6,kind=4), dimension(n) :: r1, r2\n+  character(len=6,kind=4), dimension(:,:), allocatable :: a_alloc\n+  integer, dimension(:,:), allocatable :: v_alloc\n+  character(len=6,kind=4):: all_full\n+  integer :: i\n+  character(len=6,kind=4),dimension(1) :: ret\n+  logical, dimension(n,n) :: mask\n+  logical :: smask\n+  integer(kind=4), dimension(6) :: kmin\n+\n+  kmin = -1\n+  all_full = transfer(kmin,all_full)\n+  v = reshape([(i*i+200-17*i,i=1,n*n)],shape(v))\n+  write (unit=a,fmt='(I6.6)') (i*i+200-17*i,i=1,n*n)\n+\n+  r1 =  minval(a,dim=1)\n+  write (unit=r2,fmt='(I6.6)') minval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 4_'x'\n+  write (unit=r1,fmt='(I6.6)') minval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  r1 = 4_'y'\n+  r1 =  minval(a,dim=2)\n+  write (unit=r2,fmt='(I6.6)') minval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+  r1 = 4_'z'\n+  write (unit=r1,fmt='(I6.6)') minval(v,dim=2)\n+  if (any (r1 /= r2)) call abort\n+\n+  allocate (a_alloc(0,1), v_alloc(0,1))\n+  ret = 4_'what'\n+  ret = minval(a_alloc,dim=1)\n+  if (ret(1) /= all_full) call abort\n+  \n+  r1 = 4_'qq'\n+  r1 = minval(a, dim=1, mask=a>4_\"000200\");\n+  if (any(r1 /= all_full .neqv. minval(v,dim=1, mask=v>200) < 1000)) call abort\n+  if (any(minval(a, dim=1, mask=a>4_\"000200\") /= all_full .neqv. minval(v,dim=1, mask=v>200) < 1000)) call abort\n+\n+  r1 = 4_'rr'\n+  r1 = minval(a, dim=2, mask=a>4_\"000200\");\n+  if (any(r1 /= all_full .neqv. minval(v,dim=2, mask=v>200) < 1000)) call abort\n+  if (any(minval(a, dim=2, mask=a>4_\"000200\") /= all_full .neqv. minval(v,dim=2, mask=v>200) < 1000)) call abort\n+\n+  mask = .true.\n+  forall (i=1:n)\n+     mask(i,i) = .false.\n+  end forall\n+\n+  r1 = 4_'aa'\n+  r1 = minval(a, dim=1, mask=mask)\n+  write(unit=r2,fmt='(I6.6)') minval(v,dim=1, mask=mask)\n+  if (any(r1 /= r2)) call abort\n+\n+  r1 = 4_'xyz'\n+  smask = .true.\n+  r1 = minval(a, dim=1, mask=smask)\n+  write (unit=r2,fmt='(I6.6)') minval(v,dim=1)\n+  if (any (r1 /= r2)) call abort\n+\n+  smask = .false.\n+  r1 = 4_'foobar'\n+  r1 = minval(a, dim=1, mask=smask)\n+  if (any(r1 /= all_full)) call abort\n+end program main"}, {"sha": "55867f02a2d24b8178bd3cd8baace227ea7922b4", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -1,3 +1,26 @@\n+2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/36313\n+\t* Makefile.am: Add new files for character-valued\n+\tmaxval and minval.\n+\t* Makefile.in: Regenerated.\n+\t* gfortran.map: Add new functions.\n+\t* m4/iforeach-s2.m4: New file.\n+\t* m4/ifunction-s2.m4: New file.\n+\t* m4/iparm.m4: Add intitval for minval and maxval.\n+\t* m4/maxval0s.m4: New file.\n+\t* m4/maxval1s.m4: New file.\n+\t* m4/minval0s.m4: New file.\n+\t* m4/minval1s.m4: New file.\n+        * generated/maxval0_s1.c: New file.\n+        * generated/maxval0_s4.c: New file.\n+        * generated/maxval1_s1.c: New file.\n+        * generated/maxval1_s4.c: New file.\n+        * generated/minval0_s1.c: New file.\n+        * generated/minval0_s4.c: New file.\n+        * generated/minval1_s1.c: New file.\n+        * generated/minval1_s4.c: New file.\n+\n 2017-12-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \t    Dominique d'Humieres  <dominiq@lps.ens.fr>\n "}, {"sha": "bf9dce40593f1073821a337c1cf59b0e8a8086e8", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -357,6 +357,14 @@ $(srcdir)/generated/maxval_r8.c \\\n $(srcdir)/generated/maxval_r10.c \\\n $(srcdir)/generated/maxval_r16.c\n \n+i_maxval0s_c=\\\n+$(srcdir)/generated/maxval0_s1.c \\\n+$(srcdir)/generated/maxval0_s4.c\n+\n+i_maxval1s_c=\\\n+$(srcdir)/generated/maxval1_s1.c \\\n+$(srcdir)/generated/maxval1_s4.c\n+\n i_minloc0_c= \\\n $(srcdir)/generated/minloc0_4_i1.c \\\n $(srcdir)/generated/minloc0_8_i1.c \\\n@@ -450,6 +458,14 @@ $(srcdir)/generated/minval_r8.c \\\n $(srcdir)/generated/minval_r10.c \\\n $(srcdir)/generated/minval_r16.c\n \n+i_minval0s_c=\\\n+$(srcdir)/generated/minval0_s1.c \\\n+$(srcdir)/generated/minval0_s4.c\n+\n+i_minval1s_c=\\\n+$(srcdir)/generated/minval1_s1.c \\\n+$(srcdir)/generated/minval1_s4.c\n+\n i_norm2_c= \\\n $(srcdir)/generated/norm2_r4.c \\\n $(srcdir)/generated/norm2_r8.c \\\n@@ -748,7 +764,8 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n     $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n-    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c)\n+    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n+    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c)\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n@@ -973,6 +990,8 @@ I_M4_DEPS1=$(I_M4_DEPS) m4/ifunction.m4\n I_M4_DEPS2=$(I_M4_DEPS) m4/ifunction_logical.m4\n I_M4_DEPS3=$(I_M4_DEPS) m4/iforeach-s.m4\n I_M4_DEPS4=$(I_M4_DEPS) m4/ifunction-s.m4\n+I_M4_DEPS5=$(I_M4_DEPS) m4/iforeach-s2.m4\n+I_M4_DEPS6=$(I_M4_DEPS) m4/ifunction-s2.m4\n \n kinds.h: $(srcdir)/mk-kinds-h.sh\n \t$(SHELL) $(srcdir)/mk-kinds-h.sh '$(FCCOMPILE)' > $@ || rm $@\n@@ -1039,6 +1058,12 @@ $(i_maxloc2s_c): m4/maxloc2s.m4 $(I_M4_DEPS)\n $(i_maxval_c): m4/maxval.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval.m4 > $@\n \n+$(i_maxval0s_c): m4/maxval0s.m4 $(I_M4_DEPS5)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval0s.m4 > $@\n+\n+$(i_maxval1s_c): m4/maxval1s.m4 $(I_M4_DEPS6)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval1s.m4 > $@\n+\n $(i_minloc0_c): m4/minloc0.m4 $(I_M4_DEPS0)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc0.m4 > $@\n \n@@ -1057,6 +1082,12 @@ $(i_minloc2s_c): m4/minloc2s.m4 $(I_M4_DEPS)\n $(i_minval_c): m4/minval.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval.m4 > $@\n \n+$(i_minval0s_c): m4/minval0s.m4 $(I_M4_DEPS5)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval0s.m4 > $@\n+\n+$(i_minval1s_c): m4/minval1s.m4 $(I_M4_DEPS6)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval1s.m4 > $@\n+\n $(i_product_c): m4/product.m4 $(I_M4_DEPS1)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 product.m4 > $@\n "}, {"sha": "03c3968732a789fbdd04f0e8b5260cafa8927baf", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 120, "deletions": 19, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -329,7 +329,11 @@ am__objects_41 = maxloc2_4_s1.lo maxloc2_4_s4.lo maxloc2_8_s1.lo \\\n \tmaxloc2_8_s4.lo maxloc2_16_s1.lo maxloc2_16_s4.lo\n am__objects_42 = minloc2_4_s1.lo minloc2_4_s4.lo minloc2_8_s1.lo \\\n \tminloc2_8_s4.lo minloc2_16_s1.lo minloc2_16_s4.lo\n-am__objects_43 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n+am__objects_43 = maxval0_s1.lo maxval0_s4.lo\n+am__objects_44 = minval0_s1.lo minval0_s4.lo\n+am__objects_45 = maxval1_s1.lo maxval1_s4.lo\n+am__objects_46 = minval1_s1.lo minval1_s4.lo\n+am__objects_47 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n@@ -341,14 +345,16 @@ am__objects_43 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_31) $(am__objects_32) $(am__objects_33) \\\n \t$(am__objects_34) $(am__objects_35) $(am__objects_36) \\\n \t$(am__objects_37) $(am__objects_38) $(am__objects_39) \\\n-\t$(am__objects_40) $(am__objects_41) $(am__objects_42)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_44 = close.lo file_pos.lo format.lo \\\n+\t$(am__objects_40) $(am__objects_41) $(am__objects_42) \\\n+\t$(am__objects_43) $(am__objects_44) $(am__objects_45) \\\n+\t$(am__objects_46)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_48 = close.lo file_pos.lo format.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tfbuf.lo\n-am__objects_45 = size_from_kind.lo $(am__objects_44)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_46 = access.lo c99_functions.lo \\\n+am__objects_49 = size_from_kind.lo $(am__objects_48)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_50 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tctime.lo date_and_time.lo dtime.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tenv.lo etime.lo execute_command_line.lo \\\n@@ -358,19 +364,19 @@ am__objects_45 = size_from_kind.lo $(am__objects_44)\n @LIBGFOR_MINIMAL_FALSE@\trename.lo stat.lo symlnk.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tsystem_clock.lo time.lo umask.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tunlink.lo\n-@IEEE_SUPPORT_TRUE@am__objects_47 = ieee_helper.lo\n-am__objects_48 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_51 = ieee_helper.lo\n+am__objects_52 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \teoshift2.lo erfc_scaled.lo extends_type_of.lo fnum.lo \\\n \tierrno.lo ishftc.lo mvbits.lo move_alloc.lo pack_generic.lo \\\n \tselected_char_kind.lo size.lo spread_generic.lo \\\n \tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n \treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n \tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\t$(am__objects_46) $(am__objects_47)\n-@IEEE_SUPPORT_TRUE@am__objects_49 = ieee_arithmetic.lo \\\n+\t$(am__objects_50) $(am__objects_51)\n+@IEEE_SUPPORT_TRUE@am__objects_53 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n-am__objects_50 =\n-am__objects_51 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_54 =\n+am__objects_55 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -394,19 +400,19 @@ am__objects_51 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_52 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_56 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_53 = misc_specifics.lo\n-am__objects_54 = $(am__objects_51) $(am__objects_52) $(am__objects_53) \\\n+am__objects_57 = misc_specifics.lo\n+am__objects_58 = $(am__objects_55) $(am__objects_56) $(am__objects_57) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_55 = $(am__objects_3) $(am__objects_43) $(am__objects_45) \\\n-\t$(am__objects_48) $(am__objects_49) $(am__objects_50) \\\n-\t$(am__objects_54)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_55)\n+am__objects_59 = $(am__objects_3) $(am__objects_47) $(am__objects_49) \\\n+\t$(am__objects_52) $(am__objects_53) $(am__objects_54) \\\n+\t$(am__objects_58)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_59)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -810,6 +816,14 @@ $(srcdir)/generated/maxval_r8.c \\\n $(srcdir)/generated/maxval_r10.c \\\n $(srcdir)/generated/maxval_r16.c\n \n+i_maxval0s_c = \\\n+$(srcdir)/generated/maxval0_s1.c \\\n+$(srcdir)/generated/maxval0_s4.c\n+\n+i_maxval1s_c = \\\n+$(srcdir)/generated/maxval1_s1.c \\\n+$(srcdir)/generated/maxval1_s4.c\n+\n i_minloc0_c = \\\n $(srcdir)/generated/minloc0_4_i1.c \\\n $(srcdir)/generated/minloc0_8_i1.c \\\n@@ -903,6 +917,14 @@ $(srcdir)/generated/minval_r8.c \\\n $(srcdir)/generated/minval_r10.c \\\n $(srcdir)/generated/minval_r16.c\n \n+i_minval0s_c = \\\n+$(srcdir)/generated/minval0_s1.c \\\n+$(srcdir)/generated/minval0_s4.c\n+\n+i_minval1s_c = \\\n+$(srcdir)/generated/minval1_s1.c \\\n+$(srcdir)/generated/minval1_s4.c\n+\n i_norm2_c = \\\n $(srcdir)/generated/norm2_r4.c \\\n $(srcdir)/generated/norm2_r8.c \\\n@@ -1201,7 +1223,8 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n     $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n-    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c)\n+    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n+    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c)\n \n \n # Machine generated specifics\n@@ -1379,6 +1402,8 @@ I_M4_DEPS1 = $(I_M4_DEPS) m4/ifunction.m4\n I_M4_DEPS2 = $(I_M4_DEPS) m4/ifunction_logical.m4\n I_M4_DEPS3 = $(I_M4_DEPS) m4/iforeach-s.m4\n I_M4_DEPS4 = $(I_M4_DEPS) m4/ifunction-s.m4\n+I_M4_DEPS5 = $(I_M4_DEPS) m4/iforeach-s2.m4\n+I_M4_DEPS6 = $(I_M4_DEPS) m4/ifunction-s2.m4\n EXTRA_DIST = $(m4_files)\n all: $(BUILT_SOURCES) config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n@@ -1784,6 +1809,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_4_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_8_s1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxloc2_8_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval0_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval0_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval1_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval1_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/maxval_i2.Plo@am__quote@\n@@ -1867,6 +1896,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_4_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_8_s1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minloc2_8_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval0_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval0_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval1_s1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval1_s4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval_i1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval_i16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/minval_i2.Plo@am__quote@\n@@ -5612,6 +5645,62 @@ minloc2_16_s4.lo: $(srcdir)/generated/minloc2_16_s4.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minloc2_16_s4.lo `test -f '$(srcdir)/generated/minloc2_16_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minloc2_16_s4.c\n \n+maxval0_s1.lo: $(srcdir)/generated/maxval0_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxval0_s1.lo -MD -MP -MF $(DEPDIR)/maxval0_s1.Tpo -c -o maxval0_s1.lo `test -f '$(srcdir)/generated/maxval0_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval0_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxval0_s1.Tpo $(DEPDIR)/maxval0_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxval0_s1.c' object='maxval0_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxval0_s1.lo `test -f '$(srcdir)/generated/maxval0_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval0_s1.c\n+\n+maxval0_s4.lo: $(srcdir)/generated/maxval0_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxval0_s4.lo -MD -MP -MF $(DEPDIR)/maxval0_s4.Tpo -c -o maxval0_s4.lo `test -f '$(srcdir)/generated/maxval0_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval0_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxval0_s4.Tpo $(DEPDIR)/maxval0_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxval0_s4.c' object='maxval0_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxval0_s4.lo `test -f '$(srcdir)/generated/maxval0_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval0_s4.c\n+\n+minval0_s1.lo: $(srcdir)/generated/minval0_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minval0_s1.lo -MD -MP -MF $(DEPDIR)/minval0_s1.Tpo -c -o minval0_s1.lo `test -f '$(srcdir)/generated/minval0_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval0_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minval0_s1.Tpo $(DEPDIR)/minval0_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minval0_s1.c' object='minval0_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minval0_s1.lo `test -f '$(srcdir)/generated/minval0_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval0_s1.c\n+\n+minval0_s4.lo: $(srcdir)/generated/minval0_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minval0_s4.lo -MD -MP -MF $(DEPDIR)/minval0_s4.Tpo -c -o minval0_s4.lo `test -f '$(srcdir)/generated/minval0_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval0_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minval0_s4.Tpo $(DEPDIR)/minval0_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minval0_s4.c' object='minval0_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minval0_s4.lo `test -f '$(srcdir)/generated/minval0_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval0_s4.c\n+\n+maxval1_s1.lo: $(srcdir)/generated/maxval1_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxval1_s1.lo -MD -MP -MF $(DEPDIR)/maxval1_s1.Tpo -c -o maxval1_s1.lo `test -f '$(srcdir)/generated/maxval1_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval1_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxval1_s1.Tpo $(DEPDIR)/maxval1_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxval1_s1.c' object='maxval1_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxval1_s1.lo `test -f '$(srcdir)/generated/maxval1_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval1_s1.c\n+\n+maxval1_s4.lo: $(srcdir)/generated/maxval1_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxval1_s4.lo -MD -MP -MF $(DEPDIR)/maxval1_s4.Tpo -c -o maxval1_s4.lo `test -f '$(srcdir)/generated/maxval1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval1_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/maxval1_s4.Tpo $(DEPDIR)/maxval1_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/maxval1_s4.c' object='maxval1_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o maxval1_s4.lo `test -f '$(srcdir)/generated/maxval1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxval1_s4.c\n+\n+minval1_s1.lo: $(srcdir)/generated/minval1_s1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minval1_s1.lo -MD -MP -MF $(DEPDIR)/minval1_s1.Tpo -c -o minval1_s1.lo `test -f '$(srcdir)/generated/minval1_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval1_s1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minval1_s1.Tpo $(DEPDIR)/minval1_s1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minval1_s1.c' object='minval1_s1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minval1_s1.lo `test -f '$(srcdir)/generated/minval1_s1.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval1_s1.c\n+\n+minval1_s4.lo: $(srcdir)/generated/minval1_s4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT minval1_s4.lo -MD -MP -MF $(DEPDIR)/minval1_s4.Tpo -c -o minval1_s4.lo `test -f '$(srcdir)/generated/minval1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval1_s4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/minval1_s4.Tpo $(DEPDIR)/minval1_s4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/minval1_s4.c' object='minval1_s4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o minval1_s4.lo `test -f '$(srcdir)/generated/minval1_s4.c' || echo '$(srcdir)/'`$(srcdir)/generated/minval1_s4.c\n+\n size_from_kind.lo: io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT size_from_kind.lo -MD -MP -MF $(DEPDIR)/size_from_kind.Tpo -c -o size_from_kind.lo `test -f 'io/size_from_kind.c' || echo '$(srcdir)/'`io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/size_from_kind.Tpo $(DEPDIR)/size_from_kind.Plo\n@@ -6507,6 +6596,12 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_maxval_c): m4/maxval.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_maxval0s_c): m4/maxval0s.m4 $(I_M4_DEPS5)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval0s.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_maxval1s_c): m4/maxval1s.m4 $(I_M4_DEPS6)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxval1s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_minloc0_c): m4/minloc0.m4 $(I_M4_DEPS0)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minloc0.m4 > $@\n \n@@ -6525,6 +6620,12 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_minval_c): m4/minval.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_minval0s_c): m4/minval0s.m4 $(I_M4_DEPS5)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval0s.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_minval1s_c): m4/minval1s.m4 $(I_M4_DEPS6)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 minval1s.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_product_c): m4/product.m4 $(I_M4_DEPS1)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 product.m4 > $@\n "}, {"sha": "4ed9258b205280e83677377bcd1e1930aacf68c0", "filename": "libgfortran/generated/maxval0_s1.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval0_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval0_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval0_s1.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,258 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+#define INITVAL 0\n+\n+extern void maxval0_s1 (GFC_INTEGER_1 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s1 * const restrict array, gfc_charlen_type);\n+export_proto(maxval0_s1);\n+\n+void\n+maxval0_s1 (GFC_INTEGER_1 * restrict ret,\n+        gfc_charlen_type xlen,\n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 *base;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+  /* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  base = array->base_addr;\n+\n+  {\n+\n+  const GFC_INTEGER_1 *retval;\n+   retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, retval, len) > 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+   memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void mmaxval0_s1 (GFC_INTEGER_1 * restrict,\n+       gfc_charlen_type, gfc_array_s1 * const restrict array,\n+       gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n+export_proto(mmaxval0_s1);\n+\n+void\n+mmaxval0_s1 (GFC_INTEGER_1 * const restrict ret,\n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+/* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  {\n+\n+  const GFC_INTEGER_1 *retval;\n+\n+  retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && compare_fcn (base, retval, len) > 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+    memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void smaxval0_s1 (GFC_INTEGER_1 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxval0_s1);\n+\n+void\n+smaxval0_s1 (GFC_INTEGER_1 * restrict ret,\n+        gfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\n+{\n+  if (*mask)\n+    {\n+      maxval0_s1 (ret, xlen, array, len);\n+      return;\n+    }\n+  memset (ret, INITVAL, sizeof (*ret) * len);\n+}\n+\n+#endif"}, {"sha": "689b170acb1bcb32eaecf4e9cd56662c0145ca5e", "filename": "libgfortran/generated/maxval0_s4.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval0_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval0_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval0_s4.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,258 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+#define INITVAL 0\n+\n+extern void maxval0_s4 (GFC_INTEGER_4 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s4 * const restrict array, gfc_charlen_type);\n+export_proto(maxval0_s4);\n+\n+void\n+maxval0_s4 (GFC_INTEGER_4 * restrict ret,\n+        gfc_charlen_type xlen,\n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 *base;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+  /* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  base = array->base_addr;\n+\n+  {\n+\n+  const GFC_INTEGER_4 *retval;\n+   retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, retval, len) > 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+   memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void mmaxval0_s4 (GFC_INTEGER_4 * restrict,\n+       gfc_charlen_type, gfc_array_s4 * const restrict array,\n+       gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n+export_proto(mmaxval0_s4);\n+\n+void\n+mmaxval0_s4 (GFC_INTEGER_4 * const restrict ret,\n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+/* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  {\n+\n+  const GFC_INTEGER_4 *retval;\n+\n+  retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && compare_fcn (base, retval, len) > 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+    memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void smaxval0_s4 (GFC_INTEGER_4 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(smaxval0_s4);\n+\n+void\n+smaxval0_s4 (GFC_INTEGER_4 * restrict ret,\n+        gfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\n+{\n+  if (*mask)\n+    {\n+      maxval0_s4 (ret, xlen, array, len);\n+      return;\n+    }\n+  memset (ret, INITVAL, sizeof (*ret) * len);\n+}\n+\n+#endif"}, {"sha": "b9da5a388b76fa07f546d2c28f75112d6622efde", "filename": "libgfortran/generated/maxval1_s1.c", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval1_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval1_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval1_s1.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,560 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxval1_s1 (gfc_array_s1 * const restrict,\n+        gfc_charlen_type, gfc_array_s1 * const restrict,\n+\tconst index_type * const restrict, gfc_charlen_type);\n+export_proto(maxval1_s1);\n+\n+void\n+maxval1_s1 (gfc_array_s1 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  assert (xlen == string_len);\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *retval;\n+\tretval = base;\n+\tif (len <= 0)\n+\t  memset (dest, 0, sizeof (*dest) * string_len);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, retval, string_len) > 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      }\n+\t    \n+\t    memcpy (dest, retval, sizeof (*dest) * string_len);\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxval1_s1 (gfc_array_s1 * const restrict,\n+        gfc_charlen_type, gfc_array_s1 * const restrict,\n+\tconst index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxval1_s1);\n+\n+void\n+mmaxval1_s1 (gfc_array_s1 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tgfc_array_l1 * const restrict mask,\n+\tgfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  assert (xlen == string_len);\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *retval;\n+\tmemset (dest, 0, sizeof (*dest) * string_len);\n+\tretval = dest;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tretval = src;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, retval, string_len) > 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      \n+\t  }\n+\tmemcpy (dest, retval, sizeof (*dest) * string_len);\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+void smaxval1_s1 (gfc_array_s1 * const restrict,\n+        gfc_charlen_type, gfc_array_s1 * const restrict,\n+\tconst index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\n+export_proto(smaxval1_s1);\n+\n+void\n+smaxval1_s1 (gfc_array_s1 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxval1_s1 (retarray, xlen, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      memset (dest, 0, sizeof (*dest) * string_len);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "e98ea71c2724b020c570e8e70213d19fc038221b", "filename": "libgfortran/generated/maxval1_s4.c", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval1_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fmaxval1_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval1_s4.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,560 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void maxval1_s4 (gfc_array_s4 * const restrict,\n+        gfc_charlen_type, gfc_array_s4 * const restrict,\n+\tconst index_type * const restrict, gfc_charlen_type);\n+export_proto(maxval1_s4);\n+\n+void\n+maxval1_s4 (gfc_array_s4 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  assert (xlen == string_len);\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *retval;\n+\tretval = base;\n+\tif (len <= 0)\n+\t  memset (dest, 0, sizeof (*dest) * string_len);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, retval, string_len) > 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      }\n+\t    \n+\t    memcpy (dest, retval, sizeof (*dest) * string_len);\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxval1_s4 (gfc_array_s4 * const restrict,\n+        gfc_charlen_type, gfc_array_s4 * const restrict,\n+\tconst index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mmaxval1_s4);\n+\n+void\n+mmaxval1_s4 (gfc_array_s4 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tgfc_array_l1 * const restrict mask,\n+\tgfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  assert (xlen == string_len);\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *retval;\n+\tmemset (dest, 0, sizeof (*dest) * string_len);\n+\tretval = dest;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tretval = src;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, retval, string_len) > 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      \n+\t  }\n+\tmemcpy (dest, retval, sizeof (*dest) * string_len);\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+void smaxval1_s4 (gfc_array_s4 * const restrict,\n+        gfc_charlen_type, gfc_array_s4 * const restrict,\n+\tconst index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\n+export_proto(smaxval1_s4);\n+\n+void\n+smaxval1_s4 (gfc_array_s4 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      maxval1_s4 (retarray, xlen, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      memset (dest, 0, sizeof (*dest) * string_len);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "311c9bda9263176c4a5f9119f218d9aa4cde697a", "filename": "libgfortran/generated/minval0_s1.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval0_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval0_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval0_s1.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,258 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+#define INITVAL 255\n+\n+extern void minval0_s1 (GFC_INTEGER_1 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s1 * const restrict array, gfc_charlen_type);\n+export_proto(minval0_s1);\n+\n+void\n+minval0_s1 (GFC_INTEGER_1 * restrict ret,\n+        gfc_charlen_type xlen,\n+\tgfc_array_s1 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 *base;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+  /* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  base = array->base_addr;\n+\n+  {\n+\n+  const GFC_INTEGER_1 *retval;\n+   retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, retval, len) < 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+   memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void mminval0_s1 (GFC_INTEGER_1 * restrict,\n+       gfc_charlen_type, gfc_array_s1 * const restrict array,\n+       gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n+export_proto(mminval0_s1);\n+\n+void\n+mminval0_s1 (GFC_INTEGER_1 * const restrict ret,\n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+/* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  {\n+\n+  const GFC_INTEGER_1 *retval;\n+\n+  retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && compare_fcn (base, retval, len) < 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+    memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void sminval0_s1 (GFC_INTEGER_1 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s1 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminval0_s1);\n+\n+void\n+sminval0_s1 (GFC_INTEGER_1 * restrict ret,\n+        gfc_charlen_type xlen, gfc_array_s1 * const restrict array,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\n+{\n+  if (*mask)\n+    {\n+      minval0_s1 (ret, xlen, array, len);\n+      return;\n+    }\n+  memset (ret, INITVAL, sizeof (*ret) * len);\n+}\n+\n+#endif"}, {"sha": "a2c44afaaf0a28eddedce987d53450278039bdda", "filename": "libgfortran/generated/minval0_s4.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval0_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval0_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval0_s4.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,258 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+#define INITVAL 255\n+\n+extern void minval0_s4 (GFC_INTEGER_4 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s4 * const restrict array, gfc_charlen_type);\n+export_proto(minval0_s4);\n+\n+void\n+minval0_s4 (GFC_INTEGER_4 * restrict ret,\n+        gfc_charlen_type xlen,\n+\tgfc_array_s4 * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 *base;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+  /* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  base = array->base_addr;\n+\n+  {\n+\n+  const GFC_INTEGER_4 *retval;\n+   retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (compare_fcn (base, retval, len) < 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+   memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void mminval0_s4 (GFC_INTEGER_4 * restrict,\n+       gfc_charlen_type, gfc_array_s4 * const restrict array,\n+       gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n+export_proto(mminval0_s4);\n+\n+void\n+mminval0_s4 (GFC_INTEGER_4 * const restrict ret,\n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+/* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  {\n+\n+  const GFC_INTEGER_4 *retval;\n+\n+  retval = ret;\n+\n+  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+\n+  if (*mbase && compare_fcn (base, retval, len) < 0)\n+    {\n+      retval = base;\n+    }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+    memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}\n+\n+\n+extern void sminval0_s4 (GFC_INTEGER_4 * restrict,\n+        gfc_charlen_type,\n+\tgfc_array_s4 * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(sminval0_s4);\n+\n+void\n+sminval0_s4 (GFC_INTEGER_4 * restrict ret,\n+        gfc_charlen_type xlen, gfc_array_s4 * const restrict array,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\n+{\n+  if (*mask)\n+    {\n+      minval0_s4 (ret, xlen, array, len);\n+      return;\n+    }\n+  memset (ret, INITVAL, sizeof (*ret) * len);\n+}\n+\n+#endif"}, {"sha": "02eb41eea0a9ff5c6a3fe9899b7b727c025ee73d", "filename": "libgfortran/generated/minval1_s1.c", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval1_s1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval1_s1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval1_s1.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,560 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_1 *a, const GFC_INTEGER_1 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_1) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minval1_s1 (gfc_array_s1 * const restrict,\n+        gfc_charlen_type, gfc_array_s1 * const restrict,\n+\tconst index_type * const restrict, gfc_charlen_type);\n+export_proto(minval1_s1);\n+\n+void\n+minval1_s1 (gfc_array_s1 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  assert (xlen == string_len);\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_1 *retval;\n+\tretval = base;\n+\tif (len <= 0)\n+\t  memset (dest, 255, sizeof (*dest) * string_len);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, retval, string_len) < 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      }\n+\t    \n+\t    memcpy (dest, retval, sizeof (*dest) * string_len);\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminval1_s1 (gfc_array_s1 * const restrict,\n+        gfc_charlen_type, gfc_array_s1 * const restrict,\n+\tconst index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminval1_s1);\n+\n+void\n+mminval1_s1 (gfc_array_s1 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tgfc_array_l1 * const restrict mask,\n+\tgfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  assert (xlen == string_len);\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_1 *retval;\n+\tmemset (dest, 255, sizeof (*dest) * string_len);\n+\tretval = dest;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tretval = src;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, retval, string_len) < 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      \n+\t  }\n+\tmemcpy (dest, retval, sizeof (*dest) * string_len);\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+void sminval1_s1 (gfc_array_s1 * const restrict,\n+        gfc_charlen_type, gfc_array_s1 * const restrict,\n+\tconst index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\n+export_proto(sminval1_s1);\n+\n+void\n+sminval1_s1 (gfc_array_s1 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s1 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minval1_s1 (retarray, xlen, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_1));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      memset (dest, 255, sizeof (*dest) * string_len);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "b6a794ea4a4c1410cb0a0015f3c9da98478bc29e", "filename": "libgfortran/generated/minval1_s4.c", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval1_s4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgenerated%2Fminval1_s4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval1_s4.c?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,560 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+#include <string.h>\n+#include <assert.h>\n+\n+static inline int\n+compare_fcn (const GFC_INTEGER_4 *a, const GFC_INTEGER_4 *b, gfc_charlen_type n)\n+{\n+  if (sizeof (GFC_INTEGER_4) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void minval1_s4 (gfc_array_s4 * const restrict,\n+        gfc_charlen_type, gfc_array_s4 * const restrict,\n+\tconst index_type * const restrict, gfc_charlen_type);\n+export_proto(minval1_s4);\n+\n+void\n+minval1_s4 (gfc_array_s4 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  assert (xlen == string_len);\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      src = base;\n+      {\n+\n+\tconst GFC_INTEGER_4 *retval;\n+\tretval = base;\n+\tif (len <= 0)\n+\t  memset (dest, 255, sizeof (*dest) * string_len);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+\t\tif (compare_fcn (src, retval, string_len) < 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      }\n+\t    \n+\t    memcpy (dest, retval, sizeof (*dest) * string_len);\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminval1_s4 (gfc_array_s4 * const restrict,\n+        gfc_charlen_type, gfc_array_s4 * const restrict,\n+\tconst index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(mminval1_s4);\n+\n+void\n+mminval1_s4 (gfc_array_s4 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tgfc_array_l1 * const restrict mask,\n+\tgfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  assert (xlen == string_len);\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tconst GFC_INTEGER_4 *retval;\n+\tmemset (dest, 255, sizeof (*dest) * string_len);\n+\tretval = dest;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t      {\n+\t\t\tretval = src;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, retval, string_len) < 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      \n+\t  }\n+\tmemcpy (dest, retval, sizeof (*dest) * string_len);\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+void sminval1_s4 (gfc_array_s4 * const restrict,\n+        gfc_charlen_type, gfc_array_s4 * const restrict,\n+\tconst index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\n+export_proto(sminval1_s4);\n+\n+void\n+sminval1_s4 (gfc_array_s4 * const restrict retarray, \n+\tgfc_charlen_type xlen, gfc_array_s4 * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      minval1_s4 (retarray, xlen, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      memset (dest, 255, sizeof (*dest) * string_len);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "d3403af0dac1a277604f29b5587d9f740cb6612a", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -420,6 +420,10 @@ GFORTRAN_8 {\n     _gfortran_maxloc2_4_s4;\n     _gfortran_maxloc2_8_s1;\n     _gfortran_maxloc2_8_s4;\n+    _gfortran_maxval0_s1;\n+    _gfortran_maxval0_s4;\n+    _gfortran_maxval1_s1;\n+    _gfortran_maxval1_s4;\n     _gfortran_maxval_i16;\n     _gfortran_maxval_i1;\n     _gfortran_maxval_i2;\n@@ -513,6 +517,10 @@ GFORTRAN_8 {\n     _gfortran_minloc2_4_s4;\n     _gfortran_minloc2_8_s1;\n     _gfortran_minloc2_8_s4;\n+    _gfortran_minval0_s1;\n+    _gfortran_minval0_s4;\n+    _gfortran_minval1_s1;\n+    _gfortran_minval1_s4;\n     _gfortran_minval_i16;\n     _gfortran_minval_i1;\n     _gfortran_minval_i2;\n@@ -599,6 +607,10 @@ GFORTRAN_8 {\n     _gfortran_mmaxloc2_4_s4;\n     _gfortran_mmaxloc2_8_s1;\n     _gfortran_mmaxloc2_8_s4;\n+    _gfortran_mmaxval0_s1;\n+    _gfortran_mmaxval0_s4;\n+    _gfortran_mmaxval1_s1;\n+    _gfortran_mmaxval1_s4;\n     _gfortran_mmaxval_i16;\n     _gfortran_mmaxval_i1;\n     _gfortran_mmaxval_i2;\n@@ -680,6 +692,10 @@ GFORTRAN_8 {\n     _gfortran_mminloc2_4_s4;\n     _gfortran_mminloc2_8_s1;\n     _gfortran_mminloc2_8_s4;\n+    _gfortran_mminval0_s1;\n+    _gfortran_mminval0_s4;\n+    _gfortran_mminval1_s1;\n+    _gfortran_mminval1_s4;\n     _gfortran_mminval_i16;\n     _gfortran_mminval_i1;\n     _gfortran_mminval_i2;\n@@ -927,6 +943,10 @@ GFORTRAN_8 {\n     _gfortran_smaxloc2_4_s4;\n     _gfortran_smaxloc2_8_s1;\n     _gfortran_smaxloc2_8_s4;\n+    _gfortran_smaxval0_s1;\n+    _gfortran_smaxval0_s4;\n+    _gfortran_smaxval1_s1;\n+    _gfortran_smaxval1_s4;\n     _gfortran_smaxval_i16;\n     _gfortran_smaxval_i1;\n     _gfortran_smaxval_i2;\n@@ -1008,6 +1028,10 @@ GFORTRAN_8 {\n     _gfortran_sminloc2_4_s4;\n     _gfortran_sminloc2_8_s1;\n     _gfortran_sminloc2_8_s4;\n+    _gfortran_sminval0_s1;\n+    _gfortran_sminval0_s4;\n+    _gfortran_sminval1_s1;\n+    _gfortran_sminval1_s4;\n     _gfortran_sminval_i16;\n     _gfortran_sminval_i1;\n     _gfortran_sminval_i2;"}, {"sha": "19d016f7c65ed2dfc6cdcf222c8160b585f26529", "filename": "libgfortran/m4/iforeach-s2.m4", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fiforeach-s2.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fiforeach-s2.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach-s2.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,222 @@\n+dnl Support macro file for intrinsic functions.\n+dnl Contains the generic sections of the array functions.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+define(START_FOREACH_FUNCTION,\n+`static inline int\n+compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n+{\n+  if (sizeof ('atype_name`) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+\n+}\n+\n+#define INITVAL 'initval`\n+\n+extern void 'name`'rtype_qual`_'atype_code (atype_name * restrict,\n+        gfc_charlen_type,\n+\tatype * const restrict array, gfc_charlen_type);\n+export_proto(name`'rtype_qual`_'atype_code);\n+\n+void\n+name`'rtype_qual`_'atype_code` ('atype_name` * restrict ret,\n+        gfc_charlen_type xlen,\n+\t'atype` * const restrict array, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  const 'atype_name` *base;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+  /* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+        return;\n+    }\n+\n+  base = array->base_addr;\n+\n+  {\n+')dnl\n+define(START_FOREACH_BLOCK,\n+`  while (base)\n+    {\n+      do\n+\t{\n+\t  /* Implementation start.  */\n+')dnl\n+define(FINISH_FOREACH_FUNCTION,\n+`\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+   memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}')dnl\n+define(START_MASKED_FOREACH_FUNCTION,\n+`\n+extern void `m'name`'rtype_qual`_'atype_code (atype_name * restrict,\n+       gfc_charlen_type, atype * const restrict array,\n+       gfc_array_l1 * const restrict mask, gfc_charlen_type len);\n+export_proto(`m'name`'rtype_qual`_'atype_code);\n+\n+void\n+`m'name`'rtype_qual`_'atype_code (atype_name * const restrict ret,\n+\tgfc_charlen_type xlen, atype * const restrict array,\n+\tgfc_array_l1 * const restrict mask, gfc_charlen_type len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  const atype_name *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  assert (xlen == len);\n+\n+/* Initialize return value.  */\n+  memset (ret, INITVAL, sizeof(*ret) * len);\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  {\n+')dnl\n+define(START_MASKED_FOREACH_BLOCK, `START_FOREACH_BLOCK')dnl\n+define(FINISH_MASKED_FOREACH_FUNCTION,\n+`\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+    memcpy (ret, retval, len * sizeof (*ret));\n+  }\n+}')dnl\n+define(FOREACH_FUNCTION,\n+`START_FOREACH_FUNCTION\n+$1\n+START_FOREACH_BLOCK\n+$2\n+FINISH_FOREACH_FUNCTION')dnl\n+define(MASKED_FOREACH_FUNCTION,\n+`START_MASKED_FOREACH_FUNCTION\n+$1\n+START_MASKED_FOREACH_BLOCK\n+$2\n+FINISH_MASKED_FOREACH_FUNCTION')dnl\n+define(SCALAR_FOREACH_FUNCTION,\n+`\n+extern void `s'name`'rtype_qual`_'atype_code (atype_name * restrict,\n+        gfc_charlen_type,\n+\tatype * const restrict array, GFC_LOGICAL_4 *, gfc_charlen_type);\n+export_proto(`s'name`'rtype_qual`_'atype_code);\n+\n+void\n+`s'name`'rtype_qual`_'atype_code (atype_name * restrict ret,\n+        gfc_charlen_type xlen, atype * const restrict array,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type len)\n+\t\n+{\n+  if (*mask)\n+    {\n+      name`'rtype_qual`_'atype_code (ret, xlen, array, len);\n+      return;\n+    }\n+  memset (ret, INITVAL, sizeof (*ret) * len);\n+}')dnl"}, {"sha": "4eb09084dde96b0ea7c7f91bd98759ed9110e36a", "filename": "libgfortran/m4/ifunction-s2.m4", "status": "added", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fifunction-s2.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fifunction-s2.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction-s2.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,542 @@\n+dnl Support macro file for intrinsic functions.\n+dnl Contains the generic sections of the array functions.\n+dnl This file is part of the GNU Fortran Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+dnl\n+dnl Pass the implementation for a single section as the parameter to\n+dnl {MASK_}ARRAY_FUNCTION.\n+dnl The variables base, delta, and len describe the input section.\n+dnl For masked section the mask is described by mbase and mdelta.\n+dnl These should not be modified. The result should be stored in *dest.\n+dnl The names count, extent, sstride, dstride, base, dest, rank, dim\n+dnl retarray, array, pdim and mstride should not be used.\n+dnl The variable n is declared as index_type and may be used.\n+dnl Other variable declarations may be placed at the start of the code,\n+dnl The types of the array parameter and the return value are\n+dnl atype_name and rtype_name respectively.\n+dnl Execution should be allowed to continue to the end of the block.\n+dnl You should not return or break from the inner loop of the implementation.\n+dnl Care should also be taken to avoid using the names defined in iparm.m4\n+define(START_ARRAY_FUNCTION,\n+`#include <string.h>\n+#include <assert.h>\n+\n+static inline int\n+compare_fcn (const atype_name *a, const atype_name *b, gfc_charlen_type n)\n+{\n+  if (sizeof ('atype_name`) == 1)\n+    return memcmp (a, b, n);\n+  else\n+    return memcmp_char4 (a, b, n);\n+}\n+\n+extern void name`'rtype_qual`_'atype_code (rtype * const restrict,\n+        gfc_charlen_type, atype * const restrict,\n+\tconst index_type * const restrict, gfc_charlen_type);\n+export_proto(name`'rtype_qual`_'atype_code);\n+\n+void\n+name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tgfc_charlen_type xlen, atype * const restrict array, \n+\tconst index_type * const restrict pdim, gfc_charlen_type string_len)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const atype_name * restrict base;\n+  rtype_name * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  assert (xlen == string_len);\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in u_name intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1) * string_len;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" u_name intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"u_name\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const atype_name * restrict src;\n+      src = base;\n+      {\n+')dnl\n+define(START_ARRAY_BLOCK,\n+`\tif (len <= 0)\n+\t  memset (dest, '$1`, sizeof (*dest) * string_len);\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+')dnl\n+define(FINISH_ARRAY_FUNCTION,\n+`\t      }\n+\t    '$1`\n+\t    memcpy (dest, retval, sizeof (*dest) * string_len);\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}')dnl\n+define(START_MASKED_ARRAY_FUNCTION,\n+`\n+extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict,\n+        gfc_charlen_type, atype * const restrict,\n+\tconst index_type * const restrict,\n+\tgfc_array_l1 * const restrict, gfc_charlen_type);\n+export_proto(`m'name`'rtype_qual`_'atype_code);\n+\n+void\n+`m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tgfc_charlen_type xlen, atype * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tgfc_array_l1 * const restrict mask,\n+\tgfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  rtype_name * restrict dest;\n+  const atype_name * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  assert (xlen == string_len);\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in u_name intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim) * string_len;\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1) * string_len;\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in u_name intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"u_name\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"u_name\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const atype_name * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+\n+      src = base;\n+      msrc = mbase;\n+      {\n+')dnl\n+define(START_MASKED_ARRAY_BLOCK,\n+`\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+')dnl\n+define(FINISH_MASKED_ARRAY_FUNCTION,\n+`\t  }\n+\tmemcpy (dest, retval, sizeof (*dest) * string_len);\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}')dnl\n+define(SCALAR_ARRAY_FUNCTION,\n+`\n+void `s'name`'rtype_qual`_'atype_code (rtype * const restrict,\n+        gfc_charlen_type, atype * const restrict,\n+\tconst index_type * const restrict,\n+\tGFC_LOGICAL_4 *, gfc_charlen_type);\n+\n+export_proto(`s'name`'rtype_qual`_'atype_code);\n+\n+void\n+`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tgfc_charlen_type xlen, atype * const restrict array, \n+\tconst index_type * const restrict pdim,\n+\tGFC_LOGICAL_4 *mask, gfc_charlen_type string_len)\n+\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  rtype_name * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      name`'rtype_qual`_'atype_code (retarray, xlen, array, pdim, string_len);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in u_name intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1]\n+      \t\t * string_len;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (rtype_name));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" u_name intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" u_name intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n) * string_len;\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      memset (dest, '$1`, sizeof (*dest) * string_len);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}')dnl\n+define(ARRAY_FUNCTION,\n+`START_ARRAY_FUNCTION($1)\n+$2\n+START_ARRAY_BLOCK($1)\n+$3\n+FINISH_ARRAY_FUNCTION($4)')dnl\n+define(MASKED_ARRAY_FUNCTION,\n+`START_MASKED_ARRAY_FUNCTION\n+$2\n+START_MASKED_ARRAY_BLOCK\n+$3\n+FINISH_MASKED_ARRAY_FUNCTION')dnl"}, {"sha": "a5596c98a16636208ffe08e93dbfe9d30241866b", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -35,3 +35,4 @@ define(name, regexp(regexp(file, `[^/]*$', `\\&'), `^\\([^_]*\\)_', `\\1'))dnl\n define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl\n define(`u_name',`regexp(upcase(name),`\\([A-Z]*\\)',`\\1')')dnl\n define(rtype_ccode,ifelse(rtype_letter,`i',rtype_kind,rtype_code))dnl\n+define(initval,ifelse(index(name,`maxval'),0,0,index(name,`minval'),0,255))dnl"}, {"sha": "eeb4d7b27e214ec8960f97aa3755a0431347a7ca", "filename": "libgfortran/m4/maxval0s.m4", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fmaxval0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fmaxval0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxval0s.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,58 @@\n+`/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>'\n+\n+include(iparm.m4)dnl\n+include(iforeach-s2.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+FOREACH_FUNCTION(\n+`  const atype_name *retval;\n+   retval = ret;'\n+,\n+`  if (compare_fcn (base, retval, len) > 0)\n+    {\n+      retval = base;\n+    }')\n+\n+MASKED_FOREACH_FUNCTION(\n+`  const atype_name *retval;\n+\n+  retval = ret;'\n+,\n+`  if (*mbase && compare_fcn (base, retval, len) > 0)\n+    {\n+      retval = base;\n+    }')\n+\n+SCALAR_FOREACH_FUNCTION\n+\n+#endif"}, {"sha": "edf0ef1ba04881d05d2425e12d3eb1feb7307932", "filename": "libgfortran/m4/maxval1s.m4", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fmaxval1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fmaxval1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxval1s.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,61 @@\n+`/* Implementation of the MAXVAL intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"'\n+\n+include(iparm.m4)dnl\n+include(ifunction-s2.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(0,\n+`\tconst atype_name *retval;\n+\tretval = base;',\n+`\t\tif (compare_fcn (src, retval, string_len) > 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }', `')\n+\n+MASKED_ARRAY_FUNCTION(0,\n+`\tconst atype_name *retval;\n+\tmemset (dest, 0, sizeof (*dest) * string_len);\n+\tretval = dest;',\n+`\t\tif (*msrc)\n+\t\t      {\n+\t\t\tretval = src;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, retval, string_len) > 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      ')\n+\n+SCALAR_ARRAY_FUNCTION(0)\n+\n+#endif"}, {"sha": "0bcf543503a012f396ee9da9a4f17c6810e973f4", "filename": "libgfortran/m4/minval0s.m4", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fminval0s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fminval0s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminval0s.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,58 @@\n+`/* Implementation of the MAXLOC intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <limits.h>'\n+\n+include(iparm.m4)dnl\n+include(iforeach-s2.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+FOREACH_FUNCTION(\n+`  const atype_name *retval;\n+   retval = ret;'\n+,\n+`  if (compare_fcn (base, retval, len) < 0)\n+    {\n+      retval = base;\n+    }')\n+\n+MASKED_FOREACH_FUNCTION(\n+`  const atype_name *retval;\n+\n+  retval = ret;'\n+,\n+`  if (*mbase && compare_fcn (base, retval, len) < 0)\n+    {\n+      retval = base;\n+    }')\n+\n+SCALAR_FOREACH_FUNCTION\n+\n+#endif"}, {"sha": "3f52bd9bdab65e5b1b71114432e37c362582b9de", "filename": "libgfortran/m4/minval1s.m4", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fminval1s.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac7425470a37554aa4dd017afb5f90b7328c9b0/libgfortran%2Fm4%2Fminval1s.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminval1s.m4?ref=0ac7425470a37554aa4dd017afb5f90b7328c9b0", "patch": "@@ -0,0 +1,61 @@\n+`/* Implementation of the MAXVAL intrinsic\n+   Copyright 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"'\n+\n+include(iparm.m4)dnl\n+include(ifunction-s2.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(255,\n+`\tconst atype_name *retval;\n+\tretval = base;',\n+`\t\tif (compare_fcn (src, retval, string_len) < 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }', `')\n+\n+MASKED_ARRAY_FUNCTION(255,\n+`\tconst atype_name *retval;\n+\tmemset (dest, 255, sizeof (*dest) * string_len);\n+\tretval = dest;',\n+`\t\tif (*msrc)\n+\t\t      {\n+\t\t\tretval = src;\n+\t\t\tbreak;\n+\t\t      }\n+\t    }\n+\t    for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\t\tif (*msrc && compare_fcn (src, retval, string_len) < 0)\n+\t\t  {\n+\t\t    retval = src;\n+\t\t  }\n+\t      ')\n+\n+SCALAR_ARRAY_FUNCTION(255)\n+\n+#endif"}]}