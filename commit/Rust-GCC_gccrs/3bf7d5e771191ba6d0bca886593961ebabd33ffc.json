{"sha": "3bf7d5e771191ba6d0bca886593961ebabd33ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JmN2Q1ZTc3MTE5MWJhNmQwYmNhODg2NTkzOTYxZWJhYmQzM2ZmYw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2006-04-26T16:17:01Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2006-04-26T16:17:01Z"}, "message": "basic-block.h (safe_insert_insn_on_edge): Removed.\n\n2006-04-26  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* basic-block.h (safe_insert_insn_on_edge): Removed.\n\t* cfgrtl.c (mark_killed_regs, safe_insert_insn_on_edge): Removed.\n\nFrom-SVN: r113276", "tree": {"sha": "231193cbd82c75c77a4c853332c8e539761f1a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/231193cbd82c75c77a4c853332c8e539761f1a7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bf7d5e771191ba6d0bca886593961ebabd33ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf7d5e771191ba6d0bca886593961ebabd33ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bf7d5e771191ba6d0bca886593961ebabd33ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf7d5e771191ba6d0bca886593961ebabd33ffc/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b282ff9a0f32ed6d8ebd86f98cc784c5df13a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b282ff9a0f32ed6d8ebd86f98cc784c5df13a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b282ff9a0f32ed6d8ebd86f98cc784c5df13a5d"}], "stats": {"total": 110, "additions": 6, "deletions": 104}, "files": [{"sha": "d1db0a09c498b0b4444da6281d556cb062b5dae1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf7d5e771191ba6d0bca886593961ebabd33ffc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf7d5e771191ba6d0bca886593961ebabd33ffc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bf7d5e771191ba6d0bca886593961ebabd33ffc", "patch": "@@ -1,3 +1,9 @@\n+2006-04-26  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* basic-block.h (safe_insert_insn_on_edge): Removed.\n+\t* cfgrtl.c (mark_killed_regs, safe_insert_insn_on_edge): Removed.\n+\n+\n 2006-04-26  David Edelsohn  <edelsohn@gnu.org>\n \t    Paolo Bonzini  <bonzini@gnu.org>\n "}, {"sha": "87683fe76b124ae629449d00e89158f4e3fe8a93", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf7d5e771191ba6d0bca886593961ebabd33ffc/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf7d5e771191ba6d0bca886593961ebabd33ffc/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3bf7d5e771191ba6d0bca886593961ebabd33ffc", "patch": "@@ -486,7 +486,6 @@ extern void update_bb_for_insn (basic_block);\n extern void free_basic_block_vars (void);\n \n extern void insert_insn_on_edge (rtx, edge);\n-bool safe_insert_insn_on_edge (rtx, edge);\n \n extern void commit_edge_insertions (void);\n extern void commit_edge_insertions_watch_calls (void);"}, {"sha": "026b37efdb288770bcf2be1d47d3c0f7dbf668bf", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf7d5e771191ba6d0bca886593961ebabd33ffc/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf7d5e771191ba6d0bca886593961ebabd33ffc/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=3bf7d5e771191ba6d0bca886593961ebabd33ffc", "patch": "@@ -77,7 +77,6 @@ static edge rtl_redirect_edge_and_branch (edge, basic_block);\n static basic_block rtl_split_block (basic_block, void *);\n static void rtl_dump_bb (basic_block, FILE *, int);\n static int rtl_verify_flow_info_1 (void);\n-static void mark_killed_regs (rtx, rtx, void *);\n static void rtl_make_forwarder_block (edge);\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n@@ -1337,108 +1336,6 @@ insert_insn_on_edge (rtx pattern, edge e)\n   end_sequence ();\n }\n \n-/* Called from safe_insert_insn_on_edge through note_stores, marks live\n-   registers that are killed by the store.  */\n-static void\n-mark_killed_regs (rtx reg, rtx set ATTRIBUTE_UNUSED, void *data)\n-{\n-  regset killed = data;\n-  int regno, i;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-  if (!REG_P (reg))\n-    return;\n-  regno = REGNO (reg);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    SET_REGNO_REG_SET (killed, regno);\n-  else\n-    {\n-      for (i = 0; i < (int) hard_regno_nregs[regno][GET_MODE (reg)]; i++)\n-\tSET_REGNO_REG_SET (killed, regno + i);\n-    }\n-}\n-\n-/* Similar to insert_insn_on_edge, tries to put INSN to edge E.  Additionally\n-   it checks whether this will not clobber the registers that are live on the\n-   edge (i.e. it requires liveness information to be up-to-date) and if there\n-   are some, then it tries to save and restore them.  Returns true if\n-   successful.  */\n-bool\n-safe_insert_insn_on_edge (rtx insn, edge e)\n-{\n-  rtx x;\n-  regset killed;\n-  rtx save_regs = NULL_RTX;\n-  unsigned regno;\n-  enum machine_mode mode;\n-  reg_set_iterator rsi;\n-\n-  killed = ALLOC_REG_SET (&reg_obstack);\n-\n-  for (x = insn; x; x = NEXT_INSN (x))\n-    if (INSN_P (x))\n-      note_stores (PATTERN (x), mark_killed_regs, killed);\n-\n-  /* Mark all hard registers as killed.  Register allocator/reload cannot\n-     cope with the situation when life range of hard register spans operation\n-     for that the appropriate register is needed, i.e. it would be unsafe to\n-     extend the life ranges of hard registers.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (!fixed_regs[regno]\n-\t&& !REGNO_PTR_FRAME_P (regno))\n-      SET_REGNO_REG_SET (killed, regno);\n-\n-  bitmap_and_into (killed, e->dest->il.rtl->global_live_at_start);\n-\n-  EXECUTE_IF_SET_IN_REG_SET (killed, 0, regno, rsi)\n-    {\n-      mode = regno < FIRST_PSEUDO_REGISTER\n-\t      ? reg_raw_mode[regno]\n-\t      : GET_MODE (regno_reg_rtx[regno]);\n-      if (mode == VOIDmode)\n-\treturn false;\n-\n-      /* Avoid copying in CCmode if we can't.  */\n-      if (!can_copy_p (mode))\n-\treturn false;\n-\t\n-      save_regs = alloc_EXPR_LIST (0,\n-\t\t\t\t   alloc_EXPR_LIST (0,\n-\t\t\t\t\t\t    gen_reg_rtx (mode),\n-\t\t\t\t\t\t    gen_raw_REG (mode, regno)),\n-\t\t\t\t   save_regs);\n-    }\n-\n-  if (save_regs)\n-    {\n-      rtx from, to;\n-\n-      start_sequence ();\n-      for (x = save_regs; x; x = XEXP (x, 1))\n-\t{\n-\t  from = XEXP (XEXP (x, 0), 1);\n-\t  to = XEXP (XEXP (x, 0), 0);\n-\t  emit_move_insn (to, from);\n-\t}\n-      emit_insn (insn);\n-      for (x = save_regs; x; x = XEXP (x, 1))\n-\t{\n-\t  from = XEXP (XEXP (x, 0), 0);\n-\t  to = XEXP (XEXP (x, 0), 1);\n-\t  emit_move_insn (to, from);\n-\t}\n-      insn = get_insns ();\n-      end_sequence ();\n-      free_EXPR_LIST_list (&save_regs);\n-    }\n-  insert_insn_on_edge (insn, e);\n-  \n-  FREE_REG_SET (killed);\n-\n-  return true;\n-}\n-\n /* Update the CFG for the instructions queued on edge E.  */\n \n static void"}]}