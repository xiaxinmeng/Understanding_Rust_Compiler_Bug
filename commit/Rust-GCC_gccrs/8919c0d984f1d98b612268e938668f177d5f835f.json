{"sha": "8919c0d984f1d98b612268e938668f177d5f835f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkxOWMwZDk4NGYxZDk4YjYxMjI2OGU5Mzg2NjhmMTc3ZDVmODM1Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2011-12-02T20:32:40Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-12-02T20:32:40Z"}, "message": "gcov.c (struct arc_info): Add is_throw field.\n\n\t* gcov.c (struct arc_info): Add is_throw field.\n\t(struct (block_info): Add exceptional field, reduce flags size to\n\taccount for it.\n\t(struct function_info): Add has_catch field.\n\t(struct line_info): Add unexceptional field.\n\t(process_file): Call find_exception_blocks if necessary.\n\t(read_graph_file): Adjust.  Note if an exceptional edge is seen.\n\t(find_exception_blocks): New.\n\t(add_line_counts): Set line's unexceptional flag if not\n\texceptional.\n\t(output_branch_count): Note exceptional arcs, lines and blocks.\n\t* gcov-dump.c (tag_arcs): Decode arc flags.\n\t* doc/gcov.texi: Document '=====' lines.\n\n\ttestsuite/\n\t* lib/gcov.exp (verify-lines): Allow = as a count char.\n\t* g++.dg/gcov/gcov-13.C: New.\n\nFrom-SVN: r181949", "tree": {"sha": "8ef74f6b3ac710dbaffba4b31b1cf46d2bbf5382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ef74f6b3ac710dbaffba4b31b1cf46d2bbf5382"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8919c0d984f1d98b612268e938668f177d5f835f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8919c0d984f1d98b612268e938668f177d5f835f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8919c0d984f1d98b612268e938668f177d5f835f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8919c0d984f1d98b612268e938668f177d5f835f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "134dc576a298b36dbbe5048b0acdf11e53838464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134dc576a298b36dbbe5048b0acdf11e53838464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/134dc576a298b36dbbe5048b0acdf11e53838464"}], "stats": {"total": 170, "additions": 152, "deletions": 18}, "files": [{"sha": "7e7ebe0c7ce69e2dbdc406164b0ae3af2f427429", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -1,3 +1,19 @@\n+2011-12-02  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcov.c (struct arc_info): Add is_throw field.\n+\t(struct (block_info): Add exceptional field, reduce flags size to\n+\taccount for it.\n+\t(struct function_info): Add has_catch field.\n+\t(struct line_info): Add unexceptional field.\n+\t(process_file): Call find_exception_blocks if necessary.\n+\t(read_graph_file): Adjust.  Note if an exceptional edge is seen.\n+\t(find_exception_blocks): New.\n+\t(add_line_counts): Set line's unexceptional flag if not\n+\texceptional.\n+\t(output_branch_count): Note exceptional arcs, lines and blocks.\n+\t* gcov-dump.c (tag_arcs): Decode arc flags.\n+\t* doc/gcov.texi: Document '=====' lines.\n+\n 2011-12-02  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/ia64/ia64.h (PRINT_OPERAND, PRINT_OPERAND_ADDRESS,"}, {"sha": "e771f72e4027dbcb05a3f2942235105bd6b44872", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -261,10 +261,13 @@ program source code.  The format is\n \n Additional block information may succeed each line, when requested by\n command line option.  The @var{execution_count} is @samp{-} for lines\n-containing no code and @samp{#####} for lines which were never executed.\n-Some lines of information at the start have @var{line_number} of zero.\n+containing no code.  Unexecuted lines are marked @samp{#####} or\n+@samp{====}, depending on whether they are reachable by\n+non-exceptional paths or only exceptional paths such as C++ exception\n+handlers, respectively.\n \n-The preamble lines are of the form\n+Some lines of information at the start have @var{line_number} of zero.\n+These preamble lines are of the form\n \n @smallexample\n -:0:@var{tag}:@var{value}"}, {"sha": "4c2913b4d96509212f7615f8031c053a730509b4", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -351,6 +351,18 @@ tag_arcs (const char *filename ATTRIBUTE_UNUSED,\n \t  dst = gcov_read_unsigned ();\n \t  flags = gcov_read_unsigned ();\n \t  printf (\" %u:%04x\", dst, flags);\n+\t  if (flags)\n+\t    {\n+\t      char c = '(';\n+\t      \n+\t      if (flags & GCOV_ARC_ON_TREE)\n+\t\tprintf (\"%ctree\", c), c = ',';\n+\t      if (flags & GCOV_ARC_FAKE)\n+\t\tprintf (\"%cfake\", c), c = ',';\n+\t      if (flags & GCOV_ARC_FALLTHROUGH)\n+\t\tprintf (\"%cfall\", c), c = ',';\n+\t      printf (\")\");\n+\t    }\n \t}\n     }\n }"}, {"sha": "d3cb4d095855d75e47e55c2613669b92409e3661", "filename": "gcc/gcov.c", "status": "modified", "additions": 73, "deletions": 14, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -88,6 +88,9 @@ typedef struct arc_info\n   unsigned int fake : 1;\n   unsigned int fall_through : 1;\n \n+  /* Arc to a catch handler.  */\n+  unsigned int is_throw : 1;\n+\n   /* Arc is for a function that abnormally returns.  */\n   unsigned int is_call_non_return : 1;\n \n@@ -123,10 +126,11 @@ typedef struct block_info\n \n   /* Block execution count.  */\n   gcov_type count;\n-  unsigned flags : 13;\n+  unsigned flags : 12;\n   unsigned count_valid : 1;\n   unsigned valid_chain : 1;\n   unsigned invalid_chain : 1;\n+  unsigned exceptional : 1;\n \n   /* Block is a call instrumenting site.  */\n   unsigned is_call_site : 1; /* Does the call.  */\n@@ -172,6 +176,9 @@ typedef struct function_info\n   unsigned lineno_checksum;\n   unsigned cfg_checksum;\n \n+  /* The graph contains at least one fake incoming edge.  */\n+  unsigned has_catch : 1;\n+\n   /* Array of basic blocks.  */\n   block_t *blocks;\n   unsigned num_blocks;\n@@ -224,6 +231,7 @@ typedef struct line_info\n \t\t\t      in all-blocks mode.  */\n   } u;\n   unsigned exists : 1;\n+  unsigned unexceptional : 1;\n } line_t;\n \n /* Describes a file mentioned in the block graph.  Contains an array\n@@ -369,6 +377,7 @@ static unsigned find_source (const char *);\n static function_t *read_graph_file (void);\n static int read_count_file (function_t *);\n static void solve_flow_graph (function_t *);\n+static void find_exception_blocks (function_t *);\n static void add_branch_counts (coverage_t *, const arc_t *);\n static void add_line_counts (coverage_t *, function_t *);\n static void function_summary (const coverage_t *, const char *);\n@@ -628,6 +637,8 @@ process_file (const char *file_name)\n \t    sources[src].num_lines = line + 1;\n \t  \n \t  solve_flow_graph (fn);\n+\t  if (fn->has_catch)\n+\t    find_exception_blocks (fn);\n \t  *fn_end = fn;\n \t  fn_end = &fn->next;\n \t}\n@@ -1051,13 +1062,15 @@ read_graph_file (void)\n \t{\n \t  unsigned src = gcov_read_unsigned ();\n \t  unsigned num_dests = GCOV_TAG_ARCS_NUM (length);\n+\t  block_t *src_blk = &fn->blocks[src];\n+\t  unsigned mark_catches = 0;\n+\t  struct arc_info *arc;\n \n \t  if (src >= fn->num_blocks || fn->blocks[src].succ)\n \t    goto corrupt;\n \n \t  while (num_dests--)\n \t    {\n-\t      struct arc_info *arc;\n \t      unsigned dest = gcov_read_unsigned ();\n \t      unsigned flags = gcov_read_unsigned ();\n \n@@ -1066,17 +1079,17 @@ read_graph_file (void)\n \t      arc = XCNEW (arc_t);\n \n \t      arc->dst = &fn->blocks[dest];\n-\t      arc->src = &fn->blocks[src];\n+\t      arc->src = src_blk;\n \n \t      arc->count = 0;\n \t      arc->count_valid = 0;\n \t      arc->on_tree = !!(flags & GCOV_ARC_ON_TREE);\n \t      arc->fake = !!(flags & GCOV_ARC_FAKE);\n \t      arc->fall_through = !!(flags & GCOV_ARC_FALLTHROUGH);\n \n-\t      arc->succ_next = fn->blocks[src].succ;\n-\t      fn->blocks[src].succ = arc;\n-\t      fn->blocks[src].num_succ++;\n+\t      arc->succ_next = src_blk->succ;\n+\t      src_blk->succ = arc;\n+\t      src_blk->num_succ++;\n \n \t      arc->pred_next = fn->blocks[dest].pred;\n \t      fn->blocks[dest].pred = arc;\n@@ -1090,12 +1103,12 @@ read_graph_file (void)\n \t\t\t source block must be a call.  */\n \t\t      fn->blocks[src].is_call_site = 1;\n \t\t      arc->is_call_non_return = 1;\n+\t\t      mark_catches = 1;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Non-local return from a callee of this\n-\t\t         function. The destination block is a catch or\n-\t\t         setjmp.  */\n+\t\t         function. The destination block is a setjmp.  */\n \t\t      arc->is_nonlocal_return = 1;\n \t\t      fn->blocks[dest].is_nonlocal_return = 1;\n \t\t    }\n@@ -1104,6 +1117,20 @@ read_graph_file (void)\n \t      if (!arc->on_tree)\n \t\tfn->num_counts++;\n \t    }\n+\t  \n+\t  if (mark_catches)\n+\t    {\n+\t      /* We have a fake exit from this block.  The other\n+\t\t non-fall through exits must be to catch handlers.\n+\t\t Mark them as catch arcs.  */\n+\n+\t      for (arc = src_blk->succ; arc; arc = arc->succ_next)\n+\t\tif (!arc->fake && !arc->fall_through)\n+\t\t  {\n+\t\t    arc->is_throw = 1;\n+\t\t    fn->has_catch = 1;\n+\t\t  }\n+\t    }\n \t}\n       else if (fn && tag == GCOV_TAG_LINES)\n \t{\n@@ -1543,6 +1570,34 @@ solve_flow_graph (function_t *fn)\n       }\n }\n \n+/* Mark all the blocks only reachable via an incoming catch.  */\n+\n+static void\n+find_exception_blocks (function_t *fn)\n+{\n+  unsigned ix;\n+  block_t **queue = XALLOCAVEC (block_t *, fn->num_blocks);\n+\n+  /* First mark all blocks as exceptional.  */\n+  for (ix = fn->num_blocks; ix--;)\n+    fn->blocks[ix].exceptional = 1;\n+\n+  /* Now mark all the blocks reachable via non-fake edges */\n+  queue[0] = fn->blocks;\n+  queue[0]->exceptional = 0;\n+  for (ix = 1; ix;)\n+    {\n+      block_t *block = queue[--ix];\n+      const arc_t *arc;\n+      \n+      for (arc = block->succ; arc; arc = arc->succ_next)\n+\tif (!arc->fake && !arc->is_throw && arc->dst->exceptional)\n+\t  {\n+\t    arc->dst->exceptional = 0;\n+\t    queue[ix++] = arc->dst;\n+\t  }\n+    }\n+}\n \f\n \n /* Increment totals in COVERAGE according to arc ARC.  */\n@@ -1860,6 +1915,8 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \t\t  coverage->lines_executed++;\n \t      }\n \t    line->exists = 1;\n+\t    if (!block->exceptional)\n+\t      line->unexceptional = 1;\n \t    line->count += block->count;\n \t  }\n       free (block->u.line.encoding);\n@@ -2082,7 +2139,6 @@ accumulate_line_counts (source_t *src)\n static int\n output_branch_count (FILE *gcov_file, int ix, const arc_t *arc)\n {\n-\n   if (arc->is_call_non_return)\n     {\n       if (arc->src->count)\n@@ -2099,7 +2155,8 @@ output_branch_count (FILE *gcov_file, int ix, const arc_t *arc)\n       if (arc->src->count)\n \tfnotice (gcov_file, \"branch %2d taken %s%s\\n\", ix,\n \t\t format_gcov (arc->count, arc->src->count, -flag_counts),\n-\t\t arc->fall_through ? \" (fallthrough)\" : \"\");\n+\t\t arc->fall_through ? \" (fallthrough)\"\n+\t\t : arc->is_throw ? \" (throw)\" : \"\");\n       else\n \tfnotice (gcov_file, \"branch %2d never executed\\n\", ix);\n     }\n@@ -2182,8 +2239,9 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t 16 spaces of indentation added before the source line so that\n \t tabs won't be messed up.  */\n       fprintf (gcov_file, \"%9s:%5u:\",\n-\t       !line->exists ? \"-\" : !line->count ? \"#####\"\n-\t       : format_gcov (line->count, 0, -1), line_num);\n+\t       !line->exists ? \"-\" : line->count\n+\t       ? format_gcov (line->count, 0, -1)\n+\t       : line->unexceptional ? \"#####\" : \"=====\", line_num);\n \n       if (retval)\n \t{\n@@ -2211,8 +2269,9 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t    {\n \t      if (!block->is_call_return)\n \t\tfprintf (gcov_file, \"%9s:%5u-block %2d\\n\",\n-\t\t\t !line->exists ? \"-\" : !block->count ? \"$$$$$\"\n-\t\t\t : format_gcov (block->count, 0, -1),\n+\t\t\t !line->exists ? \"-\" : block->count\n+\t\t\t ? format_gcov (block->count, 0, -1)\n+\t\t\t : block->exceptional ? \"%%%%%\" : \"$$$$$\",\n \t\t\t line_num, ix++);\n \t      if (flag_branches)\n \t\tfor (arc = block->succ; arc; arc = arc->succ_next)"}, {"sha": "d09f65229d76af9f6df46751bbadbaac760a9740", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -1,3 +1,8 @@\n+2011-12-02  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* lib/gcov.exp (verify-lines): Allow = as a count char.\n+\t* g++.dg/gcov/gcov-13.C: New.\n+\n 2011-12-02  Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n \n \t* gcc.dg/vect/slp-13.c: Increase array size, add initialization."}, {"sha": "c262a71f536472f940a5280fed394454eb241e76", "filename": "gcc/testsuite/g++.dg/gcov/gcov-13.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-13.C?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+void Baz (int i)\n+{\n+  if (i)\n+    throw 1;\n+}\n+\n+void Boz () throw ()\n+{\n+}\n+\n+int main ()\n+{\n+  try\n+    {\n+      Baz (0);  /* count(1) */\n+      Baz (0);  /* count(1) */\n+    }\n+  catch (...)\n+    {\n+      Boz ();  /* count(=====) */\n+    }\n+\n+  try\n+    {\n+      Baz (1);  /* count(1) */\n+      Baz (0);  /* count(#####) */\n+    }\n+  catch (...)\n+    {\n+      Boz ();  /* count(1) */\n+    }\n+\n+  return 0;  /* count(1) */\n+}\n+\n+/* { dg-final { run-gcov gcov-13.C } } */"}, {"sha": "fcd92616c0559c47e205f7b37365610c3b7f87a5", "filename": "gcc/testsuite/lib/gcov.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8919c0d984f1d98b612268e938668f177d5f835f/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcov.exp?ref=8919c0d984f1d98b612268e938668f177d5f835f", "patch": "@@ -45,7 +45,7 @@ proc verify-lines { testcase file } {\n     while { [gets $fd line] >= 0 } {\n         # We want to match both \"-\" and \"#####\" as count as well as numbers,\n         # since we want to detect lines that shouldn't be marked as covered.\n-\tif [regexp \"^ *(\\[^:]*): *(\\[0-9\\\\-#]+):.*count\\\\((\\[0-9\\\\-#]+)\\\\)(.*)\" \\\n+\tif [regexp \"^ *(\\[^:]*): *(\\[0-9\\\\-#]+):.*count\\\\((\\[0-9\\\\-#=]+)\\\\)(.*)\" \\\n \t\t\"$line\" all is n shouldbe rest] {\n \t    if [regexp \"^ *{(.*)}\" $rest all xfailed] {\n \t\tswitch [dg-process-target $xfailed] {"}]}