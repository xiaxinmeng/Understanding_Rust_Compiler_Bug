{"sha": "8514e31898f206915bbae2970285b1f35cd192ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUxNGUzMTg5OGYyMDY5MTViYmFlMjk3MDI4NWIxZjM1Y2QxOTJhZA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-07-09T07:51:26Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-07-09T07:51:26Z"}, "message": "diagnostic.c (diagnostic_args): New macro.\n\n2000-07-09  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n\t* diagnostic.c (diagnostic_args): New macro.\n\t(diagnostic_msg): Likewise.\n\t(output_formatted_integer): Likewise.\n\t(output_state): New data type.\n\t(digit_buffer): Make global.\n\t(output_add_integer): Rename to output_decimal. Squeeze\n\tdigit_buffer.\n\t(output_long_decimal, output_unsigned_decimal,\n\toutput_long_unsigned_decimal, output_octal, output_long_octal,\n\toutput_hexadecimal, output_long_hexadecimal): New functions.\n\t(output_append_r): New function.\n\t(output_append): Tweak.\n\t(output_flush_on): Rename to output_to_stream.\n\t(output_format): Change prototype.  Improve documentation. Handle\n\tmore format specifiers.\n\t(build_location_prefix): Rename to context_as_prefix.\n\t(output_notice): Rename to output_do_printf.\n\t(output_printf): Tweak.\n\t(line_wrapper_printf): Likewise.\n\t(vline_wrapper_message_with_location): Adjust call to renamed\n\tfunctions.\n\t(v_message_with_decl): Likewise.\n\t(default_print_error_function): Likewise.\n\t(save_output_state): New function.\n\t(restore_output_state): Likewise.\n\t(output_do_verbatim): Likewise.\n\t(output_verbatim): Define.\n\t(verbatim): Likewise.\n\n\t* diagnostic.h (printer_fn): Change return type from void to int.\n\tImprove documentation.\n\t(output_add_integer): Rename to output_decimal.\n\t(output_flush_on, output_format): Don't export.\n\t(output_verbatim, verbatim): Declare.\n\nFrom-SVN: r34932", "tree": {"sha": "2995959fa2d590980c03ae512238973e441abab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2995959fa2d590980c03ae512238973e441abab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8514e31898f206915bbae2970285b1f35cd192ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8514e31898f206915bbae2970285b1f35cd192ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8514e31898f206915bbae2970285b1f35cd192ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8514e31898f206915bbae2970285b1f35cd192ad/comments", "author": null, "committer": null, "parents": [{"sha": "8da603135f15303f13f005523dbfe9e97ab62da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da603135f15303f13f005523dbfe9e97ab62da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da603135f15303f13f005523dbfe9e97ab62da7"}], "stats": {"total": 431, "additions": 369, "deletions": 62}, "files": [{"sha": "75a2142721790df1ad6118328b3aaefbe27a8e8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8514e31898f206915bbae2970285b1f35cd192ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8514e31898f206915bbae2970285b1f35cd192ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8514e31898f206915bbae2970285b1f35cd192ad", "patch": "@@ -1,3 +1,40 @@\n+2000-07-09  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* diagnostic.c (diagnostic_args): New macro.\n+\t(diagnostic_msg): Likewise.\n+\t(output_formatted_integer): Likewise.\n+\t(output_state): New data type.\n+\t(digit_buffer): Make global.\n+\t(output_add_integer): Rename to output_decimal. Squeeze\n+\tdigit_buffer. \n+\t(output_long_decimal, output_unsigned_decimal,\n+\toutput_long_unsigned_decimal, output_octal, output_long_octal,\n+\toutput_hexadecimal, output_long_hexadecimal): New functions.\n+\t(output_append_r): New function.\n+\t(output_append): Tweak.\n+\t(output_flush_on): Rename to output_to_stream.\n+\t(output_format): Change prototype.  Improve documentation. Handle\n+\tmore format specifiers.\n+\t(build_location_prefix): Rename to context_as_prefix.\n+\t(output_notice): Rename to output_do_printf.\n+\t(output_printf): Tweak.\n+\t(line_wrapper_printf): Likewise.\n+\t(vline_wrapper_message_with_location): Adjust call to renamed\n+\tfunctions. \n+\t(v_message_with_decl): Likewise.\n+\t(default_print_error_function): Likewise.\n+\t(save_output_state): New function.\n+\t(restore_output_state): Likewise.\n+\t(output_do_verbatim): Likewise.\n+\t(output_verbatim): Define.\n+\t(verbatim): Likewise.\n+\n+\t* diagnostic.h (printer_fn): Change return type from void to int.\n+\tImprove documentation.\n+\t(output_add_integer): Rename to output_decimal.\n+\t(output_flush_on, output_format): Don't export.\n+\t(output_verbatim, verbatim): Declare.\n+\n 2000-07-08  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* fold-const.c (extract_muldiv) case PLUS_EXPR, MINUS_EXPR:"}, {"sha": "3d7f0e93919df7ba4460af65c4ef029c14bb4b5a", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 325, "deletions": 57, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8514e31898f206915bbae2970285b1f35cd192ad/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8514e31898f206915bbae2970285b1f35cd192ad/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=8514e31898f206915bbae2970285b1f35cd192ad", "patch": "@@ -42,14 +42,40 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free  free\n \n+#define diagnostic_args diagnostic_buffer->format_args\n+#define diagnostic_msg diagnostic_buffer->cursor\n+\n+#define output_formatted_integer(BUFFER, FORMAT, INTEGER) \\\n+  do {                                                    \\\n+    sprintf (digit_buffer, FORMAT, INTEGER);              \\\n+    output_add_string (BUFFER, digit_buffer);             \\\n+  } while (0)\n+\n+/* This data structure serves to save/restore an output_buffer state.  */\n+typedef struct\n+{\n+  const char *prefix;\n+  int maximum_length;\n+  int ideal_maximum_length;\n+  int emitted_prefix_p;\n+  int prefixing_rule;\n+  const char *cursor;\n+  va_list format_args;\n+} output_state;\n+\n+\n /* Prototypes. */\n static int doing_line_wrapping PARAMS ((void));\n \n+static void output_do_verbatim PARAMS ((output_buffer *));\n+static void output_to_stream PARAMS ((output_buffer *, FILE *));\n+static void output_format PARAMS ((output_buffer *));\n+\n static char *vbuild_message_string PARAMS ((const char *, va_list));\n static char *build_message_string PARAMS ((const char *, ...))\n      ATTRIBUTE_PRINTF_1;\n-static char *build_location_prefix PARAMS ((const char *, int, int));\n-static void output_notice PARAMS ((output_buffer *, const char *));\n+static char *context_as_prefix PARAMS ((const char *, int, int));\n+static void output_do_printf PARAMS ((output_buffer *, const char *));\n static void line_wrapper_printf PARAMS ((FILE *, const char *, ...))\n      ATTRIBUTE_PRINTF_2;\n static void vline_wrapper_message_with_location PARAMS ((const char *, int,\n@@ -77,6 +103,20 @@ static void report_file_and_line PARAMS ((const char *, int, int));\n static void vnotice PARAMS ((FILE *, const char *, va_list));\n static void set_real_maximum_length PARAMS ((output_buffer *));\n \n+static void save_output_state PARAMS ((const output_buffer *, output_state *));\n+static void restore_output_state PARAMS ((const output_state *,\n+                                          output_buffer *));\n+                                          \n+static void output_unsigned_decimal PARAMS ((output_buffer *, unsigned int));\n+static void output_long_decimal PARAMS ((output_buffer *, long int));\n+static void output_long_unsigned_decimal PARAMS ((output_buffer *,\n+                                                  long unsigned int));\n+static void output_octal PARAMS ((output_buffer *, int));\n+static void output_long_octal PARAMS ((output_buffer *, long int));\n+static void output_hexadecimal PARAMS ((output_buffer *, int));\n+static void output_long_hexadecimal PARAMS ((output_buffer *, long int));\n+static void output_append_r PARAMS ((output_buffer *, const char *, int));\n+\n extern int rtl_dump_and_exit;\n extern int inhibit_warnings;\n extern int warnings_are_errors;\n@@ -86,6 +126,10 @@ extern int errorcount;\n /* Front-end specific tree formatter, if non-NULL.  */\n printer_fn lang_printer = NULL;\n \n+/* This must be large enough to hold any printed integer or\n+   floating-point value.  */\n+static char digit_buffer[128];\n+\n /* An output_buffer surrogate for stderr.  */\n static output_buffer global_output_buffer;\n output_buffer *diagnostic_buffer = &global_output_buffer;\n@@ -345,41 +389,103 @@ output_add_space (buffer)\n   ++buffer->line_length;\n }\n \n-/* Add the stringified version of an integer to BUFFER.  */\n+/* These functions format an INTEGER into BUFFER as suggested by their\n+   names.  */\n void\n-output_add_integer (buffer, i)\n+output_decimal (buffer, i)\n      output_buffer *buffer;\n-     HOST_WIDE_INT i;\n+     int i;\n {\n-  /* This must be large enough to hold any printed integer or\n-     floating-point value.  */\n-  static char digit_buffer[128];\n+  output_formatted_integer (buffer, \"%d\", i);\n+}\n \n-  sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, i);\n-  output_add_string (buffer, digit_buffer);\n+static void\n+output_long_decimal (buffer, i)\n+     output_buffer *buffer;\n+     long int i;\n+{\n+  output_formatted_integer (buffer, \"%ld\", i);\n }\n \n-/* Append a string deliminated by START and END to BUFFER.  No wrapping is\n-   done.  The caller must ensure that it is safe to do so.  */\n+static void\n+output_unsigned_decimal (buffer, i)\n+     output_buffer *buffer;\n+     unsigned int i;\n+{\n+  output_formatted_integer (buffer, \"%u\", i);\n+}\n+\n+static void\n+output_long_unsigned_decimal (buffer, i)\n+     output_buffer *buffer;\n+     long unsigned int i;\n+{\n+  output_formatted_integer (buffer, \"%lu\", i);\n+}\n+\n+static void\n+output_octal (buffer, i)\n+     output_buffer *buffer;\n+     int i;\n+{\n+  output_formatted_integer (buffer, \"%o\", i);\n+}\n+\n+static void\n+output_long_octal (buffer, i)\n+     output_buffer *buffer;\n+     long int i;\n+{\n+  output_formatted_integer (buffer, \"%lo\", i);\n+}\n+\n+static void\n+output_hexadecimal (buffer, i)\n+     output_buffer *buffer;\n+     int i;\n+{\n+  output_formatted_integer (buffer, \"%x\", i);\n+}\n \n+static void\n+output_long_hexadecimal (buffer, i)\n+     output_buffer *buffer;\n+     long int i;\n+{\n+  output_formatted_integer (buffer, \"%lx\", i);\n+}\n+\n+/* Append to BUFFER a string specified by its STARTING character\n+   and LENGTH.  */\n+static void\n+output_append_r (buffer, start, length)\n+     output_buffer *buffer;\n+     const char *start;\n+     int length;\n+{\n+  obstack_grow (&buffer->obstack, start, length);\n+  buffer->line_length += length;\n+}\n+\n+/* Append a string deliminated by START and END to BUFFER.  No wrapping is\n+   done.  However, if beginning a new line then emit BUFFER->PREFIX and\n+   skip any leading whitespace if appropriate.  The caller must ensure\n+   that it is safe to do so.  */\n void\n output_append (buffer, start, end)\n      output_buffer *buffer;\n      const char *start;\n      const char *end;\n {\n-  int n;\n-\n   /* Emit prefix and skip whitespace if we're starting a new line.  */\n   if (buffer->line_length == 0)\n     {\n       output_emit_prefix (buffer);\n-      while (start != end && *start == ' ')\n-        ++start;\n+      if (output_is_line_wrapping (buffer))\n+        while (start != end && *start == ' ')\n+          ++start;\n     }\n-  n = end - start;\n-  obstack_grow (&buffer->obstack, start, n);\n-  buffer->line_length += n;\n+  output_append_r (buffer, start, end - start);\n }\n \n /* Wrap a STRing into BUFFER.  */\n@@ -418,8 +524,8 @@ output_add_string (buffer, str)\n \n /* Flush the content of BUFFER onto FILE and reinitialize BUFFER.  */\n \n-void\n-output_flush_on (buffer, file)\n+static void\n+output_to_stream (buffer, file)\n      output_buffer *buffer;\n      FILE *file;\n {\n@@ -428,39 +534,113 @@ output_flush_on (buffer, file)\n   output_clear (buffer);\n }\n \n-/* Format MESSAGE into BUFFER.  */\n-void\n-output_format (buffer, msg)\n+/* Format a message pointed to by BUFFER->CURSOR using BUFFER->CURSOR\n+   as appropriate.  The following format specifiers are recognized as\n+   being language independent:\n+   %d, %i: (signed) integer in base ten.\n+   %u: unsigned integer in base ten.\n+   %o: (signed) integer in base eight.\n+   %x: (signged) integer in base sixteen.\n+   %ld, %li, %lo, %lu, %lx: long versions of the above.\n+   %c: character.\n+   %s: string.\n+   %%: `%'.\n+   %*.s: a substring the length of which is specified by an integer.  */\n+static void\n+output_format (buffer)\n      output_buffer *buffer;\n-     const char *msg;\n {\n-  for (buffer->cursor = msg; *buffer->cursor; ++buffer->cursor)\n+  const char *msg = buffer->cursor;\n+  for (; *buffer->cursor; ++buffer->cursor)\n     {\n+      int long_integer = 0;\n       /* Ignore text.  */\n       if (*buffer->cursor != '%')\n         {\n           output_add_character (buffer, *buffer->cursor);\n           continue;\n         }\n \n-      /* We got a '%'.  Let's see what happens.  */\n-      ++buffer->cursor;\n-\n-      /* Let's handle the traditional cases.  */\n-      if (*buffer->cursor == 's')\n-        output_add_string (buffer, va_arg (buffer->format_args, const char *));\n-      else if (*buffer->cursor == 'd')\n-        output_add_integer (buffer, va_arg (buffer->format_args, int));\n-      else if (*buffer->cursor == '%')\n-        /* It was a '%%'.  Just output a '%'.  */\n-        output_add_character (buffer, '%');\n-      else if (lang_printer)\n-        (*lang_printer) (buffer);\n-      else\n+      /* We got a '%'.  Let's see what happens. Record whether we're\n+         parsing a long integer format specifier.  */\n+      if (*++buffer->cursor == 'l')\n         {\n-          /* Hmmm.  The front-end failed to install a format translator\n-             but called us with an unrecognized format.  Sorry.  */\n-          abort();\n+          long_integer = 1;\n+          ++buffer->cursor;\n+        }\n+\n+      /* Handle %c, %d, %i, %ld, %li, %lo, %lu, %lx, %o, %s, %u,\n+         %x, %.*s; %%.  And nothing else.  Front-ends should install\n+         printers to grok language specific format specifiers.  */\n+      switch (*buffer->cursor)\n+        {\n+        case 'c':\n+          output_add_character\n+            (buffer, va_arg (buffer->format_args, int));\n+          break;\n+          \n+        case 'd':\n+        case 'i':\n+          if (long_integer)\n+            output_long_decimal\n+              (buffer, va_arg (buffer->format_args, long int));\n+          else\n+            output_decimal (buffer, va_arg (buffer->format_args, int));\n+          break;\n+\n+        case 'o':\n+          if (long_integer)\n+            output_long_octal\n+              (buffer, va_arg (buffer->format_args, long int));\n+          else\n+            output_octal (buffer, va_arg (buffer->format_args, int));\n+          break;\n+\n+        case 's':\n+          output_add_string\n+            (buffer, va_arg (buffer->format_args, const char *));\n+          break;\n+\n+        case 'u':\n+          if (long_integer)\n+            output_long_unsigned_decimal\n+              (buffer, va_arg (buffer->format_args, long unsigned int));\n+          else\n+            output_unsigned_decimal\n+              (buffer, va_arg (buffer->format_args, unsigned int));\n+          \n+        case 'x':\n+          if (long_integer)\n+            output_long_hexadecimal\n+              (buffer, va_arg (buffer->format_args, long int));\n+          else\n+            output_hexadecimal (buffer, va_arg (buffer->format_args, int));\n+          break;\n+\n+        case '%':\n+          output_add_character (buffer, '%');\n+          break;\n+\n+        case '.':\n+          {\n+            int n;\n+            /* We handle no precision specifier but `%.*s'.  */\n+            if (*++buffer->cursor != '*')\n+              abort ();\n+            else if (*++buffer->cursor != 's')\n+              abort();\n+            n = va_arg (buffer->format_args, int);\n+            output_append (buffer, msg, msg + n);\n+          }\n+          break;\n+\n+        default:\n+          if (!lang_printer || !(*lang_printer) (buffer))\n+            {\n+              /* Hmmm.  The front-end failed to install a format translator\n+                 but called us with an unrecognized format.  Sorry.  */\n+              abort();\n+            }\n         }\n     }\n   output_finish (buffer);\n@@ -507,7 +687,7 @@ build_message_string VPARAMS ((const char *msgid, ...))\n    responsible for freeing the memory.  */\n \n static char *\n-build_location_prefix (file, line, warn)\n+context_as_prefix (file, line, warn)\n      const char *file;\n      int line;\n      int warn;\n@@ -531,7 +711,7 @@ build_location_prefix (file, line, warn)\n /* Format a MESSAGE into BUFFER.  Automatically wrap lines.  */\n \n static void\n-output_notice (buffer, msgid)\n+output_do_printf (buffer, msgid)\n      output_buffer *buffer;\n      const char *msgid;\n {\n@@ -552,17 +732,20 @@ output_printf VPARAMS ((struct output_buffer *buffer, const char *msgid, ...))\n   const char *msgid;\n #endif\n   va_list ap;\n+  va_list old_args;\n \n   VA_START (ap, msgid);\n-\n #ifndef ANSI_PROTOTYPES\n   buffer = va_arg (ap, struct output_buffer *);\n   msgid = va_arg (ap, const char *);\n #endif\n+  va_copy (old_args, buffer->format_args);\n \n   va_copy (buffer->format_args, ap);\n-  output_notice (buffer, msgid);\n+  output_do_printf (buffer, msgid);\n   va_end (buffer->format_args);\n+\n+  va_copy (buffer->format_args, old_args);\n }\n \n \n@@ -578,16 +761,16 @@ line_wrapper_printf VPARAMS ((FILE *file, const char *msgid, ...))\n #endif\n   output_buffer buffer;\n   \n-  init_output_buffer (&buffer, NULL, diagnostic_message_length_per_line);\n+  default_initialize_buffer (&buffer);\n   VA_START (buffer.format_args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   file = va_arg (buffer.format_args, FILE *);\n   msgid = va_arg (buffer.format_args, const char *);\n #endif  \n \n-  output_notice (&buffer, msgid);\n-  output_flush_on (&buffer, file);\n+  output_do_printf (&buffer, msgid);\n+  output_to_stream (&buffer, file);\n \n   va_end (buffer.format_args);\n }\n@@ -603,11 +786,11 @@ vline_wrapper_message_with_location (file, line, warn, msgid, ap)\n {\n   output_buffer buffer;\n   \n-  init_output_buffer (&buffer, build_location_prefix (file, line, warn),\n+  init_output_buffer (&buffer, context_as_prefix (file, line, warn),\n \t\t      diagnostic_message_length_per_line);\n   va_copy (buffer.format_args, ap);\n-  output_notice (&buffer, msgid);\n-  output_flush_on (&buffer, stderr);\n+  output_do_printf (&buffer, msgid);\n+  output_to_stream (&buffer, stderr);\n \n   output_destroy_prefix (&buffer);\n   fputc ('\\n', stderr);\n@@ -692,7 +875,7 @@ v_message_with_decl (decl, warn, msgid, ap)\n   if (doing_line_wrapping ())\n     {\n       init_output_buffer\n-        (&buffer, build_location_prefix\n+        (&buffer, context_as_prefix\n          (DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl), warn),\n          diagnostic_message_length_per_line);\n     }\n@@ -747,7 +930,7 @@ v_message_with_decl (decl, warn, msgid, ap)\n       if (doing_line_wrapping ())\n         {\n \t  va_copy (buffer.format_args, ap);\n-          output_notice (&buffer, p);\n+          output_do_printf (&buffer, p);\n           va_copy (ap, buffer.format_args);\n         }\n       else\n@@ -756,7 +939,7 @@ v_message_with_decl (decl, warn, msgid, ap)\n \n   if (doing_line_wrapping())\n     {\n-      output_flush_on (&buffer, stderr);\n+      output_to_stream (&buffer, stderr);\n       output_destroy_prefix (&buffer);\n     }\n   \n@@ -1255,7 +1438,7 @@ default_print_error_function (file)\n       last_error_function = current_function_decl;\n \n       if (doing_line_wrapping ())\n-        output_flush_on (&buffer, stderr);\n+        output_to_stream (&buffer, stderr);\n       \n       free ((char*) prefix);\n     }\n@@ -1508,3 +1691,88 @@ warning VPARAMS ((const char *msgid, ...))\n   va_end (ap);\n }\n \n+/* Save BUFFER's STATE.  */\n+static void\n+save_output_state (buffer, state)\n+     const output_buffer *buffer;\n+     output_state *state;\n+{\n+  state->prefix = buffer->prefix;\n+  state->maximum_length = buffer->maximum_length;\n+  state->ideal_maximum_length = buffer->ideal_maximum_length;\n+  state->emitted_prefix_p = buffer->emitted_prefix_p;\n+  state->prefixing_rule = buffer->prefixing_rule;\n+  state->cursor = buffer->cursor;\n+  va_copy (state->format_args, buffer->format_args);\n+}\n+\n+/* Restore BUFFER's previously saved STATE.  */\n+static void\n+restore_output_state (state, buffer)\n+     const output_state *state;\n+     output_buffer *buffer;\n+{\n+  buffer->prefix = state->prefix;\n+  buffer->maximum_length = state->maximum_length;\n+  buffer->ideal_maximum_length = state->ideal_maximum_length;\n+  buffer->emitted_prefix_p = state->emitted_prefix_p;\n+  buffer->prefixing_rule = state->prefixing_rule;\n+  buffer->cursor = state->cursor;\n+  va_copy (buffer->format_args, state->format_args);\n+}\n+\n+/* Helper subroutine of output_verbatim and verbatim. Do the approriate\n+   settings needed by BUFFER for a verbatim formatting.  */\n+static void\n+output_do_verbatim (buffer)\n+     output_buffer *buffer;\n+{\n+  buffer->prefix = NULL;\n+  buffer->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n+  output_set_maximum_length (buffer, 0);\n+  output_format (buffer);\n+}\n+\n+/* Output MESSAGE verbatim into BUFFER.  */\n+void\n+output_verbatim VPARAMS ((output_buffer *buffer, const char *msg, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  output_buffer *buffer;\n+  const char *msg;\n+#endif\n+  output_state previous_state;\n+  va_list ap;\n+\n+  VA_START (ap, msg);\n+#ifndef ANSI_PROTOTYPES\n+  buffer = va_arg (ap, output_buffer *);\n+  msg = va_arg (ap, const char *);\n+#endif\n+  save_output_state (buffer, &previous_state);\n+  buffer->cursor = msg;\n+  va_copy (buffer->format_args, ap);\n+  output_do_verbatim(buffer);\n+  va_end (buffer->format_args);\n+  restore_output_state (&previous_state, buffer);\n+}\n+\n+/* Same as above but use diagnostic_buffer.  */\n+void\n+verbatim VPARAMS ((const char *msg, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msg;\n+#endif\n+  output_state previous_state;\n+  save_output_state (diagnostic_buffer, &previous_state);\n+  VA_START (diagnostic_args, msg);\n+#ifndef ANSI_PROTOTYPES\n+  msg = va_arg (diagnostic_args, const char *);\n+#endif\n+  diagnostic_msg = msg;\n+  output_do_verbatim (diagnostic_buffer);\n+  output_to_stream (diagnostic_buffer, stderr);\n+  va_end (diagnostic_args);\n+  restore_output_state (&previous_state, diagnostic_buffer);\n+}"}, {"sha": "5699d180c19098805db8c069e819e58e438c27c2", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8514e31898f206915bbae2970285b1f35cd192ad/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8514e31898f206915bbae2970285b1f35cd192ad/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=8514e31898f206915bbae2970285b1f35cd192ad", "patch": "@@ -32,8 +32,9 @@ typedef struct output_buffer output_buffer;\n #define DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE 0x2\n \n /* The type of front-end specific hook that formats trees into an\n-   output_buffer.  */\n-typedef void (*printer_fn) PARAMS ((output_buffer *));\n+   output_buffer.  A language specific printer returns a truth value if\n+   everything goes well. */\n+typedef int (*printer_fn) PARAMS ((output_buffer *));\n \n /* The output buffer datatype.  This is best seen as an abstract datatype.  */\n struct output_buffer\n@@ -109,14 +110,15 @@ int output_space_left\t\tPARAMS ((const output_buffer *));\n void output_append\t\tPARAMS ((output_buffer *, const char *,\n                                          const char *));\n void output_add_character\tPARAMS ((output_buffer *, int));\n-void output_add_integer\t\tPARAMS ((output_buffer *, HOST_WIDE_INT));\n+void output_decimal\t\tPARAMS ((output_buffer *, int));\n void output_add_string\t\tPARAMS ((output_buffer *, const char *));\n const char *output_finish\tPARAMS ((output_buffer *));\n-void output_flush_on\t\tPARAMS ((output_buffer *, FILE *));\n void output_printf\t\tPARAMS ((output_buffer *, const char *,\n                                          ...)) ATTRIBUTE_PRINTF_2;\n-void output_format\t\tPARAMS ((output_buffer *, const char *));\n int output_is_line_wrapping\tPARAMS ((output_buffer *));\n void set_message_prefixing_rule PARAMS ((int));\n+void output_verbatim            PARAMS ((output_buffer *, const char *, ...))\n+     ATTRIBUTE_PRINTF_2;\n+void verbatim PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n #endif /* __GCC_DIAGNOSTIC_H__ */"}]}