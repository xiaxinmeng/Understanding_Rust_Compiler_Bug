{"sha": "c91457541d06789db54fa7ce42fba6a91f53bafe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkxNDU3NTQxZDA2Nzg5ZGI1NGZhN2NlNDJmYmE2YTkxZjUzYmFmZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2008-07-08T16:11:06Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2008-07-08T16:11:06Z"}, "message": "Fix PR tree-optimization/23455 Fix PR tree-optimization/35286 Fix PR tree-optimization/35287\n\n2008-07-05  Daniel Berlin  <dberlin@dberlin.org>\n\t\n\tFix PR tree-optimization/23455\n\tFix PR tree-optimization/35286\n\tFix PR tree-optimization/35287\n\t* Makefile.in (OBJS-common): Remove tree-vn.o.\n\ttree-vn.o: Remove.\n\t* dbgcnt.def: Add treepre_insert debug counter.\n\t* gcc/tree-flow.h (add_to_value): Updated for other changes.\n\t(debug_value_expressions): Ditto.\n\t(print_value_expressions): Ditto.\n\t* tree-pretty-print.c (dump_generic_node): Updated for\n\tVALUE_HANDLE removal.\n\t* tree-ssa-dom.c (record_equality): Ditto.\n\t(cprop_operand): Ditto.\n\t(lookup_avail_expr): Ditto.\n\t* tree-ssa-threadedge.c\n\t(record_temporary_equivalences_from_stmts_at_dest): Ditto.\n\t(simplify_control_stmt_condition): Ditto.\n\t* tree.c (tree_code_size): Ditto.\n\t(tree_node_structure): Ditto.\n\t(iterative_hash_expr): Ditto.\n\t* tree.def: Ditto.\n\t* tree.h (VALUE_HANDLE_ID): Ditto.\n\t(VALUE_HANDLE_EXPR_SET): Ditto.\n\t(struct tree_value_handle): Ditto.\n\t(union tree_node): Ditto.\n\t* treestruct.def: Ditto.\n\t* tree-vn.c: Removed.\n\t* tree-ssa-pre.c: Rewritten entirely.\n\t* tree-ssa-sccvn.c (constant_to_value_id): New hashtable.\n\t(constant_value_ids): Ditto.\n\t(vn_nary_op_t): Moved to header.\n\t(vn_phi_t): Ditto.\n\t(vn_reference_op_t): Ditto\n\t(vn_reference_t): Ditto.\n\t(next_value_id): New variable.\n\t(VN_INFO): Add an assert.\n\t(vn_constant_eq): New function.\n\t(vn_constant_hash): Ditto.\n\t(get_or_alloc_constant_value_id): Ditto.\n\t(value_id_constant_p): Ditto.\n\t(vn_reference_compute_hash): De-staticify.\n\t(copy_reference_ops_from_ref): Don't use get_callee_fndecl.\n\tDisable some code with a FIXME.\n\tRemove VALUE_HANDLE use.\n\t(valueize_refs): Update opcode if it changes from ssa name to\n\tconstant.\n\t(vn_reference_lookup_1): Add new argument.\n\t(vn_reference_lookup):  Ditto.\n\t(vn_reference_lookup_pieces): New function.\n\t(vn_reference_insert): Add return type. Modify to deal with value\n\tids.\n\t(vn_reference_insert_pieces):  New function.\n\t(vn_nary_op_compute_hash): De-staticify.\n\t(vn_nary_op_eq): Ditto.\n\t(vn_nary_op_lookup_pieces): New function.\n\t(vn_nary_op_lookup): Add new argument.  \n\t(vn_nary_op_insert_pieces): New function.\n\t(vn_nary_op_insert): Add return type. Modify to deal with value\n\tids.\n\t(vn_phi_insert): Ditto.\n\t(visit_unary_op): Update for callee changes.\n\t(visit_binary_op): Ditto.\n\t(visit_reference_op_load): Ditto.\n\t(visit_reference_op_store): Ditto.\n\t(init_scc_vn): Init next_value_id, constant_to_value_id and\n\tconstant_value_ids. \n\t(free_scc_vn): Free them.\n\t(set_hashtable_value_ids): New function.\n\t(run_scc_vn): Use it.\n\t(get_max_value_id): New function.\n\t(get_next_value_id): Ditto.\n\t(expressions_equal_p): Moved from tree-vn.c\n\t(sort_vuses): Ditto.\n\t(sort_vuses_heap): Ditto.\n\t* tree-ssa-sccvn.h: Structures moved from tree-ssa-sccvn.c (noted\n\tabove).\n\t* tree.c (iterative_hash_hashval_t): Made non-static\n\t* tree.h (iterative_hash_hashval_t): Declare it.\n\nFrom-SVN: r137631", "tree": {"sha": "5da0fb4b8bbe65ae089580b513801bbf27607a7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5da0fb4b8bbe65ae089580b513801bbf27607a7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c91457541d06789db54fa7ce42fba6a91f53bafe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c91457541d06789db54fa7ce42fba6a91f53bafe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c91457541d06789db54fa7ce42fba6a91f53bafe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c91457541d06789db54fa7ce42fba6a91f53bafe/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "771578a0df0245565f21186deb58135c3351f3a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771578a0df0245565f21186deb58135c3351f3a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771578a0df0245565f21186deb58135c3351f3a7"}], "stats": {"total": 4397, "additions": 2396, "deletions": 2001}, "files": [{"sha": "e88d5d3c3d34f37791e0a01e7750c484bb86cd72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -1,3 +1,84 @@\n+2008-07-05  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\tFix PR tree-optimization/23455\n+\tFix PR tree-optimization/35286\n+\tFix PR tree-optimization/35287\n+\t* Makefile.in (OBJS-common): Remove tree-vn.o.\n+\ttree-vn.o: Remove.\n+\t* dbgcnt.def: Add treepre_insert debug counter.\n+\t* gcc/tree-flow.h (add_to_value): Updated for other changes.\n+\t(debug_value_expressions): Ditto.\n+\t(print_value_expressions): Ditto.\n+\t* tree-pretty-print.c (dump_generic_node): Updated for\n+\tVALUE_HANDLE removal.\n+\t* tree-ssa-dom.c (record_equality): Ditto.\n+\t(cprop_operand): Ditto.\n+\t(lookup_avail_expr): Ditto.\n+\t* tree-ssa-threadedge.c\n+\t(record_temporary_equivalences_from_stmts_at_dest): Ditto.\n+\t(simplify_control_stmt_condition): Ditto.\n+\t* tree.c (tree_code_size): Ditto.\n+\t(tree_node_structure): Ditto.\n+\t(iterative_hash_expr): Ditto.\n+\t* tree.def: Ditto.\n+\t* tree.h (VALUE_HANDLE_ID): Ditto.\n+\t(VALUE_HANDLE_EXPR_SET): Ditto.\n+\t(struct tree_value_handle): Ditto.\n+\t(union tree_node): Ditto.\n+\t* treestruct.def: Ditto.\n+\t* tree-vn.c: Removed.\n+\t* tree-ssa-pre.c: Rewritten entirely.\n+\t* tree-ssa-sccvn.c (constant_to_value_id): New hashtable.\n+\t(constant_value_ids): Ditto.\n+\t(vn_nary_op_t): Moved to header.\n+\t(vn_phi_t): Ditto.\n+\t(vn_reference_op_t): Ditto\n+\t(vn_reference_t): Ditto.\n+\t(next_value_id): New variable.\n+\t(VN_INFO): Add an assert.\n+\t(vn_constant_eq): New function.\n+\t(vn_constant_hash): Ditto.\n+\t(get_or_alloc_constant_value_id): Ditto.\n+\t(value_id_constant_p): Ditto.\n+\t(vn_reference_compute_hash): De-staticify.\n+\t(copy_reference_ops_from_ref): Don't use get_callee_fndecl.\n+\tDisable some code with a FIXME.\n+\tRemove VALUE_HANDLE use.\n+\t(valueize_refs): Update opcode if it changes from ssa name to\n+\tconstant.\n+\t(vn_reference_lookup_1): Add new argument.\n+\t(vn_reference_lookup):  Ditto.\n+\t(vn_reference_lookup_pieces): New function.\n+\t(vn_reference_insert): Add return type. Modify to deal with value\n+\tids.\n+\t(vn_reference_insert_pieces):  New function.\n+\t(vn_nary_op_compute_hash): De-staticify.\n+\t(vn_nary_op_eq): Ditto.\n+\t(vn_nary_op_lookup_pieces): New function.\n+\t(vn_nary_op_lookup): Add new argument.  \n+\t(vn_nary_op_insert_pieces): New function.\n+\t(vn_nary_op_insert): Add return type. Modify to deal with value\n+\tids.\n+\t(vn_phi_insert): Ditto.\n+\t(visit_unary_op): Update for callee changes.\n+\t(visit_binary_op): Ditto.\n+\t(visit_reference_op_load): Ditto.\n+\t(visit_reference_op_store): Ditto.\n+\t(init_scc_vn): Init next_value_id, constant_to_value_id and\n+\tconstant_value_ids. \n+\t(free_scc_vn): Free them.\n+\t(set_hashtable_value_ids): New function.\n+\t(run_scc_vn): Use it.\n+\t(get_max_value_id): New function.\n+\t(get_next_value_id): Ditto.\n+\t(expressions_equal_p): Moved from tree-vn.c\n+\t(sort_vuses): Ditto.\n+\t(sort_vuses_heap): Ditto.\n+\t* tree-ssa-sccvn.h: Structures moved from tree-ssa-sccvn.c (noted\n+\tabove).\n+\t* tree.c (iterative_hash_hashval_t): Made non-static\n+\t* tree.h (iterative_hash_hashval_t): Declare it.\n+\t\n 2008-07-08  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-cp.c (ipcp_init_cloned_node): Call ipa_check_create_node_params"}, {"sha": "1bd7ed49de8966768f1526c7e029a88c68069882", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -1223,7 +1223,6 @@ OBJS-common = \\\n \ttree-vect-patterns.o \\\n \ttree-vect-transform.o \\\n \ttree-vectorizer.o \\\n-\ttree-vn.o \\\n \ttree-vrp.o \\\n \ttree.o \\\n \tvalue-prof.o \\\n@@ -2109,16 +2108,14 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n-   $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H)\n+   $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \\\n+   $(DBGCNT_H)\n tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n    $(TREE_INLINE_H) tree-iterator.h tree-ssa-propagate.h tree-ssa-sccvn.h \\\n    $(PARAMS_H)\n-tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n-   $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n-   $(TREE_DUMP_H) $(DIAGNOSTIC_H) tree-ssa-sccvn.h\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\"}, {"sha": "fa7557912d6d9e8e654f5370d346f51e5710c7d4", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -166,6 +166,7 @@ DEBUG_COUNTER (jump_bypass)\n DEBUG_COUNTER (local_alloc_for_sched)\n DEBUG_COUNTER (postreload_cse)\n DEBUG_COUNTER (pre_insn)\n+DEBUG_COUNTER (treepre_insert)\n DEBUG_COUNTER (sched2_func)\n DEBUG_COUNTER (sched_block)\n DEBUG_COUNTER (sched_func)\n@@ -174,4 +175,3 @@ DEBUG_COUNTER (sched_region)\n DEBUG_COUNTER (sms_sched_loop)\n DEBUG_COUNTER (split_for_sched2)\n DEBUG_COUNTER (tail_call)\n-"}, {"sha": "9ca457cb952fc89e8ebb0932bed5ae10402c0c93", "filename": "gcc/testsuite/gcc.c-torture/compile/20080704-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080704-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080704-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20080704-1.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -0,0 +1,43 @@\n+/* This code used to crash fold_convert due to PRE\n+   wanting to fold_convert from a REA_TYPE to an INTEGER_TYPE.  */\n+typedef unsigned int uint32_t;\n+union double_union\n+{\n+  double d;\n+  uint32_t i[2];\n+};\n+struct _Jv_reent\n+{\n+  int _errno;\n+};\n+_Jv_strtod_r (struct _Jv_reent *ptr, char **se)\n+{\n+  int bb2, sign;\n+  double aadj, aadj1, adj;\n+  unsigned long y, z;\n+  union double_union rv, *bs = ((void *) 0), *delta = ((void *) 0);\n+  {\n+  ovfl:ptr->_errno = 34;\n+    {\n+      (((uint32_t) 0xfffffL) | ((uint32_t) 0x100000L) * (1024 + 1023 - 1));\n+    }\n+    if ((aadj = _Jv_ratio (delta, bs)) <= 2.)\n+      {\n+\t{\n+\t  if (aadj < 2. / 2)\n+\t    aadj = 1. / 2;\n+\t  aadj1 = -aadj;\n+\t}\n+      }\n+    {\n+      (rv.i[1]) -= 53 * ((uint32_t) 0x100000L);\n+      adj = aadj1 * _Jv_ulp (rv.d);\n+      rv.d += adj;\n+      if (((rv.i[1]) & ((uint32_t) 0x7ff00000L)) >=\n+\t  ((uint32_t) 0x100000L) * (1024 + 1023 - 53))\n+\t{\n+\t  goto ovfl;\n+\t}\n+    }\n+  }\n+}"}, {"sha": "31fcc9f8b7416b25378d618747075c120a1be177", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre24.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre24.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -18,7 +18,7 @@ int foo(int argc)\n   return d + e;\n }\n \n-/* PRE of globals doesn't work.  */\n+/* We will move the load of a out of the loop.  */\n \n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "3814d90e373f5e32d7779fbda8ddac618fd9890b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23455.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23455.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23455.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23455.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+unsigned long outcnt;\n+extern void flush_outbuf(void);\n+\n+void\n+bi_windup(unsigned int *outbuf, unsigned int bi_buf)\n+{\n+    unsigned long t1 = outcnt;\n+    outbuf[t1] = bi_buf;\n+\n+    unsigned long t2 = outcnt;\n+    if (t2 == 16384)\n+      flush_outbuf();\n+\n+    unsigned long t3 = outcnt;\n+    outbuf[t3] = bi_buf;\n+}\n+/* We should eliminate one load of outcnt, which will in turn let us eliminate\n+   one multiply of outcnt which will in turn let us eliminate\n+   one add involving outcnt and outbuf.  */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 3\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "8601cabeca4647ec1e25100d434943395fcd4f36", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr35286.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35286.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35286.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35286.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int g2;\n+struct A {\n+    int a; int b;\n+}g1;\n+int foo(int a, int b)\n+{\n+  if (a > 0)\n+    {\n+      g1.a = a+ b;\n+    }\n+  else\n+    g1.a = b;\n+\n+  g2 = a+b;\n+\n+  return g1.a;\n+}\n+/* We will eliminate the g1.a from the return statement as fully redundant,\n+   and remove one calculation of a + b. */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "1e976628096771f9fdf900ab44a77378334c4ebe", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr35287.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35287.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35287.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35287.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int *gp;\n+int foo(int p)\n+{\n+  int t = 0;\n+  if (p)\n+    t = *gp + 1;\n+\n+  return (*gp + t);\n+}\n+\n+/* We will eliminate one load of gp and one indirect load of *gp. */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "0cb8fa5d1ec9d4cf661589d67f2c1adb9b97f1d7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -1124,9 +1124,10 @@ extern bool remove_stmt_from_eh_region (tree);\n extern bool maybe_clean_or_replace_eh_stmt (tree, tree);\n \n /* In tree-ssa-pre.c  */\n-void add_to_value (tree, tree);\n-void debug_value_expressions (tree);\n-void print_value_expressions (FILE *, tree);\n+struct pre_expr_d;\n+void add_to_value (unsigned int, struct pre_expr_d *);\n+void debug_value_expressions (unsigned int);\n+void print_value_expressions (FILE *, unsigned int);\n \n \n /* In tree-vn.c  */"}, {"sha": "fce766cc61e1a4f44d8048f46b265ffa46fc0e8b", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -952,16 +952,12 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tpp_character (buffer, ')');\n       pp_string (buffer, str);\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n-\n-      if (TREE_CODE (op0) != VALUE_HANDLE)\n+      op0 = component_ref_field_offset (node);\n+      if (op0 && TREE_CODE (op0) != INTEGER_CST)\n \t{\n-\t  op0 = component_ref_field_offset (node);\n-\t  if (op0 && TREE_CODE (op0) != INTEGER_CST)\n-\t    {\n-\t      pp_string (buffer, \"{off: \");\n+\t  pp_string (buffer, \"{off: \");\n \t      dump_generic_node (buffer, op0, spc, flags, false);\n \t      pp_character (buffer, '}');\n-\t    }\n \t}\n       break;\n \n@@ -1789,10 +1785,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \">\");\n       break;\n \n-    case VALUE_HANDLE:\n-      pp_printf (buffer, \"VH.%d\", VALUE_HANDLE_ID (node));\n-      break;\n-\n     case ASSERT_EXPR:\n       pp_string (buffer, \"ASSERT_EXPR <\");\n       dump_generic_node (buffer, ASSERT_EXPR_VAR (node), spc, flags, false);"}, {"sha": "0b159382e7e15b847083f8f47917e0ad6ca07abd", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -1163,7 +1163,7 @@ record_equality (tree x, tree y)\n     prev_x = x, x = y, y = prev_x, prev_x = prev_y;\n   else if (prev_x && is_gimple_min_invariant (prev_x))\n     x = y, y = prev_x, prev_x = prev_y;\n-  else if (prev_y && TREE_CODE (prev_y) != VALUE_HANDLE)\n+  else if (prev_y)\n     y = prev_y;\n \n   /* After the swapping, we must have one SSA_NAME.  */\n@@ -1629,7 +1629,7 @@ cprop_operand (tree stmt, use_operand_p op_p)\n      copy of some other variable, use the value or copy stored in\n      CONST_AND_COPIES.  */\n   val = SSA_NAME_VALUE (op);\n-  if (val && val != op && TREE_CODE (val) != VALUE_HANDLE)\n+  if (val && val != op)\n     {\n       tree op_type, val_type;\n \n@@ -1969,7 +1969,7 @@ lookup_avail_expr (tree stmt, bool insert)\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       temp = SSA_NAME_VALUE (lhs);\n-      if (temp && TREE_CODE (temp) != VALUE_HANDLE)\n+      if (temp)\n \tlhs = temp;\n     }\n "}, {"sha": "cbc1ca1f1e79fa77262b0b5765e59c5df78db4ec", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1581, "deletions": 1420, "changes": 3001, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe"}, {"sha": "659fecdfa8aa6f411bb929eab1fc72550db2500a", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 501, "deletions": 109, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -115,72 +115,9 @@ typedef struct vn_tables_s\n   alloc_pool references_pool;\n } *vn_tables_t;\n \n-/* Nary operations in the hashtable consist of length operands, an\n-   opcode, and a type.  Result is the value number of the operation,\n-   and hashcode is stored to avoid having to calculate it\n-   repeatedly.  */\n+static htab_t constant_to_value_id;\n+static bitmap constant_value_ids;\n \n-typedef struct vn_nary_op_s\n-{\n-  ENUM_BITFIELD(tree_code) opcode : 16;\n-  unsigned length : 16;\n-  hashval_t hashcode;\n-  tree result;\n-  tree type;\n-  tree op[4];\n-} *vn_nary_op_t;\n-typedef const struct vn_nary_op_s *const_vn_nary_op_t;\n-\n-/* Phi nodes in the hashtable consist of their non-VN_TOP phi\n-   arguments, and the basic block the phi is in. Result is the value\n-   number of the operation, and hashcode is stored to avoid having to\n-   calculate it repeatedly.  Phi nodes not in the same block are never\n-   considered equivalent.  */\n-\n-typedef struct vn_phi_s\n-{\n-  VEC (tree, heap) *phiargs;\n-  basic_block block;\n-  hashval_t hashcode;\n-  tree result;\n-} *vn_phi_t;\n-typedef const struct vn_phi_s *const_vn_phi_t;\n-\n-/* Reference operands only exist in reference operations structures.\n-   They consist of an opcode, type, and some number of operands.  For\n-   a given opcode, some, all, or none of the operands may be used.\n-   The operands are there to store the information that makes up the\n-   portion of the addressing calculation that opcode performs.  */\n-\n-typedef struct vn_reference_op_struct\n-{\n-  enum tree_code opcode;\n-  tree type;\n-  tree op0;\n-  tree op1;\n-} vn_reference_op_s;\n-typedef vn_reference_op_s *vn_reference_op_t;\n-typedef const vn_reference_op_s *const_vn_reference_op_t;\n-\n-DEF_VEC_O(vn_reference_op_s);\n-DEF_VEC_ALLOC_O(vn_reference_op_s, heap);\n-\n-/* A reference operation in the hashtable is representation as a\n-   collection of vuses, representing the memory state at the time of\n-   the operation, and a collection of operands that make up the\n-   addressing calculation.  If two vn_reference_t's have the same set\n-   of operands, they access the same memory location. We also store\n-   the resulting value number, and the hashcode.  The vuses are\n-   always stored in order sorted by ssa name version.  */\n-\n-typedef struct vn_reference_s\n-{\n-  VEC (tree, gc) *vuses;\n-  VEC (vn_reference_op_s, heap) *operands;\n-  hashval_t hashcode;\n-  tree result;\n-} *vn_reference_t;\n-typedef const struct vn_reference_s *const_vn_reference_t;\n \n /* Valid hashtables storing information we have proven to be\n    correct.  */\n@@ -215,6 +152,10 @@ static int *rpo_numbers;\n \n tree VN_TOP;\n \n+/* Unique counter for our value ids.  */\n+\n+static unsigned int next_value_id;\n+\n /* Next DFS number and the stack for strongly connected component\n    detection. */\n \n@@ -239,8 +180,10 @@ static struct obstack vn_ssa_aux_obstack;\n vn_ssa_aux_t\n VN_INFO (tree name)\n {\n-  return VEC_index (vn_ssa_aux_t, vn_ssa_aux_table,\n-\t\t    SSA_NAME_VERSION (name));\n+  vn_ssa_aux_t res = VEC_index (vn_ssa_aux_t, vn_ssa_aux_table,\n+\t\t\t\tSSA_NAME_VERSION (name));\n+  gcc_assert (res);\n+  return res;\n }\n \n /* Set the value numbering info for a given SSA name to a given\n@@ -290,6 +233,58 @@ free_reference (void *vp)\n   VEC_free (vn_reference_op_s, heap, vr->operands);\n }\n \n+/* Hash table equality function for vn_constant_t.  */\n+\n+static int\n+vn_constant_eq (const void *p1, const void *p2)\n+{\n+  const struct vn_constant_s *vc1 = (const struct vn_constant_s *) p1;\n+  const struct vn_constant_s *vc2 = (const struct vn_constant_s *) p2;\n+\n+  return expressions_equal_p (vc1->constant, vc2->constant);\n+}\n+\n+/* Hash table hash function for vn_constant_t.  */\n+   \n+static hashval_t\n+vn_constant_hash (const void *p1)\n+{\n+  const struct vn_constant_s *vc1 = (const struct vn_constant_s *) p1;\n+  return vc1->hashcode;\n+}\n+\n+/* Lookup a value id for CONSTANT, and if it does not exist, create a\n+   new one and return it.  If it does exist, return it.  */\n+\n+unsigned int\n+get_or_alloc_constant_value_id (tree constant)\n+{\n+  void **slot;\n+  vn_constant_t vc = XNEW (struct vn_constant_s);\n+  \n+  vc->hashcode = iterative_hash_expr (constant, 0);\n+  vc->constant = constant;\n+  slot = htab_find_slot_with_hash (constant_to_value_id, vc,\n+\t\t\t\t   vc->hashcode, INSERT);  \n+  if (*slot)\n+    {\n+      free (vc);\n+      return ((vn_constant_t)*slot)->value_id;\n+    }\n+  vc->value_id = get_next_value_id ();\n+  *slot = vc;\n+  bitmap_set_bit (constant_value_ids, vc->value_id);\n+  return vc->value_id;\n+}\n+\n+/* Return true if V is a value id for a constant.  */\n+\n+bool\n+value_id_constant_p (unsigned int v)\n+{\n+  return bitmap_bit_p (constant_value_ids, v);  \n+}\n+\n /* Compare two reference operands P1 and P2 for equality.  Return true if\n    they are equal, and false otherwise.  */\n \n@@ -301,7 +296,8 @@ vn_reference_op_eq (const void *p1, const void *p2)\n   return vro1->opcode == vro2->opcode\n     && vro1->type == vro2->type\n     && expressions_equal_p (vro1->op0, vro2->op0)\n-    && expressions_equal_p (vro1->op1, vro2->op1);\n+    && expressions_equal_p (vro1->op1, vro2->op1)\n+    && expressions_equal_p (vro1->op2, vro2->op2);\n }\n \n /* Compute the hash for a reference operand VRO1.  */\n@@ -324,7 +320,7 @@ vn_reference_hash (const void *p1)\n \n /* Compute a hash for the reference operation VR1 and return it.  */\n \n-static inline hashval_t\n+hashval_t\n vn_reference_compute_hash (const vn_reference_t vr1)\n {\n   hashval_t result = 0;\n@@ -343,7 +339,7 @@ vn_reference_compute_hash (const vn_reference_t vr1)\n /* Return true if reference operations P1 and P2 are equivalent.  This\n    means they have the same set of operands and vuses.  */\n \n-static int\n+int\n vn_reference_eq (const void *p1, const void *p2)\n {\n   tree v;\n@@ -484,10 +480,18 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n       temp.type = TREE_TYPE (ref);\n       temp.opcode = CALL_EXPR;\n       VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n-\n-      callfn = get_callee_fndecl (ref);\n-      if (!callfn)\n-\tcallfn = CALL_EXPR_FN (ref);\n+      \n+      /* We make no attempt to simplify the called function because\n+      the typical &FUNCTION_DECL form is also used in function pointer\n+      cases that become constant.  If we simplify the original to\n+      FUNCTION_DECL but not the function pointer case (which can\n+      happen because we have no fold functions that operate on\n+      vn_reference_t), we will claim they are not equivalent.\n+\n+      An example of this behavior can be see if CALL_EXPR_FN below is\n+      replaced with get_callee_fndecl and gcc.dg/tree-ssa/ssa-pre-13.c\n+      is compiled.  */\n+      callfn = CALL_EXPR_FN (ref);\n       temp.type = TREE_TYPE (callfn);\n       temp.opcode = TREE_CODE (callfn);\n       temp.op0 = callfn;\n@@ -554,6 +558,7 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t     a matching type is not necessary and a mismatching type\n \t     is always a spurious difference.  */\n \t  temp.type = NULL_TREE;\n+#if FIXME\n \t  /* If this is a reference to a union member, record the union\n \t     member size as operand.  Do so only if we are doing\n \t     expression insertion (during FRE), as PRE currently gets\n@@ -564,22 +569,24 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t      && integer_zerop (DECL_FIELD_BIT_OFFSET (TREE_OPERAND (ref, 1))))\n \t    temp.op0 = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)));\n \t  else\n+#endif\n \t    /* Record field as operand.  */\n \t    temp.op0 = TREE_OPERAND (ref, 1);\n+\t    temp.op1 = TREE_OPERAND (ref, 2);\t  \n \t  break;\n \tcase ARRAY_RANGE_REF:\n \tcase ARRAY_REF:\n \t  /* Record index as operand.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n-\t  temp.op1 = TREE_OPERAND (ref, 3);\n+\t  temp.op1 = TREE_OPERAND (ref, 2);\n+\t  temp.op2 = TREE_OPERAND (ref, 3);\n \t  break;\n \tcase STRING_CST:\n \tcase INTEGER_CST:\n \tcase COMPLEX_CST:\n \tcase VECTOR_CST:\n \tcase REAL_CST:\n \tcase CONSTRUCTOR:\n-\tcase VALUE_HANDLE:\n \tcase VAR_DECL:\n \tcase PARM_DECL:\n \tcase CONST_DECL:\n@@ -653,7 +660,16 @@ valueize_refs (VEC (vn_reference_op_s, heap) *orig)\n     {\n       if (vro->opcode == SSA_NAME\n \t  || (vro->op0 && TREE_CODE (vro->op0) == SSA_NAME))\n-\tvro->op0 = SSA_VAL (vro->op0);\n+\t{\n+\t  vro->op0 = SSA_VAL (vro->op0);\n+\t  /* If it transforms from an SSA_NAME to a constant, update\n+\t     the opcode.  */\n+\t  if (TREE_CODE (vro->op0) != SSA_NAME && vro->opcode == SSA_NAME)\n+\t    vro->opcode = TREE_CODE (vro->op0);\n+\t}\n+      /* TODO: Do we want to valueize op2 and op1 of\n+\t ARRAY_REF/COMPONENT_REF for Ada */\n+      \n     }\n \n   return orig;\n@@ -733,10 +749,11 @@ get_def_ref_stmt_vuses (tree ref, VEC (tree, gc) *vuses)\n \n /* Lookup a SCCVN reference operation VR in the current hash table.\n    Returns the resulting value number if it exists in the hash table,\n-   NULL_TREE otherwise.  */\n+   NULL_TREE otherwise.  VNRESULT will be filled in with the actual\n+   vn_reference_t stored in the hashtable if something is found.  */\n \n static tree\n-vn_reference_lookup_1 (vn_reference_t vr)\n+vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n {\n   void **slot;\n   hashval_t hash;\n@@ -748,25 +765,58 @@ vn_reference_lookup_1 (vn_reference_t vr)\n     slot = htab_find_slot_with_hash (valid_info->references, vr,\n \t\t\t\t     hash, NO_INSERT);\n   if (slot)\n-    return ((vn_reference_t)*slot)->result;\n-\n+    {\n+      if (vnresult)\n+\t*vnresult = (vn_reference_t)*slot;\n+      return ((vn_reference_t)*slot)->result;\n+    }\n+  \n   return NULL_TREE;\n }\n \n-/* Lookup OP in the current hash table, and return the resulting\n-   value number if it exists in the hash table.  Return NULL_TREE if\n-   it does not exist in the hash table. */\n+\n+/* Lookup a reference operation by it's parts, in the current hash table.\n+   Returns the resulting value number if it exists in the hash table,\n+   NULL_TREE otherwise.  VNRESULT will be filled in with the actual\n+   vn_reference_t stored in the hashtable if something is found.  */\n \n tree\n-vn_reference_lookup (tree op, VEC (tree, gc) *vuses, bool maywalk)\n+vn_reference_lookup_pieces (VEC (tree, gc) *vuses,\n+\t\t\t    VEC (vn_reference_op_s, heap) *operands,\n+\t\t\t    vn_reference_t *vnresult) \n+{\n+  struct vn_reference_s vr1;\n+  tree result;\n+  if (vnresult)\n+    *vnresult = NULL;\n+  \n+  vr1.vuses = valueize_vuses (vuses);\n+  vr1.operands = valueize_refs (operands);\n+  vr1.hashcode = vn_reference_compute_hash (&vr1);\n+  result = vn_reference_lookup_1 (&vr1, vnresult);\n+\n+  return result;\n+}\n+\n+/* Lookup OP in the current hash table, and return the resulting value\n+   number if it exists in the hash table.  Return NULL_TREE if it does\n+   not exist in the hash table or if the result field of the structure\n+   was NULL..  VNRESULT will be filled in with the vn_reference_t\n+   stored in the hashtable if one exists.  */\n+\n+tree\n+vn_reference_lookup (tree op, VEC (tree, gc) *vuses, bool maywalk,\n+\t\t     vn_reference_t *vnresult)\n {\n   struct vn_reference_s vr1;\n   tree result, def_stmt;\n+  if (vnresult)\n+    *vnresult = NULL;\n \n   vr1.vuses = valueize_vuses (vuses);\n   vr1.operands = valueize_refs (shared_reference_ops_from_ref (op));\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n-  result = vn_reference_lookup_1 (&vr1);\n+  result = vn_reference_lookup_1 (&vr1, vnresult);\n \n   /* If there is a single defining statement for all virtual uses, we can\n      use that, following virtual use-def chains.  */\n@@ -786,23 +836,27 @@ vn_reference_lookup (tree op, VEC (tree, gc) *vuses, bool maywalk)\n       vdefs_to_vec (def_stmt, &vuses);\n       vr1.vuses = valueize_vuses (vuses);\n       vr1.hashcode = vn_reference_compute_hash (&vr1);\n-      result = vn_reference_lookup_1 (&vr1);\n+      result = vn_reference_lookup_1 (&vr1, vnresult);\n     }\n \n   return result;\n }\n \n+\n /* Insert OP into the current hash table with a value number of\n-   RESULT.  */\n+   RESULT, and return the resulting reference structure we created.  */\n \n-void\n+vn_reference_t\n vn_reference_insert (tree op, tree result, VEC (tree, gc) *vuses)\n {\n   void **slot;\n   vn_reference_t vr1;\n \n   vr1 = (vn_reference_t) pool_alloc (current_info->references_pool);\n-\n+  if (TREE_CODE (result) == SSA_NAME)\n+    vr1->value_id = VN_INFO (result)->value_id;\n+  else\n+    vr1->value_id = get_or_alloc_constant_value_id (result);\n   vr1->vuses = valueize_vuses (vuses);\n   vr1->operands = valueize_refs (create_reference_ops_from_ref (op));\n   vr1->hashcode = vn_reference_compute_hash (vr1);\n@@ -824,11 +878,48 @@ vn_reference_insert (tree op, tree result, VEC (tree, gc) *vuses)\n     free_reference (*slot);\n \n   *slot = vr1;\n+  return vr1;\n+}\n+\n+/* Insert a reference by it's pieces into the current hash table with\n+   a value number of RESULT.  Return the resulting reference\n+   structure we created.  */\n+\n+vn_reference_t\n+vn_reference_insert_pieces (VEC (tree, gc) *vuses,\n+\t\t\t    VEC (vn_reference_op_s, heap) *operands,\n+\t\t\t    tree result, unsigned int value_id)\n+\n+{\n+  void **slot;\n+  vn_reference_t vr1;\n+\n+  vr1 = (vn_reference_t) pool_alloc (current_info->references_pool);\n+  vr1->value_id =  value_id;\n+  vr1->vuses = valueize_vuses (vuses);\n+  vr1->operands = valueize_refs (operands);\n+  vr1->hashcode = vn_reference_compute_hash (vr1);\n+  if (result && TREE_CODE (result) == SSA_NAME)\n+    result = SSA_VAL (result);\n+  vr1->result = result;\n+\n+  slot = htab_find_slot_with_hash (current_info->references, vr1, vr1->hashcode,\n+\t\t\t\t   INSERT);\n+  \n+  /* At this point we should have all the things inserted that we have\n+  seen before, and we should never try inserting something that\n+  already exists.  */\n+  gcc_assert (!*slot);\n+  if (*slot)\n+    free_reference (*slot);\n+\n+  *slot = vr1;\n+  return vr1;\n }\n \n /* Compute and return the hash value for nary operation VBO1.  */\n \n-static inline hashval_t\n+inline hashval_t\n vn_nary_op_compute_hash (const vn_nary_op_t vno1)\n {\n   hashval_t hash = 0;\n@@ -865,7 +956,7 @@ vn_nary_op_hash (const void *p1)\n /* Compare nary operations P1 and P2 and return true if they are\n    equivalent.  */\n \n-static int\n+int\n vn_nary_op_eq (const void *p1, const void *p2)\n {\n   const_vn_nary_op_t const vno1 = (const_vn_nary_op_t) p1;\n@@ -883,17 +974,56 @@ vn_nary_op_eq (const void *p1, const void *p2)\n   return true;\n }\n \n-/* Lookup OP in the current hash table, and return the resulting\n-   value number if it exists in the hash table.  Return NULL_TREE if\n-   it does not exist in the hash table. */\n+/* Lookup a n-ary operation by its pieces and return the resulting value\n+   number if it exists in the hash table.  Return NULL_TREE if it does\n+   not exist in the hash table or if the result field of the operation\n+   is NULL. VNRESULT will contain the vn_nary_op_t from the hashtable\n+   if it exists.  */\n \n tree\n-vn_nary_op_lookup (tree op)\n+vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n+\t\t\t  tree type, tree op0, tree op1, tree op2,\n+\t\t\t  tree op3, vn_nary_op_t *vnresult) \n+{\n+  void **slot;\n+  struct vn_nary_op_s vno1;\n+  if (vnresult)\n+    *vnresult = NULL;\n+  vno1.opcode = code;\n+  vno1.length = length;\n+  vno1.type = type;\n+  vno1.op[0] = op0;\n+  vno1.op[1] = op1;\n+  vno1.op[2] = op2;\n+  vno1.op[3] = op3;\n+  vno1.hashcode = vn_nary_op_compute_hash (&vno1);\n+  slot = htab_find_slot_with_hash (current_info->nary, &vno1, vno1.hashcode,\n+\t\t\t\t   NO_INSERT);\n+  if (!slot && current_info == optimistic_info)\n+    slot = htab_find_slot_with_hash (valid_info->nary, &vno1, vno1.hashcode,\n+\t\t\t\t     NO_INSERT);\n+  if (!slot)\n+    return NULL_TREE;\n+  if (vnresult)\n+    *vnresult = (vn_nary_op_t)*slot;\n+  return ((vn_nary_op_t)*slot)->result;\n+}\n+\n+/* Lookup OP in the current hash table, and return the resulting value\n+   number if it exists in the hash table.  Return NULL_TREE if it does\n+   not exist in the hash table or if the result field of the operation\n+   is NULL. VNRESULT will contain the vn_nary_op_t from the hashtable\n+   if it exists.  */\n+\n+tree\n+vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)\n {\n   void **slot;\n   struct vn_nary_op_s vno1;\n   unsigned i;\n \n+  if (vnresult)\n+    *vnresult = NULL;\n   vno1.opcode = TREE_CODE (op);\n   vno1.length = TREE_CODE_LENGTH (TREE_CODE (op));\n   vno1.type = TREE_TYPE (op);\n@@ -907,13 +1037,56 @@ vn_nary_op_lookup (tree op)\n \t\t\t\t     NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n+  if (vnresult)\n+    *vnresult = (vn_nary_op_t)*slot;\n   return ((vn_nary_op_t)*slot)->result;\n }\n \n+/* Insert a n-ary operation into the current hash table using it's\n+   pieces.  Return the vn_nary_op_t structure we created and put in\n+   the hashtable.  */\n+\n+vn_nary_op_t\n+vn_nary_op_insert_pieces (unsigned int length, enum tree_code code,\n+\t\t\t  tree type, tree op0,\n+\t\t\t  tree op1, tree op2, tree op3,\n+\t\t\t  tree result,\n+\t\t\t  unsigned int value_id) \n+{\n+  void **slot;\n+  vn_nary_op_t vno1;\n+\n+  vno1 = (vn_nary_op_t) obstack_alloc (&current_info->nary_obstack,\n+\t\t\t\t       (sizeof (struct vn_nary_op_s)\n+\t\t\t\t\t- sizeof (tree) * (4 - length)));\n+  vno1->value_id = value_id;\n+  vno1->opcode = code;\n+  vno1->length = length;\n+  vno1->type = type;\n+  if (length >= 1)\n+    vno1->op[0] = op0;\n+  if (length >= 2)\n+    vno1->op[1] = op1;\n+  if (length >= 3)\n+    vno1->op[2] = op2;\n+  if (length >= 4)\n+    vno1->op[3] = op3;\n+  vno1->result = result;\n+  vno1->hashcode = vn_nary_op_compute_hash (vno1);\n+  slot = htab_find_slot_with_hash (current_info->nary, vno1, vno1->hashcode,\n+\t\t\t\t   INSERT);\n+  gcc_assert (!*slot);\n+\n+  *slot = vno1;\n+  return vno1;\n+  \n+}\n+\n /* Insert OP into the current hash table with a value number of\n-   RESULT.  */\n+   RESULT.  Return the vn_nary_op_t structure we created and put in\n+   the hashtable.  */\n \n-void\n+vn_nary_op_t\n vn_nary_op_insert (tree op, tree result)\n {\n   unsigned length = TREE_CODE_LENGTH (TREE_CODE (op));\n@@ -924,6 +1097,7 @@ vn_nary_op_insert (tree op, tree result)\n   vno1 = (vn_nary_op_t) obstack_alloc (&current_info->nary_obstack,\n \t\t\t(sizeof (struct vn_nary_op_s)\n \t\t\t - sizeof (tree) * (4 - length)));\n+  vno1->value_id = VN_INFO (result)->value_id;\n   vno1->opcode = TREE_CODE (op);\n   vno1->length = length;\n   vno1->type = TREE_TYPE (op);\n@@ -936,6 +1110,7 @@ vn_nary_op_insert (tree op, tree result)\n   gcc_assert (!*slot);\n \n   *slot = vno1;\n+  return vno1;\n }\n \n /* Compute a hashcode for PHI operation VP1 and return it.  */\n@@ -1034,7 +1209,7 @@ vn_phi_lookup (tree phi)\n /* Insert PHI into the current hash table with a value number of\n    RESULT.  */\n \n-static void\n+static vn_phi_t\n vn_phi_insert (tree phi, tree result)\n {\n   void **slot;\n@@ -1049,6 +1224,7 @@ vn_phi_insert (tree phi, tree result)\n       def = TREE_CODE (def) == SSA_NAME ? SSA_VAL (def) : def;\n       VEC_safe_push (tree, heap, args, def);\n     }\n+  vp1->value_id = VN_INFO (result)->value_id;\n   vp1->phiargs = args;\n   vp1->block = bb_for_stmt (phi);\n   vp1->result = result;\n@@ -1060,6 +1236,7 @@ vn_phi_insert (tree phi, tree result)\n   /* Because we iterate over phi operations more than once, it's\n      possible the slot might already exist here, hence no assert.*/\n   *slot = vp1;\n+  return vp1;\n }\n \n \n@@ -1168,7 +1345,7 @@ static bool\n visit_unary_op (tree lhs, tree op)\n {\n   bool changed = false;\n-  tree result = vn_nary_op_lookup (op);\n+  tree result = vn_nary_op_lookup (op, NULL);\n \n   if (result)\n     {\n@@ -1190,7 +1367,7 @@ static bool\n visit_binary_op (tree lhs, tree op)\n {\n   bool changed = false;\n-  tree result = vn_nary_op_lookup (op);\n+  tree result = vn_nary_op_lookup (op, NULL);\n \n   if (result)\n     {\n@@ -1212,7 +1389,8 @@ static bool\n visit_reference_op_load (tree lhs, tree op, tree stmt)\n {\n   bool changed = false;\n-  tree result = vn_reference_lookup (op, shared_vuses_from_stmt (stmt), true);\n+  tree result = vn_reference_lookup (op, shared_vuses_from_stmt (stmt), true,\n+\t\t\t\t     NULL);\n \n   /* We handle type-punning through unions by value-numbering based\n      on offset and size of the access.  Be prepared to handle a\n@@ -1236,7 +1414,7 @@ visit_reference_op_load (tree lhs, tree op, tree stmt)\n       result = val;\n       if (!is_gimple_min_invariant (val)\n \t  && TREE_CODE (val) != SSA_NAME)\n-\tresult = vn_nary_op_lookup (val);\n+\tresult = vn_nary_op_lookup (val, NULL);\n       /* If the expression is not yet available, value-number lhs to\n \t a new SSA_NAME we create.  */\n       if (!result && may_insert)\n@@ -1319,7 +1497,8 @@ visit_reference_op_store (tree lhs, tree op, tree stmt)\n      Otherwise, the vdefs for the store are used when inserting into\n      the table, since the store generates a new memory state.  */\n \n-  result = vn_reference_lookup (lhs, shared_vuses_from_stmt (stmt), false);\n+  result = vn_reference_lookup (lhs, shared_vuses_from_stmt (stmt), false,\n+\t\t\t\tNULL);\n \n   if (result)\n     {\n@@ -2146,12 +2325,18 @@ init_scc_vn (void)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   sccstack = NULL;\n+  constant_to_value_id = htab_create (23, vn_constant_hash, vn_constant_eq,\n+\t\t\t\t  free);\n+  \n+  constant_value_ids = BITMAP_ALLOC (NULL);\n+  \n   next_dfs_num = 1;\n-\n+  next_value_id = 1;\n+  \n   vn_ssa_aux_table = VEC_alloc (vn_ssa_aux_t, heap, num_ssa_names + 1);\n   /* VEC_alloc doesn't actually grow it to the right size, it just\n      preallocates the space to do so.  */\n-  VEC_safe_grow (vn_ssa_aux_t, heap, vn_ssa_aux_table, num_ssa_names + 1);\n+  VEC_safe_grow_cleared (vn_ssa_aux_t, heap, vn_ssa_aux_table, num_ssa_names + 1);\n   gcc_obstack_init (&vn_ssa_aux_obstack);\n \n   shared_lookup_phiargs = NULL;\n@@ -2180,6 +2365,7 @@ init_scc_vn (void)\n \t{\n \t  VN_INFO_GET (name)->valnum = VN_TOP;\n \t  VN_INFO (name)->expr = name;\n+\t  VN_INFO (name)->value_id = 0;\n \t}\n     }\n \n@@ -2206,6 +2392,8 @@ free_scc_vn (void)\n {\n   size_t i;\n \n+  htab_delete (constant_to_value_id);\n+  BITMAP_FREE (constant_value_ids);\n   VEC_free (tree, heap, shared_lookup_phiargs);\n   VEC_free (tree, gc, shared_lookup_vops);\n   VEC_free (vn_reference_op_s, heap, shared_lookup_references);\n@@ -2215,8 +2403,7 @@ free_scc_vn (void)\n     {\n       tree name = ssa_name (i);\n       if (name\n-\t  && SSA_NAME_VALUE (name)\n-\t  && TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n+\t  && SSA_NAME_VALUE (name))\n \tSSA_NAME_VALUE (name) = NULL;\n       if (name\n \t  && VN_INFO (name)->needs_insertion)\n@@ -2237,6 +2424,91 @@ free_scc_vn (void)\n     }\n }\n \n+/* Set the value ids in the valid/optimistic hash tables.  */\n+\n+static void\n+set_hashtable_value_ids (void)\n+{\n+  htab_iterator hi;\n+  vn_nary_op_t vno;\n+  vn_reference_t vr;\n+  vn_phi_t vp;\n+  \n+  /* Now set the value ids of the things we had put in the hash\n+     table.  */\n+\n+  FOR_EACH_HTAB_ELEMENT (valid_info->nary,\n+\t\t\t vno, vn_nary_op_t, hi) \n+    {\n+      if (vno->result)\n+\t{\n+\t  if (TREE_CODE (vno->result) == SSA_NAME)\n+\t    vno->value_id = VN_INFO (vno->result)->value_id;\n+\t  else if (is_gimple_min_invariant (vno->result))\n+\t    vno->value_id = get_or_alloc_constant_value_id (vno->result);\n+\t}\n+    }\n+\n+  FOR_EACH_HTAB_ELEMENT (optimistic_info->nary,\n+\t\t\t vno, vn_nary_op_t, hi) \n+    {\n+      if (vno->result)\n+\t{\n+\t  if (TREE_CODE (vno->result) == SSA_NAME)\n+\t    vno->value_id = VN_INFO (vno->result)->value_id;\n+\t  else if (is_gimple_min_invariant (vno->result))\n+\t    vno->value_id = get_or_alloc_constant_value_id (vno->result);\n+\t}\n+    }\n+\n+  FOR_EACH_HTAB_ELEMENT (valid_info->phis,\n+\t\t\t vp, vn_phi_t, hi) \n+    {\n+      if (vp->result)\n+\t{\n+\t  if (TREE_CODE (vp->result) == SSA_NAME)\n+\t    vp->value_id = VN_INFO (vp->result)->value_id;\n+\t  else if (is_gimple_min_invariant (vp->result))\n+\t    vp->value_id = get_or_alloc_constant_value_id (vp->result);\n+\t}\n+    }\n+  FOR_EACH_HTAB_ELEMENT (optimistic_info->phis,\n+\t\t\t vp, vn_phi_t, hi) \n+    {\n+      if (vp->result)\n+\t{\n+\t  if (TREE_CODE (vp->result) == SSA_NAME)\n+\t    vp->value_id = VN_INFO (vp->result)->value_id;\n+\t  else if (is_gimple_min_invariant (vp->result))\n+\t    vp->value_id = get_or_alloc_constant_value_id (vp->result);\n+\t}\n+    }\n+\n+\n+  FOR_EACH_HTAB_ELEMENT (valid_info->references,\n+\t\t\t vr, vn_reference_t, hi) \n+    {\n+      if (vr->result)\n+\t{\n+\t  if (TREE_CODE (vr->result) == SSA_NAME)\n+\t    vr->value_id = VN_INFO (vr->result)->value_id;\n+\t  else if (is_gimple_min_invariant (vr->result))\n+\t    vr->value_id = get_or_alloc_constant_value_id (vr->result);\n+\t}\n+    }\n+  FOR_EACH_HTAB_ELEMENT (optimistic_info->references,\n+\t\t\t vr, vn_reference_t, hi) \n+    {\n+      if (vr->result)\n+\t{\n+\t  if (TREE_CODE (vr->result) == SSA_NAME)\n+\t    vr->value_id = VN_INFO (vr->result)->value_id;\n+\t  else if (is_gimple_min_invariant (vr->result))\n+\t    vr->value_id = get_or_alloc_constant_value_id (vr->result);\n+\t}\n+    }\n+}\n+\n /* Do SCCVN.  Returns true if it finished, false if we bailed out\n    due to resource constraints.  */\n \n@@ -2245,7 +2517,8 @@ run_scc_vn (bool may_insert_arg)\n {\n   size_t i;\n   tree param;\n-\n+  bool changed = true;\n+  \n   may_insert = may_insert_arg;\n \n   init_scc_vn ();\n@@ -2276,6 +2549,45 @@ run_scc_vn (bool may_insert_arg)\n \t  }\n     }\n \n+  /* Initialize the value ids.  */\n+      \n+  for (i = 1; i < num_ssa_names; ++i)\n+    {\n+      tree name = ssa_name (i);\n+      vn_ssa_aux_t info;\n+      if (!name)\n+\tcontinue;\n+      info = VN_INFO (name);\n+      if (info->valnum == name)\n+\tinfo->value_id = get_next_value_id ();\n+      else if (is_gimple_min_invariant (info->valnum))\n+\tinfo->value_id = get_or_alloc_constant_value_id (info->valnum);\n+    }\n+  \n+  /* Propagate until they stop changing.  */\n+  while (changed)\n+    {\n+      changed = false;\n+      for (i = 1; i < num_ssa_names; ++i)\n+\t{\n+\t  tree name = ssa_name (i);\n+\t  vn_ssa_aux_t info;\n+\t  if (!name)\n+\t    continue;\n+\t  info = VN_INFO (name);\n+\t  if (TREE_CODE (info->valnum) == SSA_NAME\n+\t      && info->valnum != name\n+\t      && TREE_CODE (info->valnum) == SSA_NAME\n+\t      && info->value_id != VN_INFO (info->valnum)->value_id)\n+\t    {\n+\t      changed = true;\n+\t      info->value_id = VN_INFO (info->valnum)->value_id;\n+\t    }\n+\t}\n+    }\n+  \n+  set_hashtable_value_ids ();\n+  \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Value numbers:\\n\");\n@@ -2300,3 +2612,83 @@ run_scc_vn (bool may_insert_arg)\n   may_insert = false;\n   return true;\n }\n+\n+/* Return the maximum value id we have ever seen.  */\n+\n+unsigned int\n+get_max_value_id (void) \n+{\n+  return next_value_id;\n+}\n+\n+/* Return the next unique value id.  */\n+\n+unsigned int\n+get_next_value_id (void)\n+{\n+  return next_value_id++;\n+}\n+\n+\n+/* Compare two expressions E1 and E2 and return true if they are\n+   equal.  */\n+\n+bool\n+expressions_equal_p (tree e1, tree e2)\n+{\n+  tree te1, te2;\n+\n+  if (e1 == e2)\n+    return true;\n+\n+  te1 = TREE_TYPE (e1);\n+  te2 = TREE_TYPE (e2);\n+\n+  if (TREE_CODE (e1) == TREE_LIST && TREE_CODE (e2) == TREE_LIST)\n+    {\n+      tree lop1 = e1;\n+      tree lop2 = e2;\n+      for (lop1 = e1, lop2 = e2;\n+\t   lop1 || lop2;\n+\t   lop1 = TREE_CHAIN (lop1), lop2 = TREE_CHAIN (lop2))\n+\t{\n+\t  if (!lop1 || !lop2)\n+\t    return false;\n+\t  if (!expressions_equal_p (TREE_VALUE (lop1), TREE_VALUE (lop2)))\n+\t    return false;\n+\t}\n+      return true;\n+\n+    }\n+  else if (TREE_CODE (e1) == TREE_CODE (e2)\n+\t   && operand_equal_p (e1, e2, OEP_PURE_SAME))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Sort the VUSE array so that we can do equality comparisons\n+   quicker on two vuse vecs.  */\n+\n+void\n+sort_vuses (VEC (tree,gc) *vuses)\n+{\n+  if (VEC_length (tree, vuses) > 1)\n+    qsort (VEC_address (tree, vuses),\n+\t   VEC_length (tree, vuses),\n+\t   sizeof (tree),\n+\t   operand_build_cmp);\n+}\n+\n+/* Sort the VUSE array so that we can do equality comparisons\n+   quicker on two vuse vecs.  */\n+\n+void\n+sort_vuses_heap (VEC (tree,heap) *vuses)\n+{\n+  if (VEC_length (tree, vuses) > 1)\n+    qsort (VEC_address (tree, vuses),\n+\t   VEC_length (tree, vuses),\n+\t   sizeof (tree),\n+\t   operand_build_cmp);\n+}"}, {"sha": "0f8189cf2a5ba363e2faae0afc8bc8d570fe469e", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 109, "deletions": 6, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -24,13 +24,97 @@\n /* TOP of the VN lattice.  */\n extern tree VN_TOP;\n \n+/* N-ary operations in the hashtable consist of length operands, an\n+   opcode, and a type.  Result is the value number of the operation,\n+   and hashcode is stored to avoid having to calculate it\n+   repeatedly.  */\n+\n+typedef struct vn_nary_op_s\n+{\n+  /* Unique identify that all expressions with the same value have. */\n+  unsigned int value_id;\n+  ENUM_BITFIELD(tree_code) opcode : 16;\n+  unsigned length : 16;\n+  hashval_t hashcode;\n+  tree result;\n+  tree type;\n+  tree op[4];\n+} *vn_nary_op_t;\n+typedef const struct vn_nary_op_s *const_vn_nary_op_t;\n+\n+/* Phi nodes in the hashtable consist of their non-VN_TOP phi\n+   arguments, and the basic block the phi is in. Result is the value\n+   number of the operation, and hashcode is stored to avoid having to\n+   calculate it repeatedly.  Phi nodes not in the same block are never\n+   considered equivalent.  */\n+\n+typedef struct vn_phi_s\n+{\n+  /* Unique identifier that all expressions with the same value have. */\n+  unsigned int value_id;\n+  hashval_t hashcode;\n+  VEC (tree, heap) *phiargs;\n+  basic_block block;\n+  tree result;\n+} *vn_phi_t;\n+typedef const struct vn_phi_s *const_vn_phi_t;\n+\n+/* Reference operands only exist in reference operations structures.\n+   They consist of an opcode, type, and some number of operands.  For\n+   a given opcode, some, all, or none of the operands may be used.\n+   The operands are there to store the information that makes up the\n+   portion of the addressing calculation that opcode performs.  */\n+\n+typedef struct vn_reference_op_struct\n+{\n+  enum tree_code opcode;\n+  tree type;\n+  tree op0;\n+  tree op1;\n+  tree op2;\n+} vn_reference_op_s;\n+typedef vn_reference_op_s *vn_reference_op_t;\n+typedef const vn_reference_op_s *const_vn_reference_op_t;\n+\n+DEF_VEC_O(vn_reference_op_s);\n+DEF_VEC_ALLOC_O(vn_reference_op_s, heap);\n+\n+/* A reference operation in the hashtable is representation as a\n+   collection of vuses, representing the memory state at the time of\n+   the operation, and a collection of operands that make up the\n+   addressing calculation.  If two vn_reference_t's have the same set\n+   of operands, they access the same memory location. We also store\n+   the resulting value number, and the hashcode.  The vuses are\n+   always stored in order sorted by ssa name version.  */\n+\n+typedef struct vn_reference_s\n+{\n+  /* Unique identifier that all expressions with the same value have. */\n+  unsigned int value_id;\n+  hashval_t hashcode;\n+  VEC (tree, gc) *vuses;\n+  VEC (vn_reference_op_s, heap) *operands;\n+  tree result;\n+} *vn_reference_t;\n+typedef const struct vn_reference_s *const_vn_reference_t;\n+\n+typedef struct vn_constant_s\n+{\n+  unsigned int value_id;\n+  hashval_t hashcode;\n+  tree constant;\n+} *vn_constant_t;\n+  \n typedef struct vn_ssa_aux\n {\n   /* Value number. This may be an SSA name or a constant.  */\n   tree valnum;\n   /* Representative expression, if not a direct constant. */\n   tree expr;\n \n+  /* Unique identifier that all expressions with the same value have. */\n+  unsigned int value_id;\n+\n   /* SCC information.  */\n   unsigned int dfsnum;\n   unsigned int low;\n@@ -57,12 +141,31 @@ extern vn_ssa_aux_t VN_INFO_GET (tree);\n bool run_scc_vn (bool);\n void free_scc_vn (void);\n void switch_to_PRE_table (void);\n-tree vn_nary_op_lookup (tree);\n-void vn_nary_op_insert (tree, tree);\n-tree vn_reference_lookup (tree, VEC (tree, gc) *, bool);\n-void vn_reference_insert (tree, tree, VEC (tree, gc) *);\n+tree vn_nary_op_lookup (tree, vn_nary_op_t *);\n+tree vn_nary_op_lookup_pieces (unsigned int, enum tree_code,\n+\t\t\t       tree, tree, tree, tree, tree,\n+\t\t\t       vn_nary_op_t *);\n+vn_nary_op_t vn_nary_op_insert (tree, tree);\n+vn_nary_op_t vn_nary_op_insert_pieces (unsigned int, enum tree_code,\n+\t\t\t\t       tree, tree, tree, tree,\n+\t\t\t\t       tree, tree, unsigned int);\n+tree vn_reference_lookup_pieces (VEC (tree, gc) *,\n+\t\t\t\t VEC (vn_reference_op_s, heap) *,\n+\t\t\t\t vn_reference_t *);\n+tree vn_reference_lookup (tree, VEC (tree, gc) *, bool, vn_reference_t *);\n+vn_reference_t vn_reference_insert (tree, tree, VEC (tree, gc) *);\n+vn_reference_t vn_reference_insert_pieces (VEC (tree, gc) *,\n+\t\t\t\t\t   VEC (vn_reference_op_s, heap) *,\n+\t\t\t\t\t   tree, unsigned int);\n+\n+hashval_t vn_nary_op_compute_hash (const vn_nary_op_t);\n+int vn_nary_op_eq (const void *, const void *);\n+hashval_t vn_reference_compute_hash (const vn_reference_t);\n+int vn_reference_eq (const void *, const void *);\n+unsigned int get_max_value_id (void);\n+unsigned int get_next_value_id (void);\n+unsigned int get_or_alloc_constant_value_id (tree);\n+bool value_id_constant_p (unsigned int);\n VEC (tree, gc) *shared_vuses_from_stmt (tree);\n VEC (tree, gc) *copy_vuses_from_stmt (tree);\n-\n-\n #endif /* TREE_SSA_SCCVN_H  */"}, {"sha": "462da5d60583c720d60d38165bbb7c326a289d5d", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -313,7 +313,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t      copy[i++] = use;\n \t      if (TREE_CODE (use) == SSA_NAME)\n \t\ttmp = SSA_NAME_VALUE (use);\n-\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n+\t      if (tmp)\n \t\tSET_USE (use_p, tmp);\n \t    }\n \n@@ -407,14 +407,14 @@ simplify_control_stmt_condition (edge e,\n       if (TREE_CODE (op0) == SSA_NAME)\n \t{\n           tree tmp = SSA_NAME_VALUE (op0);\n-\t  if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n+\t  if (tmp)\n \t    op0 = tmp;\n \t}\n \n       if (TREE_CODE (op1) == SSA_NAME)\n \t{\n \t  tree tmp = SSA_NAME_VALUE (op1);\n-\t  if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n+\t  if (tmp)\n \t    op1 = tmp;\n \t}\n "}, {"sha": "7ec19cd4b39d5737177d22eed1b0f7066aa2afaa", "filename": "gcc/tree-vn.c", "status": "removed", "additions": 0, "deletions": 406, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771578a0df0245565f21186deb58135c3351f3a7/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771578a0df0245565f21186deb58135c3351f3a7/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=771578a0df0245565f21186deb58135c3351f3a7", "patch": "@@ -1,406 +0,0 @@\n-/* Value Numbering routines for tree expressions.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n-   Foundation, Inc.\n-   Contributed by Daniel Berlin <dan@dberlin.org>, Steven Bosscher\n-   <stevenb@suse.de> and Diego Novillo <dnovillo@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"ggc.h\"\n-#include \"tree.h\"\n-#include \"tree-flow.h\"\n-#include \"hashtab.h\"\n-#include \"langhooks.h\"\n-#include \"tree-pass.h\"\n-#include \"tree-dump.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-ssa-sccvn.h\"\n-\n-/* Most of this is PRE specific.  The real grunt work is done in\n-   tree-ssa-sccvn.c.  This is where the lookup and insertion\n-   functions, etc, can be found.  */\n-\n-/* Create and return a new value handle node of type TYPE.  */\n-\n-tree\n-make_value_handle (tree type)\n-{\n-  static unsigned int id = 0;\n-  tree vh;\n-\n-  vh = build0 (VALUE_HANDLE, type);\n-  VALUE_HANDLE_ID (vh) = id++;\n-  return vh;\n-}\n-\n-/* Compare two expressions E1 and E2 and return true if they are\n-   equal.  */\n-\n-bool\n-expressions_equal_p (tree e1, tree e2)\n-{\n-  tree te1, te2;\n-\n-  if (e1 == e2)\n-    return true;\n-\n-  te1 = TREE_TYPE (e1);\n-  te2 = TREE_TYPE (e2);\n-\n-  if (TREE_CODE (e1) == TREE_LIST && TREE_CODE (e2) == TREE_LIST)\n-    {\n-      tree lop1 = e1;\n-      tree lop2 = e2;\n-      for (lop1 = e1, lop2 = e2;\n-\t   lop1 || lop2;\n-\t   lop1 = TREE_CHAIN (lop1), lop2 = TREE_CHAIN (lop2))\n-\t{\n-\t  if (!lop1 || !lop2)\n-\t    return false;\n-\t  if (!expressions_equal_p (TREE_VALUE (lop1), TREE_VALUE (lop2)))\n-\t    return false;\n-\t}\n-      return true;\n-\n-    }\n-  else if (TREE_CODE (e1) == TREE_CODE (e2)\n-\t   && operand_equal_p (e1, e2, OEP_PURE_SAME))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Set the value handle for expression E to value V.  */\n-\n-void\n-set_value_handle (tree e, tree v)\n-{\n-  if (TREE_CODE (e) == SSA_NAME)\n-    SSA_NAME_VALUE (e) = v;\n-  else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST\n-\t   || GIMPLE_STMT_P (e)\n-\t   || TREE_CODE (e) == CONSTRUCTOR)\n-    get_tree_common_ann (e)->value_handle = v;\n-  else\n-    /* Do nothing.  Constants are their own value handles.  */\n-    gcc_assert (is_gimple_min_invariant (e));\n-}\n-\n-/* Print out the \"Created value <x> for <Y>\" statement to the\n-   dump_file.\n-   This is factored because both versions of lookup use it, and it\n-   obscures the real work going on in those functions.  */\n-\n-static void\n-print_creation_to_file (tree v, tree expr, VEC (tree, gc) *vuses)\n-{\n-  fprintf (dump_file, \"Created value \");\n-  print_generic_expr (dump_file, v, dump_flags);\n-  fprintf (dump_file, \" for \");\n-  print_generic_expr (dump_file, expr, dump_flags);\n-\n-  if (vuses && VEC_length (tree, vuses) != 0)\n-    {\n-      size_t i;\n-      tree vuse;\n-\n-      fprintf (dump_file, \" vuses: (\");\n-      for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n-\t{\n-\t  print_generic_expr (dump_file, vuse, dump_flags);\n-\t  if (VEC_length (tree, vuses) - 1 != i)\n-\t    fprintf (dump_file, \",\");\n-\t}\n-      fprintf (dump_file, \")\");\n-    }\n-  fprintf (dump_file, \"\\n\");\n-}\n-\n-/* Sort the VUSE array so that we can do equality comparisons\n-   quicker on two vuse vecs.  */\n-\n-void\n-sort_vuses (VEC (tree,gc) *vuses)\n-{\n-  if (VEC_length (tree, vuses) > 1)\n-    qsort (VEC_address (tree, vuses),\n-\t   VEC_length (tree, vuses),\n-\t   sizeof (tree),\n-\t   operand_build_cmp);\n-}\n-\n-/* Sort the VUSE array so that we can do equality comparisons\n-   quicker on two vuse vecs.  */\n-\n-void\n-sort_vuses_heap (VEC (tree,heap) *vuses)\n-{\n-  if (VEC_length (tree, vuses) > 1)\n-    qsort (VEC_address (tree, vuses),\n-\t   VEC_length (tree, vuses),\n-\t   sizeof (tree),\n-\t   operand_build_cmp);\n-}\n-\n-/* Insert EXPR into VALUE_TABLE with value VAL, and add expression\n-   EXPR to the value set for value VAL.  */\n-\n-void\n-vn_add (tree expr, tree val)\n-{\n-  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n-    {\n-    case tcc_comparison:\n-    case tcc_binary:\n-      vn_nary_op_insert (expr, val);\n-      break;\n-    case tcc_unary:\n-      vn_nary_op_insert (expr, val);\n-      break;\n-      /* In the case of array-refs of constants, for example, we can\n-\t end up with no vuses.  */\n-    case tcc_reference:\n-      vn_reference_insert (expr, val, NULL);\n-      break;\n-      /* The *only* time CALL_EXPR should appear here is\n-\t when it has no vuses.  */\n-    case tcc_vl_exp:\n-    case tcc_exceptional:\n-    case tcc_expression:\n-    case tcc_declaration:\n-      if (TREE_CODE (expr) == CALL_EXPR || DECL_P (expr))\n-\t{\n-\t  vn_reference_insert (expr, val, NULL);\n-\t  break;\n-\t}\n-      else if (TREE_CODE (expr) == SSA_NAME)\n-\t{\n-\t  SSA_NAME_VALUE (expr) = val;\n-\t  break;\n-\t}\n-      switch (TREE_CODE (expr))\n-\t{\n-\tcase ADDR_EXPR:\n-\tcase TRUTH_AND_EXPR:\n-\tcase TRUTH_OR_EXPR:\n-\tcase TRUTH_XOR_EXPR:\n-\tcase TRUTH_NOT_EXPR:\n-\t  vn_nary_op_insert (expr, val);\n-\t    break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  set_value_handle (expr, val);\n-  if (TREE_CODE (val) == VALUE_HANDLE)\n-    add_to_value (val, expr);\n-}\n-\n-/* Insert EXPR into the value numbering tables with value VAL, and\n-   add expression EXPR to the value set for value VAL.  VUSES\n-   represents the virtual use operands associated with EXPR.  It is\n-   used when computing a hash value for EXPR.  */\n-\n-void\n-vn_add_with_vuses (tree expr, tree val, VEC (tree, gc) *vuses)\n-{\n-  if (!vuses)\n-    {\n-      vn_add (expr, val);\n-      return;\n-    }\n-  vn_reference_insert (expr, val, vuses);\n-\n-  set_value_handle (expr, val);\n-  if (TREE_CODE (val) == VALUE_HANDLE)\n-    add_to_value (val, expr);\n-}\n-\n-/* Lookup EXPR in the value numbering tables and return the result, if\n-   we have one.  */\n-\n-tree\n-vn_lookup (tree expr)\n-{\n-  /* Constants are their own value.  */\n-  if (is_gimple_min_invariant (expr) || TREE_CODE (expr) == FIELD_DECL)\n-    return expr;\n-\n-  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n-    {\n-    case tcc_comparison:\n-    case tcc_binary:\n-      return vn_nary_op_lookup (expr);\n-    case tcc_unary:\n-      return vn_nary_op_lookup (expr);\n-      break;\n-      /* In the case of array-refs of constants, for example, we can\n-\t end up with no vuses.  */\n-    case tcc_reference:\n-      return vn_reference_lookup (expr, NULL, false);\n-      break;\n-      /* It is possible to have CALL_EXPR with no vuses for things\n-\t like \"cos\", and these will fall into vn_lookup.   */\n-    case tcc_vl_exp:\n-    case tcc_exceptional:\n-    case tcc_expression:\n-    case tcc_declaration:\n-      if (TREE_CODE (expr) == CALL_EXPR || DECL_P (expr))\n-\treturn vn_reference_lookup (expr, NULL, false);\n-      else if (TREE_CODE (expr) == SSA_NAME)\n-\treturn SSA_NAME_VALUE (expr);\n-      switch (TREE_CODE (expr))\n-\t{\n-\tcase ADDR_EXPR:\n-\tcase TRUTH_AND_EXPR:\n-\tcase TRUTH_OR_EXPR:\n-\tcase TRUTH_XOR_EXPR:\n-\tcase TRUTH_NOT_EXPR:\n-\t  return vn_nary_op_lookup (expr);\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return NULL;\n-}\n-\n-/* Search in the value numbering tables for an existing instance of\n-   expression EXPR,  and return its value, or NULL if none has been set.  STMT\n-   represents the stmt associated with EXPR.  It is used when computing the\n-   hash value for EXPR for reference operations.  */\n-\n-tree\n-vn_lookup_with_stmt (tree expr, tree stmt)\n-{\n-  if (stmt == NULL)\n-    return vn_lookup (expr);\n-\n-  /* Constants are their own value.  */\n-  if (is_gimple_min_invariant (expr) || TREE_CODE (expr) == FIELD_DECL)\n-    return expr;\n-\n-  return vn_lookup_with_vuses (expr, shared_vuses_from_stmt (stmt));\n-}\n-\n-/* Search in VALUE_TABLE for an existing instance of expression EXPR,\n-   and return its value, or NULL if none has been set.  VUSES is the\n-   list of virtual use operands associated with EXPR.  It is used when\n-   computing the hash value for EXPR.  */\n-\n-tree\n-vn_lookup_with_vuses (tree expr, VEC (tree, gc) *vuses)\n-{\n-  if (!vuses || !VEC_length (tree, vuses))\n-    return vn_lookup (expr);\n-\n-  if (is_gimple_min_invariant (expr) || TREE_CODE (expr) == FIELD_DECL)\n-    return expr;\n-\n-  /* We may not walk the use-def chains here as the alias oracle cannot\n-     properly deal with VALUE_HANDLE tree nodes we feed it here.  */\n-  return vn_reference_lookup (expr, vuses, false);\n-}\n-\n-static tree\n-create_value_handle_for_expr (tree expr, VEC(tree, gc) *vuses)\n-{\n-  tree v;\n-\n-  v = make_value_handle (TREE_TYPE (expr));\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    print_creation_to_file (v, expr, vuses);\n-  return v;\n-}\n-\n-/* Like vn_lookup, but creates a new value for the operation if one\n-   does not exist.  */\n-\n-tree\n-vn_lookup_or_add (tree expr)\n-{\n-  tree v = vn_lookup (expr);\n-\n-  if (v == NULL_TREE)\n-    {\n-      v = create_value_handle_for_expr (expr, NULL);\n-      vn_add (expr, v);\n-    }\n-  else\n-    set_value_handle (expr, v);\n-\n-  return v;\n-}\n-\n-/* Like vn_lookup, but handles reference operations as well by using\n-   STMT to get the set of vuses.  */\n-\n-tree\n-vn_lookup_or_add_with_stmt (tree expr, tree stmt)\n-{\n-  tree v;\n-  if (!stmt)\n-    return vn_lookup_or_add (expr);\n-\n-  v = vn_lookup_with_stmt (expr, stmt);\n-  if (v == NULL_TREE)\n-    {\n-      VEC (tree, gc) *vuses = copy_vuses_from_stmt (stmt);\n-      v = create_value_handle_for_expr (expr, vuses);\n-      vn_add_with_vuses (expr, v, vuses);\n-    }\n-  else\n-    set_value_handle (expr, v);\n-\n-  return v;\n-}\n-\n-/* Like vn_lookup, but creates a new value for expression EXPR, if\n-   EXPR doesn't already have a value.  Return the existing/created\n-   value for EXPR.  STMT represents the stmt associated with EXPR.  It is used\n-   when computing the hash value for EXPR.  */\n-\n-tree\n-vn_lookup_or_add_with_vuses (tree expr, VEC (tree, gc) *vuses)\n-{\n-  tree v;\n-\n-  if (!vuses || VEC_length (tree, vuses) == 0)\n-    return vn_lookup_or_add (expr);\n-\n-  v = vn_lookup_with_vuses (expr, vuses);\n-  if (v == NULL_TREE)\n-    {\n-      v = create_value_handle_for_expr (expr, vuses);\n-      vn_add_with_vuses (expr, v, vuses);\n-    }\n-  else\n-    set_value_handle (expr, v);\n-\n-  return v;\n-}\n-"}, {"sha": "14ecf383f9357bc9f274ed08818d34c7b1d077c4", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -462,7 +462,6 @@ tree_code_size (enum tree_code code)\n \n \tcase STATEMENT_LIST:\treturn sizeof (struct tree_statement_list);\n \tcase BLOCK:\t\treturn sizeof (struct tree_block);\n-\tcase VALUE_HANDLE:\treturn sizeof (struct tree_value_handle);\n \tcase CONSTRUCTOR:\treturn sizeof (struct tree_constructor);\n \n \tdefault:\n@@ -2387,7 +2386,6 @@ tree_node_structure (const_tree t)\n     case BLOCK:\t\t\treturn TS_BLOCK;\n     case CONSTRUCTOR:\t\treturn TS_CONSTRUCTOR;\n     case TREE_BINFO:\t\treturn TS_BINFO;\n-    case VALUE_HANDLE:\t\treturn TS_VALUE_HANDLE;\n     case OMP_CLAUSE:\t\treturn TS_OMP_CLAUSE;\n \n     default:\n@@ -3639,7 +3637,7 @@ build_decl_attribute_variant (tree ddecl, tree attribute)\n \n \n /* Produce good hash value combining VAL and VAL2.  */\n-static inline hashval_t\n+hashval_t\n iterative_hash_hashval_t (hashval_t val, hashval_t val2)\n {\n   /* the golden ratio; an arbitrary value.  */\n@@ -5358,7 +5356,6 @@ iterative_hash_expr (const_tree t, hashval_t val)\n       return iterative_hash_expr (TREE_VECTOR_CST_ELTS (t), val);\n \n     case SSA_NAME:\n-    case VALUE_HANDLE:\n       /* we can just compare by pointer.  */\n       return iterative_hash_pointer (t, val);\n "}, {"sha": "48b2f1cbde1cc77dea0310c41c420d422218a2db", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -925,12 +925,6 @@ DEFTREECODE (POLYNOMIAL_CHREC, \"polynomial_chrec\", tcc_expression, 3)\n    Use the interface in tree-iterator.h to access this node.  */\n DEFTREECODE (STATEMENT_LIST, \"statement_list\", tcc_exceptional, 0)\n \n-/* Value handles.  Artificial nodes to represent expressions in\n-   partial redundancy elimination (tree-ssa-pre.c).  These nodes are\n-   used for expression canonicalization.  If two expressions compute\n-   the same value, they will be assigned the same value handle.  */\n-DEFTREECODE (VALUE_HANDLE, \"value_handle\", tcc_exceptional, 0)\n-\n /* Predicate assertion.  Artificial expression generated by the optimizers\n    to keep track of predicate values.  This expression may only appear on\n    the RHS of assignments."}, {"sha": "f5b2f66f65c4690381cd62436e1d5a0013ebf9f7", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -3492,26 +3492,6 @@ struct tree_statement_list\n   struct tree_statement_list_node *tail;\n };\n \n-#define VALUE_HANDLE_ID(NODE)\t\t\\\n-  (VALUE_HANDLE_CHECK (NODE)->value_handle.id)\n-\n-#define VALUE_HANDLE_EXPR_SET(NODE)\t\\\n-  (VALUE_HANDLE_CHECK (NODE)->value_handle.expr_set)\n-\n-/* Defined and used in tree-ssa-pre.c.  */\n-\n-struct tree_value_handle GTY(())\n-{\n-  struct tree_common common;\n-\n-  /* The set of expressions represented by this handle.  */\n-  struct bitmap_set * GTY ((skip)) expr_set;\n-\n-  /* Unique ID for this value handle.  IDs are handed out in a\n-     conveniently dense form starting at 0, so that we can make\n-     bitmaps of value handles.  */\n-  unsigned int id;\n-};\n \f\n /* Define the overall contents of a tree node.\n    It may be any of the structures declared above\n@@ -3552,7 +3532,6 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_binfo GTY ((tag (\"TS_BINFO\"))) binfo;\n   struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n   struct gimple_stmt GTY ((tag (\"TS_GIMPLE_STATEMENT\"))) gstmt;\n-  struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n   struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n   struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n   struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n@@ -4964,6 +4943,7 @@ extern int tree_log2 (const_tree);\n extern int tree_floor_log2 (const_tree);\n extern int simple_cst_equal (const_tree, const_tree);\n extern hashval_t iterative_hash_expr (const_tree, hashval_t);\n+extern hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);\n extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);\n extern int type_list_equal (const_tree, const_tree);\n extern int chain_member (const_tree, const_tree);"}, {"sha": "cdf52704ebdcda9f25439aa1c342212a2106098e", "filename": "gcc/treestruct.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91457541d06789db54fa7ce42fba6a91f53bafe/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=c91457541d06789db54fa7ce42fba6a91f53bafe", "patch": "@@ -59,7 +59,6 @@ DEFTREESTRUCT(TS_BLOCK, \"block\")\n DEFTREESTRUCT(TS_BINFO, \"binfo\")\n DEFTREESTRUCT(TS_STATEMENT_LIST, \"statement list\")\n DEFTREESTRUCT(TS_GIMPLE_STATEMENT, \"gimple statement\")\n-DEFTREESTRUCT(TS_VALUE_HANDLE, \"value handle\")\n DEFTREESTRUCT(TS_CONSTRUCTOR, \"constructor\")\n DEFTREESTRUCT(TS_MEMORY_TAG, \"memory tag\")\n DEFTREESTRUCT(TS_OMP_CLAUSE, \"omp clause\")"}]}