{"sha": "9108699053ebb8ac2493f3f9efa97d1e228182f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwODY5OTA1M2ViYjhhYzI0OTNmM2Y5ZWZhOTdkMWUyMjgxODJmNQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-09-30T21:23:29Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-09-30T21:23:29Z"}, "message": "s390-protos.h (s390_arg_frame_offset): Remove.\n\n\t* config/s390/s390-protos.h (s390_arg_frame_offset): Remove.\n\t(s390_return_address_offset): Remove.\n\t(s390_can_eliminate): Add prototype.\n\t(s390_initial_elimination_offset): Add prototype.\n\t* config/s390/s390.h (CAN_ELIMINATE): Call s390_can_eliminate.\n\t(INITIAL_ELIMINATION_OFFSET): Call s390_initial_elimination_offset.\n\t* config/s390/s390.c (s390_arg_frame_offset): Remove.\n\t(s390_return_address_offset): Remove.\n\t(s390_can_eliminate, s390_initial_elimination_offset): New functions.\n\t(struct machine_function): New member split_branches_pending_p.\n\t(s390_mainpool_start): Allow nonexistant pool insn for empty pool.\n\t(s390_mainpool_finish): Likewise.  Clear base_reg if pool empty.\n\t(s390_optimize_prologue): Remove base_used argument.  Call\n\ts390_update_frame_layout instead of s390_register_info.  Handle\n\tprologue/epilogue insns that touch only RETURN_REGNUM.\n\t(s390_reorg): Remove base_used.  Clear split_branches_pending_p.\n\t(s390_register_info): Remove base_used and return_addr_used\n\targuments, compute special register usage inline.  Return live\n\tregister data to caller.\n\t(s390_frame_info): Remove arguments, do not call s390_register_info.\n\t(s390_init_frame_layout): New function.\n\t(s390_update_frame_layout): Likewise.\n\t(s390_emit_prologue): Call s390_update_frame_layout; some code\n\tmove to there.  Do not emit pool placeholder insn if unnecessary.\n\nFrom-SVN: r88357", "tree": {"sha": "81a32418ffd1c56b733fb0bb0b171fbf1dea4bed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81a32418ffd1c56b733fb0bb0b171fbf1dea4bed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9108699053ebb8ac2493f3f9efa97d1e228182f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9108699053ebb8ac2493f3f9efa97d1e228182f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9108699053ebb8ac2493f3f9efa97d1e228182f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9108699053ebb8ac2493f3f9efa97d1e228182f5/comments", "author": null, "committer": null, "parents": [{"sha": "13c025c1866a201fc46ffdbd3438f0cfea37c1a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c025c1866a201fc46ffdbd3438f0cfea37c1a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c025c1866a201fc46ffdbd3438f0cfea37c1a0"}], "stats": {"total": 334, "additions": 211, "deletions": 123}, "files": [{"sha": "c658bc085a46a0a541a3153e16cdecf8d55f3b77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9108699053ebb8ac2493f3f9efa97d1e228182f5", "patch": "@@ -1,3 +1,30 @@\n+2004-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_arg_frame_offset): Remove.\n+\t(s390_return_address_offset): Remove.\n+\t(s390_can_eliminate): Add prototype.\n+\t(s390_initial_elimination_offset): Add prototype.\n+\t* config/s390/s390.h (CAN_ELIMINATE): Call s390_can_eliminate.\n+\t(INITIAL_ELIMINATION_OFFSET): Call s390_initial_elimination_offset.\n+\t* config/s390/s390.c (s390_arg_frame_offset): Remove.\n+\t(s390_return_address_offset): Remove.\n+\t(s390_can_eliminate, s390_initial_elimination_offset): New functions.\n+\t(struct machine_function): New member split_branches_pending_p.\n+\t(s390_mainpool_start): Allow nonexistant pool insn for empty pool.\n+\t(s390_mainpool_finish): Likewise.  Clear base_reg if pool empty.\n+\t(s390_optimize_prologue): Remove base_used argument.  Call\n+\ts390_update_frame_layout instead of s390_register_info.  Handle\n+\tprologue/epilogue insns that touch only RETURN_REGNUM.\n+\t(s390_reorg): Remove base_used.  Clear split_branches_pending_p.\n+\t(s390_register_info): Remove base_used and return_addr_used \n+\targuments, compute special register usage inline.  Return live\n+\tregister data to caller.\n+\t(s390_frame_info): Remove arguments, do not call s390_register_info.\n+\t(s390_init_frame_layout): New function.\n+\t(s390_update_frame_layout): Likewise.\n+\t(s390_emit_prologue): Call s390_update_frame_layout; some code\n+\tmove to there.  Do not emit pool placeholder insn if unnecessary.\n+\n 2004-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (legitimate_reload_constant_p): Remove"}, {"sha": "d1407c19c5a50e562d58efdb211d72e69fb54dd0", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=9108699053ebb8ac2493f3f9efa97d1e228182f5", "patch": "@@ -23,8 +23,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n extern void optimization_options (int, int);\n extern void override_options (void);\n-extern HOST_WIDE_INT s390_arg_frame_offset (void);\n-extern HOST_WIDE_INT s390_return_address_offset (void);\n+extern bool s390_can_eliminate (int, int);\n+extern HOST_WIDE_INT s390_initial_elimination_offset (int, int);\n extern void s390_emit_prologue (void);\n extern void s390_emit_epilogue (bool);\n extern void s390_function_profiler (FILE *, int);"}, {"sha": "073d9dfedf0312c114f189b7df044cd3fede84e8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 177, "deletions": 101, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9108699053ebb8ac2493f3f9efa97d1e228182f5", "patch": "@@ -254,6 +254,9 @@ struct machine_function GTY(())\n   /* Literal pool base register.  */\n   rtx base_reg;\n \n+  /* True if we may need to perform branch splitting.  */\n+  bool split_branches_pending_p;\n+\n   /* Some local-dynamic TLS symbol name.  */\n   const char *some_ld_name;\n };\n@@ -289,11 +292,13 @@ static void find_constant_pool_ref (rtx, rtx *);\n static void replace_constant_pool_ref (rtx *, rtx, rtx);\n static rtx find_ltrel_base (rtx);\n static void replace_ltrel_base (rtx *);\n-static void s390_optimize_prologue (bool);\n+static void s390_optimize_prologue (void);\n static int find_unused_clobbered_reg (void);\n static void s390_frame_area (int *, int *);\n-static void s390_register_info (int, int);\n-static void s390_frame_info (int, int);\n+static void s390_register_info (int []);\n+static void s390_frame_info (void);\n+static void s390_init_frame_layout (void);\n+static void s390_update_frame_layout (void);\n static rtx save_fpr (rtx, int, int);\n static rtx restore_fpr (rtx, int, int);\n static rtx save_gprs (rtx, int, int, int);\n@@ -4895,7 +4900,7 @@ s390_mainpool_start (void)\n \t}\n     }\n \n-  if (!pool->pool_insn)\n+  if (!pool->pool_insn && pool->size > 0)\n     abort ();\n \n   if (pool->size >= 4096)\n@@ -4918,13 +4923,17 @@ s390_mainpool_start (void)\n static void\n s390_mainpool_finish (struct constant_pool *pool)\n {\n-  rtx base_reg = SET_DEST (PATTERN (pool->pool_insn));\n+  rtx base_reg = cfun->machine->base_reg;\n   rtx insn;\n \n   /* If the pool is empty, we're done.  */\n   if (pool->size == 0)\n     {\n-      remove_insn (pool->pool_insn);\n+      /* We don't actually need a base register after all.  */\n+      cfun->machine->base_reg = NULL_RTX;\n+\n+      if (pool->pool_insn)\n+\tremove_insn (pool->pool_insn);\n       s390_free_pool (pool);\n       return;\n     }\n@@ -5437,20 +5446,16 @@ s390_output_pool_entry (rtx exp, enum machine_mode mode, unsigned int align)\n \n \n /* Rework the prologue/epilogue to avoid saving/restoring\n-   registers unnecessarily.  BASE_USED specifies whether\n-   the literal pool base register needs to be saved.  */\n+   registers unnecessarily.  */\n \n static void\n-s390_optimize_prologue (bool base_used)\n+s390_optimize_prologue (void)\n {\n   rtx insn, new_insn, next_insn;\n \n   /* Do a final recompute of the frame-related data.  */\n \n-  s390_register_info (base_used, cfun_frame_layout.save_return_addr_p);\n-  regs_ever_live[BASE_REGNUM] = base_used;\n-  regs_ever_live[RETURN_REGNUM] = cfun_frame_layout.save_return_addr_p;\n-  regs_ever_live[STACK_POINTER_REGNUM] = cfun_frame_layout.frame_size > 0;\n+  s390_update_frame_layout ();\n \n   /* If all special registers are in fact used, there's nothing we\n      can do, so no point in walking the insn list.  */\n@@ -5509,10 +5514,13 @@ s390_optimize_prologue (bool base_used)\n \n       if (GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == REG\n-\t  && REGNO (SET_SRC (PATTERN (insn))) == BASE_REGNUM\n+\t  && (REGNO (SET_SRC (PATTERN (insn))) == BASE_REGNUM\n+\t      || (!TARGET_CPU_ZARCH\n+\t\t  && REGNO (SET_SRC (PATTERN (insn))) == RETURN_REGNUM))\n \t  && GET_CODE (SET_DEST (PATTERN (insn))) == MEM)\n \t{\n \t  set = PATTERN (insn);\n+\t  first = REGNO (SET_SRC (set));\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n \t  off = INTVAL (offset);\n@@ -5526,7 +5534,7 @@ s390_optimize_prologue (bool base_used)\n \t    {\n \t      new_insn = save_gprs (base, \n \t\t\t\t    off + (cfun_frame_layout.first_save_gpr \n-\t\t\t\t\t   - BASE_REGNUM) * UNITS_PER_WORD, \n+\t\t\t\t\t   - first) * UNITS_PER_WORD, \n \t\t\t\t    cfun_frame_layout.first_save_gpr,\n \t\t\t\t    cfun_frame_layout.last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n@@ -5572,10 +5580,13 @@ s390_optimize_prologue (bool base_used)\n \n       if (GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n-\t  && REGNO (SET_DEST (PATTERN (insn))) == BASE_REGNUM\n+\t  && (REGNO (SET_DEST (PATTERN (insn))) == BASE_REGNUM\n+\t      || (!TARGET_CPU_ZARCH\n+\t\t  && REGNO (SET_DEST (PATTERN (insn))) == RETURN_REGNUM))\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == MEM)\n \t{\n \t  set = PATTERN (insn);\n+\t  first = REGNO (SET_DEST (set));\n \t  offset = const0_rtx;\n \t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n \t  off = INTVAL (offset);\n@@ -5589,7 +5600,7 @@ s390_optimize_prologue (bool base_used)\n \t    {\n \t      new_insn = restore_gprs (base, \n \t\t\t\t       off + (cfun_frame_layout.first_restore_gpr \n-\t\t\t\t\t      - BASE_REGNUM) * UNITS_PER_WORD,\n+\t\t\t\t\t      - first) * UNITS_PER_WORD,\n \t\t\t\t       cfun_frame_layout.first_restore_gpr,\n \t\t\t\t       cfun_frame_layout.last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n@@ -5607,7 +5618,6 @@ s390_optimize_prologue (bool base_used)\n static void\n s390_reorg (void)\n {\n-  bool base_used = false;\n   bool pool_overflow = false;\n \n   /* Make sure all splits have been performed; splits after\n@@ -5680,19 +5690,17 @@ s390_reorg (void)\n \n       /* If we made it up to here, both conditions are satisfied.\n \t Finish up literal pool related changes.  */\n-      if ((pool_overflow || pool->size > 0)\n-\t   && REGNO (cfun->machine->base_reg) == BASE_REGNUM)\n-\tbase_used = true;\n-\n       if (pool_overflow)\n \ts390_chunkify_finish (pool);\n       else\n \ts390_mainpool_finish (pool);\n \n+      /* We're done splitting branches.  */\n+      cfun->machine->split_branches_pending_p = false;\n       break;\n     }\n \n-  s390_optimize_prologue (base_used);\n+  s390_optimize_prologue ();\n }\n \n \n@@ -5806,14 +5814,12 @@ s390_frame_area (int *area_bottom, int *area_top)\n   *area_top = t;\n }\n \n-/* Fill cfun->machine with info about register usage of current \n-   function. BASE_USED and RETURN_ADDR_USED specify whether we assume the\n-   base and return address register will need to be saved.  */\n+/* Fill cfun->machine with info about register usage of current function.\n+   Return in LIVE_REGS which GPRs are currently considered live.  */\n \n static void\n-s390_register_info (int base_used, int return_addr_used)\n+s390_register_info (int live_regs[])\n {\n-  int live_regs[16];\n   int i, j;\n \n   /* fprs 8 - 15 are call saved for 64 Bit ABI.  */\n@@ -5837,17 +5843,24 @@ s390_register_info (int base_used, int return_addr_used)\n     live_regs[i] = regs_ever_live[i] && !global_regs[i];\n \n   if (flag_pic)\n-    live_regs[PIC_OFFSET_TABLE_REGNUM] = \n-    regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n-\n-  live_regs[BASE_REGNUM] = base_used;\n-  live_regs[RETURN_REGNUM] = return_addr_used;\n-  live_regs[STACK_POINTER_REGNUM] = (!current_function_is_leaf\n-\t\t\t\t     || TARGET_TPF_PROFILING\n-\t\t\t\t     || cfun_save_high_fprs_p\n-\t\t\t\t     || get_frame_size () > 0\n-\t\t\t\t     || current_function_calls_alloca\n-\t\t\t\t     || current_function_stdarg);\n+    live_regs[PIC_OFFSET_TABLE_REGNUM] \n+    = regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n+\n+  live_regs[BASE_REGNUM] \n+    = cfun->machine->base_reg\n+      && REGNO (cfun->machine->base_reg) == BASE_REGNUM;\n+\n+  live_regs[RETURN_REGNUM]\n+    = cfun->machine->split_branches_pending_p\n+      || cfun_frame_layout.save_return_addr_p;\n+\n+  live_regs[STACK_POINTER_REGNUM]\n+    = !current_function_is_leaf\n+      || TARGET_TPF_PROFILING\n+      || cfun_save_high_fprs_p\n+      || get_frame_size () > 0\n+      || current_function_calls_alloca\n+      || current_function_stdarg;\n   \n   for (i = 6; i < 16; i++)\n     if (live_regs[i])\n@@ -5895,19 +5908,14 @@ s390_register_info (int base_used, int return_addr_used)\n \tcfun_set_fpr_bit (i);\n }\n \n-/* Fill cfun->machine with info about frame of current \n-   function. BASE_USED and RETURN_ADDR_USED specify whether we assume the\n-   base and return address register will need to be saved.  */\n+/* Fill cfun->machine with info about frame of current function.  */\n \n static void\n-s390_frame_info (int base_used, int return_addr_used)\n+s390_frame_info (void)\n {\n   int i;\n \n   cfun_frame_layout.frame_size = get_frame_size ();\n-\n-  s390_register_info (base_used, return_addr_used);\n-\n   if (!TARGET_64BIT && cfun_frame_layout.frame_size > 0x7fff0000)\n     fatal_error (\"Total size of local variables exceeds architecture limit.\");\n   \n@@ -6011,37 +6019,136 @@ s390_frame_info (int base_used, int return_addr_used)\n     }\n }\n \n-/* Return offset between argument pointer and frame pointer\n-   initially after prologue.  */\n+/* Generate frame layout.  Fills in register and frame data for the current\n+   function in cfun->machine.  This routine can be called multiple times;\n+   it will re-do the complete frame layout every time.  */\n \n-HOST_WIDE_INT\n-s390_arg_frame_offset (void)\n+static void\n+s390_init_frame_layout (void)\n+{\n+  HOST_WIDE_INT frame_size;\n+  int base_used;\n+  int live_regs[16];\n+\n+  /* If return address register is explicitly used, we need to save it.  */\n+  if (regs_ever_live[RETURN_REGNUM]\n+      || !current_function_is_leaf\n+      || TARGET_TPF_PROFILING\n+      || current_function_stdarg\n+      || current_function_calls_eh_return)\n+    cfun_frame_layout.save_return_addr_p = true;\n+\n+  /* On S/390 machines, we may need to perform branch splitting, which\n+     will require both base and return address register.  We have no\n+     choice but to assume we're going to need them until right at the\n+     end of the machine dependent reorg phase.  */\n+  if (!TARGET_CPU_ZARCH)\n+    cfun->machine->split_branches_pending_p = true;\n+\n+  do\n+    {\n+      frame_size = cfun_frame_layout.frame_size;\n+\n+      /* Try to predict whether we'll need the base register.  */\n+      base_used = cfun->machine->split_branches_pending_p\n+\t\t  || current_function_uses_const_pool\n+\t\t  || (!DISP_IN_RANGE (-frame_size)\n+\t\t      && !CONST_OK_FOR_CONSTRAINT_P (-frame_size, 'K', \"K\"));\n+\n+      /* Decide which register to use as literal pool base.  In small\n+\t leaf functions, try to use an unused call-clobbered register\n+\t as base register to avoid save/restore overhead.  */\n+      if (!base_used)\n+\tcfun->machine->base_reg = NULL_RTX;\n+      else if (current_function_is_leaf && !regs_ever_live[5])\n+\tcfun->machine->base_reg = gen_rtx_REG (Pmode, 5);\n+      else\n+\tcfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGNUM);\n+\n+      s390_register_info (live_regs);\n+      s390_frame_info ();\n+    }\n+  while (frame_size != cfun_frame_layout.frame_size);\n+}\n+\n+/* Update frame layout.  Recompute actual register save data based on\n+   current info and update regs_ever_live for the special registers.\n+   May be called multiple times, but may never cause *more* registers\n+   to be saved than s390_init_frame_layout allocated room for.  */\n+\n+static void\n+s390_update_frame_layout (void)\n+{\n+  int live_regs[16];\n+\n+  s390_register_info (live_regs);\n+\n+  regs_ever_live[BASE_REGNUM] = live_regs[BASE_REGNUM];\n+  regs_ever_live[RETURN_REGNUM] = live_regs[RETURN_REGNUM];\n+  regs_ever_live[STACK_POINTER_REGNUM] = live_regs[STACK_POINTER_REGNUM];\n+\n+  if (cfun->machine->base_reg)\n+    regs_ever_live[REGNO (cfun->machine->base_reg)] = 1;\n+}\n+\n+/* Return true if register FROM can be eliminated via register TO.  */\n+\n+bool\n+s390_can_eliminate (int from, int to)\n {\n-  /* See the comment in s390_emit_prologue about the assumptions we make\n-     whether or not the base and return address register need to be saved.  */\n-  int return_addr_used = !current_function_is_leaf\n-\t\t\t || TARGET_TPF_PROFILING\n-\t\t\t || regs_ever_live[RETURN_REGNUM]\n-\t\t\t || cfun_frame_layout.save_return_addr_p;\n+  gcc_assert (to == STACK_POINTER_REGNUM\n+\t      || to == HARD_FRAME_POINTER_REGNUM);\n+\n+  gcc_assert (from == FRAME_POINTER_REGNUM\n+\t      || from == ARG_POINTER_REGNUM\n+\t      || from == RETURN_ADDRESS_POINTER_REGNUM);\n \n-  s390_frame_info (1, !TARGET_CPU_ZARCH || return_addr_used);\n+  /* Make sure we actually saved the return address.  */\n+  if (from == RETURN_ADDRESS_POINTER_REGNUM)\n+    if (!current_function_calls_eh_return\n+\t&& !current_function_stdarg\n+\t&& !cfun_frame_layout.save_return_addr_p)\n+      return false;\n \n-  return cfun_frame_layout.frame_size + STACK_POINTER_OFFSET;\n+  return true;\n }\n \n-/* Return offset between return address pointer (location of r14\n-   on the stack) and frame pointer initially after prologue.  */\n+/* Return offset between register FROM and TO initially after prolog.  */\n \n HOST_WIDE_INT\n-s390_return_address_offset (void)\n+s390_initial_elimination_offset (int from, int to)\n {\n-  s390_frame_info (1, 1);\n+  HOST_WIDE_INT offset;\n+  int index;\n \n-  if (cfun_frame_layout.last_save_gpr < RETURN_REGNUM)\n-    abort ();\n+  /* ??? Why are we called for non-eliminable pairs?  */\n+  if (!s390_can_eliminate (from, to))\n+    return 0;\n+\n+  switch (from)\n+    {\n+    case FRAME_POINTER_REGNUM:\n+      offset = 0;\n+      break;\n+\n+    case ARG_POINTER_REGNUM:\n+      s390_init_frame_layout ();\n+      offset = cfun_frame_layout.frame_size + STACK_POINTER_OFFSET;\n+      break;\n \n-  return (cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset\n-\t  + (RETURN_REGNUM - cfun_frame_layout.first_save_gpr) * UNITS_PER_WORD);\n+    case RETURN_ADDRESS_POINTER_REGNUM:\n+      s390_init_frame_layout ();\n+      index = RETURN_REGNUM - cfun_frame_layout.first_save_gpr;\n+      gcc_assert (index >= 0);\n+      offset = cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset;\n+      offset += index * UNITS_PER_WORD;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return offset;\n }\n \n /* Emit insn to save fpr REGNUM at offset OFFSET relative\n@@ -6230,41 +6337,9 @@ s390_emit_prologue (void)\n   int offset;\n   int next_fpr = 0;\n \n-  /* At this point, we decide whether we'll need to save/restore the\n-     return address register.  This decision is final on zSeries machines;\n-     on S/390 it can still be overridden in s390_split_branches.  */\n-\n-  if (!current_function_is_leaf\n-      || TARGET_TPF_PROFILING\n-      || regs_ever_live[RETURN_REGNUM])\n-    cfun_frame_layout.save_return_addr_p = 1;\n-\n-  /* Decide which register to use as literal pool base.  In small leaf \n-     functions, try to use an unused call-clobbered register as base \n-     register to avoid save/restore overhead.  */\n-\n-  if (current_function_is_leaf && !regs_ever_live[5])\n-    cfun->machine->base_reg = gen_rtx_REG (Pmode, 5);\n-  else\n-    cfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGNUM);\n-\n-  regs_ever_live[REGNO (cfun->machine->base_reg)] = 1;\n-\n-  /* Compute frame info.  Note that at this point, we assume the base \n-     register and -on S/390- the return register always need to be saved.\n-     This is done because the usage of these registers might change even \n-     after the prologue was emitted.  If it turns out later that we really \n-     don't need them, the prologue/epilogue code is modified again.  */\n-\n-  s390_frame_info (1, !TARGET_CPU_ZARCH\n-\t\t   || cfun_frame_layout.save_return_addr_p);\n-\n-  /* We need to update regs_ever_live to avoid data-flow problems.  */\n+  /* Complete frame layout.  */\n \n-  regs_ever_live[BASE_REGNUM] = 1;\n-  regs_ever_live[RETURN_REGNUM] = (!TARGET_CPU_ZARCH \n-\t\t\t\t   || cfun_frame_layout.save_return_addr_p);\n-  regs_ever_live[STACK_POINTER_REGNUM] = cfun_frame_layout.frame_size > 0;\n+  s390_update_frame_layout ();\n \n   /* Annotate all constant pool references to let the scheduler know\n      they implicitly use the base register.  */\n@@ -6297,7 +6372,8 @@ s390_emit_prologue (void)\n \n   /* Dummy insn to mark literal pool slot.  */\n \n-  emit_insn (gen_main_pool (cfun->machine->base_reg));\n+  if (cfun->machine->base_reg)\n+    emit_insn (gen_main_pool (cfun->machine->base_reg));\n \n   offset = cfun_frame_layout.f0_offset;\n "}, {"sha": "9814561e0526b3be1e7d7f14fb71e5ee03bd66b3", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9108699053ebb8ac2493f3f9efa97d1e228182f5/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=9108699053ebb8ac2493f3f9efa97d1e228182f5", "patch": "@@ -652,26 +652,11 @@ extern int current_function_outgoing_args_size;\n  { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},     \\\n  { RETURN_ADDRESS_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n \n-#define CAN_ELIMINATE(FROM, TO) (1)\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t  \\\n-{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \t  \\\n-  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n-  else  if ((FROM) == FRAME_POINTER_REGNUM                                \\\n-\t    && (TO) == HARD_FRAME_POINTER_REGNUM)                \t  \\\n-  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n-  else if ((FROM) == ARG_POINTER_REGNUM                                   \\\n-            && (TO) == HARD_FRAME_POINTER_REGNUM)                         \\\n-  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)  \\\n-  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n-  else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM                        \\\n-            && ((TO) == STACK_POINTER_REGNUM                              \\\n-                || (TO) == HARD_FRAME_POINTER_REGNUM))                    \\\n-  { (OFFSET) = s390_return_address_offset (); }     \t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    abort();\t\t\t\t\t\t\t\t  \\\n-}\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  s390_can_eliminate ((FROM), (TO))\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  (OFFSET) = s390_initial_elimination_offset ((FROM), (TO))\n \n \n /* Stack arguments.  */"}]}