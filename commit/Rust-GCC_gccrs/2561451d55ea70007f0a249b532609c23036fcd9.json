{"sha": "2561451d55ea70007f0a249b532609c23036fcd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU2MTQ1MWQ1NWVhNzAwMDdmMGEyNDliNTMyNjA5YzIzMDM2ZmNkOQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-11-20T11:48:07Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-11-20T11:48:07Z"}, "message": "[multiple changes]\n\n2013-11-20  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\t    Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_canonicalize_comparison): Don't fold\n\tint comparisons with an out of range condition code.\n\t(s390_optimize_nonescaping_tx): Skip empty BBs.\n\tGenerate the new tbegin RTX when removing the FPR clobbers (with\n\ttwo SETs).\n\t(s390_expand_tbegin): Fix the retry loop counter.  Copy CC to the\n\tresult before doing the retry calculations.\n\t(s390_init_builtins): Make tbegin \"returns_twice\" and tabort\n\t\"noreturn\".\n\t* config/s390/s390.md (UNSPECV_TBEGIN_TDB): New constant used for\n\tthe TDB setting part of an tbegin.\n\t(\"tbegin_1\", \"tbegin_nofloat_1\"): Add a set for the TDB.\n\t(\"tx_assist\"): Set unused argument to an immediate zero instead of\n\tloading zero into a GPR and pass it as argument.\n\t* config/s390/htmxlintrin.h (__TM_simple_begin, __TM_begin):\n\tRemove inline and related attributes.\n\t(__TM_nesting_depth, __TM_is_user_abort, __TM_is_named_user_abort)\n\t(__TM_is_illegal, __TM_is_footprint_exceeded)\n\t(__TM_is_nested_too_deep, __TM_is_conflict): Fix format value\n\tcheck.\n\n2013-11-20  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/htm-1.c: Rename to ...\n\t* gcc/testsuite/gcc.target/s390/htm-builtins-compile-1.c: ... this\n\tone.\n\t* gcc.target/s390/htm-xl-intrin-1.c: Rename to ...\n\t* gcc.target/s390/htm-builtins-compile-3.c: ... this one.\n\t* gcc.target/s390/htm-builtins-compile-2.c: New testcase.\n\t* gcc.target/s390/htm-builtins-1.c: New testcase.\n\t* gcc.target/s390/htm-builtins-2.c: New testcase.\n\t* gcc.target/s390/s390.exp: Add check for htm machine.\n\nFrom-SVN: r205099", "tree": {"sha": "1d3caac0af3932767d6ac75f4056c95a438913c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d3caac0af3932767d6ac75f4056c95a438913c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2561451d55ea70007f0a249b532609c23036fcd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2561451d55ea70007f0a249b532609c23036fcd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2561451d55ea70007f0a249b532609c23036fcd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2561451d55ea70007f0a249b532609c23036fcd9/comments", "author": null, "committer": null, "parents": [{"sha": "5d1a0108f1b72f8cb3224cc465b2f67421210181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d1a0108f1b72f8cb3224cc465b2f67421210181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d1a0108f1b72f8cb3224cc465b2f67421210181"}], "stats": {"total": 2154, "additions": 2040, "deletions": 114}, "files": [{"sha": "dbe26236c51f2626e233188d673457e87ea60baa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -1,3 +1,27 @@\n+2013-11-20  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\t    Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_canonicalize_comparison): Don't fold\n+\tint comparisons with an out of range condition code.\n+\t(s390_optimize_nonescaping_tx): Skip empty BBs.\n+\tGenerate the new tbegin RTX when removing the FPR clobbers (with\n+\ttwo SETs).\n+\t(s390_expand_tbegin): Fix the retry loop counter.  Copy CC to the\n+\tresult before doing the retry calculations.\n+\t(s390_init_builtins): Make tbegin \"returns_twice\" and tabort\n+\t\"noreturn\".\n+\t* config/s390/s390.md (UNSPECV_TBEGIN_TDB): New constant used for\n+\tthe TDB setting part of an tbegin.\n+\t(\"tbegin_1\", \"tbegin_nofloat_1\"): Add a set for the TDB.\n+\t(\"tx_assist\"): Set unused argument to an immediate zero instead of\n+\tloading zero into a GPR and pass it as argument.\n+\t* config/s390/htmxlintrin.h (__TM_simple_begin, __TM_begin):\n+\tRemove inline and related attributes.\n+\t(__TM_nesting_depth, __TM_is_user_abort, __TM_is_named_user_abort)\n+\t(__TM_is_illegal, __TM_is_footprint_exceeded)\n+\t(__TM_is_nested_too_deep, __TM_is_conflict): Fix format value\n+\tcheck.\n+\n 2013-11-20  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/59035"}, {"sha": "d1c7ec566e140f6db1e6300f8b38c02890b9ce08", "filename": "gcc/config/s390/htmxlintrin.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -33,13 +33,20 @@ extern \"C\" {\n    the IBM XL compiler.  For documentation please see the \"z/OS XL\n    C/C++ Programming Guide\" publicly available on the web.  */\n \n-extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+/* FIXME: __TM_simple_begin and __TM_begin should be marked\n+   __always_inline__ as well but this currently produces an error\n+   since the tbegin builtins are \"returns_twice\" and setjmp_call_p\n+   (calls.c) therefore identifies the functions as calling setjmp.\n+   The tree inliner currently refuses to inline functions calling\n+   setjmp.  */\n+\n+long\n __TM_simple_begin ()\n {\n   return __builtin_tbegin_nofloat (0);\n }\n \n-extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+long\n __TM_begin (void* const tdb)\n {\n   return __builtin_tbegin_nofloat (tdb);\n@@ -78,7 +85,7 @@ __TM_nesting_depth (void* const tdb_ptr)\n   if (depth != 0)\n     return depth;\n \n-  if (tdb->format == 0)\n+  if (tdb->format != 1)\n     return 0;\n   return tdb->nesting_depth;\n }\n@@ -90,7 +97,7 @@ __TM_is_user_abort (void* const tdb_ptr)\n {\n   struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n \n-  if (tdb->format == 0)\n+  if (tdb->format != 1)\n     return 0;\n \n   return !!(tdb->abort_code >= _HTM_FIRST_USER_ABORT_CODE);\n@@ -101,7 +108,7 @@ __TM_is_named_user_abort (void* const tdb_ptr, unsigned char* code)\n {\n   struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n \n-  if (tdb->format == 0)\n+  if (tdb->format != 1)\n     return 0;\n \n   if (tdb->abort_code >= _HTM_FIRST_USER_ABORT_CODE)\n@@ -117,7 +124,7 @@ __TM_is_illegal (void* const tdb_ptr)\n {\n   struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n \n-  return (tdb->format == 0\n+  return (tdb->format == 1\n \t  && (tdb->abort_code == 4 /* unfiltered program interruption */\n \t      || tdb->abort_code == 11 /* restricted instruction */));\n }\n@@ -127,7 +134,7 @@ __TM_is_footprint_exceeded (void* const tdb_ptr)\n {\n   struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n \n-  return (tdb->format == 0\n+  return (tdb->format == 1\n \t  && (tdb->abort_code == 7 /* fetch overflow */\n \t      || tdb->abort_code == 8 /* store overflow */));\n }\n@@ -137,15 +144,15 @@ __TM_is_nested_too_deep (void* const tdb_ptr)\n {\n   struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n \n-  return tdb->format == 0 && tdb->abort_code == 13; /* depth exceeded */\n+  return tdb->format == 1 && tdb->abort_code == 13; /* depth exceeded */\n }\n \n extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n __TM_is_conflict (void* const tdb_ptr)\n {\n   struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n \n-  return (tdb->format == 0\n+  return (tdb->format == 1\n \t  && (tdb->abort_code == 9 /* fetch conflict */\n \t      || tdb->abort_code == 10 /* store conflict */));\n }"}, {"sha": "62d162ab087c9146eb78162756d3fb1606289a31", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -900,7 +900,8 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t{\n \t  /* For CCRAWmode put the required cc mask into the second\n \t     operand.  */\n-\t  if (GET_MODE (XVECEXP (*op0, 0, 0)) == CCRAWmode)\n+        if (GET_MODE (XVECEXP (*op0, 0, 0)) == CCRAWmode\n+            && INTVAL (*op1) >= 0 && INTVAL (*op1) <= 3)\n \t    *op1 = gen_rtx_CONST_INT (VOIDmode, 1 << (3 - INTVAL (*op1)));\n \t  *op0 = XVECEXP (*op0, 0, 0);\n \t  *code = new_code;\n@@ -7973,6 +7974,9 @@ s390_optimize_nonescaping_tx (void)\n     {\n       bb = BASIC_BLOCK (bb_index);\n \n+      if (!bb)\n+\tcontinue;\n+\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  rtx ite, cc, pat, target;\n@@ -8086,7 +8090,10 @@ s390_optimize_nonescaping_tx (void)\n   if (!result)\n     return;\n \n-  PATTERN (tbegin_insn) = XVECEXP (PATTERN (tbegin_insn), 0, 0);\n+  PATTERN (tbegin_insn) = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t    gen_rtvec (2,\n+\t\t\t\t       XVECEXP (PATTERN (tbegin_insn), 0, 0),\n+\t\t\t\t       XVECEXP (PATTERN (tbegin_insn), 0, 1)));\n   INSN_CODE (tbegin_insn) = -1;\n   df_insn_rescan (tbegin_insn);\n \n@@ -9798,6 +9805,7 @@ s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n   const int CC3 = 1 << 0;\n   rtx abort_label = gen_label_rtx ();\n   rtx leave_label = gen_label_rtx ();\n+  rtx retry_plus_two = gen_reg_rtx (SImode);\n   rtx retry_reg = gen_reg_rtx (SImode);\n   rtx retry_label = NULL_RTX;\n   rtx jump;\n@@ -9806,16 +9814,17 @@ s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n   if (retry != NULL_RTX)\n     {\n       emit_move_insn (retry_reg, retry);\n+      emit_insn (gen_addsi3 (retry_plus_two, retry_reg, const2_rtx));\n+      emit_insn (gen_addsi3 (retry_reg, retry_reg, const1_rtx));\n       retry_label = gen_label_rtx ();\n       emit_label (retry_label);\n     }\n \n   if (clobber_fprs_p)\n-    emit_insn (gen_tbegin_1 (tdb,\n-\t\t gen_rtx_CONST_INT (VOIDmode, TBEGIN_MASK)));\n+    emit_insn (gen_tbegin_1 (gen_rtx_CONST_INT (VOIDmode, TBEGIN_MASK), tdb));\n   else\n-    emit_insn (gen_tbegin_nofloat_1 (tdb,\n-\t\t gen_rtx_CONST_INT (VOIDmode, TBEGIN_MASK)));\n+    emit_insn (gen_tbegin_nofloat_1 (gen_rtx_CONST_INT (VOIDmode, TBEGIN_MASK),\n+\t\t\t\t     tdb));\n \n   jump = s390_emit_jump (abort_label,\n \t\t\t gen_rtx_NE (VOIDmode,\n@@ -9836,6 +9845,10 @@ s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n   /* Abort handler code.  */\n \n   emit_label (abort_label);\n+  emit_move_insn (dest, gen_rtx_UNSPEC (SImode,\n+\t\t\t\t\tgen_rtvec (1, gen_rtx_REG (CCRAWmode,\n+\t\t\t\t\t\t\t\t   CC_REGNUM)),\n+\t\t\t\t\tUNSPEC_CC_TO_INT));\n   if (retry != NULL_RTX)\n     {\n       rtx count = gen_reg_rtx (SImode);\n@@ -9847,7 +9860,7 @@ s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n       add_int_reg_note (jump, REG_BR_PROB, very_unlikely);\n \n       /* CC2 - transient failure. Perform retry with ppa.  */\n-      emit_move_insn (count, retry);\n+      emit_move_insn (count, retry_plus_two);\n       emit_insn (gen_subsi3 (count, count, retry_reg));\n       emit_insn (gen_tx_assist (count));\n       jump = emit_jump_insn (gen_doloop_si64 (retry_label,\n@@ -9857,10 +9870,6 @@ s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n       LABEL_NUSES (retry_label) = 1;\n     }\n \n-  emit_move_insn (dest, gen_rtx_UNSPEC (SImode,\n-\t\t\t\t\tgen_rtvec (1, gen_rtx_REG (CCRAWmode,\n-\t\t\t\t\t\t\t\t   CC_REGNUM)),\n-\t\t\t\t\tUNSPEC_CC_TO_INT));\n   emit_label (leave_label);\n }\n \n@@ -9899,6 +9908,9 @@ static void\n s390_init_builtins (void)\n {\n   tree ftype, uint64_type;\n+  tree returns_twice_attr = tree_cons (get_identifier (\"returns_twice\"),\n+\t\t\t\t       NULL, NULL);\n+  tree noreturn_attr = tree_cons (get_identifier (\"noreturn\"), NULL, NULL);\n \n   /* void foo (void) */\n   ftype = build_function_type_list (void_type_node, NULL_TREE);\n@@ -9909,29 +9921,29 @@ s390_init_builtins (void)\n   ftype = build_function_type_list (void_type_node, integer_type_node,\n \t\t\t\t    NULL_TREE);\n   add_builtin_function (\"__builtin_tabort\", ftype,\n-\t\t\tS390_BUILTIN_TABORT, BUILT_IN_MD, NULL, NULL_TREE);\n+\t\t\tS390_BUILTIN_TABORT, BUILT_IN_MD, NULL, noreturn_attr);\n   add_builtin_function (\"__builtin_tx_assist\", ftype,\n \t\t\tS390_BUILTIN_TX_ASSIST, BUILT_IN_MD, NULL, NULL_TREE);\n \n   /* int foo (void *) */\n   ftype = build_function_type_list (integer_type_node, ptr_type_node, NULL_TREE);\n   add_builtin_function (\"__builtin_tbegin\", ftype, S390_BUILTIN_TBEGIN,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+\t\t\tBUILT_IN_MD, NULL, returns_twice_attr);\n   add_builtin_function (\"__builtin_tbegin_nofloat\", ftype,\n \t\t\tS390_BUILTIN_TBEGIN_NOFLOAT,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+\t\t\tBUILT_IN_MD, NULL, returns_twice_attr);\n \n   /* int foo (void *, int) */\n   ftype = build_function_type_list (integer_type_node, ptr_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n   add_builtin_function (\"__builtin_tbegin_retry\", ftype,\n \t\t\tS390_BUILTIN_TBEGIN_RETRY,\n \t\t\tBUILT_IN_MD,\n-\t\t\tNULL, NULL_TREE);\n+\t\t\tNULL, returns_twice_attr);\n   add_builtin_function (\"__builtin_tbegin_retry_nofloat\", ftype,\n \t\t\tS390_BUILTIN_TBEGIN_RETRY_NOFLOAT,\n \t\t\tBUILT_IN_MD,\n-\t\t\tNULL, NULL_TREE);\n+\t\t\tNULL, returns_twice_attr);\n \n   /* int foo (void) */\n   ftype = build_function_type_list (integer_type_node, NULL_TREE);"}, {"sha": "d537d29d24f002f09514d00551b291321f0ccd8c", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -155,6 +155,7 @@\n \n    ; Transactional Execution support\n    UNSPECV_TBEGIN\n+   UNSPECV_TBEGIN_TDB\n    UNSPECV_TBEGINC\n    UNSPECV_TEND\n    UNSPECV_TABORT\n@@ -9997,9 +9998,10 @@\n \n (define_insn \"tbegin_1\"\n   [(set (reg:CCRAW CC_REGNUM)\n-\t(unspec_volatile:CCRAW [(match_operand:BLK 0 \"memory_operand\"    \"=Q\")\n-\t\t\t\t(match_operand     1 \"const_int_operand\" \" D\")]\n+\t(unspec_volatile:CCRAW [(match_operand 0 \"const_int_operand\" \"D\")]\n \t\t\t       UNSPECV_TBEGIN))\n+   (set (match_operand:BLK 1 \"memory_operand\" \"=Q\")\n+\t(unspec_volatile:BLK [(match_dup 0)] UNSPECV_TBEGIN_TDB))\n    (clobber (reg:DF 16))\n    (clobber (reg:DF 17))\n    (clobber (reg:DF 18))\n@@ -10018,18 +10020,19 @@\n    (clobber (reg:DF 31))]\n ; CONST_OK_FOR_CONSTRAINT_P does not work with D constraint since D is\n ; not supposed to be used for immediates (see genpreds.c).\n-  \"TARGET_HTM && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0xffff\"\n-  \"tbegin\\t%0,%x1\"\n+  \"TARGET_HTM && INTVAL (operands[0]) >= 0 && INTVAL (operands[0]) <= 0xffff\"\n+  \"tbegin\\t%1,%x0\"\n   [(set_attr \"op_type\" \"SIL\")])\n \n ; Same as above but without the FPR clobbers\n (define_insn \"tbegin_nofloat_1\"\n   [(set (reg:CCRAW CC_REGNUM)\n-\t(unspec_volatile:CCRAW [(match_operand:BLK 0 \"memory_operand\"    \"=Q\")\n-\t\t\t\t(match_operand     1 \"const_int_operand\" \" D\")]\n-\t\t\t       UNSPECV_TBEGIN))]\n-  \"TARGET_HTM && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0xffff\"\n-  \"tbegin\\t%0,%x1\"\n+\t(unspec_volatile:CCRAW [(match_operand 0 \"const_int_operand\" \"D\")]\n+\t\t\t       UNSPECV_TBEGIN))\n+   (set (match_operand:BLK 1 \"memory_operand\" \"=Q\")\n+\t(unspec_volatile:BLK [(match_dup 0)] UNSPECV_TBEGIN_TDB))]\n+  \"TARGET_HTM && INTVAL (operands[0]) >= 0 && INTVAL (operands[0]) <= 0xffff\"\n+  \"tbegin\\t%1,%x0\"\n   [(set_attr \"op_type\" \"SIL\")])\n \n \n@@ -10113,21 +10116,18 @@\n ; Transaction perform processor assist\n \n (define_expand \"tx_assist\"\n-  [(set (match_dup 1) (const_int 0))\n-   (unspec_volatile [(match_operand:SI 0 \"register_operand\" \"\")\n-\t\t     (match_dup 1)\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"\")\n+\t\t     (reg:SI GPR0_REGNUM)\n \t\t     (const_int 1)]\n \t\t    UNSPECV_PPA)]\n   \"TARGET_HTM\"\n-{\n-  operands[1] = gen_reg_rtx (SImode);\n-})\n+  \"\")\n \n (define_insn \"*ppa\"\n   [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"d\")\n \t\t     (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t     (match_operand 2 \"const_int_operand\" \"I\")]\n \t\t    UNSPECV_PPA)]\n   \"TARGET_HTM && INTVAL (operands[2]) < 16\"\n-  \"ppa\\t%0,%1,1\"\n+  \"ppa\\t%0,%1,%2\"\n   [(set_attr \"op_type\" \"RRF\")])"}, {"sha": "606e4de6979a0112b41dc035ff947b8f274b075d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -1,3 +1,15 @@\n+2013-11-20  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/htm-1.c: Rename to ...\n+\t* gcc/testsuite/gcc.target/s390/htm-builtins-compile-1.c: ... this\n+\tone.\n+\t* gcc.target/s390/htm-xl-intrin-1.c: Rename to ...\n+\t* gcc.target/s390/htm-builtins-compile-3.c: ... this one.\n+\t* gcc.target/s390/htm-builtins-compile-2.c: New testcase.\n+\t* gcc.target/s390/htm-builtins-1.c: New testcase.\n+\t* gcc.target/s390/htm-builtins-2.c: New testcase.\n+\t* gcc.target/s390/s390.exp: Add check for htm machine.\n+\n 2013-11-19  Joshua J Cogliati  <jrincayc@yahoo.com>\n \n \tPR c/53001"}, {"sha": "245ba2c7ef9dea76e2c05ef0151cc189a96611d3", "filename": "gcc/testsuite/gcc.target/s390/htm-1.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d1a0108f1b72f8cb3224cc465b2f67421210181/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d1a0108f1b72f8cb3224cc465b2f67421210181/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-1.c?ref=5d1a0108f1b72f8cb3224cc465b2f67421210181", "patch": "@@ -1,73 +0,0 @@\n-/* This checks the availability of the low-level builtins introduced\n-   for transactional execution.  */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n-\n-#include <stdint.h>\n-#include <htmintrin.h>\n-\n-int global = 0;\n-uint64_t g;\n-struct __htm_tdb global_tdb;\n-\n-int\n-foo (struct __htm_tdb* tdb, int reg, int *mem, uint64_t *mem64)\n-{\n-\n-  int cc;\n-  int n;\n-\n-  cc = __builtin_tbegin (0);\n-  cc = __builtin_tbegin (tdb);\n-  cc = __builtin_tbegin (&global_tdb);\n-\n-  cc = __builtin_tbegin_nofloat (0);\n-  cc = __builtin_tbegin_nofloat (&global_tdb);\n-\n-  cc = __builtin_tbegin_retry (0, 42);\n-  cc = __builtin_tbegin_retry (0, reg);\n-  cc = __builtin_tbegin_retry (0, *mem);\n-  cc = __builtin_tbegin_retry (0, global);\n-  cc = __builtin_tbegin_retry (tdb, 42);\n-  cc = __builtin_tbegin_retry (&global_tdb, 42);\n-\n-  cc = __builtin_tbegin_retry_nofloat (0, 42);\n-  cc = __builtin_tbegin_retry_nofloat (0, reg);\n-  cc = __builtin_tbegin_retry_nofloat (0, *mem);\n-  cc = __builtin_tbegin_retry_nofloat (0, global);\n-  cc = __builtin_tbegin_retry_nofloat (&global_tdb, 42);\n-\n-  __builtin_tbeginc ();\n-\n-  n = __builtin_tx_nesting_depth();\n-\n-  __builtin_non_tx_store(&g, 23);\n-  __builtin_non_tx_store(mem64, 23);\n-  __builtin_non_tx_store(&g, reg);\n-  __builtin_non_tx_store(&g, *mem);\n-  __builtin_non_tx_store(&g, global);\n-\n-  __builtin_tabort (42 + 255);\n-  __builtin_tabort (reg);\n-  /* { dg-final { scan-assembler-times \"tabort\\t255\" 1 } } */\n-  __builtin_tabort (reg + 255);\n-  __builtin_tabort (*mem);\n-  __builtin_tabort (global);\n-  /* Here global + 255 gets reloaded into a reg.  Better would be to\n-     just reload global or *mem and get the +255 for free as address\n-     arithmetic.  */\n-  __builtin_tabort (*mem + 255);\n-  __builtin_tabort (global + 255);\n-\n-  __builtin_tend();\n-\n-  __builtin_tx_assist (23);\n-  __builtin_tx_assist (reg);\n-  __builtin_tx_assist (*mem);\n-  __builtin_tx_assist (global);\n-}\n-\n-/* Make sure the tdb NULL argument ends up as immediate value in the\n-   instruction.  */\n-/* { dg-final { scan-assembler-times \"tbegin\\t0,\" 10 } } */"}, {"sha": "c90490faa59c18ee91ff8b679f7eb8cc9d78e2c9", "filename": "gcc/testsuite/gcc.target/s390/htm-builtins-1.c", "status": "added", "additions": 1073, "deletions": 0, "changes": 1073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-1.c?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -0,0 +1,1073 @@\n+/* Functional tests of the htm __builtin_... macros.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target htm } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+/* ---------------------------- included header files ---------------------- */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdint.h>\n+#include <htmintrin.h>\n+\n+/* ---------------------------- local definitions -------------------------- */\n+\n+#define DEFAULT_MAX_REPETITIONS 5\n+#define DEFAULT_REQUIRED_QUORUM ((DEFAULT_MAX_REPETITIONS) - 1)\n+#define NUM_WARMUP_RUNS 10\n+\n+/* ---------------------------- local macros ------------------------------- */\n+\n+#define TEST_DF_REP(name) \\\n+  { #name, name, DEFAULT_MAX_REPETITIONS, DEFAULT_REQUIRED_QUORUM }\n+#define TEST_NO_REP(name) { #name, name, 1, 1 }\n+\n+/* ---------------------------- local types -------------------------------- */\n+\n+typedef int (*test_func_t)(void);\n+\n+typedef struct\n+{\n+  const char *name;\n+  test_func_t test_func;\n+  int max_repetitions;\n+  int required_quorum;\n+} test_table_entry_t;\n+\n+/* ---------------------------- local variables ---------------------------- */\n+\n+__attribute__ ((aligned(256))) static struct __htm_tdb local_tdb256;\n+static struct __htm_tdb local_tdb;\n+static int do_dump_tdb = 0;\n+\n+/* ---------------------------- exported variables (globals) --------------- */\n+\n+__attribute__ ((aligned(256))) struct\n+{\n+  float float_1;\n+  float float_2;\n+  float float_3;\n+} global = { 1.0, 2.5, 0.0 };\n+\n+__attribute__ ((aligned(256))) struct\n+{\n+  volatile uint64_t c1;\n+  volatile uint64_t c2;\n+  volatile uint64_t c3;\n+} counters = { 0, 0, 0 };\n+\n+/* ---------------------------- local helper functions --------------------- */\n+\n+static void dump_tdb (struct __htm_tdb *tdb)\n+{\n+  unsigned char *p;\n+  int i;\n+  int j;\n+\n+  if (do_dump_tdb == 0)\n+    {\n+      return;\n+    }\n+  p = (unsigned char *)tdb;\n+  for (i = 0; i < 16; i++)\n+    {\n+      fprintf (stderr, \"0x%02x  \", i * 16);\n+      for (j = 0; j < 16; j++)\n+\t{\n+\t  fprintf (stderr, \"%02x\", (int)p[i * 16 + j]);\n+\t  if (j < 15)\n+\t    {\n+\t      fprintf (stderr, \" \");\n+\t    }\n+\t  if (j == 7)\n+\t    {\n+\t      fprintf (stderr, \" \");\n+\t    }\n+\t}\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  return;\n+}\n+\n+/* ---------------------------- local test functions ----------------------- */\n+\n+/* Check values of the constants defined in htmintrin.h.  */\n+static int test_constants (void)\n+{\n+  if (_HTM_TBEGIN_STARTED != 0)\n+    {\n+      return 100 * _HTM_TBEGIN_STARTED + 1;\n+    }\n+  if (_HTM_TBEGIN_INDETERMINATE != 1)\n+    {\n+      return 100 * _HTM_TBEGIN_INDETERMINATE + 2;\n+    }\n+  if (_HTM_TBEGIN_TRANSIENT != 2)\n+    {\n+      return 100 * _HTM_TBEGIN_TRANSIENT + 3;\n+    }\n+  if (_HTM_TBEGIN_PERSISTENT != 3)\n+    {\n+      return 100 * _HTM_TBEGIN_PERSISTENT + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_ntstg_tend (void)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      __builtin_non_tx_store ((uint64_t *)&counters.c1, 1);\n+      counters.c2 = 2;\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (counters.c1 != 1)\n+\t{\n+\t  return 100 * counters.c1 + 2;\n+\t}\n+      if (counters.c2 != 2)\n+\t{\n+\t  return 100 * counters.c2 + 3;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_ntstg_tabort (void)\n+{\n+  float f;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  f = 0;\n+  if (__builtin_tbegin ((void *)0) == 0)\n+    {\n+      __builtin_non_tx_store ((uint64_t *)&counters.c1, 1);\n+      counters.c2 = 2;\n+      f = 1;\n+      __builtin_tabort (256);\n+      return 1;\n+    }\n+  if (counters.c1 != 1)\n+    {\n+      return 100 * counters.c1 + 2;\n+    }\n+  if (counters.c2 != 0)\n+    {\n+      return 100 * counters.c2 + 3;\n+    }\n+  if (f != 0)\n+    {\n+      return 100 * f + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_nofloat (void)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  if ((rc = __builtin_tbegin_nofloat ((void *)0)) == 0)\n+    {\n+      __builtin_non_tx_store ((uint64_t *)&counters.c1, 1);\n+      counters.c2 = 2;\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (counters.c1 != 1)\n+\t{\n+\t  return 100 * counters.c1 + 2;\n+\t}\n+      if (counters.c2 != 2)\n+\t{\n+\t  return 100 * counters.c2 + 3;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_retry (void)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  counters.c3 = 0;\n+  if ((rc = __builtin_tbegin_retry ((void *)0, 5)) == 0)\n+    {\n+      int do_abort;\n+\n+      do_abort = (counters.c1 == 0) ? 1 : 0;\n+      __builtin_non_tx_store (\n+\t\t\t     (uint64_t *)&counters.c1, counters.c1 + 1);\n+      if (do_abort == 1)\n+\t{\n+\t  __builtin_tabort (256);\n+\t}\n+      counters.c2 = counters.c2 + 10;\n+      __builtin_non_tx_store ((uint64_t *)&counters.c3, 3);\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (counters.c1 != 2)\n+\t{\n+\t  return 100 * counters.c1 + 2;\n+\t}\n+      if (counters.c2 != 10)\n+\t{\n+\t  return 100 * counters.c2 + 3;\n+\t}\n+      if (counters.c3 != 3)\n+\t{\n+\t  return 100 * counters.c3 + 6;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_retry_nofloat (void)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  counters.c3 = 0;\n+  if ((rc = __builtin_tbegin_retry_nofloat ((void *)0, 5)) == 0)\n+    {\n+      int do_abort;\n+\n+      do_abort = (counters.c1 == 0) ? 1 : 0;\n+      __builtin_non_tx_store (\n+\t\t\t     (uint64_t *)&counters.c1, counters.c1 + 1);\n+      if (do_abort == 1)\n+\t{\n+\t  __builtin_tabort (256);\n+\t}\n+      counters.c2 = counters.c2 + 10;\n+      __builtin_non_tx_store ((uint64_t *)&counters.c3, 3);\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (counters.c1 != 2)\n+\t{\n+\t  return 100 * counters.c1 + 2;\n+\t}\n+      if (counters.c2 != 10)\n+\t{\n+\t  return 100 * counters.c2 + 3;\n+\t}\n+      if (counters.c3 != 3)\n+\t{\n+\t  return 100 * counters.c3 + 6;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_aborts (void)\n+{\n+  float f;\n+  int rc;\n+\n+  f = 77;\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      f = 88;\n+      __builtin_tabort (256);\n+      return 2;\n+    }\n+  else if (rc != 2)\n+    {\n+      return 3;\n+    }\n+  if (f != 77)\n+    {\n+      return 4;\n+    }\n+  f = 66;\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      f = 99;\n+      __builtin_tabort (257);\n+      return 5;\n+    }\n+  else if (rc != 3)\n+    {\n+      return 100 * rc + 6;\n+    }\n+  if (f != 66)\n+    {\n+      return 100 * f + 7;\n+    }\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      global.float_3 = global.float_1 + global.float_2;\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 8;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 9;\n+    }\n+  if (global.float_3 != global.float_1 + global.float_2)\n+    {\n+      return 100 * rc + 10;\n+    }\n+\n+  return 0;\n+}\n+\n+static __attribute__((noinline)) void indirect_abort(int abort_code)\n+{\n+  __builtin_tabort (abort_code);\n+\n+  return;\n+}\n+\n+static int test_tbegin_indirect_aborts (void)\n+{\n+  float f;\n+  int rc;\n+\n+  f = 77;\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      f = 88;\n+      indirect_abort(256);\n+      return 2;\n+    }\n+  else if (rc != 2)\n+    {\n+      return 100 * rc + 3;\n+    }\n+  if (f != 77)\n+    {\n+      return 100 * rc + 4;\n+    }\n+  f = 66;\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      f = 99;\n+      indirect_abort(257);\n+      return 5;\n+    }\n+  else if (rc != 3)\n+    {\n+      return 100 * rc + 6;\n+    }\n+  if (f != 66)\n+    {\n+      return 100 * f + 7;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_nofloat_aborts (void)\n+{\n+  int rc;\n+\n+  if ((rc = __builtin_tbegin_nofloat ((void *)0)) == 0)\n+    {\n+      __builtin_tabort (256);\n+      return 2;\n+    }\n+  if ((rc = __builtin_tbegin_nofloat ((void *)0)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 1005;\n+    }\n+  else if (rc != 3)\n+    {\n+      return 1000 * rc + 6;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_nofloat_indirect_aborts (void)\n+{\n+  int rc;\n+\n+  if ((rc = __builtin_tbegin_nofloat ((void *)0)) == 0)\n+    {\n+      indirect_abort (256);\n+      return 2;\n+    }\n+  if ((rc = __builtin_tbegin_nofloat ((void *)0)) == 0)\n+    {\n+      indirect_abort (257);\n+      return 1005;\n+    }\n+  else if (rc != 3)\n+    {\n+      return 1000 * rc + 6;\n+    }\n+\n+  return 0;\n+}\n+\n+static\n+int _test_tbegin_retry_aborts (int retries, uint64_t abort_code)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  if ((rc = __builtin_tbegin_retry ((void *)0, retries)) == 0)\n+    {\n+      __builtin_non_tx_store ((uint64_t *)&counters.c1, counters.c1 + 1);\n+      __builtin_tabort (abort_code);\n+      return 2;\n+    }\n+  else\n+    {\n+      if ((abort_code & 1) == 0)\n+\t{\n+\t  if (rc != 2)\n+\t    {\n+\t      return 100 * rc + 2003;\n+\t    }\n+\t  else if (counters.c1 != (uint64_t)retries + 1)\n+\t    {\n+\t      return 1000 * counters.c1 + 100 * retries + 4;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (rc != 3)\n+\t    {\n+\t      return 100 * rc + 3005;\n+\t    }\n+\t  else if (counters.c1 != 1)\n+\t    {\n+\t      return 1000 * counters.c1 + 100 * retries + 6;\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_retry_aborts (void)\n+{\n+  int rc;\n+  int retries;\n+\n+  for (retries = 1; retries <= 3; retries++)\n+    {\n+      rc = _test_tbegin_retry_aborts (retries, 256);\n+      if (rc != 0)\n+\t{\n+\t  return 10000 + rc;\n+\t}\n+    }\n+  for (retries = 1; retries <= 3; retries++)\n+    {\n+      rc = _test_tbegin_retry_aborts (retries, 257);\n+      if (rc != 0)\n+\t{\n+\t  return 20000 + rc;\n+\t}\n+    }\n+  if ((rc = __builtin_tbegin_retry ((void *)0, 5)) == 0)\n+    {\n+      global.float_3 = global.float_1 + global.float_2;\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 30000 + 100 * rc + 6;\n+\t}\n+    }\n+  else\n+    {\n+      return 30000 + 100 * rc + 7;\n+    }\n+\n+  return 0;\n+}\n+\n+static int _test_tbegin_retry_nofloat_aborts (int retries, uint64_t abort_code)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  if ((rc = __builtin_tbegin_retry_nofloat ((void *)0, retries)) == 0)\n+    {\n+      __builtin_non_tx_store ((uint64_t *)&counters.c1, counters.c1 + 1);\n+      __builtin_tabort (abort_code);\n+      return 2;\n+    }\n+  else\n+    {\n+      if ((abort_code & 1) == 0)\n+\t{\n+\t  if (rc != 2)\n+\t    {\n+\t      return 100 * rc + 2003;\n+\t    }\n+\t  else if (counters.c1 != (uint64_t)retries + 1)\n+\t    {\n+\t      return 1000 * counters.c1 + 100 * retries + 4;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (rc != 3)\n+\t    {\n+\t      return 100 * rc + 3005;\n+\t    }\n+\t  else if (counters.c1 != 1)\n+\t    {\n+\t      return 1000 * counters.c1 + 100 * retries + 6;\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_retry_nofloat_aborts (void)\n+{\n+  int rc;\n+  int retries;\n+\n+  for (retries = 1; retries <= 3; retries++)\n+    {\n+      rc = _test_tbegin_retry_nofloat_aborts (retries, 256);\n+      if (rc != 0)\n+\t{\n+\t  return 10 * retries + rc;\n+\t}\n+    }\n+  for (retries = 1; retries <= 3; retries++)\n+    {\n+      rc = _test_tbegin_retry_nofloat_aborts (retries, 257);\n+      if (rc != 0)\n+\t{\n+\t  return 10000 + 10 * retries + rc;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_tdb (void)\n+{\n+  int rc;\n+\n+  local_tdb.format = 0;\n+  if ((rc = __builtin_tbegin (&local_tdb)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 1;\n+\t}\n+      if (local_tdb.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb);\n+\t  return 100 * local_tdb.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 3;\n+    }\n+  local_tdb.format = 0;\n+  if ((rc = __builtin_tbegin (&local_tdb)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 4;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (local_tdb.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb);\n+\t  return 100 * local_tdb.format + 6;\n+\t}\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin (&local_tdb256)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 1100 * rc + 1;\n+\t}\n+      if (local_tdb256.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 1100 * local_tdb256.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 1100 * rc + 3;\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin (&local_tdb256)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 2004;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 2100 * rc + 5;\n+\t}\n+      if (local_tdb256.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 2100 * local_tdb256.format + 6;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_nofloat_tdb (void)\n+{\n+  int rc;\n+\n+  local_tdb.format = 0;\n+  if ((rc = __builtin_tbegin_nofloat (&local_tdb)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 1;\n+\t}\n+      if (local_tdb.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb);\n+\t  return 100 * local_tdb.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 3;\n+    }\n+  local_tdb.format = 0;\n+  if ((rc = __builtin_tbegin_nofloat (&local_tdb)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 4;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (local_tdb.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb);\n+\t  return 100 * local_tdb.format + 6;\n+\t}\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin_nofloat (&local_tdb256)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 1100 * rc + 1;\n+\t}\n+      if (local_tdb256.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 1100 * local_tdb256.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 1003;\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin_nofloat (&local_tdb256)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 2004;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 2100 * rc + 5;\n+\t}\n+      if (local_tdb256.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 2100 * local_tdb256.format + 6;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_retry_tdb (void)\n+{\n+  int rc;\n+\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin_retry (&local_tdb256, 2)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 1100 * rc + 1;\n+\t}\n+      if (local_tdb256.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 1100 * local_tdb256.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 1003;\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin_retry (&local_tdb256, 2)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 2004;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 2100 * rc + 5;\n+\t}\n+      if (local_tdb256.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 2100 * local_tdb256.format + 6;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_retry_nofloat_tdb (void)\n+{\n+  int rc;\n+\n+  local_tdb.format = 0;\n+  if ((rc = __builtin_tbegin_retry_nofloat (&local_tdb, 2)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 1;\n+\t}\n+      if (local_tdb.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb);\n+\t  return 100 * local_tdb.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 3;\n+    }\n+  local_tdb.format = 0;\n+  if ((rc = __builtin_tbegin_retry_nofloat (&local_tdb, 2)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 4;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (local_tdb.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb);\n+\t  return 100 * local_tdb.format + 6;\n+\t}\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin_retry_nofloat (&local_tdb256, 2)) == 0)\n+    {\n+      rc = __builtin_tend ();\n+      if (rc != 0)\n+\t{\n+\t  return 1100 * rc + 1;\n+\t}\n+      if (local_tdb256.format != 0)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 1100 * local_tdb256.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 1100 * rc + 3;\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __builtin_tbegin_retry_nofloat (&local_tdb256, 2)) == 0)\n+    {\n+      __builtin_tabort (257);\n+      return 2004;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 2100 * rc + 5;\n+\t}\n+      if (local_tdb256.format != 1)\n+\t{\n+\t  dump_tdb (&local_tdb256);\n+\t  return 2100 * local_tdb256.format + 6;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_etnd (void)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  counters.c3 = 0;\n+  if ((rc = __builtin_tbegin ((void *)0)) == 0)\n+    {\n+      counters.c1 = __builtin_tx_nesting_depth ();\n+      if (__builtin_tbegin ((void *)0) == 0)\n+\t{\n+\t  counters.c2 = __builtin_tx_nesting_depth ();\n+\t  if (__builtin_tbegin ((void *)0) == 0)\n+\t    {\n+\t      counters.c3 = __builtin_tx_nesting_depth ();\n+\t      __builtin_tend ();\n+\t    }\n+\t  __builtin_tend ();\n+\t}\n+      __builtin_tend ();\n+    }\n+  else\n+    {\n+      return 100 * rc + 1;\n+    }\n+  if (counters.c1 != 1)\n+    {\n+      return 100 * counters.c1 + 2;\n+    }\n+  if (counters.c2 != 2)\n+    {\n+      return 100 * counters.c2 + 3;\n+    }\n+  if (counters.c3 != 3)\n+    {\n+      return 100 * counters.c3 + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbeginc (void)\n+{\n+  int rc;\n+\n+  counters.c1 = 0;\n+  __builtin_tbeginc ();\n+  counters.c1 = 1;\n+  rc = __builtin_tend ();\n+  if (rc != 0)\n+    {\n+      return 10000 * rc + 1;\n+    }\n+  if (counters.c1 != 1)\n+    {\n+      return 100000 * counters.c1 + 3;\n+    }\n+\n+  return 0;\n+}\n+\n+/* ---------------------------- local testing framework functions ---------- */\n+\n+static int run_one_test (const test_table_entry_t *test_entry)\n+{\n+  int do_print_passes;\n+  int succeeded;\n+  int rc;\n+  int i;\n+\n+  /* Warmup run to get all necessary data and instruction pages into the page\n+   * tables.  */\n+  {\n+    int run;\n+\n+    do_dump_tdb = 0;\n+    for (run = 0; run < NUM_WARMUP_RUNS; run++)\n+      {\n+\ttest_entry->test_func ();\n+      }\n+    do_dump_tdb = 1;\n+  }\n+  do_print_passes = (\n+\t\t     test_entry->required_quorum != 1 ||\n+\t\t     test_entry->max_repetitions != 1);\n+  printf (\"RRR RUN  %s\\n\", test_entry->name);\n+  if (do_print_passes == 1)\n+    {\n+      printf (\n+\t     \"         (requires %d successful out of %d runs)\\n\",\n+\t     test_entry->required_quorum,\n+\t     test_entry->max_repetitions);\n+    }\n+  succeeded = 0;\n+  rc = 0;\n+  for (rc = 0, i = 0; i < test_entry->max_repetitions; i++)\n+    {\n+      if (do_print_passes == 1)\n+\t{\n+\t  if (i == 0)\n+\t    {\n+\t      printf (\"        \");\n+\t    }\n+\t  else\n+\t    {\n+\t      printf (\",\");\n+\t    }\n+\t}\n+      rc = test_entry->test_func ();\n+      if (rc == 0)\n+\t{\n+\t  if (do_print_passes == 1)\n+\t    {\n+\t      printf (\" success\");\n+\t    }\n+\t  succeeded++;\n+\t  if (succeeded >= test_entry->required_quorum)\n+\t    {\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  printf (\" failed (rc = %d)\", rc);\n+\t}\n+    }\n+  if (do_print_passes == 1 || rc != 0)\n+    {\n+      printf (\"\\n\");\n+    }\n+  if (succeeded >= test_entry->required_quorum)\n+    {\n+      printf (\"+++ OK   %s\\n\", test_entry->name);\n+\n+      return 0;\n+    }\n+  else\n+    {\n+      printf (\"--- FAIL %s\\n\", test_entry->name);\n+\n+      return (rc != 0) ? rc : -1;\n+    }\n+}\n+\n+static int run_all_tests (const test_table_entry_t *test_table)\n+{\n+  const test_table_entry_t *test;\n+  int rc;\n+\n+  for (\n+       rc = 0, test = &test_table[0];\n+       test->test_func != NULL && rc == 0; test++)\n+    {\n+      rc = run_one_test (test);\n+    }\n+\n+  return rc;\n+}\n+\n+/* ---------------------------- interface functions ------------------------ */\n+\n+int main (void)\n+{\n+  const test_table_entry_t test_table[] = {\n+    TEST_NO_REP (test_constants),\n+    TEST_DF_REP (test_tbegin_ntstg_tend),\n+    TEST_DF_REP (test_tbegin_ntstg_tabort),\n+    TEST_DF_REP (test_tbegin_nofloat),\n+    TEST_NO_REP (test_tbegin_retry),\n+    TEST_NO_REP (test_tbegin_retry_nofloat),\n+    TEST_DF_REP (test_tbegin_aborts),\n+    TEST_DF_REP (test_tbegin_indirect_aborts),\n+    TEST_DF_REP (test_tbegin_nofloat_aborts),\n+    TEST_DF_REP (test_tbegin_nofloat_indirect_aborts),\n+    TEST_NO_REP (test_tbegin_retry_aborts),\n+    TEST_NO_REP (test_tbegin_retry_nofloat_aborts),\n+    TEST_DF_REP (test_tbegin_tdb),\n+    TEST_DF_REP (test_tbegin_nofloat_tdb),\n+    TEST_NO_REP (test_tbegin_retry_tdb),\n+    TEST_NO_REP (test_tbegin_retry_nofloat_tdb),\n+    TEST_DF_REP (test_etnd),\n+    TEST_DF_REP (test_tbeginc),\n+    { (void *)0, 0, 0 }\n+  };\n+\n+  {\n+    int rc;\n+\n+    rc = run_all_tests (test_table);\n+\n+    return rc;\n+  }\n+}"}, {"sha": "15b0d12ae92be69829329dcc6f5d1bf6ead8ea58", "filename": "gcc/testsuite/gcc.target/s390/htm-builtins-2.c", "status": "added", "additions": 682, "deletions": 0, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-2.c?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -0,0 +1,682 @@\n+/* Functional tests of the htm __TM_... macros.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target htm } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+/* ---------------------------- included header files ---------------------- */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include <htmxlintrin.h>\n+\n+/* ---------------------------- local definitions -------------------------- */\n+\n+#define DEFAULT_MAX_REPETITIONS 5\n+#define DEFAULT_REQUIRED_QUORUM ((DEFAULT_MAX_REPETITIONS) - 1)\n+#define DEFAULT_ABORT_ADDRESS (0x12345678u)\n+\n+/* ---------------------------- local macros ------------------------------- */\n+\n+#define TEST_DF_REP(name) \\\n+  { #name, name, DEFAULT_MAX_REPETITIONS, DEFAULT_REQUIRED_QUORUM }\n+#define TEST_NO_REP(name) { #name, name, 1, 1 }\n+\n+/* ---------------------------- local types -------------------------------- */\n+\n+typedef int (*test_func_t)(void);\n+\n+typedef struct\n+{\n+  const char *name;\n+  test_func_t test_func;\n+  int max_repetitions;\n+  int required_quorum;\n+} test_table_entry_t;\n+\n+typedef enum\n+{\n+  ABORT_T_SYSTEM = 0,\n+  ABORT_T_USER = 1,\n+} abort_user_t;\n+\n+typedef enum\n+{\n+  ABORT_T_NONE = 0,\n+  ABORT_T_ILLEGAL,\n+  ABORT_T_FOOTPRINT_EXCEEDED,\n+  ABORT_T_NESTED_TOO_DEEP,\n+  ABORT_T_CONFLICT,\n+\n+  ABORT_T_INVALID_ABORT_CODE\n+} abort_t;\n+\n+/* ---------------------------- local variables ---------------------------- */\n+\n+__attribute__ ((aligned(256))) static struct __htm_tdb local_tdb256;\n+static struct __htm_tdb local_tdb;\n+\n+static abort_t const abort_classes[] =\n+{\n+  ABORT_T_INVALID_ABORT_CODE,\n+  ABORT_T_NONE,\n+  ABORT_T_NONE,\n+  ABORT_T_NONE,\n+\n+  ABORT_T_ILLEGAL,\n+  ABORT_T_NONE,\n+  ABORT_T_NONE,\n+  ABORT_T_FOOTPRINT_EXCEEDED,\n+\n+  ABORT_T_FOOTPRINT_EXCEEDED,\n+  ABORT_T_CONFLICT,\n+  ABORT_T_CONFLICT,\n+  ABORT_T_ILLEGAL,\n+\n+  ABORT_T_NONE,\n+  ABORT_T_NESTED_TOO_DEEP,\n+  ABORT_T_NONE,\n+  ABORT_T_NONE,\n+\n+  ABORT_T_NONE\n+};\n+\n+static size_t num_abort_classes = sizeof(abort_classes) / sizeof(abort_t);\n+\n+/* ---------------------------- exported variables (globals) --------------- */\n+\n+int global_int = 0;\n+uint64_t global_u64 = 0;\n+float global_float_1 = 1.0;\n+float global_float_2 = 2.5;\n+float global_float_3 = 0.0;\n+__attribute__ ((aligned(256))) struct\n+{\n+  volatile uint64_t c1;\n+  volatile uint64_t c2;\n+  volatile uint64_t c3;\n+} counters = { 0, 0, 0 };\n+\n+/* ---------------------------- local helper functions --------------------- */\n+\n+static void dump_tdb(struct __htm_tdb *tdb)\n+{\n+  unsigned char *p;\n+  int i;\n+  int j;\n+\n+  p = (unsigned char *)tdb;\n+  for (i = 0; i < 16; i++)\n+    {\n+      fprintf(stderr, \"0x%02x  \", i * 16);\n+      for (j = 0; j < 16; j++)\n+\t{\n+\t  fprintf(stderr, \"%02x\", (int)p[i * 16 + j]);\n+\t  if (j < 15)\n+\t    {\n+\t      fprintf(stderr, \" \");\n+\t    }\n+\t  if (j == 7)\n+\t    {\n+\t      fprintf(stderr, \" \");\n+\t    }\n+\t}\n+      fprintf(stderr, \"\\n\");\n+    }\n+\n+  return;\n+}\n+\n+static void make_fake_tdb(struct __htm_tdb *tdb)\n+{\n+  memset(tdb, 0, sizeof(*tdb));\n+  tdb->format = 1;\n+  tdb->nesting_depth = 1;\n+  tdb->atia = DEFAULT_ABORT_ADDRESS;\n+  tdb->abort_code = 11;\n+\n+  return;\n+}\n+\n+static int check_abort_code_in_tdb(struct __htm_tdb *tdb, uint64_t abort_code)\n+{\n+  long expect_rc;\n+  long rc;\n+\n+  if (abort_code != 0)\n+    {\n+      long addr;\n+\n+      addr = __TM_failure_address(&local_tdb);\n+      if (addr != DEFAULT_ABORT_ADDRESS)\n+\t{\n+\t  return 11;\n+\t}\n+    }\n+  {\n+    long long tdb_abort_code;\n+\n+    tdb_abort_code = __TM_failure_code(tdb);\n+    if ((uint64_t)tdb_abort_code != abort_code)\n+      {\n+\tfprintf(\n+\t\tstderr, \"tm_ac %\" PRIu64 \", ac %\" PRIu64\n+\t\t\", tdb_ac %\" PRIu64 \"\\n\",\n+\t\t(uint64_t)tdb_abort_code, abort_code,\n+\t\t(uint64_t)tdb->abort_code);\n+\treturn 10;\n+      }\n+  }\n+  expect_rc = (abort_code >= 256) ? 1 : 0;\n+  rc = __TM_is_user_abort(tdb);\n+  if (rc != expect_rc)\n+    {\n+      fprintf(stderr, \"rc %ld, expect_rc %ld\\n\", rc, expect_rc);\n+      return 1;\n+    }\n+  {\n+    unsigned char code;\n+\n+    code = 0xffu;\n+    rc = __TM_is_named_user_abort(tdb, &code);\n+    if (rc != expect_rc)\n+      {\n+\tfprintf(\n+\t\tstderr, \"rc %ld, expect_rc %ld\\n\", rc,\n+\t\texpect_rc);\n+\treturn 2;\n+      }\n+    if (expect_rc == 1 && code != abort_code - 256)\n+      {\n+\treturn 3;\n+      }\n+  }\n+  if (abort_code > (uint64_t)num_abort_classes)\n+    {\n+      abort_code = (uint64_t)num_abort_classes;\n+    }\n+  expect_rc = (abort_classes[abort_code] == ABORT_T_ILLEGAL) ? 1 : 0;\n+  rc = __TM_is_illegal(tdb);\n+  if (rc != expect_rc)\n+    {\n+      dump_tdb(tdb);\n+      fprintf(stderr, \"rc %ld, expect_rc %ld\\n\", rc, expect_rc);\n+      return 4;\n+    }\n+  expect_rc =\n+    (abort_classes[abort_code] == ABORT_T_FOOTPRINT_EXCEEDED) ?\n+    1 : 0;\n+  rc = __TM_is_footprint_exceeded(tdb);\n+  if (rc != expect_rc)\n+    {\n+      dump_tdb(tdb);\n+      fprintf(stderr, \"rc %ld, expect_rc %ld\\n\", rc, expect_rc);\n+      return 5;\n+    }\n+  expect_rc =\n+    (abort_classes[abort_code] == ABORT_T_NESTED_TOO_DEEP) ? 1 : 0;\n+  rc = __TM_is_nested_too_deep(tdb);\n+  if (rc != expect_rc)\n+    {\n+      dump_tdb(tdb);\n+      fprintf(stderr, \"rc %ld, expect_rc %ld\\n\", rc, expect_rc);\n+      return 6;\n+    }\n+  expect_rc = (abort_classes[abort_code] == ABORT_T_CONFLICT) ? 1 : 0;\n+  rc = __TM_is_conflict(tdb);\n+  if (rc != expect_rc)\n+    {\n+      dump_tdb(tdb);\n+      fprintf(stderr, \"rc %ld, expect_rc %ld\\n\", rc, expect_rc);\n+      return 7;\n+    }\n+\n+  return 0;\n+}\n+\n+/* ---------------------------- local test functions ----------------------- */\n+\n+/* Not a test; make sure that the involved global cachelines are reserved for\n+ * writing.  */\n+static int init_cache(void)\n+{\n+  make_fake_tdb(&local_tdb);\n+  make_fake_tdb(&local_tdb256);\n+  global_int = 0;\n+  global_u64 = 0;\n+  global_float_1 = 1.0;\n+  global_float_2 = 2.5;\n+  global_float_3 = 0.0;\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  counters.c3 = 0;\n+\n+  return 0;\n+}\n+\n+static int test_abort_classification(void)\n+{\n+  int i;\n+\n+  make_fake_tdb(&local_tdb);\n+  for (i = 0; i <= 256; i++)\n+    {\n+      int rc;\n+\n+      local_tdb.abort_code = (uint64_t)i;\n+      rc = check_abort_code_in_tdb(&local_tdb, (uint64_t)i);\n+      if (rc != 0)\n+\t{\n+\t  return 100 * i + rc;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_cc_classification(void)\n+{\n+  long rc;\n+\n+  rc = __TM_is_failure_persistent(0);\n+  if (rc != 0)\n+    {\n+      return 1;\n+    }\n+  rc = __TM_is_failure_persistent(1);\n+  if (rc != 0)\n+    {\n+      return 2;\n+    }\n+  rc = __TM_is_failure_persistent(2);\n+  if (rc != 0)\n+    {\n+      return 3;\n+    }\n+  rc = __TM_is_failure_persistent(3);\n+  if (rc != 1)\n+    {\n+      return 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_ntstg_tend(void)\n+{\n+  long rc;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  if ((rc = __TM_simple_begin()) == 0)\n+    {\n+      __TM_non_transactional_store((uint64_t *)&counters.c1, 1);\n+      counters.c2 = 2;\n+      rc = __TM_end();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (counters.c1 != 1)\n+\t{\n+\t  return 100 * counters.c1 + 2;\n+\t}\n+      if (counters.c2 != 2)\n+\t{\n+\t  return 100 * counters.c2 + 3;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_ntstg_tabort(void)\n+{\n+  register float f;\n+\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  f = 0;\n+  if (__TM_simple_begin() == 0)\n+    {\n+      __TM_non_transactional_store((uint64_t *)&counters.c1, 1);\n+      counters.c2 = 2;\n+      f = 1;\n+      __TM_named_abort(0);\n+      return 1;\n+    }\n+  if (counters.c1 != 1)\n+    {\n+      return 100 * counters.c1 + 2;\n+    }\n+  if (counters.c2 != 0)\n+    {\n+      return 100 * counters.c2 + 3;\n+    }\n+  if (f != 0)\n+    {\n+      return 100 * f + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_aborts(void)\n+{\n+  float f;\n+  long rc;\n+\n+  f = 77;\n+  if ((rc = __TM_simple_begin()) == 0)\n+    {\n+      f = 88;\n+      __TM_abort();\n+      return 2;\n+    }\n+  else if (rc != 2)\n+    {\n+      return 3;\n+    }\n+  if (f != 77)\n+    {\n+      return 4;\n+    }\n+  f = 66;\n+  if ((rc = __TM_simple_begin()) == 0)\n+    {\n+      f = 99;\n+      __TM_named_abort(3);\n+      return 5;\n+    }\n+  else if (rc != 3)\n+    {\n+      return 100 * rc + 6;\n+    }\n+  if (f != 66)\n+    {\n+      return 100 * f + 7;\n+    }\n+  if ((rc = __TM_simple_begin()) == 0)\n+    {\n+      global_float_3 = global_float_1 + global_float_2;\n+      rc = __TM_end();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 8;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 9;\n+    }\n+  if (global_float_3 != global_float_1 + global_float_2)\n+    {\n+      return 100 * rc + 10;\n+    }\n+\n+  return 0;\n+}\n+\n+static int test_tbegin_tdb(void)\n+{\n+  long rc;\n+\n+  local_tdb.format = 0;\n+  if ((rc = __TM_begin(&local_tdb)) == 0)\n+    {\n+      rc = __TM_end();\n+      if (rc != 0)\n+\t{\n+\t  return 100 * rc + 1;\n+\t}\n+      if (local_tdb.format != 0)\n+\t{\n+\t  dump_tdb(&local_tdb);\n+\t  return 100 * local_tdb.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 100 * rc + 3;\n+    }\n+  local_tdb.format = 0;\n+  if ((rc = __TM_begin(&local_tdb)) == 0)\n+    {\n+      __TM_named_abort(1);\n+      return 4;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 100 * rc + 5;\n+\t}\n+      if (local_tdb.format != 1)\n+\t{\n+\t  dump_tdb(&local_tdb);\n+\t  return 100 * local_tdb.format + 6;\n+\t}\n+    }\n+  local_tdb256.format = 0;\n+  if ((rc = __TM_begin(&local_tdb256)) == 0)\n+    {\n+      rc = __TM_end();\n+      if (rc != 0)\n+\t{\n+\t  return 1100 * rc + 1;\n+\t}\n+      if (local_tdb256.format != 0)\n+\t{\n+\t  dump_tdb(&local_tdb256);\n+\t  return 1100 * local_tdb256.format + 2;\n+\t}\n+    }\n+  else\n+    {\n+      return 1100 * rc + 3;\n+    }\n+#if 1 /*!!!does not work*/\n+  local_tdb256.format = 0;\n+  if ((rc = __TM_begin(&local_tdb256)) == 0)\n+    {\n+      __TM_named_abort(1);\n+      return 2004;\n+    }\n+  else\n+    {\n+      if (rc != 3)\n+\t{\n+\t  return 2100 * rc + 5;\n+\t}\n+      if (local_tdb256.format != 1)\n+\t{\n+\t  dump_tdb(&local_tdb256);\n+\t  return 2100 * local_tdb256.format + 6;\n+\t}\n+    }\n+#endif\n+\n+  return 0;\n+}\n+\n+static int test_etnd(void)\n+{\n+  long rc;\n+\n+  {\n+    long nd;\n+\n+    make_fake_tdb(&local_tdb);\n+    local_tdb.nesting_depth = 0;\n+    nd = __TM_nesting_depth(&local_tdb);\n+    if (nd != 0)\n+      {\n+\treturn 1;\n+      }\n+    local_tdb.nesting_depth = 7;\n+    nd = __TM_nesting_depth(&local_tdb);\n+    if (nd != 7)\n+      {\n+\treturn 7;\n+      }\n+    local_tdb.format = 0;\n+    nd = __TM_nesting_depth(&local_tdb);\n+    if (nd != 0)\n+      {\n+\treturn 2;\n+      }\n+  }\n+  counters.c1 = 0;\n+  counters.c1 = 0;\n+  counters.c2 = 0;\n+  counters.c3 = 0;\n+  if ((rc = __TM_simple_begin()) == 0)\n+    {\n+      counters.c1 = __TM_nesting_depth(0);\n+      if (__TM_simple_begin() == 0)\n+\t{\n+\t  counters.c2 = __TM_nesting_depth(0);\n+\t  if (__TM_simple_begin() == 0)\n+\t    {\n+\t      counters.c3 = __TM_nesting_depth(0);\n+\t      __TM_end();\n+\t    }\n+\t  __TM_end();\n+\t}\n+      __TM_end();\n+    }\n+  else\n+    {\n+      return 100 * rc + 1;\n+    }\n+  if (counters.c1 != 1)\n+    {\n+      return 100 * counters.c1 + 2;\n+    }\n+  if (counters.c2 != 2)\n+    {\n+      return 100 * counters.c2 + 3;\n+    }\n+  if (counters.c3 != 3)\n+    {\n+      return 100 * counters.c3 + 4;\n+    }\n+\n+  return 0;\n+}\n+\n+/* ---------------------------- local testing framework functions ---------- */\n+\n+static int run_one_test(const test_table_entry_t *test_entry)\n+{\n+  int do_print_passes;\n+  int succeeded;\n+  int rc;\n+  int i;\n+\n+  do_print_passes = (\n+\t\t     test_entry->required_quorum != 1 ||\n+\t\t     test_entry->max_repetitions != 1);\n+  printf(\"RRR RUN  %s\\n\", test_entry->name);\n+  if (do_print_passes == 1)\n+    {\n+      printf(\n+\t     \"         (requires %d successful out of %d runs)\\n\",\n+\t     test_entry->required_quorum,\n+\t     test_entry->max_repetitions);\n+    }\n+  succeeded = 0;\n+  rc = 0;\n+  for (rc = 0, i = 0; i < test_entry->max_repetitions; i++)\n+    {\n+      if (do_print_passes == 1)\n+\t{\n+\t  if (i == 0)\n+\t    {\n+\t      printf(\"        \");\n+\t    }\n+\t  else\n+\t    {\n+\t      printf(\",\");\n+\t    }\n+\t}\n+      rc = test_entry->test_func();\n+      if (rc == 0)\n+\t{\n+\t  if (do_print_passes == 1)\n+\t    {\n+\t      printf(\" success\");\n+\t    }\n+\t  succeeded++;\n+\t  if (succeeded >= test_entry->required_quorum)\n+\t    {\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  printf(\" failed (rc = %d)\", rc);\n+\t}\n+    }\n+  if (do_print_passes == 1 || rc != 0)\n+    {\n+      printf(\"\\n\");\n+    }\n+  if (succeeded >= test_entry->required_quorum)\n+    {\n+      printf(\"+++ OK   %s\\n\", test_entry->name);\n+\n+      return 0;\n+    }\n+  else\n+    {\n+      printf(\"--- FAIL %s\\n\", test_entry->name);\n+\n+      return (rc != 0) ? rc : -1;\n+    }\n+}\n+\n+static int run_all_tests(const test_table_entry_t *test_table)\n+{\n+  const test_table_entry_t *test;\n+  int rc;\n+\n+  for (\n+       rc = 0, test = &test_table[0];\n+       test->test_func != NULL && rc == 0; test++)\n+    {\n+      rc = run_one_test(test);\n+    }\n+\n+  return rc;\n+}\n+\n+/* ---------------------------- interface functions ------------------------ */\n+\n+int main(void)\n+{\n+  const test_table_entry_t test_table[] = {\n+    TEST_NO_REP(init_cache),\n+    TEST_NO_REP(test_abort_classification),\n+    TEST_NO_REP(test_cc_classification),\n+    TEST_DF_REP(test_tbegin_ntstg_tend),\n+    TEST_DF_REP(test_tbegin_ntstg_tabort),\n+    TEST_DF_REP(test_tbegin_aborts),\n+    TEST_DF_REP(test_tbegin_tdb),\n+    TEST_DF_REP(test_etnd),\n+    { (void *)0, 0, 0 }\n+  };\n+\n+  {\n+    int rc;\n+\n+    rc = run_all_tests(test_table);\n+\n+    return rc;\n+  }\n+}"}, {"sha": "c1b98e2bba4935aebae427d5b8027ed61beed73f", "filename": "gcc/testsuite/gcc.target/s390/htm-builtins-compile-1.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-1.c?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -0,0 +1,164 @@\n+/* This checks the availability of the low-level builtins introduced\n+   for transactional execution.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+#include <stdint.h>\n+#include <htmintrin.h>\n+\n+int global = 0;\n+uint64_t g;\n+struct __htm_tdb global_tdb;\n+\n+int\n+foo (struct __htm_tdb* tdb, int reg, int *mem, uint64_t *mem64)\n+{\n+\n+  int cc;\n+  int n;\n+\n+  __builtin_tbegin ((void *)0);\n+  __builtin_tbegin ((void *)-99999);\n+  __builtin_tbegin ((void *)99999);\n+  while (__builtin_tbegin ((void *)0) != 0)\n+  {\n+  }\n+  cc = __builtin_tbegin ((void *)0x12345678);\n+  cc = __builtin_tbegin (tdb);\n+  cc = __builtin_tbegin (&global_tdb);\n+  cc = __builtin_tbegin ((void *)(long long)(reg + 0x12345678));\n+  cc = __builtin_tbegin ((void *)(long long)(reg));\n+\n+  __builtin_tbegin_nofloat ((void *)0);\n+  __builtin_tbegin_nofloat ((void *)-99999);\n+  __builtin_tbegin_nofloat ((void *)99999);\n+  cc = __builtin_tbegin_nofloat ((void *)0x12345678);\n+  cc = __builtin_tbegin_nofloat (tdb);\n+  cc = __builtin_tbegin_nofloat (&global_tdb);\n+  cc = __builtin_tbegin_nofloat ((void *)(long long)(reg + 0x12345678));\n+  cc = __builtin_tbegin_nofloat ((void *)(long long)(reg));\n+\n+  __builtin_tbegin_retry ((void *)0, 0);\n+  cc = __builtin_tbegin_retry ((void *)0, 1);\n+  cc = __builtin_tbegin_retry ((void *)0, -1);\n+  cc = __builtin_tbegin_retry ((void *)0, 42);\n+  cc = __builtin_tbegin_retry ((void *)0, reg);\n+  cc = __builtin_tbegin_retry ((void *)0, *mem);\n+  cc = __builtin_tbegin_retry ((void *)0, global);\n+  cc = __builtin_tbegin_retry (tdb, 42);\n+  cc = __builtin_tbegin_retry (&global_tdb, 42);\n+  cc = __builtin_tbegin_retry ((void *)0x12345678, global);\n+  cc = __builtin_tbegin_retry (\n+\t  (void *)(long long) (reg + 0x12345678), global + 1);\n+  cc = __builtin_tbegin_retry (\n+\t  (void *)(long long)(reg), global - 1);\n+\n+  __builtin_tbegin_retry_nofloat ((void *)0, 0);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0, 1);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0, -1);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0, 42);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0, reg);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0, *mem);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0, global);\n+  cc = __builtin_tbegin_retry_nofloat (tdb, 42);\n+  cc = __builtin_tbegin_retry_nofloat (&global_tdb, 42);\n+  cc = __builtin_tbegin_retry_nofloat ((void *)0x12345678, global);\n+  cc = __builtin_tbegin_retry_nofloat (\n+\t  (void *)(long long) (reg + 0x12345678), global + 1);\n+  cc = __builtin_tbegin_retry_nofloat (\n+\t  (void *)(long long)(reg), global - 1);\n+\n+  __builtin_tbeginc ();\n+\n+  __builtin_tx_nesting_depth ();\n+  n = __builtin_tx_nesting_depth ();\n+\n+  __builtin_non_tx_store (mem64, 0);\n+  {\n+\t  const uint64_t val_var = 0x1122334455667788;\n+\n+\t  __builtin_non_tx_store (mem64, val_var);\n+  }\n+  __builtin_non_tx_store (mem64, (uint64_t)reg);\n+  __builtin_non_tx_store (mem64, g);\n+  __builtin_non_tx_store ((uint64_t *)0, 0);\n+  __builtin_non_tx_store ((uint64_t *)0x12345678, 0);\n+  __builtin_non_tx_store (&g, 23);\n+  __builtin_non_tx_store (&g, reg);\n+  __builtin_non_tx_store (&g, *mem);\n+  __builtin_non_tx_store (&g, global);\n+\n+  __builtin_tend();\n+\n+  __builtin_tx_assist (0);\n+  __builtin_tx_assist (1);\n+  __builtin_tx_assist (reg);\n+  __builtin_tx_assist (*mem);\n+  __builtin_tx_assist (global);\n+}\n+\n+/* The taborts must go into separate function since they are\n+   \"noreturn\".  */\n+\n+void\n+tabort1 ()\n+{\n+  __builtin_tabort (256);\n+}\n+\n+void\n+tabort2 (int reg)\n+{\n+  __builtin_tabort (reg);\n+}\n+\n+void\n+tabort3 (int reg)\n+{\n+  /* { dg-final { scan-assembler-times \"tabort\\t255\" 1 } } */\n+  __builtin_tabort (reg + 255);\n+}\n+\n+void\n+tabort4 (int *mem)\n+{\n+  __builtin_tabort (*mem);\n+}\n+\n+void\n+tabort5 ()\n+{\n+  __builtin_tabort (global);\n+}\n+\n+void\n+tabort6 (int *mem)\n+{\n+  /* Here global + 255 gets reloaded into a reg.  Better would be to\n+     just reload global or *mem and get the +255 for free as address\n+     arithmetic.  */\n+  __builtin_tabort (*mem + 255);\n+}\n+\n+void\n+tabort7 ()\n+{\n+  __builtin_tabort (global + 255);\n+}\n+\n+void\n+tabort8 ()\n+{\n+  __builtin_tabort (-1);\n+}\n+\n+\n+/* Make sure the tdb NULL argument ends up as immediate value in the\n+   instruction.  */\n+/* { dg-final { scan-assembler-times \"tbegin\\t0,\" 17 } } */\n+/* { dg-final { scan-assembler-times \"tbegin\\t\" 41 } } */\n+/* Check number of occurences of certain instructions.  */\n+/* { dg-final { scan-assembler-times \"tbeginc\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tabort\\t\" 8 } } */\n+/* { dg-final { scan-assembler \"ppa\\t\" } } */"}, {"sha": "67d76a6d3d31511ef44639673c367cf34109f319", "filename": "gcc/testsuite/gcc.target/s390/htm-builtins-compile-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-2.c?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+void must_not_compile1 (void)\n+{\n+  __builtin_tabort (0); /* { dg-error \"Invalid transaction abort code:\" } */\n+}\n+\n+void must_not_compile2 (void)\n+{\n+  __builtin_tabort (255); /* { dg-error \"Invalid transaction abort code:\" } */\n+}"}, {"sha": "77ceeb7706f77688b219e4e1ea813b2a4e6d6d2e", "filename": "gcc/testsuite/gcc.target/s390/htm-builtins-compile-3.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-builtins-compile-3.c?ref=2561451d55ea70007f0a249b532609c23036fcd9", "previous_filename": "gcc/testsuite/gcc.target/s390/htm-xl-intrin-1.c"}, {"sha": "f7f9ad25607d3ab97a562b5976aa42b312c79fb0", "filename": "gcc/testsuite/gcc.target/s390/s390.exp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fs390.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2561451d55ea70007f0a249b532609c23036fcd9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fs390.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fs390.exp?ref=2561451d55ea70007f0a249b532609c23036fcd9", "patch": "@@ -24,6 +24,19 @@ if ![istarget s390*-*-*] then {\n # Load support procs.\n load_lib gcc-dg.exp\n \n+# Return 1 if htm (etnd - extract nesting depth) instructions can be\n+# compiled.\n+proc check_effective_target_htm { } {\n+    if { ![check_runtime s390_check_htm [subst {\n+\tint main (void)\n+\t{\n+\t    unsigned int nd = 77;\n+\t    asm (\".insn rre,0xb2ec0000,%0,0\" : \"=d\" (nd));\n+\t    return nd;\n+\t}\n+    }]] } { return 0 } else { return 1 }\n+}\n+\n # If a testcase doesn't have special options, use these.\n global DEFAULT_CFLAGS\n if ![info exists DEFAULT_CFLAGS] then {"}]}