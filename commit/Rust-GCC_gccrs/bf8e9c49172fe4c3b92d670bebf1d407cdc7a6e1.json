{"sha": "bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY4ZTljNDkxNzJmZTRjM2I5MmQ2NzBiZWJmMWQ0MDdjZGM3YTZlMQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-04T04:47:55Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-04T04:47:55Z"}, "message": "ggc-zone.c (lookup_page_table_if_allocated, [...]): Fix -Wc++-compat and/or -Wcast-qual warnings.\n\n\t* ggc-zone.c (lookup_page_table_if_allocated,\n\tset_page_table_entry, zone_find_object_size, alloc_small_page,\n\talloc_large_page, ggc_free, gt_ggc_m_S, ggc_marked_p, init_ggc,\n\tnew_ggc_zone, init_ggc_pch, ggc_pch_this_base, ggc_pch_read): Fix\n\t-Wc++-compat and/or -Wcast-qual warnings.\n\nFrom-SVN: r137450", "tree": {"sha": "1c3867587aac009b4a8521aad393fe3614411534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c3867587aac009b4a8521aad393fe3614411534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1/comments", "author": null, "committer": null, "parents": [{"sha": "1d3155fc2e6bcaf799aec31fe75c868dc2d0391b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3155fc2e6bcaf799aec31fe75c868dc2d0391b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3155fc2e6bcaf799aec31fe75c868dc2d0391b"}], "stats": {"total": 38, "additions": 23, "deletions": 15}, "files": [{"sha": "700367a723033ed4a30aff0e2f48d9d6b2fa6e8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1", "patch": "@@ -1,3 +1,11 @@\n+2008-07-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ggc-zone.c (lookup_page_table_if_allocated,\n+\tset_page_table_entry, zone_find_object_size, alloc_small_page,\n+\talloc_large_page, ggc_free, gt_ggc_m_S, ggc_marked_p, init_ggc,\n+\tnew_ggc_zone, init_ggc_pch, ggc_pch_this_base, ggc_pch_read): Fix\n+\t-Wc++-compat and/or -Wcast-qual warnings.\n+\n 2008-07-04  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/36634"}, {"sha": "5031a01b404b58f81b37775647ea518c9f0c3740", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=bf8e9c49172fe4c3b92d670bebf1d407cdc7a6e1", "patch": "@@ -541,7 +541,7 @@ lookup_page_table_if_allocated (const void *p)\n     return NULL;\n   /* We might have a page entry which does not correspond exactly to a\n      system page.  */\n-  if (base[L1][L2] && (char *) p < base[L1][L2]->page)\n+  if (base[L1][L2] && (const char *) p < base[L1][L2]->page)\n     return NULL;\n \n   return base[L1][L2];\n@@ -566,7 +566,7 @@ set_page_table_entry (void *p, page_entry *entry)\n       goto found;\n \n   /* Not found -- allocate a new table.  */\n-  table = xcalloc (1, sizeof(*table));\n+  table = XCNEW (struct page_table_chain);\n   table->next = G.lookup;\n   table->high_bits = high_bits;\n   G.lookup = table;\n@@ -579,7 +579,7 @@ set_page_table_entry (void *p, page_entry *entry)\n   L2 = LOOKUP_L2 (p);\n \n   if (base[L1] == NULL)\n-    base[L1] = xcalloc (PAGE_L2_SIZE, sizeof (page_entry *));\n+    base[L1] = XCNEWVEC (page_entry *, PAGE_L2_SIZE);\n \n   base[L1][L2] = entry;\n }\n@@ -715,7 +715,7 @@ zone_find_object_size (struct small_page_entry *page,\n   unsigned int start_word = zone_get_object_alloc_word (object_midptr);\n   unsigned int start_bit = zone_get_object_alloc_bit (object_midptr);\n   size_t max_size = (page->common.page + SMALL_PAGE_SIZE\n-\t\t     - (char *) object);\n+\t\t     - (const char *) object);\n \n   return zone_object_size_1 (page->alloc_bits, start_word, start_bit,\n \t\t\t     max_size);\n@@ -898,7 +898,7 @@ alloc_small_page (struct alloc_zone *zone)\n \t memory order.  */\n       for (i = G.quire_size - 1; i >= 1; i--)\n \t{\n-\t  e = xcalloc (1, G.small_page_overhead);\n+\t  e = XCNEWVAR (struct small_page_entry, G.small_page_overhead);\n \t  e->common.page = page + (i << GGC_PAGE_SHIFT);\n \t  e->common.zone = zone;\n \t  e->next = f;\n@@ -908,7 +908,7 @@ alloc_small_page (struct alloc_zone *zone)\n \n       zone->free_pages = f;\n \n-      entry = xcalloc (1, G.small_page_overhead);\n+      entry = XCNEWVAR (struct small_page_entry, G.small_page_overhead);\n       entry->common.page = page;\n       entry->common.zone = zone;\n       set_page_table_entry (page, &entry->common);\n@@ -935,7 +935,7 @@ alloc_large_page (size_t size, struct alloc_zone *zone)\n   size_t needed_size;\n \n   needed_size = size + sizeof (struct large_page_entry);\n-  page = xmalloc (needed_size);\n+  page = XNEWVAR (char, needed_size);\n \n   entry = (struct large_page_entry *) page;\n \n@@ -1439,7 +1439,7 @@ ggc_free (void *p)\n \n       /* Add the chunk to the free list.  We don't bother with coalescing,\n \t since we are likely to want a chunk of this size again.  */\n-      free_chunk (p, size, page->zone);\n+      free_chunk ((char *)p, size, page->zone);\n     }\n }\n \n@@ -1494,7 +1494,7 @@ gt_ggc_m_S (const void *p)\n \t a STRING_CST.  */\n       gcc_assert (offset == offsetof (struct tree_string, str));\n       p = ((const char *) p) - offset;\n-      gt_ggc_mx_lang_tree_node ((void *) p);\n+      gt_ggc_mx_lang_tree_node (CONST_CAST(void *, p));\n       return;\n     }\n \n@@ -1560,7 +1560,7 @@ int\n ggc_marked_p (const void *p)\n {\n   struct page_entry *page;\n-  const char *ptr = p;\n+  const char *ptr = (const char *) p;\n \n   page = zone_get_object_page (p);\n \n@@ -1686,7 +1686,7 @@ init_ggc (void)\n     if (GGC_PAGE_SIZE == G.pagesize)\n       {\n \t/* We have a good page, might as well hold onto it...  */\n-\te = xcalloc (1, G.small_page_overhead);\n+\te = XCNEWVAR (struct small_page_entry, G.small_page_overhead);\n \te->common.page = p;\n \te->common.zone = &main_zone;\n \te->next = main_zone.free_pages;\n@@ -1714,7 +1714,7 @@ new_ggc_zone_1 (struct alloc_zone *new_zone, const char * name)\n struct alloc_zone *\n new_ggc_zone (const char * name)\n {\n-  struct alloc_zone *new_zone = xcalloc (1, sizeof (struct alloc_zone));\n+  struct alloc_zone *new_zone = XCNEW (struct alloc_zone);\n   new_ggc_zone_1 (new_zone, name);\n   return new_zone;\n }\n@@ -2301,7 +2301,7 @@ struct ggc_pch_data\n struct ggc_pch_data *\n init_ggc_pch (void)\n {\n-  return xcalloc (sizeof (struct ggc_pch_data), 1);\n+  return XCNEW (struct ggc_pch_data);\n }\n \n /* Return which of the page-aligned buckets the object at X, with type\n@@ -2380,7 +2380,7 @@ ggc_pch_this_base (struct ggc_pch_data *d, void *base_)\n     }\n \n   if (d->alloc_bits == NULL)\n-    d->alloc_bits = xcalloc (1, d->alloc_size);\n+    d->alloc_bits = XCNEWVAR (alloc_type, d->alloc_size);\n }\n \n /* Allocate a place for object X of size SIZE in the PCH file.  */\n@@ -2516,7 +2516,7 @@ ggc_pch_read (FILE *f, void *addr)\n \n   /* Allocate the dummy page entry for the PCH, and set all pages\n      mapped into the PCH to reference it.  */\n-  pch_page = xcalloc (1, sizeof (struct page_entry));\n+  pch_page = XCNEW (struct page_entry);\n   pch_page->page = pch_zone.page;\n   pch_page->pch_p = true;\n "}]}