{"sha": "7c339b3b5a63bac5e5223e33cce4c9833153edbb", "node_id": "C_kwDOANBUbNoAKDdjMzM5YjNiNWE2M2JhYzVlNTIyM2UzM2NjZTRjOTgzMzE1M2VkYmI", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-07-11T15:00:46Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-02T07:34:06Z"}, "message": "[Ada] Recover proof of Scaled_Divide in System.Arith_64\n\nProof of Scaled_Divide was impacted by changes in provers and Why3.\nRecover it partially, leaving some unproved basic inferences to be\nfurther investigated.\n\ngcc/ada/\n\n\t* libgnat/s-aridou.adb: Add or rework ghost code.\n\t* libgnat/s-aridou.ads: Add Big_Positive subtype.", "tree": {"sha": "1ee1568c1a5589695d0d6dbab3e38b587c753938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ee1568c1a5589695d0d6dbab3e38b587c753938"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c339b3b5a63bac5e5223e33cce4c9833153edbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c339b3b5a63bac5e5223e33cce4c9833153edbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c339b3b5a63bac5e5223e33cce4c9833153edbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c339b3b5a63bac5e5223e33cce4c9833153edbb/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66643a9fe96e66914f074bee84d1fc30915afcb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66643a9fe96e66914f074bee84d1fc30915afcb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66643a9fe96e66914f074bee84d1fc30915afcb5"}], "stats": {"total": 333, "additions": 211, "deletions": 122}, "files": [{"sha": "52f23601448e37dfc890ed33b45c8405a249e90e", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 210, "deletions": 122, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c339b3b5a63bac5e5223e33cce4c9833153edbb/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c339b3b5a63bac5e5223e33cce4c9833153edbb/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=7c339b3b5a63bac5e5223e33cce4c9833153edbb", "patch": "@@ -126,7 +126,7 @@ is\n      Pre => B /= 0;\n    --  Length doubling remainder\n \n-   function Big_2xx (N : Natural) return Big_Integer is\n+   function Big_2xx (N : Natural) return Big_Positive is\n      (Big (Double_Uns'(2 ** N)))\n    with\n      Ghost,\n@@ -141,6 +141,13 @@ is\n    with Ghost;\n    --  X1&X2&X3 as a big integer\n \n+   function Big3 (X1, X2, X3 : Big_Integer) return Big_Integer is\n+     (Big_2xxSingle * Big_2xxSingle * X1\n+                    + Big_2xxSingle * X2\n+                                    + X3)\n+   with Ghost;\n+   --  Version of Big3 on big integers\n+\n    function Le3 (X1, X2, X3, Y1, Y2, Y3 : Single_Uns) return Boolean\n    with\n      Post => Le3'Result = (Big3 (X1, X2, X3) <= Big3 (Y1, Y2, Y3));\n@@ -234,6 +241,17 @@ is\n      Pre  => X /= Double_Uns'Last,\n      Post => Big (X + Double_Uns'(1)) = Big (X) + 1;\n \n+   procedure Lemma_Big_Of_Double_Uns (X : Double_Uns)\n+   with\n+     Ghost,\n+     Post => Big (X) < Big_2xxDouble;\n+\n+   procedure Lemma_Big_Of_Double_Uns_Of_Single_Uns (X : Single_Uns)\n+   with\n+     Ghost,\n+     Post => Big (Double_Uns (X)) >= 0\n+       and then Big (Double_Uns (X)) < Big_2xxSingle;\n+\n    procedure Lemma_Bounded_Powers_Of_2_Increasing (M, N : Natural)\n    with\n      Ghost,\n@@ -447,9 +465,9 @@ is\n    procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer)\n    with\n      Ghost,\n-     Pre  => (X >= Big_0 and then Y >= Big_0)\n-       or else (X <= Big_0 and then Y <= Big_0),\n-     Post => X * Y >= Big_0;\n+     Pre  => (X >= 0 and then Y >= 0)\n+       or else (X <= 0 and then Y <= 0),\n+     Post => X * Y >= 0;\n \n    procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer)\n    with\n@@ -458,6 +476,13 @@ is\n        or else (X >= Big_0 and then Y <= Big_0),\n      Post => X * Y <= Big_0;\n \n+   procedure Lemma_Mult_Positive (X, Y : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => (X > Big_0 and then Y > Big_0)\n+       or else (X < Big_0 and then Y < Big_0),\n+     Post => X * Y > Big_0;\n+\n    procedure Lemma_Neg_Div (X, Y : Big_Integer)\n    with\n      Ghost,\n@@ -604,6 +629,8 @@ is\n    procedure Lemma_Abs_Range (X : Big_Integer) is null;\n    procedure Lemma_Add_Commutation (X : Double_Uns; Y : Single_Uns) is null;\n    procedure Lemma_Add_One (X : Double_Uns) is null;\n+   procedure Lemma_Big_Of_Double_Uns (X : Double_Uns) is null;\n+   procedure Lemma_Big_Of_Double_Uns_Of_Single_Uns (X : Single_Uns) is null;\n    procedure Lemma_Bounded_Powers_Of_2_Increasing (M, N : Natural) is null;\n    procedure Lemma_Deep_Mult_Commutation\n      (Factor : Big_Integer;\n@@ -638,6 +665,7 @@ is\n    procedure Lemma_Mult_Distribution (X, Y, Z : Big_Integer) is null;\n    procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer) is null;\n    procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer) is null;\n+   procedure Lemma_Mult_Positive (X, Y : Big_Integer) is null;\n    procedure Lemma_Neg_Rem (X, Y : Big_Integer) is null;\n    procedure Lemma_Not_In_Range_Big2xx64 is null;\n    procedure Lemma_Powers (A : Big_Natural; B, C : Natural) is null;\n@@ -1888,7 +1916,7 @@ is\n \n       --  Local ghost variables\n \n-      Mult  : constant Big_Integer := abs (Big (X) * Big (Y)) with Ghost;\n+      Mult  : constant Big_Natural := abs (Big (X) * Big (Y)) with Ghost;\n       Quot  : Big_Integer with Ghost;\n       Big_R : Big_Integer with Ghost;\n       Big_Q : Big_Integer with Ghost;\n@@ -1955,6 +1983,15 @@ is\n       --  Proves correctness of the multiplication of divisor by quotient to\n       --  compute amount to subtract.\n \n+      procedure Prove_Mult_Decomposition_Split3\n+        (D1, D2, D3, D3_Hi, D3_Lo, D4 : Big_Integer)\n+      with\n+        Ghost,\n+        Pre  => Is_Mult_Decomposition (D1, D2, D3, D4)\n+          and then D3 = Big_2xxSingle * D3_Hi + D3_Lo,\n+        Post => Is_Mult_Decomposition (D1, D2 + D3_Hi, D3_Lo, D4);\n+      --  Proves decomposition of Mult after splitting third component\n+\n       procedure Prove_Negative_Dividend\n       with\n         Ghost,\n@@ -2066,6 +2103,27 @@ is\n            else abs Quot);\n       --  Proves correctness of the rounding of the unsigned quotient\n \n+      procedure Prove_Scaled_Mult_Decomposition_Regroup24\n+        (D1, D2, D3, D4 : Big_Integer)\n+      with\n+        Ghost,\n+        Pre  => Scale < Double_Size\n+          and then Is_Scaled_Mult_Decomposition (D1, D2, D3, D4),\n+        Post => Is_Scaled_Mult_Decomposition\n+          (0, Big_2xxSingle * D1 + D2, 0, Big_2xxSingle * D3 + D4);\n+      --  Proves scaled decomposition of Mult after regrouping on second and\n+      --  fourth component.\n+\n+      procedure Prove_Scaled_Mult_Decomposition_Regroup3\n+        (D1, D2, D3, D4 : Big_Integer)\n+      with\n+        Ghost,\n+        Pre  => Scale < Double_Size\n+          and then Is_Scaled_Mult_Decomposition (D1, D2, D3, D4),\n+        Post => Is_Scaled_Mult_Decomposition (0, 0, Big3 (D1, D2, D3), D4);\n+      --  Proves scaled decomposition of Mult after regrouping on third\n+      --  component.\n+\n       procedure Prove_Sign_R\n       with\n         Ghost,\n@@ -2315,6 +2373,14 @@ is\n                                               + Big (Double_Uns (S3))));\n       end Prove_Multiplication;\n \n+      -------------------------------------\n+      -- Prove_Mult_Decomposition_Split3 --\n+      -------------------------------------\n+\n+      procedure Prove_Mult_Decomposition_Split3\n+        (D1, D2, D3, D3_Hi, D3_Lo, D4 : Big_Integer)\n+      is null;\n+\n       -----------------------------\n       -- Prove_Negative_Dividend --\n       -----------------------------\n@@ -2413,6 +2479,22 @@ is\n          end if;\n       end Prove_Rounding_Case;\n \n+      -----------------------------------------------\n+      -- Prove_Scaled_Mult_Decomposition_Regroup24 --\n+      -----------------------------------------------\n+\n+      procedure Prove_Scaled_Mult_Decomposition_Regroup24\n+        (D1, D2, D3, D4 : Big_Integer)\n+      is null;\n+\n+      ----------------------------------------------\n+      -- Prove_Scaled_Mult_Decomposition_Regroup3 --\n+      ----------------------------------------------\n+\n+      procedure Prove_Scaled_Mult_Decomposition_Regroup3\n+        (D1, D2, D3, D4 : Big_Integer)\n+      is null;\n+\n       ------------------\n       -- Prove_Sign_R --\n       ------------------\n@@ -2585,29 +2667,15 @@ is\n             T2 := D (3) + Lo (T1);\n \n             Lemma_Add_Commutation (Double_Uns (D (3)), Lo (T1));\n-            pragma Assert\n-              (Is_Mult_Decomposition\n-                 (D1 => 0,\n-                  D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2)))\n-                    + Big (Double_Uns (Hi (T1))),\n-                  D3 => Big (T2),\n-                  D4 => Big (Double_Uns (D (4)))));\n             Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n-            pragma Assert\n-              (By (Is_Mult_Decomposition\n-                 (D1 => 0,\n-                  D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2)))\n-                    + Big (Double_Uns (Hi (T1))) + Big (Double_Uns (Hi (T2))),\n-                  D3 => Big (Double_Uns (Lo (T2))),\n-                  D4 => Big (Double_Uns (D (4)))),\n-               By (Big_2xxSingle * Big (T2) =\n-                 Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n-                 + Big_2xxSingle * Big (Double_Uns (Lo (T2))),\n-               Big_2xxSingle *\n-                 (Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n-                                + Big (Double_Uns (Lo (T2))))\n-              = Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n-                  + Big_2xxSingle * Big (Double_Uns (Lo (T2))))));\n+            Prove_Mult_Decomposition_Split3\n+              (D1    => 0,\n+               D2    => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2)))\n+                 + Big (Double_Uns (Hi (T1))),\n+               D3    => Big (T2),\n+               D3_Hi => Big (Double_Uns (Hi (T2))),\n+               D3_Lo => Big (Double_Uns (Lo (T2))),\n+               D4    => Big (Double_Uns (D (4))));\n \n             D (3) := Lo (T2);\n             T3 := D (2) + Hi (T1);\n@@ -2807,8 +2875,20 @@ is\n                pragma Assert\n                  (Mult >= Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n                           * Big (Double_Uns (D (1))));\n+               Lemma_Double_Big_2xxSingle;\n+               Lemma_Mult_Positive (Big_2xxDouble, Big_2xxSingle);\n+               Lemma_Ge_Mult (Big (Double_Uns (D (1))),\n+                              1,\n+                              Big_2xxDouble * Big_2xxSingle,\n+                              Big_2xxDouble * Big_2xxSingle);\n+               Lemma_Mult_Positive (Big_2xxSingle, Big (Double_Uns (D (1))));\n+               Lemma_Ge_Mult (Big_2xxSingle * Big_2xxSingle, Big_2xxDouble,\n+                              Big_2xxSingle * Big (Double_Uns (D (1))),\n+                              Big_2xxDouble * Big_2xxSingle);\n                pragma Assert (Mult >= Big_2xxDouble * Big_2xxSingle);\n                Lemma_Ge_Commutation (2 ** Single_Size, Zu);\n+               Lemma_Ge_Mult (Big_2xxSingle, Big (Zu), Big_2xxDouble,\n+                              Big_2xxDouble * Big (Zu));\n                pragma Assert (Mult >= Big_2xxDouble * Big (Zu));\n             else\n                Lemma_Ge_Commutation (Double_Uns (D (2)), Zu);\n@@ -2887,6 +2967,13 @@ is\n                  Post => Shift / 2 = 2 ** (Log_Single_Size - (Inter + 1))\n                    and then (Shift = 2 or (Shift / 2) mod 2 = 0);\n \n+               procedure Prove_Prev_And_Mask (Prev, Mask : Single_Uns)\n+               with\n+                 Ghost,\n+                 Pre  => Prev /= 0\n+                   and then (Prev and Mask) = 0,\n+                 Post => (Prev and not Mask) /= 0;\n+\n                procedure Prove_Shift_Progress\n                with\n                  Ghost,\n@@ -2918,6 +3005,7 @@ is\n                -- Local lemma null bodies --\n                -----------------------------\n \n+               procedure Prove_Prev_And_Mask (Prev, Mask : Single_Uns) is null;\n                procedure Prove_Power is null;\n                procedure Prove_Shifting is null;\n                procedure Prove_Shift_Progress is null;\n@@ -2941,6 +3029,15 @@ is\n                if (Hi (Zu) and Mask) = 0 then\n                   Zu := Shift_Left (Zu, Shift);\n \n+                  pragma Assert ((Hi (Zu_Prev) and Mask_Prev) /= 0);\n+                  pragma Assert\n+                    (By ((Hi (Zu_Prev) and Mask_Prev and Mask) = 0,\n+                     (Hi (Zu_Prev) and Mask) = 0\n+                     and then\n+                     (Hi (Zu_Prev) and Mask_Prev and Mask)\n+                     = (Hi (Zu_Prev) and Mask and Mask_Prev)\n+                    ));\n+                  Prove_Prev_And_Mask (Hi (Zu_Prev) and Mask_Prev, Mask);\n                   Prove_Shifting;\n                   pragma Assert (Big (Zu_Prev) =\n                     Big (Double_Uns'(abs Z)) * Big_2xx (Scale));\n@@ -2986,6 +3083,7 @@ is\n          --  not change the invariant that (D (1) & D (2)) < Zu.\n \n          Lemma_Lt_Commutation (D (1) & D (2), abs Z);\n+         Lemma_Big_Of_Double_Uns (Zu);\n          Lemma_Lt_Mult (Big (D (1) & D (2)),\n                         Big (Double_Uns'(abs Z)), Big_2xx (Scale),\n                         Big_2xxDouble);\n@@ -3007,82 +3105,21 @@ is\n             * Big (Double_Uns (Hi (T1)))\n             = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n             * Big (Double_Uns (D (1))));\n-\n-         pragma Assert\n-           (Is_Scaled_Mult_Decomposition\n-              (Big (Double_Uns (D (1))),\n-               Big (Double_Uns (D (2))),\n-               Big (Double_Uns (D (3))),\n-               Big (Double_Uns (D (4)))));\n-         pragma Assert\n-           (By (Is_Scaled_Mult_Decomposition\n-              (0,\n-               0,\n-               Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-                             + Big_2xxSingle * Big (Double_Uns (D (2)))\n-                                             + Big (Double_Uns (D (3))),\n-               Big (Double_Uns (D (4)))),\n-            Big_2xxSingle *\n-              (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-                             + Big_2xxSingle * Big (Double_Uns (D (2)))\n-                                             + Big (Double_Uns (D (3))))\n-            + Big (Double_Uns (D (4))) =\n-              Big_2xxSingle *\n-              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                            + Big (Double_Uns (D (4)))\n-              and then\n-            (By (Mult * Big_2xx (Scale) =\n-              Big_2xxSingle *\n-              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                            + Big (Double_Uns (D (4))),\n-             Is_Scaled_Mult_Decomposition\n-              (Big (Double_Uns (D (1))),\n-               Big (Double_Uns (D (2))),\n-               Big (Double_Uns (D (3))),\n-               Big (Double_Uns (D (4))))))));\n-         Lemma_Substitution\n-           (Mult * Big_2xx (Scale), Big_2xxSingle,\n-            Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-                          + Big_2xxSingle * Big (Double_Uns (D (2)))\n-                                          + Big (Double_Uns (D (3))),\n-            Big3 (D (1), D (2), D (3)),\n-            Big (Double_Uns (D (4))));\n          Lemma_Substitution (Big_2xxDouble * Big (Zu), Big_2xxDouble, Big (Zu),\n                              Big (Double_Uns'(abs Z)) * Big_2xx (Scale), 0);\n          Lemma_Lt_Mult (Mult, Big_2xxDouble * Big (Double_Uns'(abs Z)),\n                         Big_2xx (Scale), Big_2xxDouble * Big (Zu));\n+         pragma Assert (Mult >= Big_0);\n+         pragma Assert (Big_2xx (Scale) >= Big_0);\n+         Lemma_Mult_Non_Negative (Mult, Big_2xx (Scale));\n          Lemma_Div_Lt (Mult * Big_2xx (Scale), Big (Zu), Big_2xxDouble);\n          Lemma_Concat_Definition (D (1), D (2));\n          Lemma_Double_Big_2xxSingle;\n-         pragma Assert\n-           (Big_2xxSingle *\n-              (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-                             + Big_2xxSingle * Big (Double_Uns (D (2)))\n-                                             + Big (Double_Uns (D (3))))\n-            + Big (Double_Uns (D (4)))\n-            = Big_2xxSingle * Big_2xxSingle *\n-              (Big_2xxSingle * Big (Double_Uns (D (1)))\n-                             + Big (Double_Uns (D (2))))\n-            + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                            + Big (Double_Uns (D (4))));\n-         pragma Assert\n-           (By (Is_Scaled_Mult_Decomposition\n-              (0,\n-               Big_2xxSingle * Big (Double_Uns (D (1)))\n-                             + Big (Double_Uns (D (2))),\n-               0,\n-               Big_2xxSingle * Big (Double_Uns (D (3)))\n-                             + Big (Double_Uns (D (4)))),\n-            Big_2xxSingle * Big_2xxSingle *\n-              (Big_2xxSingle * Big (Double_Uns (D (1)))\n-                             + Big (Double_Uns (D (2)))) =\n-            Big_2xxSingle *\n-              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))));\n+         Prove_Scaled_Mult_Decomposition_Regroup24\n+           (Big (Double_Uns (D (1))),\n+            Big (Double_Uns (D (2))),\n+            Big (Double_Uns (D (3))),\n+            Big (Double_Uns (D (4))));\n          Lemma_Substitution\n            (Mult * Big_2xx (Scale), Big_2xxSingle * Big_2xxSingle,\n               Big_2xxSingle * Big (Double_Uns (D (1)))\n@@ -3115,10 +3152,20 @@ is\n             --  Local ghost variables\n \n             Qd1  : Single_Uns := 0 with Ghost;\n+            D234 : Big_Integer := 0 with Ghost;\n             D123 : constant Big_Integer := Big3 (D (1), D (2), D (3))\n               with Ghost;\n+            D4   : constant Big_Integer := Big (Double_Uns (D (4)))\n+              with Ghost;\n \n          begin\n+            Prove_Scaled_Mult_Decomposition_Regroup3\n+              (Big (Double_Uns (D (1))),\n+               Big (Double_Uns (D (2))),\n+               Big (Double_Uns (D (3))),\n+               Big (Double_Uns (D (4))));\n+            pragma Assert (Mult * Big_2xx (Scale) = Big_2xxSingle * D123 + D4);\n+\n             for J in 1 .. 2 loop\n                Lemma_Hi_Lo (D (J) & D (J + 1), D (J), D (J + 1));\n                pragma Assert (Big (D (J) & D (J + 1)) < Big (Zu));\n@@ -3138,6 +3185,7 @@ is\n                   Qd (J) := Single_Uns'Last;\n \n                   Lemma_Concat_Definition (D (J), D (J + 1));\n+                  Lemma_Big_Of_Double_Uns_Of_Single_Uns (D (J + 2));\n                   pragma Assert (Big_2xxSingle > Big (Double_Uns (D (J + 2))));\n                   pragma Assert (Big3 (D (J), D (J + 1), 0) + Big_2xxSingle\n                                  > Big3 (D (J), D (J + 1), D (J + 2)));\n@@ -3158,13 +3206,16 @@ is\n                   Lemma_Div_Lt\n                     (Big3 (D (J), D (J + 1), D (J + 2)),\n                      Big_2xxSingle, Big (Zu));\n+                  pragma Assert (Big (Double_Uns (Qd (J))) >=\n+                    Big3 (D (J), D (J + 1), D (J + 2)) / Big (Zu));\n \n                else\n                   Qd (J) := Lo ((D (J) & D (J + 1)) / Zhi);\n \n                   Prove_Qd_Calculation_Part_1 (J);\n                end if;\n \n+               pragma Assert (for all K in 1 .. J => Qd (K)'Initialized);\n                Lemma_Gt_Mult\n                  (Big (Double_Uns (Qd (J))),\n                   Big3 (D (J), D (J + 1), D (J + 2)) / Big (Zu),\n@@ -3199,7 +3250,9 @@ is\n                Lemma_Hi_Lo_3 (Zu, Zhi, Zlo);\n \n                while not Le3 (S1, S2, S3, D (J), D (J + 1), D (J + 2)) loop\n-                  pragma Loop_Invariant (Qd (J)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in 1 .. J => Qd (K)'Initialized);\n+                  pragma Loop_Invariant (if J = 2 then Qd (1) = Qd1);\n                   pragma Loop_Invariant\n                     (Big3 (S1, S2, S3) = Big (Double_Uns (Qd (J))) * Big (Zu));\n                   pragma Loop_Invariant\n@@ -3240,6 +3293,7 @@ is\n \n                --  Now subtract S1&S2&S3 from D1&D2&D3 ready for next step\n \n+               pragma Assert (for all K in 1 .. J => Qd (K)'Initialized);\n                pragma Assert\n                  (Big3 (S1, S2, S3) = Big (Double_Uns (Qd (J))) * Big (Zu));\n                pragma Assert (Big3 (S1, S2, S3) >\n@@ -3256,19 +3310,32 @@ is\n                       * Big_2xxSingle * Big (Double_Uns (D (J)))\n                       + Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n                                       + Big (Double_Uns (D (J + 2))));\n-                  pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) =\n-                    Big_2xxDouble * Big (Double_Uns (D (J)))\n-                  + Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n-                                  + Big (Double_Uns (D (J + 2))));\n                   pragma Assert (Big_2xxSingle >= 0);\n+                  Lemma_Big_Of_Double_Uns_Of_Single_Uns (D (J + 1));\n                   pragma Assert (Big (Double_Uns (D (J + 1))) >= 0);\n+                  Lemma_Mult_Non_Negative\n+                    (Big_2xxSingle, Big (Double_Uns (D (J + 1))));\n                   pragma Assert\n-                    (Big_2xxSingle * Big (Double_Uns (D (J + 1))) >= 0);\n-                  pragma Assert\n-                    (Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n-                                   + Big (Double_Uns (D (J + 2))) >= 0);\n-                  pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) >=\n-                                   Big_2xxDouble * Big (Double_Uns (D (J))));\n+                    (By (Big3 (D (J), D (J + 1), D (J + 2)) >=\n+                       Big_2xxSingle * Big_2xxSingle\n+                       * Big (Double_Uns (D (J))),\n+                     By (Big3 (D (J), D (J + 1), D (J + 2))\n+                     - Big_2xxSingle * Big_2xxSingle\n+                       * Big (Double_Uns (D (J)))\n+                     = Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n+                                     + Big (Double_Uns (D (J + 2))),\n+                     Big3 (D (J), D (J + 1), D (J + 2)) =\n+                       Big_2xxSingle\n+                       * Big_2xxSingle * Big (Double_Uns (D (J)))\n+                       + Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n+                                       + Big (Double_Uns (D (J + 2))))\n+                       and then\n+                     By (Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n+                                       + Big (Double_Uns (D (J + 2))) >= 0,\n+                     Big_2xxSingle * Big (Double_Uns (D (J + 1))) >= 0\n+                       and then\n+                     Big (Double_Uns (D (J + 2))) >= 0\n+                    )));\n                   Lemma_Ge_Commutation (Double_Uns (D (J)), Double_Uns'(1));\n                   Lemma_Ge_Mult (Big (Double_Uns (D (J))),\n                                  Big (Double_Uns'(1)),\n@@ -3283,6 +3350,8 @@ is\n \n                if J = 1 then\n                   Qd1 := Qd (1);\n+                  D234 := Big3 (D (2), D (3), D (4));\n+                  pragma Assert (D4 = Big (Double_Uns (D (4))));\n                   Lemma_Substitution\n                     (Mult * Big_2xx (Scale), Big_2xxSingle, D123,\n                      Big3 (D (1), D (2), D (3)) + Big3 (S1, S2, S3),\n@@ -3291,23 +3360,38 @@ is\n                   Lemma_Substitution (Mult * Big_2xx (Scale), Big_2xxSingle,\n                                       Big3 (S1, S2, S3),\n                                       Big (Double_Uns (Qd1)) * Big (Zu),\n-                                      Big3 (D (2), D (3), D (4)));\n+                                      D234);\n                else\n                   pragma Assert (Qd1 = Qd (1));\n                   pragma Assert\n-                    (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                     = 0);\n-                  pragma Assert\n-                    (Mult * Big_2xx (Scale) =\n-                       Big_2xxSingle * Big (Double_Uns (Qd (1))) * Big (Zu)\n+                    (By (Mult * Big_2xx (Scale) =\n+                       Big_2xxSingle * Big (Double_Uns (Qd1)) * Big (Zu)\n                      + Big3 (S1, S2, S3)\n-                     + Big3 (D (2), D (3), D (4)));\n+                     + Big3 (D (2), D (3), D (4)),\n+                     Big3 (D (2), D (3), D (4)) = D234 - Big3 (S1, S2, S3)));\n                   pragma Assert\n-                    (Mult * Big_2xx (Scale) =\n+                    (By (Mult * Big_2xx (Scale) =\n                        Big_2xxSingle * Big (Double_Uns (Qd (1))) * Big (Zu)\n                                      + Big (Double_Uns (Qd (2))) * Big (Zu)\n                      + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                     + Big (Double_Uns (D (4))));\n+                                     + Big (Double_Uns (D (4))),\n+                     Big_2xxSingle * Big (Double_Uns (Qd (1))) * Big (Zu)\n+                       = Big_2xxSingle * Big (Double_Uns (Qd1)) * Big (Zu)\n+                       and then\n+                     Big3 (S1, S2, S3) = Big (Double_Uns (Qd (2))) * Big (Zu)\n+                       and then\n+                     By (Big3 (D (2), D (3), D (4))\n+                         = Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                         + Big (Double_Uns (D (4))),\n+                        Big3 (D (2), D (3), D (4))\n+                         = Big_2xxSingle * Big_2xxSingle *\n+                           Big (Double_Uns (D (2)))\n+                           + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                           + Big (Double_Uns (D (4)))\n+                          and then\n+                       Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                        = 0)\n+                    ));\n                end if;\n             end loop;\n          end;\n@@ -3319,6 +3403,7 @@ is\n          --  We rescale the divisor as well, to make the proper comparison\n          --  for rounding below.\n \n+         pragma Assert (for all K in 1 .. 2 => Qd (K)'Initialized);\n          Qu := Qd (1) & Qd (2);\n          Ru := D (3) & D (4);\n \n@@ -3440,14 +3525,14 @@ is\n         Ghost,\n         Pre  => X2 < Y2,\n         Post => Big3 (X1, X2 - Y2, X3)\n-              = Big3 (X1, X2, X3) + Big3 (1, 0, 0) - Big3 (0, Y2, 0);\n+          = Big3 (X1, X2, X3) + Big3 (Single_Uns'(1), 0, 0) - Big3 (0, Y2, 0);\n \n       procedure Lemma_Sub3_With_Carry3 (X1, X2, X3, Y3 : Single_Uns)\n       with\n         Ghost,\n         Pre  => X3 < Y3,\n         Post => Big3 (X1, X2, X3 - Y3)\n-              = Big3 (X1, X2, X3) + Big3 (0, 1, 0) - Big3 (0, 0, Y3);\n+          = Big3 (X1, X2, X3) + Big3 (Single_Uns'(0), 1, 0) - Big3 (0, 0, Y3);\n \n       -------------------------\n       -- Lemma_Add3_No_Carry --\n@@ -3522,10 +3607,12 @@ is\n             X1 := X1 - 1;\n \n             pragma Assert\n-              (Big3 (X1, X2, X3) = Big3 (XX1, XX2, XX3) - Big3 (1, 0, 0));\n+              (Big3 (X1, X2, X3) =\n+                 Big3 (XX1, XX2, XX3) - Big3 (Single_Uns'(1), 0, 0));\n             pragma Assert\n               (Big3 (X1, X2, X3) = Big3 (XX1, XX2, XX3)\n-               - Big3 (0, Single_Uns'Last, 0) - Big3 (0, 1, 0));\n+               - Big3 (Single_Uns'(0), Single_Uns'Last, 0)\n+               - Big3 (Single_Uns'(0), 1, 0));\n             Lemma_Add3_No_Carry (X1, X2, X3, 0, Single_Uns'Last, 0);\n          else\n             Lemma_Sub3_No_Carry (X1, X2, X3, 0, 1, 0);\n@@ -3534,7 +3621,8 @@ is\n          X2 := X2 - 1;\n \n          pragma Assert\n-           (Big3 (X1, X2, X3) = Big3 (XX1, XX2, XX3) - Big3 (0, 1, 0));\n+           (Big3 (X1, X2, X3) =\n+              Big3 (XX1, XX2, XX3) - Big3 (Single_Uns'(0), 1, 0));\n          Lemma_Sub3_With_Carry3 (X1, X2, X3, Y3);\n       else\n          Lemma_Sub3_No_Carry (X1, X2, X3, 0, 0, Y3);\n@@ -3553,7 +3641,7 @@ is\n \n          pragma Assert\n            (Big3 (X1, X2, X3) = Big3 (XX1, XX2, XX3)\n-            - Big3 (0, 0, Y3) - Big3 (1, 0, 0));\n+            - Big3 (0, 0, Y3) - Big3 (Single_Uns'(1), 0, 0));\n          Lemma_Sub3_With_Carry2 (X1, X2, X3, Y2);\n       else\n          Lemma_Sub3_No_Carry (X1, X2, X3, 0, Y2, 0);"}, {"sha": "08af4f5868907b41f4fe5764e5c3f38c504dac21", "filename": "gcc/ada/libgnat/s-aridou.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c339b3b5a63bac5e5223e33cce4c9833153edbb/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c339b3b5a63bac5e5223e33cce4c9833153edbb/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.ads?ref=7c339b3b5a63bac5e5223e33cce4c9833153edbb", "patch": "@@ -69,6 +69,7 @@ is\n    package BI_Ghost renames Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n    subtype Big_Integer is BI_Ghost.Big_Integer with Ghost;\n    subtype Big_Natural is BI_Ghost.Big_Natural with Ghost;\n+   subtype Big_Positive is BI_Ghost.Big_Positive with Ghost;\n    use type BI_Ghost.Big_Integer;\n \n    package Signed_Conversion is"}]}