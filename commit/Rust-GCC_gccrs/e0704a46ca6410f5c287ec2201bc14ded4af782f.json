{"sha": "e0704a46ca6410f5c287ec2201bc14ded4af782f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA3MDRhNDZjYTY0MTBmNWMyODdlYzIyMDFiYzE0ZGVkNGFmNzgyZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-05-27T21:17:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-05-27T21:17:51Z"}, "message": "cgraph.c: Include tree-gimple.h\n\n\n\t* cgraph.c: Include tree-gimple.h\n\t(cgraph_edge): Rename expr to stmt.\n\t(cgraph_create_edge): Likewise.\n\t(cgraph_clone_node): Likewise.\n\t* cgraph.h (cgraph_node): Use call_stmt instead of call_expr.\n\t* cgraphunit.c (record_call_1): Rename to ...\n\t(record_reference): ... this one; do not build edges.\n\t(cgraph_varpool_analyze_pending_decls): Call record_reference directly.\n\t(current_basic_block): Kill.\n\t(cgraph_create_edges): Rewrite to work on gimple statements nicely.\n\t(verify_cgraph_node): Likewise.\n\t* tree-inline.c (copy_body_r): Do not mess up with cgraph edges.\n\t(copy_bb): Mess up with cgraph edges here; simplify EH handling.\n\t(copy_edges_for_bb): Simplify EH handling.\n\t(expand_call_inline): Pass statement to cgraph_edge and\n\tcgraph_create_edge.\n\nFrom-SVN: r100276", "tree": {"sha": "37bf9cb1c1664316d4898541a22871ea20671627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37bf9cb1c1664316d4898541a22871ea20671627"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0704a46ca6410f5c287ec2201bc14ded4af782f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0704a46ca6410f5c287ec2201bc14ded4af782f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0704a46ca6410f5c287ec2201bc14ded4af782f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0704a46ca6410f5c287ec2201bc14ded4af782f/comments", "author": null, "committer": null, "parents": [{"sha": "0ff90076bf6704ce363af35a4491a6856a1d9e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff90076bf6704ce363af35a4491a6856a1d9e30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff90076bf6704ce363af35a4491a6856a1d9e30"}], "stats": {"total": 355, "additions": 174, "deletions": 181}, "files": [{"sha": "5f06858a85cb1ea5755b32a4676c9da359fcdcac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0704a46ca6410f5c287ec2201bc14ded4af782f", "patch": "@@ -1,3 +1,22 @@\n+2005-05-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c: Include tree-gimple.h\n+\t(cgraph_edge): Rename expr to stmt.\n+\t(cgraph_create_edge): Likewise.\n+\t(cgraph_clone_node): Likewise.\n+\t* cgraph.h (cgraph_node): Use call_stmt instead of call_expr.\n+\t* cgraphunit.c (record_call_1): Rename to ...\n+\t(record_reference): ... this one; do not build edges.\n+\t(cgraph_varpool_analyze_pending_decls): Call record_reference directly.\n+\t(current_basic_block): Kill.\n+\t(cgraph_create_edges): Rewrite to work on gimple statements nicely.\n+\t(verify_cgraph_node): Likewise.\n+\t* tree-inline.c (copy_body_r): Do not mess up with cgraph edges.\n+\t(copy_bb): Mess up with cgraph edges here; simplify EH handling.\n+\t(copy_edges_for_bb): Simplify EH handling.\n+\t(expand_call_inline): Pass statement to cgraph_edge and\n+\tcgraph_create_edge.\n+\n 2005-05-27  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* tree-inline.c (copy_body_r): Manually fold *& to deal"}, {"sha": "e1f4c661ce79b8cf2c2fe75b3e23f90578756327", "filename": "gcc/cgraph.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e0704a46ca6410f5c287ec2201bc14ded4af782f", "patch": "@@ -97,6 +97,7 @@ The varpool data structure:\n #include \"varray.h\"\n #include \"output.h\"\n #include \"intl.h\"\n+#include \"tree-gimple.h\"\n \n static void cgraph_node_remove_callers (struct cgraph_node *node);\n static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n@@ -255,9 +256,9 @@ cgraph_node_for_asm (tree asmname)\n   return NULL;\n }\n \n-/* Return callgraph edge representing CALL_EXPR.  */\n+/* Return callgraph edge representing CALL_EXPR statement.  */\n struct cgraph_edge *\n-cgraph_edge (struct cgraph_node *node, tree call_expr)\n+cgraph_edge (struct cgraph_node *node, tree call_stmt)\n {\n   struct cgraph_edge *e;\n \n@@ -267,7 +268,7 @@ cgraph_edge (struct cgraph_node *node, tree call_expr)\n      because we want to make possible having multiple cgraph nodes representing\n      different clones of the same body before the body is actually cloned.  */\n   for (e = node->callees; e; e= e->next_callee)\n-    if (e->call_expr == call_expr)\n+    if (e->call_stmt == call_stmt)\n       break;\n   return e;\n }\n@@ -276,17 +277,17 @@ cgraph_edge (struct cgraph_node *node, tree call_expr)\n \n struct cgraph_edge *\n cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    tree call_expr, gcov_type count, int nest)\n+\t\t    tree call_stmt, gcov_type count, int nest)\n {\n   struct cgraph_edge *edge = ggc_alloc (sizeof (struct cgraph_edge));\n #ifdef ENABLE_CHECKING\n   struct cgraph_edge *e;\n \n   for (e = caller->callees; e; e = e->next_callee)\n-    gcc_assert (e->call_expr != call_expr);\n+    gcc_assert (e->call_stmt != call_stmt);\n #endif\n \n-  gcc_assert (TREE_CODE (call_expr) == CALL_EXPR);\n+  gcc_assert (get_call_expr_in (call_stmt));\n \n   if (!DECL_SAVED_TREE (callee->decl))\n     edge->inline_failed = N_(\"function body not available\");\n@@ -302,7 +303,7 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n \n   edge->caller = caller;\n   edge->callee = callee;\n-  edge->call_expr = call_expr;\n+  edge->call_stmt = call_stmt;\n   edge->prev_caller = NULL;\n   edge->next_caller = callee->callers;\n   if (callee->callers)\n@@ -839,11 +840,11 @@ cgraph_function_possibly_inlined_p (tree decl)\n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   tree call_expr, int count_scale, int loop_nest)\n+\t\t   tree call_stmt, int count_scale, int loop_nest)\n {\n   struct cgraph_edge *new;\n \n-  new = cgraph_create_edge (n, e->callee, call_expr,\n+  new = cgraph_create_edge (n, e->callee, call_stmt,\n                             e->count * count_scale / REG_BR_PROB_BASE,\n \t\t            e->loop_nest + loop_nest);\n \n@@ -880,7 +881,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest)\n   n->count -= count;\n \n   for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new, e->call_expr, count_scale, loop_nest);\n+    cgraph_clone_edge (e, new, e->call_stmt, count_scale, loop_nest);\n \n   new->next_clone = n->next_clone;\n   new->prev_clone = n;"}, {"sha": "a10fcc65d3fe3ed772d733eb739542a7b661bed7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e0704a46ca6410f5c287ec2201bc14ded4af782f", "patch": "@@ -142,7 +142,7 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n   struct cgraph_edge *next_caller;\n   struct cgraph_edge *prev_callee;\n   struct cgraph_edge *next_callee;\n-  tree call_expr;\n+  tree call_stmt;\n   PTR GTY ((skip (\"\"))) aux;\n   /* When NULL, inline this call.  When non-NULL, points to the explanation\n      why function was not inlined.  */"}, {"sha": "81436aab2ff04e1099d35d9f297ee4fc83d47213", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 91, "deletions": 116, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e0704a46ca6410f5c287ec2201bc14ded4af782f", "patch": "@@ -169,15 +169,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n-static tree record_call_1 (tree *, int *, void *);\n+static tree record_reference (tree *, int *, void *);\n static void cgraph_mark_local_functions (void);\n static void cgraph_analyze_function (struct cgraph_node *node);\n-static void cgraph_create_edges (struct cgraph_node *node, tree body);\n \n-/* Records tree nodes seen in cgraph_create_edges.  Simply using\n+/* Records tree nodes seen in record_reference.  Simply using\n    walk_tree_without_duplicates doesn't guarantee each node is visited\n    once because it gets a new htab upon each recursive call from\n-   record_calls_1.  */\n+   record_reference itself.  */\n static struct pointer_set_t *visited_nodes;\n \n static FILE *cgraph_dump_file;\n@@ -265,7 +264,12 @@ cgraph_varpool_analyze_pending_decls (void)\n       cgraph_varpool_first_unanalyzed_node = cgraph_varpool_first_unanalyzed_node->next_needed;\n \n       if (DECL_INITIAL (decl))\n-\tcgraph_create_edges (NULL, DECL_INITIAL (decl));\n+\t{\n+\t  visited_nodes = pointer_set_create ();\n+          walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n+\t  pointer_set_destroy (visited_nodes);\n+\t  visited_nodes = NULL;\n+\t}\n       changed = true;\n     }\n   timevar_pop (TV_CGRAPH);\n@@ -435,9 +439,6 @@ cgraph_finalize_function (tree decl, bool nested)\n     do_warn_unused_parameter (decl);\n }\n \n-/* Used only while constructing the callgraph.  */\n-static basic_block current_basic_block;\n-\n void\n cgraph_lower_function (struct cgraph_node *node)\n {\n@@ -449,7 +450,7 @@ cgraph_lower_function (struct cgraph_node *node)\n \n /* Walk tree and record all calls.  Called via walk_tree.  */\n static tree\n-record_call_1 (tree *tp, int *walk_subtrees, void *data)\n+record_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   tree t = *tp;\n \n@@ -480,29 +481,6 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \t}\n       break;\n \n-    case CALL_EXPR:\n-      {\n-\ttree decl = get_callee_fndecl (*tp);\n-\tif (decl && TREE_CODE (decl) == FUNCTION_DECL)\n-\t  {\n-\t    cgraph_create_edge (data, cgraph_node (decl), *tp,\n-\t\t\t        current_basic_block->count,\n-\t\t\t\tcurrent_basic_block->loop_depth);\n-\n-\t    /* When we see a function call, we don't want to look at the\n-\t       function reference in the ADDR_EXPR that is hanging from\n-\t       the CALL_EXPR we're examining here, because we would\n-\t       conclude incorrectly that the function's address could be\n-\t       taken by something that is not a function call.  So only\n-\t       walk the function parameter list, skip the other subtrees.  */\n-\n-\t    walk_tree (&TREE_OPERAND (*tp, 1), record_call_1, data,\n-\t\t       visited_nodes);\n-\t    *walk_subtrees = 0;\n-\t  }\n-\tbreak;\n-      }\n-\n     default:\n       /* Save some cycles by not walking types and declaration as we\n \t won't find anything useful there anyway.  */\n@@ -525,97 +503,62 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n static void\n cgraph_create_edges (struct cgraph_node *node, tree body)\n {\n-  /* The nodes we're interested in are never shared, so walk\n-     the tree ignoring duplicates.  */\n+  basic_block bb;\n+\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (body);\n+  block_stmt_iterator bsi;\n+  tree step;\n   visited_nodes = pointer_set_create ();\n-  gcc_assert (current_basic_block == NULL);\n-  if (TREE_CODE (body) == FUNCTION_DECL)\n-    {\n-      struct function *this_cfun = DECL_STRUCT_FUNCTION (body);\n-      block_stmt_iterator bsi;\n-      tree step;\n-\n-      /* Reach the trees by walking over the CFG, and note the \n-\t enclosing basic-blocks in the call edges.  */\n-      FOR_EACH_BB_FN (current_basic_block, this_cfun)\n-        for (bsi = bsi_start (current_basic_block); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  walk_tree (bsi_stmt_ptr (bsi), record_call_1, node, visited_nodes);\n-      current_basic_block = NULL;\n-\n-      /* Walk over any private statics that may take addresses of functions.  */\n-      if (TREE_CODE (DECL_INITIAL (body)) == BLOCK)\n-\t{\n-\t  for (step = BLOCK_VARS (DECL_INITIAL (body));\n-\t       step;\n-\t       step = TREE_CHAIN (step))\n-\t    if (DECL_INITIAL (step))\n-\t      walk_tree (&DECL_INITIAL (step), record_call_1, node, visited_nodes);\n-\t}\n \n-      /* Also look here for private statics.  */\n-      if (DECL_STRUCT_FUNCTION (body))\n-\tfor (step = DECL_STRUCT_FUNCTION (body)->unexpanded_var_list;\n-\t     step;\n-\t     step = TREE_CHAIN (step))\n+  /* Reach the trees by walking over the CFG, and note the \n+     enclosing basic-blocks in the call edges.  */\n+  FOR_EACH_BB_FN (bb, this_cfun)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree stmt = bsi_stmt (bsi);\n+\ttree call = get_call_expr_in (stmt);\n+\ttree decl;\n+\n+\tif (call && (decl = get_callee_fndecl (call)))\n \t  {\n-\t    tree decl = TREE_VALUE (step);\n-\t    if (DECL_INITIAL (decl) && TREE_STATIC (decl))\n-\t      walk_tree (&DECL_INITIAL (decl), record_call_1, node, visited_nodes);\n+\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t\tbb->count,\n+\t\t\t\tbb->loop_depth);\n+\t    walk_tree (&TREE_OPERAND (call, 1),\n+\t\t       record_reference, node, visited_nodes);\n+\t    if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t      walk_tree (&TREE_OPERAND (stmt, 0),\n+\t\t\t record_reference, node, visited_nodes);\n \t  }\n+\telse \n+\t  walk_tree (bsi_stmt_ptr (bsi), record_reference, node, visited_nodes);\n+      }\n+\n+  /* Walk over any private statics that may take addresses of functions.  */\n+  if (TREE_CODE (DECL_INITIAL (body)) == BLOCK)\n+    {\n+      for (step = BLOCK_VARS (DECL_INITIAL (body));\n+\t   step;\n+\t   step = TREE_CHAIN (step))\n+\tif (DECL_INITIAL (step))\n+\t  walk_tree (&DECL_INITIAL (step), record_reference, node, visited_nodes);\n     }\n-  else\n-    walk_tree (&body, record_call_1, node, visited_nodes);\n+\n+  /* Also look here for private statics.  */\n+  if (DECL_STRUCT_FUNCTION (body))\n+    for (step = DECL_STRUCT_FUNCTION (body)->unexpanded_var_list;\n+\t step;\n+\t step = TREE_CHAIN (step))\n+      {\n+\ttree decl = TREE_VALUE (step);\n+\tif (DECL_INITIAL (decl) && TREE_STATIC (decl))\n+\t  walk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);\n+      }\n     \n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n }\n \n-static bool error_found;\n-\n-/* Callback of verify_cgraph_node.  Check that all call_exprs have\n-   cgraph nodes.  */\n-\n-static tree\n-verify_cgraph_node_1 (tree *tp, int *walk_subtrees, void *data)\n-{\n-  tree t = *tp;\n-  tree decl;\n-\n-  if (TREE_CODE (t) == CALL_EXPR && (decl = get_callee_fndecl (t)))\n-    {\n-      struct cgraph_edge *e = cgraph_edge (data, t);\n-      if (e)\n-\t{\n-\t  if (e->aux)\n-\t    {\n-\t      error (\"Shared call_expr:\");\n-\t      debug_tree (t);\n-\t      error_found = true;\n-\t    }\n-\t  if (e->callee->decl != cgraph_node (decl)->decl)\n-\t    {\n-\t      error (\"Edge points to wrong declaration:\");\n-\t      debug_tree (e->callee->decl);\n-\t      fprintf (stderr,\" Instead of:\");\n-\t      debug_tree (decl);\n-\t    }\n-\t  e->aux = (void *)1;\n-\t}\n-      else\n-\t{\n-\t  error (\"Missing callgraph edge for call expr:\");\n-\t  debug_tree (t);\n-\t  error_found = true;\n-\t}\n-    }\n-\n-  /* Save some cycles by not walking types and declaration as we\n-     won't find anything useful there anyway.  */\n-  if (IS_TYPE_OR_DECL_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  return NULL_TREE;\n-}\n \n /* Verify cgraph nodes of given cgraph node.  */\n void\n@@ -626,9 +569,9 @@ verify_cgraph_node (struct cgraph_node *node)\n   struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n   basic_block this_block;\n   block_stmt_iterator bsi;\n+  bool error_found = false;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n-  error_found = false;\n   for (e = node->callees; e; e = e->next_callee)\n     if (e->aux)\n       {\n@@ -694,7 +637,38 @@ verify_cgraph_node (struct cgraph_node *node)\n \t     enclosing basic-blocks in the call edges.  */\n \t  FOR_EACH_BB_FN (this_block, this_cfun)\n \t    for (bsi = bsi_start (this_block); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t      walk_tree (bsi_stmt_ptr (bsi), verify_cgraph_node_1, node, visited_nodes);\n+\t      {\n+\t\ttree stmt = bsi_stmt (bsi);\n+\t\ttree call = get_call_expr_in (stmt);\n+\t\ttree decl;\n+\t\tif (call && (decl = get_callee_fndecl (call)))\n+\t\t  {\n+\t\t    struct cgraph_edge *e = cgraph_edge (node, stmt);\n+\t\t    if (e)\n+\t\t      {\n+\t\t\tif (e->aux)\n+\t\t\t  {\n+\t\t\t    error (\"Shared call_stmt:\");\n+\t\t\t    debug_generic_stmt (stmt);\n+\t\t\t    error_found = true;\n+\t\t\t  }\n+\t\t\tif (e->callee->decl != cgraph_node (decl)->decl)\n+\t\t\t  {\n+\t\t\t    error (\"Edge points to wrong declaration:\");\n+\t\t\t    debug_tree (e->callee->decl);\n+\t\t\t    fprintf (stderr,\" Instead of:\");\n+\t\t\t    debug_tree (decl);\n+\t\t\t  }\n+\t\t\te->aux = (void *)1;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\terror (\"Missing callgraph edge for call stmt:\");\n+\t\t\tdebug_generic_stmt (stmt);\n+\t\t\terror_found = true;\n+\t\t      }\n+\t\t  }\n+\t      }\n \t  pointer_set_destroy (visited_nodes);\n \t  visited_nodes = NULL;\n \t}\n@@ -706,9 +680,10 @@ verify_cgraph_node (struct cgraph_node *node)\n \t{\n \t  if (!e->aux)\n \t    {\n-\t      error (\"Edge %s->%s has no corresponding call_expr\",\n+\t      error (\"Edge %s->%s has no corresponding call_stmt\",\n \t\t     cgraph_node_name (e->caller),\n \t\t     cgraph_node_name (e->callee));\n+\t      debug_generic_stmt (e->call_stmt);\n \t      error_found = true;\n \t    }\n \t  e->aux = 0;"}, {"sha": "3c6b98f66f9013e6295d58f5f25105f5b6222bff", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0704a46ca6410f5c287ec2201bc14ded4af782f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e0704a46ca6410f5c287ec2201bc14ded4af782f", "patch": "@@ -575,8 +575,6 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n      knows not to copy VAR_DECLs, etc., so this is safe.  */\n   else\n     {\n-      tree old_node = *tp;\n-\n       /* Here we handle trees that are not completely rewritten.\n \t First we detect some inlining-induced bogosities for\n \t discarding.  */\n@@ -636,41 +634,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n \tTREE_BLOCK (*tp) = id->block;\n \n-      /* We're duplicating a CALL_EXPR.  Find any corresponding\n-\t callgraph edges and update or duplicate them.  */\n-      if (TREE_CODE (*tp) == CALL_EXPR && id->node && get_callee_fndecl (*tp))\n-\t{\n-\t  if (id->saving_p)\n-\t    {\n-\t      struct cgraph_node *node;\n-              struct cgraph_edge *edge;\n-\n-\t      /* We're saving a copy of the body, so we'll update the\n-\t\t callgraph nodes in place.  Note that we avoid\n-\t\t altering the original callgraph node; we begin with\n-\t\t the first clone.  */\n-\t      for (node = id->node->next_clone;\n-\t\t   node;\n-\t\t   node = node->next_clone)\n-\t\t{\n-\t\t  edge = cgraph_edge (node, old_node);\n-\t\t  gcc_assert (edge);\n-\t\t  edge->call_expr = *tp;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-              struct cgraph_edge *edge;\n-\n-\t      /* We're cloning or inlining this body; duplicate the\n-\t\t associate callgraph nodes.  */\n-\t      edge = cgraph_edge (id->current_node, old_node);\n-\t      if (edge)\n-\t\t cgraph_clone_edge (edge, id->node, *tp,\n-\t\t\t\t    REG_BR_PROB_BASE, 1);\n-\t    }\n-\t}\n-      else if (TREE_CODE (*tp) == RESX_EXPR && id->eh_region_offset)\n+      if (TREE_CODE (*tp) == RESX_EXPR && id->eh_region_offset)\n \tTREE_OPERAND (*tp, 0) =\n \t  build_int_cst\n \t    (NULL_TREE,\n@@ -730,7 +694,43 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n          this is signalled by making stmt pointer NULL.  */\n       if (stmt)\n \t{\n+\t  tree call, decl;\n           bsi_insert_after (&copy_bsi, stmt, BSI_NEW_STMT);\n+\t  call = get_call_expr_in (stmt);\n+\t  /* We're duplicating a CALL_EXPR.  Find any corresponding\n+\t     callgraph edges and update or duplicate them.  */\n+\t  if (call && (decl = get_callee_fndecl (call)))\n+\t    {\n+\t      if (id->saving_p)\n+\t\t{\n+\t\t  struct cgraph_node *node;\n+\t\t  struct cgraph_edge *edge;\n+\n+\t\t  /* We're saving a copy of the body, so we'll update the\n+\t\t     callgraph nodes in place.  Note that we avoid\n+\t\t     altering the original callgraph node; we begin with\n+\t\t     the first clone.  */\n+\t\t  for (node = id->node->next_clone;\n+\t\t       node;\n+\t\t       node = node->next_clone)\n+\t\t    {\n+\t\t      edge = cgraph_edge (node, orig_stmt);\n+\t\t      gcc_assert (edge);\n+\t\t      edge->call_stmt = stmt;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct cgraph_edge *edge;\n+\n+\t\t  /* We're cloning or inlining this body; duplicate the\n+\t\t     associate callgraph nodes.  */\n+\t\t  edge = cgraph_edge (id->current_node, orig_stmt);\n+\t\t  if (edge)\n+\t\t    cgraph_clone_edge (edge, id->node, stmt,\n+\t\t\t\t       REG_BR_PROB_BASE, 1);\n+\t\t}\n+\t    }\n \t  /* If you think we can abort here, you are wrong.\n \t     There is no region 0 in tree land.  */\n \t  gcc_assert (lookup_stmt_eh_region_fn (id->callee_cfun, orig_stmt)\n@@ -776,24 +776,24 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n   /* Use the indices from the original blocks to create edges for the\n      new ones.  */\n   FOR_EACH_EDGE (old_edge, ei, bb->succs)\n-    {\n-      edge new;\n+    if (!(old_edge->flags & EDGE_EH))\n+      {\n+\tedge new;\n \n-      flags = old_edge->flags;\n+\tflags = old_edge->flags;\n \n-      /* Return edges do get a FALLTHRU flag when the get inlined.  */\n-      if (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n-\t  && old_edge->dest->aux != EXIT_BLOCK_PTR)\n-\tflags |= EDGE_FALLTHRU;\n-      new = make_edge (new_bb, old_edge->dest->aux, flags);\n-      new->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n-      new->probability = old_edge->probability;\n-    }\n+\t/* Return edges do get a FALLTHRU flag when the get inlined.  */\n+\tif (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n+\t    && old_edge->dest->aux != EXIT_BLOCK_PTR)\n+\t  flags |= EDGE_FALLTHRU;\n+\tnew = make_edge (new_bb, old_edge->dest->aux, flags);\n+\tnew->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n+\tnew->probability = old_edge->probability;\n+      }\n \n   if (bb->index == ENTRY_BLOCK || bb->index == EXIT_BLOCK)\n     return;\n \n-  tree_purge_dead_eh_edges (new_bb);\n   for (bsi = bsi_start (new_bb); !bsi_end_p (bsi);)\n     {\n       tree copy_stmt;\n@@ -815,9 +815,7 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n          into a COMPONENT_REF which doesn't.  If the copy\n          can throw, the original could also throw.  */\n \n-      if (TREE_CODE (copy_stmt) == RESX_EXPR\n-\t  || (tree_could_throw_p (copy_stmt)\n-\t      && lookup_stmt_eh_region (copy_stmt) > 0))\n+      if (tree_can_throw_internal (copy_stmt))\n \t{\n \t  if (!bsi_end_p (bsi))\n \t    /* Note that bb's predecessor edges aren't necessarily\n@@ -1920,7 +1918,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   if (!id->current_node->analyzed)\n     goto egress;\n \n-  cg_edge = cgraph_edge (id->current_node, t);\n+  cg_edge = cgraph_edge (id->current_node, stmt);\n \n   /* Constant propagation on argument done during previous inlining\n      may create new direct call.  Produce an edge for it.  */\n@@ -1933,7 +1931,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n          constant propagating arguments.  In all other cases we hit a bug\n          (incorrect node sharing is most common reason for missing edges.  */\n       gcc_assert (dest->needed || !flag_unit_at_a_time);\n-      cgraph_create_edge (id->node, dest, t,\n+      cgraph_create_edge (id->node, dest, stmt,\n \t\t\t  bb->count, bb->loop_depth)->inline_failed\n \t= N_(\"originally indirect function call not considered for inlining\");\n       goto egress;"}]}