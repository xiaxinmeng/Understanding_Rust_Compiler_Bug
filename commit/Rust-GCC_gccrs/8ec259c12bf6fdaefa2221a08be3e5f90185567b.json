{"sha": "8ec259c12bf6fdaefa2221a08be3e5f90185567b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVjMjU5YzEyYmY2ZmRhZWZhMjIyMWEwOGJlM2U1ZjkwMTg1NTY3Yg==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2009-06-07T11:53:21Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-06-07T11:53:21Z"}, "message": "re PR fortran/25104 ([F2003] Non-initialization expr. as case-selector)\n\n2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/25104\n        PR fortran/29962\n        * intrinsic.h (gfc_simplify_dot_product): New prototype.\n        (gfc_simplify_matmul): Likewise.\n        (gfc_simplify_transpose): Likewise.\n        * intrinsic.c (add_functions): Added new simplifier callbacks.\n        * simplify.c (init_result_expr): New.\n        (compute_dot_product): New.\n        (gfc_simplify_dot_product): New.\n        (gfc_simplify_matmul): New.\n        (gfc_simplify_transpose): New.\n        * expr.c (check_transformational): Allow transformational\n        * intrinsics\n        with simplifier in initialization expression.\n\n\n2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n\n        PR fortran/25104\n        PR fortran/29962\n        * gfortran.dg/dot_product_1.f03: New.\n        * gfortran.dg/matmul_8.f03: New.\n        * gfortran.dg/transpose_3.f03: New.\n\nFrom-SVN: r148243", "tree": {"sha": "2e75ad1b42bc85ad8644cffb94677a120f3f3547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e75ad1b42bc85ad8644cffb94677a120f3f3547"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ec259c12bf6fdaefa2221a08be3e5f90185567b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec259c12bf6fdaefa2221a08be3e5f90185567b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ec259c12bf6fdaefa2221a08be3e5f90185567b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec259c12bf6fdaefa2221a08be3e5f90185567b/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bca4e800bc5a61148a74c4656b274155275f9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bca4e800bc5a61148a74c4656b274155275f9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bca4e800bc5a61148a74c4656b274155275f9fc"}], "stats": {"total": 372, "additions": 354, "deletions": 18}, "files": [{"sha": "d101c8bed06c935b06495142e0003b437eaf413a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -1,3 +1,19 @@\n+2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/25104\n+\tPR fortran/29962\n+\t* intrinsic.h (gfc_simplify_dot_product): New prototype.\n+\t(gfc_simplify_matmul): Likewise.\n+\t(gfc_simplify_transpose): Likewise.\n+\t* intrinsic.c (add_functions): Added new simplifier callbacks.\n+\t* simplify.c (init_result_expr): New.\n+\t(compute_dot_product): New.\n+\t(gfc_simplify_dot_product): New.\n+\t(gfc_simplify_matmul): New.\n+\t(gfc_simplify_transpose): New.\n+\t* expr.c (check_transformational): Allow transformational intrinsics\n+\twith simplifier in initialization expression.\n+\n 2009-06-06  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/37203"}, {"sha": "31b0df159206cf5956471585ca3ff4f69f32ca50", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -2127,40 +2127,39 @@ check_transformational (gfc_expr *e)\n     \"selected_real_kind\", \"transfer\", \"trim\", NULL\n   };\n \n+  static const char * const trans_func_f2003[] =  {\n+    \"dot_product\", \"matmul\", \"null\", \"pack\", \"repeat\",\n+    \"reshape\", \"selected_char_kind\", \"selected_int_kind\",\n+    \"selected_real_kind\", \"transfer\", \"transpose\", \"trim\", NULL\n+  };\n+\n   int i;\n   const char *name;\n+  const char *const *functions;\n \n   if (!e->value.function.isym\n       || !e->value.function.isym->transformational)\n     return MATCH_NO;\n \n   name = e->symtree->n.sym->name;\n \n+  functions = (gfc_option.allow_std & GFC_STD_F2003) \n+\t\t? trans_func_f2003 : trans_func_f95;\n+\n   /* NULL() is dealt with below.  */\n   if (strcmp (\"null\", name) == 0)\n     return MATCH_NO;\n \n-  for (i = 0; trans_func_f95[i]; i++)\n-    if (strcmp (trans_func_f95[i], name) == 0)\n-      break;\n+  for (i = 0; functions[i]; i++)\n+    if (strcmp (functions[i], name) == 0)\n+       break;\n \n-  /* FIXME, F2003: implement translation of initialization\n-     expressions before enabling this check. For F95, error\n-     out if the transformational function is not in the list.  */\n-#if 0\n-  if (trans_func_f95[i] == NULL\n-      && gfc_notify_std (GFC_STD_F2003, \n-\t\t\t \"transformational intrinsic '%s' at %L is not permitted \"\n-\t\t\t \"in an initialization expression\", name, &e->where) == FAILURE)\n-    return MATCH_ERROR;\n-#else\n-  if (trans_func_f95[i] == NULL)\n+  if (functions[i] == NULL)\n     {\n       gfc_error(\"transformational intrinsic '%s' at %L is not permitted \"\n \t\t\"in an initialization expression\", name, &e->where);\n       return MATCH_ERROR;\n     }\n-#endif\n \n   return check_init_expr_arguments (e);\n }"}, {"sha": "6088a8d80fa30bba6f7c45688eac3b50695b394b", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -1499,7 +1499,7 @@ add_functions (void)\n   make_generic (\"dim\", GFC_ISYM_DIM, GFC_STD_F77);\n \n   add_sym_2 (\"dot_product\", GFC_ISYM_DOT_PRODUCT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr,\n-\t     GFC_STD_F95, gfc_check_dot_product, NULL, gfc_resolve_dot_product,\n+\t     GFC_STD_F95, gfc_check_dot_product, gfc_simplify_dot_product, gfc_resolve_dot_product,\n \t     va, BT_REAL, dr, REQUIRED, vb, BT_REAL, dr, REQUIRED);\n \n   make_generic (\"dot_product\", GFC_ISYM_DOT_PRODUCT, GFC_STD_F95);\n@@ -2034,7 +2034,7 @@ add_functions (void)\n   make_generic (\"malloc\", GFC_ISYM_MALLOC, GFC_STD_GNU);\n \n   add_sym_2 (\"matmul\", GFC_ISYM_MATMUL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_matmul, NULL, gfc_resolve_matmul,\n+\t     gfc_check_matmul, gfc_simplify_matmul, gfc_resolve_matmul,\n \t     ma, BT_REAL, dr, REQUIRED, mb, BT_REAL, dr, REQUIRED);\n \n   make_generic (\"matmul\", GFC_ISYM_MATMUL, GFC_STD_F95);\n@@ -2535,7 +2535,7 @@ add_functions (void)\n   make_generic (\"transfer\", GFC_ISYM_TRANSFER, GFC_STD_F95);\n \n   add_sym_1 (\"transpose\", GFC_ISYM_TRANSPOSE, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n-\t     gfc_check_transpose, NULL, gfc_resolve_transpose,\n+\t     gfc_check_transpose, gfc_simplify_transpose, gfc_resolve_transpose,\n \t     m, BT_REAL, dr, REQUIRED);\n \n   make_generic (\"transpose\", GFC_ISYM_TRANSPOSE, GFC_STD_F95);"}, {"sha": "0e6d0f9a408cbd62a2e9c0e4e73dc5ded068f7e3", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -229,6 +229,7 @@ gfc_expr *gfc_simplify_dble (gfc_expr *);\n gfc_expr *gfc_simplify_digits (gfc_expr *);\n gfc_expr *gfc_simplify_dim (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dprod (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_dot_product (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_epsilon (gfc_expr *);\n gfc_expr *gfc_simplify_erf (gfc_expr *);\n gfc_expr *gfc_simplify_erfc (gfc_expr *);\n@@ -271,6 +272,7 @@ gfc_expr *gfc_simplify_llt (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_log (gfc_expr *);\n gfc_expr *gfc_simplify_log10 (gfc_expr *);\n gfc_expr *gfc_simplify_logical (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_matmul (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_min (gfc_expr *);\n gfc_expr *gfc_simplify_minval (gfc_expr *, gfc_expr*, gfc_expr*);\n@@ -318,6 +320,7 @@ gfc_expr *gfc_simplify_tanh (gfc_expr *);\n gfc_expr *gfc_simplify_tiny (gfc_expr *);\n gfc_expr *gfc_simplify_trailz (gfc_expr *);\n gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_transpose (gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "db28d36213a3c908374b9aab30bbf67098e1d39c", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -255,6 +255,138 @@ is_constant_array_expr (gfc_expr *e)\n }\n \n \n+/* Initialize a transformational result expression with a given value.  */\n+\n+static void\n+init_result_expr (gfc_expr *e, int init, gfc_expr *array)\n+{\n+  if (e && e->expr_type == EXPR_ARRAY)\n+    {\n+      gfc_constructor *ctor = e->value.constructor;\n+      while (ctor)\n+\t{\n+\t  init_result_expr (ctor->expr, init, array);\n+\t  ctor = ctor->next;\n+\t}\n+    }\n+  else if (e && e->expr_type == EXPR_CONSTANT)\n+    {\n+      int i = gfc_validate_kind (e->ts.type, e->ts.kind, false);\n+      int length;\n+      gfc_char_t *string;\n+\n+      switch (e->ts.type)\n+\t{\n+\t  case BT_LOGICAL:\n+\t    e->value.logical = (init ? 1 : 0);\n+\t    break;\n+\n+\t  case BT_INTEGER:\n+\t    if (init == INT_MIN)\n+\t      mpz_set (e->value.integer, gfc_integer_kinds[i].min_int);\n+\t    else if (init == INT_MAX)\n+\t      mpz_set (e->value.integer, gfc_integer_kinds[i].huge);\n+\t    else\n+\t      mpz_set_si (e->value.integer, init);\n+\t    break;\n+\n+\t  case BT_REAL:\n+\t    if (init == INT_MIN)\n+\t      {\n+\t\tmpfr_set (e->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n+\t\tmpfr_neg (e->value.real, e->value.real, GFC_RND_MODE);\n+\t      }\n+\t    else if (init == INT_MAX)\n+\t      mpfr_set (e->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n+\t    else\n+\t      mpfr_set_si (e->value.real, init, GFC_RND_MODE);\n+\t    break;\n+\n+\t  case BT_COMPLEX:\n+\t    mpfr_set_si (e->value.complex.r, init, GFC_RND_MODE);\n+\t    mpfr_set_si (e->value.complex.i, 0, GFC_RND_MODE);\n+\t    break;\n+\n+\t  case BT_CHARACTER:\n+\t    if (init == INT_MIN)\n+\t      {\n+\t\tgfc_expr *len = gfc_simplify_len (array, NULL);\n+\t\tgfc_extract_int (len, &length);\n+\t\tstring = gfc_get_wide_string (length + 1);\n+\t\tgfc_wide_memset (string, 0, length);\n+\t      }\n+\t    else if (init == INT_MAX)\n+\t      {\n+\t\tgfc_expr *len = gfc_simplify_len (array, NULL);\n+\t\tgfc_extract_int (len, &length);\n+\t\tstring = gfc_get_wide_string (length + 1);\n+\t\tgfc_wide_memset (string, 255, length);\n+\t      }\n+\t    else\n+\t      {\n+\t\tlength = 0;\n+\t\tstring = gfc_get_wide_string (1);\n+\t      }\n+\n+\t    string[length] = '\\0';\n+\t    e->value.character.length = length;\n+\t    e->value.character.string = string;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable();\n+\t}\n+    }\n+  else\n+    gcc_unreachable();\n+}\n+\n+\n+/* Helper function for gfc_simplify_dot_product() and gfc_simplify_matmul.  */\n+\n+static gfc_expr *\n+compute_dot_product (gfc_constructor *ctor_a, int stride_a,\n+\t\t     gfc_constructor *ctor_b, int stride_b)\n+{\n+  gfc_expr *result;\n+  gfc_expr *a = ctor_a->expr, *b = ctor_b->expr;\n+\n+  gcc_assert (gfc_compare_types (&a->ts, &b->ts));\n+\n+  result = gfc_constant_result (a->ts.type, a->ts.kind, &a->where);\n+  init_result_expr (result, 0, NULL);\n+\n+  while (ctor_a && ctor_b)\n+    {\n+      /* Copying of expressions is required as operands are free'd\n+\t by the gfc_arith routines.  */\n+      switch (result->ts.type)\n+\t{\n+\t  case BT_LOGICAL:\n+\t    result = gfc_or (result,\n+\t\t\t     gfc_and (gfc_copy_expr (ctor_a->expr),\n+\t\t\t\t      gfc_copy_expr (ctor_b->expr)));\n+\t    break;\n+\n+\t  case BT_INTEGER:\n+\t  case BT_REAL:\n+\t  case BT_COMPLEX:\n+\t    result = gfc_add (result,\n+\t\t\t      gfc_multiply (gfc_copy_expr (ctor_a->expr),\n+\t\t\t\t\t    gfc_copy_expr (ctor_b->expr)));\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable();\n+\t}\n+\n+      ADVANCE (ctor_a, stride_a);\n+      ADVANCE (ctor_b, stride_b);\n+    }\n+\n+  return result;\n+}\n+\n /********************** Simplification functions *****************************/\n \n gfc_expr *\n@@ -1210,6 +1342,32 @@ gfc_simplify_dim (gfc_expr *x, gfc_expr *y)\n }\n \n \n+gfc_expr*\n+gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (vector_a)\n+      || !is_constant_array_expr (vector_b))\n+    return NULL;\n+\n+  gcc_assert (vector_a->rank == 1);\n+  gcc_assert (vector_b->rank == 1);\n+  gcc_assert (gfc_compare_types (&vector_a->ts, &vector_b->ts));\n+\n+  if (vector_a->value.constructor && vector_b->value.constructor)\n+    return compute_dot_product (vector_a->value.constructor, 1,\n+\t\t\t        vector_b->value.constructor, 1);\n+\n+  /* Zero sized array ...  */\n+  result = gfc_constant_result (vector_a->ts.type,\n+\t\t\t\tvector_a->ts.kind,\n+\t\t\t\t&vector_a->where);\n+  init_result_expr (result, 0, NULL);\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_dprod (gfc_expr *x, gfc_expr *y)\n {\n@@ -2856,6 +3014,84 @@ gfc_simplify_logical (gfc_expr *e, gfc_expr *k)\n }\n \n \n+gfc_expr*\n+gfc_simplify_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n+{\n+  gfc_expr *result;\n+  gfc_constructor *ma_ctor, *mb_ctor;\n+  int row, result_rows, col, result_columns, stride_a, stride_b;\n+\n+  if (!is_constant_array_expr (matrix_a)\n+      || !is_constant_array_expr (matrix_b))\n+    return NULL;\n+\n+  gcc_assert (gfc_compare_types (&matrix_a->ts, &matrix_b->ts));\n+  result = gfc_start_constructor (matrix_a->ts.type,\n+\t\t\t\t  matrix_a->ts.kind,\n+\t\t\t\t  &matrix_a->where);\n+\n+  if (matrix_a->rank == 1 && matrix_b->rank == 2)\n+    {\n+      result_rows = 1;\n+      result_columns = mpz_get_si (matrix_b->shape[0]);\n+      stride_a = 1;\n+      stride_b = mpz_get_si (matrix_b->shape[0]);\n+\n+      result->rank = 1;\n+      result->shape = gfc_get_shape (result->rank);\n+      mpz_init_set_si (result->shape[0], result_columns);\n+    }\n+  else if (matrix_a->rank == 2 && matrix_b->rank == 1)\n+    {\n+      result_rows = mpz_get_si (matrix_b->shape[0]);\n+      result_columns = 1;\n+      stride_a = mpz_get_si (matrix_a->shape[0]);\n+      stride_b = 1;\n+\n+      result->rank = 1;\n+      result->shape = gfc_get_shape (result->rank);\n+      mpz_init_set_si (result->shape[0], result_rows);\n+    }\n+  else if (matrix_a->rank == 2 && matrix_b->rank == 2)\n+    {\n+      result_rows = mpz_get_si (matrix_a->shape[0]);\n+      result_columns = mpz_get_si (matrix_b->shape[1]);\n+      stride_a = mpz_get_si (matrix_a->shape[1]);\n+      stride_b = mpz_get_si (matrix_b->shape[0]);\n+\n+      result->rank = 2;\n+      result->shape = gfc_get_shape (result->rank);\n+      mpz_init_set_si (result->shape[0], result_rows);\n+      mpz_init_set_si (result->shape[1], result_columns);\n+    }\n+  else\n+    gcc_unreachable();\n+\n+  ma_ctor = matrix_a->value.constructor;\n+  mb_ctor = matrix_b->value.constructor;\n+\n+  for (col = 0; col < result_columns; ++col)\n+    {\n+      ma_ctor = matrix_a->value.constructor;\n+\n+      for (row = 0; row < result_rows; ++row)\n+\t{\n+\t  gfc_expr *e;\n+\t  e = compute_dot_product (ma_ctor, stride_a,\n+\t\t\t\t   mb_ctor, 1);\n+\n+\t  gfc_append_constructor (result, e);\n+\n+\t  ADVANCE (ma_ctor, 1);\n+\t}\n+\n+      ADVANCE (mb_ctor, stride_b);\n+    }\n+\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n {\n@@ -4760,6 +4996,47 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n }\n \n \n+gfc_expr *\n+gfc_simplify_transpose (gfc_expr *matrix)\n+{\n+  int i, matrix_rows;\n+  gfc_expr *result;\n+  gfc_constructor *matrix_ctor;\n+\n+  if (!is_constant_array_expr (matrix))\n+    return NULL;\n+\n+  gcc_assert (matrix->rank == 2);\n+\n+  result = gfc_start_constructor (matrix->ts.type, matrix->ts.kind, &matrix->where);\n+  result->rank = 2;\n+  result->shape = gfc_get_shape (result->rank);\n+  mpz_set (result->shape[0], matrix->shape[1]);\n+  mpz_set (result->shape[1], matrix->shape[0]);\n+\n+  if (matrix->ts.type == BT_CHARACTER)\n+    result->ts.cl = matrix->ts.cl;\n+\n+  matrix_rows = mpz_get_si (matrix->shape[0]);\n+  matrix_ctor = matrix->value.constructor;\n+  for (i = 0; i < matrix_rows; ++i)\n+    {\n+      gfc_constructor *column_ctor = matrix_ctor;\n+      while (column_ctor)\n+\t{\n+\t  gfc_append_constructor (result, \n+\t\t\t\t  gfc_copy_expr (column_ctor->expr));\n+\n+\t  ADVANCE (column_ctor, matrix_rows);\n+\t}\n+\n+      ADVANCE (matrix_ctor, 1);\n+    }\n+\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_trim (gfc_expr *e)\n {"}, {"sha": "91162e2f11b9c0ff74eddfb797ebf42fa4b497a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -1,3 +1,11 @@\n+2009-06-07  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR fortran/25104\n+\tPR fortran/29962\n+\t* gfortran.dg/dot_product_1.f03: New.\n+\t* gfortran.dg/matmul_8.f03: New.\n+\t* gfortran.dg/transpose_3.f03: New.\n+\n 2009-06-06  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/Wunused-label-1.c: New test case."}, {"sha": "5ba663348b1bd59fa6d4d400c69ab5df9acf23a8", "filename": "gcc/testsuite/gfortran.dg/dot_product_1.f03", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_1.f03?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do \"run\" }\n+! Transformational intrinsic DOT_PRODUCT as initialization expression.\n+\n+  INTEGER, PARAMETER :: n = 10\n+  INTEGER, PARAMETER :: a(n) = 1\n+  INTEGER, PARAMETER :: p = DOT_PRODUCT(a, a)\n+  INTEGER, PARAMETER :: e = DOT_PRODUCT(SHAPE(1), SHAPE(1))\n+\n+  IF (p /= n) CALL abort()\n+  IF (e /= 0) CALL abort()\n+END"}, {"sha": "d73fdcd07bd6b6e026ddb0e1b8323fcc7a90f4ac", "filename": "gcc/testsuite/gfortran.dg/matmul_8.f03", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_8.f03?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do \"run\" }\n+! Transformational intrinsic MATMUL as initialization expression.\n+\n+  REAL, PARAMETER :: PI = 3.141592654, theta = PI/6.0\n+\n+  REAL, PARAMETER :: unity(2,2) = RESHAPE([1.0, 0.0, 0.0, 1.0], [2, 2])\n+  REAL, PARAMETER :: m1(2,2)    = RESHAPE([COS(theta), SIN(theta), -SIN(theta), COS(theta)], [2, 2])\n+  REAL, PARAMETER :: m2(2,2)    = RESHAPE([COS(theta), -SIN(theta), SIN(theta), COS(theta)], [2, 2])\n+  REAL, PARAMETER :: m(2,2)     = MATMUL(m1, m2)\n+\n+  IF (ANY(ABS(m - unity) > EPSILON(0.0))) CALL abort()\n+END"}, {"sha": "b24516604c97451dad5f5b5aba16a4a59e6346e2", "filename": "gcc/testsuite/gfortran.dg/transpose_3.f03", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ec259c12bf6fdaefa2221a08be3e5f90185567b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_3.f03?ref=8ec259c12bf6fdaefa2221a08be3e5f90185567b", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do \"run\" }\n+! Transformational intrinsic TRANSPOSE as initialization expression.\n+\n+  INTEGER, PARAMETER :: n = 10\n+  INTEGER, PARAMETER :: a(n,1) = RESHAPE([ (i, i = 1, n) ], [n, 1])\n+  INTEGER, PARAMETER :: b(1,n) = TRANSPOSE(a)\n+  INTEGER, PARAMETER :: c(n,1) = TRANSPOSE(b)\n+\n+  IF (ANY(c /= a)) CALL abort()\n+END"}]}