{"sha": "3bd86940c428de9dde53e41265fb1435ed236f5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkODY5NDBjNDI4ZGU5ZGRlNTNlNDEyNjVmYjE0MzVlZDIzNmY1ZQ==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-01-26T08:29:32Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-06-24T04:49:06Z"}, "message": "i386: Add vashlm3/vashrm3/vlshrm3 to enable vectorization of vector shift vector. [PR98434]\n\nAdd expanders for vashl<VI12_AVX512BW>, vlshr<VI12_AVX512BW>,\nvashr<VI1_AVX512BW> and vashr<v32hi,v16hi,v4di,v8di>.\n\nBesides there's some assumption in expand_mult_const that mul and\nadd must be available at the same time, but for i386, addv8qi is\nrestricted under TARGET_64BIT, but mulv8qi not, that could cause ICE.\nSo restrict mulv8qi and shiftv8qi under TARGET_64BIT.\n\ngcc/ChangeLog:\n\n\tPR target/98434\n\t* config/i386/i386-expand.c (ix86_expand_vec_interleave):\n\tAdjust comments for ix86_expand_vecop_qihi2.\n\t(ix86_expand_vecmul_qihi): Renamed to ..\n\t(ix86_expand_vecop_qihi2): Adjust function prototype to\n\tsupport shift operation, add static to definition.\n\t(ix86_expand_vec_shift_qihi_constant): Add static to definition.\n\t(ix86_expand_vecop_qihi): Call ix86_expand_vecop_qihi2 and\n\tix86_expand_vec_shift_qihi_constant.\n\t* config/i386/i386-protos.h (ix86_expand_vecmul_qihi): Deleted.\n\t(ix86_expand_vec_shift_qihi_constant): Deleted.\n\t* config/i386/sse.md (VI12_256_512_AVX512VL): New mode\n\titerator.\n\t(mulv8qi3): Call ix86_expand_vecop_qihi directly, add\n\tcondition TARGET_64BIT.\n\t(mul<mode>3): Ditto.\n\t(<insn><mode>3): Ditto.\n\t(vlshr<mode>3): Extend to support avx512 vlshr.\n\t(v<insn><mode>3): New expander for\n\tvashr/vlshr/vashl.\n\t(v<insn>v8qi3): Ditto.\n\t(vashrv8hi3<mask_name>): Renamed to ..\n\t(vashr<mode>3): And extend to support V16QImode for avx512.\n\t(vashrv16qi3): Deleted.\n\t(vashrv2di3<mask_name>): Extend expander to support avx512\n\tinstruction.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/98434\n\t* gcc.target/i386/pr98434-1.c: New test.\n\t* gcc.target/i386/pr98434-2.c: New test.\n\t* gcc.target/i386/avx512vl-pr95488-1.c: Adjust testcase.", "tree": {"sha": "8f55dced6666470699916e2f031970759bd045a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f55dced6666470699916e2f031970759bd045a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd86940c428de9dde53e41265fb1435ed236f5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd86940c428de9dde53e41265fb1435ed236f5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd86940c428de9dde53e41265fb1435ed236f5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd86940c428de9dde53e41265fb1435ed236f5e/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcf617f0d2a5a1b624718e07d7b219cb0234436f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf617f0d2a5a1b624718e07d7b219cb0234436f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf617f0d2a5a1b624718e07d7b219cb0234436f"}], "stats": {"total": 386, "additions": 329, "deletions": 57}, "files": [{"sha": "2cb939e51c328bee69e5b8c3e33747d2dad72701", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=3bd86940c428de9dde53e41265fb1435ed236f5e", "patch": "@@ -20705,8 +20705,9 @@ ix86_expand_vec_interleave (rtx targ, rtx op0, rtx op1, bool high_p)\n   gcc_assert (ok);\n }\n \n-/* Optimize vector MUL generation for V8QI, V16QI and V32QI\n-   under TARGET_AVX512BW. i.e. for v16qi a * b, it has\n+/* This function is similar as ix86_expand_vecop_qihi,\n+   but optimized under AVX512BW by using vpmovwb.\n+   For example, optimize vector MUL generation like\n \n    vpmovzxbw ymm2, xmm0\n    vpmovzxbw ymm3, xmm1\n@@ -20716,13 +20717,14 @@ ix86_expand_vec_interleave (rtx targ, rtx op0, rtx op1, bool high_p)\n    it would take less instructions than ix86_expand_vecop_qihi.\n    Return true if success.  */\n \n-bool\n-ix86_expand_vecmul_qihi (rtx dest, rtx op1, rtx op2)\n+static bool\n+ix86_expand_vecop_qihi2 (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n {\n   machine_mode himode, qimode = GET_MODE (dest);\n   rtx hop1, hop2, hdest;\n   rtx (*gen_extend)(rtx, rtx);\n   rtx (*gen_truncate)(rtx, rtx);\n+  bool uns_p = (code == ASHIFTRT) ? false : true;\n \n   /* There's no V64HImode multiplication instruction.  */\n   if (qimode == E_V64QImode)\n@@ -20743,17 +20745,17 @@ ix86_expand_vecmul_qihi (rtx dest, rtx op1, rtx op2)\n     {\n     case E_V8QImode:\n       himode = V8HImode;\n-      gen_extend = gen_zero_extendv8qiv8hi2;\n+      gen_extend = uns_p ? gen_zero_extendv8qiv8hi2 : gen_extendv8qiv8hi2;\n       gen_truncate = gen_truncv8hiv8qi2;\n       break;\n     case E_V16QImode:\n       himode = V16HImode;\n-      gen_extend = gen_zero_extendv16qiv16hi2;\n+      gen_extend = uns_p ? gen_zero_extendv16qiv16hi2 : gen_extendv16qiv16hi2;\n       gen_truncate = gen_truncv16hiv16qi2;\n       break;\n     case E_V32QImode:\n       himode = V32HImode;\n-      gen_extend = gen_zero_extendv32qiv32hi2;\n+      gen_extend = uns_p ? gen_zero_extendv32qiv32hi2 : gen_extendv32qiv32hi2;\n       gen_truncate = gen_truncv32hiv32qi2;\n       break;\n     default:\n@@ -20765,16 +20767,17 @@ ix86_expand_vecmul_qihi (rtx dest, rtx op1, rtx op2)\n   hdest = gen_reg_rtx (himode);\n   emit_insn (gen_extend (hop1, op1));\n   emit_insn (gen_extend (hop2, op2));\n-  emit_insn (gen_rtx_SET (hdest, simplify_gen_binary (MULT, himode,\n+  emit_insn (gen_rtx_SET (hdest, simplify_gen_binary (code, himode,\n \t\t\t\t\t\t      hop1, hop2)));\n   emit_insn (gen_truncate (dest, hdest));\n   return true;\n }\n \n /* Expand a vector operation shift by constant for a V*QImode in terms of the\n    same operation on V*HImode. Return true if success. */\n-bool\n-ix86_expand_vec_shift_qihi_constant (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n+static bool\n+ix86_expand_vec_shift_qihi_constant (enum rtx_code code,\n+\t\t\t\t     rtx dest, rtx op1, rtx op2)\n {\n   machine_mode qimode, himode;\n   HOST_WIDE_INT and_constant, xor_constant;\n@@ -20886,6 +20889,16 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n   bool uns_p = false;\n   int i;\n \n+  if (CONST_INT_P (op2)\n+      && (code == ASHIFT || code == LSHIFTRT || code == ASHIFTRT)\n+      && ix86_expand_vec_shift_qihi_constant (code, dest, op1, op2))\n+    return;\n+\n+  if (TARGET_AVX512BW\n+      && VECTOR_MODE_P (GET_MODE (op2))\n+      && ix86_expand_vecop_qihi2 (code, dest, op1, op2))\n+    return;\n+\n   switch (qimode)\n     {\n     case E_V16QImode:\n@@ -20907,7 +20920,6 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n       gcc_unreachable ();\n     }\n \n-  op2_l = op2_h = op2;\n   switch (code)\n     {\n     case MULT:\n@@ -20936,17 +20948,46 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n       op1_h = gen_reg_rtx (himode);\n       ix86_expand_sse_unpack (op1_l, op1, uns_p, false);\n       ix86_expand_sse_unpack (op1_h, op1, uns_p, true);\n+      /* vashr/vlshr/vashl  */\n+      if (GET_MODE_CLASS (GET_MODE (op2)) == MODE_VECTOR_INT)\n+\t{\n+\t  rtx tmp = force_reg (qimode, op2);\n+\t  op2_l = gen_reg_rtx (himode);\n+\t  op2_h = gen_reg_rtx (himode);\n+\t  ix86_expand_sse_unpack (op2_l, tmp, uns_p, false);\n+\t  ix86_expand_sse_unpack (op2_h, tmp, uns_p, true);\n+\t}\n+      else\n+\top2_l = op2_h = op2;\n+\n       full_interleave = true;\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  /* Perform the operation.  */\n-  res_l = expand_simple_binop (himode, code, op1_l, op2_l, NULL_RTX,\n-\t\t\t       1, OPTAB_DIRECT);\n-  res_h = expand_simple_binop (himode, code, op1_h, op2_h, NULL_RTX,\n-\t\t\t       1, OPTAB_DIRECT);\n+  /* Perform vashr/vlshr/vashl.  */\n+  if (code != MULT\n+      && GET_MODE_CLASS (GET_MODE (op2)) == MODE_VECTOR_INT)\n+    {\n+      res_l = gen_reg_rtx (himode);\n+      res_h = gen_reg_rtx (himode);\n+      emit_insn (gen_rtx_SET (res_l,\n+\t\t\t      simplify_gen_binary (code, himode,\n+\t\t\t\t\t\t   op1_l, op2_l)));\n+      emit_insn (gen_rtx_SET (res_h,\n+\t\t\t      simplify_gen_binary (code, himode,\n+\t\t\t\t\t\t   op1_h, op2_h)));\n+    }\n+  /* Performance mult/ashr/lshr/ashl.  */\n+  else\n+    {\n+      res_l = expand_simple_binop (himode, code, op1_l, op2_l, NULL_RTX,\n+\t\t\t\t   1, OPTAB_DIRECT);\n+      res_h = expand_simple_binop (himode, code, op1_h, op2_h, NULL_RTX,\n+\t\t\t\t   1, OPTAB_DIRECT);\n+    }\n+\n   gcc_assert (res_l && res_h);\n \n   /* Merge the data back into the right place.  */"}, {"sha": "65fc307dc7b972050206ba9df96d5a1adee5560e", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3bd86940c428de9dde53e41265fb1435ed236f5e", "patch": "@@ -208,10 +208,7 @@ extern void ix86_expand_round (rtx, rtx);\n extern void ix86_expand_rounddf_32 (rtx, rtx);\n extern void ix86_expand_round_sse4 (rtx, rtx);\n \n-extern bool ix86_expand_vecmul_qihi (rtx, rtx, rtx);\n extern void ix86_expand_vecop_qihi (enum rtx_code, rtx, rtx, rtx);\n-extern bool ix86_expand_vec_shift_qihi_constant (enum rtx_code, rtx, rtx, rtx);\n-\n extern rtx ix86_split_stack_guard (void);\n \n extern void ix86_move_vector_high_sse_to_mmx (rtx);"}, {"sha": "5bd65dd931217d27fbb0ee881c4f6e9e1f0bfa91", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 76, "deletions": 35, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3bd86940c428de9dde53e41265fb1435ed236f5e", "patch": "@@ -397,6 +397,10 @@\n (define_mode_iterator VI1_AVX512F\n   [(V64QI \"TARGET_AVX512F\") (V32QI \"TARGET_AVX\") V16QI])\n \n+(define_mode_iterator VI12_256_512_AVX512VL\n+  [V64QI (V32QI \"TARGET_AVX512VL\")\n+   V32HI (V16HI \"TARGET_AVX512VL\")])\n+\n (define_mode_iterator VI2_AVX2\n   [(V32HI \"TARGET_AVX512BW\") (V16HI \"TARGET_AVX2\") V8HI])\n \n@@ -11780,9 +11784,9 @@\n   [(set (match_operand:V8QI 0 \"register_operand\")\n \t(mult:V8QI (match_operand:V8QI 1 \"register_operand\")\n \t\t   (match_operand:V8QI 2 \"register_operand\")))]\n-  \"TARGET_AVX512VL && TARGET_AVX512BW\"\n+  \"TARGET_AVX512VL && TARGET_AVX512BW && TARGET_64BIT\"\n {\n-  gcc_assert (ix86_expand_vecmul_qihi (operands[0], operands[1], operands[2]));\n+  ix86_expand_vecop_qihi (MULT, operands[0], operands[1], operands[2]);\n   DONE;\n })\n \n@@ -11792,8 +11796,6 @@\n \t\t       (match_operand:VI1_AVX512 2 \"register_operand\")))]\n   \"TARGET_SSE2\"\n {\n-  if (ix86_expand_vecmul_qihi (operands[0], operands[1], operands[2]))\n-    DONE;\n   ix86_expand_vecop_qihi (MULT, operands[0], operands[1], operands[2]);\n   DONE;\n })\n@@ -20239,12 +20241,20 @@\n \t(lshiftrt:VI12_128\n \t  (match_operand:VI12_128 1 \"register_operand\")\n \t  (match_operand:VI12_128 2 \"nonimmediate_operand\")))]\n-  \"TARGET_XOP\"\n+  \"TARGET_XOP || (TARGET_AVX512BW && TARGET_AVX512VL)\"\n {\n-  rtx neg = gen_reg_rtx (<MODE>mode);\n-  emit_insn (gen_neg<mode>2 (neg, operands[2]));\n-  emit_insn (gen_xop_shl<mode>3 (operands[0], operands[1], neg));\n-  DONE;\n+  if (TARGET_XOP)\n+    {\n+      rtx neg = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+      emit_insn (gen_xop_shl<mode>3 (operands[0], operands[1], neg));\n+      DONE;\n+    }\n+    else if (<MODE>mode == V16QImode)\n+    {\n+      ix86_expand_vecop_qihi (LSHIFTRT, operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n })\n \n (define_expand \"vlshr<mode>3\"\n@@ -20263,6 +20273,31 @@\n     }\n })\n \n+(define_expand \"v<insn><mode>3\"\n+  [(set (match_operand:VI12_256_512_AVX512VL 0 \"register_operand\")\n+\t(any_shift:VI12_256_512_AVX512VL\n+\t  (match_operand:VI12_256_512_AVX512VL 1 \"register_operand\")\n+\t  (match_operand:VI12_256_512_AVX512VL 2 \"nonimmediate_operand\")))]\n+  \"TARGET_AVX512BW\"\n+{\n+  if (<MODE>mode == V32QImode || <MODE>mode == V64QImode)\n+    {\n+      ix86_expand_vecop_qihi (<CODE>, operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"v<insn>v8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\")\n+\t(any_shift:V8QI\n+\t  (match_operand:V8QI 1 \"register_operand\")\n+\t  (match_operand:V8QI 2 \"nonimmediate_operand\")))]\n+  \"TARGET_AVX512BW && TARGET_AVX512VL && TARGET_64BIT\"\n+{\n+  ix86_expand_vecop_qihi (<CODE>, operands[0], operands[1], operands[2]);\n+  DONE;\n+})\n+\n (define_expand \"vlshr<mode>3\"\n   [(set (match_operand:VI48_512 0 \"register_operand\")\n \t(lshiftrt:VI48_512\n@@ -20277,33 +20312,32 @@\n \t  (match_operand:VI48_256 2 \"nonimmediate_operand\")))]\n   \"TARGET_AVX2\")\n \n-(define_expand \"vashrv8hi3<mask_name>\"\n-  [(set (match_operand:V8HI 0 \"register_operand\")\n-\t(ashiftrt:V8HI\n-\t  (match_operand:V8HI 1 \"register_operand\")\n-\t  (match_operand:V8HI 2 \"nonimmediate_operand\")))]\n+(define_expand \"vashr<mode>3\"\n+  [(set (match_operand:VI8_256_512 0 \"register_operand\")\n+\t(ashiftrt:VI8_256_512\n+\t  (match_operand:VI8_256_512 1 \"register_operand\")\n+\t  (match_operand:VI8_256_512 2 \"nonimmediate_operand\")))]\n+  \"TARGET_AVX512F\")\n+\n+(define_expand \"vashr<mode>3\"\n+  [(set (match_operand:VI12_128 0 \"register_operand\")\n+\t(ashiftrt:VI12_128\n+\t  (match_operand:VI12_128 1 \"register_operand\")\n+\t  (match_operand:VI12_128 2 \"nonimmediate_operand\")))]\n   \"TARGET_XOP || (TARGET_AVX512BW && TARGET_AVX512VL)\"\n {\n   if (TARGET_XOP)\n     {\n-      rtx neg = gen_reg_rtx (V8HImode);\n-      emit_insn (gen_negv8hi2 (neg, operands[2]));\n-      emit_insn (gen_xop_shav8hi3 (operands[0], operands[1], neg));\n+      rtx neg = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+      emit_insn (gen_xop_sha<mode>3 (operands[0], operands[1], neg));\n+      DONE;\n+    }\n+  else if(<MODE>mode == V16QImode)\n+    {\n+      ix86_expand_vecop_qihi (ASHIFTRT, operands[0],operands[1], operands[2]);\n       DONE;\n     }\n-})\n-\n-(define_expand \"vashrv16qi3\"\n-  [(set (match_operand:V16QI 0 \"register_operand\")\n-\t(ashiftrt:V16QI\n-\t  (match_operand:V16QI 1 \"register_operand\")\n-\t  (match_operand:V16QI 2 \"nonimmediate_operand\")))]\n-  \"TARGET_XOP\"\n-{\n-   rtx neg = gen_reg_rtx (V16QImode);\n-   emit_insn (gen_negv16qi2 (neg, operands[2]));\n-   emit_insn (gen_xop_shav16qi3 (operands[0], operands[1], neg));\n-   DONE;\n })\n \n (define_expand \"vashrv2di3<mask_name>\"\n@@ -20354,10 +20388,18 @@\n \t(ashift:VI12_128\n \t  (match_operand:VI12_128 1 \"register_operand\")\n \t  (match_operand:VI12_128 2 \"nonimmediate_operand\")))]\n-  \"TARGET_XOP\"\n+  \"TARGET_XOP || (TARGET_AVX512BW && TARGET_AVX512VL)\"\n {\n-  emit_insn (gen_xop_sha<mode>3 (operands[0], operands[1], operands[2]));\n-  DONE;\n+  if (TARGET_XOP)\n+  {\n+    emit_insn (gen_xop_sha<mode>3 (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n+  else if (<MODE>mode == V16QImode)\n+  {\n+    ix86_expand_vecop_qihi (ASHIFT, operands[0], operands[1], operands[2]);\n+    DONE;\n+  }\n })\n \n (define_expand \"vashl<mode>3\"\n@@ -20461,8 +20503,7 @@\n       gen = (<CODE> == LSHIFTRT ? gen_xop_shlv16qi3 : gen_xop_shav16qi3);\n       emit_insn (gen (operands[0], operands[1], tmp));\n     }\n-  else if (!ix86_expand_vec_shift_qihi_constant (<CODE>, operands[0],\n-\t\t\t\t\t\toperands[1], operands[2]))\n+  else\n     ix86_expand_vecop_qihi (<CODE>, operands[0], operands[1], operands[2]);\n   DONE;\n })"}, {"sha": "dc684a167c8ebebe399aebf5ef9885d7fcd571f0", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-pr95488-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr95488-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr95488-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-pr95488-1.c?ref=3bd86940c428de9dde53e41265fb1435ed236f5e", "patch": "@@ -1,10 +1,10 @@\n /* PR target/pr95488  */\n /* { dg-do compile } */\n /* { dg-options \"-O2 -mavx512bw -mavx512vl\" }  */\n-/* { dg-final { scan-assembler-times \"vpmovzxbw\" 8 } } */\n+/* { dg-final { scan-assembler-times \"vpmovzxbw\" 8 { target { ! ia32 } } } } */\n /* { dg-final { scan-assembler-times \"vpmullw\\[^\\n\\]*ymm\" 2 } } */\n-/* { dg-final { scan-assembler-times \"vpmullw\\[^\\n\\]*xmm\" 2 } } */\n-/* { dg-final { scan-assembler-times \"vpmovwb\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vpmullw\\[^\\n\\]*xmm\" 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"vpmovwb\" 4 { target { ! ia32 } } } } */\n \n typedef char v16qi __attribute__ ((vector_size (16)));\n typedef char v8qi __attribute__ ((vector_size (8)));"}, {"sha": "773d3b8ad60db0448d851e4af928b939c95f8f43", "filename": "gcc/testsuite/gcc.target/i386/pr98434-1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98434-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98434-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98434-1.c?ref=3bd86940c428de9dde53e41265fb1435ed236f5e", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512bw -mavx512vl -O2 -mprefer-vector-width=512\" } */\n+/* { dg-final { scan-assembler-times {vpsravw[\\t ]*%xmm} 2 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times {vpsrlvw[\\t ]*%ymm} 2 } } */\n+/* { dg-final { scan-assembler-times {vpsllvw[\\t ]*%zmm} 2 } } */\n+/* { dg-final { scan-assembler-times {vpsllvq[\\t ]*%xmm} 1 } } */\n+/* { dg-final { scan-assembler-times {vpsravq[\\t ]*%ymm} 1 } } */\n+/* { dg-final { scan-assembler-times {vpsrlvq[\\t ]*%zmm} 1 } } */\n+\n+int n;\n+\n+typedef char v8qi __attribute__((vector_size (8)));\n+typedef char v16qi __attribute__((vector_size (16)));\n+typedef char v32qi __attribute__((vector_size (32)));\n+typedef short v8hi __attribute__((vector_size (16)));\n+typedef short v16hi __attribute__((vector_size (32)));\n+typedef short v32hi __attribute__((vector_size (64)));\n+typedef long long v2di __attribute__((vector_size (16)));\n+typedef long long v4di __attribute__((vector_size (32)));\n+typedef long long v8di __attribute__((vector_size (64)));\n+typedef unsigned char v8uqi __attribute__((vector_size (8)));\n+typedef unsigned char v16uqi __attribute__((vector_size (16)));\n+typedef unsigned char v32uqi __attribute__((vector_size (32)));\n+typedef unsigned short v8uhi __attribute__((vector_size (16)));\n+typedef unsigned short v16uhi __attribute__((vector_size (32)));\n+typedef unsigned short v32uhi __attribute__((vector_size (64)));\n+typedef unsigned long long v2udi __attribute__((vector_size (16)));\n+typedef unsigned long long v4udi __attribute__((vector_size (32)));\n+typedef unsigned long long v8udi __attribute__((vector_size (64)));\n+\n+#define FOO(TYPE, OP, NAME)\t\t\\\n+  __attribute__((noipa)) TYPE\t\t\\\n+  foo_##TYPE##_##NAME (TYPE a, TYPE b)\t\\\n+  {\t\t\t\t\t\\\n+    return a OP b;\t\t\t\\\n+  }\t\t\t\t\t\\\n+\n+FOO (v8qi, <<, vashl);\n+FOO (v8qi, >>, vashr);\n+FOO (v8uqi, >>, vlshr);\n+FOO (v16qi, <<, vashl);\n+FOO (v16qi, >>, vashr);\n+FOO (v16uqi, >>, vlshr);\n+FOO (v32qi, <<, vashl);\n+FOO (v32qi, >>, vashr);\n+FOO (v32uqi, >>, vlshr);\n+FOO (v8hi, <<, vashl);\n+FOO (v8hi, >>, vashr);\n+FOO (v8uhi, >>, vlshr);\n+FOO (v16hi, <<, vashl);\n+FOO (v16hi, >>, vashr);\n+FOO (v16uhi, >>, vlshr);\n+FOO (v32hi, <<, vashl);\n+FOO (v32hi, >>, vashr);\n+FOO (v32uhi, >>, vlshr);\n+FOO (v2di, <<, vashl);\n+FOO (v2di, >>, vashr);\n+FOO (v2udi, >>, vlshr);\n+FOO (v4di, <<, vashl);\n+FOO (v4di, >>, vashr);\n+FOO (v4udi, >>, vlshr);\n+FOO (v8di, <<, vashl);\n+FOO (v8di, >>, vashr);\n+FOO (v8udi, >>, vlshr);"}, {"sha": "4878e70bce44536f0a1b28fdb1cb178653b76240", "filename": "gcc/testsuite/gcc.target/i386/pr98434-2.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98434-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd86940c428de9dde53e41265fb1435ed236f5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98434-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr98434-2.c?ref=3bd86940c428de9dde53e41265fb1435ed236f5e", "patch": "@@ -0,0 +1,129 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mprefer-vector-width=512 -mavx512vl -mavx512bw\" } */\n+/* { dg-require-effective-target avx512bw } */\n+/* { dg-require-effective-target avx512vl } */\n+\n+#include \"pr98434-1.c\"\n+void test (void);\n+#define DO_TEST test\n+#define AVX512VL\n+#define AVX512BW\n+#include \"avx512-check.h\"\n+\n+\n+typedef char int8;\n+typedef unsigned char uint8;\n+typedef short int16;\n+typedef unsigned short uint16;\n+typedef long long int64;\n+typedef unsigned long long uint64;\n+\n+#define F_EMULATE(TYPE, SIZE, OP, NAME)\t\t\\\n+  __attribute__((noipa, optimize(\"-fno-tree-vectorize\"))) void\t\\\n+  emulate_##SIZE##_##TYPE##_##NAME (TYPE *a,\t\\\n+\t\t\t\t    TYPE *b,\t\\\n+\t\t\t\t    TYPE *c)\t\\\n+  {\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\\\n+    for (i = 0; i < SIZE; i++)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta[i] = b[i] OP c[i];\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+F_EMULATE (int8,  8, <<, vashl);\n+F_EMULATE (int8,  8,  >>, vashr);\n+F_EMULATE (uint8,  8, >>, vlshr);\n+F_EMULATE (int8,  16, <<, vashl);\n+F_EMULATE (int8,  16, >>, vashr);\n+F_EMULATE (uint8,  16, >>, vlshr);\n+F_EMULATE (int8,  32, <<, vashl);\n+F_EMULATE (int8,  32, >>, vashr);\n+F_EMULATE (uint8,  32, >>, vlshr);\n+F_EMULATE (int16,  8, <<, vashl);\n+F_EMULATE (int16,  8, >>, vashr);\n+F_EMULATE (uint16, 8, >>, vlshr);\n+F_EMULATE (int16,  16, <<, vashl);\n+F_EMULATE (int16,  16, >>, vashr);\n+F_EMULATE (uint16, 16, >>, vlshr);\n+F_EMULATE (int16,  32, <<, vashl);\n+F_EMULATE (int16,  32, >>, vashr);\n+F_EMULATE (uint16, 32, >>, vlshr);\n+F_EMULATE (int64,  2, <<, vashl);\n+F_EMULATE (int64,  2, >>, vashr);\n+F_EMULATE (uint64,  2, >>, vlshr);\n+F_EMULATE (int64,  4, <<, vashl);\n+F_EMULATE (int64,  4, >>, vashr);\n+F_EMULATE (uint64,  4, >>, vlshr);\n+F_EMULATE (int64,  8, <<, vashl);\n+F_EMULATE (int64,  8, >>, vashr);\n+F_EMULATE (uint64,  8, >>, vlshr);\n+\n+#define VSHIFT(VTYPE, NAME, src1, src2)\t\\\n+  foo_##VTYPE##_##NAME (src1, src2)\n+\n+#define EMULATE(SIZE, TYPE, NAME, dst, src1, src2)\t\\\n+  emulate_##SIZE##_##TYPE##_##NAME (dst, src1, src2)\n+\n+#define F_TEST_SHIFT(VTYPE, VTYPEU, TYPE, TYPEU, SIZE)    \\\n+  __attribute__((noipa, optimize(\"-fno-tree-vectorize\"))) void \\\n+  test_##VTYPE ()\\\n+  {\\\n+    TYPE src1[SIZE], src2[SIZE], ref[SIZE];\t\t\\\n+    TYPEU usrc1[SIZE], usrc2[SIZE], uref[SIZE];\t\t\t\\\n+    VTYPE dst;\t     \\\n+    VTYPEU udst;     \\\n+    int i;\\\n+    for (i = 0; i < SIZE; i++)\\\n+    {\\\n+      dst[i] = ref[i] = -i; \\\n+      src1[i] = -(i + SIZE);\t\t\t\\\n+      src2[i] = i % 8;\t\t\t\\\n+      udst[i] = uref[i] = i;\t\t\t\\\n+      usrc1[i] = (i + SIZE);\t\t\t\\\n+      usrc2[i] = (i % 8);\t\t\t\\\n+    }\\\n+    EMULATE(SIZE, TYPE, vashl, ref, src1, src2);\t\\\n+    dst = VSHIFT(VTYPE, vashl, *((VTYPE* )&src1[0]), *((VTYPE*) &src2[0])); \\\n+    for (i = 0; i < SIZE; i++)\\\n+    {\\\n+      if(dst[i] != ref[i]) __builtin_abort();\\\n+    }\\\n+    EMULATE(SIZE, TYPE, vashr, ref, src1, src2);\t\\\n+    dst = VSHIFT(VTYPE, vashr, *((VTYPE* )&src1[0]), *((VTYPE*) &src2[0])); \\\n+    for (i = 0; i < SIZE; i++)\\\n+    {\\\n+      if(dst[i] != ref[i]) __builtin_abort();\\\n+    }\\\n+    EMULATE(SIZE, TYPEU, vlshr, uref, usrc1, usrc2);\t\\\n+    udst = VSHIFT(VTYPEU, vlshr, *((VTYPEU* )&usrc1[0]), *((VTYPEU*) &usrc2[0])); \\\n+    for (i = 0; i < SIZE; i++)\\\n+    {\\\n+      if(udst[i] != uref[i]) __builtin_abort();\\\n+    }\\\n+  }\n+\n+F_TEST_SHIFT (v8qi, v8uqi, int8, uint8, 8);\n+F_TEST_SHIFT (v16qi, v16uqi, int8, uint8, 16);\n+F_TEST_SHIFT (v32qi, v32uqi, int8, uint8, 32);\n+F_TEST_SHIFT (v8hi, v8uhi, int16, uint16, 8);\n+F_TEST_SHIFT (v16hi, v16uhi, int16, uint16, 16);\n+F_TEST_SHIFT (v32hi, v32uhi, int16, uint16, 32);\n+F_TEST_SHIFT (v2di, v2udi, int64, uint64, 2);\n+F_TEST_SHIFT (v4di, v4udi, int64, uint64, 4);\n+F_TEST_SHIFT (v8di, v8udi, int64, uint64, 8);\n+\n+\n+void\n+test (void)\n+{\n+  test_v8qi ();\n+  test_v16qi ();\n+  test_v32qi ();\n+  test_v8hi ();\n+  test_v16hi ();\n+  test_v32hi ();\n+  test_v2di ();\n+  test_v4di ();\n+  test_v8di ();\n+}"}]}