{"sha": "5d59ed6332df25f0ae59660dc127a4106bc1b7db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1OWVkNjMzMmRmMjVmMGFlNTk2NjBkYzEyN2E0MTA2YmMxYjdkYg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2015-12-11T00:27:14Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2015-12-11T00:27:14Z"}, "message": "Fix shrink-wrapping bug (PR67778, PR68634)\n\nAfter shrink-wrapping has found the \"tightest fit\" for where to place\nthe prologue, it tries move it earlier (so that frame saves are run\nearlier) -- but without copying any more basic blocks.\n\nUnfortunately a candidate block we select can be inside a loop, and we\nwill still allow it (because the loop always exits via our previously\nchosen block).  We can do that just fine if we make a duplicate of the\nblock, but we do not want to here.\n\nSo we need to detect this situation.  We can place the prologue at a\nprevious block PRE only if PRE dominates every block reachable from\nit, because then we will never need to duplicate that block (it will\nalways be executed with prologue).\n\n\n2015-12-11  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\tPR rtl-optimization/67778\n\tPR rtl-optimization/68634\n\t* shrink-wrap.c (try_shrink_wrapping): Add a comment about why we want\n\tto put the prologue earlier.  When determining if an earlier block is\n\tsuitable, make sure it dominates every block reachable from it.\n\nFrom-SVN: r231552", "tree": {"sha": "dc15978b0076a05b78a6f5c3f29688925bde398f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc15978b0076a05b78a6f5c3f29688925bde398f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d59ed6332df25f0ae59660dc127a4106bc1b7db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d59ed6332df25f0ae59660dc127a4106bc1b7db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d59ed6332df25f0ae59660dc127a4106bc1b7db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d59ed6332df25f0ae59660dc127a4106bc1b7db/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c7163d0bf0ec96fa52df323b35a625d73baa8b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c7163d0bf0ec96fa52df323b35a625d73baa8b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c7163d0bf0ec96fa52df323b35a625d73baa8b3"}], "stats": {"total": 48, "additions": 43, "deletions": 5}, "files": [{"sha": "ab875851c89e5fdbf1b07a8cd1c5d59e8bb3b304", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59ed6332df25f0ae59660dc127a4106bc1b7db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59ed6332df25f0ae59660dc127a4106bc1b7db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d59ed6332df25f0ae59660dc127a4106bc1b7db", "patch": "@@ -1,3 +1,11 @@\n+2015-12-11  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR rtl-optimization/67778\n+\tPR rtl-optimization/68634\n+\t* shrink-wrap.c (try_shrink_wrapping): Add a comment about why we want\n+\tto put the prologue earlier.  When determining if an earlier block is\n+\tsuitable, make sure it dominates every block reachable from it.\n+\n 2015-12-11  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/68814"}, {"sha": "f65b0c3e5505d3003a8145c46df212246e5312b3", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59ed6332df25f0ae59660dc127a4106bc1b7db/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59ed6332df25f0ae59660dc127a4106bc1b7db/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=5d59ed6332df25f0ae59660dc127a4106bc1b7db", "patch": "@@ -744,36 +744,66 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n \t  vec.quick_push (e->dest);\n     }\n \n-  vec.release ();\n-\n   if (dump_file)\n     fprintf (dump_file, \"Avoiding non-duplicatable blocks, PRO is now %d\\n\",\n \t     pro->index);\n \n   /* If we can move PRO back without having to duplicate more blocks, do so.\n+     We do this because putting the prologue earlier is better for scheduling.\n      We can move back to a block PRE if every path from PRE will eventually\n-     need a prologue, that is, PRO is a post-dominator of PRE.  */\n+     need a prologue, that is, PRO is a post-dominator of PRE.  PRE needs\n+     to dominate every block reachable from itself.  */\n \n   if (pro != entry)\n     {\n       calculate_dominance_info (CDI_POST_DOMINATORS);\n \n+      bitmap bb_tmp = BITMAP_ALLOC (NULL);\n+      bitmap_copy (bb_tmp, bb_with);\n       basic_block last_ok = pro;\n+      vec.truncate (0);\n+\n       while (pro != entry)\n \t{\n \t  basic_block pre = get_immediate_dominator (CDI_DOMINATORS, pro);\n \t  if (!dominated_by_p (CDI_POST_DOMINATORS, pre, pro))\n \t    break;\n \n+\t  if (bitmap_set_bit (bb_tmp, pre->index))\n+\t    vec.quick_push (pre);\n+\n+\t  bool ok = true;\n+\t  while (!vec.is_empty ())\n+\t    {\n+\t      basic_block bb = vec.pop ();\n+\t      bitmap_set_bit (bb_tmp, pre->index);\n+\n+\t      if (!dominated_by_p (CDI_DOMINATORS, bb, pre))\n+\t\t{\n+\t\t  ok = false;\n+\t\t  break;\n+\t\t}\n+\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tif (!bitmap_bit_p (bb_with, e->dest->index)\n+\t\t    && bitmap_set_bit (bb_tmp, e->dest->index))\n+\t\t  vec.quick_push (e->dest);\n+\t    }\n+\n+\t  if (ok && can_get_prologue (pre, prologue_clobbered))\n+\t    last_ok = pre;\n+\n \t  pro = pre;\n-\t  if (can_get_prologue (pro, prologue_clobbered))\n-\t    last_ok = pro;\n \t}\n+\n       pro = last_ok;\n \n+      BITMAP_FREE (bb_tmp);\n       free_dominance_info (CDI_POST_DOMINATORS);\n     }\n \n+  vec.release ();\n+\n   if (dump_file)\n     fprintf (dump_file, \"Bumping back to anticipatable blocks, PRO is now %d\\n\",\n \t     pro->index);"}]}