{"sha": "642ce434645564d7f02c4acefe90b74a0eca5d09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQyY2U0MzQ2NDU1NjRkN2YwMmM0YWNlZmU5MGI3NGEwZWNhNWQwOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-07T23:17:56Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-07T23:17:56Z"}, "message": "cppfiles.c (struct include_file): Move from cpphash.h.\n\n        * cppfiles.c (struct include_file): Move from cpphash.h.\n        (_cpp_never_reread): New function.\n        (open_file, read_include_file): Use it.\n        (stack_include_file): Set the buffer's sysp according to the\n        path in which the file was found.\n        (find_include_file): Don't set sysp.\n        (cpp_make_system_header, actual_directory): Update.\n        (_cpp_execute_include): Do #include_next lookup handling here,\n        not in cpplib.c.  Use _cpp_never_reread.\n        * cpphash.h (struct_include_file): Remove.\n        (struct cpp_buffer): New member sysp.\n        (CPP_IN_SYSTEM_HEADER, _cpp_execute_include): Update.\n        (_cpp_never_reread): New.\n        * cpplib.c (read_line_number): Rename read_flag.  Rework slightly.\n        (end_directive): Clear line_extension flag.\n        (_cpp_handle_directive): Set line_extension flag for #number.\n        (do_include_next): Handle path lookup in _cpp_execute_include.\n        (do_line): Cleanup to use read_flag.  Don't allow flags in #line.\n        (_cpp_do_file_change): Update.\n        (do_pragma_once): Use cpp_never_reread.  Clean up.\n        * cpplib.h (struct lexer_state): New member line_extension.\n\nFrom-SVN: r38120", "tree": {"sha": "7d2a48752253e693dd73859fe4a6329bee0871f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d2a48752253e693dd73859fe4a6329bee0871f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/642ce434645564d7f02c4acefe90b74a0eca5d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642ce434645564d7f02c4acefe90b74a0eca5d09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642ce434645564d7f02c4acefe90b74a0eca5d09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642ce434645564d7f02c4acefe90b74a0eca5d09/comments", "author": null, "committer": null, "parents": [{"sha": "02428c5d54c4280b35d33dfbed45c035ea9b4a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02428c5d54c4280b35d33dfbed45c035ea9b4a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02428c5d54c4280b35d33dfbed45c035ea9b4a06"}], "stats": {"total": 218, "additions": 123, "deletions": 95}, "files": [{"sha": "407baf1ed030a345078e62a1dc6cb6069ca8140a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=642ce434645564d7f02c4acefe90b74a0eca5d09", "patch": "@@ -1,3 +1,27 @@\n+2000-12-07  Neil Booth  <neilb@earthling.net>\n+\n+        * cppfiles.c (struct include_file): Move from cpphash.h.\n+        (_cpp_never_reread): New function.\n+        (open_file, read_include_file): Use it.\n+        (stack_include_file): Set the buffer's sysp according to the\n+        path in which the file was found.\n+        (find_include_file): Don't set sysp.\n+        (cpp_make_system_header, actual_directory): Update.\n+        (_cpp_execute_include): Do #include_next lookup handling here,\n+        not in cpplib.c.  Use _cpp_never_reread.\n+        * cpphash.h (struct_include_file): Remove.\n+        (struct cpp_buffer): New member sysp.\n+        (CPP_IN_SYSTEM_HEADER, _cpp_execute_include): Update.\n+        (_cpp_never_reread): New.\n+        * cpplib.c (read_line_number): Rename read_flag.  Rework slightly.\n+        (end_directive): Clear line_extension flag.\n+        (_cpp_handle_directive): Set line_extension flag for #number.\n+        (do_include_next): Handle path lookup in _cpp_execute_include.\n+        (do_line): Cleanup to use read_flag.  Don't allow flags in #line.\n+        (_cpp_do_file_change): Update.\n+        (do_pragma_once): Use cpp_never_reread.  Clean up.\n+        * cpplib.h (struct lexer_state): New member line_extension.\n+\n 2000-12-07  Richard Henderson  <rth@redhat.com>\n \n \t* flow.c (calculate_global_regs_live): Force the stack pointer live"}, {"sha": "4508034687e16ce35373e66b416b93bb52c70dcb", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=642ce434645564d7f02c4acefe90b74a0eca5d09", "patch": "@@ -63,6 +63,23 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    C.  It is unlikely that glibc's strcmp macro helps this file at all.  */\n #undef strcmp\n \n+/* This structure is used for the table of all includes.  */\n+struct include_file\n+{\n+  const char *name;\t\t/* actual path name of file */\n+  const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n+  const struct file_name_list *foundhere;\n+\t\t\t\t/* location in search path where file was\n+\t\t\t\t   found, for #include_next and sysp.  */\n+  const unsigned char *buffer;\t/* pointer to cached file contents */\n+  struct stat st;\t\t/* copy of stat(2) data for file */\n+  int fd;\t\t\t/* fd open on file (short term storage only) */\n+  unsigned short include_count;\t/* number of times file has been read */\n+  unsigned short refcnt;\t/* number of stacked buffers using this file */\n+  unsigned char mapped;\t\t/* file buffer is mmapped */\n+  unsigned char defined;\t/* cmacro prevents inclusion in this state */\n+};\n+\n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));\n@@ -118,6 +135,14 @@ _cpp_cleanup_includes (pfile)\n   splay_tree_delete (pfile->all_include_files);\n }\n \n+/* Mark a file to not be reread (e.g. #import, read failure).  */\n+void\n+_cpp_never_reread (file)\n+     struct include_file *file;\n+{\n+  file->cmacro = NEVER_REREAD;\n+}\n+\n /* Given a file name, look it up in the cache; if there is no entry,\n    create one with a non-NULL value (regardless of success in opening\n    the file).  If the file doesn't exist or is inaccessible, this\n@@ -155,6 +180,7 @@ open_file (pfile, filename)\n     }\n   else\n     {\n+      /* In particular, this clears foundhere.  */\n       file = xcnew (struct include_file);\n       file->name = xstrdup (filename);\n       splay_tree_insert (pfile->all_include_files,\n@@ -186,7 +212,7 @@ open_file (pfile, filename)\n       /* Mark a regular, zero-length file never-reread now.  */\n       if (S_ISREG (file->st.st_mode) && file->st.st_size == 0)\n         {\n-\t  file->cmacro = NEVER_REREAD;\n+\t  _cpp_never_reread (file);\n \t  close (file->fd);\n \t  file->fd = -1;\n \t}\n@@ -239,6 +265,8 @@ stack_include_file (pfile, inc)\n   fp->line_base = fp->buf;\n   fp->lineno = 0;\t\t/* For _cpp_do_file_change.  */\n   fp->inc->refcnt++;\n+  if (inc->foundhere)\n+    fp->sysp = inc->foundhere->sysp;\n \n   /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n      see do_include */\n@@ -377,7 +405,7 @@ read_include_file (pfile, inc)\n   /* Do not try to read this file again.  */\n   close (inc->fd);\n   inc->fd = -1;\n-  inc->cmacro = NEVER_REREAD;\n+  _cpp_never_reread (inc);\n   return;\n }\n \n@@ -466,7 +494,6 @@ find_include_file (pfile, fname, search_start)\n       file = open_file (pfile, name);\n       if (file)\n \t{\n-\t  file->sysp = path->sysp;\n \t  file->foundhere = path;\n \t  return file;\n \t}\n@@ -475,8 +502,8 @@ find_include_file (pfile, fname, search_start)\n }\n \n /* Not everyone who wants to set system-header-ness on a buffer can\n-   see the details of struct include_file.  This is an exported interface\n-   because fix-header needs it.  */\n+   see the details of a buffer.  This is an exported interface because\n+   fix-header needs it.  */\n void\n cpp_make_system_header (pfile, syshdr, externc)\n      cpp_reader *pfile;\n@@ -487,7 +514,7 @@ cpp_make_system_header (pfile, syshdr, externc)\n   /* 1 = system header, 2 = system header to be treated as C.  */\n   if (syshdr)\n     flags = 1 + (externc != 0);\n-  pfile->buffer->inc->sysp = flags;\n+  pfile->buffer->sysp = flags;\n }\n \n /* Report on all files that might benefit from a multiple include guard.\n@@ -524,12 +551,13 @@ report_missing_guard (n, b)\n \n #define PRINT_THIS_DEP(p, b) (CPP_PRINT_DEPS(p) > (b||p->system_include_depth))\n void\n-_cpp_execute_include (pfile, header, no_reinclude, search_start)\n+_cpp_execute_include (pfile, header, no_reinclude, include_next)\n      cpp_reader *pfile;\n      const cpp_token *header;\n      int no_reinclude;\n-     struct file_name_list *search_start;\n+     int include_next;\n {\n+  struct file_name_list *search_start = 0;\n   unsigned int len = header->val.str.len;\n   unsigned int angle_brackets = header->type == CPP_HEADER_NAME;\n   struct include_file *inc;\n@@ -549,6 +577,27 @@ _cpp_execute_include (pfile, header, no_reinclude, search_start)\n       return;\n     }\n \n+  /* For #include_next, skip in the search path past the dir in which\n+     the current file was found.  If this is the last directory in the\n+     search path, don't include anything.  If the current file was\n+     specified with an absolute path, use the normal search logic.  If\n+     this is the primary source file, use the normal search logic and\n+     generate a warning.  */\n+  if (include_next)\n+    {\n+      if (! pfile->buffer->prev)\n+\tcpp_warning (pfile, \"#include_next in primary source file\");\n+      else\n+\t{\n+\t  if (pfile->buffer->inc->foundhere)\n+\t    {\n+\t      search_start = pfile->buffer->inc->foundhere->next;\n+\t      if (! search_start)\n+\t\treturn;\n+\t    }\n+\t}\n+    }\n+\n   fname = alloca (len + 1);\n   memcpy (fname, header->val.str.text, len);\n   fname[len] = '\\0';\n@@ -587,7 +636,7 @@ _cpp_execute_include (pfile, header, no_reinclude, search_start)\n       if (! DO_NOT_REREAD (inc))\n \t{\n \t  if (no_reinclude)\n-\t    inc->cmacro = NEVER_REREAD;\n+\t    _cpp_never_reread (inc);\n \n \t  /* Handle -H option.  */\n \t  if (CPP_OPTION (pfile, print_include_names))\n@@ -981,7 +1030,7 @@ actual_directory (pfile, fname)\n   x->nlen = dlen;\n   x->next = CPP_OPTION (pfile, quote_include);\n   x->alloc = pfile->actual_dirs;\n-  x->sysp = CPP_BUFFER (pfile)->inc->sysp;\n+  x->sysp = pfile->buffer->sysp;\n   x->name_map = NULL;\n \n   pfile->actual_dirs = x;"}, {"sha": "1f4f98554c447b21c0489d202596d6e1676b8681", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=642ce434645564d7f02c4acefe90b74a0eca5d09", "patch": "@@ -70,24 +70,6 @@ struct file_name_list\n };\n #define ABSOLUTE_PATH ((struct file_name_list *)-1)\n \n-/* This structure is used for the table of all includes.  */\n-struct include_file\n-{\n-  const char *name;\t\t/* actual path name of file */\n-  const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n-  const struct file_name_list *foundhere;\n-\t\t\t\t/* location in search path where file was\n-\t\t\t\t   found, for #include_next */\n-  const unsigned char *buffer;\t/* pointer to cached file contents */\n-  struct stat st;\t\t/* copy of stat(2) data for file */\n-  int fd;\t\t\t/* fd open on file (short term storage only) */\n-  unsigned short include_count;\t/* number of times file has been read */\n-  unsigned short refcnt;\t/* number of stacked buffers using this file */\n-  unsigned char sysp;\t\t/* file is a system header */\n-  unsigned char mapped;\t\t/* file buffer is mmapped */\n-  unsigned char defined;\t/* cmacro prevents inclusion in this state */\n-};\n-\n /* The cmacro works like this: If it's NULL, the file is to be\n    included again.  If it's NEVER_REREAD, the file is never to be\n    included again.  Otherwise it is a macro hashnode, and the file is\n@@ -148,6 +130,9 @@ struct cpp_buffer\n \n   /* Temporary storage for pfile->skipping whilst in a directive.  */\n   unsigned char was_skipping;\n+\n+  /* 1 = system header file, 2 = C system header file used for C++.  */\n+  unsigned char sysp;\n };\n \n /* Character classes.\n@@ -191,8 +176,7 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n #define CPP_IN_SYSTEM_HEADER(PFILE) \\\n-  (CPP_BUFFER (PFILE) && CPP_BUFFER (PFILE)->inc \\\n-   && CPP_BUFFER (PFILE)->inc->sysp)\n+  (CPP_BUFFER (PFILE) && CPP_BUFFER (PFILE)->sysp)\n #define CPP_PEDANTIC(PF) \\\n   CPP_OPTION (PF, pedantic)\n #define CPP_WTRADITIONAL(PF) \\\n@@ -223,11 +207,11 @@ extern cpp_hashnode *_cpp_lookup_with_hash PARAMS ((cpp_reader*, size_t,\n \t\t\t\t\t\t    unsigned int));\n \n /* In cppfiles.c */\n+extern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n extern int _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_execute_include\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_token *, int,\n-\t\t\t\t\t\t struct file_name_list *));\n+\t\t\t\t\t\t const cpp_token *, int, int));\n extern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n \t\t\t\t\t\t const cpp_token *));\n extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));"}, {"sha": "d785fcd4d961122cf68385ad46505ae59e38e318", "filename": "gcc/cpplib.c", "status": "modified", "additions": 31, "deletions": 63, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=642ce434645564d7f02c4acefe90b74a0eca5d09", "patch": "@@ -90,7 +90,7 @@ static int glue_header_name\tPARAMS ((cpp_reader *, cpp_token *));\n static int  parse_include\tPARAMS ((cpp_reader *, cpp_token *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n-static int  read_line_number\tPARAMS ((cpp_reader *, int *));\n+static unsigned int read_flag\tPARAMS ((cpp_reader *));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n@@ -260,6 +260,7 @@ end_directive (pfile, skip_line)\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n   pfile->state.in_directive = 0;\n   pfile->state.angled_headers = 0;\n+  pfile->state.line_extension = 0;\n   pfile->directive = 0;\n }\n \n@@ -296,6 +297,7 @@ _cpp_handle_directive (pfile, indented)\n       if (! buffer->was_skipping && CPP_OPTION (pfile, lang) != CLK_ASM)\n \t{\n \t  dir = &dtable[T_LINE];\n+\t  pfile->state.line_extension = 1;\n \t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n \t  if (CPP_PEDANTIC (pfile) && buffer->inc\n \t      && ! CPP_OPTION (pfile, preprocessed))\n@@ -632,58 +634,32 @@ do_include_next (pfile)\n      cpp_reader *pfile;\n {\n   cpp_token header;\n-  struct file_name_list *search_start = 0;\n \n-  if (parse_include (pfile, &header))\n-    return;\n-\n-  /* For #include_next, skip in the search path past the dir in which\n-     the current file was found.  If this is the last directory in the\n-     search path, don't include anything.  If the current file was\n-     specified with an absolute path, use the normal search logic.  If\n-     this is the primary source file, use the normal search logic and\n-     generate a warning.  */\n-  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)))\n-    {\n-      if (CPP_BUFFER (pfile)->inc->foundhere)\n-\t{\n-\t  search_start = CPP_BUFFER (pfile)->inc->foundhere->next;\n-\t  if (!search_start)\n-\t    return;\n-\t}\n-    }\n-  else\n-    cpp_warning (pfile, \"#include_next in primary source file\");\n-\n-  _cpp_execute_include (pfile, &header, 0, search_start);\n+  if (!parse_include (pfile, &header))\n+    _cpp_execute_include (pfile, &header, 0, 1);\n }\n \n-/* Subroutine of do_line.  Read next token from PFILE without adding it to\n-   the output buffer.  If it is a number between 1 and 4, store it in *NUM\n-   and return 1; otherwise, return 0 and complain if we aren't at the end\n-   of the directive.  */\n+/* Subroutine of do_line.  Read possible flags after file name.  If it\n+   is a number between 1 and 4, return it, otherwise return 0.  If\n+   it's not the end of the directive complain.  */\n \n-static int\n-read_line_number (pfile, num)\n+static unsigned int\n+read_flag (pfile)\n      cpp_reader *pfile;\n-     int *num;\n {\n   cpp_token token;\n-  unsigned int val;\n \n   _cpp_lex_token (pfile, &token);\n   if (token.type == CPP_NUMBER && token.val.str.len == 1)\n     {\n-      val = token.val.str.text[0] - '1';\n-      if (val <= 3)\n-\t{\n-\t  *num = val + 1;\n-\t  return 1;\n-\t}\n+      unsigned int flag = token.val.str.text[0] - '1';\n+      if (flag <= 3)\n+\treturn flag + 1;\n     }\n \n   if (token.type != CPP_EOF)\n-    cpp_error (pfile, \"invalid format #line\");\n+    cpp_error (pfile, \"invalid flag \\\"%s\\\" in line directive\",\n+\t       cpp_token_as_text (pfile, &token));\n   return 0;\n }\n \n@@ -747,7 +723,6 @@ do_line (pfile)\n     {\n       char *fname;\n       unsigned int len;\n-      int action_number = 0;\n \n       /* FIXME: memory leak.  */\n       len = token.val.str.len;\n@@ -758,33 +733,28 @@ do_line (pfile)\n       _cpp_simplify_pathname (fname);\n       buffer->nominal_fname = fname;\n \n-      if (read_line_number (pfile, &action_number) != 0)\n+      if (pfile->state.line_extension)\n \t{\n-\t  if (! CPP_OPTION (pfile, preprocessed) && CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile,  \"extra tokens at end of #line directive\");\n+\t  int flag, sysp = 0;\n \n-\t  if (action_number == 1)\n+\t  flag = read_flag (pfile);\n+\t  if (flag == 1)\n \t    {\n \t      reason = FC_ENTER;\n-\t      cpp_make_system_header (pfile, 0, 0);\n-\t      read_line_number (pfile, &action_number);\n+\t      flag = read_flag (pfile);\n \t    }\n-\t  else if (action_number == 2)\n+\t  else if (flag == 2)\n \t    {\n \t      reason = FC_LEAVE;\n-\t      cpp_make_system_header (pfile, 0, 0);\n-\t      read_line_number (pfile, &action_number);\n+\t      flag = read_flag (pfile);\n \t    }\n-\t  if (action_number == 3)\n+\t  if (flag == 3)\n \t    {\n-\t      cpp_make_system_header (pfile, 1, 0);\n-\t      read_line_number (pfile, &action_number);\n-\t    }\n-\t  if (action_number == 4)\n-\t    {\n-\t      cpp_make_system_header (pfile, 1, 1);\n-\t      read_line_number (pfile, &action_number);\n+\t      flag = read_flag (pfile);\n+\t      sysp = 1;\n \t    }\n+\n+\t  cpp_make_system_header (pfile, sysp, flag == 4);\n \t}\n \n       check_eol (pfile);\n@@ -820,8 +790,8 @@ _cpp_do_file_change (pfile, reason, from_file, from_lineno)\n       fc.from.lineno = from_lineno;\n       fc.to.filename = buffer->nominal_fname;\n       fc.to.lineno = buffer->lineno + 1;\n-      fc.sysp = buffer->inc->sysp;\n-      fc.externc = CPP_OPTION (pfile, cplusplus) && buffer->inc->sysp == 2;\n+      fc.sysp = buffer->sysp;\n+      fc.externc = CPP_OPTION (pfile, cplusplus) && buffer->sysp == 2;\n       pfile->cb.change_file (pfile, &fc);\n     }\n }\n@@ -1034,14 +1004,12 @@ static void\n do_pragma_once (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n   cpp_warning (pfile, \"#pragma once is obsolete\");\n  \n-  if (CPP_PREV_BUFFER (ip) == NULL)\n+  if (pfile->buffer->prev == NULL)\n     cpp_warning (pfile, \"#pragma once in main file\");\n   else\n-    ip->inc->cmacro = NEVER_REREAD;\n+    _cpp_never_reread (pfile->buffer->inc);\n \n   check_eol (pfile);\n }"}, {"sha": "e14cbd4570b8b9aa98730d654ae03b0e46f5ee7e", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642ce434645564d7f02c4acefe90b74a0eca5d09/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=642ce434645564d7f02c4acefe90b74a0eca5d09", "patch": "@@ -455,6 +455,9 @@ struct lexer_state\n \n   /* Nonzero when parsing arguments to a function-like macro.  */\n   unsigned char parsing_args;\n+\n+  /* Nonzero when in a # NUMBER directive.  */\n+  unsigned char line_extension;\n };\n \n /* Special nodes - identifiers with predefined significance.  */"}]}