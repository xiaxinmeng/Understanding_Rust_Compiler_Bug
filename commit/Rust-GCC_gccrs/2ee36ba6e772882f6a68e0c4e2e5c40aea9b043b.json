{"sha": "2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlMzZiYTZlNzcyODgyZjZhNjhlMGM0ZTJlNWM0MGFlYTliMDQzYg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2011-05-20T15:09:35Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-05-20T15:09:35Z"}, "message": "lto-streamer.c (lto_record_common_node): Don't track seen nodes...\n\n\t* lto-streamer.c (lto_record_common_node): Don't track seen nodes,\n\tuse lto_streamer_cache_append directly instead of returning a VEC.\n\t(preload_common_node): Remove.\n\t(lto_get_common_nodes): Rename to lto_preload_common_nodes, don't\n\ttrack seen nodes.\n\t(lto_streamer_cache_create): Call lto_preload_common_nodes.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r173956", "tree": {"sha": "ec5c23c11af436464d8f82894f9cca0d225eeeef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec5c23c11af436464d8f82894f9cca0d225eeeef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "90ff582fb1f05f7380adfab59d86065aae09a9a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ff582fb1f05f7380adfab59d86065aae09a9a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ff582fb1f05f7380adfab59d86065aae09a9a7"}], "stats": {"total": 102, "additions": 40, "deletions": 62}, "files": [{"sha": "ae560b6f586db634ad6637ae0eabb89e3d0a8e13", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b", "patch": "@@ -1,3 +1,13 @@\n+2011-05-20  Michael Matz  <matz@suse.de>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-streamer.c (lto_record_common_node): Don't track seen nodes,\n+\tuse lto_streamer_cache_append directly instead of returning a VEC.\n+\t(preload_common_node): Remove.\n+\t(lto_get_common_nodes): Rename to lto_preload_common_nodes, don't\n+\ttrack seen nodes.\n+\t(lto_streamer_cache_create): Call lto_preload_common_nodes.\n+\n 2011-05-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/49079"}, {"sha": "abccd10ccee3e0ec5d28c18b0d7db0e2fe7ba603", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 30, "deletions": 62, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=2ee36ba6e772882f6a68e0c4e2e5c40aea9b043b", "patch": "@@ -475,17 +475,21 @@ lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n }\n \n \n-/* Record NODE in COMMON_NODES if it is not NULL and is not already in\n-   SEEN_NODES.  */\n+/* Record NODE in CACHE.  */\n \n static void\n-lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n-\t\t\tstruct pointer_set_t *seen_nodes)\n+lto_record_common_node (struct lto_streamer_cache_d *cache, tree *nodep)\n {\n   tree node = *nodep;\n \n-  if (node == NULL_TREE)\n-    return;\n+  /* We have to make sure to fill exactly the same number of\n+     elements for all frontends.  That can include NULL trees.\n+     As our hash table can't deal with zero entries we'll simply stream\n+     a random other tree.  A NULL tree never will be looked up so it\n+     doesn't matter which tree we replace it with, just to be sure\n+     use error_mark_node.  */\n+  if (!node)\n+    node = error_mark_node;\n \n   if (TYPE_P (node))\n     {\n@@ -500,28 +504,32 @@ lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n       *nodep = node;\n     }\n \n-  /* Return if node is already seen.  */\n-  if (pointer_set_insert (seen_nodes, node))\n-    return;\n-\n-  VEC_safe_push (tree, heap, *common_nodes, node);\n+  lto_streamer_cache_append (cache, node);\n \n   if (POINTER_TYPE_P (node)\n       || TREE_CODE (node) == COMPLEX_TYPE\n       || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_record_common_node (&TREE_TYPE (node), common_nodes, seen_nodes);\n+    lto_record_common_node (cache, &TREE_TYPE (node));\n+  else if (TREE_CODE (node) == RECORD_TYPE)\n+    {\n+      /* The FIELD_DECLs of structures should be shared, so that every\n+\t COMPONENT_REF uses the same tree node when referencing a field.\n+\t Pointer equality between FIELD_DECLs is used by the alias\n+\t machinery to compute overlapping memory references (See\n+\t nonoverlapping_component_refs_p).  */\n+      tree f;\n+      for (f = TYPE_FIELDS (node); f; f = TREE_CHAIN (f))\n+\tlto_record_common_node (cache, &f);\n+    }\n }\n \n-\n-/* Generate a vector of common nodes and make sure they are merged\n+/* Preload common nodes into CACHE and make sure they are merged\n    properly according to the gimple type table.  */\n \n-static VEC(tree,heap) *\n-lto_get_common_nodes (void)\n+static void\n+lto_preload_common_nodes (struct lto_streamer_cache_d *cache)\n {\n   unsigned i;\n-  VEC(tree,heap) *common_nodes = NULL;\n-  struct pointer_set_t *seen_nodes;\n \n   /* The MAIN_IDENTIFIER_NODE is normally set up by the front-end, but the\n      LTO back-end must agree. Currently, the only languages that set this\n@@ -545,59 +553,24 @@ lto_get_common_nodes (void)\n   gcc_assert (fileptr_type_node == ptr_type_node);\n   gcc_assert (TYPE_MAIN_VARIANT (fileptr_type_node) == ptr_type_node);\n \n-  seen_nodes = pointer_set_create ();\n-\n   /* Skip itk_char.  char_type_node is shared with the appropriately\n      signed variant.  */\n   for (i = itk_signed_char; i < itk_none; i++)\n-    lto_record_common_node (&integer_types[i], &common_nodes, seen_nodes);\n+    lto_record_common_node (cache, &integer_types[i]);\n \n   for (i = 0; i < TYPE_KIND_LAST; i++)\n-    lto_record_common_node (&sizetype_tab[i], &common_nodes, seen_nodes);\n+    lto_record_common_node (cache, &sizetype_tab[i]);\n \n   for (i = 0; i < TI_MAX; i++)\n-    lto_record_common_node (&global_trees[i], &common_nodes, seen_nodes);\n-\n-  pointer_set_destroy (seen_nodes);\n-\n-  return common_nodes;\n-}\n-\n-\n-/* Assign an index to tree node T and enter it in the streamer cache\n-   CACHE.  */\n-\n-static void\n-preload_common_node (struct lto_streamer_cache_d *cache, tree t)\n-{\n-  gcc_assert (t);\n-\n-  lto_streamer_cache_insert (cache, t, NULL);\n-\n- /* The FIELD_DECLs of structures should be shared, so that every\n-    COMPONENT_REF uses the same tree node when referencing a field.\n-    Pointer equality between FIELD_DECLs is used by the alias\n-    machinery to compute overlapping memory references (See\n-    nonoverlapping_component_refs_p).  */\n- if (TREE_CODE (t) == RECORD_TYPE)\n-   {\n-     tree f;\n-\n-     for (f = TYPE_FIELDS (t); f; f = TREE_CHAIN (f))\n-       preload_common_node (cache, f);\n-   }\n+    lto_record_common_node (cache, &global_trees[i]);\n }\n \n-\n /* Create a cache of pickled nodes.  */\n \n struct lto_streamer_cache_d *\n lto_streamer_cache_create (void)\n {\n   struct lto_streamer_cache_d *cache;\n-  VEC(tree, heap) *common_nodes;\n-  unsigned i;\n-  tree node;\n \n   cache = XCNEW (struct lto_streamer_cache_d);\n \n@@ -606,12 +579,7 @@ lto_streamer_cache_create (void)\n   /* Load all the well-known tree nodes that are always created by\n      the compiler on startup.  This prevents writing them out\n      unnecessarily.  */\n-  common_nodes = lto_get_common_nodes ();\n-\n-  FOR_EACH_VEC_ELT (tree, common_nodes, i, node)\n-    preload_common_node (cache, node);\n-\n-  VEC_free(tree, heap, common_nodes);\n+  lto_preload_common_nodes (cache);\n \n   return cache;\n }"}]}