{"sha": "98e6ecab8caecd055780ee085e59c9858886169c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThlNmVjYWI4Y2FlY2QwNTU3ODBlZTA4NWU1OWM5ODU4ODg2MTY5Yw==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2014-04-08T18:31:06Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2014-04-08T18:31:06Z"}, "message": "sync.md (AINT mode_iterator): Move definition.\n\n\t* config/rs6000/sync.md (AINT mode_iterator): Move definition.\n\t(loadsync_<mode>): Change mode.\n\t(load_quadpti, store_quadpti): New.\n\t(atomic_load<mode>, atomic_store<mode>): Add support for TI mode.\n\t* config/rs6000/rs6000.md (unspec enum): Add UNSPEC_LSQ.\n\n\t* gcc.target/powerpc/atomic_load_store-p8.c: New.\n\nFrom-SVN: r209225", "tree": {"sha": "448d7cdeed209fc876b4ae9c8e40566bf3259f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/448d7cdeed209fc876b4ae9c8e40566bf3259f8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98e6ecab8caecd055780ee085e59c9858886169c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e6ecab8caecd055780ee085e59c9858886169c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e6ecab8caecd055780ee085e59c9858886169c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e6ecab8caecd055780ee085e59c9858886169c/comments", "author": null, "committer": null, "parents": [{"sha": "795bc4b6fb8017905edfa27e3c528b2a32afd695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795bc4b6fb8017905edfa27e3c528b2a32afd695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795bc4b6fb8017905edfa27e3c528b2a32afd695"}], "stats": {"total": 144, "additions": 127, "deletions": 17}, "files": [{"sha": "9cfe12a2800e2cc8a3736b90a4264d86dad2218a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98e6ecab8caecd055780ee085e59c9858886169c", "patch": "@@ -1,3 +1,11 @@\n+2014-04-08  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/sync.md (AINT mode_iterator): Move definition.\n+\t(loadsync_<mode>): Change mode.\n+\t(load_quadpti, store_quadpti): New.\n+\t(atomic_load<mode>, atomic_store<mode>): Add support for TI mode.\n+\t* config/rs6000/rs6000.md (unspec enum): Add UNSPEC_LSQ.\n+\n 2014-04-08  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR target/60763"}, {"sha": "d204835f9e9e9514246c311e1f18e7c778fdea71", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=98e6ecab8caecd055780ee085e59c9858886169c", "patch": "@@ -624,14 +624,14 @@\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n ;; Return 1 if the operand is suitable for load/store quad memory.\n-;; This predicate only checks for non-atomic loads/stores.\n+;; This predicate only checks for non-atomic loads/stores (not lqarx/stqcx).\n (define_predicate \"quad_memory_operand\"\n   (match_code \"mem\")\n {\n   rtx addr, op0, op1;\n   int ret;\n \n-  if (!TARGET_QUAD_MEMORY)\n+  if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)\n     ret = 0;\n \n   else if (!memory_operand (op, mode))"}, {"sha": "f220f436ec254d7d73871b03e2941e4ca2b62bd6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=98e6ecab8caecd055780ee085e59c9858886169c", "patch": "@@ -125,6 +125,7 @@\n    UNSPEC_P8V_MTVSRD\n    UNSPEC_P8V_XXPERMDI\n    UNSPEC_P8V_RELOAD_FROM_VSX\n+   UNSPEC_LSQ\n   ])\n \n ;;"}, {"sha": "63152ed04d20e9a8299b4a24b3358f48ae15d3d6", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 90, "deletions": 15, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=98e6ecab8caecd055780ee085e59c9858886169c", "patch": "@@ -107,29 +107,74 @@\n   \"isync\"\n   [(set_attr \"type\" \"isync\")])\n \n+;; Types that we should provide atomic instructions for.\n+(define_mode_iterator AINT [QI\n+\t\t\t    HI\n+\t\t\t    SI\n+\t\t\t    (DI \"TARGET_POWERPC64\")\n+\t\t\t    (TI \"TARGET_SYNC_TI\")])\n+\n ;; The control dependency used for load dependency described\n ;; in B.2.3 of the Power ISA 2.06B.\n (define_insn \"loadsync_<mode>\"\n-  [(unspec_volatile:BLK [(match_operand:INT1 0 \"register_operand\" \"r\")]\n+  [(unspec_volatile:BLK [(match_operand:AINT 0 \"register_operand\" \"r\")]\n \t\t\tUNSPECV_ISYNC)\n    (clobber (match_scratch:CC 1 \"=y\"))]\n   \"\"\n   \"cmpw %1,%0,%0\\;bne- %1,$+4\\;isync\"\n   [(set_attr \"type\" \"isync\")\n    (set_attr \"length\" \"12\")])\n \n+(define_insn \"load_quadpti\"\n+  [(set (match_operand:PTI 0 \"quad_int_reg_operand\" \"=&r\")\n+\t(unspec:PTI\n+\t [(match_operand:TI 1 \"quad_memory_operand\" \"wQ\")] UNSPEC_LSQ))]\n+  \"TARGET_SYNC_TI\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n+  \"lq %0,%1\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_expand \"atomic_load<mode>\"\n-  [(set (match_operand:INT1 0 \"register_operand\" \"\")\t\t;; output\n-\t(match_operand:INT1 1 \"memory_operand\" \"\"))\t\t;; memory\n+  [(set (match_operand:AINT 0 \"register_operand\" \"\")\t\t;; output\n+\t(match_operand:AINT 1 \"memory_operand\" \"\"))\t\t;; memory\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n   \"\"\n {\n+  if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n+    FAIL;\n+\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n \n   if (model == MEMMODEL_SEQ_CST)\n     emit_insn (gen_hwsync ());\n \n-  emit_move_insn (operands[0], operands[1]);\n+  if (<MODE>mode != TImode)\n+    emit_move_insn (operands[0], operands[1]);\n+  else\n+    {\n+      rtx op0 = operands[0];\n+      rtx op1 = operands[1];\n+      rtx pti_reg = gen_reg_rtx (PTImode);\n+\n+      // Can't have indexed address for 'lq'\n+      if (indexed_address (XEXP (op1, 0), TImode))\n+\t{\n+\t  rtx old_addr = XEXP (op1, 0);\n+\t  rtx new_addr = force_reg (Pmode, old_addr);\n+\t  operands[1] = op1 = replace_equiv_address (op1, new_addr);\n+\t}\n+\n+      emit_insn (gen_load_quadpti (pti_reg, op1));\n+\n+      if (WORDS_BIG_ENDIAN)\n+\temit_move_insn (op0, gen_lowpart (TImode, pti_reg));\n+      else\n+\t{\n+\t  emit_move_insn (gen_lowpart (DImode, op0), gen_highpart (DImode, pti_reg));\n+\t  emit_move_insn (gen_highpart (DImode, op0), gen_lowpart (DImode, pti_reg));\n+\t}\n+    }\n \n   switch (model)\n     {\n@@ -146,12 +191,24 @@\n   DONE;\n })\n \n+(define_insn \"store_quadpti\"\n+  [(set (match_operand:PTI 0 \"quad_memory_operand\" \"=wQ\")\n+\t(unspec:PTI\n+\t [(match_operand:PTI 1 \"quad_int_reg_operand\" \"r\")] UNSPEC_LSQ))]\n+  \"TARGET_SYNC_TI\"\n+  \"stq %1,%0\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_expand \"atomic_store<mode>\"\n-  [(set (match_operand:INT1 0 \"memory_operand\" \"\")\t\t;; memory\n-\t(match_operand:INT1 1 \"register_operand\" \"\"))\t\t;; input\n+  [(set (match_operand:AINT 0 \"memory_operand\" \"\")\t\t;; memory\n+\t(match_operand:AINT 1 \"register_operand\" \"\"))\t\t;; input\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n   \"\"\n {\n+  if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n+    FAIL;\n+\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n   switch (model)\n     {\n@@ -166,7 +223,33 @@\n     default:\n       gcc_unreachable ();\n     }\n-  emit_move_insn (operands[0], operands[1]);\n+  if (<MODE>mode != TImode)\n+    emit_move_insn (operands[0], operands[1]);\n+  else\n+    {\n+      rtx op0 = operands[0];\n+      rtx op1 = operands[1];\n+      rtx pti_reg = gen_reg_rtx (PTImode);\n+\n+      // Can't have indexed address for 'stq'\n+      if (indexed_address (XEXP (op0, 0), TImode))\n+\t{\n+\t  rtx old_addr = XEXP (op0, 0);\n+\t  rtx new_addr = force_reg (Pmode, old_addr);\n+\t  operands[0] = op0 = replace_equiv_address (op0, new_addr);\n+\t}\n+\n+      if (WORDS_BIG_ENDIAN)\n+\temit_move_insn (pti_reg, gen_lowpart (PTImode, op1));\n+      else\n+\t{\n+\t  emit_move_insn (gen_lowpart (DImode, pti_reg), gen_highpart (DImode, op1));\n+\t  emit_move_insn (gen_highpart (DImode, pti_reg), gen_lowpart (DImode, op1));\n+\t}\n+\n+      emit_insn (gen_store_quadpti (gen_lowpart (PTImode, op0), pti_reg));\n+    }\n+\n   DONE;\n })\n \n@@ -180,14 +263,6 @@\n \t\t\t      SI\n \t\t\t      (DI \"TARGET_POWERPC64\")])\n \n-;; Types that we should provide atomic instructions for.\n-\n-(define_mode_iterator AINT [QI\n-\t\t\t    HI\n-\t\t\t    SI\n-\t\t\t    (DI \"TARGET_POWERPC64\")\n-\t\t\t    (TI \"TARGET_SYNC_TI\")])\n-\n (define_insn \"load_locked<mode>\"\n   [(set (match_operand:ATOMIC 0 \"int_reg_operand\" \"=r\")\n \t(unspec_volatile:ATOMIC"}, {"sha": "5d907c060af99d1795b46442927761499039318b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98e6ecab8caecd055780ee085e59c9858886169c", "patch": "@@ -1,3 +1,7 @@\n+2014-04-08  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* gcc.target/powerpc/atomic_load_store-p8.c: New.\n+\n 2014-04-08  Jason Merrill  <jason@redhat.com>\n \n \t* lib/gcc-dg.exp (dg-build-dso): Reset dg-do-what-default to"}, {"sha": "8a5cbfaa36be186493d4e8cdc889909cbaf317f0", "filename": "gcc/testsuite/gcc.target/powerpc/atomic_load_store-p8.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fatomic_load_store-p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e6ecab8caecd055780ee085e59c9858886169c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fatomic_load_store-p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fatomic_load_store-p8.c?ref=98e6ecab8caecd055780ee085e59c9858886169c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-final { scan-assembler-times \"lq\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stq\" 1 } } */\n+/* { dg-final { scan-assembler-not \"bl __atomic\" } } */\n+/* { dg-final { scan-assembler-not \"lqarx\" } } */\n+/* { dg-final { scan-assembler-not \"stqcx\" } } */\n+\n+__int128\n+atomic_load_128_relaxed (__int128 *ptr)\n+{\n+\treturn __atomic_load_n (ptr, __ATOMIC_RELAXED);\n+}\n+\n+void\n+atomic_store_128_relaxed (__int128 *ptr, __int128 val)\n+{\n+\t__atomic_store_n (ptr, val, __ATOMIC_RELAXED);\n+}\n+"}]}