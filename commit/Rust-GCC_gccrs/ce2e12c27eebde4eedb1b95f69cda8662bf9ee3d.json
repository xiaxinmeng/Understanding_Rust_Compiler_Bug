{"sha": "ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyZTEyYzI3ZWViZGU0ZWVkYjFiOTVmNjljZGE4NjYyYmY5ZWUzZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-05-28T18:03:28Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-05-28T18:03:28Z"}, "message": "decl.c, [...]: Fix comment typos.\n\n\t* decl.c, env.c, gigi.h, init.c, initialize.c, raise-gcc.c,\n\tsem_ch13.adb, sysdep.c, targtyps.c, tb-alvxw.c, tracebak.c,\n\ttrans.c, utils.c: Fix comment typos.  Follow spelling\n\tconventions.\n\t* gnat_rm.texi, gnat_ugn.texi, : Fix typos.  Follow spelling\n\tconventions.\n\nFrom-SVN: r114171", "tree": {"sha": "476907f2cf934fdc4751893878c1d3f0fa3b64c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/476907f2cf934fdc4751893878c1d3f0fa3b64c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/comments", "author": null, "committer": null, "parents": [{"sha": "e2ae1407d3a0429fada6ff23f38ebf96bd62bd73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2ae1407d3a0429fada6ff23f38ebf96bd62bd73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2ae1407d3a0429fada6ff23f38ebf96bd62bd73"}], "stats": {"total": 65, "additions": 37, "deletions": 28}, "files": [{"sha": "6698b77a0733b67f0be34073391c7b24fb277b33", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -1,3 +1,12 @@\n+2006-05-28  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* decl.c, env.c, gigi.h, init.c, initialize.c, raise-gcc.c,\n+\tsem_ch13.adb, sysdep.c, targtyps.c, tb-alvxw.c, tracebak.c,\n+\ttrans.c, utils.c: Fix comment typos.  Follow spelling\n+\tconventions.\n+\t* gnat_rm.texi, gnat_ugn.texi, : Fix typos.  Follow spelling\n+\tconventions.\n+\n 2006-05-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* Make-lang.in (ada/decl.o): Replace target.h with $(TARGET_H)."}, {"sha": "6a8f23424c5e20198ff22c500e8114e2aff53c6c", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -134,7 +134,7 @@ gnat_to_gnu_type (Entity_Id gnat_entity)\n    DEFINITION is nonzero if this call is intended for a definition.  This is\n    used for separate compilation where it necessary to know whether an\n    external declaration or a definition should be created if the GCC equivalent\n-   was not created previously.  The value of 1 is normally used for a non-zero\n+   was not created previously.  The value of 1 is normally used for a nonzero\n    DEFINITION, but a value of 2 is used in special circumstances, defined in\n    the code.  */\n \n@@ -4719,7 +4719,7 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n   if (present_gnu_tree (gnat_expr))\n     return get_gnu_tree (gnat_expr);\n \n-  /* If we don't need a value and this is static or a discriment, we\n+  /* If we don't need a value and this is static or a discriminant, we\n      don't need to do anything.  */\n   else if (!need_value\n \t   && (Is_OK_Static_Expression (gnat_expr)\n@@ -5254,7 +5254,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n      this a bitfield and avoid making things wider.\n \n      Doing this is first useful if the record is packed because we can then\n-     place the field at a non-byte-aligned position and so achieve tigther\n+     place the field at a non-byte-aligned position and so achieve tighter\n      packing.\n \n      This is in addition *required* if the field shares a byte with another"}, {"sha": "9465a3ec0c98fe3de72efa1be01ef78ec1f782fb", "filename": "gcc/ada/env.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -227,7 +227,7 @@ void __gnat_unsetenv (char *name) {\n      have been allocated using malloc. To avoid this memory leak another\n      method can be used. It consists in forcing the reallocation of all the\n      strings in the environ table using malloc on the first call on the\n-     functions related to environment variable management. The disavantage\n+     functions related to environment variable management. The disadvantage\n      is that if a program makes a direct call to getenv the return string\n      may be deallocated at some point. */\n   /* Note that on AIX, unsetenv is not supported on 5.1 but it is on 5.3."}, {"sha": "e1661290f723ded1782e666ebf143747f253926c", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -63,7 +63,7 @@ extern void init_dummy_type (void);\n    DEFINITION is nonzero if this call is intended for a definition.  This is\n    used for separate compilation where it necessary to know whether an\n    external declaration or a definition should be created if the GCC equivalent\n-   was not created previously.  The value of 1 is normally used for a non-zero\n+   was not created previously.  The value of 1 is normally used for a nonzero\n    DEFINITION, but a value of 2 is used in special circumstances, defined in\n    the code.  */\n extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n@@ -406,7 +406,7 @@ extern GTY(()) tree static_dtors;\n /* Routines expected by the gcc back-end. They must have exactly the same\n    prototype and names as below.  */\n \n-/* Returns non-zero if we are currently in the global binding level       */\n+/* Returns nonzero if we are currently in the global binding level.  */\n extern int global_bindings_p (void);\n \n /* Enter and exit a new binding level. */"}, {"sha": "a0f1b4fa96e9a05d045466d043972443ae61e80e", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -7146,7 +7146,7 @@ case letters. This line is always present.\n \n @item\n @code{ppp} is the Process Id value as a decimal integer (this line is\n-present only if the Process Id is non-zero). Currently we are\n+present only if the Process Id is nonzero). Currently we are\n not making use of this field.\n \n @item\n@@ -7456,7 +7456,7 @@ must define with the following profile:\n \n    The parameter is a C null-terminated string representing a message to be\n    associated with the exception (typically the source location of the raise\n-   statement generated by the compiler). The Line parameter when non-zero\n+   statement generated by the compiler). The Line parameter when nonzero\n    represents the line number in the source program where the raise occurs.\n \n @item No_Exception_Streams\n@@ -8185,7 +8185,7 @@ The ceiling priority of internal protected objects is\n @strong{101}.  Implementation-defined queuing policies.  See D.4(1).\n @end cartouche\n @noindent\n-There are no implementation-defined queueing policies.\n+There are no implementation-defined queuing policies.\n \n @sp 1\n @cartouche"}, {"sha": "750a0869ff9a686dcd09571c04cbfd30f24dbcaf", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -3014,7 +3014,7 @@ interface to @code{printfi}.\n @item\n It may work on some platforms to directly interface to\n a @code{varargs} function by providing a specific Ada profile\n-for a a particular call. However, this does not work on\n+for a particular call. However, this does not work on\n all platforms, since there is no guarantee that the\n calling sequence for a two argument normal C function\n is the same as for calling a @code{varargs} C function with\n@@ -3050,7 +3050,7 @@ in section B.5 of the Ada 95 Reference Manual.\n \n @item Intrinsic\n This applies to an intrinsic operation, as defined in the Ada 95\n-Reference Manual. If a a pragma Import (Intrinsic) applies to a subprogram,\n+Reference Manual. If a pragma Import (Intrinsic) applies to a subprogram,\n this means that the body of the subprogram is provided by the compiler itself,\n usually by means of an efficient code sequence, and that the user does not\n supply an explicit body for it. In an application program, the pragma can\n@@ -7318,7 +7318,7 @@ Set the time slice value to @var{n} milliseconds. If the system supports\n the specification of a specific time slice value, then the indicated value\n is used. If the system does not support specific time slice values, but\n does support some general notion of round-robin scheduling, then any\n-non-zero value will activate round-robin scheduling.\n+nonzero value will activate round-robin scheduling.\n \n A value of zero is treated specially. It turns off time\n slicing, and in addition, indicates to the tasking run time that the\n@@ -9104,7 +9104,7 @@ in @ref{Inlining of Subprograms}.\n @noindent\n Although it is possible to do a reasonable amount of debugging at\n @ifclear vms\n-non-zero optimization levels,\n+nonzero optimization levels,\n the higher the level the more likely that\n @end ifclear\n @ifset vms\n@@ -20052,7 +20052,7 @@ This command allows to switch to the task referred by @var{taskno}. In\n particular, This allows to browse the backtrace of the specified\n task. It is advised to switch back to the original task before\n continuing execution otherwise the scheduling of the program may be\n-perturbated.\n+perturbed.\n @end table\n \n @noindent"}, {"sha": "521963751e50eb2d38967285ad409346342470e6", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -1801,7 +1801,7 @@ __gnat_init_float (void)\n #endif\n \n   /* Similarly for sparc64. Achieved by masking bits in the Trap Enable Mask\n-     field of the Floating-point Status Register (see the Sparc Architecture\n+     field of the Floating-point Status Register (see the SPARC Architecture\n      Manual Version 9, p 48).  */\n #if defined (sparc64)\n "}, {"sha": "0b86c2f2f0507ecc84464b8e48842ad0d2015341", "filename": "gcc/ada/initialize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Finitialize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Finitialize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finitialize.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -126,7 +126,7 @@ __gnat_initialize (void *eh)\n      step documented for C++.  The de-registration is handled symmetrically,\n      a-la C++ destructor fashion and typically triggered by the dynamic\n      unloader.  Note that since the tables shall be registered against a\n-     common datastructure, libgcc should be one of the modules (vs beeing\n+     common datastructure, libgcc should be one of the modules (vs being\n      partially linked against all the others at build time) and shall be\n      loaded first.\n "}, {"sha": "3100af3b9e53556a919380d72005bd7860b320b2", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -62,7 +62,7 @@ typedef char bool;\n    (SJLJ or DWARF). We need a consistently named interface to import from\n    a-except, so wrappers are defined here.\n \n-   Besides, eventhough the compiler is never setup to use the GCC propagation\n+   Besides, even though the compiler is never setup to use the GCC propagation\n    circuitry, it still relies on exceptions internally and part of the sources\n    to handle to exceptions are shared with the run-time library.  We need\n    dummy definitions for the wrappers to satisfy the linker in this case."}, {"sha": "88c0fc005fad6b5afbd83dbc25232ebe556a3ba5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -582,7 +582,7 @@ package body Sem_Ch13 is\n                   Mark_Aliased_Address_As_Volatile (Expr);\n \n                   --  Second case is where we have a constant whose\n-                  --  definition is of the form of an adress as in:\n+                  --  definition is of the form of an address as in:\n \n                   --     A : constant Address := K'Address;\n                   --     ..."}, {"sha": "055c99f1ad8bb570d28fce4d6c69efbab88b19c2", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -187,7 +187,7 @@ __gnat_ttyname (int filedes)\n     return NULL;\n }\n \n-/* This function is needed to fix a bug under Win95/98. Under these plateforms\n+/* This function is needed to fix a bug under Win95/98. Under these platforms\n    doing :\n                 ch1 = getch();\n \t\tch2 = fgetc (stdin);"}, {"sha": "08bca930f5ae2b929f61e17bbff909f5f549b8fb", "filename": "gcc/ada/targtyps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargtyps.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -89,7 +89,7 @@ get_target_char_size (void)\n Pos\n get_target_wchar_t_size (void)\n {\n-  /* We never want wide chacters less than \"short\" in Ada.  */\n+  /* We never want wide characters less than \"short\" in Ada.  */\n   return MAX (SHORT_TYPE_SIZE, WCHAR_TYPE_SIZE);\n }\n "}, {"sha": "3c782762b86d277f499916e2e30c74fd2cb3804e", "filename": "gcc/ada/tb-alvxw.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftb-alvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftb-alvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvxw.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -630,7 +630,7 @@ find_proc_desc (CORE_ADDR pc,\n {\n   CORE_ADDR startaddr;\n \n-  /* If heuristic_fence_post is non-zero, determine the procedure\n+  /* If heuristic_fence_post is nonzero, determine the procedure\n      start address by examining the instructions.\n      This allows us to find the start address of static functions which\n      have no symbolic information, as startaddr would have been set to"}, {"sha": "9c25d1ee4bfbd69874d423cf6c1c7793b0e1eb19", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -35,7 +35,7 @@\n    It has been tested on the following configurations:\n    PowerPC/AiX\n    PowerPC/VxWorks\n-   Sparc/Solaris\n+   SPARC/Solaris\n    i386/GNU/Linux\n    i386/Solaris\n    i386/NT\n@@ -187,7 +187,7 @@ extern void (*Unlock_Task) (void);\n \n    o FETCH_UP_FRAME, to force an invocation of __builtin_frame_address with a\n      positive argument right after a possibly forced call even if FRAME_LEVEL\n-     is 0. See the Sparc Solaris case for an example where this is useful.\n+     is 0. See the SPARC Solaris case for an example where this is useful.\n \n   */\n "}, {"sha": "b7b3598cef191ba7b319439e2f669814338ba5de", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -1510,7 +1510,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      we must turn a condition into the corresponding exception even if there\n      is no applicable Ada handler, and need at least one condition handler per\n      possible call chain involving GNAT code.  OTOH, establishing the handler\n-     has a cost so we want to mimize the number of subprograms into which this\n+     has a cost so we want to minimize the number of subprograms into which this\n      happens.  The foreign or exported condition is expected to satisfy all\n      the constraints.  */\n   if (TARGET_ABI_OPEN_VMS\n@@ -4829,7 +4829,7 @@ gnat_gimplify_stmt (tree *stmt_p)\n /* The reason for this routine's existence is two-fold.\n    First, with some debugging formats, notably MDEBUG on SGI\n    IRIX, the linker will remove duplicate debugging information if two\n-   clients have identical debugguing information.  With the normal scheme\n+   clients have identical debugging information.  With the normal scheme\n    of elaboration, this does not usually occur, since entities in with'ed\n    packages are elaborated on demand, and if clients have different usage\n    patterns, the normal case, then the order and selection of entities"}, {"sha": "1bdfacf09bcfbd113d5584c16ef17343559c0180", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=ce2e12c27eebde4eedb1b95f69cda8662bf9ee3d", "patch": "@@ -186,7 +186,7 @@ present_gnu_tree (Entity_Id gnat_entity)\n }\n \n \f\n-/* Return non-zero if we are currently in the global binding level.  */\n+/* Return nonzero if we are currently in the global binding level.  */\n \n int\n global_bindings_p (void)\n@@ -2874,15 +2874,15 @@ convert (tree type, tree expr)\n     case VIEW_CONVERT_EXPR:\n       {\n \t/* GCC 4.x is very sensitive to type consistency overall, and view\n-\t   conversions thus are very frequent.  Eventhough just \"convert\"ing\n+\t   conversions thus are very frequent.  Even though just \"convert\"ing\n \t   the inner operand to the output type is fine in most cases, it\n \t   might expose unexpected input/output type mismatches in special\n \t   circumstances so we avoid such recursive calls when we can.  */\n \n \ttree op0 = TREE_OPERAND (expr, 0);\n \n \t/* If we are converting back to the original type, we can just\n-\t   lift the input conversion.  This is a common occurence with\n+\t   lift the input conversion.  This is a common occurrence with\n \t   switches back-and-forth amongst type variants.  */\n \tif (type == TREE_TYPE (op0))\n \t  return op0;"}]}