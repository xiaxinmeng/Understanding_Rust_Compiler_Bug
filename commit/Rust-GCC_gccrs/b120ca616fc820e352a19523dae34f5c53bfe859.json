{"sha": "b120ca616fc820e352a19523dae34f5c53bfe859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyMGNhNjE2ZmM4MjBlMzUyYTE5NTIzZGFlMzRmNWM1M2JmZTg1OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-09-07T16:25:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-23T08:25:02Z"}, "message": "[Ada] Implement new legality rules introduced in C.6(12) by AI12-0363\n\ngcc/ada/\n\n\t* doc/gnat_rm/implementation_defined_pragmas.rst (VFA): Remove uage\n\trestrictions in conjunction with Atomic and Aliased.\n\t* gnat_rm.texi: Regenerate.\n\t* aspects.ads (Aspect_Id): Add Aspect_Full_Access_Only.\n\t(Is_Representation_Aspect): Likewise.\n\t(Aspect_Names): Likewise.\n\t(Aspect_Delay): Likewise.\n\t* einfo.ads (Is_Atomic_Or_VFA): Rename into...\n\t(Is_Full_Access): ...this.\n\t(Is_Volatile_Full_Access): Document new usage for Full_Access_Only.\n\t* einfo.adb (Is_Atomic_Or_VFA): Rename into...\n\t(Is_Full_Access): ...this.\n\t* freeze.ads (Is_Atomic_VFA_Aggregate): Rename into...\n\t(Is_Full_Access_Aggregate): ...this.\n\t* freeze.adb (Is_Atomic_VFA_Aggregate): Rename into...\n\t(Is_Full_Access_Aggregate): ...this.  Adjust to above renaming.\n\t(Freeze_Array_Type): Likewise.\n\t(Freeze_Entity): Likewise.\n\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Likewise.\n\t(Expand_Record_Aggregate): Likewise.\n\t* exp_ch4.adb (Expand_N_Op_Eq): Likewise.\n\t* exp_ch5.adb (Expand_Assign_Array): Likewise.\n\t* exp_ch8.adb (Evaluation_Required): Likewise.\n\t* layout.adb (Layout_Type): Likewise.\n\t(Set_Composite_Alignment): Likewise.\n\t* sem_aux.ads (Has_Rep_Item): Delete.\n\t* sem_aux.adb (Has_Rep_Item): Likewise.\n\t* sem_attr.adb (Resolve_Attribute) <Attribute_Access>: Implement\n\tnew legality rules in C.6(12).\n\t* sem_ch12.adb (Instantiate_Object): Likewise.\n\t* sem_res.adb (Resolve_Actuals): Likewise.\n\t* sem_ch13.adb (Inherit_Delayed_Rep_Aspects): Deal with aspect\n\tFull_Access_Only.\n\t(Check_False_Aspect_For_Derived_Type): Likewise.\n\t(Make_Pragma_From_Boolean_Aspect): Test for the presence of Expr.\n\tDeal with aspect Full_Access_Only.\n\t(Analyze_Aspects_At_Freeze_Point): Likewise.\n\t(Analyze_One_Aspect): Do not set Delay_Required to true even for\n\tAlways_Delay boolean aspects if they have no expression.  Force\n\tDelay_Required to true for aspect Full_Access_Only in all cases.\n\tReject aspect Full_Access_Only if not in Ada 2020 mode.\n\t(Check_Aspect_At_End_Of_Declarations): Deal with empty expression.\n\t(Check_Aspect_At_Freeze_Point): Likewise.\n\t(Rep_Item_Entity): Delete.\n\t(Inherit_Aspects_At_Freeze_Point): Align handling for Bit_Order\n\twith that for Scalar_Storage_Order.\n\t* sem_prag.adb (Check_Atomic_VFA): Delete.\n\t(Check_VFA_Conflicts): Likewise.\n\t(Check_Full_Access_Only): New procedure.\n\t(Process_Atomic_Independent_Shared_Volatile): Call to implement\n\tthe new legality checks in C.6(8/2) and mark the entity last.\n\t(Analyze_Pragma) <Pragma_Atomic_Components>: Remove obsolete check.\n\t* sem_util.ads (Is_Atomic_Or_VFA_Object): Rename into...\n\t(Is_Full_Access_Object): ...this.\n\t(Is_Subcomponent_Of_Atomic_Object): Rename into...\n\t(Is_Subcomponent_Of_Full_Access_Object): ...this.\n\t* sem_util.adb (Inherit_Rep_Item_Chain): Use Present_In_Rep_Item.\n\t(Is_Atomic_Or_VFA_Object): Rename into...\n\t(Is_Full_Access_Object): ...this.\n\t(Is_Subcomponent_Of_Atomic_Object): Rename into...\n\t(Is_Subcomponent_Of_Full_Access_Object): ...this and adjust.\n\t* snames.ads-tmpl (Name_Full_Access_Only): New name of aspect.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust for renaming.\n\t(promote_object_alignment): Likewise.\n\t(gnat_to_gnu_field): Likewise.  Rename local variable and use\n\tspecific qualifier in error message for Volatile_Full_Access.\n\t* gcc-interface/trans.c (lvalue_required_p): Likewise.", "tree": {"sha": "a1c3cdf69ff403e07cabb282d2f6643041a3bdc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1c3cdf69ff403e07cabb282d2f6643041a3bdc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b120ca616fc820e352a19523dae34f5c53bfe859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b120ca616fc820e352a19523dae34f5c53bfe859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b120ca616fc820e352a19523dae34f5c53bfe859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b120ca616fc820e352a19523dae34f5c53bfe859/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84a5809c7214d103dd2e7f5c352fd99cb8320bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a5809c7214d103dd2e7f5c352fd99cb8320bb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84a5809c7214d103dd2e7f5c352fd99cb8320bb3"}], "stats": {"total": 872, "additions": 393, "deletions": 479}, "files": [{"sha": "1470efebab931af6301fe1b8025ce69d5016df6c", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -188,6 +188,7 @@ package Aspects is\n       Aspect_Exclusive_Functions,\n       Aspect_Export,\n       Aspect_Favor_Top_Level,               -- GNAT\n+      Aspect_Full_Access_Only,\n       Aspect_Independent,\n       Aspect_Independent_Components,\n       Aspect_Import,\n@@ -554,6 +555,7 @@ package Aspects is\n       Aspect_Discard_Names                => True,\n       Aspect_Export                       => True,\n       Aspect_Favor_Top_Level              => False,\n+      Aspect_Full_Access_Only             => True,\n       Aspect_Independent                  => True,\n       Aspect_Independent_Components       => True,\n       Aspect_Import                       => True,\n@@ -634,6 +636,7 @@ package Aspects is\n       Aspect_External_Name                => Name_External_Name,\n       Aspect_External_Tag                 => Name_External_Tag,\n       Aspect_Favor_Top_Level              => Name_Favor_Top_Level,\n+      Aspect_Full_Access_Only             => Name_Full_Access_Only,\n       Aspect_Ghost                        => Name_Ghost,\n       Aspect_Global                       => Name_Global,\n       Aspect_Implicit_Dereference         => Name_Implicit_Dereference,\n@@ -976,6 +979,7 @@ package Aspects is\n       Aspect_Atomic_Components            => Rep_Aspect,\n       Aspect_Bit_Order                    => Rep_Aspect,\n       Aspect_Component_Size               => Rep_Aspect,\n+      Aspect_Full_Access_Only             => Rep_Aspect,\n       Aspect_Machine_Radix                => Rep_Aspect,\n       Aspect_Object_Size                  => Rep_Aspect,\n       Aspect_Pack                         => Rep_Aspect,"}, {"sha": "e1e6853e02cdede26d489c0dee5b145532b58d37", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -7285,12 +7285,6 @@ there is no guarantee that all the bits will be accessed if the reference\n is not to the whole object; the compiler is allowed (and generally will)\n access only part of the object in this case.\n \n-It is not permissible to specify ``Atomic`` and ``Volatile_Full_Access`` for\n-the same type or object.\n-\n-It is not permissible to specify ``Volatile_Full_Access`` for a composite\n-(record or array) type or object that has an ``Aliased`` subcomponent.\n-\n .. _Pragma-Volatile_Function:\n \n Pragma Volatile_Function"}, {"sha": "f39b3bcd1a13de4a8107bd43b0379d2b0f7ffc8d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -8046,15 +8046,6 @@ package body Einfo is\n       return Empty;\n    end Invariant_Procedure;\n \n-   ----------------------\n-   -- Is_Atomic_Or_VFA --\n-   ----------------------\n-\n-   function Is_Atomic_Or_VFA (Id : E) return B is\n-   begin\n-      return Is_Atomic (Id) or else Is_Volatile_Full_Access (Id);\n-   end Is_Atomic_Or_VFA;\n-\n    ------------------\n    -- Is_Base_Type --\n    ------------------\n@@ -8213,6 +8204,15 @@ package body Einfo is\n       return Ekind (Id) = E_Procedure and then Chars (Id) = Name_uFinalizer;\n    end Is_Finalizer;\n \n+   ----------------------\n+   -- Is_Full_Access --\n+   ----------------------\n+\n+   function Is_Full_Access (Id : E) return B is\n+   begin\n+      return Is_Atomic (Id) or else Is_Volatile_Full_Access (Id);\n+   end Is_Full_Access;\n+\n    -------------------\n    -- Is_Null_State --\n    -------------------"}, {"sha": "be195ab23c5c7ec5aa7d6de7c0f4521716303181", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -2374,12 +2374,11 @@ package Einfo is\n --       In the case of private and incomplete types, this flag is set in\n --       both the partial view and the full view.\n \n---    Is_Atomic_Or_VFA (synth)\n+--    Is_Full_Access (synth)\n --       Defined in all type entities, and also in constants, components and\n---       variables. Set if a pragma Atomic or Shared or Volatile_Full_Access\n---       applies to the entity. For many purposes VFA objects should be treated\n---       the same as Atomic objects, and this predicate is intended for that\n---       usage. In the case of private and incomplete types, the predicate\n+--       variables. Set if an aspect/pragma Atomic/Shared, or an aspect/pragma\n+--       Volatile_Full_Access or an Ada 2020 aspect Full_Access_Only applies\n+--       to the entity. In the case of private and incomplete types, the flag\n --       applies to both the partial view and the full view.\n \n --    Is_Base_Type (synthesized)\n@@ -3418,9 +3417,10 @@ package Einfo is\n \n --    Is_Volatile_Full_Access (Flag285)\n --       Defined in all type entities, and also in constants, components, and\n---       variables. Set if a pragma Volatile_Full_Access applies to the entity.\n---       In the case of private and incomplete types, this flag is set in\n---       both the partial view and the full view.\n+--       variables. Set if an aspect/pragma Volatile_Full_Access or an Ada 2020\n+--       aspect Full_Access_Only applies to the entity. In the case of private\n+--       and incomplete types, this flag is set in both the partial view and\n+--       the full view.\n \n --    Is_Wrapper_Package (synthesized)\n --       Defined in package entities. Indicates that the package has been\n@@ -5815,7 +5815,7 @@ package Einfo is\n    --    Implementation_Base_Type            (synth)\n    --    Invariant_Procedure                 (synth)\n    --    Is_Access_Protected_Subprogram_Type (synth)\n-   --    Is_Atomic_Or_VFA                    (synth)\n+   --    Is_Full_Access                      (synth)\n    --    Is_Controlled                       (synth)\n    --    Object_Size_Clause                  (synth)\n    --    Partial_Invariant_Procedure         (synth)\n@@ -5982,7 +5982,7 @@ package Einfo is\n    --    Is_Volatile                         (Flag16)\n    --    Is_Volatile_Full_Access             (Flag285)\n    --    Treat_As_Volatile                   (Flag41)\n-   --    Is_Atomic_Or_VFA                    (synth)\n+   --    Is_Full_Access                      (synth)\n    --    Next_Component                      (synth)\n    --    Next_Component_Or_Discriminant      (synth)\n \n@@ -6036,8 +6036,8 @@ package Einfo is\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n-   --    Is_Atomic_Or_VFA                    (synth)\n    --    Is_Elaboration_Target               (synth)\n+   --    Is_Full_Access                      (synth)\n    --    Size_Clause                         (synth)\n \n    --  E_Decimal_Fixed_Point_Type\n@@ -6856,8 +6856,8 @@ package Einfo is\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n-   --    Is_Atomic_Or_VFA                    (synth)\n    --    Is_Elaboration_Target               (synth)\n+   --    Is_Full_Access                      (synth)\n    --    Size_Clause                         (synth)\n \n    --  E_Void\n@@ -7677,7 +7677,6 @@ package Einfo is\n    function Has_Null_Abstract_State             (Id : E) return B;\n    function Has_Null_Visible_Refinement         (Id : E) return B;\n    function Implementation_Base_Type            (Id : E) return E;\n-   function Is_Atomic_Or_VFA                    (Id : E) return B;\n    function Is_Base_Type                        (Id : E) return B;\n    function Is_Boolean_Type                     (Id : E) return B;\n    function Is_Constant_Object                  (Id : E) return B;\n@@ -7687,6 +7686,7 @@ package Einfo is\n    function Is_Elaboration_Target               (Id : E) return B;\n    function Is_External_State                   (Id : E) return B;\n    function Is_Finalizer                        (Id : E) return B;\n+   function Is_Full_Access                      (Id : E) return B;\n    function Is_Null_State                       (Id : E) return B;\n    function Is_Package_Or_Generic_Package       (Id : E) return B;\n    function Is_Packed_Array                     (Id : E) return B;\n@@ -8889,7 +8889,6 @@ package Einfo is\n    pragma Inline (Is_Assignable);\n    pragma Inline (Is_Asynchronous);\n    pragma Inline (Is_Atomic);\n-   pragma Inline (Is_Atomic_Or_VFA);\n    pragma Inline (Is_Bit_Packed_Array);\n    pragma Inline (Is_Called);\n    pragma Inline (Is_Character_Type);\n@@ -8940,6 +8939,7 @@ package Einfo is\n    pragma Inline (Is_Formal_Object);\n    pragma Inline (Is_Formal_Subprogram);\n    pragma Inline (Is_Frozen);\n+   pragma Inline (Is_Full_Access);\n    pragma Inline (Is_Generic_Actual_Subprogram);\n    pragma Inline (Is_Generic_Actual_Type);\n    pragma Inline (Is_Generic_Instance);"}, {"sha": "469777f1b09116f400fd3c5dd3dc97669f8ab95d", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -426,6 +426,8 @@ package body Exp_Aggr is\n          return Nkind (First (Assoc)) /= N_Iterated_Component_Association;\n       end Is_OK_Aggregate;\n \n+   --  Start of processing for Aggr_Assignment_OK_For_Backend\n+\n    begin\n       --  Back end doesn't know about <>\n \n@@ -474,7 +476,7 @@ package body Exp_Aggr is\n          Csiz := Component_Size (Ctyp);\n          Ctyp := Component_Type (Ctyp);\n \n-         if Is_Atomic_Or_VFA (Ctyp) then\n+         if Is_Full_Access (Ctyp) then\n             return False;\n          end if;\n       end loop;\n@@ -8289,13 +8291,13 @@ package body Exp_Aggr is\n    --  Start of processing for Expand_Record_Aggregate\n \n    begin\n-      --  If the aggregate is to be assigned to an atomic/VFA variable, we have\n+      --  If the aggregate is to be assigned to a full access variable, we have\n       --  to prevent a piecemeal assignment even if the aggregate is to be\n       --  expanded. We create a temporary for the aggregate, and assign the\n       --  temporary instead, so that the back end can generate an atomic move\n       --  for it.\n \n-      if Is_Atomic_VFA_Aggregate (N) then\n+      if Is_Full_Access_Aggregate (N) then\n          return;\n \n       --  No special management required for aggregates used to initialize"}, {"sha": "4d5486057aa6f9e0ea105e5d5b6b861069fc577e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -8334,12 +8334,12 @@ package body Exp_Ch4 is\n          --  Where the component type is elementary we can use a block bit\n          --  comparison (if supported on the target) exception in the case\n          --  of floating-point (negative zero issues require element by\n-         --  element comparison), and atomic/VFA types (where we must be sure\n+         --  element comparison), and full access types (where we must be sure\n          --  to load elements independently) and possibly unaligned arrays.\n \n          elsif Is_Elementary_Type (Component_Type (Typl))\n            and then not Is_Floating_Point_Type (Component_Type (Typl))\n-           and then not Is_Atomic_Or_VFA (Component_Type (Typl))\n+           and then not Is_Full_Access (Component_Type (Typl))\n            and then not Is_Possibly_Unaligned_Object (Lhs)\n            and then not Is_Possibly_Unaligned_Slice (Lhs)\n            and then not Is_Possibly_Unaligned_Object (Rhs)"}, {"sha": "85b5bb8c38aecafda32f497de912629126b994f8", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -523,11 +523,11 @@ package body Exp_Ch5 is\n       elsif Has_Controlled_Component (L_Type) then\n          Loop_Required := True;\n \n-      --  If object is atomic/VFA, we cannot tolerate a loop\n+      --  If object is full access, we cannot tolerate a loop\n \n-      elsif Is_Atomic_Or_VFA_Object (Act_Lhs)\n+      elsif Is_Full_Access_Object (Act_Lhs)\n               or else\n-            Is_Atomic_Or_VFA_Object (Act_Rhs)\n+            Is_Full_Access_Object (Act_Rhs)\n       then\n          return;\n \n@@ -536,8 +536,8 @@ package body Exp_Ch5 is\n \n       elsif Has_Atomic_Components (L_Type)\n         or else Has_Atomic_Components (R_Type)\n-        or else Is_Atomic_Or_VFA (Component_Type (L_Type))\n-        or else Is_Atomic_Or_VFA (Component_Type (R_Type))\n+        or else Is_Full_Access (Component_Type (L_Type))\n+        or else Is_Full_Access (Component_Type (R_Type))\n       then\n          Loop_Required := True;\n "}, {"sha": "9f4c65c89bad65ff236fcb07e5e5bfcb5fa8d7be", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -129,7 +129,7 @@ package body Exp_Ch8 is\n             if Is_Packed (Etype (Prefix (Nam))) then\n                return True;\n \n-            elsif Is_Atomic_Or_VFA_Object (Prefix (Nam)) then\n+            elsif Is_Full_Access_Object (Prefix (Nam)) then\n                return True;\n \n             else\n@@ -152,7 +152,7 @@ package body Exp_Ch8 is\n                then\n                   return True;\n \n-               elsif Is_Atomic_Or_VFA_Object (Prefix (Nam)) then\n+               elsif Is_Full_Access_Object (Prefix (Nam)) then\n                   return True;\n \n                else"}, {"sha": "f3abba1538d15dbd0c0016ebb68b9d1579e8cad7", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -1737,11 +1737,11 @@ package body Freeze is\n       end loop;\n    end Check_Unsigned_Type;\n \n-   -----------------------------\n-   -- Is_Atomic_VFA_Aggregate --\n-   -----------------------------\n+   ------------------------------\n+   -- Is_Full_Access_Aggregate --\n+   ------------------------------\n \n-   function Is_Atomic_VFA_Aggregate (N : Node_Id) return Boolean is\n+   function Is_Full_Access_Aggregate (N : Node_Id) return Boolean is\n       Loc   : constant Source_Ptr := Sloc (N);\n       New_N : Node_Id;\n       Par   : Node_Id;\n@@ -1765,18 +1765,18 @@ package body Freeze is\n          when N_Assignment_Statement =>\n             Typ := Etype (Name (Par));\n \n-            if not Is_Atomic_Or_VFA (Typ)\n+            if not Is_Full_Access (Typ)\n               and then not (Is_Entity_Name (Name (Par))\n-                             and then Is_Atomic_Or_VFA (Entity (Name (Par))))\n+                             and then Is_Full_Access (Entity (Name (Par))))\n             then\n                return False;\n             end if;\n \n          when N_Object_Declaration =>\n             Typ := Etype (Defining_Identifier (Par));\n \n-            if not Is_Atomic_Or_VFA (Typ)\n-              and then not Is_Atomic_Or_VFA (Defining_Identifier (Par))\n+            if not Is_Full_Access (Typ)\n+              and then not Is_Full_Access (Defining_Identifier (Par))\n             then\n                return False;\n             end if;\n@@ -1797,7 +1797,7 @@ package body Freeze is\n \n       Set_Expression (Par, New_Occurrence_Of (Temp, Loc));\n       return True;\n-   end Is_Atomic_VFA_Aggregate;\n+   end Is_Full_Access_Aggregate;\n \n    -----------------------------------------------\n    -- Explode_Initialization_Compound_Statement --\n@@ -2639,21 +2639,21 @@ package body Freeze is\n                end;\n             end if;\n \n-            --  Check for Aliased or Atomic_Components/Atomic/VFA with\n+            --  Check for Aliased or Atomic_Components or Full Access with\n             --  unsuitable packing or explicit component size clause given.\n \n             if (Has_Aliased_Components (Arr)\n                  or else Has_Atomic_Components (Arr)\n-                 or else Is_Atomic_Or_VFA (Ctyp))\n+                 or else Is_Full_Access (Ctyp))\n               and then\n                 (Has_Component_Size_Clause (Arr) or else Is_Packed (Arr))\n             then\n                Alias_Atomic_Check : declare\n \n                   procedure Complain_CS (T : String);\n                   --  Outputs error messages for incorrect CS clause or pragma\n-                  --  Pack for aliased or atomic/VFA components (T is \"aliased\"\n-                  --  or \"atomic/vfa\");\n+                  --  Pack for aliased or full access components (T is either\n+                  --  \"aliased\" or \"atomic\" or \"volatile full access\");\n \n                   -----------------\n                   -- Complain_CS --\n@@ -5518,11 +5518,11 @@ package body Freeze is\n          --  than component-wise (the assignment to the temp may be done\n          --  component-wise, but that is harmless).\n \n-         elsif Is_Atomic_Or_VFA (E)\n+         elsif Is_Full_Access (E)\n            and then Nkind (Parent (E)) = N_Object_Declaration\n            and then Present (Expression (Parent (E)))\n            and then Nkind (Expression (Parent (E))) = N_Aggregate\n-           and then Is_Atomic_VFA_Aggregate (Expression (Parent (E)))\n+           and then Is_Full_Access_Aggregate (Expression (Parent (E)))\n          then\n             null;\n          end if;"}, {"sha": "448d1edb14f8932120b966208f1f05b773fc9628", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -174,8 +174,8 @@ package Freeze is\n    --  do not allow a size clause if the size would not otherwise be known at\n    --  compile time in any case.\n \n-   function Is_Atomic_VFA_Aggregate (N : Node_Id) return Boolean;\n-   --  If an atomic/VFA object is initialized with an aggregate or is assigned\n+   function Is_Full_Access_Aggregate (N : Node_Id) return Boolean;\n+   --  If a full access object is initialized with an aggregate or is assigned\n    --  an aggregate, we have to prevent a piecemeal access or assignment to the\n    --  object, even if the aggregate is to be expanded. We create a temporary\n    --  for the aggregate, and assign the temporary instead, so that the back"}, {"sha": "4e6dc84beea382e71cb340adb5cdddf3dbb7b1a6", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -896,13 +896,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  gnu_size = bitsize_unit_node;\n \n \t/* If this is an object with no specified size and alignment, and\n-\t   if either it is atomic or we are not optimizing alignment for\n+\t   if either it is full access or we are not optimizing alignment for\n \t   space and it is composite and not an exception, an Out parameter\n \t   or a reference to another object, and the size of its type is a\n \t   constant, set the alignment to the smallest one which is not\n \t   smaller than the size, with an appropriate cap.  */\n \tif (!gnu_size && align == 0\n-\t    && (Is_Atomic_Or_VFA (gnat_entity)\n+\t    && (Is_Full_Access (gnat_entity)\n \t\t|| (!Optimize_Alignment_Space (gnat_entity)\n \t\t    && kind != E_Exception\n \t\t    && kind != E_Out_Parameter\n@@ -1014,7 +1014,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  }\n \n \t/* Now check if the type of the object allows atomic access.  */\n-\tif (Is_Atomic_Or_VFA (gnat_entity))\n+\tif (Is_Full_Access (gnat_entity))\n \t  check_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n \t/* If this is a renaming, avoid as much as possible to create a new\n@@ -2876,7 +2876,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t{\n \t\t  const int quals\n \t\t    = TYPE_QUAL_VOLATILE\n-\t\t      | (Is_Atomic_Or_VFA (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n+\t\t      | (Is_Full_Access (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n \t\t  gnu_type = change_qualified_type (gnu_type, quals);\n \t\t}\n \t      /* Make it artificial only if the base type was artificial too.\n@@ -4362,12 +4362,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t       gnat_entity);\n \t    }\n \t}\n-      else if (Is_Atomic_Or_VFA (gnat_entity) && !gnu_size\n+      else if (Is_Full_Access (gnat_entity) && !gnu_size\n \t       && tree_fits_uhwi_p (TYPE_SIZE (gnu_type))\n \t       && integer_pow2p (TYPE_SIZE (gnu_type)))\n \talign = MIN (BIGGEST_ALIGNMENT,\n \t\t     tree_to_uhwi (TYPE_SIZE (gnu_type)));\n-      else if (Is_Atomic_Or_VFA (gnat_entity) && gnu_size\n+      else if (Is_Full_Access (gnat_entity) && gnu_size\n \t       && tree_fits_uhwi_p (gnu_size)\n \t       && integer_pow2p (gnu_size))\n \talign = MIN (BIGGEST_ALIGNMENT, tree_to_uhwi (gnu_size));\n@@ -4603,7 +4603,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \n       /* Now check if the type allows atomic access.  */\n-      if (Is_Atomic_Or_VFA (gnat_entity))\n+      if (Is_Full_Access (gnat_entity))\n \tcheck_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n       /* If this is not an unconstrained array type, set some flags.  */\n@@ -4721,7 +4721,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t{\n \t  const int quals\n \t    = TYPE_QUAL_VOLATILE\n-\t      | (Is_Atomic_Or_VFA (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n+\t      | (Is_Full_Access (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n \t  gnu_type = change_qualified_type (gnu_type, quals);\n \t}\n \n@@ -5250,7 +5250,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n     }\n \n   /* Now check if the type of the component allows atomic access.  */\n-  if (Has_Atomic_Components (gnat_array) || Is_Atomic_Or_VFA (gnat_type))\n+  if (Has_Atomic_Components (gnat_array) || Is_Full_Access (gnat_type))\n     check_ok_for_atomic_type (gnu_type, gnat_array, true);\n \n   /* If the component type is a padded type made for a non-bit-packed array\n@@ -7105,9 +7105,9 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   const Entity_Id gnat_field_type = Etype (gnat_field);\n   tree gnu_field_type = gnat_to_gnu_type (gnat_field_type);\n   tree gnu_field_id = get_entity_name (gnat_field);\n-  const bool is_atomic\n-    = (Is_Atomic_Or_VFA (gnat_field) || Is_Atomic_Or_VFA (gnat_field_type));\n   const bool is_aliased = Is_Aliased (gnat_field);\n+  const bool is_full_access\n+    = (Is_Full_Access (gnat_field) || Is_Full_Access (gnat_field_type));\n   const bool is_independent\n     = (Is_Independent (gnat_field) || Is_Independent (gnat_field_type));\n   const bool is_volatile\n@@ -7122,7 +7122,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n      only constraint is the implementation advice whereby only the bits of\n      the components should be accessed if they both start and end on byte\n      boundaries, but that should be guaranteed by the GCC memory model.\n-     Note that we have some redundancies (is_atomic => is_independent,\n+     Note that we have some redundancies (is_full_access => is_independent,\n      is_aliased => is_independent and is_by_ref => is_strict_alignment)\n      so the following formula is sufficient.  */\n   const bool needs_strict_alignment = (is_independent || is_strict_alignment);\n@@ -7131,10 +7131,16 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   bool is_bitfield;\n \n   /* The qualifier to be used in messages.  */\n-  if (is_atomic)\n-    field_s = \"atomic&\";\n-  else if (is_aliased)\n+  if (is_aliased)\n     field_s = \"aliased&\";\n+  else if (is_full_access)\n+    {\n+      if (Is_Volatile_Full_Access (gnat_field)\n+\t  || Is_Volatile_Full_Access (gnat_field_type))\n+\tfield_s = \"volatile full access&\";\n+      else\n+\tfield_s = \"atomic&\";\n+    }\n   else if (is_independent)\n     field_s = \"independent&\";\n   else if (is_by_ref)\n@@ -7145,7 +7151,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     field_s = \"&\";\n \n   /* The message to be used for incompatible size.  */\n-  if (is_atomic || is_aliased)\n+  if (is_aliased || is_full_access)\n     size_s = \"size for %s must be ^\";\n   else if (field_s)\n     size_s = \"size for %s too small{, minimum allowed is ^}\";\n@@ -7237,7 +7243,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     }\n \n   /* Now check if the type of the field allows atomic access.  */\n-  if (Is_Atomic_Or_VFA (gnat_field))\n+  if (Is_Full_Access (gnat_field))\n     {\n       const unsigned int align\n \t= promote_object_alignment (gnu_field_type, gnat_field);\n@@ -7333,7 +7339,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t      /* If the size is lower than that of the type, or greater for\n \t\t atomic and aliased, then error out and reset the size.  */\n \t      else if ((cmp = tree_int_cst_compare (gnu_size, type_size)) < 0\n-\t\t       || (cmp > 0 && (is_atomic || is_aliased)))\n+\t\t       || (cmp > 0 && (is_aliased || is_full_access)))\n \t\t{\n \t\t  char s[128];\n \t\t  snprintf (s, sizeof (s), size_s, field_s);\n@@ -9278,8 +9284,8 @@ promote_object_alignment (tree gnu_type, Entity_Id gnat_entity)\n      the NRV optimization for it.  No point in jumping through all the hoops\n      needed in order to support BIGGEST_ALIGNMENT if we don't really have to.\n      So we cap to the smallest alignment that corresponds to a known efficient\n-     memory access pattern, except for Atomic and Volatile_Full_Access.  */\n-  if (Is_Atomic_Or_VFA (gnat_entity))\n+     memory access pattern, except for a full access entity.  */\n+  if (Is_Full_Access (gnat_entity))\n     {\n       size_cap = UINT_MAX;\n       align_cap = BIGGEST_ALIGNMENT;"}, {"sha": "059e1a4f6775d4352b4ce296ebde30a7f3214f7e", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -901,7 +901,7 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t the actual assignment might end up being done component-wise.  */\n       return (!constant\n \t      ||(Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n-\t\t && Is_Atomic_Or_VFA (Defining_Entity (gnat_parent)))\n+\t\t && Is_Full_Access (Defining_Entity (gnat_parent)))\n \t      /* We don't use a constructor if this is a class-wide object\n \t\t because the effective type of the object is the equivalent\n \t\t type of the class-wide subtype and it smashes most of the\n@@ -916,7 +916,7 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t      || Name (gnat_parent) == gnat_node\n \t      || (Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n \t\t  && Is_Entity_Name (Name (gnat_parent))\n-\t\t  && Is_Atomic_Or_VFA (Entity (Name (gnat_parent)))));\n+\t\t  && Is_Full_Access (Entity (Name (gnat_parent)))));\n \n     case N_Unchecked_Type_Conversion:\n \tif (!constant)"}, {"sha": "e1a5568549f6cc03a9bda41f1c171ff3d03b6153", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -8776,12 +8776,6 @@ there is no guarantee that all the bits will be accessed if the reference\n is not to the whole object; the compiler is allowed (and generally will)\n access only part of the object in this case.\n \n-It is not permissible to specify @code{Atomic} and @code{Volatile_Full_Access} for\n-the same type or object.\n-\n-It is not permissible to specify @code{Volatile_Full_Access} for a composite\n-(record or array) type or object that has an @code{Aliased} subcomponent.\n-\n @node Pragma Volatile_Function,Pragma Warning_As_Error,Pragma Volatile_Full_Access,Implementation Defined Pragmas\n @anchor{gnat_rm/implementation_defined_pragmas id56}@anchor{11a}@anchor{gnat_rm/implementation_defined_pragmas pragma-volatile-function}@anchor{11b}\n @section Pragma Volatile_Function"}, {"sha": "ad808495e604707f070dc3c77bd0793c3f1d6639", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -470,7 +470,7 @@ package body Layout is\n \n          --  For non-packed arrays set the alignment of the array to the\n          --  alignment of the component type if it is unknown. Skip this\n-         --  in atomic/VFA case since a larger alignment may be needed.\n+         --  in full access case since a larger alignment may be needed.\n \n          if Is_Array_Type (E)\n            and then not Is_Packed (E)\n@@ -479,7 +479,7 @@ package body Layout is\n            and then Known_Static_Component_Size (E)\n            and then Known_Static_Esize (Component_Type (E))\n            and then Component_Size (E) = Esize (Component_Type (E))\n-           and then not Is_Atomic_Or_VFA (E)\n+           and then not Is_Full_Access (E)\n          then\n             Set_Alignment (E, Alignment (Component_Type (E)));\n          end if;\n@@ -505,11 +505,11 @@ package body Layout is\n \n       elsif Is_Array_Type (E) then\n \n-         --  For arrays that are required to be atomic/VFA, we do the same\n-         --  processing as described above for short records, since we\n-         --  really need to have the alignment set for the whole array.\n+         --  For arrays that are required to be full access, we do the same\n+         --  processing as described above for short records, since we really\n+         --  need to have the alignment set for the whole array.\n \n-         if Is_Atomic_Or_VFA (E) and then not Debug_Flag_Q then\n+         if Is_Full_Access (E) and then not Debug_Flag_Q then\n             Set_Composite_Alignment (E);\n          end if;\n \n@@ -615,9 +615,9 @@ package body Layout is\n         and then Is_Record_Type (E)\n         and then Is_Packed (E)\n       then\n-         --  No effect for record with atomic/VFA components\n+         --  No effect for record with full access components\n \n-         if Is_Atomic_Or_VFA (E) then\n+         if Is_Full_Access (E) then\n             Error_Msg_N (\"Optimize_Alignment has no effect for &??\", E);\n \n             if Is_Atomic (E) then\n@@ -640,7 +640,7 @@ package body Layout is\n             return;\n          end if;\n \n-         --  No effect if any component is atomic/VFA or is a by-reference type\n+         --  No effect if a component is full access or of a by-reference type\n \n          declare\n             Ent : Entity_Id;\n@@ -649,8 +649,8 @@ package body Layout is\n             Ent := First_Component_Or_Discriminant (E);\n             while Present (Ent) loop\n                if Is_By_Reference_Type (Etype (Ent))\n-                 or else Is_Atomic_Or_VFA (Etype (Ent))\n-                 or else Is_Atomic_Or_VFA (Ent)\n+                 or else Is_Full_Access (Etype (Ent))\n+                 or else Is_Full_Access (Ent)\n                then\n                   Error_Msg_N (\"Optimize_Alignment has no effect for &??\", E);\n \n@@ -660,7 +660,7 @@ package body Layout is\n                         & \"components present??\", E);\n                   else\n                      Error_Msg_N\n-                       (\"\\pragma is ignored if bolatile full access \"\n+                       (\"\\pragma is ignored if volatile full access \"\n                         & \"components present??\", E);\n                   end if;\n \n@@ -756,9 +756,9 @@ package body Layout is\n \n       --  Further processing for record types only to reduce the alignment\n       --  set by the above processing in some specific cases. We do not\n-      --  do this for atomic/VFA records, since we need max alignment there,\n+      --  do this for full access records, since we need max alignment there,\n \n-      if Is_Record_Type (E) and then not Is_Atomic_Or_VFA (E) then\n+      if Is_Record_Type (E) and then not Is_Full_Access (E) then\n \n          --  For records, there is generally no point in setting alignment\n          --  higher than word size since we cannot do better than move by"}, {"sha": "104796f1f8046a0235c7e52bdf04e9a415366220", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -11505,7 +11505,7 @@ package body Sem_Attr is\n \n             Set_Etype (N, Btyp);\n \n-            --  Check for incorrect atomic/volatile reference (RM C.6(12))\n+            --  Check for incorrect atomic/volatile/VFA reference (RM C.6(12))\n \n             if Attr_Id /= Attribute_Unrestricted_Access then\n                if Is_Atomic_Object (P)\n@@ -11521,6 +11521,27 @@ package body Sem_Attr is\n                   Error_Msg_F\n                     (\"access to volatile object cannot yield access-to-\" &\n                      \"non-volatile type\", P);\n+\n+               elsif Is_Volatile_Full_Access_Object (P)\n+                 and then not Is_Volatile_Full_Access (Designated_Type (Typ))\n+               then\n+                  Error_Msg_F\n+                    (\"access to full access object cannot yield access-to-\" &\n+                     \"non-full-access type\", P);\n+               end if;\n+\n+               --  Check for nonatomic subcomponent of a full access object\n+               --  in Ada 2020 (RM C.6 (12)).\n+\n+               if Ada_Version >= Ada_2020\n+                 and then Is_Subcomponent_Of_Full_Access_Object (P)\n+                 and then not Is_Atomic_Object (P)\n+               then\n+                  Error_Msg_NE\n+                    (\"cannot have access attribute with prefix &\", N, P);\n+                  Error_Msg_N\n+                    (\"\\nonatomic subcomponent of full access object \"\n+                     & \"(RM C.6(12))\", N);\n                end if;\n             end if;\n "}, {"sha": "36fd6ad0987bd9584555150f073fb6430f62301a", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -704,29 +704,6 @@ package body Sem_Aux is\n       return Present (Get_Rep_Item (E, Nam1, Nam2, Check_Parents));\n    end Has_Rep_Item;\n \n-   function Has_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean is\n-      Item : Node_Id;\n-\n-   begin\n-      pragma Assert\n-        (Nkind (N) in N_Aspect_Specification\n-                    | N_Attribute_Definition_Clause\n-                    | N_Enumeration_Representation_Clause\n-                    | N_Pragma\n-                    | N_Record_Representation_Clause);\n-\n-      Item := First_Rep_Item (E);\n-      while Present (Item) loop\n-         if Item = N then\n-            return True;\n-         end if;\n-\n-         Next_Rep_Item (Item);\n-      end loop;\n-\n-      return False;\n-   end Has_Rep_Item;\n-\n    --------------------\n    -- Has_Rep_Pragma --\n    --------------------"}, {"sha": "1d820458a368acaf6cf6c715d4569312659c439d", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -240,10 +240,6 @@ package Sem_Aux is\n    --  not inherited from its parents, if any). If found then True is returned,\n    --  otherwise False indicates that no matching entry was found.\n \n-   function Has_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean;\n-   --  Determine whether the Rep_Item chain of arbitrary entity E contains item\n-   --  N. N must denote a valid rep item.\n-\n    function Has_Rep_Pragma\n      (E             : Entity_Id;\n       Nam           : Name_Id;"}, {"sha": "06b3bec3b5c5d6442ba585d3e0c12d64b6951bdf", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -11379,8 +11379,8 @@ package body Sem_Ch12 is\n \n          Note_Possible_Modification (Actual, Sure => True);\n \n-         --  Check for instantiation with atomic/volatile object actual for\n-         --  nonatomic/nonvolatile formal (RM C.6 (12)).\n+         --  Check for instantiation with atomic/volatile/VFA object actual for\n+         --  nonatomic/nonvolatile/nonVFA formal (RM C.6 (12)).\n \n          if Is_Atomic_Object (Actual) and then not Is_Atomic (Orig_Ftyp) then\n             Error_Msg_NE\n@@ -11394,20 +11394,29 @@ package body Sem_Ch12 is\n               (\"cannot instantiate nonvolatile formal & of mode in out\",\n                Actual, Gen_Obj);\n             Error_Msg_N (\"\\with volatile object actual (RM C.6(12))\", Actual);\n+\n+         elsif Is_Volatile_Full_Access_Object (Actual)\n+           and then not Is_Volatile_Full_Access (Orig_Ftyp)\n+         then\n+            Error_Msg_NE\n+              (\"cannot instantiate nonfull access formal & of mode in out\",\n+               Actual, Gen_Obj);\n+            Error_Msg_N\n+              (\"\\with full access object actual (RM C.6(12))\", Actual);\n          end if;\n \n-         --  Check for instantiation on nonatomic subcomponent of an atomic\n-         --  object in Ada 2020 (RM C.6 (13)).\n+         --  Check for instantiation on nonatomic subcomponent of a full access\n+         --  object in Ada 2020 (RM C.6 (12)).\n \n          if Ada_Version >= Ada_2020\n-            and then Is_Subcomponent_Of_Atomic_Object (Actual)\n+            and then Is_Subcomponent_Of_Full_Access_Object (Actual)\n             and then not Is_Atomic_Object (Actual)\n          then\n             Error_Msg_NE\n               (\"cannot instantiate formal & of mode in out with actual\",\n                Actual, Gen_Obj);\n             Error_Msg_N\n-              (\"\\nonatomic subcomponent of atomic object (RM C.6(13))\",\n+              (\"\\nonatomic subcomponent of full access object (RM C.6(12))\",\n                Actual);\n          end if;\n \n@@ -12699,15 +12708,15 @@ package body Sem_Ch12 is\n \n             if Is_Volatile (A_Gen_T) and then not Is_Volatile (Act_T) then\n                Error_Msg_NE\n-                  (\"actual for& has different Volatile aspect\",\n-                    Actual, A_Gen_T);\n+                  (\"actual for& must have Volatile aspect\",\n+                   Actual, A_Gen_T);\n \n             elsif Is_Derived_Type (A_Gen_T)\n               and then Is_Volatile (A_Gen_T) /= Is_Volatile (Act_T)\n             then\n                Error_Msg_NE\n                   (\"actual for& has different Volatile aspect\",\n-                     Actual, A_Gen_T);\n+                   Actual, A_Gen_T);\n             end if;\n \n             --  We assume that an array type whose atomic component type"}, {"sha": "1a80b3aafec57ca26a90e5369703fdfa7be469b7", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 95, "deletions": 64, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -1210,9 +1210,11 @@ package body Sem_Ch13 is\n                            Set_Is_Volatile (E);\n                         end if;\n \n-                     --  Volatile_Full_Access\n+                     --  Volatile_Full_Access (also Full_Access_Only)\n \n-                     when Aspect_Volatile_Full_Access =>\n+                     when Aspect_Volatile_Full_Access\n+                        | Aspect_Full_Access_Only\n+                     =>\n                         if Is_Volatile_Full_Access (P) then\n                            Set_Is_Volatile_Full_Access (E);\n                         end if;\n@@ -1308,7 +1310,9 @@ package body Sem_Ch13 is\n                      return;\n                   end if;\n \n-               when Aspect_Volatile_Full_Access =>\n+               when Aspect_Volatile_Full_Access\n+                  | Aspect_Full_Access_Only\n+               =>\n                   if not Is_Volatile_Full_Access (Par) then\n                      return;\n                   end if;\n@@ -1326,23 +1330,28 @@ package body Sem_Ch13 is\n \n          --  Local variables\n \n-         Prag : Node_Id;\n+         Prag   : Node_Id;\n+         P_Name : Name_Id;\n \n       --  Start of processing for Make_Pragma_From_Boolean_Aspect\n \n       begin\n-         --  Note that we know Expr is present, because for a missing Expr\n-         --  argument, we knew it was True and did not need to delay the\n-         --  evaluation to the freeze point.\n-\n-         if Is_False (Static_Boolean (Expr)) then\n+         if Present (Expr) and then Is_False (Static_Boolean (Expr)) then\n             Check_False_Aspect_For_Derived_Type;\n \n          else\n+            --  There is no Full_Access_Only pragma so use VFA instead\n+\n+            if A_Name = Name_Full_Access_Only then\n+               P_Name := Name_Volatile_Full_Access;\n+            else\n+               P_Name := A_Name;\n+            end if;\n+\n             Prag :=\n               Make_Pragma (Loc,\n                 Pragma_Identifier            =>\n-                  Make_Identifier (Sloc (Ident), Chars (Ident)),\n+                  Make_Identifier (Sloc (Ident), P_Name),\n                 Pragma_Argument_Associations => New_List (\n                   Make_Pragma_Argument_Association (Sloc (Ident),\n                     Expression => New_Occurrence_Of (Ent, Sloc (Ident)))));\n@@ -1427,12 +1436,13 @@ package body Sem_Ch13 is\n                      --  Analyze_Aspect_Export_Import, but is not analyzed as\n                      --  the complete analysis must happen now.\n \n-                     if A_Id = Aspect_Export or else A_Id = Aspect_Import then\n-                        null;\n-\n-                     --  Otherwise create a corresponding pragma\n+                     --  Aspect Full_Access_Only must be analyzed last so that\n+                     --  aspects Volatile and Atomic, if any, are analyzed.\n \n-                     else\n+                     if A_Id /= Aspect_Export\n+                       and then A_Id /= Aspect_Import\n+                       and then A_Id /= Aspect_Full_Access_Only\n+                     then\n                         Make_Pragma_From_Boolean_Aspect (ASN);\n                      end if;\n \n@@ -1499,6 +1509,25 @@ package body Sem_Ch13 is\n          Next_Rep_Item (ASN);\n       end loop;\n \n+      --  Make a second pass for a Full_Access_Only entry\n+\n+      ASN := First_Rep_Item (E);\n+      while Present (ASN) loop\n+         if Nkind (ASN) = N_Aspect_Specification then\n+            exit when Entity (ASN) /= E;\n+\n+            if Get_Aspect_Id (ASN) = Aspect_Full_Access_Only then\n+               Make_Pragma_From_Boolean_Aspect (ASN);\n+               Ritem := Aspect_Rep_Item (ASN);\n+               if Present (Ritem) then\n+                  Analyze (Ritem);\n+               end if;\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (ASN);\n+      end loop;\n+\n       --  This is where we inherit delayed rep aspects from our parent. Note\n       --  that if we fell out of the above loop with ASN non-empty, it means\n       --  we hit an aspect for an entity other than E, and it must be the\n@@ -2683,6 +2712,7 @@ package body Sem_Ch13 is\n             is\n                Args  : List_Id := Pragma_Argument_Associations;\n                Aitem : Node_Id;\n+\n             begin\n                --  We should never get here if aspect was disabled\n \n@@ -2870,31 +2900,41 @@ package body Sem_Ch13 is\n \n             case Aspect_Delay (A_Id) is\n                when Always_Delay =>\n-                  Delay_Required := True;\n+                  --  For Boolean aspects, do not delay if no expression\n+\n+                  if A_Id in Boolean_Aspects | Library_Unit_Aspects then\n+                     Delay_Required := Present (Expr);\n+                  else\n+                     Delay_Required := True;\n+                  end if;\n \n                when Never_Delay =>\n                   Delay_Required := False;\n \n                when Rep_Aspect =>\n \n-                  --  If expression has the form of an integer literal, then\n-                  --  do not delay, since we know the value cannot change.\n-                  --  This optimization catches most rep clause cases.\n-\n-                  --  For Boolean aspects, don't delay if no expression\n+                  --  For Boolean aspects, do not delay if no expression except\n+                  --  for Full_Access_Only because we need to process it after\n+                  --  Volatile and Atomic, which can be independently delayed.\n \n-                  if A_Id in Boolean_Aspects and then No (Expr) then\n+                  if A_Id in Boolean_Aspects\n+                    and then A_Id /= Aspect_Full_Access_Only\n+                    and then No (Expr)\n+                  then\n                      Delay_Required := False;\n \n-                  --  For non-Boolean aspects, don't delay if integer literal\n+                  --  For non-Boolean aspects, if the expression has the form\n+                  --  of an integer literal, then do not delay, since we know\n+                  --  the value cannot change. This optimization catches most\n+                  --  rep clause cases.\n \n                   elsif A_Id not in Boolean_Aspects\n                     and then Present (Expr)\n                     and then Nkind (Expr) = N_Integer_Literal\n                   then\n                      Delay_Required := False;\n \n-                  --  For Alignment and various Size aspects, don't delay for\n+                  --  For Alignment and various Size aspects, do not delay for\n                   --  an attribute reference whose prefix is Standard, for\n                   --  example Standard'Maximum_Alignment or Standard'Word_Size.\n \n@@ -4491,6 +4531,15 @@ package body Sem_Ch13 is\n \n                      goto Continue;\n \n+                  --  Ada 202x (AI12-0363): Full_Access_Only\n+\n+                  elsif A_Id = Aspect_Full_Access_Only then\n+                     if Ada_Version < Ada_2020 then\n+                        Error_Msg_N\n+                          (\"aspect % is an Ada 202x feature\", Aspect);\n+                        Error_Msg_N (\"\\compile with -gnat2020\", Aspect);\n+                     end if;\n+\n                   --  Ada 202x (AI12-0075): static expression functions\n \n                   elsif A_Id = Aspect_Static then\n@@ -4525,10 +4574,9 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n-                  --  Cases where we do not delay, includes all cases where the\n-                  --  expression is missing other than the above cases.\n+                  --  Cases where we do not delay\n \n-                  if not Delay_Required or else No (Expr) then\n+                  if not Delay_Required then\n \n                      --  Exclude aspects Export and Import because their pragma\n                      --  syntax does not map directly to a Boolean aspect.\n@@ -4543,8 +4591,6 @@ package body Sem_Ch13 is\n                            Pragma_Name                  => Chars (Id));\n                      end if;\n \n-                     Delay_Required := False;\n-\n                   --  In general cases, the corresponding pragma/attribute\n                   --  definition clause will be inserted later at the freezing\n                   --  point, and we do not need to build it now.\n@@ -10447,7 +10493,10 @@ package body Sem_Ch13 is\n       Freeze_Expr : constant Node_Id := Expression (ASN);\n       --  Expression from call to Check_Aspect_At_Freeze_Point.\n \n-      T : constant Entity_Id := Etype (Original_Node (Freeze_Expr));\n+      T : constant Entity_Id :=\n+            (if Present (Freeze_Expr)\n+             then Etype (Original_Node (Freeze_Expr))\n+             else Empty);\n       --  Type required for preanalyze call. We use the original expression to\n       --  get the proper type, to prevent cascaded errors when the expression\n       --  is constant-folded.\n@@ -10591,12 +10640,12 @@ package body Sem_Ch13 is\n \n          Set_Parent (End_Decl_Expr, ASN);\n \n-         --  In a generic context the original  aspect expressions have not\n+         --  In a generic context the original aspect expressions have not\n          --  been preanalyzed, so do it now. There are no conformance checks\n          --  to perform in this case. As before, we have to make components\n          --  visible for aspects that may reference them.\n \n-         if No (T) then\n+         if Present (Freeze_Expr) and then No (T) then\n             if A_Id = Aspect_Dynamic_Predicate\n               or else A_Id = Aspect_Predicate\n               or else A_Id = Aspect_Priority\n@@ -10636,7 +10685,7 @@ package body Sem_Ch13 is\n \n          elsif A_Id = Aspect_Predicate_Failure then\n             Preanalyze_Spec_Expression (End_Decl_Expr, Standard_String);\n-         else\n+         elsif Present (End_Decl_Expr) then\n             Preanalyze_Spec_Expression (End_Decl_Expr, T);\n          end if;\n \n@@ -10926,7 +10975,9 @@ package body Sem_Ch13 is\n \n       --  Do the preanalyze call\n \n-      Preanalyze_Spec_Expression (Expression (ASN), T);\n+      if Present (Expression (ASN)) then\n+         Preanalyze_Spec_Expression (Expression (ASN), T);\n+      end if;\n    end Check_Aspect_At_Freeze_Point;\n \n    -----------------------------------\n@@ -13129,9 +13180,6 @@ package body Sem_Ch13 is\n       --  specification node whose correponding pragma (if any) is present in\n       --  the Rep Item chain of the entity it has been specified to.\n \n-      function Rep_Item_Entity (Rep_Item : Node_Id) return Entity_Id;\n-      --  Return the entity for which Rep_Item is specified\n-\n       --------------------------------------------------\n       -- Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item --\n       --------------------------------------------------\n@@ -13142,26 +13190,10 @@ package body Sem_Ch13 is\n       begin\n          return\n            Nkind (Rep_Item) = N_Pragma\n-             or else Present_In_Rep_Item\n-                       (Entity (Rep_Item), Aspect_Rep_Item (Rep_Item));\n+             or else\n+           Present_In_Rep_Item (Entity (Rep_Item), Aspect_Rep_Item (Rep_Item));\n       end Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item;\n \n-      ---------------------\n-      -- Rep_Item_Entity --\n-      ---------------------\n-\n-      function Rep_Item_Entity (Rep_Item : Node_Id) return Entity_Id is\n-      begin\n-         if Nkind (Rep_Item) = N_Aspect_Specification then\n-            return Entity (Rep_Item);\n-\n-         else\n-            pragma Assert\n-              (Nkind (Rep_Item) in N_Attribute_Definition_Clause | N_Pragma);\n-            return Entity (Name (Rep_Item));\n-         end if;\n-      end Rep_Item_Entity;\n-\n    --  Start of processing for Inherit_Aspects_At_Freeze_Point\n \n    begin\n@@ -13287,10 +13319,12 @@ package body Sem_Ch13 is\n          Set_Treat_As_Volatile (Typ);\n       end if;\n \n-      --  Volatile_Full_Access\n+      --  Volatile_Full_Access and Full_Access_Only\n \n       if not Has_Rep_Item (Typ, Name_Volatile_Full_Access, False)\n-        and then Has_Rep_Pragma (Typ, Name_Volatile_Full_Access)\n+        and then not Has_Rep_Item (Typ, Name_Full_Access_Only, False)\n+        and then (Has_Rep_Item (Typ, Name_Volatile_Full_Access)\n+                    or else Has_Rep_Item (Typ, Name_Full_Access_Only))\n         and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n                    (Get_Rep_Item (Typ, Name_Volatile_Full_Access))\n       then\n@@ -13347,23 +13381,20 @@ package body Sem_Ch13 is\n \n             --  Bit_Order\n \n-            if Is_Record_Type (Typ) then\n+            if Is_Record_Type (Typ) and then Typ = Bas_Typ then\n                if not Has_Rep_Item (Typ, Name_Bit_Order, False)\n                  and then Has_Rep_Item (Typ, Name_Bit_Order)\n                then\n                   Set_Reverse_Bit_Order (Bas_Typ,\n-                    Reverse_Bit_Order (Rep_Item_Entity\n-                      (Get_Rep_Item (Typ, Name_Bit_Order))));\n+                    Reverse_Bit_Order\n+                      (Implementation_Base_Type (Etype (Bas_Typ))));\n                end if;\n             end if;\n \n             --  Scalar_Storage_Order\n \n-            --  Note: the aspect is specified on a first subtype, but recorded\n-            --  in a flag of the base type!\n-\n             if (Is_Record_Type (Typ) or else Is_Array_Type (Typ))\n-                 and then Typ = Bas_Typ\n+              and then Typ = Bas_Typ\n             then\n                --  For a type extension, always inherit from parent; otherwise\n                --  inherit if no default applies. Note: we do not check for"}, {"sha": "4edb67dff330a3a46c0c615f8241b6c0bd958788", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 116, "deletions": 250, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -3944,10 +3944,6 @@ package body Sem_Prag is\n       procedure Check_At_Most_N_Arguments (N : Nat);\n       --  Check there are no more than N arguments present\n \n-      procedure Check_Atomic_VFA (E : Entity_Id; VFA : Boolean);\n-      --  Apply legality checks to type or object E subject to an Atomic aspect\n-      --  in Ada 2020 (RM C.6(13)) or to a Volatile_Full_Access aspect.\n-\n       procedure Check_Component\n         (Comp            : Node_Id;\n          UU_Typ          : Entity_Id;\n@@ -5627,165 +5623,6 @@ package body Sem_Prag is\n          end if;\n       end Check_At_Most_N_Arguments;\n \n-      ------------------------\n-      --  Check_Atomic_VFA  --\n-      ------------------------\n-\n-      procedure Check_Atomic_VFA (E : Entity_Id; VFA : Boolean) is\n-\n-         Aliased_Subcomponent : exception;\n-         --  Exception raised if an aliased subcomponent is found in E\n-\n-         Independent_Subcomponent : exception;\n-         --  Exception raised if an independent subcomponent is found in E\n-\n-         procedure Check_Subcomponents (Typ : Entity_Id);\n-         --  Apply checks to subcomponents for Atomic and Volatile_Full_Access\n-\n-         -------------------------\n-         -- Check_Subcomponents --\n-         -------------------------\n-\n-         procedure Check_Subcomponents (Typ : Entity_Id) is\n-            Comp : Entity_Id;\n-\n-         begin\n-            if Is_Array_Type (Typ) then\n-               Comp := Component_Type (Typ);\n-\n-               --  For Atomic we accept any atomic subcomponents\n-\n-               if not VFA\n-                 and then (Has_Atomic_Components (Typ)\n-                            or else Is_Atomic (Comp))\n-               then\n-                  null;\n-\n-               --  Give an error if the components are aliased\n-\n-               elsif Has_Aliased_Components (Typ)\n-                 or else Is_Aliased (Comp)\n-               then\n-                  raise Aliased_Subcomponent;\n-\n-               --  For VFA we accept non-aliased VFA subcomponents\n-\n-               elsif VFA\n-                 and then Is_Volatile_Full_Access (Comp)\n-               then\n-                  null;\n-\n-               --  Give an error if the components are independent\n-\n-               elsif Has_Independent_Components (Typ)\n-                  or else Is_Independent (Comp)\n-               then\n-                  raise Independent_Subcomponent;\n-               end if;\n-\n-               --  Recurse on the component type\n-\n-               Check_Subcomponents (Comp);\n-\n-            --  Note: Has_Aliased_Components, like Has_Atomic_Components,\n-            --  and Has_Independent_Components, applies only to arrays.\n-            --  However, this flag does not have a corresponding pragma, so\n-            --  perhaps it should be possible to apply it to record types as\n-            --  well. Should this be done ???\n-\n-            elsif Is_Record_Type (Typ) then\n-               --  It is possible to have an aliased discriminant, so they\n-               --  must be checked along with normal components.\n-\n-               Comp := First_Component_Or_Discriminant (Typ);\n-               while Present (Comp) loop\n-\n-                  --  For Atomic we accept any atomic subcomponents\n-\n-                  if not VFA\n-                    and then (Is_Atomic (Comp)\n-                               or else Is_Atomic (Etype (Comp)))\n-                  then\n-                     null;\n-\n-                  --  Give an error if the component is aliased\n-\n-                  elsif Is_Aliased (Comp)\n-                    or else Is_Aliased (Etype (Comp))\n-                  then\n-                     raise Aliased_Subcomponent;\n-\n-                  --  For VFA we accept non-aliased VFA subcomponents\n-\n-                  elsif VFA\n-                    and then (Is_Volatile_Full_Access (Comp)\n-                               or else Is_Volatile_Full_Access (Etype (Comp)))\n-                  then\n-                     null;\n-\n-                  --  Give an error if the component is independent\n-\n-                  elsif Is_Independent (Comp)\n-                     or else Is_Independent (Etype (Comp))\n-                  then\n-                     raise Independent_Subcomponent;\n-                  end if;\n-\n-                  --  Recurse on the component type\n-\n-                  Check_Subcomponents (Etype (Comp));\n-\n-                  Next_Component_Or_Discriminant (Comp);\n-               end loop;\n-            end if;\n-         end Check_Subcomponents;\n-\n-         Typ : Entity_Id;\n-\n-      begin\n-         --  Fetch the type in case we are dealing with an object or component\n-\n-         if Is_Type (E) then\n-            Typ := E;\n-         else\n-            pragma Assert (Is_Object (E)\n-              or else\n-                Nkind (Declaration_Node (E)) = N_Component_Declaration);\n-\n-            Typ := Etype (E);\n-         end if;\n-\n-         --  Check all the subcomponents of the type recursively, if any\n-\n-         Check_Subcomponents (Typ);\n-\n-      exception\n-         when Aliased_Subcomponent =>\n-            if VFA then\n-               Error_Pragma\n-                 (\"cannot apply Volatile_Full_Access with aliased \"\n-                  & \"subcomponent \");\n-            else\n-               Error_Pragma\n-                 (\"cannot apply Atomic with aliased subcomponent \"\n-                  & \"(RM C.6(13))\");\n-            end if;\n-\n-         when Independent_Subcomponent =>\n-            if VFA then\n-               Error_Pragma\n-                 (\"cannot apply Volatile_Full_Access with independent \"\n-                  & \"subcomponent \");\n-            else\n-               Error_Pragma\n-                 (\"cannot apply Atomic with independent subcomponent \"\n-                  & \"(RM C.6(13))\");\n-            end if;\n-\n-         when others =>\n-            raise Program_Error;\n-      end Check_Atomic_VFA;\n-\n       ---------------------\n       -- Check_Component --\n       ---------------------\n@@ -7371,8 +7208,9 @@ package body Sem_Prag is\n       ------------------------------------------------\n \n       procedure Process_Atomic_Independent_Shared_Volatile is\n-         procedure Check_VFA_Conflicts (Ent : Entity_Id);\n-         --  Check that Volatile_Full_Access and VFA do not conflict\n+         procedure Check_Full_Access_Only (Ent : Entity_Id);\n+         --  Apply legality checks to type or object Ent subject to the\n+         --  Full_Access_Only aspect in Ada 2020 (RM C.6(8.2)).\n \n          procedure Mark_Component_Or_Object (Ent : Entity_Id);\n          --  Appropriately set flags on the given entity, either an array or\n@@ -7389,15 +7227,68 @@ package body Sem_Prag is\n          --  full access arrays. Note: this is necessary for derived types.\n \n          -------------------------\n-         -- Check_VFA_Conflicts --\n+         -- Check_Full_Access_Only --\n          -------------------------\n \n-         procedure Check_VFA_Conflicts (Ent : Entity_Id) is\n-            Comp : Entity_Id;\n+         procedure Check_Full_Access_Only (Ent : Entity_Id) is\n             Typ  : Entity_Id;\n \n-            VFA_And_Atomic : Boolean := False;\n-            --  Set True if both VFA and Atomic present\n+            Full_Access_Subcomponent : exception;\n+            --  Exception raised if a full access subcomponent is found\n+\n+            Generic_Type_Subcomponent : exception;\n+            --  Exception raised if a subcomponent with generic type is found\n+\n+            procedure Check_Subcomponents (Typ : Entity_Id);\n+            --  Apply checks to subcomponents recursively\n+\n+            -------------------------\n+            -- Check_Subcomponents --\n+            -------------------------\n+\n+            procedure Check_Subcomponents (Typ : Entity_Id) is\n+               Comp : Entity_Id;\n+\n+            begin\n+               if Is_Array_Type (Typ) then\n+                  Comp := Component_Type (Typ);\n+\n+                  if Has_Atomic_Components (Typ)\n+                    or else Is_Full_Access (Comp)\n+                  then\n+                     raise Full_Access_Subcomponent;\n+\n+                  elsif Is_Generic_Type (Comp) then\n+                     raise Generic_Type_Subcomponent;\n+                  end if;\n+\n+                  --  Recurse on the component type\n+\n+                  Check_Subcomponents (Comp);\n+\n+               elsif Is_Record_Type (Typ) then\n+                  Comp := First_Component_Or_Discriminant (Typ);\n+                  while Present (Comp) loop\n+\n+                     if Is_Full_Access (Comp)\n+                       or else Is_Full_Access (Etype (Comp))\n+                     then\n+                        raise Full_Access_Subcomponent;\n+\n+                     elsif Is_Generic_Type (Etype (Comp)) then\n+                        raise Generic_Type_Subcomponent;\n+                     end if;\n+\n+                     --  Recurse on the component type\n+\n+                     Check_Subcomponents (Etype (Comp));\n+\n+                     Next_Component_Or_Discriminant (Comp);\n+                  end loop;\n+               end if;\n+            end Check_Subcomponents;\n+\n+         --  Start of processing for Check_Full_Access_Only\n \n          begin\n             --  Fetch the type in case we are dealing with an object or\n@@ -7413,49 +7304,29 @@ package body Sem_Prag is\n                Typ := Etype (Ent);\n             end if;\n \n-            --  Check Atomic and VFA used together\n-\n-            if Prag_Id = Pragma_Volatile_Full_Access\n-              or else Is_Volatile_Full_Access (Ent)\n-            then\n-               if Prag_Id = Pragma_Atomic\n-                 or else Prag_Id = Pragma_Shared\n-                 or else Is_Atomic (Ent)\n-               then\n-                  VFA_And_Atomic := True;\n-\n-               elsif Is_Array_Type (Typ) then\n-                  VFA_And_Atomic := Has_Atomic_Components (Typ);\n+            if not Is_Volatile (Ent) and then not Is_Volatile (Typ) then\n+               Error_Pragma\n+                 (\"cannot have Full_Access_Only without Volatile/Atomic \"\n+                  & \"(RM C.6(8.2))\");\n+               return;\n+            end if;\n \n-               --  Note: Has_Atomic_Components is not used below, as this flag\n-               --  represents the pragma of the same name, Atomic_Components,\n-               --  which only applies to arrays.\n+            --  Check all the subcomponents of the type recursively, if any\n \n-               elsif Is_Record_Type (Typ) then\n-                  --  Attributes cannot be applied to discriminants, only\n-                  --  regular record components.\n+            Check_Subcomponents (Typ);\n \n-                  Comp := First_Component (Typ);\n-                  while Present (Comp) loop\n-                     if Is_Atomic (Comp)\n-                       or else Is_Atomic (Typ)\n-                     then\n-                        VFA_And_Atomic := True;\n+         exception\n+            when Full_Access_Subcomponent =>\n+               Error_Pragma\n+                 (\"cannot have Full_Access_Only with full access subcomponent \"\n+                  & \"(RM C.6(8.2))\");\n \n-                        exit;\n-                     end if;\n+            when Generic_Type_Subcomponent =>\n+               Error_Pragma\n+                 (\"cannot have Full_Access_Only with subcomponent of generic \"\n+                  & \"type (RM C.6(8.2))\");\n \n-                     Next_Component (Comp);\n-                  end loop;\n-               end if;\n-\n-               if VFA_And_Atomic then\n-                  Error_Pragma\n-                    (\"cannot have Volatile_Full_Access and Atomic for same \"\n-                     & \"entity\");\n-               end if;\n-            end if;\n-         end Check_VFA_Conflicts;\n+         end Check_Full_Access_Only;\n \n          ------------------------------\n          -- Mark_Component_Or_Object --\n@@ -7611,6 +7482,7 @@ package body Sem_Prag is\n          end if;\n \n          E := Entity (E_Arg);\n+         Decl := Declaration_Node (E);\n \n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n@@ -7621,9 +7493,43 @@ package body Sem_Prag is\n \n          Check_Duplicate_Pragma (E);\n \n-         --  Check appropriateness of the entity\n+         --  Check the constraints of Full_Access_Only in Ada 2020. Note that\n+         --  they do not apply to GNAT's Volatile_Full_Access because 1) this\n+         --  aspect subsumes the Volatile aspect and 2) nesting is supported\n+         --  for this aspect and the outermost enclosing VFA object prevails.\n \n-         Decl := Declaration_Node (E);\n+         --  Note also that we used to forbid specifying both Atomic and VFA on\n+         --  the same type or object, but the restriction has been lifted in\n+         --  light of the semantics of Full_Access_Only and Atomic in Ada 2020.\n+\n+         if Prag_Id = Pragma_Volatile_Full_Access\n+           and then From_Aspect_Specification (N)\n+           and then\n+             Get_Aspect_Id (Corresponding_Aspect (N)) = Aspect_Full_Access_Only\n+         then\n+            Check_Full_Access_Only (E);\n+         end if;\n+\n+         --  The following check is only relevant when SPARK_Mode is on as\n+         --  this is not a standard Ada legality rule. Pragma Volatile can\n+         --  only apply to a full type declaration or an object declaration\n+         --  (SPARK RM 7.1.3(2)). Original_Node is necessary to account for\n+         --  untagged derived types that are rewritten as subtypes of their\n+         --  respective root types.\n+\n+         if SPARK_Mode = On\n+           and then Prag_Id = Pragma_Volatile\n+           and then Nkind (Original_Node (Decl)) not in\n+                      N_Full_Type_Declaration        |\n+                      N_Formal_Type_Declaration      |\n+                      N_Object_Declaration           |\n+                      N_Single_Protected_Declaration |\n+                      N_Single_Task_Declaration\n+         then\n+            Error_Pragma_Arg\n+              (\"argument of pragma % must denote a full type or object \"\n+               & \"declaration\", Arg1);\n+         end if;\n \n          --  Deal with the case where the pragma/attribute is applied to a type\n \n@@ -7656,41 +7562,6 @@ package body Sem_Prag is\n          else\n             Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n          end if;\n-\n-         --  Check that Volatile_Full_Access and Atomic do not conflict\n-\n-         Check_VFA_Conflicts (E);\n-\n-         --  Check for the application of Atomic or Volatile_Full_Access to\n-         --  an entity that has [nonatomic] aliased, or else specified to be\n-         --  independently addressable, subcomponents.\n-\n-         if (Prag_Id = Pragma_Atomic and then Ada_Version >= Ada_2020)\n-           or else Prag_Id = Pragma_Volatile_Full_Access\n-         then\n-            Check_Atomic_VFA (E, VFA => Prag_Id = Pragma_Volatile_Full_Access);\n-         end if;\n-\n-         --  The following check is only relevant when SPARK_Mode is on as\n-         --  this is not a standard Ada legality rule. Pragma Volatile can\n-         --  only apply to a full type declaration or an object declaration\n-         --  (SPARK RM 7.1.3(2)). Original_Node is necessary to account for\n-         --  untagged derived types that are rewritten as subtypes of their\n-         --  respective root types.\n-\n-         if SPARK_Mode = On\n-           and then Prag_Id = Pragma_Volatile\n-           and then Nkind (Original_Node (Decl)) not in\n-                      N_Full_Type_Declaration        |\n-                      N_Formal_Type_Declaration      |\n-                      N_Object_Declaration           |\n-                      N_Single_Protected_Declaration |\n-                      N_Single_Task_Declaration\n-         then\n-            Error_Pragma_Arg\n-              (\"argument of pragma % must denote a full type or object \"\n-               & \"declaration\", Arg1);\n-         end if;\n       end Process_Atomic_Independent_Shared_Volatile;\n \n       -------------------------------------------\n@@ -13591,11 +13462,6 @@ package body Sem_Prag is\n                --  Atomic implies both Independent and Volatile\n \n                if Prag_Id = Pragma_Atomic_Components then\n-                  if Ada_Version >= Ada_2020 then\n-                     Check_Atomic_VFA\n-                       (Component_Type (Etype (E)), VFA => False);\n-                  end if;\n-\n                   Set_Has_Atomic_Components (E);\n                   Set_Has_Independent_Components (E);\n                end if;"}, {"sha": "33206eb685e5b8da8bea2ff5566da0852fc560ef", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -4726,7 +4726,7 @@ package body Sem_Res is\n                end if;\n             end if;\n \n-            --  Check illegal cases of atomic/volatile actual (RM C.6(12,13))\n+            --  Check illegal cases of atomic/volatile/VFA actual (RM C.6(12))\n \n             if (Is_By_Reference_Type (Etype (F)) or else Is_Aliased (F))\n               and then Comes_From_Source (N)\n@@ -4748,17 +4748,29 @@ package body Sem_Res is\n                      A, F);\n                   Error_Msg_N\n                     (\"\\which is passed by reference (RM C.6(12))\", A);\n+\n+               elsif Is_Volatile_Full_Access_Object (A)\n+                 and then not Is_Volatile_Full_Access (Etype (F))\n+               then\n+                  Error_Msg_NE\n+                    (\"cannot pass full access object to nonfull access \"\n+                     & \"formal&\", A, F);\n+                  Error_Msg_N\n+                    (\"\\which is passed by reference (RM C.6(12))\", A);\n                end if;\n \n+               --  Check for nonatomic subcomponent of a full access object\n+               --  in Ada 2020 (RM C.6 (12)).\n+\n                if Ada_Version >= Ada_2020\n-                 and then Is_Subcomponent_Of_Atomic_Object (A)\n+                 and then Is_Subcomponent_Of_Full_Access_Object (A)\n                  and then not Is_Atomic_Object (A)\n                then\n                   Error_Msg_N\n-                    (\"cannot pass nonatomic subcomponent of atomic object\",\n-                     A);\n+                    (\"cannot pass nonatomic subcomponent of full access \"\n+                     & \"object\", A);\n                   Error_Msg_NE\n-                    (\"\\to formal & which is passed by reference (RM C.6(13))\",\n+                    (\"\\to formal & which is passed by reference (RM C.6(12))\",\n                      A, F);\n                end if;\n             end if;"}, {"sha": "5557328062f8d09a823496f00aa6c24694b59d45", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -14566,7 +14566,7 @@ package body Sem_Util is\n             --                      ^\n             --                     Item\n \n-            if Has_Rep_Item (From_Typ, Next_Item) then\n+            if Present_In_Rep_Item (From_Typ, Next_Item) then\n                exit;\n             end if;\n \n@@ -15187,15 +15187,6 @@ package body Sem_Util is\n           and then (Is_Atomic (Id) or else Is_Atomic (Etype (Id)));\n    end Is_Atomic_Object_Entity;\n \n-   -----------------------------\n-   -- Is_Atomic_Or_VFA_Object --\n-   -----------------------------\n-\n-   function Is_Atomic_Or_VFA_Object (N : Node_Id) return Boolean is\n-   begin\n-      return Is_Atomic_Object (N) or else Is_Volatile_Full_Access_Object (N);\n-   end Is_Atomic_Or_VFA_Object;\n-\n    -----------------------------\n    -- Is_Attribute_Loop_Entry --\n    -----------------------------\n@@ -16797,6 +16788,15 @@ package body Sem_Util is\n       return R;\n    end Is_Fixed_Model_Number;\n \n+   -----------------------------\n+   -- Is_Full_Access_Object --\n+   -----------------------------\n+\n+   function Is_Full_Access_Object (N : Node_Id) return Boolean is\n+   begin\n+      return Is_Atomic_Object (N) or else Is_Volatile_Full_Access_Object (N);\n+   end Is_Full_Access_Object;\n+\n    -------------------------------\n    -- Is_Fully_Initialized_Type --\n    -------------------------------\n@@ -19746,11 +19746,12 @@ package body Sem_Util is\n         and then Has_All_Static_Actuals (Call);\n    end Is_Static_Function_Call;\n \n-   ----------------------------------------\n-   --  Is_Subcomponent_Of_Atomic_Object  --\n-   ----------------------------------------\n+   -------------------------------------------\n+   -- Is_Subcomponent_Of_Full_Access_Object --\n+   -------------------------------------------\n \n-   function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean is\n+   function Is_Subcomponent_Of_Full_Access_Object (N : Node_Id) return Boolean\n+   is\n       R : Node_Id;\n \n    begin\n@@ -19763,19 +19764,19 @@ package body Sem_Util is\n          --  If the prefix is an access value, only the designated type matters\n \n          if Is_Access_Type (Etype (R)) then\n-            if Is_Atomic (Designated_Type (Etype (R))) then\n+            if Is_Full_Access (Designated_Type (Etype (R))) then\n                return True;\n             end if;\n \n          else\n-            if Is_Atomic_Object (R) then\n+            if Is_Full_Access_Object (R) then\n                return True;\n             end if;\n          end if;\n       end loop;\n \n       return False;\n-   end Is_Subcomponent_Of_Atomic_Object;\n+   end Is_Subcomponent_Of_Full_Access_Object;\n \n    ---------------------------------------\n    -- Is_Subprogram_Contract_Annotation --"}, {"sha": "f38d0f5ad1c0cf5a77d3fe4c65dc2340dc58b826", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -1670,10 +1670,6 @@ package Sem_Util is\n    --  Determine whether arbitrary node N denotes a reference to an atomic\n    --  object as per RM C.6(7) and the crucial remark in RM C.6(8).\n \n-   function Is_Atomic_Or_VFA_Object (N : Node_Id) return Boolean;\n-   --  Determine whether arbitrary node N denotes a reference to an object\n-   --  which is either atomic or Volatile_Full_Access.\n-\n    function Is_Attribute_Loop_Entry (N : Node_Id) return Boolean;\n    --  Determine whether node N denotes attribute 'Loop_Entry\n \n@@ -1909,6 +1905,10 @@ package Sem_Util is\n    --  Returns True iff the number U is a model number of the fixed-point type\n    --  T, i.e. if it is an exact multiple of Small.\n \n+   function Is_Full_Access_Object (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a reference to a full access\n+   --  object as per Ada 2020 RM C.6(8.2).\n+\n    function Is_Fully_Initialized_Type (Typ : Entity_Id) return Boolean;\n    --  Typ is a type entity. This function returns true if this type is fully\n    --  initialized, meaning that an object of the type is fully initialized.\n@@ -2173,9 +2173,9 @@ package Sem_Util is\n    --  meaning that the name of the call denotes a static function\n    --  and all of the call's actual parameters are given by static expressions.\n \n-   function Is_Subcomponent_Of_Atomic_Object (N : Node_Id) return Boolean;\n+   function Is_Subcomponent_Of_Full_Access_Object (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to a subcomponent\n-   --  of an atomic object as per RM C.6(7).\n+   --  of a full access object as per RM C.6(7).\n \n    function Is_Subprogram_Contract_Annotation (Item : Node_Id) return Boolean;\n    --  Determine whether aspect specification or pragma Item is one of the"}, {"sha": "a9fd7c5c9f569e33659524fb9275b50674513184", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b120ca616fc820e352a19523dae34f5c53bfe859/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=b120ca616fc820e352a19523dae34f5c53bfe859", "patch": "@@ -143,6 +143,7 @@ package Snames is\n    Name_Disable_Controlled             : constant Name_Id := N + $;\n    Name_Dynamic_Predicate              : constant Name_Id := N + $;\n    Name_Exclusive_Functions            : constant Name_Id := N + $;\n+   Name_Full_Access_Only               : constant Name_Id := N + $;\n    Name_Integer_Literal                : constant Name_Id := N + $;\n    Name_Real_Literal                   : constant Name_Id := N + $;\n    Name_Relaxed_Initialization         : constant Name_Id := N + $;"}]}