{"sha": "bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "node_id": "C_kwDOANBUbNoAKGJkNWU4ODJjZjZlMGRlZjNkZDFiYzEwNjA3NWQ1OWEzMDNmZTBkMWU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-10-18T22:55:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-01T13:35:46Z"}, "message": "diagnostics: escape non-ASCII source bytes for certain diagnostics\n\nThis patch adds support to GCC's diagnostic subsystem for escaping certain\nbytes and Unicode characters when quoting source code.\n\nSpecifically, this patch adds a new flag rich_location::m_escape_on_output\nwhich is a hint from a diagnostic that non-ASCII bytes in the pertinent\nlines of the user's source code should be escaped when printed.\n\nThe patch sets this for the following diagnostics:\n- when complaining about stray bytes in the program (when these\nare non-printable)\n- when complaining about \"null character(s) ignored\");\n- for -Wnormalized= (and generate source ranges for such warnings)\n\nThe escaping is controlled by a new option:\n  -fdiagnostics-escape-format=[unicode|bytes]\n\nFor example, consider a diagnostic involing a source line containing the\nstring \"before\" followed by the Unicode character U+03C0 (\"GREEK SMALL\nLETTER PI\", with UTF-8 encoding 0xCF 0x80) followed by the byte 0xBF\n(a stray UTF-8 trailing byte), followed by the string \"after\", where the\ndiagnostic highlights the U+03C0 character.\n\nBy default, this line will be printed verbatim to the user when\nreporting a diagnostic at it, as:\n\n before\u03c0Xafter\n       ^\n\n(using X for the stray byte to avoid putting invalid UTF-8 in this\ncommit message)\n\nIf the diagnostic sets the \"escape\" flag, it will be printed as:\n\n before<U+03C0><BF>after\n       ^~~~~~~~\n\nwith -fdiagnostics-escape-format=unicode (the default), or as:\n\n  before<CF><80><BF>after\n        ^~~~~~~~\n\nif the user supplies -fdiagnostics-escape-format=bytes.\n\nThis only affects how the source is printed; it does not affect\nhow column numbers that are printed (as per -fdiagnostics-column-unit=\nand -fdiagnostics-column-origin=).\n\ngcc/c-family/ChangeLog:\n\t* c-lex.c (c_lex_with_flags): When complaining about non-printable\n\tCPP_OTHER tokens, set the \"escape on output\" flag.\n\ngcc/ChangeLog:\n\t* common.opt (fdiagnostics-escape-format=): New.\n\t(diagnostics_escape_format): New enum.\n\t(DIAGNOSTICS_ESCAPE_FORMAT_UNICODE): New enum value.\n\t(DIAGNOSTICS_ESCAPE_FORMAT_BYTES): Likewise.\n\t* diagnostic-format-json.cc (json_end_diagnostic): Add\n\t\"escape-source\" attribute.\n\t* diagnostic-show-locus.c\n\t(exploc_with_display_col::exploc_with_display_col): Replace\n\t\"tabstop\" param with a cpp_char_column_policy and add an \"aspect\"\n\tparam.  Use these to compute m_display_col accordingly.\n\t(struct char_display_policy): New struct.\n\t(layout::m_policy): New field.\n\t(layout::m_escape_on_output): New field.\n\t(def_policy): New function.\n\t(make_range): Update for changes to exploc_with_display_col ctor.\n\t(default_print_decoded_ch): New.\n\t(width_per_escaped_byte): New.\n\t(escape_as_bytes_width): New.\n\t(escape_as_bytes_print): New.\n\t(escape_as_unicode_width): New.\n\t(escape_as_unicode_print): New.\n\t(make_policy): New.\n\t(layout::layout): Initialize new fields.  Update m_exploc ctor\n\tcall for above change to ctor.\n\t(layout::maybe_add_location_range): Update for changes to\n\texploc_with_display_col ctor.\n\t(layout::calculate_x_offset_display): Update for change to\n\tcpp_display_width.\n\t(layout::print_source_line): Pass policy\n\tto cpp_display_width_computation. Capture cpp_decoded_char when\n\tcalling process_next_codepoint.  Move printing of source code to\n\tm_policy.m_print_cb.\n\t(line_label::line_label): Pass in policy rather than context.\n\t(layout::print_any_labels): Update for change to line_label ctor.\n\t(get_affected_range): Pass in policy rather than context, updating\n\tcalls to location_compute_display_column accordingly.\n\t(get_printed_columns): Likewise, also for cpp_display_width.\n\t(correction::correction): Pass in policy rather than tabstop.\n\t(correction::compute_display_cols): Pass m_policy rather than\n\tm_tabstop to cpp_display_width.\n\t(correction::m_tabstop): Replace with...\n\t(correction::m_policy): ...this.\n\t(line_corrections::line_corrections): Pass in policy rather than\n\tcontext.\n\t(line_corrections::m_context): Replace with...\n\t(line_corrections::m_policy): ...this.\n\t(line_corrections::add_hint): Update to use m_policy rather than\n\tm_context.\n\t(line_corrections::add_hint): Likewise.\n\t(layout::print_trailing_fixits): Likewise.\n\t(selftest::test_display_widths): New.\n\t(selftest::test_layout_x_offset_display_utf8): Update to use\n\tpolicy rather than tabstop.\n\t(selftest::test_one_liner_labels_utf8): Add test of escaping\n\tsource lines.\n\t(selftest::test_diagnostic_show_locus_one_liner_utf8): Update to\n\tuse policy rather than tabstop.\n\t(selftest::test_overlapped_fixit_printing): Likewise.\n\t(selftest::test_overlapped_fixit_printing_utf8): Likewise.\n\t(selftest::test_overlapped_fixit_printing_2): Likewise.\n\t(selftest::test_tab_expansion): Likewise.\n\t(selftest::test_escaping_bytes_1): New.\n\t(selftest::test_escaping_bytes_2): New.\n\t(selftest::diagnostic_show_locus_c_tests): Call the new tests.\n\t* diagnostic.c (diagnostic_initialize): Initialize\n\tcontext->escape_format.\n\t(convert_column_unit): Update to use default character width policy.\n\t(selftest::test_diagnostic_get_location_text): Likewise.\n\t* diagnostic.h (enum diagnostics_escape_format): New enum.\n\t(diagnostic_context::escape_format): New field.\n\t* doc/invoke.texi (-fdiagnostics-escape-format=): New option.\n\t(-fdiagnostics-format=): Add \"escape-source\" attribute to examples\n\tof JSON output, and document it.\n\t* input.c (location_compute_display_column): Pass in \"policy\"\n\trather than \"tabstop\", passing to\n\tcpp_byte_column_to_display_column.\n\t(selftest::test_cpp_utf8): Update to use cpp_char_column_policy.\n\t* input.h (class cpp_char_column_policy): New forward decl.\n\t(location_compute_display_column): Pass in \"policy\" rather than\n\t\"tabstop\".\n\t* opts.c (common_handle_option): Handle\n\tOPT_fdiagnostics_escape_format_.\n\t* selftest.c (temp_source_file::temp_source_file): New ctor\n\toverload taking a size_t.\n\t* selftest.h (temp_source_file::temp_source_file): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* c-c++-common/diagnostic-format-json-1.c: Add regexp to consume\n\t\"escape-source\" attribute.\n\t* c-c++-common/diagnostic-format-json-2.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-3.c: Likewise.\n\t* c-c++-common/diagnostic-format-json-4.c: Likewise, twice.\n\t* c-c++-common/diagnostic-format-json-5.c: Likewise.\n\t* gcc.dg/cpp/warn-normalized-4-bytes.c: New test.\n\t* gcc.dg/cpp/warn-normalized-4-unicode.c: New test.\n\t* gcc.dg/encoding-issues-bytes.c: New test.\n\t* gcc.dg/encoding-issues-unicode.c: New test.\n\t* gfortran.dg/diagnostic-format-json-1.F90: Add regexp to consume\n\t\"escape-source\" attribute.\n\t* gfortran.dg/diagnostic-format-json-2.F90: Likewise.\n\t* gfortran.dg/diagnostic-format-json-3.F90: Likewise.\n\nlibcpp/ChangeLog:\n\t* charset.c (convert_escape): Use encoding_rich_location when\n\tcomplaining about nonprintable unknown escape sequences.\n\t(cpp_display_width_computation::::cpp_display_width_computation):\n\tPass in policy rather than tabstop.\n\t(cpp_display_width_computation::process_next_codepoint): Add \"out\"\n\tparam and populate *out if non-NULL.\n\t(cpp_display_width_computation::advance_display_cols): Pass NULL\n\tto process_next_codepoint.\n\t(cpp_byte_column_to_display_column): Pass in policy rather than\n\ttabstop.  Pass NULL to process_next_codepoint.\n\t(cpp_display_column_to_byte_column): Pass in policy rather than\n\ttabstop.\n\t* errors.c (cpp_diagnostic_get_current_location): New function,\n\tsplitting out the logic from...\n\t(cpp_diagnostic): ...here.\n\t(cpp_warning_at): New function.\n\t(cpp_pedwarning_at): New function.\n\t* include/cpplib.h (cpp_warning_at): New decl for rich_location.\n\t(cpp_pedwarning_at): Likewise.\n\t(struct cpp_decoded_char): New.\n\t(struct cpp_char_column_policy): New.\n\t(cpp_display_width_computation::cpp_display_width_computation):\n\tReplace \"tabstop\" param with \"policy\".\n\t(cpp_display_width_computation::process_next_codepoint): Add \"out\"\n\tparam.\n\t(cpp_display_width_computation::m_tabstop): Replace with...\n\t(cpp_display_width_computation::m_policy): ...this.\n\t(cpp_byte_column_to_display_column): Replace \"tabstop\" param with\n\t\"policy\".\n\t(cpp_display_width): Likewise.\n\t(cpp_display_column_to_byte_column): Likewise.\n\t* include/line-map.h (rich_location::escape_on_output_p): New.\n\t(rich_location::set_escape_on_output): New.\n\t(rich_location::m_escape_on_output): New.\n\t* internal.h (cpp_diagnostic_get_current_location): New decl.\n\t(class encoding_rich_location): New.\n\t* lex.c (skip_whitespace): Use encoding_rich_location when\n\tcomplaining about null characters.\n\t(warn_about_normalization): Generate a source range when\n\tcomplaining about improperly normalized tokens, rather than just a\n\tpoint, and use encoding_rich_location so that the source code\n\tis escaped on printing.\n\t* line-map.c (rich_location::rich_location): Initialize\n\tm_escape_on_output.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "858681a7eee72064d0b6977f0b68c5fdd0cbb9b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/858681a7eee72064d0b6977f0b68c5fdd0cbb9b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91bac9fed5d082f0b180834110ebc0f46f97599a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bac9fed5d082f0b180834110ebc0f46f97599a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bac9fed5d082f0b180834110ebc0f46f97599a"}], "stats": {"total": 1110, "additions": 942, "deletions": 168}, "files": [{"sha": "2651331e683162cadd16e5e313006e0437e66fa1", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -616,7 +616,11 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \telse if (ISGRAPH (c))\n \t  error_at (*loc, \"stray %qc in program\", (int) c);\n \telse\n-\t  error_at (*loc, \"stray %<\\\\%o%> in program\", (int) c);\n+\t  {\n+\t    rich_location rich_loc (line_table, *loc);\n+\t    rich_loc.set_escape_on_output (true);\n+\t    error_at (&rich_loc, \"stray %<\\\\%o%> in program\", (int) c);\n+\t  }\n       }\n       goto retry;\n "}, {"sha": "1a5b9bfcca9149b9343dd481f7b774752e440444", "filename": "gcc/common.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -1365,6 +1365,10 @@ fdiagnostics-format=\n Common Joined RejectNegative Enum(diagnostics_output_format)\n -fdiagnostics-format=[text|json]\tSelect output format.\n \n+fdiagnostics-escape-format=\n+Common Joined RejectNegative Enum(diagnostics_escape_format)\n+-fdiagnostics-escape-format=[unicode|bytes]\tSelect how to escape non-printable-ASCII bytes in the source for diagnostics that suggest it.\n+\n ; Required for these enum values.\n SourceInclude\n diagnostic.h\n@@ -1378,6 +1382,15 @@ Enum(diagnostics_column_unit) String(display) Value(DIAGNOSTICS_COLUMN_UNIT_DISP\n EnumValue\n Enum(diagnostics_column_unit) String(byte) Value(DIAGNOSTICS_COLUMN_UNIT_BYTE)\n \n+Enum\n+Name(diagnostics_escape_format) Type(int)\n+\n+EnumValue\n+Enum(diagnostics_escape_format) String(unicode) Value(DIAGNOSTICS_ESCAPE_FORMAT_UNICODE)\n+\n+EnumValue\n+Enum(diagnostics_escape_format) String(bytes) Value(DIAGNOSTICS_ESCAPE_FORMAT_BYTES)\n+\n Enum\n Name(diagnostics_output_format) Type(int)\n "}, {"sha": "eff1907652354ad071f65be659729910136e088f", "filename": "gcc/diagnostic-format-json.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic-format-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic-format-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-format-json.cc?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -264,6 +264,9 @@ json_end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n       json::value *path_value = context->make_json_for_path (context, path);\n       diag_obj->set (\"path\", path_value);\n     }\n+\n+  diag_obj->set (\"escape-source\",\n+\t\t new json::literal (richloc->escape_on_output_p ()));\n }\n \n /* No-op implementation of \"begin_group_cb\" for JSON output.  */"}, {"sha": "d796085222a0a81fe1a0a53df2aeb70318e73462", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 498, "deletions": 82, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -175,10 +175,26 @@ enum column_unit {\n class exploc_with_display_col : public expanded_location\n {\n  public:\n-  exploc_with_display_col (const expanded_location &exploc, int tabstop)\n-    : expanded_location (exploc),\n-      m_display_col (location_compute_display_column (exploc, tabstop))\n-  {}\n+  exploc_with_display_col (const expanded_location &exploc,\n+\t\t\t   const cpp_char_column_policy &policy,\n+\t\t\t   enum location_aspect aspect)\n+  : expanded_location (exploc),\n+    m_display_col (location_compute_display_column (exploc, policy))\n+  {\n+    if (exploc.column > 0)\n+      {\n+\t/* m_display_col is now the final column of the byte.\n+\t   If escaping has happened, we may want the first column instead.  */\n+\tif (aspect != LOCATION_ASPECT_FINISH)\n+\t  {\n+\t    expanded_location prev_exploc (exploc);\n+\t    prev_exploc.column--;\n+\t    int prev_display_col\n+\t      = (location_compute_display_column (prev_exploc, policy));\n+\t    m_display_col = prev_display_col + 1;\n+\t  }\n+      }\n+  }\n \n   int m_display_col;\n };\n@@ -313,6 +329,31 @@ test_line_span ()\n \n #endif /* #if CHECKING_P */\n \n+/* A bundle of information containing how to print unicode\n+   characters and bytes when quoting source code.\n+\n+   Provides a unified place to support escaping some subset\n+   of characters to some format.\n+\n+   Extends char_column_policy; printing is split out to avoid\n+   libcpp having to know about pretty_printer.  */\n+\n+struct char_display_policy : public cpp_char_column_policy\n+{\n+ public:\n+  char_display_policy (int tabstop,\n+\t\t       int (*width_cb) (cppchar_t c),\n+\t\t       void (*print_cb) (pretty_printer *pp,\n+\t\t\t\t\t const cpp_decoded_char &cp))\n+  : cpp_char_column_policy (tabstop, width_cb),\n+    m_print_cb (print_cb)\n+  {\n+  }\n+\n+  void (*m_print_cb) (pretty_printer *pp,\n+\t\t      const cpp_decoded_char &cp);\n+};\n+\n /* A class to control the overall layout when printing a diagnostic.\n \n    The layout is determined within the constructor.\n@@ -345,6 +386,8 @@ class layout\n \n   void print_line (linenum_type row);\n \n+  void on_bad_codepoint (const char *ptr, cppchar_t ch, size_t ch_sz);\n+\n  private:\n   bool will_show_line_p (linenum_type row) const;\n   void print_leading_fixits (linenum_type row);\n@@ -386,6 +429,7 @@ class layout\n  private:\n   diagnostic_context *m_context;\n   pretty_printer *m_pp;\n+  char_display_policy m_policy;\n   location_t m_primary_loc;\n   exploc_with_display_col m_exploc;\n   colorizer m_colorizer;\n@@ -398,6 +442,7 @@ class layout\n   auto_vec <line_span> m_line_spans;\n   int m_linenum_width;\n   int m_x_offset_display;\n+  bool m_escape_on_output;\n };\n \n /* Implementation of \"class colorizer\".  */\n@@ -646,6 +691,11 @@ layout_range::intersects_line_p (linenum_type row) const\n /* Default for when we don't care what the tab expansion is set to.  */\n static const int def_tabstop = 8;\n \n+static cpp_char_column_policy def_policy ()\n+{\n+  return cpp_char_column_policy (8, cpp_wcwidth);\n+}\n+\n /* Create some expanded locations for testing layout_range.  The filename\n    member of the explocs is set to the empty string.  This member will only be\n    inspected by the calls to location_compute_display_column() made from the\n@@ -662,10 +712,13 @@ make_range (int start_line, int start_col, int end_line, int end_col)\n     = {\"\", start_line, start_col, NULL, false};\n   const expanded_location finish_exploc\n     = {\"\", end_line, end_col, NULL, false};\n-  return layout_range (exploc_with_display_col (start_exploc, def_tabstop),\n-\t\t       exploc_with_display_col (finish_exploc, def_tabstop),\n+  return layout_range (exploc_with_display_col (start_exploc, def_policy (),\n+\t\t\t\t\t\tLOCATION_ASPECT_START),\n+\t\t       exploc_with_display_col (finish_exploc, def_policy (),\n+\t\t\t\t\t\tLOCATION_ASPECT_FINISH),\n \t\t       SHOW_RANGE_WITHOUT_CARET,\n-\t\t       exploc_with_display_col (start_exploc, def_tabstop),\n+\t\t       exploc_with_display_col (start_exploc, def_policy (),\n+\t\t\t\t\t\tLOCATION_ASPECT_CARET),\n \t\t       0, NULL);\n }\n \n@@ -959,6 +1012,164 @@ fixit_cmp (const void *p_a, const void *p_b)\n   return hint_a->get_start_loc () - hint_b->get_start_loc ();\n }\n \n+/* Callbacks for use when not escaping the source.  */\n+\n+/* The default callback for char_column_policy::m_width_cb is cpp_wcwidth.  */\n+\n+/* Callback for char_display_policy::m_print_cb for printing source chars\n+   when not escaping the source.  */\n+\n+static void\n+default_print_decoded_ch (pretty_printer *pp,\n+\t\t\t  const cpp_decoded_char &decoded_ch)\n+{\n+  for (const char *ptr = decoded_ch.m_start_byte;\n+       ptr != decoded_ch.m_next_byte; ptr++)\n+    {\n+      if (*ptr == '\\0' || *ptr == '\\r')\n+\t{\n+\t  pp_space (pp);\n+\t  continue;\n+\t}\n+\n+      pp_character (pp, *ptr);\n+    }\n+}\n+\n+/* Callbacks for use with DIAGNOSTICS_ESCAPE_FORMAT_BYTES.  */\n+\n+static const int width_per_escaped_byte = 4;\n+\n+/* Callback for char_column_policy::m_width_cb for determining the\n+   display width when escaping with DIAGNOSTICS_ESCAPE_FORMAT_BYTES.  */\n+\n+static int\n+escape_as_bytes_width (cppchar_t ch)\n+{\n+  if (ch < 0x80 && ISPRINT (ch))\n+    return cpp_wcwidth (ch);\n+  else\n+    {\n+      if (ch <=   0x7F) return 1 * width_per_escaped_byte;\n+      if (ch <=  0x7FF) return 2 * width_per_escaped_byte;\n+      if (ch <= 0xFFFF) return 3 * width_per_escaped_byte;\n+      return 4 * width_per_escaped_byte;\n+    }\n+}\n+\n+/* Callback for char_display_policy::m_print_cb for printing source chars\n+   when escaping with DIAGNOSTICS_ESCAPE_FORMAT_BYTES.  */\n+\n+static void\n+escape_as_bytes_print (pretty_printer *pp,\n+\t\t       const cpp_decoded_char &decoded_ch)\n+{\n+  if (!decoded_ch.m_valid_ch)\n+    {\n+      for (const char *iter = decoded_ch.m_start_byte;\n+\t   iter != decoded_ch.m_next_byte; ++iter)\n+\t{\n+\t  char buf[16];\n+\t  sprintf (buf, \"<%02x>\", (unsigned char)*iter);\n+\t  pp_string (pp, buf);\n+\t}\n+      return;\n+    }\n+\n+  cppchar_t ch = decoded_ch.m_ch;\n+  if (ch < 0x80 && ISPRINT (ch))\n+    pp_character (pp, ch);\n+  else\n+    {\n+      for (const char *iter = decoded_ch.m_start_byte;\n+\t   iter < decoded_ch.m_next_byte; ++iter)\n+\t{\n+\t  char buf[16];\n+\t  sprintf (buf, \"<%02x>\", (unsigned char)*iter);\n+\t  pp_string (pp, buf);\n+\t}\n+    }\n+}\n+\n+/* Callbacks for use with DIAGNOSTICS_ESCAPE_FORMAT_UNICODE.  */\n+\n+/* Callback for char_column_policy::m_width_cb for determining the\n+   display width when escaping with DIAGNOSTICS_ESCAPE_FORMAT_UNICODE.  */\n+\n+static int\n+escape_as_unicode_width (cppchar_t ch)\n+{\n+  if (ch < 0x80 && ISPRINT (ch))\n+    return cpp_wcwidth (ch);\n+  else\n+    {\n+      // Width of \"<U+%04x>\"\n+      if (ch > 0xfffff)\n+\treturn 10;\n+      else if (ch > 0xffff)\n+\treturn 9;\n+      else\n+\treturn 8;\n+    }\n+}\n+\n+/* Callback for char_display_policy::m_print_cb for printing source chars\n+   when escaping with DIAGNOSTICS_ESCAPE_FORMAT_UNICODE.  */\n+\n+static void\n+escape_as_unicode_print (pretty_printer *pp,\n+\t\t\t const cpp_decoded_char &decoded_ch)\n+{\n+  if (!decoded_ch.m_valid_ch)\n+    {\n+      escape_as_bytes_print (pp, decoded_ch);\n+      return;\n+    }\n+\n+  cppchar_t ch = decoded_ch.m_ch;\n+  if (ch < 0x80 && ISPRINT (ch))\n+    pp_character (pp, ch);\n+  else\n+    {\n+      char buf[16];\n+      sprintf (buf, \"<U+%04X>\", ch);\n+      pp_string (pp, buf);\n+    }\n+}\n+\n+/* Populate a char_display_policy based on DC and RICHLOC.  */\n+\n+static char_display_policy\n+make_policy (const diagnostic_context &dc,\n+\t     const rich_location &richloc)\n+{\n+  /* The default is to not escape non-ASCII bytes.  */\n+  char_display_policy result\n+    (dc.tabstop, cpp_wcwidth, default_print_decoded_ch);\n+\n+  /* If the diagnostic suggests escaping non-ASCII bytes, then\n+     use policy from user-supplied options.  */\n+  if (richloc.escape_on_output_p ())\n+    {\n+      result.m_undecoded_byte_width = width_per_escaped_byte;\n+      switch (dc.escape_format)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase DIAGNOSTICS_ESCAPE_FORMAT_UNICODE:\n+\t  result.m_width_cb = escape_as_unicode_width;\n+\t  result.m_print_cb = escape_as_unicode_print;\n+\t  break;\n+\tcase DIAGNOSTICS_ESCAPE_FORMAT_BYTES:\n+\t  result.m_width_cb = escape_as_bytes_width;\n+\t  result.m_print_cb = escape_as_bytes_print;\n+\t  break;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n /* Implementation of class layout.  */\n \n /* Constructor for class layout.\n@@ -975,8 +1186,10 @@ layout::layout (diagnostic_context * context,\n \t\tdiagnostic_t diagnostic_kind)\n : m_context (context),\n   m_pp (context->printer),\n+  m_policy (make_policy (*context, *richloc)),\n   m_primary_loc (richloc->get_range (0)->m_loc),\n-  m_exploc (richloc->get_expanded_location (0), context->tabstop),\n+  m_exploc (richloc->get_expanded_location (0), m_policy,\n+\t    LOCATION_ASPECT_CARET),\n   m_colorizer (context, diagnostic_kind),\n   m_colorize_source_p (context->colorize_source_p),\n   m_show_labels_p (context->show_labels_p),\n@@ -986,7 +1199,8 @@ layout::layout (diagnostic_context * context,\n   m_fixit_hints (richloc->get_num_fixit_hints ()),\n   m_line_spans (1 + richloc->get_num_locations ()),\n   m_linenum_width (0),\n-  m_x_offset_display (0)\n+  m_x_offset_display (0),\n+  m_escape_on_output (richloc->escape_on_output_p ())\n {\n   for (unsigned int idx = 0; idx < richloc->get_num_locations (); idx++)\n     {\n@@ -1072,10 +1286,13 @@ layout::maybe_add_location_range (const location_range *loc_range,\n \n   /* Everything is now known to be in the correct source file,\n      but it may require further sanitization.  */\n-  layout_range ri (exploc_with_display_col (start, m_context->tabstop),\n-\t\t   exploc_with_display_col (finish, m_context->tabstop),\n+  layout_range ri (exploc_with_display_col (start, m_policy,\n+\t\t\t\t\t    LOCATION_ASPECT_START),\n+\t\t   exploc_with_display_col (finish, m_policy,\n+\t\t\t\t\t    LOCATION_ASPECT_FINISH),\n \t\t   loc_range->m_range_display_kind,\n-\t\t   exploc_with_display_col (caret, m_context->tabstop),\n+\t\t   exploc_with_display_col (caret, m_policy,\n+\t\t\t\t\t    LOCATION_ASPECT_CARET),\n \t\t   original_idx, loc_range->m_label);\n \n   /* If we have a range that finishes before it starts (perhaps\n@@ -1409,7 +1626,7 @@ layout::calculate_x_offset_display ()\n     = get_line_bytes_without_trailing_whitespace (line.get_buffer (),\n \t\t\t\t\t\t  line.length ());\n   int eol_display_column\n-    = cpp_display_width (line.get_buffer (), line_bytes, m_context->tabstop);\n+    = cpp_display_width (line.get_buffer (), line_bytes, m_policy);\n   if (caret_display_column > eol_display_column\n       || !caret_display_column)\n     {\n@@ -1488,7 +1705,7 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes)\n   /* This object helps to keep track of which display column we are at, which is\n      necessary for computing the line bounds in display units, for doing\n      tab expansion, and for implementing m_x_offset_display.  */\n-  cpp_display_width_computation dw (line, line_bytes, m_context->tabstop);\n+  cpp_display_width_computation dw (line, line_bytes, m_policy);\n \n   /* Skip the first m_x_offset_display display columns.  In case the leading\n      portion that will be skipped ends with a character with wcwidth > 1, then\n@@ -1536,7 +1753,8 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes)\n \t tabs and replacing some control bytes with spaces as necessary.  */\n       const char *c = dw.next_byte ();\n       const int start_disp_col = dw.display_cols_processed () + 1;\n-      const int this_display_width = dw.process_next_codepoint ();\n+      cpp_decoded_char cp;\n+      const int this_display_width = dw.process_next_codepoint (&cp);\n       if (*c == '\\t')\n \t{\n \t  /* The returned display width is the number of spaces into which the\n@@ -1545,15 +1763,6 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes)\n \t    pp_space (m_pp);\n \t  continue;\n \t}\n-      if (*c == '\\0' || *c == '\\r')\n-\t{\n-\t  /* cpp_wcwidth() promises to return 1 for all control bytes, and we\n-\t     want to output these as a single space too, so this case is\n-\t     actually the same as the '\\t' case.  */\n-\t  gcc_assert (this_display_width == 1);\n-\t  pp_space (m_pp);\n-\t  continue;\n-\t}\n \n       /* We have a (possibly multibyte) character to output; update the line\n \t bounds if it is not whitespace.  */\n@@ -1565,7 +1774,8 @@ layout::print_source_line (linenum_type row, const char *line, int line_bytes)\n \t}\n \n       /* Output the character.  */\n-      while (c != dw.next_byte ()) pp_character (m_pp, *c++);\n+      m_policy.m_print_cb (m_pp, cp);\n+      c = dw.next_byte ();\n     }\n   print_newline ();\n   return lbounds;\n@@ -1664,14 +1874,14 @@ layout::print_annotation_line (linenum_type row, const line_bounds lbounds)\n class line_label\n {\n public:\n-  line_label (diagnostic_context *context, int state_idx, int column,\n+  line_label (const cpp_char_column_policy &policy,\n+\t      int state_idx, int column,\n \t      label_text text)\n   : m_state_idx (state_idx), m_column (column),\n     m_text (text), m_label_line (0), m_has_vbar (true)\n   {\n     const int bytes = strlen (text.m_buffer);\n-    m_display_width\n-      = cpp_display_width (text.m_buffer, bytes, context->tabstop);\n+    m_display_width = cpp_display_width (text.m_buffer, bytes, policy);\n   }\n \n   /* Sorting is primarily by column, then by state index.  */\n@@ -1731,7 +1941,7 @@ layout::print_any_labels (linenum_type row)\n \tif (text.m_buffer == NULL)\n \t  continue;\n \n-\tlabels.safe_push (line_label (m_context, i, disp_col, text));\n+\tlabels.safe_push (line_label (m_policy, i, disp_col, text));\n       }\n   }\n \n@@ -2011,7 +2221,7 @@ class column_range\n \n /* Get the range of bytes or display columns that HINT would affect.  */\n static column_range\n-get_affected_range (diagnostic_context *context,\n+get_affected_range (const cpp_char_column_policy &policy,\n \t\t    const fixit_hint *hint, enum column_unit col_unit)\n {\n   expanded_location exploc_start = expand_location (hint->get_start_loc ());\n@@ -2022,13 +2232,11 @@ get_affected_range (diagnostic_context *context,\n   int finish_column;\n   if (col_unit == CU_DISPLAY_COLS)\n     {\n-      start_column\n-\t= location_compute_display_column (exploc_start, context->tabstop);\n+      start_column = location_compute_display_column (exploc_start, policy);\n       if (hint->insertion_p ())\n \tfinish_column = start_column - 1;\n       else\n-\tfinish_column\n-\t  = location_compute_display_column (exploc_finish, context->tabstop);\n+\tfinish_column = location_compute_display_column (exploc_finish, policy);\n     }\n   else\n     {\n@@ -2041,12 +2249,13 @@ get_affected_range (diagnostic_context *context,\n /* Get the range of display columns that would be printed for HINT.  */\n \n static column_range\n-get_printed_columns (diagnostic_context *context, const fixit_hint *hint)\n+get_printed_columns (const cpp_char_column_policy &policy,\n+\t\t     const fixit_hint *hint)\n {\n   expanded_location exploc = expand_location (hint->get_start_loc ());\n-  int start_column = location_compute_display_column (exploc, context->tabstop);\n+  int start_column = location_compute_display_column (exploc, policy);\n   int hint_width = cpp_display_width (hint->get_string (), hint->get_length (),\n-\t\t\t\t      context->tabstop);\n+\t\t\t\t      policy);\n   int final_hint_column = start_column + hint_width - 1;\n   if (hint->insertion_p ())\n     {\n@@ -2056,8 +2265,7 @@ get_printed_columns (diagnostic_context *context, const fixit_hint *hint)\n     {\n       exploc = expand_location (hint->get_next_loc ());\n       --exploc.column;\n-      int finish_column\n-\t= location_compute_display_column (exploc, context->tabstop);\n+      int finish_column = location_compute_display_column (exploc, policy);\n       return column_range (start_column,\n \t\t\t   MAX (finish_column, final_hint_column));\n     }\n@@ -2075,13 +2283,13 @@ class correction\n \t      column_range affected_columns,\n \t      column_range printed_columns,\n \t      const char *new_text, size_t new_text_len,\n-\t      int tabstop)\n+\t      const cpp_char_column_policy &policy)\n   : m_affected_bytes (affected_bytes),\n     m_affected_columns (affected_columns),\n     m_printed_columns (printed_columns),\n     m_text (xstrdup (new_text)),\n     m_byte_length (new_text_len),\n-    m_tabstop (tabstop),\n+    m_policy (policy),\n     m_alloc_sz (new_text_len + 1)\n   {\n     compute_display_cols ();\n@@ -2099,7 +2307,7 @@ class correction\n \n   void compute_display_cols ()\n   {\n-    m_display_cols = cpp_display_width (m_text, m_byte_length, m_tabstop);\n+    m_display_cols = cpp_display_width (m_text, m_byte_length, m_policy);\n   }\n \n   void overwrite (int dst_offset, const char_span &src_span)\n@@ -2127,7 +2335,7 @@ class correction\n   char *m_text;\n   size_t m_byte_length; /* Not including null-terminator.  */\n   int m_display_cols;\n-  int m_tabstop;\n+  const cpp_char_column_policy &m_policy;\n   size_t m_alloc_sz;\n };\n \n@@ -2163,15 +2371,16 @@ correction::ensure_terminated ()\n class line_corrections\n {\n public:\n-  line_corrections (diagnostic_context *context, const char *filename,\n+  line_corrections (const char_display_policy &policy,\n+\t\t    const char *filename,\n \t\t    linenum_type row)\n-    : m_context (context), m_filename (filename), m_row (row)\n+  : m_policy (policy), m_filename (filename), m_row (row)\n   {}\n   ~line_corrections ();\n \n   void add_hint (const fixit_hint *hint);\n \n-  diagnostic_context *m_context;\n+  const char_display_policy &m_policy;\n   const char *m_filename;\n   linenum_type m_row;\n   auto_vec <correction *> m_corrections;\n@@ -2217,10 +2426,10 @@ source_line::source_line (const char *filename, int line)\n void\n line_corrections::add_hint (const fixit_hint *hint)\n {\n-  column_range affected_bytes = get_affected_range (m_context, hint, CU_BYTES);\n-  column_range affected_columns = get_affected_range (m_context, hint,\n+  column_range affected_bytes = get_affected_range (m_policy, hint, CU_BYTES);\n+  column_range affected_columns = get_affected_range (m_policy, hint,\n \t\t\t\t\t\t      CU_DISPLAY_COLS);\n-  column_range printed_columns = get_printed_columns (m_context, hint);\n+  column_range printed_columns = get_printed_columns (m_policy, hint);\n \n   /* Potentially consolidate.  */\n   if (!m_corrections.is_empty ())\n@@ -2289,7 +2498,7 @@ line_corrections::add_hint (const fixit_hint *hint)\n \t\t\t\t\t   printed_columns,\n \t\t\t\t\t   hint->get_string (),\n \t\t\t\t\t   hint->get_length (),\n-\t\t\t\t\t   m_context->tabstop));\n+\t\t\t\t\t   m_policy));\n }\n \n /* If there are any fixit hints on source line ROW, print them.\n@@ -2303,7 +2512,7 @@ layout::print_trailing_fixits (linenum_type row)\n {\n   /* Build a list of correction instances for the line,\n      potentially consolidating hints (for the sake of readability).  */\n-  line_corrections corrections (m_context, m_exploc.file, row);\n+  line_corrections corrections (m_policy, m_exploc.file, row);\n   for (unsigned int i = 0; i < m_fixit_hints.length (); i++)\n     {\n       const fixit_hint *hint = m_fixit_hints[i];\n@@ -2646,6 +2855,59 @@ namespace selftest {\n \n /* Selftests for diagnostic_show_locus.  */\n \n+/* Verify that cpp_display_width correctly handles escaping.  */\n+\n+static void\n+test_display_widths ()\n+{\n+  gcc_rich_location richloc (UNKNOWN_LOCATION);\n+\n+  /* U+03C0 \"GREEK SMALL LETTER PI\".  */\n+  const char *pi = \"\\xCF\\x80\";\n+  /* U+1F642 \"SLIGHTLY SMILING FACE\".  */\n+  const char *emoji = \"\\xF0\\x9F\\x99\\x82\";\n+  /* Stray trailing byte of a UTF-8 character.  */\n+  const char *stray = \"\\xBF\";\n+  /* U+10FFFF.  */\n+  const char *max_codepoint = \"\\xF4\\x8F\\xBF\\xBF\";\n+\n+  /* No escaping.  */\n+  {\n+    test_diagnostic_context dc;\n+    char_display_policy policy (make_policy (dc, richloc));\n+    ASSERT_EQ (cpp_display_width (pi, strlen (pi), policy), 1);\n+    ASSERT_EQ (cpp_display_width (emoji, strlen (emoji), policy), 2);\n+    ASSERT_EQ (cpp_display_width (stray, strlen (stray), policy), 1);\n+    /* Don't check width of U+10FFFF; it's in a private use plane.  */\n+  }\n+\n+  richloc.set_escape_on_output (true);\n+\n+  {\n+    test_diagnostic_context dc;\n+    dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_UNICODE;\n+    char_display_policy policy (make_policy (dc, richloc));\n+    ASSERT_EQ (cpp_display_width (pi, strlen (pi), policy), 8);\n+    ASSERT_EQ (cpp_display_width (emoji, strlen (emoji), policy), 9);\n+    ASSERT_EQ (cpp_display_width (stray, strlen (stray), policy), 4);\n+    ASSERT_EQ (cpp_display_width (max_codepoint, strlen (max_codepoint),\n+\t\t\t\t  policy),\n+\t       strlen (\"<U+10FFFF>\"));\n+  }\n+\n+  {\n+    test_diagnostic_context dc;\n+    dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_BYTES;\n+    char_display_policy policy (make_policy (dc, richloc));\n+    ASSERT_EQ (cpp_display_width (pi, strlen (pi), policy), 8);\n+    ASSERT_EQ (cpp_display_width (emoji, strlen (emoji), policy), 16);\n+    ASSERT_EQ (cpp_display_width (stray, strlen (stray), policy), 4);\n+    ASSERT_EQ (cpp_display_width (max_codepoint, strlen (max_codepoint),\n+\t\t\t\t  policy),\n+\t       16);\n+  }\n+}\n+\n /* For precise tests of the layout, make clear where the source line will\n    start.  test_left_margin sets the total byte count from the left side of the\n    screen to the start of source lines, after the line number and the separator,\n@@ -2715,10 +2977,10 @@ test_layout_x_offset_display_utf8 (const line_table_case &case_)\n   char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n   ASSERT_EQ (line_display_cols,\n \t     cpp_display_width (lspan.get_buffer (), lspan.length (),\n-\t\t\t\tdef_tabstop));\n+\t\t\t\tdef_policy ()));\n   ASSERT_EQ (line_display_cols,\n \t     location_compute_display_column (expand_location (line_end),\n-\t\t\t\t\t      def_tabstop));\n+\t\t\t\t\t      def_policy ()));\n   ASSERT_EQ (0, memcmp (lspan.get_buffer () + (emoji_col - 1),\n \t\t\t\"\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\", 8));\n \n@@ -2866,12 +3128,13 @@ test_layout_x_offset_display_tab (const line_table_case &case_)\n   ASSERT_EQ ('\\t', *(lspan.get_buffer () + (tab_col - 1)));\n   for (int tabstop = 1; tabstop != num_tabstops; ++tabstop)\n     {\n+      cpp_char_column_policy policy (tabstop, cpp_wcwidth);\n       ASSERT_EQ (line_bytes + extra_width[tabstop],\n \t\t cpp_display_width (lspan.get_buffer (), lspan.length (),\n-\t\t\t\t    tabstop));\n+\t\t\t\t    policy));\n       ASSERT_EQ (line_bytes + extra_width[tabstop],\n \t\t location_compute_display_column (expand_location (line_end),\n-\t\t\t\t\t\t  tabstop));\n+\t\t\t\t\t\t  policy));\n     }\n \n   /* Check that the tab is expanded to the expected number of spaces.  */\n@@ -4003,6 +4266,43 @@ test_one_liner_labels_utf8 ()\n \t\t\t   \" bb\\xf0\\x9f\\x98\\x82\\xf0\\x9f\\x98\\x82\\n\",\n \t\t  pp_formatted_text (dc.printer));\n   }\n+\n+  /* Example of escaping the source lines.  */\n+  {\n+    text_range_label label0 (\"label 0\\xf0\\x9f\\x98\\x82\");\n+    text_range_label label1 (\"label 1\\xcf\\x80\");\n+    text_range_label label2 (\"label 2\\xcf\\x80\");\n+    gcc_rich_location richloc (foo, &label0);\n+    richloc.add_range (bar, SHOW_RANGE_WITHOUT_CARET, &label1);\n+    richloc.add_range (field, SHOW_RANGE_WITHOUT_CARET, &label2);\n+    richloc.set_escape_on_output (true);\n+\n+    {\n+      test_diagnostic_context dc;\n+      dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_UNICODE;\n+      diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+      ASSERT_STREQ (\" <U+1F602>_foo = <U+03C0>_bar.<U+1F602>_field<U+03C0>;\\n\"\n+\t\t    \" ^~~~~~~~~~~~~   ~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n+\t\t    \" |               |            |\\n\"\n+\t\t    \" |               |            label 2\\xcf\\x80\\n\"\n+\t\t    \" |               label 1\\xcf\\x80\\n\"\n+\t\t    \" label 0\\xf0\\x9f\\x98\\x82\\n\",\n+\t\t    pp_formatted_text (dc.printer));\n+    }\n+    {\n+      test_diagnostic_context dc;\n+      dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_BYTES;\n+      diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+      ASSERT_STREQ\n+\t(\" <f0><9f><98><82>_foo = <cf><80>_bar.<f0><9f><98><82>_field<cf><80>;\\n\"\n+\t \" ^~~~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n+\t \" |                      |            |\\n\"\n+\t \" |                      |            label 2\\xcf\\x80\\n\"\n+\t \" |                      label 1\\xcf\\x80\\n\"\n+\t \" label 0\\xf0\\x9f\\x98\\x82\\n\",\n+\t pp_formatted_text (dc.printer));\n+    }\n+  }\n }\n \n /* Make sure that colorization codes don't interrupt a multibyte\n@@ -4057,9 +4357,9 @@ test_diagnostic_show_locus_one_liner_utf8 (const line_table_case &case_)\n \n   char_span lspan = location_get_source_line (tmp.get_filename (), 1);\n   ASSERT_EQ (25, cpp_display_width (lspan.get_buffer (), lspan.length (),\n-\t\t\t\t    def_tabstop));\n+\t\t\t\t    def_policy ()));\n   ASSERT_EQ (25, location_compute_display_column (expand_location (line_end),\n-\t\t\t\t\t\t  def_tabstop));\n+\t\t\t\t\t\t  def_policy ()));\n \n   test_one_liner_simple_caret_utf8 ();\n   test_one_liner_caret_and_range_utf8 ();\n@@ -4445,30 +4745,31 @@ test_overlapped_fixit_printing (const line_table_case &case_)\n \t\t  pp_formatted_text (dc.printer));\n \n     /* Unit-test the line_corrections machinery.  */\n+    char_display_policy policy (make_policy (dc, richloc));\n     ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n     ASSERT_EQ (column_range (12, 12),\n-\t       get_affected_range (&dc, hint_0, CU_BYTES));\n+\t       get_affected_range (policy, hint_0, CU_BYTES));\n     ASSERT_EQ (column_range (12, 12),\n-\t       get_affected_range (&dc, hint_0, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (12, 22), get_printed_columns (&dc, hint_0));\n+\t       get_affected_range (policy, hint_0, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (12, 22), get_printed_columns (policy, hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n     ASSERT_EQ (column_range (18, 18),\n-\t       get_affected_range (&dc, hint_1, CU_BYTES));\n+\t       get_affected_range (policy, hint_1, CU_BYTES));\n     ASSERT_EQ (column_range (18, 18),\n-\t       get_affected_range (&dc, hint_1, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (18, 20), get_printed_columns (&dc, hint_1));\n+\t       get_affected_range (policy, hint_1, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (18, 20), get_printed_columns (policy, hint_1));\n     const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n     ASSERT_EQ (column_range (29, 28),\n-\t       get_affected_range (&dc, hint_2, CU_BYTES));\n+\t       get_affected_range (policy, hint_2, CU_BYTES));\n     ASSERT_EQ (column_range (29, 28),\n-\t       get_affected_range (&dc, hint_2, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (29, 29), get_printed_columns (&dc, hint_2));\n+\t       get_affected_range (policy, hint_2, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (29, 29), get_printed_columns (policy, hint_2));\n \n     /* Add each hint in turn to a line_corrections instance,\n        and verify that they are consolidated into one correction instance\n        as expected.  */\n-    line_corrections lc (&dc, tmp.get_filename (), 1);\n+    line_corrections lc (policy, tmp.get_filename (), 1);\n \n     /* The first replace hint by itself.  */\n     lc.add_hint (hint_0);\n@@ -4660,30 +4961,31 @@ test_overlapped_fixit_printing_utf8 (const line_table_case &case_)\n \t\t  pp_formatted_text (dc.printer));\n \n     /* Unit-test the line_corrections machinery.  */\n+    char_display_policy policy (make_policy (dc, richloc));\n     ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n     ASSERT_EQ (column_range (14, 14),\n-\t       get_affected_range (&dc, hint_0, CU_BYTES));\n+\t       get_affected_range (policy, hint_0, CU_BYTES));\n     ASSERT_EQ (column_range (12, 12),\n-\t       get_affected_range (&dc, hint_0, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (12, 22), get_printed_columns (&dc, hint_0));\n+\t       get_affected_range (policy, hint_0, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (12, 22), get_printed_columns (policy, hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n     ASSERT_EQ (column_range (22, 22),\n-\t       get_affected_range (&dc, hint_1, CU_BYTES));\n+\t       get_affected_range (policy, hint_1, CU_BYTES));\n     ASSERT_EQ (column_range (18, 18),\n-\t       get_affected_range (&dc, hint_1, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (18, 20), get_printed_columns (&dc, hint_1));\n+\t       get_affected_range (policy, hint_1, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (18, 20), get_printed_columns (policy, hint_1));\n     const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n     ASSERT_EQ (column_range (35, 34),\n-\t       get_affected_range (&dc, hint_2, CU_BYTES));\n+\t       get_affected_range (policy, hint_2, CU_BYTES));\n     ASSERT_EQ (column_range (30, 29),\n-\t       get_affected_range (&dc, hint_2, CU_DISPLAY_COLS));\n-    ASSERT_EQ (column_range (30, 30), get_printed_columns (&dc, hint_2));\n+\t       get_affected_range (policy, hint_2, CU_DISPLAY_COLS));\n+    ASSERT_EQ (column_range (30, 30), get_printed_columns (policy, hint_2));\n \n     /* Add each hint in turn to a line_corrections instance,\n        and verify that they are consolidated into one correction instance\n        as expected.  */\n-    line_corrections lc (&dc, tmp.get_filename (), 1);\n+    line_corrections lc (policy, tmp.get_filename (), 1);\n \n     /* The first replace hint by itself.  */\n     lc.add_hint (hint_0);\n@@ -4877,15 +5179,16 @@ test_overlapped_fixit_printing_2 (const line_table_case &case_)\n     richloc.add_fixit_insert_before (col_21, \"}\");\n \n     /* These fixits should be accepted; they can't be consolidated.  */\n+    char_display_policy policy (make_policy (dc, richloc));\n     ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n     const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n     ASSERT_EQ (column_range (23, 22),\n-\t       get_affected_range (&dc, hint_0, CU_BYTES));\n-    ASSERT_EQ (column_range (23, 23), get_printed_columns (&dc, hint_0));\n+\t       get_affected_range (policy, hint_0, CU_BYTES));\n+    ASSERT_EQ (column_range (23, 23), get_printed_columns (policy, hint_0));\n     const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n     ASSERT_EQ (column_range (21, 20),\n-\t       get_affected_range (&dc, hint_1, CU_BYTES));\n-    ASSERT_EQ (column_range (21, 21), get_printed_columns (&dc, hint_1));\n+\t       get_affected_range (policy, hint_1, CU_BYTES));\n+    ASSERT_EQ (column_range (21, 21), get_printed_columns (policy, hint_1));\n \n     /* Verify that they're printed correctly.  */\n     diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n@@ -5152,10 +5455,11 @@ test_tab_expansion (const line_table_case &case_)\n      ....................123 45678901234 56789012345  columns  */\n \n   const int tabstop = 8;\n+  cpp_char_column_policy policy (tabstop, cpp_wcwidth);\n   const int first_non_ws_byte_col = 7;\n   const int right_quote_byte_col = 15;\n   const int last_byte_col = 25;\n-  ASSERT_EQ (35, cpp_display_width (content, last_byte_col, tabstop));\n+  ASSERT_EQ (35, cpp_display_width (content, last_byte_col, policy));\n \n   temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n   line_table_test ltt (case_);\n@@ -5198,6 +5502,114 @@ test_tab_expansion (const line_table_case &case_)\n   }\n }\n \n+/* Verify that the escaping machinery can cope with a variety of different\n+   invalid bytes.  */\n+\n+static void\n+test_escaping_bytes_1 (const line_table_case &case_)\n+{\n+  const char content[] = \"before\\0\\1\\2\\3\\r\\x80\\xff\"\"after\\n\";\n+  const size_t sz = sizeof (content);\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content, sz);\n+  line_table_test ltt (case_);\n+  const line_map_ordinary *ord_map = linemap_check_ordinary\n+    (linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 0));\n+  linemap_line_start (line_table, 1, 100);\n+\n+  location_t finish\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1,\n+\t\t\t\t\t    strlen (content));\n+\n+  if (finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Locations of the NUL and \\r bytes.  */\n+  location_t nul_loc\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 7);\n+  location_t r_loc\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 11);\n+  gcc_rich_location richloc (nul_loc);\n+  richloc.add_range (r_loc);\n+\n+  {\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\" before \\1\\2\\3 \\x80\\xff\"\"after\\n\"\n+\t\t  \"       ^   ~\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+  richloc.set_escape_on_output (true);\n+  {\n+    test_diagnostic_context dc;\n+    dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_UNICODE;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ\n+      (\" before<U+0000><U+0001><U+0002><U+0003><U+000D><80><ff>after\\n\"\n+       \"       ^~~~~~~~                        ~~~~~~~~\\n\",\n+       pp_formatted_text (dc.printer));\n+  }\n+  {\n+    test_diagnostic_context dc;\n+    dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_BYTES;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\" before<00><01><02><03><0d><80><ff>after\\n\"\n+\t\t  \"       ^~~~            ~~~~\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n+/* As above, but verify that we handle the initial byte of a line\n+   correctly.  */\n+\n+static void\n+test_escaping_bytes_2 (const line_table_case &case_)\n+{\n+  const char content[]  = \"\\0after\\n\";\n+  const size_t sz = sizeof (content);\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", content, sz);\n+  line_table_test ltt (case_);\n+  const line_map_ordinary *ord_map = linemap_check_ordinary\n+    (linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 0));\n+  linemap_line_start (line_table, 1, 100);\n+\n+  location_t finish\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1,\n+\t\t\t\t\t    strlen (content));\n+\n+  if (finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Location of the NUL byte.  */\n+  location_t nul_loc\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 1);\n+  gcc_rich_location richloc (nul_loc);\n+\n+  {\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"  after\\n\"\n+\t\t  \" ^\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+  richloc.set_escape_on_output (true);\n+  {\n+    test_diagnostic_context dc;\n+    dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_UNICODE;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\" <U+0000>after\\n\"\n+\t\t  \" ^~~~~~~~\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+  {\n+    test_diagnostic_context dc;\n+    dc.escape_format = DIAGNOSTICS_ESCAPE_FORMAT_BYTES;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\" <00>after\\n\"\n+\t\t  \" ^~~~\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n /* Verify that line numbers are correctly printed for the case of\n    a multiline range in which the width of the line numbers changes\n    (e.g. from \"9\" to \"10\").  */\n@@ -5254,6 +5666,8 @@ diagnostic_show_locus_c_tests ()\n   test_layout_range_for_single_line ();\n   test_layout_range_for_multiple_lines ();\n \n+  test_display_widths ();\n+\n   for_each_line_table_case (test_layout_x_offset_display_utf8);\n   for_each_line_table_case (test_layout_x_offset_display_tab);\n \n@@ -5274,6 +5688,8 @@ diagnostic_show_locus_c_tests ()\n   for_each_line_table_case (test_fixit_replace_containing_newline);\n   for_each_line_table_case (test_fixit_deletion_affecting_newline);\n   for_each_line_table_case (test_tab_expansion);\n+  for_each_line_table_case (test_escaping_bytes_1);\n+  for_each_line_table_case (test_escaping_bytes_2);\n \n   test_line_numbers_multiline_range ();\n }"}, {"sha": "4ded1760705057b6adb106926c55debc71d4754d", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -230,6 +230,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   context->column_unit = DIAGNOSTICS_COLUMN_UNIT_DISPLAY;\n   context->column_origin = 1;\n   context->tabstop = 8;\n+  context->escape_format = DIAGNOSTICS_ESCAPE_FORMAT_UNICODE;\n   context->edit_context_ptr = NULL;\n   context->diagnostic_group_nesting_depth = 0;\n   context->diagnostic_group_emission_count = 0;\n@@ -393,7 +394,10 @@ convert_column_unit (enum diagnostics_column_unit column_unit,\n       gcc_unreachable ();\n \n     case DIAGNOSTICS_COLUMN_UNIT_DISPLAY:\n-      return location_compute_display_column (s, tabstop);\n+      {\n+\tcpp_char_column_policy policy (tabstop, cpp_wcwidth);\n+\treturn location_compute_display_column (s, policy);\n+      }\n \n     case DIAGNOSTICS_COLUMN_UNIT_BYTE:\n       return s.column;\n@@ -2373,8 +2377,8 @@ test_diagnostic_get_location_text ()\n     const char *const content = \"smile \\xf0\\x9f\\x98\\x82\\n\";\n     const int line_bytes = strlen (content) - 1;\n     const int def_tabstop = 8;\n-    const int display_width = cpp_display_width (content, line_bytes,\n-\t\t\t\t\t\t def_tabstop);\n+    const cpp_char_column_policy policy (def_tabstop, cpp_wcwidth);\n+    const int display_width = cpp_display_width (content, line_bytes, policy);\n     ASSERT_EQ (line_bytes - 2, display_width);\n     temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n     const char *const fname = tmp.get_filename ();"}, {"sha": "c2aea508392776314b522218baa049a3428864dd", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -38,6 +38,20 @@ enum diagnostics_column_unit\n   DIAGNOSTICS_COLUMN_UNIT_BYTE\n };\n \n+/* An enum for controlling how to print non-ASCII characters/bytes when\n+   a diagnostic suggests escaping the source code on output.  */\n+\n+enum diagnostics_escape_format\n+{\n+  /* Escape non-ASCII Unicode characters in the form <U+XXXX> and\n+     non-UTF-8 bytes in the form <XX>.  */\n+  DIAGNOSTICS_ESCAPE_FORMAT_UNICODE,\n+\n+  /* Escape non-ASCII bytes in the form <XX> (thus showing the underlying\n+     encoding of non-ASCII Unicode characters).  */\n+  DIAGNOSTICS_ESCAPE_FORMAT_BYTES\n+};\n+\n /* Enum for overriding the standard output format.  */\n \n enum diagnostics_output_format\n@@ -340,6 +354,10 @@ struct diagnostic_context\n   /* The size of the tabstop for tab expansion.  */\n   int tabstop;\n \n+  /* How should non-ASCII/non-printable bytes be escaped when\n+     a diagnostic suggests escaping the source code on output.  */\n+  enum diagnostics_escape_format escape_format;\n+\n   /* If non-NULL, an edit_context to which fix-it hints should be\n      applied, for generating patches.  */\n   edit_context *edit_context_ptr;"}, {"sha": "c5730228821840efd66b044e77b12d62df44d324", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -312,7 +312,8 @@ Objective-C and Objective-C++ Dialects}.\n -fdiagnostics-show-path-depths @gol\n -fno-show-column @gol\n -fdiagnostics-column-unit=@r{[}display@r{|}byte@r{]} @gol\n--fdiagnostics-column-origin=@var{origin}}\n+-fdiagnostics-column-origin=@var{origin} @gol\n+-fdiagnostics-escape-format=@r{[}unicode@r{|}bytes@r{]}}\n \n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n@@ -5126,6 +5127,38 @@ first column.  The default value of 1 corresponds to traditional GCC\n behavior and to the GNU style guide.  Some utilities may perform better with an\n origin of 0; any non-negative value may be specified.\n \n+@item -fdiagnostics-escape-format=@var{FORMAT}\n+@opindex fdiagnostics-escape-format\n+When GCC prints pertinent source lines for a diagnostic it normally attempts\n+to print the source bytes directly.  However, some diagnostics relate to encoding\n+issues in the source file, such as malformed UTF-8, or issues with Unicode\n+normalization.  These diagnostics are flagged so that GCC will escape bytes\n+that are not printable ASCII when printing their pertinent source lines.\n+\n+This option controls how such bytes should be escaped.\n+\n+The default @var{FORMAT}, @samp{unicode} displays Unicode characters that\n+are not printable ASCII in the form @samp{<U+XXXX>}, and bytes that do not\n+correspond to a Unicode character validly-encoded in UTF-8-encoded will be\n+displayed as hexadecimal in the form @samp{<XX>}.\n+\n+For example, a source line containing the string @samp{before} followed by the\n+Unicode character U+03C0 (``GREEK SMALL LETTER PI'', with UTF-8 encoding\n+0xCF 0x80) followed by the byte 0xBF (a stray UTF-8 trailing byte), followed by\n+the string @samp{after} will be printed for such a diagnostic as:\n+\n+@smallexample\n+ before<U+03C0><BF>after\n+@end smallexample\n+\n+Setting @var{FORMAT} to @samp{bytes} will display all non-printable-ASCII bytes\n+in the form @samp{<XX>}, thus showing the underlying encoding of non-ASCII\n+Unicode characters.  For the example above, the following will be printed:\n+\n+@smallexample\n+ before<CF><80><BF>after\n+@end smallexample\n+\n @item -fdiagnostics-format=@var{FORMAT}\n @opindex fdiagnostics-format\n Select a different format for printing diagnostics.\n@@ -5193,9 +5226,11 @@ might be printed in JSON form (after formatting) like this:\n                         @}\n                     @}\n                 ],\n+                \"escape-source\": false,\n                 \"message\": \"...this statement, but the latter is @dots{}\"\n             @}\n         ]\n+\t\"escape-source\": false,\n \t\"column-origin\": 1,\n     @}\n ]\n@@ -5281,6 +5316,7 @@ of the expression, which have labels.  It might be printed in JSON form as:\n                 \"label\": \"T @{aka struct t@}\"\n             @}\n         ],\n+        \"escape-source\": false,\n         \"message\": \"invalid operands to binary + @dots{}\"\n     @}\n @end smallexample\n@@ -5334,6 +5370,7 @@ might be printed in JSON form as:\n                 @}\n             @}\n         ],\n+        \"escape-source\": false,\n         \"message\": \"\\u2018struct s\\u2019 has no member named @dots{}\"\n     @}\n @end smallexample\n@@ -5391,6 +5428,10 @@ For example, the intraprocedural example shown for\n     ]\n @end smallexample\n \n+Diagnostics have a boolean attribute @code{escape-source}, hinting whether\n+non-ASCII bytes should be escaped when printing the pertinent lines of\n+source code (@code{true} for diagnostics involving source encoding issues).\n+\n @end table\n \n @node Warning Options"}, {"sha": "4650547c7c91bacd6bd63ba97a5975b107f70e20", "filename": "gcc/input.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -1060,15 +1060,16 @@ make_location (location_t caret, source_range src_range)\n    source line in order to calculate the display width.  If that cannot be done\n    for any reason, then returns the byte column as a fallback.  */\n int\n-location_compute_display_column (expanded_location exploc, int tabstop)\n+location_compute_display_column (expanded_location exploc,\n+\t\t\t\t const cpp_char_column_policy &policy)\n {\n   if (!(exploc.file && *exploc.file && exploc.line && exploc.column))\n     return exploc.column;\n   char_span line = location_get_source_line (exploc.file, exploc.line);\n   /* If line is NULL, this function returns exploc.column which is the\n      desired fallback.  */\n   return cpp_byte_column_to_display_column (line.get_buffer (), line.length (),\n-\t\t\t\t\t    exploc.column, tabstop);\n+\t\t\t\t\t    exploc.column, policy);\n }\n \n /* Dump statistics to stderr about the memory usage of the line_table\n@@ -3767,43 +3768,50 @@ test_line_offset_overflow ()\n void test_cpp_utf8 ()\n {\n   const int def_tabstop = 8;\n+  cpp_char_column_policy policy (def_tabstop, cpp_wcwidth);\n+\n   /* Verify that wcwidth of invalid UTF-8 or control bytes is 1.  */\n   {\n-    int w_bad = cpp_display_width (\"\\xf0!\\x9f!\\x98!\\x82!\", 8, def_tabstop);\n+    int w_bad = cpp_display_width (\"\\xf0!\\x9f!\\x98!\\x82!\", 8, policy);\n     ASSERT_EQ (8, w_bad);\n-    int w_ctrl = cpp_display_width (\"\\r\\n\\v\\0\\1\", 5, def_tabstop);\n+    int w_ctrl = cpp_display_width (\"\\r\\n\\v\\0\\1\", 5, policy);\n     ASSERT_EQ (5, w_ctrl);\n   }\n \n   /* Verify that wcwidth of valid UTF-8 is as expected.  */\n   {\n-    const int w_pi = cpp_display_width (\"\\xcf\\x80\", 2, def_tabstop);\n+    const int w_pi = cpp_display_width (\"\\xcf\\x80\", 2, policy);\n     ASSERT_EQ (1, w_pi);\n-    const int w_emoji = cpp_display_width (\"\\xf0\\x9f\\x98\\x82\", 4, def_tabstop);\n+    const int w_emoji = cpp_display_width (\"\\xf0\\x9f\\x98\\x82\", 4, policy);\n     ASSERT_EQ (2, w_emoji);\n     const int w_umlaut_precomposed = cpp_display_width (\"\\xc3\\xbf\", 2,\n-\t\t\t\t\t\t\tdef_tabstop);\n+\t\t\t\t\t\t\tpolicy);\n     ASSERT_EQ (1, w_umlaut_precomposed);\n     const int w_umlaut_combining = cpp_display_width (\"y\\xcc\\x88\", 3,\n-\t\t\t\t\t\t      def_tabstop);\n+\t\t\t\t\t\t      policy);\n     ASSERT_EQ (1, w_umlaut_combining);\n-    const int w_han = cpp_display_width (\"\\xe4\\xb8\\xba\", 3, def_tabstop);\n+    const int w_han = cpp_display_width (\"\\xe4\\xb8\\xba\", 3, policy);\n     ASSERT_EQ (2, w_han);\n-    const int w_ascii = cpp_display_width (\"GCC\", 3, def_tabstop);\n+    const int w_ascii = cpp_display_width (\"GCC\", 3, policy);\n     ASSERT_EQ (3, w_ascii);\n     const int w_mixed = cpp_display_width (\"\\xcf\\x80 = 3.14 \\xf0\\x9f\\x98\\x82\"\n \t\t\t\t\t   \"\\x9f! \\xe4\\xb8\\xba y\\xcc\\x88\",\n-\t\t\t\t\t   24, def_tabstop);\n+\t\t\t\t\t   24, policy);\n     ASSERT_EQ (18, w_mixed);\n   }\n \n   /* Verify that display width properly expands tabs.  */\n   {\n     const char *tstr = \"\\tabc\\td\";\n-    ASSERT_EQ (6, cpp_display_width (tstr, 6, 1));\n-    ASSERT_EQ (10, cpp_display_width (tstr, 6, 3));\n-    ASSERT_EQ (17, cpp_display_width (tstr, 6, 8));\n-    ASSERT_EQ (1, cpp_display_column_to_byte_column (tstr, 6, 7, 8));\n+    ASSERT_EQ (6, cpp_display_width (tstr, 6,\n+\t\t\t\t     cpp_char_column_policy (1, cpp_wcwidth)));\n+    ASSERT_EQ (10, cpp_display_width (tstr, 6,\n+\t\t\t\t      cpp_char_column_policy (3, cpp_wcwidth)));\n+    ASSERT_EQ (17, cpp_display_width (tstr, 6,\n+\t\t\t\t      cpp_char_column_policy (8, cpp_wcwidth)));\n+    ASSERT_EQ (1,\n+\t       cpp_display_column_to_byte_column\n+\t\t (tstr, 6, 7, cpp_char_column_policy (8, cpp_wcwidth)));\n   }\n \n   /* Verify that cpp_byte_column_to_display_column can go past the end,\n@@ -3816,13 +3824,13 @@ void test_cpp_utf8 ()\n       /* 111122223456\n \t Byte columns.  */\n \n-    ASSERT_EQ (5, cpp_display_width (str, 6, def_tabstop));\n+    ASSERT_EQ (5, cpp_display_width (str, 6, policy));\n     ASSERT_EQ (105,\n-\t       cpp_byte_column_to_display_column (str, 6, 106, def_tabstop));\n+\t       cpp_byte_column_to_display_column (str, 6, 106, policy));\n     ASSERT_EQ (10000,\n-\t       cpp_byte_column_to_display_column (NULL, 0, 10000, def_tabstop));\n+\t       cpp_byte_column_to_display_column (NULL, 0, 10000, policy));\n     ASSERT_EQ (0,\n-\t       cpp_byte_column_to_display_column (NULL, 10000, 0, def_tabstop));\n+\t       cpp_byte_column_to_display_column (NULL, 10000, 0, policy));\n   }\n \n   /* Verify that cpp_display_column_to_byte_column can go past the end,\n@@ -3836,25 +3844,25 @@ void test_cpp_utf8 ()\n       /* 000000000000000000000000000000000111111\n \t 111122223333444456666777788889999012345\n \t Byte columns.  */\n-    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 2, def_tabstop));\n+    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 2, policy));\n     ASSERT_EQ (15,\n-\t       cpp_display_column_to_byte_column (str, 15, 11, def_tabstop));\n+\t       cpp_display_column_to_byte_column (str, 15, 11, policy));\n     ASSERT_EQ (115,\n-\t       cpp_display_column_to_byte_column (str, 15, 111, def_tabstop));\n+\t       cpp_display_column_to_byte_column (str, 15, 111, policy));\n     ASSERT_EQ (10000,\n-\t       cpp_display_column_to_byte_column (NULL, 0, 10000, def_tabstop));\n+\t       cpp_display_column_to_byte_column (NULL, 0, 10000, policy));\n     ASSERT_EQ (0,\n-\t       cpp_display_column_to_byte_column (NULL, 10000, 0, def_tabstop));\n+\t       cpp_display_column_to_byte_column (NULL, 10000, 0, policy));\n \n     /* Verify that we do not interrupt a UTF-8 sequence.  */\n-    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 1, def_tabstop));\n+    ASSERT_EQ (4, cpp_display_column_to_byte_column (str, 15, 1, policy));\n \n     for (int byte_col = 1; byte_col <= 15; ++byte_col)\n       {\n \tconst int disp_col\n-\t  = cpp_byte_column_to_display_column (str, 15, byte_col, def_tabstop);\n+\t  = cpp_byte_column_to_display_column (str, 15, byte_col, policy);\n \tconst int byte_col2\n-\t  = cpp_display_column_to_byte_column (str, 15, disp_col, def_tabstop);\n+\t  = cpp_display_column_to_byte_column (str, 15, disp_col, policy);\n \n \t/* If we ask for the display column in the middle of a UTF-8\n \t   sequence, it will return the length of the partial sequence,"}, {"sha": "f7b08bdc444896f29ad78e19d69b698679b90c84", "filename": "gcc/input.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -39,8 +39,11 @@ STATIC_ASSERT (BUILTINS_LOCATION < RESERVED_LOCATION_COUNT);\n extern bool is_location_from_builtin_token (location_t);\n extern expanded_location expand_location (location_t);\n \n-extern int location_compute_display_column (expanded_location exploc,\n-\t\t\t\t\t    int tabstop);\n+class cpp_char_column_policy;\n+\n+extern int\n+location_compute_display_column (expanded_location exploc,\n+\t\t\t\t const cpp_char_column_policy &policy);\n \n /* A class capturing the bounds of a buffer, to allow for run-time\n    bounds-checking in a checked build.  */"}, {"sha": "3f80fce82bcc7ab664266a64b742421f6ef2d614", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -2734,6 +2734,10 @@ common_handle_option (struct gcc_options *opts,\n       dc->column_origin = value;\n       break;\n \n+    case OPT_fdiagnostics_escape_format_:\n+      dc->escape_format = (enum diagnostics_escape_format)value;\n+      break;\n+\n     case OPT_fdiagnostics_show_cwe:\n       dc->show_cwe = value;\n       break;"}, {"sha": "13ec4f0f61cbcd8d64c40a3d4b93adf0bc03886e", "filename": "gcc/selftest.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -192,6 +192,21 @@ temp_source_file::temp_source_file (const location &loc,\n   fclose (out);\n }\n \n+/* As above, but with a size, to allow for NUL bytes in CONTENT.  */\n+\n+temp_source_file::temp_source_file (const location &loc,\n+\t\t\t\t    const char *suffix,\n+\t\t\t\t    const char *content,\n+\t\t\t\t    size_t sz)\n+: named_temp_file (suffix)\n+{\n+  FILE *out = fopen (get_filename (), \"w\");\n+  if (!out)\n+    fail_formatted (loc, \"unable to open tempfile: %s\", get_filename ());\n+  fwrite (content, sz, 1, out);\n+  fclose (out);\n+}\n+\n /* Avoid introducing locale-specific differences in the results\n    by hardcoding open_quote and close_quote.  */\n "}, {"sha": "24ef57cb6cc0225a33e6d00fad74259eb8abbfbc", "filename": "gcc/selftest.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -112,6 +112,8 @@ class temp_source_file : public named_temp_file\n  public:\n   temp_source_file (const location &loc, const char *suffix,\n \t\t    const char *content);\n+  temp_source_file (const location &loc, const char *suffix,\n+\t\t    const char *content, size_t sz);\n };\n \n /* RAII-style class for avoiding introducing locale-specific differences"}, {"sha": "af57eb636d501b7378813b0c545020decf6e3766", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-1.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -9,6 +9,7 @@\n \n /* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n /* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n+/* { dg-regexp \"\\\"escape-source\\\": false\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"#error message\\\"\" } */\n \n /* { dg-regexp \"\\\"caret\\\": \\{\" } */"}, {"sha": "edb802efb8df307e19c61b4eb1e97d826ef78a3d", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-2.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -9,6 +9,7 @@\n \n /* { dg-regexp \"\\\"kind\\\": \\\"warning\\\"\" } */\n /* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n+/* { dg-regexp \"\\\"escape-source\\\": false\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" } */\n /* { dg-regexp \"\\\"option\\\": \\\"-Wcpp\\\"\" } */\n /* { dg-regexp \"\\\"option_url\\\": \\\"https:\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" } */"}, {"sha": "bb7b8dc5d1611f860a2969e7577d333681b01c95", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-3.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -9,6 +9,7 @@\n \n /* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n /* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n+/* { dg-regexp \"\\\"escape-source\\\": false\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" } */\n /* { dg-regexp \"\\\"option\\\": \\\"-Werror=cpp\\\"\" } */\n /* { dg-regexp \"\\\"option_url\\\": \\\"https:\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" } */"}, {"sha": "8ac90723cbd73c74e75a2ce3eb1a5ffe48b7a325", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-4.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-4.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -19,6 +19,7 @@ int test (void)\n \n /* { dg-regexp \"\\\"kind\\\": \\\"note\\\"\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'\\\"\" } */\n+/* { dg-regexp \"\\\"escape-source\\\": false\" } */\n \n /* { dg-regexp \"\\\"caret\\\": \\{\" } */\n /* { dg-regexp \"\\\"file\\\": \\\"\\[^\\n\\r\\\"\\]*diagnostic-format-json-4.c\\\"\" } */\n@@ -39,6 +40,7 @@ int test (void)\n /* { dg-regexp \"\\\"kind\\\": \\\"warning\\\"\" } */\n /* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n /* { dg-regexp \"\\\"message\\\": \\\"this 'if' clause does not guard...\\\"\" } */\n+/* { dg-regexp \"\\\"escape-source\\\": false\" } */\n /* { dg-regexp \"\\\"option\\\": \\\"-Wmisleading-indentation\\\"\" } */\n /* { dg-regexp \"\\\"option_url\\\": \\\"https:\\[^\\n\\r\\\"\\]*#index-Wmisleading-indentation\\\"\" } */\n "}, {"sha": "8d2eb0c5089fc4ffe24105aa272ecc93d29d4c2e", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-json-5.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-json-5.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -14,6 +14,7 @@ int test (struct s *ptr)\n \n /* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n /* { dg-regexp \"\\\"column-origin\\\": 1\" } */\n+/* { dg-regexp \"\\\"escape-source\\\": false\" } */\n /* { dg-regexp \"\\\"message\\\": \\\".*\\\"\" } */\n \n /* Verify fix-it hints.  */"}, {"sha": "e6e1f3ef63f987dcb3e6db48bc5e146a06ae1bd6", "filename": "gcc/testsuite/gcc.dg/cpp/warn-normalized-4-bytes.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fwarn-normalized-4-bytes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fwarn-normalized-4-bytes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fwarn-normalized-4-bytes.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do preprocess }\n+// { dg-options \"-std=gnu99 -Werror=normalized=nfc -fdiagnostics-show-caret -fdiagnostics-escape-format=bytes\" }\n+/* { dg-message \"some warnings being treated as errors\" \"\" {target \"*-*-*\"} 0 } */\n+\n+/* \u0f43 = U+0F43 TIBETAN LETTER GHA, which has decomposition \"0F42 0FB7\" i.e.\n+   U+0F42 TIBETAN LETTER GA: \u0f42\n+   U+0FB7 TIBETAN SUBJOINED LETTER HA: \u0fb7\n+\n+   The UTF-8 encoding of U+0F43 TIBETAN LETTER GHA is: E0 BD 83.  */\n+\n+foo before_\\u0F43_after bar // { dg-error \"`before_.U00000f43_after' is not in NFC .-Werror=normalized=.\" }\n+/* { dg-begin-multiline-output \"\" }\n+ foo before_\\u0F43_after bar\n+     ^~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+foo before_\u0f43_after bar // { dg-error \"`before_.U00000f43_after' is not in NFC .-Werror=normalized=.\" }\n+/* { dg-begin-multiline-output \"\" }\n+ foo before_<e0><bd><83>_after bar\n+     ^~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "f9f2f7a79f32fe3ab74ef55b7a69bbb25c1b5199", "filename": "gcc/testsuite/gcc.dg/cpp/warn-normalized-4-unicode.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fwarn-normalized-4-unicode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fwarn-normalized-4-unicode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fwarn-normalized-4-unicode.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do preprocess }\n+// { dg-options \"-std=gnu99 -Werror=normalized=nfc -fdiagnostics-show-caret -fdiagnostics-escape-format=unicode\" }\n+/* { dg-message \"some warnings being treated as errors\" \"\" {target \"*-*-*\"} 0 } */\n+\n+/* \u0f43 = U+0F43 TIBETAN LETTER GHA, which has decomposition \"0F42 0FB7\" i.e.\n+   U+0F42 TIBETAN LETTER GA: \u0f42\n+   U+0FB7 TIBETAN SUBJOINED LETTER HA: \u0fb7  */\n+\n+foo before_\\u0F43_after bar  // { dg-error \"`before_.U00000f43_after' is not in NFC .-Werror=normalized=.\" }\n+/* { dg-begin-multiline-output \"\" }\n+ foo before_\\u0F43_after bar\n+     ^~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+foo before_\u0f43_after bar // { dg-error \"`before_.U00000f43_after' is not in NFC .-Werror=normalized=.\" }\n+/* { dg-begin-multiline-output \"\" }\n+ foo before_<U+0F43>_after bar\n+     ^~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "d3dc59f35309b2c091900ded15abd204368bd3c8", "filename": "gcc/testsuite/gcc.dg/encoding-issues-bytes.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fencoding-issues-bytes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fencoding-issues-bytes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fencoding-issues-bytes.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e"}, {"sha": "39f371307d8ce75f65524aa8a00e7f46f4aecbe1", "filename": "gcc/testsuite/gcc.dg/encoding-issues-unicode.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fencoding-issues-unicode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgcc.dg%2Fencoding-issues-unicode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fencoding-issues-unicode.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e"}, {"sha": "2993f7c852bf4207943cd86421dd96978db57a10", "filename": "gcc/testsuite/gfortran.dg/diagnostic-format-json-1.F90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-1.F90?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -9,6 +9,7 @@\n \n ! { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" }\n ! { dg-regexp \"\\\"column-origin\\\": 1\" }\n+! { dg-regexp \"\\\"escape-source\\\": false\" }\n ! { dg-regexp \"\\\"message\\\": \\\"#error message\\\"\" }\n \n ! { dg-regexp \"\\\"caret\\\": \\{\" }"}, {"sha": "1681462fa086ab2e18f054c8d8c2ee4692175077", "filename": "gcc/testsuite/gfortran.dg/diagnostic-format-json-2.F90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-2.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-2.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-2.F90?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -9,6 +9,7 @@\n \n ! { dg-regexp \"\\\"kind\\\": \\\"warning\\\"\" }\n ! { dg-regexp \"\\\"column-origin\\\": 1\" }\n+! { dg-regexp \"\\\"escape-source\\\": false\" }\n ! { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" }\n ! { dg-regexp \"\\\"option\\\": \\\"-Wcpp\\\"\" }\n ! { dg-regexp \"\\\"option_url\\\": \\\"\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" }"}, {"sha": "f0a67de76b083bacd4e065a40c15b6cd2ce704a0", "filename": "gcc/testsuite/gfortran.dg/diagnostic-format-json-3.F90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdiagnostic-format-json-3.F90?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -9,6 +9,7 @@\n \n ! { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" }\n ! { dg-regexp \"\\\"column-origin\\\": 1\" }\n+! { dg-regexp \"\\\"escape-source\\\": false\" }\n ! { dg-regexp \"\\\"message\\\": \\\"#warning message\\\"\" }\n ! { dg-regexp \"\\\"option\\\": \\\"-Werror=cpp\\\"\" }\n ! { dg-regexp \"\\\"option_url\\\": \\\"\\[^\\n\\r\\\"\\]*#index-Wcpp\\\"\" }"}, {"sha": "0b0ccc6c021ed2ca0890c73239213b824c8eee65", "filename": "libcpp/charset.c", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -1582,12 +1582,14 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \t\t   \"unknown escape sequence: '\\\\%c'\", (int) c);\n       else\n \t{\n+\t  encoding_rich_location rich_loc (pfile);\n+\n \t  /* diagnostic.c does not support \"%03o\".  When it does, this\n \t     code can use %03o directly in the diagnostic again.  */\n \t  char buf[32];\n \t  sprintf(buf, \"%03o\", (int) c);\n-\t  cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t     \"unknown escape sequence: '\\\\%s'\", buf);\n+\t  cpp_error_at (pfile, CPP_DL_PEDWARN, &rich_loc,\n+\t\t\t\"unknown escape sequence: '\\\\%s'\", buf);\n \t}\n     }\n \n@@ -2345,14 +2347,16 @@ cpp_string_location_reader::get_next ()\n }\n \n cpp_display_width_computation::\n-cpp_display_width_computation (const char *data, int data_length, int tabstop) :\n+cpp_display_width_computation (const char *data, int data_length,\n+\t\t\t       const cpp_char_column_policy &policy) :\n   m_begin (data),\n   m_next (m_begin),\n   m_bytes_left (data_length),\n-  m_tabstop (tabstop),\n+  m_policy (policy),\n   m_display_cols (0)\n {\n-  gcc_assert (m_tabstop > 0);\n+  gcc_assert (policy.m_tabstop > 0);\n+  gcc_assert (policy.m_width_cb);\n }\n \n \n@@ -2364,19 +2368,28 @@ cpp_display_width_computation (const char *data, int data_length, int tabstop) :\n    point to a valid UTF-8-encoded sequence, then it will be treated as a single\n    byte with display width 1.  m_cur_display_col is the current display column,\n    relative to which tab stops should be expanded.  Returns the display width of\n-   the codepoint just processed.  */\n+   the codepoint just processed.\n+   If OUT is non-NULL, it is populated.  */\n \n int\n-cpp_display_width_computation::process_next_codepoint ()\n+cpp_display_width_computation::process_next_codepoint (cpp_decoded_char *out)\n {\n   cppchar_t c;\n   int next_width;\n \n+  if (out)\n+    out->m_start_byte = m_next;\n+\n   if (*m_next == '\\t')\n     {\n       ++m_next;\n       --m_bytes_left;\n-      next_width = m_tabstop - (m_display_cols % m_tabstop);\n+      next_width = m_policy.m_tabstop - (m_display_cols % m_policy.m_tabstop);\n+      if (out)\n+\t{\n+\t  out->m_ch = '\\t';\n+\t  out->m_valid_ch = true;\n+\t}\n     }\n   else if (one_utf8_to_cppchar ((const uchar **) &m_next, &m_bytes_left, &c)\n \t   != 0)\n@@ -2386,14 +2399,24 @@ cpp_display_width_computation::process_next_codepoint ()\n \t of one.  */\n       ++m_next;\n       --m_bytes_left;\n-      next_width = 1;\n+      next_width = m_policy.m_undecoded_byte_width;\n+      if (out)\n+\tout->m_valid_ch = false;\n     }\n   else\n     {\n       /*  one_utf8_to_cppchar() has updated m_next and m_bytes_left for us.  */\n-      next_width = cpp_wcwidth (c);\n+      next_width = m_policy.m_width_cb (c);\n+      if (out)\n+\t{\n+\t  out->m_ch = c;\n+\t  out->m_valid_ch = true;\n+\t}\n     }\n \n+  if (out)\n+    out->m_next_byte = m_next;\n+\n   m_display_cols += next_width;\n   return next_width;\n }\n@@ -2409,37 +2432,41 @@ cpp_display_width_computation::advance_display_cols (int n)\n   const int start = m_display_cols;\n   const int target = start + n;\n   while (m_display_cols < target && !done ())\n-    process_next_codepoint ();\n+    process_next_codepoint (NULL);\n   return m_display_cols - start;\n }\n \n /*  For the string of length DATA_LENGTH bytes that begins at DATA, compute\n     how many display columns are occupied by the first COLUMN bytes.  COLUMN\n     may exceed DATA_LENGTH, in which case the phantom bytes at the end are\n     treated as if they have display width 1.  Tabs are expanded to the next tab\n-    stop, relative to the start of DATA.  */\n+    stop, relative to the start of DATA, and non-printable-ASCII characters\n+    will be escaped as per POLICY.  */\n \n int\n cpp_byte_column_to_display_column (const char *data, int data_length,\n-\t\t\t\t   int column, int tabstop)\n+\t\t\t\t   int column,\n+\t\t\t\t   const cpp_char_column_policy &policy)\n {\n   const int offset = MAX (0, column - data_length);\n-  cpp_display_width_computation dw (data, column - offset, tabstop);\n+  cpp_display_width_computation dw (data, column - offset, policy);\n   while (!dw.done ())\n-    dw.process_next_codepoint ();\n+    dw.process_next_codepoint (NULL);\n   return dw.display_cols_processed () + offset;\n }\n \n /*  For the string of length DATA_LENGTH bytes that begins at DATA, compute\n     the least number of bytes that will result in at least DISPLAY_COL display\n     columns.  The return value may exceed DATA_LENGTH if the entire string does\n-    not occupy enough display columns.  */\n+    not occupy enough display columns.  Non-printable-ASCII characters\n+    will be escaped as per POLICY.  */\n \n int\n cpp_display_column_to_byte_column (const char *data, int data_length,\n-\t\t\t\t   int display_col, int tabstop)\n+\t\t\t\t   int display_col,\n+\t\t\t\t   const cpp_char_column_policy &policy)\n {\n-  cpp_display_width_computation dw (data, data_length, tabstop);\n+  cpp_display_width_computation dw (data, data_length, policy);\n   const int avail_display = dw.advance_display_cols (display_col);\n   return dw.bytes_processed () + MAX (0, display_col - avail_display);\n }"}, {"sha": "f34334a63b5cff3515cecccf07ed8ef4307ff7d0", "filename": "libcpp/errors.c", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ferrors.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -27,6 +27,31 @@ along with this program; see the file COPYING3.  If not see\n #include \"cpplib.h\"\n #include \"internal.h\"\n \n+/* Get a location_t for the current location in PFILE,\n+   generally that of the previously lexed token.  */\n+\n+location_t\n+cpp_diagnostic_get_current_location (cpp_reader *pfile)\n+{\n+  if (CPP_OPTION (pfile, traditional))\n+    {\n+      if (pfile->state.in_directive)\n+\treturn pfile->directive_line;\n+      else\n+\treturn pfile->line_table->highest_line;\n+    }\n+  /* We don't want to refer to a token before the beginning of the\n+     current run -- that is invalid.  */\n+  else if (pfile->cur_token == pfile->cur_run->base)\n+    {\n+      return 0;\n+    }\n+  else\n+    {\n+      return pfile->cur_token[-1].src_loc;\n+    }\n+}\n+\n /* Print a diagnostic at the given location.  */\n \n ATTRIBUTE_FPTR_PRINTF(5,0)\n@@ -52,25 +77,7 @@ cpp_diagnostic (cpp_reader * pfile, enum cpp_diagnostic_level level,\n \t\tenum cpp_warning_reason reason,\n \t\tconst char *msgid, va_list *ap)\n {\n-  location_t src_loc;\n-\n-  if (CPP_OPTION (pfile, traditional))\n-    {\n-      if (pfile->state.in_directive)\n-\tsrc_loc = pfile->directive_line;\n-      else\n-\tsrc_loc = pfile->line_table->highest_line;\n-    }\n-  /* We don't want to refer to a token before the beginning of the\n-     current run -- that is invalid.  */\n-  else if (pfile->cur_token == pfile->cur_run->base)\n-    {\n-      src_loc = 0;\n-    }\n-  else\n-    {\n-      src_loc = pfile->cur_token[-1].src_loc;\n-    }\n+  location_t src_loc = cpp_diagnostic_get_current_location (pfile);\n   rich_location richloc (pfile->line_table, src_loc);\n   return cpp_diagnostic_at (pfile, level, reason, &richloc, msgid, ap);\n }\n@@ -144,6 +151,43 @@ cpp_warning_syshdr (cpp_reader * pfile, enum cpp_warning_reason reason,\n   return ret;\n }\n \n+/* As cpp_warning above, but use RICHLOC as the location of the diagnostic.  */\n+\n+bool cpp_warning_at (cpp_reader *pfile, enum cpp_warning_reason reason,\n+\t\t     rich_location *richloc, const char *msgid, ...)\n+{\n+  va_list ap;\n+  bool ret;\n+\n+  va_start (ap, msgid);\n+\n+  ret = cpp_diagnostic_at (pfile, CPP_DL_WARNING, reason, richloc,\n+\t\t\t   msgid, &ap);\n+\n+  va_end (ap);\n+  return ret;\n+\n+}\n+\n+/* As cpp_pedwarning above, but use RICHLOC as the location of the\n+   diagnostic.  */\n+\n+bool\n+cpp_pedwarning_at (cpp_reader * pfile, enum cpp_warning_reason reason,\n+\t\t   rich_location *richloc, const char *msgid, ...)\n+{\n+  va_list ap;\n+  bool ret;\n+\n+  va_start (ap, msgid);\n+\n+  ret = cpp_diagnostic_at (pfile, CPP_DL_PEDWARN, reason, richloc,\n+\t\t\t   msgid, &ap);\n+\n+  va_end (ap);\n+  return ret;\n+}\n+\n /* Print a diagnostic at a specific location.  */\n \n ATTRIBUTE_FPTR_PRINTF(6,0)"}, {"sha": "176f8c5bbce95595822c6c60b06a77446e2fcd5c", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -1268,6 +1268,14 @@ extern bool cpp_warning_syshdr (cpp_reader *, enum cpp_warning_reason reason,\n \t\t\t\tconst char *msgid, ...)\n   ATTRIBUTE_PRINTF_3;\n \n+/* As their counterparts above, but use RICHLOC.  */\n+extern bool cpp_warning_at (cpp_reader *, enum cpp_warning_reason,\n+\t\t\t    rich_location *richloc, const char *msgid, ...)\n+  ATTRIBUTE_PRINTF_4;\n+extern bool cpp_pedwarning_at (cpp_reader *, enum cpp_warning_reason,\n+\t\t\t       rich_location *richloc, const char *msgid, ...)\n+  ATTRIBUTE_PRINTF_4;\n+\n /* Output a diagnostic with \"MSGID: \" preceding the\n    error string of errno.  No location is printed.  */\n extern bool cpp_errno (cpp_reader *, enum cpp_diagnostic_level,\n@@ -1442,43 +1450,95 @@ extern const char * cpp_get_userdef_suffix\n \n /* In charset.c */\n \n+/* The result of attempting to decode a run of UTF-8 bytes.  */\n+\n+struct cpp_decoded_char\n+{\n+  const char *m_start_byte;\n+  const char *m_next_byte;\n+\n+  bool m_valid_ch;\n+  cppchar_t m_ch;\n+};\n+\n+/* Information for mapping between code points and display columns.\n+\n+   This is a tabstop value, along with a callback for getting the\n+   widths of characters.  Normally this callback is cpp_wcwidth, but we\n+   support other schemes for escaping non-ASCII unicode as a series of\n+   ASCII chars when printing the user's source code in diagnostic-show-locus.c\n+\n+   For example, consider:\n+   - the Unicode character U+03C0 \"GREEK SMALL LETTER PI\" (UTF-8: 0xCF 0x80)\n+   - the Unicode character U+1F642 \"SLIGHTLY SMILING FACE\"\n+     (UTF-8: 0xF0 0x9F 0x99 0x82)\n+   - the byte 0xBF (a stray trailing byte of a UTF-8 character)\n+   Normally U+03C0 would occupy one display column, U+1F642\n+   would occupy two display columns, and the stray byte would be\n+   printed verbatim as one display column.\n+\n+   However when escaping them as unicode code points as \"<U+03C0>\"\n+   and \"<U+1F642>\" they occupy 8 and 9 display columns respectively,\n+   and when escaping them as bytes as \"<CF><80>\" and \"<F0><9F><99><82>\"\n+   they occupy 8 and 16 display columns respectively.  In both cases\n+   the stray byte is escaped to <BF> as 4 display columns.  */\n+\n+struct cpp_char_column_policy\n+{\n+  cpp_char_column_policy (int tabstop,\n+\t\t\t  int (*width_cb) (cppchar_t c))\n+  : m_tabstop (tabstop),\n+    m_undecoded_byte_width (1),\n+    m_width_cb (width_cb)\n+  {}\n+\n+  int m_tabstop;\n+  /* Width in display columns of a stray byte that isn't decodable\n+     as UTF-8.  */\n+  int m_undecoded_byte_width;\n+  int (*m_width_cb) (cppchar_t c);\n+};\n+\n /* A class to manage the state while converting a UTF-8 sequence to cppchar_t\n    and computing the display width one character at a time.  */\n class cpp_display_width_computation {\n  public:\n   cpp_display_width_computation (const char *data, int data_length,\n-\t\t\t\t int tabstop);\n+\t\t\t\t const cpp_char_column_policy &policy);\n   const char *next_byte () const { return m_next; }\n   int bytes_processed () const { return m_next - m_begin; }\n   int bytes_left () const { return m_bytes_left; }\n   bool done () const { return !bytes_left (); }\n   int display_cols_processed () const { return m_display_cols; }\n \n-  int process_next_codepoint ();\n+  int process_next_codepoint (cpp_decoded_char *out);\n   int advance_display_cols (int n);\n \n  private:\n   const char *const m_begin;\n   const char *m_next;\n   size_t m_bytes_left;\n-  const int m_tabstop;\n+  const cpp_char_column_policy &m_policy;\n   int m_display_cols;\n };\n \n /* Convenience functions that are simple use cases for class\n    cpp_display_width_computation.  Tab characters will be expanded to spaces\n-   as determined by TABSTOP.  */\n+   as determined by POLICY.m_tabstop, and non-printable-ASCII characters\n+   will be escaped as per POLICY.  */\n \n int cpp_byte_column_to_display_column (const char *data, int data_length,\n-\t\t\t\t       int column, int tabstop);\n+\t\t\t\t       int column,\n+\t\t\t\t       const cpp_char_column_policy &policy);\n inline int cpp_display_width (const char *data, int data_length,\n-\t\t\t      int tabstop)\n+\t\t\t      const cpp_char_column_policy &policy)\n {\n   return cpp_byte_column_to_display_column (data, data_length, data_length,\n-\t\t\t\t\t    tabstop);\n+\t\t\t\t\t    policy);\n }\n int cpp_display_column_to_byte_column (const char *data, int data_length,\n-\t\t\t\t       int display_col, int tabstop);\n+\t\t\t\t       int display_col,\n+\t\t\t\t       const cpp_char_column_policy &policy);\n int cpp_wcwidth (cppchar_t c);\n \n bool cpp_input_conversion_is_trivial (const char *input_charset);"}, {"sha": "8b5e2f8298269d48847632606fcd775fe2655cb7", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -1787,6 +1787,18 @@ class rich_location\n   const diagnostic_path *get_path () const { return m_path; }\n   void set_path (const diagnostic_path *path) { m_path = path; }\n \n+  /* A flag for hinting that the diagnostic involves character encoding\n+     issues, and thus that it will be helpful to the user if we show some\n+     representation of how the characters in the pertinent source lines\n+     are encoded.\n+     The default is false (i.e. do not escape).\n+     When set to true, non-ASCII bytes in the pertinent source lines will\n+     be escaped in a manner controlled by the user-supplied option\n+     -fdiagnostics-escape-format=, so that the user can better understand\n+     what's going on with the encoding in their source file.  */\n+  bool escape_on_output_p () const { return m_escape_on_output; }\n+  void set_escape_on_output (bool flag) { m_escape_on_output = flag; }\n+\n private:\n   bool reject_impossible_fixit (location_t where);\n   void stop_supporting_fixits ();\n@@ -1813,6 +1825,7 @@ class rich_location\n   bool m_fixits_cannot_be_auto_applied;\n \n   const diagnostic_path *m_path;\n+  bool m_escape_on_output;\n };\n \n /* A struct for the result of range_label::get_text: a NUL-terminated buffer"}, {"sha": "8577cab6c83ec537e2f0c04b710bbffe83390e34", "filename": "libcpp/internal.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -769,6 +769,9 @@ extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,\n extern void _cpp_pop_buffer (cpp_reader *);\n extern char *_cpp_bracket_include (cpp_reader *);\n \n+/* In errors.c  */\n+extern location_t cpp_diagnostic_get_current_location (cpp_reader *);\n+\n /* In traditional.c.  */\n extern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *, bool);\n extern bool _cpp_read_logical_line_trad (cpp_reader *);\n@@ -935,6 +938,26 @@ int linemap_get_expansion_line (class line_maps *,\n const char* linemap_get_expansion_filename (class line_maps *,\n \t\t\t\t\t    location_t);\n \n+/* A subclass of rich_location for emitting a diagnostic\n+   at the current location of the reader, but flagging\n+   it with set_escape_on_output (true).  */\n+class encoding_rich_location : public rich_location\n+{\n+ public:\n+  encoding_rich_location (cpp_reader *pfile)\n+  : rich_location (pfile->line_table,\n+\t\t   cpp_diagnostic_get_current_location (pfile))\n+  {\n+    set_escape_on_output (true);\n+  }\n+\n+  encoding_rich_location (cpp_reader *pfile, location_t loc)\n+  : rich_location (pfile->line_table, loc)\n+  {\n+    set_escape_on_output (true);\n+  }\n+};\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "fa2253d41c38176458b30c15febd8d41fa484bd2", "filename": "libcpp/lex.c", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -1268,7 +1268,11 @@ skip_whitespace (cpp_reader *pfile, cppchar_t c)\n   while (is_nvspace (c));\n \n   if (saw_NUL)\n-    cpp_error (pfile, CPP_DL_WARNING, \"null character(s) ignored\");\n+    {\n+      encoding_rich_location rich_loc (pfile);\n+      cpp_error_at (pfile, CPP_DL_WARNING, &rich_loc,\n+\t\t    \"null character(s) ignored\");\n+    }\n \n   buffer->cur--;\n }\n@@ -1297,21 +1301,43 @@ warn_about_normalization (cpp_reader *pfile,\n   if (CPP_OPTION (pfile, warn_normalize) < NORMALIZE_STATE_RESULT (s)\n       && !pfile->state.skipping)\n     {\n+      location_t loc = token->src_loc;\n+\n+      /* If possible, create a location range for the token.  */\n+      if (loc >= RESERVED_LOCATION_COUNT\n+\t  && token->type != CPP_EOF\n+\t  /* There must be no line notes to process.  */\n+\t  && (!(pfile->buffer->cur\n+\t\t>= pfile->buffer->notes[pfile->buffer->cur_note].pos\n+\t\t&& !pfile->overlaid_buffer)))\n+\t{\n+\t  source_range tok_range;\n+\t  tok_range.m_start = loc;\n+\t  tok_range.m_finish\n+\t    = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t\t   CPP_BUF_COLUMN (pfile->buffer,\n+\t\t\t\t\t\t\t   pfile->buffer->cur));\n+\t  loc = COMBINE_LOCATION_DATA (pfile->line_table,\n+\t\t\t\t       loc, tok_range, NULL);\n+\t}\n+\n+      encoding_rich_location rich_loc (pfile, loc);\n+\n       /* Make sure that the token is printed using UCNs, even\n \t if we'd otherwise happily print UTF-8.  */\n       unsigned char *buf = XNEWVEC (unsigned char, cpp_token_len (token));\n       size_t sz;\n \n       sz = cpp_spell_token (pfile, token, buf, false) - buf;\n       if (NORMALIZE_STATE_RESULT (s) == normalized_C)\n-\tcpp_warning_with_line (pfile, CPP_W_NORMALIZE, token->src_loc, 0,\n-\t\t\t       \"`%.*s' is not in NFKC\", (int) sz, buf);\n+\tcpp_warning_at (pfile, CPP_W_NORMALIZE, &rich_loc,\n+\t\t\t\"`%.*s' is not in NFKC\", (int) sz, buf);\n       else if (CPP_OPTION (pfile, cxx23_identifiers))\n-\tcpp_pedwarning_with_line (pfile, CPP_W_NORMALIZE, token->src_loc, 0,\n+\tcpp_pedwarning_at (pfile, CPP_W_NORMALIZE, &rich_loc,\n \t\t\t\t  \"`%.*s' is not in NFC\", (int) sz, buf);\n       else\n-\tcpp_warning_with_line (pfile, CPP_W_NORMALIZE, token->src_loc, 0,\n-\t\t\t       \"`%.*s' is not in NFC\", (int) sz, buf);\n+\tcpp_warning_at (pfile, CPP_W_NORMALIZE, &rich_loc,\n+\t\t\t\"`%.*s' is not in NFC\", (int) sz, buf);\n       free (buf);\n     }\n }"}, {"sha": "1957dd712c82921748935436688f904d2cd1dec5", "filename": "libcpp/line-map.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5e882cf6e0def3dd1bc106075d59a303fe0d1e/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=bd5e882cf6e0def3dd1bc106075d59a303fe0d1e", "patch": "@@ -2086,7 +2086,8 @@ rich_location::rich_location (line_maps *set, location_t loc,\n   m_fixit_hints (),\n   m_seen_impossible_fixit (false),\n   m_fixits_cannot_be_auto_applied (false),\n-  m_path (NULL)\n+  m_path (NULL),\n+  m_escape_on_output (false)\n {\n   add_range (loc, SHOW_RANGE_WITH_CARET, label);\n }"}]}