{"sha": "3202e9f88fd286a8fc4814abeaa2238d70f4d585", "node_id": "C_kwDOANBUbNoAKDMyMDJlOWY4OGZkMjg2YThmYzQ4MTRhYmVhYTIyMzhkNzBmNGQ1ODU", "commit": {"author": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-06-02T07:52:21Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-06T13:29:48Z"}, "message": "[Ada] Handle secondary stack memory allocations alignment\n\nTo accomodate cases where objects allocated on the secondary stack\nneeded a more constrained alignement than Standard'Maximum_Alignement,\nthe alignment for all allocations in the full runtime were forced on to\nbe aligned on Standard'Maximum_Alignement*2. This changes removes this\nworkaround and correctly handles the over-alignment in all runtimes.\n\nThis change modifies the SS_Allocate procedure to accept a new Alignment\nparameter and to dynamically realign the pointer returned by the memory\nallocation (Allocate_* functions or dedicated stack allocations for\nzfp/cert).\n\nIt also simplifies the 0-sized allocations by not allocating any memory\nif pointer is already correctly aligned (already the case in cert and\nzfp runtimes).\n\ngcc/ada/\n\n\t* libgnat/s-secsta.ads (SS_Allocate): Add new Alignment\n\tparameter.\n\t(Memory_Alignment): Remove.\n\t* libgnat/s-secsta.adb (Align_Addr): New.\n\t(SS_Allocate): Add new Alignment parameter. Realign pointer if\n\tneeded. Don't allocate anything for 0-sized allocations.\n\t* gcc-interface/utils2.cc (build_call_alloc_dealloc_proc): Add\n\tallocated object's alignment as last parameter to allocation\n\tinvocation.", "tree": {"sha": "bd5a0f263e62a5019093bc0d0911062ab4b66cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd5a0f263e62a5019093bc0d0911062ab4b66cc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3202e9f88fd286a8fc4814abeaa2238d70f4d585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3202e9f88fd286a8fc4814abeaa2238d70f4d585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3202e9f88fd286a8fc4814abeaa2238d70f4d585", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3202e9f88fd286a8fc4814abeaa2238d70f4d585/comments", "author": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b65a875a7c1a728ddb5d58fb97777394a6f773e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b65a875a7c1a728ddb5d58fb97777394a6f773e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b65a875a7c1a728ddb5d58fb97777394a6f773e2"}], "stats": {"total": 109, "additions": 74, "deletions": 35}, "files": [{"sha": "0dcc9fff2a083d7cf2357138e8474a64212cbbf9", "filename": "gcc/ada/gcc-interface/utils2.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3202e9f88fd286a8fc4814abeaa2238d70f4d585/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3202e9f88fd286a8fc4814abeaa2238d70f4d585/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.cc?ref=3202e9f88fd286a8fc4814abeaa2238d70f4d585", "patch": "@@ -2139,6 +2139,8 @@ build_call_alloc_dealloc_proc (tree gnu_obj, tree gnu_size, tree gnu_type,\n \t\t\t       Entity_Id gnat_proc, Entity_Id gnat_pool)\n {\n   tree gnu_proc = gnat_to_gnu (gnat_proc);\n+  tree gnu_align = size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT);\n+\n   tree gnu_call;\n \n   /* A storage pool's underlying type is a record type for both predefined\n@@ -2154,7 +2156,6 @@ build_call_alloc_dealloc_proc (tree gnu_obj, tree gnu_size, tree gnu_type,\n \n       tree gnu_pool = gnat_to_gnu (gnat_pool);\n       tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n-      tree gnu_align = size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT);\n \n       gnu_size = convert (gnu_size_type, gnu_size);\n       gnu_align = convert (gnu_size_type, gnu_align);\n@@ -2178,6 +2179,7 @@ build_call_alloc_dealloc_proc (tree gnu_obj, tree gnu_size, tree gnu_type,\n       tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n \n       gnu_size = convert (gnu_size_type, gnu_size);\n+      gnu_align = convert (gnu_size_type, gnu_align);\n \n       if (DECL_BUILT_IN_CLASS (gnu_proc) == BUILT_IN_FRONTEND\n \t  && DECL_FE_FUNCTION_CODE (gnu_proc) == BUILT_IN_RETURN_SLOT)\n@@ -2191,7 +2193,7 @@ build_call_alloc_dealloc_proc (tree gnu_obj, tree gnu_size, tree gnu_type,\n \n \t  gnu_call = DECL_RESULT (current_function_decl);\n \n-\t  /* The allocation has alreay been done by the caller so we check that\n+\t  /* The allocation has already been done by the caller so we check that\n \t     we are not going to overflow the return slot.  */\n \t  if (TYPE_CI_CO_LIST (TREE_TYPE (current_function_decl)))\n \t    gnu_ret_size\n@@ -2216,7 +2218,7 @@ build_call_alloc_dealloc_proc (tree gnu_obj, tree gnu_size, tree gnu_type,\n \tgnu_call = build_call_n_expr (gnu_proc, 2, gnu_obj, gnu_size);\n \n       else\n-\tgnu_call = build_call_n_expr (gnu_proc, 1, gnu_size);\n+\tgnu_call = build_call_n_expr (gnu_proc, 2, gnu_size, gnu_align);\n     }\n \n   return gnu_call;\n@@ -2334,7 +2336,7 @@ maybe_wrap_free (tree data_ptr, tree data_type)\n \n /* Build a GCC tree to call an allocation or deallocation function.\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n-   generate an allocator.\n+   generate an allocation.\n \n    GNU_SIZE is the number of bytes to allocate and GNU_TYPE is the contained\n    object type, used to determine the to-be-honored address alignment."}, {"sha": "24b7601c4b50cc9fbcc0661670bb677936c2b328", "filename": "gcc/ada/libgnat/s-secsta.adb", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3202e9f88fd286a8fc4814abeaa2238d70f4d585/gcc%2Fada%2Flibgnat%2Fs-secsta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3202e9f88fd286a8fc4814abeaa2238d70f4d585/gcc%2Fada%2Flibgnat%2Fs-secsta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-secsta.adb?ref=3202e9f88fd286a8fc4814abeaa2238d70f4d585", "patch": "@@ -550,22 +550,52 @@ package body System.Secondary_Stack is\n \n    procedure SS_Allocate\n      (Addr         : out Address;\n-      Storage_Size : Storage_Count)\n+      Storage_Size : Storage_Count;\n+      Alignment    : SSE.Storage_Count := Standard'Maximum_Alignment)\n    is\n+\n       function Round_Up (Size : Storage_Count) return Memory_Size;\n       pragma Inline (Round_Up);\n       --  Round Size up to the nearest multiple of the maximum alignment\n \n+      function Align_Addr (Addr : Address) return Address;\n+      pragma Inline (Align_Addr);\n+      --  Align Addr to the next multiple of Alignment\n+\n+      ----------------\n+      -- Align_Addr --\n+      ----------------\n+\n+      function Align_Addr (Addr : Address) return Address is\n+         Int_Algn : constant Integer_Address := Integer_Address (Alignment);\n+         Int_Addr : constant Integer_Address := To_Integer (Addr);\n+      begin\n+\n+         --  L : Alignment\n+         --  A : Standard'Maximum_Alignment\n+\n+         --           Addr\n+         --      L     |     L           L\n+         --      A--A--A--A--A--A--A--A--A--A--A\n+         --                  |     |\n+         --      \\----/      |     |\n+         --     Addr mod L   |   Addr + L\n+         --                  |\n+         --                Addr + L - (Addr mod L)\n+\n+         return To_Address (Int_Addr + Int_Algn - (Int_Addr mod Int_Algn));\n+      end Align_Addr;\n+\n       --------------\n       -- Round_Up --\n       --------------\n \n       function Round_Up (Size : Storage_Count) return Memory_Size is\n-         Algn_MS : constant Memory_Size := Memory_Alignment;\n+         Algn_MS : constant Memory_Size := Standard'Maximum_Alignment;\n          Size_MS : constant Memory_Size := Memory_Size (Size);\n \n       begin\n-         --  Detect a case where the Storage_Size is very large and may yield\n+         --  Detect a case where the Size is very large and may yield\n          --  a rounded result which is outside the range of Chunk_Memory_Size.\n          --  Treat this case as secondary-stack depletion.\n \n@@ -581,27 +611,46 @@ package body System.Secondary_Stack is\n       Stack    : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n       Mem_Size : Memory_Size;\n \n+      Over_Aligning : constant Boolean :=\n+        Alignment > Standard'Maximum_Alignment;\n+\n+      Padding : SSE.Storage_Count := 0;\n+\n    --  Start of processing for SS_Allocate\n \n    begin\n-      --  Round the requested size up to the nearest multiple of the maximum\n-      --  alignment to ensure efficient access.\n+      --  Alignment must be a power of two and can be:\n \n-      if Storage_Size = 0 then\n-         Mem_Size := Memory_Alignment;\n-      else\n-         --  It should not be possible to request an allocation of negative\n-         --  size.\n+      --  - lower than or equal to Maximum_Alignment, in which case the result\n+      --    will be aligned on Maximum_Alignment;\n+      --  - higher than Maximum_Alignment, in which case the result will be\n+      --    dynamically realigned.\n \n-         pragma Assert (Storage_Size >= 0);\n-         Mem_Size := Round_Up (Storage_Size);\n+      if Over_Aligning then\n+         Padding := Alignment;\n       end if;\n \n+      --  Round the requested size (plus the needed padding in case of\n+      --  over-alignment) up to the nearest multiple of the default\n+      --  alignment to ensure efficient access and that the next available\n+      --  Byte is always aligned on the default alignement value.\n+\n+      --  It should not be possible to request an allocation of negative\n+      --  size.\n+\n+      pragma Assert (Storage_Size >= 0);\n+      Mem_Size := Round_Up (Storage_Size + Padding);\n+\n       if Sec_Stack_Dynamic then\n          Allocate_Dynamic (Stack, Mem_Size, Addr);\n       else\n          Allocate_Static  (Stack, Mem_Size, Addr);\n       end if;\n+\n+      if Over_Aligning then\n+         Addr := Align_Addr (Addr);\n+      end if;\n+\n    end SS_Allocate;\n \n    -------------"}, {"sha": "9399fa34637a12a4375f31968f5939d368d7a3d7", "filename": "gcc/ada/libgnat/s-secsta.ads", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3202e9f88fd286a8fc4814abeaa2238d70f4d585/gcc%2Fada%2Flibgnat%2Fs-secsta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3202e9f88fd286a8fc4814abeaa2238d70f4d585/gcc%2Fada%2Flibgnat%2Fs-secsta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-secsta.ads?ref=3202e9f88fd286a8fc4814abeaa2238d70f4d585", "patch": "@@ -69,11 +69,13 @@ package System.Secondary_Stack is\n \n    procedure SS_Allocate\n      (Addr         : out Address;\n-      Storage_Size : SSE.Storage_Count);\n+      Storage_Size : SSE.Storage_Count;\n+      Alignment    : SSE.Storage_Count := Standard'Maximum_Alignment);\n    --  Allocate enough space on the secondary stack of the invoking task to\n-   --  accommodate an alloction of size Storage_Size. Return the address of the\n-   --  first byte of the allocation in Addr. The routine may carry out one or\n-   --  more of the following actions:\n+   --  accommodate an allocation of size Storage_Size. Return the address of\n+   --  the first byte of the allocation in Addr, which is a multiple of\n+   --  Alignment. The routine may carry out one or more of the following\n+   --  actions:\n    --\n    --    * Reuse an existing chunk that is big enough to accommodate the\n    --      requested Storage_Size.\n@@ -259,22 +261,8 @@ private\n    subtype Memory_Index is Memory_Size;\n    --  Index into the memory storage of a single chunk\n \n-   Memory_Alignment : constant := Standard'Maximum_Alignment * 2;\n-   --  The memory alignment we will want to honor on every allocation.\n-   --\n-   --  At this stage, gigi assumes we can accommodate any alignment requirement\n-   --  there might be on the data type for which the memory gets allocated (see\n-   --  build_call_alloc_dealloc).\n-   --\n-   --  The multiplication factor is intended to account for requirements\n-   --  by user code compiled with specific arch/cpu options such as -mavx\n-   --  on X86[_64] targets, which Standard'Maximum_Alignment doesn't convey\n-   --  without such compilation options. * 4 would actually be needed to\n-   --  support -mavx512f on X86, but this would incur more annoying memory\n-   --  consumption overheads.\n-\n    type Chunk_Memory is array (Memory_Size range <>) of SSE.Storage_Element;\n-   for Chunk_Memory'Alignment use Memory_Alignment;\n+   for Chunk_Memory'Alignment use Standard'Maximum_Alignment;\n    --  The memory storage of a single chunk\n \n    --------------"}]}