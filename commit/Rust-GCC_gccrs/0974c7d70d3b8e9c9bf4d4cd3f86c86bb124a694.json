{"sha": "0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3NGM3ZDcwZDNiOGU5YzliZjRkNGNkM2Y4NmM4NmJiMTI0YTY5NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-10T20:33:07Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-10-10T20:33:07Z"}, "message": "genmodes.c, [...]: New files.\n\n\t* genmodes.c, mode-classes.def: New files.\n\t* machmode.def: Rewritten to genmodes.c interface.\n\t* Makefile.in (extra_modes_file): New substitution variable.\n\t(MACHMODE_H): No longer includes machmode.def or\n\t@extra_modes_file@; instead, mode-classes.def and insn-modes.h.\n\t(BUILD_RTL): Add $(BUILD_PREFIX)insn-modes.o.\n\t(OBJS-common): Add insn-modes.o.\n\t(STAGESTUFF): Add insn-modes.c, insn-modes.h, s-modes, and\n\tgenmodes$(build_exeext).\n\t(insn-modes.o, insn-modes.c, insn-modes.h, s-modes, genmodes.o,\n\tgenmodes$(build_exeext), $(BUILD_PREFIX_1)insn-modes.o): New targets.\n\t(s-genrtl): Don't depend on $(RTL_BASE_H).\n\t(gengenrtl.o): Don't depend on coretypes.h, $(GTM_H), real.h,\n\tor $(RTL_BASE_H); just rtl.def.\n\t* gengenrtl.c: Don't include coretypes.h, tm.h, rtl.h, or\n\treal.h.  Give fake definition of CONST_DOUBLE_FORMAT and\n\tsubstitute definition of NUM_RTX_CODE.  Add casts to avoid\n\twarnings.\n\t* machmode.h: Include insn-modes.h, not machmode.def.  Include\n\tmode-classes.def to define enum mode_class.  Tweak definitions\n\tof GET_MODE_CLASS, GET_MODE_SIZE, GET_MODE_BITSIZE, GET_MODE_MASK,\n\tGET_MODE_INNER, GET_MODE_WIDER_MODE, GET_CLASS_NARROWEST_MODE.\n\t(inner_mode_array): Renamed mode_inner.\n\t(mode_base_align): New.\n\t* rtl.c (mode_name, mode_class, mode_bitsize, mode_size,\n\tmode_unit_size, mode_wider_mode, mode_mask_array,\n\tinner_mode_array, class_narrowest_mode): Delete definitions.\n\t* stor-layout.c (get_mode_alignment): Use mode_base_align.\n\t* real.h: Use MIN_MODE_FLOAT and MAX_MODE_FLOAT, not QFmode\n\tand TFmode, in real_format_for_mode and REAL_MODE_FORMAT.\n\n\t* config/ip2k/ip2k.h, config/iq2000/iq2000.h:\n\tNo need to define BITS_PER_UNIT.\n\nFrom-SVN: r72313", "tree": {"sha": "f9be992652ecd68b01a301007bfe03ceccd94dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9be992652ecd68b01a301007bfe03ceccd94dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/comments", "author": null, "committer": null, "parents": [{"sha": "51e73d5737418298d1814d11e5b1a2c71fb6623c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e73d5737418298d1814d11e5b1a2c71fb6623c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e73d5737418298d1814d11e5b1a2c71fb6623c"}], "stats": {"total": 1456, "additions": 1154, "deletions": 302}, "files": [{"sha": "aafd1b536f7da46292467daa4a3a6e29fbce4ff7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -362,6 +362,7 @@ target_cpu_default=@target_cpu_default@\n GCC_THREAD_FILE=@thread_file@\n OBJC_BOEHM_GC=@objc_boehm_gc@\n GTHREAD_FLAGS=@gthread_flags@\n+extra_modes_file=@extra_modes_file@\n host_hook_obj=@out_host_hook_obj@\n # Be prepared for gcc2 merges.\n gcc_version=@gcc_version@\n@@ -632,7 +633,7 @@ TARGET_H = target.h\n HOOKS_H = hooks.h\n LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)\n TARGET_DEF_H = target-def.h $(HOOKS_H)\n-MACHMODE_H = machmode.h machmode.def @extra_modes_file@\n+MACHMODE_H = machmode.h mode-classes.def insn-modes.h\n RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H)\n RTL_H = $(RTL_BASE_H) genrtl.h input.h\n PARAMS_H = params.h params.def\n@@ -714,7 +715,7 @@ LDEXP_LIB = @LDEXP_LIB@\n BUILD_LIBS = $(BUILD_LIBIBERTY)\n \n BUILD_RTL = $(BUILD_PREFIX)rtl.o read-rtl.o $(BUILD_PREFIX)bitmap.o \\\n-\t\t$(BUILD_PREFIX)ggc-none.o\n+\t\t$(BUILD_PREFIX)ggc-none.o $(BUILD_PREFIX)insn-modes.o\n BUILD_SUPPORT = gensupport.o insn-conditions.o\n BUILD_EARLY_SUPPORT = gensupport.o dummy-conditions.o\n \n@@ -834,7 +835,7 @@ OBJS-common = \\\n  dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n- haifa-sched.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o\t\t   \\\n+ haifa-sched.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-modes.o\t   \\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t   \\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n  loop.o optabs.o options.o opts.o params.o postreload.o predict.o\t   \\\n@@ -862,16 +863,16 @@ BACKEND = main.o libbackend.a\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c insn-constants.h tm-preds.h \\\n- tree-check.h insn-conditions.c \\\n- s-flags s-config s-codes s-mlib s-genrtl s-gtype gtyp-gen.h \\\n+ tree-check.h insn-conditions.c insn-modes.c insn-modes.h \\\n+ s-flags s-config s-codes s-mlib s-genrtl s-modes s-gtype gtyp-gen.h \\\n  s-output s-recog s-emit s-extract s-peep s-check s-conditions \\\n  s-attr s-attrtab s-opinit s-preds s-constants s-crt0 \\\n  genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \\\n  genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext) \\\n  genconfig$(build_exeext) genpeep$(build_exeext) genattrtab$(build_exeext) \\\n  genattr$(build_exeext) genopinit$(build_exeext) gengenrtl$(build_exeext) \\\n  gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext) \\\n- gengtype$(build_exeext) genconditions$(build_exeext) \\\n+ gengtype$(build_exeext) genconditions$(build_exeext) genmodes$(build_exeext) \\\n  genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c \\\n  xgcc$(exeext) cpp$(exeext) cc1$(exeext) $(EXTRA_PASSES) \\\n  $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) \\\n@@ -2000,13 +2001,24 @@ genrtl.o : genrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n genrtl.c genrtl.h : s-genrtl\n \t@true\t# force gnu make to recheck modification times.\n \n-s-genrtl: gengenrtl$(build_exeext) $(srcdir)/move-if-change $(RTL_BASE_H)\n+s-genrtl: gengenrtl$(build_exeext) $(srcdir)/move-if-change\n \t$(RUN_GEN) ./gengenrtl$(build_exeext) -h > tmp-genrtl.h\n \t$(SHELL) $(srcdir)/move-if-change tmp-genrtl.h genrtl.h\n \t$(RUN_GEN) ./gengenrtl$(build_exeext) > tmp-genrtl.c\n \t$(SHELL) $(srcdir)/move-if-change tmp-genrtl.c genrtl.c\n \t$(STAMP) s-genrtl\n \n+insn-modes.o : insn-modes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \\\n+\t       $(MACHMODE_H)\n+insn-modes.c insn-modes.h : s-modes ; @true\n+\n+s-modes: genmodes$(build_exeext) $(srcdir)/move-if-change\n+\t$(RUN_GEN) ./genmodes$(build_exeext) -h > tmp-modes.h\n+\t$(SHELL) $(srcdir)/move-if-change tmp-modes.h insn-modes.h\n+\t$(RUN_GEN) ./genmodes$(build_exeext) > tmp-modes.c\n+\t$(SHELL) $(srcdir)/move-if-change tmp-modes.c insn-modes.c\n+\t$(STAMP) s-modes\n+\n tm-preds.h: s-preds; @true\n \n s-preds: genpreds$(build_exeext) $(srcdir)/move-if-change\n@@ -2176,8 +2188,14 @@ gengenrtl$(build_exeext) : gengenrtl.o $(BUILD_LIBDEPS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n \t gengenrtl.o $(BUILD_LIBS)\n \n-gengenrtl.o : gengenrtl.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(GTM_H) real.h\n+gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n+\n+genmodes$(build_exeext) : genmodes.o $(BUILD_ERRORS) $(BUILD_LIBDEPS)\n+\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n+\t genmodes.o $(BUILD_ERRORS) $(BUILD_LIBS)\n+\n+genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h machmode.def \\\n+\t     $(extra_modes_file)\n \n genpreds$(build_exeext) : genpreds.o $(BUILD_LIBDEPS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n@@ -2270,6 +2288,12 @@ $(BUILD_PREFIX_1)ggc-none.o: ggc-none.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYST\n \tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/ggc-none.c > $(BUILD_PREFIX)ggc-none.c\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)ggc-none.c $(OUTPUT_OPTION)\n \n+$(BUILD_PREFIX_1)insn-modes.o: insn-modes.c $(BCONFIG_H) $(SYSTEM_H) \\\n+\t\t\t       coretypes.h $(GTM_H) $(MACHMODE_H)\n+\trm -f $(BUILD_PREFIX)insn-modes.c\n+\tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/insn-modes.c > $(BUILD_PREFIX)insn-modes.c\n+\t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)insn-modes.c $(OUTPUT_OPTION)\n+\n #\f\n # Remake internationalization support.\n intl.o: intl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h Makefile"}, {"sha": "88b90b0c186ab94c5695e3da38117438e5ab7f69", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -63,7 +63,6 @@ extern int target_flags;\n #define BITS_BIG_ENDIAN 0\n #define BYTES_BIG_ENDIAN 1\n #define WORDS_BIG_ENDIAN 1\n-#define BITS_PER_UNIT 8\n #define BITS_PER_WORD 8\n #define UNITS_PER_WORD (BITS_PER_WORD / BITS_PER_UNIT)\n "}, {"sha": "f32d0c388c939dd796f61ae354720611d76d3b85", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -142,8 +142,6 @@ extern int\ttarget_flags;\n \n #define LIBGCC2_WORDS_BIG_ENDIAN 1\n \n-#define BITS_PER_UNIT 8\n-\n #define BITS_PER_WORD 32\n \n #define MAX_BITS_PER_WORD 64"}, {"sha": "9fe9481bc8e08ba65d3187d24def7efea4df3502", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -22,26 +22,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"bconfig.h\"\n #include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#define NO_GENRTL_H\n-#include \"rtl.h\"\n-#undef abort\n-\n-#include \"real.h\"\n \n struct rtx_definition\n {\n   const char *const enumname, *const name, *const format;\n };\n \n+/* rtl.def needs CONST_DOUBLE_FORMAT, but we don't care what\n+   CONST_DOUBLE_FORMAT is because we're not going to be generating\n+   anything for CONST_DOUBLE anyway.  */\n+#define CONST_DOUBLE_FORMAT \"\"\n+\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS) { #ENUM, NAME, FORMAT },\n \n static const struct rtx_definition defs[] =\n {\n #include \"rtl.def\"\t\t/* rtl expressions are documented here */\n };\n+#define NUM_RTX_CODE ARRAY_SIZE(defs)\n \n static const char *formats[NUM_RTX_CODE];\n \n@@ -169,7 +167,7 @@ find_formats (void)\n {\n   int i;\n \n-  for (i = 0; i < NUM_RTX_CODE; i++)\n+  for (i = 0; i < (int)NUM_RTX_CODE; i++)\n     {\n       const char **f;\n \n@@ -309,7 +307,7 @@ genheader (void)\n \n   putchar ('\\n');\n \n-  for (i = 0; i < NUM_RTX_CODE; i++)\n+  for (i = 0; i < (int) NUM_RTX_CODE; i++)\n     if (! special_format (defs[i].format))\n       genmacro (i);\n "}, {"sha": "7a5d2951b1b197829527c8a376ff8f628745acb1", "filename": "gcc/genmodes.c", "status": "added", "additions": 908, "deletions": 0, "changes": 908, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -0,0 +1,908 @@\n+/* Generate the machine mode enumeration and associated tables.\n+   Copyright (C) 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"bconfig.h\"\n+#include \"system.h\"\n+#include \"errors.h\"\n+\n+/* enum mode_class is normally defined by machmode.h but we can't\n+   include that header here.  */\n+#include \"mode-classes.def\"\n+\n+#define DEF_MODE_CLASS(M) M\n+enum mode_class { MODE_CLASSES, MAX_MODE_CLASS };\n+#undef DEF_MODE_CLASS\n+\n+/* Text names of mode classes, for output.  */\n+#define DEF_MODE_CLASS(M) #M\n+static const char *const mode_class_names[MAX_MODE_CLASS] =\n+{\n+  MODE_CLASSES\n+};\n+#undef DEF_MODE_CLASS\n+#undef MODE_CLASSES\n+\n+#ifdef EXTRA_MODES_FILE\n+# define HAVE_EXTRA_MODES 1\n+#else\n+# define HAVE_EXTRA_MODES 0\n+# define EXTRA_MODES_FILE \"\"\n+#endif\n+\n+/* Data structure for building up what we know about a mode.\n+   They're clustered by mode class.  */\n+struct mode_data\n+{\n+  struct mode_data *next;\t/* next this class - arbitrary order */\n+\n+  const char *name;\t\t/* printable mode name -- SI, not SImode */\n+  enum mode_class class;\t/* this mode class */\n+  unsigned int bitsize;\t\t/* size in bits, equiv to TYPE_PRECISION */\n+  unsigned int bytesize;\t/* storage size in addressable units */\n+  unsigned int ncomponents;\t/* number of subunits */\n+  unsigned int alignment;\t/* mode alignment */\n+\n+  struct mode_data *component;\t/* mode of components */\n+  struct mode_data *wider;\t/* next wider mode */\n+\n+  const char *file;\t\t/* file and line of definition, */\n+  unsigned int line;\t\t/* for error reporting */\n+};\n+\n+static struct mode_data *known_modes[MAX_MODE_CLASS];\n+static unsigned int n_modes[MAX_MODE_CLASS];\n+static struct mode_data *void_mode;\n+\n+static const struct mode_data blank_mode = {\n+  0, \"<unknown>\", MAX_MODE_CLASS,\n+  -1, -1, -1, -1,\n+  0, 0,\n+  \"<unknown>\", 0\n+};\n+\n+/* Mode class operations.  */\n+static enum mode_class\n+complex_class (enum mode_class class)\n+{\n+  switch (class)\n+    {\n+    case MODE_INT: return MODE_COMPLEX_INT;\n+    case MODE_FLOAT: return MODE_COMPLEX_FLOAT;\n+    default:\n+      error (\"no complex class for class %s\", mode_class_names[class]);\n+      return MODE_RANDOM;\n+    }\n+}\n+\n+static enum mode_class\n+vector_class (enum mode_class class)\n+{\n+  switch (class)\n+    {\n+    case MODE_INT: return MODE_VECTOR_INT;\n+    case MODE_FLOAT: return MODE_VECTOR_FLOAT;\n+    default:\n+      error (\"no vector class for class %s\", mode_class_names[class]);\n+      return MODE_RANDOM;\n+    }\n+}\n+\n+static struct mode_data *\n+find_mode (enum mode_class class, const char *name)\n+{\n+  struct mode_data *m;\n+\n+  for (m = known_modes[class]; m; m = m->next)\n+    if (!strcmp (name, m->name))\n+      return m;\n+\n+  return 0;\n+}\n+\n+static struct mode_data *\n+new_mode (enum mode_class class, const char *name,\n+\t  const char *file, unsigned int line)\n+{\n+  struct mode_data *m;\n+\n+  m = find_mode (class, name);\n+  if (m)\n+    {\n+      error (\"%s:%d: duplicate definition of mode \\\"%s\\\"\",\n+\t     trim_filename (file), line, name);\n+      error (\"%s:%d: previous definition here\", m->file, m->line);\n+      return m;\n+    }\n+\n+  m = xmalloc (sizeof (struct mode_data));\n+  memcpy (m, &blank_mode, sizeof (struct mode_data));\n+  m->class = class;\n+  m->name = name;\n+  if (file)\n+    m->file = trim_filename (file);\n+  m->line = line;\n+\n+  m->next = known_modes[class];\n+  known_modes[class] = m;\n+  n_modes[class]++;\n+  return m;\n+}\n+\n+#define for_all_modes(C, M)\t\t\t\\\n+  for (C = 0; C < MAX_MODE_CLASS; C++)\t\t\\\n+    for (M = known_modes[C]; M; M = M->next)\n+\n+\n+/* Diagnose failure to meet expectations in a partially filled out\n+   mode structure.  */\n+enum requirement { SET, UNSET, OPTIONAL };\n+\n+#define validate_field_(mname, fname, req, val, unset, file, line) do {\t\\\n+  switch (req)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case SET:\t\t\t\t\t\t\t\t\\\n+      if (val == unset)\t\t\t\t\t\t\t\\\n+\terror (\"%s:%d: (%s) field %s must be set\",\t\t\t\\\n+\t       file, line, mname, fname);\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case UNSET:\t\t\t\t\t\t\t\t\\\n+      if (val != unset)\t\t\t\t\t\t\t\\\n+\terror (\"%s:%d: (%s) field %s must not be set\",\t\t\t\\\n+\t       file, line, mname, fname);\t\t\t\t\\\n+    case OPTIONAL:\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define validate_field(M, F) \\\n+  validate_field_(M->name, #F, r_##F, M->F, blank_mode.F, M->file, M->line)\n+\n+static void\n+validate_mode (struct mode_data *m,\n+\t       enum requirement r_bitsize,\n+\t       enum requirement r_bytesize,\n+\t       enum requirement r_component,\n+\t       enum requirement r_ncomponents)\n+{\n+  validate_field (m, bitsize);\n+  validate_field (m, bytesize);\n+  validate_field (m, component);\n+  validate_field (m, ncomponents);\n+}\n+#undef validate_field\n+#undef validate_field_\n+\n+/* Given a partially-filled-out mode structure, figure out what we can\n+   and fill the rest of it in; die if it isn't enough.  */\n+static void\n+complete_mode (struct mode_data *m)\n+{\n+  unsigned int alignment;\n+\n+  if (!m->name)\n+    {\n+      error (\"%s:%d: mode with no name\", m->file, m->line);\n+      return;\n+    }\n+  if (m->class == MAX_MODE_CLASS)\n+    {\n+      error (\"%s:%d: %smode has no mode class\", m->file, m->line, m->name);\n+      return;\n+    }\n+\n+  switch (m->class)\n+    {\n+    case MODE_RANDOM:\n+      /* Nothing more need be said.  */\n+      if (!strcmp (m->name, \"VOID\"))\n+\tvoid_mode = m;\n+\n+      validate_mode (m, UNSET, UNSET, UNSET, UNSET);\n+\n+      m->bitsize = 0;\n+      m->bytesize = 0;\n+      m->ncomponents = 0;\n+      m->component = 0;\n+      break;\n+\n+    case MODE_CC:\n+      /* Again, nothing more need be said.  For historical reasons,\n+\t the size of a CC mode is four units.  */\n+      validate_mode (m, UNSET, UNSET, UNSET, UNSET);\n+\n+      m->bytesize = 4;\n+      m->ncomponents = 0;\n+      m->component = 0;\n+      break;\n+\n+    case MODE_INT:\n+    case MODE_FLOAT:\n+      /* A scalar mode must have a byte size, may have a bit size,\n+\t and must not have components.  */\n+      validate_mode (m, OPTIONAL, SET, UNSET, UNSET);\n+\n+      m->ncomponents = 0;\n+      m->component = 0;\n+      break;\n+\n+    case MODE_PARTIAL_INT:\n+      /* A partial integer mode uses ->component to say what the\n+\t corresponding full-size integer mode is, and may also\n+\t specify a bit size.  */\n+      validate_mode (m, OPTIONAL, UNSET, SET, UNSET);\n+\n+      m->bytesize = m->component->bytesize;\n+\n+      m->ncomponents = 0;\n+      m->component = 0;  /* ??? preserve this */\n+      break;\n+\n+    case MODE_COMPLEX_INT:\n+    case MODE_COMPLEX_FLOAT:\n+      /* Complex modes should have a component indicated, but no more.  */\n+      validate_mode (m, UNSET, UNSET, SET, UNSET);\n+      m->ncomponents = 2;\n+      if (m->component->bitsize != (unsigned int)-1)\n+\tm->bitsize = 2 * m->component->bitsize;\n+      m->bytesize = 2 * m->component->bytesize;\n+      break;\n+\n+    case MODE_VECTOR_INT:\n+    case MODE_VECTOR_FLOAT:\n+      /* Vector modes should have a component and a number of components.  */\n+      validate_mode (m, UNSET, UNSET, SET, SET);\n+      if (m->component->bitsize != (unsigned int)-1)\n+\tm->bitsize = m->ncomponents * m->component->bitsize;\n+      m->bytesize = m->ncomponents * m->component->bytesize;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* If not already specified, the mode alignment defaults to the largest\n+     power of two that divides the size of the object.  Complex types are\n+     not more aligned than their contents.  */\n+  if (m->class == MODE_COMPLEX_INT || m->class == MODE_COMPLEX_FLOAT)\n+    alignment = m->component->bytesize;\n+  else\n+    alignment = m->bytesize;\n+\n+  m->alignment = alignment & (~alignment + 1);\n+}\n+\n+static void\n+complete_all_modes (void)\n+{\n+  struct mode_data *m;\n+  enum mode_class c;\n+  \n+  for_all_modes (c, m)\n+    complete_mode (m);\n+}\n+\n+/* For each mode in class CLASS, construct a corresponding complex mode.  */\n+#define COMPLEX_MODES(C) make_complex_modes(MODE_##C, __FILE__, __LINE__)\n+static void\n+make_complex_modes (enum mode_class class,\n+\t\t    const char *file, unsigned int line)\n+{\n+  struct mode_data *m;\n+  struct mode_data *c;\n+  char buf[8];\n+  enum mode_class cclass = complex_class (class);\n+\n+  if (cclass == MODE_RANDOM)\n+    return;\n+    \n+  for (m = known_modes[class]; m; m = m->next)\n+    {\n+      /* Skip BImode.  FIXME: BImode probably shouldn't be MODE_INT.  */\n+      if (m->bitsize == 1)\n+\tcontinue;\n+\n+      if (strlen (m->name) >= sizeof buf)\n+\t{\n+\t  error (\"%s:%d:mode name \\\"%s\\\" is too long\",\n+\t\t m->file, m->line, m->name);\n+\t  continue;\n+\t}\n+\n+      /* Float complex modes are named SCmode, etc.\n+\t Int complex modes are named CSImode, etc.\n+         This inconsistency should be eliminated.  */\n+      if (class == MODE_FLOAT)\n+\t{\n+\t  char *p;\n+\t  strncpy (buf, m->name, sizeof buf);\n+\t  p = strchr (buf, 'F');\n+\t  if (p == 0)\n+\t    {\n+\t      error (\"%s:%d: float mode \\\"%s\\\" has no 'F'\",\n+\t\t     m->file, m->line, m->name);\n+\t      continue;\n+\t    }\n+\n+\t  *p = 'C';\n+\t}\n+      else\n+\tsnprintf (buf, sizeof buf, \"C%s\", m->name);\n+\n+      c = new_mode (cclass, xstrdup (buf), file, line);\n+      c->component = m;\n+    }\n+}\n+\n+/* For all modes in class CLASS, construct vector modes of width\n+   WIDTH, having as many components as necessary.  */\n+#define VECTOR_MODES(C, W) make_vector_modes(MODE_##C, W, __FILE__, __LINE__)\n+static void\n+make_vector_modes (enum mode_class class, unsigned int width,\n+\t\t   const char *file, unsigned int line)\n+{\n+  struct mode_data *m;\n+  struct mode_data *v;\n+  char buf[8];\n+  unsigned int ncomponents;\n+  enum mode_class vclass = vector_class (class);\n+\n+  if (vclass == MODE_RANDOM)\n+    return;\n+\n+  for (m = known_modes[class]; m; m = m->next)\n+    {\n+      /* Do not construct vector modes with only one element, or\n+\t vector modes where the element size doesn't divide the full\n+\t size evenly.  */\n+      ncomponents = width / m->bytesize;\n+      if (ncomponents < 2)\n+\tcontinue;\n+      if (width % m->bytesize)\n+\tcontinue;\n+\n+      /* Skip QFmode and BImode.  FIXME: this special case should\n+\t not be necessary.  */\n+      if (class == MODE_FLOAT && m->bytesize == 1)\n+\tcontinue;\n+      if (class == MODE_INT && m->bitsize == 1)\n+\tcontinue;\n+\n+      if ((size_t)snprintf (buf, sizeof buf, \"V%u%s\", ncomponents, m->name)\n+\t  >= sizeof buf)\n+\t{\n+\t  error (\"%s:%d: mode name \\\"%s\\\" is too long\",\n+\t\t m->file, m->line, m->name);\n+\t  continue;\n+\t}\n+\n+      v = new_mode (vclass, xstrdup (buf), file, line);\n+      v->component = m;\n+      v->ncomponents = ncomponents;\n+    }\n+}\n+\n+/* Input.  */\n+\n+#define _SPECIAL_MODE(C, N) make_special_mode(MODE_##C, #N, __FILE__, __LINE__)\n+#define RANDOM_MODE(N) _SPECIAL_MODE (RANDOM, N)\n+#define CC_MODE(N) _SPECIAL_MODE (CC, N)\n+\n+static void\n+make_special_mode (enum mode_class class, const char *name,\n+\t\t   const char *file, unsigned int line)\n+{\n+  new_mode (class, name, file, line);\n+}\n+\n+#define _SCALAR_MODE(C, N, B, Y) \\\n+  make_scalar_mode (MODE_##C, #N, B, Y, __FILE__, __LINE__)\n+\n+#define INT_MODE(N, Y)                 _SCALAR_MODE (INT, N, -1, Y)\n+#define FRACTIONAL_INT_MODE(N, B, Y)   _SCALAR_MODE (INT, N, B, Y)\n+#define FLOAT_MODE(N, Y)               _SCALAR_MODE (FLOAT, N, -1, Y)\n+#define FRACTIONAL_FLOAT_MODE(N, B, Y) _SCALAR_MODE (FLOAT, N, B, Y)\n+\n+static void\n+make_scalar_mode (enum mode_class class, const char *name,\n+\t\t  unsigned int bitsize, unsigned int bytesize,\n+\t\t  const char *file, unsigned int line)\n+{\n+  struct mode_data *m = new_mode (class, name, file, line);\n+  m->bytesize = bytesize;\n+  m->bitsize = bitsize;\n+}\n+\n+/* Partial integer modes are specified by relation to a full integer mode.\n+   For now, we do not attempt to narrow down their bit sizes.  */\n+#define PARTIAL_INT_MODE(M) \\\n+  make_partial_integer_mode (#M, \"P\" #M, -1, __FILE__, __LINE__)\n+static void ATTRIBUTE_UNUSED\n+make_partial_integer_mode (const char *base, const char *name,\n+\t\t\t   unsigned int bitsize,\n+\t\t\t   const char *file, unsigned int line)\n+{\n+  struct mode_data *m;\n+  struct mode_data *component = find_mode (MODE_INT, base);\n+  if (!component)\n+    {\n+      error (\"%s:%d: no mode \\\"%s\\\" in class INT\", file, line, name);\n+      return;\n+    }\n+  \n+  m = new_mode (MODE_PARTIAL_INT, name, file, line);\n+  m->bitsize = bitsize;\n+  m->component = component;\n+}\n+\n+/* A single vector mode can be specified by naming its component\n+   mode and the number of components.  */\n+#define VECTOR_MODE(C, M, N) \\\n+  make_vector_mode (MODE_##C, #M, N, __FILE__, __LINE__);\n+static void ATTRIBUTE_UNUSED\n+make_vector_mode (enum mode_class bclass,\n+\t\t  const char *base,\n+\t\t  unsigned int ncomponents,\n+\t\t  const char *file, unsigned int line)\n+{\n+  struct mode_data *v;\n+  enum mode_class vclass = vector_class (bclass);\n+  struct mode_data *component = find_mode (bclass, base);\n+  char namebuf[8];\n+\n+  if (vclass == MODE_RANDOM)\n+    return;\n+  if (component == 0)\n+    {\n+      error (\"%s:%d: no mode \\\"%s\\\" in class %s\",\n+\t     file, line, base, mode_class_names[bclass] + 5);\n+      return;\n+    }\n+\n+  if ((size_t)snprintf (namebuf, sizeof namebuf, \"V%u%s\",\n+\t\t\tncomponents, base) >= sizeof namebuf)\n+    {\n+      error (\"%s:%d: mode name \\\"%s\\\" is too long\",\n+\t     base, file, line);\n+      return;\n+    }\n+\n+  v = new_mode (vclass, xstrdup (namebuf), file, line);\n+  v->ncomponents = ncomponents;\n+  v->component = component;\n+}\n+  \n+\n+static void\n+create_modes (void)\n+{\n+#include \"machmode.def\"\n+}\n+\n+/* Processing.  */\n+\n+/* Sort a list of modes into the order needed for the WIDER field:\n+   major sort by bitsize, minor sort by component bitsize.\n+\n+   For instance:\n+     QI < HI < SI < DI < TI\n+     V4QI < V2HI < V8QI < V4HI < V2SI.\n+\n+   If the bitsize is not set, sort by the bytesize.  A mode with\n+   bitsize set gets sorted before a mode without bitsize set, if\n+   they have the same bytesize; this is the right thing because\n+   the bitsize must always be smaller than the bytesize * BITS_PER_UNIT.\n+   We don't have to do anything special to get this done -- an unset\n+   bitsize shows up as (unsigned int)-1, i.e. UINT_MAX.  */\n+static int\n+cmp_modes (const void *a, const void *b)\n+{\n+  struct mode_data *m = *(struct mode_data **)a;\n+  struct mode_data *n = *(struct mode_data **)b;\n+\n+  if (m->bytesize > n->bytesize)\n+    return 1;\n+  else if (m->bytesize < n->bytesize)\n+    return -1;\n+\n+  if (m->bitsize > n->bitsize)\n+    return 1;\n+  else if (m->bitsize < n->bitsize)\n+    return -1;\n+\n+  if (!m->component && !n->component)\n+    return 0;\n+\n+  if (m->component->bytesize > n->component->bytesize)\n+    return 1;\n+  else if (m->component->bytesize < n->component->bytesize)\n+    return -1;\n+\n+  if (m->component->bitsize > n->component->bitsize)\n+    return 1;\n+  else if (m->component->bitsize < n->component->bitsize)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+static void\n+calc_wider_mode (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+  struct mode_data **sortbuf;\n+  unsigned int max_n_modes = 0;\n+  unsigned int i, j;\n+\n+  for (c = 0; c < MAX_MODE_CLASS; c++)\n+    max_n_modes = MAX (max_n_modes, n_modes[c]);\n+\n+  sortbuf = alloca (max_n_modes * sizeof (struct mode_data *));\n+\n+  for (c = 0; c < MAX_MODE_CLASS; c++)\n+    {\n+      /* \"wider\" is not meaningful for MODE_RANDOM and MODE_CC.\n+\t However, we want these in textual order, and we have\n+\t precisely the reverse.  */\n+      if (c == MODE_RANDOM || c == MODE_CC)\n+\t{\n+\t  struct mode_data *prev, *next;\n+\n+\t  for (prev = 0, m = known_modes[c]; m; m = next)\n+\t    {\n+\t      m->wider = void_mode;\n+\n+\t      /* this is nreverse */\n+\t      next = m->next;\n+\t      m->next = prev;\n+\t      prev = m;\n+\t    }\n+\t  known_modes[c] = prev;\n+\t}\n+      else\n+\t{\n+\t  if (!known_modes[c])\n+\t    continue;\n+\n+\t  for (i = 0, m = known_modes[c]; m; i++, m = m->next)\n+\t    sortbuf[i] = m;\n+\n+\t  qsort (sortbuf, i, sizeof (struct mode_data *), cmp_modes);\n+\n+\t  sortbuf[i] = 0;\n+\t  for (j = 0; j < i; j++)\n+\t    sortbuf[j]->next = sortbuf[j]->wider = sortbuf[j + 1];\n+\n+\n+\t  known_modes[c] = sortbuf[0];\n+\t}\n+    }\n+}\n+\n+/* Output routines.  */\n+\n+#define tagged_printf(FMT, ARG, TAG) do {\t\t\\\n+  int count_;\t\t\t\t\t\t\\\n+  printf (\"  \" FMT \",%n\", ARG, &count_);\t\t\\\n+  printf (\"%*s/* %s */\\n\", 27 - count_, \"\", TAG);\t\\\n+} while (0)\n+\n+#define print_decl(TYPE, NAME, ASIZE) \\\n+  printf (\"\\nconst %s %s[%s] =\\n{\\n\", TYPE, NAME, ASIZE);\n+\n+#define print_closer() puts (\"};\")\n+\n+static void\n+emit_insn_modes_h (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m, *first, *last;\n+\n+  printf (\"/* Generated automatically from machmode.def%s%s\\n\",\n+\t   HAVE_EXTRA_MODES ? \" and \" : \"\",\n+\t   EXTRA_MODES_FILE);\n+\n+  puts (\"\\\n+   by genmodes.  */\\n\\\n+\\n\\\n+#ifndef GCC_INSN_MODES_H\\n\\\n+#define GCC_INSN_MODES_H\\n\\\n+\\n\\\n+enum machine_mode\\n{\");\n+\n+  for (c = 0; c < MAX_MODE_CLASS; c++)\n+    for (m = known_modes[c]; m; m = m->next)\n+      {\n+\tint count_;\n+\tprintf (\"  %smode,%n\", m->name, &count_);\n+\tprintf (\"%*s/* %s:%d */\\n\", 27 - count_, \"\",\n+\t\t trim_filename (m->file), m->line);\n+      }\n+\n+  puts (\"  MAX_MACHINE_MODE,\\n\");\n+\n+  for (c = 0; c < MAX_MODE_CLASS; c++)\n+    {\n+      first = known_modes[c];\n+      last = 0;\n+      for (m = first; m; last = m, m = m->next)\n+\t;\n+\n+      /* Don't use BImode for MIN_MODE_INT, since otherwise the middle\n+\t end will try to use it for bitfields in structures and the\n+\t like, which we do not want.  Only the target md file should\n+\t generate BImode widgets.  */\n+      if (first && first->bitsize == 1)\n+\tfirst = first->next;\n+\n+      if (first && last)\n+\tprintf (\"  MIN_%s = %smode,\\n  MAX_%s = %smode,\\n\\n\",\n+\t\t mode_class_names[c], first->name,\n+\t\t mode_class_names[c], last->name);\n+      else\n+\tprintf (\"  MIN_%s = %smode,\\n  MAX_%s = %smode,\\n\\n\",\n+\t\t mode_class_names[c], void_mode->name,\n+\t\t mode_class_names[c], void_mode->name);\n+    }\n+\n+  puts (\"\\\n+  NUM_MACHINE_MODES = MAX_MACHINE_MODE\\n\\\n+};\\n\\\n+\\n\\\n+#endif /* insn-modes.h */\");\n+}\n+\n+static void\n+emit_insn_modes_c_header (void)\n+{\n+  printf (\"/* Generated automatically from machmode.def%s%s\\n\",\n+\t   HAVE_EXTRA_MODES ? \" and \" : \"\",\n+\t   EXTRA_MODES_FILE);\n+\n+  puts (\"\\\n+   by genmodes.  */\\n\\\n+\\n\\\n+#define GENERATOR_FILE /* This inhibits insn-flags.h and\\n\\\n+                          insn-constants.h, which don't exist yet.  */\\n\\\n+#include \\\"config.h\\\"\\n\\\n+#include \\\"system.h\\\"\\n\\\n+#include \\\"coretypes.h\\\"\\n\\\n+#include \\\"tm.h\\\"\\n\\\n+#include \\\"machmode.h\\\"\");\n+}\n+\n+static void\n+emit_mode_name (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"char *const\", \"mode_name\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    printf (\"  \\\"%s\\\",\\n\", m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_class (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_class\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%s\", mode_class_names[m->class], m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_bitsize (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned short\", \"mode_bitsize\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    if (m->bitsize != (unsigned int)-1)\n+      tagged_printf (\"%u\", m->bitsize, m->name);\n+    else\n+      tagged_printf (\"%u*BITS_PER_UNIT\", m->bytesize, m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_size (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_size\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%u\", m->bytesize, m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_unit_size (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_unit_size\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%u\",\n+\t\t   m->component\n+\t\t   ? m->component->bytesize : m->bytesize,\n+\t\t   m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_wider (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_wider\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%smode\",\n+\t\t   m->wider ? m->wider->name : void_mode->name,\n+\t\t   m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_mask (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned HOST_WIDE_INT\", \"mode_mask_array\",\n+\t      \"NUM_MACHINE_MODES\");\n+  puts (\"\\\n+#define MASK(m)                               \\\\\\n\\\n+  ((m) >= HOST_BITS_PER_WIDE_INT)             \\\\\\n\\\n+   ? ~(unsigned HOST_WIDE_INT) 0              \\\\\\n\\\n+   : ((unsigned HOST_WIDE_INT) 1 << (m)) - 1\\n\");\n+\n+  for_all_modes (c, m)\n+    if (m->bitsize != (unsigned int)-1)\n+      tagged_printf (\"MASK (%u)\", m->bitsize, m->name);\n+    else\n+      tagged_printf (\"MASK (%u*BITS_PER_UNIT)\", m->bytesize, m->name);\n+\n+  puts (\"#undef MASK\");\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_inner (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_inner\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%smode\",\n+\t\t   m->component ? m->component->name : void_mode->name,\n+\t\t   m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_mode_base_align (void)\n+{\n+  enum mode_class c;\n+  struct mode_data *m;\n+\n+  print_decl (\"unsigned char\", \"mode_base_align\", \"NUM_MACHINE_MODES\");\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%u\", m->alignment, m->name);\n+\n+  print_closer ();\n+}\n+\n+static void\n+emit_class_narrowest_mode (void)\n+{\n+  enum mode_class c;\n+\n+  print_decl (\"unsigned char\", \"class_narrowest_mode\", \"MAX_MODE_CLASS\");\n+\n+  for (c = 0; c < MAX_MODE_CLASS; c++)\n+    /* Bleah, all this to get the comment right for MIN_MODE_INT.  */\n+    tagged_printf (\"MIN_%s\", mode_class_names[c],\n+\t\t   known_modes[c]\n+\t\t   ? (known_modes[c]->bitsize != 1\n+\t\t      ? known_modes[c]->name\n+\t\t      : (known_modes[c]->next\n+\t\t\t ? known_modes[c]->next->name\n+\t\t\t : void_mode->name))\n+\t\t   : void_mode->name);\n+  \n+  print_closer ();\n+}\n+\n+static void\n+emit_insn_modes_c (void)\n+{\n+  emit_insn_modes_c_header ();\n+  emit_mode_name ();\n+  emit_mode_class ();\n+  emit_mode_bitsize ();\n+  emit_mode_size ();\n+  emit_mode_unit_size ();\n+  emit_mode_wider ();\n+  emit_mode_mask ();\n+  emit_mode_inner ();\n+  emit_mode_base_align ();\n+  emit_class_narrowest_mode ();\n+}\n+\n+/* Master control.  */\n+int\n+main(int argc, char **argv)\n+{\n+  bool gen_header;\n+  progname = argv[0];\n+\n+  if (argc == 1)\n+    gen_header = false;\n+  else if (argc == 2 && !strcmp (argv[1], \"-h\"))\n+    gen_header = true;\n+  else\n+    {\n+      error (\"usage: %s [-h] > file\", progname);\n+      return FATAL_EXIT_CODE;\n+    }\n+\n+  create_modes ();\n+  complete_all_modes ();\n+\n+  if (have_error)\n+    return FATAL_EXIT_CODE;\n+  \n+  calc_wider_mode ();\n+\n+  if (gen_header)\n+    emit_insn_modes_h ();\n+  else\n+    emit_insn_modes_c ();\n+\n+  if (fflush (stdout) || fclose (stdout))\n+    return FATAL_EXIT_CODE;\n+  return SUCCESS_EXIT_CODE;\n+}"}, {"sha": "8688f8ad02986fc628a0002381a7beb86b4ecff1", "filename": "gcc/machmode.def", "status": "modified", "additions": 147, "deletions": 126, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -1,6 +1,7 @@\n /* This file contains the definitions and documentation for the\n    machine modes used in the GNU compiler.\n-   Copyright (C) 1987, 1992, 1994, 1997, 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1994, 1997, 1998, 2000, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -31,145 +32,165 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    has a machine mode which describes data of that type or the\n    data of the variable declared.  */\n \n-/* The first argument is the internal name of the machine mode\n-   used in the C source.\n-   By convention these are in UPPER_CASE, except for the word  \"mode\".\n-\n-   The second argument  is the name of the machine mode in the\n-   external ASCII format used for reading and printing RTL and trees.\n-   By convention these names in UPPER_CASE.\n-\n-   Third argument states the kind of representation:\n-   MODE_INT - integer\n-   MODE_FLOAT - floating\n-   MODE_PARTIAL_INT - PQImode, PHImode, PSImode and PDImode\n-   MODE_CC - modes used for representing the condition code in a register\n-   MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT - complex number\n-   MODE_VECTOR_INT, MODE_VECTOR_FLOAT - vector\n-   MODE_RANDOM - anything else\n-\n-   Fourth argument is the relative size of the object, in bits,\n-   so we can have modes smaller than 1 byte.\n-\n-   Fifth argument is the relative size of the object, in bytes.\n-   It is zero when the size is meaningless or not determined.\n-   A byte's size is determined by BITS_PER_UNIT in tm.h. \n-\n-   Sixth arg is the relative size of subunits of the object.\n-   It is same as the fifth argument except for complexes and vectors,\n-   since they are really made of many equal size subunits.\n-\n-   Seventh arg is next wider natural mode of the same class.  0 if\n-   there is none.  Vector modes use this field to point to the next\n-   vector size, so we can iterate through the different vectors modes.\n-   The ordering is by increasing byte size, with QI coming before HI,\n-   HI before SI, etc.\n-\n-   Eigth arg is the mode of the internal elements in a vector or\n-   complex, and VOIDmode if not applicable.\n-*/\n+/* This file is included by the genmodes program.  Its text is the\n+   body of a function.  Do not rely on this, it will change in the\n+   future.\n+\n+   The following statements can be used in this file -- all have\n+   the form of a C macro call.  In their arguments:\n+\n+   A CLASS argument must be one of the constants defined in\n+   mode-classes.def, less the leading MODE_ prefix; some statements\n+   that take CLASS arguments have restructions on which classes are\n+   acceptable.  For instance, INT.\n+\n+   A MODE argument must be the printable name of a machine mode,\n+   without quotation marks or trailing \"mode\".  For instance, SI.\n+\n+   A BITSIZE, BYTESIZE, or COUNT argument must be a positive integer\n+   constant.\n+\n+   Order matters in this file in so far as statements which refer to\n+   other modes must appear after the modes they refer to.  However,\n+   statements which do not refer to other modes may appear in any\n+   order.\n+\n+     RANDOM_MODE (MODE);\n+        declares MODE to be of class RANDOM.\n+\n+     CC_MODE (MODE);\n+        declares MODE to be of class CC.\n+\n+     INT_MODE (MODE, BYTESIZE);\n+        declares MODE to be of class INT and BYTESIZE bytes wide.\n+\tAll of the bits of its representation are significant.\n+\n+     FRACTIONAL_INT_MODE (MODE, BITSIZE, BYTESIZE);\n+        declares MODE to be of class INT, BYTESIZE bytes wide in\n+\tstorage, but with only BITSIZE significant bits.\n+\n+     FLOAT_MODE (MODE, BYTESIZE);\n+        declares MODE to be of class FLOAT and BYTESIZE bytes wide.\n+\tAll of the bits of its representation are significant.\n+\n+     FRACTIONAL_FLOAT_MODE (MODE, BITSIZE, BYTESIZE);\n+        declares MODE to be of class FLOAT, BYTESIZE bytes wide in\n+\tstorage, but with only BITSIZE significant bits.\n+\n+     PARTIAL_INT_MODE (MODE);\n+        declares a mode of class PARTIAL_INT with the same size as\n+\tMODE (which must be an INT mode).  The name of the new mode\n+\tis made by prefixing a P to the name MODE.  This statement\n+\tmay grow a BITSIZE argument in the future.\n+\n+     VECTOR_MODE (CLASS, MODE, COUNT);\n+        Declare a vector mode whose component mode is MODE (of class\n+\tCLASS) with COUNT components.  CLASS must be INT or FLOAT.\n+\tThe name of the vector mode takes the form VnX where n is\n+\tCOUNT in decimal and X is MODE.\n+\n+     VECTOR_MODES (CLASS, WIDTH);\n+        For all modes presently declared in class CLASS, construct\n+\tcorresponding vector modes having width WIDTH.  Modes whose\n+\tbyte sizes do not evenly divide WIDTH are ignored, as are\n+\tmodes that would produce vector modes with only one component,\n+\tand modes smaller than one byte (if CLASS is INT) or smaller\n+\tthan two bytes (if CLASS is FLOAT).  CLASS must be INT or\n+\tFLOAT.  The names follow the same rule as VECTOR_MODE uses.\n+\n+     COMPLEX_MODES (CLASS);\n+        For all modes presently declared in class CLASS, construct\n+\tcorresponding complex modes.  Modes smaller than one byte\n+\tare ignored.  For FLOAT modes, the names are derived by\n+\treplacing the 'F' in the mode name with a 'C'.  (It is an\n+\terror if there is no 'F'.  For INT modes, the names are\n+\tderived by prefixing a C to the name.\n+\n+     BITS_PER_UNIT (COUNT);\n+        Sets the number of bits in a machine byte (least addressable\n+\tunit).  If this statement does not appear, the default is 8.\n+\n+   Note: If a mode is ever made which is more than 255 bytes wide,\n+   machmode.h and genmodes.c will have to be changed to allocate\n+   more space for the mode_size and mode_alignment arrays.  */\n \n /* VOIDmode is used when no mode needs to be specified,\n    as for example on CONST_INT RTL expressions.  */\n-DEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n+RANDOM_MODE (VOID);\n+\n+/* BLKmode is used for structures, arrays, etc.\n+   that fit no more specific mode.  */\n+RANDOM_MODE (BLK);\n+\n+/* Single bit mode used for booleans.  */\n+FRACTIONAL_INT_MODE (BI, 1, 1);\n \n-DEF_MACHMODE (BImode, \"BI\", MODE_INT, 1, 1, 1, QImode, VOIDmode)\n-DEF_MACHMODE (QImode, \"QI\", MODE_INT, BITS_PER_UNIT, 1, 1, HImode, VOIDmode)\n-DEF_MACHMODE (HImode, \"HI\", MODE_INT, BITS_PER_UNIT*2, 2, 2, SImode, VOIDmode)\n-DEF_MACHMODE (SImode, \"SI\", MODE_INT, BITS_PER_UNIT*4, 4, 4, DImode, VOIDmode)\n-DEF_MACHMODE (DImode, \"DI\", MODE_INT, BITS_PER_UNIT*8, 8, 8, TImode, VOIDmode)\n-DEF_MACHMODE (TImode, \"TI\", MODE_INT, BITS_PER_UNIT*16, 16, 16, OImode, VOIDmode)\n-DEF_MACHMODE (OImode, \"OI\", MODE_INT, BITS_PER_UNIT*32, 32, 32, VOIDmode, VOIDmode)\n+/* Basic integer modes.  */\n+INT_MODE (QI, 1);\n+INT_MODE (HI, 2);\n+INT_MODE (SI, 4);\n+INT_MODE (DI, 8);\n+INT_MODE (TI, 16);\n+INT_MODE (OI, 32);\n \n /* Pointers on some machines use these types to distinguish them from\n    ints.  Useful if a pointer is 4 bytes but has some bits that are\n    not significant, so it is really not quite as wide as an integer.  */\n-DEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, BITS_PER_UNIT, 1, 1, PHImode, VOIDmode)\n-DEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, BITS_PER_UNIT*2, 2, 2, PSImode, VOIDmode)\n-DEF_MACHMODE (PSImode, \"PSI\", MODE_PARTIAL_INT, BITS_PER_UNIT*4, 4, 4, PDImode, VOIDmode)\n-DEF_MACHMODE (PDImode, \"PDI\", MODE_PARTIAL_INT, BITS_PER_UNIT*8, 8, 8, VOIDmode, VOIDmode)\n-\n-DEF_MACHMODE (QFmode, \"QF\", MODE_FLOAT, BITS_PER_UNIT, 1, 1, HFmode, VOIDmode)\n-DEF_MACHMODE (HFmode, \"HF\", MODE_FLOAT, BITS_PER_UNIT*2, 2, 2, TQFmode, VOIDmode)\n-DEF_MACHMODE (TQFmode, \"TQF\", MODE_FLOAT, BITS_PER_UNIT*3, 3, 3, SFmode, VOIDmode) /* MIL-STD-1750A */\n-DEF_MACHMODE (SFmode, \"SF\", MODE_FLOAT, BITS_PER_UNIT*4, 4, 4, DFmode, VOIDmode)\n-DEF_MACHMODE (DFmode, \"DF\", MODE_FLOAT, BITS_PER_UNIT*8, 8, 8, XFmode, VOIDmode)\n-DEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, BITS_PER_UNIT*12, 12, 12, TFmode, VOIDmode) /* IEEE extended */\n-DEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, BITS_PER_UNIT*16, 16, 16, VOIDmode, VOIDmode)\n+PARTIAL_INT_MODE (QI);\n+PARTIAL_INT_MODE (HI);\n+PARTIAL_INT_MODE (SI);\n+PARTIAL_INT_MODE (DI);\n+\n+/* Basic floating point modes.  */\n+FLOAT_MODE (QF, 1);\t/* C4x single precision */\n+FLOAT_MODE (HF, 2);\t/* C4x double precision */\n+FLOAT_MODE (TQF, 3);\t/* MIL-STD-1750a */\n+FLOAT_MODE (SF, 4);\n+FLOAT_MODE (DF, 8);\n+FLOAT_MODE (XF, 12);\t/* IEEE extended (80-bit) */\n+FLOAT_MODE (TF, 16);\n+\n+/* Basic CC modes.  */\n+CC_MODE (CC);\n+\n+/* Allow the target to specify additional modes of various kinds.  */\n+#if HAVE_EXTRA_MODES\n+# define CC(X) CC_MODE(X);  /* backward compatibility, temporary */\n+# include EXTRA_MODES_FILE\n+# undef CC\n+#endif\n \n /* Complex modes.  */\n-DEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*2, 2, 1, HCmode, QFmode)\n-DEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*4, 4, 2, SCmode, HFmode)\n-DEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*8, 8, 4, DCmode, SFmode)\n-DEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*16, 16, 8, XCmode, DFmode)\n-DEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*24, 24, 12, TCmode, XFmode)\n-DEF_MACHMODE (TCmode, \"TC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*32, 32, 16, VOIDmode, TFmode)\n-\n-DEF_MACHMODE (CQImode, \"CQI\", MODE_COMPLEX_INT, BITS_PER_UNIT*2, 2, 1, CHImode, QImode)\n-DEF_MACHMODE (CHImode, \"CHI\", MODE_COMPLEX_INT, BITS_PER_UNIT*4, 4, 2, CSImode, HImode)\n-DEF_MACHMODE (CSImode, \"CSI\", MODE_COMPLEX_INT, BITS_PER_UNIT*8, 8, 4, CDImode, SImode)\n-DEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, BITS_PER_UNIT*16, 16, 8, CTImode, DImode)\n-DEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, BITS_PER_UNIT*32, 32, 16, COImode, TImode)\n-DEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, BITS_PER_UNIT*64, 64, 32, VOIDmode, OImode)\n+COMPLEX_MODES (INT);\n+COMPLEX_MODES (FLOAT);\n \n /* Vector modes.  */\n-/* The wider mode field for vectors follows in order of increasing bit\n-   size with QI coming before HI, HI before SI, and SI before DI\n-   within same bit sizes.  */\n-DEF_MACHMODE (V1DImode, \"V1DI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 8, V2QImode, DImode)\n-DEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, BITS_PER_UNIT*2, 2, 1, V4QImode, QImode)\n-DEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 2, V8QImode, HImode)\n-DEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 4, V16QImode, SImode)\n-DEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 8, V8SImode, DImode)\n-\n-DEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 1, V2HImode, QImode)\n-DEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 2, V2SImode, HImode)\n-DEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 4, V2DImode, SImode)\n-DEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 8, V8DImode, DImode)\n-\n-DEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 1, V4HImode, QImode)\n-DEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 2, V4SImode, HImode)\n-DEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 4, V4DImode, SImode)\n-DEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, BITS_PER_UNIT*64, 64, 8, VOIDmode, DImode)\n-\n-DEF_MACHMODE (V16QImode, \"V16QI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 1, V8HImode, QImode)\n-\n-DEF_MACHMODE (V2HFmode, \"V2HF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*4, 4, 2, V4HFmode, HFmode)\n-DEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*8, 8, 4, V4SFmode, SFmode)\n-DEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 8, V8SFmode, DFmode)\n-\n-DEF_MACHMODE (V4HFmode, \"V4HF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*8,  8,  2, V2SFmode, HFmode)\n-DEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 4, V2DFmode, SFmode)\n-DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 8, V8DFmode, DFmode)\n-\n-DEF_MACHMODE (V8HFmode, \"V8HF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 2, V4SFmode, HFmode)\n-DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 4, V4DFmode, SFmode)\n-DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*64, 64, 8, VOIDmode, DFmode)\n-DEF_MACHMODE (V16SFmode, \"V16SF\", MODE_VECTOR_FLOAT, 512, 64, 4, VOIDmode, SFmode)\n-\n-/* BLKmode is used for structures, arrays, etc.\n-   that fit no more specific mode.  */\n-DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n-\n-/* The modes for representing the condition codes come last.  CCmode\n-   is always defined.  Additional modes for the condition code can be\n-   specified in the EXTRA_CC_MODES header.  All MODE_CC modes are the\n-   same width as SImode and have VOIDmode as their next wider mode.  */\n-\n-/* We do not use CC() for CCmode to avoid a warning about use of\n-   function-like macros with no arguments.  */\n-DEF_MACHMODE (CCmode, \"CC\", MODE_CC, BITS_PER_UNIT*4, 4, 4, VOIDmode, VOIDmode)\n-\n-#ifdef EXTRA_MODES_FILE\n-#define CC(N)  \\\n-  DEF_MACHMODE (N##mode, #N, \\\n-                MODE_CC, BITS_PER_UNIT*4, 4, 4, VOIDmode, VOIDmode)\n-#include EXTRA_MODES_FILE\n-#undef CC\n-#endif\n+VECTOR_MODES (INT, 2);        /*                 V2QI */\n+VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n+VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n+VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n+/* VECTOR_MODES (INT, 32);             V8SI V4DI      */\n+/* VECTOR_MODES (INT, 64);             V8DI           */\n+\n+VECTOR_MODE (INT, SI, 8)\n+VECTOR_MODE (INT, DI, 4);\n+VECTOR_MODE (INT, DI, 8);\n+\n+VECTOR_MODE (INT, DI, 1);  /* PPC uses this.  Why not plain DI? */\n+\n+VECTOR_MODES (FLOAT, 4);      /*                 V2HF */\n+VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n+VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */\n+/* VECTOR_MODES (FLOAT, 32);           V8SF V4DF      */\n+/* VECTOR_MODES (FLOAT, 64);     V16SF V8DF           */\n+\n+VECTOR_MODE (FLOAT, SF, 8);\n+VECTOR_MODE (FLOAT, SF, 16);\n+VECTOR_MODE (FLOAT, DF, 4);\n+VECTOR_MODE (FLOAT, DF, 8);\n \n /* The symbol Pmode stands for one of the above machine modes (usually SImode).\n-   The tm file specifies which one.  It is not a distinct mode.  */\n+   The tm.h file specifies which one.  It is not a distinct mode.  */\n \n /*\n Local variables:"}, {"sha": "4c4086c312dd6abd6040b451b03e90a62dbc049d", "filename": "gcc/machmode.h", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -23,34 +23,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HAVE_MACHINE_MODES\n \n /* Make an enum class that gives all the machine modes.  */\n-\n-#define DEF_MACHMODE(SYM, NAME, TYPE, BITSIZE, SIZE, UNIT, WIDER, INNER)  SYM,\n-\n-enum machine_mode {\n-#include \"machmode.def\"\n-MAX_MACHINE_MODE };\n-\n-#undef DEF_MACHMODE\n-\n-#ifndef NUM_MACHINE_MODES\n-#define NUM_MACHINE_MODES (int) MAX_MACHINE_MODE\n-#endif\n+#include \"insn-modes.h\"\n \n /* Get the name of mode MODE as a string.  */\n \n extern const char * const mode_name[NUM_MACHINE_MODES];\n-#define GET_MODE_NAME(MODE)\t\t(mode_name[(int) (MODE)])\n+#define GET_MODE_NAME(MODE)  mode_name[MODE]\n+\n+/* Mode classes.  */\n \n-enum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n-\t\t  MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT,\n-\t\t  MODE_VECTOR_INT, MODE_VECTOR_FLOAT,\n-\t\t  MAX_MODE_CLASS};\n+#include \"mode-classes.def\"\n+#define DEF_MODE_CLASS(M) M\n+enum mode_class { MODE_CLASSES, MAX_MODE_CLASS };\n+#undef DEF_MODE_CLASS\n+#undef MODE_CLASSES\n \n /* Get the general kind of object that mode MODE represents\n    (integer, floating, complex, etc.)  */\n \n-extern const enum mode_class mode_class[NUM_MACHINE_MODES];\n-#define GET_MODE_CLASS(MODE)\t\t(mode_class[(int) (MODE)])\n+extern const unsigned char mode_class[NUM_MACHINE_MODES];\n+#define GET_MODE_CLASS(MODE)  mode_class[MODE]\n \n /* Nonzero if MODE is an integral mode.  */\n #define INTEGRAL_MODE_P(MODE)\t\t\t\\\n@@ -87,12 +79,12 @@ extern const enum mode_class mode_class[NUM_MACHINE_MODES];\n /* Get the size in bytes of an object of mode MODE.  */\n \n extern const unsigned char mode_size[NUM_MACHINE_MODES];\n-#define GET_MODE_SIZE(MODE)\t\t(mode_size[(int) (MODE)])\n+#define GET_MODE_SIZE(MODE)   mode_size[MODE]\n \n /* Get the size in bytes of the basic parts of an object of mode MODE.  */\n \n extern const unsigned char mode_unit_size[NUM_MACHINE_MODES];\n-#define GET_MODE_UNIT_SIZE(MODE)\t(mode_unit_size[(int) (MODE)])\n+#define GET_MODE_UNIT_SIZE(MODE)  mode_unit_size[MODE]\n \n /* Get the number of units in the object.  */\n \n@@ -103,7 +95,7 @@ extern const unsigned char mode_unit_size[NUM_MACHINE_MODES];\n /* Get the size in bits of an object of mode MODE.  */\n \n extern const unsigned short mode_bitsize[NUM_MACHINE_MODES];\n-#define GET_MODE_BITSIZE(MODE)  (mode_bitsize[(int) (MODE)])\n+#define GET_MODE_BITSIZE(MODE)  mode_bitsize[MODE]\n \n #endif /* not HAVE_MACHINE_MODES */\n \n@@ -114,13 +106,13 @@ extern const unsigned short mode_bitsize[NUM_MACHINE_MODES];\n \n extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n \n-#define GET_MODE_MASK(MODE) mode_mask_array[(int) (MODE)]\n+#define GET_MODE_MASK(MODE) mode_mask_array[MODE]\n \n-extern const enum machine_mode inner_mode_array[NUM_MACHINE_MODES];\n+extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n \n /* Return the mode of the inner elements in a vector.  */\n \n-#define GET_MODE_INNER(MODE) inner_mode_array[(int) (MODE)]\n+#define GET_MODE_INNER(MODE) mode_inner[MODE]\n \n #endif /* defined (HOST_WIDE_INT) && ! defined GET_MODE_MASK */\n \n@@ -129,8 +121,8 @@ extern const enum machine_mode inner_mode_array[NUM_MACHINE_MODES];\n \n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n-extern const unsigned char mode_wider_mode[NUM_MACHINE_MODES];\n-#define GET_MODE_WIDER_MODE(MODE)\t((enum machine_mode)mode_wider_mode[(int) (MODE)])\n+extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n+#define GET_MODE_WIDER_MODE(MODE) mode_wider[MODE]\n \n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n@@ -156,14 +148,16 @@ extern enum machine_mode get_best_mode (int, int, unsigned int,\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n \n+extern const unsigned char mode_base_align[NUM_MACHINE_MODES];\n+\n extern unsigned get_mode_alignment (enum machine_mode);\n \n #define GET_MODE_ALIGNMENT(MODE) get_mode_alignment (MODE)\n \n /* For each class, get the narrowest mode in that class.  */\n \n-extern const enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS];\n-#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode[(int) (CLASS)]\n+extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];\n+#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode[CLASS]\n \n /* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD\n    and the mode whose class is Pmode and whose size is POINTER_SIZE.  */"}, {"sha": "d154493ebcc3254afb5347774f011e68f8263e30", "filename": "gcc/mode-classes.def", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -0,0 +1,31 @@\n+/* Machine mode class definitions for GCC.\n+   Copyright (C) 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#define MODE_CLASSES\t\t\t\t\t\t\t   \\\n+  DEF_MODE_CLASS (MODE_RANDOM),\t\t/* other */\t\t\t   \\\n+  DEF_MODE_CLASS (MODE_CC),\t\t/* condition code in a register */ \\\n+  DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n+  DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */\t   \\\n+  DEF_MODE_CLASS (MODE_FLOAT),\t\t/* floating point */\t\t   \\\n+  DEF_MODE_CLASS (MODE_COMPLEX_INT), \t/* complex numbers */\t\t   \\\n+  DEF_MODE_CLASS (MODE_COMPLEX_FLOAT),\t\t\t\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_INT),\t/* SIMD vectors */\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_FLOAT)"}, {"sha": "3620d50580a79af866e1215593aa83049cde8241", "filename": "gcc/real.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -143,9 +143,10 @@ struct real_format\n \n /* The target format used for each floating floating point mode.\n    Indexed by MODE - QFmode.  */\n-extern const struct real_format *real_format_for_mode[TFmode - QFmode + 1];\n+extern const struct real_format *\n+  real_format_for_mode[MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1];\n \n-#define REAL_MODE_FORMAT(MODE) (real_format_for_mode[(MODE) - QFmode])\n+#define REAL_MODE_FORMAT(MODE) (real_format_for_mode[(MODE) - MIN_MODE_FLOAT])\n \n /* Declare functions in real.c.  */\n "}, {"sha": "f339ff6927028e86f075ba51ade10297cb4626a5", "filename": "gcc/rtl.c", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -50,115 +50,6 @@ const char * const rtx_name[NUM_RTX_CODE] = {\n \n #undef DEF_RTL_EXPR\n \n-/* Indexed by machine mode, gives the name of that machine mode.\n-   This name does not include the letters \"mode\".  */\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  NAME,\n-\n-const char * const mode_name[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\n-};\n-\n-#undef DEF_MACHMODE\n-\n-/* Indexed by machine mode, gives the class mode for GET_MODE_CLASS.  */\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  CLASS,\n-\n-const enum mode_class mode_class[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\n-};\n-\n-#undef DEF_MACHMODE\n-\n-/* Indexed by machine mode, gives the length of the mode, in bits.\n-   GET_MODE_BITSIZE uses this.  */\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  BITSIZE,\n-\n-const unsigned short mode_bitsize[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\n-};\n-\n-#undef DEF_MACHMODE\n-\n-/* Indexed by machine mode, gives the length of the mode, in bytes.\n-   GET_MODE_SIZE uses this.  */\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  SIZE,\n-\n-const unsigned char mode_size[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\n-};\n-\n-#undef DEF_MACHMODE\n-\n-/* Indexed by machine mode, gives the length of the mode's subunit.\n-   GET_MODE_UNIT_SIZE uses this.  */\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  UNIT,\n-\n-const unsigned char mode_unit_size[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\t\t/* machine modes are documented here */\n-};\n-\n-#undef DEF_MACHMODE\n-\n-/* Indexed by machine mode, gives next wider natural mode\n-   (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions\n-   use this.  */\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  \\\n-  (unsigned char) WIDER,\n-\n-const unsigned char mode_wider_mode[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\t\t/* machine modes are documented here */\n-};\n-\n-#undef DEF_MACHMODE\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  \\\n-  ((BITSIZE) >= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT) 0 : ((unsigned HOST_WIDE_INT) 1 << (BITSIZE)) - 1,\n-\n-/* Indexed by machine mode, gives mask of significant bits in mode.  */\n-\n-const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\n-};\n-\n-#undef DEF_MACHMODE\n-\n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER) INNER,\n-\n-/* Indexed by machine mode, gives the mode of the inner elements in a\n-   vector type.  */\n-\n-const enum machine_mode inner_mode_array[NUM_MACHINE_MODES] = {\n-#include \"machmode.def\"\n-};\n-\n-/* Indexed by mode class, gives the narrowest mode for each class.\n-   The Q modes are always of width 1 (2 for complex) - it is impossible\n-   for any mode to be narrower.\n-\n-   Note that we use QImode instead of BImode for MODE_INT, since\n-   otherwise the middle end will try to use it for bitfields in\n-   structures and the like, which we do not want.  Only the target\n-   md file should generate BImode widgets.  */\n-\n-const enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS] = {\n-    /* MODE_RANDOM */\t\tVOIDmode,\n-    /* MODE_INT */\t\tQImode,\n-    /* MODE_FLOAT */\t\tQFmode,\n-    /* MODE_PARTIAL_INT */\tPQImode,\n-    /* MODE_CC */\t\tCCmode,\n-    /* MODE_COMPLEX_INT */\tCQImode,\n-    /* MODE_COMPLEX_FLOAT */\tQCmode,\n-    /* MODE_VECTOR_INT */\tV1DImode,\n-    /* MODE_VECTOR_FLOAT */\tV2SFmode\n-};\n-\n-\n /* Indexed by rtx code, gives a sequence of operand-types for\n    rtx's of that code.  The sequence is a C string in which\n    each character describes one operand.  */"}, {"sha": "dcdca573a8cd5dcdaf74d82e8e9bd1937814217c", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0974c7d70d3b8e9c9bf4d4cd3f86c86bb124a694", "patch": "@@ -298,20 +298,7 @@ int_mode_for_mode (enum machine_mode mode)\n unsigned int\n get_mode_alignment (enum machine_mode mode)\n {\n-  unsigned int alignment;\n-\n-  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-      || GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)\n-    alignment = GET_MODE_UNIT_SIZE (mode);\n-  else\n-    alignment = GET_MODE_SIZE (mode);\n-\n-  /* Extract the LSB of the size.  */\n-  alignment = alignment & -alignment;\n-  alignment *= BITS_PER_UNIT;\n-\n-  alignment = MIN (BIGGEST_ALIGNMENT, MAX (1, alignment));\n-  return alignment;\n+  return MIN (BIGGEST_ALIGNMENT, MAX (1, mode_base_align[mode]*BITS_PER_UNIT));\n }\n \n /* Return the value of VALUE, rounded up to a multiple of DIVISOR."}]}