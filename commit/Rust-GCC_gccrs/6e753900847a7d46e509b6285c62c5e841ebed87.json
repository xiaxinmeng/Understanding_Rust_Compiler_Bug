{"sha": "6e753900847a7d46e509b6285c62c5e841ebed87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3NTM5MDA4NDdhN2Q0NmU1MDliNjI4NWM2MmM1ZTg0MWViZWQ4Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T22:43:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T22:43:46Z"}, "message": "(FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER):\n\nExtension for -ax option (profile_block_flag == 2).\n(MACHINE_STATE_SAVE,MACHINE_STATE_RESTORE): New macros.\n(FUNCTION_BLOCK_PROFILER_EXIT): New macro.\n\nFrom-SVN: r10852", "tree": {"sha": "4efc20092ba971bcb50451aae26d51c3212621f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4efc20092ba971bcb50451aae26d51c3212621f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e753900847a7d46e509b6285c62c5e841ebed87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e753900847a7d46e509b6285c62c5e841ebed87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e753900847a7d46e509b6285c62c5e841ebed87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e753900847a7d46e509b6285c62c5e841ebed87/comments", "author": null, "committer": null, "parents": [{"sha": "88c956eb52a65d895b23052655fa25497af3d843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c956eb52a65d895b23052655fa25497af3d843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c956eb52a65d895b23052655fa25497af3d843"}], "stats": {"total": 429, "additions": 366, "deletions": 63}, "files": [{"sha": "497f68a8b205c2db1625a98ebe37aa5d0350e9ef", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 314, "deletions": 57, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e753900847a7d46e509b6285c62c5e841ebed87/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e753900847a7d46e509b6285c62c5e841ebed87/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6e753900847a7d46e509b6285c62c5e841ebed87", "patch": "@@ -948,102 +948,359 @@ typedef struct i386_args {\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-/* A C statement or compound statement to output to FILE some\n-   assembler code to initialize basic-block profiling for the current\n-   object module.  This code should call the subroutine\n-   `__bb_init_func' once per object module, passing it as its sole\n-   argument the address of a block allocated in the object module.\n \n-   The name of the block is a local symbol made with this statement:\n+/* There are three profiling modes for basic blocks available.\n+   The modes are selected at compile time by using the options\n+   -a or -ax of the gnu compiler.\n+   The variable `profile_block_flag' will be set according to the\n+   selected option.\n \n-\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+   profile_block_flag == 0, no option used:\n \n-   Of course, since you are writing the definition of\n-   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-   can take a short cut in the definition of this macro and use the\n-   name that you know will result.\n+      No profiling done.\n \n-   The first word of this block is a flag which will be nonzero if the\n-   object module has already been initialized.  So test this word\n-   first, and do not call `__bb_init_func' if the flag is nonzero.  */\n+   profile_block_flag == 1, -a option used.\n+\n+      Count frequency of execution of every basic block.\n+\n+   profile_block_flag == 2, -ax option used.\n+\n+      Generate code to allow several different profiling modes at run time. \n+      Available modes are:\n+             Produce a trace of all basic blocks.\n+             Count frequency of jump instructions executed.\n+      In every mode it is possible to start profiling upon entering\n+      certain functions and to disable profiling of some other functions.\n+\n+    The result of basic-block profiling will be written to a file `bb.out'.\n+    If the -ax option is used parameters for the profiling will be read\n+    from file `bb.in'.\n+\n+*/\n+\n+/* The following macro shall output assembler code to FILE\n+   to initialize basic-block profiling.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to call the subroutine `__bb_init_trace_func'\n+\tand pass two parameters to it. The first parameter is\n+\tthe address of a block allocated in the object module.\n+\tThe second parameter is the number of the first basic block\n+\tof the function.\n+\n+\tThe name of the block is a local symbol made with this statement:\n+\t\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n+\n+\tThe number of the first basic block of the function is\n+\tpassed to the macro in BLOCK_OR_LABEL.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tparameter1 <- LPBX0\n+\t\tparameter2 <- BLOCK_OR_LABEL\n+\t\tcall __bb_init_trace_func\n+\n+    else if profile_block_flag != 0\n+\n+\tOutput code to call the subroutine `__bb_init_func'\n+\tand pass one single parameter to it, which is the same\n+\tas the first parameter to `__bb_init_trace_func'.\n+\n+\tThe first word of this parameter is a flag which will be nonzero if\n+\tthe object module has already been initialized.  So test this word\n+\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n+\tNote: When profile_block_flag == 2 the test need not be done\n+\tbut `__bb_init_trace_func' *must* be called.\n+\n+\tBLOCK_OR_LABEL may be used to generate a label number as a\n+\tbranch destination in case `__bb_init_func' will not be called.\n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tcmp (LPBX0),0\n+\t\tjne local_label\n+\t\tparameter1 <- LPBX0\n+\t\tcall __bb_init_func\n+local_label:\n+\n+*/\n \n #undef\tFUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(STREAM, LABELNO)\t\t\t\\\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     static int num_func = 0;\t\t\t\t\t\t\\\n     rtx xops[8];\t\t\t\t\t\t\t\\\n     char block_table[80], false_label[80];\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (false_label, \"LPBZ\", num_func);\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    xops[0] = const0_rtx;\t\t\t\t\t\t\\\n     xops[1] = gen_rtx (SYMBOL_REF, VOIDmode, block_table);\t\t\\\n-    xops[2] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, false_label)); \\\n-    xops[3] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, \"__bb_init_func\")); \\\n-    xops[4] = gen_rtx (MEM, Pmode, xops[1]);\t\t\t\t\\\n     xops[5] = stack_pointer_rtx;\t\t\t\t\t\\\n-    xops[6] = GEN_INT (4);\t\t\t\t\t\t\\\n     xops[7] = gen_rtx (REG, Pmode, 0);\t/* eax */\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     CONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\t\t\t\t\\\n-    CONSTANT_POOL_ADDRESS_P (xops[2]) = TRUE;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    output_asm_insn (AS2(cmp%L4,%0,%4), xops);\t\t\t\t\\\n-    output_asm_insn (AS1(jne,%2), xops);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_pic)\t\t\t\t\t\t\t\\\n-      output_asm_insn (AS1(push%L1,%1), xops);\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n+    switch (profile_block_flag) \t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\toutput_asm_insn (AS2 (lea%L7,%a1,%7), xops);\t\t\t\\\n-\toutput_asm_insn (AS1 (push%L7,%7), xops);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n-    output_asm_insn (AS2(add%L0,%6,%5), xops);\t\t\t\t\\\n-    ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"LPBZ\", num_func);\t\t\\\n-    num_func++;\t\t\t\t\t\t\t\t\\\n+      case 2:\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        xops[2] = GEN_INT ((BLOCK_OR_LABEL));\t\t\t\t\\\n+        xops[3] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, \"__bb_init_trace_func\")); \\\n+        xops[6] = GEN_INT (8);\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        output_asm_insn (AS1(push%L2,%2), xops);\t\t\t\\\n+        if (!flag_pic)\t\t\t\t\t\t\t\\\n+          output_asm_insn (AS1(push%L1,%1), xops);\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+            output_asm_insn (AS2 (lea%L7,%a1,%7), xops);\t\t\\\n+            output_asm_insn (AS1 (push%L7,%7), xops);\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n+        output_asm_insn (AS2(add%L0,%6,%5), xops);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        ASM_GENERATE_INTERNAL_LABEL (false_label, \"LPBZ\", num_func);\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        xops[0] = const0_rtx;\t\t\t\t\t\t\\\n+        xops[2] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, false_label)); \\\n+        xops[3] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, \"__bb_init_func\")); \\\n+        xops[4] = gen_rtx (MEM, Pmode, xops[1]);\t\t\t\\\n+        xops[6] = GEN_INT (4);\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        CONSTANT_POOL_ADDRESS_P (xops[2]) = TRUE;\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        output_asm_insn (AS2(cmp%L4,%0,%4), xops);\t\t\t\\\n+        output_asm_insn (AS1(jne,%2), xops);\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        if (!flag_pic)\t\t\t\t\t\t\t\\\n+          output_asm_insn (AS1(push%L1,%1), xops);\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+            output_asm_insn (AS2 (lea%L7,%a1,%7), xops);\t\t\\\n+            output_asm_insn (AS1 (push%L7,%7), xops);\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+        output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n+        output_asm_insn (AS2(add%L0,%6,%5), xops);\t\t\t\\\n+        ASM_OUTPUT_INTERNAL_LABEL (FILE, \"LPBZ\", num_func);\t\t\\\n+        num_func++;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n+/* The following macro shall output assembler code to FILE\n+   to increment a counter associated with basic block number BLOCKNO.\n+\n+   If profile_block_flag == 2\n+\n+\tOutput code to initialize the global structure `__bb' and\n+\tcall the function `__bb_trace_func' which will increment the\n+\tcounter.\n+\n+\t`__bb' consists of two words. In the first word the number\n+\tof the basic block has to be stored. In the second word\n+\tthe address of a block allocated in the object module \n+\thas to be stored.\n+\n+\tThe basic block number is given by BLOCKNO.\n+\n+\tThe address of the block is given by the label created with \n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+\tby FUNCTION_BLOCK_PROFILER.\n \n-/* A C statement or compound statement to increment the count\n-   associated with the basic block number BLOCKNO.  Basic blocks are\n-   numbered separately from zero within each compilation.  The count\n-   associated with block number BLOCKNO is at index BLOCKNO in a\n-   vector of words; the name of this array is a local symbol made\n-   with this statement:\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result.\n \n-\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n \n-   Of course, since you are writing the definition of\n-   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-   can take a short cut in the definition of this macro and use the\n-   name that you know will result.  */\n+\t\tmove BLOCKNO -> (__bb)\n+\t\tmove LPBX0 -> (__bb+4)\n+\t\tcall __bb_trace_func\n \n-#define BLOCK_PROFILER(STREAM, BLOCKNO)\t\t\t\t\t\\\n+\tNote that function `__bb_trace_func' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE\n+\tand MACHINE_STATE_RESTORE. The last two macros will be\n+\tused in the function `__bb_trace_func', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE.\n+\n+   else if profile_block_flag != 0\n+\n+\tOutput code to increment the counter directly.\n+\tBasic blocks are numbered separately from zero within each\n+\tcompiled object module. The count associated with block number\n+\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n+\tthis array is a local symbol made with this statement:\n+\n+\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+\tOf course, since you are writing the definition of\n+\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+\tcan take a short cut in the definition of this macro and use the\n+\tname that you know will result. \n+\n+\tIf described in a virtual assembler language the code to be\n+\toutput looks like:\n+\n+\t\tinc (LPBX2+4*BLOCKNO)\n+\n+*/\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    rtx xops[1], cnt_rtx;\t\t\t\t\t\t\\\n+    rtx xops[8], cnt_rtx;\t\t\t\t\t\t\\\n     char counts[80];\t\t\t\t\t\t\t\\\n+    char *block_table = counts;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (counts, \"LPBX\", 2);\t\t\t\\\n-    cnt_rtx = gen_rtx (SYMBOL_REF, VOIDmode, counts);\t\t\t\\\n-    SYMBOL_REF_FLAG (cnt_rtx) = TRUE;\t\t\t\t\t\\\n+    switch (profile_block_flag) \t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    if (BLOCKNO)\t\t\t\t\t\t\t\\\n-      cnt_rtx = plus_constant (cnt_rtx, (BLOCKNO)*4);\t\t\t\\\n+      case 2:\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\t\t\\\n-      cnt_rtx = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, cnt_rtx);\t\\\n+        ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\txops[1] = gen_rtx (SYMBOL_REF, VOIDmode, block_table);\t\t\\\n+        xops[2] = GEN_INT ((BLOCKNO));\t\t\t\t\t\\\n+        xops[3] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, \"__bb_trace_func\")); \\\n+        xops[4] = gen_rtx (SYMBOL_REF, VOIDmode, \"__bb\");\t\t\\\n+\txops[5] = plus_constant (xops[4], 4);\t\t\t\t\\\n+\txops[0] = gen_rtx (MEM, SImode, xops[4]);\t\t\t\\\n+\txops[6] = gen_rtx (MEM, SImode, xops[5]);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tCONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tpushf\\n\");\t\t\t\t\t\\\n+        output_asm_insn (AS2(mov%L0,%2,%0), xops);\t\t\t\\\n+\tif (flag_pic)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            xops[7] = gen_rtx (REG, Pmode, 0);\t/* eax */\t\t\\\n+            output_asm_insn (AS1(push%L7,%7), xops);\t\t\t\\\n+            output_asm_insn (AS2(lea%L7,%a1,%7), xops);\t\t\t\\\n+            output_asm_insn (AS2(mov%L6,%7,%6), xops);\t\t\t\\\n+            output_asm_insn (AS1(pop%L7,%7), xops);\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+          output_asm_insn (AS2(mov%L6,%1,%6), xops);\t\t\t\\\n+        output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n+\tfprintf(FILE, \"\\tpopf\\n\");\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        ASM_GENERATE_INTERNAL_LABEL (counts, \"LPBX\", 2);\t\t\\\n+        cnt_rtx = gen_rtx (SYMBOL_REF, VOIDmode, counts);\t\t\\\n+        SYMBOL_REF_FLAG (cnt_rtx) = TRUE;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        if (BLOCKNO)\t\t\t\t\t\t\t\\\n+          cnt_rtx = plus_constant (cnt_rtx, (BLOCKNO)*4);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        if (flag_pic)\t\t\t\t\t\t\t\\\n+          cnt_rtx = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, cnt_rtx);\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    xops[0] = gen_rtx (MEM, SImode, cnt_rtx);\t\t\t\t\\\n-    output_asm_insn (AS1(inc%L0,%0), xops);\t\t\t\t\\\n+        xops[0] = gen_rtx (MEM, SImode, cnt_rtx);\t\t\t\\\n+        output_asm_insn (AS1(inc%L0,%0), xops);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n+/* The following macro shall output assembler code to FILE\n+   to indicate a return from function during basic-block profiling.\n+\n+   If profiling_block_flag == 2:\n+\n+\tOutput assembler code to call function `__bb_trace_ret'.\n+\n+\tNote that function `__bb_trace_ret' must not change the\n+\tmachine state, especially the flag register. To grant\n+\tthis, you must output code to save and restore registers\n+\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n+\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n+\tused in the function `__bb_trace_ret', so you must make\n+\tsure that the function prologue does not change any \n+\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n+\n+   else if profiling_block_flag != 0:\n+\n+\tThe macro will not be used, so it need not distinguish\n+\tthese cases.\n+*/\n+\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    rtx xops[1];\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    xops[0] = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, VOIDmode, \"__bb_trace_ret\")); \\\n+\t\t\t\t\t\t\t\t\t\\\n+    output_asm_insn (AS1(call,%P0), xops);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* The function `__bb_trace_func' is called in every basic block\n+   and is not allowed to change the machine state. Saving (restoring)\n+   the state can either be done in the BLOCK_PROFILER macro,\n+   before calling function (rsp. after returning from function)\n+   `__bb_trace_func', or it can be done inside the function by\n+   defining the macros:\n+\n+\tMACHINE_STATE_SAVE(ID)\n+\tMACHINE_STATE_RESTORE(ID)\n+\n+   In the latter case care must be taken, that the prologue code\n+   of function `__bb_trace_func' does not already change the\n+   state prior to saving it with MACHINE_STATE_SAVE.\n+\n+   The parameter `ID' is a string identifying a unique macro use.\n+\n+   On the i386 the initialization code at the begin of\n+   function `__bb_trace_func' contains a `sub' instruction\n+   therefore we handle save and restore of the flag register \n+   in the BLOCK_PROFILER macro. */\n+\n+#define MACHINE_STATE_SAVE(ID) \\\n+  asm (\"\tpushl %eax\"); \\\n+  asm (\"\tpushl %ecx\"); \\\n+  asm (\"\tpushl %edx\"); \\\n+  asm (\"\tpushl %esi\");\n+\n+#define MACHINE_STATE_RESTORE(ID) \\\n+  asm (\"\tpopl %esi\"); \\\n+  asm (\"\tpopl %edx\"); \\\n+  asm (\"\tpopl %ecx\"); \\\n+  asm (\"\tpopl %eax\");\n+\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers."}, {"sha": "c8280f6adf5662da3bd2bc91a780f9efb3fa0b72", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e753900847a7d46e509b6285c62c5e841ebed87/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e753900847a7d46e509b6285c62c5e841ebed87/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=6e753900847a7d46e509b6285c62c5e841ebed87", "patch": "@@ -880,15 +880,61 @@ extern enum reg_class regno_reg_class[];\n /* Output assembler code to FILE to initialize this source file's\n    basic block profiling info, if that has not already been done.  */\n \n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  asm_fprintf (FILE, \"\\ttstl %LLPBX0\\n\\tbne %LLPI%d\\n\\tpea %LLPBX0\\n\\tjsr %U__bb_init_func\\n\\taddql %I4,%Rsp\\n%LLPI%d:\\n\",  \\\n-\t   LABELNO, LABELNO);\n-\n-/* Output assembler code to FILE to increment the entry-count for\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n+do\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    switch (profile_block_flag)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+      case 2:\t\t\t\t\t\t\\\n+        asm_fprintf (FILE, \"\\tpea %d\\n\\tpea %LLPBX0\\n\\tjsr %U__bb_init_trace_func\\n\\taddql %I8,%Rsp\\n\", \\\n+                           (BLOCK_OR_LABEL)); \\\n+        break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\\\n+        asm_fprintf (FILE, \"\\ttstl %LLPBX0\\n\\tbne %LLPI%d\\n\\tpea %LLPBX0\\n\\tjsr %U__bb_init_func\\n\\taddql %I4,%Rsp\\n%LLPI%d:\\n\", \\\n+                           (BLOCK_OR_LABEL), (BLOCK_OR_LABEL)); \\\n+        break;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+while(0)\n+\n+/* Output assembler code to FILE to increment the counter for\n    the BLOCKNO'th basic block in this source file.  */\n \n #define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n-  asm_fprintf (FILE, \"\\taddql %I1,%LLPBX2+%d\\n\", 4 * BLOCKNO)\n+do\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    switch (profile_block_flag)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+      case 2:\t\t\t\t\t\t\\\n+        asm_fprintf (FILE, \"\\tmovel %Ra1,%Rsp@-\\n\\tlea ___bb,%Ra1\\n\\tmovel %I%d,%Ra1@(0)\\n\\tmovel %I%LLPBX0,%Ra1@(4)\\n\\tmovel %Rsp@+,%Ra1\\n\\tjsr %U__bb_trace_func\\n\", \\\n+                           BLOCKNO);\t\t\t\\\n+        break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\\\n+        asm_fprintf (FILE, \"\\taddql %I1,%LLPBX2+%d\\n\", 4 * BLOCKNO); \\\n+        break;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+while(0)\n+\n+/* Output assembler code to FILE to indicate return from \n+   a function during basic block profiling. */\n+\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\t\\\n+  asm_fprintf (FILE, \"\\tjsr %U__bb_trace_ret\\n\");\n+\n+/* Save all registers which may be clobbered by a function call. */\n+\n+#define MACHINE_STATE_SAVE(id)\t\t\t\\\n+  asm (\"\tmovew cc,sp@-\");\t\t\\\n+  asm (\"\tmoveml d0/d1/a0/a1,sp@-\");\n+\n+/* Restore all registers saved by MACHINE_STATE_SAVE. */\n+\n+#define MACHINE_STATE_RESTORE(id)\t\t\\\n+  asm (\"\tmoveml sp@+,d0/d1/a0/a1\");\t\\\n+  asm (\"\tmovew sp@+,cc\");\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in"}]}