{"sha": "e26d4611b584225b283830cabf86d7ce68925f1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI2ZDQ2MTFiNTg0MjI1YjI4MzgzMGNhYmY4NmQ3Y2U2ODkyNWYxZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-28T07:43:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-28T07:43:14Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r3569", "tree": {"sha": "b84bbdeb60ee6938653d99c5089c60d7b6539c5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b84bbdeb60ee6938653d99c5089c60d7b6539c5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e26d4611b584225b283830cabf86d7ce68925f1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26d4611b584225b283830cabf86d7ce68925f1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e26d4611b584225b283830cabf86d7ce68925f1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26d4611b584225b283830cabf86d7ce68925f1d/comments", "author": null, "committer": null, "parents": [{"sha": "41424fddc04cf7d566f7fc2014c78746f2fcf023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41424fddc04cf7d566f7fc2014c78746f2fcf023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41424fddc04cf7d566f7fc2014c78746f2fcf023"}], "stats": {"total": 226, "additions": 113, "deletions": 113}, "files": [{"sha": "69fa12cc0e555c87219c037f71ea910e0cb308af", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 113, "deletions": 113, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e26d4611b584225b283830cabf86d7ce68925f1d/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e26d4611b584225b283830cabf86d7ce68925f1d/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=e26d4611b584225b283830cabf86d7ce68925f1d", "patch": "@@ -27,6 +27,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"c-tree.h\"\n #include \"flags.h\"\n+#include \"obstack.h\"\n+#include \"rtl.h\"\n \n static void expand_stmt_with_iterators_1 ();\n static tree collect_iterators();\n@@ -36,29 +38,96 @@ static void add_ixpansion ();\n static void delete_ixpansion();\n static int top_level_ixpansion_p ();\n static void istack_sublevel_to_current ();\n+\n+/* A special obstack, and a pointer to the start of\n+   all the data in it (so we can free everything easily).  */\n+static struct obstack ixp_obstack;\n+static char *ixp_firstobj;\n \f\n-void\n-iterator_for_loop_start (idecl)\n-     tree idecl;\n+/*\n+\t\tKEEPING TRACK OF EXPANSIONS\n+\n+   In order to clean out expansions corresponding to statements inside\n+   \"{(...)}\" constructs we have to keep track of all expansions.  The\n+   cleanup is needed when an automatic, or implicit, expansion on\n+   iterator, say X, happens to a statement which contains a {(...)}\n+   form with a statement already expanded on X.  In this case we have\n+   to go back and cleanup the inner expansion.  This can be further\n+   complicated by the fact that {(...)} can be nested.\n+\n+   To make this cleanup possible, we keep lists of all expansions, and\n+   to make it work for nested constructs, we keep a stack.  The list at\n+   the top of the stack (ITER_STACK.CURRENT_LEVEL) corresponds to the\n+   currently parsed level.  All expansions of the levels below the\n+   current one are kept in one list whose head is pointed to by\n+   ITER_STACK.SUBLEVEL_FIRST (SUBLEVEL_LAST is there for making merges\n+   easy).  The process works as follows:\n+\n+   -- On \"({\"  a new node is added to the stack by PUSH_ITERATOR_STACK.\n+\t       The sublevel list is not changed at this point.\n+\n+   -- On \"})\" the list for the current level is appended to the sublevel\n+\t      list. \n+\n+   -- On \";\"  sublevel lists are appended to the current level lists.\n+\t      The reason is this: if they have not been superseded by the\n+\t      expansion at the current level, they still might be\n+\t      superseded later by the expansion on the higher level.\n+\t      The levels do not have to distinguish levels below, so we\n+\t      can merge the lists together.  */\n+\n+struct  ixpansion\n {\n-  iterator_loop_prologue (idecl, 0, 0);\n-}\n+  tree ixdecl;\t\t\t/* Iterator decl */\n+  rtx  ixprologue_start;\t/* First insn of epilogue. NULL means */\n+  /* explicit (FOR) expansion*/\n+  rtx  ixprologue_end;\n+  rtx  ixepilogue_start;\n+  rtx  ixepilogue_end;\n+  struct ixpansion *next;\t/* Next in the list */\n+};\n+\n+struct iter_stack_node\n+{\n+  struct ixpansion *first;\t/* Head of list of ixpansions */\n+  struct ixpansion *last;\t/* Last node in list  of ixpansions */\n+  struct iter_stack_node *next; /* Next level iterator stack node  */\n+};\n+\n+struct iter_stack_node *iter_stack;\n+\n+struct iter_stack_node sublevel_ixpansions;\n+\f\n+/* Initialize our obstack once per compilation.  */\n \n void\n-iterator_for_loop_end (idecl)\n-     tree idecl;\n+init_iterators ()\n {\n-  iterator_loop_epilogue (idecl, 0, 0);\n+  gcc_obstack_init (&ixp_obstack);\n+  ixp_firstobj = (char *) obstack_alloc (&ixp_obstack, 0);\n }\n \n+/* Handle the start of an explicit `for' loop for iterator IDECL.  */\n+\n void\n-iterator_for_loop_record (idecl)\n+iterator_for_loop_start (idecl)\n      tree idecl;\n {\n+  ITERATOR_BOUND_P (idecl) = 1;\n   add_ixpansion (idecl, 0, 0, 0, 0);\n+  iterator_loop_prologue (idecl, 0, 0);\n }\n \n+/* Handle the end of an explicit `for' loop for iterator IDECL.  */\n \n+void\n+iterator_for_loop_end (idecl)\n+     tree idecl;\n+{\n+  iterator_loop_epilogue (idecl, 0, 0);\n+  ITERATOR_BOUND_P (idecl) = 0;\n+}\n+\f\n /*\n   \t\tITERATOR DECLS\n \n@@ -100,16 +169,14 @@ build_iterator_decl (id, limit)\n /*\n   \t\tITERATOR RTL EXPANSIONS\n \n-   Expanding simple statements with iterators is  pretty straightforward:\n-   collect (collect_iterators) the list  of  all \"free\" iterators  in the\n-   statement and for each  of them add  a  special prologue before and an\n-   epilogue after the expansion for  the statement. Iterator is \"free\" if\n-   it has not been \"bound\" by a FOR operator. The rtx associated with the\n-   iterator's  decl is used as  the loop counter.  Special processing  is\n-   used  for \"{(...)}\" constructs:  each iterator expansion is registered\n-   (by \"add_ixpansion\" function)  and inner expansions are superseded  by\n-   outer ones. The cleanup of superseded expansions is done by  a call to\n-   delete_ixpansion.  */\n+   Expanding simple statements with iterators is straightforward:\n+   collect the list of all free iterators in the statement, and\n+   generate a loop for each of them.\n+\n+   An iterator is \"free\" if it has not been \"bound\" by a FOR\n+   operator.  The DECL_RTL of the iterator is the loop counter.  */\n+\n+/* Expand a statement STMT, possibly containing iterator usage, into RTL.  */\n \n void\n iterator_expand (stmt)\n@@ -146,9 +213,9 @@ expand_stmt_with_iterators_1 (stmt, iter_list)\n }\n \n \n-/* Return a list containing all the free (i.e. not bound by \"for\"\n-   statement or anaccumulator) iterators mentioned in EXP,\n-   plus those in LIST.   Duplicates are avoided.  */\n+/* Return a list containing all the free (i.e. not bound by a\n+   containing `for' statement) iterators mentioned in EXP, plus those\n+   in LIST.  Do not add duplicate entries to the list.  */\n \n static tree\n collect_iterators (exp, list)\n@@ -238,17 +305,18 @@ iterator_loop_prologue (idecl, start_note, end_note)\n    DECL_RTL is zeroed unless we are inside \"({...})\". The reason for that is\n    described below.\n \n-   When we create two (or more)  loops based on the  same IDECL, and both\n-   inside the same \"({...})\"  construct, we  must be prepared  to  delete\n-   both of the loops  and create a single one  on the  level  above, i.e.\n-   enclosing the \"({...})\". The new loop has to use  the same counter rtl\n-   because the references to the iterator decl  (IDECL) have already been\n-   expanded as references to the counter rtl.\n+   When we create two (or more) loops based on the same IDECL, and\n+   both inside the same \"({...})\"  construct, we must be prepared to\n+   delete both of the loops and create a single one on the level\n+   above, i.e.  enclosing the \"({...})\". The new loop has to use the\n+   same counter rtl because the references to the iterator decl\n+   (IDECL) have already been expanded as references to the counter\n+   rtl.\n \n    It is incorrect to use the same counter reg in different functions,\n    and it is desirable to use different counters in disjoint loops\n-   when we know there's no need to combine them\n-   (because then they can get allocated separately).  */\n+   when we know there's no need to combine them (because then they can\n+   get allocated separately).  */\n \n static void\n iterator_loop_epilogue (idecl, start_note, end_note)\n@@ -275,65 +343,7 @@ iterator_loop_epilogue (idecl, start_note, end_note)\n     *end_note = emit_note (0, NOTE_INSN_DELETED);\n }\n \f\n-/*\n-\t\tKEEPING TRACK OF EXPANSIONS\n-\n-   In order to clean out expansions corresponding to statements inside\n-   \"{(...)}\" constructs we have to keep track of all expansions.  The\n-   cleanup is needed when an automatic, or implicit, expansion on\n-   iterator, say X, happens to a statement which contains a {(...)}\n-   form with a statement already expanded on X.  In this case we have\n-   to go back and cleanup the inner expansion.  This can be further\n-   complicated by the fact that {(...)} can be nested.\n-\n-   To make this cleanup possible, we keep lists of all expansions, and\n-   to make it work for nested constructs, we keep a stack.  The list at\n-   the top of the stack (ITER_STACK.CURRENT_LEVEL) corresponds to the\n-   currently parsed level.  All expansions of the levels below the\n-   current one are kept in one list whose head is pointed to by\n-   ITER_STACK.SUBLEVEL_FIRST (SUBLEVEL_LAST is there for making merges\n-   easy).  The process works as follows:\n-\n-   -- On \"({\"  a new node is added to the stack by PUSH_ITERATOR_STACK.\n-\t       The sublevel list is not changed at this point.\n-\n-   -- On \"})\" the list for the current level is appended to the sublevel\n-\t      list. \n-\n-   -- On \";\"  sublevel lists are appended to the current level lists.\n-\t      The reason is this: if they have not been superseded by the\n-\t      expansion at the current level, they still might be\n-\t      superseded later by the expansion on the higher level.\n-\t      The levels do not have to distinguish levels below, so we\n-\t      can merge the lists together.  */\n-\n-struct  ixpansion\n-{\n-  tree ixdecl;\t\t\t/* Iterator decl */\n-  rtx  ixprologue_start;\t/* First insn of epilogue. NULL means */\n-  /* explicit (FOR) expansion*/\n-  rtx  ixprologue_end;\n-  rtx  ixepilogue_start;\n-  rtx  ixepilogue_end;\n-  struct ixpansion *next;\t/* Next in the list */\n-};\n-\n-static struct obstack ixp_obstack;\n-\n-static char *ixp_firstobj;\n-\n-struct iter_stack_node\n-{\n-  struct ixpansion *first;\t/* Head of list of ixpansions */\n-  struct ixpansion *last;\t/* Last node in list  of ixpansions */\n-  struct iter_stack_node *next; /* Next level iterator stack node  */\n-};\n-\n-struct iter_stack_node *iter_stack;\n-\n-struct iter_stack_node sublevel_ixpansions;\n-\n-/** Return true if we are not currently inside a \"({...})\" construct */\n+/* Return true if we are not currently inside a \"({...})\" construct.  */\n \n static int\n top_level_ixpansion_p ()\n@@ -495,33 +505,22 @@ delete_ixpansion (idecl)\n       previx = ix;\n }\n \f\n-/*\n-We initialize iterators obstack once per file\n-*/\n-\n-init_iterators ()\n-{\n-  gcc_obstack_init (&ixp_obstack);\n-  ixp_firstobj = (char *) obstack_alloc (&ixp_obstack, 0);\n-}\n-\n #ifdef DEBUG_ITERATORS\n \n-/*\n-The functions below are for use from source level debugger.\n-They print short forms of iterator lists and the iterator stack.\n-*/\n+/* The functions below are for use from source level debugger.\n+   They print short forms of iterator lists and the iterator stack.  */\n+\n+/* Print the name of the iterator D.  */\n \n-/* Print the name of the iterator D */\n void\n-PRDECL (D)\n-     tree D;\n+prdecl (d)\n+     tree d;\n {\n-  if (D)\n+  if (d)\n     {\n-      if (TREE_CODE (D) == VAR_DECL)\n+      if (TREE_CODE (d) == VAR_DECL)\n \t{\n-\t  tree tname = DECL_NAME (D);\n+\t  tree tname = DECL_NAME (d);\n \t  char *dname = IDENTIFIER_POINTER (tname);\n \t  fprintf (stderr, dname);\n \t}\n@@ -539,10 +538,10 @@ pil (head)\n      tree head;\n {\n   tree current, next;\n-  for (current=head; current; current = next)\n+  for (current = head; current; current = next)\n     {\n       tree node = TREE_VALUE (current);\n-      PRDECL (node);\n+      prdecl (node);\n       next = TREE_CHAIN (current);\n       if (next) fprintf (stderr, \",\");\n     }\n@@ -563,7 +562,7 @@ pixl (head)\n   for (current=head; current; current = next)\n     {\n       tree node = current->ixdecl;\n-      PRDECL (node);\n+      prdecl (node);\n       next = current->next;\n       if (next)\n \tfprintf (stderr, \",\");\n@@ -587,4 +586,5 @@ pis ()\n        stack_node = stack_node->next)\n     pixl (stack_node->first);\n }\n-#endif\n+\n+#endif /* DEBUG_ITERATORS */"}]}