{"sha": "c91062822060a9cab744b3d10fda6456822740aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkxMDYyODIyMDYwYTljYWI3NDRiM2QxMGZkYTY0NTY4MjI3NDBhYQ==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2015-11-16T10:21:09Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2015-11-16T10:21:09Z"}, "message": "re PR target/65837 ([arm-linux-gnueabihf] lto1 target specific builtin not available)\n\n2015-11-16  Christian Bruel  <christian.bruel@st.com>\n\n\tPR target/65837\n\t* config/arm/arm-c.c (arm_cpu_builtins): Set or reset\n\t__ARM_FEATURE_CRYPTO, __VFP_FP__, __ARM_NEON__\n\t(arm_pragma_target_parse): Change check for arm_cpu_builtins.\n\tundefine __ARM_FP.\n\t* config/arm/arm.c (arm_can_inline_p): Check FPUs.\n\t(arm_valid_target_attribute_rec): Handle -mfpu attribute target.\n\t* doc/invoke.texi (-mfpu=): Mention attribute and pragma.\n\t* doc/extend.texi (-mfpu=): Describe attribute.\n\n2015-11-16  Christian Bruel  <christian.bruel@st.com>\n\n\tPR target/65837\n\tgcc.target/arm/lto/pr65837_0.c\n\tgcc.target/arm/attr-neon2.c\n\tgcc.target/arm/attr-neon.c\n\tgcc.target/arm/attr-neon-builtin-fail.c\n\tgcc.target/arm/attr-crypto.c\n\nFrom-SVN: r230408", "tree": {"sha": "ee314e0dd14d265464bb96c6e9abbc167b1599e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee314e0dd14d265464bb96c6e9abbc167b1599e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c91062822060a9cab744b3d10fda6456822740aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c91062822060a9cab744b3d10fda6456822740aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c91062822060a9cab744b3d10fda6456822740aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c91062822060a9cab744b3d10fda6456822740aa/comments", "author": null, "committer": null, "parents": [{"sha": "f39cdf66d6e7f9b42b9339315aabfea40af44460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f39cdf66d6e7f9b42b9339315aabfea40af44460", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f39cdf66d6e7f9b42b9339315aabfea40af44460"}], "stats": {"total": 256, "additions": 222, "deletions": 34}, "files": [{"sha": "fb7dc5a37aecd5bd080375738a81f6afca09422e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -1,3 +1,15 @@\n+2015-11-16  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/65837\n+\t* config/arm/arm-c.c (arm_cpu_builtins): Set or reset\n+\t__ARM_FEATURE_CRYPTO, __VFP_FP__, __ARM_NEON__\n+\t(arm_pragma_target_parse): Change check for arm_cpu_builtins.\n+\tundefine __ARM_FP.\n+\t* config/arm/arm.c (arm_can_inline_p): Check FPUs.\n+\t(arm_valid_target_attribute_rec): Handle -mfpu attribute target.\n+\t* doc/invoke.texi (-mfpu=): Mention attribute and pragma.\n+\t* doc/extend.texi (-mfpu=): Describe attribute.\n+\n 2015-11-16  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/65837"}, {"sha": "e94fa107537922d038536dddc9ab32d37c2dae73", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -64,8 +64,8 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_DSP\", TARGET_DSP_MULTIPLY);\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_QBIT\", TARGET_ARM_QBIT); \n   def_or_undef_macro (pfile, \"__ARM_FEATURE_SAT\", TARGET_ARM_SAT);\n-  if (TARGET_CRYPTO)\n-    builtin_define (\"__ARM_FEATURE_CRYPTO\");\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_CRYPTO\", TARGET_CRYPTO);\n+\n   if (unaligned_access)\n     builtin_define (\"__ARM_FEATURE_UNALIGNED\");\n   if (TARGET_CRC32)\n@@ -125,9 +125,8 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   if (TARGET_SOFT_FLOAT)\n     builtin_define (\"__SOFTFP__\");\n \n-  if (TARGET_VFP)\n-    builtin_define (\"__VFP_FP__\");\n-\t\n+  def_or_undef_macro (pfile, \"__VFP_FP__\", TARGET_VFP);\n+\n   if (TARGET_ARM_FP)\n     builtin_define_with_int_value (\"__ARM_FP\", TARGET_ARM_FP);\n   if (arm_fp16_format == ARM_FP16_FORMAT_IEEE)\n@@ -137,19 +136,16 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   if (TARGET_FMA)\n     builtin_define (\"__ARM_FEATURE_FMA\");\n \n-  if (TARGET_NEON)\n-    {\n-      builtin_define (\"__ARM_NEON__\");\n-      builtin_define (\"__ARM_NEON\");\n-    }\n+  def_or_undef_macro (pfile, \"__ARM_NEON__\", TARGET_NEON);\n+  def_or_undef_macro (pfile, \"__ARM_NEON\", TARGET_NEON);\n+\n   if (TARGET_NEON_FP)\n     builtin_define_with_int_value (\"__ARM_NEON_FP\", TARGET_NEON_FP);\n-  \n+\n   /* Add a define for interworking. Needed when building libgcc.a.  */\n   if (arm_cpp_interwork)\n     builtin_define (\"__THUMB_INTERWORK__\");\n \n-\n   builtin_define (arm_arch_name);\n   if (arm_arch_xscale)\n     builtin_define (\"__XSCALE__\");\n@@ -228,19 +224,27 @@ arm_pragma_target_parse (tree args, tree pop_target)\n   gcc_assert (prev_opt);\n   gcc_assert (cur_opt);\n \n-  if (cur_opt->x_target_flags != prev_opt->x_target_flags)\n+  if (cur_opt != prev_opt)\n     {\n       /* For the definitions, ensure all newly defined macros are considered\n \t as used for -Wunused-macros.  There is no point warning about the\n \t compiler predefined macros.  */\n       cpp_options *cpp_opts = cpp_get_options (parse_in);\n       unsigned char saved_warn_unused_macros = cpp_opts->warn_unused_macros;\n+      unsigned char saved_warn_builtin_macro_redefined\n+\t= cpp_opts->warn_builtin_macro_redefined;\n+\n       cpp_opts->warn_unused_macros = 0;\n+      cpp_opts->warn_builtin_macro_redefined = 0;\n \n       /* Update macros.  */\n       gcc_assert (cur_opt->x_target_flags == target_flags);\n+      /* This one can be redefined by the pragma without warning.  */\n+      cpp_undef (parse_in, \"__ARM_FP\");\n+\n       arm_cpu_builtins (parse_in);\n \n+      cpp_opts->warn_builtin_macro_redefined = saved_warn_builtin_macro_redefined;\n       cpp_opts->warn_unused_macros = saved_warn_unused_macros;\n     }\n "}, {"sha": "a6b25dccb017d156c3cef7375ed05ebb2ef13749", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -29759,11 +29759,36 @@ arm_option_print (FILE *file, int indent, struct cl_target_option *ptr)\n /* Hook to determine if one function can safely inline another.  */\n \n static bool\n-arm_can_inline_p (tree caller ATTRIBUTE_UNUSED, tree callee ATTRIBUTE_UNUSED)\n+arm_can_inline_p (tree caller, tree callee)\n {\n-  /* Overidde default hook: Always OK to inline between different modes. \n-     Function with mode specific instructions, e.g using asm, must be explicitely \n-     protected with noinline.  */\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n+\n+  struct cl_target_option *caller_opts\n+\t= TREE_TARGET_OPTION (caller_tree ? caller_tree\n+\t\t\t\t\t   : target_option_default_node);\n+\n+  struct cl_target_option *callee_opts\n+\t= TREE_TARGET_OPTION (callee_tree ? callee_tree\n+\t\t\t\t\t   : target_option_default_node);\n+\n+  const struct arm_fpu_desc *caller_fpu\n+    = &all_fpus[caller_opts->x_arm_fpu_index];\n+  const struct arm_fpu_desc *callee_fpu\n+    = &all_fpus[callee_opts->x_arm_fpu_index];\n+\n+  /* Callee's fpu features should be a subset of the caller's.  */\n+  if ((caller_fpu->features & callee_fpu->features) != callee_fpu->features)\n+    return false;\n+\n+  /* Need same model and regs.  */\n+  if (callee_fpu->model != caller_fpu->model\n+      || callee_fpu->regs != callee_fpu->regs)\n+    return false;\n+\n+  /* OK to inline between different modes.\n+     Function with mode specific instructions, e.g using asm,\n+     must be explicitly protected with noinline.  */\n   return true;\n }\n \n@@ -29794,6 +29819,7 @@ arm_valid_target_attribute_rec (tree args, struct gcc_options *opts)\n   if (TREE_CODE (args) == TREE_LIST)\n     {\n       bool ret = true;\n+\n       for (; args; args = TREE_CHAIN (args))\n \tif (TREE_VALUE (args)\n \t    && !arm_valid_target_attribute_rec (TREE_VALUE (args), opts))\n@@ -29808,30 +29834,38 @@ arm_valid_target_attribute_rec (tree args, struct gcc_options *opts)\n     }\n \n   char *argstr = ASTRDUP (TREE_STRING_POINTER (args));\n-  while (argstr && *argstr != '\\0')\n+  char *q;\n+\n+  while ((q = strtok (argstr, \",\")) != NULL)\n     {\n-      while (ISSPACE (*argstr))\n-\targstr++;\n+      while (ISSPACE (*q)) ++q;\n \n-      if (!strcmp (argstr, \"thumb\"))\n-\t{\n+      argstr = NULL;\n+      if (!strncmp (q, \"thumb\", 5))\n \t  opts->x_target_flags |= MASK_THUMB;\n-\t  arm_option_check_internal (opts);\n-\t  return true;\n-\t}\n \n-      if (!strcmp (argstr, \"arm\"))\n-\t{\n+      else if (!strncmp (q, \"arm\", 3))\n \t  opts->x_target_flags &= ~MASK_THUMB;\n-\t  arm_option_check_internal (opts);\n-\t  return true;\n+\n+      else if (!strncmp (q, \"fpu=\", 4))\n+\t{\n+\t  if (! opt_enum_arg_to_value (OPT_mfpu_, q+4,\n+\t\t\t\t       &opts->x_arm_fpu_index, CL_TARGET))\n+\t    {\n+\t      error (\"invalid fpu for attribute(target(\\\"%s\\\"))\", q);\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  error (\"attribute(target(\\\"%s\\\")) is unknown\", q);\n+\t  return false;\n \t}\n \n-      warning (0, \"attribute(target(\\\"%s\\\")) is unknown\", argstr);\n-      return false;\n+      arm_option_check_internal (opts);\n     }\n \n-  return false;\n+  return true;\n }\n \n /* Return a TARGET_OPTION_NODE tree of the target options listed or NULL.  */"}, {"sha": "4d64e14f5b81d6781a22d231954db6c7717e98a3", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -3701,10 +3701,17 @@ architecture level.\n @item arm\n @cindex @code{target(\"arm\")} function attribute, ARM\n Force code generation in the ARM (A32) ISA.\n-@end table\n \n Functions from different modes can be inlined in the caller's mode.\n \n+@item fpu=\n+@cindex @code{target(\"fpu=\")} function attribute, ARM\n+Specifies the fpu for which to tune the performance of this function.\n+The behavior and permissible arguments are the same as for the @option{-mfpu=}\n+command-line option.\n+\n+@end table\n+\n @end table\n \n @node AVR Function Attributes"}, {"sha": "8057ac9454973dd4145b0e2735d1e27fa978d492", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -13644,6 +13644,8 @@ because NEON hardware does not fully implement the IEEE 754 standard for\n floating-point arithmetic (in particular denormal values are treated as\n zero), so the use of NEON instructions may lead to a loss of precision.\n \n+You can also set the fpu name at function level by using the @code{target(\"fpu=\")} function attributes (@pxref{ARM Function Attributes}) or pragmas (@pxref{Function Specific Option Pragmas}).\n+\n @item -mfp16-format=@var{name}\n @opindex mfp16-format\n Specify the format of the @code{__fp16} half-precision floating-point type."}, {"sha": "10def9fd1525efdda7610a9610a26926540158f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -1,3 +1,12 @@\n+2015-11-16  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/65837\n+\tgcc.target/arm/lto/pr65837_0.c\n+\tgcc.target/arm/attr-neon2.c\n+\tgcc.target/arm/attr-neon.c\n+\tgcc.target/arm/attr-neon-builtin-fail.c\n+\tgcc.target/arm/attr-crypto.c\n+\n 2015-11-16  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/vect/bb-slp-32.c: Adjust testcase.\n@@ -4782,7 +4791,7 @@\n \tPR c++-common/67882\n \t* c-c++-common/builtin-offsetof-2.c: New test.\n \n-2015-11-03  Dominique d'Humieres <dominiq@lps.ens.fr>\n+015-11-03  Dominique d'Humieres <dominiq@lps.ens.fr>\n \n \tPR fortran/67982\n \t* gfortran.dg/warn_unused_function_3.f90: New test."}, {"sha": "1db598447cd724e5c18c645029d1a5e9cbb80fbe", "filename": "gcc/testsuite/gcc.target/arm/attr-crypto.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-crypto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-crypto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-crypto.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_crypto_ok } */\n+/* { dg-options \"-O2 -mfloat-abi=softfp\" } */\n+\n+#pragma GCC target (\"fpu=crypto-neon-fp-armv8\")\n+\n+#ifndef __ARM_FEATURE_CRYPTO\n+#error __ARM_FEATURE_CRYPTO not defined.\n+#endif\n+\n+#ifndef __ARM_NEON\n+#error __ARM_NEON not defined.\n+#endif\n+\n+#if !defined(__ARM_FP) || (__ARM_FP != 14)\n+#error __ARM_FP\n+#endif\n+\n+#include \"arm_neon.h\"\n+\n+int\n+foo (void)\n+{\n+  uint32x4_t a = {0xd, 0xe, 0xa, 0xd};\n+  uint32x4_t b = {0, 1, 2, 3};\n+\n+  uint32x4_t res = vsha256su0q_u32 (a, b);\n+  return res[0];\n+}\n+\n+#pragma GCC reset_options\n+\n+/* Check that the FP version is correctly reset.  */\n+\n+#if !defined(__ARM_FP) || (__ARM_FP != 12)\n+#error __ARM_FP\n+#endif\n+\n+/* { dg-final { scan-assembler \"sha256su0.32\\tq\\[0-9\\]+, q\\[0-9\\]+\" } } */"}, {"sha": "6ac32fca166711bb0a7bc86c57e5c88b677b6dca", "filename": "gcc/testsuite/gcc.target/arm/attr-neon-builtin-fail.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-builtin-fail.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-builtin-fail.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon-builtin-fail.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -0,0 +1,17 @@\n+/* Check that calling a neon builtin from a function compiled with vfp fails.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O2 -mfloat-abi=softfp\" } */\n+\n+#include <arm_neon.h>\n+\n+__attribute__ ((target (\"fpu=vfp\")))\n+void \n+foo (uint8x16_t *p)\n+{\n+  *p = vmovq_n_u8 (3); /* { dg-message \"called from here\" } */\n+}\n+\n+/* { dg-error \"inlining failed in call to always_inline\" \"\" { target *-*-* } 0 }\n+ */\n+"}, {"sha": "a29ea12c8e0ce08a02294d9c6cd9634fb3986adf", "filename": "gcc/testsuite/gcc.target/arm/attr-neon.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O2 -mfloat-abi=softfp -ftree-vectorize\" } */\n+\n+/* Verify that neon instructions are emitted once.  */\n+void __attribute__ ((target(\"fpu=neon\")))\n+ f1(int n, int x[], int y[]) {\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    y[i] = x[i] << 3;\n+}\n+\n+void __attribute__ ((target(\"fpu=vfp\")))\n+f3(int n, int x[], int y[]) {\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    y[i] = x[i] << 3;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\.fpu vfp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\.fpu neon\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vshl\" 1 } } */"}, {"sha": "819fad4ce621965a9595f8f32e4058ea0b70c861", "filename": "gcc/testsuite/gcc.target/arm/attr-neon2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr-neon2.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O2 -mfloat-abi=softfp -mfpu=vfp\" } */\n+\n+#pragma GCC target (\"fpu=neon\")\n+#include <arm_neon.h>\n+\n+/* Check that pragma target is used.  */\n+int8x8_t \n+my (int8x8_t __a, int8x8_t __b)\n+{\n+  return __a + __b;\n+}\n+\n+#pragma GCC reset_options\n+\n+/* Check that command line option is restored.  */\n+int8x8_t \n+my1 (int8x8_t __a, int8x8_t __b)\n+{\n+  return __a + __b;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\.fpu vfp\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\.fpu neon\" 1 } } */\n+/* { dg-final { scan-assembler \"vadd\" } } */\n+\n+"}, {"sha": "000fc2a31c9e095066507c7e455a28206dcc0fd5", "filename": "gcc/testsuite/gcc.target/arm/lto/pr65837_0.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Flto%2Fpr65837_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c91062822060a9cab744b3d10fda6456822740aa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Flto%2Fpr65837_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Flto%2Fpr65837_0.c?ref=c91062822060a9cab744b3d10fda6456822740aa", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {{-flto -mfpu=neon}} } */\n+/* { dg-suppress-ld-options {-mfpu=neon} } */\n+\n+#include \"arm_neon.h\"\n+\n+float32x2_t a, b, c, e;\n+\n+int main()\n+{\n+  e = __builtin_neon_vmls_lanev2sf (a, b, c, 0);\n+  return 0;\n+}\n+"}]}