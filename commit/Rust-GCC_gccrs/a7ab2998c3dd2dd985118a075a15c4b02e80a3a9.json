{"sha": "a7ab2998c3dd2dd985118a075a15c4b02e80a3a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhYjI5OThjM2RkMmRkOTg1MTE4YTA3NWExNWM0YjAyZTgwYTNhOQ==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2005-11-15T14:00:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T14:00:29Z"}, "message": "make.adb (Compile_Sources): Change verbose message to minimum verbosity level High for \"is in an Ada...\n\n2005-11-14  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Compile_Sources): Change verbose message to minimum\n\tverbosity level High for \"is in an Ada library\", \"is a read-only\n\tlibrary\" and \"is an internal library\",\n\t(Create_Binder_Mapping_File): Path name of ALI file for library project\n\tmust include the library directory, not the object directory.\n\t(Scan_Make_Arg): Make sure that Switch.M.Scan_Make_Switches is called\n\tfor new switches -vl, -vm and -vh.\n\t(Verbose_Msg): Add new defaulted parameter Minimum_Verbosity\n\t(Check): Use minimum verbosity Medium for some Verbose_Msg calls\n\t(Compile_Sources): Do not attempt to compile if an ALI file is missing\n\tin a project that is externally built.\n\t(Compute_All_Imported_Projects): New procedure\n\t(Gnatmake): Check if importing libraries should be regenerated because\n\tat least an imported library is more recent.\n\t(Initialize): For each project compute the list of the projects it\n\timports directly or indirectly.\n\t(Add_Library_Search_Dir): New procedure, used in place of\n\tAdd_Lib_Search_Dir in procedure Scan_Make_Arg so that absolute paths are\n\tput in the search paths.\n\t(Add_Source_Search_Dir): New procedure, used in place of\n\tAdd_Src_Search_Dir in procedure Scan_Make_Arg so that absolute paths are\n\tput in the search paths.\n\t(Mark_Directory): Resolve the absolute path the directory before marking\n\tit.\n\n\t* switch-m.adb (Scan_Make_Switches): Replace \"raise Bad_Switch;\" with\n\tcall to new procedure Bad_Switch. Call Scan_Pos with new parameter\n\tSwitch. Do not handle any exception.\n\t(Scan_Make_Switches): Increment Ptr for new switches -vl, -vm and -vh\n\tso that the switch is recognized as valid.\n\t(Scan_Make_Switches): Implement new switches -vl, -vm and -vh.\n\nFrom-SVN: r106989", "tree": {"sha": "b991c200952dacefbd1360221fcca048bf28f8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b991c200952dacefbd1360221fcca048bf28f8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dff0475fb55528621b7c9a2324d042df943ad803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff0475fb55528621b7c9a2324d042df943ad803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff0475fb55528621b7c9a2324d042df943ad803"}], "stats": {"total": 679, "additions": 501, "deletions": 178}, "files": [{"sha": "3204154947d8b76c16972bb812945d55b411819c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 474, "deletions": 157, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=a7ab2998c3dd2dd985118a075a15c4b02e80a3a9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -250,10 +250,9 @@ package body Make is\n      Table_Increment      => 100,\n      Table_Name           => \"Make.Library_Projs\");\n \n-   --  Two variables to keep the last binder and linker switch index\n-   --  in tables Binder_Switches and Linker_Switches, before adding\n-   --  switches from the project file (if any) and switches from the\n-   --  command line (if any).\n+   --  Two variables to keep the last binder and linker switch index in tables\n+   --  Binder_Switches and Linker_Switches, before adding switches from the\n+   --  project file (if any) and switches from the command line (if any).\n \n    Last_Binder_Switch : Integer := 0;\n    Last_Linker_Switch : Integer := 0;\n@@ -281,9 +280,9 @@ package body Make is\n    --  The project id of the main project file, if any\n \n    Project_Object_Directory : Project_Id := No_Project;\n-   --  The object directory of the project for the last compilation.\n-   --  Avoid calling Change_Dir if the current working directory is already\n-   --  this directory\n+   --  The object directory of the project for the last compilation. Avoid\n+   --  calling Change_Dir if the current working directory is already this\n+   --  directory\n \n    --  Packages of project files where unknown attributes are errors\n \n@@ -303,16 +302,30 @@ package body Make is\n    Packages_To_Check_By_Gnatmake : constant String_List_Access :=\n      Gnatmake_Packages'Access;\n \n+   procedure Add_Library_Search_Dir\n+     (Path            : String;\n+      On_Command_Line : Boolean);\n+   --  Call Add_Lib_Search_Dir with an absolute directory path. If Path is a\n+   --  relative path, when On_Command_Line is True, it is relative to the\n+   --  current working directory; when On_Command_Line is False, it is relative\n+   --  to the project directory of the main project.\n+\n+   procedure Add_Source_Search_Dir\n+     (Path            : String;\n+      On_Command_Line : Boolean);\n+   --  Call Add_Src_Search_Dir with an absolute directory path. If Path is a\n+   --  relative path, when On_Command_Line is True, it is relative to the\n+   --  current working directory; when On_Command_Line is False, it is relative\n+   --  to the project directory of the main project.\n+\n    procedure Add_Source_Dir (N : String);\n-   --  Call Add_Src_Search_Dir.\n-   --  Output one line when in verbose mode.\n+   --  Call Add_Src_Search_Dir (output one line when in verbose mode)\n \n    procedure Add_Source_Directories is\n      new Prj.Env.For_All_Source_Dirs (Action => Add_Source_Dir);\n \n    procedure Add_Object_Dir (N : String);\n-   --  Call Add_Lib_Search_Dir.\n-   --  Output one line when in verbose mode.\n+   --  Call Add_Lib_Search_Dir (output one line when in verbose mode)\n \n    procedure Add_Object_Directories is\n      new Prj.Env.For_All_Object_Dirs (Action => Add_Object_Dir);\n@@ -326,11 +339,10 @@ package body Make is\n       Unit  : Unit_Name_Type;\n       Found : Boolean;\n    end record;\n-   --  File is the name of the file for which a compilation failed.\n-   --  Unit is for gnatdist use in order to easily get the unit name\n-   --  of a file when its name is krunched or declared in gnat.adc.\n-   --  Found is False if the compilation failed because the file could\n-   --  not be found.\n+   --  File is the name of the file for which a compilation failed. Unit is for\n+   --  gnatdist use in order to easily get the unit name of a file when its\n+   --  name is krunched or declared in gnat.adc. Found is False if the\n+   --  compilation failed because the file could not be found.\n \n    package Bad_Compilation is new Table.Table (\n      Table_Component_Type => Bad_Compilation_Info,\n@@ -401,7 +413,7 @@ package body Make is\n    --  if an executable is up to date or not.\n \n    procedure Enter_Into_Obsoleted (F : Name_Id);\n-   --  Enter a file name, without directory information, into the has table\n+   --  Enter a file name, without directory information, into the hash table\n    --  Obsoleted.\n \n    function Is_In_Obsoleted (F : Name_Id) return Boolean;\n@@ -480,12 +492,14 @@ package body Make is\n    --  Prints out the list of all files for which the compilation failed\n \n    procedure Verbose_Msg\n-     (N1     : Name_Id;\n-      S1     : String;\n-      N2     : Name_Id := No_Name;\n-      S2     : String  := \"\";\n-      Prefix : String  := \"  -> \");\n-   --  If the verbose flag (Verbose_Mode) is set then print Prefix to standard\n+     (N1                : Name_Id;\n+      S1                : String;\n+      N2                : Name_Id := No_Name;\n+      S2                : String  := \"\";\n+      Prefix            : String  := \"  -> \";\n+      Minimum_Verbosity : Verbosity_Level_Type := Opt.Low);\n+   --  If the verbose flag (Verbose_Mode) is set and the verbosity level is\n+   --  at least equal to Minimum_Verbosity, then print Prefix to standard\n    --  output followed by N1 and S1. If N2 /= No_Name then N2 is printed after\n    --  S1. S2 is printed last. Both N1 and N2 are printed in quotation marks.\n \n@@ -504,6 +518,10 @@ package body Make is\n       Depth   : Natural);\n    --  Compute depth of Project and of the projects it depends on\n \n+   procedure Compute_All_Imported_Projects (Project : Project_Id);\n+   --  Compute, the list of the projects imported directly or indirectly by\n+   --  project Project.\n+\n    -----------------------\n    -- Gnatmake Routines --\n    -----------------------\n@@ -519,19 +537,18 @@ package body Make is\n    Ada_Lib_Dir : constant Lib_Mark_Type := 1;\n    --  Used to mark a directory as a GNAT lib dir\n \n-   --  Note that the notion of GNAT lib dir is no longer used. The code\n-   --  related to it has not been removed to give an idea on how to use\n-   --  the directory prefix marking mechanism.\n+   --  Note that the notion of GNAT lib dir is no longer used. The code related\n+   --  to it has not been removed to give an idea on how to use the directory\n+   --  prefix marking mechanism.\n \n-   --  An Ada library directory is a directory containing ali and object\n-   --  files but no source files for the bodies (the specs can be in the\n-   --  same or some other directory). These directories are specified\n-   --  in the Gnatmake command line with the switch \"-Adir\" (to specify the\n-   --  spec location -Idir cab be used).  Gnatmake skips the missing sources\n-   --  whose ali are in Ada library directories. For an explanation of why\n-   --  Gnatmake behaves that way, see the spec of Make.Compile_Sources.\n-   --  The directory lookup penalty is incurred every single time this\n-   --  routine is called.\n+   --  An Ada library directory is a directory containing ali and object files\n+   --  but no source files for the bodies (the specs can be in the same or some\n+   --  other directory). These directories are specified in the Gnatmake\n+   --  command line with the switch \"-Adir\" (to specify the spec location -Idir\n+   --  cab be used). Gnatmake skips the missing sources whose ali are in Ada\n+   --  library directories. For an explanation of why Gnatmake behaves that\n+   --  way, see the spec of Make.Compile_Sources. The directory lookup penalty\n+   --  is incurred every single time this routine is called.\n \n    procedure Check_Steps;\n    --  Check what steps (Compile, Bind, Link) must be executed.\n@@ -542,10 +559,15 @@ package body Make is\n    --  table for this directory. Then check if an Ada lib mark has been set.\n \n    procedure Mark_Directory\n-     (Dir  : String;\n-      Mark : Lib_Mark_Type);\n-   --  Store Dir in name table and set lib mark as name info to identify\n-   --  Ada libraries.\n+     (Dir             : String;\n+      Mark            : Lib_Mark_Type;\n+      On_Command_Line : Boolean);\n+   --  Store the absolute path from Dir in name table and set lib mark as name\n+   --  info to identify Ada libraries.\n+   --\n+   --  If Dir is a relative path, when On_Command_Line is True, it is relative\n+   --  to the current working directory; when On_Command_Line is False, it is\n+   --  relative to the project directory of the main project.\n \n    Output_Is_Object : Boolean := True;\n    --  Set to False when using a switch -S for the compiler\n@@ -561,12 +583,12 @@ package body Make is\n       Naming           : Naming_Data;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value;\n-   --  Return the switches for the source file in the specified package\n-   --  of a project file. If the Source_File ends with a standard GNAT\n-   --  extension (\".ads\" or \".adb\"), try first the full name, then the\n-   --  name without the extension, then, if Allow_ALI is True, the name with\n-   --  the extension \".ali\". If there is no switches for either names, try the\n-   --  default switches for Ada. If all failed, return No_Variable_Value.\n+   --  Return the switches for the source file in the specified package of a\n+   --  project file. If the Source_File ends with a standard GNAT extension\n+   --  (\".ads\" or \".adb\"), try first the full name, then the name without the\n+   --  extension, then, if Allow_ALI is True, the name with the extension\n+   --  \".ali\". If there is no switches for either names, try the default\n+   --  switches for Ada. If all failed, return No_Variable_Value.\n \n    function Is_In_Object_Directory\n      (Source_File   : File_Name_Type;\n@@ -785,6 +807,28 @@ package body Make is\n       Dependencies.Table (Dependencies.Last) := (S, On);\n    end Add_Dependency;\n \n+   ----------------------------\n+   -- Add_Library_Search_Dir --\n+   ----------------------------\n+\n+   procedure Add_Library_Search_Dir\n+     (Path            : String;\n+      On_Command_Line : Boolean)\n+   is\n+   begin\n+      if On_Command_Line then\n+         Add_Lib_Search_Dir\n+           (Normalize_Pathname (Path));\n+\n+      else\n+         Get_Name_String\n+           (Project_Tree.Projects.Table (Main_Project).Directory);\n+         Add_Lib_Search_Dir\n+           (Normalize_Pathname\n+              (Path, Name_Buffer (1 .. Name_Len)));\n+      end if;\n+   end Add_Library_Search_Dir;\n+\n    --------------------\n    -- Add_Object_Dir --\n    --------------------\n@@ -817,6 +861,28 @@ package body Make is\n       end if;\n    end Add_Source_Dir;\n \n+   ---------------------------\n+   -- Add_Source_Search_Dir --\n+   ---------------------------\n+\n+   procedure Add_Source_Search_Dir\n+     (Path            : String;\n+      On_Command_Line : Boolean)\n+   is\n+   begin\n+      if On_Command_Line then\n+         Add_Src_Search_Dir\n+           (Normalize_Pathname (Path));\n+\n+      else\n+         Get_Name_String\n+           (Project_Tree.Projects.Table (Main_Project).Directory);\n+         Add_Src_Search_Dir\n+           (Normalize_Pathname\n+              (Path, Name_Buffer (1 .. Name_Len)));\n+      end if;\n+   end Add_Source_Search_Dir;\n+\n    ----------------\n    -- Add_Switch --\n    ----------------\n@@ -838,7 +904,7 @@ package body Make is\n       -- Generic_Position --\n       ----------------------\n \n-      procedure  Generic_Position (New_Position : out Integer) is\n+      procedure Generic_Position (New_Position : out Integer) is\n       begin\n          T.Increment_Last;\n \n@@ -968,8 +1034,7 @@ package body Make is\n                   if Name_Len > 0 then\n                      declare\n                         Argv : constant String := Name_Buffer (1 .. Name_Len);\n-                        --  We need a copy, because Name_Buffer may be\n-                        --  modified.\n+                        --  We need a copy, because Name_Buffer may be modified\n \n                      begin\n                         if Verbose_Mode then\n@@ -1033,8 +1098,8 @@ package body Make is\n          Bind_Args (Args'Range) := Args;\n       end if;\n \n-      --  It is completely pointless to re-check source file time stamps.\n-      --  This has been done already by gnatmake\n+      --  It is completely pointless to re-check source file time stamps. This\n+      --  has been done already by gnatmake\n \n       Bind_Last := Bind_Last + 1;\n       Bind_Args (Bind_Last) := Do_Not_Check_Flag;\n@@ -1142,9 +1207,9 @@ package body Make is\n          Spec_File_Name : File_Name_Type := No_File;\n \n          function New_Spec (Uname : Unit_Name_Type) return Boolean;\n-         --  Uname is the name of the spec or body of some ada unit.\n-         --  This function returns True if the Uname is the name of a body\n-         --  which has a spec not mentioned inali file A. If True is returned\n+         --  Uname is the name of the spec or body of some ada unit. This\n+         --  function returns True if the Uname is the name of a body which has\n+         --  a spec not mentioned inali file A. If True is returned\n          --  Spec_File_Name above is set to the name of this spec file.\n \n          --------------\n@@ -1262,9 +1327,9 @@ package body Make is\n    begin\n       pragma Assert (Lib_File /= No_File);\n \n-      --  If the ALI file is read-only, set temporarily\n-      --  Check_Object_Consistency to False: we don't care if the object file\n-      --  is not there; presumably, a library will be used for linking.\n+      --  If ALI file is read-only, temporarily set Check_Object_Consistency to\n+      --  False. We don't care if the object file is not there (presumably a\n+      --  library will be used for linking.)\n \n       if Read_Only then\n          declare\n@@ -1286,9 +1351,17 @@ package body Make is\n       Obj_Stamp     := Current_Object_File_Stamp;\n \n       if Full_Lib_File = No_File then\n-         Verbose_Msg (Lib_File, \"being checked ...\", Prefix => \"  \");\n+         Verbose_Msg\n+           (Lib_File,\n+            \"being checked ...\",\n+            Prefix => \"  \",\n+            Minimum_Verbosity => Opt.Medium);\n       else\n-         Verbose_Msg (Full_Lib_File, \"being checked ...\", Prefix => \"  \");\n+         Verbose_Msg\n+           (Full_Lib_File,\n+            \"being checked ...\",\n+            Prefix => \"  \",\n+            Minimum_Verbosity => Opt.Medium);\n       end if;\n \n       ALI     := No_ALI_Id;\n@@ -1382,13 +1455,13 @@ package body Make is\n \n             for J in 1 .. Switches_To_Check.Last loop\n \n-               --  Comparing switches is delicate because gcc reorders\n-               --  a number of switches, according to lang-specs.h, but\n-               --  gnatmake doesn't have the sufficient knowledge to\n-               --  perform the same reordering. Instead, we ignore orders\n-               --  between different \"first letter\" switches, but keep\n-               --  orders between same switches, e.g -O -O2 is different\n-               --  than -O2 -O, but -g -O is equivalent to -O -g.\n+               --  Comparing switches is delicate because gcc reorders a number\n+               --  of switches, according to lang-specs.h, but gnatmake doesn't\n+               --  have the sufficient knowledge to perform the same\n+               --  reordering. Instead, we ignore orders between different\n+               --  \"first letter\" switches, but keep orders between same\n+               --  switches, e.g -O -O2 is different than -O2 -O, but -g -O is\n+               --  equivalent to -O -g.\n \n                if Switches_To_Check.Table (J) (2) /= Prev_Switch (2) or else\n                    (Prev_Switch'Length >= 6 and then\n@@ -1561,7 +1634,7 @@ package body Make is\n             Name_Len := Name_Len - 1;\n          end loop;\n \n-         if Name_Len <= 0 then\n+         if Name_Len = 0 then\n             return;\n \n          elsif Name_Buffer (1) = '-' then\n@@ -2687,7 +2760,10 @@ package body Make is\n                  and then In_Ada_Lib_Dir (Full_Lib_File)\n                then\n                   Verbose_Msg\n-                    (Lib_File, \"is in an Ada library\", Prefix => \"  \");\n+                    (Lib_File,\n+                     \"is in an Ada library\",\n+                     Prefix => \"  \",\n+                     Minimum_Verbosity => Opt.High);\n \n                   --  If the library file is a read-only library skip it, but\n                   --  only if, when using project files, this library file is\n@@ -2701,7 +2777,10 @@ package body Make is\n                  and then Is_In_Object_Directory (Source_File, Full_Lib_File)\n                then\n                   Verbose_Msg\n-                    (Lib_File, \"is a read-only library\", Prefix => \"  \");\n+                    (Lib_File,\n+                     \"is a read-only library\",\n+                     Prefix => \"  \",\n+                     Minimum_Verbosity => Opt.High);\n \n                   --  The source file that we are checking cannot be located\n \n@@ -2724,7 +2803,10 @@ package body Make is\n                   end if;\n \n                   Verbose_Msg\n-                    (Lib_File, \"is an internal library\", Prefix => \"  \");\n+                    (Lib_File,\n+                     \"is an internal library\",\n+                     Prefix => \"  \",\n+                     Minimum_Verbosity => Opt.High);\n \n                --  The source file that we are checking can be located\n \n@@ -2764,52 +2846,65 @@ package body Make is\n                      end if;\n \n                   else\n-                     --  Is this the first file we have to compile?\n+                     --  Do nothing if project of source is externally built\n \n-                     if First_Compiled_File = No_File then\n-                        First_Compiled_File  := Full_Source_File;\n-                        Most_Recent_Obj_File := No_File;\n+                     if not Arguments_Collected then\n+                        Collect_Arguments (Source_File, Source_Index, Args);\n+                     end if;\n \n-                        if Do_Not_Execute then\n-                           exit Make_Loop;\n+                     if Arguments_Project = No_Project\n+                       or else not Project_Tree.Projects.Table\n+                                     (Arguments_Project).Externally_Built\n+                     then\n+                        --  Is this the first file we have to compile?\n+\n+                        if First_Compiled_File = No_File then\n+                           First_Compiled_File  := Full_Source_File;\n+                           Most_Recent_Obj_File := No_File;\n+\n+                           if Do_Not_Execute then\n+                              exit Make_Loop;\n+                           end if;\n                         end if;\n-                     end if;\n \n-                     if In_Place_Mode then\n+                        if In_Place_Mode then\n \n-                        --  If the library file was not found, then save the\n-                        --  library file near the source file.\n+                           --  If the library file was not found, then save\n+                           --  the library file near the source file.\n \n-                        if Full_Lib_File = No_File then\n-                           Lib_File := Osint.Lib_File_Name\n-                             (Full_Source_File, Source_Index);\n+                           if Full_Lib_File = No_File then\n+                              Lib_File := Osint.Lib_File_Name\n+                                (Full_Source_File, Source_Index);\n \n-                           --  If the library file was found, then save the\n-                           --  library file in the same place.\n+                              --  If the library file was found, then save the\n+                              --  library file in the same place.\n \n-                        else\n-                           Lib_File := Full_Lib_File;\n-                        end if;\n+                           else\n+                              Lib_File := Full_Lib_File;\n+                           end if;\n \n-                     end if;\n+                        end if;\n \n-                     --  Start the compilation and record it. We can do this\n-                     --  because there is at least one free process.\n+                        --  Start the compilation and record it. We can do\n+                        --  this because there is at least one free process.\n \n-                     Collect_Arguments_And_Compile (Source_File, Source_Index);\n+                        Collect_Arguments_And_Compile\n+                          (Source_File, Source_Index);\n \n-                     --  Make sure we could successfully start the compilation\n+                        --  Make sure we could successfully start\n+                        --  the Compilation.\n \n-                     if Process_Created then\n-                        if Pid = Invalid_Pid then\n-                           Record_Failure (Full_Source_File, Source_Unit);\n-                        else\n-                           Add_Process\n-                             (Pid,\n-                              Full_Source_File,\n-                              Lib_File,\n-                              Source_Unit,\n-                              Mfile);\n+                        if Process_Created then\n+                           if Pid = Invalid_Pid then\n+                              Record_Failure (Full_Source_File, Source_Unit);\n+                           else\n+                              Add_Process\n+                                (Pid,\n+                                 Full_Source_File,\n+                                 Lib_File,\n+                                 Source_Unit,\n+                                 Mfile);\n+                           end if;\n                         end if;\n                      end if;\n                   end if;\n@@ -3007,6 +3102,95 @@ package body Make is\n \n    end Compile_Sources;\n \n+   -----------------------------------\n+   -- Compute_All_Imported_Projects --\n+   -----------------------------------\n+\n+   procedure Compute_All_Imported_Projects (Project : Project_Id) is\n+      procedure Add_To_List (Prj : Project_Id);\n+      --  Add a project to the list All_Imported_Projects of project Project\n+\n+      procedure Recursive_Add_Imported (Project : Project_Id);\n+      --  Recursively add the projects imported by project Project, but not\n+      --  those that are extended.\n+\n+      -----------------\n+      -- Add_To_List --\n+      -----------------\n+\n+      procedure Add_To_List (Prj : Project_Id) is\n+         Element : constant Project_Element :=\n+           (Prj, Project_Tree.Projects.Table (Project).All_Imported_Projects);\n+         List : Project_List;\n+      begin\n+         Project_List_Table.Increment_Last (Project_Tree.Project_Lists);\n+         List := Project_List_Table.Last (Project_Tree.Project_Lists);\n+         Project_Tree.Project_Lists.Table (List) := Element;\n+         Project_Tree.Projects.Table (Project).All_Imported_Projects := List;\n+      end Add_To_List;\n+\n+      ----------------------------\n+      -- Recursive_Add_Imported --\n+      ----------------------------\n+\n+      procedure Recursive_Add_Imported (Project : Project_Id) is\n+         List    : Project_List;\n+         Element : Project_Element;\n+         Prj     : Project_Id;\n+\n+      begin\n+         if Project /= No_Project then\n+\n+            --  For all the imported projects\n+\n+            List := Project_Tree.Projects.Table (Project).Imported_Projects;\n+            while List /= Empty_Project_List loop\n+               Element := Project_Tree.Project_Lists.Table (List);\n+               Prj := Element.Project;\n+\n+               --  Get the ultimate extending project\n+\n+               while\n+                 Project_Tree.Projects.Table (Prj).Extended_By /= No_Project\n+               loop\n+                  Prj := Project_Tree.Projects.Table (Prj).Extended_By;\n+               end loop;\n+\n+               --  If project has not yet been visited, add to list and recurse\n+\n+               if not Project_Tree.Projects.Table (Prj).Seen then\n+                  Project_Tree.Projects.Table (Prj).Seen := True;\n+                  Add_To_List (Prj);\n+                  Recursive_Add_Imported (Prj);\n+               end if;\n+\n+               List := Element.Next;\n+            end loop;\n+\n+            --  Recurse on projects being imported, if any\n+\n+            Recursive_Add_Imported\n+              (Project_Tree.Projects.Table (Project).Extends);\n+         end if;\n+      end Recursive_Add_Imported;\n+\n+   begin\n+      --  Reset the Seen flag for all projects\n+\n+      for Index in 1 .. Project_Table.Last (Project_Tree.Projects) loop\n+         Project_Tree.Projects.Table (Index).Seen := False;\n+      end loop;\n+\n+      --  Make sure the list is empty\n+\n+      Project_Tree.Projects.Table (Project).All_Imported_Projects :=\n+        Empty_Project_List;\n+\n+      --  Add to the list all projects imported directly or indirectly\n+\n+      Recursive_Add_Imported (Project);\n+   end Compute_All_Imported_Projects;\n+\n    ----------------------------------\n    -- Configuration_Pragmas_Switch --\n    ----------------------------------\n@@ -3757,17 +3941,25 @@ package body Make is\n \n                         exit when not OK;\n \n-                        --  Third line it the ALI path name,\n-                        --  concatenation of the project\n+                        --  Third line it the ALI path name, concatenation\n+                        --  of either the library directory or the object\n                         --  directory with the ALI file name.\n \n                         declare\n                            ALI : constant String :=\n                                    Get_Name_String (ALI_Name);\n+                           PD  : Project_Data renames\n+                                   Project_Tree.Projects.Table (ALI_Project);\n+\n                         begin\n-                           Get_Name_String\n-                             (Project_Tree.Projects.Table\n-                                (ALI_Project).Object_Directory);\n+                           --  For library projects, use the library directory,\n+                           --  for other projects, use the object directory.\n+\n+                           if PD.Library then\n+                              Get_Name_String (PD.Library_Dir);\n+                           else\n+                              Get_Name_String (PD.Object_Directory);\n+                           end if;\n \n                            if Name_Buffer (Name_Len) /=\n                              Directory_Separator\n@@ -4797,17 +4989,51 @@ package body Make is\n \n                if Main_Project /= No_Project\n                  and then MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None\n-                 and then (Do_Bind_Step or Unique_Compile_All_Projects\n-                           or not Compile_Only)\n+                 and then (Do_Bind_Step\n+                             or Unique_Compile_All_Projects\n+                             or not Compile_Only)\n                  and then (Do_Link_Step or N_File = Osint.Number_Of_Files)\n                then\n                   Library_Projs.Init;\n \n                   declare\n-                     Proj2   : Project_Id;\n                      Depth   : Natural;\n                      Current : Natural;\n \n+                     procedure Add_To_Library_Projs (Proj : Project_Id);\n+                     --  Add project Project to table Library_Projs\n+                     --  in decreasing depth order.\n+\n+                     --------------------------\n+                     -- Add_To_Library_Projs --\n+                     --------------------------\n+\n+                     procedure Add_To_Library_Projs (Proj : Project_Id) is\n+                        Prj   : Project_Id;\n+\n+                     begin\n+                        Library_Projs.Increment_Last;\n+                        Depth := Project_Tree.Projects.Table (Proj).Depth;\n+\n+                        --  Put the projects in decreasing depth order,\n+                        --  so that if libA depends on libB, libB is first\n+                        --  in order.\n+\n+                        Current := Library_Projs.Last;\n+                        while Current > 1 loop\n+                           Prj := Library_Projs.Table (Current - 1);\n+                           exit when Project_Tree.Projects.Table\n+                             (Prj).Depth >= Depth;\n+                           Library_Projs.Table (Current) := Prj;\n+                           Current := Current - 1;\n+                        end loop;\n+\n+                        Library_Projs.Table (Current) := Proj;\n+                     end Add_To_Library_Projs;\n+\n+                  --  Start of processing for ??? (should name declare block\n+                  --  or probably better, break this out as a nested proc.\n+\n                   begin\n                      --  Put in Library_Projs table all library project\n                      --  file ids when the library need to be rebuilt.\n@@ -4821,40 +5047,84 @@ package body Make is\n                            There_Are_Stand_Alone_Libraries := True;\n                         end if;\n \n-                        if Project_Tree.Projects.Table (Proj1).Library\n-                          and then not Project_Tree.Projects.Table\n-                                         (Proj1).Need_To_Build_Lib\n-                          and then not Project_Tree.Projects.Table\n-                                         (Proj1).Externally_Built\n-                        then\n+                        if Project_Tree.Projects.Table (Proj1).Library then\n                            MLib.Prj.Check_Library (Proj1, Project_Tree);\n                         end if;\n \n                         if Project_Tree.Projects.Table\n                              (Proj1).Need_To_Build_Lib\n                         then\n-                           Library_Projs.Increment_Last;\n-                           Current := Library_Projs.Last;\n-                           Depth := Project_Tree.Projects.Table\n-                                      (Proj1).Depth;\n+                           Add_To_Library_Projs (Proj1);\n+                        end if;\n+                     end loop;\n \n-                           --  Put the projects in decreasing depth order,\n-                           --  so that if libA depends on libB, libB is first\n-                           --  in order.\n+                     --  Check if importing libraries should be regenerated\n+                     --  because at least an imported library will be\n+                     --  regenerated or is more recent.\n \n-                           while Current > 1 loop\n-                              Proj2 := Library_Projs.Table (Current - 1);\n-                              exit when Project_Tree.Projects.Table\n-                                          (Proj2).Depth >= Depth;\n-                              Library_Projs.Table (Current) := Proj2;\n-                              Current := Current - 1;\n-                           end loop;\n-\n-                           Library_Projs.Table (Current) := Proj1;\n-                           Project_Tree.Projects.Table\n-                             (Proj1).Need_To_Build_Lib := False;\n+                     for Proj1 in Project_Table.First ..\n+                                  Project_Table.Last (Project_Tree.Projects)\n+                     loop\n+                        if Project_Tree.Projects.Table (Proj1).Library\n+                          and then not Project_Tree.Projects.Table\n+                            (Proj1).Need_To_Build_Lib\n+                          and then not Project_Tree.Projects.Table\n+                            (Proj1).Externally_Built\n+                        then\n+                           declare\n+                              List    : Project_List;\n+                              Element : Project_Element;\n+                              Proj2   : Project_Id;\n+                              Rebuild : Boolean := False;\n+\n+                              Lib_Timestamp1 : constant Time_Stamp_Type :=\n+                                                 Project_Tree.Projects.Table\n+                                                   (Proj1). Library_TS;\n+\n+                           begin\n+                              List := Project_Tree.Projects.Table (Proj1).\n+                                                      All_Imported_Projects;\n+                              while List /= Empty_Project_List loop\n+                                 Element :=\n+                                   Project_Tree.Project_Lists.Table (List);\n+                                 Proj2 := Element.Project;\n+\n+                                 if\n+                                   Project_Tree.Projects.Table (Proj2).Library\n+                                 then\n+                                    if Project_Tree.Projects.Table (Proj2).\n+                                          Need_To_Build_Lib\n+                                      or else\n+                                        (Lib_Timestamp1 <\n+                                             Project_Tree.Projects.Table\n+                                               (Proj2).Library_TS)\n+                                    then\n+                                       Rebuild := True;\n+                                       exit;\n+                                    end if;\n+                                 end if;\n+\n+                                 List := Element.Next;\n+                              end loop;\n+\n+                              if Rebuild then\n+                                 Project_Tree.Projects.Table\n+                                   (Proj1).Need_To_Build_Lib := True;\n+                                 Add_To_Library_Projs (Proj1);\n+                              end if;\n+                           end;\n                         end if;\n                      end loop;\n+\n+                     --  Reset the flags Need_To_Build_Lib for the next main,\n+                     --  to avoid rebuilding libraries uselessly.\n+\n+                     for Proj1 in Project_Table.First ..\n+                                  Project_Table.Last (Project_Tree.Projects)\n+                     loop\n+                        Project_Tree.Projects.Table\n+                          (Proj1).Need_To_Build_Lib := False;\n+                     end loop;\n                   end;\n \n                   --  Build the libraries, if any need to be built\n@@ -5909,6 +6179,15 @@ package body Make is\n          Recursive_Compute_Depth\n            (Main_Project, Depth => 1);\n \n+         --  For each project compute the list of the projects it imports\n+         --  directly or indirectly.\n+\n+         for Proj in Project_Table.First ..\n+                     Project_Table.Last (Project_Tree.Projects)\n+         loop\n+            Compute_All_Imported_Projects (Proj);\n+         end loop;\n+\n       else\n \n          Osint.Add_Default_Search_Dirs;\n@@ -6389,17 +6668,51 @@ package body Make is\n    --------------------\n \n    procedure Mark_Directory\n-     (Dir  : String;\n-      Mark : Lib_Mark_Type)\n+     (Dir             : String;\n+      Mark            : Lib_Mark_Type;\n+      On_Command_Line : Boolean)\n    is\n       N : Name_Id;\n       B : Byte;\n \n    begin\n-      --  Dir last character is supposed to be a directory separator\n+      if On_Command_Line then\n+         declare\n+            Real_Path : constant String :=\n+              Normalize_Pathname (Dir);\n+\n+         begin\n+            if Real_Path'Length = 0 then\n+               Name_Len := Dir'Length;\n+               Name_Buffer (1 .. Name_Len) := Dir;\n+\n+            else\n+               Name_Len := Real_Path'Length;\n+               Name_Buffer (1 .. Name_Len) := Real_Path;\n+            end if;\n+         end;\n+\n+      else\n+         declare\n+            Real_Path : constant String :=\n+              Normalize_Pathname\n+                (Dir,\n+                 Get_Name_String\n+                   (Project_Tree.Projects.Table (Main_Project).Directory));\n+\n+         begin\n+            if Real_Path'Length = 0 then\n+               Name_Len := Dir'Length;\n+               Name_Buffer (1 .. Name_Len) := Dir;\n+\n+            else\n+               Name_Len := Real_Path'Length;\n+               Name_Buffer (1 .. Name_Len) := Real_Path;\n+            end if;\n+         end;\n+      end if;\n \n-      Name_Len := Dir'Length;\n-      Name_Buffer (1 .. Name_Len) := Dir;\n+      --  Last character is supposed to be a directory separator\n \n       if not Is_Directory_Separator (Name_Buffer (Name_Len)) then\n          Name_Len := Name_Len + 1;\n@@ -6623,11 +6936,11 @@ package body Make is\n \n             elsif Program_Args = Compiler then\n                if Argv (3 .. Argv'Last) /= \"-\" then\n-                  Add_Src_Search_Dir (Argv (3 .. Argv'Last));\n+                  Add_Source_Search_Dir (Argv (3 .. Argv'Last), And_Save);\n                end if;\n \n             elsif Program_Args = Binder then\n-               Add_Lib_Search_Dir (Argv (3 .. Argv'Last));\n+               Add_Library_Search_Dir (Argv (3 .. Argv'Last), And_Save);\n             end if;\n          end if;\n \n@@ -6787,15 +7100,15 @@ package body Make is\n          --  -Idir\n \n          elsif Argv (2) = 'I' then\n-            Add_Src_Search_Dir (Argv (3 .. Argv'Last));\n-            Add_Lib_Search_Dir (Argv (3 .. Argv'Last));\n+            Add_Source_Search_Dir (Argv (3 .. Argv'Last), And_Save);\n+            Add_Library_Search_Dir (Argv (3 .. Argv'Last), And_Save);\n             Add_Switch (Argv, Compiler, And_Save => And_Save);\n             Add_Switch (Argv, Binder, And_Save => And_Save);\n \n          --  -aIdir (to gcc this is like a -I switch)\n \n          elsif Argv'Length >= 3 and then Argv (2 .. 3) = \"aI\" then\n-            Add_Src_Search_Dir (Argv (4 .. Argv'Last));\n+            Add_Source_Search_Dir (Argv (4 .. Argv'Last), And_Save);\n             Add_Switch (\"-I\" & Argv (4 .. Argv'Last),\n                         Compiler,\n                         And_Save => And_Save);\n@@ -6804,24 +7117,24 @@ package body Make is\n          --  -aOdir\n \n          elsif Argv'Length >= 3 and then Argv (2 .. 3) = \"aO\" then\n-            Add_Lib_Search_Dir (Argv (4 .. Argv'Last));\n+            Add_Library_Search_Dir (Argv (4 .. Argv'Last), And_Save);\n             Add_Switch (Argv, Binder, And_Save => And_Save);\n \n          --  -aLdir (to gnatbind this is like a -aO switch)\n \n          elsif Argv'Length >= 3 and then Argv (2 .. 3) = \"aL\" then\n-            Mark_Directory (Argv (4 .. Argv'Last), Ada_Lib_Dir);\n-            Add_Lib_Search_Dir (Argv (4 .. Argv'Last));\n+            Mark_Directory (Argv (4 .. Argv'Last), Ada_Lib_Dir, And_Save);\n+            Add_Library_Search_Dir (Argv (4 .. Argv'Last), And_Save);\n             Add_Switch (\"-aO\" & Argv (4 .. Argv'Last),\n                         Binder,\n                         And_Save => And_Save);\n \n          --  -Adir (to gnatbind this is like a -aO switch, to gcc like a -I)\n \n          elsif Argv (2) = 'A' then\n-            Mark_Directory (Argv (3 .. Argv'Last), Ada_Lib_Dir);\n-            Add_Src_Search_Dir (Argv (3 .. Argv'Last));\n-            Add_Lib_Search_Dir (Argv (3 .. Argv'Last));\n+            Mark_Directory (Argv (3 .. Argv'Last), Ada_Lib_Dir, And_Save);\n+            Add_Source_Search_Dir (Argv (3 .. Argv'Last), And_Save);\n+            Add_Library_Search_Dir (Argv (3 .. Argv'Last), And_Save);\n             Add_Switch (\"-I\"  & Argv (3 .. Argv'Last),\n                         Compiler,\n                         And_Save => And_Save);\n@@ -7041,6 +7354,9 @@ package body Make is\n            and then Argv (2 .. Argv'Last) /= \"F\"\n            and then Argv (2 .. Argv'Last) /= \"M\"\n            and then Argv (2 .. Argv'Last) /= \"B\"\n+           and then Argv (2 .. Argv'Last) /= \"vl\"\n+           and then Argv (2 .. Argv'Last) /= \"vm\"\n+           and then Argv (2 .. Argv'Last) /= \"vh\"\n            and then (Argv'Length > 2 or else Argv (2) not in 'a' .. 'z')\n          then\n             Add_Switch (Argv, Compiler, And_Save => And_Save);\n@@ -7189,14 +7505,15 @@ package body Make is\n    -----------------\n \n    procedure Verbose_Msg\n-     (N1     : Name_Id;\n-      S1     : String;\n-      N2     : Name_Id := No_Name;\n-      S2     : String  := \"\";\n-      Prefix : String := \"  -> \")\n+     (N1                : Name_Id;\n+      S1                : String;\n+      N2                : Name_Id := No_Name;\n+      S2                : String  := \"\";\n+      Prefix            : String := \"  -> \";\n+      Minimum_Verbosity : Verbosity_Level_Type := Opt.Low)\n    is\n    begin\n-      if not Verbose_Mode then\n+      if (not Verbose_Mode) or else (Minimum_Verbosity > Verbosity_Level) then\n          return;\n       end if;\n "}, {"sha": "bad932a01a68242f491ce50e2963eea4acb26dfc", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7ab2998c3dd2dd985118a075a15c4b02e80a3a9/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=a7ab2998c3dd2dd985118a075a15c4b02e80a3a9", "patch": "@@ -491,7 +491,7 @@ package body Switch.M is\n       --  Skip past the initial character (must be the switch character)\n \n       if Ptr = Max then\n-         raise Bad_Switch;\n+         Bad_Switch (C);\n \n       else\n          Ptr := Ptr + 1;\n@@ -581,7 +581,7 @@ package body Switch.M is\n                then\n                   Set_Debug_Flag (C);\n                else\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n                end if;\n             end loop;\n \n@@ -593,7 +593,7 @@ package body Switch.M is\n             Ptr := Ptr + 1;\n \n             if Ptr > Max then\n-               raise Bad_Switch;\n+               Bad_Switch (C);\n             end if;\n \n             case Switch_Chars (Ptr) is\n@@ -602,7 +602,7 @@ package body Switch.M is\n \n                when 'I' =>\n                   Ptr := Ptr + 1;\n-                  Scan_Pos (Switch_Chars, Max, Ptr, Main_Index);\n+                  Scan_Pos (Switch_Chars, Max, Ptr, Main_Index, C);\n \n                --  processing for eL switch\n \n@@ -611,7 +611,7 @@ package body Switch.M is\n                   Follow_Links := True;\n \n                when others =>\n-                  raise Bad_Switch;\n+                  Bad_Switch (C);\n             end case;\n \n          --  Processing for f switch\n@@ -646,7 +646,7 @@ package body Switch.M is\n             declare\n                Max_Proc : Pos;\n             begin\n-               Scan_Pos (Switch_Chars, Max, Ptr, Max_Proc);\n+               Scan_Pos (Switch_Chars, Max, Ptr, Max_Proc, C);\n                Maximum_Processes := Positive (Max_Proc);\n             end;\n \n@@ -679,7 +679,7 @@ package body Switch.M is\n             Ptr := Ptr + 1;\n \n             if Output_File_Name_Present then\n-               raise Too_Many_Output_Files;\n+               Osint.Fail (\"duplicate -o switch\");\n             else\n                Output_File_Name_Present := True;\n             end if;\n@@ -707,6 +707,25 @@ package body Switch.M is\n          when 'v' =>\n             Ptr := Ptr + 1;\n             Verbose_Mode := True;\n+            Verbosity_Level := Opt.High;\n+\n+            if Ptr <= Max then\n+               case Switch_Chars (Ptr) is\n+                  when 'l' =>\n+                     Verbosity_Level := Opt.Low;\n+\n+                  when 'm' =>\n+                     Verbosity_Level := Opt.Medium;\n+\n+                  when 'h' =>\n+                     Verbosity_Level := Opt.High;\n+\n+                  when others =>\n+                     Osint.Fail (\"invalid switch: \", Switch_Chars);\n+               end case;\n+\n+               Ptr := Ptr + 1;\n+            end if;\n \n          --  Processing for x switch\n \n@@ -728,7 +747,7 @@ package body Switch.M is\n          --  Anything else is an error (illegal switch character)\n \n          when others =>\n-            raise Bad_Switch;\n+            Bad_Switch (C);\n \n          end case;\n \n@@ -738,19 +757,6 @@ package body Switch.M is\n \n       end Check_Switch;\n \n-   exception\n-      when Bad_Switch =>\n-         Osint.Fail (\"invalid switch: \", (1 => C));\n-\n-      when Bad_Switch_Value =>\n-         Osint.Fail (\"numeric value out of range for switch: \", (1 => C));\n-\n-      when Missing_Switch_Value =>\n-         Osint.Fail (\"missing numeric value for switch: \", (1 => C));\n-\n-      when Too_Many_Output_Files =>\n-         Osint.Fail (\"duplicate -o switch\");\n-\n    end Scan_Make_Switches;\n \n end Switch.M;"}]}