{"sha": "5609420fbab5ca93d18219b94eda95779bd75bb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYwOTQyMGZiYWI1Y2E5M2QxODIxOWI5NGVkYTk1Nzc5YmQ3NWJiMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-06T09:07:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-06T09:07:39Z"}, "message": "match.pd: Implement bitwise binary and unary simplifications from tree-ssa-forwprop.c.\n\n2014-11-06  Richard Biener  <rguenther@suse.de>\n\n\t* match.pd: Implement bitwise binary and unary simplifications\n\tfrom tree-ssa-forwprop.c.\n\t* fold-const.c (fold_unary_loc): Remove them here.\n\t(fold_binary_loc): Likewise.\n\t* tree-ssa-forwprop.c (simplify_not_neg_expr): Remove.\n\t(truth_valued_ssa_name): Likewise.\n\t(lookup_logical_inverted_value): Likewise.\n\t(simplify_bitwise_binary_1): Likewise.\n\t(hoist_conversion_for_bitop_p): Likewise.\n\t(simplify_bitwise_binary_boolean): Likewise.\n\t(simplify_bitwise_binary): Likewise.\n\t(pass_forwprop::execute): Remove calls to simplify_not_neg_expr\n\tand simplify_bitwise_binary.\n\t* genmatch.c (dt_node::append_true_op): Use safe_as_a for parent.\n\t(decision_tree::insert): Also insert non-expressions.\n\n\t* gcc.dg/tree-ssa/forwprop-28.c: Adjust scanning for the\n\tdesired transform.\n\nFrom-SVN: r217178", "tree": {"sha": "e8f63a58ac6d127bfe10b0ea17550a63bc530c20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8f63a58ac6d127bfe10b0ea17550a63bc530c20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5609420fbab5ca93d18219b94eda95779bd75bb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5609420fbab5ca93d18219b94eda95779bd75bb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5609420fbab5ca93d18219b94eda95779bd75bb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5609420fbab5ca93d18219b94eda95779bd75bb2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45ea41fe8a833e4605ce0a1af794530030d483e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ea41fe8a833e4605ce0a1af794530030d483e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ea41fe8a833e4605ce0a1af794530030d483e4"}], "stats": {"total": 740, "additions": 156, "deletions": 584}, "files": [{"sha": "1776df3065f2b62d950501780c1f75d765b5f925", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -1,3 +1,21 @@\n+2014-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* match.pd: Implement bitwise binary and unary simplifications\n+\tfrom tree-ssa-forwprop.c.\n+\t* fold-const.c (fold_unary_loc): Remove them here.\n+\t(fold_binary_loc): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_not_neg_expr): Remove.\n+\t(truth_valued_ssa_name): Likewise.\n+\t(lookup_logical_inverted_value): Likewise.\n+\t(simplify_bitwise_binary_1): Likewise.\n+\t(hoist_conversion_for_bitop_p): Likewise.\n+\t(simplify_bitwise_binary_boolean): Likewise.\n+\t(simplify_bitwise_binary): Likewise.\n+\t(pass_forwprop::execute): Remove calls to simplify_not_neg_expr\n+\tand simplify_bitwise_binary.\n+\t* genmatch.c (dt_node::append_true_op): Use safe_as_a for parent.\n+\t(decision_tree::insert): Also insert non-expressions.\n+\n 2014-11-06  Hale Wang  <Hale.Wang@arm.com>\n \n \t* config/arm/arm-cores.def: Add support for"}, {"sha": "e3bb70643d5e66fa6b8a7a2469134a9193073aa5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -8008,8 +8008,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n     case BIT_NOT_EXPR:\n       if (TREE_CODE (arg0) == INTEGER_CST)\n         return fold_not_const (arg0, type);\n-      else if (TREE_CODE (arg0) == BIT_NOT_EXPR)\n-\treturn fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n       /* Convert ~ (-A) to A - 1.  */\n       else if (INTEGRAL_TYPE_P (type) && TREE_CODE (arg0) == NEGATE_EXPR)\n \treturn fold_build2_loc (loc, MINUS_EXPR, type,\n@@ -11152,26 +11150,6 @@ fold_binary_loc (location_t loc,\n \t\t\t\t    arg1);\n \t}\n \n-      /* (X & Y) | Y is (X, Y).  */\n-      if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn omit_one_operand_loc (loc, type, arg1, TREE_OPERAND (arg0, 0));\n-      /* (X & Y) | X is (Y, X).  */\n-      if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n-\t  && reorder_operands_p (TREE_OPERAND (arg0, 1), arg1))\n-\treturn omit_one_operand_loc (loc, type, arg1, TREE_OPERAND (arg0, 1));\n-      /* X | (X & Y) is (Y, X).  */\n-      if (TREE_CODE (arg1) == BIT_AND_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0)\n-\t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 1)))\n-\treturn omit_one_operand_loc (loc, type, arg0, TREE_OPERAND (arg1, 1));\n-      /* X | (Y & X) is (Y, X).  */\n-      if (TREE_CODE (arg1) == BIT_AND_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 1), 0)\n-\t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 0)))\n-\treturn omit_one_operand_loc (loc, type, arg0, TREE_OPERAND (arg1, 0));\n-\n       /* (X & ~Y) | (~X & Y) is X ^ Y */\n       if (TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && TREE_CODE (arg1) == BIT_AND_EXPR)\n@@ -11391,42 +11369,6 @@ fold_binary_loc (location_t loc,\n \t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n \n-      /* Canonicalize (X | C1) & C2 as (X & C2) | (C1 & C2).  */\n-      if (TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree tmp1 = fold_convert_loc (loc, type, arg1);\n-\t  tree tmp2 = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n-\t  tree tmp3 = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 1));\n-\t  tmp2 = fold_build2_loc (loc, BIT_AND_EXPR, type, tmp2, tmp1);\n-\t  tmp3 = fold_build2_loc (loc, BIT_AND_EXPR, type, tmp3, tmp1);\n-\t  return\n-\t    fold_convert_loc (loc, type,\n-\t\t\t      fold_build2_loc (loc, BIT_IOR_EXPR,\n-\t\t\t\t\t   type, tmp2, tmp3));\n-\t}\n-\n-      /* (X | Y) & Y is (X, Y).  */\n-      if (TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn omit_one_operand_loc (loc, type, arg1, TREE_OPERAND (arg0, 0));\n-      /* (X | Y) & X is (Y, X).  */\n-      if (TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n-\t  && reorder_operands_p (TREE_OPERAND (arg0, 1), arg1))\n-\treturn omit_one_operand_loc (loc, type, arg1, TREE_OPERAND (arg0, 1));\n-      /* X & (X | Y) is (Y, X).  */\n-      if (TREE_CODE (arg1) == BIT_IOR_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0)\n-\t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 1)))\n-\treturn omit_one_operand_loc (loc, type, arg0, TREE_OPERAND (arg1, 1));\n-      /* X & (Y | X) is (Y, X).  */\n-      if (TREE_CODE (arg1) == BIT_IOR_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 1), 0)\n-\t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 0)))\n-\treturn omit_one_operand_loc (loc, type, arg0, TREE_OPERAND (arg1, 0));\n-\n       /* Fold (X ^ 1) & 1 as (X & 1) == 0.  */\n       if (TREE_CODE (arg0) == BIT_XOR_EXPR\n \t  && INTEGRAL_TYPE_P (type)"}, {"sha": "e01f7b31e529578335dbc81d917013a25c5e313f", "filename": "gcc/genmatch.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -1126,7 +1126,7 @@ dt_node::append_op (operand *op, dt_node *parent, unsigned pos)\n dt_node *\n dt_node::append_true_op (dt_node *parent, unsigned pos)\n {\n-  dt_operand *parent_ = as_a<dt_operand *> (parent);\n+  dt_operand *parent_ = safe_as_a<dt_operand *> (parent);\n   dt_operand *n = new dt_operand (DT_TRUE, 0, 0, parent_, pos);\n   return append_node (n);\n }\n@@ -1232,9 +1232,6 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n void\n decision_tree::insert (struct simplify *s, unsigned pattern_no)\n {\n-  if (s->match->type != operand::OP_EXPR)\n-    return;\n-\n   dt_operand **indexes = XCNEWVEC (dt_operand *, s->capture_max + 1);\n   dt_node *p = decision_tree::insert_operand (root, s->match, indexes);\n   p->append_simplify (s, pattern_no, indexes);"}, {"sha": "0c7ef5609bf40458f76d538369984b40341a4602", "filename": "gcc/match.pd", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -113,6 +113,134 @@ along with GCC; see the file COPYING3.  If not see\n  @0)\n \n \n+/* Try to fold (type) X op CST -> (type) (X op ((type-x) CST))\n+   when profitable.\n+   For bitwise binary operations apply operand conversions to the\n+   binary operation result instead of to the operands.  This allows\n+   to combine successive conversions and bitwise binary operations.\n+   We combine the above two cases by using a conditional convert.  */\n+(for bitop (bit_and bit_ior bit_xor)\n+ (simplify\n+  (bitop (convert @0) (convert? @1))\n+  (if (((TREE_CODE (@1) == INTEGER_CST\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+\t && int_fits_type_p (@1, TREE_TYPE (@0))\n+\t /* ???  This transform conflicts with fold-const.c doing\n+\t    Convert (T)(x & c) into (T)x & (T)c, if c is an integer\n+\t    constants (if x has signed type, the sign bit cannot be set\n+\t    in c).  This folds extension into the BIT_AND_EXPR.\n+\t    Restrict it to GIMPLE to avoid endless recursions.  */\n+\t && (bitop != BIT_AND_EXPR || GIMPLE))\n+\t|| types_compatible_p (TREE_TYPE (@0), TREE_TYPE (@1)))\n+       && (/* That's a good idea if the conversion widens the operand, thus\n+\t      after hoisting the conversion the operation will be narrower.  */\n+\t   TYPE_PRECISION (TREE_TYPE (@0)) < TYPE_PRECISION (type)\n+\t   /* It's also a good idea if the conversion is to a non-integer\n+\t      mode.  */\n+\t   || GET_MODE_CLASS (TYPE_MODE (type)) != MODE_INT\n+\t   /* Or if the precision of TO is not the same as the precision\n+\t      of its mode.  */\n+\t   || TYPE_PRECISION (type) != GET_MODE_PRECISION (TYPE_MODE (type))))\n+   (convert (bitop @0 (convert @1))))))\n+\n+/* Simplify (A & B) OP0 (C & B) to (A OP0 C) & B. */\n+(for bitop (bit_and bit_ior bit_xor)\n+ (simplify\n+  (bitop (bit_and:c @0 @1) (bit_and @2 @1))\n+  (bit_and (bitop @0 @2) @1)))\n+\n+/* (x | CST1) & CST2 -> (x & CST2) | (CST1 & CST2) */\n+(simplify\n+  (bit_and (bit_ior @0 CONSTANT_CLASS_P@1) CONSTANT_CLASS_P@2)\n+  (bit_ior (bit_and @0 @2) (bit_and @1 @2)))\n+\n+/* Combine successive equal operations with constants.  */\n+(for bitop (bit_and bit_ior bit_xor)\n+ (simplify\n+  (bitop (bitop @0 CONSTANT_CLASS_P@1) CONSTANT_CLASS_P@2)\n+  (bitop @0 (bitop @1 @2))))\n+\n+/* Try simple folding for X op !X, and X op X with the help\n+   of the truth_valued_p and logical_inverted_value predicates.  */\n+(match truth_valued_p\n+ @0\n+ (if (INTEGRAL_TYPE_P (type) && TYPE_PRECISION (type) == 1)))\n+(for op (lt le eq ne ge gt truth_and truth_andif truth_or truth_orif truth_xor)\n+ (match truth_valued_p\n+  (op @0 @1)))\n+(match truth_valued_p\n+  (truth_not @0))\n+\n+(match (logical_inverted_value @0)\n+ (bit_not truth_valued_p@0))\n+(match (logical_inverted_value @0)\n+ (eq @0 integer_zerop)\n+ (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n+(match (logical_inverted_value @0)\n+ (ne truth_valued_p@0 integer_onep)\n+ (if (INTEGRAL_TYPE_P (TREE_TYPE (@0)))))\n+(match (logical_inverted_value @0)\n+ (bit_xor truth_valued_p@0 integer_onep))\n+\n+/* X & !X -> 0.  */\n+(simplify\n+ (bit_and:c @0 (logical_inverted_value @0))\n+ { build_zero_cst (type); })\n+/* X | !X and X ^ !X -> 1, , if X is truth-valued.  */\n+(for op (bit_ior bit_xor)\n+ (simplify\n+  (op:c truth_valued_p@0 (logical_inverted_value @0))\n+  { build_one_cst (type); }))\n+\n+(for bitop (bit_and bit_ior)\n+     rbitop (bit_ior bit_and)\n+  /* (x | y) & x -> x */\n+  /* (x & y) | x -> x */\n+ (simplify\n+  (bitop:c (rbitop:c @0 @1) @0)\n+  @0)\n+ /* (~x | y) & x -> x & y */\n+ /* (~x & y) | x -> x | y */\n+ (simplify\n+  (bitop:c (rbitop:c (bit_not @0) @1) @0)\n+  (bitop @0 @1)))\n+\n+/* If arg1 and arg2 are booleans (or any single bit type)\n+   then try to simplify:\n+\n+   (~X & Y) -> X < Y\n+   (X & ~Y) -> Y < X\n+   (~X | Y) -> X <= Y\n+   (X | ~Y) -> Y <= X\n+\n+   But only do this if our result feeds into a comparison as\n+   this transformation is not always a win, particularly on\n+   targets with and-not instructions.\n+   -> simplify_bitwise_binary_boolean */\n+(simplify\n+  (ne (bit_and:c (bit_not @0) @1) integer_zerop)\n+  (if (INTEGRAL_TYPE_P (TREE_TYPE (@1))\n+       && TYPE_PRECISION (TREE_TYPE (@1)) == 1)\n+   (lt @0 @1)))\n+(simplify\n+  (ne (bit_ior:c (bit_not @0) @1) integer_zerop)\n+  (if (INTEGRAL_TYPE_P (TREE_TYPE (@1))\n+       && TYPE_PRECISION (TREE_TYPE (@1)) == 1)\n+   (le @0 @1)))\n+\n+/* From tree-ssa-forwprop.c:simplify_not_neg_expr.  */\n+\n+/* ~~x -> x */\n+(simplify\n+  (bit_not (bit_not @0))\n+  @0)\n+\n+/* The corresponding (negate (negate @0)) -> @0 is in match-plusminus.pd.  */\n+(simplify\n+ (negate (negate @0))\n+ @0)\n+\n+\n /* Simplifications of conversions.  */\n \n /* Basic strip-useless-type-conversions / strip_nops.  */"}, {"sha": "5c8e8c1f728f488acd5075be4aa81f2326a31ab6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -1,3 +1,8 @@\n+2014-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/forwprop-28.c: Adjust scanning for the\n+\tdesired transform.\n+\n 2014-11-05  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \t* gcc.target/mips/asm-1.c (bar): Add prototype."}, {"sha": "5c945fce41ba89300b244be7529902badd8276b9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-28.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -1,7 +1,7 @@\n /* Setting LOGICAL_OP_NON_SHORT_CIRCUIT to 0 leads to two conditional jumps\n    when evaluating an && condition.  VRP is not able to optimize this.  */\n /* { dg-do compile { target { ! { logical_op_short_circuit || { m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-* hppa*-*-* } } } } } */\n-/* { dg-options \"-O2 -fdump-tree-forwprop1\" } */\n+/* { dg-options \"-O2 -fdump-tree-forwprop1-details\" } */\n \n extern char *frob (void);\n extern _Bool testit (void);\n@@ -79,6 +79,6 @@ test_8 (int code)\n     oof ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replaced\" 8 \"forwprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"simplified to if \\\\\\(\\[^ ]* <\" 8 \"forwprop1\"} } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n "}, {"sha": "671c612214803f697938a1177796751ddc12fb7b", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 520, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5609420fbab5ca93d18219b94eda95779bd75bb2/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=5609420fbab5ca93d18219b94eda95779bd75bb2", "patch": "@@ -1253,49 +1253,6 @@ simplify_conversion_from_bitmask (gimple_stmt_iterator *gsi_p)\n }\n \n \n-/* If we have lhs = ~x (STMT), look and see if earlier we had x = ~y.\n-   If so, we can change STMT into lhs = y which can later be copy\n-   propagated.  Similarly for negation.\n-\n-   This could trivially be formulated as a forward propagation\n-   to immediate uses.  However, we already had an implementation\n-   from DOM which used backward propagation via the use-def links.\n-\n-   It turns out that backward propagation is actually faster as\n-   there's less work to do for each NOT/NEG expression we find.\n-   Backwards propagation needs to look at the statement in a single\n-   backlink.  Forward propagation needs to look at potentially more\n-   than one forward link.\n-\n-   Returns true when the statement was changed.  */\n-\n-static bool \n-simplify_not_neg_expr (gimple_stmt_iterator *gsi_p)\n-{\n-  gimple stmt = gsi_stmt (*gsi_p);\n-  tree rhs = gimple_assign_rhs1 (stmt);\n-  gimple rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-\n-  /* See if the RHS_DEF_STMT has the same form as our statement.  */\n-  if (is_gimple_assign (rhs_def_stmt)\n-      && gimple_assign_rhs_code (rhs_def_stmt) == gimple_assign_rhs_code (stmt))\n-    {\n-      tree rhs_def_operand = gimple_assign_rhs1 (rhs_def_stmt);\n-\n-      /* Verify that RHS_DEF_OPERAND is a suitable SSA_NAME.  */\n-      if (TREE_CODE (rhs_def_operand) == SSA_NAME\n-\t  && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs_def_operand))\n-\t{\n-\t  gimple_assign_set_rhs_from_tree (gsi_p, rhs_def_operand);\n-\t  stmt = gsi_stmt (*gsi_p);\n-\t  update_stmt (stmt);\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* Helper function for simplify_gimple_switch.  Remove case labels that\n    have values outside the range of the new type.  */\n \n@@ -1714,126 +1671,6 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n   return false;\n }\n \n-/* Checks if expression has type of one-bit precision, or is a known\n-   truth-valued expression.  */\n-static bool\n-truth_valued_ssa_name (tree name)\n-{\n-  gimple def;\n-  tree type = TREE_TYPE (name);\n-\n-  if (!INTEGRAL_TYPE_P (type))\n-    return false;\n-  /* Don't check here for BOOLEAN_TYPE as the precision isn't\n-     necessarily one and so ~X is not equal to !X.  */\n-  if (TYPE_PRECISION (type) == 1)\n-    return true;\n-  def = SSA_NAME_DEF_STMT (name);\n-  if (is_gimple_assign (def))\n-    return truth_value_p (gimple_assign_rhs_code (def));\n-  return false;\n-}\n-\n-/* Helper routine for simplify_bitwise_binary_1 function.\n-   Return for the SSA name NAME the expression X if it mets condition\n-   NAME = !X. Otherwise return NULL_TREE.\n-   Detected patterns for NAME = !X are:\n-     !X and X == 0 for X with integral type.\n-     X ^ 1, X != 1,or ~X for X with integral type with precision of one.  */\n-static tree\n-lookup_logical_inverted_value (tree name)\n-{\n-  tree op1, op2;\n-  enum tree_code code;\n-  gimple def;\n-\n-  /* If name has none-intergal type, or isn't a SSA_NAME, then\n-     return.  */\n-  if (TREE_CODE (name) != SSA_NAME\n-      || !INTEGRAL_TYPE_P (TREE_TYPE (name)))\n-    return NULL_TREE;\n-  def = SSA_NAME_DEF_STMT (name);\n-  if (!is_gimple_assign (def))\n-    return NULL_TREE;\n-\n-  code = gimple_assign_rhs_code (def);\n-  op1 = gimple_assign_rhs1 (def);\n-  op2 = NULL_TREE;\n-\n-  /* Get for EQ_EXPR or BIT_XOR_EXPR operation the second operand.\n-     If CODE isn't an EQ_EXPR, BIT_XOR_EXPR, or BIT_NOT_EXPR, then return.  */\n-  if (code == EQ_EXPR || code == NE_EXPR\n-      || code == BIT_XOR_EXPR)\n-    op2 = gimple_assign_rhs2 (def);\n-\n-  switch (code)\n-    {\n-    case BIT_NOT_EXPR:\n-      if (truth_valued_ssa_name (name))\n-\treturn op1;\n-      break;\n-    case EQ_EXPR:\n-      /* Check if we have X == 0 and X has an integral type.  */\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n-\tbreak;\n-      if (integer_zerop (op2))\n-\treturn op1;\n-      break;\n-    case NE_EXPR:\n-      /* Check if we have X != 1 and X is a truth-valued.  */\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n-\tbreak;\n-      if (integer_onep (op2) && truth_valued_ssa_name (op1))\n-\treturn op1;\n-      break;\n-    case BIT_XOR_EXPR:\n-      /* Check if we have X ^ 1 and X is truth valued.  */\n-      if (integer_onep (op2) && truth_valued_ssa_name (op1))\n-\treturn op1;\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Optimize ARG1 CODE ARG2 to a constant for bitwise binary\n-   operations CODE, if one operand has the logically inverted\n-   value of the other.  */\n-static tree\n-simplify_bitwise_binary_1 (enum tree_code code, tree type,\n-\t\t\t   tree arg1, tree arg2)\n-{\n-  tree anot;\n-\n-  /* If CODE isn't a bitwise binary operation, return NULL_TREE.  */\n-  if (code != BIT_AND_EXPR && code != BIT_IOR_EXPR\n-      && code != BIT_XOR_EXPR)\n-    return NULL_TREE;\n-\n-  /* First check if operands ARG1 and ARG2 are equal.  If so\n-     return NULL_TREE as this optimization is handled fold_stmt.  */\n-  if (arg1 == arg2)\n-    return NULL_TREE;\n-  /* See if we have in arguments logical-not patterns.  */\n-  if (((anot = lookup_logical_inverted_value (arg1)) == NULL_TREE\n-       || anot != arg2)\n-      && ((anot = lookup_logical_inverted_value (arg2)) == NULL_TREE\n-\t  || anot != arg1))\n-    return NULL_TREE;\n-\n-  /* X & !X -> 0.  */\n-  if (code == BIT_AND_EXPR)\n-    return fold_convert (type, integer_zero_node);\n-  /* X | !X -> 1 and X ^ !X -> 1, if X is truth-valued.  */\n-  if (truth_valued_ssa_name (anot))\n-    return fold_convert (type, integer_one_node);\n-\n-  /* ??? Otherwise result is (X != 0 ? X : 1).  not handled.  */\n-  return NULL_TREE;\n-}\n-\n /* Given a ssa_name in NAME see if it was defined by an assignment and\n    set CODE to be the code and ARG1 to the first operand on the rhs and ARG2\n    to the second operand on the rhs. */\n@@ -1879,353 +1716,6 @@ defcodefor_name (tree name, enum tree_code *code, tree *arg1, tree *arg2)\n   /* Ignore arg3 currently. */\n }\n \n-/* Return true if a conversion of an operand from type FROM to type TO\n-   should be applied after performing the operation instead.  */\n-\n-static bool\n-hoist_conversion_for_bitop_p (tree to, tree from)\n-{\n-  /* That's a good idea if the conversion widens the operand, thus\n-     after hoisting the conversion the operation will be narrower.  */\n-  if (TYPE_PRECISION (from) < TYPE_PRECISION (to))\n-    return true;\n-\n-  /* It's also a good idea if the conversion is to a non-integer mode.  */\n-  if (GET_MODE_CLASS (TYPE_MODE (to)) != MODE_INT)\n-    return true;\n-\n-  /* Or if the precision of TO is not the same as the precision\n-     of its mode.  */\n-  if (TYPE_PRECISION (to) != GET_MODE_PRECISION (TYPE_MODE (to)))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* GSI points to a statement of the form\n-\n-   result = OP0 CODE OP1\n-\n-   Where OP0 and OP1 are single bit SSA_NAMEs and CODE is either\n-   BIT_AND_EXPR or BIT_IOR_EXPR.\n-\n-   If OP0 is fed by a bitwise negation of another single bit SSA_NAME,\n-   then we can simplify the two statements into a single LT_EXPR or LE_EXPR\n-   when code is BIT_AND_EXPR and BIT_IOR_EXPR respectively.\n-\n-   If a simplification is made, return TRUE, else return FALSE.  */\n-static bool\n-simplify_bitwise_binary_boolean (gimple_stmt_iterator *gsi,\n-\t\t\t\t enum tree_code code,\n-\t\t\t\t tree op0, tree op1)\n-{\n-  gimple op0_def_stmt = SSA_NAME_DEF_STMT (op0);\n-\n-  if (!is_gimple_assign (op0_def_stmt)\n-      || (gimple_assign_rhs_code (op0_def_stmt) != BIT_NOT_EXPR))\n-    return false;\n-\n-  tree x = gimple_assign_rhs1 (op0_def_stmt);\n-  if (TREE_CODE (x) == SSA_NAME\n-      && INTEGRAL_TYPE_P (TREE_TYPE (x))\n-      && TYPE_PRECISION (TREE_TYPE (x)) == 1\n-      && TYPE_UNSIGNED (TREE_TYPE (x)) == TYPE_UNSIGNED (TREE_TYPE (op1)))\n-    {\n-      enum tree_code newcode;\n-\n-      gimple stmt = gsi_stmt (*gsi);\n-      gimple_assign_set_rhs1 (stmt, x);\n-      gimple_assign_set_rhs2 (stmt, op1);\n-      if (code == BIT_AND_EXPR)\n-\tnewcode = TYPE_UNSIGNED (TREE_TYPE (x)) ? LT_EXPR : GT_EXPR;\n-      else\n-\tnewcode = TYPE_UNSIGNED (TREE_TYPE (x)) ? LE_EXPR : GE_EXPR;\n-      gimple_assign_set_rhs_code (stmt, newcode); \n-      update_stmt (stmt);\n-      return true;\n-    }\n-  return false;\n-\n-}\n-\n-/* Simplify bitwise binary operations.\n-   Return true if a transformation applied, otherwise return false.  */\n-\n-static bool\n-simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-  tree arg1 = gimple_assign_rhs1 (stmt);\n-  tree arg2 = gimple_assign_rhs2 (stmt);\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  tree res;\n-  tree def1_arg1, def1_arg2, def2_arg1, def2_arg2;\n-  enum tree_code def1_code, def2_code;\n-\n-  defcodefor_name (arg1, &def1_code, &def1_arg1, &def1_arg2);\n-  defcodefor_name (arg2, &def2_code, &def2_arg1, &def2_arg2);\n-\n-  /* Try to fold (type) X op CST -> (type) (X op ((type-x) CST))\n-     when profitable.  */\n-  if (TREE_CODE (arg2) == INTEGER_CST\n-      && CONVERT_EXPR_CODE_P (def1_code)\n-      && hoist_conversion_for_bitop_p (TREE_TYPE (arg1), TREE_TYPE (def1_arg1))\n-      && INTEGRAL_TYPE_P (TREE_TYPE (def1_arg1))\n-      && int_fits_type_p (arg2, TREE_TYPE (def1_arg1)))\n-    {\n-      gimple newop;\n-      tree tem = make_ssa_name (TREE_TYPE (def1_arg1), NULL);\n-      newop =\n-        gimple_build_assign_with_ops (code, tem, def1_arg1,\n-\t\t\t\t      fold_convert_loc (gimple_location (stmt),\n-\t\t\t\t\t\t\tTREE_TYPE (def1_arg1),\n-\t\t\t\t\t\t\targ2));\n-      gimple_set_location (newop, gimple_location (stmt));\n-      gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n-      gimple_assign_set_rhs_with_ops_1 (gsi, NOP_EXPR,\n-\t\t\t\t\ttem, NULL_TREE, NULL_TREE);\n-      update_stmt (gsi_stmt (*gsi));\n-      return true;\n-    }\n-\n-  /* For bitwise binary operations apply operand conversions to the\n-     binary operation result instead of to the operands.  This allows\n-     to combine successive conversions and bitwise binary operations.  */\n-  if (CONVERT_EXPR_CODE_P (def1_code)\n-      && CONVERT_EXPR_CODE_P (def2_code)\n-      && types_compatible_p (TREE_TYPE (def1_arg1), TREE_TYPE (def2_arg1))\n-      && hoist_conversion_for_bitop_p (TREE_TYPE (arg1), TREE_TYPE (def1_arg1)))\n-    {\n-      gimple newop;\n-      tree tem = make_ssa_name (TREE_TYPE (def1_arg1), NULL);\n-      newop = gimple_build_assign_with_ops (code, tem, def1_arg1, def2_arg1);\n-      gimple_set_location (newop, gimple_location (stmt));\n-      gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n-      gimple_assign_set_rhs_with_ops_1 (gsi, NOP_EXPR,\n-\t\t\t\t\ttem, NULL_TREE, NULL_TREE);\n-      update_stmt (gsi_stmt (*gsi));\n-      return true;\n-    }\n-\n-\n-   /* Simplify (A & B) OP0 (C & B) to (A OP0 C) & B. */\n-   if (def1_code == def2_code\n-       && def1_code == BIT_AND_EXPR\n-       && operand_equal_for_phi_arg_p (def1_arg2,\n-\t\t\t\t       def2_arg2))\n-    {\n-      tree b = def1_arg2;\n-      tree a = def1_arg1;\n-      tree c = def2_arg1;\n-      tree inner = fold_build2 (code, TREE_TYPE (arg2), a, c);\n-      /* If A OP0 C (this usually means C is the same as A) is 0\n-\t then fold it down correctly. */\n-      if (integer_zerop (inner))\n-\t{\n-\t  gimple_assign_set_rhs_from_tree (gsi, inner);\n-\t  update_stmt (stmt);\n-\t  return true;\n-\t}\n-      /* If A OP0 C (this usually means C is the same as A) is a ssa_name\n-\t then fold it down correctly. */\n-      else if (TREE_CODE (inner) == SSA_NAME)\n-\t{\n-      \t  tree outer = fold_build2 (def1_code, TREE_TYPE (inner),\n-\t\t\t\t    inner, b);\n-\t  gimple_assign_set_rhs_from_tree (gsi, outer);\n-\t  update_stmt (stmt);\n-\t  return true;\n-\t}\n-      else\n-\t{\n-\t  gimple newop;\n-\t  tree tem;\n-\t  tem = make_ssa_name (TREE_TYPE (arg2), NULL);\n-\t  newop = gimple_build_assign_with_ops (code, tem, a, c);\n-\t  gimple_set_location (newop, gimple_location (stmt));\n-\t  /* Make sure to re-process the new stmt as it's walking upwards.  */\n-\t  gsi_insert_before (gsi, newop, GSI_NEW_STMT);\n-\t  gimple_assign_set_rhs1 (stmt, tem);\n-\t  gimple_assign_set_rhs2 (stmt, b);\n-\t  gimple_assign_set_rhs_code (stmt, def1_code);\n-\t  update_stmt (stmt);\n-\t  return true;\n-\t}\n-    }\n-\n-  /* (a | CST1) & CST2  ->  (a & CST2) | (CST1 & CST2).  */\n-  if (code == BIT_AND_EXPR\n-      && def1_code == BIT_IOR_EXPR\n-      && CONSTANT_CLASS_P (arg2)\n-      && CONSTANT_CLASS_P (def1_arg2))\n-    {\n-      tree cst = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg2),\n-\t\t\t      arg2, def1_arg2);\n-      tree tem;\n-      gimple newop;\n-      if (integer_zerop (cst))\n-\t{\n-\t  gimple_assign_set_rhs1 (stmt, def1_arg1);\n-\t  update_stmt (stmt);\n-\t  return true;\n-\t}\n-      tem = make_ssa_name (TREE_TYPE (arg2), NULL);\n-      newop = gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\t    tem, def1_arg1, arg2);\n-      gimple_set_location (newop, gimple_location (stmt));\n-      /* Make sure to re-process the new stmt as it's walking upwards.  */\n-      gsi_insert_before (gsi, newop, GSI_NEW_STMT);\n-      gimple_assign_set_rhs1 (stmt, tem);\n-      gimple_assign_set_rhs2 (stmt, cst);\n-      gimple_assign_set_rhs_code (stmt, BIT_IOR_EXPR);\n-      update_stmt (stmt);\n-      return true;\n-    }\n-\n-  /* Combine successive equal operations with constants.  */\n-  if ((code == BIT_AND_EXPR\n-       || code == BIT_IOR_EXPR\n-       || code == BIT_XOR_EXPR)\n-      && def1_code == code \n-      && CONSTANT_CLASS_P (arg2)\n-      && CONSTANT_CLASS_P (def1_arg2))\n-    {\n-      tree cst = fold_build2 (code, TREE_TYPE (arg2),\n-\t\t\t      arg2, def1_arg2);\n-      gimple_assign_set_rhs1 (stmt, def1_arg1);\n-      gimple_assign_set_rhs2 (stmt, cst);\n-      update_stmt (stmt);\n-      return true;\n-    }\n-\n-  /* Try simple folding for X op !X, and X op X.  */\n-  res = simplify_bitwise_binary_1 (code, TREE_TYPE (arg1), arg1, arg2);\n-  if (res != NULL_TREE)\n-    {\n-      gimple_assign_set_rhs_from_tree (gsi, res);\n-      update_stmt (gsi_stmt (*gsi));\n-      return true;\n-    }\n-\n-  if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR)\n-    {\n-      enum tree_code ocode = code == BIT_AND_EXPR ? BIT_IOR_EXPR : BIT_AND_EXPR;\n-      if (def1_code == ocode)\n-\t{\n-\t  tree x = arg2;\n-\t  enum tree_code coden;\n-\t  tree a1, a2;\n-\t  /* ( X | Y) & X -> X */\n-\t  /* ( X & Y) | X -> X */\n-\t  if (x == def1_arg1\n-\t      || x == def1_arg2)\n-\t    {\n-\t      gimple_assign_set_rhs_from_tree (gsi, x);\n-\t      update_stmt (gsi_stmt (*gsi));\n-\t      return true;\n-\t    }\n-\n-\t  defcodefor_name (def1_arg1, &coden, &a1, &a2);\n-\t  /* (~X | Y) & X -> X & Y */\n-\t  /* (~X & Y) | X -> X | Y */\n-\t  if (coden == BIT_NOT_EXPR && a1 == x)\n-\t    {\n-\t      gimple_assign_set_rhs_with_ops (gsi, code,\n-\t\t\t\t\t      x, def1_arg2);\n-\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t      update_stmt (stmt);\n-\t      return true;\n-\t    }\n-\t  defcodefor_name (def1_arg2, &coden, &a1, &a2);\n-\t  /* (Y | ~X) & X -> X & Y */\n-\t  /* (Y & ~X) | X -> X | Y */\n-\t  if (coden == BIT_NOT_EXPR && a1 == x)\n-\t    {\n-\t      gimple_assign_set_rhs_with_ops (gsi, code,\n-\t\t\t\t\t      x, def1_arg1);\n-\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t      update_stmt (stmt);\n-\t      return true;\n-\t    }\n-\t}\n-      if (def2_code == ocode)\n-\t{\n-\t  enum tree_code coden;\n-\t  tree a1;\n-\t  tree x = arg1;\n-\t  /* X & ( X | Y) -> X */\n-\t  /* X | ( X & Y) -> X */\n-\t  if (x == def2_arg1\n-\t      || x == def2_arg2)\n-\t    {\n-\t      gimple_assign_set_rhs_from_tree (gsi, x);\n-\t      update_stmt (gsi_stmt (*gsi));\n-\t      return true;\n-\t    }\n-\t  defcodefor_name (def2_arg1, &coden, &a1, NULL);\n-\t  /* (~X | Y) & X -> X & Y */\n-\t  /* (~X & Y) | X -> X | Y */\n-\t  if (coden == BIT_NOT_EXPR && a1 == x)\n-\t    {\n-\t      gimple_assign_set_rhs_with_ops (gsi, code,\n-\t\t\t\t\t      x, def2_arg2);\n-\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t      update_stmt (stmt);\n-\t      return true;\n-\t    }\n-\t  defcodefor_name (def2_arg2, &coden, &a1, NULL);\n-\t  /* (Y | ~X) & X -> X & Y */\n-\t  /* (Y & ~X) | X -> X | Y */\n-\t  if (coden == BIT_NOT_EXPR && a1 == x)\n-\t    {\n-\t      gimple_assign_set_rhs_with_ops (gsi, code,\n-\t\t\t\t\t      x, def2_arg1);\n-\t      gcc_assert (gsi_stmt (*gsi) == stmt);\n-\t      update_stmt (stmt);\n-\t      return true;\n-\t    }\n-\t}\n-\n-      /* If arg1 and arg2 are booleans (or any single bit type)\n-         then try to simplify:\n-\n-\t   (~X & Y) -> X < Y\n-\t   (X & ~Y) -> Y < X\n-\t   (~X | Y) -> X <= Y\n-\t   (X | ~Y) -> Y <= X \n-\n-\t  But only do this if our result feeds into a comparison as\n-\t  this transformation is not always a win, particularly on\n-\t  targets with and-not instructions.  */\n-      if (TREE_CODE (arg1) == SSA_NAME\n-\t  && TREE_CODE (arg2) == SSA_NAME\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t  && TYPE_PRECISION (TREE_TYPE (arg1)) == 1\n-\t  && TYPE_PRECISION (TREE_TYPE (arg2)) == 1\n-\t  && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t      == TYPE_UNSIGNED (TREE_TYPE (arg2))))\n-\t{\n-\t  use_operand_p use_p;\n-          gimple use_stmt;\n-\n-\t  if (single_imm_use (gimple_assign_lhs (stmt), &use_p, &use_stmt))\n-\t    {\n-\t      if (gimple_code (use_stmt) == GIMPLE_COND\n-\t\t  && gimple_cond_lhs (use_stmt) == gimple_assign_lhs (stmt)\n-\t\t  && integer_zerop (gimple_cond_rhs (use_stmt))\n-\t\t  && gimple_cond_code (use_stmt) == NE_EXPR)\n-\t\t{\n-\t          if (simplify_bitwise_binary_boolean (gsi, code, arg1, arg2))\n-\t\t    return true;\n-\t          if (simplify_bitwise_binary_boolean (gsi, code, arg2, arg1))\n-\t\t    return true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return false;\n-}\n-\n \n /* Recognize rotation patterns.  Return true if a transformation\n    applied, otherwise return false.\n@@ -3760,12 +3250,8 @@ pass_forwprop::execute (function *fun)\n \t\ttree rhs1 = gimple_assign_rhs1 (stmt);\n \t\tenum tree_code code = gimple_assign_rhs_code (stmt);\n \n-\t\tif ((code == BIT_NOT_EXPR\n-\t\t     || code == NEGATE_EXPR)\n-\t\t    && TREE_CODE (rhs1) == SSA_NAME)\n-\t\t  changed = simplify_not_neg_expr (&gsi);\n-\t\telse if (code == COND_EXPR\n-\t\t\t || code == VEC_COND_EXPR)\n+\t\tif (code == COND_EXPR\n+\t\t    || code == VEC_COND_EXPR)\n \t\t  {\n \t\t    /* In this case the entire COND_EXPR is in rhs1. */\n \t\t    if (forward_propagate_into_cond (&gsi)\n@@ -3788,10 +3274,6 @@ pass_forwprop::execute (function *fun)\n \t\t\t  || code == BIT_XOR_EXPR)\n \t\t\t && simplify_rotate (&gsi))\n \t\t  changed = true;\n-\t\telse if (code == BIT_AND_EXPR\n-\t\t\t || code == BIT_IOR_EXPR\n-\t\t\t || code == BIT_XOR_EXPR)\n-\t\t  changed = simplify_bitwise_binary (&gsi);\n \t\telse if (code == MULT_EXPR)\n \t\t  {\n \t\t    changed = simplify_mult (&gsi);"}]}