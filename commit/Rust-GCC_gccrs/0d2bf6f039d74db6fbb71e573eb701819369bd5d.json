{"sha": "0d2bf6f039d74db6fbb71e573eb701819369bd5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQyYmY2ZjAzOWQ3NGRiNmZiYjcxZTU3M2ViNzAxODE5MzY5YmQ1ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-19T04:10:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-19T04:10:09Z"}, "message": "tree-ssa-operands.c (opf_non_specific): New.\n\n        * tree-ssa-operands.c (opf_non_specific): New.\n        (get_asm_expr_operands): Set it.\n        (add_call_clobber_ops, add_call_read_ops): Likewise.\n        (add_stmt_operand): Test it instead of opf_kill_def when\n        considering unmodifiable variables.\n\n        * tree-ssa-operands.c (get_expr_operands): Fix exact test.\n\nFrom-SVN: r99948", "tree": {"sha": "e98b216c4f3155f5e231ce5a68644eb87fc488ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e98b216c4f3155f5e231ce5a68644eb87fc488ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d2bf6f039d74db6fbb71e573eb701819369bd5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d2bf6f039d74db6fbb71e573eb701819369bd5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d2bf6f039d74db6fbb71e573eb701819369bd5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d2bf6f039d74db6fbb71e573eb701819369bd5d/comments", "author": null, "committer": null, "parents": [{"sha": "c64d0e992972de157490985fa2fbc6aa4269a795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64d0e992972de157490985fa2fbc6aa4269a795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64d0e992972de157490985fa2fbc6aa4269a795"}], "stats": {"total": 47, "additions": 31, "deletions": 16}, "files": [{"sha": "6b68588c188a10da1743d60772cab11e6413668e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2bf6f039d74db6fbb71e573eb701819369bd5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2bf6f039d74db6fbb71e573eb701819369bd5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d2bf6f039d74db6fbb71e573eb701819369bd5d", "patch": "@@ -1,3 +1,13 @@\n+2005-05-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-ssa-operands.c (opf_non_specific): New.\n+\t(get_asm_expr_operands): Set it.\n+\t(add_call_clobber_ops, add_call_read_ops): Likewise.\n+\t(add_stmt_operand): Test it instead of opf_kill_def when\n+\tconsidering unmodifiable variables.\n+\n+\t* tree-ssa-operands.c (get_expr_operands): Fix exact test.\n+\n 2005-05-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cfgexpand.c, tree-cfg.c, tree-inline.c, tree-optimize.c,"}, {"sha": "a64778656b098ab61f78d6f735eb5167092f2f93", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d2bf6f039d74db6fbb71e573eb701819369bd5d/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d2bf6f039d74db6fbb71e573eb701819369bd5d/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0d2bf6f039d74db6fbb71e573eb701819369bd5d", "patch": "@@ -99,6 +99,10 @@ Boston, MA 02111-1307, USA.  */\n    VUSE for 'b'.  */\n #define opf_no_vops \t(1 << 2)\n \n+/* Operand is a \"non-specific\" kill for call-clobbers and such.  This is used\n+   to distinguish \"reset the world\" events from explicit MODIFY_EXPRs.  */\n+#define opf_non_specific  (1 << 3)\n+\n /* This structure maintain a sorted list of operands which is created by\n    parse_ssa_operand.  */\n struct opbuild_list_d GTY (())\n@@ -1326,7 +1330,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t\tbool exact;\t\t\n \t\tif (overlap_subvar (offset, size, sv, &exact))\n \t\t  {\n-\t\t    if (exact)\n+\t\t    if (!exact)\n \t\t      flags &= ~opf_kill_def;\n \t\t    add_stmt_operand (&sv->var, s_ann, flags);\n \t\t  }\n@@ -1552,7 +1556,7 @@ get_asm_expr_operands (tree stmt)\n \t  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n \t      {\n \t\ttree var = referenced_var (i);\n-\t\tadd_stmt_operand (&var, s_ann, opf_is_def);\n+\t\tadd_stmt_operand (&var, s_ann, opf_is_def | opf_non_specific);\n \t      }\n \n \t/* Now clobber all addressables.  */\n@@ -1570,7 +1574,7 @@ get_asm_expr_operands (tree stmt)\n \t\t  && get_subvars_for_var (var) != NULL)\n \t\tcontinue;\t\t\n \n-\t      add_stmt_operand (&var, s_ann, opf_is_def);\n+\t      add_stmt_operand (&var, s_ann, opf_is_def | opf_non_specific);\n \t    }\n \n \tbreak;\n@@ -1756,19 +1760,20 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n   /* If the variable cannot be modified and this is a V_MAY_DEF change\n      it into a VUSE.  This happens when read-only variables are marked\n      call-clobbered and/or aliased to writeable variables.  So we only\n-     check that this only happens on stores, and not writes to GIMPLE\n-     registers.\n-     \n-     FIXME: The C++ FE is emitting assignments in the IL stream for\n-     read-only globals.  This is wrong, but for the time being disable\n-     this transformation on V_MUST_DEF operands (otherwise, we\n-     mis-optimize SPEC2000's eon).  */\n-  if ((flags & opf_is_def)\n-      && !(flags & opf_kill_def)\n-      && unmodifiable_var_p (var))\n+     check that this only happens on non-specific stores.\n+\n+     Note that if this is a specific store, i.e. associated with a\n+     modify_expr, then we can't suppress the V_DEF, lest we run into\n+     validation problems.\n+\n+     This can happen when programs cast away const, leaving us with a\n+     store to read-only memory.  If the statement is actually executed\n+     at runtime, then the program is ill formed.  If the statement is\n+     not executed then all is well.  At the very least, we cannot ICE.  */\n+  if ((flags & opf_non_specific) && unmodifiable_var_p (var))\n     {\n       gcc_assert (!is_real_op);\n-      flags &= ~opf_is_def;\n+      flags &= ~(opf_is_def | opf_kill_def);\n     }\n \n   if (is_real_op)\n@@ -1976,7 +1981,7 @@ add_call_clobber_ops (tree stmt)\n       if (unmodifiable_var_p (var))\n \tadd_stmt_operand (&var, &empty_ann, opf_none);\n       else\n-\tadd_stmt_operand (&var, &empty_ann, opf_is_def);\n+\tadd_stmt_operand (&var, &empty_ann, opf_is_def | opf_non_specific);\n     }\n \n   clobbered_aliased_loads = empty_ann.makes_aliased_loads;\n@@ -2061,7 +2066,7 @@ add_call_read_ops (tree stmt)\n   EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, u, bi)\n     {\n       tree var = referenced_var (u);\n-      add_stmt_operand (&var, &empty_ann, opf_none);\n+      add_stmt_operand (&var, &empty_ann, opf_none | opf_non_specific);\n     }\n \n   ro_call_aliased_loads = empty_ann.makes_aliased_loads;"}]}