{"sha": "777ad4c21f744ae353c2ee440c61ef7600174823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3YWQ0YzIxZjc0NGFlMzUzYzJlZTQ0MGM2MWVmNzYwMDE3NDgyMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "1999-12-01T01:48:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-12-01T01:48:02Z"}, "message": "dwarf2out.c (scope_die_for): Only handle types.\n\n        * dwarf2out.c (scope_die_for): Only handle types.  Only search for\n        containing types.\n        (decl_scope_table): Just an array of trees now.\n        (push_decl_scope): Simplify.\n        (dwarf2out_init): Adjust.\n        (local_scope_p): New fn.\n        (gen_inlined_enumeration_type_die): Don't call scope_die_for.\n        (gen_inlined_union_type_die, gen_inlined_structure_type_die): Likewise.\n        (gen_typedef_die): Likewise.\n        (gen_lexical_block_die): Don't call push/pop_decl_scope.\n        (gen_inlined_subroutine_die): Likewise.\n        (gen_abstract_function): Set current_function_decl temporarily.\n        (gen_subprogram_die): Don't check DECL_ABSTRACT to set declaration.\n        Handle block extern declarations.  Don't call push/pop_decl_scope.\n        (gen_decl_die): Fix logic for block externs.\n\nFrom-SVN: r30733", "tree": {"sha": "7ea2b8691dfd3142330085dd3c9b9d7098f2ebce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ea2b8691dfd3142330085dd3c9b9d7098f2ebce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777ad4c21f744ae353c2ee440c61ef7600174823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777ad4c21f744ae353c2ee440c61ef7600174823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777ad4c21f744ae353c2ee440c61ef7600174823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777ad4c21f744ae353c2ee440c61ef7600174823/comments", "author": null, "committer": null, "parents": [{"sha": "d94656872ddd8c58776576c370d6e174ab6662f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94656872ddd8c58776576c370d6e174ab6662f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d94656872ddd8c58776576c370d6e174ab6662f4"}], "stats": {"total": 214, "additions": 79, "deletions": 135}, "files": [{"sha": "2fdac346e38d2c2a26cc18f398aeda744d1d2d99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777ad4c21f744ae353c2ee440c61ef7600174823/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777ad4c21f744ae353c2ee440c61ef7600174823/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=777ad4c21f744ae353c2ee440c61ef7600174823", "patch": "@@ -1,3 +1,21 @@\n+1999-11-30  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* dwarf2out.c (scope_die_for): Only handle types.  Only search for\n+\tcontaining types.\n+\t(decl_scope_table): Just an array of trees now.\n+\t(push_decl_scope): Simplify.\n+\t(dwarf2out_init): Adjust.\n+\t(local_scope_p): New fn.\n+\t(gen_inlined_enumeration_type_die): Don't call scope_die_for.\n+\t(gen_inlined_union_type_die, gen_inlined_structure_type_die): Likewise.\n+\t(gen_typedef_die): Likewise.\n+\t(gen_lexical_block_die): Don't call push/pop_decl_scope.\n+\t(gen_inlined_subroutine_die): Likewise.\n+\t(gen_abstract_function): Set current_function_decl temporarily.\n+\t(gen_subprogram_die): Don't check DECL_ABSTRACT to set declaration.\n+\tHandle block extern declarations.  Don't call push/pop_decl_scope.\n+\t(gen_decl_die): Fix logic for block externs.\n+\n 1999-11-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* calls.c (special_function_p): Remove `realloc' and add `strdup'"}, {"sha": "0b62deb689180fef3f35ee936b85ca7cd9c319a9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 61, "deletions": 135, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777ad4c21f744ae353c2ee440c61ef7600174823/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777ad4c21f744ae353c2ee440c61ef7600174823/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=777ad4c21f744ae353c2ee440c61ef7600174823", "patch": "@@ -2227,23 +2227,12 @@ static unsigned decl_die_table_in_use;\n    decl_die_table.  */\n #define DECL_DIE_TABLE_INCREMENT 256\n \n-/* Structure used for the decl_scope table.  scope is the current declaration\n-   scope, and previous is the entry that is the parent of this scope.  This\n-   is usually but not always the immediately preceeding entry.  */\n-\n-typedef struct decl_scope_struct\n-{\n-  tree scope;\n-  int previous;\n-}\n-decl_scope_node;\n-\n /* A pointer to the base of a table of references to declaration\n    scopes.  This table is a display which tracks the nesting\n    of declaration scopes at the current scope and containing\n    scopes.  This table is used to find the proper place to\n    define type declaration DIE's.  */\n-static decl_scope_node *decl_scope_table;\n+static tree *decl_scope_table;\n \n /* Number of elements currently allocated for the decl_scope_table.  */\n static int decl_scope_table_allocated;\n@@ -7589,34 +7578,28 @@ push_decl_scope (scope)\n     {\n       decl_scope_table_allocated += DECL_SCOPE_TABLE_INCREMENT;\n       decl_scope_table\n-\t= (decl_scope_node *) xrealloc (decl_scope_table,\n-\t\t\t\t\t(decl_scope_table_allocated\n-\t\t\t\t\t * sizeof (decl_scope_node)));\n+\t= (tree *) xrealloc (decl_scope_table,\n+\t\t\t     decl_scope_table_allocated * sizeof (tree));\n     }\n \n-  decl_scope_table[decl_scope_depth].scope = scope;\n-\n-  /* If we're starting to emit a global class while we're in the middle\n-     of emitting a function, we need to find the proper .previous.  */\n-\n-  if (AGGREGATE_TYPE_P (scope))\n-    {\n-      tree containing_scope = TYPE_CONTEXT (scope);\n-      int i;\n-\n-      for (i = decl_scope_depth - 1; i >= 0; --i)\n-\tif (decl_scope_table[i].scope == containing_scope)\n-\t  break;\n-\n-      decl_scope_table[decl_scope_depth].previous = i;\n-    }\n-  else\n-    decl_scope_table[decl_scope_depth].previous = decl_scope_depth - 1;\n-\n+  decl_scope_table[decl_scope_depth] = scope;\n   decl_scope_depth++;\n }\n \n-/* Return the DIE for the scope that immediately contains this declaration.  */\n+/* Pop a declaration scope.  */\n+static inline void\n+pop_decl_scope ()\n+{\n+  if (decl_scope_depth <= 0)\n+    abort ();\n+  --decl_scope_depth;\n+}\n+\n+/* Return the DIE for the scope that immediately contains this type.\n+   Non-named types get global scope.  Named types nested in other\n+   types get their containing scope if it's open, or global scope\n+   otherwise.  All other types (i.e. function-local named types) get\n+   the current active scope.  */\n \n static dw_die_ref\n scope_die_for (t, context_die)\n@@ -7627,14 +7610,11 @@ scope_die_for (t, context_die)\n   register tree containing_scope;\n   register int i;\n \n-  /* Walk back up the declaration tree looking for a place to define\n-     this type.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    containing_scope = TYPE_CONTEXT (t);\n-  else if (TREE_CODE (t) == FUNCTION_DECL && DECL_VINDEX (t))\n-    containing_scope = decl_class_context (t);\n-  else\n-    containing_scope = DECL_CONTEXT (t);\n+  /* Non-types always go in the current scope.  */\n+  if (! TYPE_P (t))\n+    abort ();\n+\n+  containing_scope = TYPE_CONTEXT (t);\n \n   /* Ignore namespaces for the moment.  */\n   if (containing_scope && TREE_CODE (containing_scope) == NAMESPACE_DECL)\n@@ -7646,34 +7626,20 @@ scope_die_for (t, context_die)\n   if (containing_scope && TREE_CODE (containing_scope) == FUNCTION_TYPE)\n     containing_scope = NULL_TREE;\n \n-  /* Function-local tags and functions get stuck in limbo until they are\n-     fixed up by decls_for_scope.  */\n-  if (context_die == NULL && containing_scope != NULL_TREE\n-      && (TREE_CODE (t) == FUNCTION_DECL || is_tagged_type (t)))\n-    return NULL;\n-\n   if (containing_scope == NULL_TREE)\n     scope_die = comp_unit_die;\n-  else if (TYPE_P (containing_scope) || DECL_P (containing_scope))\n+  else if (TYPE_P (containing_scope))\n     {\n-      /* For types and decls, we can just look up the appropriate DIE.  But\n-\t first we check to see if we're in the middle of emitting it so we\n-\t know where the new DIE should go.  */\n+      /* For types, we can just look up the appropriate DIE.  But\n+\t first we check to see if we're in the middle of emitting it\n+\t so we know where the new DIE should go.  */\n \n       for (i = decl_scope_depth - 1; i >= 0; --i)\n-\tif (decl_scope_table[i].scope == containing_scope)\n+\tif (decl_scope_table[i] == containing_scope)\n \t  break;\n \n       if (i < 0)\n \t{\n-\t  /* Function-local tags and functions get stuck in limbo\n-\t     until they are fixed up by decls_for_scope.  */\n-\t  if (TREE_CODE (containing_scope) == FUNCTION_DECL\n-\t      && (TREE_CODE (t) == FUNCTION_DECL || is_tagged_type (t)))\n-\t    return NULL;\n-\t    \n-\t  if (! TYPE_P (containing_scope))\n-\t    abort ();\n \t  if (debug_info_level > DINFO_LEVEL_TERSE\n \t      && !TREE_ASM_WRITTEN (containing_scope))\n \t    abort ();\n@@ -7682,56 +7648,25 @@ scope_die_for (t, context_die)\n \t  scope_die = comp_unit_die;\n \t}\n       else\n-\t{\n-\t  if (TYPE_P (containing_scope))\n-\t    scope_die = lookup_type_die (containing_scope);\n-\t  else\n-\t    scope_die = lookup_decl_die (containing_scope);\n-\t}\n+\tscope_die = lookup_type_die (containing_scope);\n     }\n   else\n-    {\n-      /* Something that we can't just look up the DIE for, such as a\n-         BLOCK.  */\n-\n-      for (i = decl_scope_depth - 1, scope_die = context_die;\n-\t   i >= 0 && decl_scope_table[i].scope != containing_scope;\n-\t   (scope_die = scope_die->die_parent,\n-\t    i = decl_scope_table[i].previous))\n-\t;\n-\n-      /* ??? Integrate_decl_tree does not handle BLOCK_TYPE_TAGS, nor\n-\t does it try to handle types defined by TYPE_DECLs.  Such types\n-\t thus have an incorrect TYPE_CONTEXT, which points to the block\n-\t they were originally defined in, instead of the current block\n-\t created by function inlining.  We try to detect that here and\n-\t work around it.  */\n-\n-      if (i < 0 && scope_die == comp_unit_die\n-\t  && TREE_CODE (containing_scope) == BLOCK\n-\t  && is_tagged_type (t)\n-\t  && (block_ultimate_origin (decl_scope_table[decl_scope_depth - 1].scope)\n-\t      == containing_scope))\n-\t{\n-\t  scope_die = context_die;\n-\t  /* Since the checks below are no longer applicable.  */\n-\t  i = 0;\n-\t}\n-\n-      if (i < 0)\n-\tabort ();\n-    }\n+    scope_die = context_die;\n \n   return scope_die;\n }\n \n-/* Pop a declaration scope.  */\n-static inline void\n-pop_decl_scope ()\n+/* Returns nonzero iff CONTEXT_DIE is internal to a function.  */\n+\n+static inline int\n+local_scope_p (context_die)\n+     dw_die_ref context_die;\n {\n-  if (decl_scope_depth <= 0)\n-    abort ();\n-  --decl_scope_depth;\n+  for (; context_die; context_die = context_die->die_parent)\n+    if (context_die->die_tag == DW_TAG_inlined_subroutine\n+\t|| context_die->die_tag == DW_TAG_subprogram)\n+      return 1;\n+  return 0;\n }\n \n /* Many forms of DIEs require a \"type description\" attribute.  This\n@@ -7981,7 +7916,7 @@ gen_inlined_enumeration_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register dw_die_ref type_die = new_die (DW_TAG_enumeration_type,\n-\t\t\t\t\t  scope_die_for (type, context_die));\n+\t\t\t\t\t  context_die);\n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n   add_abstract_origin_attribute (type_die, type);\n@@ -7994,8 +7929,8 @@ gen_inlined_structure_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = new_die (DW_TAG_structure_type,\n-\t\t\t\t\t  scope_die_for (type, context_die));\n+  register dw_die_ref type_die = new_die (DW_TAG_structure_type, context_die);\n+\n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n   add_abstract_origin_attribute (type_die, type);\n@@ -8008,8 +7943,8 @@ gen_inlined_union_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = new_die (DW_TAG_union_type,\n-\t\t\t\t\t  scope_die_for (type, context_die));\n+  register dw_die_ref type_die = new_die (DW_TAG_union_type, context_die);\n+\n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n   add_abstract_origin_attribute (type_die, type);\n@@ -8247,14 +8182,20 @@ gen_abstract_function (decl)\n      tree decl;\n {\n   register dw_die_ref old_die = lookup_decl_die (decl);\n+  tree save_fn;\n \n   if (old_die && get_AT_unsigned (old_die, DW_AT_inline))\n     /* We've already generated the abstract instance.  */\n     return;\n \n+  save_fn = current_function_decl;\n+  current_function_decl = decl;\n+\n   set_decl_abstract_flags (decl, 1);\n   dwarf2out_decl (decl);\n   set_decl_abstract_flags (decl, 0);\n+\n+  current_function_decl = save_fn;\n }\n \n /* Generate a DIE to represent a declared function (either file-scope or\n@@ -8273,7 +8214,7 @@ gen_subprogram_die (decl, context_die)\n   register tree outer_scope;\n   register dw_die_ref old_die = lookup_decl_die (decl);\n   register int declaration\n-    = ((current_function_decl != decl && ! DECL_ABSTRACT (decl))\n+    = (current_function_decl != decl\n        || (context_die\n \t   && (context_die->die_tag == DW_TAG_structure_type\n \t       || context_die->die_tag == DW_TAG_union_type)));\n@@ -8287,7 +8228,7 @@ gen_subprogram_die (decl, context_die)\n \n   if (origin != NULL)\n     {\n-      if (declaration)\n+      if (declaration && ! local_scope_p (context_die))\n \tabort ();\n \n       subr_die = new_die (DW_TAG_subprogram, context_die);\n@@ -8355,15 +8296,7 @@ gen_subprogram_die (decl, context_die)\n     }\n   else\n     {\n-      register dw_die_ref scope_die;\n-\n-      if (DECL_CONTEXT (decl))\n-\tscope_die = scope_die_for (decl, context_die);\n-      else\n-\t/* Don't put block extern declarations under comp_unit_die.  */\n-\tscope_die = context_die;\n-\n-      subr_die = new_die (DW_TAG_subprogram, scope_die);\n+      subr_die = new_die (DW_TAG_subprogram, context_die);\n \t\t\t \n       if (TREE_PUBLIC (decl))\n \tadd_AT_flag (subr_die, DW_AT_external, 1);\n@@ -8388,13 +8321,14 @@ gen_subprogram_die (decl, context_die)\n \n   if (declaration)\n     {\n-      add_AT_flag (subr_die, DW_AT_declaration, 1);\n+      if (! origin)\n+\tadd_AT_flag (subr_die, DW_AT_declaration, 1);\n \n       /* The first time we see a member function, it is in the context of\n          the class to which it belongs.  We make sure of this by emitting\n          the class first.  The next time is the definition, which is\n          handled above.  The two may come from the same source text.  */\n-      if (DECL_CONTEXT (decl))\n+      if (DECL_CONTEXT (decl) || DECL_ABSTRACT (decl))\n \tequate_decl_number_to_die (decl, subr_die);\n     }\n   else if (DECL_ABSTRACT (decl))\n@@ -8461,7 +8395,6 @@ gen_subprogram_die (decl, context_die)\n      FUNCTION_TYPE. If the chain of type nodes hanging off of this\n      FUNCTION_TYPE node ends with a void_type_node then there should *not* be \n      an ellipsis at the end.  */\n-  push_decl_scope (decl);\n \n   /* In the case where we are describing a mere function declaration, all we\n      need to do here (and all we *can* do here) is to describe the *types* of \n@@ -8541,8 +8474,6 @@ gen_subprogram_die (decl, context_die)\n \t}\n #endif\n     }\n-\n-  pop_decl_scope ();\n }\n \n /* Generate a DIE to represent a declared data object.  */\n@@ -8690,9 +8621,7 @@ gen_lexical_block_die (stmt, context_die, depth)\n       add_AT_lbl_id (stmt_die, DW_AT_high_pc, label);\n     }\n \n-  push_decl_scope (stmt);\n   decls_for_scope (stmt, stmt_die, depth);\n-  pop_decl_scope ();\n }\n \n /* Generate a DIE for an inlined subprogram.  */\n@@ -8719,9 +8648,7 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label);\n       ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_END_LABEL, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label);\n-      push_decl_scope (decl);\n       decls_for_scope (stmt, subr_die, depth);\n-      pop_decl_scope ();\n       current_function_has_inlines = 1;\n     }\n }\n@@ -9072,7 +8999,7 @@ gen_typedef_die (decl, context_die)\n     return;\n   TREE_ASM_WRITTEN (decl) = 1;\n \n-  type_die = new_die (DW_TAG_typedef, scope_die_for (decl, context_die));\n+  type_die = new_die (DW_TAG_typedef, context_die);\n   origin = decl_ultimate_origin (decl);\n   if (origin != NULL)\n     add_abstract_origin_attribute (type_die, origin);\n@@ -9195,7 +9122,7 @@ gen_type_die (type, context_die)\n \t written out yet, writing it out will cover this one, too.\n          This does not apply to instantiations of member class templates;\n \t they need to be added to the containing class as they are\n-\t generated.  FIXME: This breaks the idea of combining type decls\n+\t generated.  FIXME: This hurts the idea of combining type decls\n          from multiple TUs, since we can't predict what set of template\n          instantiations we'll get.  */\n       if (TYPE_CONTEXT (type)\n@@ -9474,7 +9401,7 @@ gen_decl_die (decl, context_die)\n       /* Don't output any DIEs to represent mere function declarations,\n \t unless they are class members or explicit block externs.  */\n       if (DECL_INITIAL (decl) == NULL_TREE && DECL_CONTEXT (decl) == NULL_TREE\n-\t  && (current_function_decl == NULL_TREE || ! DECL_ARTIFICIAL (decl)))\n+\t  && (current_function_decl == NULL_TREE || DECL_ARTIFICIAL (decl)))\n \tbreak;\n \n       /* Emit info for the abstract instance first, if we haven't yet.  */\n@@ -9983,8 +9910,7 @@ dwarf2out_init (asm_out_file, main_input_filename)\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n   decl_scope_table\n-    = (decl_scope_node *) xcalloc (DECL_SCOPE_TABLE_INCREMENT,\n-\t\t\t\t   sizeof (decl_scope_node));\n+    = (tree *) xcalloc (DECL_SCOPE_TABLE_INCREMENT, sizeof (tree));\n   decl_scope_table_allocated = DECL_SCOPE_TABLE_INCREMENT;\n   decl_scope_depth = 0;\n "}]}