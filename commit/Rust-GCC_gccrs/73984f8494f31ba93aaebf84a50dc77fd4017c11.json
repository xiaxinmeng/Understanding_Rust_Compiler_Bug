{"sha": "73984f8494f31ba93aaebf84a50dc77fd4017c11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM5ODRmODQ5NGYzMWJhOTNhYWViZjg0YTUwZGM3N2ZkNDAxN2MxMQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-05-23T03:33:28Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-05-23T03:33:28Z"}, "message": "re PR tree-optimization/54733 (Missing opportunity to optimize endian independent load/store)\n\n2014-05-23  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\tPR tree-optimization/54733\ngcc/\n\t* tree-ssa-math-opts.c (nop_stats): New \"bswap_stats\" structure.\n\t(CMPNOP): Define.\n\t(find_bswap_or_nop_load): New.\n\t(find_bswap_1): Renamed to ...\n\t(find_bswap_or_nop_1): This. Also add support for memory source.\n\t(find_bswap): Renamed to ...\n\t(find_bswap_or_nop): This. Also add support for memory source and\n\tdetection of bitwise operations equivalent to load in host endianness.\n\t(execute_optimize_bswap): Likewise. Also move its leading comment back\n\tin place and split statement transformation into ...\n\t(bswap_replace): This.\n\ngcc/testsuite\n\t* gcc.dg/optimize-bswapdi-3.c: New test to check extension of bswap\n\toptimization to support memory sources and bitwise operations\n\tequivalent to load in host endianness.\n\t* gcc.dg/optimize-bswaphi-1.c: Likewise.\n\t* gcc.dg/optimize-bswapsi-2.c: Likewise.\n\t* gcc.c-torture/execute/bswap-2.c: Likewise.\n\nFrom-SVN: r210843", "tree": {"sha": "8bab8083343643305fc3a4dbcbdc58042c48e5ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bab8083343643305fc3a4dbcbdc58042c48e5ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73984f8494f31ba93aaebf84a50dc77fd4017c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73984f8494f31ba93aaebf84a50dc77fd4017c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73984f8494f31ba93aaebf84a50dc77fd4017c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73984f8494f31ba93aaebf84a50dc77fd4017c11/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eaa33a6a651713511f9642f5a3e2eff8639edf41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa33a6a651713511f9642f5a3e2eff8639edf41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa33a6a651713511f9642f5a3e2eff8639edf41"}], "stats": {"total": 790, "additions": 680, "deletions": 110}, "files": [{"sha": "176a40c6d720571c57ef0f483cfa128273e35988", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -1,3 +1,18 @@\n+2014-05-23  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/54733\n+\t* tree-ssa-math-opts.c (nop_stats): New \"bswap_stats\" structure.\n+\t(CMPNOP): Define.\n+\t(find_bswap_or_nop_load): New.\n+\t(find_bswap_1): Renamed to ...\n+\t(find_bswap_or_nop_1): This. Also add support for memory source.\n+\t(find_bswap): Renamed to ...\n+\t(find_bswap_or_nop): This. Also add support for memory source and\n+\tdetection of bitwise operations equivalent to load in host endianness.\n+\t(execute_optimize_bswap): Likewise. Also move its leading comment back\n+\tin place and split statement transformation into ...\n+\t(bswap_replace): This.\n+\n 2014-05-22  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/61215"}, {"sha": "e0b594b433de54c7b15f7b5d42a62f39f2cdfce8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -1,3 +1,13 @@\n+2014-05-23  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/54733\n+\t* gcc.dg/optimize-bswapdi-3.c: New test to check extension of bswap\n+\toptimization to support memory sources and bitwise operations\n+\tequivalent to load in host endianness.\n+\t* gcc.dg/optimize-bswaphi-1.c: Likewise.\n+\t* gcc.dg/optimize-bswapsi-2.c: Likewise.\n+\t* gcc.c-torture/execute/bswap-2.c: Likewise.\n+\n 2014-05-23  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* lib/target-supports.exp: New effective targets for architectures"}, {"sha": "e91b4874fc89ca06a640a49f9becc33c6ad15896", "filename": "gcc/testsuite/gcc.c-torture/execute/bswap-2.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbswap-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbswap-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbswap-2.c?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -0,0 +1,90 @@\n+#ifdef __UINT32_TYPE__\n+typedef __UINT32_TYPE__ uint32_t;\n+#else\n+typedef __UINT32_TYPE__ unsigned;\n+#endif\n+\n+struct bitfield {\n+  unsigned char f0:7;\n+  unsigned char f1:7;\n+  unsigned char f2:7;\n+  unsigned char f3:7;\n+};\n+\n+struct ok {\n+  unsigned char f0;\n+  unsigned char f1;\n+  unsigned char f2;\n+  unsigned char f3;\n+};\n+\n+union bf_or_uint32 {\n+  struct ok inval;\n+  struct bitfield bfval;\n+};\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+partial_read_le32 (union bf_or_uint32 in)\n+{\n+  return in.bfval.f0 | (in.bfval.f1 << 8)\n+\t | (in.bfval.f2 << 16) | (in.bfval.f3 << 24);\n+}\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+partial_read_be32 (union bf_or_uint32 in)\n+{\n+  return in.bfval.f3 | (in.bfval.f2 << 8)\n+\t | (in.bfval.f1 << 16) | (in.bfval.f0 << 24);\n+}\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+fake_read_le32 (char *x, char *y)\n+{\n+  unsigned char c0, c1, c2, c3;\n+\n+  c0 = x[0];\n+  c1 = x[1];\n+  *y = 1;\n+  c2 = x[2];\n+  c3 = x[3];\n+  return c0 | c1 << 8 | c2 << 16 | c3 << 24;\n+}\n+\n+__attribute__ ((noinline, noclone)) uint32_t\n+fake_read_be32 (char *x, char *y)\n+{\n+  unsigned char c0, c1, c2, c3;\n+\n+  c0 = x[0];\n+  c1 = x[1];\n+  *y = 1;\n+  c2 = x[2];\n+  c3 = x[3];\n+  return c3 | c2 << 8 | c1 << 16 | c0 << 24;\n+}\n+\n+int\n+main ()\n+{\n+  union bf_or_uint32 bfin;\n+  uint32_t out;\n+  char cin[] = { 0x83, 0x85, 0x87, 0x89 };\n+\n+  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)\n+    return 0;\n+  bfin.inval = (struct ok) { 0x83, 0x85, 0x87, 0x89 };\n+  out = partial_read_le32 (bfin);\n+  if (out != 0x09070503 && out != 0x88868482)\n+    __builtin_abort ();\n+  bfin.inval = (struct ok) { 0x83, 0x85, 0x87, 0x89 };\n+  out = partial_read_be32 (bfin);\n+  if (out != 0x03050709 && out != 0x82848688)\n+    __builtin_abort ();\n+  out = fake_read_le32 (cin, &cin[2]);\n+  if (out != 0x89018583)\n+    __builtin_abort ();\n+  out = fake_read_be32 (cin, &cin[2]);\n+  if (out != 0x83850189)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "0a8bf2e739d71f056aeb34dbdb1e76aefea79b5e", "filename": "gcc/testsuite/gcc.dg/optimize-bswapdi-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-3.c?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target bswap64 } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+\n+#include <stdint.h>\n+\n+unsigned char data[8];\n+\n+struct uint64_st {\n+  unsigned char u0, u1, u2, u3, u4, u5, u6, u7;\n+};\n+\n+uint64_t read_le64_1 (void)\n+{\n+  return (uint64_t) data[0] | ((uint64_t) data[1] << 8)\n+\t | ((uint64_t) data[2] << 16) | ((uint64_t) data[3] << 24)\n+\t | ((uint64_t) data[4] << 32) | ((uint64_t) data[5] << 40)\n+\t | ((uint64_t) data[6] << 48) | ((uint64_t) data[7] << 56);\n+}\n+\n+uint64_t read_le64_2 (struct uint64_st data)\n+{\n+  return (uint64_t) data.u0 | ((uint64_t) data.u1 << 8)\n+\t | ((uint64_t) data.u2 << 16) | ((uint64_t) data.u3 << 24)\n+\t | ((uint64_t) data.u4 << 32) | ((uint64_t) data.u5 << 40)\n+\t | ((uint64_t) data.u6 << 48) | ((uint64_t) data.u7 << 56);\n+}\n+\n+uint64_t read_le64_3 (unsigned char *data)\n+{\n+  return (uint64_t) *data | ((uint64_t) *(data + 1) << 8)\n+\t | ((uint64_t) *(data + 2) << 16) | ((uint64_t) *(data + 3) << 24)\n+\t | ((uint64_t) *(data + 4) << 32) | ((uint64_t) *(data + 5) << 40)\n+\t | ((uint64_t) *(data + 6) << 48) | ((uint64_t) *(data + 7) << 56);\n+}\n+\n+uint64_t read_be64_1 (void)\n+{\n+  return (uint64_t) data[7] | ((uint64_t) data[6] << 8)\n+\t | ((uint64_t) data[5] << 16) | ((uint64_t) data[4] << 24)\n+\t | ((uint64_t) data[3] << 32) | ((uint64_t) data[2] << 40)\n+\t | ((uint64_t) data[1] << 48) | ((uint64_t) data[0] << 56);\n+}\n+\n+uint64_t read_be64_2 (struct uint64_st data)\n+{\n+  return (uint64_t) data.u7 | ((uint64_t) data.u6 << 8)\n+\t | ((uint64_t) data.u5 << 16) | ((uint64_t) data.u4 << 24)\n+\t | ((uint64_t) data.u3 << 32) | ((uint64_t) data.u2 << 40)\n+\t | ((uint64_t) data.u1 << 48) | ((uint64_t) data.u0 << 56);\n+}\n+\n+uint64_t read_be64_3 (unsigned char *data)\n+{\n+  return (uint64_t) *(data + 7) | ((uint64_t) *(data + 6) << 8)\n+\t | ((uint64_t) *(data + 5) << 16) | ((uint64_t) *(data + 4) << 24)\n+\t | ((uint64_t) *(data + 3) << 32) | ((uint64_t) *(data + 2) << 40)\n+\t | ((uint64_t) *(data + 1) << 48) | ((uint64_t) *data << 56);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"64 bit load in host endianness found at\" 3 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"64 bit bswap implementation found at\" 3 \"bswap\" { xfail alpha*-*-* arm*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"bswap\" } } */"}, {"sha": "65bff98f9f9befdff61306cd03a33d14704d7196", "filename": "gcc/testsuite/gcc.dg/optimize-bswaphi-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswaphi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswaphi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswaphi-1.c?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target bswap16 } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-bswap -march=z900\" { target s390-*-* } } */\n+\n+#include <stdint.h>\n+\n+unsigned char data[2];\n+\n+struct uint16_st {\n+  unsigned char u0, u1;\n+};\n+\n+uint32_t read_le16_1 (void)\n+{\n+  return data[0] | (data[1] << 8);\n+}\n+\n+uint32_t read_le16_2 (struct uint16_st data)\n+{\n+  return data.u0 | (data.u1 << 8);\n+}\n+\n+uint32_t read_le16_3 (unsigned char *data)\n+{\n+  return *data | (*(data + 1) << 8);\n+}\n+\n+uint32_t read_be16_1 (void)\n+{\n+  return data[1] | (data[0] << 8);\n+}\n+\n+uint32_t read_be16_2 (struct uint16_st data)\n+{\n+  return data.u1 | (data.u0 << 8);\n+}\n+\n+uint32_t read_be16_3 (unsigned char *data)\n+{\n+  return *(data + 1) | (*data << 8);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"16 bit load in host endianness found at\" 3 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"16 bit bswap implementation found at\" 3 \"bswap\" { xfail alpha*-*-* arm*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"bswap\" } } */"}, {"sha": "518b51083784211ec71d9b53f9afee342f844c3d", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-2.c?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target bswap32 } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-bswap -march=z900\" { target s390-*-* } } */\n+\n+#include <stdint.h>\n+\n+extern unsigned char data[4];\n+\n+struct uint32_st {\n+  unsigned char u0, u1, u2, u3;\n+};\n+\n+uint32_t read_le32_1 (void)\n+{\n+  return data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n+}\n+\n+uint32_t read_le32_2 (struct uint32_st data)\n+{\n+  return data.u0 | (data.u1 << 8) | (data.u2 << 16) | (data.u3 << 24);\n+}\n+\n+uint32_t read_le32_3 (unsigned char *data)\n+{\n+  return *data | (*(data + 1) << 8) | (*(data + 2) << 16)\n+\t | (*(data + 3) << 24);\n+}\n+\n+uint32_t read_be32_1 (void)\n+{\n+  return data[3] | (data[2] << 8) | (data[1] << 16) | (data[0] << 24);\n+}\n+\n+uint32_t read_be32_2 (struct uint32_st data)\n+{\n+  return data.u3 | (data.u2 << 8) | (data.u1 << 16) | (data.u0 << 24);\n+}\n+\n+uint32_t read_be32_3 (unsigned char *data)\n+{\n+  return *(data + 3) | (*(data + 2) << 8) | (*(data + 1) << 16)\n+\t | (*data << 24);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"32 bit load in host endianness found at\" 3 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"32 bit bswap implementation found at\" 3 \"bswap\" { xfail alpha*-*-* arm*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"bswap\" } } */"}, {"sha": "7c8c63ac99a32ff8e2f0b7be1c4879f848a13ca0", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 405, "deletions": 110, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73984f8494f31ba93aaebf84a50dc77fd4017c11/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=73984f8494f31ba93aaebf84a50dc77fd4017c11", "patch": "@@ -98,6 +98,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"is-a.h\"\n #include \"gimple.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimplify.h\"\n #include \"gimplify-me.h\"\n #include \"stor-layout.h\"\n #include \"gimple-ssa.h\"\n@@ -170,15 +171,15 @@ static struct\n \n static struct\n {\n-  /* Number of hand-written 16-bit bswaps found.  */\n+  /* Number of hand-written 16-bit nop / bswaps found.  */\n   int found_16bit;\n \n-  /* Number of hand-written 32-bit bswaps found.  */\n+  /* Number of hand-written 32-bit nop / bswaps found.  */\n   int found_32bit;\n \n-  /* Number of hand-written 64-bit bswaps found.  */\n+  /* Number of hand-written 64-bit nop / bswaps found.  */\n   int found_64bit;\n-} bswap_stats;\n+} nop_stats, bswap_stats;\n \n static struct\n {\n@@ -1604,13 +1605,43 @@ make_pass_cse_sincos (gcc::context *ctxt)\n \n    0    - byte has the value 0\n    1..size - byte contains the content of the byte\n-   number indexed with that value minus one  */\n+   number indexed with that value minus one.\n+\n+   To detect permutations on memory sources (arrays and structures), a symbolic\n+   number is also associated a base address (the array or structure the load is\n+   made from), an offset from the base address and a range which gives the\n+   difference between the highest and lowest accessed memory location to make\n+   such a symbolic number. The range is thus different from size which reflects\n+   the size of the type of current expression. Note that for non memory source,\n+   range holds the same value as size.\n+\n+   For instance, for an array char a[], (short) a[0] | (short) a[3] would have\n+   a size of 2 but a range of 4 while (short) a[0] | ((short) a[0] << 1) would\n+   still have a size of 2 but this time a range of 1.  */\n \n struct symbolic_number {\n   unsigned HOST_WIDEST_INT n;\n   int size;\n+  tree base_addr;\n+  tree offset;\n+  HOST_WIDE_INT bytepos;\n+  tree alias_set;\n+  tree vuse;\n+  unsigned HOST_WIDE_INT range;\n };\n \n+/* The number which the find_bswap_or_nop_1 result should match in\n+   order to have a nop.  The number is masked according to the size of\n+   the symbolic number before using it.  */\n+#define CMPNOP (sizeof (HOST_WIDEST_INT) < 8 ? 0 : \\\n+  (unsigned HOST_WIDEST_INT)0x08070605 << 32 | 0x04030201)\n+\n+/* The number which the find_bswap_or_nop_1 result should match in\n+   order to have a byte swap.  The number is masked according to the\n+   size of the symbolic number before using it.  */\n+#define CMPXCHG (sizeof (HOST_WIDEST_INT) < 8 ? 0 : \\\n+  (unsigned HOST_WIDEST_INT)0x01020304 << 32 | 0x05060708)\n+\n /* Perform a SHIFT or ROTATE operation by COUNT bits on symbolic\n    number N.  Return false if the requested operation is not permitted\n    on a symbolic number.  */\n@@ -1670,13 +1701,76 @@ verify_symbolic_number_p (struct symbolic_number *n, gimple stmt)\n   return true;\n }\n \n-/* find_bswap_1 invokes itself recursively with N and tries to perform\n-   the operation given by the rhs of STMT on the result.  If the\n-   operation could successfully be executed the function returns the\n-   tree expression of the source operand and NULL otherwise.  */\n+/* Check if STMT might be a byte swap or a nop from a memory source and returns\n+   the answer. If so, REF is that memory source and the base of the memory area\n+   accessed and the offset of the access from that base are recorded in N.  */\n+\n+bool\n+find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n+{\n+  /* Leaf node is an array or component ref. Memorize its base and\n+     offset from base to compare to other such leaf node.  */\n+  HOST_WIDE_INT bitsize, bitpos;\n+  enum machine_mode mode;\n+  int unsignedp, volatilep;\n+\n+  if (!gimple_assign_load_p (stmt) || gimple_has_volatile_ops (stmt))\n+    return false;\n+\n+  n->base_addr = get_inner_reference (ref, &bitsize, &bitpos, &n->offset,\n+\t\t\t\t      &mode, &unsignedp, &volatilep, false);\n+\n+  if (TREE_CODE (n->base_addr) == MEM_REF)\n+    {\n+      offset_int bit_offset = 0;\n+      tree off = TREE_OPERAND (n->base_addr, 1);\n+\n+      if (!integer_zerop (off))\n+\t{\n+\t  offset_int boff, coff = mem_ref_offset (n->base_addr);\n+\t  boff = wi::lshift (coff, LOG2_BITS_PER_UNIT);\n+\t  bit_offset += boff;\n+\t}\n+\n+      n->base_addr = TREE_OPERAND (n->base_addr, 0);\n+\n+      /* Avoid returning a negative bitpos as this may wreak havoc later.  */\n+      if (wi::neg_p (bit_offset))\n+\t{\n+\t  offset_int mask = wi::mask <offset_int> (LOG2_BITS_PER_UNIT, false);\n+\t  offset_int tem = bit_offset.and_not (mask);\n+\t  /* TEM is the bitpos rounded to BITS_PER_UNIT towards -Inf.\n+\t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n+\t  bit_offset -= tem;\n+\t  tem = wi::arshift (tem, LOG2_BITS_PER_UNIT);\n+\t  if (n->offset)\n+\t    n->offset = size_binop (PLUS_EXPR, n->offset,\n+\t\t\t\t    wide_int_to_tree (sizetype, tem));\n+\t  else\n+\t    n->offset = wide_int_to_tree (sizetype, tem);\n+\t}\n+\n+      bitpos += bit_offset.to_shwi ();\n+    }\n+\n+  if (bitpos % BITS_PER_UNIT)\n+    return false;\n+  if (bitsize % BITS_PER_UNIT)\n+    return false;\n+\n+  n->bytepos = bitpos / BITS_PER_UNIT;\n+  n->alias_set = reference_alias_ptr_type (ref);\n+  n->vuse = gimple_vuse (stmt);\n+  return true;\n+}\n+\n+/* find_bswap_or_nop_1 invokes itself recursively with N and tries to perform\n+   the operation given by the rhs of STMT on the result.  If the operation\n+   could successfully be executed the function returns the tree expression of\n+   the source operand and NULL otherwise.  */\n \n static tree\n-find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n+find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n {\n   enum tree_code code;\n   tree rhs1, rhs2 = NULL;\n@@ -1689,6 +1783,9 @@ find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n   rhs1 = gimple_assign_rhs1 (stmt);\n \n+  if (find_bswap_or_nop_load (stmt, rhs1, n))\n+    return rhs1;\n+\n   if (TREE_CODE (rhs1) != SSA_NAME)\n     return NULL_TREE;\n \n@@ -1715,11 +1812,11 @@ find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  && code != CONVERT_EXPR)\n \treturn NULL_TREE;\n \n-      source_expr1 = find_bswap_1 (rhs1_stmt, n, limit - 1);\n+      source_expr1 = find_bswap_or_nop_1 (rhs1_stmt, n, limit - 1);\n \n-      /* If find_bswap_1 returned NULL STMT is a leaf node and we have\n-\t to initialize the symbolic number.  */\n-      if (!source_expr1)\n+      /* If find_bswap_or_nop_1 returned NULL, STMT is a leaf node and\n+\t we have to initialize the symbolic number.  */\n+      if (!source_expr1 || gimple_assign_load_p (rhs1_stmt))\n \t{\n \t  /* Set up the symbolic number N by setting each byte to a\n \t     value between 1 and the byte size of rhs1.  The highest\n@@ -1729,14 +1826,18 @@ find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  if (n->size % BITS_PER_UNIT != 0)\n \t    return NULL_TREE;\n \t  n->size /= BITS_PER_UNIT;\n-\t  n->n = (sizeof (HOST_WIDEST_INT) < 8 ? 0 :\n-\t\t  (unsigned HOST_WIDEST_INT)0x08070605 << 32 | 0x04030201);\n+\t  n->range = n->size;\n+\t  n->n = CMPNOP;\n \n \t  if (n->size < (int)sizeof (HOST_WIDEST_INT))\n \t    n->n &= ((unsigned HOST_WIDEST_INT)1 <<\n \t\t     (n->size * BITS_PER_UNIT)) - 1;\n \n-\t  source_expr1 = rhs1;\n+\t  if (!source_expr1)\n+\t    {\n+\t      n->base_addr = n->offset = n->alias_set = n->vuse = NULL_TREE;\n+\t      source_expr1 = rhs1;\n+\t    }\n \t}\n \n       switch (code)\n@@ -1777,6 +1878,8 @@ find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t\tn->n &= ((unsigned HOST_WIDEST_INT)1 << type_size) - 1;\n \t      }\n \t    n->size = type_size / BITS_PER_UNIT;\n+\t    if (!n->base_addr)\n+\t      n->range = n->size;\n \t  }\n \t  break;\n \tdefault:\n@@ -1805,17 +1908,79 @@ find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n       switch (code)\n \t{\n \tcase BIT_IOR_EXPR:\n-\t  source_expr1 = find_bswap_1 (rhs1_stmt, &n1, limit - 1);\n+\t  source_expr1 = find_bswap_or_nop_1 (rhs1_stmt, &n1, limit - 1);\n \n \t  if (!source_expr1)\n \t    return NULL_TREE;\n \n-\t  source_expr2 = find_bswap_1 (rhs2_stmt, &n2, limit - 1);\n+\t  source_expr2 = find_bswap_or_nop_1 (rhs2_stmt, &n2, limit - 1);\n+\n+\t  if (n1.size != n2.size || !source_expr2)\n+\t    return NULL_TREE;\n \n-\t  if (source_expr1 != source_expr2\n-\t      || n1.size != n2.size)\n+\t  if (!n1.vuse != !n2.vuse ||\n+\t  (n1.vuse && !operand_equal_p (n1.vuse, n2.vuse, 0)))\n \t    return NULL_TREE;\n \n+\t  if (source_expr1 != source_expr2)\n+\t    {\n+\t      HOST_WIDEST_INT inc, mask;\n+\t      unsigned i;\n+\t      HOST_WIDE_INT off_sub;\n+\t      struct symbolic_number *n_ptr;\n+\n+\t      if (!n1.base_addr || !n2.base_addr\n+\t\t  || !operand_equal_p (n1.base_addr, n2.base_addr, 0))\n+\t\treturn NULL_TREE;\n+\t      if (!n1.offset != !n2.offset ||\n+\t          (n1.offset && !operand_equal_p (n1.offset, n2.offset, 0)))\n+\t\treturn NULL_TREE;\n+\n+\t      /* We swap n1 with n2 to have n1 < n2.  */\n+\t      if (n2.bytepos < n1.bytepos)\n+\t\t{\n+\t\t  struct symbolic_number tmpn;\n+\n+\t\t  tmpn = n2;\n+\t\t  n2 = n1;\n+\t\t  n1 = tmpn;\n+\t\t  source_expr1 = source_expr2;\n+\t\t}\n+\n+\t      off_sub = n2.bytepos - n1.bytepos;\n+\n+\t      /* Check that the range of memory covered < biggest int size.  */\n+\t      if (off_sub + n2.range > (int) sizeof (HOST_WIDEST_INT))\n+\t        return NULL_TREE;\n+\t      n->range = n2.range + off_sub;\n+\n+\t      /* Reinterpret byte marks in symbolic number holding the value of\n+\t\t bigger weight according to host endianness.  */\n+\t      inc = BYTES_BIG_ENDIAN ? off_sub + n2.range - n1.range : off_sub;\n+\t      mask = 0xFF;\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\tn_ptr = &n1;\n+\t      else\n+\t\tn_ptr = &n2;\n+\t      for (i = 0; i < sizeof (HOST_WIDEST_INT); i++, inc <<= 8,\n+\t\t   mask <<= 8)\n+\t\t{\n+\t\t  if (n_ptr->n & mask)\n+\t\t    n_ptr->n += inc;\n+\t\t}\n+\t    }\n+\t  else\n+\t    n->range = n1.range;\n+\n+\t  if (!n1.alias_set\n+\t      || alias_ptr_types_compatible_p (n1.alias_set, n2.alias_set))\n+\t    n->alias_set = n1.alias_set;\n+\t  else\n+\t    n->alias_set = ptr_type_node;\n+\t  n->vuse = n1.vuse;\n+\t  n->base_addr = n1.base_addr;\n+\t  n->offset = n1.offset;\n+\t  n->bytepos = n1.bytepos;\n \t  n->size = n1.size;\n \t  for (i = 0, mask = 0xff; i < n->size; i++, mask <<= BITS_PER_UNIT)\n \t    {\n@@ -1840,57 +2005,75 @@ find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n   return NULL_TREE;\n }\n \n-/* Check if STMT completes a bswap implementation consisting of ORs,\n-   SHIFTs and ANDs.  Return the source tree expression on which the\n-   byte swap is performed and NULL if no bswap was found.  */\n+/* Check if STMT completes a bswap implementation or a read in a given\n+   endianness consisting of ORs, SHIFTs and ANDs and sets *BSWAP\n+   accordingly.  It also sets N to represent the kind of operations\n+   performed: size of the resulting expression and whether it works on\n+   a memory source, and if so alias-set and vuse.  At last, the\n+   function returns the source tree expression.  */\n \n static tree\n-find_bswap (gimple stmt)\n+find_bswap_or_nop (gimple stmt, struct symbolic_number *n, bool *bswap)\n {\n-/* The number which the find_bswap result should match in order to\n-   have a full byte swap.  The number is shifted to the left according\n-   to the size of the symbolic number before using it.  */\n-  unsigned HOST_WIDEST_INT cmp =\n-    sizeof (HOST_WIDEST_INT) < 8 ? 0 :\n-    (unsigned HOST_WIDEST_INT)0x01020304 << 32 | 0x05060708;\n-\n-  struct symbolic_number n;\n+/* The number which the find_bswap_or_nop_1 result should match in order\n+   to have a full byte swap.  The number is shifted to the right\n+   according to the size of the symbolic number before using it.  */\n+  unsigned HOST_WIDEST_INT cmpxchg = CMPXCHG;\n+  unsigned HOST_WIDEST_INT cmpnop = CMPNOP;\n+\n   tree source_expr;\n   int limit;\n \n   /* The last parameter determines the depth search limit.  It usually\n-     correlates directly to the number of bytes to be touched.  We\n-     increase that number by three  here in order to also\n-     cover signed -> unsigned converions of the src operand as can be seen\n+     correlates directly to the number n of bytes to be touched.  We\n+     increase that number by log2(n) + 1 here in order to also\n+     cover signed -> unsigned conversions of the src operand as can be seen\n      in libgcc, and for initial shift/and operation of the src operand.  */\n   limit = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (gimple_expr_type (stmt)));\n   limit += 1 + (int) ceil_log2 ((unsigned HOST_WIDE_INT) limit);\n-  source_expr =  find_bswap_1 (stmt, &n, limit);\n+  source_expr =  find_bswap_or_nop_1 (stmt, n, limit);\n \n   if (!source_expr)\n     return NULL_TREE;\n \n-  /* Zero out the extra bits of N and CMP.  */\n-  if (n.size < (int)sizeof (HOST_WIDEST_INT))\n+  /* Find real size of result (highest non zero byte).  */\n+  if (n->base_addr)\n     {\n-      unsigned HOST_WIDEST_INT mask =\n-\t((unsigned HOST_WIDEST_INT)1 << (n.size * BITS_PER_UNIT)) - 1;\n+      int rsize;\n+      unsigned HOST_WIDEST_INT tmpn;\n \n-      n.n &= mask;\n-      cmp >>= (sizeof (HOST_WIDEST_INT) - n.size) * BITS_PER_UNIT;\n+      for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_UNIT, rsize++);\n+      n->range = rsize;\n     }\n \n-  /* A complete byte swap should make the symbolic number to start\n-     with the largest digit in the highest order byte.  */\n-  if (cmp != n.n)\n+  /* Zero out the extra bits of N and CMP*.  */\n+  if (n->range < (int)sizeof (HOST_WIDEST_INT))\n+    {\n+      unsigned HOST_WIDEST_INT mask;\n+\n+      mask = ((unsigned HOST_WIDEST_INT)1 << (n->range * BITS_PER_UNIT)) - 1;\n+      cmpxchg >>= (sizeof (HOST_WIDEST_INT) - n->range) * BITS_PER_UNIT;\n+      cmpnop &= mask;\n+    }\n+\n+  /* A complete byte swap should make the symbolic number to start with\n+     the largest digit in the highest order byte. Unchanged symbolic\n+     number indicates a read with same endianness as host architecture.  */\n+  if (n->n == cmpnop)\n+    *bswap = false;\n+  else if (n->n == cmpxchg)\n+    *bswap = true;\n+  else\n     return NULL_TREE;\n \n+  /* Useless bit manipulation performed by code.  */\n+  if (!n->base_addr && n->n == cmpnop)\n+    return NULL_TREE;\n+\n+  n->range *= BITS_PER_UNIT;\n   return source_expr;\n }\n \n-/* Find manual byte swap implementations and turn them into a bswap\n-   builtin invokation.  */\n-\n namespace {\n \n const pass_data pass_data_optimize_bswap =\n@@ -1924,6 +2107,156 @@ class pass_optimize_bswap : public gimple_opt_pass\n \n }; // class pass_optimize_bswap\n \n+/* Perform the bswap optimization: replace the statement STMT at GSI\n+   with load type, VUSE and set-alias as described by N if a memory\n+   source is involved (N->base_addr is non null), followed by the\n+   builtin bswap invocation in FNDECL if BSWAP is true.  SRC gives\n+   the source on which STMT is operating and N->range gives the\n+   size of the expression involved for maintaining some statistics.  */\n+\n+static bool\n+bswap_replace (gimple stmt, gimple_stmt_iterator *gsi, tree src, tree fndecl,\n+\t       tree bswap_type, tree load_type, struct symbolic_number *n,\n+\t       bool bswap)\n+{\n+  tree tmp, tgt;\n+  gimple call;\n+\n+  tgt = gimple_assign_lhs (stmt);\n+\n+  /* Need to load the value from memory first.  */\n+  if (n->base_addr)\n+    {\n+      tree addr_expr, addr_tmp, val_expr, val_tmp;\n+      tree load_offset_ptr, aligned_load_type;\n+      gimple addr_stmt, load_stmt;\n+      unsigned align;\n+\n+      align = get_object_alignment (src);\n+      if (bswap && SLOW_UNALIGNED_ACCESS (TYPE_MODE (load_type), align))\n+\treturn false;\n+\n+      /*  Compute address to load from and cast according to the size\n+\t  of the load.  */\n+      addr_expr = build_fold_addr_expr (unshare_expr (src));\n+      if (is_gimple_min_invariant (addr_expr))\n+\taddr_tmp = addr_expr;\n+      else\n+\t{\n+\t  addr_tmp = make_temp_ssa_name (TREE_TYPE (addr_expr), NULL,\n+\t\t\t\t\t \"load_src\");\n+\t  addr_stmt = gimple_build_assign (addr_tmp, addr_expr);\n+\t  gsi_insert_before (gsi, addr_stmt, GSI_SAME_STMT);\n+\t}\n+\n+      /* Perform the load.  */\n+      aligned_load_type = load_type;\n+      if (align < TYPE_ALIGN (load_type))\n+\taligned_load_type = build_aligned_type (load_type, align);\n+      load_offset_ptr = build_int_cst (n->alias_set, 0);\n+      val_expr = fold_build2 (MEM_REF, aligned_load_type, addr_tmp,\n+\t\t\t      load_offset_ptr);\n+\n+      if (!bswap)\n+\t{\n+\t  if (n->range == 16)\n+\t    nop_stats.found_16bit++;\n+\t  else if (n->range == 32)\n+\t    nop_stats.found_32bit++;\n+\t  else\n+\t    {\n+\t      gcc_assert (n->range == 64);\n+\t      nop_stats.found_64bit++;\n+\t    }\n+\n+\t  /* Convert the result of load if necessary.  */\n+\t  if (!useless_type_conversion_p (TREE_TYPE (tgt), load_type))\n+\t    {\n+\t      val_tmp = make_temp_ssa_name (aligned_load_type, NULL,\n+\t\t\t\t\t    \"load_dst\");\n+\t      load_stmt = gimple_build_assign (val_tmp, val_expr);\n+\t      gimple_set_vuse (load_stmt, n->vuse);\n+\t      gsi_insert_before (gsi, load_stmt, GSI_SAME_STMT);\n+\t      gimple_assign_set_rhs_with_ops_1 (gsi, NOP_EXPR, val_tmp,\n+\t\t\t\t\t\tNULL_TREE, NULL_TREE);\n+\t    }\n+\t  else\n+\t    gimple_assign_set_rhs_with_ops_1 (gsi, MEM_REF, val_expr,\n+\t\t\t\t\t      NULL_TREE, NULL_TREE);\n+\t  update_stmt (gsi_stmt (*gsi));\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"%d bit load in host endianness found at: \",\n+\t\t       (int)n->range);\n+\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t    }\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  val_tmp = make_temp_ssa_name (aligned_load_type, NULL, \"load_dst\");\n+\t  load_stmt = gimple_build_assign (val_tmp, val_expr);\n+\t  gimple_set_vuse (load_stmt, n->vuse);\n+\t  gsi_insert_before (gsi, load_stmt, GSI_SAME_STMT);\n+\t}\n+      src = val_tmp;\n+    }\n+\n+  if (n->range == 16)\n+    bswap_stats.found_16bit++;\n+  else if (n->range == 32)\n+    bswap_stats.found_32bit++;\n+  else\n+    {\n+      gcc_assert (n->range == 64);\n+      bswap_stats.found_64bit++;\n+    }\n+\n+  tmp = src;\n+\n+  /* Convert the src expression if necessary.  */\n+  if (!useless_type_conversion_p (TREE_TYPE (tmp), bswap_type))\n+    {\n+      gimple convert_stmt;\n+      tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapsrc\");\n+      convert_stmt = gimple_build_assign_with_ops (NOP_EXPR, tmp, src, NULL);\n+      gsi_insert_before (gsi, convert_stmt, GSI_SAME_STMT);\n+    }\n+\n+  call = gimple_build_call (fndecl, 1, tmp);\n+\n+  tmp = tgt;\n+\n+  /* Convert the result if necessary.  */\n+  if (!useless_type_conversion_p (TREE_TYPE (tgt), bswap_type))\n+    {\n+      gimple convert_stmt;\n+      tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n+      convert_stmt = gimple_build_assign_with_ops (NOP_EXPR, tgt, tmp, NULL);\n+      gsi_insert_after (gsi, convert_stmt, GSI_SAME_STMT);\n+    }\n+\n+  gimple_call_set_lhs (call, tmp);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%d bit bswap implementation found at: \",\n+\t       (int)n->range);\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+    }\n+\n+  gsi_insert_after (gsi, call, GSI_SAME_STMT);\n+  gsi_remove (gsi, true);\n+  return true;\n+}\n+\n+/* Find manual byte swap implementations as well as load in a given\n+   endianness. Byte swaps are turned into a bswap builtin invokation\n+   while endian loads are converted to bswap builtin invokation or\n+   simple load according to the host endianness.  */\n+\n unsigned int\n pass_optimize_bswap::execute (function *fun)\n {\n@@ -1946,9 +2279,6 @@ pass_optimize_bswap::execute (function *fun)\n \t       && (optab_handler (bswap_optab, DImode) != CODE_FOR_nothing\n \t\t   || (bswap32_p && word_mode == SImode)));\n \n-  if (!bswap16_p && !bswap32_p && !bswap64_p)\n-    return 0;\n-\n   /* Determine the argument type of the builtins.  The code later on\n      assumes that the return and argument type are the same.  */\n   if (bswap16_p)\n@@ -1969,6 +2299,7 @@ pass_optimize_bswap::execute (function *fun)\n       bswap64_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n     }\n \n+  memset (&nop_stats, 0, sizeof (nop_stats));\n   memset (&bswap_stats, 0, sizeof (bswap_stats));\n \n   FOR_EACH_BB_FN (bb, fun)\n@@ -1982,35 +2313,40 @@ pass_optimize_bswap::execute (function *fun)\n       for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n         {\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  tree bswap_src, bswap_type;\n-\t  tree bswap_tmp;\n-\t  tree fndecl = NULL_TREE;\n-\t  int type_size;\n-\t  gimple call;\n+\t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE;\n+\t  tree src, load_type;\n+\t  struct symbolic_number n;\n+\t  bool bswap;\n \n \t  if (!is_gimple_assign (stmt)\n \t      || gimple_assign_rhs_code (stmt) != BIT_IOR_EXPR)\n \t    continue;\n \n-\t  type_size = TYPE_PRECISION (gimple_expr_type (stmt));\n+\t  src = find_bswap_or_nop (stmt, &n, &bswap);\n+\n+\t  if (!src)\n+\t    continue;\n \n-\t  switch (type_size)\n+\t  switch (n.range)\n \t    {\n \t    case 16:\n+\t      load_type = uint16_type_node;\n \t      if (bswap16_p)\n \t\t{\n \t\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP16);\n \t\t  bswap_type = bswap16_type;\n \t\t}\n \t      break;\n \t    case 32:\n+\t      load_type = uint32_type_node;\n \t      if (bswap32_p)\n \t\t{\n \t\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP32);\n \t\t  bswap_type = bswap32_type;\n \t\t}\n \t      break;\n \t    case 64:\n+\t      load_type = uint64_type_node;\n \t      if (bswap64_p)\n \t\t{\n \t\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP64);\n@@ -2021,62 +2357,21 @@ pass_optimize_bswap::execute (function *fun)\n \t      continue;\n \t    }\n \n-\t  if (!fndecl)\n+\t  if (bswap && !fndecl)\n \t    continue;\n \n-\t  bswap_src = find_bswap (stmt);\n-\n-\t  if (!bswap_src)\n-\t    continue;\n-\n-\t  changed = true;\n-\t  if (type_size == 16)\n-\t    bswap_stats.found_16bit++;\n-\t  else if (type_size == 32)\n-\t    bswap_stats.found_32bit++;\n-\t  else\n-\t    bswap_stats.found_64bit++;\n-\n-\t  bswap_tmp = bswap_src;\n-\n-\t  /* Convert the src expression if necessary.  */\n-\t  if (!useless_type_conversion_p (TREE_TYPE (bswap_tmp), bswap_type))\n-\t    {\n-\t      gimple convert_stmt;\n-\t      bswap_tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapsrc\");\n-\t      convert_stmt = gimple_build_assign_with_ops\n-\t\t  \t\t(NOP_EXPR, bswap_tmp, bswap_src, NULL);\n-\t      gsi_insert_before (&gsi, convert_stmt, GSI_SAME_STMT);\n-\t    }\n-\n-\t  call = gimple_build_call (fndecl, 1, bswap_tmp);\n-\n-\t  bswap_tmp = gimple_assign_lhs (stmt);\n-\n-\t  /* Convert the result if necessary.  */\n-\t  if (!useless_type_conversion_p (TREE_TYPE (bswap_tmp), bswap_type))\n-\t    {\n-\t      gimple convert_stmt;\n-\t      bswap_tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n-\t      convert_stmt = gimple_build_assign_with_ops\n-\t\t\t(NOP_EXPR, gimple_assign_lhs (stmt), bswap_tmp, NULL);\n-\t      gsi_insert_after (&gsi, convert_stmt, GSI_SAME_STMT);\n-\t    }\n-\n-\t  gimple_call_set_lhs (call, bswap_tmp);\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"%d bit bswap implementation found at: \",\n-\t\t       (int)type_size);\n-\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t    }\n-\n-\t  gsi_insert_after (&gsi, call, GSI_SAME_STMT);\n-\t  gsi_remove (&gsi, true);\n+\t  if (bswap_replace (stmt, &gsi, src, fndecl, bswap_type, load_type,\n+\t\t\t     &n, bswap))\n+\t    changed = true;\n \t}\n     }\n \n+  statistics_counter_event (fun, \"16-bit nop implementations found\",\n+\t\t\t    nop_stats.found_16bit);\n+  statistics_counter_event (fun, \"32-bit nop implementations found\",\n+\t\t\t    nop_stats.found_32bit);\n+  statistics_counter_event (fun, \"64-bit nop implementations found\",\n+\t\t\t    nop_stats.found_64bit);\n   statistics_counter_event (fun, \"16-bit bswap implementations found\",\n \t\t\t    bswap_stats.found_16bit);\n   statistics_counter_event (fun, \"32-bit bswap implementations found\","}]}