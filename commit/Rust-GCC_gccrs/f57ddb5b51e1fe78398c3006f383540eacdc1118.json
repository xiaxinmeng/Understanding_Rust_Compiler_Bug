{"sha": "f57ddb5b51e1fe78398c3006f383540eacdc1118", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3ZGRiNWI1MWUxZmU3ODM5OGMzMDA2ZjM4MzU0MGVhY2RjMTExOA==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-04-03T20:51:28Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-04-03T20:51:28Z"}, "message": "This patch enables the gcov-dump tool to optionally compute and dump the working set information from the counter histogram...\n\nThis patch enables the gcov-dump tool to optionally compute and dump\nthe working set information from the counter histogram, via a new -w option.\nThis is useful to help understand and tune how the compiler will use\nthe counter histogram, since it first computes the working set and selects\nthresholds based on that.\n\nThis required moving the bulk of the compute_working_sets functionality\ninto gcov-io.c so that it was accessible by gcov-dump.c.\n\n2013-04-03  Teresa Johnson  <tejohnson@google.com>\n\n\t* gcov-io.c (compute_working_sets): Moved most of body of old\n        compute_working_sets here from profile.c.\n\t* gcov-io.h (NUM_GCOV_WORKING_SETS): Moved here from profile.c.\n        (gcov_working_set_t): Moved typedef here from basic-block.h\n        (compute_working_set): Declare.\n\t* profile.c (NUM_GCOV_WORKING_SETS): Moved to gcov-io.h.\n\t(get_working_sets): Renamed from compute_working_set,\n        replace most of body with call to new compute_working_sets.\n\t(get_exec_counts): Replace call to compute_working_sets\n        to get_working_sets.\n\t* profile.h (get_working_sets): Renamed from\n        compute_working_set.\n\t* lto-cgraph.c (input_symtab): Replace call to compute_working_sets\n        to get_working_sets.\n\t* basic-block.h (gcov_working_set_t): Moved to gcov-io.h.\n\t* gcov-dump.c (dump_working_sets): New function.\n\nFrom-SVN: r197457", "tree": {"sha": "adc203a589f57f6641e15408a2579a630f743208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adc203a589f57f6641e15408a2579a630f743208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57ddb5b51e1fe78398c3006f383540eacdc1118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57ddb5b51e1fe78398c3006f383540eacdc1118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57ddb5b51e1fe78398c3006f383540eacdc1118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57ddb5b51e1fe78398c3006f383540eacdc1118/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e0919f1eecbb00fdcf16ff7e064be122fd0bbfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0919f1eecbb00fdcf16ff7e064be122fd0bbfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0919f1eecbb00fdcf16ff7e064be122fd0bbfc"}], "stats": {"total": 314, "additions": 199, "deletions": 115}, "files": [{"sha": "52a8b36534d04ef1248e890f39e5065e26c3bf04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -1,3 +1,22 @@\n+2013-04-03  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* gcov-io.c (compute_working_sets): Moved most of body of old\n+        compute_working_sets here from profile.c.\n+\t* gcov-io.h (NUM_GCOV_WORKING_SETS): Moved here from profile.c.\n+        (gcov_working_set_t): Moved typedef here from basic-block.h\n+        (compute_working_set): Declare.\n+\t* profile.c (NUM_GCOV_WORKING_SETS): Moved to gcov-io.h.\n+\t(get_working_sets): Renamed from compute_working_set,\n+        replace most of body with call to new compute_working_sets.\n+\t(get_exec_counts): Replace call to compute_working_sets\n+        to get_working_sets.\n+\t* profile.h (get_working_sets): Renamed from\n+        compute_working_set.\n+\t* lto-cgraph.c (input_symtab): Replace call to compute_working_sets\n+        to get_working_sets.\n+\t* basic-block.h (gcov_working_set_t): Moved to gcov-io.h.\n+\t* gcov-dump.c (dump_working_sets): New function.\n+\n 2013-04-03  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \t* hwint.c (sext_hwi, zext_hwi): New functions."}, {"sha": "d8377308b7f007e0d50af25f21d5d02ca3a7eb51", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -87,16 +87,6 @@ enum cfg_edge_flags {\n    profile.c.  */\n extern const struct gcov_ctr_summary *profile_info;\n \n-/* Working set size statistics for a given percentage of the entire\n-   profile (sum_all from the counter summary).  */\n-typedef struct gcov_working_set_info\n-{\n-  /* Number of hot counters included in this working set.  */\n-  unsigned num_counters;\n-  /* Smallest counter included in this working set.  */\n-  gcov_type min_counter;\n-} gcov_working_set_t;\n-\n /* Structure to gather statistic about profile consistency, per pass.\n    An array of this structure, indexed by pass static number, is allocated\n    in passes.c.  The structure is defined here so that different CFG modes\n@@ -935,6 +925,7 @@ extern void rtl_profile_for_edge (edge);\n extern void default_rtl_profile (void);\n \n /* In profile.c.  */\n+typedef struct gcov_working_set_info gcov_working_set_t;\n extern gcov_working_set_t *find_working_set(unsigned pct_times_10);\n \n /* Check tha probability is sane.  */"}, {"sha": "7f8e23109f8c521d336b3fc3abe0e1394bbd75f2", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -38,6 +38,8 @@ static void tag_arcs (const char *, unsigned, unsigned);\n static void tag_lines (const char *, unsigned, unsigned);\n static void tag_counters (const char *, unsigned, unsigned);\n static void tag_summary (const char *, unsigned, unsigned);\n+static void dump_working_sets (const char *filename ATTRIBUTE_UNUSED,\n+                               const struct gcov_ctr_summary *summary);\n extern int main (int, char **);\n \n typedef struct tag_format\n@@ -49,13 +51,15 @@ typedef struct tag_format\n \n static int flag_dump_contents = 0;\n static int flag_dump_positions = 0;\n+static int flag_dump_working_sets = 0;\n \n static const struct option options[] =\n {\n   { \"help\",                 no_argument,       NULL, 'h' },\n   { \"version\",              no_argument,       NULL, 'v' },\n   { \"long\",                 no_argument,       NULL, 'l' },\n   { \"positions\",\t    no_argument,       NULL, 'o' },\n+  { \"working-sets\",\t    no_argument,       NULL, 'w' },\n   { 0, 0, 0, 0 }\n };\n \n@@ -93,7 +97,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n \n   diagnostic_initialize (global_dc, 0);\n \n-  while ((opt = getopt_long (argc, argv, \"hlpv\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"hlpvw\", options, NULL)) != -1)\n     {\n       switch (opt)\n \t{\n@@ -109,6 +113,9 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n \tcase 'p':\n \t  flag_dump_positions = 1;\n \t  break;\n+\tcase 'w':\n+\t  flag_dump_working_sets = 1;\n+\t  break;\n \tdefault:\n \t  fprintf (stderr, \"unknown flag `%c'\\n\", opt);\n \t}\n@@ -128,6 +135,7 @@ print_usage (void)\n   printf (\"  -v, --version        Print version number\\n\");\n   printf (\"  -l, --long           Dump record contents too\\n\");\n   printf (\"  -p, --positions      Dump record positions\\n\");\n+  printf (\"  -w, --working-sets   Dump working set computed from summary\\n\");\n }\n \n static void\n@@ -484,5 +492,39 @@ tag_summary (const char *filename ATTRIBUTE_UNUSED,\n               (HOST_WIDEST_INT)histo_bucket->min_value,\n               (HOST_WIDEST_INT)histo_bucket->cum_value);\n         }\n+      if (flag_dump_working_sets)\n+        dump_working_sets (filename, &summary.ctrs[ix]);\n+    }\n+}\n+\n+static void\n+dump_working_sets (const char *filename ATTRIBUTE_UNUSED,\n+                   const struct gcov_ctr_summary *summary)\n+{\n+  gcov_working_set_t gcov_working_sets[NUM_GCOV_WORKING_SETS];\n+  unsigned ws_ix, pctinc, pct;\n+  gcov_working_set_t *ws_info;\n+\n+  compute_working_sets (summary, gcov_working_sets);\n+\n+  printf (\"\\n\");\n+  print_prefix (filename, 0, 0);\n+  printf (\"\\t\\tcounter working sets:\");\n+  /* Multiply the percentage by 100 to avoid float.  */\n+  pctinc = 100 * 100 / NUM_GCOV_WORKING_SETS;\n+  for (ws_ix = 0, pct = pctinc; ws_ix < NUM_GCOV_WORKING_SETS;\n+       ws_ix++, pct += pctinc)\n+    {\n+      if (ws_ix == NUM_GCOV_WORKING_SETS - 1)\n+        pct = 9990;\n+      ws_info = &gcov_working_sets[ws_ix];\n+      /* Print out the percentage using int arithmatic to avoid float.  */\n+      printf (\"\\n\");\n+      print_prefix (filename, 0, 0);\n+      printf (\"\\t\\t%u.%02u%%: num counts=%u, min counter=\"\n+               HOST_WIDEST_INT_PRINT_DEC,\n+               pct / 100, pct - (pct / 100 * 100),\n+               ws_info->num_counters,\n+               (HOST_WIDEST_INT)ws_info->min_counter);\n     }\n }"}, {"sha": "441aad92833dbc353ffab137d54e53f3ce263d80", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -837,3 +837,110 @@ static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n   memcpy(tgt_histo, tmp_histo, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n }\n #endif /* !IN_GCOV */\n+\n+/* This is used by gcov-dump (IN_GCOV == -1) and in the compiler\n+   (!IN_GCOV && !IN_LIBGCOV).  */\n+#if IN_GCOV <= 0 && !IN_LIBGCOV\n+/* Compute the working set information from the counter histogram in\n+   the profile summary. This is an array of information corresponding to a\n+   range of percentages of the total execution count (sum_all), and includes\n+   the number of counters required to cover that working set percentage and\n+   the minimum counter value in that working set.  */\n+\n+GCOV_LINKAGE void\n+compute_working_sets (const struct gcov_ctr_summary *summary,\n+                      gcov_working_set_t *gcov_working_sets)\n+{\n+  gcov_type working_set_cum_values[NUM_GCOV_WORKING_SETS];\n+  gcov_type ws_cum_hotness_incr;\n+  gcov_type cum, tmp_cum;\n+  const gcov_bucket_type *histo_bucket;\n+  unsigned ws_ix, c_num, count;\n+  int h_ix;\n+\n+  /* Compute the amount of sum_all that the cumulative hotness grows\n+     by in each successive working set entry, which depends on the\n+     number of working set entries.  */\n+  ws_cum_hotness_incr = summary->sum_all / NUM_GCOV_WORKING_SETS;\n+\n+  /* Next fill in an array of the cumulative hotness values corresponding\n+     to each working set summary entry we are going to compute below.\n+     Skip 0% statistics, which can be extrapolated from the\n+     rest of the summary data.  */\n+  cum = ws_cum_hotness_incr;\n+  for (ws_ix = 0; ws_ix < NUM_GCOV_WORKING_SETS;\n+       ws_ix++, cum += ws_cum_hotness_incr)\n+    working_set_cum_values[ws_ix] = cum;\n+  /* The last summary entry is reserved for (roughly) 99.9% of the\n+     working set. Divide by 1024 so it becomes a shift, which gives\n+     almost exactly 99.9%.  */\n+  working_set_cum_values[NUM_GCOV_WORKING_SETS-1]\n+      = summary->sum_all - summary->sum_all/1024;\n+\n+  /* Next, walk through the histogram in decending order of hotness\n+     and compute the statistics for the working set summary array.\n+     As histogram entries are accumulated, we check to see which\n+     working set entries have had their expected cum_value reached\n+     and fill them in, walking the working set entries in increasing\n+     size of cum_value.  */\n+  ws_ix = 0; /* The current entry into the working set array.  */\n+  cum = 0; /* The current accumulated counter sum.  */\n+  count = 0; /* The current accumulated count of block counters.  */\n+  for (h_ix = GCOV_HISTOGRAM_SIZE - 1;\n+       h_ix >= 0 && ws_ix < NUM_GCOV_WORKING_SETS; h_ix--)\n+    {\n+      histo_bucket = &summary->histogram[h_ix];\n+\n+      /* If we haven't reached the required cumulative counter value for\n+         the current working set percentage, simply accumulate this histogram\n+         entry into the running sums and continue to the next histogram\n+         entry.  */\n+      if (cum + histo_bucket->cum_value < working_set_cum_values[ws_ix])\n+        {\n+          cum += histo_bucket->cum_value;\n+          count += histo_bucket->num_counters;\n+          continue;\n+        }\n+\n+      /* If adding the current histogram entry's cumulative counter value\n+         causes us to exceed the current working set size, then estimate\n+         how many of this histogram entry's counter values are required to\n+         reach the working set size, and fill in working set entries\n+         as we reach their expected cumulative value.  */\n+      for (c_num = 0, tmp_cum = cum;\n+           c_num < histo_bucket->num_counters && ws_ix < NUM_GCOV_WORKING_SETS;\n+           c_num++)\n+        {\n+          count++;\n+          /* If we haven't reached the last histogram entry counter, add\n+             in the minimum value again. This will underestimate the\n+             cumulative sum so far, because many of the counter values in this\n+             entry may have been larger than the minimum. We could add in the\n+             average value every time, but that would require an expensive\n+             divide operation.  */\n+          if (c_num + 1 < histo_bucket->num_counters)\n+            tmp_cum += histo_bucket->min_value;\n+          /* If we have reached the last histogram entry counter, then add\n+             in the entire cumulative value.  */\n+          else\n+            tmp_cum = cum + histo_bucket->cum_value;\n+\n+\t  /* Next walk through successive working set entries and fill in\n+\t     the statistics for any whose size we have reached by accumulating\n+\t     this histogram counter.  */\n+\t  while (ws_ix < NUM_GCOV_WORKING_SETS\n+\t\t && tmp_cum >= working_set_cum_values[ws_ix])\n+            {\n+              gcov_working_sets[ws_ix].num_counters = count;\n+              gcov_working_sets[ws_ix].min_counter\n+                  = histo_bucket->min_value;\n+              ws_ix++;\n+            }\n+        }\n+      /* Finally, update the running cumulative value since we were\n+         using a temporary above.  */\n+      cum += histo_bucket->cum_value;\n+    }\n+  gcc_assert (ws_ix == NUM_GCOV_WORKING_SETS);\n+}\n+#endif /* IN_GCOV <= 0 && !IN_LIBGCOV */"}, {"sha": "08fe7b9240a2d537b0c11d0db567146747aa8739", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -617,6 +617,28 @@ GCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\n GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n #endif\n \n+#if IN_GCOV <= 0 && !IN_LIBGCOV\n+/* Available in gcov-dump and the compiler.  */\n+\n+/* Number of data points in the working set summary array. Using 128\n+   provides information for at least every 1% increment of the total\n+   profile size. The last entry is hardwired to 99.9% of the total.  */\n+#define NUM_GCOV_WORKING_SETS 128\n+\n+/* Working set size statistics for a given percentage of the entire\n+   profile (sum_all from the counter summary).  */\n+typedef struct gcov_working_set_info\n+{\n+  /* Number of hot counters included in this working set.  */\n+  unsigned num_counters;\n+  /* Smallest counter included in this working set.  */\n+  gcov_type min_counter;\n+} gcov_working_set_t;\n+\n+GCOV_LINKAGE void compute_working_sets (const struct gcov_ctr_summary *summary,\n+                                        gcov_working_set_t *gcov_working_sets);\n+#endif\n+\n #if IN_GCOV > 0\n /* Available in gcov */\n GCOV_LINKAGE time_t gcov_time (void);"}, {"sha": "ac92e90d7b59af18f420ef904e1b6df6a6d5c5cb", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -1466,7 +1466,7 @@ input_symtab (void)\n     }\n \n   merge_profile_summaries (file_data_vec);\n-  compute_working_sets ();\n+  get_working_sets ();\n \n \n   /* Clear out the aux field that was used to store enough state to"}, {"sha": "4b8be4483c192cd68ff00eeb3e92fefba1d71f93", "filename": "gcc/profile.c", "status": "modified", "additions": 5, "deletions": 102, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -82,11 +82,6 @@ struct bb_info {\n \n const struct gcov_ctr_summary *profile_info;\n \n-/* Number of data points in the working set summary array. Using 128\n-   provides information for at least every 1% increment of the total\n-   profile size. The last entry is hardwired to 99.9% of the total.  */\n-#define NUM_GCOV_WORKING_SETS 128\n-\n /* Counter working set information computed from the current counter\n    summary. Not initialized unless profile_info summary is non-NULL.  */\n static gcov_working_set_t gcov_working_sets[NUM_GCOV_WORKING_SETS];\n@@ -199,110 +194,18 @@ instrument_values (histogram_values values)\n }\n \f\n \n-/* Compute the working set information from the counter histogram in\n-   the profile summary. This is an array of information corresponding to a\n-   range of percentages of the total execution count (sum_all), and includes\n-   the number of counters required to cover that working set percentage and\n-   the minimum counter value in that working set.  */\n+/* Fill the working set information into the profile_info structure.  */\n \n void\n-compute_working_sets (void)\n+get_working_sets (void)\n {\n-  gcov_type working_set_cum_values[NUM_GCOV_WORKING_SETS];\n-  gcov_type ws_cum_hotness_incr;\n-  gcov_type cum, tmp_cum;\n-  const gcov_bucket_type *histo_bucket;\n-  unsigned ws_ix, c_num, count, pctinc, pct;\n-  int h_ix;\n+  unsigned ws_ix, pctinc, pct;\n   gcov_working_set_t *ws_info;\n \n   if (!profile_info)\n     return;\n \n-  /* Compute the amount of sum_all that the cumulative hotness grows\n-     by in each successive working set entry, which depends on the\n-     number of working set entries.  */\n-  ws_cum_hotness_incr = profile_info->sum_all / NUM_GCOV_WORKING_SETS;\n-\n-  /* Next fill in an array of the cumulative hotness values corresponding\n-     to each working set summary entry we are going to compute below.\n-     Skip 0% statistics, which can be extrapolated from the\n-     rest of the summary data.  */\n-  cum = ws_cum_hotness_incr;\n-  for (ws_ix = 0; ws_ix < NUM_GCOV_WORKING_SETS;\n-       ws_ix++, cum += ws_cum_hotness_incr)\n-    working_set_cum_values[ws_ix] = cum;\n-  /* The last summary entry is reserved for (roughly) 99.9% of the\n-     working set. Divide by 1024 so it becomes a shift, which gives\n-     almost exactly 99.9%.  */\n-  working_set_cum_values[NUM_GCOV_WORKING_SETS-1]\n-      = profile_info->sum_all - profile_info->sum_all/1024;\n-\n-  /* Next, walk through the histogram in decending order of hotness\n-     and compute the statistics for the working set summary array.\n-     As histogram entries are accumulated, we check to see which\n-     working set entries have had their expected cum_value reached\n-     and fill them in, walking the working set entries in increasing\n-     size of cum_value.  */\n-  ws_ix = 0; /* The current entry into the working set array.  */\n-  cum = 0; /* The current accumulated counter sum.  */\n-  count = 0; /* The current accumulated count of block counters.  */\n-  for (h_ix = GCOV_HISTOGRAM_SIZE - 1;\n-       h_ix >= 0 && ws_ix < NUM_GCOV_WORKING_SETS; h_ix--)\n-    {\n-      histo_bucket = &profile_info->histogram[h_ix];\n-\n-      /* If we haven't reached the required cumulative counter value for\n-         the current working set percentage, simply accumulate this histogram\n-         entry into the running sums and continue to the next histogram\n-         entry.  */\n-      if (cum + histo_bucket->cum_value < working_set_cum_values[ws_ix])\n-        {\n-          cum += histo_bucket->cum_value;\n-          count += histo_bucket->num_counters;\n-          continue;\n-        }\n-\n-      /* If adding the current histogram entry's cumulative counter value\n-         causes us to exceed the current working set size, then estimate\n-         how many of this histogram entry's counter values are required to\n-         reach the working set size, and fill in working set entries\n-         as we reach their expected cumulative value.  */\n-      for (c_num = 0, tmp_cum = cum;\n-           c_num < histo_bucket->num_counters && ws_ix < NUM_GCOV_WORKING_SETS;\n-           c_num++)\n-        {\n-          count++;\n-          /* If we haven't reached the last histogram entry counter, add\n-             in the minimum value again. This will underestimate the\n-             cumulative sum so far, because many of the counter values in this\n-             entry may have been larger than the minimum. We could add in the\n-             average value every time, but that would require an expensive\n-             divide operation.  */\n-          if (c_num + 1 < histo_bucket->num_counters)\n-            tmp_cum += histo_bucket->min_value;\n-          /* If we have reached the last histogram entry counter, then add\n-             in the entire cumulative value.  */\n-          else\n-            tmp_cum = cum + histo_bucket->cum_value;\n-\n-\t  /* Next walk through successive working set entries and fill in\n-\t     the statistics for any whose size we have reached by accumulating\n-\t     this histogram counter.  */\n-\t  while (ws_ix < NUM_GCOV_WORKING_SETS\n-\t\t && tmp_cum >= working_set_cum_values[ws_ix])\n-            {\n-              gcov_working_sets[ws_ix].num_counters = count;\n-              gcov_working_sets[ws_ix].min_counter\n-                  = histo_bucket->min_value;\n-              ws_ix++;\n-            }\n-        }\n-      /* Finally, update the running cumulative value since we were\n-         using a temporary above.  */\n-      cum += histo_bucket->cum_value;\n-    }\n-  gcc_assert (ws_ix == NUM_GCOV_WORKING_SETS);\n+  compute_working_sets (profile_info, gcov_working_sets);\n \n   if (dump_file)\n     {\n@@ -372,7 +275,7 @@ get_exec_counts (unsigned cfg_checksum, unsigned lineno_checksum)\n   if (!counts)\n     return NULL;\n \n-  compute_working_sets();\n+  get_working_sets();\n \n   if (dump_file && profile_info)\n     fprintf(dump_file, \"Merged %u profiles with maximal count %u.\\n\","}, {"sha": "d0b637de53b1948e2409a39d846b9cd5fa978989", "filename": "gcc/profile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ddb5b51e1fe78398c3006f383540eacdc1118/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=f57ddb5b51e1fe78398c3006f383540eacdc1118", "patch": "@@ -46,7 +46,7 @@ extern gcov_type sum_edge_counts (vec<edge, va_gc> *edges);\n extern void init_node_map (void);\n extern void del_node_map (void);\n \n-extern void compute_working_sets (void);\n+extern void get_working_sets (void);\n \n /* In predict.c.  */\n extern gcov_type get_hot_bb_threshold (void);"}]}