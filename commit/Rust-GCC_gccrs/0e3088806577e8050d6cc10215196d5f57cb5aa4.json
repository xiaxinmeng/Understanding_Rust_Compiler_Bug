{"sha": "0e3088806577e8050d6cc10215196d5f57cb5aa4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzMDg4ODA2NTc3ZTgwNTBkNmNjMTAyMTUxOTZkNWY1N2NiNWFhNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-03-12T13:40:51Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-03-12T13:40:51Z"}, "message": "re PR fortran/89363 (RANK incorrect for unallocated allocatable)\n\n2019-03-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89363\n\tPR fortran/89364\n\t* trans-expr.c (set_dtype_for_unallocated): New function.\n\t(gfc_conv_gfc_desc_to_cfi_desc): Call it for allocatable and\n\tpointer arguments.\n\t(gfc_conv_procedure_call): Likewise. Also, set the ubound of\n\tthe final dimension to -1 for assumed rank formal args that are\n\tassociated with assumed size arrays.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Return -1 for\n\tthe final dimension of assumed rank entities that are argument\n\tassociated with assumed size arrays.\n\t(gfc_conv_intrinsic_shape): Likewise return -1 for the final\n\tdimension of the shape intrinsic.\n\n2019-03-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89363\n\t* gfortran.dg/assumed_rank_16.f90: New test.\n\n\tPR fortran/89364\n\t* gfortran.dg/assumed_rank_17.f90: New test.\n\nFrom-SVN: r269612", "tree": {"sha": "8ddc5bde47fc6618007675a7a1be96502119d73d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ddc5bde47fc6618007675a7a1be96502119d73d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3088806577e8050d6cc10215196d5f57cb5aa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3088806577e8050d6cc10215196d5f57cb5aa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3088806577e8050d6cc10215196d5f57cb5aa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3088806577e8050d6cc10215196d5f57cb5aa4/comments", "author": null, "committer": null, "parents": [{"sha": "c9634470ba8b918c01a7680740cf9ea13ca06967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9634470ba8b918c01a7680740cf9ea13ca06967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9634470ba8b918c01a7680740cf9ea13ca06967"}], "stats": {"total": 268, "additions": 264, "deletions": 4}, "files": [{"sha": "9cefe39bfb8b2c92ded0ee0e856e8c6862be4b1d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e3088806577e8050d6cc10215196d5f57cb5aa4", "patch": "@@ -1,3 +1,19 @@\n+2019-03-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89363\n+\tPR fortran/89364\n+\t* trans-expr.c (set_dtype_for_unallocated): New function.\n+\t(gfc_conv_gfc_desc_to_cfi_desc): Call it for allocatable and\n+\tpointer arguments.\n+\t(gfc_conv_procedure_call): Likewise. Also, set the ubound of\n+\tthe final dimension to -1 for assumed rank formal args that are\n+\tassociated with assumed size arrays.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Return -1 for\n+\tthe final dimension of assumed rank entities that are argument\n+\tassociated with assumed size arrays.\n+\t(gfc_conv_intrinsic_shape): Likewise return -1 for the final\n+\tdimension of the shape intrinsic.\n+\n 2019-03-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/89651"}, {"sha": "1a48e73a9f868e238713cce29cbb4e16c94fc122", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0e3088806577e8050d6cc10215196d5f57cb5aa4", "patch": "@@ -4919,6 +4919,52 @@ expr_may_alias_variables (gfc_expr *e, bool array_may_alias)\n }\n \n \n+/* A helper function to set the dtype for unallocated or unassociated\n+   entities.  */\n+\n+static void\n+set_dtype_for_unallocated (gfc_se *parmse, gfc_expr *e)\n+{\n+  tree tmp;\n+  tree desc;\n+  tree cond;\n+  tree type;\n+  stmtblock_t block;\n+\n+  /* TODO Figure out how to handle optional dummies.  */\n+  if (e && e->expr_type == EXPR_VARIABLE\n+      && e->symtree->n.sym->attr.optional)\n+    return;\n+\n+  desc = parmse->expr;\n+  if (desc == NULL_TREE)\n+    return;\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (desc)))\n+    desc = build_fold_indirect_ref_loc (input_location, desc);\n+\n+  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    return;\n+\n+  gfc_init_block (&block);\n+  tmp = gfc_conv_descriptor_data_get (desc);\n+  cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t  logical_type_node, tmp,\n+\t\t\t  build_int_cst (TREE_TYPE (tmp), 0));\n+  tmp = gfc_conv_descriptor_dtype (desc);\n+  type = gfc_get_element_type (TREE_TYPE (desc));\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t TREE_TYPE (tmp), tmp,\n+\t\t\t gfc_get_dtype_rank_type (e->rank, type));\n+  gfc_add_expr_to_block (&block, tmp);\n+  cond = build3_v (COND_EXPR, cond,\n+\t\t   gfc_finish_block (&block),\n+\t\t   build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&parmse->pre, cond);\n+}\n+\n+\n+\n /* Provide an interface between gfortran array descriptors and the F2018:18.4\n    ISO_Fortran_binding array descriptors. */\n \n@@ -4958,6 +5004,15 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \tparmse->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t    parmse->expr);\n \n+      /* Unallocated allocatable arrays and unassociated pointer arrays\n+\t need their dtype setting if they are argument associated with\n+\t assumed rank dummies.  */\n+      if (fsym && fsym->as\n+\t  && fsym->as->type == AS_ASSUMED_RANK\n+\t  && (gfc_expr_attr (e).pointer\n+\t      || gfc_expr_attr (e).allocatable))\n+\tset_dtype_for_unallocated (parmse, e);\n+\n       /* All the temporary descriptors are marked as DECL_ARTIFICIAL. If\n \t the expression type is different from the descriptor type, then\n \t the offset must be found (eg. to a component ref or substring)\n@@ -5953,6 +6008,30 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,\n \t\t\t\t\t  sym->name, NULL);\n \n+\t      /* Unallocated allocatable arrays and unassociated pointer arrays\n+\t\t need their dtype setting if they are argument associated with\n+\t\t assumed rank dummies.  */\n+\t      if (!sym->attr.is_bind_c && e && fsym && fsym->as\n+\t\t  && fsym->as->type == AS_ASSUMED_RANK)\n+\t\t{\n+\t\t  if (gfc_expr_attr (e).pointer\n+\t\t      || gfc_expr_attr (e).allocatable)\n+\t\t    set_dtype_for_unallocated (&parmse, e);\n+\t\t  else if (e->expr_type == EXPR_VARIABLE\n+\t\t\t   && e->symtree->n.sym->attr.dummy\n+\t\t\t   && e->symtree->n.sym->as\n+\t\t\t   && e->symtree->n.sym->as->type == AS_ASSUMED_SIZE)\n+\t\t    {\n+\t\t      tree minus_one;\n+\t\t      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t parmse.expr);\n+\t\t      minus_one = build_int_cst (gfc_array_index_type, -1);\n+\t\t      gfc_conv_descriptor_ubound_set (&parmse.pre, tmp,\n+\t\t\t\t\t\t      gfc_rank_cst[e->rank - 1],\n+\t\t\t\t\t\t      minus_one);\n+ \t\t    }\n+\t\t}\n+\n \t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is\n \t\t allocated on entry, it must be deallocated.  */\n \t      if (fsym && fsym->attr.allocatable"}, {"sha": "2eb5d1ae6f7ea9e1ba6dbc31565965ea5c3e19c4", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0e3088806577e8050d6cc10215196d5f57cb5aa4", "patch": "@@ -2873,7 +2873,7 @@ gfc_conv_intrinsic_is_contiguous (gfc_se * se, gfc_expr * expr)\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n       desc = gfc_evaluate_now (argse.expr, &se->pre);\n-  \n+\n       stride = gfc_conv_descriptor_stride_get (desc, gfc_rank_cst[0]);\n       cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n \t\t\t      stride, build_int_cst (TREE_TYPE (stride), 1));\n@@ -3103,6 +3103,29 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \tse->expr = gfc_index_one_node;\n     }\n \n+  /* According to F2018 16.9.172, para 5, an assumed rank object, argument\n+     associated with and assumed size array, has the ubound of the final\n+     dimension set to -1 and UBOUND must return this.  */\n+  if (upper && as && as->type == AS_ASSUMED_RANK)\n+    {\n+      tree minus_one = build_int_cst (gfc_array_index_type, -1);\n+      tree rank = fold_convert (gfc_array_index_type,\n+\t\t\t\tgfc_conv_descriptor_rank (desc));\n+      rank = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t      gfc_array_index_type, rank, minus_one);\n+      /* Fix the expression to stop it from becoming even more complicated.  */\n+      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+      cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t     logical_type_node, bound, rank);\n+      cond1 = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t       logical_type_node, ubound, minus_one);\n+      cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t      logical_type_node, cond, cond1);\n+      se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t  gfc_array_index_type, cond,\n+\t\t\t\t  se->expr, minus_one);\n+    }\n+\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, se->expr);\n }\n@@ -6243,6 +6266,8 @@ gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n {\n   gfc_actual_arglist *s, *k;\n   gfc_expr *e;\n+  gfc_array_spec *as;\n+  gfc_ss *ss;\n \n   /* Remove the KIND argument, if present. */\n   s = expr->value.function.actual;\n@@ -6252,6 +6277,59 @@ gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n   k->expr = NULL;\n \n   gfc_conv_intrinsic_funcall (se, expr);\n+\n+  as = gfc_get_full_arrayspec_from_expr (s->expr);;\n+  ss = gfc_walk_expr (s->expr);\n+\n+  /* According to F2018 16.9.172, para 5, an assumed rank entity, argument\n+     associated with an assumed size array, has the ubound of the final\n+     dimension set to -1 and SHAPE must return this.  */\n+  if (as && as->type == AS_ASSUMED_RANK\n+      && se->expr && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se->expr))\n+      && ss && ss->info->type == GFC_SS_SECTION)\n+    {\n+      tree desc, rank, minus_one, cond, ubound, tmp;\n+      stmtblock_t block;\n+      gfc_se ase;\n+\n+      minus_one = build_int_cst (gfc_array_index_type, -1);\n+\n+      /* Recover the descriptor for the array.  */\n+      gfc_init_se (&ase, NULL);\n+      ase.descriptor_only = 1;\n+      gfc_conv_expr_lhs (&ase, ss->info->expr);\n+\n+      /* Obtain rank-1 so that we can address both descriptors.  */\n+      rank = gfc_conv_descriptor_rank (ase.expr);\n+      rank = fold_convert (gfc_array_index_type, rank);\n+      rank = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t      gfc_array_index_type,\n+\t\t\t      rank, minus_one);\n+      rank = gfc_evaluate_now (rank, &se->pre);\n+\n+      /* The ubound for the final dimension will be tested for being -1.  */\n+      ubound = gfc_conv_descriptor_ubound_get (ase.expr, rank);\n+      ubound = gfc_evaluate_now (ubound, &se->pre);\n+      cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t     logical_type_node,\n+\t\t\t     ubound, minus_one);\n+\n+      /* Obtain the last element of the result from the library shape\n+\t intrinsic and set it to -1 if that is the value of ubound.  */\n+      desc = se->expr;\n+      tmp = gfc_conv_array_data (desc);\n+      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+      tmp = gfc_build_array_ref (tmp, rank, NULL, NULL);\n+\n+      gfc_init_block (&block);\n+      gfc_add_modify (&block, tmp, build_int_cst (TREE_TYPE (tmp), -1));\n+\n+      cond = build3_v (COND_EXPR, cond,\n+\t\t       gfc_finish_block (&block),\n+\t\t       build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&se->pre, cond);\n+    }\n+\n }\n \n static void\n@@ -10390,7 +10468,7 @@ gfc_inline_intrinsic_function_p (gfc_expr *expr)\n \t  && maskexpr->symtree->n.sym->attr.dummy\n \t  && maskexpr->symtree->n.sym->attr.optional)\n \treturn false;\n-\t  \n+\n       return true;\n \n     case GFC_ISYM_TRANSPOSE:"}, {"sha": "baba609ada11482dbe80991be8b91b421a14a19e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e3088806577e8050d6cc10215196d5f57cb5aa4", "patch": "@@ -1,3 +1,11 @@\n+2019-03-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89363\n+\t* gfortran.dg/assumed_rank_16.f90: New test.\n+\n+\tPR fortran/89364\n+\t* gfortran.dg/assumed_rank_17.f90: New test.\n+\n 2019-03-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/89663\n@@ -731,7 +739,7 @@\n 2019-02-25  Dominique d'Humieres  <dominiq@gcc.gnu.org>\n \n \tPR fortran/89282\n-\t* gfortran.dg/overload_3.f90: New test. \n+\t* gfortran.dg/overload_3.f90: New test.\n \n 2019-02-25  Jakub Jelinek  <jakub@redhat.com>\n \n@@ -741,7 +749,7 @@\n 2019-02-25  Dominique d'Humieres  <dominiq@gcc.gnu.org>\n \n \tPR libfortran/89274\n-\t* gfortran.dg/list_directed_large.f90: New test. \n+\t* gfortran.dg/list_directed_large.f90: New test.\n \n 2019-02-25  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "6d8797e0cded1122979440a93092a430aa7bd99a", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_16.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_16.f90?ref=0e3088806577e8050d6cc10215196d5f57cb5aa4", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR89363, in which the rank of unallocated or unassociated\n+! entities, argument associated with assumed rank dummies, was not being set.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_ass_rank_02\n+  implicit none\n+contains\n+  subroutine procr(this,flag)\n+    real, allocatable :: this(..)\n+    logical :: flag\n+    if (rank(this) /= 2 .or. allocated(this)) then\n+       write(*,*) 'FAIL procr', rank(this), allocated(this)\n+       flag = .FALSE.\n+     end if\n+  end subroutine procr\n+  subroutine procs(this,flag)\n+    real, allocatable :: this(..)\n+    logical :: flag\n+    if (rank(this) /= 2 .or. .not. allocated(this)) then\n+       write(*,*) 'FAIL procs status', rank(this), allocated(this)\n+       flag = .FALSE.\n+     end if\n+     if (size(this,1) /= 2 .and. size(this,2) /= 5) then\n+       write(*,*) 'FAIL procs shape', size(this)\n+       flag = .FALSE.\n+     end if\n+  end subroutine procs\n+end module mod_ass_rank_02\n+program ass_rank_02\n+  use mod_ass_rank_02\n+  implicit none\n+  real, allocatable :: x(:,:)\n+  logical :: flag\n+\n+  flag = .TRUE.\n+  call procr(x,flag)\n+  if (.not.flag) stop 1\n+  allocate(x(2,5))\n+  call procs(x,flag)\n+  if (.not.flag) stop 2\n+  deallocate(x)\n+end program ass_rank_02"}, {"sha": "ec78bafd9519cae6fc15b7991ff40127c8d630b3", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_17.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3088806577e8050d6cc10215196d5f57cb5aa4/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_17.f90?ref=0e3088806577e8050d6cc10215196d5f57cb5aa4", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR89364, in which the ubound and the last element of\n+! shape were note returning -1 for assumed rank entities, argument\n+! associated with assumed size dummies.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_ass_rank_04\n+  implicit none\n+contains\n+  subroutine si(this)\n+    real :: this(4, *)\n+    call sa(this)\n+  end subroutine si\n+  subroutine sa(this)\n+    real :: this(..)\n+    if (rank(this) /= 2) then\n+       stop 1\n+    end if\n+    if (maxval(abs(shape(this) - [4,-1])) > 0) then\n+       stop 2\n+    end if\n+    if (ubound(this,2) /= lbound(this,2) - 2) then\n+       stop 3\n+    end if\n+  end subroutine sa\n+end module mod_ass_rank_04\n+program ass_rank_04\n+  use mod_ass_rank_04\n+  implicit none\n+  real :: y(9)\n+  call si(y(2))\n+end program ass_rank_04"}]}