{"sha": "8469e54e147147ee65ee899b20fd68493af85327", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2OWU1NGUxNDcxNDdlZTY1ZWU4OTliMjBmZDY4NDkzYWY4NTMyNw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-01-29T17:19:58Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-01-29T17:19:58Z"}, "message": "re PR c/3325 (cast of bit-field to same type gets discarded)\n\n\tPR c/3325\n\t* c-decl.c (enum_decl_context): Remove BITFIELD.\n\t(grokdeclarator): Take bitfield width as an input.\n\tEnsure bitfields are given the correct type.  Perform\n\tbitfield width validation with build_bitfield_integer_type\n\trather than waiting for finish_struct.\n\t(grok_typename, grok_typename_in_parm_context, start_decl,\n\tpush_parmdecl, grokfield, start_function): Update calls to\n\tgrokdeclarator.\n\t(build_bitfield_integer_type): New function.\n\t(finish_struct): Move bitfield validation to grokdeclarator\n\tand build_bitfield_integer_type.\n\t* tree.c (build_nonstandard_integer_type): New function.\n\t* tree.h (build_nonstandard_integer_type): New prototype.\nobjc:\n\t* objc-act.c (objc_copy_list): Remove DECL_INITIAL kludge.\ntestsuite:\n\t* gcc.c-torture/compile/20000224-1.c: Update.\n\t* gcc.c-torture/execute/bitfld-1.c: New tests.\n\t* gcc.dg/bitfld-1.c, bitfld-2.c: Diagnostic tests.\n\t* gcc.dg/uninit-A.c: Update.\n\nFrom-SVN: r49321", "tree": {"sha": "21de1159c8ed89bada613b376351f07531e6dca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21de1159c8ed89bada613b376351f07531e6dca3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8469e54e147147ee65ee899b20fd68493af85327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8469e54e147147ee65ee899b20fd68493af85327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8469e54e147147ee65ee899b20fd68493af85327", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8469e54e147147ee65ee899b20fd68493af85327/comments", "author": null, "committer": null, "parents": [{"sha": "6c54b16cef90d93555a96dc3542fea96b8a4c7fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c54b16cef90d93555a96dc3542fea96b8a4c7fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c54b16cef90d93555a96dc3542fea96b8a4c7fc"}], "stats": {"total": 414, "additions": 291, "deletions": 123}, "files": [{"sha": "a0f5e3126eaab49ccb4d25fbcc255aa545b5bdde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -1,3 +1,22 @@\n+2002-01-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\tPR c/3325, c/3326, c/2511, c/3347\n+\t* c-decl.c (enum_decl_context): Remove BITFIELD.\n+\t(grokdeclarator): Take bitfield width as an input.\n+\tEnsure bitfields are given the correct type.  Perform\n+\tbitfield width validation with build_bitfield_integer_type\n+\trather than waiting for finish_struct.\n+\t(grok_typename, grok_typename_in_parm_context, start_decl,\n+\tpush_parmdecl, grokfield, start_function): Update calls to\n+\tgrokdeclarator.\n+\t(build_bitfield_integer_type): New function.\n+\t(finish_struct): Move bitfield validation to grokdeclarator\n+\tand build_bitfield_integer_type. \n+\t* tree.c (build_nonstandard_integer_type): New function.\n+\t* tree.h (build_nonstandard_integer_type): New prototype.\n+objc:\n+\t* objc-act.c (objc_copy_list): Remove DECL_INITIAL kludge.\n+\n 2002-01-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/1502:"}, {"sha": "ad2380931aacfd3a21263b7a4908cf3fe8806ff4", "filename": "gcc/c-decl.c", "status": "modified", "additions": 137, "deletions": 114, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -53,7 +53,6 @@ enum decl_context\n   FUNCDEF,\t\t\t/* Function definition */\n   PARM,\t\t\t\t/* Declaration of parm before function body */\n   FIELD,\t\t\t/* Declaration inside struct or union */\n-  BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME};\t\t\t/* Typename (inside cast or sizeof)  */\n \n \f\n@@ -276,12 +275,13 @@ static tree lookup_tag\t\t\tPARAMS ((enum tree_code, tree,\n \t\t\t\t\t\t struct binding_level *, int));\n static tree lookup_tag_reverse\t\tPARAMS ((tree));\n static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n-\t\t\t\t\t\t int));\n+\t\t\t\t\t\t int, tree));\n static tree grokparms\t\t\tPARAMS ((tree, int));\n static void layout_array_type\t\tPARAMS ((tree));\n static tree c_make_fname_decl           PARAMS ((tree, int));\n static void c_expand_body               PARAMS ((tree, int, int));\n static void warn_if_shadowing\t\tPARAMS ((tree, tree));\n+static tree build_bitfield_integer_type\tPARAMS ((tree, tree, const char *));\n \f\n /* C-specific option variables.  */\n \n@@ -319,7 +319,7 @@ int flag_noniso_default_format_attributes = 1;\n    being traditional.  */\n int flag_allow_single_precision = 0;\n \n-/* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */\n+/* Nonzero means to treat bit-fields as signed unless they say `unsigned'.  */\n \n int flag_signed_bitfields = 1;\n int explicit_flag_signed_bitfields = 0;\n@@ -3390,7 +3390,8 @@ groktypename (typename)\n \n   split_specs_attrs (TREE_PURPOSE (typename), &specs, &attrs);\n \n-  typename = grokdeclarator (TREE_VALUE (typename), specs, TYPENAME, 0);\n+  typename = grokdeclarator (TREE_VALUE (typename), specs, TYPENAME, 0,\n+\t\t\t     NULL_TREE);\n \n   /* Apply attributes.  */\n   decl_attributes (&typename, attrs, 0);\n@@ -3408,7 +3409,7 @@ groktypename_in_parm_context (typename)\n     return typename;\n   return grokdeclarator (TREE_VALUE (typename),\n \t\t\t TREE_PURPOSE (typename),\n-\t\t\t PARM, 0);\n+\t\t\t PARM, 0, NULL_TREE);\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -3441,7 +3442,7 @@ start_decl (declarator, declspecs, initialized, attributes)\n     deprecated_state = DEPRECATED_SUPPRESS;\n \n   decl = grokdeclarator (declarator, declspecs,\n-\t\t\t NORMAL, initialized);\n+\t\t\t NORMAL, initialized, NULL_TREE);\n   \n   deprecated_state = DEPRECATED_NORMAL;\n \n@@ -3819,7 +3820,8 @@ push_parm_decl (parm)\n   immediate_size_expand = 0;\n \n   decl = grokdeclarator (TREE_VALUE (TREE_PURPOSE (parm)),\n-\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)), PARM, 0);\n+\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)),\n+\t\t\t PARM, 0, NULL_TREE);\n   decl_attributes (&decl, TREE_VALUE (parm), 0);\n \n #if 0\n@@ -3979,6 +3981,92 @@ complete_array_type (type, initial_value, do_default)\n   return value;\n }\n \f\n+/* A bit-field NAME should have an integer type whose precision\n+   accurately reflects its WIDTH.  If TYPE is good for that, return\n+   it, otherwise create and return the appropriate type.\n+\n+   This routine also performs sanity checks on the bit-field's type\n+   and width, and uses appropriate values if they are invalid.  */\n+static tree\n+build_bitfield_integer_type (type, width, orig_name)\n+     tree type, width;\n+     const char *orig_name;\n+{\n+  tree type_mv;\n+  unsigned int max_width;\n+  unsigned HOST_WIDE_INT w;\n+  const char *name = orig_name ? orig_name: _(\"<anonymous>\");\n+\n+  /* Necessary?  */\n+  STRIP_NOPS (width);\n+\n+  /* Detect and ignore out of range field width and process valid\n+     field widths.  */\n+  if (TREE_CODE (width) != INTEGER_CST)\n+    {\n+      error (\"bit-field `%s' width not an integer constant\", name);\n+      width = integer_one_node;\n+    }\n+  else\n+    {\n+      constant_expression_warning (width);\n+      if (tree_int_cst_sgn (width) < 0)\n+\t{\n+\t  error (\"negative width in bit-field `%s'\", name);\n+\t  width = integer_one_node;\n+\t}\n+      else if (integer_zerop (width) && orig_name)\n+\t{\n+\t  error (\"zero width for bit-field `%s'\", name);\n+\t  width = integer_one_node;\n+\t}\n+    }\n+\n+  /* Detect invalid bit-field type.  */\n+  if (TREE_CODE (type) != INTEGER_TYPE\n+      && TREE_CODE (type) != BOOLEAN_TYPE\n+      && TREE_CODE (type) != ENUMERAL_TYPE)\n+    {\n+      error (\"bit-field `%s' has invalid type\", name);\n+      type = unsigned_type_node;\n+    }\n+\n+  type_mv = TYPE_MAIN_VARIANT (type);\n+  if (pedantic\n+      && type_mv != integer_type_node\n+      && type_mv != unsigned_type_node\n+      && type_mv != c_bool_type_node\n+      /* Accept an enum that's equivalent to int or unsigned int.  */\n+      && (TREE_CODE (type) != ENUMERAL_TYPE\n+\t  || TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node)))\n+    pedwarn (\"type of bit-field `%s' is a GCC extension\", name);\n+\n+  if (type_mv == c_bool_type_node)\n+    max_width = CHAR_TYPE_SIZE;\n+  else\n+    max_width = TYPE_PRECISION (type);\n+\n+  if (0 < compare_tree_int (width, max_width))\n+    {\n+      error (\"width of `%s' exceeds its type\", name);\n+      w = max_width;\n+    }\n+  else\n+    w = tree_low_cst (width, 1);\n+\n+  if (TREE_CODE (type) == ENUMERAL_TYPE\n+      && (w < min_precision (TYPE_MIN_VALUE (type), TREE_UNSIGNED (type))\n+\t  || w < min_precision (TYPE_MAX_VALUE (type), TREE_UNSIGNED (type))))\n+    warning (\"`%s' is narrower than values of its type\", name);\n+\n+  /* The type of a bit-field should have precision the same as the\n+     bit-field's width.  */\n+  if (w != TYPE_PRECISION (type))\n+    type = build_nonstandard_integer_type (w, TREE_UNSIGNED (type));\n+\n+  return type;\n+}\n+\f\n /* Given declspecs and a declarator,\n    determine the name and type of the object declared\n    and construct a ..._DECL node for it.\n@@ -3998,8 +4086,9 @@ complete_array_type (type, initial_value, do_default)\n      TYPENAME if for a typename (in a cast or sizeof).\n       Don't make a DECL node; just return the ..._TYPE node.\n      FIELD for a struct or union field; make a FIELD_DECL.\n-     BITFIELD for a field with specified width.\n    INITIALIZED is 1 if the decl has an initializer.\n+   WIDTH is non-NULL for bit-fields, and is an INTEGER_CST node representing\n+   the width of the bit-field.\n \n    In the TYPENAME case, DECLARATOR is really an absolute declarator.\n    It may also be so in the PARM case, for a prototype where the\n@@ -4009,11 +4098,12 @@ complete_array_type (type, initial_value, do_default)\n    and `extern' are interpreted.  */\n \n static tree\n-grokdeclarator (declarator, declspecs, decl_context, initialized)\n+grokdeclarator (declarator, declspecs, decl_context, initialized, width)\n      tree declspecs;\n      tree declarator;\n      enum decl_context decl_context;\n      int initialized;\n+     tree width;\n {\n   int specbits = 0;\n   tree spec;\n@@ -4028,19 +4118,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   int explicit_char = 0;\n   int defaulted_int = 0;\n   tree typedef_decl = 0;\n-  const char *name;\n+  const char *name, *orig_name;\n   tree typedef_type = 0;\n   int funcdef_flag = 0;\n   enum tree_code innermost_code = ERROR_MARK;\n-  int bitfield = 0;\n   int size_varies = 0;\n   tree decl_attr = NULL_TREE;\n   tree array_ptr_quals = NULL_TREE;\n   int array_parm_static = 0;\n   tree returned_attrs = NULL_TREE;\n-\n-  if (decl_context == BITFIELD)\n-    bitfield = 1, decl_context = FIELD;\n+  bool bitfield = width != NULL_TREE;\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n@@ -4073,6 +4160,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \tdefault:\n \t  abort ();\n \t}\n+    orig_name = name;\n     if (name == 0)\n       name = \"type name\";\n   }\n@@ -4284,9 +4372,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n     }\n \n   /* Decide whether an integer type is signed or not.\n-     Optionally treat bitfields as signed by default.  */\n+     Optionally treat bit-fields as signed by default.  */\n   if (specbits & 1 << (int) RID_UNSIGNED\n-      /* Traditionally, all bitfields are unsigned.  */\n+      /* Traditionally, all bit-fields are unsigned.  */\n       || (bitfield && flag_traditional\n \t  && (! explicit_flag_signed_bitfields || !flag_signed_bitfields))\n       || (bitfield && ! flag_signed_bitfields\n@@ -4359,6 +4447,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t}\n     }\n \n+  /* A bit-field needs its type to have precision equal to its width,\n+     rather than the precision of the specified standard type.  */\n+  if (bitfield)\n+    type = build_bitfield_integer_type (type, width, orig_name);\n+\n   /* Figure out the type qualifiers for the declaration.  There are\n      two ways a declaration can become qualified.  One is something\n      like `const int i' where the `const' is explicit.  Another is\n@@ -5008,7 +5101,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n     else if (decl_context == FIELD)\n       {\n \t/* Structure field.  It may not be a function.  */\n-\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    error (\"field `%s' declared as a function\", name);\n@@ -5032,6 +5124,29 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n #endif\n \t  }\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n+\tif (bitfield)\n+\t  {\n+\t    DECL_SIZE (decl) = bitsize_int (TYPE_PRECISION (type));\n+\t    DECL_BIT_FIELD (decl) = 1;\n+\t    SET_DECL_C_BIT_FIELD (decl);\n+\n+\t    /* Bit-field width 0 => force desired amount of alignment.  */\n+\t    if (TYPE_PRECISION (type) == 0)\n+\t      {\n+#ifdef EMPTY_FIELD_BOUNDARY\n+\t\tDECL_ALIGN (decl) = MAX (DECL_ALIGN (decl),\n+\t\t\t\t\t EMPTY_FIELD_BOUNDARY);\n+#endif\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+\t\tif (PCC_BITFIELD_TYPE_MATTERS)\n+\t\t  {\n+\t\t    DECL_ALIGN (decl) = MAX (DECL_ALIGN (decl),\n+\t\t\t\t\t     TYPE_ALIGN (type));\n+\t\t    DECL_USER_ALIGN (decl) |= TYPE_USER_ALIGN (type);\n+\t\t  }\n+#endif\n+\t      }\n+\t  }\n \tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \n \tif (size_varies)\n@@ -5534,7 +5649,7 @@ start_struct (code, name)\n \n /* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n    of a structure component, returning a FIELD_DECL node.\n-   WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.\n+   WIDTH is non-NULL for bit-fields only, and is an INTEGER_CST node.\n \n    This is done during the parsing of the struct declaration.\n    The FIELD_DECL nodes are chained together and the lot of them\n@@ -5560,10 +5675,9 @@ grokfield (filename, line, declarator, declspecs, width)\n \t}\n     }\n \n-  value = grokdeclarator (declarator, declspecs, width ? BITFIELD : FIELD, 0);\n+  value = grokdeclarator (declarator, declspecs, FIELD, 0, width);\n \n   finish_decl (value, NULL_TREE, NULL_TREE);\n-  DECL_INITIAL (value) = width;\n \n   maybe_objc_check_decl (value);\n   return value;\n@@ -5615,10 +5729,7 @@ finish_struct (t, fieldlist, attributes)\n \t\t fieldlist ? _(\"named members\") : _(\"members\"));\n     }\n \n-  /* Install struct as DECL_CONTEXT of each field decl.\n-     Also process specified field sizes,m which is found in the DECL_INITIAL.\n-     Store 0 there, except for \": 0\" fields (so we can find them\n-     and delete them, below).  */\n+  /* Install struct as DECL_CONTEXT of each field decl.  */\n \n   saw_named_field = 0;\n   for (x = fieldlist; x; x = TREE_CHAIN (x))\n@@ -5654,93 +5765,7 @@ finish_struct (t, fieldlist, attributes)\n \terror (\"nested redefinition of `%s'\",\n \t       IDENTIFIER_POINTER (TYPE_NAME (t)));\n \n-      /* Detect invalid bit-field size.  */\n-      if (DECL_INITIAL (x))\n-\tSTRIP_NOPS (DECL_INITIAL (x));\n-      if (DECL_INITIAL (x))\n-\t{\n-\t  if (TREE_CODE (DECL_INITIAL (x)) == INTEGER_CST)\n-\t    constant_expression_warning (DECL_INITIAL (x));\n-\t  else\n-\t    {\n-\t      error_with_decl (x,\n-\t\t\t       \"bit-field `%s' width not an integer constant\");\n-\t      DECL_INITIAL (x) = NULL;\n-\t    }\n-\t}\n-\n-      /* Detect invalid bit-field type.  */\n-      if (DECL_INITIAL (x)\n-\t  && TREE_CODE (TREE_TYPE (x)) != INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE\n-\t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n-\t{\n-\t  error_with_decl (x, \"bit-field `%s' has invalid type\");\n-\t  DECL_INITIAL (x) = NULL;\n-\t}\n-\n-      if (DECL_INITIAL (x) && pedantic\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != integer_type_node\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != unsigned_type_node\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != c_bool_type_node\n-\t  /* Accept an enum that's equivalent to int or unsigned int.  */\n-\t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t       && (TYPE_PRECISION (TREE_TYPE (x))\n-\t\t   == TYPE_PRECISION (integer_type_node))))\n-\tpedwarn_with_decl (x, \"bit-field `%s' type invalid in ISO C\");\n-\n-      /* Detect and ignore out of range field width and process valid\n-\t field widths.  */\n-      if (DECL_INITIAL (x))\n-\t{\n-\t  int max_width\n-\t    = (TYPE_MAIN_VARIANT (TREE_TYPE (x)) == c_bool_type_node\n-\t       ? CHAR_TYPE_SIZE : TYPE_PRECISION (TREE_TYPE (x)));\n-\n-\t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n-\t    error_with_decl (x, \"negative width in bit-field `%s'\");\n-\t  else if (0 < compare_tree_int (DECL_INITIAL (x), max_width))\n-\t    pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n-\t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n-\t    error_with_decl (x, \"zero width for bit-field `%s'\");\n-\t  else\n-\t    {\n-\t      /* The test above has assured us that TREE_INT_CST_HIGH is 0.  */\n-\t      unsigned HOST_WIDE_INT width\n-\t\t= tree_low_cst (DECL_INITIAL (x), 1);\n-\n-\t      if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t\t  && (width < min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t     TREE_UNSIGNED (TREE_TYPE (x)))\n-\t\t      || (width\n-\t\t\t  < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))))))\n-\t\twarning_with_decl (x,\n-\t\t\t\t   \"`%s' is narrower than values of its type\");\n-\n-\t      DECL_SIZE (x) = bitsize_int (width);\n-\t      DECL_BIT_FIELD (x) = 1;\n-\t      SET_DECL_C_BIT_FIELD (x);\n-\n-\t      if (width == 0)\n-\t\t{\n-\t\t  /* field size 0 => force desired amount of alignment.  */\n-#ifdef EMPTY_FIELD_BOUNDARY\n-\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n-#endif\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t\t  if (PCC_BITFIELD_TYPE_MATTERS)\n-\t\t    {\n-\t\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (x)));\n-\t\t      DECL_USER_ALIGN (x) |= TYPE_USER_ALIGN (TREE_TYPE (x));\n-\t\t    }\n-#endif\n-\t\t}\n-\t    }\n-\t}\n-\n-      else if (TREE_TYPE (x) != error_mark_node)\n+      if (TREE_TYPE (x) != error_mark_node && !DECL_BIT_FIELD (x))\n \t{\n \t  unsigned int min_align = (DECL_PACKED (x) ? BITS_PER_UNIT\n \t\t\t\t    : TYPE_ALIGN (TREE_TYPE (x)));\n@@ -5752,8 +5777,6 @@ finish_struct (t, fieldlist, attributes)\n \t    DECL_USER_ALIGN (x) |= TYPE_USER_ALIGN (TREE_TYPE (x));\n \t}\n \n-      DECL_INITIAL (x) = 0;\n-\n       /* Detect flexible array member in an invalid context.  */\n       if (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n \t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n@@ -6178,7 +6201,7 @@ start_function (declspecs, declarator, attributes)\n   /* Don't expand any sizes in the return type of the function.  */\n   immediate_size_expand = 0;\n \n-  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1);\n+  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, NULL_TREE);\n \n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */"}, {"sha": "91b2223cf1083f8f504129f8749f81011e34c99b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -2393,13 +2393,6 @@ objc_copy_list (list, head)\n   while (list)\n     {\n       tail = copy_node (list);\n-\n-      /* The following statement fixes a bug when inheriting instance\n-\t variables that are declared to be bitfields. finish_struct\n-\t expects to find the width of the bitfield in DECL_INITIAL.  */\n-      if (DECL_BIT_FIELD (tail) && DECL_INITIAL (tail) == 0)\n-\tDECL_INITIAL (tail) = DECL_SIZE (tail);\n-\n       newlist = chainon (newlist, tail);\n       list = TREE_CHAIN (list);\n     }"}, {"sha": "1c72b6accabf2c663f231b1cc98acd995987b9e2", "filename": "gcc/testsuite/gcc.c-torture/compile/20000224-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000224-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000224-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000224-1.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -15,7 +15,7 @@ union Lisp_Object\n       {\n         enum Lisp_Type type: 3L ;\n         unsigned long  markbit: 1;\n-        unsigned long  val: 60;\n+        unsigned long  val: 32;\n       } gu;\n     long  i;\n   }"}, {"sha": "b7e86e8103e2d5f0bb93f3317237706abb9a708f", "filename": "gcc/testsuite/gcc.c-torture/execute/bitfld-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbitfld-1.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -0,0 +1,54 @@\n+/* Copyright 2002 Free Software Foundation, Inc.\n+\n+   Tests correct signedness of operations on bitfields; in particular\n+   that integer promotions are done correctly, including the case when\n+   casts are present.\n+\n+   The C front end was eliding the cast of an unsigned bitfield to\n+   unsigned as a no-op, when in fact it forces a conversion to a\n+   full-width unsigned int. (At the time of writing, the C++ front end\n+   has a different bug; it erroneously promotes the uncast unsigned\n+   bitfield to an unsigned int).\n+\n+   Source: Neil Booth, 25 Jan 2002, based on PR 3325 (and 3326, which\n+   is a different manifestation of the same bug).\n+*/\n+\n+extern void abort ();\n+\n+int\n+main(int argc, char *argv[])\n+{\n+  struct x { signed int i : 7; unsigned int u : 7; } bit;\n+\n+  unsigned int u;\n+  int i;\n+  unsigned int unsigned_result = -13U % 61;\n+  int signed_result = -13 % 61;\n+\n+  bit.u = 61, u = 61; \n+  bit.i = -13, i = -13;\n+\n+  if (i % u != unsigned_result)\n+    abort ();\n+  if (i % (unsigned int) u != unsigned_result)\n+    abort ();\n+\n+  /* Somewhat counter-intuitively, bit.u is promoted to an int, making\n+     the operands and result an int.  */\n+  if (i % bit.u != signed_result)\n+    abort ();\n+\n+  if (bit.i % bit.u != signed_result)\n+    abort ();\n+\n+  /* But with a cast to unsigned int, the unsigned int is promoted to\n+     itself as a no-op, and the operands and result are unsigned.  */\n+  if (i % (unsigned int) bit.u != unsigned_result)\n+    abort ();\n+\n+  if (bit.i % (unsigned int) bit.u != unsigned_result)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "ce37cc4e2e6a2cd3370bec19c3e9c92377f098ea", "filename": "gcc/testsuite/gcc.dg/bitfld-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-1.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -0,0 +1,30 @@\n+/* Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+   Tests various diagnostics about a bit-field's type and width.\n+\n+   Source: Neil Booth, 26 Jan 2002.\n+*/\n+\n+/* { dg-options -pedantic } */\n+\n+enum foo {e1 = 0, e2, e3, e4, e5};\n+\n+int x;\n+typedef unsigned int ui;\n+\n+struct bf1\n+{\n+  unsigned int a: 3.5;\t\t/* { dg-error \"integer constant\" } */\n+  unsigned int b: x;\t\t/* { dg-error \"integer constant\" } */\n+  unsigned int c: -1;\t\t/* { dg-error \"negative width\" } */\n+  unsigned int d: 0;\t\t/* { dg-error \"zero width\" } */\n+  unsigned int : 0;\t\t/* { dg-bogus \"zero width\" } */\n+  unsigned int : 5;\n+  double e: 1;\t\t\t/* { dg-error \"invalid type\" } */\n+  float f: 1;\t\t\t/* { dg-error \"invalid type\" } */\n+  unsigned long g: 5;\t\t/* { dg-warning \"GCC extension\" } */\n+  ui h: 5;\n+  enum foo i: 2;\t\t/* { dg-error \"narrower\" } */\n+  enum foo j: 3;\n+  unsigned int k: 256;\t\t/* { dg-error \"exceeds its type\" } */\n+};"}, {"sha": "e3f5f1bcc35bf222cebec8c36cd97475a08d2b39", "filename": "gcc/testsuite/gcc.dg/bitfld-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-2.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -0,0 +1,23 @@\n+/* Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+   Tests we warn about overly-large assignments to bitfields.\n+\n+   Source: Neil Booth, 28 Jan 2002.\n+*/\n+\n+struct bf\n+{\n+  unsigned int a: 2;\n+  int b: 2;\n+};\n+\n+struct bf p = {4, 0};\t\t/* { dg-warning \"truncated\" } */\n+struct bf q = {0, 2};\t\t/* { dg-warning \"overflow\" } */\n+struct bf r = {3, -2};\t\t/* { dg-bogus \"(truncated|overflow)\" } */\n+\n+void foo ()\n+{\n+  p.a = 4, p.b = 0;\t\t/* { dg-warning \"truncated\" } */\n+  q.a = 0, q.b = 2;\t\t/* { dg-warning \"overflow\" } */\n+  r.a = 3, r.b = -2;\t\t/* { dg-bogus \"(truncated|overflow)\" } */\n+}"}, {"sha": "48df2048b39df76def062dd6e71242be24381c63", "filename": "gcc/testsuite/gcc.dg/uninit-A.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-A.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-A.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-A.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -8,7 +8,9 @@ struct tree\n {\n     struct tree *car, *cdr, *wfl;\n     int code;\n-    struct { int renp:1; int rtnp:1; int rpnp:1; } flags;\n+    struct { unsigned int renp:1;\n+      unsigned int rtnp:1;\n+      unsigned int rpnp:1; } flags;\n };\n typedef struct tree *tree;\n #define NULL_TREE ((tree)0)"}, {"sha": "8d22d6856a70670fc846d021ec6b62ef24b5c45e", "filename": "gcc/tree.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -3758,6 +3758,29 @@ build_index_type (maxval)\n     return itype;\n }\n \n+/* Builds a signed or unsigned integer type of precision PRECISION.\n+   Used for C bitfields whose precision does not match that of\n+   built-in target types.  */\n+tree\n+build_nonstandard_integer_type (precision, unsignedp)\n+     unsigned HOST_WIDE_INT precision;\n+     int unsignedp;\n+{\n+  tree itype = make_node (INTEGER_TYPE);\n+\n+  TYPE_PRECISION (itype) = precision;\n+\n+  if (unsignedp)\n+    fixup_unsigned_type (itype);\n+  else\n+    fixup_signed_type (itype);\n+\n+  if (host_integerp (TYPE_MAX_VALUE (itype), 1))\n+    return type_hash_canon (tree_low_cst (TYPE_MAX_VALUE (itype), 1), itype);\n+\n+  return itype;\n+}\n+\n /* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n    ENUMERAL_TYPE, BOOLEAN_TYPE, or CHAR_TYPE), with\n    low bound LOWVAL and high bound HIGHVAL."}, {"sha": "930d82096730f96f3d16bb45bd17341b602ad3e1", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8469e54e147147ee65ee899b20fd68493af85327/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8469e54e147147ee65ee899b20fd68493af85327", "patch": "@@ -2860,6 +2860,7 @@ extern tree getdecls\t\t\t\tPARAMS ((void));\n /* Function to return the chain of structure tags in the current scope level.  */\n extern tree gettags\t\t\t\tPARAMS ((void));\n \n+extern tree build_nonstandard_integer_type\tPARAMS ((unsigned int, int));\n extern tree build_range_type PARAMS ((tree, tree, tree));\n \n /* In alias.c */"}]}