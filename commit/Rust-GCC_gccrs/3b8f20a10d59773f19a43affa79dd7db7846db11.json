{"sha": "3b8f20a10d59773f19a43affa79dd7db7846db11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I4ZjIwYTEwZDU5NzczZjE5YTQzYWZmYTc5ZGQ3ZGI3ODQ2ZGIxMQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-07-22T09:45:58Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-07-22T09:45:58Z"}, "message": "re PR preprocessor/28079 (#line range not verified without -pedantic)\n\n2008-07-22  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\tPR 28079\nlibcpp/\n\t* directives.c (strtolinenum): Handle overflow.\n\t(do_line): Give a warning if line number overflowed.\n\t(do_linemarker): Update call to strtolinenum.\n\ngcc/testsuite/\n\t* gcc.dg/cpp/line6.c: New.\n\nFrom-SVN: r138049", "tree": {"sha": "17d49712a4145447c738fd8de9102fd6bb8c8f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17d49712a4145447c738fd8de9102fd6bb8c8f50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b8f20a10d59773f19a43affa79dd7db7846db11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8f20a10d59773f19a43affa79dd7db7846db11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8f20a10d59773f19a43affa79dd7db7846db11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8f20a10d59773f19a43affa79dd7db7846db11/comments", "author": null, "committer": null, "parents": [{"sha": "92d3046118455bc90fd7daaf349b2dffe849dddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d3046118455bc90fd7daaf349b2dffe849dddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d3046118455bc90fd7daaf349b2dffe849dddd"}], "stats": {"total": 50, "additions": 40, "deletions": 10}, "files": [{"sha": "21202bd3a1f9682fc1857b1ea7d32756f1ced4ac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8f20a10d59773f19a43affa79dd7db7846db11/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8f20a10d59773f19a43affa79dd7db7846db11/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b8f20a10d59773f19a43affa79dd7db7846db11", "patch": "@@ -1,3 +1,8 @@\n+2008-07-22  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 28079\n+\t* gcc.dg/cpp/line6.c: New.\n+\t\n 2008-07-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* gfortran.dg/fmt_g0_3.f08: Fix typo in expected error message."}, {"sha": "c59ea3af7f15a0a8004a0d74607b6a511403cc0e", "filename": "gcc/testsuite/gcc.dg/cpp/line6.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8f20a10d59773f19a43affa79dd7db7846db11/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8f20a10d59773f19a43affa79dd7db7846db11/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline6.c?ref=3b8f20a10d59773f19a43affa79dd7db7846db11", "patch": "@@ -0,0 +1,7 @@\n+/* PR 28079 */\n+/* { dg-do preprocess } */\n+/* { dg-options \"\" } */\n+\n+#line 18446744073709551616 /* { dg-warning \"line number out of range\" } */\n+\n+#line 12312312312435 /* { dg-warning \"line number out of range\" \"\" { target *-*-* } 0 } */"}, {"sha": "cb1de791edc0534ce34c450c8dc0e365c8b1fee0", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8f20a10d59773f19a43affa79dd7db7846db11/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8f20a10d59773f19a43affa79dd7db7846db11/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3b8f20a10d59773f19a43affa79dd7db7846db11", "patch": "@@ -1,3 +1,10 @@\n+2008-07-22  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 28079\n+\t* directives.c (strtolinenum): Handle overflow.\n+\t(do_line): Give a warning if line number overflowed.\n+\t(do_linemarker): Update call to strtolinenum.\n+\n 2008-07-21  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* include/line-map.h (linenum_type): New typedef."}, {"sha": "9e0744b23d9f6695c949cb9c00f5c391c6823b9f", "filename": "libcpp/directives.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8f20a10d59773f19a43affa79dd7db7846db11/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8f20a10d59773f19a43affa79dd7db7846db11/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=3b8f20a10d59773f19a43affa79dd7db7846db11", "patch": "@@ -102,7 +102,7 @@ static char *glue_header_name (cpp_reader *);\n static const char *parse_include (cpp_reader *, int *, const cpp_token ***);\n static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);\n static unsigned int read_flag (cpp_reader *, unsigned int);\n-static int strtolinenum (const uchar *, unsigned int, linenum_type *);\n+static bool strtolinenum (const uchar *, size_t, linenum_type *, bool *);\n static void do_diagnostic (cpp_reader *, int, int);\n static cpp_hashnode *lex_macro_node (cpp_reader *, bool);\n static int undefine_macros (cpp_reader *, cpp_hashnode *, void *);\n@@ -837,23 +837,30 @@ read_flag (cpp_reader *pfile, unsigned int last)\n }\n \n /* Subroutine of do_line and do_linemarker.  Convert a number in STR,\n-   of length LEN, to binary; store it in NUMP, and return 0 if the\n-   number was well-formed, 1 if not.  Temporary, hopefully.  */\n-static int\n-strtolinenum (const uchar *str, unsigned int len, linenum_type *nump)\n+   of length LEN, to binary; store it in NUMP, and return false if the\n+   number was well-formed, true if not. WRAPPED is set to true if the\n+   number did not fit into 'unsigned long'.  */\n+static bool\n+strtolinenum (const uchar *str, size_t len, linenum_type *nump, bool *wrapped)\n {\n   linenum_type reg = 0;\n+  linenum_type reg_prev = 0;\n+\n   uchar c;\n+  *wrapped = false;\n   while (len--)\n     {\n       c = *str++;\n       if (!ISDIGIT (c))\n-\treturn 1;\n+\treturn true;\n       reg *= 10;\n       reg += c - '0';\n+      if (reg < reg_prev) \n+\t*wrapped = true;\n+      reg_prev = reg;\n     }\n   *nump = reg;\n-  return 0;\n+  return false;\n }\n \n /* Interpret #line command.\n@@ -875,12 +882,13 @@ do_line (cpp_reader *pfile)\n \n   /* C99 raised the minimum limit on #line numbers.  */\n   linenum_type cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n+  bool wrapped;\n \n   /* #line commands expand macros.  */\n   token = cpp_get_token (pfile);\n   if (token->type != CPP_NUMBER\n       || strtolinenum (token->val.str.text, token->val.str.len,\n-\t\t       &new_lineno))\n+\t\t       &new_lineno, &wrapped))\n     {\n       if (token->type == CPP_EOF)\n \tcpp_error (pfile, CPP_DL_ERROR, \"unexpected end of file after #line\");\n@@ -891,8 +899,10 @@ do_line (cpp_reader *pfile)\n       return;\n     }\n \n-  if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n+  if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap || wrapped))\n     cpp_error (pfile, CPP_DL_PEDWARN, \"line number out of range\");\n+  else if (wrapped)\n+    cpp_error (pfile, CPP_DL_WARNING, \"line number out of range\");\n \n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n@@ -929,6 +939,7 @@ do_linemarker (cpp_reader *pfile)\n   unsigned int new_sysp = map->sysp;\n   enum lc_reason reason = LC_RENAME;\n   int flag;\n+  bool wrapped;\n \n   /* Back up so we can get the number again.  Putting this in\n      _cpp_handle_directive risks two calls to _cpp_backup_tokens in\n@@ -939,7 +950,7 @@ do_linemarker (cpp_reader *pfile)\n   token = cpp_get_token (pfile);\n   if (token->type != CPP_NUMBER\n       || strtolinenum (token->val.str.text, token->val.str.len,\n-\t\t       &new_lineno))\n+\t\t       &new_lineno, &wrapped))\n     {\n       /* Unlike #line, there does not seem to be a way to get an EOF\n \t here.  So, it should be safe to always spell the token.  */"}]}