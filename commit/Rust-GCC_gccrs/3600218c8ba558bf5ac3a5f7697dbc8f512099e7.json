{"sha": "3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYwMDIxOGM4YmE1NThiZjVhYzNhNWY3Njk3ZGJjOGY1MTIwOTllNw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-04-30T11:41:46Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-04-30T11:41:46Z"}, "message": "Fix expansion point loc for macro-like tokens\n\nConsider the test case gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c.\nIts interesting part is:\n\n    #define A(x) vari x /* line 7.  */\n    #define vari(x)\n    #define B , varj\n    int A(B) ;  /* line 10.  */\n\nIn its initial version, this test was being pre-processed as:\n\n    # 1 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n    # 1 \"build/gcc//\"\n    # 1 \"<command-line>\"\n    # 1 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n    # 10 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n    int\n    # 7 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n\t\t vari\n\n\t, varj ;\n\nNote how \"int\" and \"vari\" are on separate lines, whereas \"int\" and\n\", varj\" are on the same line.\n\nThis looks like a bug to me, even independantly from the macro\nlocation tracking work.\n\nWith macro location tracking turned on, the preprocessed output\nbecomes:\n\n    # 1 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n    # 1 \"<command-line>\"\n    # 1 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n    # 10 \"gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c\"\n    int vari , varj ;\n\nWhich, IMO, is what we'd expect.\n\nThis is due to an unexpected side effect of enter_macro_context when\npassed a token that might look like a function-like macro at first\nsight, but that it eventually considers to not be a macro after all.\n\nThis is the case for the \"vari\" token which looks like a macro when it\nis first lexed, but is eventually considered to be a normal token by\nenter_macro_context because it's not used as a function-like macro\ninvocation.\n\nIn that case, besides returning NULL, enter_macro_context sets\npfile->context->c.macro to NULL, making cpp_get_token_1 forget to set\nthe location of the \"vari\" to the expansion point of A.\n\nenter_macro_context sets pfile->context->c.macro to NULL in that case\nbecause funlike_invocation_p reads one token pass \"foo\", sees that\nthere is no '(' token, so we are not invoking the function-like\nparameter.  It then puts the tokens (which it has read after \"foo\")\nback into the tokens stream by calling _cpp_push_token_context on it,\nwhich sets pfile->context->c.macro to NULL, saying in essence that the\ncurrent macro expansion context is \"stopped\".\n\nThe fix here is to teach _cpp_push_token and\npush_extended_tokens_context to continue the current macro context\nwhen passed a NULL macro.  But then, now that there can be several\ncontinguous contexts associated with the same macro, we need to teach\n_cpp_pop_context to re-enable the expansion of the current macro only\nwhen we are really out of expanding the current macro.  Otherwise we\ncan run in cases where we have recursive expansions of the same macro.\n\nTested on x86_64-unknown-linux-gnu against trunk.  Now this test has\nthe same output with and without tracking locations accross macro\nexpansions.\n\nNote that the bootstrap with -ftrack-macro-expansion exhibits other\nseparate issues that are addressed in subsequent patches.  This patch\njust fixes one class of problems.\n\nThe patch does pass bootstrap with -ftrack-macro-expansion turned off,\nthough.\n\nlibcpp/\n\t* macro.c (macro_of_context): New static function.\n\t(_cpp_push_token_context, push_extended_tokens_context): If the\n\tmacro argument is NULL, it means we are continuing the expansion\n\tof the current macro, if any.  Update comments.\n\t(_cpp_pop_context): Re-enable expansion of the macro only when we\n\tare really out of the context of the current expansion.\n\ngcc/testsuite/\n\n\t* gcc.dg/debug/dwarf2/pr41445-5.c: Adjust.\n\t* gcc.dg/debug/dwarf2/pr41445-6.c: Likewise.\n\nFrom-SVN: r186968", "tree": {"sha": "893dd585aa96874cc48af67d835d42819344b45b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/893dd585aa96874cc48af67d835d42819344b45b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/comments", "author": null, "committer": null, "parents": [{"sha": "163fa1ebbaa850de13fae527fdc921fd59535eec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163fa1ebbaa850de13fae527fdc921fd59535eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/163fa1ebbaa850de13fae527fdc921fd59535eec"}], "stats": {"total": 78, "additions": 68, "deletions": 10}, "files": [{"sha": "ed2779e83ad780e452601bda7e73a78ee1f4e58a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "patch": "@@ -1,5 +1,9 @@\n 2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n \n+\tFix expansion point loc for macro-like tokens\n+\t* gcc.dg/debug/dwarf2/pr41445-5.c: Adjust.\n+    \t* gcc.dg/debug/dwarf2/pr41445-6.c: Likewise.\n+\n \tFix token pasting with -ftrack-macro-expansion\n \t* gcc.dg/cpp/paste17.c: New test case for\n     \t-ftrack-macro-expansion=2 mode only."}, {"sha": "d21acd5aba98c704dfac35427ff58f9da5753f40", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr41445-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr41445-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr41445-5.c?ref=3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "patch": "@@ -9,6 +9,9 @@\n #define B , varj\n int A(B) ;\n \n-/* { dg-final { scan-assembler \"DW_TAG_variable\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\\"vari\\[^\\\\r\\\\n\\]*DW_AT_name(\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*DW_AT_)*\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\[^0-9a-fA-FxX](0x)?7\\[^0-9a-fA-FxX]\\[^\\\\r\\\\n\\]*DW_AT_decl_line\" } } */\n+/*  We want to check that both vari and varj have the same line\n+    number.  */\n+\n+/* { dg-final { scan-assembler \"DW_TAG_variable\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\\"vari\\[^\\\\r\\\\n\\]*DW_AT_name(\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*DW_AT_)*\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\[^0-9a-fA-FxX](0xa|10)\\[^0-9a-fA-FxX]\\[^\\\\r\\\\n\\]*DW_AT_decl_line\" } } */\n /* { dg-final { scan-assembler \"DW_TAG_variable\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\\"varj\\[^\\\\r\\\\n\\]*DW_AT_name(\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*DW_AT_)*\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\[^0-9a-fA-FxX](0xa|10)\\[^0-9a-fA-FxX]\\[^\\\\r\\\\n\\]*DW_AT_decl_line\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "d6d79ccc46969fbdf3d0f16ccc1699c5b4ad4078", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-6.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr41445-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr41445-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr41445-6.c?ref=3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "patch": "@@ -4,5 +4,8 @@\n \n #include \"pr41445-5.c\"\n \n-/* { dg-final { scan-assembler \"DW_TAG_variable\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\\"vari\\[^\\\\r\\\\n\\]*DW_AT_name(\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*DW_AT_)*\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\[^0-9a-fA-FxX](0x)?7\\[^0-9a-fA-FxX]\\[^\\\\r\\\\n\\]*DW_AT_decl_line\" } } */\n+/*  We want to check that both vari and varj have the same line\n+    number.  */\n+\n+/* { dg-final { scan-assembler \"DW_TAG_variable\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\\"vari\\[^\\\\r\\\\n\\]*DW_AT_name(\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*DW_AT_)*\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\[^0-9a-fA-FxX](0xa|10)?\\[^0-9a-fA-FxX]\\[^\\\\r\\\\n\\]*DW_AT_decl_line\" } } */\n /* { dg-final { scan-assembler \"DW_TAG_variable\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\\"varj\\[^\\\\r\\\\n\\]*DW_AT_name(\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*DW_AT_)*\\[^\\\\r\\\\n\\]*\\[\\\\r\\\\n\\]+\\[^\\\\r\\\\n\\]*\\[^0-9a-fA-FxX](0xa|10)\\[^0-9a-fA-FxX]\\[^\\\\r\\\\n\\]*DW_AT_decl_line\" } } */"}, {"sha": "5e93396ac7536adb41a108bdfc4020949b73ca4f", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "patch": "@@ -1,5 +1,13 @@\n 2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n \n+\tFix expansion point loc for macro-like tokens\n+\t* macro.c (macro_of_context): New static function.\n+\t(_cpp_push_token_context, push_extended_tokens_context): If the\n+\tmacro argument is NULL, it means we are continuing the expansion\n+\tof the current macro, if any.  Update comments.\n+\t(_cpp_pop_context): Re-enable expansion of the macro only when we\n+\tare really out of the context of the current expansion.\n+\n \tFix token pasting with -ftrack-macro-expansion\n \t* macro.c (paste_all_tokens): Put the token resulting from pasting\n \tinto an extended token context with -ftrack-macro-location is in"}, {"sha": "ab3e8f641dca31093780b0941f9cca2664394d63", "filename": "libcpp/macro.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3600218c8ba558bf5ac3a5f7697dbc8f512099e7/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=3600218c8ba558bf5ac3a5f7697dbc8f512099e7", "patch": "@@ -165,6 +165,8 @@ static void consume_next_token_from_context (cpp_reader *pfile,\n \t\t\t\t\t     source_location *);\n static const cpp_token* cpp_get_token_1 (cpp_reader *, source_location *);\n \n+static cpp_hashnode* macro_of_context (cpp_context *context);\n+\n /* Statistical counter tracking the number of macros that got\n    expanded.  */\n unsigned num_expanded_macros_counter = 0;\n@@ -1808,26 +1810,40 @@ push_ptoken_context (cpp_reader *pfile, cpp_hashnode *macro, _cpp_buff *buff,\n   LAST (context).ptoken = first + count;\n }\n \n-/* Push a list of tokens.  */\n+/* Push a list of tokens.\n+\n+   A NULL macro means that we should continue the current macro\n+   expansion, in essence.  That means that if we are currently in a\n+   macro expansion context, we'll make the new pfile->context refer to\n+   the current macro.  */\n void\n _cpp_push_token_context (cpp_reader *pfile, cpp_hashnode *macro,\n \t\t\t const cpp_token *first, unsigned int count)\n {\n-   cpp_context *context = next_context (pfile);\n- \n+  cpp_context *context;\n+\n+   if (macro == NULL)\n+     macro = macro_of_context (pfile->context);\n+\n+   context = next_context (pfile);\n    context->tokens_kind = TOKENS_KIND_DIRECT;\n    context->c.macro = macro;\n    context->buff = NULL;\n-  FIRST (context).token = first;\n-  LAST (context).token = first + count;\n+   FIRST (context).token = first;\n+   LAST (context).token = first + count;\n }\n \n /* Build a context containing a list of tokens as well as their\n    virtual locations and push it.  TOKENS_BUFF is the buffer that\n    contains the tokens pointed to by FIRST.  If TOKENS_BUFF is\n    non-NULL, it means that the context owns it, meaning that\n    _cpp_pop_context will free it as well as VIRT_LOCS_BUFF that\n-   contains the virtual locations.  */\n+   contains the virtual locations.\n+\n+   A NULL macro means that we should continue the current macro\n+   expansion, in essence.  That means that if we are currently in a\n+   macro expansion context, we'll make the new pfile->context refer to\n+   the current macro.  */\n static void\n push_extended_tokens_context (cpp_reader *pfile,\n \t\t\t      cpp_hashnode *macro,\n@@ -1836,9 +1852,13 @@ push_extended_tokens_context (cpp_reader *pfile,\n \t\t\t      const cpp_token **first,\n \t\t\t      unsigned int count)\n {\n-  cpp_context *context = next_context (pfile);\n+  cpp_context *context;\n   macro_context *m;\n \n+  if (macro == NULL)\n+    macro = macro_of_context (pfile->context);\n+\n+  context = next_context (pfile);\n   context->tokens_kind = TOKENS_KIND_EXTENDED;\n   context->buff = token_buff;\n \n@@ -2110,6 +2130,19 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n   CPP_WTRADITIONAL (pfile) = saved_warn_trad;\n }\n \n+/* Returns the macro associated to the current context if we are in\n+   the context a macro expansion, NULL otherwise.  */\n+static cpp_hashnode*\n+macro_of_context (cpp_context *context)\n+{\n+  if (context == NULL)\n+    return NULL;\n+\n+  return (context->tokens_kind == TOKENS_KIND_EXTENDED)\n+    ? context->c.mc->macro_node\n+    : context->c.macro;\n+}\n+\n /* Pop the current context off the stack, re-enabling the macro if the\n    context represented a macro's replacement list.  Initially the\n    context structure was not freed so that we can re-use it later, but\n@@ -2146,7 +2179,14 @@ _cpp_pop_context (cpp_reader *pfile)\n \t tokens is pushed just for the purpose of walking them using\n \t cpp_get_token_1.  In that case, no 'macro' field is set into\n \t the dummy context.  */\n-      if (macro != NULL)\n+      if (macro != NULL\n+\t  /* Several contiguous macro expansion contexts can be\n+\t     associated to the same macro; that means it's the same\n+\t     macro expansion that spans accross all these (sub)\n+\t     contexts.  So we should re-enable an expansion-disabled\n+\t     macro only when we are sure we are really out of that\n+\t     macro expansion.  */\n+\t  && macro_of_context (context->prev) != macro)\n \tmacro->flags &= ~NODE_DISABLED;\n     }\n "}]}