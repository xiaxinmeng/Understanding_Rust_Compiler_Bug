{"sha": "46c5ad278b15d1db509093032ea1eed00459b3a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjNWFkMjc4YjE1ZDFkYjUwOTA5MzAzMmVhMWVlZDAwNDU5YjNhMA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-07-06T12:35:56Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-06T12:35:56Z"}, "message": "sbitmap.c: Convert prototypes to ISO C90.\n\n\t* sbitmap.c: Convert prototypes to ISO C90.\n\t* sbitmap.h: Likewise.\n\t* scan-decls.c: Likewise.\n\t* scan.c: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-ebb.c: Likewise.\n\t* sched-int.h: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* sched-vis.c: Likewise.\n\t* sibcall.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* sreal.c: Likewise.\n\t* sreal.h: Likewise.\n\t* ssa-ccp.c: Likewise.\n\t* ssa-dce.c: Likewise.\n\t* ssa.c: Likewise.\n\t* ssa.h: Likewise.\n\t* stack.h: Likewise.\n\t* stmt.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* stringpool.c: Likewise.\n\t* target.h: Likewise.\n\t* timevar.c: Likewise.\n\t* timevar.h: Likewise.\n\t* tlink.c: Likewise.\n\t* tracer.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-inline.h: Likewise.\n\t* tree.c: Likewise.\n\t* tree.h: Likewise.\n\nFrom-SVN: r69002", "tree": {"sha": "2e1f352052c069dc89b540d510fb95d6fac245ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e1f352052c069dc89b540d510fb95d6fac245ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46c5ad278b15d1db509093032ea1eed00459b3a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c5ad278b15d1db509093032ea1eed00459b3a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c5ad278b15d1db509093032ea1eed00459b3a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c5ad278b15d1db509093032ea1eed00459b3a0/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6623b2f26dd64817454896e5b20a793e8d6ac14c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6623b2f26dd64817454896e5b20a793e8d6ac14c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6623b2f26dd64817454896e5b20a793e8d6ac14c"}], "stats": {"total": 4284, "additions": 1668, "deletions": 2616}, "files": [{"sha": "024734560c1cfe6d7bb5266672c9100687bf5bac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -67,6 +67,36 @@\n \t* rtl.c: Likewise.\n \t* rtl.h: Likewise.\n \t* rtlanal.c: Likewise.\n+\t* sbitmap.c: Likewise.\n+\t* sbitmap.h: Likewise.\n+\t* scan-decls.c: Likewise.\n+\t* scan.c: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-ebb.c: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* sched-vis.c: Likewise.\n+\t* sibcall.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* sreal.c: Likewise.\n+\t* sreal.h: Likewise.\n+\t* ssa-ccp.c: Likewise.\n+\t* ssa-dce.c: Likewise.\n+\t* ssa.c: Likewise.\n+\t* ssa.h: Likewise.\n+\t* stack.h: Likewise.\n+\t* stmt.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* stringpool.c: Likewise.\n+\t* target.h: Likewise.\n+\t* timevar.c: Likewise.\n+\t* timevar.h: Likewise.\n+\t* tlink.c: Likewise.\n+\t* tracer.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-inline.h: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.h: Likewise.\n \n 2003-07-05  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "508eca3eabe0878384ef1c5ce4f637fafdb147a6", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 36, "deletions": 86, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -32,8 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Allocate a simple bitmap of N_ELMS bits.  */\n \n sbitmap\n-sbitmap_alloc (n_elms)\n-     unsigned int n_elms;\n+sbitmap_alloc (unsigned int n_elms)\n {\n   unsigned int bytes, size, amt;\n   sbitmap bmap;\n@@ -54,10 +53,7 @@ sbitmap_alloc (n_elms)\n    is zero, and set them to one otherwise.  */\n \n sbitmap\n-sbitmap_resize (bmap, n_elms, def)\n-     sbitmap bmap;\n-     unsigned int n_elms;\n-     int def;\n+sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n {\n   unsigned int bytes, size, amt;\n   unsigned int last_bit;\n@@ -110,8 +106,7 @@ sbitmap_resize (bmap, n_elms, def)\n /* Allocate a vector of N_VECS bitmaps of N_ELMS bits.  */\n \n sbitmap *\n-sbitmap_vector_alloc (n_vecs, n_elms)\n-     unsigned int n_vecs, n_elms;\n+sbitmap_vector_alloc (unsigned int n_vecs, unsigned int n_elms)\n {\n   unsigned int i, bytes, offset, elm_bytes, size, amt, vector_bytes;\n   sbitmap *bitmap_vector;\n@@ -153,34 +148,30 @@ sbitmap_vector_alloc (n_vecs, n_elms)\n /* Copy sbitmap SRC to DST.  */\n \n void\n-sbitmap_copy (dst, src)\n-     sbitmap dst, src;\n+sbitmap_copy (sbitmap dst, sbitmap src)\n {\n   memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * dst->size);\n }\n \n /* Determine if a == b.  */\n int\n-sbitmap_equal (a, b)\n-     sbitmap a, b;\n+sbitmap_equal (sbitmap a, sbitmap b)\n {\n   return !memcmp (a->elms, b->elms, sizeof (SBITMAP_ELT_TYPE) * a->size);\n }\n \n /* Zero all elements in a bitmap.  */\n \n void\n-sbitmap_zero (bmap)\n-     sbitmap bmap;\n+sbitmap_zero (sbitmap bmap)\n {\n   memset (bmap->elms, 0, bmap->bytes);\n }\n \n /* Set all elements in a bitmap to ones.  */\n \n void\n-sbitmap_ones (bmap)\n-     sbitmap bmap;\n+sbitmap_ones (sbitmap bmap)\n {\n   unsigned int last_bit;\n \n@@ -195,9 +186,7 @@ sbitmap_ones (bmap)\n /* Zero a vector of N_VECS bitmaps.  */\n \n void\n-sbitmap_vector_zero (bmap, n_vecs)\n-     sbitmap *bmap;\n-     unsigned int n_vecs;\n+sbitmap_vector_zero (sbitmap *bmap, unsigned int n_vecs)\n {\n   unsigned int i;\n \n@@ -208,9 +197,7 @@ sbitmap_vector_zero (bmap, n_vecs)\n /* Set a vector of N_VECS bitmaps to ones.  */\n \n void\n-sbitmap_vector_ones (bmap, n_vecs)\n-     sbitmap *bmap;\n-     unsigned int n_vecs;\n+sbitmap_vector_ones (sbitmap *bmap, unsigned int n_vecs)\n {\n   unsigned int i;\n \n@@ -223,8 +210,7 @@ sbitmap_vector_ones (bmap, n_vecs)\n    Returns true if any change is made.  */\n \n bool\n-sbitmap_union_of_diff_cg (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n+sbitmap_union_of_diff_cg (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -244,8 +230,7 @@ sbitmap_union_of_diff_cg (dst, a, b, c)\n }\n \n void\n-sbitmap_union_of_diff (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n+sbitmap_union_of_diff (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -260,8 +245,7 @@ sbitmap_union_of_diff (dst, a, b, c)\n /* Set bitmap DST to the bitwise negation of the bitmap SRC.  */\n \n void\n-sbitmap_not (dst, src)\n-     sbitmap dst, src;\n+sbitmap_not (sbitmap dst, sbitmap src)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -275,15 +259,14 @@ sbitmap_not (dst, src)\n    in A and the bits in B. i.e. dst = a & (~b).  */\n \n void\n-sbitmap_difference (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_difference (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, dst_size = dst->size;\n   unsigned int min_size = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n   sbitmap_ptr ap = a->elms;\n   sbitmap_ptr bp = b->elms;\n-  \n+\n   /* A should be at least as large as DEST, to have a defined source.  */\n   if (a->size < dst_size)\n     abort ();\n@@ -304,8 +287,7 @@ sbitmap_difference (dst, a, b)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_and_b_cg (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_a_and_b_cg (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -324,8 +306,7 @@ sbitmap_a_and_b_cg (dst, a, b)\n }\n \n void\n-sbitmap_a_and_b (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_a_and_b (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -340,8 +321,7 @@ sbitmap_a_and_b (dst, a, b)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_xor_b_cg (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_a_xor_b_cg (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -360,8 +340,7 @@ sbitmap_a_xor_b_cg (dst, a, b)\n }\n \n void\n-sbitmap_a_xor_b (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_a_xor_b (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -376,8 +355,7 @@ sbitmap_a_xor_b (dst, a, b)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_or_b_cg (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_a_or_b_cg (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -396,8 +374,7 @@ sbitmap_a_or_b_cg (dst, a, b)\n }\n \n void\n-sbitmap_a_or_b (dst, a, b)\n-     sbitmap dst, a, b;\n+sbitmap_a_or_b (sbitmap dst, sbitmap a, sbitmap b)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -411,8 +388,7 @@ sbitmap_a_or_b (dst, a, b)\n /* Return nonzero if A is a subset of B.  */\n \n bool\n-sbitmap_a_subset_b_p (a, b)\n-     sbitmap a, b;\n+sbitmap_a_subset_b_p (sbitmap a, sbitmap b)\n {\n   unsigned int i, n = a->size;\n   sbitmap_ptr ap, bp;\n@@ -428,8 +404,7 @@ sbitmap_a_subset_b_p (a, b)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_or_b_and_c_cg (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n+sbitmap_a_or_b_and_c_cg (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -449,8 +424,7 @@ sbitmap_a_or_b_and_c_cg (dst, a, b, c)\n }\n \n void\n-sbitmap_a_or_b_and_c (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n+sbitmap_a_or_b_and_c (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -466,8 +440,7 @@ sbitmap_a_or_b_and_c (dst, a, b, c)\n    Return nonzero if any change is made.  */\n \n bool\n-sbitmap_a_and_b_or_c_cg (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n+sbitmap_a_and_b_or_c_cg (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -487,8 +460,7 @@ sbitmap_a_and_b_or_c_cg (dst, a, b, c)\n }\n \n void\n-sbitmap_a_and_b_or_c (dst, a, b, c)\n-     sbitmap dst, a, b, c;\n+sbitmap_a_and_b_or_c (sbitmap dst, sbitmap a, sbitmap b, sbitmap c)\n {\n   unsigned int i, n = dst->size;\n   sbitmap_ptr dstp = dst->elms;\n@@ -505,10 +477,7 @@ sbitmap_a_and_b_or_c (dst, a, b, c)\n    block number BB, using the new flow graph structures.  */\n \n void\n-sbitmap_intersection_of_succs (dst, src, bb)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n+sbitmap_intersection_of_succs (sbitmap dst, sbitmap *src, int bb)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n@@ -545,10 +514,7 @@ sbitmap_intersection_of_succs (dst, src, bb)\n    block number BB, using the new flow graph structures.  */\n \n void\n-sbitmap_intersection_of_preds (dst, src, bb)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n+sbitmap_intersection_of_preds (sbitmap dst, sbitmap *src, int bb)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n@@ -585,10 +551,7 @@ sbitmap_intersection_of_preds (dst, src, bb)\n    block number BB, using the new flow graph structures.  */\n \n void\n-sbitmap_union_of_succs (dst, src, bb)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n+sbitmap_union_of_succs (sbitmap dst, sbitmap *src, int bb)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n@@ -625,10 +588,7 @@ sbitmap_union_of_succs (dst, src, bb)\n    block number BB, using the new flow graph structures.  */\n \n void\n-sbitmap_union_of_preds (dst, src, bb)\n-     sbitmap dst;\n-     sbitmap *src;\n-     int bb;\n+sbitmap_union_of_preds (sbitmap dst, sbitmap *src, int bb)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   unsigned int set_size = dst->size;\n@@ -665,8 +625,7 @@ sbitmap_union_of_preds (dst, src, bb)\n /* Return number of first bit set in the bitmap, -1 if none.  */\n \n int\n-sbitmap_first_set_bit (bmap)\n-     sbitmap bmap;\n+sbitmap_first_set_bit (sbitmap bmap)\n {\n   unsigned int n;\n \n@@ -677,8 +636,7 @@ sbitmap_first_set_bit (bmap)\n /* Return number of last bit set in the bitmap, -1 if none.  */\n \n int\n-sbitmap_last_set_bit (bmap)\n-     sbitmap bmap;\n+sbitmap_last_set_bit (sbitmap bmap)\n {\n   int i;\n   SBITMAP_ELT_TYPE *ptr = bmap->elms;\n@@ -708,9 +666,7 @@ sbitmap_last_set_bit (bmap)\n }\n \n void\n-dump_sbitmap (file, bmap)\n-     FILE *file;\n-     sbitmap bmap;\n+dump_sbitmap (FILE *file, sbitmap bmap)\n {\n   unsigned int i, n, j;\n   unsigned int set_size = bmap->size;\n@@ -731,9 +687,7 @@ dump_sbitmap (file, bmap)\n }\n \n void\n-dump_sbitmap_file (file, bmap)\n-     FILE *file;\n-     sbitmap bmap;\n+dump_sbitmap_file (FILE *file, sbitmap bmap)\n {\n   unsigned int i, pos;\n \n@@ -756,18 +710,14 @@ dump_sbitmap_file (file, bmap)\n }\n \n void\n-debug_sbitmap (bmap)\n-     sbitmap bmap;\n+debug_sbitmap (sbitmap bmap)\n {\n   dump_sbitmap_file (stderr, bmap);\n }\n \n void\n-dump_sbitmap_vector (file, title, subtitle, bmaps, n_maps)\n-     FILE *file;\n-     const char *title, *subtitle;\n-     sbitmap *bmaps;\n-     int n_maps;\n+dump_sbitmap_vector (FILE *file, const char *title, const char *subtitle,\n+\t\t     sbitmap *bmaps, int n_maps)\n {\n   int bb;\n "}, {"sha": "fecc49150837a4da01764d2ce24d4f4ffd91ec8e", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 44, "deletions": 51, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -19,7 +19,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n #ifndef GCC_SBITMAP_H\n-#define GCC_SBITMAP_H \n+#define GCC_SBITMAP_H\n \n /* It's not clear yet whether using bitmap.[ch] will be a win.\n    It should be straightforward to convert so for now we keep things simple\n@@ -118,63 +118,56 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n struct int_list;\n \n-extern void dump_sbitmap\t\tPARAMS ((FILE *, sbitmap));\n-extern void dump_sbitmap_file\t\tPARAMS ((FILE *, sbitmap));\n-extern void dump_sbitmap_vector \tPARAMS ((FILE *, const char *,\n-\t\t\t\t\t\t const char *, sbitmap *,\n-\t\t\t\t\t\t int));\n-extern sbitmap sbitmap_alloc\t\tPARAMS ((unsigned int));\n-extern sbitmap *sbitmap_vector_alloc\tPARAMS ((unsigned int, unsigned int));\n-extern sbitmap sbitmap_resize\t\tPARAMS ((sbitmap, unsigned int, int));\n-extern void sbitmap_copy \t\tPARAMS ((sbitmap, sbitmap));\n-extern int sbitmap_equal                PARAMS ((sbitmap, sbitmap));\n-extern void sbitmap_zero\t\tPARAMS ((sbitmap));\n-extern void sbitmap_ones\t\tPARAMS ((sbitmap));\n-extern void sbitmap_vector_zero\t\tPARAMS ((sbitmap *, unsigned int));\n-extern void sbitmap_vector_ones\t\tPARAMS ((sbitmap *, unsigned int));\n-\n-extern void sbitmap_union_of_diff\tPARAMS ((sbitmap, sbitmap, sbitmap,\n-\t\t\t\t\t\t sbitmap));\n-extern bool sbitmap_union_of_diff_cg\tPARAMS ((sbitmap, sbitmap, sbitmap,\n-\t\t\t\t\t\t sbitmap));\n-extern void sbitmap_difference\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_not\t\t\tPARAMS ((sbitmap, sbitmap));\n-extern void sbitmap_a_or_b_and_c\tPARAMS ((sbitmap, sbitmap, sbitmap,\n-\t\t\t\t\t\t sbitmap));\n-extern bool sbitmap_a_or_b_and_c_cg\tPARAMS ((sbitmap, sbitmap, sbitmap,\n-\t\t\t\t\t\t sbitmap));\n-extern void sbitmap_a_and_b_or_c\tPARAMS ((sbitmap, sbitmap, sbitmap,\n-\t\t\t\t\t\t sbitmap));\n-extern bool sbitmap_a_and_b_or_c_cg\tPARAMS ((sbitmap, sbitmap, sbitmap,\n-\t\t\t\t\t\t sbitmap));\n-extern void sbitmap_a_and_b\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern bool sbitmap_a_and_b_cg\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_a_or_b\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern bool sbitmap_a_or_b_cg\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_a_xor_b\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern bool sbitmap_a_xor_b_cg\t\tPARAMS ((sbitmap, sbitmap, sbitmap));\n-extern bool sbitmap_a_subset_b_p\tPARAMS ((sbitmap, sbitmap));\n-\n-extern int sbitmap_first_set_bit\tPARAMS ((sbitmap));\n-extern int sbitmap_last_set_bit\t\tPARAMS ((sbitmap));\n-\n-extern void sbitmap_intersect_of_predsucc PARAMS ((sbitmap, sbitmap *,\n-\t\t\t\t\t\t  int, struct int_list **));\n+extern void dump_sbitmap (FILE *, sbitmap);\n+extern void dump_sbitmap_file (FILE *, sbitmap);\n+extern void dump_sbitmap_vector (FILE *, const char *, const char *, sbitmap *,\n+\t\t\t\t int);\n+extern sbitmap sbitmap_alloc (unsigned int);\n+extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);\n+extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);\n+extern void sbitmap_copy (sbitmap, sbitmap);\n+extern int sbitmap_equal (sbitmap, sbitmap);\n+extern void sbitmap_zero (sbitmap);\n+extern void sbitmap_ones (sbitmap);\n+extern void sbitmap_vector_zero (sbitmap *, unsigned int);\n+extern void sbitmap_vector_ones (sbitmap *, unsigned int);\n+\n+extern void sbitmap_union_of_diff (sbitmap, sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_union_of_diff_cg (sbitmap, sbitmap, sbitmap, sbitmap);\n+extern void sbitmap_difference (sbitmap, sbitmap, sbitmap);\n+extern void sbitmap_not (sbitmap, sbitmap);\n+extern void sbitmap_a_or_b_and_c (sbitmap, sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_a_or_b_and_c_cg (sbitmap, sbitmap, sbitmap, sbitmap);\n+extern void sbitmap_a_and_b_or_c (sbitmap, sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_a_and_b_or_c_cg (sbitmap, sbitmap, sbitmap, sbitmap);\n+extern void sbitmap_a_and_b (sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_a_and_b_cg (sbitmap, sbitmap, sbitmap);\n+extern void sbitmap_a_or_b (sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_a_or_b_cg (sbitmap, sbitmap, sbitmap);\n+extern void sbitmap_a_xor_b (sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_a_xor_b_cg (sbitmap, sbitmap, sbitmap);\n+extern bool sbitmap_a_subset_b_p (sbitmap, sbitmap);\n+\n+extern int sbitmap_first_set_bit (sbitmap);\n+extern int sbitmap_last_set_bit (sbitmap);\n+\n+extern void sbitmap_intersect_of_predsucc (sbitmap, sbitmap *, int,\n+\t\t\t\t\t   struct int_list **);\n #define sbitmap_intersect_of_predecessors  sbitmap_intersect_of_predsucc\n #define sbitmap_intersect_of_successors    sbitmap_intersect_of_predsucc\n \n-extern void sbitmap_union_of_predsucc\tPARAMS ((sbitmap, sbitmap *, int,\n-\t\t\t\t\t\t struct int_list **));\n+extern void sbitmap_union_of_predsucc (sbitmap, sbitmap *, int,\n+\t\t\t\t       struct int_list **);\n #define sbitmap_union_of_predecessors  sbitmap_union_of_predsucc\n #define sbitmap_union_of_successors    sbitmap_union_of_predsucc\n \n-/* Intersection and Union of preds/succs using the new flow graph \n+/* Intersection and Union of preds/succs using the new flow graph\n    structure instead of the pred/succ arrays.  */\n \n-extern void sbitmap_intersection_of_succs  PARAMS ((sbitmap, sbitmap *, int));\n-extern void sbitmap_intersection_of_preds  PARAMS ((sbitmap, sbitmap *, int));\n-extern void sbitmap_union_of_succs\t   PARAMS ((sbitmap, sbitmap *, int));\n-extern void sbitmap_union_of_preds\t   PARAMS ((sbitmap, sbitmap *, int));\n+extern void sbitmap_intersection_of_succs (sbitmap, sbitmap *, int);\n+extern void sbitmap_intersection_of_preds (sbitmap, sbitmap *, int);\n+extern void sbitmap_union_of_succs (sbitmap, sbitmap *, int);\n+extern void sbitmap_union_of_preds (sbitmap, sbitmap *, int);\n \n-extern void debug_sbitmap\t\t   PARAMS ((sbitmap));\n+extern void debug_sbitmap (sbitmap);\n #endif /* ! GCC_SBITMAP_H */"}, {"sha": "14f64e8cb2e175f9ca678a410ddaa16e09c38e5f", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,6 +1,6 @@\n /* scan-decls.c - Extracts declarations from cpp output.\n    Copyright (C) 1993, 1995, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -25,8 +25,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"scan.h\"\n \n-static void skip_to_closing_brace PARAMS ((cpp_reader *));\n-static const cpp_token *get_a_token PARAMS ((cpp_reader *));\n+static void skip_to_closing_brace (cpp_reader *);\n+static const cpp_token *get_a_token (cpp_reader *);\n \n int brace_nesting = 0;\n \n@@ -43,8 +43,7 @@ int current_extern_C = 0;\n \n /* Get a token but skip padding.  */\n static const cpp_token *\n-get_a_token (pfile)\n-     cpp_reader *pfile;\n+get_a_token (cpp_reader *pfile)\n {\n   for (;;)\n     {\n@@ -55,8 +54,7 @@ get_a_token (pfile)\n }\n \n static void\n-skip_to_closing_brace (pfile)\n-     cpp_reader *pfile;\n+skip_to_closing_brace (cpp_reader *pfile)\n {\n   int nesting = 1;\n   for (;;)\n@@ -95,10 +93,8 @@ Here dname is the actual name being declared.\n */\n \n int\n-scan_decls (pfile, argc, argv)\n-     cpp_reader *pfile;\n-     int argc ATTRIBUTE_UNUSED;\n-     char **argv ATTRIBUTE_UNUSED;\n+scan_decls (cpp_reader *pfile, int argc ATTRIBUTE_UNUSED,\n+\t    char **argv ATTRIBUTE_UNUSED)\n {\n   int saw_extern, saw_inline;\n   cpp_token prev_id;"}, {"sha": "f32606107979b03bc238497d50707659746928ad", "filename": "gcc/scan.c", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fscan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fscan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* Utility functions for scan-decls and fix-header programs.\n-   Copyright (C) 1993, 1994, 1998, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1998, 2002, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -26,9 +26,7 @@ int source_lineno = 1;\n sstring source_filename;\n \n void\n-make_sstring_space (str, count)\n-     sstring *str;\n-     int count;\n+make_sstring_space (sstring *str, int count)\n {\n   int cur_pos = str->ptr - str->base;\n   int cur_size = str->limit - str->base;\n@@ -43,9 +41,7 @@ make_sstring_space (str, count)\n }\n \n void\n-sstring_append (dst, src)\n-     sstring *dst;\n-     sstring *src;\n+sstring_append (sstring *dst, sstring *src)\n {\n   char *d, *s;\n   int count = SSTRING_LENGTH (src);\n@@ -59,10 +55,7 @@ sstring_append (dst, src)\n }\n \n int\n-scan_ident (fp, s, c)\n-     FILE *fp;\n-     sstring *s;\n-     int c;\n+scan_ident (FILE *fp, sstring *s, int c)\n {\n   s->ptr = s->base;\n   if (ISIDST (c))\n@@ -81,10 +74,7 @@ scan_ident (fp, s, c)\n }\n \n int\n-scan_string (fp, s, init)\n-     FILE *fp;\n-     sstring *s;\n-     int init;\n+scan_string (FILE *fp, sstring *s, int init)\n {\n   int c;\n \n@@ -116,9 +106,7 @@ scan_string (fp, s, init)\n /* Skip horizontal white spaces (spaces, tabs, and C-style comments).  */\n \n int\n-skip_spaces (fp, c)\n-     FILE *fp;\n-     int c;\n+skip_spaces (FILE *fp, int c)\n {\n   for (;;)\n     {\n@@ -154,10 +142,7 @@ skip_spaces (fp, c)\n }\n \n int\n-read_upto (fp, str, delim)\n-     FILE *fp;\n-     sstring *str;\n-     int delim;\n+read_upto (FILE *fp, sstring *str, int delim)\n {\n   int ch;\n \n@@ -174,9 +159,7 @@ read_upto (fp, str, delim)\n }\n \n int\n-get_token (fp, s)\n-     FILE *fp;\n-     sstring *s;\n+get_token (FILE *fp, sstring *s)\n {\n   int c;\n \n@@ -244,9 +227,7 @@ get_token (fp, s)\n }\n \n unsigned int\n-hashstr (str, len)\n-     const char *str;\n-     unsigned int len;\n+hashstr (const char *str, unsigned int len)\n {\n   unsigned int n = len;\n   unsigned int r = 0;"}, {"sha": "cb85feaae387bdd606b74d9851efd5443e7e35e0", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 44, "deletions": 79, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,7 +1,7 @@\n /* Instruction scheduling pass.  This file computes dependencies between\n    instructions.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -92,24 +92,23 @@ static sbitmap *output_dependency_cache;\n static sbitmap *forward_dependency_cache;\n #endif\n \n-static int deps_may_trap_p PARAMS ((rtx));\n-static void add_dependence_list PARAMS ((rtx, rtx, enum reg_note));\n-static void add_dependence_list_and_free PARAMS ((rtx, rtx *, enum reg_note));\n-static void set_sched_group_p PARAMS ((rtx));\n+static int deps_may_trap_p (rtx);\n+static void add_dependence_list (rtx, rtx, enum reg_note);\n+static void add_dependence_list_and_free (rtx, rtx *, enum reg_note);\n+static void set_sched_group_p (rtx);\n \n-static void flush_pending_lists PARAMS ((struct deps *, rtx, int, int));\n-static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n-static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n-static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n+static void flush_pending_lists (struct deps *, rtx, int, int);\n+static void sched_analyze_1 (struct deps *, rtx, rtx);\n+static void sched_analyze_2 (struct deps *, rtx, rtx);\n+static void sched_analyze_insn (struct deps *, rtx, rtx, rtx);\n \n-static rtx get_condition PARAMS ((rtx));\n-static int conditions_mutex_p PARAMS ((rtx, rtx));\n+static rtx get_condition (rtx);\n+static int conditions_mutex_p (rtx, rtx);\n \f\n /* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n \n static int\n-deps_may_trap_p (mem)\n-     rtx mem;\n+deps_may_trap_p (rtx mem)\n {\n   rtx addr = XEXP (mem, 0);\n \n@@ -124,9 +123,7 @@ deps_may_trap_p (mem)\n    if LIST does not contain INSN.  */\n \n rtx\n-find_insn_list (insn, list)\n-     rtx insn;\n-     rtx list;\n+find_insn_list (rtx insn, rtx list)\n {\n   while (list)\n     {\n@@ -140,8 +137,7 @@ find_insn_list (insn, list)\n /* Find the condition under which INSN is executed.  */\n \n static rtx\n-get_condition (insn)\n-     rtx insn;\n+get_condition (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   rtx cond;\n@@ -172,8 +168,7 @@ get_condition (insn)\n /* Return nonzero if conditions COND1 and COND2 can never be both true.  */\n \n static int\n-conditions_mutex_p (cond1, cond2)\n-     rtx cond1, cond2;\n+conditions_mutex_p (rtx cond1, rtx cond2)\n {\n   if (GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n       && GET_RTX_CLASS (GET_CODE (cond2)) == '<'\n@@ -190,10 +185,7 @@ conditions_mutex_p (cond1, cond2)\n    nonzero if a new entry has been added to insn's LOG_LINK.  */\n \n int\n-add_dependence (insn, elem, dep_type)\n-     rtx insn;\n-     rtx elem;\n-     enum reg_note dep_type;\n+add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n {\n   rtx link;\n   int present_p;\n@@ -289,7 +281,7 @@ add_dependence (insn, elem, dep_type)\n \t\tabort ();\n \t    }\n #endif\n-\t  \n+\n \t  /* If this is a more restrictive type of dependence than the existing\n \t     one, then change the existing dependence to this type.  */\n \t  if ((int) dep_type < (int) REG_NOTE_KIND (link))\n@@ -340,9 +332,7 @@ add_dependence (insn, elem, dep_type)\n /* A convenience wrapper to operate on an entire list.  */\n \n static void\n-add_dependence_list (insn, list, dep_type)\n-     rtx insn, list;\n-     enum reg_note dep_type;\n+add_dependence_list (rtx insn, rtx list, enum reg_note dep_type)\n {\n   for (; list; list = XEXP (list, 1))\n     add_dependence (insn, XEXP (list, 0), dep_type);\n@@ -351,10 +341,7 @@ add_dependence_list (insn, list, dep_type)\n /* Similar, but free *LISTP at the same time.  */\n \n static void\n-add_dependence_list_and_free (insn, listp, dep_type)\n-     rtx insn;\n-     rtx *listp;\n-     enum reg_note dep_type;\n+add_dependence_list_and_free (rtx insn, rtx *listp, enum reg_note dep_type)\n {\n   rtx list, next;\n   for (list = *listp, *listp = NULL; list ; list = next)\n@@ -369,8 +356,7 @@ add_dependence_list_and_free (insn, listp, dep_type)\n    goes along with that.  */\n \n static void\n-set_sched_group_p (insn)\n-     rtx insn;\n+set_sched_group_p (rtx insn)\n {\n   rtx prev;\n \n@@ -396,9 +382,8 @@ set_sched_group_p (insn)\n    so that we can do memory aliasing on it.  */\n \n void\n-add_insn_mem_dependence (deps, insn_list, mem_list, insn, mem)\n-     struct deps *deps;\n-     rtx *insn_list, *mem_list, insn, mem;\n+add_insn_mem_dependence (struct deps *deps, rtx *insn_list, rtx *mem_list,\n+\t\t\t rtx insn, rtx mem)\n {\n   rtx link;\n \n@@ -421,10 +406,8 @@ add_insn_mem_dependence (deps, insn_list, mem_list, insn, mem)\n    dependencies for a read operation, similarly with FOR_WRITE.  */\n \n static void\n-flush_pending_lists (deps, insn, for_read, for_write)\n-     struct deps *deps;\n-     rtx insn;\n-     int for_read, for_write;\n+flush_pending_lists (struct deps *deps, rtx insn, int for_read,\n+\t\t     int for_write)\n {\n   if (for_write)\n     {\n@@ -449,10 +432,7 @@ flush_pending_lists (deps, insn, for_read, for_write)\n    destination of X, and reads of everything mentioned.  */\n \n static void\n-sched_analyze_1 (deps, x, insn)\n-     struct deps *deps;\n-     rtx x;\n-     rtx insn;\n+sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n {\n   int regno;\n   rtx dest = XEXP (x, 0);\n@@ -485,13 +465,13 @@ sched_analyze_1 (deps, x, insn)\n \t || GET_CODE (dest) == SIGN_EXTRACT\n \t || read_modify_subreg_p (dest))\n         {\n-\t  /* These both read and modify the result.  We must handle \n+\t  /* These both read and modify the result.  We must handle\n              them as writes to get proper dependencies for following\n              instructions.  We must handle them as reads to get proper\n              dependencies from this to previous instructions.\n              Thus we need to call sched_analyze_2.  */\n \n-\t  sched_analyze_2 (deps, XEXP (dest, 0), insn);  \n+\t  sched_analyze_2 (deps, XEXP (dest, 0), insn);\n \t}\n       if (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n \t{\n@@ -616,10 +596,7 @@ sched_analyze_1 (deps, x, insn)\n /* Analyze the uses of memory and registers in rtx X in INSN.  */\n \n static void\n-sched_analyze_2 (deps, x, insn)\n-     struct deps *deps;\n-     rtx x;\n-     rtx insn;\n+sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n {\n   int i;\n   int j;\n@@ -816,10 +793,7 @@ sched_analyze_2 (deps, x, insn)\n /* Analyze an INSN with pattern X to find all dependencies.  */\n \n static void\n-sched_analyze_insn (deps, x, insn, loop_notes)\n-     struct deps *deps;\n-     rtx x, insn;\n-     rtx loop_notes;\n+sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n {\n   RTX_CODE code = GET_CODE (x);\n   rtx link;\n@@ -1161,9 +1135,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n    for every dependency.  */\n \n void\n-sched_analyze (deps, head, tail)\n-     struct deps *deps;\n-     rtx head, tail;\n+sched_analyze (struct deps *deps, rtx head, rtx tail)\n {\n   rtx insn;\n   rtx loop_notes = 0;\n@@ -1296,7 +1268,7 @@ sched_analyze (deps, head, tail)\n \n       /* Now that we have completed handling INSN, check and see if it is\n \t a CLOBBER beginning a libcall block.   If it is, record the\n-\t end of the libcall sequence. \n+\t end of the libcall sequence.\n \n \t We want to schedule libcall blocks as a unit before reload.  While\n \t this restricts scheduling, it preserves the meaning of a libcall\n@@ -1307,7 +1279,7 @@ sched_analyze (deps, head, tail)\n \t a libcall block.  */\n       if (!reload_completed\n \t  /* Note we may have nested libcall sequences.  We only care about\n-\t     the outermost libcall sequence.  */ \n+\t     the outermost libcall sequence.  */\n \t  && deps->libcall_block_tail_insn == 0\n \t  /* The sequence must start with a clobber of a register.  */\n \t  && GET_CODE (insn) == INSN\n@@ -1348,18 +1320,15 @@ sched_analyze (deps, head, tail)\n    given DEP_TYPE.  The forward dependence should be not exist before.  */\n \n void\n-add_forward_dependence (from, to, dep_type)\n-     rtx from;\n-     rtx to;\n-     enum reg_note dep_type;\n+add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n {\n   rtx new_link;\n \n #ifdef ENABLE_CHECKING\n   /* If add_dependence is working properly there should never\n      be notes, deleted insns or duplicates in the backward\n      links.  Thus we need not check for them here.\n-     \n+\n      However, if we have enabled checking we might as well go\n      ahead and verify that add_dependence worked properly.  */\n   if (GET_CODE (from) == NOTE\n@@ -1374,11 +1343,11 @@ add_forward_dependence (from, to, dep_type)\n     SET_BIT (forward_dependency_cache[INSN_LUID (from)],\n \t     INSN_LUID (to));\n #endif\n-  \n+\n   new_link = alloc_INSN_LIST (to, INSN_DEPEND (from));\n-  \n+\n   PUT_REG_NOTE_KIND (new_link, dep_type);\n-  \n+\n   INSN_DEPEND (from) = new_link;\n   INSN_DEP_COUNT (to) += 1;\n }\n@@ -1388,8 +1357,7 @@ add_forward_dependence (from, to, dep_type)\n    INSN_DEPEND.  */\n \n void\n-compute_forward_dependences (head, tail)\n-     rtx head, tail;\n+compute_forward_dependences (rtx head, rtx tail)\n {\n   rtx insn, link;\n   rtx next_tail;\n@@ -1409,8 +1377,7 @@ compute_forward_dependences (head, tail)\n    n_bbs is the number of region blocks.  */\n \n void\n-init_deps (deps)\n-     struct deps *deps;\n+init_deps (struct deps *deps)\n {\n   int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n \n@@ -1435,8 +1402,7 @@ init_deps (deps)\n /* Free insn lists found in DEPS.  */\n \n void\n-free_deps (deps)\n-     struct deps *deps;\n+free_deps (struct deps *deps)\n {\n   int i;\n \n@@ -1469,8 +1435,7 @@ free_deps (deps)\n    it is used in the estimate of profitability.  */\n \n void\n-init_dependency_caches (luid)\n-     int luid;\n+init_dependency_caches (int luid)\n {\n   /* ?!? We could save some memory by computing a per-region luid mapping\n      which could reduce both the number of vectors in the cache and the size\n@@ -1496,7 +1461,7 @@ init_dependency_caches (luid)\n /* Free the caches allocated in init_dependency_caches.  */\n \n void\n-free_dependency_caches ()\n+free_dependency_caches (void)\n {\n   if (true_dependency_cache)\n     {\n@@ -1517,7 +1482,7 @@ free_dependency_caches ()\n    code.  */\n \n void\n-init_deps_global ()\n+init_deps_global (void)\n {\n   reg_pending_sets = INITIALIZE_REG_SET (reg_pending_sets_head);\n   reg_pending_clobbers = INITIALIZE_REG_SET (reg_pending_clobbers_head);\n@@ -1528,7 +1493,7 @@ init_deps_global ()\n /* Free everything used by the dependency analysis code.  */\n \n void\n-finish_deps_global ()\n+finish_deps_global (void)\n {\n   FREE_REG_SET (reg_pending_sets);\n   FREE_REG_SET (reg_pending_clobbers);"}, {"sha": "0e316b51d6616154715f1919881c429bb76ebcaa", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 35, "deletions": 51, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -48,25 +48,25 @@ static int target_n_insns;\n static int sched_n_insns;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n-static void init_ready_list PARAMS ((struct ready_list *));\n-static int can_schedule_ready_p PARAMS ((rtx));\n-static int new_ready PARAMS ((rtx));\n-static int schedule_more_p PARAMS ((void));\n-static const char *ebb_print_insn PARAMS ((rtx, int));\n-static int rank PARAMS ((rtx, rtx));\n-static int contributes_to_priority PARAMS ((rtx, rtx));\n-static void compute_jump_reg_dependencies PARAMS ((rtx, regset));\n-static basic_block earliest_block_with_similiar_load PARAMS ((basic_block,\n-\t\t\t\t\t\t\t      rtx));\n-static void add_deps_for_risky_insns PARAMS ((rtx, rtx));\n-static basic_block schedule_ebb PARAMS ((rtx, rtx));\n-static basic_block fix_basic_block_boundaries PARAMS ((basic_block, basic_block, rtx, rtx));\n-static void add_missing_bbs PARAMS ((rtx, basic_block, basic_block));\n+static void init_ready_list (struct ready_list *);\n+static int can_schedule_ready_p (rtx);\n+static int new_ready (rtx);\n+static int schedule_more_p (void);\n+static const char *ebb_print_insn (rtx, int);\n+static int rank (rtx, rtx);\n+static int contributes_to_priority (rtx, rtx);\n+static void compute_jump_reg_dependencies (rtx, regset);\n+static basic_block earliest_block_with_similiar_load (basic_block, rtx);\n+static void add_deps_for_risky_insns (rtx, rtx);\n+static basic_block schedule_ebb (rtx, rtx);\n+static basic_block fix_basic_block_boundaries (basic_block, basic_block, rtx,\n+\t\t\t\t\t       rtx);\n+static void add_missing_bbs (rtx, basic_block, basic_block);\n \n /* Return nonzero if there are more insns that should be scheduled.  */\n \n static int\n-schedule_more_p ()\n+schedule_more_p (void)\n {\n   return sched_n_insns < target_n_insns;\n }\n@@ -75,8 +75,7 @@ schedule_more_p ()\n    once before scheduling a set of insns.  */\n \n static void\n-init_ready_list (ready)\n-     struct ready_list *ready;\n+init_ready_list (struct ready_list *ready)\n {\n   rtx prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n@@ -105,8 +104,7 @@ init_ready_list (ready)\n    insn can be scheduled, nonzero if we should silently discard it.  */\n \n static int\n-can_schedule_ready_p (insn)\n-     rtx insn ATTRIBUTE_UNUSED;\n+can_schedule_ready_p (rtx insn ATTRIBUTE_UNUSED)\n {\n   sched_n_insns++;\n   return 1;\n@@ -116,8 +114,7 @@ can_schedule_ready_p (insn)\n    if it should be moved to the ready list or the queue, or zero if we\n    should silently discard it.  */\n static int\n-new_ready (next)\n-     rtx next ATTRIBUTE_UNUSED;\n+new_ready (rtx next ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n@@ -128,9 +125,7 @@ new_ready (next)\n    to be formatted so that multiple output lines will line up nicely.  */\n \n static const char *\n-ebb_print_insn (insn, aligned)\n-     rtx insn;\n-     int aligned ATTRIBUTE_UNUSED;\n+ebb_print_insn (rtx insn, int aligned ATTRIBUTE_UNUSED)\n {\n   static char tmp[80];\n \n@@ -143,8 +138,7 @@ ebb_print_insn (insn, aligned)\n    is to be preferred.  Zero if they are equally good.  */\n \n static int\n-rank (insn1, insn2)\n-     rtx insn1, insn2;\n+rank (rtx insn1, rtx insn2)\n {\n   basic_block bb1 = BLOCK_FOR_INSN (insn1);\n   basic_block bb2 = BLOCK_FOR_INSN (insn2);\n@@ -163,8 +157,8 @@ rank (insn1, insn2)\n    calculations.  */\n \n static int\n-contributes_to_priority (next, insn)\n-     rtx next ATTRIBUTE_UNUSED, insn ATTRIBUTE_UNUSED;\n+contributes_to_priority (rtx next ATTRIBUTE_UNUSED,\n+\t\t\t rtx insn ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n@@ -173,9 +167,7 @@ contributes_to_priority (next, insn)\n    to be set by this jump in SET.  */\n \n static void\n-compute_jump_reg_dependencies (insn, set)\n-     rtx insn;\n-     regset set;\n+compute_jump_reg_dependencies (rtx insn, regset set)\n {\n   basic_block b = BLOCK_FOR_INSN (insn);\n   edge e;\n@@ -210,9 +202,7 @@ static struct sched_info ebb_sched_info =\n    Place blocks from FIRST to LAST before BEFORE.  */\n \n static void\n-add_missing_bbs (before, first, last)\n-     rtx before;\n-     basic_block first, last;\n+add_missing_bbs (rtx before, basic_block first, basic_block last)\n {\n   for (; last != first->prev_bb; last = last->prev_bb)\n     {\n@@ -229,9 +219,8 @@ add_missing_bbs (before, first, last)\n    structures between BB and LAST.  */\n \n static basic_block\n-fix_basic_block_boundaries (bb, last, head, tail)\n-     basic_block bb, last;\n-     rtx head, tail;\n+fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n+\t\t\t    rtx tail)\n {\n   rtx insn = head;\n   rtx last_inside = bb->head;\n@@ -288,7 +277,7 @@ fix_basic_block_boundaries (bb, last, head, tail)\n \t         In this case we can create new basic block.  It is\n \t         always exactly one basic block last in the sequence.  Handle\n \t         it by splitting the edge and repositioning the block.\n-\t         This is somewhat hackish, but at least avoid cut&paste \n+\t         This is somewhat hackish, but at least avoid cut&paste\n \n \t         A safer solution can be to bring the code into sequence,\n \t         do the split and re-emit it back in case this will ever\n@@ -359,9 +348,7 @@ fix_basic_block_boundaries (bb, last, head, tail)\n    blocks in EBB.  The list is formed in `add_deps_for_risky_insns'.  */\n \n static basic_block\n-earliest_block_with_similiar_load (last_block, load_insn)\n-     basic_block last_block;\n-     rtx load_insn;\n+earliest_block_with_similiar_load (basic_block last_block, rtx load_insn)\n {\n   rtx back_link;\n   basic_block bb, earliest_block = NULL;\n@@ -394,7 +381,7 @@ earliest_block_with_similiar_load (last_block, load_insn)\n \t\t  if (haifa_classify_insn (insn2) != PFREE_CANDIDATE)\n \t\t    /* insn2 not guaranteed to be a 1 base reg load.  */\n \t\t    continue;\n-\t\t  \n+\n \t\t  for (bb = last_block; bb; bb = bb->aux)\n \t\t    if (insn2_block == bb)\n \t\t      break;\n@@ -414,15 +401,14 @@ earliest_block_with_similiar_load (last_block, load_insn)\n    insns in given ebb.  */\n \n static void\n-add_deps_for_risky_insns (head, tail)\n-     rtx head, tail;\n+add_deps_for_risky_insns (rtx head, rtx tail)\n {\n   rtx insn, prev;\n   int class;\n   rtx last_jump = NULL_RTX;\n   rtx next_tail = NEXT_INSN (tail);\n   basic_block last_block = NULL, bb;\n-  \n+\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == JUMP_INSN)\n       {\n@@ -461,7 +447,7 @@ add_deps_for_risky_insns (head, tail)\n \t    if (add_dependence (insn, prev, REG_DEP_ANTI))\n \t      add_forward_dependence (prev, insn, REG_DEP_ANTI);\n             break;\n-\t    \n+\n           default:\n             break;\n \t  }\n@@ -479,8 +465,7 @@ add_deps_for_risky_insns (head, tail)\n    and TAIL.  */\n \n static basic_block\n-schedule_ebb (head, tail)\n-     rtx head, tail;\n+schedule_ebb (rtx head, rtx tail)\n {\n   int n_insns;\n   basic_block b;\n@@ -564,8 +549,7 @@ schedule_ebb (head, tail)\n    this pass.  */\n \n void\n-schedule_ebbs (dump_file)\n-     FILE *dump_file;\n+schedule_ebbs (FILE *dump_file)\n {\n   basic_block bb;\n "}, {"sha": "f255b068ded8e92ad6db00890f976e32cd07b8f2", "filename": "gcc/sched-int.h", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,7 +1,7 @@\n /* Instruction scheduling pass.  This file contains definitions used\n    internally in the scheduler.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -123,7 +123,7 @@ struct sched_info\n {\n   /* Add all insns that are initially ready to the ready list.  Called once\n      before scheduling a set of insns.  */\n-  void (*init_ready_list) PARAMS ((struct ready_list *));\n+  void (*init_ready_list) (struct ready_list *);\n   /* Called after taking an insn from the ready list.  Returns nonzero if\n      this insn can be scheduled, nonzero if we should silently discard it.  */\n   int (*can_schedule_ready_p) PARAMS ((rtx));\n@@ -337,56 +337,55 @@ enum INSN_TRAP_CLASS\n #endif\n \n /* Functions in sched-vis.c.  */\n-extern void init_target_units PARAMS ((void));\n-extern void insn_print_units PARAMS ((rtx));\n-extern void init_block_visualization PARAMS ((void));\n-extern void print_block_visualization PARAMS ((const char *));\n-extern void visualize_scheduled_insns PARAMS ((int));\n-extern void visualize_no_unit PARAMS ((rtx));\n-extern void visualize_stall_cycles PARAMS ((int));\n-extern void visualize_alloc PARAMS ((void));\n-extern void visualize_free PARAMS ((void));\n+extern void init_target_units (void);\n+extern void insn_print_units (rtx);\n+extern void init_block_visualization (void);\n+extern void print_block_visualization (const char *);\n+extern void visualize_scheduled_insns (int);\n+extern void visualize_no_unit (rtx);\n+extern void visualize_stall_cycles (int);\n+extern void visualize_alloc (void);\n+extern void visualize_free (void);\n \n /* Functions in sched-deps.c.  */\n-extern int add_dependence PARAMS ((rtx, rtx, enum reg_note));\n-extern void add_insn_mem_dependence PARAMS ((struct deps *, rtx *, rtx *, rtx,\n-\t\t\t\t\t     rtx));\n-extern void sched_analyze PARAMS ((struct deps *, rtx, rtx));\n-extern void init_deps PARAMS ((struct deps *));\n-extern void free_deps PARAMS ((struct deps *));\n-extern void init_deps_global PARAMS ((void));\n-extern void finish_deps_global PARAMS ((void));\n-extern void add_forward_dependence PARAMS ((rtx, rtx, enum reg_note));\n-extern void compute_forward_dependences PARAMS ((rtx, rtx));\n-extern rtx find_insn_list PARAMS ((rtx, rtx));\n-extern void init_dependency_caches PARAMS ((int));\n-extern void free_dependency_caches PARAMS ((void));\n+extern int add_dependence (rtx, rtx, enum reg_note);\n+extern void add_insn_mem_dependence (struct deps *, rtx *, rtx *, rtx, rtx);\n+extern void sched_analyze (struct deps *, rtx, rtx);\n+extern void init_deps (struct deps *);\n+extern void free_deps (struct deps *);\n+extern void init_deps_global (void);\n+extern void finish_deps_global (void);\n+extern void add_forward_dependence (rtx, rtx, enum reg_note);\n+extern void compute_forward_dependences (rtx, rtx);\n+extern rtx find_insn_list (rtx, rtx);\n+extern void init_dependency_caches (int);\n+extern void free_dependency_caches (void);\n \n /* Functions in haifa-sched.c.  */\n-extern int haifa_classify_insn PARAMS ((rtx));\n-extern void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n-extern int no_real_insns_p PARAMS ((rtx, rtx));\n+extern int haifa_classify_insn (rtx);\n+extern void get_block_head_tail (int, rtx *, rtx *);\n+extern int no_real_insns_p (rtx, rtx);\n \n-extern void rm_line_notes PARAMS ((rtx, rtx));\n-extern void save_line_notes PARAMS ((int, rtx, rtx));\n-extern void restore_line_notes PARAMS ((rtx, rtx));\n-extern void rm_redundant_line_notes PARAMS ((void));\n-extern void rm_other_notes PARAMS ((rtx, rtx));\n+extern void rm_line_notes (rtx, rtx);\n+extern void save_line_notes (int, rtx, rtx);\n+extern void restore_line_notes (rtx, rtx);\n+extern void rm_redundant_line_notes (void);\n+extern void rm_other_notes (rtx, rtx);\n \n-extern int insn_issue_delay PARAMS ((rtx));\n-extern int set_priorities PARAMS ((rtx, rtx));\n+extern int insn_issue_delay (rtx);\n+extern int set_priorities (rtx, rtx);\n \n-extern rtx sched_emit_insn PARAMS ((rtx));\n-extern void schedule_block PARAMS ((int, int));\n-extern void sched_init PARAMS ((FILE *));\n-extern void sched_finish PARAMS ((void));\n+extern rtx sched_emit_insn (rtx);\n+extern void schedule_block (int, int);\n+extern void sched_init (FILE *);\n+extern void sched_finish (void);\n \n-extern void ready_add PARAMS ((struct ready_list *, rtx));\n+extern void ready_add (struct ready_list *, rtx);\n \n /* The following are exported for the benefit of debugging functions.  It\n    would be nicer to keep them private to haifa-sched.c.  */\n-extern int insn_unit PARAMS ((rtx));\n-extern int insn_cost PARAMS ((rtx, rtx, rtx));\n-extern rtx get_unit_last_insn PARAMS ((int));\n-extern int actual_hazard_this_instance PARAMS ((int, int, rtx, int, int));\n-extern void print_insn PARAMS ((char *, rtx, int));\n+extern int insn_unit (rtx);\n+extern int insn_cost (rtx, rtx, rtx);\n+extern rtx get_unit_last_insn (int);\n+extern int actual_hazard_this_instance (int, int, rtx, int, int);\n+extern void print_insn (char *, rtx, int);"}, {"sha": "cebb389dd5bb2716c582a18e8f5be824f244d91f", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 92, "deletions": 144, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -116,9 +116,9 @@ static int *out_edges;\n #define IN_EDGES(block) (in_edges[block])\n #define OUT_EDGES(block) (out_edges[block])\n \n-static int is_cfg_nonregular PARAMS ((void));\n-static int build_control_flow PARAMS ((struct edge_list *));\n-static void new_edge PARAMS ((int, int));\n+static int is_cfg_nonregular (void);\n+static int build_control_flow (struct edge_list *);\n+static void new_edge (int, int);\n \n /* A region is the main entity for interblock scheduling: insns\n    are allowed to move between blocks in the same region, along\n@@ -153,12 +153,12 @@ static int *containing_rgn;\n #define BLOCK_TO_BB(block) (block_to_bb[block])\n #define CONTAINING_RGN(block) (containing_rgn[block])\n \n-void debug_regions PARAMS ((void));\n-static void find_single_block_region PARAMS ((void));\n-static void find_rgns PARAMS ((struct edge_list *, dominance_info));\n-static int too_large PARAMS ((int, int *, int *));\n+void debug_regions (void);\n+static void find_single_block_region (void);\n+static void find_rgns (struct edge_list *, dominance_info);\n+static int too_large (int, int *, int *);\n \n-extern void debug_live PARAMS ((int, int));\n+extern void debug_live (int, int);\n \n /* Blocks of the current region being scheduled.  */\n static int current_nr_blocks;\n@@ -177,7 +177,7 @@ bitlst;\n static int bitlst_table_last;\n static int *bitlst_table;\n \n-static void extract_bitlst PARAMS ((sbitmap, bitlst *));\n+static void extract_bitlst (sbitmap, bitlst *);\n \n /* Target info declarations.\n \n@@ -218,10 +218,10 @@ static int target_bb;\n typedef bitlst edgelst;\n \n /* Target info functions.  */\n-static void split_edges PARAMS ((int, int, edgelst *));\n-static void compute_trg_info PARAMS ((int));\n-void debug_candidate PARAMS ((int));\n-void debug_candidates PARAMS ((int));\n+static void split_edges (int, int, edgelst *);\n+static void compute_trg_info (int);\n+void debug_candidate (int);\n+void debug_candidates (int);\n \n /* Dominators array: dom[i] contains the sbitmap of dominators of\n    bb i in the region.  */\n@@ -269,7 +269,7 @@ static edgeset *pot_split;\n /* For every bb, a set of its ancestor edges.  */\n static edgeset *ancestor_edges;\n \n-static void compute_dom_prob_ps PARAMS ((int));\n+static void compute_dom_prob_ps (int);\n \n #define INSN_PROBABILITY(INSN) (SRC_PROB (BLOCK_TO_BB (BLOCK_NUM (INSN))))\n #define IS_SPECULATIVE_INSN(INSN) (IS_SPECULATIVE (BLOCK_TO_BB (BLOCK_NUM (INSN))))\n@@ -280,29 +280,29 @@ static void compute_dom_prob_ps PARAMS ((int));\n #define MIN_PROBABILITY 40\n \n /* Speculative scheduling functions.  */\n-static int check_live_1 PARAMS ((int, rtx));\n-static void update_live_1 PARAMS ((int, rtx));\n-static int check_live PARAMS ((rtx, int));\n-static void update_live PARAMS ((rtx, int));\n-static void set_spec_fed PARAMS ((rtx));\n-static int is_pfree PARAMS ((rtx, int, int));\n-static int find_conditional_protection PARAMS ((rtx, int));\n-static int is_conditionally_protected PARAMS ((rtx, int, int));\n-static int is_prisky PARAMS ((rtx, int, int));\n-static int is_exception_free PARAMS ((rtx, int, int));\n-\n-static bool sets_likely_spilled PARAMS ((rtx));\n-static void sets_likely_spilled_1 PARAMS ((rtx, rtx, void *));\n-static void add_branch_dependences PARAMS ((rtx, rtx));\n-static void compute_block_backward_dependences PARAMS ((int));\n-void debug_dependencies PARAMS ((void));\n-\n-static void init_regions PARAMS ((void));\n-static void schedule_region PARAMS ((int));\n-static rtx concat_INSN_LIST PARAMS ((rtx, rtx));\n-static void concat_insn_mem_list PARAMS ((rtx, rtx, rtx *, rtx *));\n-static void propagate_deps PARAMS ((int, struct deps *));\n-static void free_pending_lists PARAMS ((void));\n+static int check_live_1 (int, rtx);\n+static void update_live_1 (int, rtx);\n+static int check_live (rtx, int);\n+static void update_live (rtx, int);\n+static void set_spec_fed (rtx);\n+static int is_pfree (rtx, int, int);\n+static int find_conditional_protection (rtx, int);\n+static int is_conditionally_protected (rtx, int, int);\n+static int is_prisky (rtx, int, int);\n+static int is_exception_free (rtx, int, int);\n+\n+static bool sets_likely_spilled (rtx);\n+static void sets_likely_spilled_1 (rtx, rtx, void *);\n+static void add_branch_dependences (rtx, rtx);\n+static void compute_block_backward_dependences (int);\n+void debug_dependencies (void);\n+\n+static void init_regions (void);\n+static void schedule_region (int);\n+static rtx concat_INSN_LIST (rtx, rtx);\n+static void concat_insn_mem_list (rtx, rtx, rtx *, rtx *);\n+static void propagate_deps (int, struct deps *);\n+static void free_pending_lists (void);\n \n /* Functions for construction of the control flow graph.  */\n \n@@ -313,7 +313,7 @@ static void free_pending_lists PARAMS ((void));\n    have nonlocal gotos.  */\n \n static int\n-is_cfg_nonregular ()\n+is_cfg_nonregular (void)\n {\n   basic_block b;\n   rtx insn;\n@@ -374,8 +374,7 @@ is_cfg_nonregular ()\n    prevent cross block scheduling.  */\n \n static int\n-build_control_flow (edge_list)\n-     struct edge_list *edge_list;\n+build_control_flow (struct edge_list *edge_list)\n {\n   int i, unreachable, num_edges;\n   basic_block b;\n@@ -426,8 +425,7 @@ build_control_flow (edge_list)\n    integer lists.  */\n \n static void\n-new_edge (source, target)\n-     int source, target;\n+new_edge (int source, int target)\n {\n   int e, next_edge;\n   int curr_edge, fst_edge;\n@@ -481,9 +479,7 @@ new_edge (source, target)\n /* Translate a bit-set SET to a list BL of the bit-set members.  */\n \n static void\n-extract_bitlst (set, bl)\n-     sbitmap set;\n-     bitlst *bl;\n+extract_bitlst (sbitmap set, bitlst *bl)\n {\n   int i;\n \n@@ -507,7 +503,7 @@ extract_bitlst (set, bl)\n /* Print the regions, for debugging purposes.  Callable from debugger.  */\n \n void\n-debug_regions ()\n+debug_regions (void)\n {\n   int rgn, bb;\n \n@@ -537,7 +533,7 @@ debug_regions ()\n    scheduling.  */\n \n static void\n-find_single_block_region ()\n+find_single_block_region (void)\n {\n   basic_block bb;\n \n@@ -559,8 +555,7 @@ find_single_block_region ()\n    scheduling (compile time considerations), otherwise return 0.  */\n \n static int\n-too_large (block, num_bbs, num_insns)\n-     int block, *num_bbs, *num_insns;\n+too_large (int block, int *num_bbs, int *num_insns)\n {\n   (*num_bbs)++;\n   (*num_insns) += (INSN_LUID (BLOCK_END (block)) -\n@@ -618,9 +613,7 @@ too_large (block, num_bbs, num_insns)\n    of edge tables.  That would simplify it somewhat.  */\n \n static void\n-find_rgns (edge_list, dom)\n-     struct edge_list *edge_list;\n-     dominance_info dom;\n+find_rgns (struct edge_list *edge_list, dominance_info dom)\n {\n   int *max_hdr, *dfs_nr, *stack, *degree;\n   char no_loops = 1;\n@@ -1044,8 +1037,7 @@ find_rgns (edge_list, dom)\n    Assume that these values were already computed for bb's predecessors.  */\n \n static void\n-compute_dom_prob_ps (bb)\n-     int bb;\n+compute_dom_prob_ps (int bb)\n {\n   int nxt_in_edge, fst_in_edge, pred;\n   int fst_out_edge, nxt_out_edge, nr_out_edges, nr_rgn_out_edges;\n@@ -1123,10 +1115,7 @@ compute_dom_prob_ps (bb)\n    Note that bb_trg dominates bb_src.  */\n \n static void\n-split_edges (bb_src, bb_trg, bl)\n-     int bb_src;\n-     int bb_trg;\n-     edgelst *bl;\n+split_edges (int bb_src, int bb_trg, edgelst *bl)\n {\n   sbitmap src = (edgeset) sbitmap_alloc (pot_split[bb_src]->n_bits);\n   sbitmap_copy (src, pot_split[bb_src]);\n@@ -1141,8 +1130,7 @@ split_edges (bb_src, bb_trg, bl)\n    For speculative sources, compute their update-blocks and split-blocks.  */\n \n static void\n-compute_trg_info (trg)\n-     int trg;\n+compute_trg_info (int trg)\n {\n   candidate *sp;\n   edgelst el;\n@@ -1240,8 +1228,7 @@ compute_trg_info (trg)\n /* Print candidates info, for debugging purposes.  Callable from debugger.  */\n \n void\n-debug_candidate (i)\n-     int i;\n+debug_candidate (int i)\n {\n   if (!candidate_table[i].is_valid)\n     return;\n@@ -1278,8 +1265,7 @@ debug_candidate (i)\n /* Print candidates info, for debugging purposes.  Callable from debugger.  */\n \n void\n-debug_candidates (trg)\n-     int trg;\n+debug_candidates (int trg)\n {\n   int i;\n \n@@ -1295,9 +1281,7 @@ debug_candidates (trg)\n    of the split-blocks of src, otherwise return 1.  */\n \n static int\n-check_live_1 (src, x)\n-     int src;\n-     rtx x;\n+check_live_1 (int src, rtx x)\n {\n   int i;\n   int regno;\n@@ -1375,9 +1359,7 @@ check_live_1 (src, x)\n    of every update-block of src.  */\n \n static void\n-update_live_1 (src, x)\n-     int src;\n-     rtx x;\n+update_live_1 (int src, rtx x)\n {\n   int i;\n   int regno;\n@@ -1443,9 +1425,7 @@ update_live_1 (src, x)\n    ready-list or before the scheduling.  */\n \n static int\n-check_live (insn, src)\n-     rtx insn;\n-     int src;\n+check_live (rtx insn, int src)\n {\n   /* Find the registers set by instruction.  */\n   if (GET_CODE (PATTERN (insn)) == SET\n@@ -1470,9 +1450,7 @@ check_live (insn, src)\n    block src to trg.  */\n \n static void\n-update_live (insn, src)\n-     rtx insn;\n-     int src;\n+update_live (rtx insn, int src)\n {\n   /* Find the registers set by instruction.  */\n   if (GET_CODE (PATTERN (insn)) == SET\n@@ -1498,8 +1476,7 @@ update_live (insn, src)\n /* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */\n \n static void\n-set_spec_fed (load_insn)\n-     rtx load_insn;\n+set_spec_fed (rtx load_insn)\n {\n   rtx link;\n \n@@ -1512,9 +1489,7 @@ set_spec_fed (load_insn)\n branch depending on insn, that guards the speculative load.  */\n \n static int\n-find_conditional_protection (insn, load_insn_bb)\n-     rtx insn;\n-     int load_insn_bb;\n+find_conditional_protection (rtx insn, int load_insn_bb)\n {\n   rtx link;\n \n@@ -1549,9 +1524,7 @@ find_conditional_protection (insn, load_insn_bb)\n    Locate the branch by following INSN_DEPEND from insn1.  */\n \n static int\n-is_conditionally_protected (load_insn, bb_src, bb_trg)\n-     rtx load_insn;\n-     int bb_src, bb_trg;\n+is_conditionally_protected (rtx load_insn, int bb_src, int bb_trg)\n {\n   rtx link;\n \n@@ -1601,9 +1574,7 @@ is_conditionally_protected (load_insn, bb_src, bb_trg)\n    load2 anyhow.  */\n \n static int\n-is_pfree (load_insn, bb_src, bb_trg)\n-     rtx load_insn;\n-     int bb_src, bb_trg;\n+is_pfree (rtx load_insn, int bb_src, int bb_trg)\n {\n   rtx back_link;\n   candidate *candp = candidate_table + bb_src;\n@@ -1654,9 +1625,7 @@ is_pfree (load_insn, bb_src, bb_trg)\n    a compare on load_insn's address).  */\n \n static int\n-is_prisky (load_insn, bb_src, bb_trg)\n-     rtx load_insn;\n-     int bb_src, bb_trg;\n+is_prisky (rtx load_insn, int bb_src, int bb_trg)\n {\n   if (FED_BY_SPEC_LOAD (load_insn))\n     return 1;\n@@ -1676,9 +1645,7 @@ is_prisky (load_insn, bb_src, bb_trg)\n    and 0 otherwise.  */\n \n static int\n-is_exception_free (insn, bb_src, bb_trg)\n-     rtx insn;\n-     int bb_src, bb_trg;\n+is_exception_free (rtx insn, int bb_src, int bb_trg)\n {\n   int insn_class = haifa_classify_insn (insn);\n \n@@ -1727,19 +1694,19 @@ static int sched_n_insns;\n static int last_was_jump;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n-static void init_ready_list PARAMS ((struct ready_list *));\n-static int can_schedule_ready_p PARAMS ((rtx));\n-static int new_ready PARAMS ((rtx));\n-static int schedule_more_p PARAMS ((void));\n-static const char *rgn_print_insn PARAMS ((rtx, int));\n-static int rgn_rank PARAMS ((rtx, rtx));\n-static int contributes_to_priority PARAMS ((rtx, rtx));\n-static void compute_jump_reg_dependencies PARAMS ((rtx, regset));\n+static void init_ready_list (struct ready_list *);\n+static int can_schedule_ready_p (rtx);\n+static int new_ready (rtx);\n+static int schedule_more_p (void);\n+static const char *rgn_print_insn (rtx, int);\n+static int rgn_rank (rtx, rtx);\n+static int contributes_to_priority (rtx, rtx);\n+static void compute_jump_reg_dependencies (rtx, regset);\n \n /* Return nonzero if there are more insns that should be scheduled.  */\n \n static int\n-schedule_more_p ()\n+schedule_more_p (void)\n {\n   return ! last_was_jump && sched_target_n_insns < target_n_insns;\n }\n@@ -1748,8 +1715,7 @@ schedule_more_p ()\n    once before scheduling a set of insns.  */\n \n static void\n-init_ready_list (ready)\n-     struct ready_list *ready;\n+init_ready_list (struct ready_list *ready)\n {\n   rtx prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n@@ -1835,8 +1801,7 @@ init_ready_list (ready)\n    insn can be scheduled, nonzero if we should silently discard it.  */\n \n static int\n-can_schedule_ready_p (insn)\n-     rtx insn;\n+can_schedule_ready_p (rtx insn)\n {\n   if (GET_CODE (insn) == JUMP_INSN)\n     last_was_jump = 1;\n@@ -1900,8 +1865,7 @@ can_schedule_ready_p (insn)\n    if it should be moved to the ready list or the queue, or zero if we\n    should silently discard it.  */\n static int\n-new_ready (next)\n-     rtx next;\n+new_ready (rtx next)\n {\n   /* For speculative insns, before inserting to ready/queue,\n      check live, exception-free, and issue-delay.  */\n@@ -1930,9 +1894,7 @@ new_ready (next)\n    to be formatted so that multiple output lines will line up nicely.  */\n \n static const char *\n-rgn_print_insn (insn, aligned)\n-     rtx insn;\n-     int aligned;\n+rgn_print_insn (rtx insn, int aligned)\n {\n   static char tmp[80];\n \n@@ -1953,8 +1915,7 @@ rgn_print_insn (insn, aligned)\n    is to be preferred.  Zero if they are equally good.  */\n \n static int\n-rgn_rank (insn1, insn2)\n-     rtx insn1, insn2;\n+rgn_rank (rtx insn1, rtx insn2)\n {\n   /* Some comparison make sense in interblock scheduling only.  */\n   if (INSN_BB (insn1) != INSN_BB (insn2))\n@@ -1985,8 +1946,7 @@ rgn_rank (insn1, insn2)\n    calculations.  */\n \n static int\n-contributes_to_priority (next, insn)\n-     rtx next, insn;\n+contributes_to_priority (rtx next, rtx insn)\n {\n   return BLOCK_NUM (next) == BLOCK_NUM (insn);\n }\n@@ -1995,9 +1955,8 @@ contributes_to_priority (next, insn)\n    to be set by this jump in SET.  */\n \n static void\n-compute_jump_reg_dependencies (insn, set)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     regset set ATTRIBUTE_UNUSED;\n+compute_jump_reg_dependencies (rtx insn ATTRIBUTE_UNUSED,\n+\t\t\t       regset set ATTRIBUTE_UNUSED)\n {\n   /* Nothing to do here, since we postprocess jumps in\n      add_branch_dependences.  */\n@@ -2025,18 +1984,15 @@ static struct sched_info region_sched_info =\n /* Determine if PAT sets a CLASS_LIKELY_SPILLED_P register.  */\n \n static bool\n-sets_likely_spilled (pat)\n-     rtx pat;\n+sets_likely_spilled (rtx pat)\n {\n   bool ret = false;\n   note_stores (pat, sets_likely_spilled_1, &ret);\n   return ret;\n }\n \n static void\n-sets_likely_spilled_1 (x, pat, data)\n-     rtx x, pat;\n-     void *data;\n+sets_likely_spilled_1 (rtx x, rtx pat, void *data)\n {\n   bool *ret = (bool *) data;\n \n@@ -2051,8 +2007,7 @@ sets_likely_spilled_1 (x, pat, data)\n    block.  */\n \n static void\n-add_branch_dependences (head, tail)\n-     rtx head, tail;\n+add_branch_dependences (rtx head, rtx tail)\n {\n   rtx insn, last;\n \n@@ -2133,8 +2088,7 @@ static struct deps *bb_deps;\n /* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */\n \n static rtx\n-concat_INSN_LIST (copy, old)\n-     rtx copy, old;\n+concat_INSN_LIST (rtx copy, rtx old)\n {\n   rtx new = old;\n   for (; copy ; copy = XEXP (copy, 1))\n@@ -2143,9 +2097,8 @@ concat_INSN_LIST (copy, old)\n }\n \n static void\n-concat_insn_mem_list (copy_insns, copy_mems, old_insns_p, old_mems_p)\n-     rtx copy_insns, copy_mems;\n-     rtx *old_insns_p, *old_mems_p;\n+concat_insn_mem_list (rtx copy_insns, rtx copy_mems, rtx *old_insns_p,\n+\t\t      rtx *old_mems_p)\n {\n   rtx new_insns = *old_insns_p;\n   rtx new_mems = *old_mems_p;\n@@ -2165,9 +2118,7 @@ concat_insn_mem_list (copy_insns, copy_mems, old_insns_p, old_mems_p)\n /* After computing the dependencies for block BB, propagate the dependencies\n    found in TMP_DEPS to the successors of the block.  */\n static void\n-propagate_deps (bb, pred_deps)\n-     int bb;\n-     struct deps *pred_deps;\n+propagate_deps (int bb, struct deps *pred_deps)\n {\n   int b = BB_TO_BLOCK (bb);\n   int e, first_edge;\n@@ -2268,8 +2219,7 @@ propagate_deps (bb, pred_deps)\n    similar, and the result is interblock dependences in the region.  */\n \n static void\n-compute_block_backward_dependences (bb)\n-     int bb;\n+compute_block_backward_dependences (int bb)\n {\n   rtx head, tail;\n   struct deps tmp_deps;\n@@ -2292,7 +2242,7 @@ compute_block_backward_dependences (bb)\n    them to the unused_*_list variables, so that they can be reused.  */\n \n static void\n-free_pending_lists ()\n+free_pending_lists (void)\n {\n   int bb;\n \n@@ -2308,7 +2258,7 @@ free_pending_lists ()\n /* Print dependences for debugging, callable from debugger.  */\n \n void\n-debug_dependencies ()\n+debug_dependencies (void)\n {\n   int bb;\n \n@@ -2421,8 +2371,7 @@ debug_dependencies ()\n    scheduled after its flow predecessors.  */\n \n static void\n-schedule_region (rgn)\n-     int rgn;\n+schedule_region (int rgn)\n {\n   int bb;\n   int rgn_n_insns = 0;\n@@ -2520,7 +2469,7 @@ schedule_region (rgn)\n \n       /* rm_other_notes only removes notes which are _inside_ the\n \t block---that is, it won't remove notes before the first real insn\n- \t or after the last real insn of the block.  So if the first insn\n+\t or after the last real insn of the block.  So if the first insn\n \t has a REG_SAVE_NOTE which would otherwise be emitted before the\n \t insn, it is redundant with the note before the start of the\n \t block, and so we have to take it out.  */\n@@ -2605,7 +2554,7 @@ static int *deaths_in_region;\n /* Initialize data structures for region scheduling.  */\n \n static void\n-init_regions ()\n+init_regions (void)\n {\n   sbitmap blocks;\n   int rgn;\n@@ -2690,8 +2639,7 @@ init_regions ()\n    this pass.  */\n \n void\n-schedule_insns (dump_file)\n-     FILE *dump_file;\n+schedule_insns (FILE *dump_file)\n {\n   sbitmap large_region_blocks, blocks;\n   int rgn;"}, {"sha": "91f25e79b88c02b4b4ba26fcd6dfb03e916b24b0", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 21, "deletions": 41, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -47,17 +47,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int target_units = 0;\n \n-static char *safe_concat PARAMS ((char *, char *, const char *));\n-static int get_visual_tbl_length PARAMS ((void));\n-static void print_exp PARAMS ((char *, rtx, int));\n-static void print_value PARAMS ((char *, rtx, int));\n-static void print_pattern PARAMS ((char *, rtx, int));\n+static char *safe_concat (char *, char *, const char *);\n+static int get_visual_tbl_length (void);\n+static void print_exp (char *, rtx, int);\n+static void print_value (char *, rtx, int);\n+static void print_pattern (char *, rtx, int);\n \n /* Print names of units on which insn can/should execute, for debugging.  */\n \n void\n-insn_print_units (insn)\n-     rtx insn;\n+insn_print_units (rtx insn)\n {\n   int i;\n   int unit = insn_unit (insn);\n@@ -98,7 +97,7 @@ rtx vis_no_unit[MAX_VISUAL_NO_UNIT];\n    for visualization.  */\n \n void\n-init_target_units ()\n+init_target_units (void)\n {\n   rtx insn;\n   int unit;\n@@ -120,7 +119,7 @@ init_target_units ()\n /* Return the length of the visualization table.  */\n \n static int\n-get_visual_tbl_length ()\n+get_visual_tbl_length (void)\n {\n   int unit, i;\n   int n, n1;\n@@ -158,7 +157,7 @@ get_visual_tbl_length ()\n /* Init block visualization debugging info.  */\n \n void\n-init_block_visualization ()\n+init_block_visualization (void)\n {\n   strcpy (visual_tbl, \"\");\n   n_visual_lines = 0;\n@@ -168,10 +167,7 @@ init_block_visualization ()\n #define BUF_LEN 2048\n \n static char *\n-safe_concat (buf, cur, str)\n-     char *buf;\n-     char *cur;\n-     const char *str;\n+safe_concat (char *buf, char *cur, const char *str)\n {\n   char *end = buf + BUF_LEN - 2;\t/* Leave room for null.  */\n   int c;\n@@ -194,10 +190,7 @@ safe_concat (buf, cur, str)\n    may be stored in objects representing values.  */\n \n static void\n-print_exp (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n+print_exp (char *buf, rtx x, int verbose)\n {\n   char tmp[BUF_LEN];\n   const char *st[4];\n@@ -548,10 +541,7 @@ print_exp (buf, x, verbose)\n    registers, labels, symbols and memory accesses.  */\n \n static void\n-print_value (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n+print_value (char *buf, rtx x, int verbose)\n {\n   char t[BUF_LEN];\n   char *cur = buf;\n@@ -641,10 +631,7 @@ print_value (buf, x, verbose)\n /* The next step in insn detalization, its pattern recognition.  */\n \n static void\n-print_pattern (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n+print_pattern (char *buf, rtx x, int verbose)\n {\n   char t1[BUF_LEN], t2[BUF_LEN], t3[BUF_LEN];\n \n@@ -755,10 +742,7 @@ print_pattern (buf, x, verbose)\n    depends now on sched.c inner variables ...)  */\n \n void\n-print_insn (buf, x, verbose)\n-     char *buf;\n-     rtx x;\n-     int verbose;\n+print_insn (char *buf, rtx x, int verbose)\n {\n   char t[BUF_LEN];\n   rtx insn = x;\n@@ -824,8 +808,7 @@ print_insn (buf, x, verbose)\n    description should never use the following function.  */\n \n void\n-print_block_visualization (s)\n-     const char *s;\n+print_block_visualization (const char *s)\n {\n   int unit, i;\n \n@@ -854,8 +837,7 @@ print_block_visualization (s)\n /* Print insns in the 'no_unit' column of visualization.  */\n \n void\n-visualize_no_unit (insn)\n-     rtx insn;\n+visualize_no_unit (rtx insn)\n {\n   if (n_vis_no_unit < MAX_VISUAL_NO_UNIT)\n     {\n@@ -867,8 +849,7 @@ visualize_no_unit (insn)\n /* Print insns scheduled in clock, for visualization.  */\n \n void\n-visualize_scheduled_insns (clock)\n-     int clock;\n+visualize_scheduled_insns (int clock)\n {\n   int i, unit;\n \n@@ -914,8 +895,7 @@ visualize_scheduled_insns (clock)\n /* Print stalled cycles.  */\n \n void\n-visualize_stall_cycles (stalls)\n-     int stalls;\n+visualize_stall_cycles (int stalls)\n {\n   static const char *const prefix = \";;       \";\n   const char *suffix = \"\\n\";\n@@ -950,15 +930,15 @@ visualize_stall_cycles (stalls)\n /* Allocate data used for visualization during scheduling.  */\n \n void\n-visualize_alloc ()\n+visualize_alloc (void)\n {\n   visual_tbl = xmalloc (get_visual_tbl_length ());\n }\n \n /* Free data used for visualization.  */\n \n void\n-visualize_free ()\n+visualize_free (void)\n {\n   free (visual_tbl);\n }"}, {"sha": "ec85cb2378671329cb727064789700432a9f23bc", "filename": "gcc/sibcall.c", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,6 @@\n /* Generic sibling call optimization support\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -40,28 +41,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    return in the sibcall sequence.  */\n static rtx return_value_pseudo;\n \n-static int identify_call_return_value\tPARAMS ((rtx, rtx *, rtx *));\n-static rtx skip_copy_to_return_value\tPARAMS ((rtx));\n-static rtx skip_use_of_return_value\tPARAMS ((rtx, enum rtx_code));\n-static rtx skip_stack_adjustment\tPARAMS ((rtx));\n-static rtx skip_pic_restore\t\tPARAMS ((rtx));\n-static rtx skip_jump_insn\t\tPARAMS ((rtx));\n-static int call_ends_block_p\t\tPARAMS ((rtx, rtx));\n-static int uses_addressof\t\tPARAMS ((rtx));\n-static int sequence_uses_addressof\tPARAMS ((rtx));\n-static void purge_reg_equiv_notes\tPARAMS ((void));\n-static void purge_mem_unchanging_flag\tPARAMS ((rtx));\n-static rtx skip_unreturned_value \tPARAMS ((rtx));\n+static int identify_call_return_value (rtx, rtx *, rtx *);\n+static rtx skip_copy_to_return_value (rtx);\n+static rtx skip_use_of_return_value (rtx, enum rtx_code);\n+static rtx skip_stack_adjustment (rtx);\n+static rtx skip_pic_restore (rtx);\n+static rtx skip_jump_insn (rtx);\n+static int call_ends_block_p (rtx, rtx);\n+static int uses_addressof (rtx);\n+static int sequence_uses_addressof (rtx);\n+static void purge_reg_equiv_notes (void);\n+static void purge_mem_unchanging_flag (rtx);\n+static rtx skip_unreturned_value (rtx);\n \n /* Examine a CALL_PLACEHOLDER pattern and determine where the call's\n    return value is located.  P_HARD_RETURN receives the hard register\n    that the function used; P_SOFT_RETURN receives the pseudo register\n    that the sequence used.  Return nonzero if the values were located.  */\n \n static int\n-identify_call_return_value (cp, p_hard_return, p_soft_return)\n-     rtx cp;\n-     rtx *p_hard_return, *p_soft_return;\n+identify_call_return_value (rtx cp, rtx *p_hard_return, rtx *p_soft_return)\n {\n   rtx insn, set, hard, soft;\n \n@@ -142,8 +141,7 @@ identify_call_return_value (cp, p_hard_return, p_soft_return)\n    copy.  Otherwise return ORIG_INSN.  */\n \n static rtx\n-skip_copy_to_return_value (orig_insn)\n-     rtx orig_insn;\n+skip_copy_to_return_value (rtx orig_insn)\n {\n   rtx insn, set = NULL_RTX;\n   rtx hardret, softret;\n@@ -219,9 +217,7 @@ skip_copy_to_return_value (orig_insn)\n    value, return insn.  Otherwise return ORIG_INSN.  */\n \n static rtx\n-skip_use_of_return_value (orig_insn, code)\n-     rtx orig_insn;\n-     enum rtx_code code;\n+skip_use_of_return_value (rtx orig_insn, enum rtx_code code)\n {\n   rtx insn;\n \n@@ -240,8 +236,7 @@ skip_use_of_return_value (orig_insn, code)\n /* In case function does not return value,  we get clobber of pseudo followed\n    by set to hard return value.  */\n static rtx\n-skip_unreturned_value (orig_insn)\n-     rtx orig_insn;\n+skip_unreturned_value (rtx orig_insn)\n {\n   rtx insn = next_nonnote_insn (orig_insn);\n \n@@ -271,8 +266,7 @@ skip_unreturned_value (orig_insn)\n    Otherwise return ORIG_INSN.  */\n \n static rtx\n-skip_stack_adjustment (orig_insn)\n-     rtx orig_insn;\n+skip_stack_adjustment (rtx orig_insn)\n {\n   rtx insn, set = NULL_RTX;\n \n@@ -296,8 +290,7 @@ skip_stack_adjustment (orig_insn)\n    return it.  Otherwise return ORIG_INSN.  */\n \n static rtx\n-skip_pic_restore (orig_insn)\n-     rtx orig_insn;\n+skip_pic_restore (rtx orig_insn)\n {\n   rtx insn, set = NULL_RTX;\n \n@@ -316,8 +309,7 @@ skip_pic_restore (orig_insn)\n    Otherwise return ORIG_INSN.  */\n \n static rtx\n-skip_jump_insn (orig_insn)\n-     rtx orig_insn;\n+skip_jump_insn (rtx orig_insn)\n {\n   rtx insn;\n \n@@ -335,9 +327,7 @@ skip_jump_insn (orig_insn)\n    goes all the way to END, the end of a basic block.  Return 1 if so.  */\n \n static int\n-call_ends_block_p (insn, end)\n-     rtx insn;\n-     rtx end;\n+call_ends_block_p (rtx insn, rtx end)\n {\n   rtx new_insn;\n   /* END might be a note, so get the last nonnote insn of the block.  */\n@@ -394,8 +384,7 @@ call_ends_block_p (insn, end)\n    is found outside of some MEM expression, else return zero.  */\n \n static int\n-uses_addressof (x)\n-     rtx x;\n+uses_addressof (rtx x)\n {\n   RTX_CODE code;\n   int i, j;\n@@ -441,8 +430,7 @@ uses_addressof (x)\n    of insns.  */\n \n static int\n-sequence_uses_addressof (seq)\n-     rtx seq;\n+sequence_uses_addressof (rtx seq)\n {\n   rtx insn;\n \n@@ -474,7 +462,7 @@ sequence_uses_addressof (seq)\n /* Remove all REG_EQUIV notes found in the insn chain.  */\n \n static void\n-purge_reg_equiv_notes ()\n+purge_reg_equiv_notes (void)\n {\n   rtx insn;\n \n@@ -498,8 +486,7 @@ purge_reg_equiv_notes ()\n /* Clear RTX_UNCHANGING_P flag of incoming argument MEMs.  */\n \n static void\n-purge_mem_unchanging_flag (x)\n-     rtx x;\n+purge_mem_unchanging_flag (rtx x)\n {\n   RTX_CODE code;\n   int i, j;\n@@ -538,9 +525,7 @@ purge_mem_unchanging_flag (x)\n    the CALL_PLACEHOLDER insn; USE tells which child to use.  */\n \n void\n-replace_call_placeholder (insn, use)\n-     rtx insn;\n-     sibcall_use_t use;\n+replace_call_placeholder (rtx insn, sibcall_use_t use)\n {\n   if (use == sibcall_use_tail_recursion)\n     emit_insn_before (XEXP (PATTERN (insn), 2), insn);\n@@ -571,7 +556,7 @@ replace_call_placeholder (insn, use)\n    Replace the CALL_PLACEHOLDER with an appropriate insn chain.  */\n \n void\n-optimize_sibling_and_tail_recursive_calls ()\n+optimize_sibling_and_tail_recursive_calls (void)\n {\n   rtx insn, insns;\n   basic_block alternate_exit = EXIT_BLOCK_PTR;"}, {"sha": "27fe4f377b67de6be2d29a1b6e976c71beb51c63", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 34, "deletions": 70, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -49,19 +49,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HWI_SIGN_EXTEND(low) \\\n  ((((HOST_WIDE_INT) low) < 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))\n \n-static rtx neg_const_int PARAMS ((enum machine_mode, rtx));\n-static int simplify_plus_minus_op_data_cmp PARAMS ((const void *,\n-\t\t\t\t\t\t    const void *));\n-static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx,\n-\t\t\t\t\t\t rtx, int));\n+static rtx neg_const_int (enum machine_mode, rtx);\n+static int simplify_plus_minus_op_data_cmp (const void *, const void *);\n+static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx,\n+\t\t\t\trtx, int);\n \f\n /* Negate a CONST_INT rtx, truncating (because a conversion from a\n    maximally negative number can overflow).  */\n static rtx\n-neg_const_int (mode, i)\n-     enum machine_mode mode;\n-     rtx i;\n+neg_const_int (enum machine_mode mode, rtx i)\n {\n   return gen_int_mode (- INTVAL (i), mode);\n }\n@@ -71,10 +67,8 @@ neg_const_int (mode, i)\n    seeing if the expression folds.  */\n \n rtx\n-simplify_gen_binary (code, mode, op0, op1)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1;\n+simplify_gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0,\n+\t\t     rtx op1)\n {\n   rtx tem;\n \n@@ -104,8 +98,7 @@ simplify_gen_binary (code, mode, op0, op1)\n /* If X is a MEM referencing the constant pool, return the real value.\n    Otherwise return X.  */\n rtx\n-avoid_constant_pool_reference (x)\n-     rtx x;\n+avoid_constant_pool_reference (rtx x)\n {\n   rtx c, tmp, addr;\n   enum machine_mode cmode;\n@@ -163,11 +156,8 @@ avoid_constant_pool_reference (x)\n    the specified operation.  */\n \n rtx\n-simplify_gen_unary (code, mode, op, op_mode)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op;\n-     enum machine_mode op_mode;\n+simplify_gen_unary (enum rtx_code code, enum machine_mode mode, rtx op,\n+\t\t    enum machine_mode op_mode)\n {\n   rtx tem;\n \n@@ -181,10 +171,8 @@ simplify_gen_unary (code, mode, op, op_mode)\n /* Likewise for ternary operations.  */\n \n rtx\n-simplify_gen_ternary (code, mode, op0_mode, op0, op1, op2)\n-     enum rtx_code code;\n-     enum machine_mode mode, op0_mode;\n-     rtx op0, op1, op2;\n+simplify_gen_ternary (enum rtx_code code, enum machine_mode mode,\n+\t\t      enum machine_mode op0_mode, rtx op0, rtx op1, rtx op2)\n {\n   rtx tem;\n \n@@ -201,11 +189,8 @@ simplify_gen_ternary (code, mode, op0_mode, op0, op1, op2)\n   */\n \n rtx\n-simplify_gen_relational (code, mode, cmp_mode, op0, op1)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     enum machine_mode cmp_mode;\n-     rtx op0, op1;\n+simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n+\t\t\t enum machine_mode cmp_mode, rtx op0, rtx op1)\n {\n   rtx tem;\n \n@@ -248,10 +233,7 @@ simplify_gen_relational (code, mode, cmp_mode, op0, op1)\n    resulting RTX.  Return a new RTX which is as simplified as possible.  */\n \n rtx\n-simplify_replace_rtx (x, old, new)\n-     rtx x;\n-     rtx old;\n-     rtx new;\n+simplify_replace_rtx (rtx x, rtx old, rtx new)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -321,7 +303,7 @@ simplify_replace_rtx (x, old, new)\n \t  rtx exp;\n \t  exp = simplify_gen_subreg (GET_MODE (x),\n \t\t\t\t     simplify_replace_rtx (SUBREG_REG (x),\n-\t\t\t\t     \t\t\t   old, new),\n+\t\t\t\t\t\t\t   old, new),\n \t\t\t\t     GET_MODE (SUBREG_REG (x)),\n \t\t\t\t     SUBREG_BYTE (x));\n \t  if (exp)\n@@ -363,11 +345,8 @@ simplify_replace_rtx (x, old, new)\n    MODE with input operand OP whose mode was originally OP_MODE.\n    Return zero if no simplification can be made.  */\n rtx\n-simplify_unary_operation (code, mode, op, op_mode)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op;\n-     enum machine_mode op_mode;\n+simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n+\t\t\t  rtx op, enum machine_mode op_mode)\n {\n   unsigned int width = GET_MODE_BITSIZE (mode);\n   rtx trueop = avoid_constant_pool_reference (op);\n@@ -872,10 +851,8 @@ simplify_unary_operation (code, mode, op, op_mode)\n    Don't use this for relational operations such as EQ or LT.\n    Use simplify_relational_operation instead.  */\n rtx\n-simplify_binary_operation (code, mode, op0, op1)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1;\n+simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n+\t\t\t   rtx op0, rtx op1)\n {\n   HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n   HOST_WIDE_INT val;\n@@ -1898,9 +1875,7 @@ struct simplify_plus_minus_op_data\n };\n \n static int\n-simplify_plus_minus_op_data_cmp (p1, p2)\n-     const void *p1;\n-     const void *p2;\n+simplify_plus_minus_op_data_cmp (const void *p1, const void *p2)\n {\n   const struct simplify_plus_minus_op_data *d1 = p1;\n   const struct simplify_plus_minus_op_data *d2 = p2;\n@@ -1910,11 +1885,8 @@ simplify_plus_minus_op_data_cmp (p1, p2)\n }\n \n static rtx\n-simplify_plus_minus (code, mode, op0, op1, force)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1;\n-     int force;\n+simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n+\t\t     rtx op1, int force)\n {\n   struct simplify_plus_minus_op_data ops[8];\n   rtx result, tem;\n@@ -2160,10 +2132,8 @@ simplify_plus_minus (code, mode, op0, op1, force)\n    it returns either const_true_rtx or const0_rtx.  */\n \n rtx\n-simplify_relational_operation (code, mode, op0, op1)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1;\n+simplify_relational_operation (enum rtx_code code, enum machine_mode mode,\n+\t\t\t       rtx op0, rtx op1)\n {\n   int equal, op0lt, op0ltu, op1lt, op1ltu;\n   rtx tem;\n@@ -2397,7 +2367,7 @@ simplify_relational_operation (code, mode, op0, op1)\n \t\treturn const_true_rtx;\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -2449,10 +2419,9 @@ simplify_relational_operation (code, mode, op0, op1)\n    a constant.  Return 0 if no simplifications is possible.  */\n \n rtx\n-simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n-     enum rtx_code code;\n-     enum machine_mode mode, op0_mode;\n-     rtx op0, op1, op2;\n+simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n+\t\t\t    enum machine_mode op0_mode, rtx op0, rtx op1,\n+\t\t\t    rtx op2)\n {\n   unsigned int width = GET_MODE_BITSIZE (mode);\n \n@@ -2603,10 +2572,8 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n /* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)\n    Return 0 if no simplifications is possible.  */\n rtx\n-simplify_subreg (outermode, op, innermode, byte)\n-     rtx op;\n-     unsigned int byte;\n-     enum machine_mode outermode, innermode;\n+simplify_subreg (enum machine_mode outermode, rtx op,\n+\t\t enum machine_mode innermode, unsigned int byte)\n {\n   /* Little bit of sanity checking.  */\n   if (innermode == VOIDmode || outermode == VOIDmode\n@@ -2989,10 +2956,8 @@ simplify_subreg (outermode, op, innermode, byte)\n /* Make a SUBREG operation or equivalent if it folds.  */\n \n rtx\n-simplify_gen_subreg (outermode, op, innermode, byte)\n-     rtx op;\n-     unsigned int byte;\n-     enum machine_mode outermode, innermode;\n+simplify_gen_subreg (enum machine_mode outermode, rtx op,\n+\t\t     enum machine_mode innermode, unsigned int byte)\n {\n   rtx new;\n   /* Little bit of sanity checking.  */\n@@ -3061,8 +3026,7 @@ simplify_gen_subreg (outermode, op, innermode, byte)\n     simplification and 1 for tree simplification.  */\n \n rtx\n-simplify_rtx (x)\n-     rtx x;\n+simplify_rtx (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);"}, {"sha": "8980659c99bb9e7df0b5e4c6fcfb27313751c9ea", "filename": "gcc/sreal.c", "status": "modified", "additions": 18, "deletions": 43, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -24,7 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Value of sreal is\n \tx = sig * 2 ^ exp\n-   where \n+   where\n \tsig = significant\n \t  (for < 64-bit machines sig = sig_lo + sig_hi * 2 ^ SREAL_PART_BITS)\n \texp = exponent\n@@ -35,13 +35,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Only a half of significant bits is used (in normalized sreals) so that we do\n    not have problems with overflow, for example when c->sig = a->sig * b->sig.\n    So the precision for 64-bit and 32-bit machines is 32-bit.\n-\t\t\t\n+\n    Invariant: The numbers are normalized before and after each call of sreal_*.\n \n    Normalized sreals:\n    All numbers (except zero) meet following conditions:\n \t SREAL_MIN_SIG <= sig && sig <= SREAL_MAX_SIG\n-\t-SREAL_MAX_EXP <= exp && exp <= SREAL_MAX_EXP \n+\t-SREAL_MAX_EXP <= exp && exp <= SREAL_MAX_EXP\n \n    If the number would be too large, it is set to upper bounds of these\n    conditions.\n@@ -56,16 +56,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n #include \"sreal.h\"\n \n-static inline void copy\t\tPARAMS ((sreal *, sreal *));\n-static inline void shift_right\tPARAMS ((sreal *, int));\n-static void normalize\t\tPARAMS ((sreal *));\n+static inline void copy (sreal *, sreal *);\n+static inline void shift_right (sreal *, int);\n+static void normalize (sreal *);\n \n /* Print the content of struct sreal.  */\n \n void\n-dump_sreal (file, x)\n-     FILE *file;\n-     sreal *x;\n+dump_sreal (FILE *file, sreal *x)\n {\n #if SREAL_PART_BITS < 32\n   fprintf (file, \"((\" HOST_WIDE_INT_PRINT_UNSIGNED \" * 2^16 + \"\n@@ -79,9 +77,7 @@ dump_sreal (file, x)\n /* Copy the sreal number.  */\n \n static inline void\n-copy (r, a)\n-     sreal *r;\n-     sreal *a;\n+copy (sreal *r, sreal *a)\n {\n #if SREAL_PART_BITS < 32\n   r->sig_lo = a->sig_lo;\n@@ -96,9 +92,7 @@ copy (r, a)\n    When the most significant bit shifted out is 1, add 1 to X (rounding).  */\n \n static inline void\n-shift_right (x, s)\n-     sreal *x;\n-     int s;\n+shift_right (sreal *x, int s)\n {\n #ifdef ENABLE_CHECKING\n   if (s <= 0 || s > SREAL_BITS)\n@@ -143,13 +137,12 @@ shift_right (x, s)\n /* Normalize *X.  */\n \n static void\n-normalize (x)\n-     sreal *x;\n+normalize (sreal *x)\n {\n #if SREAL_PART_BITS < 32\n   int shift;\n   HOST_WIDE_INT mask;\n-  \n+\n   if (x->sig_lo == 0 && x->sig_hi == 0)\n     {\n       x->exp = -SREAL_MAX_EXP;\n@@ -280,10 +273,7 @@ normalize (x)\n /* Set *R to SIG * 2 ^ EXP.  Return R.  */\n \n sreal *\n-sreal_init (r, sig, exp)\n-     sreal *r;\n-     unsigned HOST_WIDE_INT sig;\n-     signed int exp;\n+sreal_init (sreal *r, unsigned HOST_WIDE_INT sig, signed int exp)\n {\n #if SREAL_PART_BITS < 32\n   r->sig_lo = 0;\n@@ -300,8 +290,7 @@ sreal_init (r, sig, exp)\n /* Return integer value of *R.  */\n \n HOST_WIDE_INT\n-sreal_to_int (r)\n-     sreal *r;\n+sreal_to_int (sreal *r)\n {\n #if SREAL_PART_BITS < 32\n   if (r->exp <= -SREAL_BITS)\n@@ -325,9 +314,7 @@ sreal_to_int (r)\n /* Compare *A and *B. Return -1 if *A < *B, 1 if *A > *B and 0 if *A == *B.  */\n \n int\n-sreal_compare (a, b)\n-     sreal *a;\n-     sreal *b;\n+sreal_compare (sreal *a, sreal *b)\n {\n   if (a->exp > b->exp)\n     return 1;\n@@ -354,10 +341,7 @@ sreal_compare (a, b)\n /* *R = *A + *B.  Return R.  */\n \n sreal *\n-sreal_add (r, a, b)\n-  sreal *r;\n-  sreal *a;\n-  sreal *b;\n+sreal_add (sreal *r, sreal *a, sreal *b)\n {\n   int dexp;\n   sreal tmp;\n@@ -411,10 +395,7 @@ sreal_add (r, a, b)\n /* *R = *A - *B.  Return R.  */\n \n sreal *\n-sreal_sub (r, a, b)\n-  sreal *r;\n-  sreal *a;\n-  sreal *b;\n+sreal_sub (sreal *r, sreal *a, sreal *b)\n {\n   int dexp;\n   sreal tmp;\n@@ -467,10 +448,7 @@ sreal_sub (r, a, b)\n /* *R = *A * *B.  Return R.  */\n \n sreal *\n-sreal_mul (r, a, b)\n-     sreal *r;\n-     sreal *a;\n-     sreal *b;\n+sreal_mul (sreal *r, sreal *a, sreal *b)\n {\n #if SREAL_PART_BITS < 32\n   if (a->sig_hi < SREAL_MIN_SIG || b->sig_hi < SREAL_MIN_SIG)\n@@ -526,10 +504,7 @@ sreal_mul (r, a, b)\n /* *R = *A / *B.  Return R.  */\n \n sreal *\n-sreal_div (r, a, b)\n-     sreal *r;\n-     sreal *a;\n-     sreal *b;\n+sreal_div (sreal *r, sreal *a, sreal *b)\n {\n #if SREAL_PART_BITS < 32\n   unsigned HOST_WIDE_INT tmp, tmp1, tmp2;"}, {"sha": "b24b29b58578ad7cad5fc2cf1561563f2f0cd815", "filename": "gcc/sreal.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for simple data type for positive real numbers.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -53,15 +53,13 @@ typedef struct sreal\n   signed int exp;\t\t\t/* Exponent.  */\n } sreal;\n \n-extern void dump_sreal\t\t\tPARAMS ((FILE *, sreal *));\n-extern sreal *sreal_init\t\tPARAMS ((sreal *,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t signed int));\n-extern HOST_WIDE_INT sreal_to_int\tPARAMS ((sreal *));\n-extern int sreal_compare\t\tPARAMS ((sreal *, sreal *));\n-extern sreal *sreal_add\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n-extern sreal *sreal_sub\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n-extern sreal *sreal_mul\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n-extern sreal *sreal_div\t\t\tPARAMS ((sreal *, sreal *, sreal *));\n+extern void dump_sreal (FILE *, sreal *);\n+extern sreal *sreal_init (sreal *, unsigned HOST_WIDE_INT, signed int);\n+extern HOST_WIDE_INT sreal_to_int (sreal *);\n+extern int sreal_compare (sreal *, sreal *);\n+extern sreal *sreal_add (sreal *, sreal *, sreal *);\n+extern sreal *sreal_sub (sreal *, sreal *, sreal *);\n+extern sreal *sreal_mul (sreal *, sreal *, sreal *);\n+extern sreal *sreal_div (sreal *, sreal *, sreal *);\n \n #endif"}, {"sha": "c093cc463e74c5bb5ca6839e1477783efd255e15", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* Conditional constant propagation pass for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Original framework by Daniel Berlin <dan@cgsoftware.com>\n    Fleshed out and major cleanups by Jeff Law <law@redhat.com>\n \n@@ -124,24 +124,22 @@ static sbitmap ssa_edges;\n #define SSA_NAME(x) REGNO (SET_DEST (x))\n #define EIE(x,y) EDGE_INDEX (edges, x, y)\n \n-static void visit_phi_node             PARAMS ((rtx, basic_block));\n-static void visit_expression           PARAMS ((rtx, basic_block));\n-static void defs_to_undefined          PARAMS ((rtx));\n-static void defs_to_varying            PARAMS ((rtx));\n-static void examine_flow_edges         PARAMS ((void));\n-static int mark_references             PARAMS ((rtx *, void *));\n-static void follow_def_use_chains      PARAMS ((void));\n-static void optimize_unexecutable_edges PARAMS ((struct edge_list *, sbitmap));\n-static void ssa_ccp_substitute_constants PARAMS ((void));\n-static void ssa_ccp_df_delete_unreachable_insns PARAMS ((void));\n-static void ssa_fast_dce PARAMS ((struct df *));\n+static void visit_phi_node (rtx, basic_block);\n+static void visit_expression (rtx, basic_block);\n+static void defs_to_undefined (rtx);\n+static void defs_to_varying (rtx);\n+static void examine_flow_edges (void);\n+static int mark_references (rtx *, void *);\n+static void follow_def_use_chains (void);\n+static void optimize_unexecutable_edges (struct edge_list *, sbitmap);\n+static void ssa_ccp_substitute_constants (void);\n+static void ssa_ccp_df_delete_unreachable_insns (void);\n+static void ssa_fast_dce (struct df *);\n \n /* Loop through the PHI_NODE's parameters for BLOCK and compare their\n    lattice values to determine PHI_NODE's lattice value.  */\n static void\n-visit_phi_node (phi_node, block)\n-     rtx phi_node;\n-     basic_block block;\n+visit_phi_node (rtx phi_node, basic_block block)\n {\n   unsigned int i;\n   rtx phi_node_expr = NULL;\n@@ -210,8 +208,7 @@ visit_phi_node (phi_node, block)\n \n /* Sets all defs in an insn to UNDEFINED.  */\n static void\n-defs_to_undefined (insn)\n-     rtx insn;\n+defs_to_undefined (rtx insn)\n {\n   struct df_link *currdef;\n   for (currdef = DF_INSN_DEFS (df_analyzer, insn); currdef;\n@@ -225,8 +222,7 @@ defs_to_undefined (insn)\n \n /* Sets all defs in an insn to VARYING.  */\n static void\n-defs_to_varying (insn)\n-     rtx insn;\n+defs_to_varying (rtx insn)\n {\n   struct df_link *currdef;\n   for (currdef = DF_INSN_DEFS (df_analyzer, insn); currdef;\n@@ -241,9 +237,7 @@ defs_to_varying (insn)\n /* Go through the expression, call the appropriate evaluation routines\n    to attempt cprop */\n static void\n-visit_expression (insn, block)\n-     rtx insn;\n-     basic_block block;\n+visit_expression (rtx insn, basic_block block)\n {\n   rtx src, dest, set;\n \n@@ -625,7 +619,7 @@ visit_expression (insn, block)\n /* Iterate over the FLOW_EDGES work list.  Simulate the target block\n    for each edge.  */\n static void\n-examine_flow_edges ()\n+examine_flow_edges (void)\n {\n   while (flow_edges != NULL)\n     {\n@@ -693,7 +687,7 @@ examine_flow_edges ()\n    simulate the uses of the definition.  */\n \n static void\n-follow_def_use_chains ()\n+follow_def_use_chains (void)\n {\n   /* Iterate over all the entries on the SSA_EDGES worklist.  */\n   while (sbitmap_first_set_bit (ssa_edges) >= 0)\n@@ -736,9 +730,8 @@ follow_def_use_chains ()\n    the edge from the CFG.  Note we do not delete unreachable blocks\n    yet as the DF analyzer can not deal with that yet.  */\n static void\n-optimize_unexecutable_edges (edges, executable_edges)\n-     struct edge_list *edges;\n-     sbitmap executable_edges;\n+optimize_unexecutable_edges (struct edge_list *edges,\n+\t\t\t     sbitmap executable_edges)\n {\n   int i;\n   basic_block bb;\n@@ -849,7 +842,7 @@ optimize_unexecutable_edges (edges, executable_edges)\n    replace uses with the known constant value.  */\n \n static void\n-ssa_ccp_substitute_constants ()\n+ssa_ccp_substitute_constants (void)\n {\n   unsigned int i;\n \n@@ -928,7 +921,7 @@ ssa_ccp_substitute_constants ()\n    updates for the DF analyzer.  */\n \n static void\n-ssa_ccp_df_delete_unreachable_insns ()\n+ssa_ccp_df_delete_unreachable_insns (void)\n {\n   basic_block b;\n \n@@ -975,7 +968,7 @@ ssa_ccp_df_delete_unreachable_insns ()\n    operate on so that it can be called for sub-graphs.  */\n \n void\n-ssa_const_prop ()\n+ssa_const_prop (void)\n {\n   unsigned int i;\n   edge curredge;\n@@ -1088,9 +1081,7 @@ ssa_const_prop ()\n }\n \n static int\n-mark_references (current_rtx, data)\n-     rtx *current_rtx;\n-     void *data;\n+mark_references (rtx *current_rtx, void *data)\n {\n   rtx x = *current_rtx;\n   sbitmap worklist = (sbitmap) data;\n@@ -1141,8 +1132,7 @@ mark_references (current_rtx, data)\n }\n \n static void\n-ssa_fast_dce (df)\n-     struct df *df;\n+ssa_fast_dce (struct df *df)\n {\n   sbitmap worklist = sbitmap_alloc (VARRAY_SIZE (ssa_definition));\n   sbitmap_ones (worklist);"}, {"sha": "c308c7793b6ed680b62609c20bb7ef72c290eede", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 39, "deletions": 69, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* Dead-code elimination pass for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n \n This file is part of GCC.\n@@ -93,30 +93,23 @@ typedef struct {\n \n /* Local function prototypes.  */\n static control_dependent_block_to_edge_map control_dependent_block_to_edge_map_create\n-  PARAMS((size_t num_basic_blocks));\n+  (size_t num_basic_blocks);\n static void set_control_dependent_block_to_edge_map_bit\n-  PARAMS ((control_dependent_block_to_edge_map c, basic_block bb,\n-\t   int edge_index));\n+  (control_dependent_block_to_edge_map c, basic_block bb, int edge_index);\n static void control_dependent_block_to_edge_map_free\n-  PARAMS ((control_dependent_block_to_edge_map c));\n+  (control_dependent_block_to_edge_map c);\n static void find_all_control_dependences\n-  PARAMS ((struct edge_list *el, dominance_info pdom,\n-\t   control_dependent_block_to_edge_map cdbte));\n+  (struct edge_list *el, dominance_info pdom,\n+   control_dependent_block_to_edge_map cdbte);\n static void find_control_dependence\n-  PARAMS ((struct edge_list *el, int edge_index, dominance_info pdom,\n-\t   control_dependent_block_to_edge_map cdbte));\n-static basic_block find_pdom\n-  PARAMS ((dominance_info pdom, basic_block block));\n-static int inherently_necessary_register_1\n-  PARAMS ((rtx *current_rtx, void *data));\n-static int inherently_necessary_register\n-  PARAMS ((rtx current_rtx));\n-static int find_inherently_necessary\n-  PARAMS ((rtx current_rtx));\n-static int propagate_necessity_through_operand\n-  PARAMS ((rtx *current_rtx, void *data));\n-static void note_inherently_necessary_set\n-  PARAMS ((rtx, rtx, void *));\n+  (struct edge_list *el, int edge_index, dominance_info pdom,\n+   control_dependent_block_to_edge_map cdbte);\n+static basic_block find_pdom (dominance_info pdom, basic_block block);\n+static int inherently_necessary_register_1 (rtx *current_rtx, void *data);\n+static int inherently_necessary_register (rtx current_rtx);\n+static int find_inherently_necessary (rtx current_rtx);\n+static int propagate_necessity_through_operand (rtx *current_rtx, void *data);\n+static void note_inherently_necessary_set (rtx, rtx, void *);\n \f\n /* Unnecessary insns are indicated using insns' in_struct bit.  */\n \n@@ -126,8 +119,7 @@ static void note_inherently_necessary_set\n #define RESURRECT_INSN(INSN)\tINSN_DEAD_CODE_P(INSN) = 0\n /* Return nonzero if INSN is unnecessary.  */\n #define UNNECESSARY_P(INSN)\tINSN_DEAD_CODE_P(INSN)\n-static void mark_all_insn_unnecessary\n-  PARAMS ((void));\n+static void mark_all_insn_unnecessary (void);\n /* Execute CODE with free variable INSN for all unnecessary insns in\n    an unspecified order, producing no output.  */\n #define EXECUTE_IF_UNNECESSARY(INSN, CODE)\t\\\n@@ -142,11 +134,9 @@ static void mark_all_insn_unnecessary\n }\n \n /* Find the label beginning block BB.  */\n-static rtx find_block_label\n-  PARAMS ((basic_block bb));\n+static rtx find_block_label (basic_block bb);\n /* Remove INSN, updating its basic block structure.  */\n-static void delete_insn_bb\n-  PARAMS ((rtx insn));\n+static void delete_insn_bb (rtx insn);\n \f\n /* Recording which blocks are control dependent on which edges.  We\n    expect each block to be control dependent on very few edges so we\n@@ -161,8 +151,7 @@ static void delete_insn_bb\n    control_dependent_block_to_edge_map_free ().  */\n \n static control_dependent_block_to_edge_map\n-control_dependent_block_to_edge_map_create (num_basic_blocks)\n-     size_t num_basic_blocks;\n+control_dependent_block_to_edge_map_create (size_t num_basic_blocks)\n {\n   int i;\n   control_dependent_block_to_edge_map c\n@@ -180,10 +169,8 @@ control_dependent_block_to_edge_map_create (num_basic_blocks)\n    control-dependent.  */\n \n static void\n-set_control_dependent_block_to_edge_map_bit (c, bb, edge_index)\n-     control_dependent_block_to_edge_map c;\n-     basic_block bb;\n-     int edge_index;\n+set_control_dependent_block_to_edge_map_bit (control_dependent_block_to_edge_map c,\n+\t\t\t\t\t     basic_block bb, int edge_index)\n {\n   if (bb->index - (INVALID_BLOCK+1) >= c->length)\n     abort ();\n@@ -205,8 +192,7 @@ set_control_dependent_block_to_edge_map_bit (c, bb, edge_index)\n /* Destroy a control_dependent_block_to_edge_map C.  */\n \n static void\n-control_dependent_block_to_edge_map_free (c)\n-     control_dependent_block_to_edge_map c;\n+control_dependent_block_to_edge_map_free (control_dependent_block_to_edge_map c)\n {\n   int i;\n   for (i = 0; i < c->length; ++i)\n@@ -220,10 +206,8 @@ control_dependent_block_to_edge_map_free (c)\n    which should be empty.  */\n \n static void\n-find_all_control_dependences (el, pdom, cdbte)\n-   struct edge_list *el;\n-   dominance_info pdom;\n-   control_dependent_block_to_edge_map cdbte;\n+find_all_control_dependences (struct edge_list *el, dominance_info pdom,\n+\t\t\t      control_dependent_block_to_edge_map cdbte)\n {\n   int i;\n \n@@ -238,11 +222,9 @@ find_all_control_dependences (el, pdom, cdbte)\n    with zeros in each (block b', edge) position.  */\n \n static void\n-find_control_dependence (el, edge_index, pdom, cdbte)\n-   struct edge_list *el;\n-   int edge_index;\n-   dominance_info pdom;\n-   control_dependent_block_to_edge_map cdbte;\n+find_control_dependence (struct edge_list *el, int edge_index,\n+\t\t\t dominance_info pdom,\n+\t\t\t control_dependent_block_to_edge_map cdbte)\n {\n   basic_block current_block;\n   basic_block ending_block;\n@@ -269,9 +251,7 @@ find_control_dependence (el, edge_index, pdom, cdbte)\n    negative numbers.  */\n \n static basic_block\n-find_pdom (pdom, block)\n-     dominance_info pdom;\n-     basic_block block;\n+find_pdom (dominance_info pdom, basic_block block)\n {\n   if (!block)\n     abort ();\n@@ -300,9 +280,8 @@ find_pdom (pdom, block)\n    particular PC values.  */\n \n static int\n-inherently_necessary_register_1 (current_rtx, data)\n-     rtx *current_rtx;\n-     void *data ATTRIBUTE_UNUSED;\n+inherently_necessary_register_1 (rtx *current_rtx,\n+\t\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *current_rtx;\n \n@@ -332,8 +311,7 @@ inherently_necessary_register_1 (current_rtx, data)\n /* Return nonzero if the insn CURRENT_RTX is inherently necessary.  */\n \n static int\n-inherently_necessary_register (current_rtx)\n-     rtx current_rtx;\n+inherently_necessary_register (rtx current_rtx)\n {\n   return for_each_rtx (&current_rtx,\n \t\t       &inherently_necessary_register_1, NULL);\n@@ -345,10 +323,7 @@ inherently_necessary_register (current_rtx)\n    nonzero value in inherently_necessary_p if such a store is found.  */\n \n static void\n-note_inherently_necessary_set (dest, set, data)\n-     rtx set ATTRIBUTE_UNUSED;\n-     rtx dest;\n-     void *data;\n+note_inherently_necessary_set (rtx dest, rtx set ATTRIBUTE_UNUSED, void *data)\n {\n   int *inherently_necessary_set_p = (int *) data;\n \n@@ -370,8 +345,7 @@ note_inherently_necessary_set (dest, set, data)\n    Return nonzero iff inherently necessary.  */\n \n static int\n-find_inherently_necessary (x)\n-     rtx x;\n+find_inherently_necessary (rtx x)\n {\n   if (x == NULL_RTX)\n     return 0;\n@@ -416,9 +390,7 @@ find_inherently_necessary (x)\n    instructions.  */\n \n static int\n-propagate_necessity_through_operand (current_rtx, data)\n-     rtx *current_rtx;\n-     void *data;\n+propagate_necessity_through_operand (rtx *current_rtx, void *data)\n {\n   rtx x = *current_rtx;\n   varray_type *unprocessed_instructions = (varray_type *) data;\n@@ -447,21 +419,20 @@ propagate_necessity_through_operand (current_rtx, data)\n /* Indicate all insns initially assumed to be unnecessary.  */\n \n static void\n-mark_all_insn_unnecessary ()\n+mark_all_insn_unnecessary (void)\n {\n   rtx insn;\n   for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn)) {\n     if (INSN_P (insn))\n       KILL_INSN (insn);\n   }\n-  \n+\n }\n \n /* Find the label beginning block BB, adding one if necessary.  */\n \n static rtx\n-find_block_label (bb)\n-     basic_block bb;\n+find_block_label (basic_block bb)\n {\n   rtx insn = bb->head;\n   if (LABEL_P (insn))\n@@ -478,8 +449,7 @@ find_block_label (bb)\n /* Remove INSN, updating its basic block structure.  */\n \n static void\n-delete_insn_bb (insn)\n-     rtx insn;\n+delete_insn_bb (rtx insn)\n {\n   if (!insn)\n     abort ();\n@@ -498,7 +468,7 @@ delete_insn_bb (insn)\n /* Perform the dead-code elimination.  */\n \n void\n-ssa_eliminate_dead_code ()\n+ssa_eliminate_dead_code (void)\n {\n   rtx insn;\n   basic_block bb;\n@@ -734,7 +704,7 @@ ssa_eliminate_dead_code ()\n     if (INSN_P (insn))\n       RESURRECT_INSN (insn);\n   }\n-  \n+\n   if (VARRAY_ACTIVE_SIZE (unprocessed_instructions) != 0)\n     abort ();\n   control_dependent_block_to_edge_map_free (cdbte);"}, {"sha": "1e36290491c661a6583c94a9e45d4898bf30d7e9", "filename": "gcc/ssa.c", "status": "modified", "additions": 121, "deletions": 241, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -127,36 +127,24 @@ struct ssa_rename_from_hash_table_data {\n   partition reg_partition;\n };\n \n-static rtx gen_sequence\n-  PARAMS ((void));\n-static void ssa_rename_from_initialize\n-  PARAMS ((void));\n-static rtx ssa_rename_from_lookup\n-  PARAMS ((int reg));\n-static unsigned int original_register\n-  PARAMS ((unsigned int regno));\n-static void ssa_rename_from_insert\n-  PARAMS ((unsigned int reg, rtx r));\n-static void ssa_rename_from_free\n-  PARAMS ((void));\n-typedef int (*srf_trav) PARAMS ((int regno, rtx r, sbitmap canonical_elements, partition reg_partition));\n-static void ssa_rename_from_traverse\n-  PARAMS ((htab_trav callback_function, sbitmap canonical_elements, partition reg_partition));\n-/*static Avoid warning message.  */ void ssa_rename_from_print\n-  PARAMS ((void));\n-static int ssa_rename_from_print_1\n-  PARAMS ((void **slot, void *data));\n-static hashval_t ssa_rename_from_hash_function\n-  PARAMS ((const void * srfp));\n-static int ssa_rename_from_equal\n-  PARAMS ((const void *srfp1, const void *srfp2));\n-static void ssa_rename_from_delete\n-  PARAMS ((void *srfp));\n-\n-static rtx ssa_rename_to_lookup\n-  PARAMS ((rtx reg));\n-static void ssa_rename_to_insert\n-  PARAMS ((rtx reg, rtx r));\n+static rtx gen_sequence (void);\n+static void ssa_rename_from_initialize (void);\n+static rtx ssa_rename_from_lookup (int reg);\n+static unsigned int original_register (unsigned int regno);\n+static void ssa_rename_from_insert (unsigned int reg, rtx r);\n+static void ssa_rename_from_free (void);\n+typedef int (*srf_trav) (int regno, rtx r, sbitmap canonical_elements,\n+\t\t\t partition reg_partition);\n+static void ssa_rename_from_traverse (htab_trav callback_function,\n+\t\t\t\t      sbitmap canonical_elements, partition reg_partition);\n+/*static Avoid warning message.  */ void ssa_rename_from_print (void);\n+static int ssa_rename_from_print_1 (void **slot, void *data);\n+static hashval_t ssa_rename_from_hash_function (const void * srfp);\n+static int ssa_rename_from_equal (const void *srfp1, const void *srfp2);\n+static void ssa_rename_from_delete (void *srfp);\n+\n+static rtx ssa_rename_to_lookup (rtx reg);\n+static void ssa_rename_to_insert (rtx reg, rtx r);\n \n /* The number of registers that were live on entry to the SSA routines.  */\n static unsigned int ssa_max_reg_num;\n@@ -165,87 +153,66 @@ static unsigned int ssa_max_reg_num;\n \n struct rename_context;\n \n-static inline rtx * phi_alternative\n-  PARAMS ((rtx, int));\n-static void compute_dominance_frontiers_1\n-  PARAMS ((sbitmap *frontiers, dominance_info idom, int bb, sbitmap done));\n-static void find_evaluations_1\n-  PARAMS ((rtx dest, rtx set, void *data));\n-static void find_evaluations\n-  PARAMS ((sbitmap *evals, int nregs));\n-static void compute_iterated_dominance_frontiers\n-  PARAMS ((sbitmap *idfs, sbitmap *frontiers, sbitmap *evals, int nregs));\n-static void insert_phi_node\n-  PARAMS ((int regno, int b));\n-static void insert_phi_nodes\n-  PARAMS ((sbitmap *idfs, sbitmap *evals, int nregs));\n-static void create_delayed_rename\n-  PARAMS ((struct rename_context *, rtx *));\n-static void apply_delayed_renames\n-  PARAMS ((struct rename_context *));\n-static int rename_insn_1\n-  PARAMS ((rtx *ptr, void *data));\n-static void rename_block\n-  PARAMS ((int b, dominance_info dom));\n-static void rename_registers\n-  PARAMS ((int nregs, dominance_info idom));\n-\n-static inline int ephi_add_node\n-  PARAMS ((rtx reg, rtx *nodes, int *n_nodes));\n-static int * ephi_forward\n-  PARAMS ((int t, sbitmap visited, sbitmap *succ, int *tstack));\n-static void ephi_backward\n-  PARAMS ((int t, sbitmap visited, sbitmap *pred, rtx *nodes));\n-static void ephi_create\n-  PARAMS ((int t, sbitmap visited, sbitmap *pred, sbitmap *succ, rtx *nodes));\n-static void eliminate_phi\n-  PARAMS ((edge e, partition reg_partition));\n-static int make_regs_equivalent_over_bad_edges\n-  PARAMS ((int bb, partition reg_partition));\n+static inline rtx * phi_alternative (rtx, int);\n+static void compute_dominance_frontiers_1 (sbitmap *frontiers,\n+\t\t\t\t\t   dominance_info idom, int bb,\n+\t\t\t\t\t   sbitmap done);\n+static void find_evaluations_1 (rtx dest, rtx set, void *data);\n+static void find_evaluations (sbitmap *evals, int nregs);\n+static void compute_iterated_dominance_frontiers (sbitmap *idfs,\n+\t\t\t\t\t\t  sbitmap *frontiers,\n+\t\t\t\t\t\t  sbitmap *evals, int nregs);\n+static void insert_phi_node (int regno, int b);\n+static void insert_phi_nodes (sbitmap *idfs, sbitmap *evals, int nregs);\n+static void create_delayed_rename (struct rename_context *, rtx *);\n+static void apply_delayed_renames (struct rename_context *);\n+static int rename_insn_1 (rtx *ptr, void *data);\n+static void rename_block (int b, dominance_info dom);\n+static void rename_registers (int nregs, dominance_info idom);\n+\n+static inline int ephi_add_node (rtx reg, rtx *nodes, int *n_nodes);\n+static int * ephi_forward (int t, sbitmap visited, sbitmap *succ, int *tstack);\n+static void ephi_backward (int t, sbitmap visited, sbitmap *pred, rtx *nodes);\n+static void ephi_create (int t, sbitmap visited, sbitmap *pred,\n+\t\t\t sbitmap *succ, rtx *nodes);\n+static void eliminate_phi (edge e, partition reg_partition);\n+static int make_regs_equivalent_over_bad_edges (int bb,\n+\t\t\t\t\t\tpartition reg_partition);\n \n /* These are used only in the conservative register partitioning\n    algorithms.  */\n static int make_equivalent_phi_alternatives_equivalent\n-  PARAMS ((int bb, partition reg_partition));\n-static partition compute_conservative_reg_partition\n-  PARAMS ((void));\n-static int record_canonical_element_1\n-  PARAMS ((void **srfp, void *data));\n-static int check_hard_regs_in_partition\n-  PARAMS ((partition reg_partition));\n+  (int bb, partition reg_partition);\n+static partition compute_conservative_reg_partition (void);\n+static int record_canonical_element_1 (void **srfp, void *data);\n+static int check_hard_regs_in_partition (partition reg_partition);\n \n /* These are used in the register coalescing algorithm.  */\n-static int coalesce_if_unconflicting\n-  PARAMS ((partition p, conflict_graph conflicts, int reg1, int reg2));\n-static int coalesce_regs_in_copies\n-  PARAMS ((basic_block bb, partition p, conflict_graph conflicts));\n-static int coalesce_reg_in_phi\n-  PARAMS ((rtx, int dest_regno, int src_regno, void *data));\n-static int coalesce_regs_in_successor_phi_nodes\n-  PARAMS ((basic_block bb, partition p, conflict_graph conflicts));\n-static partition compute_coalesced_reg_partition\n-  PARAMS ((void));\n-static int mark_reg_in_phi\n-  PARAMS ((rtx *ptr, void *data));\n-static void mark_phi_and_copy_regs\n-  PARAMS ((regset phi_set));\n-\n-static int rename_equivalent_regs_in_insn\n-  PARAMS ((rtx *ptr, void *data));\n-static void rename_equivalent_regs\n-  PARAMS ((partition reg_partition));\n+static int coalesce_if_unconflicting (partition p, conflict_graph conflicts,\n+\t\t\t\t      int reg1, int reg2);\n+static int coalesce_regs_in_copies (basic_block bb, partition p,\n+\t\t\t\t    conflict_graph conflicts);\n+static int coalesce_reg_in_phi (rtx, int dest_regno, int src_regno,\n+\t\t\t\tvoid *data);\n+static int coalesce_regs_in_successor_phi_nodes (basic_block bb,\n+\t\t\t\t\t\t partition p,\n+\t\t\t\t\t\t conflict_graph conflicts);\n+static partition compute_coalesced_reg_partition (void);\n+static int mark_reg_in_phi (rtx *ptr, void *data);\n+static void mark_phi_and_copy_regs (regset phi_set);\n+\n+static int rename_equivalent_regs_in_insn (rtx *ptr, void *data);\n+static void rename_equivalent_regs (partition reg_partition);\n \n /* Deal with hard registers.  */\n-static int conflicting_hard_regs_p\n-  PARAMS ((int reg1, int reg2));\n+static int conflicting_hard_regs_p (int reg1, int reg2);\n \n /* ssa_rename_to maps registers and machine modes to SSA pseudo registers.  */\n \n /* Find the register associated with REG in the indicated mode.  */\n \n static rtx\n-ssa_rename_to_lookup (reg)\n-     rtx reg;\n+ssa_rename_to_lookup (rtx reg)\n {\n   if (!HARD_REGISTER_P (reg))\n     return ssa_rename_to_pseudo[REGNO (reg) - FIRST_PSEUDO_REGISTER];\n@@ -256,9 +223,7 @@ ssa_rename_to_lookup (reg)\n /* Store a new value mapping REG to R in ssa_rename_to.  */\n \n static void\n-ssa_rename_to_insert(reg, r)\n-     rtx reg;\n-     rtx r;\n+ssa_rename_to_insert (rtx reg, rtx r)\n {\n   if (!HARD_REGISTER_P (reg))\n     ssa_rename_to_pseudo[REGNO (reg) - FIRST_PSEUDO_REGISTER] = r;\n@@ -269,7 +234,7 @@ ssa_rename_to_insert(reg, r)\n /* Prepare ssa_rename_from for use.  */\n \n static void\n-ssa_rename_from_initialize ()\n+ssa_rename_from_initialize (void)\n {\n   /* We use an arbitrary initial hash table size of 64.  */\n   ssa_rename_from_ht = htab_create (64,\n@@ -282,8 +247,7 @@ ssa_rename_from_initialize ()\n    found.  */\n \n static rtx\n-ssa_rename_from_lookup (reg)\n-     int reg;\n+ssa_rename_from_lookup (int reg)\n {\n   ssa_rename_from_pair srfp;\n   ssa_rename_from_pair *answer;\n@@ -299,8 +263,7 @@ ssa_rename_from_lookup (reg)\n    Otherwise, return this register number REGNO.  */\n \n static unsigned int\n-original_register (regno)\n-     unsigned int regno;\n+original_register (unsigned int regno)\n {\n   rtx original_rtx = ssa_rename_from_lookup (regno);\n   return original_rtx != NULL_RTX ? REGNO (original_rtx) : regno;\n@@ -309,9 +272,7 @@ original_register (regno)\n /* Add mapping from R to REG to ssa_rename_from even if already present.  */\n \n static void\n-ssa_rename_from_insert (reg, r)\n-     unsigned int reg;\n-     rtx r;\n+ssa_rename_from_insert (unsigned int reg, rtx r)\n {\n   void **slot;\n   ssa_rename_from_pair *srfp = xmalloc (sizeof (ssa_rename_from_pair));\n@@ -329,11 +290,8 @@ ssa_rename_from_insert (reg, r)\n    current use of this function.  */\n \n static void\n-ssa_rename_from_traverse (callback_function,\n-\t\t\t  canonical_elements, reg_partition)\n-     htab_trav callback_function;\n-     sbitmap canonical_elements;\n-     partition reg_partition;\n+ssa_rename_from_traverse (htab_trav callback_function,\n+\t\t\t  sbitmap canonical_elements, partition reg_partition)\n {\n   struct ssa_rename_from_hash_table_data srfhd;\n   srfhd.canonical_elements = canonical_elements;\n@@ -344,7 +302,7 @@ ssa_rename_from_traverse (callback_function,\n /* Destroy ssa_rename_from.  */\n \n static void\n-ssa_rename_from_free ()\n+ssa_rename_from_free (void)\n {\n   htab_delete (ssa_rename_from_ht);\n }\n@@ -353,7 +311,7 @@ ssa_rename_from_free ()\n \n /* static  Avoid erroneous error message.  */\n void\n-ssa_rename_from_print ()\n+ssa_rename_from_print (void)\n {\n   printf (\"ssa_rename_from's hash table contents:\\n\");\n   htab_traverse (ssa_rename_from_ht, &ssa_rename_from_print_1, NULL);\n@@ -363,9 +321,7 @@ ssa_rename_from_print ()\n    attribute DATA.  Used as a callback function with htab_traverse ().  */\n \n static int\n-ssa_rename_from_print_1 (slot, data)\n-     void **slot;\n-     void *data ATTRIBUTE_UNUSED;\n+ssa_rename_from_print_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   ssa_rename_from_pair * p = *slot;\n   printf (\"ssa_rename_from maps pseudo %i to original %i.\\n\",\n@@ -376,18 +332,15 @@ ssa_rename_from_print_1 (slot, data)\n /* Given a hash entry SRFP, yield a hash value.  */\n \n static hashval_t\n-ssa_rename_from_hash_function (srfp)\n-     const void *srfp;\n+ssa_rename_from_hash_function (const void *srfp)\n {\n   return ((const ssa_rename_from_pair *) srfp)->reg;\n }\n \n /* Test whether two hash table entries SRFP1 and SRFP2 are equal.  */\n \n static int\n-ssa_rename_from_equal (srfp1, srfp2)\n-     const void *srfp1;\n-     const void *srfp2;\n+ssa_rename_from_equal (const void *srfp1, const void *srfp2)\n {\n   return ssa_rename_from_hash_function (srfp1) ==\n     ssa_rename_from_hash_function (srfp2);\n@@ -396,8 +349,7 @@ ssa_rename_from_equal (srfp1, srfp2)\n /* Delete the hash table entry SRFP.  */\n \n static void\n-ssa_rename_from_delete (srfp)\n-     void *srfp;\n+ssa_rename_from_delete (void *srfp)\n {\n   free (srfp);\n }\n@@ -406,9 +358,7 @@ ssa_rename_from_delete (srfp)\n    for predecessor block C.  */\n \n static inline rtx *\n-phi_alternative (set, c)\n-     rtx set;\n-     int c;\n+phi_alternative (rtx set, int c)\n {\n   rtvec phi_vec = XVEC (SET_SRC (set), 0);\n   int v;\n@@ -425,9 +375,7 @@ phi_alternative (set, c)\n    found for C.  */\n \n int\n-remove_phi_alternative (set, block)\n-     rtx set;\n-     basic_block block;\n+remove_phi_alternative (rtx set, basic_block block)\n {\n   rtvec phi_vec = XVEC (SET_SRC (set), 0);\n   int num_elem = GET_NUM_ELEM (phi_vec);\n@@ -458,20 +406,16 @@ static sbitmap *fe_evals;\n static int fe_current_bb;\n \n static void\n-find_evaluations_1 (dest, set, data)\n-     rtx dest;\n-     rtx set ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+find_evaluations_1 (rtx dest, rtx set ATTRIBUTE_UNUSED,\n+\t\t    void *data ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (dest) == REG\n       && CONVERT_REGISTER_TO_SSA_P (REGNO (dest)))\n     SET_BIT (fe_evals[REGNO (dest)], fe_current_bb);\n }\n \n static void\n-find_evaluations (evals, nregs)\n-     sbitmap *evals;\n-     int nregs;\n+find_evaluations (sbitmap *evals, int nregs)\n {\n   basic_block bb;\n \n@@ -515,11 +459,8 @@ find_evaluations (evals, nregs)\n */\n \n static void\n-compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n-     sbitmap *frontiers;\n-     dominance_info idom;\n-     int bb;\n-     sbitmap done;\n+compute_dominance_frontiers_1 (sbitmap *frontiers, dominance_info idom,\n+\t\t\t       int bb, sbitmap done)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   edge e;\n@@ -559,9 +500,7 @@ compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n }\n \n void\n-compute_dominance_frontiers (frontiers, idom)\n-     sbitmap *frontiers;\n-     dominance_info idom;\n+compute_dominance_frontiers (sbitmap *frontiers, dominance_info idom)\n {\n   sbitmap done = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (done);\n@@ -580,11 +519,8 @@ compute_dominance_frontiers (frontiers, idom)\n */\n \n static void\n-compute_iterated_dominance_frontiers (idfs, frontiers, evals, nregs)\n-     sbitmap *idfs;\n-     sbitmap *frontiers;\n-     sbitmap *evals;\n-     int nregs;\n+compute_iterated_dominance_frontiers (sbitmap *idfs, sbitmap *frontiers,\n+\t\t\t\t      sbitmap *evals, int nregs)\n {\n   sbitmap worklist;\n   int reg, passes = 0;\n@@ -638,8 +574,7 @@ compute_iterated_dominance_frontiers (idfs, frontiers, evals, nregs)\n /* Insert the phi nodes.  */\n \n static void\n-insert_phi_node (regno, bb)\n-     int regno, bb;\n+insert_phi_node (int regno, int bb)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   edge e;\n@@ -683,10 +618,7 @@ insert_phi_node (regno, bb)\n }\n \n static void\n-insert_phi_nodes (idfs, evals, nregs)\n-     sbitmap *idfs;\n-     sbitmap *evals ATTRIBUTE_UNUSED;\n-     int nregs;\n+insert_phi_nodes (sbitmap *idfs, sbitmap *evals ATTRIBUTE_UNUSED, int nregs)\n {\n   int reg;\n \n@@ -738,9 +670,7 @@ struct rename_context\n \n /* Queue the rename of *REG_LOC.  */\n static void\n-create_delayed_rename (c, reg_loc)\n-     struct rename_context *c;\n-     rtx *reg_loc;\n+create_delayed_rename (struct rename_context *c, rtx *reg_loc)\n {\n   struct rename_set_data *r;\n   r = (struct rename_set_data *) xmalloc (sizeof(*r));\n@@ -770,8 +700,7 @@ create_delayed_rename (c, reg_loc)\n    applying all the renames on NEW_RENAMES.  */\n \n static void\n-apply_delayed_renames (c)\n-       struct rename_context *c;\n+apply_delayed_renames (struct rename_context *c)\n {\n   struct rename_set_data *r;\n   struct rename_set_data *last_r = NULL;\n@@ -820,9 +749,7 @@ apply_delayed_renames (c)\n    Mark pseudos that are set for later update.  Transform uses of pseudos.  */\n \n static int\n-rename_insn_1 (ptr, data)\n-     rtx *ptr;\n-     void *data;\n+rename_insn_1 (rtx *ptr, void *data)\n {\n   rtx x = *ptr;\n   struct rename_context *context = data;\n@@ -976,7 +903,7 @@ rename_insn_1 (ptr, data)\n }\n \n static rtx\n-gen_sequence ()\n+gen_sequence (void)\n {\n   rtx first_insn = get_insns ();\n   rtx result;\n@@ -998,9 +925,7 @@ gen_sequence ()\n }\n \n static void\n-rename_block (bb, idom)\n-     int bb;\n-     dominance_info idom;\n+rename_block (int bb, dominance_info idom)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   edge e;\n@@ -1134,9 +1059,7 @@ rename_block (bb, idom)\n }\n \n static void\n-rename_registers (nregs, idom)\n-     int nregs;\n-     dominance_info idom;\n+rename_registers (int nregs, dominance_info idom)\n {\n   VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n   ssa_rename_from_initialize ();\n@@ -1157,7 +1080,7 @@ rename_registers (nregs, idom)\n /* The main entry point for moving to SSA.  */\n \n void\n-convert_to_ssa ()\n+convert_to_ssa (void)\n {\n   /* Element I is the set of blocks that set register I.  */\n   sbitmap *evals;\n@@ -1247,9 +1170,7 @@ convert_to_ssa ()\n    index of this register in the node set.  */\n \n static inline int\n-ephi_add_node (reg, nodes, n_nodes)\n-     rtx reg, *nodes;\n-     int *n_nodes;\n+ephi_add_node (rtx reg, rtx *nodes, int *n_nodes)\n {\n   int i;\n   for (i = *n_nodes - 1; i >= 0; --i)\n@@ -1266,11 +1187,7 @@ ephi_add_node (reg, nodes, n_nodes)\n    no other dependencies.  */\n \n static int *\n-ephi_forward (t, visited, succ, tstack)\n-     int t;\n-     sbitmap visited;\n-     sbitmap *succ;\n-     int *tstack;\n+ephi_forward (int t, sbitmap visited, sbitmap *succ, int *tstack)\n {\n   int s;\n \n@@ -1290,10 +1207,7 @@ ephi_forward (t, visited, succ, tstack)\n    a cycle in the graph, copying the data forward as we go.  */\n \n static void\n-ephi_backward (t, visited, pred, nodes)\n-     int t;\n-     sbitmap visited, *pred;\n-     rtx *nodes;\n+ephi_backward (int t, sbitmap visited, sbitmap *pred, rtx *nodes)\n {\n   int p;\n \n@@ -1313,10 +1227,7 @@ ephi_backward (t, visited, pred, nodes)\n    and any cycle of which it is a member.  */\n \n static void\n-ephi_create (t, visited, pred, succ, nodes)\n-     int t;\n-     sbitmap visited, *pred, *succ;\n-     rtx *nodes;\n+ephi_create (int t, sbitmap visited, sbitmap *pred, sbitmap *succ, rtx *nodes)\n {\n   rtx reg_u = NULL_RTX;\n   int unvisited_predecessors = 0;\n@@ -1372,9 +1283,7 @@ ephi_create (t, visited, pred, succ, nodes)\n /* Convert the edge to normal form.  */\n \n static void\n-eliminate_phi (e, reg_partition)\n-     edge e;\n-     partition reg_partition;\n+eliminate_phi (edge e, partition reg_partition)\n {\n   int n_nodes;\n   sbitmap *pred, *succ;\n@@ -1501,9 +1410,7 @@ eliminate_phi (e, reg_partition)\n    regs were not already in the same class.  */\n \n static int\n-make_regs_equivalent_over_bad_edges (bb, reg_partition)\n-     int bb;\n-     partition reg_partition;\n+make_regs_equivalent_over_bad_edges (int bb, partition reg_partition)\n {\n   int changed = 0;\n   basic_block b = BASIC_BLOCK (bb);\n@@ -1574,9 +1481,7 @@ make_regs_equivalent_over_bad_edges (bb, reg_partition)\n    Return nonzero if any new register classes were unioned.  */\n \n static int\n-make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n-     int bb;\n-     partition reg_partition;\n+make_equivalent_phi_alternatives_equivalent (int bb, partition reg_partition)\n {\n   int changed = 0;\n   basic_block b = BASIC_BLOCK (bb);\n@@ -1659,7 +1564,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n    See Morgan 7.3.1.  */\n \n static partition\n-compute_conservative_reg_partition ()\n+compute_conservative_reg_partition (void)\n {\n   basic_block bb;\n   int changed = 0;\n@@ -1721,11 +1626,8 @@ compute_conservative_reg_partition ()\n    See Morgan figure 11.15.  */\n \n static int\n-coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n-     partition p;\n-     conflict_graph conflicts;\n-     int reg1;\n-     int reg2;\n+coalesce_if_unconflicting (partition p, conflict_graph conflicts,\n+\t\t\t   int reg1, int reg2)\n {\n   int reg;\n \n@@ -1769,10 +1671,7 @@ coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n    See Morgan figure 11.14.  */\n \n static int\n-coalesce_regs_in_copies (bb, p, conflicts)\n-     basic_block bb;\n-     partition p;\n-     conflict_graph conflicts;\n+coalesce_regs_in_copies (basic_block bb, partition p, conflict_graph conflicts)\n {\n   int changed = 0;\n   rtx insn;\n@@ -1831,11 +1730,8 @@ struct phi_coalesce_context\n    phi_coalesce_context struct.  */\n \n static int\n-coalesce_reg_in_phi (insn, dest_regno, src_regno, data)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int dest_regno;\n-     int src_regno;\n-     void *data;\n+coalesce_reg_in_phi (rtx insn ATTRIBUTE_UNUSED, int dest_regno,\n+\t\t     int src_regno, void *data)\n {\n   struct phi_coalesce_context *context =\n     (struct phi_coalesce_context *) data;\n@@ -1857,10 +1753,8 @@ coalesce_reg_in_phi (insn, dest_regno, src_regno, data)\n    See Morgan figure 11.14.  */\n \n static int\n-coalesce_regs_in_successor_phi_nodes (bb, p, conflicts)\n-     basic_block bb;\n-     partition p;\n-     conflict_graph conflicts;\n+coalesce_regs_in_successor_phi_nodes (basic_block bb, partition p,\n+\t\t\t\t      conflict_graph conflicts)\n {\n   struct phi_coalesce_context context;\n   context.p = p;\n@@ -1878,7 +1772,7 @@ coalesce_regs_in_successor_phi_nodes (bb, p, conflicts)\n    The caller is responsible for deallocating the returned partition.  */\n \n static partition\n-compute_coalesced_reg_partition ()\n+compute_coalesced_reg_partition (void)\n {\n   basic_block bb;\n   int changed = 0;\n@@ -1936,9 +1830,7 @@ compute_coalesced_reg_partition ()\n    set all regs.  Called from for_each_rtx.  */\n \n static int\n-mark_reg_in_phi (ptr, data)\n-     rtx *ptr;\n-     void *data;\n+mark_reg_in_phi (rtx *ptr, void *data)\n {\n   rtx expr = *ptr;\n   regset set = (regset) data;\n@@ -1962,8 +1854,7 @@ mark_reg_in_phi (ptr, data)\n    ssa_definition.  */\n \n static void\n-mark_phi_and_copy_regs (phi_set)\n-     regset phi_set;\n+mark_phi_and_copy_regs (regset phi_set)\n {\n   unsigned int reg;\n \n@@ -2007,9 +1898,7 @@ mark_phi_and_copy_regs (phi_set)\n    partition which specifies equivalences.  */\n \n static int\n-rename_equivalent_regs_in_insn (ptr, data)\n-     rtx *ptr;\n-     void* data;\n+rename_equivalent_regs_in_insn (rtx *ptr, void* data)\n {\n   rtx x = *ptr;\n   partition reg_partition = (partition) data;\n@@ -2058,9 +1947,7 @@ rename_equivalent_regs_in_insn (ptr, data)\n    as a callback function for traversing ssa_rename_from.  */\n \n static int\n-record_canonical_element_1 (srfp, data)\n-     void **srfp;\n-     void *data;\n+record_canonical_element_1 (void **srfp, void *data)\n {\n   unsigned int reg = ((ssa_rename_from_pair *) *srfp)->reg;\n   sbitmap canonical_elements =\n@@ -2078,8 +1965,7 @@ record_canonical_element_1 (srfp, data)\n    nonzero if this is the case, i.e., the partition is acceptable.  */\n \n static int\n-check_hard_regs_in_partition (reg_partition)\n-     partition reg_partition;\n+check_hard_regs_in_partition (partition reg_partition)\n {\n   /* CANONICAL_ELEMENTS has a nonzero bit if a class with the given register\n      number and machine mode has already been seen.  This is a\n@@ -2122,8 +2008,7 @@ check_hard_regs_in_partition (reg_partition)\n    any SEQUENCE insns.  */\n \n static void\n-rename_equivalent_regs (reg_partition)\n-     partition reg_partition;\n+rename_equivalent_regs (partition reg_partition)\n {\n   basic_block b;\n \n@@ -2169,7 +2054,7 @@ rename_equivalent_regs (reg_partition)\n /* The main entry point for moving from SSA.  */\n \n void\n-convert_from_ssa ()\n+convert_from_ssa (void)\n {\n   basic_block b, bb;\n   partition reg_partition;\n@@ -2257,10 +2142,7 @@ convert_from_ssa ()\n    value.  Otherwise, returns zero.  */\n \n int\n-for_each_successor_phi (bb, fn, data)\n-     basic_block bb;\n-     successor_phi_fn fn;\n-     void *data;\n+for_each_successor_phi (basic_block bb, successor_phi_fn fn, void *data)\n {\n   edge e;\n \n@@ -2317,9 +2199,7 @@ for_each_successor_phi (bb, fn, data)\n    different hard registers.  */\n \n static int\n-conflicting_hard_regs_p (reg1, reg2)\n-     int reg1;\n-     int reg2;\n+conflicting_hard_regs_p (int reg1, int reg2)\n {\n   int orig_reg1 = original_register (reg1);\n   int orig_reg2 = original_register (reg2);"}, {"sha": "ab3cdf1a7894726e7c60a3937797be49d47152d7", "filename": "gcc/ssa.h", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* Static Single Assignment (SSA) definitions for GCC\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n    Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n \n This file is part of GCC.\n@@ -21,23 +21,21 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n \n /* Main SSA routines.  */\n-extern void convert_to_ssa\t\tPARAMS ((void));\n-extern void convert_from_ssa\t\tPARAMS ((void));\n-typedef int (*successor_phi_fn)         PARAMS ((rtx, int, int, void *));\n-extern int for_each_successor_phi       PARAMS ((basic_block bb,\n-\t\t\t\t\t\t successor_phi_fn,\n-\t\t\t\t\t\t void *));\n-void compute_dominance_frontiers\tPARAMS ((sbitmap *frontiers,\n-\t\t\t\t\t\t dominance_info idom));\n-extern int remove_phi_alternative\tPARAMS ((rtx, basic_block));\n+extern void convert_to_ssa (void);\n+extern void convert_from_ssa (void);\n+typedef int (*successor_phi_fn) (rtx, int, int, void *);\n+extern int for_each_successor_phi (basic_block bb, successor_phi_fn,\n+\t\t\t\t   void *);\n+void compute_dominance_frontiers (sbitmap *frontiers, dominance_info idom);\n+extern int remove_phi_alternative (rtx, basic_block);\n \n \n /* Optimizations.  */\n /* In ssa-dce.c */\n-extern void ssa_eliminate_dead_code\tPARAMS ((void));\n+extern void ssa_eliminate_dead_code (void);\n \n /* In ssa-ccp.c */\n-extern void ssa_const_prop\t\tPARAMS ((void));\n+extern void ssa_const_prop (void);\n \n \n /* SSA definitions and uses.  */"}, {"sha": "12161036691228df0de5c306904befc050c6bd39", "filename": "gcc/stack.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* stack.h - structed access to object stacks\n-   Copyright (C) 1988, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n \n This program is free software; you can redistribute it and/or modify it\n@@ -21,7 +21,7 @@ Boston, MA 02111-1307, USA.  */\n    on top of obstacks for GNU C++.  */\n \n /* Stack of data placed on obstacks.  */\n-   \n+\n struct stack_level\n {\n   /* Pointer back to previous such level.  */\n@@ -38,5 +38,5 @@ struct stack_level\n   int limit;\n };\n \n-struct stack_level *push_stack_level PARAMS ((struct obstack *, char *, int));\n-struct stack_level *pop_stack_level PARAMS ((struct stack_level *));\n+struct stack_level *push_stack_level (struct obstack *, char *, int);\n+struct stack_level *pop_stack_level (struct stack_level *);"}, {"sha": "ce11895e6351fdca0898076bc75f18053427face", "filename": "gcc/stmt.c", "status": "modified", "additions": 148, "deletions": 282, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -390,53 +390,49 @@ struct stmt_status GTY(())\n /* Nonzero if we are using EH to handle cleanups.  */\n static int using_eh_for_cleanups_p = 0;\n \n-static int n_occurrences\t\tPARAMS ((int, const char *));\n-static bool parse_input_constraint\tPARAMS ((const char **, int, int, int,\n-\t\t\t\t\t\t int, const char * const *,\n-\t\t\t\t\t\t bool *, bool *));\n-static bool decl_conflicts_with_clobbers_p PARAMS ((tree, const HARD_REG_SET));\n-static void expand_goto_internal\tPARAMS ((tree, rtx, rtx));\n-static int expand_fixup\t\t\tPARAMS ((tree, rtx, rtx));\n-static rtx expand_nl_handler_label\tPARAMS ((rtx, rtx));\n-static void expand_nl_goto_receiver\tPARAMS ((void));\n-static void expand_nl_goto_receivers\tPARAMS ((struct nesting *));\n-static void fixup_gotos\t\t\tPARAMS ((struct nesting *, rtx, tree,\n-\t\t\t\t\t       rtx, int));\n-static bool check_operand_nalternatives\tPARAMS ((tree, tree));\n-static bool check_unique_operand_names\tPARAMS ((tree, tree));\n-static char *resolve_operand_name_1\tPARAMS ((char *, tree, tree));\n-static void expand_null_return_1\tPARAMS ((rtx));\n-static enum br_predictor return_prediction PARAMS ((rtx));\n-static void expand_value_return\t\tPARAMS ((rtx));\n-static int tail_recursion_args\t\tPARAMS ((tree, tree));\n-static void expand_cleanups\t\tPARAMS ((tree, int, int));\n-static void check_seenlabel\t\tPARAMS ((void));\n-static void do_jump_if_equal\t\tPARAMS ((rtx, rtx, rtx, int));\n-static int estimate_case_costs\t\tPARAMS ((case_node_ptr));\n-static bool same_case_target_p\t\tPARAMS ((rtx, rtx));\n-static void strip_default_case_nodes\tPARAMS ((case_node_ptr *, rtx));\n-static bool lshift_cheap_p\t\tPARAMS ((void));\n-static int case_bit_test_cmp\t\tPARAMS ((const void *, const void *));\n-static void emit_case_bit_tests\t\tPARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t case_node_ptr, rtx));\n-static void group_case_nodes\t\tPARAMS ((case_node_ptr));\n-static void balance_case_nodes\t\tPARAMS ((case_node_ptr *,\n-\t\t\t\t\t       case_node_ptr));\n-static int node_has_low_bound\t\tPARAMS ((case_node_ptr, tree));\n-static int node_has_high_bound\t\tPARAMS ((case_node_ptr, tree));\n-static int node_is_bounded\t\tPARAMS ((case_node_ptr, tree));\n-static void emit_jump_if_reachable\tPARAMS ((rtx));\n-static void emit_case_nodes\t\tPARAMS ((rtx, case_node_ptr, rtx, tree));\n-static struct case_node *case_tree2list\tPARAMS ((case_node *, case_node *));\n+static int n_occurrences (int, const char *);\n+static bool parse_input_constraint (const char **, int, int, int, int,\n+\t\t\t\t    const char * const *, bool *, bool *);\n+static bool decl_conflicts_with_clobbers_p (tree, const HARD_REG_SET);\n+static void expand_goto_internal (tree, rtx, rtx);\n+static int expand_fixup (tree, rtx, rtx);\n+static rtx expand_nl_handler_label (rtx, rtx);\n+static void expand_nl_goto_receiver (void);\n+static void expand_nl_goto_receivers (struct nesting *);\n+static void fixup_gotos (struct nesting *, rtx, tree, rtx, int);\n+static bool check_operand_nalternatives (tree, tree);\n+static bool check_unique_operand_names (tree, tree);\n+static char *resolve_operand_name_1 (char *, tree, tree);\n+static void expand_null_return_1 (rtx);\n+static enum br_predictor return_prediction (rtx);\n+static void expand_value_return (rtx);\n+static int tail_recursion_args (tree, tree);\n+static void expand_cleanups (tree, int, int);\n+static void check_seenlabel (void);\n+static void do_jump_if_equal (rtx, rtx, rtx, int);\n+static int estimate_case_costs (case_node_ptr);\n+static bool same_case_target_p (rtx, rtx);\n+static void strip_default_case_nodes (case_node_ptr *, rtx);\n+static bool lshift_cheap_p (void);\n+static int case_bit_test_cmp (const void *, const void *);\n+static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, rtx);\n+static void group_case_nodes (case_node_ptr);\n+static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n+static int node_has_low_bound (case_node_ptr, tree);\n+static int node_has_high_bound (case_node_ptr, tree);\n+static int node_is_bounded (case_node_ptr, tree);\n+static void emit_jump_if_reachable (rtx);\n+static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n+static struct case_node *case_tree2list (case_node *, case_node *);\n \f\n void\n-using_eh_for_cleanups ()\n+using_eh_for_cleanups (void)\n {\n   using_eh_for_cleanups_p = 1;\n }\n \n void\n-init_stmt_for_function ()\n+init_stmt_for_function (void)\n {\n   cfun->stmt = ((struct stmt_status *)ggc_alloc (sizeof (struct stmt_status)));\n \n@@ -461,9 +457,7 @@ init_stmt_for_function ()\n \f\n /* Record the current file and line.  Called from emit_line_note.  */\n void\n-set_file_and_line_for_stmt (file, line)\n-     const char *file;\n-     int line;\n+set_file_and_line_for_stmt (const char *file, int line)\n {\n   /* If we're outputting an inline function, and we add a line note,\n      there may be no CFUN->STMT information.  So, there's no need to\n@@ -478,7 +472,7 @@ set_file_and_line_for_stmt (file, line)\n /* Emit a no-op instruction.  */\n \n void\n-emit_nop ()\n+emit_nop (void)\n {\n   rtx last_insn;\n \n@@ -494,8 +488,7 @@ emit_nop ()\n    creating it if necessary.  */\n \n rtx\n-label_rtx (label)\n-     tree label;\n+label_rtx (tree label)\n {\n   if (TREE_CODE (label) != LABEL_DECL)\n     abort ();\n@@ -509,8 +502,7 @@ label_rtx (label)\n /* As above, but also put it on the forced-reference list of the\n    function that contains it.  */\n rtx\n-force_label_rtx (label)\n-     tree label;\n+force_label_rtx (tree label)\n {\n   rtx ref = label_rtx (label);\n   tree function = decl_function_context (label);\n@@ -533,8 +525,7 @@ force_label_rtx (label)\n /* Add an unconditional jump to LABEL as the next sequential instruction.  */\n \n void\n-emit_jump (label)\n-     rtx label;\n+emit_jump (rtx label)\n {\n   do_pending_stack_adjust ();\n   emit_jump_insn (gen_jump (label));\n@@ -545,8 +536,7 @@ emit_jump (label)\n    specified by the pointer expression EXP.  */\n \n void\n-expand_computed_goto (exp)\n-     tree exp;\n+expand_computed_goto (tree exp)\n {\n   rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n@@ -562,7 +552,7 @@ expand_computed_goto (exp)\n       cfun->computed_goto_common_reg = copy_to_mode_reg (Pmode, x);\n       cfun->computed_goto_common_label = gen_label_rtx ();\n       emit_label (cfun->computed_goto_common_label);\n-  \n+\n       do_pending_stack_adjust ();\n       emit_indirect_jump (cfun->computed_goto_common_reg);\n \n@@ -589,8 +579,7 @@ expand_computed_goto (exp)\n    Languages vary in how they do that and what that even means.  */\n \n void\n-expand_label (label)\n-     tree label;\n+expand_label (tree label)\n {\n   struct label_chain *p;\n \n@@ -612,8 +601,7 @@ expand_label (label)\n    from nested functions.  */\n \n void\n-declare_nonlocal_label (label)\n-     tree label;\n+declare_nonlocal_label (tree label)\n {\n   rtx slot = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n \n@@ -634,8 +622,7 @@ declare_nonlocal_label (label)\n    defined with `expand_label'.  */\n \n void\n-expand_goto (label)\n-     tree label;\n+expand_goto (tree label)\n {\n   tree context;\n \n@@ -723,10 +710,7 @@ expand_goto (label)\n    insn emitted (for the purposes of cleaning up a return).  */\n \n static void\n-expand_goto_internal (body, label, last_insn)\n-     tree body;\n-     rtx label;\n-     rtx last_insn;\n+expand_goto_internal (tree body, rtx label, rtx last_insn)\n {\n   struct nesting *block;\n   rtx stack_level = 0;\n@@ -810,10 +794,7 @@ expand_goto_internal (body, label, last_insn)\n    Value is nonzero if a fixup is made.  */\n \n static int\n-expand_fixup (tree_label, rtl_label, last_insn)\n-     tree tree_label;\n-     rtx rtl_label;\n-     rtx last_insn;\n+expand_fixup (tree tree_label, rtx rtl_label, rtx last_insn)\n {\n   struct nesting *block, *end_block;\n \n@@ -949,8 +930,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n    function.  FIRST_INSN is the first insn in the function.  */\n \n void\n-expand_fixups (first_insn)\n-     rtx first_insn;\n+expand_fixups (rtx first_insn)\n {\n   fixup_gotos (NULL, NULL_RTX, NULL_TREE, first_insn, 0);\n }\n@@ -969,12 +949,8 @@ expand_fixups (first_insn)\n    STACK_LEVEL is nonzero unless DONT_JUMP_IN is negative.  */\n \n static void\n-fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n-     struct nesting *thisblock;\n-     rtx stack_level;\n-     tree cleanup_list;\n-     rtx first_insn;\n-     int dont_jump_in;\n+fixup_gotos (struct nesting *thisblock, rtx stack_level,\n+\t     tree cleanup_list, rtx first_insn, int dont_jump_in)\n {\n   struct goto_fixup *f, *prev;\n \n@@ -1125,9 +1101,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \f\n /* Return the number of times character C occurs in string S.  */\n static int\n-n_occurrences (c, s)\n-     int c;\n-     const char *s;\n+n_occurrences (int c, const char *s)\n {\n   int n = 0;\n   while (*s)\n@@ -1141,9 +1115,7 @@ n_occurrences (c, s)\n    insn is volatile; don't optimize it.  */\n \n void\n-expand_asm (string, vol)\n-     tree string;\n-     int vol;\n+expand_asm (tree string, int vol)\n {\n   rtx body;\n \n@@ -1155,7 +1127,7 @@ expand_asm (string, vol)\n   MEM_VOLATILE_P (body) = vol;\n \n   emit_insn (body);\n-  \n+\n   clear_last_expr ();\n }\n \n@@ -1173,15 +1145,9 @@ expand_asm (string, vol)\n    Returns TRUE if all went well; FALSE if an error occurred.  */\n \n bool\n-parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n-\t\t\t allows_mem, allows_reg, is_inout)\n-     const char **constraint_p;\n-     int operand_num;\n-     int ninputs;\n-     int noutputs;\n-     bool *allows_mem;\n-     bool *allows_reg;\n-     bool *is_inout;\n+parse_output_constraint (const char **constraint_p, int operand_num,\n+\t\t\t int ninputs, int noutputs, bool *allows_mem,\n+\t\t\t bool *allows_reg, bool *is_inout)\n {\n   const char *constraint = *constraint_p;\n   const char *p;\n@@ -1312,16 +1278,10 @@ parse_output_constraint (constraint_p, operand_num, ninputs, noutputs,\n /* Similar, but for input constraints.  */\n \n static bool\n-parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n-\t\t\tconstraints, allows_mem, allows_reg)\n-     const char **constraint_p;\n-     int input_num;\n-     int ninputs;\n-     int noutputs;\n-     int ninout;\n-     const char * const * constraints;\n-     bool *allows_mem;\n-     bool *allows_reg;\n+parse_input_constraint (const char **constraint_p, int input_num,\n+\t\t\tint ninputs, int noutputs, int ninout,\n+\t\t\tconst char * const * constraints,\n+\t\t\tbool *allows_mem, bool *allows_reg)\n {\n   const char *constraint = *constraint_p;\n   const char *orig_constraint = constraint;\n@@ -1450,9 +1410,7 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n    FALSE for ok.  */\n \n static bool\n-decl_conflicts_with_clobbers_p (decl, clobbered_regs)\n-     tree decl;\n-     const HARD_REG_SET clobbered_regs;\n+decl_conflicts_with_clobbers_p (tree decl, const HARD_REG_SET clobbered_regs)\n {\n   /* Conflicts between asm-declared register variables and the clobber\n      list are not allowed.  */\n@@ -1500,11 +1458,8 @@ decl_conflicts_with_clobbers_p (decl, clobbered_regs)\n    VOL nonzero means the insn is volatile; don't optimize it.  */\n \n void\n-expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n-     tree string, outputs, inputs, clobbers;\n-     int vol;\n-     const char *filename;\n-     int line;\n+expand_asm_operands (tree string, tree outputs, tree inputs,\n+\t\t     tree clobbers, int vol, const char *filename, int line)\n {\n   rtvec argvec, constraintvec;\n   rtx body;\n@@ -1952,8 +1907,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n    the same number of alternatives.  Return true if so.  */\n \n static bool\n-check_operand_nalternatives (outputs, inputs)\n-     tree outputs, inputs;\n+check_operand_nalternatives (tree outputs, tree inputs)\n {\n   if (outputs || inputs)\n     {\n@@ -1996,8 +1950,7 @@ check_operand_nalternatives (outputs, inputs)\n    so all we need are pointer comparisons.  */\n \n static bool\n-check_unique_operand_names (outputs, inputs)\n-     tree outputs, inputs;\n+check_unique_operand_names (tree outputs, tree inputs)\n {\n   tree i, j;\n \n@@ -2096,9 +2049,7 @@ resolve_asm_operand_names (tree string, tree outputs, tree inputs)\n    balance of the string after substitution.  */\n \n static char *\n-resolve_operand_name_1 (p, outputs, inputs)\n-     char *p;\n-     tree outputs, inputs;\n+resolve_operand_name_1 (char *p, tree outputs, tree inputs)\n {\n   char *q;\n   int op;\n@@ -2163,8 +2114,7 @@ resolve_operand_name_1 (p, outputs, inputs)\n    should be used for new code.  */\n \n void\n-expand_expr_stmt (exp)\n-     tree exp;\n+expand_expr_stmt (tree exp)\n {\n   expand_expr_stmt_value (exp, -1, 1);\n }\n@@ -2175,9 +2125,7 @@ expand_expr_stmt (exp)\n    deprecated, and retained only for backward compatibility.  */\n \n void\n-expand_expr_stmt_value (exp, want_value, maybe_last)\n-     tree exp;\n-     int want_value, maybe_last;\n+expand_expr_stmt_value (tree exp, int want_value, int maybe_last)\n {\n   rtx value;\n   tree type;\n@@ -2258,8 +2206,7 @@ expand_expr_stmt_value (exp, want_value, maybe_last)\n    Return 1 if a warning is printed; 0 otherwise.  */\n \n int\n-warn_if_unused_value (exp)\n-     tree exp;\n+warn_if_unused_value (tree exp)\n {\n   if (TREE_USED (exp))\n     return 0;\n@@ -2365,7 +2312,7 @@ warn_if_unused_value (exp)\n /* Clear out the memory of the last expression evaluated.  */\n \n void\n-clear_last_expr ()\n+clear_last_expr (void)\n {\n   last_expr_type = NULL_TREE;\n   last_expr_value = NULL_RTX;\n@@ -2379,8 +2326,7 @@ clear_last_expr ()\n    expression.  */\n \n tree\n-expand_start_stmt_expr (has_scope)\n-     int has_scope;\n+expand_start_stmt_expr (int has_scope)\n {\n   tree t;\n \n@@ -2410,8 +2356,7 @@ expand_start_stmt_expr (has_scope)\n    return something with type `void'.  */\n \n tree\n-expand_end_stmt_expr (t)\n-     tree t;\n+expand_end_stmt_expr (tree t)\n {\n   OK_DEFER_POP;\n \n@@ -2452,9 +2397,7 @@ expand_end_stmt_expr (t)\n    `exit_something'.  */\n \n void\n-expand_start_cond (cond, exitflag)\n-     tree cond;\n-     int exitflag;\n+expand_start_cond (tree cond, int exitflag)\n {\n   struct nesting *thiscond = ALLOC_NESTING ();\n \n@@ -2480,8 +2423,7 @@ expand_start_cond (cond, exitflag)\n    of an if-then-elseif-....  */\n \n void\n-expand_start_elseif (cond)\n-     tree cond;\n+expand_start_elseif (tree cond)\n {\n   if (cond_stack->data.cond.endif_label == 0)\n     cond_stack->data.cond.endif_label = gen_label_rtx ();\n@@ -2495,7 +2437,7 @@ expand_start_elseif (cond)\n    of an if-then-else.  */\n \n void\n-expand_start_else ()\n+expand_start_else (void)\n {\n   if (cond_stack->data.cond.endif_label == 0)\n     cond_stack->data.cond.endif_label = gen_label_rtx ();\n@@ -2509,8 +2451,7 @@ expand_start_else ()\n    by providing another condition.  */\n \n void\n-expand_elseif (cond)\n-     tree cond;\n+expand_elseif (tree cond)\n {\n   cond_stack->data.cond.next_label = gen_label_rtx ();\n   do_jump (cond, cond_stack->data.cond.next_label, NULL_RTX);\n@@ -2520,7 +2461,7 @@ expand_elseif (cond)\n    Pop the record for it off of cond_stack.  */\n \n void\n-expand_end_cond ()\n+expand_end_cond (void)\n {\n   struct nesting *thiscond = cond_stack;\n \n@@ -2542,8 +2483,7 @@ expand_end_cond ()\n    this loop.  */\n \n struct nesting *\n-expand_start_loop (exit_flag)\n-     int exit_flag;\n+expand_start_loop (int exit_flag)\n {\n   struct nesting *thisloop = ALLOC_NESTING ();\n \n@@ -2572,8 +2512,7 @@ expand_start_loop (exit_flag)\n    (for expand_continue_loop) will be specified explicitly.  */\n \n struct nesting *\n-expand_start_loop_continue_elsewhere (exit_flag)\n-     int exit_flag;\n+expand_start_loop_continue_elsewhere (int exit_flag)\n {\n   struct nesting *thisloop = expand_start_loop (exit_flag);\n   loop_stack->data.loop.continue_label = gen_label_rtx ();\n@@ -2584,7 +2523,7 @@ expand_start_loop_continue_elsewhere (exit_flag)\n    of said loop can still contain a break, we must frob the loop nest.  */\n \n struct nesting *\n-expand_start_null_loop ()\n+expand_start_null_loop (void)\n {\n   struct nesting *thisloop = ALLOC_NESTING ();\n \n@@ -2610,7 +2549,7 @@ expand_start_null_loop ()\n    should jump.  */\n \n void\n-expand_loop_continue_here ()\n+expand_loop_continue_here (void)\n {\n   do_pending_stack_adjust ();\n   emit_note (NOTE_INSN_LOOP_CONT);\n@@ -2621,7 +2560,7 @@ expand_loop_continue_here ()\n    Pop the block off of loop_stack.  */\n \n void\n-expand_end_loop ()\n+expand_end_loop (void)\n {\n   rtx start_label = loop_stack->data.loop.start_label;\n   rtx etc_note;\n@@ -2776,7 +2715,7 @@ expand_end_loop ()\n /* Finish a null loop, aka do { } while (0).  */\n \n void\n-expand_end_null_loop ()\n+expand_end_null_loop (void)\n {\n   do_pending_stack_adjust ();\n   emit_label (loop_stack->data.loop.end_label);\n@@ -2792,8 +2731,7 @@ expand_end_null_loop ()\n    return 0 and do nothing; caller will print an error message.  */\n \n int\n-expand_continue_loop (whichloop)\n-     struct nesting *whichloop;\n+expand_continue_loop (struct nesting *whichloop)\n {\n   /* Emit information for branch prediction.  */\n   rtx note;\n@@ -2817,8 +2755,7 @@ expand_continue_loop (whichloop)\n    return 0 and do nothing; caller will print an error message.  */\n \n int\n-expand_exit_loop (whichloop)\n-     struct nesting *whichloop;\n+expand_exit_loop (struct nesting *whichloop)\n {\n   clear_last_expr ();\n   if (whichloop == 0)\n@@ -2834,9 +2771,7 @@ expand_exit_loop (whichloop)\n    return 0 and do nothing; caller will print an error message.  */\n \n int\n-expand_exit_loop_if_false (whichloop, cond)\n-     struct nesting *whichloop;\n-     tree cond;\n+expand_exit_loop_if_false (struct nesting *whichloop, tree cond)\n {\n   rtx label;\n   clear_last_expr ();\n@@ -2876,9 +2811,7 @@ expand_exit_loop_if_false (whichloop, cond)\n    after expand_loop_start.  */\n \n int\n-expand_exit_loop_top_cond (whichloop, cond)\n-     struct nesting *whichloop;\n-     tree cond;\n+expand_exit_loop_top_cond (struct nesting *whichloop, tree cond)\n {\n   if (! expand_exit_loop_if_false (whichloop, cond))\n     return 0;\n@@ -2895,7 +2828,7 @@ expand_exit_loop_top_cond (whichloop, cond)\n    the loop may still be a small one.  */\n \n int\n-preserve_subexpressions_p ()\n+preserve_subexpressions_p (void)\n {\n   rtx insn;\n \n@@ -2923,7 +2856,7 @@ preserve_subexpressions_p ()\n    return 0 and do nothing; caller will print an error message.  */\n \n int\n-expand_exit_something ()\n+expand_exit_something (void)\n {\n   struct nesting *n;\n   clear_last_expr ();\n@@ -2941,7 +2874,7 @@ expand_exit_something ()\n    (That is, we do not do anything about returning any value.)  */\n \n void\n-expand_null_return ()\n+expand_null_return (void)\n {\n   rtx last_insn;\n \n@@ -2957,8 +2890,7 @@ expand_null_return ()\n \n /* Try to guess whether the value of return means error code.  */\n static enum br_predictor\n-return_prediction (val)\n-     rtx val;\n+return_prediction (rtx val)\n {\n   /* Different heuristics for pointers and scalars.  */\n   if (POINTER_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n@@ -2987,8 +2919,7 @@ return_prediction (val)\n /* Generate RTL to return from the current function, with value VAL.  */\n \n static void\n-expand_value_return (val)\n-     rtx val;\n+expand_value_return (rtx val)\n {\n   rtx last_insn;\n   rtx return_reg;\n@@ -3038,8 +2969,7 @@ expand_value_return (val)\n    pretend that the return takes place after LAST_INSN.  */\n \n static void\n-expand_null_return_1 (last_insn)\n-     rtx last_insn;\n+expand_null_return_1 (rtx last_insn)\n {\n   rtx end_label = cleanup_label ? cleanup_label : return_label;\n \n@@ -3056,8 +2986,7 @@ expand_null_return_1 (last_insn)\n    from the current function.  */\n \n void\n-expand_return (retval)\n-     tree retval;\n+expand_return (tree retval)\n {\n   /* If there are any cleanups to be performed, then they will\n      be inserted following LAST_INSN.  It is desirable\n@@ -3278,9 +3207,7 @@ expand_return (retval)\n    Return TRUE if the call was optimized into a goto.  */\n \n int\n-optimize_tail_recursion (arguments, last_insn)\n-     tree arguments;\n-     rtx last_insn;\n+optimize_tail_recursion (tree arguments, rtx last_insn)\n {\n   /* Finish checking validity, and if valid emit code to set the\n      argument variables for the new call.  */\n@@ -3307,8 +3234,7 @@ optimize_tail_recursion (arguments, last_insn)\n    otherwise return 0 and do not emit any code.  */\n \n static int\n-tail_recursion_args (actuals, formals)\n-     tree actuals, formals;\n+tail_recursion_args (tree actuals, tree formals)\n {\n   tree a = actuals, f = formals;\n   int i;\n@@ -3403,9 +3329,7 @@ tail_recursion_args (actuals, formals)\n     note.  */\n \n void\n-expand_start_bindings_and_block (flags, block)\n-     int flags;\n-     tree block;\n+expand_start_bindings_and_block (int flags, tree block)\n {\n   struct nesting *thisblock = ALLOC_NESTING ();\n   rtx note;\n@@ -3474,7 +3398,7 @@ expand_start_bindings_and_block (flags, block)\n    destroyed and their space freed for reuse.  */\n \n void\n-expand_start_target_temps ()\n+expand_start_target_temps (void)\n {\n   /* This is so that even if the result is preserved, the space\n      allocated will be freed, as we know that it is no longer in use.  */\n@@ -3488,7 +3412,7 @@ expand_start_target_temps ()\n }\n \n void\n-expand_end_target_temps ()\n+expand_end_target_temps (void)\n {\n   expand_end_bindings (NULL_TREE, 0, 0);\n \n@@ -3508,8 +3432,7 @@ expand_end_target_temps ()\n    *that* node in turn will point to the relevant FUNCTION_DECL node.  */\n \n int\n-is_body_block (stmt)\n-     tree stmt;\n+is_body_block (tree stmt)\n {\n   if (lang_hooks.no_body_blocks)\n     return 0;\n@@ -3535,7 +3458,7 @@ is_body_block (stmt)\n    the cleanup handling code to generate conditional cleanup actions.  */\n \n int\n-conditional_context ()\n+conditional_context (void)\n {\n   return block_stack && block_stack->data.block.conditional_code;\n }\n@@ -3544,7 +3467,7 @@ conditional_context ()\n    can check its own sanity.  */\n \n struct nesting *\n-current_nesting_level ()\n+current_nesting_level (void)\n {\n   return cfun ? block_stack : 0;\n }\n@@ -3553,8 +3476,7 @@ current_nesting_level ()\n    Also emit code to store the handler label in SLOT before BEFORE_INSN.  */\n \n static rtx\n-expand_nl_handler_label (slot, before_insn)\n-     rtx slot, before_insn;\n+expand_nl_handler_label (rtx slot, rtx before_insn)\n {\n   rtx insns;\n   rtx handler_label = gen_label_rtx ();\n@@ -3576,7 +3498,7 @@ expand_nl_handler_label (slot, before_insn)\n /* Emit code to restore vital registers at the beginning of a nonlocal goto\n    handler.  */\n static void\n-expand_nl_goto_receiver ()\n+expand_nl_goto_receiver (void)\n {\n #ifdef HAVE_nonlocal_goto\n   if (! HAVE_nonlocal_goto)\n@@ -3632,8 +3554,7 @@ expand_nl_goto_receiver ()\n    block THISBLOCK.  */\n \n static void\n-expand_nl_goto_receivers (thisblock)\n-     struct nesting *thisblock;\n+expand_nl_goto_receivers (struct nesting *thisblock)\n {\n   tree link;\n   rtx afterward = gen_label_rtx ();\n@@ -3710,8 +3631,7 @@ expand_nl_goto_receivers (thisblock)\n    via the TREE_CHAIN field.  */\n \n void\n-warn_about_unused_variables (vars)\n-     tree vars;\n+warn_about_unused_variables (tree vars)\n {\n   tree decl;\n \n@@ -3739,10 +3659,7 @@ warn_about_unused_variables (vars)\n    labels (because the front end does that).  */\n \n void\n-expand_end_bindings (vars, mark_ends, dont_jump_in)\n-     tree vars;\n-     int mark_ends;\n-     int dont_jump_in;\n+expand_end_bindings (tree vars, int mark_ends, int dont_jump_in)\n {\n   struct nesting *thisblock = block_stack;\n \n@@ -3870,7 +3787,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n    and set up to restore it on exit.  */\n \n void\n-save_stack_pointer ()\n+save_stack_pointer (void)\n {\n   struct nesting *thisblock = block_stack;\n \n@@ -3887,8 +3804,7 @@ save_stack_pointer ()\n    (Other kinds of declarations are simply ignored if seen here.)  */\n \n void\n-expand_decl (decl)\n-     tree decl;\n+expand_decl (tree decl)\n {\n   tree type;\n \n@@ -4049,8 +3965,7 @@ expand_decl (decl)\n /* Emit code to perform the initialization of a declaration DECL.  */\n \n void\n-expand_decl_init (decl)\n-     tree decl;\n+expand_decl_init (tree decl)\n {\n   int was_used = TREE_USED (decl);\n \n@@ -4102,8 +4017,7 @@ expand_decl_init (decl)\n    that is not associated with any particular variable.  */\n \n int\n-expand_decl_cleanup (decl, cleanup)\n-     tree decl, cleanup;\n+expand_decl_cleanup (tree decl, tree cleanup)\n {\n   struct nesting *thisblock;\n \n@@ -4199,9 +4113,7 @@ expand_decl_cleanup (decl, cleanup)\n    is thrown.  */\n \n int\n-expand_decl_cleanup_eh (decl, cleanup, eh_only)\n-     tree decl, cleanup;\n-     int eh_only;\n+expand_decl_cleanup_eh (tree decl, tree cleanup, int eh_only)\n {\n   int ret = expand_decl_cleanup (decl, cleanup);\n   if (cleanup && ret)\n@@ -4217,8 +4129,7 @@ expand_decl_cleanup_eh (decl, cleanup, eh_only)\n    In each, the TREE_VALUE is a VAR_DECL, and the TREE_PURPOSE a cleanup.  */\n \n void\n-expand_anon_union_decl (decl, cleanup, decl_elts)\n-     tree decl, cleanup, decl_elts;\n+expand_anon_union_decl (tree decl, tree cleanup, tree decl_elts)\n {\n   struct nesting *thisblock = cfun == 0 ? 0 : block_stack;\n   rtx x;\n@@ -4297,10 +4208,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n    code about this finalization.  */\n \n static void\n-expand_cleanups (list, in_fixup, reachable)\n-     tree list;\n-     int in_fixup;\n-     int reachable;\n+expand_cleanups (tree list, int in_fixup, int reachable)\n {\n   tree tail;\n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n@@ -4346,7 +4254,7 @@ expand_cleanups (list, in_fixup, reachable)\n    expression (tree) is expanded that is within a conditional context.  */\n \n void\n-start_cleanup_deferral ()\n+start_cleanup_deferral (void)\n {\n   /* block_stack can be NULL if we are inside the parameter list.  It is\n      OK to do nothing, because cleanups aren't possible here.  */\n@@ -4360,7 +4268,7 @@ start_cleanup_deferral ()\n    deferred cleanups, are we back in unconditional code.  */\n \n void\n-end_cleanup_deferral ()\n+end_cleanup_deferral (void)\n {\n   /* block_stack can be NULL if we are inside the parameter list.  It is\n      OK to do nothing, because cleanups aren't possible here.  */\n@@ -4369,7 +4277,7 @@ end_cleanup_deferral ()\n }\n \n tree\n-last_cleanup_this_contour ()\n+last_cleanup_this_contour (void)\n {\n   if (block_stack == 0)\n     return 0;\n@@ -4382,7 +4290,7 @@ last_cleanup_this_contour ()\n    the current contour.  */\n \n int\n-any_pending_cleanups ()\n+any_pending_cleanups (void)\n {\n   struct nesting *block;\n \n@@ -4415,11 +4323,8 @@ any_pending_cleanups ()\n    but instead we take short cuts.  */\n \n void\n-expand_start_case (exit_flag, expr, type, printname)\n-     int exit_flag;\n-     tree expr;\n-     tree type;\n-     const char *printname;\n+expand_start_case (int exit_flag, tree expr, tree type,\n+\t\t   const char *printname)\n {\n   struct nesting *thiscase = ALLOC_NESTING ();\n \n@@ -4458,7 +4363,7 @@ expand_start_case (exit_flag, expr, type, printname)\n    into the middle of certain kinds of constructs.  */\n \n void\n-expand_start_case_dummy ()\n+expand_start_case_dummy (void)\n {\n   struct nesting *thiscase = ALLOC_NESTING ();\n \n@@ -4479,7 +4384,7 @@ expand_start_case_dummy ()\n }\n \f\n static void\n-check_seenlabel ()\n+check_seenlabel (void)\n {\n   /* If this is the first label, warn if any insns have been emitted.  */\n   if (case_stack->data.case_stmt.line_number_status >= 0)\n@@ -4534,11 +4439,8 @@ check_seenlabel ()\n    Extended to handle range statements.  */\n \n int\n-pushcase (value, converter, label, duplicate)\n-     tree value;\n-     tree (*converter) PARAMS ((tree, tree));\n-     tree label;\n-     tree *duplicate;\n+pushcase (tree value, tree (*converter) (tree, tree), tree label,\n+\t  tree *duplicate)\n {\n   tree index_type;\n   tree nominal_type;\n@@ -4584,11 +4486,8 @@ pushcase (value, converter, label, duplicate)\n    additional error code: 4 means the specified range was empty.  */\n \n int\n-pushcase_range (value1, value2, converter, label, duplicate)\n-     tree value1, value2;\n-     tree (*converter) PARAMS ((tree, tree));\n-     tree label;\n-     tree *duplicate;\n+pushcase_range (tree value1, tree value2, tree (*converter) (tree, tree),\n+\t\ttree label, tree *duplicate)\n {\n   tree index_type;\n   tree nominal_type;\n@@ -4648,10 +4547,7 @@ pushcase_range (value1, value2, converter, label, duplicate)\n    slowdown for large switch statements.  */\n \n int\n-add_case_node (low, high, label, duplicate)\n-     tree low, high;\n-     tree label;\n-     tree *duplicate;\n+add_case_node (tree low, tree high, tree label, tree *duplicate)\n {\n   struct case_node *p, **q, *r;\n \n@@ -4895,9 +4791,7 @@ add_case_node (low, high, label, duplicate)\n    otherwise sets it to 0.  */\n \n HOST_WIDE_INT\n-all_cases_count (type, sparseness)\n-     tree type;\n-     int *sparseness;\n+all_cases_count (tree type, int *sparseness)\n {\n   tree t;\n   HOST_WIDE_INT count, minval, lastval;\n@@ -4970,11 +4864,8 @@ all_cases_count (type, sparseness)\n    SPARSENESS is 2, in which case quadratic time is needed.  */\n \n void\n-mark_seen_cases (type, cases_seen, count, sparseness)\n-     tree type;\n-     unsigned char *cases_seen;\n-     HOST_WIDE_INT count;\n-     int sparseness;\n+mark_seen_cases (tree type, unsigned char *cases_seen, HOST_WIDE_INT count,\n+\t\t int sparseness)\n {\n   tree next_node_to_try = NULL_TREE;\n   HOST_WIDE_INT next_node_offset = 0;\n@@ -5112,8 +5003,7 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n    is the same as one of the enumeration literals.''  */\n \n void\n-check_for_full_enumeration_handling (type)\n-     tree type;\n+check_for_full_enumeration_handling (tree type)\n {\n   struct case_node *n;\n   tree chain;\n@@ -5286,11 +5176,8 @@ static int case_bit_test_cmp (p1, p2)\n     node targets.  */\n \n static void\n-emit_case_bit_tests (index_type, index_expr, minval, range,\n-\t\t     nodes, default_label)\n-     tree index_type, index_expr, minval, range;\n-     case_node_ptr nodes;\n-     rtx default_label;\n+emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n+\t\t     tree range, case_node_ptr nodes, rtx default_label)\n {\n   struct case_bit_test test[MAX_CASE_BIT_TESTS];\n   enum machine_mode mode;\n@@ -5369,8 +5256,7 @@ emit_case_bit_tests (index_type, index_expr, minval, range,\n    Generate the code to test it and jump to the right place.  */\n \n void\n-expand_end_case_type (orig_index, orig_type)\n-     tree orig_index, orig_type;\n+expand_end_case_type (tree orig_index, tree orig_type)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n   rtx default_label = 0;\n@@ -5728,8 +5614,7 @@ expand_end_case_type (orig_index, orig_type)\n    rightmost in the resulting list.  */\n \n static struct case_node *\n-case_tree2list (node, right)\n-     struct case_node *node, *right;\n+case_tree2list (struct case_node *node, struct case_node *right)\n {\n   struct case_node *left;\n \n@@ -5749,9 +5634,7 @@ case_tree2list (node, right)\n /* Generate code to jump to LABEL if OP1 and OP2 are equal.  */\n \n static void\n-do_jump_if_equal (op1, op2, label, unsignedp)\n-     rtx op1, op2, label;\n-     int unsignedp;\n+do_jump_if_equal (rtx op1, rtx op2, rtx label, int unsignedp)\n {\n   if (GET_CODE (op1) == CONST_INT && GET_CODE (op2) == CONST_INT)\n     {\n@@ -5789,8 +5672,7 @@ do_jump_if_equal (op1, op2, label, unsignedp)\n    return 0.  */\n \n static int\n-estimate_case_costs (node)\n-     case_node_ptr node;\n+estimate_case_costs (case_node_ptr node)\n {\n   tree min_ascii = integer_minus_one_node;\n   tree max_ascii = convert (TREE_TYPE (node->high), build_int_2 (127, 0));\n@@ -5848,8 +5730,7 @@ estimate_case_costs (node)\n /* Determine whether two case labels branch to the same target.  */\n \n static bool\n-same_case_target_p (l1, l2)\n-     rtx l1, l2;\n+same_case_target_p (rtx l1, rtx l2)\n {\n   rtx i1, i2;\n \n@@ -5877,9 +5758,7 @@ same_case_target_p (l1, l2)\n    case nodes.  Eg. case 5: default: becomes just default:  */\n \n static void\n-strip_default_case_nodes (prev, deflab)\n-     case_node_ptr *prev;\n-     rtx deflab;\n+strip_default_case_nodes (case_node_ptr *prev, rtx deflab)\n {\n   case_node_ptr ptr;\n \n@@ -5899,8 +5778,7 @@ strip_default_case_nodes (prev, deflab)\n    Eg. three separate entries 1: 2: 3: become one entry 1..3:  */\n \n static void\n-group_case_nodes (head)\n-     case_node_ptr head;\n+group_case_nodes (case_node_ptr head)\n {\n   case_node_ptr node = head;\n \n@@ -5946,9 +5824,7 @@ group_case_nodes (head)\n    branch is then transformed recursively.  */\n \n static void\n-balance_case_nodes (head, parent)\n-     case_node_ptr *head;\n-     case_node_ptr parent;\n+balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n {\n   case_node_ptr np;\n \n@@ -6065,9 +5941,7 @@ balance_case_nodes (head, parent)\n    span.  Thus the test would be redundant.  */\n \n static int\n-node_has_low_bound (node, index_type)\n-     case_node_ptr node;\n-     tree index_type;\n+node_has_low_bound (case_node_ptr node, tree index_type)\n {\n   tree low_minus_one;\n   case_node_ptr pnode;\n@@ -6112,9 +5986,7 @@ node_has_low_bound (node, index_type)\n    span.  Thus the test would be redundant.  */\n \n static int\n-node_has_high_bound (node, index_type)\n-     case_node_ptr node;\n-     tree index_type;\n+node_has_high_bound (case_node_ptr node, tree index_type)\n {\n   tree high_plus_one;\n   case_node_ptr pnode;\n@@ -6158,9 +6030,7 @@ node_has_high_bound (node, index_type)\n    bounds of NODE would be redundant.  */\n \n static int\n-node_is_bounded (node, index_type)\n-     case_node_ptr node;\n-     tree index_type;\n+node_is_bounded (case_node_ptr node, tree index_type)\n {\n   return (node_has_low_bound (node, index_type)\n \t  && node_has_high_bound (node, index_type));\n@@ -6169,8 +6039,7 @@ node_is_bounded (node, index_type)\n /*  Emit an unconditional jump to LABEL unless it would be dead code.  */\n \n static void\n-emit_jump_if_reachable (label)\n-     rtx label;\n+emit_jump_if_reachable (rtx label)\n {\n   if (GET_CODE (get_last_insn ()) != BARRIER)\n     emit_jump (label);\n@@ -6203,11 +6072,8 @@ emit_jump_if_reachable (label)\n    tests for the value 50, then this node need not test anything.  */\n \n static void\n-emit_case_nodes (index, node, default_label, index_type)\n-     rtx index;\n-     case_node_ptr node;\n-     rtx default_label;\n-     tree index_type;\n+emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n+\t\t tree index_type)\n {\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n   int unsignedp = TREE_UNSIGNED (index_type);"}, {"sha": "403f8ab4ea58f65beb38e0b4b92201bba7e46d3b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 61, "deletions": 119, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -59,18 +59,16 @@ unsigned int set_alignment = 0;\n    called only by a front end.  */\n static int reference_types_internal = 0;\n \n-static void finalize_record_size\tPARAMS ((record_layout_info));\n-static void finalize_type_size\t\tPARAMS ((tree));\n-static void place_union_field\t\tPARAMS ((record_layout_info, tree));\n+static void finalize_record_size (record_layout_info);\n+static void finalize_type_size (tree);\n+static void place_union_field (record_layout_info, tree);\n #if defined (PCC_BITFIELD_TYPE_MATTERS) || defined (BITFIELD_NBYTES_LIMITED)\n-static int excess_unit_span\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t\ttree));\n+static int excess_unit_span (HOST_WIDE_INT, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t     HOST_WIDE_INT, tree);\n #endif\n-static unsigned int update_alignment_for_field\n-                                        PARAMS ((record_layout_info, tree, \n-\t\t\t\t\t\t unsigned int));\n-extern void debug_rli\t\t\tPARAMS ((record_layout_info));\n+static unsigned int update_alignment_for_field (record_layout_info, tree,\n+\t\t\t\t\t\tunsigned int);\n+extern void debug_rli (record_layout_info);\n \f\n /* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */\n \n@@ -85,15 +83,15 @@ int immediate_size_expand;\n    by front end.  */\n \n void\n-internal_reference_types ()\n+internal_reference_types (void)\n {\n   reference_types_internal = 1;\n }\n \n /* Get a list of all the objects put on the pending sizes list.  */\n \n tree\n-get_pending_sizes ()\n+get_pending_sizes (void)\n {\n   tree chain = pending_sizes;\n   tree t;\n@@ -109,8 +107,7 @@ get_pending_sizes ()\n /* Return nonzero if EXPR is present on the pending sizes list.  */\n \n int\n-is_pending_size (expr)\n-     tree expr;\n+is_pending_size (tree expr)\n {\n   tree t;\n \n@@ -123,8 +120,7 @@ is_pending_size (expr)\n /* Add EXPR to the pending sizes list.  */\n \n void\n-put_pending_size (expr)\n-     tree expr;\n+put_pending_size (tree expr)\n {\n   /* Strip any simple arithmetic from EXPR to see if it has an underlying\n      SAVE_EXPR.  */\n@@ -138,8 +134,7 @@ put_pending_size (expr)\n    empty.  */\n \n void\n-put_pending_sizes (chain)\n-     tree chain;\n+put_pending_sizes (tree chain)\n {\n   if (pending_sizes)\n     abort ();\n@@ -151,8 +146,7 @@ put_pending_sizes (chain)\n    to serve as the actual size-expression for a type or decl.  */\n \n tree\n-variable_size (size)\n-     tree size;\n+variable_size (tree size)\n {\n   tree save;\n \n@@ -215,10 +209,7 @@ variable_size (size)\n    be used.  */\n \n enum machine_mode\n-mode_for_size (size, class, limit)\n-     unsigned int size;\n-     enum mode_class class;\n-     int limit;\n+mode_for_size (unsigned int size, enum mode_class class, int limit)\n {\n   enum machine_mode mode;\n \n@@ -237,10 +228,7 @@ mode_for_size (size, class, limit)\n /* Similar, except passed a tree node.  */\n \n enum machine_mode\n-mode_for_size_tree (size, class, limit)\n-     tree size;\n-     enum mode_class class;\n-     int limit;\n+mode_for_size_tree (tree size, enum mode_class class, int limit)\n {\n   if (TREE_CODE (size) != INTEGER_CST\n       || TREE_OVERFLOW (size)\n@@ -257,9 +245,7 @@ mode_for_size_tree (size, class, limit)\n    contains at least the requested number of bits.  */\n \n enum machine_mode\n-smallest_mode_for_size (size, class)\n-     unsigned int size;\n-     enum mode_class class;\n+smallest_mode_for_size (unsigned int size, enum mode_class class)\n {\n   enum machine_mode mode;\n \n@@ -276,8 +262,7 @@ smallest_mode_for_size (size, class)\n /* Find an integer mode of the exact same size, or BLKmode on failure.  */\n \n enum machine_mode\n-int_mode_for_mode (mode)\n-     enum machine_mode mode;\n+int_mode_for_mode (enum machine_mode mode)\n {\n   switch (GET_MODE_CLASS (mode))\n     {\n@@ -311,8 +296,7 @@ int_mode_for_mode (mode)\n    BIGGEST_ALIGNMENT.  */\n \n unsigned int\n-get_mode_alignment (mode)\n-     enum machine_mode mode;\n+get_mode_alignment (enum machine_mode mode)\n {\n   unsigned int alignment;\n \n@@ -334,9 +318,7 @@ get_mode_alignment (mode)\n    This can only be applied to objects of a sizetype.  */\n \n tree\n-round_up (value, divisor)\n-     tree value;\n-     int divisor;\n+round_up (tree value, int divisor)\n {\n   tree arg = size_int_type (divisor, TREE_TYPE (value));\n \n@@ -346,9 +328,7 @@ round_up (value, divisor)\n /* Likewise, but round down.  */\n \n tree\n-round_down (value, divisor)\n-     tree value;\n-     int divisor;\n+round_down (tree value, int divisor)\n {\n   tree arg = size_int_type (divisor, TREE_TYPE (value));\n \n@@ -382,9 +362,7 @@ do_type_align (tree type, tree decl)\n    the record will be aligned to suit.  */\n \n void\n-layout_decl (decl, known_align)\n-     tree decl;\n-     unsigned int known_align;\n+layout_decl (tree decl, unsigned int known_align)\n {\n   tree type = TREE_TYPE (decl);\n   enum tree_code code = TREE_CODE (decl);\n@@ -557,11 +535,10 @@ layout_decl (decl, known_align)\n /* Hook for a front-end function that can modify the record layout as needed\n    immediately before it is finalized.  */\n \n-void (*lang_adjust_rli) PARAMS ((record_layout_info)) = 0;\n+void (*lang_adjust_rli) (record_layout_info) = 0;\n \n void\n-set_lang_adjust_rli (f)\n-     void (*f) PARAMS ((record_layout_info));\n+set_lang_adjust_rli (void (*f) (record_layout_info))\n {\n   lang_adjust_rli = f;\n }\n@@ -574,8 +551,7 @@ set_lang_adjust_rli (f)\n    out the record.  */\n \n record_layout_info\n-start_record_layout (t)\n-     tree t;\n+start_record_layout (tree t)\n {\n   record_layout_info rli\n     = (record_layout_info) xmalloc (sizeof (struct record_layout_info_s));\n@@ -608,17 +584,15 @@ start_record_layout (t)\n    the offset/bitpos forms and byte and bit offsets.  */\n \n tree\n-bit_from_pos (offset, bitpos)\n-     tree offset, bitpos;\n+bit_from_pos (tree offset, tree bitpos)\n {\n   return size_binop (PLUS_EXPR, bitpos,\n \t\t     size_binop (MULT_EXPR, convert (bitsizetype, offset),\n \t\t\t\t bitsize_unit_node));\n }\n \n tree\n-byte_from_pos (offset, bitpos)\n-     tree offset, bitpos;\n+byte_from_pos (tree offset, tree bitpos)\n {\n   return size_binop (PLUS_EXPR, offset,\n \t\t     convert (sizetype,\n@@ -627,10 +601,8 @@ byte_from_pos (offset, bitpos)\n }\n \n void\n-pos_from_bit (poffset, pbitpos, off_align, pos)\n-     tree *poffset, *pbitpos;\n-     unsigned int off_align;\n-     tree pos;\n+pos_from_bit (tree *poffset, tree *pbitpos, unsigned int off_align,\n+\t      tree pos)\n {\n   *poffset = size_binop (MULT_EXPR,\n \t\t\t convert (sizetype,\n@@ -644,9 +616,7 @@ pos_from_bit (poffset, pbitpos, off_align, pos)\n    normalize the offsets so they are within the alignment.  */\n \n void\n-normalize_offset (poffset, pbitpos, off_align)\n-     tree *poffset, *pbitpos;\n-     unsigned int off_align;\n+normalize_offset (tree *poffset, tree *pbitpos, unsigned int off_align)\n {\n   /* If the bit position is now larger than it should be, adjust it\n      downwards.  */\n@@ -668,8 +638,7 @@ normalize_offset (poffset, pbitpos, off_align)\n /* Print debugging information about the information in RLI.  */\n \n void\n-debug_rli (rli)\n-     record_layout_info rli;\n+debug_rli (record_layout_info rli)\n {\n   print_node_brief (stderr, \"type\", rli->t, 0);\n   print_node_brief (stderr, \"\\noffset\", rli->offset, 0);\n@@ -692,26 +661,23 @@ debug_rli (rli)\n    BITPOS if necessary to keep BITPOS below OFFSET_ALIGN.  */\n \n void\n-normalize_rli (rli)\n-     record_layout_info rli;\n+normalize_rli (record_layout_info rli)\n {\n   normalize_offset (&rli->offset, &rli->bitpos, rli->offset_align);\n }\n \n /* Returns the size in bytes allocated so far.  */\n \n tree\n-rli_size_unit_so_far (rli)\n-     record_layout_info rli;\n+rli_size_unit_so_far (record_layout_info rli)\n {\n   return byte_from_pos (rli->offset, rli->bitpos);\n }\n \n /* Returns the size in bits allocated so far.  */\n \n tree\n-rli_size_so_far (rli)\n-     record_layout_info rli;\n+rli_size_so_far (record_layout_info rli)\n {\n   return bit_from_pos (rli->offset, rli->bitpos);\n }\n@@ -722,10 +688,8 @@ rli_size_so_far (rli)\n    the FIELD.  */\n \n static unsigned int\n-update_alignment_for_field (rli, field, known_align)\n-     record_layout_info rli;\n-     tree field;\n-     unsigned int known_align;\n+update_alignment_for_field (record_layout_info rli, tree field,\n+\t\t\t    unsigned int known_align)\n {\n   /* The alignment required for FIELD.  */\n   unsigned int desired_align;\n@@ -756,10 +720,10 @@ update_alignment_for_field (rli, field, known_align)\n \t applies if there was an immediately prior, nonzero-size\n \t bitfield.  (That's the way it is, experimentally.) */\n       if (! integer_zerop (DECL_SIZE (field))\n- \t  ? ! DECL_PACKED (field)\n- \t  : (rli->prev_field\n- \t     && DECL_BIT_FIELD_TYPE (rli->prev_field)\n- \t     && ! integer_zerop (DECL_SIZE (rli->prev_field))))\n+\t  ? ! DECL_PACKED (field)\n+\t  : (rli->prev_field\n+\t     && DECL_BIT_FIELD_TYPE (rli->prev_field)\n+\t     && ! integer_zerop (DECL_SIZE (rli->prev_field))))\n \t{\n \t  unsigned int type_align = TYPE_ALIGN (type);\n \t  type_align = MAX (type_align, desired_align);\n@@ -816,9 +780,7 @@ update_alignment_for_field (rli, field, known_align)\n /* Called from place_field to handle unions.  */\n \n static void\n-place_union_field (rli, field)\n-     record_layout_info rli;\n-     tree field;\n+place_union_field (record_layout_info rli, tree field)\n {\n   update_alignment_for_field (rli, field, /*known_align=*/0);\n \n@@ -841,9 +803,8 @@ place_union_field (rli, field)\n    at BYTE_OFFSET / BIT_OFFSET.  Return nonzero if the field would span more\n    units of alignment than the underlying TYPE.  */\n static int\n-excess_unit_span (byte_offset, bit_offset, size, align, type)\n-     HOST_WIDE_INT byte_offset, bit_offset, size, align;\n-     tree type;\n+excess_unit_span (HOST_WIDE_INT byte_offset, HOST_WIDE_INT bit_offset,\n+\t\t  HOST_WIDE_INT size, HOST_WIDE_INT align, tree type)\n {\n   /* Note that the calculation of OFFSET might overflow; we calculate it so\n      that we still get the right result as long as ALIGN is a power of two.  */\n@@ -862,9 +823,7 @@ excess_unit_span (byte_offset, bit_offset, size, align, type)\n    callers that desire that behavior must manually perform that step.)  */\n \n void\n-place_field (rli, field)\n-     record_layout_info rli;\n-     tree field;\n+place_field (record_layout_info rli, tree field)\n {\n   /* The alignment required for FIELD.  */\n   unsigned int desired_align;\n@@ -915,7 +874,7 @@ place_field (rli, field)\n \t\t      & - tree_low_cst (rli->offset, 1)));\n   else\n     known_align = rli->offset_align;\n-  \n+\n   desired_align = update_alignment_for_field (rli, field, known_align);\n \n   if (warn_packed && DECL_PACKED (field))\n@@ -1056,7 +1015,7 @@ place_field (rli, field)\n \n   if ((* targetm.ms_bitfield_layout_p) (rli->t)\n        && ((DECL_BIT_FIELD_TYPE (field) && ! DECL_PACKED (field))\n- \t  || (rli->prev_field && ! DECL_PACKED (rli->prev_field))))\n+\t  || (rli->prev_field && ! DECL_PACKED (rli->prev_field))))\n     {\n       /* At this point, either the prior or current are bitfields,\n \t (possibly both), and we're dealing with MS packing.  */\n@@ -1251,8 +1210,7 @@ place_field (rli, field)\n    indicated by RLI.  */\n \n static void\n-finalize_record_size (rli)\n-     record_layout_info rli;\n+finalize_record_size (record_layout_info rli)\n {\n   tree unpadded_size, unpadded_size_unit;\n \n@@ -1333,8 +1291,7 @@ finalize_record_size (rli)\n /* Compute the TYPE_MODE for the TYPE (which is a RECORD_TYPE).  */\n \n void\n-compute_record_mode (type)\n-     tree type;\n+compute_record_mode (tree type)\n {\n   tree field;\n   enum machine_mode mode = VOIDmode;\n@@ -1419,8 +1376,7 @@ compute_record_mode (type)\n    out.  */\n \n static void\n-finalize_type_size (type)\n-     tree type;\n+finalize_type_size (tree type)\n {\n   /* Normally, use the alignment corresponding to the mode chosen.\n      However, where strict alignment is not required, avoid\n@@ -1501,9 +1457,7 @@ finalize_type_size (type)\n    G++ 3.2 ABI.  */\n \n void\n-finish_record_layout (rli, free_p)\n-     record_layout_info rli;\n-     int free_p;\n+finish_record_layout (record_layout_info rli, int free_p)\n {\n   /* Compute the final size.  */\n   finalize_record_size (rli);\n@@ -1535,11 +1489,8 @@ finish_record_layout (rli, free_p)\n    ALIGN_TYPE.  */\n \n void\n-finish_builtin_struct (type, name, fields, align_type)\n-     tree type;\n-     const char *name;\n-     tree fields;\n-     tree align_type;\n+finish_builtin_struct (tree type, const char *name, tree fields,\n+\t\t       tree align_type)\n {\n   tree tail, next;\n \n@@ -1578,8 +1529,7 @@ finish_builtin_struct (type, name, fields, align_type)\n    If the type is incomplete, its TYPE_SIZE remains zero.  */\n \n void\n-layout_type (type)\n-     tree type;\n+layout_type (tree type)\n {\n   if (type == 0)\n     abort ();\n@@ -1885,8 +1835,7 @@ layout_type (type)\n /* Create and return a type for signed integers of PRECISION bits.  */\n \n tree\n-make_signed_type (precision)\n-     int precision;\n+make_signed_type (int precision)\n {\n   tree type = make_node (INTEGER_TYPE);\n \n@@ -1899,8 +1848,7 @@ make_signed_type (precision)\n /* Create and return a type for unsigned integers of PRECISION bits.  */\n \n tree\n-make_unsigned_type (precision)\n-     int precision;\n+make_unsigned_type (int precision)\n {\n   tree type = make_node (INTEGER_TYPE);\n \n@@ -1914,7 +1862,7 @@ make_unsigned_type (precision)\n    value to enable integer types to be created.  */\n \n void\n-initialize_sizetypes ()\n+initialize_sizetypes (void)\n {\n   tree t = make_node (INTEGER_TYPE);\n \n@@ -1947,8 +1895,7 @@ initialize_sizetypes ()\n    Also update the type of any standard type's sizes made so far.  */\n \n void\n-set_sizetype (type)\n-     tree type;\n+set_sizetype (tree type)\n {\n   int oprecision = TYPE_PRECISION (type);\n   /* The *bitsizetype types use a precision that avoids overflows when\n@@ -2027,8 +1974,7 @@ set_sizetype (type)\n    E.g. for Pascal, when the -fsigned-char option is given.  */\n \n void\n-fixup_signed_type (type)\n-     tree type;\n+fixup_signed_type (tree type)\n {\n   int precision = TYPE_PRECISION (type);\n \n@@ -2065,8 +2011,7 @@ fixup_signed_type (type)\n    and for enumeral types.  */\n \n void\n-fixup_unsigned_type (type)\n-     tree type;\n+fixup_unsigned_type (tree type)\n {\n   int precision = TYPE_PRECISION (type);\n \n@@ -2108,11 +2053,8 @@ fixup_unsigned_type (type)\n    all the conditions.  */\n \n enum machine_mode\n-get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n-     int bitsize, bitpos;\n-     unsigned int align;\n-     enum machine_mode largest_mode;\n-     int volatilep;\n+get_best_mode (int bitsize, int bitpos, unsigned int align,\n+\t       enum machine_mode largest_mode, int volatilep)\n {\n   enum machine_mode mode;\n   unsigned int unit = 0;"}, {"sha": "01e54ac8270853d72c7f19a9b994d7e05ee43e74", "filename": "gcc/stringpool.c", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* String pool for GCC.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -49,13 +49,13 @@ const char digit_vector[] = {\n struct ht *ident_hash;\n static struct obstack string_stack;\n \n-static hashnode alloc_node PARAMS ((hash_table *));\n-static int mark_ident PARAMS ((struct cpp_reader *, hashnode, const void *));\n-static int ht_copy_and_clear PARAMS ((struct cpp_reader *, hashnode, const void *));\n+static hashnode alloc_node (hash_table *);\n+static int mark_ident (struct cpp_reader *, hashnode, const void *);\n+static int ht_copy_and_clear (struct cpp_reader *, hashnode, const void *);\n \n /* Initialize the string pool.  */\n void\n-init_stringpool ()\n+init_stringpool (void)\n {\n   /* Create with 16K (2^14) entries.  */\n   ident_hash = ht_create (14);\n@@ -65,8 +65,7 @@ init_stringpool ()\n \n /* Allocate a hash node.  */\n static hashnode\n-alloc_node (table)\n-     hash_table *table ATTRIBUTE_UNUSED;\n+alloc_node (hash_table *table ATTRIBUTE_UNUSED)\n {\n   return GCC_IDENT_TO_HT_IDENT (make_node (IDENTIFIER_NODE));\n }\n@@ -78,9 +77,7 @@ alloc_node (table)\n    returned this time too.  */\n \n const char *\n-ggc_alloc_string (contents, length)\n-     const char *contents;\n-     int length;\n+ggc_alloc_string (const char *contents, int length)\n {\n   if (length == -1)\n     length = strlen (contents);\n@@ -99,8 +96,7 @@ ggc_alloc_string (contents, length)\n    the same node is returned this time.  */\n \n tree\n-get_identifier (text)\n-     const char *text;\n+get_identifier (const char *text)\n {\n   hashnode ht_node = ht_lookup (ident_hash,\n \t\t\t\t(const unsigned char *) text,\n@@ -114,9 +110,7 @@ get_identifier (text)\n    known.  */\n \n tree\n-get_identifier_with_length (text, length)\n-     const char *text;\n-     unsigned int length;\n+get_identifier_with_length (const char *text, unsigned int length)\n {\n   hashnode ht_node = ht_lookup (ident_hash,\n \t\t\t\t(const unsigned char *) text,\n@@ -131,8 +125,7 @@ get_identifier_with_length (text, length)\n    NULL_TREE.  */\n \n tree\n-maybe_get_identifier (text)\n-     const char *text;\n+maybe_get_identifier (const char *text)\n {\n   hashnode ht_node;\n \n@@ -147,18 +140,16 @@ maybe_get_identifier (text)\n /* Report some basic statistics about the string pool.  */\n \n void\n-stringpool_statistics ()\n+stringpool_statistics (void)\n {\n   ht_dump_statistics (ident_hash);\n }\n \n /* Mark an identifier for GC.  */\n \n static int\n-mark_ident (pfile, h, v)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     hashnode h;\n-     const void *v ATTRIBUTE_UNUSED;\n+mark_ident (struct cpp_reader *pfile ATTRIBUTE_UNUSED, hashnode h,\n+\t    const void *v ATTRIBUTE_UNUSED)\n {\n   gt_ggc_m_9tree_node (HT_IDENT_TO_GCC_IDENT (h));\n   return 1;\n@@ -169,7 +160,7 @@ mark_ident (pfile, h, v)\n    treatment for strings.  */\n \n void\n-ggc_mark_stringpool ()\n+ggc_mark_stringpool (void)\n {\n   ht_forall (ident_hash, mark_ident, NULL);\n }\n@@ -179,28 +170,24 @@ ggc_mark_stringpool ()\n    to strings.  */\n \n void\n-gt_ggc_m_S (x)\n-     void *x ATTRIBUTE_UNUSED;\n+gt_ggc_m_S (void *x ATTRIBUTE_UNUSED)\n {\n }\n \n /* Pointer-walking routine for strings (not very interesting, since\n    strings don't contain pointers).  */\n \n void\n-gt_pch_p_S (obj, x, op, cookie)\n-     void *obj ATTRIBUTE_UNUSED;\n-     void *x ATTRIBUTE_UNUSED;\n-     gt_pointer_operator op ATTRIBUTE_UNUSED;\n-     void *cookie ATTRIBUTE_UNUSED;\n+gt_pch_p_S (void *obj ATTRIBUTE_UNUSED, void *x ATTRIBUTE_UNUSED,\n+\t    gt_pointer_operator op ATTRIBUTE_UNUSED,\n+\t    void *cookie ATTRIBUTE_UNUSED)\n {\n }\n \n /* PCH pointer-walking routine for strings.  */\n \n void\n-gt_pch_n_S (x)\n-     const void *x;\n+gt_pch_n_S (const void *x)\n {\n   gt_pch_note_object ((void *)x, (void *)x, &gt_pch_p_S);\n }\n@@ -216,11 +203,8 @@ struct string_pool_data GTY(())\n \n static GTY(()) struct string_pool_data * spd;\n \n-static int \n-ht_copy_and_clear (r, hp, ht2_p)\n-     cpp_reader *r ATTRIBUTE_UNUSED;\n-     hashnode hp;\n-     const void *ht2_p;\n+static int\n+ht_copy_and_clear (cpp_reader *r ATTRIBUTE_UNUSED, hashnode hp, const void *ht2_p)\n {\n   cpp_hashnode *h = CPP_HASHNODE (hp);\n   struct ht *ht2 = (struct ht *) ht2_p;\n@@ -244,10 +228,10 @@ ht_copy_and_clear (r, hp, ht2_p)\n static struct ht *saved_ident_hash;\n \n void\n-gt_pch_save_stringpool ()\n+gt_pch_save_stringpool (void)\n {\n   unsigned int i;\n-  \n+\n   spd = ggc_alloc (sizeof (*spd));\n   spd->nslots = ident_hash->nslots;\n   spd->nelements = ident_hash->nelements;\n@@ -264,18 +248,18 @@ gt_pch_save_stringpool ()\n }\n \n void\n-gt_pch_fixup_stringpool ()\n+gt_pch_fixup_stringpool (void)\n {\n   ht_forall (saved_ident_hash, ht_copy_and_clear, ident_hash);\n   ht_destroy (saved_ident_hash);\n   saved_ident_hash = 0;\n }\n \n void\n-gt_pch_restore_stringpool ()\n+gt_pch_restore_stringpool (void)\n {\n   unsigned int i;\n-  \n+\n   ident_hash->nslots = spd->nslots;\n   ident_hash->nelements = spd->nelements;\n   ident_hash->entries = xrealloc (ident_hash->entries,"}, {"sha": "8acfb7ab26f7ec2a27300fff545fe67977d29246", "filename": "gcc/target.h", "status": "modified", "additions": 73, "deletions": 75, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -67,89 +67,87 @@ struct gcc_target\n        ALIGNED_P indicates whether it is aligned.  Return true if\n        successful.  Only handles cases for which BYTE_OP, ALIGNED_OP\n        and UNALIGNED_OP are NULL.  */\n-    bool (* integer) PARAMS ((rtx x, unsigned int size, int aligned_p));\n+    bool (* integer) (rtx x, unsigned int size, int aligned_p);\n \n     /* Output code that will globalize a label.  */\n-    void (* globalize_label) PARAMS ((FILE *, const char *));\n+    void (* globalize_label) (FILE *, const char *);\n \n     /* Output an internal label.  */\n-    void (* internal_label) PARAMS ((FILE *, const char *, unsigned long));\n+    void (* internal_label) (FILE *, const char *, unsigned long);\n \n     /* Emit an assembler directive to set visibility for the symbol\n        associated with the tree decl.  */\n-    void (* visibility) PARAMS ((tree, int));\n+    void (* visibility) (tree, int);\n \n     /* Output the assembler code for entry to a function.  */\n-    void (* function_prologue) PARAMS ((FILE *, HOST_WIDE_INT));\n+    void (* function_prologue) (FILE *, HOST_WIDE_INT);\n \n     /* Output the assembler code for end of prologue.  */\n-    void (* function_end_prologue) PARAMS ((FILE *));\n+    void (* function_end_prologue) (FILE *);\n \n     /* Output the assembler code for start of epilogue.  */\n-    void (* function_begin_epilogue) PARAMS ((FILE *));\n+    void (* function_begin_epilogue) (FILE *);\n \n     /* Output the assembler code for function exit.  */\n-    void (* function_epilogue) PARAMS ((FILE *, HOST_WIDE_INT));\n+    void (* function_epilogue) (FILE *, HOST_WIDE_INT);\n \n     /* Switch to an arbitrary section NAME with attributes as\n        specified by FLAGS.  */\n-    void (* named_section) PARAMS ((const char *, unsigned int));\n+    void (* named_section) (const char *, unsigned int);\n \n     /* Switch to the section that holds the exception table.  */\n-    void (* exception_section) PARAMS ((void));\n+    void (* exception_section) (void);\n \n     /* Switch to the section that holds the exception frames.  */\n-    void (* eh_frame_section) PARAMS ((void));\n+    void (* eh_frame_section) (void);\n \n     /* Select and switch to a section for EXP.  It may be a DECL or a\n        constant.  RELOC is nonzero if runtime relocations must be applied;\n        bit 1 will be set if the runtime relocations require non-local\n        name resolution.  ALIGN is the required alignment of the data.  */\n-    void (* select_section) PARAMS ((tree, int, unsigned HOST_WIDE_INT));\n+    void (* select_section) (tree, int, unsigned HOST_WIDE_INT);\n \n     /* Select and switch to a section for X with MODE.  ALIGN is\n        the desired alignment of the data.  */\n-    void (* select_rtx_section) PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t unsigned HOST_WIDE_INT));\n+    void (* select_rtx_section) (enum machine_mode, rtx,\n+\t\t\t\t unsigned HOST_WIDE_INT);\n \n     /* Select a unique section name for DECL.  RELOC is the same as\n        for SELECT_SECTION.  */\n-    void (* unique_section) PARAMS ((tree, int));\n+    void (* unique_section) (tree, int);\n \n     /* Output a constructor for a symbol with a given priority.  */\n-    void (* constructor) PARAMS ((rtx, int));\n+    void (* constructor) (rtx, int);\n \n     /* Output a destructor for a symbol with a given priority.  */\n-    void (* destructor) PARAMS ((rtx, int));\n+    void (* destructor) (rtx, int);\n \n     /* Output the assembler code for a thunk function.  THUNK_DECL is the\n        declaration for the thunk function itself, FUNCTION is the decl for\n        the target function.  DELTA is an immediate constant offset to be\n        added to THIS.  If VCALL_OFFSET is nonzero, the word at\n        *(*this + vcall_offset) should be added to THIS.  */\n-    void (* output_mi_thunk) PARAMS ((FILE *file, tree thunk_decl,\n-\t\t\t\t      HOST_WIDE_INT delta,\n-\t\t\t\t      HOST_WIDE_INT vcall_offset,\n-\t\t\t\t      tree function_decl));\n+    void (* output_mi_thunk) (FILE *file, tree thunk_decl,\n+\t\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t\t      tree function_decl);\n \n     /* Determine whether output_mi_thunk would succeed.  */\n     /* ??? Ideally, this hook would not exist, and success or failure\n        would be returned from output_mi_thunk directly.  But there's\n        too much undo-able setup involved in invoking output_mi_thunk.\n        Could be fixed by making output_mi_thunk emit rtl instead of\n        text to the output file.  */\n-    bool (* can_output_mi_thunk) PARAMS ((tree thunk_decl,\n-\t\t\t\t          HOST_WIDE_INT delta,\n-\t\t\t\t          HOST_WIDE_INT vcall_offset,\n-\t\t\t\t          tree function_decl));\n+    bool (* can_output_mi_thunk) (tree thunk_decl, HOST_WIDE_INT delta,\n+\t\t\t\t  HOST_WIDE_INT vcall_offset,\n+\t\t\t\t  tree function_decl);\n \n     /* Output any boilerplate text needed at the beginning of a\n        translation unit.  */\n-    void (*file_start) PARAMS ((void));\n+    void (*file_start) (void);\n \n     /* Output any boilerplate text needed at the end of a\n        translation unit.  */\n-    void (*file_end) PARAMS ((void));\n+    void (*file_end) (void);\n   } asm_out;\n \n   /* Functions relating to instruction scheduling.  */\n@@ -158,41 +156,41 @@ struct gcc_target\n     /* Given the current cost, COST, of an insn, INSN, calculate and\n        return a new cost based on its relationship to DEP_INSN through\n        the dependence LINK.  The default is to make no adjustment.  */\n-    int (* adjust_cost) PARAMS ((rtx insn, rtx link, rtx def_insn, int cost));\n+    int (* adjust_cost) (rtx insn, rtx link, rtx def_insn, int cost);\n \n     /* Adjust the priority of an insn as you see fit.  Returns the new\n        priority.  */\n-    int (* adjust_priority) PARAMS ((rtx, int));\n+    int (* adjust_priority) (rtx, int);\n \n     /* Function which returns the maximum number of insns that can be\n        scheduled in the same machine cycle.  This must be constant\n        over an entire compilation.  The default is 1.  */\n-    int (* issue_rate) PARAMS ((void));\n+    int (* issue_rate) (void);\n \n     /* Calculate how much this insn affects how many more insns we\n        can emit this cycle.  Default is they all cost the same.  */\n-    int (* variable_issue) PARAMS ((FILE *, int, rtx, int));\n+    int (* variable_issue) (FILE *, int, rtx, int);\n \n     /* Initialize machine-dependent scheduling code.  */\n-    void (* md_init) PARAMS ((FILE *, int, int));\n+    void (* md_init) (FILE *, int, int);\n \n     /* Finalize machine-dependent scheduling code.  */\n-    void (* md_finish) PARAMS ((FILE *, int));\n+    void (* md_finish) (FILE *, int);\n \n     /* Reorder insns in a machine-dependent fashion, in two different\n        places.  Default does nothing.  */\n-    int (* reorder)  PARAMS ((FILE *, int, rtx *, int *, int));\n-    int (* reorder2) PARAMS ((FILE *, int, rtx *, int *, int));\n+    int (* reorder) (FILE *, int, rtx *, int *, int);\n+    int (* reorder2) (FILE *, int, rtx *, int *, int);\n \n     /* The following member value is a pointer to a function called\n        after evaluation forward dependencies of insns in chain given\n        by two parameter values (head and tail correspondingly).  */\n-    void (* dependencies_evaluation_hook) PARAMS ((rtx, rtx));\n+    void (* dependencies_evaluation_hook) (rtx, rtx);\n \n     /* The following member value is a pointer to a function returning\n        nonzero if we should use DFA based scheduling.  The default is\n        to use the old pipeline scheduler.  */\n-    int (* use_dfa_pipeline_interface) PARAMS ((void));\n+    int (* use_dfa_pipeline_interface) (void);\n     /* The values of all the following members are used only for the\n        DFA based scheduler: */\n     /* The values of the following four members are pointers to\n@@ -206,24 +204,24 @@ struct gcc_target\n        the memebers result in not changing the automaton state when\n        the new simulated processor cycle correspondingly starts and\n        finishes.  */\n-    void (* init_dfa_pre_cycle_insn) PARAMS ((void));\n-    rtx (* dfa_pre_cycle_insn) PARAMS ((void));\n-    void (* init_dfa_post_cycle_insn) PARAMS ((void));\n-    rtx (* dfa_post_cycle_insn) PARAMS ((void));\n+    void (* init_dfa_pre_cycle_insn) (void);\n+    rtx (* dfa_pre_cycle_insn) (void);\n+    void (* init_dfa_post_cycle_insn) (void);\n+    rtx (* dfa_post_cycle_insn) (void);\n     /* The following member value is a pointer to a function returning value\n        which defines how many insns in queue `ready' will we try for\n        multi-pass scheduling.  if the member value is nonzero and the\n        function returns positive value, the DFA based scheduler will make\n        multi-pass scheduling for the first cycle.  In other words, we will\n        try to choose ready insn which permits to start maximum number of\n        insns on the same cycle.  */\n-    int (* first_cycle_multipass_dfa_lookahead) PARAMS ((void));\n+    int (* first_cycle_multipass_dfa_lookahead) (void);\n     /* The following member value is pointer to a function controlling\n        what insns from the ready insn queue will be considered for the\n        multipass insn scheduling.  If the hook returns zero for insn\n        passed as the parameter, the insn will be not chosen to be\n        issued.  */\n-    int (* first_cycle_multipass_dfa_lookahead_guard) PARAMS ((rtx));\n+    int (* first_cycle_multipass_dfa_lookahead_guard) (rtx);\n     /* The following member value is pointer to a function called by\n        the insn scheduler before issuing insn passed as the third\n        parameter on given cycle.  If the hook returns nonzero, the\n@@ -236,7 +234,7 @@ struct gcc_target\n        parameter values are correspondingly processor cycle on which\n        the previous insn has been issued and the current processor\n        cycle.  */\n-    int (* dfa_new_cycle) PARAMS ((FILE *, int, rtx, int, int, int *));\n+    int (* dfa_new_cycle) (FILE *, int, rtx, int, int, int *);\n     /* The values of the following members are pointers to functions\n        used to improve the first cycle multipass scheduling by\n        inserting nop insns.  dfa_scheduler_bubble gives a function\n@@ -247,15 +245,15 @@ struct gcc_target\n        init_dfa_scheduler_bubbles is used.  The default values of the\n        members result in not inserting nop insns during the multipass\n        scheduling.  */\n-    void (* init_dfa_bubbles) PARAMS ((void));\n-    rtx (* dfa_bubble) PARAMS ((int));\n+    void (* init_dfa_bubbles) (void);\n+    rtx (* dfa_bubble) (int);\n   } sched;\n \n   /* Given two decls, merge their attributes and return the result.  */\n-  tree (* merge_decl_attributes) PARAMS ((tree, tree));\n+  tree (* merge_decl_attributes) (tree, tree);\n \n   /* Given two types, merge their attributes and return the result.  */\n-  tree (* merge_type_attributes) PARAMS ((tree, tree));\n+  tree (* merge_type_attributes) (tree, tree);\n \n   /* Table of machine attributes and functions to handle them.\n      Ignored if NULL.  */\n@@ -264,104 +262,104 @@ struct gcc_target\n   /* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,\n      one if they are compatible and two if they are nearly compatible\n      (which causes a warning to be generated).  */\n-  int (* comp_type_attributes) PARAMS ((tree type1, tree type2));\n+  int (* comp_type_attributes) (tree type1, tree type2);\n \n   /* Assign default attributes to the newly defined TYPE.  */\n-  void (* set_default_type_attributes) PARAMS ((tree type));\n+  void (* set_default_type_attributes) (tree type);\n \n   /* Insert attributes on the newly created DECL.  */\n-  void (* insert_attributes) PARAMS ((tree decl, tree *attributes));\n+  void (* insert_attributes) (tree decl, tree *attributes);\n \n   /* Return true if FNDECL (which has at least one machine attribute)\n      can be inlined despite its machine attributes, false otherwise.  */\n-  bool (* function_attribute_inlinable_p) PARAMS ((tree fndecl));\n+  bool (* function_attribute_inlinable_p) (tree fndecl);\n \n   /* Return true if bitfields in RECORD_TYPE should follow the\n      Microsoft Visual C++ bitfield layout rules.  */\n-  bool (* ms_bitfield_layout_p) PARAMS ((tree record_type));\n+  bool (* ms_bitfield_layout_p) (tree record_type);\n \n   /* Set up target-specific built-in functions.  */\n-  void (* init_builtins) PARAMS ((void));\n+  void (* init_builtins) (void);\n \n   /* Expand a target-specific builtin.  */\n-  rtx (* expand_builtin) PARAMS ((tree exp, rtx target, rtx subtarget,\n-\t\t\t\t  enum machine_mode mode, int ignore));\n+  rtx (* expand_builtin) (tree exp, rtx target, rtx subtarget,\n+\t\t\t  enum machine_mode mode, int ignore);\n \n   /* Given a decl, a section name, and whether the decl initializer\n      has relocs, choose attributes for the section.  */\n   /* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */\n-  unsigned int (* section_type_flags) PARAMS ((tree, const char *, int));\n+  unsigned int (* section_type_flags) (tree, const char *, int);\n \n   /* True if new jumps cannot be created, to replace existing ones or\n      not, at the current point in the compilation.  */\n-  bool (* cannot_modify_jumps_p) PARAMS ((void));\n+  bool (* cannot_modify_jumps_p) (void);\n \n   /* Return a register class for which branch target register\n      optimizations should be applied.  */\n-  int (* branch_target_register_class) PARAMS ((void));\n+  int (* branch_target_register_class) (void);\n \n   /* Return true if branch target register optimizations should include\n      callee-saved registers that are not already live during the current\n      function.  AFTER_PE_GEN is true if prologues and epilogues have\n      already been generated.  */\n-  bool (* branch_target_register_callee_saved) PARAMS ((bool after_pe_gen));\n+  bool (* branch_target_register_callee_saved) (bool after_pe_gen);\n \n   /* True if the constant X cannot be placed in the constant pool.  */\n-  bool (* cannot_force_const_mem) PARAMS ((rtx));\n+  bool (* cannot_force_const_mem) (rtx);\n \n   /* True if the insn X cannot be duplicated.  */\n-  bool (* cannot_copy_insn_p) PARAMS ((rtx));\n+  bool (* cannot_copy_insn_p) (rtx);\n \n   /* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n-  rtx (* delegitimize_address) PARAMS ((rtx));\n+  rtx (* delegitimize_address) (rtx);\n \n   /* True if it is OK to do sibling call optimization for the specified\n      call expression EXP.  DECL will be the called function, or NULL if\n      this is an indirect call.  */\n-  bool (*function_ok_for_sibcall) PARAMS ((tree decl, tree exp));\n-  \n+  bool (*function_ok_for_sibcall) (tree decl, tree exp);\n+\n   /* True if EXP should be placed in a \"small data\" section.  */\n-  bool (* in_small_data_p) PARAMS ((tree));\n+  bool (* in_small_data_p) (tree);\n \n   /* True if EXP names an object for which name resolution must resolve\n      to the current module.  */\n-  bool (* binds_local_p) PARAMS ((tree));\n+  bool (* binds_local_p) (tree);\n \n   /* Do something target-specific to record properties of the DECL into\n      the associated SYMBOL_REF.  */\n-  void (* encode_section_info) PARAMS ((tree, rtx, int));\n+  void (* encode_section_info) (tree, rtx, int);\n \n   /* Undo the effects of encode_section_info on the symbol string.  */\n-  const char * (* strip_name_encoding) PARAMS ((const char *));\n+  const char * (* strip_name_encoding) (const char *);\n \n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n-  bool (* valid_pointer_mode) PARAMS ((enum machine_mode mode));\n+  bool (* valid_pointer_mode) (enum machine_mode mode);\n \n   /* True if a vector is opaque.  */\n-  bool (* vector_opaque_p) PARAMS ((tree));\n+  bool (* vector_opaque_p) (tree);\n \n   /* Compute a (partial) cost for rtx X.  Return true if the complete\n      cost has been computed, and false if subexpressions should be\n      scanned.  In either case, *TOTAL contains the cost result.  */\n   /* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n      not necessarily defined at this point.  */\n-  bool (* rtx_costs) PARAMS ((rtx x, int code, int outer_code, int *total));\n+  bool (* rtx_costs) (rtx x, int code, int outer_code, int *total);\n \n   /* Compute the cost of X, used as an address.  Never called with\n      invalid addresses.  */\n-  int (* address_cost) PARAMS ((rtx x));\n+  int (* address_cost) (rtx x);\n \n   /* Given a register, this hook should return a parallel of registers\n      to represent where to find the register pieces.  Define this hook\n      if the register and its mode are represented in Dwarf in\n      non-contiguous locations, or if the register should be\n      represented in more than one register in Dwarf.  Otherwise, this\n      hook should return NULL_RTX.  */\n-  rtx (* dwarf_register_span) PARAMS ((rtx));\n+  rtx (* dwarf_register_span) (rtx);\n \n   /* Do machine-dependent code transformations.  Called just before\n      delayed-branch scheduling.  */\n-  void (* machine_dependent_reorg) PARAMS ((void));\n+  void (* machine_dependent_reorg) (void);\n \n   /* Leave the boolean fields at the end.  */\n "}, {"sha": "776f575eb6927991e81c8e034f5d83ed04046d4a", "filename": "gcc/timevar.c", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -71,7 +71,7 @@ struct tms\n    information).  */\n #ifdef HAVE_TIMES\n # if defined HAVE_DECL_TIMES && !HAVE_DECL_TIMES\n-  extern clock_t times PARAMS ((struct tms *));\n+  extern clock_t times (struct tms *);\n # endif\n # define USE_TIMES\n # define HAVE_USER_TIME\n@@ -168,19 +168,17 @@ static struct timevar_stack_def *unused_stack_instances;\n    element.  */\n static struct timevar_time_def start_time;\n \n-static void get_time\n-  PARAMS ((struct timevar_time_def *));\n-static void timevar_accumulate\n-  PARAMS ((struct timevar_time_def *, struct timevar_time_def *,\n-\t   struct timevar_time_def *));\n+static void get_time (struct timevar_time_def *);\n+static void timevar_accumulate (struct timevar_time_def *,\n+\t\t\t\tstruct timevar_time_def *,\n+\t\t\t\tstruct timevar_time_def *);\n \n /* Fill the current times into TIME.  The definition of this function\n    also defines any or all of the HAVE_USER_TIME, HAVE_SYS_TIME, and\n    HAVE_WALL_TIME macros.  */\n \n static void\n-get_time (now)\n-     struct timevar_time_def *now;\n+get_time (struct timevar_time_def *now)\n {\n   now->user = 0;\n   now->sys  = 0;\n@@ -211,10 +209,9 @@ get_time (now)\n /* Add the difference between STOP_TIME and START_TIME to TIMER.  */\n \n static void\n-timevar_accumulate (timer, start_time, stop_time)\n-     struct timevar_time_def *timer;\n-     struct timevar_time_def *start_time;\n-     struct timevar_time_def *stop_time;\n+timevar_accumulate (struct timevar_time_def *timer,\n+\t\t    struct timevar_time_def *start_time,\n+\t\t    struct timevar_time_def *stop_time)\n {\n   timer->user += stop_time->user - start_time->user;\n   timer->sys += stop_time->sys - start_time->sys;\n@@ -224,7 +221,7 @@ timevar_accumulate (timer, start_time, stop_time)\n /* Initialize timing variables.  */\n \n void\n-timevar_init ()\n+timevar_init (void)\n {\n   timevar_enable = true;\n \n@@ -253,8 +250,7 @@ timevar_init ()\n    TIMEVAR cannot be running as a standalone timer.  */\n \n void\n-timevar_push (timevar)\n-     timevar_id_t timevar;\n+timevar_push (timevar_id_t timevar)\n {\n   struct timevar_def *tv = &timevars[timevar];\n   struct timevar_stack_def *context;\n@@ -306,8 +302,7 @@ timevar_push (timevar)\n    timing variable.  */\n \n void\n-timevar_pop (timevar)\n-     timevar_id_t timevar;\n+timevar_pop (timevar_id_t timevar)\n {\n   struct timevar_time_def now;\n   struct timevar_stack_def *popped = stack;\n@@ -346,8 +341,7 @@ timevar_pop (timevar)\n    attributed to TIMEVAR.  */\n \n void\n-timevar_start (timevar)\n-     timevar_id_t timevar;\n+timevar_start (timevar_id_t timevar)\n {\n   struct timevar_def *tv = &timevars[timevar];\n \n@@ -370,8 +364,7 @@ timevar_start (timevar)\n    is attributed to it.  */\n \n void\n-timevar_stop (timevar)\n-     timevar_id_t timevar;\n+timevar_stop (timevar_id_t timevar)\n {\n   struct timevar_def *tv = &timevars[timevar];\n   struct timevar_time_def now;\n@@ -391,9 +384,7 @@ timevar_stop (timevar)\n    update-to-date information even if TIMEVAR is currently running.  */\n \n void\n-timevar_get (timevar, elapsed)\n-     timevar_id_t timevar;\n-     struct timevar_time_def *elapsed;\n+timevar_get (timevar_id_t timevar, struct timevar_time_def *elapsed)\n {\n   struct timevar_def *tv = &timevars[timevar];\n   struct timevar_time_def now;\n@@ -419,8 +410,7 @@ timevar_get (timevar, elapsed)\n    for normalizing the others, and is displayed last.  */\n \n void\n-timevar_print (fp)\n-     FILE *fp;\n+timevar_print (FILE *fp)\n {\n   /* Only print stuff if we have some sort of time information.  */\n #if defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) || defined (HAVE_WALL_TIME)\n@@ -517,9 +507,7 @@ timevar_print (fp)\n    TOTAL (given in microseconds).  */\n \n void\n-print_time (str, total)\n-     const char *str;\n-     long total;\n+print_time (const char *str, long total)\n {\n   long all_time = get_run_time ();\n   fprintf (stderr,"}, {"sha": "6f40ec0abd975003483d64fe24526045750f8460", "filename": "gcc/timevar.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -79,15 +79,15 @@ timevar_id_t;\n /* Execute the sequence: timevar_pop (TV), return (E);  */\n #define POP_TIMEVAR_AND_RETURN(TV, E)  return (timevar_pop (TV), (E))\n \n-extern void timevar_init PARAMS ((void));\n-extern void timevar_push PARAMS ((timevar_id_t));\n-extern void timevar_pop PARAMS ((timevar_id_t));\n-extern void timevar_start PARAMS ((timevar_id_t));\n-extern void timevar_stop PARAMS ((timevar_id_t));\n-extern void timevar_get PARAMS ((timevar_id_t, struct timevar_time_def *));\n-extern void timevar_print PARAMS ((FILE *));\n+extern void timevar_init (void);\n+extern void timevar_push (timevar_id_t);\n+extern void timevar_pop (timevar_id_t);\n+extern void timevar_start (timevar_id_t);\n+extern void timevar_stop (timevar_id_t);\n+extern void timevar_get (timevar_id_t, struct timevar_time_def *);\n+extern void timevar_print (FILE *);\n \n /* Provided for backward compatibility.  */\n-extern void print_time PARAMS ((const char *, long));\n+extern void print_time (const char *, long);\n \n #endif /* ! GCC_TIMEVAR_H */"}, {"sha": "d377c7592dc74e130ea9228f179e0feccd676aa9", "filename": "gcc/tlink.c", "status": "modified", "additions": 48, "deletions": 77, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,7 +1,8 @@\n /* Scan linker error messages for missing template instantiations and provide\n    them.\n \n-   Copyright (C) 1995, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Jason Merrill (jason@cygnus.com).\n \n This file is part of GCC.\n@@ -67,58 +68,51 @@ typedef struct demangled_hash_entry\n \n /* Hash and comparison functions for these hash tables.  */\n \n-static int hash_string_eq PARAMS ((const void *, const void *));\n-static hashval_t hash_string_hash PARAMS ((const void *));\n+static int hash_string_eq (const void *, const void *);\n+static hashval_t hash_string_hash (const void *);\n \n static int\n-hash_string_eq (s1_p, s2_p)\n-     const void *s1_p;\n-     const void *s2_p;\n+hash_string_eq (const void *s1_p, const void *s2_p)\n {\n   const char *const *s1 = (const char *const *) s1_p;\n   const char *s2 = (const char *) s2_p;\n   return strcmp (*s1, s2) == 0;\n }\n \n static hashval_t\n-hash_string_hash (s_p)\n-     const void *s_p;\n+hash_string_hash (const void *s_p)\n {\n   const char *const *s = (const char *const *) s_p;\n   return (*htab_hash_string) (*s);\n }\n \n static htab_t symbol_table;\n \n-static struct symbol_hash_entry * symbol_hash_lookup PARAMS ((const char *,\n-\t\t\t\t\t\t\t      int));\n-static struct file_hash_entry * file_hash_lookup PARAMS ((const char *));\n-static struct demangled_hash_entry *\n-  demangled_hash_lookup PARAMS ((const char *, int));\n-static void symbol_push PARAMS ((symbol *));\n-static symbol * symbol_pop PARAMS ((void));\n-static void file_push PARAMS ((file *));\n-static file * file_pop PARAMS ((void));\n-static void tlink_init PARAMS ((void));\n-static int tlink_execute PARAMS ((const char *, char **, const char *));\n-static char * frob_extension PARAMS ((const char *, const char *));\n-static char * obstack_fgets PARAMS ((FILE *, struct obstack *));\n-static char * tfgets PARAMS ((FILE *));\n-static char * pfgets PARAMS ((FILE *));\n-static void freadsym PARAMS ((FILE *, file *, int));\n-static void read_repo_file PARAMS ((file *));\n-static void maybe_tweak PARAMS ((char *, file *));\n-static int recompile_files PARAMS ((void));\n-static int read_repo_files PARAMS ((char **));\n-static void demangle_new_symbols PARAMS ((void));\n-static int scan_linker_output PARAMS ((const char *));\n+static struct symbol_hash_entry * symbol_hash_lookup (const char *, int);\n+static struct file_hash_entry * file_hash_lookup (const char *);\n+static struct demangled_hash_entry *demangled_hash_lookup (const char *, int);\n+static void symbol_push (symbol *);\n+static symbol * symbol_pop (void);\n+static void file_push (file *);\n+static file * file_pop (void);\n+static void tlink_init (void);\n+static int tlink_execute (const char *, char **, const char *);\n+static char * frob_extension (const char *, const char *);\n+static char * obstack_fgets (FILE *, struct obstack *);\n+static char * tfgets (FILE *);\n+static char * pfgets (FILE *);\n+static void freadsym (FILE *, file *, int);\n+static void read_repo_file (file *);\n+static void maybe_tweak (char *, file *);\n+static int recompile_files (void);\n+static int read_repo_files (char **);\n+static void demangle_new_symbols (void);\n+static int scan_linker_output (const char *);\n \n /* Look up an entry in the symbol hash table.  */\n \n static struct symbol_hash_entry *\n-symbol_hash_lookup (string, create)\n-     const char *string;\n-     int create;\n+symbol_hash_lookup (const char *string, int create)\n {\n   void **e;\n   e = htab_find_slot_with_hash (symbol_table, string,\n@@ -140,8 +134,7 @@ static htab_t file_table;\n /* Look up an entry in the file hash table.  */\n \n static struct file_hash_entry *\n-file_hash_lookup (string)\n-     const char *string;\n+file_hash_lookup (const char *string)\n {\n   void **e;\n   e = htab_find_slot_with_hash (file_table, string,\n@@ -161,9 +154,7 @@ static htab_t demangled_table;\n /* Look up an entry in the demangled name hash table.  */\n \n static struct demangled_hash_entry *\n-demangled_hash_lookup (string, create)\n-     const char *string;\n-     int create;\n+demangled_hash_lookup (const char *string, int create)\n {\n   void **e;\n   e = htab_find_slot_with_hash (demangled_table, string,\n@@ -199,8 +190,7 @@ struct obstack file_stack_obstack;\n struct file_stack_entry *file_stack;\n \n static void\n-symbol_push (p)\n-     symbol *p;\n+symbol_push (symbol *p)\n {\n   struct symbol_stack_entry *ep = (struct symbol_stack_entry *) obstack_alloc\n     (&symbol_stack_obstack, sizeof (struct symbol_stack_entry));\n@@ -210,7 +200,7 @@ symbol_push (p)\n }\n \n static symbol *\n-symbol_pop ()\n+symbol_pop (void)\n {\n   struct symbol_stack_entry *ep = symbol_stack;\n   symbol *p;\n@@ -223,8 +213,7 @@ symbol_pop ()\n }\n \n static void\n-file_push (p)\n-     file *p;\n+file_push (file *p)\n {\n   struct file_stack_entry *ep;\n \n@@ -240,7 +229,7 @@ file_push (p)\n }\n \n static file *\n-file_pop ()\n+file_pop (void)\n {\n   struct file_stack_entry *ep = file_stack;\n   file *p;\n@@ -258,7 +247,7 @@ file_pop ()\n /* Initialize the tlink machinery.  Called from do_tlink.  */\n \n static void\n-tlink_init ()\n+tlink_init (void)\n {\n   const char *p;\n \n@@ -268,7 +257,7 @@ tlink_init ()\n \t\t\t    NULL);\n   demangled_table = htab_create (500, hash_string_hash, hash_string_eq,\n \t\t\t\t NULL);\n-  \n+\n   obstack_begin (&symbol_stack_obstack, 0);\n   obstack_begin (&file_stack_obstack, 0);\n \n@@ -286,19 +275,14 @@ tlink_init ()\n }\n \n static int\n-tlink_execute (prog, argv, redir)\n-     const char *prog;\n-     char **argv;\n-     const char *redir;\n+tlink_execute (const char *prog, char **argv, const char *redir)\n {\n   collect_execute (prog, argv, redir);\n   return collect_wait (prog);\n }\n \n static char *\n-frob_extension (s, ext)\n-     const char *s;\n-     const char *ext;\n+frob_extension (const char *s, const char *ext)\n {\n   const char *p = strrchr (s, '/');\n   if (! p)\n@@ -312,9 +296,7 @@ frob_extension (s, ext)\n }\n \n static char *\n-obstack_fgets (stream, ob)\n-     FILE *stream;\n-     struct obstack *ob;\n+obstack_fgets (FILE *stream, struct obstack *ob)\n {\n   int c;\n   while ((c = getc (stream)) != EOF && c != '\\n')\n@@ -326,15 +308,13 @@ obstack_fgets (stream, ob)\n }\n \n static char *\n-tfgets (stream)\n-     FILE *stream;\n+tfgets (FILE *stream)\n {\n   return obstack_fgets (stream, &temporary_obstack);\n }\n \n static char *\n-pfgets (stream)\n-     FILE *stream;\n+pfgets (FILE *stream)\n {\n   return xstrdup (tfgets (stream));\n }\n@@ -348,10 +328,7 @@ pfgets (stream)\n    XXX \"provided\" is unimplemented, both here and in the compiler.  */\n \n static void\n-freadsym (stream, f, chosen)\n-     FILE *stream;\n-     file *f;\n-     int chosen;\n+freadsym (FILE *stream, file *f, int chosen)\n {\n   symbol *sym;\n \n@@ -391,8 +368,7 @@ freadsym (stream, f, chosen)\n /* Read in the repo file denoted by F, and record all its information.  */\n \n static void\n-read_repo_file (f)\n-     file *f;\n+read_repo_file (file *f)\n {\n   char c;\n   FILE *stream = fopen (f->key, \"r\");\n@@ -438,9 +414,7 @@ read_repo_file (f)\n    this one wants to emit it as well.  */\n \n static void\n-maybe_tweak (line, f)\n-     char *line;\n-     file *f;\n+maybe_tweak (char *line, file *f)\n {\n   symbol *sym = symbol_hash_lookup (line + 2, false);\n \n@@ -463,7 +437,7 @@ maybe_tweak (line, f)\n    XXX Should this use collect_execute instead of system?  */\n \n static int\n-recompile_files ()\n+recompile_files (void)\n {\n   file *f;\n \n@@ -519,8 +493,7 @@ recompile_files ()\n    .rpo files associated with them, and read in the information.  */\n \n static int\n-read_repo_files (object_lst)\n-     char **object_lst;\n+read_repo_files (char **object_lst)\n {\n   char **object = object_lst;\n \n@@ -552,7 +525,7 @@ read_repo_files (object_lst)\n /* Add the demangled forms of any new symbols to the hash table.  */\n \n static void\n-demangle_new_symbols ()\n+demangle_new_symbols (void)\n {\n   symbol *sym;\n \n@@ -573,8 +546,7 @@ demangle_new_symbols ()\n    adjust the settings for each symbol encountered.  */\n \n static int\n-scan_linker_output (fname)\n-     const char *fname;\n+scan_linker_output (const char *fname)\n {\n   FILE *stream = fopen (fname, \"r\");\n   char *line;\n@@ -702,8 +674,7 @@ scan_linker_output (fname)\n      to provide missing definitions.  Currently ignored.  */\n \n void\n-do_tlink (ld_argv, object_lst)\n-     char **ld_argv, **object_lst ATTRIBUTE_UNUSED;\n+do_tlink (char **ld_argv, char **object_lst ATTRIBUTE_UNUSED)\n {\n   int exit = tlink_execute (\"ld\", ld_argv, ldout);\n "}, {"sha": "eb311b9c7ef6dd2c1bb0c87fc67555914a20f6cc", "filename": "gcc/tracer.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -48,14 +48,14 @@\n #include \"params.h\"\n #include \"coverage.h\"\n \n-static int count_insns\t\tPARAMS ((basic_block));\n-static bool ignore_bb_p\t\tPARAMS ((basic_block));\n-static bool better_p\t\tPARAMS ((edge, edge));\n-static edge find_best_successor PARAMS ((basic_block));\n-static edge find_best_predecessor PARAMS ((basic_block));\n-static int find_trace\t\tPARAMS ((basic_block, basic_block *));\n-static void tail_duplicate\tPARAMS ((void));\n-static void layout_superblocks\tPARAMS ((void));\n+static int count_insns (basic_block);\n+static bool ignore_bb_p (basic_block);\n+static bool better_p (edge, edge);\n+static edge find_best_successor (basic_block);\n+static edge find_best_predecessor (basic_block);\n+static int find_trace (basic_block, basic_block *);\n+static void tail_duplicate (void);\n+static void layout_superblocks (void);\n \n /* Minimal outgoing edge probability considered for superblock formation.  */\n static int probability_cutoff;\n@@ -68,8 +68,7 @@ static int branch_ratio_cutoff;\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */\n static bool\n-ignore_bb_p (bb)\n-     basic_block bb;\n+ignore_bb_p (basic_block bb)\n {\n   if (bb->index < 0)\n     return true;\n@@ -81,8 +80,7 @@ ignore_bb_p (bb)\n /* Return number of instructions in the block.  */\n \n static int\n-count_insns (bb)\n-     basic_block bb;\n+count_insns (basic_block bb)\n {\n   rtx insn;\n   int n = 0;\n@@ -95,8 +93,7 @@ count_insns (bb)\n \n /* Return true if E1 is more frequent than E2.  */\n static bool\n-better_p (e1, e2)\n-     edge e1, e2;\n+better_p (edge e1, edge e2)\n {\n   if (e1->count != e2->count)\n     return e1->count > e2->count;\n@@ -114,8 +111,7 @@ better_p (e1, e2)\n /* Return most frequent successor of basic block BB.  */\n \n static edge\n-find_best_successor (bb)\n-     basic_block bb;\n+find_best_successor (basic_block bb)\n {\n   edge e;\n   edge best = NULL;\n@@ -133,8 +129,7 @@ find_best_successor (bb)\n /* Return most frequent predecessor of basic block BB.  */\n \n static edge\n-find_best_predecessor (bb)\n-     basic_block bb;\n+find_best_predecessor (basic_block bb)\n {\n   edge e;\n   edge best = NULL;\n@@ -154,9 +149,7 @@ find_best_predecessor (bb)\n    Return number of basic blocks recorded.  */\n \n static int\n-find_trace (bb, trace)\n-     basic_block bb;\n-     basic_block *trace;\n+find_trace (basic_block bb, basic_block *trace)\n {\n   int i = 0;\n   edge e;\n@@ -198,7 +191,7 @@ find_trace (bb, trace)\n    if profitable.  */\n \n static void\n-tail_duplicate ()\n+tail_duplicate (void)\n {\n   fibnode_t *blocks = xcalloc (last_basic_block, sizeof (fibnode_t));\n   basic_block *trace = xmalloc (sizeof (basic_block) * n_basic_blocks);\n@@ -322,7 +315,7 @@ tail_duplicate ()\n    change though.  */\n \n static void\n-layout_superblocks ()\n+layout_superblocks (void)\n {\n   basic_block end = ENTRY_BLOCK_PTR->succ->dest;\n   basic_block bb = ENTRY_BLOCK_PTR->succ->dest->next_bb;\n@@ -361,7 +354,7 @@ layout_superblocks ()\n /* Main entry point to this file.  */\n \n void\n-tracer ()\n+tracer (void)\n {\n   if (n_basic_blocks <= 1)\n     return;"}, {"sha": "0d4d7a41098576e4e4b56885e27a1daec40666e1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 49, "deletions": 106, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -110,26 +110,26 @@ typedef struct inline_data\n \n /* Prototypes.  */\n \n-static tree declare_return_variable PARAMS ((inline_data *, tree, tree *));\n-static tree copy_body_r PARAMS ((tree *, int *, void *));\n-static tree copy_body PARAMS ((inline_data *));\n-static tree expand_call_inline PARAMS ((tree *, int *, void *));\n-static void expand_calls_inline PARAMS ((tree *, inline_data *));\n-static int inlinable_function_p PARAMS ((tree, inline_data *, int));\n-static tree remap_decl PARAMS ((tree, inline_data *));\n+static tree declare_return_variable (inline_data *, tree, tree *);\n+static tree copy_body_r (tree *, int *, void *);\n+static tree copy_body (inline_data *);\n+static tree expand_call_inline (tree *, int *, void *);\n+static void expand_calls_inline (tree *, inline_data *);\n+static int inlinable_function_p (tree, inline_data *, int);\n+static tree remap_decl (tree, inline_data *);\n #ifndef INLINER_FOR_JAVA\n-static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree));\n-static void remap_block PARAMS ((tree, tree, inline_data *));\n-static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n+static tree initialize_inlined_parameters (inline_data *, tree, tree);\n+static void remap_block (tree, tree, inline_data *);\n+static void copy_scope_stmt (tree *, int *, inline_data *);\n #else /* INLINER_FOR_JAVA */\n-static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree, tree));\n-static void remap_block PARAMS ((tree *, tree, inline_data *));\n-static tree add_stmt_to_compound PARAMS ((tree, tree, tree));\n+static tree initialize_inlined_parameters (inline_data *, tree, tree, tree);\n+static void remap_block (tree *, tree, inline_data *);\n+static tree add_stmt_to_compound (tree, tree, tree);\n #endif /* INLINER_FOR_JAVA */\n-static tree find_alloca_call_1 PARAMS ((tree *, int *, void *));\n-static tree find_alloca_call PARAMS ((tree));\n-static tree find_builtin_longjmp_call_1 PARAMS ((tree *, int *, void *));\n-static tree find_builtin_longjmp_call PARAMS ((tree));\n+static tree find_alloca_call_1 (tree *, int *, void *);\n+static tree find_alloca_call (tree);\n+static tree find_builtin_longjmp_call_1 (tree *, int *, void *);\n+static tree find_builtin_longjmp_call (tree);\n \n /* The approximate number of instructions per statement.  This number\n    need not be particularly accurate; it is used only to make\n@@ -139,9 +139,7 @@ static tree find_builtin_longjmp_call PARAMS ((tree));\n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n static tree\n-remap_decl (decl, id)\n-     tree decl;\n-     inline_data *id;\n+remap_decl (tree decl, inline_data *id)\n {\n   splay_tree_node n;\n   tree fn;\n@@ -221,14 +219,10 @@ remap_decl (decl, id)\n \n static void\n #ifndef INLINER_FOR_JAVA\n-remap_block (scope_stmt, decls, id)\n-     tree scope_stmt;\n+remap_block (tree scope_stmt, tree decls, inline_data *id)\n #else /* INLINER_FOR_JAVA */\n-remap_block (block, decls, id)\n-     tree *block;\n+remap_block (tree *block, tree decls, inline_data *id)\n #endif /* INLINER_FOR_JAVA */\n-     tree decls;\n-     inline_data *id;\n {\n #ifndef INLINER_FOR_JAVA\n   /* We cannot do this in the cleanup for a TARGET_EXPR since we do\n@@ -389,10 +383,7 @@ remap_block (block, decls, id)\n /* Copy the SCOPE_STMT pointed to by TP.  */\n \n static void\n-copy_scope_stmt (tp, walk_subtrees, id)\n-     tree *tp;\n-     int *walk_subtrees;\n-     inline_data *id;\n+copy_scope_stmt (tree *tp, int *walk_subtrees, inline_data *id)\n {\n   tree block;\n \n@@ -414,10 +405,7 @@ copy_scope_stmt (tp, walk_subtrees, id)\n /* Called from copy_body via walk_tree.  DATA is really an\n    `inline_data *'.  */\n static tree\n-copy_body_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n+copy_body_r (tree *tp, int *walk_subtrees, void *data)\n {\n   inline_data* id;\n   tree fn;\n@@ -610,8 +598,7 @@ copy_body_r (tp, walk_subtrees, data)\n    another function.  */\n \n static tree\n-copy_body (id)\n-     inline_data *id;\n+copy_body (inline_data *id)\n {\n   tree body;\n \n@@ -626,15 +613,9 @@ copy_body (id)\n \n static tree\n #ifndef INLINER_FOR_JAVA\n-initialize_inlined_parameters (id, args, fn)\n+initialize_inlined_parameters (inline_data *id, tree args, tree fn)\n #else /* INLINER_FOR_JAVA */\n-initialize_inlined_parameters (id, args, fn, block)\n-#endif /* INLINER_FOR_JAVA */\n-     inline_data *id;\n-     tree args;\n-     tree fn;\n-#ifdef INLINER_FOR_JAVA\n-     tree block;\n+initialize_inlined_parameters (inline_data *id, tree args, tree fn, tree block)\n #endif /* INLINER_FOR_JAVA */\n {\n   tree init_stmts;\n@@ -823,16 +804,12 @@ initialize_inlined_parameters (id, args, fn, block)\n \n #ifndef INLINER_FOR_JAVA\n static tree\n-declare_return_variable (id, return_slot_addr, use_stmt)\n-     struct inline_data *id;\n-     tree return_slot_addr;\n-     tree *use_stmt;\n+declare_return_variable (struct inline_data *id, tree return_slot_addr,\n+\t\t\t tree *use_stmt)\n #else /* INLINER_FOR_JAVA */\n static tree\n-declare_return_variable (id, return_slot_addr, var)\n-     struct inline_data *id;\n-     tree return_slot_addr;\n-     tree *var;\n+declare_return_variable (struct inline_data *id, tree return_slot_addr,\n+\t\t\t tree *var)\n #endif /* INLINER_FOR_JAVA */\n {\n   tree fn = VARRAY_TOP_TREE (id->fns);\n@@ -901,19 +878,15 @@ declare_return_variable (id, return_slot_addr, var)\n /* Returns nonzero if a function can be inlined as a tree.  */\n \n int\n-tree_inlinable_function_p (fn, nolimit)\n-     tree fn;\n-     int nolimit;\n+tree_inlinable_function_p (tree fn, int nolimit)\n {\n   return inlinable_function_p (fn, NULL, nolimit);\n }\n \n /* If *TP is possibly call to alloca, return nonzero.  */\n static tree\n-find_alloca_call_1 (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+find_alloca_call_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t    void *data ATTRIBUTE_UNUSED)\n {\n   if (alloca_call_p (*tp))\n     return *tp;\n@@ -922,8 +895,7 @@ find_alloca_call_1 (tp, walk_subtrees, data)\n \n /* Return subexpression representing possible alloca call, if any.  */\n static tree\n-find_alloca_call (exp)\n-     tree exp;\n+find_alloca_call (tree exp)\n {\n   location_t saved_loc = input_location;\n   tree ret = walk_tree (&exp, find_alloca_call_1, NULL, NULL);\n@@ -932,10 +904,8 @@ find_alloca_call (exp)\n }\n \n static tree\n-find_builtin_longjmp_call_1 (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+find_builtin_longjmp_call_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t     void *data ATTRIBUTE_UNUSED)\n {\n   tree exp = *tp, decl;\n \n@@ -951,8 +921,7 @@ find_builtin_longjmp_call_1 (tp, walk_subtrees, data)\n }\n \n static tree\n-find_builtin_longjmp_call (exp)\n-     tree exp;\n+find_builtin_longjmp_call (tree exp)\n {\n   location_t saved_loc = input_location;\n   tree ret = walk_tree (&exp, find_builtin_longjmp_call_1, NULL, NULL);\n@@ -965,10 +934,7 @@ find_builtin_longjmp_call (exp)\n    can be inlined at all.  */\n \n static int\n-inlinable_function_p (fn, id, nolimit)\n-     tree fn;\n-     inline_data *id;\n-     int nolimit;\n+inlinable_function_p (tree fn, inline_data *id, int nolimit)\n {\n   int inlinable;\n   int currfn_insns;\n@@ -983,13 +949,13 @@ inlinable_function_p (fn, id, nolimit)\n      inlined.  (It is important that this hook be called early because\n      in C++ it may result in template instantiation.)  */\n   inlinable = !(*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn);\n-       \n+\n   /* We may be here either because fn is declared inline or because\n      we use -finline-functions.  For the second case, we are more\n      restrictive.  */\n   if (DID_INLINE_FUNC (fn))\n     max_inline_insns_single = MAX_INLINE_INSNS_AUTO;\n-\t\n+\n   /* The number of instructions (estimated) of current function.  */\n   currfn_insns = DECL_NUM_STMTS (fn) * INSNS_PER_STMT;\n \n@@ -1098,10 +1064,7 @@ inlinable_function_p (fn, id, nolimit)\n /* If *TP is a CALL_EXPR, replace it with its inline expansion.  */\n \n static tree\n-expand_call_inline (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n+expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n {\n   inline_data *id;\n   tree t;\n@@ -1159,7 +1122,7 @@ expand_call_inline (tp, walk_subtrees, data)\n       *walk_subtrees = 0;\n       /* Update the source position.  */\n       push_srcloc (EXPR_WFL_FILENAME (t), EXPR_WFL_LINENO (t));\n-      walk_tree (&EXPR_WFL_NODE (t), expand_call_inline, data, \n+      walk_tree (&EXPR_WFL_NODE (t), expand_call_inline, data,\n \t\t id->tree_pruner);\n       /* Restore the original source position.  */\n       pop_srcloc ();\n@@ -1461,9 +1424,7 @@ expand_call_inline (tp, walk_subtrees, data)\n    expansions as appropriate.  */\n \n static void\n-expand_calls_inline (tp, id)\n-     tree *tp;\n-     inline_data *id;\n+expand_calls_inline (tree *tp, inline_data *id)\n {\n   /* Search through *TP, replacing all calls to inline functions by\n      appropriate equivalents.  Use walk_tree in no-duplicates mode\n@@ -1477,8 +1438,7 @@ expand_calls_inline (tp, id)\n /* Expand calls to inline functions in the body of FN.  */\n \n void\n-optimize_inline_calls (fn)\n-     tree fn;\n+optimize_inline_calls (tree fn)\n {\n   inline_data id;\n   tree prev_fn;\n@@ -1532,9 +1492,7 @@ optimize_inline_calls (fn)\n    declarations according to the ARG_MAP splay_tree.  */\n \n void\n-clone_body (clone, fn, arg_map)\n-     tree clone, fn;\n-     void *arg_map;\n+clone_body (tree clone, tree fn, void *arg_map)\n {\n   inline_data id;\n \n@@ -1564,11 +1522,7 @@ clone_body (clone, fn, arg_map)\n    once.  */\n \n tree\n-walk_tree (tp, func, data, htab_)\n-     tree *tp;\n-     walk_tree_fn func;\n-     void *data;\n-     void *htab_;\n+walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n {\n   htab_t htab = (htab_t) htab_;\n   enum tree_code code;\n@@ -1814,10 +1768,7 @@ walk_tree (tp, func, data, htab_)\n    once.  */\n \n tree\n-walk_tree_without_duplicates (tp, func, data)\n-     tree *tp;\n-     walk_tree_fn func;\n-     void *data;\n+walk_tree_without_duplicates (tree *tp, walk_tree_fn func, void *data)\n {\n   tree result;\n   htab_t htab;\n@@ -1831,10 +1782,7 @@ walk_tree_without_duplicates (tp, func, data)\n /* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */\n \n tree\n-copy_tree_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data ATTRIBUTE_UNUSED;\n+copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*tp);\n \n@@ -1884,11 +1832,7 @@ copy_tree_r (tp, walk_subtrees, data)\n    ST.  FN is the function into which the copy will be placed.  */\n \n void\n-remap_save_expr (tp, st_, fn, walk_subtrees)\n-     tree *tp;\n-     void *st_;\n-     tree fn;\n-     int *walk_subtrees;\n+remap_save_expr (tree *tp, void *st_, tree fn, int *walk_subtrees)\n {\n   splay_tree st = (splay_tree) st_;\n   splay_tree_node n;\n@@ -1928,8 +1872,7 @@ remap_save_expr (tp, st_, fn, walk_subtrees)\n    COMPOUND_EXPR and add STMT to it.  */\n \n static tree\n-add_stmt_to_compound (existing, type, stmt)\n-     tree existing, type, stmt;\n+add_stmt_to_compound (tree existing, tree type, tree stmt)\n {\n   if (!stmt)\n     return existing;"}, {"sha": "87eebac9803556323850b5d8d08248d56ee49ada", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -1,5 +1,5 @@\n /* Tree inlining hooks and declarations.\n-   Copyright 2001 Free Software Foundation, Inc.\n+   Copyright 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva  <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -24,13 +24,13 @@ Boston, MA 02111-1307, USA.  */\n \n /* Function prototypes.  */\n \n-void optimize_inline_calls PARAMS ((tree));\n-int tree_inlinable_function_p PARAMS ((tree, int));\n-tree walk_tree PARAMS ((tree*, walk_tree_fn, void*, void*));\n-tree walk_tree_without_duplicates PARAMS ((tree*, walk_tree_fn, void*));\n-tree copy_tree_r PARAMS ((tree*, int*, void*));\n-void clone_body PARAMS ((tree, tree, void*));\n-void remap_save_expr PARAMS ((tree*, void*, tree, int*));\n+void optimize_inline_calls (tree);\n+int tree_inlinable_function_p (tree, int);\n+tree walk_tree (tree*, walk_tree_fn, void*, void*);\n+tree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\n+tree copy_tree_r (tree*, int*, void*);\n+void clone_body (tree, tree, void*);\n+void remap_save_expr (tree*, void*, tree, int*);\n \n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level."}, {"sha": "9298247bf56169ade87280c071658a85b7012498", "filename": "gcc/tree.c", "status": "modified", "additions": 172, "deletions": 355, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -47,7 +47,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n \n /* obstack.[ch] explicitly declined to prototype this.  */\n-extern int _obstack_allocated_p PARAMS ((struct obstack *h, void *obj));\n+extern int _obstack_allocated_p (struct obstack *h, void *obj);\n \n #ifdef GATHER_STATISTICS\n /* Statistics-gathering stuff.  */\n@@ -118,22 +118,22 @@ struct type_hash GTY(())\n static GTY ((if_marked (\"type_hash_marked_p\"), param_is (struct type_hash)))\n      htab_t type_hash_table;\n \n-static void set_type_quals PARAMS ((tree, int));\n-static void append_random_chars PARAMS ((char *));\n-static int type_hash_eq PARAMS ((const void *, const void *));\n-static hashval_t type_hash_hash PARAMS ((const void *));\n-static void print_type_hash_statistics PARAMS((void));\n-static void finish_vector_type PARAMS((tree));\n-static tree make_vector PARAMS ((enum machine_mode, tree, int));\n-static int type_hash_marked_p PARAMS ((const void *));\n+static void set_type_quals (tree, int);\n+static void append_random_chars (char *);\n+static int type_hash_eq (const void *, const void *);\n+static hashval_t type_hash_hash (const void *);\n+static void print_type_hash_statistics (void);\n+static void finish_vector_type (tree);\n+static tree make_vector (enum machine_mode, tree, int);\n+static int type_hash_marked_p (const void *);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n \f\n /* Init tree.c.  */\n \n void\n-init_ttree ()\n+init_ttree (void)\n {\n   /* Initialize the hash table of types.  */\n   type_hash_table = htab_create_ggc (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n@@ -145,8 +145,7 @@ init_ttree ()\n    translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n    as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n tree\n-decl_assembler_name (decl)\n-     tree decl;\n+decl_assembler_name (tree decl)\n {\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n     (*lang_hooks.set_decl_assembler_name) (decl);\n@@ -156,8 +155,7 @@ decl_assembler_name (decl)\n /* Compute the number of bytes occupied by 'node'.  This routine only\n    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n size_t\n-tree_size (node)\n-     tree node;\n+tree_size (tree node)\n {\n   enum tree_code code = TREE_CODE (node);\n \n@@ -221,8 +219,7 @@ tree_size (node)\n    Achoo!  I got a code in the node.  */\n \n tree\n-make_node (code)\n-     enum tree_code code;\n+make_node (enum tree_code code)\n {\n   tree t;\n   int type = TREE_CODE_CLASS (code);\n@@ -362,8 +359,7 @@ make_node (code)\n    TREE_CHAIN is zero and it has a fresh uid.  */\n \n tree\n-copy_node (node)\n-     tree node;\n+copy_node (tree node)\n {\n   tree t;\n   enum tree_code code = TREE_CODE (node);\n@@ -397,8 +393,7 @@ copy_node (node)\n    For example, this can copy a list made of TREE_LIST nodes.  */\n \n tree\n-copy_list (list)\n-     tree list;\n+copy_list (tree list)\n {\n   tree head;\n   tree prev, next;\n@@ -425,9 +420,7 @@ copy_list (list)\n    This function should be used via the `build_int_2' macro.  */\n \n tree\n-build_int_2_wide (low, hi)\n-     unsigned HOST_WIDE_INT low;\n-     HOST_WIDE_INT hi;\n+build_int_2_wide (unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n {\n   tree t = make_node (INTEGER_CST);\n \n@@ -441,8 +434,7 @@ build_int_2_wide (low, hi)\n    are in a list pointed by VALS.  */\n \n tree\n-build_vector (type, vals)\n-     tree type, vals;\n+build_vector (tree type, tree vals)\n {\n   tree v = make_node (VECTOR_CST);\n   int over1 = 0, over2 = 0;\n@@ -469,8 +461,7 @@ build_vector (type, vals)\n /* Return a new CONSTRUCTOR node whose type is TYPE and whose values\n    are in a list pointed to by VALS.  */\n tree\n-build_constructor (type, vals)\n-     tree type, vals;\n+build_constructor (tree type, tree vals)\n {\n   tree c = make_node (CONSTRUCTOR);\n   TREE_TYPE (c) = type;\n@@ -492,9 +483,7 @@ build_constructor (type, vals)\n /* Return a new REAL_CST node whose type is TYPE and value is D.  */\n \n tree\n-build_real (type, d)\n-     tree type;\n-     REAL_VALUE_TYPE d;\n+build_real (tree type, REAL_VALUE_TYPE d)\n {\n   tree v;\n   REAL_VALUE_TYPE *dp;\n@@ -517,8 +506,7 @@ build_real (type, d)\n    and whose value is the integer value of the INTEGER_CST node I.  */\n \n REAL_VALUE_TYPE\n-real_value_from_int_cst (type, i)\n-     tree type ATTRIBUTE_UNUSED, i;\n+real_value_from_int_cst (tree type ATTRIBUTE_UNUSED, tree i)\n {\n   REAL_VALUE_TYPE d;\n \n@@ -539,9 +527,7 @@ real_value_from_int_cst (type, i)\n    representing the same value as a floating-point constant of type TYPE.  */\n \n tree\n-build_real_from_int_cst (type, i)\n-     tree type;\n-     tree i;\n+build_real_from_int_cst (tree type, tree i)\n {\n   tree v;\n   int overflow = TREE_OVERFLOW (i);\n@@ -558,9 +544,7 @@ build_real_from_int_cst (type, i)\n    The TREE_TYPE is not initialized.  */\n \n tree\n-build_string (len, str)\n-     int len;\n-     const char *str;\n+build_string (int len, const char *str)\n {\n   tree s = make_node (STRING_CST);\n \n@@ -576,9 +560,7 @@ build_string (len, str)\n    will be the type of the COMPLEX_CST; otherwise a new type will be made.  */\n \n tree\n-build_complex (type, real, imag)\n-     tree type;\n-     tree real, imag;\n+build_complex (tree type, tree real, tree imag)\n {\n   tree t = make_node (COMPLEX_CST);\n \n@@ -594,8 +576,7 @@ build_complex (type, real, imag)\n /* Build a newly constructed TREE_VEC node of length LEN.  */\n \n tree\n-make_tree_vec (len)\n-     int len;\n+make_tree_vec (int len)\n {\n   tree t;\n   int length = (len - 1) * sizeof (tree) + sizeof (struct tree_vec);\n@@ -618,8 +599,7 @@ make_tree_vec (len)\n    of zero.  */\n \n int\n-integer_zerop (expr)\n-     tree expr;\n+integer_zerop (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -636,8 +616,7 @@ integer_zerop (expr)\n    complex constant.  */\n \n int\n-integer_onep (expr)\n-     tree expr;\n+integer_onep (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -654,8 +633,7 @@ integer_onep (expr)\n    it contains.  Likewise for the corresponding complex constant.  */\n \n int\n-integer_all_onesp (expr)\n-     tree expr;\n+integer_all_onesp (tree expr)\n {\n   int prec;\n   int uns;\n@@ -707,8 +685,7 @@ integer_all_onesp (expr)\n    one bit on).  */\n \n int\n-integer_pow2p (expr)\n-     tree expr;\n+integer_pow2p (tree expr)\n {\n   int prec;\n   HOST_WIDE_INT high, low;\n@@ -753,8 +730,7 @@ integer_pow2p (expr)\n    complex constant other than zero.  */\n \n int\n-integer_nonzerop (expr)\n-     tree expr;\n+integer_nonzerop (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -771,8 +747,7 @@ integer_nonzerop (expr)\n    power of two.  */\n \n int\n-tree_log2 (expr)\n-     tree expr;\n+tree_log2 (tree expr)\n {\n   int prec;\n   HOST_WIDE_INT high, low;\n@@ -810,8 +785,7 @@ tree_log2 (expr)\n    than or equal to EXPR.  */\n \n int\n-tree_floor_log2 (expr)\n-     tree expr;\n+tree_floor_log2 (tree expr)\n {\n   int prec;\n   HOST_WIDE_INT high, low;\n@@ -849,8 +823,7 @@ tree_floor_log2 (expr)\n /* Return 1 if EXPR is the real constant zero.  */\n \n int\n-real_zerop (expr)\n-     tree expr;\n+real_zerop (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -865,8 +838,7 @@ real_zerop (expr)\n /* Return 1 if EXPR is the real constant one in real or complex form.  */\n \n int\n-real_onep (expr)\n-     tree expr;\n+real_onep (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -881,8 +853,7 @@ real_onep (expr)\n /* Return 1 if EXPR is the real constant two.  */\n \n int\n-real_twop (expr)\n-     tree expr;\n+real_twop (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -897,8 +868,7 @@ real_twop (expr)\n /* Return 1 if EXPR is the real constant minus one.  */\n \n int\n-real_minus_onep (expr)\n-     tree expr;\n+real_minus_onep (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -913,8 +883,7 @@ real_minus_onep (expr)\n /* Nonzero if EXP is a constant or a cast of a constant.  */\n \n int\n-really_constant_p (exp)\n-     tree exp;\n+really_constant_p (tree exp)\n {\n   /* This is not quite the same as STRIP_NOPS.  It does more.  */\n   while (TREE_CODE (exp) == NOP_EXPR\n@@ -928,8 +897,7 @@ really_constant_p (exp)\n    Return 0 if ELEM is not in LIST.  */\n \n tree\n-value_member (elem, list)\n-     tree elem, list;\n+value_member (tree elem, tree list)\n {\n   while (list)\n     {\n@@ -944,8 +912,7 @@ value_member (elem, list)\n    Return 0 if ELEM is not in LIST.  */\n \n tree\n-purpose_member (elem, list)\n-     tree elem, list;\n+purpose_member (tree elem, tree list)\n {\n   while (list)\n     {\n@@ -960,8 +927,7 @@ purpose_member (elem, list)\n    Return 0 if ELEM is not in LIST.  */\n \n tree\n-binfo_member (elem, list)\n-     tree elem, list;\n+binfo_member (tree elem, tree list)\n {\n   while (list)\n     {\n@@ -975,8 +941,7 @@ binfo_member (elem, list)\n /* Return nonzero if ELEM is part of the chain CHAIN.  */\n \n int\n-chain_member (elem, chain)\n-     tree elem, chain;\n+chain_member (tree elem, tree chain)\n {\n   while (chain)\n     {\n@@ -993,8 +958,7 @@ chain_member (elem, chain)\n    This is the Lisp primitive `length'.  */\n \n int\n-list_length (t)\n-     tree t;\n+list_length (tree t)\n {\n   tree tail;\n   int len = 0;\n@@ -1008,8 +972,7 @@ list_length (t)\n /* Returns the number of FIELD_DECLs in TYPE.  */\n \n int\n-fields_length (type)\n-     tree type;\n+fields_length (tree type)\n {\n   tree t = TYPE_FIELDS (type);\n   int count = 0;\n@@ -1026,8 +989,7 @@ fields_length (type)\n    This is the Lisp primitive `nconc'.  */\n \n tree\n-chainon (op1, op2)\n-     tree op1, op2;\n+chainon (tree op1, tree op2)\n {\n   tree t1;\n \n@@ -1055,8 +1017,7 @@ chainon (op1, op2)\n /* Return the last node in a chain of nodes (chained through TREE_CHAIN).  */\n \n tree\n-tree_last (chain)\n-     tree chain;\n+tree_last (tree chain)\n {\n   tree next;\n   if (chain)\n@@ -1069,8 +1030,7 @@ tree_last (chain)\n    and return the new head of the chain (old last element).  */\n \n tree\n-nreverse (t)\n-     tree t;\n+nreverse (tree t)\n {\n   tree prev = 0, decl, next;\n   for (decl = t; decl; decl = next)\n@@ -1086,8 +1046,7 @@ nreverse (t)\n    purpose and value fields are PARM and VALUE.  */\n \n tree\n-build_tree_list (parm, value)\n-     tree parm, value;\n+build_tree_list (tree parm, tree value)\n {\n   tree t = make_node (TREE_LIST);\n   TREE_PURPOSE (t) = parm;\n@@ -1100,8 +1059,7 @@ build_tree_list (parm, value)\n    and whose TREE_CHAIN is CHAIN.  */\n \n tree\n-tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n+tree_cons (tree purpose, tree value, tree chain)\n {\n   tree node;\n \n@@ -1151,7 +1109,7 @@ int\n expr_length (tree expr)\n {\n   int len = 0;\n-  \n+\n   if (expr == NULL_TREE)\n     return 0;\n   for (; TREE_CODE (expr) == COMPOUND_EXPR; expr = TREE_OPERAND (expr, 1))\n@@ -1167,8 +1125,7 @@ expr_length (tree expr)\n    make_unsigned_type).  */\n \n tree\n-size_in_bytes (type)\n-     tree type;\n+size_in_bytes (tree type)\n {\n   tree t;\n \n@@ -1194,8 +1151,7 @@ size_in_bytes (type)\n    or return -1 if the size can vary or is larger than an integer.  */\n \n HOST_WIDE_INT\n-int_size_in_bytes (type)\n-     tree type;\n+int_size_in_bytes (tree type)\n {\n   tree t;\n \n@@ -1219,8 +1175,7 @@ int_size_in_bytes (type)\n    This is a tree of type bitsizetype.  */\n \n tree\n-bit_position (field)\n-     tree field;\n+bit_position (tree field)\n {\n   return bit_from_pos (DECL_FIELD_OFFSET (field),\n \t\t       DECL_FIELD_BIT_OFFSET (field));\n@@ -1231,8 +1186,7 @@ bit_position (field)\n    of returning -1 like int_size_in_byte can.  */\n \n HOST_WIDE_INT\n-int_bit_position (field)\n-     tree field;\n+int_bit_position (tree field)\n {\n   return tree_low_cst (bit_position (field), 0);\n }\n@@ -1241,8 +1195,7 @@ int_bit_position (field)\n    This is a tree of type sizetype.  */\n \n tree\n-byte_position (field)\n-     tree field;\n+byte_position (tree field)\n {\n   return byte_from_pos (DECL_FIELD_OFFSET (field),\n \t\t\tDECL_FIELD_BIT_OFFSET (field));\n@@ -1253,17 +1206,15 @@ byte_position (field)\n    of returning -1 like int_size_in_byte can.  */\n \n HOST_WIDE_INT\n-int_byte_position (field)\n-     tree field;\n+int_byte_position (tree field)\n {\n   return tree_low_cst (byte_position (field), 0);\n }\n \f\n /* Return the strictest alignment, in bits, that T is known to have.  */\n \n unsigned int\n-expr_align (t)\n-     tree t;\n+expr_align (tree t)\n {\n   unsigned int align0, align1;\n \n@@ -1310,8 +1261,7 @@ expr_align (t)\n    ARRAY_TYPE) minus one. This counts only elements of the top array.  */\n \n tree\n-array_type_nelts (type)\n-     tree type;\n+array_type_nelts (tree type)\n {\n   tree index_type, min, max;\n \n@@ -1333,8 +1283,7 @@ array_type_nelts (type)\n    static storage.  This is not the same as the C meaning of `static'.  */\n \n int\n-staticp (arg)\n-     tree arg;\n+staticp (tree arg)\n {\n   switch (TREE_CODE (arg))\n     {\n@@ -1411,8 +1360,7 @@ staticp (arg)\n    are used for.  */\n \n tree\n-save_expr (expr)\n-     tree expr;\n+save_expr (tree expr)\n {\n   tree t = fold (expr);\n   tree inner;\n@@ -1455,11 +1403,10 @@ save_expr (expr)\n    the innermost non-arithmetic node.  */\n \n tree\n-skip_simple_arithmetic (expr)\n-     tree expr;\n+skip_simple_arithmetic (tree expr)\n {\n   tree inner;\n-  \n+\n   /* We don't care about whether this can be used as an lvalue in this\n      context.  */\n   while (TREE_CODE (expr) == NON_LVALUE_EXPR)\n@@ -1494,8 +1441,7 @@ skip_simple_arithmetic (expr)\n    SAVE_EXPR.  Return FALSE otherwise.  */\n \n bool\n-saved_expr_p (expr)\n-     tree expr;\n+saved_expr_p (tree expr)\n {\n   return TREE_CODE (skip_simple_arithmetic (expr)) == SAVE_EXPR;\n }\n@@ -1505,8 +1451,7 @@ saved_expr_p (expr)\n    expand them multiple times in different places.  */\n \n tree\n-unsave_expr (expr)\n-     tree expr;\n+unsave_expr (tree expr)\n {\n   tree t;\n \n@@ -1523,8 +1468,7 @@ unsave_expr (expr)\n    of operands if all are trees.  */\n \n int\n-first_rtl_op (code)\n-     enum tree_code code;\n+first_rtl_op (enum tree_code code)\n {\n   switch (code)\n     {\n@@ -1545,17 +1489,16 @@ first_rtl_op (code)\n /* Return which tree structure is used by T.  */\n \n enum tree_node_structure_enum\n-tree_node_structure (t)\n-     tree t;\n+tree_node_structure (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n-  \n+\n   switch (TREE_CODE_CLASS (code))\n     {\n     case 'd':\treturn TS_DECL;\n     case 't':\treturn TS_TYPE;\n     case 'b':\treturn TS_BLOCK;\n-    case 'r': case '<': case '1': case '2': case 'e': case 's': \n+    case 'r': case '<': case '1': case '2': case 'e': case 's':\n       return TS_EXP;\n     default:  /* 'c' and 'x' */\n       break;\n@@ -1584,8 +1527,7 @@ tree_node_structure (t)\n    not recurse into EXPR's subtrees.  */\n \n void\n-unsave_expr_1 (expr)\n-     tree expr;\n+unsave_expr_1 (tree expr)\n {\n   switch (TREE_CODE (expr))\n     {\n@@ -1620,8 +1562,7 @@ unsave_expr_1 (expr)\n /* Default lang hook for \"unsave_expr_now\".  */\n \n tree\n-lhd_unsave_expr_now (expr)\n-     tree expr;\n+lhd_unsave_expr_now (tree expr)\n {\n   enum tree_code code;\n \n@@ -1686,8 +1627,7 @@ lhd_unsave_expr_now (expr)\n    never possible to unsave them.  */\n \n int\n-unsafe_for_reeval (expr)\n-     tree expr;\n+unsafe_for_reeval (tree expr)\n {\n   int unsafeness = 0;\n   enum tree_code code;\n@@ -1764,8 +1704,7 @@ unsafe_for_reeval (expr)\n    or offset that depends on a field within a record.  */\n \n bool\n-contains_placeholder_p (exp)\n-     tree exp;\n+contains_placeholder_p (tree exp)\n {\n   enum tree_code code;\n   int result;\n@@ -1856,8 +1795,7 @@ contains_placeholder_p (exp)\n    positions.  */\n \n bool\n-type_contains_placeholder_p (type)\n-     tree type;\n+type_contains_placeholder_p (tree type)\n {\n   /* If the size contains a placeholder or the parent type (component type in\n      the case of arrays) type involves a placeholder, this type does.  */\n@@ -1958,8 +1896,7 @@ type_contains_placeholder_p (type)\n    outer scope to deal with.  Used by fold.  */\n \n int\n-has_cleanups (exp)\n-     tree exp;\n+has_cleanups (tree exp)\n {\n   int i, nops, cmp;\n \n@@ -2020,10 +1957,7 @@ has_cleanups (exp)\n    PLACEHOLDER_EXPR occurring only in its arglist.  */\n \n tree\n-substitute_in_expr (exp, f, r)\n-     tree exp;\n-     tree f;\n-     tree r;\n+substitute_in_expr (tree exp, tree f, tree r)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree op0, op1, op2;\n@@ -2203,8 +2137,7 @@ substitute_in_expr (exp, f, r)\n    Any other kind of expression is returned unchanged.  */\n \n tree\n-stabilize_reference (ref)\n-     tree ref;\n+stabilize_reference (tree ref)\n {\n   tree result;\n   enum tree_code code = TREE_CODE (ref);\n@@ -2301,8 +2234,7 @@ stabilize_reference (ref)\n    multiple utterances of the same expression should that prove fruitful.  */\n \n tree\n-stabilize_reference_1 (e)\n-     tree e;\n+stabilize_reference_1 (tree e)\n {\n   tree result;\n   enum tree_code code = TREE_CODE (e);\n@@ -2474,10 +2406,7 @@ build (enum tree_code code, tree tt, ...)\n    of varargs, which is expensive for RISC machines.  */\n \n tree\n-build1 (code, type, node)\n-     enum tree_code code;\n-     tree type;\n-     tree node;\n+build1 (enum tree_code code, tree type, tree node)\n {\n   int length = sizeof (struct tree_exp);\n #ifdef GATHER_STATISTICS\n@@ -2590,9 +2519,7 @@ build_nt (enum tree_code code, ...)\n    Other slots are initialized to 0 or null pointers.  */\n \n tree\n-build_decl (code, name, type)\n-     enum tree_code code;\n-     tree name, type;\n+build_decl (enum tree_code code, tree name, tree type)\n {\n   tree t;\n \n@@ -2619,8 +2546,8 @@ build_decl (code, name, type)\n    compiled.  This information is used for outputting debugging info.  */\n \n tree\n-build_block (vars, tags, subblocks, supercontext, chain)\n-     tree vars, tags ATTRIBUTE_UNUSED, subblocks, supercontext, chain;\n+build_block (tree vars, tree tags ATTRIBUTE_UNUSED, tree subblocks,\n+\t     tree supercontext, tree chain)\n {\n   tree block = make_node (BLOCK);\n \n@@ -2637,10 +2564,7 @@ build_block (vars, tags, subblocks, supercontext, chain)\n    recursively more than one file (Java is one of them).  */\n \n tree\n-build_expr_wfl (node, file, line, col)\n-     tree node;\n-     const char *file;\n-     int line, col;\n+build_expr_wfl (tree node, const char *file, int line, int col)\n {\n   static const char *last_file = 0;\n   static tree last_filenode = NULL_TREE;\n@@ -2668,8 +2592,7 @@ build_expr_wfl (node, file, line, col)\n    is ATTRIBUTE.  */\n \n tree\n-build_decl_attribute_variant (ddecl, attribute)\n-     tree ddecl, attribute;\n+build_decl_attribute_variant (tree ddecl, tree attribute)\n {\n   DECL_ATTRIBUTES (ddecl) = attribute;\n   return ddecl;\n@@ -2681,8 +2604,7 @@ build_decl_attribute_variant (ddecl, attribute)\n    Record such modified types already made so we don't make duplicates.  */\n \n tree\n-build_type_attribute_variant (ttype, attribute)\n-     tree ttype, attribute;\n+build_type_attribute_variant (tree ttype, tree attribute)\n {\n   if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n@@ -2738,9 +2660,7 @@ build_type_attribute_variant (ttype, attribute)\n    their canonicalized form.  */\n \n int\n-is_attribute_p (attr, ident)\n-     const char *attr;\n-     tree ident;\n+is_attribute_p (const char *attr, tree ident)\n {\n   int ident_len, attr_len;\n   const char *p;\n@@ -2785,9 +2705,7 @@ is_attribute_p (attr, ident)\n    be passed back in if further occurrences are wanted.  */\n \n tree\n-lookup_attribute (attr_name, list)\n-     const char *attr_name;\n-     tree list;\n+lookup_attribute (const char *attr_name, tree list)\n {\n   tree l;\n \n@@ -2805,8 +2723,7 @@ lookup_attribute (attr_name, list)\n /* Return an attribute list that is the union of a1 and a2.  */\n \n tree\n-merge_attributes (a1, a2)\n-     tree a1, a2;\n+merge_attributes (tree a1, tree a2)\n {\n   tree attributes;\n \n@@ -2856,8 +2773,7 @@ merge_attributes (a1, a2)\n   the result.  */\n \n tree\n-merge_type_attributes (t1, t2)\n-     tree t1, t2;\n+merge_type_attributes (tree t1, tree t2)\n {\n   return merge_attributes (TYPE_ATTRIBUTES (t1),\n \t\t\t   TYPE_ATTRIBUTES (t2));\n@@ -2867,8 +2783,7 @@ merge_type_attributes (t1, t2)\n    the result.  */\n \n tree\n-merge_decl_attributes (olddecl, newdecl)\n-     tree olddecl, newdecl;\n+merge_decl_attributes (tree olddecl, tree newdecl)\n {\n   return merge_attributes (DECL_ATTRIBUTES (olddecl),\n \t\t\t   DECL_ATTRIBUTES (newdecl));\n@@ -2886,9 +2801,7 @@ merge_decl_attributes (olddecl, newdecl)\n    The second instance of `foo' nullifies the dllimport.  */\n \n tree\n-merge_dllimport_decl_attributes (old, new)\n-     tree old;\n-     tree new;\n+merge_dllimport_decl_attributes (tree old, tree new)\n {\n   tree a;\n   int delete_dllimport_p;\n@@ -2935,9 +2848,7 @@ merge_dllimport_decl_attributes (old, new)\n    of the various TYPE_QUAL values.  */\n \n static void\n-set_type_quals (type, type_quals)\n-     tree type;\n-     int type_quals;\n+set_type_quals (tree type, int type_quals)\n {\n   TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n   TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n@@ -2949,9 +2860,7 @@ set_type_quals (type, type_quals)\n    return NULL_TREE.  */\n \n tree\n-get_qualified_type (type, type_quals)\n-     tree type;\n-     int type_quals;\n+get_qualified_type (tree type, int type_quals)\n {\n   tree t;\n \n@@ -2970,9 +2879,7 @@ get_qualified_type (type, type_quals)\n    exist.  This function never returns NULL_TREE.  */\n \n tree\n-build_qualified_type (type, type_quals)\n-     tree type;\n-     int type_quals;\n+build_qualified_type (tree type, int type_quals)\n {\n   tree t;\n \n@@ -2993,8 +2900,7 @@ build_qualified_type (type, type_quals)\n    This is so the caller can modify it.  */\n \n tree\n-build_type_copy (type)\n-     tree type;\n+build_type_copy (tree type)\n {\n   tree t, m = TYPE_MAIN_VARIANT (type);\n \n@@ -3018,8 +2924,7 @@ build_type_copy (type)\n    of the individual types.  */\n \n unsigned int\n-type_hash_list (list)\n-     tree list;\n+type_hash_list (tree list)\n {\n   unsigned int hashcode;\n   tree tail;\n@@ -3035,9 +2940,7 @@ type_hash_list (list)\n /* Returns true if the types are equal.  */\n \n static int\n-type_hash_eq (va, vb)\n-     const void *va;\n-     const void *vb;\n+type_hash_eq (const void *va, const void *vb)\n {\n   const struct type_hash *a = va, *b = vb;\n   if (a->hash == b->hash\n@@ -3067,8 +2970,7 @@ type_hash_eq (va, vb)\n /* Return the cached hash value.  */\n \n static hashval_t\n-type_hash_hash (item)\n-     const void *item;\n+type_hash_hash (const void *item)\n {\n   return ((const struct type_hash *) item)->hash;\n }\n@@ -3077,9 +2979,7 @@ type_hash_hash (item)\n    If one is found, return it.  Otherwise return 0.  */\n \n tree\n-type_hash_lookup (hashcode, type)\n-     unsigned int hashcode;\n-     tree type;\n+type_hash_lookup (unsigned int hashcode, tree type)\n {\n   struct type_hash *h, in;\n \n@@ -3100,9 +3000,7 @@ type_hash_lookup (hashcode, type)\n    for a type TYPE whose hash code is HASHCODE.  */\n \n void\n-type_hash_add (hashcode, type)\n-     unsigned int hashcode;\n-     tree type;\n+type_hash_add (unsigned int hashcode, tree type)\n {\n   struct type_hash *h;\n   void **loc;\n@@ -3129,9 +3027,7 @@ type_hash_add (hashcode, type)\n int debug_no_type_hash = 0;\n \n tree\n-type_hash_canon (hashcode, type)\n-     unsigned int hashcode;\n-     tree type;\n+type_hash_canon (unsigned int hashcode, tree type)\n {\n   tree t1;\n \n@@ -3163,16 +3059,15 @@ type_hash_canon (hashcode, type)\n    the number of garbage collections.  */\n \n static int\n-type_hash_marked_p (p)\n-     const void *p;\n+type_hash_marked_p (const void *p)\n {\n   tree type = ((struct type_hash *) p)->type;\n \n   return ggc_marked_p (type) || TYPE_SYMTAB_POINTER (type);\n }\n \n static void\n-print_type_hash_statistics ()\n+print_type_hash_statistics (void)\n {\n   fprintf (stderr, \"Type hash: size %ld, %ld elements, %f collisions\\n\",\n \t   (long) htab_size (type_hash_table),\n@@ -3185,8 +3080,7 @@ print_type_hash_statistics ()\n    by adding the hash codes of the individual attributes.  */\n \n unsigned int\n-attribute_hash_list (list)\n-     tree list;\n+attribute_hash_list (tree list)\n {\n   unsigned int hashcode;\n   tree tail;\n@@ -3201,8 +3095,7 @@ attribute_hash_list (list)\n    equivalent to l1.  */\n \n int\n-attribute_list_equal (l1, l2)\n-     tree l1, l2;\n+attribute_list_equal (tree l1, tree l2)\n {\n   return attribute_list_contained (l1, l2)\n \t && attribute_list_contained (l2, l1);\n@@ -3217,8 +3110,7 @@ attribute_list_equal (l1, l2)\n    correctly.  */\n \n int\n-attribute_list_contained (l1, l2)\n-     tree l1, l2;\n+attribute_list_contained (tree l1, tree l2)\n {\n   tree t1, t2;\n \n@@ -3265,8 +3157,7 @@ attribute_list_contained (l1, l2)\n    Also, the TREE_PURPOSEs must match.  */\n \n int\n-type_list_equal (l1, l2)\n-     tree l1, l2;\n+type_list_equal (tree l1, tree l2)\n {\n   tree t1, t2;\n \n@@ -3286,8 +3177,7 @@ type_list_equal (l1, l2)\n    then this function counts only the ordinary arguments.  */\n \n int\n-type_num_arguments (type)\n-     tree type;\n+type_num_arguments (tree type)\n {\n   int i = 0;\n   tree t;\n@@ -3307,8 +3197,7 @@ type_num_arguments (type)\n    represent the same constant value.  */\n \n int\n-tree_int_cst_equal (t1, t2)\n-     tree t1, t2;\n+tree_int_cst_equal (tree t1, tree t2)\n {\n   if (t1 == t2)\n     return 1;\n@@ -3329,8 +3218,7 @@ tree_int_cst_equal (t1, t2)\n    The precise way of comparison depends on their data type.  */\n \n int\n-tree_int_cst_lt (t1, t2)\n-     tree t1, t2;\n+tree_int_cst_lt (tree t1, tree t2)\n {\n   if (t1 == t2)\n     return 0;\n@@ -3357,9 +3245,7 @@ tree_int_cst_lt (t1, t2)\n /* Returns -1 if T1 < T2, 0 if T1 == T2, and 1 if T1 > T2.  */\n \n int\n-tree_int_cst_compare (t1, t2)\n-     tree t1;\n-     tree t2;\n+tree_int_cst_compare (tree t1, tree t2)\n {\n   if (tree_int_cst_lt (t1, t2))\n     return -1;\n@@ -3375,9 +3261,7 @@ tree_int_cst_compare (t1, t2)\n    be represented in a single unsigned HOST_WIDE_INT.  */\n \n int\n-host_integerp (t, pos)\n-     tree t;\n-     int pos;\n+host_integerp (tree t, int pos)\n {\n   return (TREE_CODE (t) == INTEGER_CST\n \t  && ! TREE_OVERFLOW (t)\n@@ -3394,9 +3278,7 @@ host_integerp (t, pos)\n    be positive.  Abort if we cannot satisfy the above conditions.  */\n \n HOST_WIDE_INT\n-tree_low_cst (t, pos)\n-     tree t;\n-     int pos;\n+tree_low_cst (tree t, int pos)\n {\n   if (host_integerp (t, pos))\n     return TREE_INT_CST_LOW (t);\n@@ -3407,8 +3289,7 @@ tree_low_cst (t, pos)\n /* Return the most significant bit of the integer constant T.  */\n \n int\n-tree_int_cst_msb (t)\n-     tree t;\n+tree_int_cst_msb (tree t)\n {\n   int prec;\n   HOST_WIDE_INT h;\n@@ -3427,8 +3308,7 @@ tree_int_cst_msb (t)\n    Note that -1 will never be returned it T's type is unsigned.  */\n \n int\n-tree_int_cst_sgn (t)\n-     tree t;\n+tree_int_cst_sgn (tree t)\n {\n   if (TREE_INT_CST_LOW (t) == 0 && TREE_INT_CST_HIGH (t) == 0)\n     return 0;\n@@ -3444,8 +3324,7 @@ tree_int_cst_sgn (t)\n    are known to be equal; otherwise return 0.  */\n \n int\n-simple_cst_list_equal (l1, l2)\n-     tree l1, l2;\n+simple_cst_list_equal (tree l1, tree l2)\n {\n   while (l1 != NULL_TREE && l2 != NULL_TREE)\n     {\n@@ -3466,8 +3345,7 @@ simple_cst_list_equal (l1, l2)\n    this function.  */\n \n int\n-simple_cst_equal (t1, t2)\n-     tree t1, t2;\n+simple_cst_equal (tree t1, tree t2)\n {\n   enum tree_code code1, code2;\n   int cmp;\n@@ -3605,9 +3483,7 @@ simple_cst_equal (t1, t2)\n    than U, respectively.  */\n \n int\n-compare_tree_int (t, u)\n-     tree t;\n-     unsigned HOST_WIDE_INT u;\n+compare_tree_int (tree t, unsigned HOST_WIDE_INT u)\n {\n   if (tree_int_cst_sgn (t) < 0)\n     return -1;\n@@ -3722,9 +3598,7 @@ iterative_hash_expr (tree t, hashval_t val)\n    reuse it.  */\n \n tree\n-build_pointer_type_for_mode (to_type, mode)\n-     tree to_type;\n-     enum machine_mode mode;\n+build_pointer_type_for_mode (tree to_type, enum machine_mode mode)\n {\n   tree t = TYPE_POINTER_TO (to_type);\n \n@@ -3752,8 +3626,7 @@ build_pointer_type_for_mode (to_type, mode)\n /* By default build pointers in ptr_mode.  */\n \n tree\n-build_pointer_type (to_type)\n-     tree to_type;\n+build_pointer_type (tree to_type)\n {\n   return build_pointer_type_for_mode (to_type, ptr_mode);\n }\n@@ -3763,9 +3636,7 @@ build_pointer_type (to_type)\n    reuse it.  */\n \n tree\n-build_reference_type_for_mode (to_type, mode)\n-     tree to_type;\n-     enum machine_mode mode;\n+build_reference_type_for_mode (tree to_type, enum machine_mode mode)\n {\n   tree t = TYPE_REFERENCE_TO (to_type);\n \n@@ -3792,8 +3663,7 @@ build_reference_type_for_mode (to_type, mode)\n    in ptr_mode.  */\n \n tree\n-build_reference_type (to_type)\n-     tree to_type;\n+build_reference_type (tree to_type)\n {\n   return build_reference_type_for_mode (to_type, ptr_mode);\n }\n@@ -3804,8 +3674,7 @@ build_reference_type (to_type)\n    const char *const *const *  ->  char ***.  */\n \n tree\n-build_type_no_quals (t)\n-     tree t;\n+build_type_no_quals (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -3828,8 +3697,7 @@ build_type_no_quals (t)\n    sizes that use more than one HOST_WIDE_INT.  */\n \n tree\n-build_index_type (maxval)\n-     tree maxval;\n+build_index_type (tree maxval)\n {\n   tree itype = make_node (INTEGER_TYPE);\n \n@@ -3855,8 +3723,7 @@ build_index_type (maxval)\n    if TYPE==NULL_TREE, sizetype is used.  */\n \n tree\n-build_range_type (type, lowval, highval)\n-     tree type, lowval, highval;\n+build_range_type (tree type, tree lowval, tree highval)\n {\n   tree itype = make_node (INTEGER_TYPE);\n \n@@ -3886,8 +3753,7 @@ build_range_type (type, lowval, highval)\n    of just highval (maxval).  */\n \n tree\n-build_index_2_type (lowval, highval)\n-     tree lowval, highval;\n+build_index_2_type (tree lowval, tree highval)\n {\n   return build_range_type (sizetype, lowval, highval);\n }\n@@ -3897,8 +3763,7 @@ build_index_2_type (lowval, highval)\n    If such a type has already been constructed, reuse it.  */\n \n tree\n-build_array_type (elt_type, index_type)\n-     tree elt_type, index_type;\n+build_array_type (tree elt_type, tree index_type)\n {\n   tree t;\n   unsigned int hashcode;\n@@ -3935,8 +3800,7 @@ build_array_type (elt_type, index_type)\n    the innermost dimension of ARRAY.  */\n \n tree\n-get_inner_array_type (array)\n-     tree array;\n+get_inner_array_type (tree array)\n {\n   tree type = TREE_TYPE (array);\n \n@@ -3954,8 +3818,7 @@ get_inner_array_type (array)\n    If such a type has already been constructed, reuse it.  */\n \n tree\n-build_function_type (value_type, arg_types)\n-     tree value_type, arg_types;\n+build_function_type (tree value_type, tree arg_types)\n {\n   tree t;\n   unsigned int hashcode;\n@@ -4012,8 +3875,7 @@ build_function_type_list (tree return_type, ...)\n    TYPE must be a FUNCTION_TYPE node.  */\n \n tree\n-build_method_type (basetype, type)\n-     tree basetype, type;\n+build_method_type (tree basetype, tree type)\n {\n   tree t;\n   unsigned int hashcode;\n@@ -4049,8 +3911,7 @@ build_method_type (basetype, type)\n    If a suitable offset type exists already, reuse it.  */\n \n tree\n-build_offset_type (basetype, type)\n-     tree basetype, type;\n+build_offset_type (tree basetype, tree type)\n {\n   tree t;\n   unsigned int hashcode;\n@@ -4074,8 +3935,7 @@ build_offset_type (basetype, type)\n /* Create a complex type whose components are COMPONENT_TYPE.  */\n \n tree\n-build_complex_type (component_type)\n-     tree component_type;\n+build_complex_type (tree component_type)\n {\n   tree t;\n   unsigned int hashcode;\n@@ -4155,9 +4015,7 @@ build_complex_type (component_type)\n    is different from (int) OP.  */\n \n tree\n-get_unwidened (op, for_type)\n-     tree op;\n-     tree for_type;\n+get_unwidened (tree op, tree for_type)\n {\n   /* Set UNS initially if converting OP to FOR_TYPE is a zero-extension.  */\n   tree type = TREE_TYPE (op);\n@@ -4247,9 +4105,7 @@ get_unwidened (op, for_type)\n    or 0 if the value should be sign-extended.  */\n \n tree\n-get_narrower (op, unsignedp_ptr)\n-     tree op;\n-     int *unsignedp_ptr;\n+get_narrower (tree op, int *unsignedp_ptr)\n {\n   int uns = 0;\n   int first = 1;\n@@ -4335,19 +4191,18 @@ get_narrower (op, unsignedp_ptr)\n    for type TYPE (an INTEGER_TYPE).  */\n \n int\n-int_fits_type_p (c, type)\n-     tree c, type;\n+int_fits_type_p (tree c, tree type)\n {\n   tree type_low_bound = TYPE_MIN_VALUE (type);\n   tree type_high_bound = TYPE_MAX_VALUE (type);\n   int ok_for_low_bound, ok_for_high_bound;\n-    \n+\n   /* Perform some generic filtering first, which may allow making a decision\n      even if the bounds are not constant.  First, negative integers never fit\n      in unsigned types, */\n   if ((TREE_UNSIGNED (type) && tree_int_cst_sgn (c) < 0)\n       /* Also, unsigned integers with top bit set never fit signed types.  */\n-      || (! TREE_UNSIGNED (type) \n+      || (! TREE_UNSIGNED (type)\n \t  && TREE_UNSIGNED (TREE_TYPE (c)) && tree_int_cst_msb (c)))\n     return 0;\n \n@@ -4363,7 +4218,7 @@ int_fits_type_p (c, type)\n \n   ok_for_low_bound = -1;\n   ok_for_high_bound = -1;\n-    \n+\n   /* Check if C >= type_low_bound.  */\n   if (type_low_bound && TREE_CODE (type_low_bound) == INTEGER_CST)\n     {\n@@ -4388,7 +4243,7 @@ int_fits_type_p (c, type)\n      can check ourselves here. Look at the base type if we have one.  */\n   else if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != 0)\n     return int_fits_type_p (c, TREE_TYPE (type));\n-  \n+\n   /* Or to force_fit_type, if nothing else.  */\n   else\n     {\n@@ -4403,35 +4258,34 @@ int_fits_type_p (c, type)\n    modified types': in C99, a struct type is never variably modified\n    because a VLA may not appear as a structure member.  However, in\n    GNU C code like:\n-    \n+\n      struct S { int i[f()]; };\n \n    is valid, and other languages may define similar constructs.  */\n \n bool\n-variably_modified_type_p (type)\n-     tree type;\n+variably_modified_type_p (tree type)\n {\n   if (type == error_mark_node)\n     return false;\n \n-  /* If TYPE itself has variable size, it is variably modified.  \n+  /* If TYPE itself has variable size, it is variably modified.\n \n      We do not yet have a representation of the C99 '[*]' syntax.\n      When a representation is chosen, this function should be modified\n      to test for that case as well.  */\n-  if (TYPE_SIZE (type) \n+  if (TYPE_SIZE (type)\n       && TYPE_SIZE (type) != error_mark_node\n       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     return true;\n \n-  /* If TYPE is a pointer or reference, it is variably modified if \n+  /* If TYPE is a pointer or reference, it is variably modified if\n      the type pointed to is variably modified.  */\n   if ((TREE_CODE (type) == POINTER_TYPE\n        || TREE_CODE (type) == REFERENCE_TYPE)\n       && variably_modified_type_p (TREE_TYPE (type)))\n     return true;\n-  \n+\n   /* If TYPE is an array, it is variably modified if the array\n      elements are.  (Note that the VLA case has already been checked\n      above.)  */\n@@ -4448,8 +4302,8 @@ variably_modified_type_p (type)\n \n       if (variably_modified_type_p (TREE_TYPE (type)))\n \treturn true;\n-      for (parm = TYPE_ARG_TYPES (type); \n-\t   parm && parm != void_list_node; \n+      for (parm = TYPE_ARG_TYPES (type);\n+\t   parm && parm != void_list_node;\n \t   parm = TREE_CHAIN (parm))\n \tif (variably_modified_type_p (TREE_VALUE (parm)))\n \t  return true;\n@@ -4464,8 +4318,7 @@ variably_modified_type_p (type)\n    NULL_TREE if there is no containing scope.  */\n \n tree\n-get_containing_scope (t)\n-     tree t;\n+get_containing_scope (tree t)\n {\n   return (TYPE_P (t) ? TYPE_CONTEXT (t) : DECL_CONTEXT (t));\n }\n@@ -4474,8 +4327,7 @@ get_containing_scope (t)\n    a FUNCTION_DECL, or zero if none.  */\n \n tree\n-decl_function_context (decl)\n-     tree decl;\n+decl_function_context (tree decl)\n {\n   tree context;\n \n@@ -4514,8 +4366,7 @@ decl_function_context (decl)\n    TYPE_DECLs and FUNCTION_DECLs are transparent to this function.  */\n \n tree\n-decl_type_context (decl)\n-     tree decl;\n+decl_type_context (tree decl)\n {\n   tree context = DECL_CONTEXT (decl);\n \n@@ -4548,8 +4399,7 @@ decl_type_context (decl)\n    determined.  */\n \n tree\n-get_callee_fndecl (call)\n-     tree call;\n+get_callee_fndecl (tree call)\n {\n   tree addr;\n \n@@ -4584,7 +4434,7 @@ get_callee_fndecl (call)\n    and any language-specific information.  */\n \n void\n-dump_tree_statistics ()\n+dump_tree_statistics (void)\n {\n #ifdef GATHER_STATISTICS\n   int i;\n@@ -4624,17 +4474,17 @@ default_flag_random_seed (void)\n {\n   unsigned HOST_WIDE_INT value;\n   char *new_random_seed;\n-  \n+\n   if (flag_random_seed != NULL)\n     return;\n \n   /* Get some more or less random data.  */\n #ifdef HAVE_GETTIMEOFDAY\n  {\n    struct timeval tv;\n-   \n+\n    gettimeofday (&tv, NULL);\n-   value = (((unsigned HOST_WIDE_INT) tv.tv_usec << 16) \n+   value = (((unsigned HOST_WIDE_INT) tv.tv_usec << 16)\n \t    ^ tv.tv_sec ^ getpid ());\n  }\n #else\n@@ -4653,8 +4503,7 @@ default_flag_random_seed (void)\n    Derived from mkstemp.c in libiberty.  */\n \n static void\n-append_random_chars (template)\n-     char *template;\n+append_random_chars (char *template)\n {\n   static const char letters[]\n     = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n@@ -4663,7 +4512,7 @@ append_random_chars (template)\n \n   default_flag_random_seed ();\n \n-  /* This isn't a very good hash, but it does guarantee no collisions \n+  /* This isn't a very good hash, but it does guarantee no collisions\n      when the random string is generated by the code above and the time\n      delta is small.  */\n   v = 0;\n@@ -4692,8 +4541,7 @@ append_random_chars (template)\n    that are not valid in that context.  */\n \n void\n-clean_symbol_name (p)\n-     char *p;\n+clean_symbol_name (char *p)\n {\n   for (; *p; p++)\n     if (! (ISALNUM (*p)\n@@ -4712,8 +4560,7 @@ clean_symbol_name (p)\n    linker or collect2.  */\n \n tree\n-get_file_function_name_long (type)\n-     const char *type;\n+get_file_function_name_long (const char *type)\n {\n   char *buf;\n   const char *p;\n@@ -4761,8 +4608,7 @@ get_file_function_name_long (type)\n    If KIND=='D', return a suitable global clean-up (destructor) name.  */\n \n tree\n-get_file_function_name (kind)\n-     int kind;\n+get_file_function_name (int kind)\n {\n   char p[2];\n \n@@ -4780,10 +4626,7 @@ get_file_function_name (kind)\n    Otherwise, a TREE_LIST of the non-constant elements is emitted.  */\n \n tree\n-get_set_constructor_bits (init, buffer, bit_size)\n-     tree init;\n-     char *buffer;\n-     int bit_size;\n+get_set_constructor_bits (tree init, char *buffer, int bit_size)\n {\n   int i;\n   tree vals;\n@@ -4838,10 +4681,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n    Otherwise, a TREE_LIST of the non-constant elements is emitted.  */\n \n tree\n-get_set_constructor_bytes (init, buffer, wd_size)\n-     tree init;\n-     unsigned char *buffer;\n-     int wd_size;\n+get_set_constructor_bytes (tree init, unsigned char *buffer, int wd_size)\n {\n   int i;\n   int set_word_size = BITS_PER_UNIT;\n@@ -4875,12 +4715,8 @@ get_set_constructor_bytes (init, buffer, wd_size)\n    FILE, LINE, and FUNCTION are of the caller.  */\n \n void\n-tree_check_failed (node, code, file, line, function)\n-     const tree node;\n-     enum tree_code code;\n-     const char *file;\n-     int line;\n-     const char *function;\n+tree_check_failed (const tree node, enum tree_code code, const char *file,\n+\t\t   int line, const char *function)\n {\n   internal_error (\"tree check: expected %s, have %s in %s, at %s:%d\",\n \t\t  tree_code_name[code], tree_code_name[TREE_CODE (node)],\n@@ -4891,12 +4727,8 @@ tree_check_failed (node, code, file, line, function)\n    code, given in CL.  */\n \n void\n-tree_class_check_failed (node, cl, file, line, function)\n-     const tree node;\n-     int cl;\n-     const char *file;\n-     int line;\n-     const char *function;\n+tree_class_check_failed (const tree node, int cl, const char *file,\n+\t\t\t int line, const char *function)\n {\n   internal_error\n     (\"tree check: expected class '%c', have '%c' (%s) in %s, at %s:%d\",\n@@ -4908,12 +4740,8 @@ tree_class_check_failed (node, cl, file, line, function)\n    (dynamically sized) vector.  */\n \n void\n-tree_vec_elt_check_failed (idx, len, file, line, function)\n-     int idx;\n-     int len;\n-     const char *file;\n-     int line;\n-     const char *function;\n+tree_vec_elt_check_failed (int idx, int len, const char *file, int line,\n+\t\t\t   const char *function)\n {\n   internal_error\n     (\"tree check: accessed elt %d of tree_vec with %d elts in %s, at %s:%d\",\n@@ -4924,12 +4752,8 @@ tree_vec_elt_check_failed (idx, len, file, line, function)\n    vector of an expression node.  */\n \n void\n-tree_operand_check_failed (idx, code, file, line, function)\n-     int idx;\n-     enum tree_code code;\n-     const char *file;\n-     int line;\n-     const char *function;\n+tree_operand_check_failed (int idx, enum tree_code code, const char *file,\n+\t\t\t   int line, const char *function)\n {\n   internal_error\n     (\"tree check: accessed operand %d of %s with %d operands in %s, at %s:%d\",\n@@ -4942,8 +4766,7 @@ tree_operand_check_failed (idx, code, file, line, function)\n    debugging output.  */\n \n static void\n-finish_vector_type (t)\n-     tree t;\n+finish_vector_type (tree t)\n {\n   layout_type (t);\n \n@@ -4970,8 +4793,7 @@ finish_vector_type (t)\n    this function to select one of the types as sizetype.  */\n \n void\n-build_common_tree_nodes (signed_char)\n-     int signed_char;\n+build_common_tree_nodes (int signed_char)\n {\n   error_mark_node = make_node (ERROR_MARK);\n   TREE_TYPE (error_mark_node) = error_mark_node;\n@@ -5015,8 +4837,7 @@ build_common_tree_nodes (signed_char)\n    It will create several other common tree nodes.  */\n \n void\n-build_common_tree_nodes_2 (short_double)\n-     int short_double;\n+build_common_tree_nodes_2 (int short_double)\n {\n   /* Define these next since types below may used them.  */\n   integer_zero_node = build_int_2 (0, 0);\n@@ -5129,10 +4950,7 @@ build_common_tree_nodes_2 (short_double)\n    the signness.  */\n \n static tree\n-make_vector (mode, innertype, unsignedp)\n-     enum machine_mode mode;\n-     tree innertype;\n-     int unsignedp;\n+make_vector (enum machine_mode mode, tree innertype, int unsignedp)\n {\n   tree t;\n \n@@ -5149,8 +4967,7 @@ make_vector (mode, innertype, unsignedp)\n    aggregate of zeros.  Otherwise return FALSE.  */\n \n bool\n-initializer_zerop (init)\n-     tree init;\n+initializer_zerop (tree init)\n {\n   STRIP_NOPS (init);\n "}, {"sha": "2ca31dd5725bac8c323e2fc34abb29a88562964b", "filename": "gcc/tree.h", "status": "modified", "additions": 392, "deletions": 428, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c5ad278b15d1db509093032ea1eed00459b3a0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=46c5ad278b15d1db509093032ea1eed00459b3a0", "patch": "@@ -165,7 +165,7 @@ struct tree_common GTY(())\n    addressable_flag:\n \n        TREE_ADDRESSABLE in\n-   \t   VAR_DECL, FUNCTION_DECL, FIELD_DECL, CONSTRUCTOR, LABEL_DECL,\n+\t   VAR_DECL, FUNCTION_DECL, FIELD_DECL, CONSTRUCTOR, LABEL_DECL,\n \t   ..._TYPE, IDENTIFIER_NODE.\n \t   In a STMT_EXPR, it means we want the result of the enclosed\n \t   expression.\n@@ -337,20 +337,20 @@ struct tree_common GTY(())\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n-extern void tree_check_failed PARAMS ((const tree, enum tree_code,\n-\t\t\t\t       const char *, int, const char *))\n+extern void tree_check_failed (const tree, enum tree_code,\n+\t\t\t       const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void tree_class_check_failed PARAMS ((const tree, int,\n-\t\t\t\t\t     const char *, int, const char *))\n+extern void tree_class_check_failed (const tree, int,\n+\t\t\t\t     const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void tree_vec_elt_check_failed PARAMS ((int, int, const char *,\n-\t\t\t\t\t       int, const char *))\n+extern void tree_vec_elt_check_failed (int, int, const char *,\n+\t\t\t\t       int, const char *)\n     ATTRIBUTE_NORETURN;\n \n-extern void tree_operand_check_failed PARAMS ((int, enum tree_code,\n-\t\t\t\t\t       const char *, int, const char *))\n+extern void tree_operand_check_failed (int, enum tree_code,\n+\t\t\t\t       const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n-    \n+\n #else /* not ENABLE_TREE_CHECKING, or not gcc */\n \n #define TREE_CHECK(T, CODE)\t\t(T)\n@@ -658,7 +658,7 @@ extern void tree_operand_check_failed PARAMS ((int, enum tree_code,\n    || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n \t== (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n        && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n- \n+\n struct tree_int_cst GTY(())\n {\n   struct tree_common common;\n@@ -832,8 +832,8 @@ struct tree_exp GTY(())\n {\n   struct tree_common common;\n   int complexity;\n-  tree GTY ((special (\"tree_exp\"), \n-\t     desc (\"TREE_CODE ((tree) &%0)\"))) \n+  tree GTY ((special (\"tree_exp\"),\n+\t     desc (\"TREE_CODE ((tree) &%0)\")))\n     operands[1];\n };\n \f\n@@ -1098,10 +1098,10 @@ struct tree_type GTY(())\n   tree pointer_to;\n   tree reference_to;\n   union tree_type_symtab {\n-    int GTY ((tag (\"0\"))) address; \n-    char * GTY ((tag (\"1\"))) pointer; \n+    int GTY ((tag (\"0\"))) address;\n+    char * GTY ((tag (\"1\"))) pointer;\n     struct die_struct * GTY ((tag (\"2\"))) die;\n-  } GTY ((desc (\"debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0\"), \n+  } GTY ((desc (\"debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0\"),\n \t  descbits (\"2\"))) symtab;\n   tree name;\n   tree minval;\n@@ -1667,7 +1667,7 @@ struct tree_decl GTY(())\n     /* DECL_ALIGN and DECL_OFFSET_ALIGN.  (These are not used for\n        FUNCTION_DECLs).  */\n     struct tree_decl_u1_a {\n-      unsigned int align : 24; \n+      unsigned int align : 24;\n       unsigned int off_align : 8;\n     } a;\n   } GTY ((skip (\"\"))) u1;\n@@ -1999,120 +1999,120 @@ enum ptrmemfunc_vbit_where_t\n \f\n #define NULL_TREE (tree) NULL\n \n-extern tree decl_assembler_name\t\tPARAMS ((tree));\n+extern tree decl_assembler_name (tree);\n \n /* Compute the number of bytes occupied by 'node'.  This routine only\n    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n \n-extern size_t tree_size\t\t\tPARAMS ((tree));\n+extern size_t tree_size (tree);\n \n /* Lowest level primitive for allocating a node.\n    The TREE_CODE is the only argument.  Contents are initialized\n    to zero except for a few of the common fields.  */\n \n-extern tree make_node\t\t\tPARAMS ((enum tree_code));\n+extern tree make_node (enum tree_code);\n \n /* Make a copy of a node, with all the same contents.  */\n \n-extern tree copy_node\t\t\tPARAMS ((tree));\n+extern tree copy_node (tree);\n \n /* Make a copy of a chain of TREE_LIST nodes.  */\n \n-extern tree copy_list\t\t\tPARAMS ((tree));\n+extern tree copy_list (tree);\n \n /* Make a TREE_VEC.  */\n \n-extern tree make_tree_vec\t\tPARAMS ((int));\n+extern tree make_tree_vec (int);\n \n /* Return the (unique) IDENTIFIER_NODE node for a given name.\n    The name is supplied as a char *.  */\n \n-extern tree get_identifier\t\tPARAMS ((const char *));\n+extern tree get_identifier (const char *);\n \n /* Identical to get_identifier, except that the length is assumed\n    known.  */\n \n-extern tree get_identifier_with_length  PARAMS ((const char *, unsigned int));\n+extern tree get_identifier_with_length (const char *, unsigned int);\n \n /* If an identifier with the name TEXT (a null-terminated string) has\n    previously been referred to, return that node; otherwise return\n    NULL_TREE.  */\n \n-extern tree maybe_get_identifier\tPARAMS ((const char *));\n+extern tree maybe_get_identifier (const char *);\n \n /* Construct various types of nodes.  */\n \n #define build_int_2(LO, HI)  \\\n   build_int_2_wide ((unsigned HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))\n \n-extern tree build\t\t\tPARAMS ((enum tree_code, tree, ...));\n-extern tree build_nt\t\t\tPARAMS ((enum tree_code, ...));\n-\n-extern tree build_int_2_wide\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT));\n-extern tree build_vector                PARAMS ((tree, tree));\n-extern tree build_constructor\t\tPARAMS ((tree, tree));\n-extern tree build_real_from_int_cst \tPARAMS ((tree, tree));\n-extern tree build_complex\t\tPARAMS ((tree, tree, tree));\n-extern tree build_string\t\tPARAMS ((int, const char *));\n-extern tree build1\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree build_tree_list\t\tPARAMS ((tree, tree));\n-extern tree build_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree build_block\t\t\tPARAMS ((tree, tree, tree, tree, tree));\n-extern tree build_expr_wfl              PARAMS ((tree, const char *, int, int));\n+extern tree build (enum tree_code, tree, ...);\n+extern tree build_nt (enum tree_code, ...);\n+\n+extern tree build_int_2_wide (unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n+extern tree build_vector (tree, tree);\n+extern tree build_constructor (tree, tree);\n+extern tree build_real_from_int_cst (tree, tree);\n+extern tree build_complex (tree, tree, tree);\n+extern tree build_string (int, const char *);\n+extern tree build1 (enum tree_code, tree, tree);\n+extern tree build_tree_list (tree, tree);\n+extern tree build_decl (enum tree_code, tree, tree);\n+extern tree build_block (tree, tree, tree, tree, tree);\n+extern tree build_expr_wfl (tree, const char *, int, int);\n \n /* Construct various nodes representing data types.  */\n \n-extern tree make_signed_type\t\tPARAMS ((int));\n-extern tree make_unsigned_type\t\tPARAMS ((int));\n-extern void initialize_sizetypes\tPARAMS ((void));\n-extern void set_sizetype\t\tPARAMS ((tree));\n-extern void fixup_unsigned_type\t\tPARAMS ((tree));\n-extern tree build_pointer_type_for_mode PARAMS ((tree, enum machine_mode));\n-extern tree build_pointer_type\t\tPARAMS ((tree));\n-extern tree build_reference_type_for_mode PARAMS ((tree, enum machine_mode));\n-extern tree build_reference_type \tPARAMS ((tree));\n-extern tree build_type_no_quals \tPARAMS ((tree));\n-extern tree build_index_type\t\tPARAMS ((tree));\n-extern tree build_index_2_type\t\tPARAMS ((tree, tree));\n-extern tree build_array_type\t\tPARAMS ((tree, tree));\n-extern tree build_function_type\t\tPARAMS ((tree, tree));\n-extern tree build_function_type_list\tPARAMS ((tree, ...));\n-extern tree build_method_type\t\tPARAMS ((tree, tree));\n-extern tree build_offset_type\t\tPARAMS ((tree, tree));\n-extern tree build_complex_type\t\tPARAMS ((tree));\n-extern tree array_type_nelts\t\tPARAMS ((tree));\n-\n-extern tree value_member\t\tPARAMS ((tree, tree));\n-extern tree purpose_member\t\tPARAMS ((tree, tree));\n-extern tree binfo_member\t\tPARAMS ((tree, tree));\n-extern unsigned int attribute_hash_list\tPARAMS ((tree));\n-extern int attribute_list_equal\t\tPARAMS ((tree, tree));\n-extern int attribute_list_contained\tPARAMS ((tree, tree));\n-extern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\n-extern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\n-extern int tree_int_cst_compare         PARAMS ((tree, tree));\n-extern int host_integerp\t\tPARAMS ((tree, int));\n-extern HOST_WIDE_INT tree_low_cst\tPARAMS ((tree, int));\n-extern int tree_int_cst_msb\t\tPARAMS ((tree));\n-extern int tree_int_cst_sgn\t\tPARAMS ((tree));\n-extern int tree_expr_nonnegative_p\tPARAMS ((tree));\n-extern int rtl_expr_nonnegative_p\tPARAMS ((rtx));\n-extern tree get_inner_array_type\tPARAMS ((tree));\n+extern tree make_signed_type (int);\n+extern tree make_unsigned_type (int);\n+extern void initialize_sizetypes (void);\n+extern void set_sizetype (tree);\n+extern void fixup_unsigned_type (tree);\n+extern tree build_pointer_type_for_mode (tree, enum machine_mode);\n+extern tree build_pointer_type (tree);\n+extern tree build_reference_type_for_mode (tree, enum machine_mode);\n+extern tree build_reference_type (tree);\n+extern tree build_type_no_quals (tree);\n+extern tree build_index_type (tree);\n+extern tree build_index_2_type (tree, tree);\n+extern tree build_array_type (tree, tree);\n+extern tree build_function_type (tree, tree);\n+extern tree build_function_type_list (tree, ...);\n+extern tree build_method_type (tree, tree);\n+extern tree build_offset_type (tree, tree);\n+extern tree build_complex_type (tree);\n+extern tree array_type_nelts (tree);\n+\n+extern tree value_member (tree, tree);\n+extern tree purpose_member (tree, tree);\n+extern tree binfo_member (tree, tree);\n+extern unsigned int attribute_hash_list (tree);\n+extern int attribute_list_equal (tree, tree);\n+extern int attribute_list_contained (tree, tree);\n+extern int tree_int_cst_equal (tree, tree);\n+extern int tree_int_cst_lt (tree, tree);\n+extern int tree_int_cst_compare (tree, tree);\n+extern int host_integerp (tree, int);\n+extern HOST_WIDE_INT tree_low_cst (tree, int);\n+extern int tree_int_cst_msb (tree);\n+extern int tree_int_cst_sgn (tree);\n+extern int tree_expr_nonnegative_p (tree);\n+extern int rtl_expr_nonnegative_p (rtx);\n+extern tree get_inner_array_type (tree);\n \n /* From expmed.c.  Since rtl.h is included after tree.h, we can't\n    put the prototype here.  Rtl.h does declare the prototype if\n    tree.h had been included.  */\n \n-extern tree make_tree\t\t\tPARAMS ((tree, rtx));\n+extern tree make_tree (tree, rtx);\n \f\n /* Return a type like TTYPE except that its TYPE_ATTRIBUTES\n    is ATTRIBUTE.\n \n    Such modified types already made are recorded so that duplicates\n    are not made.  */\n \n-extern tree build_type_attribute_variant PARAMS ((tree, tree));\n-extern tree build_decl_attribute_variant PARAMS ((tree, tree));\n+extern tree build_type_attribute_variant (tree, tree);\n+extern tree build_decl_attribute_variant (tree, tree);\n \n /* Structure describing an attribute and a function to handle it.  */\n struct attribute_spec\n@@ -2155,8 +2155,8 @@ struct attribute_spec\n      otherwise the return value should be NULL_TREE.  This pointer may be\n      NULL if no special handling is required beyond the checks implied\n      by the rest of this structure.  */\n-  tree (*const handler) PARAMS ((tree *node, tree name, tree args,\n-\t\t\t\t int flags, bool *no_add_attrs));\n+  tree (*const handler) (tree *node, tree name, tree args,\n+\t\t\t\t int flags, bool *no_add_attrs);\n };\n \n /* Flags that may be passed in the third argument of decl_attributes, and\n@@ -2186,9 +2186,9 @@ enum attribute_flags\n \n /* Default versions of target-overridable functions.  */\n \n-extern tree merge_decl_attributes PARAMS ((tree, tree));\n-extern tree merge_type_attributes PARAMS ((tree, tree));\n-extern void default_register_cpp_builtins PARAMS ((struct cpp_reader *));\n+extern tree merge_decl_attributes (tree, tree);\n+extern tree merge_type_attributes (tree, tree);\n+extern void default_register_cpp_builtins (struct cpp_reader *);\n \n /* Split a list of declspecs and attributes into two.  */\n \n@@ -2200,38 +2200,38 @@ extern tree strip_attrs (tree);\n \n /* Return 1 if an attribute and its arguments are valid for a decl or type.  */\n \n-extern int valid_machine_attribute\tPARAMS ((tree, tree, tree, tree));\n+extern int valid_machine_attribute (tree, tree, tree, tree);\n \n /* Given a tree node and a string, return nonzero if the tree node is\n    a valid attribute name for the string.  */\n \n-extern int is_attribute_p\t\tPARAMS ((const char *, tree));\n+extern int is_attribute_p (const char *, tree);\n \n /* Given an attribute name and a list of attributes, return the list element\n    of the attribute or NULL_TREE if not found.  */\n \n-extern tree lookup_attribute\t\tPARAMS ((const char *, tree));\n+extern tree lookup_attribute (const char *, tree);\n \n /* Given two attributes lists, return a list of their union.  */\n \n-extern tree merge_attributes\t\tPARAMS ((tree, tree));\n+extern tree merge_attributes (tree, tree);\n \n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n /* Given two Windows decl attributes lists, possibly including\n    dllimport, return a list of their union .  */\n-extern tree merge_dllimport_decl_attributes PARAMS ((tree, tree));\n+extern tree merge_dllimport_decl_attributes (tree, tree);\n #endif\n \n /* Return a version of the TYPE, qualified as indicated by the\n    TYPE_QUALS, if one exists.  If no qualified version exists yet,\n    return NULL_TREE.  */\n \n-extern tree get_qualified_type          PARAMS ((tree, int));\n+extern tree get_qualified_type (tree, int);\n \n /* Like get_qualified_type, but creates the type if it does not\n    exist.  This function never returns NULL_TREE.  */\n \n-extern tree build_qualified_type        PARAMS ((tree, int));\n+extern tree build_qualified_type (tree, int);\n \n /* Like build_qualified_type, but only deals with the `const' and\n    `volatile' qualifiers.  This interface is retained for backwards\n@@ -2245,19 +2245,19 @@ extern tree build_qualified_type        PARAMS ((tree, int));\n \n /* Make a copy of a type node.  */\n \n-extern tree build_type_copy\t\tPARAMS ((tree));\n+extern tree build_type_copy (tree);\n \n /* Finish up a builtin RECORD_TYPE. Give it a name and provide its\n    fields. Optionally specify an alignment, and then lsy it out.  */\n \n-extern void finish_builtin_struct\t\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t\t tree, tree));\n+extern void finish_builtin_struct (tree, const char *,\n+\t\t\t\t\t\t\t tree, tree);\n \n /* Given a ..._TYPE node, calculate the TYPE_SIZE, TYPE_SIZE_UNIT,\n    TYPE_ALIGN and TYPE_MODE fields.  If called more than once on one\n    node, does nothing except for the first time.  */\n \n-extern void layout_type\t\t\tPARAMS ((tree));\n+extern void layout_type (tree);\n \n /* These functions allow a front-end to perform a manual layout of a\n    RECORD_TYPE.  (For instance, if the placement of subsequent fields\n@@ -2294,28 +2294,25 @@ typedef struct record_layout_info_s\n   int packed_maybe_necessary;\n } *record_layout_info;\n \n-extern void set_lang_adjust_rli\t\tPARAMS ((void (*) PARAMS\n-\t\t\t\t\t\t ((record_layout_info))));\n-extern record_layout_info start_record_layout PARAMS ((tree));\n-extern tree bit_from_pos\t\tPARAMS ((tree, tree));\n-extern tree byte_from_pos\t\tPARAMS ((tree, tree));\n-extern void pos_from_bit\t\tPARAMS ((tree *, tree *, unsigned int,\n-\t\t\t\t\t\t tree));\n-extern void normalize_offset\t\tPARAMS ((tree *, tree *,\n-\t\t\t\t\t\t unsigned int));\n-extern tree rli_size_unit_so_far\tPARAMS ((record_layout_info));\n-extern tree rli_size_so_far\t\tPARAMS ((record_layout_info));\n-extern void normalize_rli\t\tPARAMS ((record_layout_info));\n-extern void place_field\t\t\tPARAMS ((record_layout_info, tree));\n-extern void compute_record_mode\t\tPARAMS ((tree));\n-extern void finish_record_layout\tPARAMS ((record_layout_info, int));\n+extern void set_lang_adjust_rli (void (*) (record_layout_info));\n+extern record_layout_info start_record_layout (tree);\n+extern tree bit_from_pos (tree, tree);\n+extern tree byte_from_pos (tree, tree);\n+extern void pos_from_bit (tree *, tree *, unsigned int, tree);\n+extern void normalize_offset (tree *, tree *, unsigned int);\n+extern tree rli_size_unit_so_far (record_layout_info);\n+extern tree rli_size_so_far (record_layout_info);\n+extern void normalize_rli (record_layout_info);\n+extern void place_field (record_layout_info, tree);\n+extern void compute_record_mode (tree);\n+extern void finish_record_layout (record_layout_info, int);\n \n /* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n    return a canonicalized ..._TYPE node, so that duplicates are not made.\n    How the hash code is computed is up to the caller, as long as any two\n    callers that could hash identical-looking type nodes agree.  */\n \n-extern tree type_hash_canon\t\tPARAMS ((unsigned int, tree));\n+extern tree type_hash_canon (unsigned int, tree);\n \n /* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n    calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n@@ -2325,32 +2322,31 @@ extern tree type_hash_canon\t\tPARAMS ((unsigned int, tree));\n    be starting at (in bits).  Zero means it can be assumed aligned\n    on any boundary that may be needed.  */\n \n-extern void layout_decl\t\t\tPARAMS ((tree, unsigned));\n+extern void layout_decl (tree, unsigned);\n \n /* Return the mode for data of a given size SIZE and mode class CLASS.\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  This is like\n    mode_for_size, but is passed a tree.  */\n \n-extern enum machine_mode mode_for_size_tree PARAMS ((tree, enum mode_class,\n-\t\t\t\t\t\t     int));\n+extern enum machine_mode mode_for_size_tree (tree, enum mode_class, int);\n \n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n-extern tree non_lvalue\t\t\tPARAMS ((tree));\n-extern tree pedantic_non_lvalue\t\tPARAMS ((tree));\n-\n-extern tree convert\t\t\tPARAMS ((tree, tree));\n-extern unsigned int expr_align\t\tPARAMS ((tree));\n-extern tree expr_first\t\t\tPARAMS ((tree));\n-extern tree expr_last\t\t\tPARAMS ((tree));\n-extern int expr_length\t\t\tPARAMS ((tree));\n-extern tree size_in_bytes\t\tPARAMS ((tree));\n-extern HOST_WIDE_INT int_size_in_bytes\tPARAMS ((tree));\n-extern tree bit_position\t\tPARAMS ((tree));\n-extern HOST_WIDE_INT int_bit_position\tPARAMS ((tree));\n-extern tree byte_position\t\tPARAMS ((tree));\n-extern HOST_WIDE_INT int_byte_position\tPARAMS ((tree));\n+extern tree non_lvalue (tree);\n+extern tree pedantic_non_lvalue (tree);\n+\n+extern tree convert (tree, tree);\n+extern unsigned int expr_align (tree);\n+extern tree expr_first (tree);\n+extern tree expr_last (tree);\n+extern int expr_length (tree);\n+extern tree size_in_bytes (tree);\n+extern HOST_WIDE_INT int_size_in_bytes (tree);\n+extern tree bit_position (tree);\n+extern HOST_WIDE_INT int_bit_position (tree);\n+extern tree byte_position (tree);\n+extern HOST_WIDE_INT int_byte_position (tree);\n \n /* Define data structures, macros, and functions for handling sizes\n    and the various types used to represent sizes.  */\n@@ -2374,24 +2370,23 @@ extern GTY(()) tree sizetype_tab[(int) TYPE_KIND_LAST];\n #define sbitsizetype sizetype_tab[(int) SBITSIZETYPE]\n #define ubitsizetype sizetype_tab[(int) UBITSIZETYPE]\n \n-extern tree size_binop\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree size_diffop\t\t\tPARAMS ((tree, tree));\n-extern tree size_int_wide\t\tPARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t\t enum size_type_kind));\n-extern tree size_int_type_wide\t\tPARAMS ((HOST_WIDE_INT, tree));\n+extern tree size_binop (enum tree_code, tree, tree);\n+extern tree size_diffop (tree, tree);\n+extern tree size_int_wide (HOST_WIDE_INT, enum size_type_kind);\n+extern tree size_int_type_wide (HOST_WIDE_INT, tree);\n \n #define size_int_type(L, T) size_int_type_wide ((HOST_WIDE_INT) (L), T)\n #define size_int(L) size_int_wide ((HOST_WIDE_INT) (L), SIZETYPE)\n #define ssize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SSIZETYPE)\n #define bitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), BITSIZETYPE)\n #define sbitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SBITSIZETYPE)\n \n-extern tree round_up\t\t\tPARAMS ((tree, int));\n-extern tree round_down\t\t\tPARAMS ((tree, int));\n-extern tree get_pending_sizes\t\tPARAMS ((void));\n-extern int is_pending_size\t\tPARAMS ((tree));\n-extern void put_pending_size\t\tPARAMS ((tree));\n-extern void put_pending_sizes\t\tPARAMS ((tree));\n+extern tree round_up (tree, int);\n+extern tree round_down (tree, int);\n+extern tree get_pending_sizes (void);\n+extern int is_pending_size (tree);\n+extern void put_pending_size (tree);\n+extern void put_pending_sizes (tree);\n \n /* Type for sizes of data-type.  */\n \n@@ -2410,115 +2405,115 @@ extern unsigned int set_alignment;\n    by making the last node in X point to Y.\n    Returns X, except if X is 0 returns Y.  */\n \n-extern tree chainon\t\t\tPARAMS ((tree, tree));\n+extern tree chainon (tree, tree);\n \n /* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n \n-extern tree tree_cons\t\t\tPARAMS ((tree, tree, tree));\n+extern tree tree_cons (tree, tree, tree);\n \n /* Return the last tree node in a chain.  */\n \n-extern tree tree_last\t\t\tPARAMS ((tree));\n+extern tree tree_last (tree);\n \n /* Reverse the order of elements in a chain, and return the new head.  */\n \n-extern tree nreverse\t\t\tPARAMS ((tree));\n+extern tree nreverse (tree);\n \n /* Returns the length of a chain of nodes\n    (number of chain pointers to follow before reaching a null pointer).  */\n \n-extern int list_length\t\t\tPARAMS ((tree));\n+extern int list_length (tree);\n \n /* Returns the number of FIELD_DECLs in a type.  */\n \n-extern int fields_length\t\tPARAMS ((tree));\n+extern int fields_length (tree);\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some\n    aggregate of zeros.  Otherwise return FALSE.  */\n \n-extern bool initializer_zerop\t\tPARAMS ((tree));\n+extern bool initializer_zerop (tree);\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0 */\n \n-extern int integer_zerop\t\tPARAMS ((tree));\n+extern int integer_zerop (tree);\n \n /* integer_onep (tree x) is nonzero if X is an integer constant of value 1 */\n \n-extern int integer_onep\t\t\tPARAMS ((tree));\n+extern int integer_onep (tree);\n \n /* integer_all_onesp (tree x) is nonzero if X is an integer constant\n    all of whose significant bits are 1.  */\n \n-extern int integer_all_onesp\t\tPARAMS ((tree));\n+extern int integer_all_onesp (tree);\n \n /* integer_pow2p (tree x) is nonzero is X is an integer constant with\n    exactly one bit 1.  */\n \n-extern int integer_pow2p\t\tPARAMS ((tree));\n+extern int integer_pow2p (tree);\n \n /* integer_nonzerop (tree x) is nonzero if X is an integer constant\n    with a nonzero value.  */\n \n-extern int integer_nonzerop\t\tPARAMS ((tree));\n+extern int integer_nonzerop (tree);\n \n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  */\n \n-extern int staticp\t\t\tPARAMS ((tree));\n+extern int staticp (tree);\n \n /* Gets an error if argument X is not an lvalue.\n    Also returns 1 if X is an lvalue, 0 if not.  */\n \n-extern int lvalue_or_else\t\tPARAMS ((tree, const char *));\n+extern int lvalue_or_else (tree, const char *);\n \n /* save_expr (EXP) returns an expression equivalent to EXP\n    but it can be used multiple times within context CTX\n    and only evaluate EXP once.  */\n \n-extern tree save_expr\t\t\tPARAMS ((tree));\n+extern tree save_expr (tree);\n \n /* Look inside EXPR and into any simple arithmetic operations.  Return\n    the innermost non-arithmetic node.  */\n \n-extern tree skip_simple_arithmetic\tPARAMS ((tree));\n+extern tree skip_simple_arithmetic (tree);\n \n /* Return TRUE if EXPR is a SAVE_EXPR or wraps simple arithmetic around a\n    SAVE_EXPR.  Return FALSE otherwise.  */\n \n-extern bool saved_expr_p                PARAMS ((tree));\n+extern bool saved_expr_p (tree);\n \n /* Returns the index of the first non-tree operand for CODE, or the number\n    of operands if all are trees.  */\n \n-extern int first_rtl_op\t\t\tPARAMS ((enum tree_code));\n+extern int first_rtl_op (enum tree_code);\n \n /* Return which tree structure is used by T.  */\n \n-enum tree_node_structure_enum tree_node_structure PARAMS ((tree));\n+enum tree_node_structure_enum tree_node_structure (tree);\n \n /* unsave_expr (EXP) returns an expression equivalent to EXP but it\n    can be used multiple times and will evaluate EXP in its entirety\n    each time.  */\n \n-extern tree unsave_expr\t\t\tPARAMS ((tree));\n+extern tree unsave_expr (tree);\n \n /* Reset EXP in place so that it can be expanded again.  Does not\n    recurse into subtrees.  */\n \n-extern void unsave_expr_1               PARAMS ((tree));\n+extern void unsave_expr_1 (tree);\n \n /* Return 0 if it is safe to evaluate EXPR multiple times,\n    return 1 if it is safe if EXPR is unsaved afterward, or\n    return 2 if it is completely unsafe.  */\n-extern int unsafe_for_reeval\t\tPARAMS ((tree));\n+extern int unsafe_for_reeval (tree);\n \n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.\n \n    Note that we only allow such expressions within simple arithmetic\n    or a COND_EXPR.  */\n \n-extern bool contains_placeholder_p\tPARAMS ((tree));\n+extern bool contains_placeholder_p (tree);\n \n /* This macro calls the above function but short-circuits the common\n    case of a constant to save time.  Also check for null.  */\n@@ -2530,89 +2525,87 @@ extern bool contains_placeholder_p\tPARAMS ((tree));\n    This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and field\n    positions.  */\n \n-extern bool type_contains_placeholder_p\tPARAMS ((tree));\n+extern bool type_contains_placeholder_p (tree);\n \n /* Return 1 if EXP contains any expressions that produce cleanups for an\n    outer scope to deal with.  Used by fold.  */\n \n-extern int has_cleanups\t\t\tPARAMS ((tree));\n+extern int has_cleanups (tree);\n \n /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n    return a tree with all occurrences of references to F in a\n    PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n    contains only arithmetic expressions.  */\n \n-extern tree substitute_in_expr\t\tPARAMS ((tree, tree, tree));\n+extern tree substitute_in_expr (tree, tree, tree);\n \n /* variable_size (EXP) is like save_expr (EXP) except that it\n    is for the special case of something that is part of a\n    variable size for a data type.  It makes special arrangements\n    to compute the value at the right time when the data type\n    belongs to a function parameter.  */\n \n-extern tree variable_size\t\tPARAMS ((tree));\n+extern tree variable_size (tree);\n \n /* stabilize_reference (EXP) returns an reference equivalent to EXP\n    but it can be used multiple times\n    and only evaluate the subexpressions once.  */\n \n-extern tree stabilize_reference\t\tPARAMS ((tree));\n+extern tree stabilize_reference (tree);\n \n /* Subroutine of stabilize_reference; this is called for subtrees of\n    references.  Any expression with side-effects must be put in a SAVE_EXPR\n    to ensure that it is only evaluated once.  */\n \n-extern tree stabilize_reference_1\tPARAMS ((tree));\n+extern tree stabilize_reference_1 (tree);\n \n /* Return EXP, stripped of any conversions to wider types\n    in such a way that the result of converting to type FOR_TYPE\n    is the same as if EXP were converted to FOR_TYPE.\n    If FOR_TYPE is 0, it signifies EXP's type.  */\n \n-extern tree get_unwidened\t\tPARAMS ((tree, tree));\n+extern tree get_unwidened (tree, tree);\n \n /* Return OP or a simpler expression for a narrower value\n    which can be sign-extended or zero-extended to give back OP.\n    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended\n    or 0 if the value should be sign-extended.  */\n \n-extern tree get_narrower\t\tPARAMS ((tree, int *));\n+extern tree get_narrower (tree, int *);\n \n /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n    look for nested component-refs or array-refs at constant positions\n    and find the ultimate containing object, which is returned.  */\n \n-extern tree get_inner_reference\t\tPARAMS ((tree, HOST_WIDE_INT *,\n-\t\t\t\t\t\t HOST_WIDE_INT *, tree *,\n-\t\t\t\t\t\t enum machine_mode *, int *,\n-\t\t\t\t\t\t int *));\n+extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t tree *, enum machine_mode *, int *, int *);\n \n /* Return 1 if T is an expression that get_inner_reference handles.  */\n \n-extern int handled_component_p\t\tPARAMS ((tree));\n+extern int handled_component_p (tree);\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */\n \n-extern tree get_containing_scope        PARAMS ((tree));\n+extern tree get_containing_scope (tree);\n \n /* Return the FUNCTION_DECL which provides this _DECL with its context,\n    or zero if none.  */\n-extern tree decl_function_context \tPARAMS ((tree));\n+extern tree decl_function_context (tree);\n \n /* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides\n    this _DECL with its context, or zero if none.  */\n-extern tree decl_type_context\t\tPARAMS ((tree));\n+extern tree decl_type_context (tree);\n \n /* Given the FUNCTION_DECL for the current function,\n    return zero if it is ok for this function to be inline.\n    Otherwise return a warning message with a single %s\n    for the function's name.  */\n \n-extern const char *function_cannot_inline_p \tPARAMS ((tree));\n+extern const char *function_cannot_inline_p (tree);\n \n /* Return 1 if EXPR is the real constant zero.  */\n-extern int real_zerop PARAMS ((tree));\n+extern int real_zerop (tree);\n \f\n /* Declare commonly used variables for tree structure.  */\n \n@@ -2643,80 +2636,70 @@ extern tree poplevel (int, int, int);\n \n /* Declare a predefined function.  Return the declaration.  This function is\n    provided by each language frontend.  */\n-extern tree builtin_function\t\tPARAMS ((const char *, tree, int,\n-\t\t\t\t\t       enum built_in_class,\n-\t\t\t\t\t       const char *, tree));\n+extern tree builtin_function (const char *, tree, int, enum built_in_class,\n+\t\t\t      const char *, tree);\n \f\n /* In tree.c */\n-extern void clean_symbol_name\t\t\tPARAMS ((char *));\n-extern tree get_file_function_name_long \tPARAMS ((const char *));\n-extern tree get_set_constructor_bits\t\tPARAMS ((tree, char *, int));\n-extern tree get_set_constructor_bytes\t\tPARAMS ((tree,\n-\t\t\t\t\t\t       unsigned char *, int));\n-extern tree get_callee_fndecl                   PARAMS ((tree));\n-extern void set_decl_assembler_name             PARAMS ((tree));\n-extern int type_num_arguments                   PARAMS ((tree));\n-extern tree lhd_unsave_expr_now\t\tPARAMS ((tree));\n+extern void clean_symbol_name (char *);\n+extern tree get_file_function_name_long (const char *);\n+extern tree get_set_constructor_bits (tree, char *, int);\n+extern tree get_set_constructor_bytes (tree, unsigned char *, int);\n+extern tree get_callee_fndecl (tree);\n+extern void set_decl_assembler_name (tree);\n+extern int type_num_arguments (tree);\n+extern tree lhd_unsave_expr_now (tree);\n \n \f\n /* In stmt.c */\n \n-extern void expand_fixups\t\t\tPARAMS ((rtx));\n-extern tree expand_start_stmt_expr\t\tPARAMS ((int));\n-extern tree expand_end_stmt_expr\t\tPARAMS ((tree));\n-extern void expand_expr_stmt\t\t\tPARAMS ((tree));\n-extern void expand_expr_stmt_value\t\tPARAMS ((tree, int, int));\n-extern int warn_if_unused_value\t\t\tPARAMS ((tree));\n-extern void expand_decl_init\t\t\tPARAMS ((tree));\n-extern void clear_last_expr\t\t\tPARAMS ((void));\n-extern void expand_label\t\t\tPARAMS ((tree));\n-extern void expand_goto\t\t\t\tPARAMS ((tree));\n-extern void expand_asm\t\t\t\tPARAMS ((tree, int));\n-extern void expand_start_cond\t\t\tPARAMS ((tree, int));\n-extern void expand_end_cond\t\t\tPARAMS ((void));\n-extern void expand_start_else\t\t\tPARAMS ((void));\n-extern void expand_start_elseif\t\t\tPARAMS ((tree));\n-extern struct nesting *expand_start_loop \tPARAMS ((int));\n-extern struct nesting *expand_start_loop_continue_elsewhere \tPARAMS ((int));\n-extern struct nesting *expand_start_null_loop \tPARAMS ((void));\n-extern void expand_loop_continue_here\t\tPARAMS ((void));\n-extern void expand_end_loop\t\t\tPARAMS ((void));\n-extern void expand_end_null_loop\t\tPARAMS ((void));\n-extern int expand_continue_loop\t\t\tPARAMS ((struct nesting *));\n-extern int expand_exit_loop\t\t\tPARAMS ((struct nesting *));\n-extern int expand_exit_loop_if_false\t\tPARAMS ((struct nesting *,\n-\t\t\t\t\t\t         tree));\n-extern int expand_exit_loop_top_cond\t\tPARAMS ((struct nesting *,\n-\t\t\t\t\t\t\t tree));\n-extern int expand_exit_something\t\tPARAMS ((void));\n-\n-extern void expand_return\t\t\tPARAMS ((tree));\n-extern int optimize_tail_recursion\t\tPARAMS ((tree, rtx));\n-extern void expand_start_bindings_and_block     PARAMS ((int, tree));\n+extern void expand_fixups (rtx);\n+extern tree expand_start_stmt_expr (int);\n+extern tree expand_end_stmt_expr (tree);\n+extern void expand_expr_stmt (tree);\n+extern void expand_expr_stmt_value (tree, int, int);\n+extern int warn_if_unused_value (tree);\n+extern void expand_decl_init (tree);\n+extern void clear_last_expr (void);\n+extern void expand_label (tree);\n+extern void expand_goto (tree);\n+extern void expand_asm (tree, int);\n+extern void expand_start_cond (tree, int);\n+extern void expand_end_cond (void);\n+extern void expand_start_else (void);\n+extern void expand_start_elseif (tree);\n+extern struct nesting *expand_start_loop (int);\n+extern struct nesting *expand_start_loop_continue_elsewhere (int);\n+extern struct nesting *expand_start_null_loop (void);\n+extern void expand_loop_continue_here (void);\n+extern void expand_end_loop (void);\n+extern void expand_end_null_loop (void);\n+extern int expand_continue_loop (struct nesting *);\n+extern int expand_exit_loop (struct nesting *);\n+extern int expand_exit_loop_if_false (struct nesting *,tree);\n+extern int expand_exit_loop_top_cond (struct nesting *, tree);\n+extern int expand_exit_something (void);\n+\n+extern void expand_return (tree);\n+extern int optimize_tail_recursion (tree, rtx);\n+extern void expand_start_bindings_and_block (int, tree);\n #define expand_start_bindings(flags) \\\n   expand_start_bindings_and_block(flags, NULL_TREE)\n-extern void expand_end_bindings\t\t\tPARAMS ((tree, int, int));\n-extern void warn_about_unused_variables         PARAMS ((tree));\n-extern void start_cleanup_deferral\t\tPARAMS ((void));\n-extern void end_cleanup_deferral\t\tPARAMS ((void));\n-extern int is_body_block\t\t\tPARAMS ((tree));\n-\n-extern int conditional_context\t\t\tPARAMS ((void));\n-extern struct nesting * current_nesting_level\tPARAMS ((void));\n-extern tree last_cleanup_this_contour\t\tPARAMS ((void));\n-extern void expand_start_case\t\t\tPARAMS ((int, tree, tree,\n-\t\t\t\t\t\t       const char *));\n-extern void expand_end_case_type\t\tPARAMS ((tree, tree));\n+extern void expand_end_bindings (tree, int, int);\n+extern void warn_about_unused_variables (tree);\n+extern void start_cleanup_deferral (void);\n+extern void end_cleanup_deferral (void);\n+extern int is_body_block (tree);\n+\n+extern int conditional_context (void);\n+extern struct nesting * current_nesting_level (void);\n+extern tree last_cleanup_this_contour (void);\n+extern void expand_start_case (int, tree, tree, const char *);\n+extern void expand_end_case_type (tree, tree);\n #define expand_end_case(cond) expand_end_case_type (cond, NULL)\n-extern int add_case_node                        PARAMS ((tree, tree,\n-\t\t\t\t\t\t\t tree, tree *));\n-extern int pushcase\t\t\t\tPARAMS ((tree,\n-\t\t\t\t\t\t       tree (*) (tree, tree),\n-\t\t\t\t\t\t       tree, tree *));\n-extern int pushcase_range\t\t\tPARAMS ((tree, tree,\n-\t\t\t\t\t\t       tree (*) (tree, tree),\n-\t\t\t\t\t\t       tree, tree *));\n-extern void using_eh_for_cleanups\t\tPARAMS ((void));\n+extern int add_case_node (tree, tree, tree, tree *);\n+extern int pushcase (tree, tree (*) (tree, tree), tree, tree *);\n+extern int pushcase_range (tree, tree, tree (*) (tree, tree), tree, tree *);\n+extern void using_eh_for_cleanups (void);\n \n /* In fold-const.c */\n \n@@ -2726,154 +2709,136 @@ extern void using_eh_for_cleanups\t\tPARAMS ((void));\n    if the argument itself cannot be simplified, its\n    subexpressions are not changed.  */\n \n-extern tree fold\t\tPARAMS ((tree));\n-extern tree fold_single_bit_test\n-  PARAMS ((enum tree_code, tree, tree, tree));\n-\n-extern int force_fit_type\tPARAMS ((tree, int));\n-extern int add_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *));\n-extern int neg_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *));\n-extern int mul_double\t\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT,\n-\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *));\n-extern void lshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *, int));\n-extern void rshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *, int));\n-extern void lrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *));\n-extern void rrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *));\n-\n-extern int div_and_round_double\t\tPARAMS ((enum tree_code, int,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t\t HOST_WIDE_INT *,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t\t HOST_WIDE_INT *));\n-\n-extern int operand_equal_p\tPARAMS ((tree, tree, int));\n-extern tree omit_one_operand\tPARAMS ((tree, tree, tree));\n-extern tree invert_truthvalue\tPARAMS ((tree));\n+extern tree fold (tree);\n+extern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n+\n+extern int force_fit_type (tree, int);\n+extern int add_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern int mul_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, unsigned int,\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);\n+extern void rshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, unsigned int,\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);\n+extern void lrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t    HOST_WIDE_INT, unsigned int,\n+\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern void rrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t    HOST_WIDE_INT, unsigned int,\n+\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+\n+extern int div_and_round_double (enum tree_code, int, unsigned HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,\n+\t\t\t\t HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n+\t\t\t\t HOST_WIDE_INT *);\n+\n+extern int operand_equal_p (tree, tree, int);\n+extern tree omit_one_operand (tree, tree, tree);\n+extern tree invert_truthvalue (tree);\n \n /* In builtins.c */\n-extern tree fold_builtin\t\t\t\tPARAMS ((tree));\n-extern enum built_in_function builtin_mathfn_code\tPARAMS ((tree));\n-extern tree build_function_call_expr\t\t\tPARAMS ((tree, tree));\n-extern tree mathfn_built_in\t\t\t\tPARAMS ((tree, enum built_in_function fn));\n+extern tree fold_builtin (tree);\n+extern enum built_in_function builtin_mathfn_code (tree);\n+extern tree build_function_call_expr (tree, tree);\n+extern tree mathfn_built_in (tree, enum built_in_function fn);\n \n /* In convert.c */\n-extern tree strip_float_extensions\t\t\tPARAMS ((tree));\n+extern tree strip_float_extensions (tree);\n \n /* In alias.c */\n-extern void record_component_aliases\t\tPARAMS ((tree));\n-extern HOST_WIDE_INT get_alias_set\t\tPARAMS ((tree));\n-extern int alias_sets_conflict_p\t\tPARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n-extern int readonly_fields_p\t\t\tPARAMS ((tree));\n-extern int objects_must_conflict_p\t\tPARAMS ((tree, tree));\n+extern void record_component_aliases (tree);\n+extern HOST_WIDE_INT get_alias_set (tree);\n+extern int alias_sets_conflict_p (HOST_WIDE_INT, HOST_WIDE_INT);\n+extern int readonly_fields_p (tree);\n+extern int objects_must_conflict_p (tree, tree);\n \n /* In tree.c */\n-extern int really_constant_p\t\tPARAMS ((tree));\n-extern int int_fits_type_p\t\tPARAMS ((tree, tree));\n-extern bool variably_modified_type_p    PARAMS ((tree));\n-extern int tree_log2\t\t\tPARAMS ((tree));\n-extern int tree_floor_log2\t\tPARAMS ((tree));\n-extern int simple_cst_equal\t\tPARAMS ((tree, tree));\n-extern unsigned int iterative_hash_expr\tPARAMS ((tree, unsigned int));\n-extern int compare_tree_int\t\tPARAMS ((tree,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-extern int type_list_equal\t\tPARAMS ((tree, tree));\n-extern int chain_member\t\t\tPARAMS ((tree, tree));\n-extern tree type_hash_lookup\t\tPARAMS ((unsigned int, tree));\n-extern void type_hash_add\t\tPARAMS ((unsigned int, tree));\n-extern unsigned int type_hash_list\tPARAMS ((tree));\n-extern int simple_cst_list_equal\tPARAMS ((tree, tree));\n-extern void dump_tree_statistics\tPARAMS ((void));\n-extern void expand_function_end\t\tPARAMS ((void));\n-extern void expand_function_start\tPARAMS ((tree, int));\n-extern void expand_pending_sizes        PARAMS ((tree));\n-\n-extern int real_onep\t\t\tPARAMS ((tree));\n-extern int real_twop\t\t\tPARAMS ((tree));\n-extern int real_minus_onep\t\tPARAMS ((tree));\n-extern void init_ttree\t\t\tPARAMS ((void));\n-extern void build_common_tree_nodes\tPARAMS ((int));\n-extern void build_common_tree_nodes_2\tPARAMS ((int));\n-extern tree build_range_type\t\tPARAMS ((tree, tree, tree));\n+extern int really_constant_p (tree);\n+extern int int_fits_type_p (tree, tree);\n+extern bool variably_modified_type_p (tree);\n+extern int tree_log2 (tree);\n+extern int tree_floor_log2 (tree);\n+extern int simple_cst_equal (tree, tree);\n+extern unsigned int iterative_hash_expr (tree, unsigned int);\n+extern int compare_tree_int (tree, unsigned HOST_WIDE_INT);\n+extern int type_list_equal (tree, tree);\n+extern int chain_member (tree, tree);\n+extern tree type_hash_lookup (unsigned int, tree);\n+extern void type_hash_add (unsigned int, tree);\n+extern unsigned int type_hash_list (tree);\n+extern int simple_cst_list_equal (tree, tree);\n+extern void dump_tree_statistics (void);\n+extern void expand_function_end (void);\n+extern void expand_function_start (tree, int);\n+extern void expand_pending_sizes (tree);\n+\n+extern int real_onep (tree);\n+extern int real_twop (tree);\n+extern int real_minus_onep (tree);\n+extern void init_ttree (void);\n+extern void build_common_tree_nodes (int);\n+extern void build_common_tree_nodes_2 (int);\n+extern tree build_range_type (tree, tree, tree);\n \n /* In function.c */\n-extern void setjmp_protect_args\t\tPARAMS ((void));\n-extern void setjmp_protect\t\tPARAMS ((tree));\n-extern void expand_main_function\tPARAMS ((void));\n-extern void init_dummy_function_start\tPARAMS ((void));\n-extern void expand_dummy_function_end\tPARAMS ((void));\n-extern void init_function_for_compilation\tPARAMS ((void));\n-extern void init_function_start\t\tPARAMS ((tree));\n-extern void assign_parms\t\tPARAMS ((tree));\n-extern void put_var_into_stack\t\tPARAMS ((tree, int));\n-extern void flush_addressof\t\tPARAMS ((tree));\n-extern void uninitialized_vars_warning\tPARAMS ((tree));\n-extern void setjmp_args_warning\t\tPARAMS ((void));\n-extern void mark_all_temps_used\t\tPARAMS ((void));\n-extern void init_temp_slots\t\tPARAMS ((void));\n-extern void combine_temp_slots\t\tPARAMS ((void));\n-extern void free_temp_slots\t\tPARAMS ((void));\n-extern void pop_temp_slots\t\tPARAMS ((void));\n-extern void push_temp_slots\t\tPARAMS ((void));\n-extern void preserve_temp_slots\t\tPARAMS ((rtx));\n-extern void preserve_rtl_expr_temps\tPARAMS ((tree));\n-extern int aggregate_value_p\t\tPARAMS ((tree));\n-extern void free_temps_for_rtl_expr\tPARAMS ((tree));\n-extern void instantiate_virtual_regs\tPARAMS ((tree, rtx));\n-extern void unshare_all_rtl\t\tPARAMS ((tree, rtx));\n-extern void push_function_context\tPARAMS ((void));\n-extern void pop_function_context\tPARAMS ((void));\n-extern void push_function_context_to\tPARAMS ((tree));\n-extern void pop_function_context_from\tPARAMS ((tree));\n+extern void setjmp_protect_args (void);\n+extern void setjmp_protect (tree);\n+extern void expand_main_function (void);\n+extern void init_dummy_function_start (void);\n+extern void expand_dummy_function_end (void);\n+extern void init_function_for_compilation (void);\n+extern void init_function_start (tree);\n+extern void assign_parms (tree);\n+extern void put_var_into_stack (tree, int);\n+extern void flush_addressof (tree);\n+extern void uninitialized_vars_warning (tree);\n+extern void setjmp_args_warning (void);\n+extern void mark_all_temps_used (void);\n+extern void init_temp_slots (void);\n+extern void combine_temp_slots (void);\n+extern void free_temp_slots (void);\n+extern void pop_temp_slots (void);\n+extern void push_temp_slots (void);\n+extern void preserve_temp_slots (rtx);\n+extern void preserve_rtl_expr_temps (tree);\n+extern int aggregate_value_p (tree);\n+extern void free_temps_for_rtl_expr (tree);\n+extern void instantiate_virtual_regs (tree, rtx);\n+extern void unshare_all_rtl (tree, rtx);\n+extern void push_function_context (void);\n+extern void pop_function_context (void);\n+extern void push_function_context_to (tree);\n+extern void pop_function_context_from (tree);\n \n /* In print-rtl.c */\n #ifdef BUFSIZ\n-extern void print_rtl\t\t\tPARAMS ((FILE *, rtx));\n+extern void print_rtl (FILE *, rtx);\n #endif\n \n /* In print-tree.c */\n-extern void debug_tree\t\t\tPARAMS ((tree));\n+extern void debug_tree (tree);\n #ifdef BUFSIZ\n-extern void print_node\t\t\tPARAMS ((FILE *, const char *, tree,\n-\t\t\t\t\t\t int));\n-extern void print_node_brief\t\tPARAMS ((FILE *, const char *, tree,\n-\t\t\t\t\t\t int));\n-extern void indent_to\t\t\tPARAMS ((FILE *, int));\n+extern void print_node (FILE *, const char *, tree, int);\n+extern void print_node_brief (FILE *, const char *, tree, int);\n+extern void indent_to (FILE *, int);\n #endif\n \n /* In expr.c */\n-extern int apply_args_register_offset\t\tPARAMS ((int));\n-extern rtx expand_builtin_return_addr\n-\tPARAMS ((enum built_in_function, int, rtx));\n-extern void check_max_integer_computation_mode\tPARAMS ((tree));\n+extern int apply_args_register_offset (int);\n+extern rtx expand_builtin_return_addr (enum built_in_function, int, rtx);\n+extern void check_max_integer_computation_mode (tree);\n \n /* In emit-rtl.c */\n-extern void start_sequence_for_rtl_expr\t\tPARAMS ((tree));\n-extern rtx emit_line_note\t\tPARAMS ((const char *, int));\n+extern void start_sequence_for_rtl_expr (tree);\n+extern rtx emit_line_note (const char *, int);\n \n /* In calls.c */\n \n@@ -2906,10 +2871,10 @@ extern rtx emit_line_note\t\tPARAMS ((const char *, int));\n /* Create libcall block around the call.  */\n #define ECF_LIBCALL_BLOCK\t4096\n \n-extern int flags_from_decl_or_type\tPARAMS ((tree));\n+extern int flags_from_decl_or_type (tree);\n \n-extern int setjmp_call_p\t\tPARAMS ((tree));\n-extern bool alloca_call_p\t\tPARAMS ((tree));\n+extern int setjmp_call_p (tree);\n+extern bool alloca_call_p (tree);\n \n /* In attribs.c.  */\n \n@@ -2924,88 +2889,87 @@ extern bool alloca_call_p\t\tPARAMS ((tree));\n extern tree decl_attributes (tree *, tree, int);\n \n /* In integrate.c */\n-extern void save_for_inline\t\tPARAMS ((tree));\n-extern void set_decl_abstract_flags\tPARAMS ((tree, int));\n-extern void output_inline_function\tPARAMS ((tree));\n-extern void set_decl_origin_self\tPARAMS ((tree));\n+extern void save_for_inline (tree);\n+extern void set_decl_abstract_flags (tree, int);\n+extern void output_inline_function (tree);\n+extern void set_decl_origin_self (tree);\n \n /* In stor-layout.c */\n-extern void fixup_signed_type\t\tPARAMS ((tree));\n-extern void internal_reference_types \tPARAMS ((void));\n+extern void fixup_signed_type (tree);\n+extern void internal_reference_types (void);\n \n /* varasm.c */\n-extern void make_decl_rtl\t\tPARAMS ((tree, const char *));\n-extern void make_decl_one_only\t\tPARAMS ((tree));\n-extern int supports_one_only\t\tPARAMS ((void));\n-extern void variable_section\t\tPARAMS ((tree, int));\n-enum tls_model decl_tls_model\t\tPARAMS ((tree));\n-enum symbol_visibility decl_visibility\tPARAMS ((tree));\n-extern void resolve_unique_section\tPARAMS ((tree, int, int));\n-extern void mark_referenced\tPARAMS ((tree));\n+extern void make_decl_rtl (tree, const char *);\n+extern void make_decl_one_only (tree);\n+extern int supports_one_only (void);\n+extern void variable_section (tree, int);\n+enum tls_model decl_tls_model (tree);\n+enum symbol_visibility decl_visibility (tree);\n+extern void resolve_unique_section (tree, int, int);\n+extern void mark_referenced (tree);\n \n /* In stmt.c */\n-extern void emit_nop\t\t\tPARAMS ((void));\n-extern void expand_computed_goto\tPARAMS ((tree));\n-extern bool parse_output_constraint     PARAMS ((const char **,\n-\t\t\t\t\t\t int, int, int,\n-\t\t\t\t\t\t bool *, bool *, bool *));\n-extern void expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int,\n-\t\t\t\t\t\t const char *, int));\n+extern void emit_nop (void);\n+extern void expand_computed_goto (tree);\n+extern bool parse_output_constraint (const char **, int, int, int,\n+\t\t\t\t     bool *, bool *, bool *);\n+extern void expand_asm_operands (tree, tree, tree, tree, int,\n+\t\t\t\t const char *, int);\n extern tree resolve_asm_operand_names (tree, tree, tree);\n-extern int any_pending_cleanups\t\tPARAMS ((void));\n-extern void init_stmt_for_function\tPARAMS ((void));\n-extern void expand_start_target_temps\tPARAMS ((void));\n-extern void expand_end_target_temps\tPARAMS ((void));\n-extern void expand_elseif\t\tPARAMS ((tree));\n-extern void save_stack_pointer\t\tPARAMS ((void));\n-extern void expand_decl\t\t\tPARAMS ((tree));\n-extern int expand_decl_cleanup\t\tPARAMS ((tree, tree));\n-extern int expand_decl_cleanup_eh\tPARAMS ((tree, tree, int));\n-extern void expand_anon_union_decl\tPARAMS ((tree, tree, tree));\n-extern void expand_start_case_dummy\tPARAMS ((void));\n-extern HOST_WIDE_INT all_cases_count\tPARAMS ((tree, int *));\n-extern void check_for_full_enumeration_handling PARAMS ((tree));\n-extern void declare_nonlocal_label\tPARAMS ((tree));\n-extern void default_flag_random_seed\tPARAMS ((void));\n+extern int any_pending_cleanups (void);\n+extern void init_stmt_for_function (void);\n+extern void expand_start_target_temps (void);\n+extern void expand_end_target_temps (void);\n+extern void expand_elseif (tree);\n+extern void save_stack_pointer (void);\n+extern void expand_decl (tree);\n+extern int expand_decl_cleanup (tree, tree);\n+extern int expand_decl_cleanup_eh (tree, tree, int);\n+extern void expand_anon_union_decl (tree, tree, tree);\n+extern void expand_start_case_dummy (void);\n+extern HOST_WIDE_INT all_cases_count (tree, int *);\n+extern void check_for_full_enumeration_handling (tree);\n+extern void declare_nonlocal_label (tree);\n+extern void default_flag_random_seed (void);\n \n /* If KIND=='I', return a suitable global initializer (constructor) name.\n    If KIND=='D', return a suitable global clean-up (destructor) name.  */\n-extern tree get_file_function_name PARAMS ((int));\n+extern tree get_file_function_name (int);\n \f\n /* Interface of the DWARF2 unwind info support.  */\n \n /* Generate a new label for the CFI info to refer to.  */\n \n-extern char *dwarf2out_cfi_label\tPARAMS ((void));\n+extern char *dwarf2out_cfi_label (void);\n \n /* Entry point to update the canonical frame address (CFA).  */\n \n-extern void dwarf2out_def_cfa\t\tPARAMS ((const char *, unsigned, long));\n+extern void dwarf2out_def_cfa (const char *, unsigned, long);\n \n /* Add the CFI for saving a register window.  */\n \n-extern void dwarf2out_window_save\tPARAMS ((const char *));\n+extern void dwarf2out_window_save (const char *);\n \n /* Add a CFI to update the running total of the size of arguments pushed\n    onto the stack.  */\n \n-extern void dwarf2out_args_size\t\tPARAMS ((const char *, long));\n+extern void dwarf2out_args_size (const char *, long);\n \n /* Entry point for saving a register to the stack.  */\n \n-extern void dwarf2out_reg_save\t\tPARAMS ((const char *, unsigned, long));\n+extern void dwarf2out_reg_save (const char *, unsigned, long);\n \n /* Entry point for saving the return address in the stack.  */\n \n-extern void dwarf2out_return_save\tPARAMS ((const char *, long));\n+extern void dwarf2out_return_save (const char *, long);\n \n /* Entry point for saving the return address in a register.  */\n \n-extern void dwarf2out_return_reg\tPARAMS ((const char *, unsigned));\n+extern void dwarf2out_return_reg (const char *, unsigned);\n \n /* The type of a function that walks over tree structure.  */\n \n-typedef tree (*walk_tree_fn)\t\tPARAMS ((tree *, int *, void *));\n+typedef tree (*walk_tree_fn) (tree *, int *, void *);\n \n /* In tree-dump.c */\n \n@@ -3030,24 +2994,24 @@ enum tree_dump_index\n \n typedef struct dump_info *dump_info_p;\n \n-extern int dump_flag\t\t\tPARAMS ((dump_info_p, int, tree));\n-extern int dump_enabled_p\t\tPARAMS ((enum tree_dump_index));\n-extern FILE *dump_begin\t\t\tPARAMS ((enum tree_dump_index, int *));\n-extern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\n-extern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\n-extern int dump_switch_p                PARAMS ((const char *));\n-extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n+extern int dump_flag (dump_info_p, int, tree);\n+extern int dump_enabled_p (enum tree_dump_index);\n+extern FILE *dump_begin (enum tree_dump_index, int *);\n+extern void dump_end (enum tree_dump_index, FILE *);\n+extern void dump_node (tree, int, FILE *);\n+extern int dump_switch_p (const char *);\n+extern const char *dump_flag_name (enum tree_dump_index);\n /* Assign the RTX to declaration.  */\n \n-extern void set_decl_rtl\t\tPARAMS ((tree, rtx));\n+extern void set_decl_rtl (tree, rtx);\n \f\n /* Redefine abort to report an internal error w/o coredump, and\n    reporting the location of the error in the source file.  This logic\n    is duplicated in rtl.h and tree.h because every file that needs the\n    special abort includes one or both.  toplev.h gets too few files,\n    system.h gets too many.  */\n \n-extern void fancy_abort PARAMS ((const char *, int, const char *))\n+extern void fancy_abort (const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n #define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n "}]}