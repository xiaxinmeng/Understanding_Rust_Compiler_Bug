{"sha": "67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "node_id": "C_kwDOANBUbNoAKDY3YjZkMWJlMDYyM2RlMWE4YWEzMmZlMjQ5YmZhMDEyOWM1NWIxMWE", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-02T13:00:15Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-02T13:00:15Z"}, "message": "vect: Use better fallback costs in layout subpass\n\nvect_optimize_slp_pass always treats the starting layout as valid,\nto avoid having to \"optimise\" when every possible choice is invalid.\nBut it gives the starting layout a high cost if it seems like the\ntarget might reject it, in the hope that this will encourage other\n(valid) layouts.\n\nThe testcase for PR106787 showed that this was flawed, since it was\ntriggering even in cases where the number of input lanes is different\nfrom the number of output lanes.  Picking such a high cost could also\nmake costs for loop-invariant nodes overwhelm the costs for inner-loop\nnodes.\n\nThis patch makes the costing less aggressive by (a) restricting\nit to N-to-N permutations and (b) assigning the maximum cost of\na permute.\n\ngcc/\n\t* tree-vect-slp.cc (vect_optimize_slp_pass::internal_node_cost):\n\tReduce the fallback cost to 1.  Only use it if the number of\n\tinput lanes is equal to the number of output lanes.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-layout-20.c: New test.", "tree": {"sha": "6bd0ccd739be294ddf2c026c067178f76e5c6c20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bd0ccd739be294ddf2c026c067178f76e5c6c20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b6d1be0623de1a8aa32fe249bfa0129c55b11a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eab511df13ca6abb24c3c2abb0f420a89c91e310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab511df13ca6abb24c3c2abb0f420a89c91e310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab511df13ca6abb24c3c2abb0f420a89c91e310"}], "stats": {"total": 73, "additions": 63, "deletions": 10}, "files": [{"sha": "ed7816b3f7b88875789b02db8f1bf7cec2b2a34f", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-layout-20.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b6d1be0623de1a8aa32fe249bfa0129c55b11a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b6d1be0623de1a8aa32fe249bfa0129c55b11a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-layout-20.c?ref=67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+\n+extern int a[][4], b[][4], c[][4], d[4], e[4];\n+void f()\n+{\n+  int t0 = a[0][3];\n+  int t1 = a[1][3];\n+  int t2 = a[2][3];\n+  int t3 = a[3][3];\n+  int a0 = 0, a1 = 0, a2 = 0, a3 = 0, b0 = 0, b1 = 0, b2 = 0, b3 = 0;\n+  for (int i = 0; i < 400; i += 4)\n+    {\n+      a0 += b[i][3] * t0;\n+      a1 += b[i][2] * t1;\n+      a2 += b[i][1] * t2;\n+      a3 += b[i][0] * t3;\n+      b0 += c[i][3] * t0;\n+      b1 += c[i][2] * t1;\n+      b2 += c[i][1] * t2;\n+      b3 += c[i][0] * t3;\n+    }\n+  d[0] = a0;\n+  d[1] = a1;\n+  d[2] = a2;\n+  d[3] = a3;\n+  e[0] = b0;\n+  e[1] = b1;\n+  e[2] = b2;\n+  e[3] = b3;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"add new stmt: \\[^\\\\n\\\\r\\]* = VEC_PERM_EXPR\" 3 \"slp1\" { target { vect_int_mult && vect_perm } } } } */"}, {"sha": "b10f69da133f292805aac448ea65bc48cf2472b0", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67b6d1be0623de1a8aa32fe249bfa0129c55b11a/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67b6d1be0623de1a8aa32fe249bfa0129c55b11a/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "patch": "@@ -4436,18 +4436,19 @@ change_vec_perm_layout (slp_tree node, lane_permutation_t &perm,\n \n    IN_LAYOUT_I has no meaning for other types of node.\n \n-   Keeping the node as-is is always valid.  If the target doesn't appear to\n-   support the node as-is then layout 0 has a high and arbitrary cost instead\n-   of being invalid.  On the one hand, this ensures that every node has at\n-   least one valid layout, avoiding what would otherwise be an awkward\n-   special case.  On the other, it still encourages the pass to change\n-   an invalid pre-existing layout choice into a valid one.  */\n+   Keeping the node as-is is always valid.  If the target doesn't appear\n+   to support the node as-is, but might realistically support other layouts,\n+   then layout 0 instead has the cost of a worst-case permutation.  On the\n+   one hand, this ensures that every node has at least one valid layout,\n+   avoiding what would otherwise be an awkward special case.  On the other,\n+   it still encourages the pass to change an invalid pre-existing layout\n+   choice into a valid one.  */\n \n int\n vect_optimize_slp_pass::internal_node_cost (slp_tree node, int in_layout_i,\n \t\t\t\t\t    unsigned int out_layout_i)\n {\n-  const int fallback_cost = 100;\n+  const int fallback_cost = 1;\n \n   if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n     {\n@@ -4457,8 +4458,9 @@ vect_optimize_slp_pass::internal_node_cost (slp_tree node, int in_layout_i,\n       /* Check that the child nodes support the chosen layout.  Checking\n \t the first child is enough, since any second child would have the\n \t same shape.  */\n+      auto first_child = SLP_TREE_CHILDREN (node)[0];\n       if (in_layout_i > 0\n-\t  && !is_compatible_layout (SLP_TREE_CHILDREN (node)[0], in_layout_i))\n+\t  && !is_compatible_layout (first_child, in_layout_i))\n \treturn -1;\n \n       change_vec_perm_layout (node, tmp_perm, in_layout_i, out_layout_i);\n@@ -4469,7 +4471,15 @@ vect_optimize_slp_pass::internal_node_cost (slp_tree node, int in_layout_i,\n       if (count < 0)\n \t{\n \t  if (in_layout_i == 0 && out_layout_i == 0)\n-\t    return fallback_cost;\n+\t    {\n+\t      /* Use the fallback cost if the node could in principle support\n+\t\t some nonzero layout for both the inputs and the outputs.\n+\t\t Otherwise assume that the node will be rejected later\n+\t\t and rebuilt from scalars.  */\n+\t      if (SLP_TREE_LANES (node) == SLP_TREE_LANES (first_child))\n+\t\treturn fallback_cost;\n+\t      return 0;\n+\t    }\n \t  return -1;\n \t}\n \n@@ -4498,8 +4508,18 @@ vect_optimize_slp_pass::internal_node_cost (slp_tree node, int in_layout_i,\n       if (!vect_transform_slp_perm_load_1 (m_vinfo, node, tmp_perm, vNULL,\n \t\t\t\t\t   nullptr, vf, true, false, &n_perms))\n \t{\n+\t  auto rep = SLP_TREE_REPRESENTATIVE (node);\n \t  if (out_layout_i == 0)\n-\t    return fallback_cost;\n+\t    {\n+\t      /* Use the fallback cost if the load is an N-to-N permutation.\n+\t\t Otherwise assume that the node will be rejected later\n+\t\t and rebuilt from scalars.  */\n+\t      if (STMT_VINFO_GROUPED_ACCESS (rep)\n+\t\t  && (DR_GROUP_SIZE (DR_GROUP_FIRST_ELEMENT (rep))\n+\t\t      == SLP_TREE_LANES (node)))\n+\t\treturn fallback_cost;\n+\t      return 0;\n+\t    }\n \t  return -1;\n \t}\n "}]}