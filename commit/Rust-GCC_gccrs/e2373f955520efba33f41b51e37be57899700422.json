{"sha": "e2373f955520efba33f41b51e37be57899700422", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIzNzNmOTU1NTIwZWZiYTMzZjQxYjUxZTM3YmU1Nzg5OTcwMDQyMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-17T19:50:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-17T19:50:58Z"}, "message": "recog.c (validate_replace_src_1): New.\n\n\t* recog.c (validate_replace_src_1): New.\n\t(validate_replace_src_data): Likewise.\n\t(validate_replace_src): Use note_uses.\n\t* rtl.h (note_uses): Declare.\n\t* rtlanal.c (note_uses): New.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r39804", "tree": {"sha": "0f5631dc5eb3ec8aa8ef7d3ac0ae2a68b44d49bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f5631dc5eb3ec8aa8ef7d3ac0ae2a68b44d49bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2373f955520efba33f41b51e37be57899700422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2373f955520efba33f41b51e37be57899700422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2373f955520efba33f41b51e37be57899700422", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2373f955520efba33f41b51e37be57899700422/comments", "author": null, "committer": null, "parents": [{"sha": "f5d3e93f974899f1fde4b015e925d25b908a666d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d3e93f974899f1fde4b015e925d25b908a666d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d3e93f974899f1fde4b015e925d25b908a666d"}], "stats": {"total": 138, "additions": 120, "deletions": 18}, "files": [{"sha": "11e9a8e5ea62353c47fcbfe6e8fafb4e5ec008fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2373f955520efba33f41b51e37be57899700422/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2373f955520efba33f41b51e37be57899700422/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2373f955520efba33f41b51e37be57899700422", "patch": "@@ -1,3 +1,12 @@\n+Sat Feb 17 14:48:30 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\t\t\t  Jan Hubicka  <jh@suse.cz>\n+\n+\t* recog.c (validate_replace_src_1): New.\n+\t(validate_replace_src_data): Likewise.\n+\t(validate_replace_src): Use note_uses.\n+\t* rtl.h (note_uses): Declare.\n+\t* rtlanal.c (note_uses): New.\n+\n Sat Feb 17 10:52:34 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* reg-stack.c (stack_def): Make field reg unsigned."}, {"sha": "d6cdf5450e46fdd2c852e7bc88cd1a1e81bcc69b", "filename": "gcc/recog.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2373f955520efba33f41b51e37be57899700422/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2373f955520efba33f41b51e37be57899700422/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e2373f955520efba33f41b51e37be57899700422", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used by or related to instruction recognition.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -59,6 +59,7 @@ static void validate_replace_rtx_1\tPARAMS ((rtx *, rtx, rtx, rtx));\n static rtx *find_single_use_1\t\tPARAMS ((rtx, rtx *));\n static rtx *find_constant_term_loc\tPARAMS ((rtx *));\n static int insn_invalid_p\t\tPARAMS ((rtx));\n+static void validate_replace_src_1 \tPARAMS ((rtx *, void *));\n \n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n@@ -741,6 +742,23 @@ validate_replace_rtx_group (from, to, insn)\n   validate_replace_rtx_1 (&PATTERN (insn), from, to, insn);\n }\n \n+/* Function called by note_uses to replace used subexpressions.  */\n+struct validate_replace_src_data\n+  {\n+    rtx from, to, insn;\n+  };\n+\n+static void\n+validate_replace_src_1 (x, data)\n+     rtx *x;\n+     void *data;\n+{\n+  struct validate_replace_src_data *d\n+    = (struct validate_replace_src_data *) data;\n+\n+  validate_replace_rtx_1 (x, d->from, d->to, d->insn);\n+}\n+\n /* Try replacing every occurrence of FROM in INSN with TO, avoiding\n    SET_DESTs.  After all changes have been made, validate by seeing if\n    INSN is still valid.  */\n@@ -749,22 +767,12 @@ int\n validate_replace_src (from, to, insn)\n      rtx from, to, insn;\n {\n-  if ((GET_CODE (insn) != INSN && GET_CODE (insn) != JUMP_INSN)\n-      || GET_CODE (PATTERN (insn)) != SET)\n-    abort ();\n-\n-  validate_replace_rtx_1 (&SET_SRC (PATTERN (insn)), from, to, insn);\n-  if (GET_CODE (SET_DEST (PATTERN (insn))) == MEM)\n-    validate_replace_rtx_1 (&XEXP (SET_DEST (PATTERN (insn)), 0),\n-\t\t\t    from, to, insn);\n-  else if (GET_CODE (SET_DEST (PATTERN (insn))) == ZERO_EXTRACT)\n-    {\n-      validate_replace_rtx_1 (&XEXP (SET_DEST (PATTERN (insn)), 1),\n-\t\t\t      from, to, insn);\n-      validate_replace_rtx_1 (&XEXP (SET_DEST (PATTERN (insn)), 2),\n-\t\t\t      from, to, insn);\n-    }\n+  struct validate_replace_src_data d;\n \n+  d.from = from;\n+  d.to = to;\n+  d.insn = insn;\n+  note_uses (&PATTERN (insn), validate_replace_src_1, &d);\n   return apply_change_group ();\n }\n \f"}, {"sha": "ecbde555be9c717535cfb07825d3e7a82bff9611", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2373f955520efba33f41b51e37be57899700422/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2373f955520efba33f41b51e37be57899700422/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e2373f955520efba33f41b51e37be57899700422", "patch": "@@ -1403,6 +1403,9 @@ extern rtx set_of\t\t\tPARAMS ((rtx, rtx));\n extern void note_stores\t\t\tPARAMS ((rtx,\n \t\t\t\t\t\t void (*) (rtx, rtx, void *),\n \t\t\t\t\t\t void *));\n+extern void note_uses\t\t\tPARAMS ((rtx *,\n+\t\t\t\t\t\t void (*) (rtx *, void *),\n+\t\t\t\t\t\t void *));\n extern rtx reg_set_last\t\t\tPARAMS ((rtx, rtx));\n extern int dead_or_set_p\t\tPARAMS ((rtx, rtx));\n extern int dead_or_set_regno_p\t\tPARAMS ((rtx, unsigned int));"}, {"sha": "5dc2af586a33ca3a7fa9489ea7518057ca01b612", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2373f955520efba33f41b51e37be57899700422/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2373f955520efba33f41b51e37be57899700422/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e2373f955520efba33f41b51e37be57899700422", "patch": "@@ -25,10 +25,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"rtl.h\"\n \n+/* Forward declarations */\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n-\n-/* Forward declarations */\n static int computed_jump_p_1\tPARAMS ((rtx));\n \n /* Bit flags that specify the machine subtype we are compiling for.\n@@ -1303,6 +1302,89 @@ note_stores (x, fun, data)\n       note_stores (XVECEXP (x, 0, i), fun, data);\n }\n \f\n+/* Like notes_stores, but call FUN for each expression that is being\n+   referenced in PBODY, a pointer to the PATTERN of an insn.  We only call\n+   FUN for each expression, not any interior subexpressions.  FUN receives a\n+   pointer to the expression and the DATA passed to this function.\n+\n+   Note that this is not quite the same test as that done in reg_referenced_p\n+   since that considers something as being referenced if it is being\n+   partially set, while we do not.  */\n+\n+void\n+note_uses (pbody, fun, data)\n+     rtx *pbody;\n+     void (*fun) PARAMS ((rtx *, void *));\n+     void *data;\n+{\n+  rtx body = *pbody;\n+  int i;\n+\n+  switch (GET_CODE (body))\n+    {\n+    case COND_EXEC:\n+      (*fun) (&COND_EXEC_TEST (body), data);\n+      note_uses (&COND_EXEC_CODE (body), fun, data);\n+      return;\n+\n+    case PARALLEL:\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n+\tnote_uses (&XVECEXP (body, 0, i), fun, data);\n+      return;\n+\n+    case USE:\n+      (*fun) (&XEXP (body, 0), data);\n+      return;\n+\n+    case ASM_OPERANDS:\n+      for (i = ASM_OPERANDS_INPUT_LENGTH (body) - 1; i >= 0; i--)\n+\t(*fun) (&ASM_OPERANDS_INPUT (body, i), data);\n+      return;\n+\n+    case TRAP_IF:\n+      (*fun) (&TRAP_CONDITION (body), data);\n+      return;\n+\n+    case UNSPEC:\n+    case UNSPEC_VOLATILE:\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n+\t(*fun) (&XVECEXP (body, 0, i), data);\n+      return;\n+\n+    case CLOBBER:\n+      if (GET_CODE (XEXP (body, 0)) == MEM)\n+\t(*fun) (&XEXP (XEXP (body, 0), 0), data);\n+      return;\n+\n+    case SET:\n+      {\n+\trtx dest = SET_DEST (body);\n+\n+\t/* For sets we replace everything in source plus registers in memory\n+\t   expression in store and operands of a ZERO_EXTRACT.  */\n+\t(*fun) (&SET_SRC (body), data);\n+\n+\tif (GET_CODE (dest) == ZERO_EXTRACT)\n+\t  {\n+\t    (*fun) (&XEXP (dest, 1), data);\n+\t    (*fun) (&XEXP (dest, 2), data);\n+\t  }\n+\n+\twhile (GET_CODE (dest) == SUBREG || GET_CODE (dest) == STRICT_LOW_PART)\n+\t  dest = XEXP (dest, 0);\n+\n+\tif (GET_CODE (dest) == MEM)\n+\t  (*fun) (&XEXP (dest, 0), data);\n+      }\n+      return;\n+\n+    default:\n+      /* All the other possibilities never store.  */\n+      (*fun) (pbody, data);\n+      return;\n+    }\n+}\n+\f\n /* Return nonzero if X's old contents don't survive after INSN.\n    This will be true if X is (cc0) or if X is a register and\n    X dies in INSN or because INSN entirely sets X."}]}