{"sha": "f8d9772e2fc172baf760e9986e4ea4c2c36df42b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkOTc3MmUyZmMxNzJiYWY3NjBlOTk4NmU0ZWE0YzJjMzZkZjQyYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-23T22:53:47Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-23T22:53:47Z"}, "message": "(a29k_makes_calls): New global variable.\n\n(compute_regstack_size, a29k_compute_reg_names): New functions.\n(output_prolog): Much code moved to two new functions.  Use\na29k_makes_calls instead of makes_calls.\n\nFrom-SVN: r13019", "tree": {"sha": "b053b22336aebfa11adc09a5789cd90698d9a346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b053b22336aebfa11adc09a5789cd90698d9a346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8d9772e2fc172baf760e9986e4ea4c2c36df42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d9772e2fc172baf760e9986e4ea4c2c36df42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d9772e2fc172baf760e9986e4ea4c2c36df42b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d9772e2fc172baf760e9986e4ea4c2c36df42b/comments", "author": null, "committer": null, "parents": [{"sha": "469c300bacad32351b8e0e6235a540e7044609af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469c300bacad32351b8e0e6235a540e7044609af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469c300bacad32351b8e0e6235a540e7044609af"}], "stats": {"total": 63, "additions": 43, "deletions": 20}, "files": [{"sha": "d6588f2357313cf66ddf9db054ad7705c479acd4", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d9772e2fc172baf760e9986e4ea4c2c36df42b/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d9772e2fc172baf760e9986e4ea4c2c36df42b/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=f8d9772e2fc172baf760e9986e4ea4c2c36df42b", "patch": "@@ -44,6 +44,10 @@ Boston, MA 02111-1307, USA.  */\n \n static int a29k_regstack_size;\n \n+/* True if the current procedure has a call instruction.  */\n+\n+static int a29k_makes_calls;\n+\n /* This points to the last insn of the insn prologue.  It is set when\n    an insn without a filled delay slot is found near the start of the\n    function.  */\n@@ -1189,29 +1193,24 @@ print_operand (file, x, code)\n \f\n /* This page contains routines to output function prolog and epilog code. */\n \n-/* Output function prolog code to file FILE.  Memory stack size is SIZE.\n-\n-   Also sets register names for incoming arguments and frame pointer.  */\n+/* Compute the size of the register stack, and determine if there are any\n+   call instructions.  */\n \n-void\n-output_prolog (file, size)\n-     FILE *file;\n-     int size;\n+static void\n+compute_regstack_size ()\n {\n-  int makes_calls = 0;\n-  int arg_count = 0;\n-  rtx insn;\n   int i;\n-  unsigned int tag_word;\n+  rtx insn;\n \n   /* See if we make any calls.  We need to set lr1 if so.  */\n+  a29k_makes_calls = 0;\n   for (insn = get_insns (); insn; insn = next_insn (insn))\n     if (GET_CODE (insn) == CALL_INSN\n \t|| (GET_CODE (insn) == INSN\n \t    && GET_CODE (PATTERN (insn)) == SEQUENCE\n \t    && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN))\n       {\n-\tmakes_calls = 1;\n+\ta29k_makes_calls = 1;\n \tbreak;\n       }\n \n@@ -1223,21 +1222,24 @@ output_prolog (file, size)\n   a29k_regstack_size = i - (R_LR (0) - 1);\n \n   /* If calling routines, ensure we count lr0 & lr1.  */\n-  if (makes_calls && a29k_regstack_size < 2)\n+  if (a29k_makes_calls && a29k_regstack_size < 2)\n     a29k_regstack_size = 2;\n \n   /* Count frame pointer and align to 8 byte boundary (even number of\n      registers).  */\n   a29k_regstack_size += frame_pointer_needed;\n   if (a29k_regstack_size & 1) a29k_regstack_size++;\n+}\n \n-  /* See how many incoming arguments we have in registers.  */\n-  for (i = R_AR (0); i < R_AR (16); i++)\n-    if (! fixed_regs[i])\n-      arg_count++;\n+/*  Sets register names for incoming arguments and frame pointer.\n+    This can't be computed until after register allocation.  */\n \n-  /* The argument count includes the caller's lr0 and lr1.  */\n-  arg_count += 2;\n+void\n+a29k_compute_reg_names ()\n+{\n+  int i;\n+\n+  compute_regstack_size ();\n \n   /* Set the names and numbers of the frame pointer and incoming argument\n      registers.  */\n@@ -1263,6 +1265,27 @@ output_prolog (file, size)\n \ta29k_debug_reg_map[i] = a29k_debug_reg_map[R_KR (i)];\n \ta29k_debug_reg_map[R_KR (i)] = tem;\n       }\n+}\n+\n+/* Output function prolog code to file FILE.  Memory stack size is SIZE.  */\n+\n+void\n+output_prolog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int i;\n+  int arg_count = 0;\n+  rtx insn;\n+  unsigned int tag_word;\n+\n+  /* See how many incoming arguments we have in registers.  */\n+  for (i = R_AR (0); i < R_AR (16); i++)\n+    if (! fixed_regs[i])\n+      arg_count++;\n+\n+  /* The argument count includes the caller's lr0 and lr1.  */\n+  arg_count += 2;\n \n   /* Compute memory stack size.  Add in number of bytes that the we should\n      push and pretend the caller did and the size of outgoing arguments.\n@@ -1326,7 +1349,7 @@ output_prolog (file, size)\n      slot (this condition is equivalent to seeing if we have an insn that\n      needs delay slots before an insn that has a filled delay slot).  */\n   a29k_last_prologue_insn = 0;\n-  if (makes_calls)\n+  if (a29k_makes_calls)\n     {\n       i = (a29k_regstack_size + arg_count) * 4;\n       if (i >= 256)"}]}