{"sha": "d68bd5a8f29c31ca172979e5a37368aff6685d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY4YmQ1YThmMjljMzFjYTE3Mjk3OWU1YTM3MzY4YWZmNjY4NWQyNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-25T15:11:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-06-25T15:11:02Z"}, "message": "re PR fortran/25056 (non-PURE function should not be a valid argument)\n\n2006-06-25  Paul Thomas  <pault@gcc.gnu.org>\n \n\tPR fortran/25056\n\t* interface.c (compare_actual_formal): Signal an error if the formal\n\targument is a pure procedure and the actual is not pure.\n\n\tPR fortran/27554\n\t* resolve.c (resolve_actual_arglist): If the type of procedure\n\tpassed as an actual argument is not already declared, see if it is\n\tan intrinsic.\n\n\tPR fortran/25073\n\t* resolve.c (resolve_select): Use bits 1 and 2 of a new int to\n\tkeep track of  the appearance of constant logical case expressions.\n\tSignal an error is either value appears more than once.\n\n\tPR fortran/20874\n\t* resolve.c (resolve_fl_procedure): Signal an error if an elemental\n\tfunction is not scalar valued.\n\n\tPR fortran/20867\n\t* match.c (recursive_stmt_fcn): Perform implicit typing of variables.\n\n\tPR fortran/22038\n\t* match.c (match_forall_iterator): Mark new variables as\n\tFL_UNKNOWN if the match fails.\n\n\tPR fortran/28119\n\t* match.c (gfc_match_forall): Remove extraneous call to\n\tgfc_match_eos.\n\n\tPR fortran/25072\n\t* resolve.c (resolve_code, resolve_function): Rework\n\tforall_flag scheme so that it is set and has a value of\n\t2, when the code->expr (ie. the forall mask) is resolved.\n\tThis is used to change \"block\" to \"mask\" in the non-PURE\n\terror message.\n\n\n2006-06-25  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20867\n\t* gfortran.dg/stfunc_3.f90: New test.\n\n\tPR fortran/25056\n\t* gfortran.dg/impure_actual_1.f90: New test.\n\n\tPR fortran/20874\n\t* gfortran.dg/elemental_result_1.f90: New test.\n\n\tPR fortran/25073\n\t* gfortran.dg/select_7.f90: New test.\n\n\tPR fortran/27554\n\t* intrinsic_actual_1.f: New test.\n\n\tPR fortran/22038\n\tPR fortran/28119\n\t* gfortran.dg/forall_4.f90: New test.\n\n\tPR fortran/25072\n\t* gfortran.dg/forall_5.f90: New test.\n\nFrom-SVN: r114987", "tree": {"sha": "cf0741725bd30f57ea1e75a058f37946edac8691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf0741725bd30f57ea1e75a058f37946edac8691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d68bd5a8f29c31ca172979e5a37368aff6685d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68bd5a8f29c31ca172979e5a37368aff6685d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d68bd5a8f29c31ca172979e5a37368aff6685d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d68bd5a8f29c31ca172979e5a37368aff6685d26/comments", "author": null, "committer": null, "parents": [{"sha": "344f237baff9bb9348473bafa10bf19ad6ac3577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/344f237baff9bb9348473bafa10bf19ad6ac3577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/344f237baff9bb9348473bafa10bf19ad6ac3577"}], "stats": {"total": 370, "additions": 361, "deletions": 9}, "files": [{"sha": "bae2a2b8f5c3423b0ef2574d326b0b2164e2d67f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -1,3 +1,41 @@\n+2006-06-25  Paul Thomas  <pault@gcc.gnu.org>\n+ \n+\tPR fortran/25056\n+\t* interface.c (compare_actual_formal): Signal an error if the formal\n+\targument is a pure procedure and the actual is not pure.\n+\n+\tPR fortran/27554\n+\t* resolve.c (resolve_actual_arglist): If the type of procedure\n+\tpassed as an actual argument is not already declared, see if it is\n+\tan intrinsic.\n+\n+\tPR fortran/25073\n+\t* resolve.c (resolve_select): Use bits 1 and 2 of a new int to\n+\tkeep track of  the appearance of constant logical case expressions.\n+\tSignal an error is either value appears more than once.\n+\n+\tPR fortran/20874\n+\t* resolve.c (resolve_fl_procedure): Signal an error if an elemental\n+\tfunction is not scalar valued.\n+\n+\tPR fortran/20867\n+\t* match.c (recursive_stmt_fcn): Perform implicit typing of variables.\n+\n+\tPR fortran/22038\n+\t* match.c (match_forall_iterator): Mark new variables as\n+\tFL_UNKNOWN if the match fails.\n+\n+\tPR fortran/28119\n+\t* match.c (gfc_match_forall): Remove extraneous call to\n+\tgfc_match_eos.\n+\n+\tPR fortran/25072\n+\t* resolve.c (resolve_code, resolve_function): Rework\n+\tforall_flag scheme so that it is set and has a value of\n+\t2, when the code->expr (ie. the forall mask) is resolved.\n+\tThis is used to change \"block\" to \"mask\" in the non-PURE\n+\terror message.\n+\n 2006-06-24  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/28081"}, {"sha": "bc99aab0f4ca44bbe5f84f5f099cbe01cf1a24d1", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -1296,6 +1296,17 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \t    }\n \t}\n \n+      if (f->sym->attr.flavor == FL_PROCEDURE\n+\t    && f->sym->attr.pure\n+\t    && a->expr->ts.type == BT_PROCEDURE\n+\t    && !a->expr->symtree->n.sym->attr.pure)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Expected a PURE procedure for argument '%s' at %L\",\n+\t\t       f->sym->name, &a->expr->where);\n+\t  return 0;\n+\t}\n+\n       if (f->sym->as\n \t  && f->sym->as->type == AS_ASSUMED_SHAPE\n \t  && a->expr->expr_type == EXPR_VARIABLE"}, {"sha": "77594cbf5672fa6209bd63013c964ee4b43a3408", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -2802,7 +2802,11 @@ gfc_match_equivalence (void)\n \n /* Check that a statement function is not recursive. This is done by looking\n    for the statement function symbol(sym) by looking recursively through its\n-   expression(e).  If a reference to sym is found, true is returned.  */\n+   expression(e).  If a reference to sym is found, true is returned.  \n+   12.5.4 requires that any variable of function that is implicitly typed\n+   shall have that type confirmed by any subsequent type declaration.  The\n+   implicit typing is conveniently done here.  */\n+\n static bool\n recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n {\n@@ -2836,11 +2840,17 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n \t    && recursive_stmt_fcn (e->symtree->n.sym->value, sym))\n \treturn true;\n \n+      if (e->symtree->n.sym->ts.type == BT_UNKNOWN)\n+\tgfc_set_default_type (e->symtree->n.sym, 0, NULL);\n+\n       break;\n \n     case EXPR_VARIABLE:\n       if (e->symtree && sym->name == e->symtree->n.sym->name)\n \treturn true;\n+\n+      if (e->symtree->n.sym->ts.type == BT_UNKNOWN)\n+\tgfc_set_default_type (e->symtree->n.sym, 0, NULL);\n       break;\n \n     case EXPR_OP:\n@@ -3392,6 +3402,13 @@ match_forall_iterator (gfc_forall_iterator ** result)\n   m = MATCH_ERROR;\n \n cleanup:\n+  /* Make sure that potential internal function references in the\n+     mask do not get messed up.  */\n+  if (iter->var\n+\t&& iter->var->expr_type == EXPR_VARIABLE\n+\t&& iter->var->symtree->n.sym->refs == 1)\n+    iter->var->symtree->n.sym->attr.flavor = FL_UNKNOWN;\n+\n   gfc_current_locus = where;\n   gfc_free_forall_iterator (iter);\n   return m;\n@@ -3586,9 +3603,6 @@ gfc_match_forall (gfc_statement * st)\n   *c = new_st;\n   c->loc = gfc_current_locus;\n \n-  if (gfc_match_eos () != MATCH_YES)\n-    goto syntax;\n-\n   gfc_clear_new_st ();\n   new_st.op = EXEC_FORALL;\n   new_st.expr = mask;"}, {"sha": "0e9916a1282db8209ea54c91cf642006292a4ed3", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -829,6 +829,14 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t  || sym->attr.external)\n \t{\n \n+\t  /* If a procedure is not already determined to be something else\n+\t     check if it is intrinsic.  */\n+\t  if (!sym->attr.intrinsic\n+\t\t&& !(sym->attr.external || sym->attr.use_assoc\n+\t\t       || sym->attr.if_source == IFSRC_IFBODY)\n+\t\t&& gfc_intrinsic_name (sym->name, sym->attr.subroutine))\n+\t    sym->attr.intrinsic = 1;\n+\n \t  if (sym->attr.proc == PROC_ST_FUNCTION)\n \t    {\n \t      gfc_error (\"Statement function '%s' at %L is not allowed as an \"\n@@ -1381,8 +1389,9 @@ resolve_function (gfc_expr * expr)\n       if (forall_flag)\n \t{\n \t  gfc_error\n-\t    (\"Function reference to '%s' at %L is inside a FORALL block\",\n-\t     name, &expr->where);\n+\t    (\"reference to non-PURE function '%s' at %L inside a \"\n+\t     \"FORALL %s\", name, &expr->where, forall_flag == 2 ?\n+\t     \"mask\" : \"block\");\n \t  t = FAILURE;\n \t}\n       else if (gfc_pure (NULL))\n@@ -3619,6 +3628,7 @@ resolve_select (gfc_code * code)\n   gfc_expr *case_expr;\n   gfc_case *cp, *default_case, *tail, *head;\n   int seen_unreachable;\n+  int seen_logical;\n   int ncases;\n   bt type;\n   try t;\n@@ -3701,6 +3711,7 @@ resolve_select (gfc_code * code)\n   default_case = NULL;\n   head = tail = NULL;\n   ncases = 0;\n+  seen_logical = 0;\n \n   for (body = code->block; body; body = body->block)\n     {\n@@ -3753,6 +3764,21 @@ resolve_select (gfc_code * code)\n \t      break;\n \t    }\n \n+\t  if (type == BT_LOGICAL && cp->low->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      int value;\n+\t      value = cp->low->value.logical == 0 ? 2 : 1;\n+\t      if (value & seen_logical)\n+\t\t{\n+\t\t  gfc_error (\"constant logical value in CASE statement \"\n+\t\t\t     \"is repeated at %L\",\n+\t\t\t     &cp->low->where);\n+\t\t  t = FAILURE;\n+\t\t  break;\n+\t\t}\n+\t      seen_logical |= value;\n+\t    }\n+\n \t  if (cp->low != NULL && cp->high != NULL\n \t      && cp->low != cp->high\n \t      && gfc_compare_expr (cp->low, cp->high) > 0)\n@@ -4513,6 +4539,7 @@ static void\n resolve_code (gfc_code * code, gfc_namespace * ns)\n {\n   int omp_workshare_save;\n+  int forall_save;\n   code_stack frame;\n   gfc_alloc *a;\n   try t;\n@@ -4524,14 +4551,13 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n   for (; code; code = code->next)\n     {\n       frame.current = code;\n+      forall_save = forall_flag;\n \n       if (code->op == EXEC_FORALL)\n \t{\n-\t  int forall_save = forall_flag;\n-\n \t  forall_flag = 1;\n \t  gfc_resolve_forall (code, ns, forall_save);\n-\t  forall_flag = forall_save;\n+\t  forall_flag = 2;\n \t}\n       else if (code->block)\n \t{\n@@ -4567,6 +4593,8 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \t}\n \n       t = gfc_resolve_expr (code->expr);\n+      forall_flag = forall_save;\n+\n       if (gfc_resolve_expr (code->expr2) == FAILURE)\n \tt = FAILURE;\n \n@@ -5181,6 +5209,16 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n       return FAILURE;\n     }\n \n+  /* An elemental function is required to return a scalar 12.7.1  */\n+  if (sym->attr.elemental && sym->attr.function && sym->as)\n+    {\n+      gfc_error (\"ELEMENTAL function '%s' at %L must have a scalar \"\n+\t\t \"result\", sym->name, &sym->declared_at);\n+      /* Reset so that the error only occurs once.  */\n+      sym->attr.elemental = 0;\n+      return FAILURE;\n+    }\n+\n   /* 5.1.1.5 of the Standard: A function name declared with an asterisk\n      char-len-param shall not be array-valued, pointer-valued, recursive\n      or pure.  ....snip... A character value of * may only be used in the"}, {"sha": "644b44ea041aa54d9f9126a1cf159fcca991a809", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -1,3 +1,27 @@\n+2006-06-25  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20867\n+\t* gfortran.dg/stfunc_3.f90: New test.\n+\n+\tPR fortran/25056\n+\t* gfortran.dg/impure_actual_1.f90: New test.\n+\n+\tPR fortran/20874\n+\t* gfortran.dg/elemental_result_1.f90: New test.\n+\n+\tPR fortran/25073\n+\t* gfortran.dg/select_7.f90: New test.\n+\n+\tPR fortran/27554\n+\t* intrinsic_actual_1.f: New test.\n+\n+\tPR fortran/22038\n+\tPR fortran/28119\n+\t* gfortran.dg/forall_4.f90: New test.\n+\n+\tPR fortran/25072\n+\t* gfortran.dg/forall_5.f90: New test.\n+\n 2006-06-25  Lee Millward  <lee.millward@gmail.com>\n \n \tPR c++/28051"}, {"sha": "c94e08e073f44a7c539d123ef93d9582a169a5ed", "filename": "gcc/testsuite/gfortran.dg/elemental_result_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_result_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_result_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_result_1.f90?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! Tests the fix for PR20874 in which array valued elemental\n+! functions were permitted.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE Test\n+CONTAINS\n+  ELEMENTAL FUNCTION LL(I) ! { dg-error \"must have a scalar result\" }\n+    INTEGER, INTENT(IN) :: I\n+    INTEGER  :: LL(2)\n+  END FUNCTION LL\n+!\n+! This was already OK.\n+!\n+  ELEMENTAL FUNCTION MM(I)\n+    INTEGER, INTENT(IN) :: I\n+    INTEGER, pointer  :: MM ! { dg-error \"conflicts with ELEMENTAL\" }\n+  END FUNCTION MM\n+END MODULE Test\n+"}, {"sha": "0b0d731650735ac9f4782ff1bd3bfee3fb829d71", "filename": "gcc/testsuite/gfortran.dg/forall_4.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_4.f90?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! Tests the fix for PR25072, in which mask expressions\n+! that start with an internal or intrinsic function \n+! reference would give a syntax error.\n+!\n+! The fix for PR28119 is tested as well; here, the forall\n+! statement could not be followed by another statement on\n+! the same line.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module foo\n+  integer, parameter :: n = 4\n+contains\n+  pure logical function foot (i)\n+    integer, intent(in) :: i\n+    foot = (i == 2) .or. (i == 3)\n+  end function foot\n+end module foo\n+\n+  use foo\n+  integer :: i, a(n)\n+  logical :: s(n)\n+  s = (/(foot (i), i=1, n)/)\n+\n+! Check that non-mask case is still OK and the fix for PR28119\n+  a = 0\n+  forall (i=1:n) a(i) = i ; if (any (a .ne. (/1,2,3,4/))) call abort ()\n+\n+! Now a mask using a function with an explicit interface\n+! via use association.\n+  a = 0\n+  forall (i=1:n, foot (i)) a(i) = i\n+  if (any (a .ne. (/0,2,3,0/))) call abort ()\n+\n+! Now an array variable mask\n+  a = 0\n+  forall (i=1:n, .not. s(i)) a(i) = i\n+  if (any (a .ne. (/1,0,0,4/))) call abort ()\n+\n+! This was the PR - an internal function mask\n+  a = 0\n+  forall (i=1:n, t (i)) a(i) = i\n+  if (any (a .ne. (/0,2,0,4/))) call abort ()\n+\n+! Check that an expression is OK - this also gave a syntax\n+! error\n+  a = 0\n+  forall (i=1:n, mod (i, 2) == 0) a(i) = i\n+  if (any (a .ne. (/0,2,0,4/))) call abort ()\n+\n+! And that an expression that used to work is OK\n+  a = 0\n+  forall (i=1:n, s (i) .or. t(i)) a(i) = w (i)\n+  if (any (a .ne. (/0,3,2,1/))) call abort ()\n+\n+contains\n+  pure logical function t(i)\n+    integer, intent(in) :: i\n+    t = (mod (i, 2) == 0)\n+  end function t\n+  pure integer function w(i)\n+    integer, intent(in) :: i\n+    w = 5 - i\n+  end function w\n+end"}, {"sha": "43ed2b5c313627384537938e2e3fd3859a6891e2", "filename": "gcc/testsuite/gfortran.dg/forall_5.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_5.f90?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! Tests the fix for PR25072, in which non-PURE functions could\n+! be referenced inside a FORALL mask.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module foo\n+  integer, parameter :: n = 4\n+contains\n+  logical function foot (i)\n+    integer, intent(in) :: i\n+    foot = (i == 2) .or. (i == 3)\n+  end function foot\n+end module foo\n+\n+  use foo\n+  integer :: i, a(n)\n+  logical :: s(n)\n+\n+  a = 0\n+  forall (i=1:n, foot (i)) a(i) = i  ! { dg-error \"non-PURE\" }\n+  if (any (a .ne. (/0,2,3,0/))) call abort ()\n+\n+  forall (i=1:n, s (i) .or. t(i)) a(i) = i  ! { dg-error \"non-PURE|LOGICAL\" }\n+  if (any (a .ne. (/0,3,2,1/))) call abort ()\n+\n+  a = 0\n+  forall (i=1:n, mod (i, 2) == 0) a(i) = w (i)  ! { dg-error \"non-PURE\" }\n+  if (any (a .ne. (/0,2,0,4/))) call abort ()\n+\n+contains\n+  logical function t(i)\n+    integer, intent(in) :: i\n+    t = (mod (i, 2) == 0)\n+  end function t\n+  integer function w(i)\n+    integer, intent(in) :: i\n+    w = 5 - i\n+  end function w\n+end"}, {"sha": "43711d4217659bddd3fddb4b089770862a544212", "filename": "gcc/testsuite/gfortran.dg/impure_actual_1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_actual_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_actual_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_actual_1.f90?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! Tests the fix for PR25056 in which a non-PURE procedure could be\n+! passed as the actual argument to a PURE procedure.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+MODULE M1\n+CONTAINS\n+ FUNCTION L()\n+  L=1\n+ END FUNCTION L\n+ PURE FUNCTION J(K)\n+   INTERFACE\n+     PURE FUNCTION K()\n+     END FUNCTION K\n+   END INTERFACE\n+   J=K()\n+ END FUNCTION J\n+END MODULE M1\n+USE M1\n+ write(6,*) J(L) ! { dg-error \"Expected a PURE procedure for argument\" }\n+END\n+\n+! { dg-final { cleanup-modules \"M1\" } }\n+"}, {"sha": "7596e322305d5749d443b7f4e7fb32a8916e51e1", "filename": "gcc/testsuite/gfortran.dg/intrinsic_actual_1.f", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_1.f?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+! Tests the fix for PR27554, where the actual argument reference\n+! to abs would not be recognised as being to an intrinsic\n+! procedure and would produce junk in the assembler.\n+!\n+! Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org> \n+!\n+      subroutine foo (proc, z)\n+        external proc\n+        real proc, z\n+        if ((proc(z) .ne. abs (z)) .and. \n+     &      (proc(z) .ne. alog10 (abs(z)))) call abort ()\n+        return\n+      end\n+\n+        external cos\n+        interface\n+          function sin (a)\n+            real a, sin\n+          end function sin\n+        end interface\n+\n+\n+        intrinsic alog10\n+        real x\n+        x = 100.\n+! The reference here would prevent the actual arg from being seen\n+! as an intrinsic procedure in the call to foo.\n+        x = -abs(x)\n+        call foo(abs, x)\n+! The intrinsic function can be locally over-ridden by an interface\n+        call foo(sin, x)\n+! or an external declaration.\n+        call foo(cos, x)\n+! Just make sure with another intrinsic but this time not referenced.\n+        call foo(alog10, -x)\n+      end\n+\n+      function sin (a)\n+        real a, sin\n+        sin = -a\n+        return\n+      end\n+\n+      function cos (a)\n+        real a, cos\n+        cos = -a\n+        return\n+      end"}, {"sha": "15b0750c4f114a96e21731d2a35db4b8cf43aceb", "filename": "gcc/testsuite/gfortran.dg/select_7.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_7.f90?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Tests the fix for PR25073 in which overlap in logical case\n+! expressions was permitted.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+LOGICAL :: L\n+SELECT CASE(L)\n+CASE(.true.)\n+CASE(.false.)\n+CASE(.true.) ! { dg-error \"value in CASE statement is repeated\" }\n+END SELECT\n+END"}, {"sha": "42eedf8c830fb4903b4d942950bfffa04877f1c2", "filename": "gcc/testsuite/gfortran.dg/stfunc_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fstfunc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d68bd5a8f29c31ca172979e5a37368aff6685d26/gcc%2Ftestsuite%2Fgfortran.dg%2Fstfunc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstfunc_3.f90?ref=d68bd5a8f29c31ca172979e5a37368aff6685d26", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Tests the fix for PR20867 in which implicit typing was not done within\n+! statement functions and so was not confirmed or not by subsequent\n+! type delarations.\n+!\n+! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n+!\n+  REAL :: st1\n+  st1(I)=I**2\n+  REAL :: I ! { dg-error \" already has basic type of INTEGER\" }\n+  END\n+\n+"}]}