{"sha": "eafa1afac6763098941e1edc3f14bab2c347be5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmYTFhZmFjNjc2MzA5ODk0MWUxZWRjM2YxNGJhYjJjMzQ3YmU1Zg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-07-01T19:58:42Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-01T19:58:42Z"}, "message": "strstream: Remove namespace std.\n\n\n2002-07-01  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/backward/strstream: Remove namespace std. Transfer to...\n\t* include/backward/strstream.h: ...here. Qualify std names.\n\t* src/strstream.cc: Remove namespace std.\n\t* include/Makefile.am (backward_headers): Remove strstream.h.\n\t* include/Makefile.in: Regenerate.\n\t* config/linker-map.gnu: Export strstream bits.\n\n\t* src/fstream-inst.cc: Tweak.\n\t* src/io-inst.cc: Same.\n\t* src/istream-inst.cc: Same.\n\t* src/misc-inst.cc: Same.\n\t* src/ostream-inst.cc: Same.\n\t* src/sstream-inst.cc: Same.\n\t* src/valarray-inst.cc: Same.\n\t* src/misc-inst.cc: Remove unused instantiations.\n\nFrom-SVN: r55148", "tree": {"sha": "82862134190cbc216bff4df5d44bb421012f831f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82862134190cbc216bff4df5d44bb421012f831f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eafa1afac6763098941e1edc3f14bab2c347be5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafa1afac6763098941e1edc3f14bab2c347be5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eafa1afac6763098941e1edc3f14bab2c347be5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafa1afac6763098941e1edc3f14bab2c347be5f/comments", "author": null, "committer": null, "parents": [{"sha": "c1b92d09069106355c7133244bbd01bfa67c471d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1b92d09069106355c7133244bbd01bfa67c471d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1b92d09069106355c7133244bbd01bfa67c471d"}], "stats": {"total": 1094, "additions": 518, "deletions": 576}, "files": [{"sha": "baa71d429db64dda3463999ec4e3261472355edd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -1,3 +1,21 @@\n+2002-07-01  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/backward/strstream: Remove namespace std. Transfer to...\n+\t* include/backward/strstream.h: ...here. Qualify std names.\n+\t* src/strstream.cc: Remove namespace std.\n+\t* include/Makefile.am (backward_headers): Remove strstream.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* config/linker-map.gnu: Export strstream bits.\n+\t\n+\t* src/fstream-inst.cc: Tweak.\n+\t* src/io-inst.cc: Same.\n+\t* src/istream-inst.cc: Same.\n+\t* src/misc-inst.cc: Same.\n+\t* src/ostream-inst.cc: Same.\n+\t* src/sstream-inst.cc: Same.\n+\t* src/valarray-inst.cc: Same.\n+\t* src/misc-inst.cc: Remove unused instantiations.\n+\n 2002-07-01  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* configure.in (libtool_VERSION): Bump to 5:0:0."}, {"sha": "28e1720add242e34f6777b5c818afe2358daf28b", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -38,7 +38,11 @@ GLIBCPP_3.1 {\n       std::_S_bit_count;\n       std::_S_first_one;\n       std::__default_alloc_template*;\n-      std::__malloc_alloc_template*\n+      std::__malloc_alloc_template*;\n+      strstreambuf::*;\n+      istrstream::*;\n+      ostrstream::*;\n+      strstream::*\n     };\n \n     # Names not in an 'extern' block are mangled names."}, {"sha": "c24fb5eff19d2cf9e9367ddad5cfe9a344fbbfd2", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -139,7 +139,6 @@ backward_headers = \\\n \t${backward_srcdir}/vector.h \\\n \t${backward_srcdir}/fstream.h \\\n \t${backward_srcdir}/strstream.h \\\n-\t${backward_srcdir}/strstream \\\n \t${backward_srcdir}/backward_warning.h\n \n ext_srcdir = ${glibcpp_srcdir}/include/ext"}, {"sha": "91e52da41d7a9cd7fc78e4673b739fdc78efee7a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -246,7 +246,6 @@ backward_headers = \\\n \t${backward_srcdir}/vector.h \\\n \t${backward_srcdir}/fstream.h \\\n \t${backward_srcdir}/strstream.h \\\n-\t${backward_srcdir}/strstream \\\n \t${backward_srcdir}/backward_warning.h\n \n "}, {"sha": "165c6e70dd4a1316f3b55dc578c8cca7ebd73735", "filename": "libstdc++-v3/include/backward/strstream", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1b92d09069106355c7133244bbd01bfa67c471d/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1b92d09069106355c7133244bbd01bfa67c471d/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream?ref=c1b92d09069106355c7133244bbd01bfa67c471d", "patch": "@@ -1,174 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1998\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-// WARNING: The classes defined in this header are DEPRECATED.  This\n-// header is defined in section D.7.1 of the C++ standard, and it\n-// MAY BE REMOVED in a future standard revision.  You should use the\n-// header <sstream> instead.\n-\n-#ifndef __SGI_STL_STRSTREAM\n-#define __SGI_STL_STRSTREAM\n-\n-#include \"backward_warning.h\"\n-#include <iosfwd>\n-#include <ios>\n-#include <istream>\n-#include <ostream>\n-#include <string>\n-\n-namespace std\n-{\n-  // Class strstreambuf, a streambuf class that manages an array of char.\n-  // Note that this class is not a template.\n-  class strstreambuf : public basic_streambuf<char, char_traits<char> >\n-  {\n-  public:                         \n-    // Types.\n-    typedef char_traits<char>              _Traits;\n-    typedef basic_streambuf<char, _Traits> _Base;\n-\n-  public:  \n-    // Constructor, destructor\n-    explicit strstreambuf(streamsize __initial_capacity = 0);\n-    strstreambuf(void* (*__alloc)(size_t), void (*__free)(void*));\n-\n-    strstreambuf(char* __get, streamsize __n, char* __put = 0);\n-    strstreambuf(signed char* __get, streamsize __n, signed char* __put = 0);\n-    strstreambuf(unsigned char* __get, streamsize __n, unsigned char* __put=0);\n-\n-    strstreambuf(const char* __get, streamsize __n);\n-    strstreambuf(const signed char* __get, streamsize __n);\n-    strstreambuf(const unsigned char* __get, streamsize __n);\n-\n-    virtual ~strstreambuf();\n-\n-  public:\n-    void freeze(bool = true);\n-    char* str();\n-    int pcount() const;\n-\n-  protected:\n-    virtual int_type overflow(int_type __c  = _Traits::eof());\n-    virtual int_type pbackfail(int_type __c = _Traits::eof());\n-    virtual int_type underflow();\n-    virtual _Base* setbuf(char* __buf, streamsize __n);\n-    virtual pos_type seekoff(off_type __off, ios_base::seekdir __dir,\n-\t\t\t     ios_base::openmode __mode\n-\t\t\t     = ios_base::in | ios_base::out);\n-    virtual pos_type seekpos(pos_type __pos, ios_base::openmode __mode\n-\t\t\t     = ios_base::in | ios_base::out);\n-\n-  private:  \n-    // Dynamic allocation, possibly using _M_alloc_fun and _M_free_fun.\n-    char* _M_alloc(size_t);\n-    void  _M_free(char*);\n-\n-    // Helper function used in constructors.\n-    void _M_setup(char* __get, char* __put, streamsize __n);\n-\n-  private:  \n-    // Data members.\n-    void* (*_M_alloc_fun)(size_t);\n-    void  (*_M_free_fun)(void*);\n-\n-    bool _M_dynamic  : 1;\n-    bool _M_frozen   : 1;\n-    bool _M_constant : 1;\n-  };\n-\n-  // Class istrstream, an istream that manages a strstreambuf.\n-  class istrstream : public basic_istream<char>\n-  {\n-  public:\n-    explicit istrstream(char*);\n-    explicit istrstream(const char*);\n-    istrstream(char* , streamsize);\n-    istrstream(const char*, streamsize);\n-    virtual ~istrstream();\n-\n-    strstreambuf* rdbuf() const;\n-    char* str();\n-\n-  private:\n-    strstreambuf _M_buf;\n-  };\n-\n-  // Class ostrstream\n-  class ostrstream : public basic_ostream<char>\n-  {\n-  public:\n-    ostrstream();\n-    ostrstream(char*, int, ios_base::openmode = ios_base::out);\n-    virtual ~ostrstream();\n-\n-    strstreambuf* rdbuf() const;\n-    void freeze(bool = true);\n-    char* str();\n-    int pcount() const;\n-\n-  private:\n-    strstreambuf _M_buf;\n-  };\n-\n-  // Class strstream\n-  class strstream : public basic_iostream<char>\n-  {\n-  public:\n-    typedef char                        char_type;\n-    typedef char_traits<char>::int_type int_type;\n-    typedef char_traits<char>::pos_type pos_type;\n-    typedef char_traits<char>::off_type off_type;\n-\n-    strstream();\n-    strstream(char*, int, ios_base::openmode = ios_base::in | ios_base::out);\n-    virtual ~strstream();\n-\n-    strstreambuf* rdbuf() const;\n-    void freeze(bool = true);\n-    int pcount() const;\n-    char* str();\n-\n-  private:\n-    strstreambuf _M_buf;\n-  };\n-} // namespace std\n-#endif "}, {"sha": "c96ca768ab00277dc3cea1eaccc7154daf0db69a", "filename": "libstdc++-v3/include/backward/strstream.h", "status": "modified", "additions": 152, "deletions": 19, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -1,22 +1,22 @@\n-// -*- C++ -*- forwarding header.\n-// Copyright (C) 2000 Free Software Foundation\n+// Backward-compat support -*- C++ -*-\n \n-// This file is part of GNU CC.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n // any later version.\n-// \n-// GNU CC is distributed in the hope that it will be useful,\n+\n+// This library is distributed in the hope that it will be useful,\n // but WITHOUT ANY WARRANTY; without even the implied warranty of\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n // GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n \n // As a special exception, you may use this file as part of a free software\n // library without restriction.  Specifically, if other files instantiate\n@@ -27,15 +27,148 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n+/*\n+ * Copyright (c) 1998\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+// WARNING: The classes defined in this header are DEPRECATED.  This\n+// header is defined in section D.7.1 of the C++ standard, and it\n+// MAY BE REMOVED in a future standard revision.  You should use the\n+// header <sstream> instead.\n+\n #ifndef _CPP_BACKWARD_STRSTREAM_H\n #define _CPP_BACKWARD_STRSTREAM_H 1\n \n-#include \"strstream\"\n+#include \"backward_warning.h\"\n+#include <iosfwd>\n+#include <ios>\n+#include <istream>\n+#include <ostream>\n+#include <string>\n \n-using std::strstreambuf;\n-using std::istrstream;\n-using std::ostrstream;\n-using std::strstream;\n+// Class strstreambuf, a streambuf class that manages an array of char.\n+// Note that this class is not a template.\n+class strstreambuf : public std::basic_streambuf<char>\n+{\n+public:                         \n+  // Types.\n+  typedef std::char_traits<char>              _Traits;\n+  typedef std::basic_streambuf<char, _Traits> _Base;\n \n-#endif \n+public:  \n+  // Constructor, destructor\n+  explicit strstreambuf(std::streamsize __initial_capacity = 0);\n+  strstreambuf(void* (*__alloc)(size_t), void (*__free)(void*));\n+\n+  strstreambuf(char* __get, std::streamsize __n, char* __put = 0);\n+  strstreambuf(signed char* __get, std::streamsize __n, \n+\t       signed char* __put = 0);\n+  strstreambuf(unsigned char* __get, std::streamsize __n, \n+\t       unsigned char* __put=0);\n+  \n+  strstreambuf(const char* __get, std::streamsize __n);\n+  strstreambuf(const signed char* __get, std::streamsize __n);\n+  strstreambuf(const unsigned char* __get, std::streamsize __n);\n+  \n+  virtual ~strstreambuf();\n \n+public:\n+  void freeze(bool = true);\n+  char* str();\n+  int pcount() const;\n+\n+protected:\n+  virtual int_type overflow(int_type __c  = _Traits::eof());\n+  virtual int_type pbackfail(int_type __c = _Traits::eof());\n+  virtual int_type underflow();\n+  virtual _Base* setbuf(char* __buf, std::streamsize __n);\n+  virtual pos_type seekoff(off_type __off, std::ios_base::seekdir __dir,\n+\t\t\t   std::ios_base::openmode __mode\n+\t\t\t   = std::ios_base::in | std::ios_base::out);\n+  virtual pos_type seekpos(pos_type __pos, std::ios_base::openmode __mode\n+\t\t\t   = std::ios_base::in | std::ios_base::out);\n+  \n+private:  \n+  // Dynamic allocation, possibly using _M_alloc_fun and _M_free_fun.\n+  char* _M_alloc(size_t);\n+  void  _M_free(char*);\n+  \n+  // Helper function used in constructors.\n+  void _M_setup(char* __get, char* __put, std::streamsize __n);\n+  \n+private:  \n+  // Data members.\n+  void* (*_M_alloc_fun)(size_t);\n+  void  (*_M_free_fun)(void*);\n+  \n+  bool _M_dynamic  : 1;\n+  bool _M_frozen   : 1;\n+  bool _M_constant : 1;\n+};\n+\n+// Class istrstream, an istream that manages a strstreambuf.\n+class istrstream : public std::basic_istream<char>\n+{\n+public:\n+  explicit istrstream(char*);\n+  explicit istrstream(const char*);\n+  istrstream(char* , std::streamsize);\n+  istrstream(const char*, std::streamsize);\n+  virtual ~istrstream();\n+  \n+  strstreambuf* rdbuf() const;\n+  char* str();\n+  \n+private:\n+  strstreambuf _M_buf;\n+};\n+\n+// Class ostrstream\n+class ostrstream : public std::basic_ostream<char>\n+{\n+public:\n+  ostrstream();\n+  ostrstream(char*, int, std::ios_base::openmode = std::ios_base::out);\n+  virtual ~ostrstream();\n+  \n+  strstreambuf* rdbuf() const;\n+  void freeze(bool = true);\n+  char* str();\n+  int pcount() const;\n+  \n+private:\n+  strstreambuf _M_buf;\n+};\n+\n+// Class strstream\n+class strstream : public std::basic_iostream<char>\n+{\n+public:\n+  typedef char                        char_type;\n+  typedef std::char_traits<char>::int_type int_type;\n+  typedef std::char_traits<char>::pos_type pos_type;\n+  typedef std::char_traits<char>::off_type off_type;\n+  \n+  strstream();\n+  strstream(char*, int, \n+\t    std::ios_base::openmode = std::ios_base::in | std::ios_base::out);\n+  virtual ~strstream();\n+  \n+  strstreambuf* rdbuf() const;\n+  void freeze(bool = true);\n+  int pcount() const;\n+  char* str();\n+  \n+private:\n+  strstreambuf _M_buf;\n+};\n+#endif "}, {"sha": "8b866c0c92735870dbe6396490e1c6fa5d3278cd", "filename": "libstdc++-v3/src/fstream-inst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Ffstream-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Ffstream-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffstream-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -59,4 +59,4 @@ namespace std\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class basic_fstream<wchar_t>;\n #endif\n-} //std\n+} // namespace std"}, {"sha": "31f53b4e39540cf720cbb4ea5081d42d077d1d5b", "filename": "libstdc++-v3/src/io-inst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fio-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fio-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fio-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -57,4 +57,4 @@ namespace std\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class basic_iostream<wchar_t>; \n #endif\n-} //std\n+} // namespace std"}, {"sha": "f2c72fde198d4c5007c67a4347d6d9804b03e98f", "filename": "libstdc++-v3/src/istream-inst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fistream-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fistream-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fistream-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -67,4 +67,4 @@ namespace std\n   template wistream& operator>>(wistream&, _Setprecision);\n   template wistream& operator>>(wistream&, _Setw);\n #endif\n-} //std\n+} // namespace std"}, {"sha": "1500e45a721159be93a427dba27a8bd4d198d0f8", "filename": "libstdc++-v3/src/misc-inst.cc", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -67,36 +67,4 @@ namespace std\n     basic_istream<wchar_t>& \n     getline(basic_istream<wchar_t>&, wstring&);\n #endif\n-\n-#if 1\n-  // XXX\n-  // 2002-05-24 These are no longer needed and should be deleted.\n-\n-  // algorithm\n-  typedef  _Char_traits_match<char, char_traits<char> > char_match;\n-\n-  template \n-    const char*  \n-    find_if<const char *, char_match>\n-    (const char *, const char *, char_match, random_access_iterator_tag);\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  typedef  _Char_traits_match<wchar_t, char_traits<wchar_t> > wchar_match;\n-\n-  template const wchar_t*  \n-    find_if<const wchar_t*, wchar_match>\n-    (const wchar_t*, const wchar_t*, wchar_match, random_access_iterator_tag);\n-#endif\n-  \n-  template \n-    string* \n-    __uninitialized_fill_n_aux<string*, size_t, string>\n-    (string*, size_t, string const &, __false_type);\n-\n-  template \n-    string* \n-    __uninitialized_copy_aux<vector<string>::const_iterator, string *>\n-    (vector<string>::const_iterator, vector<string>::const_iterator, \n-     string*, __false_type);\n-#endif\n-} //std\n+} // namespace std"}, {"sha": "b834640646bc19a824b5464ab7b47ef12e210768", "filename": "libstdc++-v3/src/ostream-inst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fostream-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fostream-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fostream-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -73,4 +73,4 @@ namespace std\n   template wostream& operator<<(wostream&, _Setprecision);\n   template wostream& operator<<(wostream&, _Setw);\n #endif\n-} //std\n+} // namespace std"}, {"sha": "6c0272ba2897d055cde65eb17defc62831f878ce", "filename": "libstdc++-v3/src/sstream-inst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fsstream-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fsstream-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fsstream-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -59,4 +59,4 @@ namespace std\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class basic_stringstream<wchar_t>; \n #endif\n-} //std\n+} // namespace std"}, {"sha": "3c852ab65865477e0205a576c2077a37fb3499ad", "filename": "libstdc++-v3/src/strstream.cc", "status": "modified", "additions": 335, "deletions": 338, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -54,149 +54,149 @@\n #include <string.h>\n #include <limits.h>\n \n-namespace std\n+using namespace std;\n+\n+strstreambuf::strstreambuf(streamsize initial_capacity)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(true), \n+  _M_frozen(false), _M_constant(false)\n {\n-  strstreambuf::strstreambuf(streamsize initial_capacity)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(true), \n-    _M_frozen(false), _M_constant(false)\n-  {\n-    _M_buf_size = _M_buf_size_opt = max(initial_capacity, streamsize(16));\n-    _M_buf = _M_alloc(_M_buf_size);\n-    if (_M_buf) \n-      {\n-\tsetp(_M_buf, _M_buf + _M_buf_size);\n-\tsetg(_M_buf, _M_buf, _M_buf);\n-      }\n-  }\n-\n-  strstreambuf::strstreambuf(void* (*alloc_f)(size_t), void (*free_f)(void*))\n-  : _Base(), _M_alloc_fun(alloc_f), _M_free_fun(free_f), _M_dynamic(true), \n-    _M_frozen(false), _M_constant(false)\n-  {\n-    _M_buf_size = _M_buf_size_opt = 16;\n-    _M_buf = _M_alloc(_M_buf_size);\n-    if (_M_buf) \n-      {\n-\tsetp(_M_buf, _M_buf + _M_buf_size);\n-\tsetg(_M_buf, _M_buf, _M_buf);\n-      }\n-  }\n-\n-  strstreambuf::strstreambuf(char* get, streamsize n, char* put)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-    _M_frozen(false), _M_constant(false)\n-  { _M_setup(get, put, n); }\n-\n-  strstreambuf::strstreambuf(signed char* get, streamsize n, signed char* put)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_buf_size = _M_buf_size_opt = max(initial_capacity, streamsize(16));\n+  _M_buf = _M_alloc(_M_buf_size);\n+  if (_M_buf) \n+    {\n+      setp(_M_buf, _M_buf + _M_buf_size);\n+      setg(_M_buf, _M_buf, _M_buf);\n+    }\n+}\n+\n+strstreambuf::strstreambuf(void* (*alloc_f)(size_t), void (*free_f)(void*))\n+: _Base(), _M_alloc_fun(alloc_f), _M_free_fun(free_f), _M_dynamic(true), \n   _M_frozen(false), _M_constant(false)\n-  { _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n-\n-  strstreambuf::strstreambuf(unsigned char* get, streamsize n, \n-\t\t\t     unsigned char* put)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-    _M_frozen(false), _M_constant(false)\n-  { _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n-\n-  strstreambuf::strstreambuf(const char* get, streamsize n)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-    _M_frozen(false), _M_constant(true)\n-  { _M_setup(const_cast<char*>(get), 0, n); }\n-\n-  strstreambuf::strstreambuf(const signed char* get, streamsize n)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-    _M_frozen(false), _M_constant(true)\n-  { _M_setup(reinterpret_cast<char*>(const_cast<signed char*>(get)), 0, n); }\n-\n-  strstreambuf::strstreambuf(const unsigned char* get, streamsize n)\n-  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-    _M_frozen(false), _M_constant(true)\n-  { _M_setup(reinterpret_cast<char*>(const_cast<unsigned char*>(get)), 0, n); }\n-\n-  strstreambuf::~strstreambuf()\n-  {\n-    if (_M_dynamic && !_M_frozen)\n-      {\n-\tchar* p = this->eback();\n-\t_M_free(p);\n-\tif (p == _M_buf)\n-\t  _M_buf = 0;\n-      }\n-    if (_M_buf)\n-      _M_free(_M_buf);\n-  }\n-\n-  void \n-  strstreambuf::freeze(bool frozenflag)\n-  {\n-    if (_M_dynamic)\n-      _M_frozen = frozenflag;\n-  }\n-\n-  char* \n-  strstreambuf::str()\n-  {\n-    freeze(true);\n-    return eback();\n-  }\n-\n-  int \n-  strstreambuf::pcount() const\n-  { return pptr() ? pptr() - pbase() : 0; }\n-\n-  strstreambuf::int_type \n-  strstreambuf::overflow(int_type c) \n-  {\n-    if (c == traits_type::eof())\n-      return traits_type::not_eof(c);\n+{\n+  _M_buf_size = _M_buf_size_opt = 16;\n+  _M_buf = _M_alloc(_M_buf_size);\n+  if (_M_buf) \n+    {\n+      setp(_M_buf, _M_buf + _M_buf_size);\n+      setg(_M_buf, _M_buf, _M_buf);\n+    }\n+}\n+\n+strstreambuf::strstreambuf(char* get, streamsize n, char* put)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(false)\n+{ _M_setup(get, put, n); }\n+\n+strstreambuf::strstreambuf(signed char* get, streamsize n, signed char* put)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(false)\n+{ _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n+\n+strstreambuf::strstreambuf(unsigned char* get, streamsize n, \n+\t\t\t   unsigned char* put)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(false)\n+{ _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n+\n+strstreambuf::strstreambuf(const char* get, streamsize n)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(true)\n+{ _M_setup(const_cast<char*>(get), 0, n); }\n+\n+strstreambuf::strstreambuf(const signed char* get, streamsize n)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(true)\n+{ _M_setup(reinterpret_cast<char*>(const_cast<signed char*>(get)), 0, n); }\n+\n+strstreambuf::strstreambuf(const unsigned char* get, streamsize n)\n+: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+  _M_frozen(false), _M_constant(true)\n+{ _M_setup(reinterpret_cast<char*>(const_cast<unsigned char*>(get)), 0, n); }\n+\n+strstreambuf::~strstreambuf()\n+{\n+  if (_M_dynamic && !_M_frozen)\n+    {\n+      char* p = this->eback();\n+      _M_free(p);\n+      if (p == _M_buf)\n+\t_M_buf = 0;\n+    }\n+  if (_M_buf)\n+    _M_free(_M_buf);\n+}\n+\n+void \n+strstreambuf::freeze(bool frozenflag)\n+{\n+  if (_M_dynamic)\n+    _M_frozen = frozenflag;\n+}\n+\n+char* \n+strstreambuf::str()\n+{\n+  freeze(true);\n+  return eback();\n+}\n+\n+int \n+strstreambuf::pcount() const\n+{ return pptr() ? pptr() - pbase() : 0; }\n+\n+strstreambuf::int_type \n+strstreambuf::overflow(int_type c) \n+{\n+  if (c == traits_type::eof())\n+    return traits_type::not_eof(c);\n     \n-    // Try to expand the buffer.\n-    if (pptr() == epptr() && _M_dynamic && !_M_frozen && !_M_constant) \n-      {\n-\tptrdiff_t old_size = epptr() - pbase();\n-\tptrdiff_t new_size = max(2 * old_size, ptrdiff_t(1));\n+  // Try to expand the buffer.\n+  if (pptr() == epptr() && _M_dynamic && !_M_frozen && !_M_constant) \n+    {\n+      ptrdiff_t old_size = epptr() - pbase();\n+      ptrdiff_t new_size = max(2 * old_size, ptrdiff_t(1));\n \t\n-\tchar* buf = _M_alloc(new_size);\n-\tif (buf) \n-\t  {\n-\t    memcpy(buf, pbase(), old_size);\n-\t    char* old_buffer = pbase();\n-\t    bool reposition_get = false;\n-\t    ptrdiff_t old_get_offset;\n-\t    if (gptr() != 0) \n-\t      {\n-\t\treposition_get = true;\n-\t\told_get_offset = gptr() - eback();\n-\t      }\n+      char* buf = _M_alloc(new_size);\n+      if (buf) \n+\t{\n+\t  memcpy(buf, pbase(), old_size);\n+\t  char* old_buffer = pbase();\n+\t  bool reposition_get = false;\n+\t  ptrdiff_t old_get_offset;\n+\t  if (gptr() != 0) \n+\t    {\n+\t      reposition_get = true;\n+\t      old_get_offset = gptr() - eback();\n+\t    }\n \t    \n-\t    _M_buf = buf;\n-\t    _M_buf_size = _M_buf_size_opt = new_size;\n-\t    setp(buf, buf + new_size);\n-\t    pbump(old_size);\n-\n-\t    if (reposition_get)\n-\t      setg(buf, buf + old_get_offset, buf + \n-\t\t   max(old_get_offset, old_size));\n-\n-\t    _M_free(old_buffer);\n-\t  }\n-      }\n+\t  _M_buf = buf;\n+\t  _M_buf_size = _M_buf_size_opt = new_size;\n+\t  setp(buf, buf + new_size);\n+\t  pbump(old_size);\n+\n+\t  if (reposition_get)\n+\t    setg(buf, buf + old_get_offset, buf + \n+\t\t max(old_get_offset, old_size));\n+\n+\t  _M_free(old_buffer);\n+\t}\n+    }\n     \n-    if (pptr() != epptr()) \n-      {\n-\t*pptr() = c;\n-\tpbump(1);\n-\treturn c;\n-      }\n-    else\n-      return traits_type::eof();\n-  }\n-\n-  strstreambuf::int_type \n-  strstreambuf::pbackfail(int_type c)\n-  {\n-    if (gptr() != eback()) \n-      {\n+  if (pptr() != epptr()) \n+    {\n+      *pptr() = c;\n+      pbump(1);\n+      return c;\n+    }\n+  else\n+    return traits_type::eof();\n+}\n+\n+strstreambuf::int_type \n+strstreambuf::pbackfail(int_type c)\n+{\n+  if (gptr() != eback()) \n+    {\n       if (c == _Traits::eof()) \n \t{\n \t  gbump(-1);\n@@ -214,211 +214,208 @@ namespace std\n \t  return c;\n \t}\n     }\n-    return _Traits::eof();\n-  }\n+  return _Traits::eof();\n+}\n \n-  strstreambuf::int_type \n-  strstreambuf::underflow()\n-  {\n-    if (gptr() == egptr() && pptr() && pptr() > egptr())\n-      setg(eback(), gptr(), pptr());\n+strstreambuf::int_type \n+strstreambuf::underflow()\n+{\n+  if (gptr() == egptr() && pptr() && pptr() > egptr())\n+    setg(eback(), gptr(), pptr());\n     \n-    if (gptr() != egptr())\n-      return (unsigned char) *gptr();\n-    else\n-      return _Traits::eof();\n-  }\n-\n-  basic_streambuf<char, char_traits<char> >*\n-  strstreambuf::setbuf(char*, streamsize)\n-  { return this; }\n-\n-  strstreambuf::pos_type\n-  strstreambuf::seekoff(off_type off, ios_base::seekdir dir, \n-\t\t\tios_base::openmode mode)\n-  {\n-    bool do_get = false;\n-    bool do_put = false;\n-\n-    if ((mode & (ios_base::in | ios_base::out)) \n-\t== (ios_base::in | ios_base::out) &&\n-\t(dir == ios_base::beg || dir == ios_base::end))\n-      do_get = do_put = true;\n-    else if (mode & ios_base::in)\n-      do_get = true;\n-    else if (mode & ios_base::out)\n-      do_put = true;\n-\n-    // !gptr() is here because, according to D.7.1 paragraph 4, the seekable\n-    // area is undefined if there is no get area.\n-    if ((!do_get && !do_put) || (do_put && !pptr()) || !gptr())\n-      return pos_type(off_type(-1));\n+  if (gptr() != egptr())\n+    return (unsigned char) *gptr();\n+  else\n+    return _Traits::eof();\n+}\n \n-    char* seeklow  = eback();\n-    char* seekhigh = epptr() ? epptr() : egptr();\n-\n-    off_type newoff;\n-    switch (dir) \n-      {\n-      case ios_base::beg:\n-\tnewoff = 0;\n-\tbreak;\n-      case ios_base::end:\n-\tnewoff = seekhigh - seeklow;\n-\tbreak;\n-      case ios_base::cur:\n-\tnewoff = do_put ? pptr() - seeklow : gptr() - seeklow;\n-\tbreak;\n-      default:\n-\treturn pos_type(off_type(-1));\n-      }\n-    \n-    off += newoff;\n-    if (off < 0 || off > seekhigh - seeklow)\n+basic_streambuf<char, char_traits<char> >*\n+strstreambuf::setbuf(char*, streamsize)\n+{ return this; }\n+\n+strstreambuf::pos_type\n+strstreambuf::seekoff(off_type off, ios_base::seekdir dir, \n+\t\t      ios_base::openmode mode)\n+{\n+  bool do_get = false;\n+  bool do_put = false;\n+\n+  if ((mode & (ios_base::in | ios_base::out)) \n+      == (ios_base::in | ios_base::out) &&\n+      (dir == ios_base::beg || dir == ios_base::end))\n+    do_get = do_put = true;\n+  else if (mode & ios_base::in)\n+    do_get = true;\n+  else if (mode & ios_base::out)\n+    do_put = true;\n+\n+  // !gptr() is here because, according to D.7.1 paragraph 4, the seekable\n+  // area is undefined if there is no get area.\n+  if ((!do_get && !do_put) || (do_put && !pptr()) || !gptr())\n+    return pos_type(off_type(-1));\n+\n+  char* seeklow  = eback();\n+  char* seekhigh = epptr() ? epptr() : egptr();\n+\n+  off_type newoff;\n+  switch (dir) \n+    {\n+    case ios_base::beg:\n+      newoff = 0;\n+      break;\n+    case ios_base::end:\n+      newoff = seekhigh - seeklow;\n+      break;\n+    case ios_base::cur:\n+      newoff = do_put ? pptr() - seeklow : gptr() - seeklow;\n+      break;\n+    default:\n       return pos_type(off_type(-1));\n+    }\n+    \n+  off += newoff;\n+  if (off < 0 || off > seekhigh - seeklow)\n+    return pos_type(off_type(-1));\n \n-    if (do_put) \n-      {\n-\tif (seeklow + off < pbase()) \n-\t  {\n-\t    setp(seeklow, epptr());\n-\t    pbump(off);\n-\t  }\n-\telse \n-\t  {\n-\t    setp(pbase(), epptr());\n-\t    pbump(off - (pbase() - seeklow));\n-\t  }\n-      }\n-    if (do_get) \n-      {\n-\tif (off <= egptr() - seeklow)\n-\t  setg(seeklow, seeklow + off, egptr());\n-\telse if (off <= pptr() - seeklow)\n-\t  setg(seeklow, seeklow + off, pptr());\n-\telse\n-\t  setg(seeklow, seeklow + off, epptr());\n-      }\n-    return pos_type(newoff);\n-  }\n-\n-  strstreambuf::pos_type\n-  strstreambuf::seekpos(pos_type pos, ios_base::openmode mode)\n-  { return seekoff(pos - pos_type(off_type(0)), ios_base::beg, mode); }\n-\n-  char* \n-  strstreambuf::_M_alloc(size_t n)\n-  {\n-    if (_M_alloc_fun)\n-      return static_cast<char*>(_M_alloc_fun(n));\n-    else\n-      return new char[n];\n-  }\n-\n-  void \n-  strstreambuf::_M_free(char* p)\n-  {\n-    if (p)\n-      if (_M_free_fun)\n-\t_M_free_fun(p);\n+  if (do_put) \n+    {\n+      if (seeklow + off < pbase()) \n+\t{\n+\t  setp(seeklow, epptr());\n+\t  pbump(off);\n+\t}\n+      else \n+\t{\n+\t  setp(pbase(), epptr());\n+\t  pbump(off - (pbase() - seeklow));\n+\t}\n+    }\n+  if (do_get) \n+    {\n+      if (off <= egptr() - seeklow)\n+\tsetg(seeklow, seeklow + off, egptr());\n+      else if (off <= pptr() - seeklow)\n+\tsetg(seeklow, seeklow + off, pptr());\n       else\n-\tdelete[] p;\n-  }\n-\n-  void \n-  strstreambuf::_M_setup(char* get, char* put, streamsize n)\n-  {\n-    if (get) \n-      {\n-\tsize_t N = n > 0 ? size_t(n) : n == 0 ? strlen(get) : size_t(INT_MAX);\n+\tsetg(seeklow, seeklow + off, epptr());\n+    }\n+  return pos_type(newoff);\n+}\n+\n+strstreambuf::pos_type\n+strstreambuf::seekpos(pos_type pos, ios_base::openmode mode)\n+{ return seekoff(pos - pos_type(off_type(0)), ios_base::beg, mode); }\n+\n+char* \n+strstreambuf::_M_alloc(size_t n)\n+{\n+  if (_M_alloc_fun)\n+    return static_cast<char*>(_M_alloc_fun(n));\n+  else\n+    return new char[n];\n+}\n+\n+void \n+strstreambuf::_M_free(char* p)\n+{\n+  if (p)\n+    if (_M_free_fun)\n+      _M_free_fun(p);\n+    else\n+      delete[] p;\n+}\n+\n+void \n+strstreambuf::_M_setup(char* get, char* put, streamsize n)\n+{\n+  if (get) \n+    {\n+      size_t N = n > 0 ? size_t(n) : n == 0 ? strlen(get) : size_t(INT_MAX);\n \t\n-\tif (put) \n-\t  {\n-\t    setg(get, get, put);\n-\t    setp(put, put + N);\n-\t  }\n-\telse \n-\t  setg(get, get, get + N);\n-      }\n-  }\n-\n-  istrstream::istrstream(char* s)\n-  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  istrstream::istrstream(const char* s)\n-  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  istrstream::istrstream(char* s, streamsize n)\n-  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  istrstream::istrstream(const char* s, streamsize n)\n-  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  istrstream::~istrstream() { }\n-\n-  strstreambuf* \n-  istrstream::rdbuf() const \n-  { return const_cast<strstreambuf*>(&_M_buf); }\n-\n-  char* \n-  istrstream::str() \n-  { return _M_buf.str(); }\n-\n-  ostrstream::ostrstream()\n-  : basic_ios<char>(), basic_ostream<char>(0), _M_buf()\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)\n-  : basic_ios<char>(), basic_ostream<char>(0), \n-    _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  ostrstream::~ostrstream() {}\n-\n-  strstreambuf* \n-  ostrstream::rdbuf() const\n-  { return const_cast<strstreambuf*>(&_M_buf); }\n-\n-  void \n-  ostrstream::freeze(bool freezeflag)\n-  { _M_buf.freeze(freezeflag); }\n-\n-  char* \n-  ostrstream::str()\n-  { return _M_buf.str(); }\n-\n-  int \n-  ostrstream::pcount() const\n-  { return _M_buf.pcount(); }\n-\n-  strstream::strstream()\n-  : basic_ios<char>(), basic_iostream<char>(0), _M_buf()\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  strstream::strstream(char* s, int n, ios_base::openmode mode)\n-  : basic_ios<char>(), basic_iostream<char>(0), \n-    _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n-  { basic_ios<char>::init(&_M_buf); }\n-\n-  strstream::~strstream() { }\n-\n-  strstreambuf* \n-  strstream::rdbuf() const\n-  { return const_cast<strstreambuf*>(&_M_buf); }\n-\n-  void \n-  strstream::freeze(bool freezeflag)\n-  { _M_buf.freeze(freezeflag); }\n-\n-  int \n-  strstream::pcount() const\n-  { return _M_buf.pcount(); }\n-\n-  char* \n-  strstream::str()\n-  { return _M_buf.str(); }\n-} // namespace std\n+      if (put) \n+\t{\n+\t  setg(get, get, put);\n+\t  setp(put, put + N);\n+\t}\n+      else \n+\tsetg(get, get, get + N);\n+    }\n+}\n+\n+istrstream::istrstream(char* s)\n+: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+istrstream::istrstream(const char* s)\n+: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+istrstream::istrstream(char* s, streamsize n)\n+: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+istrstream::istrstream(const char* s, streamsize n)\n+: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+istrstream::~istrstream() { }\n+\n+strstreambuf* \n+istrstream::rdbuf() const \n+{ return const_cast<strstreambuf*>(&_M_buf); }\n+\n+char* \n+istrstream::str() \n+{ return _M_buf.str(); }\n+\n+ostrstream::ostrstream() : basic_ios<char>(), basic_ostream<char>(0), _M_buf()\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)\n+: basic_ios<char>(), basic_ostream<char>(0), \n+  _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+ostrstream::~ostrstream() {}\n+\n+strstreambuf* \n+ostrstream::rdbuf() const\n+{ return const_cast<strstreambuf*>(&_M_buf); }\n+\n+void \n+ostrstream::freeze(bool freezeflag)\n+{ _M_buf.freeze(freezeflag); }\n+\n+char* \n+ostrstream::str()\n+{ return _M_buf.str(); }\n+\n+int \n+ostrstream::pcount() const\n+{ return _M_buf.pcount(); }\n+\n+strstream::strstream() : basic_ios<char>(), basic_iostream<char>(0), _M_buf()\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+strstream::strstream(char* s, int n, ios_base::openmode mode)\n+: basic_ios<char>(), basic_iostream<char>(0), \n+  _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n+{ basic_ios<char>::init(&_M_buf); }\n+\n+strstream::~strstream() { }\n+\n+strstreambuf* \n+strstream::rdbuf() const\n+{ return const_cast<strstreambuf*>(&_M_buf); }\n+\n+void \n+strstream::freeze(bool freezeflag)\n+{ _M_buf.freeze(freezeflag); }\n+\n+int \n+strstream::pcount() const\n+{ return _M_buf.pcount(); }\n+\n+char* \n+strstream::str()\n+{ return _M_buf.str(); }"}, {"sha": "a45a616f0bbefb5f999eb6ba40a98b01ee9a8e75", "filename": "libstdc++-v3/src/valarray-inst.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafa1afac6763098941e1edc3f14bab2c347be5f/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc?ref=eafa1afac6763098941e1edc3f14bab2c347be5f", "patch": "@@ -35,7 +35,7 @@\n \n namespace std\n {\n-  // Some explicit instanciations.\n+  // Some explicit instantiations.\n   template void\n      __valarray_fill(size_t* __restrict__, size_t, const size_t&);\n   \n@@ -112,7 +112,5 @@ namespace std\n                              const valarray<size_t>& __s)\n       : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),\n         _M_index(__l.size() == 0 ? 0 : __valarray_product(__l))\n-  { __gslice_to_index(__o, __l, __s, _M_index); }\n-  \n+  { __gslice_to_index(__o, __l, __s, _M_index); }  \n } // namespace std\n-"}]}