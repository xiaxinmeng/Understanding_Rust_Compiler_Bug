{"sha": "b6779d815b9ecbd5e1726b222901222e083e2047", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3NzlkODE1YjllY2JkNWUxNzI2YjIyMjkwMTIyMmUwODNlMjA0Nw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-04-07T06:33:35Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-04-07T06:33:35Z"}, "message": "Fix comments in ifconvert.\n\n2010-04-07  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-if-conv.c: Fix indentation and comments.\n\nFrom-SVN: r158039", "tree": {"sha": "0bfc0abcbc9a342fdf2333df6b776be916b8a366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bfc0abcbc9a342fdf2333df6b776be916b8a366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6779d815b9ecbd5e1726b222901222e083e2047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6779d815b9ecbd5e1726b222901222e083e2047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6779d815b9ecbd5e1726b222901222e083e2047", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6779d815b9ecbd5e1726b222901222e083e2047/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdd277f3a06ec09eb8cfcfe36b59e02f7a7743fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdd277f3a06ec09eb8cfcfe36b59e02f7a7743fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdd277f3a06ec09eb8cfcfe36b59e02f7a7743fd"}], "stats": {"total": 129, "additions": 64, "deletions": 65}, "files": [{"sha": "98716f50eb3796163c21da6d0b8fade60783e23c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6779d815b9ecbd5e1726b222901222e083e2047/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6779d815b9ecbd5e1726b222901222e083e2047/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6779d815b9ecbd5e1726b222901222e083e2047", "patch": "@@ -1,3 +1,7 @@\n+2010-04-07  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-if-conv.c: Fix indentation and comments.\n+\n 2010-04-06  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/43519"}, {"sha": "5ff864478def98f81ac93e58cc2faf95c7d053dd", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 60, "deletions": 65, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6779d815b9ecbd5e1726b222901222e083e2047/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6779d815b9ecbd5e1726b222901222e083e2047/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b6779d815b9ecbd5e1726b222901222e083e2047", "patch": "@@ -134,12 +134,12 @@ static bool bb_with_exit_edge_p (struct loop *, basic_block);\n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n-/* Main entry point.\n-   Apply if-conversion to the LOOP. Return true if successful otherwise return\n-   false. If false is returned then loop remains unchanged.\n-   FOR_VECTORIZER is a boolean flag. It indicates whether if-conversion is used\n-   for vectorizer or not. If it is used for vectorizer, additional checks are\n-   used. (Vectorization checks are not yet implemented).  */\n+/* Main entry point.  Apply if-conversion to the LOOP.  Return true if\n+   successful otherwise return false.  If false is returned then loop\n+   remains unchanged.  FOR_VECTORIZER is a boolean flag.  It indicates\n+   whether if-conversion is used for vectorizer or not.  If it is used\n+   for vectorizer, additional checks are used. (Vectorization checks\n+   are not yet implemented).  */\n \n static bool\n tree_if_conversion (struct loop *loop, bool for_vectorizer)\n@@ -150,8 +150,8 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \n   ifc_bbs = NULL;\n \n-  /* if-conversion is not appropriate for all loops. First, check if loop  is\n-     if-convertible or not.  */\n+  /* If-conversion is not appropriate for all loops.  First, check if\n+     loop is if-convertible or not.  */\n   if (!if_convertible_loop_p (loop, for_vectorizer))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -192,7 +192,7 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n \t{\n \t  basic_block bb_n = single_succ (bb);\n \n-\t  /* Successor bb inherits predicate of its predecessor. If there\n+\t  /* Successor bb inherits predicate of its predecessor.  If there\n \t     is no predicate in predecessor bb, then consider successor bb\n \t     as always executed.  */\n \t  if (cond == NULL_TREE)\n@@ -203,7 +203,7 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n     }\n \n   /* Now, all statements are if-converted and basic blocks are\n-     annotated appropriately. Combine all basic block into one huge\n+     annotated appropriately.  Combine all basic block into one huge\n      basic block.  */\n   combine_blocks (loop);\n \n@@ -215,12 +215,12 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n   return true;\n }\n \n-/* if-convert stmt T which is part of LOOP.\n+/* If-convert stmt T which is part of LOOP.\n    If T is a GIMPLE_ASSIGN then it is converted into conditional modify\n    expression using COND.  For conditional expressions, add condition in the\n    destination basic block's predicate list and remove conditional\n-   expression itself. BSI is the iterator used to traverse statements of\n-   loop. It is used here when it is required to delete current statement.  */\n+   expression itself.  BSI is the iterator used to traverse statements of\n+   loop.  It is used here when it is required to delete current statement.  */\n \n static tree\n tree_if_convert_stmt (struct loop *  loop, gimple t, tree cond,\n@@ -249,11 +249,11 @@ tree_if_convert_stmt (struct loop *  loop, gimple t, tree cond,\n       break;\n \n     case GIMPLE_ASSIGN:\n-      /* This GIMPLE_ASSIGN is killing previous value of LHS. Appropriate\n-\t value will be selected by PHI node based on condition. It is possible\n+      /* This GIMPLE_ASSIGN is killing previous value of LHS.  Appropriate\n+\t value will be selected by PHI node based on condition.  It is possible\n \t that before this transformation, PHI nodes was selecting default\n-\t value and now it will use this new value. This is OK because it does\n-\t not change validity the program.  */\n+\t value and now it will use this new value.  This is OK because it does\n+\t not change the validity of the program.  */\n       break;\n \n     case GIMPLE_COND:\n@@ -269,10 +269,10 @@ tree_if_convert_stmt (struct loop *  loop, gimple t, tree cond,\n   return cond;\n }\n \n-/* STMT is a GIMPLE_COND. Update two destination's predicate list.\n-   Remove COND_EXPR, if it is not the loop exit condition. Otherwise\n+/* STMT is a GIMPLE_COND.  Update two destination's predicate list.\n+   Remove COND_EXPR, if it is not the loop exit condition.  Otherwise\n    update loop exit condition appropriately.  GSI is the iterator\n-   used to traverse statement list. STMT is part of loop LOOP.  */\n+   used to traverse statement list.  STMT is part of loop LOOP.  */\n \n static void\n tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n@@ -292,15 +292,15 @@ tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n \n   /* Add new condition into destination's predicate list.  */\n \n-  /* If C is true then TRUE_EDGE is taken.  */\n+  /* If C is true, then TRUE_EDGE is taken.  */\n   add_to_dst_predicate_list (loop, true_edge, cond, c, gsi);\n \n-  /* If 'c' is false then FALSE_EDGE is taken.  */\n+  /* If C is false, then FALSE_EDGE is taken.  */\n   c2 = invert_truthvalue_loc (loc, unshare_expr (c));\n   add_to_dst_predicate_list (loop, false_edge, cond, c2, gsi);\n \n-  /* Now this conditional statement is redundant. Remove it.\n-     But, do not remove exit condition! Update exit condition\n+  /* Now this conditional statement is redundant.  Remove it.\n+     But, do not remove exit condition!  Update exit condition\n      using new condition.  */\n   if (!bb_with_exit_edge_p (loop, gimple_bb (stmt)))\n     {\n@@ -310,12 +310,12 @@ tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n   return;\n }\n \n-/* Return true, iff PHI is if-convertible. PHI is part of loop LOOP\n+/* Return true, iff PHI is if-convertible.  PHI is part of loop LOOP\n    and it belongs to basic block BB.\n    PHI is not if-convertible\n-   - if it has more than 2 arguments.\n-   - Virtual PHI is immediately used in another PHI node.\n-   - Virtual PHI on BB other than header.  */\n+   - if it has more than 2 arguments,\n+   - virtual PHI is immediately used in another PHI node,\n+   - virtual PHI on BB other than header.  */\n \n static bool\n if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n@@ -360,10 +360,10 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n \n /* Return true, if STMT is if-convertible.\n    GIMPLE_ASSIGN statement is not if-convertible if,\n-   - It is not movable.\n-   - It could trap.\n+   - it is not movable,\n+   - it could trap,\n    - LHS is not var decl.\n-  GIMPLE_ASSIGN is part of block BB, which is inside loop LOOP.  */\n+   GIMPLE_ASSIGN is part of block BB, which is inside loop LOOP.  */\n \n static bool\n if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n@@ -420,8 +420,8 @@ if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n \n /* Return true, iff STMT is if-convertible.\n    Statement is if-convertible if,\n-   - It is if-convertible GIMPLE_ASSGIN\n-   - It is GIMPLE_LABEL or GIMPLE_COND.\n+   - it is if-convertible GIMPLE_ASSGIN,\n+   - it is GIMPLE_LABEL or GIMPLE_COND.\n    STMT is inside block BB, which is inside loop LOOP.  */\n \n static bool\n@@ -459,10 +459,10 @@ if_convertible_stmt_p (struct loop *loop, basic_block bb, gimple stmt)\n \n /* Return true, iff BB is if-convertible.\n    Note: This routine does _not_ check basic block statements and phis.\n-   Basic block is not if-convertible if,\n-   - Basic block is non-empty and it is after exit block (in BFS order).\n-   - Basic block is after exit block but before latch.\n-   - Basic block edge(s) is not normal.\n+   Basic block is not if-convertible if:\n+   - basic block is non-empty and it is after exit block (in BFS order),\n+   - basic block is after exit block but before latch,\n+   - basic block edge(s) is not normal.\n    EXIT_BB_SEEN is true if basic block with exit edge is already seen.\n    BB is inside loop LOOP.  */\n \n@@ -513,15 +513,16 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n }\n \n /* Return true, iff LOOP is if-convertible.\n-   LOOP is if-convertible if,\n-   - It is innermost.\n-   - It has two or more basic blocks.\n-   - It has only one exit.\n-   - Loop header is not the exit edge.\n-   - If its basic blocks and phi nodes are if convertible. See above for\n+   LOOP is if-convertible if:\n+   - it is innermost,\n+   - it has two or more basic blocks,\n+   - it has only one exit,\n+   - loop header is not the exit edge,\n+   - if its basic blocks and phi nodes are if convertible.  See above for\n      more info.\n-   FOR_VECTORIZER enables vectorizer specific checks. For example, support\n-   for vector conditions, data dependency checks etc.. (Not implemented yet).  */\n+   FOR_VECTORIZER enables vectorizer specific checks, for example, support\n+   for vector conditions, data dependency checks, etc.\n+   (Not implemented yet).  */\n \n static bool\n if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n@@ -587,21 +588,16 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n       if (!if_convertible_bb_p (loop, bb, exit_bb))\n \treturn false;\n \n-      /* Check statements.  */\n       for (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n \tif (!if_convertible_stmt_p (loop, bb, gsi_stmt (itr)))\n \t  return false;\n-      /* ??? Check data dependency for vectorizer.  */\n \n-      /* What about phi nodes ? */\n       itr = gsi_start_phis (bb);\n \n-      /* Clear aux field of incoming edges to a bb with a phi node.  */\n       if (!gsi_end_p (itr))\n \tFOR_EACH_EDGE (e, ei, bb->preds)\n \t  e->aux = NULL;\n \n-      /* Check statements.  */\n       for (; !gsi_end_p (itr); gsi_next (&itr))\n \tif (!if_convertible_phi_p (loop, bb, gsi_stmt (itr)))\n \t  return false;\n@@ -610,8 +606,6 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n \texit_bb = bb;\n     }\n \n-  /* OK. Did not find any potential issues so go ahead in if-convert\n-     this loop. Now there is no looking back.  */\n   if (dump_file)\n     fprintf (dump_file,\"Applying if-conversion\\n\");\n \n@@ -679,7 +673,7 @@ add_to_dst_predicate_list (struct loop * loop, edge e,\n }\n \n /* During if-conversion aux field from basic block structure is used to hold\n-   predicate list. Clean each basic block's predicate list for the given LOOP.\n+   predicate list.  Clean each basic block's predicate list for the given LOOP.\n    Also clean aux field of successor edges, used to hold true and false\n    condition from conditional expression.  */\n \n@@ -702,7 +696,7 @@ clean_predicate_lists (struct loop *loop)\n }\n \n /* Basic block BB has two predecessors. Using predecessor's aux field, set\n-   appropriate condition COND for the PHI node replacement. Return true block\n+   appropriate condition COND for the PHI node replacement.  Return true block\n    whose phi arguments are selected when cond is true.  */\n \n static basic_block\n@@ -1013,15 +1007,15 @@ combine_blocks (struct loop *loop)\n     }\n \n   /* Now if possible, merge loop header and block with exit edge.\n-     This reduces number of basic blocks to 2. Auto vectorizer addresses\n+     This reduces number of basic blocks to 2.  Auto vectorizer addresses\n      loops with two nodes only.  FIXME: Use cleanup_tree_cfg().  */\n   if (exit_bb\n       && exit_bb != loop->header\n       && can_merge_blocks_p (loop->header, exit_bb))\n     merge_blocks (loop->header, exit_bb);\n }\n \n-/* Make a new temp variable of type TYPE. Add GIMPLE_ASSIGN to assign EXP\n+/* Make a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n    to the new variable.  */\n \n static gimple\n@@ -1064,11 +1058,11 @@ pred_blocks_visited_p (basic_block bb, bitmap *visited)\n   return true;\n }\n \n-/* Get body of a LOOP in suitable order for if-conversion.\n-   It is caller's responsibility to deallocate basic block\n-   list.  If-conversion suitable order is, BFS order with one\n-   additional constraint. Select block in BFS block, if all\n-   pred are already selected.  */\n+/* Get body of a LOOP in suitable order for if-conversion.  It is\n+   caller's responsibility to deallocate basic block list.\n+   If-conversion suitable order is, breadth first sort (BFS) order\n+   with an additional constraint: select a block only if all its\n+   predecessors are already selected.  */\n \n static basic_block *\n get_loop_body_in_if_conv_order (const struct loop *loop)\n@@ -1099,6 +1093,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n \t  free (blocks);\n \t  return NULL;\n \t}\n+\n       if (!bitmap_bit_p (visited, bb->index))\n \t{\n \t  if (pred_blocks_visited_p (bb, &visited)\n@@ -1109,13 +1104,13 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n \t      blocks[visited_count++] = bb;\n \t    }\n \t}\n+\n       index++;\n+\n       if (index == loop->num_nodes\n \t  && visited_count != loop->num_nodes)\n-\t{\n-\t  /* Not done yet.  */\n-\t  index = 0;\n-\t}\n+\t/* Not done yet.  */\n+\tindex = 0;\n     }\n   free (blocks_in_bfs_order);\n   BITMAP_FREE (visited);"}]}