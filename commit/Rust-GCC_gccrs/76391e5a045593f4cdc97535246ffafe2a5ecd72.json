{"sha": "76391e5a045593f4cdc97535246ffafe2a5ecd72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYzOTFlNWEwNDU1OTNmNGNkYzk3NTM1MjQ2ZmZhZmUyYTVlY2Q3Mg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-05-24T07:19:22Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-05-24T07:19:22Z"}, "message": "gcc.c (struct prefix_list): Add forward declaration.\n\n2004-05-23 Paolo Bonzini <bonzini@gnu.org>\n\n\t* gcc.c (struct prefix_list): Add forward declaration.\n\t(do_spec_path): New function, extracted from...\n\t(do_spec_1) <'D'>: ... here.  Drop support for\n\tSPACE_AFTER_L_OPTION.\n\t(do_spec_1) <'I'>: Use do_spec_path.\n\t(process_command): Do not store the 'include' suffix\n\tin include_prefixes.\n\t* system.h: Poison SPACE_AFTER_L_OPTION.\n\nFrom-SVN: r82197", "tree": {"sha": "f829381da7a47fb161e03e0799fba089b86b59bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f829381da7a47fb161e03e0799fba089b86b59bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76391e5a045593f4cdc97535246ffafe2a5ecd72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76391e5a045593f4cdc97535246ffafe2a5ecd72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76391e5a045593f4cdc97535246ffafe2a5ecd72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76391e5a045593f4cdc97535246ffafe2a5ecd72/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d4a2ff6c65aeb24104ad5daee443fa89a5d6652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4a2ff6c65aeb24104ad5daee443fa89a5d6652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d4a2ff6c65aeb24104ad5daee443fa89a5d6652"}], "stats": {"total": 253, "additions": 136, "deletions": 117}, "files": [{"sha": "c1d6b2b77025b7d860571d57e3380b111000b3ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76391e5a045593f4cdc97535246ffafe2a5ecd72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76391e5a045593f4cdc97535246ffafe2a5ecd72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76391e5a045593f4cdc97535246ffafe2a5ecd72", "patch": "@@ -1,3 +1,14 @@\n+2004-05-23 Paolo Bonzini <bonzini@gnu.org>\n+\n+\t* gcc.c (struct prefix_list): Add forward declaration.\n+\t(do_spec_path): New function, extracted from...\n+\t(do_spec_1) <'D'>: ... here.  Drop support for\n+\tSPACE_AFTER_L_OPTION.\n+\t(do_spec_1) <'I'>: Use do_spec_path.\n+\t(process_command): Do not store the 'include' suffix\n+\tin include_prefixes.\n+\t* system.h: Poison SPACE_AFTER_L_OPTION.\n+\n 2002-05-23  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (non_lvalue): Explicitly list the tree codes that"}, {"sha": "ade30b86445bd3560fe1f2f5b5999b12bb04f388", "filename": "gcc/gcc.c", "status": "modified", "additions": 124, "deletions": 116, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76391e5a045593f4cdc97535246ffafe2a5ecd72/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76391e5a045593f4cdc97535246ffafe2a5ecd72/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=76391e5a045593f4cdc97535246ffafe2a5ecd72", "patch": "@@ -290,6 +290,7 @@ static struct rusage rus, prus;\n \n /* Forward declaration for prototypes.  */\n struct path_prefix;\n+struct prefix_list;\n \n static void init_spec (void);\n static void store_arg (const char *, int, int);\n@@ -323,6 +324,7 @@ static const char *eval_spec_function (const char *, const char *);\n static const char *handle_spec_function (const char *);\n static char *save_string (const char *, int);\n static void set_collect_gcc_options (void);\n+static void do_spec_path (struct prefix_list *, const char *, int, int, int, const char *, const char *);\n static int do_spec_1 (const char *, int, const char *);\n static int do_spec_2 (const char *);\n static void do_option_spec (const char *, const char *);\n@@ -3309,9 +3311,8 @@ process_command (int argc, const char **argv)\n \t\tnstore[endp - startp] = 0;\n \t      add_prefix (&exec_prefixes, nstore, 0,\n \t\t\t  PREFIX_PRIORITY_LAST, 0, NULL, 0);\n-\t      add_prefix (&include_prefixes,\n-\t\t\t  concat (nstore, \"include\", NULL),\n-\t\t\t  0, PREFIX_PRIORITY_LAST, 0, NULL, 0);\n+\t      add_prefix (&include_prefixes, nstore, 0,\n+\t\t\t  PREFIX_PRIORITY_LAST, 0, NULL, 0);\n \t      if (*endp == 0)\n \t\tbreak;\n \t      endp = startp = endp + 1;\n@@ -3663,15 +3664,14 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\t    && (IS_DIR_SEPARATOR (value[len - 1])))\n \t\t  {\n \t\t    if (len == 7)\n-\t\t      add_prefix (&include_prefixes, \"include\", NULL,\n+\t\t      add_prefix (&include_prefixes, \"./\", NULL,\n \t\t\t\t  PREFIX_PRIORITY_B_OPT, 0, NULL, 0);\n \t\t    else\n \t\t      {\n-\t\t\tchar * string = xmalloc (len + 1);\n-\n-\t\t\tstrncpy (string, value, len - 7);\n-\t\t\tstrcpy (string + len - 7, \"include\");\n-\t\t\tadd_prefix (&include_prefixes, string, NULL,\n+\t\t        char *string = xmalloc (len - 6);\n+\t\t\tmemcpy (string, value, len - 7);\n+\t\t\tstring[len - 7] = 0;\n+\t\t        add_prefix (&include_prefixes, string, NULL,\n \t\t\t\t    PREFIX_PRIORITY_B_OPT, 0, NULL, 0);\n \t\t      }\n \t\t  }\n@@ -3680,8 +3680,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, &warn_B, 0);\n \t\tadd_prefix (&startfile_prefixes, value, NULL,\n \t\t\t    PREFIX_PRIORITY_B_OPT, 0, &warn_B, 0);\n-\t\tadd_prefix (&include_prefixes, concat (value, \"include\", NULL),\n-\t\t\t    NULL, PREFIX_PRIORITY_B_OPT, 0, NULL, 0);\n+\t\tadd_prefix (&include_prefixes, value, NULL,\n+\t\t\t    PREFIX_PRIORITY_B_OPT, 0, NULL, 0);\n \t\tn_switches++;\n \t      }\n \t      break;\n@@ -4394,6 +4394,107 @@ do_self_spec (const char *spec)\n     }\n }\n \n+void\n+do_spec_path (struct prefix_list *pl, const char *option,\n+\t      int omit_if_relative, int separate_options,\n+\t      int only_subdir,\n+\t      const char *dir_for_machine_suffix,\n+\t      const char *dir_for_no_suffix)\n+{\n+  static size_t bufsize = 0;\n+  static char *buffer;\n+  int idx;\n+\n+  /* Used on systems which record the specified -L dirs\n+     and use them to search for dynamic linking.  */\n+  /* Relative directories always come from -B,\n+     and it is better not to use them for searching\n+     at run time.  In particular, stage1 loses.  */\n+  if (omit_if_relative\n+      && !IS_ABSOLUTE_PATH (pl->prefix))\n+    return;\n+\n+  /* Try subdirectory if there is one.  */\n+  if (machine_suffix && dir_for_machine_suffix)\n+    {\n+      if (strlen (pl->prefix) + strlen (machine_suffix)\n+\t  >= bufsize)\n+\tbufsize = (strlen (pl->prefix)\n+\t\t  + strlen (machine_suffix)) * 2 + 1;\n+      buffer = xrealloc (buffer, bufsize);\n+      strcpy (buffer, pl->prefix);\n+      strcat (buffer, machine_suffix);\n+      if (is_directory (buffer, dir_for_machine_suffix, 1))\n+\t{\n+\t  do_spec_1 (option, separate_options, NULL);\n+\t  if (separate_options)\n+\t    do_spec_1 (\" \", 0, NULL);\n+\t  do_spec_1 (buffer, 1, NULL);\n+\t  do_spec_1 (dir_for_machine_suffix, 1, NULL);\n+\t  /* Make this a separate argument.  */\n+\t  do_spec_1 (\" \", 0, NULL);\n+\t}\n+    }\n+  if (!pl->require_machine_suffix && dir_for_no_suffix)\n+    {\n+      if (is_directory (pl->prefix, dir_for_no_suffix, 1))\n+\t{\n+\t  do_spec_1 (option, separate_options, NULL);\n+\t  if (separate_options)\n+\t    do_spec_1 (\" \", 0, NULL);\n+\t  do_spec_1 (pl->prefix, 1, NULL);\n+\t  do_spec_1 (dir_for_no_suffix, 1, NULL);\n+\t  /* Make this a separate argument.  */\n+\t  do_spec_1 (\" \", 0, NULL);\n+\t}\n+    }\n+\n+  if (only_subdir)\n+    return;\n+\n+  if (machine_suffix)\n+    {\n+      if (is_directory (pl->prefix, machine_suffix, 1))\n+\t{\n+\t  do_spec_1 (option, separate_options, NULL);\n+\t  if (separate_options)\n+\t    do_spec_1 (\" \", 0, NULL);\n+\t  do_spec_1 (pl->prefix, 1, NULL);\n+\t  /* Remove slash from machine_suffix.  */\n+\t  if (strlen (machine_suffix) >= bufsize)\n+\t    bufsize = strlen (machine_suffix) * 2 + 1;\n+\t  buffer = xrealloc (buffer, bufsize);\n+\t  strcpy (buffer, machine_suffix);\n+\t  idx = strlen (buffer);\n+\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n+\t    buffer[idx - 1] = 0;\n+\t  do_spec_1 (buffer, 1, NULL);\n+\t  /* Make this a separate argument.  */\n+\t  do_spec_1 (\" \", 0, NULL);\n+\t}\n+    }\n+  if (!pl->require_machine_suffix)\n+    {\n+      if (is_directory (pl->prefix, \"\", 1))\n+\t{\n+\t  do_spec_1 (option, separate_options, NULL);\n+\t  if (separate_options)\n+\t    do_spec_1 (\" \", 0, NULL);\n+\t  /* Remove slash from pl->prefix.  */\n+\t  if (strlen (pl->prefix) >= bufsize)\n+\t    bufsize = strlen (pl->prefix) * 2 + 1;\n+\t  buffer = xrealloc (buffer, bufsize);\n+\t  strcpy (buffer, pl->prefix);\n+\t  idx = strlen (buffer);\n+\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n+\t    buffer[idx - 1] = 0;\n+\t  do_spec_1 (buffer, 1, NULL);\n+\t  /* Make this a separate argument.  */\n+\t  do_spec_1 (\" \", 0, NULL);\n+\t}\n+    }\n+}\n+\n /* Process the sub-spec SPEC as a portion of a larger spec.\n    This is like processing a whole spec except that we do\n    not initialize at the beginning and we do not supply a\n@@ -4530,110 +4631,22 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t  case 'D':\n \t    {\n \t      struct prefix_list *pl = startfile_prefixes.plist;\n-\t      size_t bufsize = 100;\n-\t      char *buffer = xmalloc (bufsize);\n-\t      int idx;\n \n \t      for (; pl; pl = pl->next)\n \t\t{\n-#ifdef RELATIVE_PREFIX_NOT_LINKDIR\n-\t\t  /* Used on systems which record the specified -L dirs\n-\t\t     and use them to search for dynamic linking.  */\n-\t\t  /* Relative directories always come from -B,\n-\t\t     and it is better not to use them for searching\n-\t\t     at run time.  In particular, stage1 loses.  */\n-\t\t  if (!IS_ABSOLUTE_PATH (pl->prefix))\n-\t\t    continue;\n-#endif\n-\t\t  /* Try subdirectory if there is one.  */\n-\t\t  if (multilib_dir != NULL\n-\t\t      || (pl->os_multilib && multilib_os_dir != NULL))\n-\t\t    {\n-\t\t      const char *multi_dir;\n+\t\t  const char *no_suffix_multilib_dir;\n \n-\t\t      multi_dir = pl->os_multilib ? multilib_os_dir\n-\t\t\t\t\t\t  : multilib_dir;\n-\t\t      if (machine_suffix && multilib_dir)\n-\t\t\t{\n-\t\t\t  if (strlen (pl->prefix) + strlen (machine_suffix)\n-\t\t\t      >= bufsize)\n-\t\t\t    bufsize = (strlen (pl->prefix)\n-\t\t\t\t       + strlen (machine_suffix)) * 2 + 1;\n-\t\t\t  buffer = xrealloc (buffer, bufsize);\n-\t\t\t  strcpy (buffer, pl->prefix);\n-\t\t\t  strcat (buffer, machine_suffix);\n-\t\t\t  if (is_directory (buffer, multilib_dir, 1))\n-\t\t\t    {\n-\t\t\t      do_spec_1 (\"-L\", 0, NULL);\n-#ifdef SPACE_AFTER_L_OPTION\n-\t\t\t      do_spec_1 (\" \", 0, NULL);\n-#endif\n-\t\t\t      do_spec_1 (buffer, 1, NULL);\n-\t\t\t      do_spec_1 (multilib_dir, 1, NULL);\n-\t\t\t      /* Make this a separate argument.  */\n-\t\t\t      do_spec_1 (\" \", 0, NULL);\n-\t\t\t    }\n-\t\t\t}\n-\t\t      if (!pl->require_machine_suffix)\n-\t\t\t{\n-\t\t\t  if (is_directory (pl->prefix, multi_dir, 1))\n-\t\t\t    {\n-\t\t\t      do_spec_1 (\"-L\", 0, NULL);\n-#ifdef SPACE_AFTER_L_OPTION\n-\t\t\t      do_spec_1 (\" \", 0, NULL);\n-#endif\n-\t\t\t      do_spec_1 (pl->prefix, 1, NULL);\n-\t\t\t      do_spec_1 (multi_dir, 1, NULL);\n-\t\t\t      /* Make this a separate argument.  */\n-\t\t\t      do_spec_1 (\" \", 0, NULL);\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  if (machine_suffix)\n-\t\t    {\n-\t\t      if (is_directory (pl->prefix, machine_suffix, 1))\n-\t\t\t{\n-\t\t\t  do_spec_1 (\"-L\", 0, NULL);\n-#ifdef SPACE_AFTER_L_OPTION\n-\t\t\t  do_spec_1 (\" \", 0, NULL);\n-#endif\n-\t\t\t  do_spec_1 (pl->prefix, 1, NULL);\n-\t\t\t  /* Remove slash from machine_suffix.  */\n-\t\t\t  if (strlen (machine_suffix) >= bufsize)\n-\t\t\t    bufsize = strlen (machine_suffix) * 2 + 1;\n-\t\t\t  buffer = xrealloc (buffer, bufsize);\n-\t\t\t  strcpy (buffer, machine_suffix);\n-\t\t\t  idx = strlen (buffer);\n-\t\t\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n-\t\t\t    buffer[idx - 1] = 0;\n-\t\t\t  do_spec_1 (buffer, 1, NULL);\n-\t\t\t  /* Make this a separate argument.  */\n-\t\t\t  do_spec_1 (\" \", 0, NULL);\n-\t\t\t}\n-\t\t    }\n-\t\t  if (!pl->require_machine_suffix)\n-\t\t    {\n-\t\t      if (is_directory (pl->prefix, \"\", 1))\n-\t\t\t{\n-\t\t\t  do_spec_1 (\"-L\", 0, NULL);\n-#ifdef SPACE_AFTER_L_OPTION\n-\t\t\t  do_spec_1 (\" \", 0, NULL);\n+\t\t  no_suffix_multilib_dir = pl->os_multilib ? multilib_os_dir\n+\t\t\t\t\t   : multilib_dir;\n+\t\t  /* Do not separate options, include non-multilibbed variant.  */\n+\t\t  do_spec_path (pl, \"-L\",\n+#ifdef RELATIVE_PREFIX_NOT_LINKDIR\n+\t\t\t\t1,\n+#else\n+\t\t\t\t0,\n #endif\n-\t\t\t  /* Remove slash from pl->prefix.  */\n-\t\t\t  if (strlen (pl->prefix) >= bufsize)\n-\t\t\t    bufsize = strlen (pl->prefix) * 2 + 1;\n-\t\t\t  buffer = xrealloc (buffer, bufsize);\n-\t\t\t  strcpy (buffer, pl->prefix);\n-\t\t\t  idx = strlen (buffer);\n-\t\t\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n-\t\t\t    buffer[idx - 1] = 0;\n-\t\t\t  do_spec_1 (buffer, 1, NULL);\n-\t\t\t  /* Make this a separate argument.  */\n-\t\t\t  do_spec_1 (\" \", 0, NULL);\n-\t\t\t}\n-\t\t    }\n+\t\t\t\t0, 0, multilib_dir, no_suffix_multilib_dir);\n \t\t}\n-\t      free (buffer);\n \t    }\n \t    break;\n \n@@ -4885,13 +4898,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t}\n \n \t      for (; pl; pl = pl->next)\n-\t\t{\n-\t\t  do_spec_1 (\"-isystem\", 1, NULL);\n-\t\t  /* Make this a separate argument.  */\n-\t\t  do_spec_1 (\" \", 0, NULL);\n-\t\t  do_spec_1 (pl->prefix, 1, NULL);\n-\t\t  do_spec_1 (\" \", 0, NULL);\n-\t\t}\n+\t\t/* Separate options, don't include non-suffixed variant.  */\n+\t\tdo_spec_path (pl, \"-isystem\", 0, 1, 1, \"include\", \"include\");\n \t    }\n \t    break;\n "}, {"sha": "53754660f58ca7d33102ebaf4dc8f0f535d6fe5c", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76391e5a045593f4cdc97535246ffafe2a5ecd72/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76391e5a045593f4cdc97535246ffafe2a5ecd72/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=76391e5a045593f4cdc97535246ffafe2a5ecd72", "patch": "@@ -643,7 +643,7 @@ typedef char _Bool;\n \tTRADITIONAL_PIPELINE_INTERFACE DFA_PIPELINE_INTERFACE\t\t   \\\n \tDBX_OUTPUT_STANDARD_TYPES BUILTIN_SETJMP_FRAME_VALUE\t\t   \\\n \tSUNOS4_SHARED_LIBRARIES PROMOTE_FOR_CALL_ONLY\t\t\t   \\\n-\tNO_RECURSIVE_FUNCTION_CSE\n+\tSPACE_AFTER_L_OPTION NO_RECURSIVE_FUNCTION_CSE\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}]}