{"sha": "08e1ff9d6e5a419d5b4a60c077df549e81601d9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhlMWZmOWQ2ZTVhNDE5ZDViNGE2MGMwNzdkZjU0OWU4MTYwMWQ5Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-06-11T20:55:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-06-12T16:34:36Z"}, "message": "c++: constexpr and array[0] [PR101029]\n\nbuild_vec_init_elt exits early if we're initializing a zero-element array,\nso build_vec_init needs to do the same to avoid trying to instantiate things\nafter we've already started throwing important bits away.\n\n\tPR c++/101029\n\ngcc/cp/ChangeLog:\n\n\t* init.c (build_vec_init): Shortcut [0] case.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/array4.C: New test.", "tree": {"sha": "47e0d36efa71d5e46343023c6b51d6ce95e2423e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47e0d36efa71d5e46343023c6b51d6ce95e2423e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08e1ff9d6e5a419d5b4a60c077df549e81601d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e1ff9d6e5a419d5b4a60c077df549e81601d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08e1ff9d6e5a419d5b4a60c077df549e81601d9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e1ff9d6e5a419d5b4a60c077df549e81601d9b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4e50e500da7692aad53a4488aff32e056149b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e50e500da7692aad53a4488aff32e056149b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4e50e500da7692aad53a4488aff32e056149b3c"}], "stats": {"total": 180, "additions": 180, "deletions": 0}, "files": [{"sha": "622d6e9d0c5406c12abedd9623eb52ebcc972522", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e1ff9d6e5a419d5b4a60c077df549e81601d9b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e1ff9d6e5a419d5b4a60c077df549e81601d9b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=08e1ff9d6e5a419d5b4a60c077df549e81601d9b", "patch": "@@ -4222,6 +4222,14 @@ build_vec_init (tree base, tree maxindex, tree init,\n   else\n     ptype = atype;\n \n+  if (integer_all_onesp (maxindex))\n+    {\n+      /* Shortcut zero element case to avoid unneeded constructor synthesis.  */\n+      if (init && TREE_SIDE_EFFECTS (init))\n+\tbase = build2 (COMPOUND_EXPR, void_type_node, init, base);\n+      return base;\n+    }\n+\n   /* The code we are generating looks like:\n      ({\n        T* t1 = (T*) base;"}, {"sha": "0068ea854e1de9c98d951014bc300f31b2cd7960", "filename": "gcc/testsuite/g++.dg/ext/array4.C", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e1ff9d6e5a419d5b4a60c077df549e81601d9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farray4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e1ff9d6e5a419d5b4a60c077df549e81601d9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farray4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farray4.C?ref=08e1ff9d6e5a419d5b4a60c077df549e81601d9b", "patch": "@@ -0,0 +1,172 @@\n+// PR c++/101029\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" } allow [0]\n+\n+template <int __v> struct integral_constant {\n+  static constexpr int value = __v;\n+  typedef int value_type;\n+  constexpr operator value_type() { return __v; }\n+};\n+template <bool __v> using __bool_constant = integral_constant<__v>;\n+template <bool, typename> struct conditional;\n+template <typename...> struct __and_;\n+template <typename _B1, typename _B2, typename _B3, typename... _Bn>\n+struct __and_<_B1, _B2, _B3, _Bn...> : conditional<_B1::value, _B1> {};\n+template <typename _Tp>\n+constexpr integral_constant<true> __is_complete_or_unbounded(_Tp) {\n+  return {};\n+}\n+struct Trans_NS_std_formatter;\n+template <typename _Tp>\n+struct is_default_constructible : integral_constant<false> {\n+  static_assert(__is_complete_or_unbounded(_Tp{}), \"\");\n+};\n+template <typename _Tp, typename _Up>\n+struct is_same : integral_constant<__is_same_as(_Tp, _Up)> {};\n+template <bool> struct enable_if;\n+template <typename _Iffalse> struct conditional<false, _Iffalse> {\n+  typedef _Iffalse type;\n+};\n+struct pair {\n+  template <typename _U1 = int, typename _U2 = int,\n+            typename enable_if<__and_<is_default_constructible<_U1>, _U2,\n+                                      int>::valuebool>::type>\n+  pair();\n+};\n+\n+class BucketLogger;\n+struct __shared_ptr_access {\n+  using element_type = BucketLogger;\n+  element_type *operator->();\n+};\n+struct DcpProducer {\n+  __shared_ptr_access logger;\n+  void bufferAcknowledgement();\n+};\n+struct atomic {\n+  atomic(long);\n+};\n+inline namespace v7 {\n+template <bool B, class, class F>\n+using conditional_t = typename conditional<B, F>::type;\n+template <typename> struct basic_string_view { basic_string_view(int, int); };\n+template <typename, typename> struct formatter;\n+template <typename, typename>\n+using has_formatter =\n+    __bool_constant<__is_constructible(Trans_NS_std_formatter)>;\n+struct fallback_formatter;\n+template <typename Context> struct custom_value {\n+  using parse_context = typename Context::parse_context_type;\n+  void (*format)(const void *, parse_context &, Context &);\n+};\n+template <typename Context> struct value {\n+  float float_value;\n+  custom_value<Context> custom;\n+  template <typename T> value(T) {\n+    custom.format =\n+        format_custom_arg<T, conditional_t<has_formatter<T, Context>::value,\n+                                           typename Context::formatter_type<T>,\n+                                           fallback_formatter>>;\n+  }\n+  template <typename, typename Formatter>\n+  static void format_custom_arg(const void *arg,\n+                                typename Context::parse_context_type &,\n+                                Context &ctx) {\n+    Formatter f;\n+    f.format(*static_cast<const int *>(arg), ctx);\n+  }\n+};\n+enum { max_packed_args };\n+template <typename Context> struct basic_format_arg { value<Context> value_; };\n+template <typename Visitor, typename Context>\n+void visit_format_arg(Visitor vis, Context arg) {\n+  vis(arg.value_.float_value);\n+}\n+template <typename Context, typename T> basic_format_arg<Context> make_arg(T);\n+struct basic_format_context {\n+  using char_type = int;\n+  using parse_context_type = int;\n+  template <typename T> using formatter_type = formatter<T, char_type>;\n+};\n+struct format_arg_store {\n+  using value_type = conditional_t<max_packed_args, basic_format_context,\n+                                   basic_format_arg<basic_format_context>>;\n+  value_type data_;\n+};\n+template <typename... Args, typename S>\n+auto make_args_checked(S, Args... args) -> format_arg_store {\n+  return {args...};\n+}\n+struct basic_format_specs {};\n+template <typename Char, typename OutputIt, typename T>\n+void write(OutputIt, T, Char) {\n+  if (is_same<T, float>())\n+    ;\n+}\n+struct arg_formatter_base {\n+  using iterator = int;\n+  using format_specs = basic_format_specs;\n+  iterator out_;\n+  template <typename T> void operator()(T value) {\n+    auto specs = format_specs();\n+    write(out_, value, specs);\n+  }\n+};\n+struct arg_formatter : arg_formatter_base {\n+  using context_type = basic_format_context;\n+  arg_formatter(context_type, int *, format_specs *);\n+};\n+template <typename T, typename> struct formatter {\n+  template <typename FormatContext> void format(T val, FormatContext ctx) {\n+    using af = arg_formatter;\n+    basic_format_arg<FormatContext> __trans_tmp_2 = make_arg<FormatContext>(val);\n+    visit_format_arg(af(ctx, nullptr, &specs_), __trans_tmp_2);\n+  }\n+  basic_format_specs specs_;\n+};\n+} // namespace v7\n+namespace level {\n+enum level_enum { warn };\n+}\n+struct BucketLogger {\n+  template <typename S, typename... Args>\n+  void log(level::level_enum, const S &, Args &&...);\n+  template <typename... Args> void warn(const char *, const Args &...);\n+};\n+namespace v7 {\n+struct fallback_formatter : formatter<basic_string_view<int>, int> {\n+  template <typename OutputIt> void format(int, OutputIt ctx) {\n+    basic_string_view<int> str(0, 0);\n+    formatter::format(str, ctx);\n+  }\n+};\n+} // namespace v7\n+template <typename S, typename... Args>\n+void BucketLogger::log(level::level_enum, const S &fmt, Args &&...args) {\n+  make_args_checked(fmt, args...);\n+}\n+template <typename... Args>\n+void BucketLogger::warn(const char *fmt, const Args &...args) {\n+  log(level::warn, fmt, args...);\n+}\n+template <class KeyT> struct AtomicHashArray {\n+  static void create();\n+  atomic isFull_;\n+  atomic numErases_;\n+  pair cells_[0];\n+  AtomicHashArray(int, KeyT, KeyT, KeyT, double, unsigned);\n+};\n+template <class KeyT>\n+AtomicHashArray<KeyT>::AtomicHashArray(int, KeyT, KeyT, KeyT, double, unsigned)\n+    : isFull_(0), numErases_(0) {}\n+template <class KeyT> void AtomicHashArray<KeyT>::create() {\n+  int c_4, capacity;\n+  double c_3;\n+  char c_2, c_1, c_0;\n+  AtomicHashArray(capacity, c_0, c_1, c_2, c_3, c_4);\n+}\n+int bufferAcknowledgement_vbucket;\n+void DcpProducer::bufferAcknowledgement() {\n+  logger->warn(\"\", bufferAcknowledgement_vbucket);\n+}\n+void (*makeStreamsMap_p)() = AtomicHashArray<char>::create;"}]}