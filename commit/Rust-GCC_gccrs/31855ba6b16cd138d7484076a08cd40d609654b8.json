{"sha": "31855ba6b16cd138d7484076a08cd40d609654b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE4NTViYTZiMTZjZDEzOGQ3NDg0MDc2YTA4Y2Q0MGQ2MDk2NTRiOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-29T12:14:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-04T13:28:07Z"}, "message": "Add emulated gather capability to the vectorizer\n\nThis adds a gather vectorization capability to the vectorizer\nwithout target support by decomposing the offset vector, doing\nsclar loads and then building a vector from the result.  This\nis aimed mainly at cases where vectorizing the rest of the loop\noffsets the cost of vectorizing the gather.\n\nNote it's difficult to avoid vectorizing the offset load, but in\nsome cases later passes can turn the vector load + extract into\nscalar loads, see the followup patch.\n\nOn SPEC CPU 2017 510.parest_r this improves runtime from 250s\nto 219s on a Zen2 CPU which has its native gather instructions\ndisabled (using those the runtime instead increases to 254s)\nusing -Ofast -march=znver2 [-flto].  It turns out the critical\nloops in this benchmark all perform gather operations.\n\n2021-07-30  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_check_gather_scatter):\n\tInclude widening conversions only when the result is\n\tstill handed by native gather or the current offset\n\tsize not already matches the data size.\n\tAlso succeed analysis in case there's no native support,\n\tnoted by a IFN_LAST ifn and a NULL decl.\n\t(vect_analyze_data_refs): Always consider gathers.\n\t* tree-vect-patterns.c (vect_recog_gather_scatter_pattern):\n\tTest for no IFN gather rather than decl gather.\n\t* tree-vect-stmts.c (vect_model_load_cost): Pass in the\n\tgather-scatter info and cost emulated gathers accordingly.\n\t(vect_truncate_gather_scatter_offset): Properly test for\n\tno IFN gather.\n\t(vect_use_strided_gather_scatters_p): Likewise.\n\t(get_load_store_type): Handle emulated gathers and its\n\trestrictions.\n\t(vectorizable_load): Likewise.  Emulate them by extracting\n\tscalar offsets, doing scalar loads and a vector construct.\n\n\t* gcc.target/i386/vect-gather-1.c: New testcase.\n\t* gfortran.dg/vect/vect-8.f90: Adjust.", "tree": {"sha": "0aadaf8b611556e6771087979a40d839e0e6a276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aadaf8b611556e6771087979a40d839e0e6a276"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31855ba6b16cd138d7484076a08cd40d609654b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31855ba6b16cd138d7484076a08cd40d609654b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31855ba6b16cd138d7484076a08cd40d609654b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31855ba6b16cd138d7484076a08cd40d609654b8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2e5d2717d9e249edc5e0d45e49e4f9ef81fc694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e5d2717d9e249edc5e0d45e49e4f9ef81fc694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2e5d2717d9e249edc5e0d45e49e4f9ef81fc694"}], "stats": {"total": 155, "additions": 137, "deletions": 18}, "files": [{"sha": "261b66be061dfb8fd5e6fac622cea61d4954e1ec", "filename": "gcc/testsuite/gcc.target/i386/vect-gather-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-gather-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-gather-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-gather-1.c?ref=31855ba6b16cd138d7484076a08cd40d609654b8", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -msse2 -fdump-tree-vect-details -fdump-tree-forwprop4\" } */\n+\n+#ifndef INDEXTYPE\n+#define INDEXTYPE int\n+#endif\n+double vmul(INDEXTYPE *rowstart, INDEXTYPE *rowend,\n+\t    double *luval, double *dst)\n+{\n+  double res = 0;\n+  for (const INDEXTYPE * col = rowstart; col != rowend; ++col, ++luval)\n+        res += *luval * dst[*col];\n+  return res;\n+}\n+\n+/* With gather emulation this should be profitable to vectorize\n+   even with plain SSE2.  */\n+/* { dg-final { scan-tree-dump \"loop vectorized\" \"vect\" } } */\n+/* The index vector loads and promotions should be scalar after forwprop.  */\n+/* { dg-final { scan-tree-dump-not \"vec_unpack\" \"forwprop4\" } } */"}, {"sha": "cc1aebfbd841ae2539a59eff61ccfcd6ce676bc2", "filename": "gcc/testsuite/gfortran.dg/vect/vect-8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90?ref=31855ba6b16cd138d7484076a08cd40d609654b8", "patch": "@@ -706,5 +706,5 @@ END SUBROUTINE kernel\n \n ! { dg-final { scan-tree-dump-times \"vectorized 24 loops\" 1 \"vect\" { target aarch64_sve } } }\n ! { dg-final { scan-tree-dump-times \"vectorized 23 loops\" 1 \"vect\" { target { aarch64*-*-* && { ! aarch64_sve } } } } }\n-! { dg-final { scan-tree-dump-times \"vectorized 2\\[23\\] loops\" 1 \"vect\" { target { vect_intdouble_cvt && { ! aarch64*-*-* } } } } }\n+! { dg-final { scan-tree-dump-times \"vectorized 2\\[234\\] loops\" 1 \"vect\" { target { vect_intdouble_cvt && { ! aarch64*-*-* } } } } }\n ! { dg-final { scan-tree-dump-times \"vectorized 17 loops\" 1 \"vect\" { target { { ! vect_intdouble_cvt } && { ! aarch64*-*-* } } } } }"}, {"sha": "17d24b44fc1750f01a4b4c2f52198a7c8df6417a", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=31855ba6b16cd138d7484076a08cd40d609654b8", "patch": "@@ -4007,8 +4007,24 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \t      continue;\n \t    }\n \n-\t  if (TYPE_PRECISION (TREE_TYPE (op0))\n-\t      < TYPE_PRECISION (TREE_TYPE (off)))\n+\t  /* Include the conversion if it is widening and we're using\n+\t     the IFN path or the target can handle the converted from\n+\t     offset or the current size is not already the same as the\n+\t     data vector element size.  */\n+\t  if ((TYPE_PRECISION (TREE_TYPE (op0))\n+\t       < TYPE_PRECISION (TREE_TYPE (off)))\n+\t      && (use_ifn_p\n+\t\t  || (DR_IS_READ (dr)\n+\t\t      ? (targetm.vectorize.builtin_gather\n+\t\t\t && targetm.vectorize.builtin_gather (vectype,\n+\t\t\t\t\t\t\t      TREE_TYPE (op0),\n+\t\t\t\t\t\t\t      scale))\n+\t\t      : (targetm.vectorize.builtin_scatter\n+\t\t\t && targetm.vectorize.builtin_scatter (vectype,\n+\t\t\t\t\t\t\t       TREE_TYPE (op0),\n+\t\t\t\t\t\t\t       scale)))\n+\t\t  || !operand_equal_p (TYPE_SIZE (TREE_TYPE (off)),\n+\t\t\t\t       TYPE_SIZE (TREE_TYPE (vectype)), 0)))\n \t    {\n \t      off = op0;\n \t      offtype = TREE_TYPE (off);\n@@ -4036,7 +4052,8 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n       if (!vect_gather_scatter_fn_p (loop_vinfo, DR_IS_READ (dr), masked_p,\n \t\t\t\t     vectype, memory_type, offtype, scale,\n \t\t\t\t     &ifn, &offset_vectype))\n-\treturn false;\n+\tifn = IFN_LAST;\n+      decl = NULL_TREE;\n     }\n   else\n     {\n@@ -4050,10 +4067,6 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \t  if (targetm.vectorize.builtin_scatter)\n \t    decl = targetm.vectorize.builtin_scatter (vectype, offtype, scale);\n \t}\n-\n-      if (!decl)\n-\treturn false;\n-\n       ifn = IFN_LAST;\n       /* The offset vector type will be read from DECL when needed.  */\n       offset_vectype = NULL_TREE;\n@@ -4283,9 +4296,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf, bool *fatal)\n         {\n \t  bool maybe_gather\n \t    = DR_IS_READ (dr)\n-\t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n-\t      && (targetm.vectorize.builtin_gather != NULL\n-\t\t  || supports_vec_gather_load_p ());\n+\t      && !TREE_THIS_VOLATILE (DR_REF (dr));\n \t  bool maybe_scatter\n \t    = DR_IS_WRITE (dr)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))"}, {"sha": "25de97bd9b0c23f9566463ed07adcf580d3838cf", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=31855ba6b16cd138d7484076a08cd40d609654b8", "patch": "@@ -4811,7 +4811,7 @@ vect_recog_gather_scatter_pattern (vec_info *vinfo,\n      function for the gather/scatter operation.  */\n   gather_scatter_info gs_info;\n   if (!vect_check_gather_scatter (stmt_info, loop_vinfo, &gs_info)\n-      || gs_info.decl)\n+      || gs_info.ifn == IFN_LAST)\n     return NULL;\n \n   /* Convert the mask to the right form.  */"}, {"sha": "e6b81a0518cfad70472ed45786623bde70c38fcd", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 94, "deletions": 6, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31855ba6b16cd138d7484076a08cd40d609654b8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=31855ba6b16cd138d7484076a08cd40d609654b8", "patch": "@@ -1084,6 +1084,7 @@ static void\n vect_model_load_cost (vec_info *vinfo,\n \t\t      stmt_vec_info stmt_info, unsigned ncopies, poly_uint64 vf,\n \t\t      vect_memory_access_type memory_access_type,\n+\t\t      gather_scatter_info *gs_info,\n \t\t      slp_tree slp_node,\n \t\t      stmt_vector_for_cost *cost_vec)\n {\n@@ -1172,9 +1173,17 @@ vect_model_load_cost (vec_info *vinfo,\n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_GATHER_SCATTER)\n     {\n-      /* N scalar loads plus gathering them into a vector.  */\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n+      if (memory_access_type == VMAT_GATHER_SCATTER\n+\t  && gs_info->ifn == IFN_LAST && !gs_info->decl)\n+\t/* For emulated gathers N offset vector element extracts\n+\t   (we assume the scalar scaling and ptr + offset add is consumed by\n+\t   the load).  */\n+\tinside_cost += record_stmt_cost (cost_vec, ncopies * assumed_nunits,\n+\t\t\t\t\t vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t vect_body);\n+      /* N scalar loads plus gathering them into a vector.  */\n       inside_cost += record_stmt_cost (cost_vec,\n \t\t\t\t       ncopies * assumed_nunits,\n \t\t\t\t       scalar_load, stmt_info, 0, vect_body);\n@@ -1184,7 +1193,9 @@ vect_model_load_cost (vec_info *vinfo,\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tcost_vec, cost_vec, true);\n   if (memory_access_type == VMAT_ELEMENTWISE\n-      || memory_access_type == VMAT_STRIDED_SLP)\n+      || memory_access_type == VMAT_STRIDED_SLP\n+      || (memory_access_type == VMAT_GATHER_SCATTER\n+\t  && gs_info->ifn == IFN_LAST && !gs_info->decl))\n     inside_cost += record_stmt_cost (cost_vec, ncopies, vec_construct,\n \t\t\t\t     stmt_info, 0, vect_body);\n \n@@ -1866,7 +1877,8 @@ vect_truncate_gather_scatter_offset (stmt_vec_info stmt_info,\n       tree memory_type = TREE_TYPE (DR_REF (dr));\n       if (!vect_gather_scatter_fn_p (loop_vinfo, DR_IS_READ (dr), masked_p,\n \t\t\t\t     vectype, memory_type, offset_type, scale,\n-\t\t\t\t     &gs_info->ifn, &gs_info->offset_vectype))\n+\t\t\t\t     &gs_info->ifn, &gs_info->offset_vectype)\n+\t  || gs_info->ifn == IFN_LAST)\n \tcontinue;\n \n       gs_info->decl = NULL_TREE;\n@@ -1901,7 +1913,7 @@ vect_use_strided_gather_scatters_p (stmt_vec_info stmt_info,\n \t\t\t\t    gather_scatter_info *gs_info)\n {\n   if (!vect_check_gather_scatter (stmt_info, loop_vinfo, gs_info)\n-      || gs_info->decl)\n+      || gs_info->ifn == IFN_LAST)\n     return vect_truncate_gather_scatter_offset (stmt_info, loop_vinfo,\n \t\t\t\t\t\tmasked_p, gs_info);\n \n@@ -2355,6 +2367,27 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t\t\t     vls_type == VLS_LOAD ? \"gather\" : \"scatter\");\n \t  return false;\n \t}\n+      else if (gs_info->ifn == IFN_LAST && !gs_info->decl)\n+\t{\n+\t  if (vls_type != VLS_LOAD)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"unsupported emulated scatter.\\n\");\n+\t      return false;\n+\t    }\n+\t  else if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant ()\n+\t\t   || !known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t TYPE_VECTOR_SUBPARTS\n+\t\t\t\t   (gs_info->offset_vectype)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"unsupported vector types for emulated \"\n+\t\t\t\t \"gather.\\n\");\n+\t      return false;\n+\t    }\n+\t}\n       /* Gather-scatter accesses perform only component accesses, alignment\n \t is irrelevant for them.  */\n       *alignment_support_scheme = dr_unaligned_supported;\n@@ -8692,6 +8725,15 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t     \"unsupported access type for masked load.\\n\");\n \t  return false;\n \t}\n+      else if (memory_access_type == VMAT_GATHER_SCATTER\n+\t       && gs_info.ifn == IFN_LAST\n+\t       && !gs_info.decl)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported masked emulated gather.\\n\");\n+\t  return false;\n+\t}\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n@@ -8725,7 +8767,7 @@ vectorizable_load (vec_info *vinfo,\n \n       STMT_VINFO_TYPE (orig_stmt_info) = load_vec_info_type;\n       vect_model_load_cost (vinfo, stmt_info, ncopies, vf, memory_access_type,\n-\t\t\t    slp_node, cost_vec);\n+\t\t\t    &gs_info, slp_node, cost_vec);\n       return true;\n     }\n \n@@ -9438,7 +9480,8 @@ vectorizable_load (vec_info *vinfo,\n \t\t    unsigned int misalign;\n \t\t    unsigned HOST_WIDE_INT align;\n \n-\t\t    if (memory_access_type == VMAT_GATHER_SCATTER)\n+\t\t    if (memory_access_type == VMAT_GATHER_SCATTER\n+\t\t\t&& gs_info.ifn != IFN_LAST)\n \t\t      {\n \t\t\ttree zero = build_zero_cst (vectype);\n \t\t\ttree scale = size_int (gs_info.scale);\n@@ -9456,6 +9499,51 @@ vectorizable_load (vec_info *vinfo,\n \t\t\tdata_ref = NULL_TREE;\n \t\t\tbreak;\n \t\t      }\n+\t\t    else if (memory_access_type == VMAT_GATHER_SCATTER)\n+\t\t      {\n+\t\t\t/* Emulated gather-scatter.  */\n+\t\t\tgcc_assert (!final_mask);\n+\t\t\tunsigned HOST_WIDE_INT const_nunits\n+\t\t\t  = nunits.to_constant ();\n+\t\t\tvec<constructor_elt, va_gc> *ctor_elts;\n+\t\t\tvec_alloc (ctor_elts, const_nunits);\n+\t\t\tgimple_seq stmts = NULL;\n+\t\t\ttree idx_type = TREE_TYPE (TREE_TYPE (vec_offset));\n+\t\t\ttree scale = size_int (gs_info.scale);\n+\t\t\talign\n+\t\t\t  = get_object_alignment (DR_REF (first_dr_info->dr));\n+\t\t\ttree ltype = build_aligned_type (TREE_TYPE (vectype),\n+\t\t\t\t\t\t\t align);\n+\t\t\tfor (unsigned k = 0; k < const_nunits; ++k)\n+\t\t\t  {\n+\t\t\t    tree boff = size_binop (MULT_EXPR,\n+\t\t\t\t\t\t    TYPE_SIZE (idx_type),\n+\t\t\t\t\t\t    bitsize_int (k));\n+\t\t\t    tree idx = gimple_build (&stmts, BIT_FIELD_REF,\n+\t\t\t\t\t\t     idx_type, vec_offset,\n+\t\t\t\t\t\t     TYPE_SIZE (idx_type),\n+\t\t\t\t\t\t     boff);\n+\t\t\t    idx = gimple_convert (&stmts, sizetype, idx);\n+\t\t\t    idx = gimple_build (&stmts, MULT_EXPR,\n+\t\t\t\t\t\tsizetype, idx, scale);\n+\t\t\t    tree ptr = gimple_build (&stmts, PLUS_EXPR,\n+\t\t\t\t\t\t     TREE_TYPE (dataref_ptr),\n+\t\t\t\t\t\t     dataref_ptr, idx);\n+\t\t\t    ptr = gimple_convert (&stmts, ptr_type_node, ptr);\n+\t\t\t    tree elt = make_ssa_name (TREE_TYPE (vectype));\n+\t\t\t    tree ref = build2 (MEM_REF, ltype, ptr,\n+\t\t\t\t\t       build_int_cst (ref_type, 0));\n+\t\t\t    new_stmt = gimple_build_assign (elt, ref);\n+\t\t\t    gimple_seq_add_stmt (&stmts, new_stmt);\n+\t\t\t    CONSTRUCTOR_APPEND_ELT (ctor_elts, NULL_TREE, elt);\n+\t\t\t  }\n+\t\t\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t\t\tnew_stmt = gimple_build_assign (NULL_TREE,\n+\t\t\t\t\t\t\tbuild_constructor\n+\t\t\t\t\t\t\t  (vectype, ctor_elts));\n+\t\t\tdata_ref = NULL_TREE;\n+\t\t\tbreak;\n+\t\t      }\n \n \t\t    align =\n \t\t      known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));"}]}