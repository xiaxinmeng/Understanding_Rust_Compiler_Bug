{"sha": "af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY5MmFiMzY4YWQ3MDlmY2QyNmIzNjBkYzFjZjRlNTBiMGNkNjE4NQ==", "commit": {"author": {"name": "Ollie Wild", "email": "aaw@google.com", "date": "2007-07-01T20:49:29Z"}, "committer": {"name": "Ollie Wild", "email": "aaw@gcc.gnu.org", "date": "2007-07-01T20:49:29Z"}, "message": "name-lookup.c (ambiguous_decl): Fix case when new->value is hidden.\n\n\t* name-lookup.c (ambiguous_decl): Fix case when new->value is hidden.\n\t(select_decl): Remove function.\n\t(unqualified_namespace_lookup): Populate binding by calling\n\tambiguous_decl.  Remove select_decl call.\n\t(lookup_qualified_name): Remove select_decl call.\n\t* decl.c (lookup_and_check_tag): Check for ambiguous references.\n\t* parser.c (cp_parser_elaborated_type_specifier): Skip redundant error\n\tgeneration when name lookup is ambiguous.\n\n\t* g++.dg/lookup/using16.C: New test.\n\t* g++.dg/lookup/using17.C: New test.\n\nFrom-SVN: r126177", "tree": {"sha": "3d4fa643b8d41d6d480c77eb01d90ee5dc80d4ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d4fa643b8d41d6d480c77eb01d90ee5dc80d4ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/comments", "author": {"login": "olliewild", "id": 11523068, "node_id": "MDQ6VXNlcjExNTIzMDY4", "avatar_url": "https://avatars.githubusercontent.com/u/11523068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olliewild", "html_url": "https://github.com/olliewild", "followers_url": "https://api.github.com/users/olliewild/followers", "following_url": "https://api.github.com/users/olliewild/following{/other_user}", "gists_url": "https://api.github.com/users/olliewild/gists{/gist_id}", "starred_url": "https://api.github.com/users/olliewild/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olliewild/subscriptions", "organizations_url": "https://api.github.com/users/olliewild/orgs", "repos_url": "https://api.github.com/users/olliewild/repos", "events_url": "https://api.github.com/users/olliewild/events{/privacy}", "received_events_url": "https://api.github.com/users/olliewild/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31c97dfe34220de54c1d93ce858af83bfda31fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c97dfe34220de54c1d93ce858af83bfda31fd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c97dfe34220de54c1d93ce858af83bfda31fd3"}], "stats": {"total": 190, "additions": 115, "deletions": 75}, "files": [{"sha": "aeb0e5c720a13a7474f6d70416102de4852a3baf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -1,3 +1,14 @@\n+2007-07-01  Ollie Wild  <aaw@google.com>\n+\n+\t* name-lookup.c (ambiguous_decl): Fix case when new->value is hidden.\n+\t(select_decl): Remove function.\n+\t(unqualified_namespace_lookup): Populate binding by calling\n+\tambiguous_decl.  Remove select_decl call.\n+\t(lookup_qualified_name): Remove select_decl call.\n+\t* decl.c (lookup_and_check_tag): Check for ambiguous references.\n+\t* parser.c (cp_parser_elaborated_type_specifier): Skip redundant error\n+\tgeneration when name lookup is ambiguous.\n+\n 2007-06-29  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/31724"}, {"sha": "1fae5f8cd6aacdadefdbc71a1b7e2091946184b2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -9933,6 +9933,12 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n \t\t\t\t\t   | DECL_SELF_REFERENCE_P (decl));\n       return t;\n     }\n+  else if (decl && TREE_CODE (decl) == TREE_LIST)\n+    {\n+      error (\"reference to %qD is ambiguous\", name);\n+      print_candidates (decl);\n+      return error_mark_node;\n+    }\n   else\n     return NULL_TREE;\n }"}, {"sha": "068725859ff9b0486be0ae6208e756b87b1df2be", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 52, "deletions": 74, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -42,7 +42,6 @@ struct scope_binding {\n #define EMPTY_SCOPE_BINDING { NULL_TREE, NULL_TREE }\n \n static cxx_scope *innermost_nonclass_level (void);\n-static tree select_decl (const struct scope_binding *, int);\n static cxx_binding *binding_for_name (cxx_scope *, tree);\n static tree lookup_name_innermost_nonclass_level (tree);\n static tree push_overloaded_decl (tree, int, bool);\n@@ -3497,36 +3496,55 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n {\n   tree val, type;\n   gcc_assert (old != NULL);\n+\n+  /* Copy the type.  */\n+  type = new->type;\n+  if (LOOKUP_NAMESPACES_ONLY (flags)\n+      || (type && hidden_name_p (type) && !(flags & LOOKUP_HIDDEN)))\n+    type = NULL_TREE;\n+\n   /* Copy the value.  */\n   val = new->value;\n   if (val)\n-    switch (TREE_CODE (val))\n-      {\n-      case TEMPLATE_DECL:\n-\t/* If we expect types or namespaces, and not templates,\n-\t   or this is not a template class.  */\n-\tif ((LOOKUP_QUALIFIERS_ONLY (flags)\n-\t     && !DECL_CLASS_TEMPLATE_P (val))\n-\t    || hidden_name_p (val))\n-\t  val = NULL_TREE;\n-\tbreak;\n-      case TYPE_DECL:\n-\tif (LOOKUP_NAMESPACES_ONLY (flags) || hidden_name_p (val))\n-\t  val = NULL_TREE;\n-\tbreak;\n-      case NAMESPACE_DECL:\n-\tif (LOOKUP_TYPES_ONLY (flags))\n-\t  val = NULL_TREE;\n-\tbreak;\n-      case FUNCTION_DECL:\n-\t/* Ignore built-in functions that are still anticipated.  */\n-\tif (LOOKUP_QUALIFIERS_ONLY (flags) || hidden_name_p (val))\n-\t  val = NULL_TREE;\n-\tbreak;\n-      default:\n-\tif (LOOKUP_QUALIFIERS_ONLY (flags))\n-\t  val = NULL_TREE;\n-      }\n+    {\n+      if (hidden_name_p (val) && !(flags & LOOKUP_HIDDEN))\n+\tval = NULL_TREE;\n+      else\n+\tswitch (TREE_CODE (val))\n+\t  {\n+\t  case TEMPLATE_DECL:\n+\t    /* If we expect types or namespaces, and not templates,\n+\t       or this is not a template class.  */\n+\t    if ((LOOKUP_QUALIFIERS_ONLY (flags)\n+\t\t && !DECL_CLASS_TEMPLATE_P (val)))\n+\t      val = NULL_TREE;\n+\t    break;\n+\t  case TYPE_DECL:\n+\t    if (LOOKUP_NAMESPACES_ONLY (flags)\n+\t\t|| (type && (flags & LOOKUP_PREFER_TYPES)))\n+\t      val = NULL_TREE;\n+\t    break;\n+\t  case NAMESPACE_DECL:\n+\t    if (LOOKUP_TYPES_ONLY (flags))\n+\t      val = NULL_TREE;\n+\t    break;\n+\t  case FUNCTION_DECL:\n+\t    /* Ignore built-in functions that are still anticipated.  */\n+\t    if (LOOKUP_QUALIFIERS_ONLY (flags))\n+\t      val = NULL_TREE;\n+\t    break;\n+\t  default:\n+\t    if (LOOKUP_QUALIFIERS_ONLY (flags))\n+\t      val = NULL_TREE;\n+\t  }\n+    }\n+\n+  /* If val is hidden, shift down any class or enumeration name.  */\n+  if (!val)\n+    {\n+      val = type;\n+      type = NULL_TREE;\n+    }\n \n   if (!old->value)\n     old->value = val;\n@@ -3537,14 +3555,11 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n       else\n \t{\n \t  old->value = tree_cons (NULL_TREE, old->value,\n-\t\t\t\t  build_tree_list (NULL_TREE, new->value));\n+\t\t\t\t  build_tree_list (NULL_TREE, val));\n \t  TREE_TYPE (old->value) = error_mark_node;\n \t}\n     }\n-  /* ... and copy the type.  */\n-  type = new->type;\n-  if (LOOKUP_NAMESPACES_ONLY (flags) || (type && hidden_name_p (type)))\n-    type = NULL_TREE;\n+\n   if (!old->type)\n     old->type = type;\n   else if (type && old->type != type)\n@@ -3644,36 +3659,6 @@ remove_hidden_names (tree fns)\n   return fns;\n }\n \n-/* Select the right _DECL from multiple choices.  */\n-\n-static tree\n-select_decl (const struct scope_binding *binding, int flags)\n-{\n-  tree val;\n-  val = binding->value;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (LOOKUP_NAMESPACES_ONLY (flags))\n-    {\n-      /* We are not interested in types.  */\n-      if (val && (TREE_CODE (val) == NAMESPACE_DECL\n-\t\t  || TREE_CODE (val) == TREE_LIST))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-    }\n-\n-  /* If looking for a type, or if there is no non-type binding, select\n-     the value binding.  */\n-  if (binding->type && (!val || (flags & LOOKUP_PREFER_TYPES)))\n-    val = binding->type;\n-  /* Don't return non-types if we really prefer types.  */\n-  else if (val && LOOKUP_TYPES_ONLY (flags)\n-\t   && ! DECL_DECLARES_TYPE_P (val))\n-    val = NULL_TREE;\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-}\n-\n /* Unscoped lookup of a global: iterate over current namespaces,\n    considering using-directives.  */\n \n@@ -3685,24 +3670,17 @@ unqualified_namespace_lookup (tree name, int flags)\n   tree siter;\n   struct cp_binding_level *level;\n   tree val = NULL_TREE;\n-  struct scope_binding binding = EMPTY_SCOPE_BINDING;\n \n   timevar_push (TV_NAME_LOOKUP);\n \n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n+      struct scope_binding binding = EMPTY_SCOPE_BINDING;\n       cxx_binding *b =\n \t cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n \n       if (b)\n-\t{\n-\t  if (b->value\n-\t      && ((flags & LOOKUP_HIDDEN) || !hidden_name_p (b->value)))\n-\t    binding.value = b->value;\n-\t  if (b->type\n-\t      && ((flags & LOOKUP_HIDDEN) || !hidden_name_p (b->type)))\n-\t    binding.type = b->type;\n-\t}\n+\tambiguous_decl (name, &binding, b, flags);\n \n       /* Add all _DECLs seen through local using-directives.  */\n       for (level = current_binding_level;\n@@ -3727,7 +3705,7 @@ unqualified_namespace_lookup (tree name, int flags)\n \t  siter = CP_DECL_CONTEXT (siter);\n \t}\n \n-      val = select_decl (&binding, flags);\n+      val = binding.value;\n       if (scope == global_namespace)\n \tbreak;\n     }\n@@ -3757,7 +3735,7 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n       if (is_type_p)\n \tflags |= LOOKUP_PREFER_TYPES;\n       if (qualified_lookup_using_namespace (name, scope, &binding, flags))\n-\tt = select_decl (&binding, flags);\n+\tt = binding.value;\n     }\n   else if (is_aggr_type (scope, complain))\n     t = lookup_member (scope, name, 2, is_type_p);"}, {"sha": "484c6b5a5cc665697fb88c4570b5d631c7ec9ac9", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -10855,13 +10855,19 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       if (parser->scope)\n \t{\n \t  tree decl;\n+\t  tree ambiguous_decls;\n \n \t  decl = cp_parser_lookup_name (parser, identifier,\n \t\t\t\t\ttag_type,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true,\n-\t\t\t\t\t/*ambiguous_decls=*/NULL);\n+\t\t\t\t\t&ambiguous_decls);\n+\n+\t  /* If the lookup was ambiguous, an error will already have been\n+\t     issued.  */\n+\t  if (ambiguous_decls)\n+\t    return error_mark_node;\n \n \t  /* If we are parsing friend declaration, DECL may be a\n \t     TEMPLATE_DECL tree node here.  However, we need to check"}, {"sha": "5b390d32a191a28c0e3647f207d85ca593695d7d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -1,3 +1,8 @@\n+2007-07-01  Ollie Wild  <aaw@google.com>\n+\n+\t* g++.dg/lookup/using16.C: New test.\n+\t* g++.dg/lookup/using17.C: New test.\n+\n 2007-07-01  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/32239"}, {"sha": "e373f3778977b7d3112186774333b5119c5b7eda", "filename": "gcc/testsuite/g++.dg/lookup/using16.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing16.C?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -0,0 +1,19 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+namespace M {\n+  struct S {}; // { dg-error \"candidates are: struct M::S\" \"candidate 1\" }\n+}\n+\n+namespace N {\n+  int S;\n+  struct S {}; // { dg-error \"struct N::S\" \"candidate 2\" }\n+}\n+\n+using namespace M;\n+using namespace N;\n+\n+struct ::S s; // { dg-bogus \"ambiguous.*ambiguous\" \"duplicate error\" }\n+// { dg-error \"reference to 'S' is ambiguous\" \"\" { target *-*-* } 17 }}\n+// { dg-error \"invalid type\" \"\" { target *-*-* } 17 }"}, {"sha": "59888852c42af45d26364d8cee3f67c4e13ff697", "filename": "gcc/testsuite/g++.dg/lookup/using17.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af92ab368ad709fcd26b360dc1cf4e50b0cd6185/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing17.C?ref=af92ab368ad709fcd26b360dc1cf4e50b0cd6185", "patch": "@@ -0,0 +1,15 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+namespace M {\n+  struct S {}; // { dg-error \"struct M::S\" \"candidate 2\" }\n+}\n+\n+int S;\n+struct S {}; // { dg-error \"candidates are: struct S\" \"candidate 1\" }\n+\n+using namespace M;\n+\n+struct S s; // { dg-error \"reference to 'S' is ambiguous\" \"\" }\n+// { dg-error \"invalid type in declaration\" \"\" { target *-*-* } 14 }"}]}