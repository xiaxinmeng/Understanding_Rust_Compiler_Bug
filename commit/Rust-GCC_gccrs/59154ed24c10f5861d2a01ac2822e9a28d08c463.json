{"sha": "59154ed24c10f5861d2a01ac2822e9a28d08c463", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkxNTRlZDI0YzEwZjU4NjFkMmEwMWFjMjgyMmU5YTI4ZDA4YzQ2Mw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@verizon.net", "date": "2005-09-14T20:18:19Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-09-14T20:18:19Z"}, "message": "PR fortran/21875 Internal Unit Array I/O, NIST\n\n2005-09-14  Jerry DeLisle  <jvdelisle@verizon.net\n\n\tPR fortran/21875 Internal Unit Array I/O, NIST\n\t* libgfortran.h: Add run time error code for array stride.\n\t* runtime/error.c (translate_error): Add error message for\n\tarray stride.\n\t* io/io.h: Add array descriptor pointer to IOPARM structure.\n\tAdd prtotypes for two new functions.\n\t* io/transfer.c (data_transfer_init): Removed initialization and\n\tmoved to unit.c (get_unit)\n\t* io/transfer.c (next_record_r): Include internal unit read\n\tfunctionality.\n\t* io/transfer.c (next_record_w): Include internal unit write\n\tfunctionality, including padding of character array records.\n\t* io/unit.c (get_array_unit_len): New function to return the number\n\tof records in the character array 'file' from the array descriptor.\n\t* io/unit.c (get_unit): Gathered initialization code from\n\tinit_data_transfer for internal units and added initialization of\n\tcharacter array unit.\n\t* io/unit.c (is_array_io): New function to determine if internal unit\n\tis an array.\n\t* io/unix.c (mem_alloc_w_at): Add error checks for bad record length\n\tand end of file.\n\nFrom-SVN: r104276", "tree": {"sha": "b7bbd7592f231bcb71427e42df3994eb7b534c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7bbd7592f231bcb71427e42df3994eb7b534c32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59154ed24c10f5861d2a01ac2822e9a28d08c463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59154ed24c10f5861d2a01ac2822e9a28d08c463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59154ed24c10f5861d2a01ac2822e9a28d08c463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59154ed24c10f5861d2a01ac2822e9a28d08c463/comments", "author": null, "committer": null, "parents": [{"sha": "7ad00e132508704abc2fd3d785b42ab4310880a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad00e132508704abc2fd3d785b42ab4310880a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ad00e132508704abc2fd3d785b42ab4310880a4"}], "stats": {"total": 165, "additions": 132, "deletions": 33}, "files": [{"sha": "bd2b872c857a2576bbb91f565800d2882daa6e08", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -1,3 +1,27 @@\n+2005-09-14  Jerry DeLisle  <jvdelisle@verizon.net\n+\n+\tPR fortran/21875 Internal Unit Array I/O, NIST\n+\t* libgfortran.h: Add run time error code for array stride.\n+\t* runtime/error.c (translate_error): Add error message for\n+\tarray stride.\n+\t* io/io.h: Add array descriptor pointer to IOPARM structure.\n+\tAdd prtotypes for two new functions.\n+\t* io/transfer.c (data_transfer_init): Removed initialization and\n+\tmoved to unit.c (get_unit)\n+\t* io/transfer.c (next_record_r): Include internal unit read\n+\tfunctionality.\n+\t* io/transfer.c (next_record_w): Include internal unit write\n+\tfunctionality, including padding of character array records.\n+\t* io/unit.c (get_array_unit_len): New function to return the number\n+\tof records in the character array 'file' from the array descriptor.\n+\t* io/unit.c (get_unit): Gathered initialization code from\n+\tinit_data_transfer for internal units and added initialization of\n+\tcharacter array unit.\n+\t* io/unit.c (is_array_io): New function to determine if internal unit\n+\tis an array.\n+\t* io/unix.c (mem_alloc_w_at): Add error checks for bad record length\n+\tand end of file.\n+\n 2005-09-13  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR target/19269"}, {"sha": "4f5f88a58cdf609479d35206c6b8787e3fe14453", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -251,6 +251,7 @@ typedef struct\n   CHARACTER (advance);\n   CHARACTER (name);\n   CHARACTER (internal_unit);\n+  gfc_array_char *internal_unit_desc;\n   CHARACTER (sequential);\n   CHARACTER (direct);\n   CHARACTER (formatted);\n@@ -525,6 +526,12 @@ internal_proto(close_unit);\n extern int is_internal_unit (void);\n internal_proto(is_internal_unit);\n \n+extern int is_array_io (void);\n+internal_proto(is_array_io);\n+\n+extern gfc_offset get_array_unit_len (gfc_array_char *);\n+internal_proto(get_array_unit_len);\n+\n extern gfc_unit *find_unit (int);\n internal_proto(find_unit);\n "}, {"sha": "a279f92151e5f74cffeae1b883085b567ca55844", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -292,14 +292,14 @@ void *\n write_block (int length)\n {\n   char *dest;\n-\n-  if (!is_internal_unit() && current_unit->bytes_left < length)\n+  \n+  if (current_unit->bytes_left < length)\n     {\n       generate_error (ERROR_EOR, NULL);\n       return NULL;\n     }\n \n-  current_unit->bytes_left -= length;\n+  current_unit->bytes_left -= (gfc_offset)length;\n   dest = salloc_w (current_unit->s, &length);\n \n   if (ioparm.size != NULL)\n@@ -1021,15 +1021,6 @@ data_transfer_init (int read_flag)\n   if (current_unit == NULL)\n     return;\n \n-  if (is_internal_unit())\n-    {\n-      current_unit->recl = file_length(current_unit->s);\n-      if (g.mode==WRITING)\n-        empty_internal_buffer (current_unit->s);\n-      else\n-        current_unit->bytes_left = current_unit->recl;\t\n-    }\n-\n   /* Check the action.  */\n \n   if (read_flag && current_unit->flags.action == ACTION_WRITE)\n@@ -1267,7 +1258,7 @@ data_transfer_init (int read_flag)\n static void\n next_record_r (void)\n {\n-  int rlength, length;\n+  int rlength, length, bytes_left;\n   gfc_offset new;\n   char *p;\n \n@@ -1321,16 +1312,18 @@ next_record_r (void)\n \t  break;\n \t}\n \n-      do\n+      if (is_internal_unit())\n+\t{\n+\t  bytes_left = (int) current_unit->bytes_left;\n+\t  p = salloc_r (current_unit->s, &bytes_left);\n+\t  if (p != NULL)\n+\t    current_unit->bytes_left = current_unit->recl;\n+\t  break;\n+\t}\n+      else do\n \t{\n \t  p = salloc_r (current_unit->s, &length);\n \n-\t  /* In case of internal file, there may not be any '\\n'.  */\n-\t  if (is_internal_unit() && p == NULL)\n-\t    {\n-\t       break;\n-\t    }\n-\n \t  if (p == NULL)\n \t    {\n \t      generate_error (ERROR_OS, NULL);\n@@ -1359,7 +1352,7 @@ static void\n next_record_w (void)\n {\n   gfc_offset c, m;\n-  int length;\n+  int length, bytes_left;\n   char *p;\n \n   /* Zero counters for X- and T-editing.  */\n@@ -1422,15 +1415,36 @@ next_record_w (void)\n       break;\n \n     case FORMATTED_SEQUENTIAL:\n+\n+      if (current_unit->bytes_left == 0)\n+\tbreak;\n+\t\n+      if (is_internal_unit())\n+\t{\n+\t  if (is_array_io())\n+\t    {\n+\t      bytes_left = (int) current_unit->bytes_left;\n+\t      p = salloc_w (current_unit->s, &bytes_left);\n+\t      if (p != NULL)\n+\t\t{\n+\t\t  memset(p, ' ', bytes_left);\n+\t          current_unit->bytes_left = current_unit->recl;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      length = 1;\n+\t      p = salloc_w (current_unit->s, &length);\n+\t    }\n+ \t}\n+      else\n+\t{\n #ifdef HAVE_CRLF\n-      length = 2;\n+\t  length = 2;\n #else\n-      length = 1;\n+\t  length = 1;\n #endif\n-      p = salloc_w (current_unit->s, &length);\n-\n-      if (!is_internal_unit())\n-\t{\n+\t  p = salloc_w (current_unit->s, &length);\n \t  if (p)\n \t    {  /* No new line for internal writes.  */\n #ifdef HAVE_CRLF\n@@ -1444,9 +1458,6 @@ next_record_w (void)\n \t    goto io_error;\n \t}\n \n-      if (sfree (current_unit->s) == FAILURE)\n-\tgoto io_error;\n-\n       break;\n \n     io_error:"}, {"sha": "586e9edf3d36090a4300f97820c2dc0eb56ab57b", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -244,6 +244,32 @@ find_unit (int n)\n   return p;\n }\n \n+\n+/* get_array_unit_len()-- return the number of records in the array. */\n+\n+gfc_offset\n+get_array_unit_len (gfc_array_char *desc)\n+{\n+  gfc_offset record_count;\n+  int i, rank, stride;\n+  rank = GFC_DESCRIPTOR_RANK(desc);\n+  record_count = stride = 1;\n+  for (i=0;i<rank;++i)\n+    {\n+      /* Check that array is contiguous */\n+      \n+      if (desc->dim[i].stride != stride)\n+\t{\n+\t  generate_error (ERROR_ARRAY_STRIDE, NULL);\n+\t  return NULL;\n+\t}\n+      stride *= desc->dim[i].ubound;\n+      record_count *= desc->dim[i].ubound;\n+    }\n+  return record_count;\n+}\n+\n+ \n /* get_unit()-- Returns the unit structure associated with the integer\n  * unit or the internal file. */\n \n@@ -252,8 +278,18 @@ get_unit (int read_flag __attribute__ ((unused)))\n {\n   if (ioparm.internal_unit != NULL)\n     {\n+      internal_unit.recl = ioparm.internal_unit_len;\n+      if (is_array_io()) ioparm.internal_unit_len *=\n+\t\t\t   get_array_unit_len(ioparm.internal_unit_desc);\n       internal_unit.s =\n \topen_internal (ioparm.internal_unit, ioparm.internal_unit_len);\n+      internal_unit.bytes_left = internal_unit.recl;\n+      internal_unit.last_record=0;\n+      internal_unit.maxrec=0;\n+      internal_unit.current_record=0;\n+\n+      if (g.mode==WRITING && !is_array_io())\n+        empty_internal_buffer (internal_unit.s);\n \n       /* Set flags for the internal unit */\n \n@@ -271,8 +307,7 @@ get_unit (int read_flag __attribute__ ((unused)))\n }\n \n \n-/* is_internal_unit()-- Determine if the current unit is internal or\n- * not */\n+/* is_internal_unit()-- Determine if the current unit is internal or not */\n \n int\n is_internal_unit (void)\n@@ -281,6 +316,14 @@ is_internal_unit (void)\n }\n \n \n+/* is_array_io ()-- Determine if the I/O is to/from an array */\n+\n+int\n+is_array_io (void)\n+{\n+  return (ioparm.internal_unit_desc != NULL);\n+}\n+\n \n /*************************/\n /* Initialize everything */"}, {"sha": "e402f4432c9c2ff2db38fa94bfb779590732bf19", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02110-1301, USA.  */\n #include <stdio.h>\n #include <sys/stat.h>\n #include <fcntl.h>\n+#include <assert.h>\n \n #ifdef HAVE_SYS_MMAN_H\n #include <sys/mman.h>\n@@ -618,14 +619,22 @@ mem_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n {\n   gfc_offset m;\n \n+  assert (*len >= 0);  /* Negative values not allowed. */\n+  \n   if (where == -1)\n     where = s->logical_offset;\n \n   m = where + *len;\n \n-  if (where < s->buffer_offset || m > s->buffer_offset + s->active)\n+  if (where < s->buffer_offset)\n     return NULL;\n \n+  if (m > s->file_length)\n+    {\n+      generate_error (ERROR_END, NULL);\n+      return NULL;\n+    }\n+\n   s->logical_offset = m;\n \n   return s->buffer + (where - s->buffer_offset);"}, {"sha": "07f0614a0b3eac372991160df3891618988eff75", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -344,6 +344,7 @@ typedef enum\n   ERROR_BAD_US,\n   ERROR_READ_VALUE,\n   ERROR_READ_OVERFLOW,\n+  ERROR_ARRAY_STRIDE,\n   ERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n }\n error_codes;"}, {"sha": "7c708e3db4edc4159772b1ecab19b8d70201ffd4", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59154ed24c10f5861d2a01ac2822e9a28d08c463/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=59154ed24c10f5861d2a01ac2822e9a28d08c463", "patch": "@@ -431,6 +431,10 @@ translate_error (int code)\n       p = \"Numeric overflow on read\";\n       break;\n \n+    case ERROR_ARRAY_STRIDE:\n+      p = \"Array unit stride must be 1\";\n+      break;\n+\n     default:\n       p = \"Unknown error code\";\n       break;"}]}