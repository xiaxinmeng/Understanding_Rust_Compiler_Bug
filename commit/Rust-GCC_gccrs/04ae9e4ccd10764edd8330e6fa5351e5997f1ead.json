{"sha": "04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRhZTllNGNjZDEwNzY0ZWRkODMzMGU2ZmE1MzUxZTU5OTdmMWVhZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T21:44:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T21:44:34Z"}, "message": "(ereal_from_float, .._double): Change arg from long to HOST_WIDE_INT\nand unpack the HOST_WIDE_INTs.\n\nFrom-SVN: r7312", "tree": {"sha": "40f772ec466705d03c1c5e1f1378c12c1aaf4bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40f772ec466705d03c1c5e1f1378c12c1aaf4bf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ae9e4ccd10764edd8330e6fa5351e5997f1ead/comments", "author": null, "committer": null, "parents": [{"sha": "403cd5d7f822a8e000cf814275f4fecaa25fa591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403cd5d7f822a8e000cf814275f4fecaa25fa591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/403cd5d7f822a8e000cf814275f4fecaa25fa591"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "ba26cbdb28ab468e61185a05ceee02bedbf95c7c", "filename": "gcc/real.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04ae9e4ccd10764edd8330e6fa5351e5997f1ead/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04ae9e4ccd10764edd8330e6fa5351e5997f1ead/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=04ae9e4ccd10764edd8330e6fa5351e5997f1ead", "patch": "@@ -5489,7 +5489,7 @@ make_nan (nan, sign, mode)\n \n REAL_VALUE_TYPE\n ereal_from_float (f)\n-     unsigned long f;\n+     HOST_WIDE_INT f;\n {\n   REAL_VALUE_TYPE r;\n   unsigned EMUSHORT s[2];\n@@ -5516,31 +5516,49 @@ ereal_from_float (f)\n    This is the inverse of the function `etardouble' invoked by\n    REAL_VALUE_TO_TARGET_DOUBLE.\n \n-   The DFmode is stored as an array of long ints\n-   with 32 bits of the value per each long.  The first element\n+   The DFmode is stored as an array of HOST_WIDE_INT in the target's\n+   data format, with no holes in the bit packing.  The first element\n    of the input array holds the bits that would come first in the\n    target computer's memory.  */\n \n REAL_VALUE_TYPE\n ereal_from_double (d)\n-     unsigned long d[];\n+     HOST_WIDE_INT d[];\n {\n   REAL_VALUE_TYPE r;\n   unsigned EMUSHORT s[4];\n   unsigned EMUSHORT e[NE];\n \n-  /* Convert array of 32 bit pieces to equivalent array of 16 bit pieces.\n-   This is the inverse of `endian'.   */\n+  /* Convert array of HOST_WIDE_INT to equivalent array of 16-bit pieces.  */\n #if FLOAT_WORDS_BIG_ENDIAN\n   s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n   s[1] = (unsigned EMUSHORT) d[0];\n-  s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n-  s[3] = (unsigned EMUSHORT) d[1];\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    {\n+      /* In this case the entire target double is contained in the\n+         first array element.  The second element of the input is ignored.  */\n+      s[2] = (unsigned EMUSHORT) (d[0] >> 48);\n+      s[3] = (unsigned EMUSHORT) (d[0] >> 32);\n+    }\n+  else\n+    {\n+      s[2] = (unsigned EMUSHORT) (d[1] >> 16);\n+      s[3] = (unsigned EMUSHORT) d[1];\n+    }\n #else\n+/* Target float words are little-endian.  */\n   s[0] = (unsigned EMUSHORT) d[0];\n   s[1] = (unsigned EMUSHORT) (d[0] >> 16);\n-  s[2] = (unsigned EMUSHORT) d[1];\n-  s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    {\n+      s[2] = (unsigned EMUSHORT) (d[0] >> 32);\n+      s[3] = (unsigned EMUSHORT) (d[0] >> 48);\n+    }\n+  else\n+    {\n+      s[2] = (unsigned EMUSHORT) d[1];\n+      s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n+    }\n #endif\n   /* Convert target double to E-type. */\n   e53toe (s, e);"}]}