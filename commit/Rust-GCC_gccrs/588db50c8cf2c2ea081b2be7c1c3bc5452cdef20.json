{"sha": "588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg4ZGI1MGM4Y2YyYzJlYTA4MWIyYmU3YzFjM2JjNTQ1MmNkZWYyMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:55:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:55:27Z"}, "message": "poly_int: get_ref_base_and_extent\n\nThis patch changes the types of the bit offsets and sizes returned\nby get_ref_base_and_extent to poly_int64.\n\nThere are some callers that can't sensibly operate on polynomial\noffsets or handle cases where the offset and size aren't known\nexactly.  This includes the IPA devirtualisation code (since\nthere's no defined way of having vtables at variable offsets)\nand some parts of the DWARF code.  The patch therefore adds\na helper function get_ref_base_and_extent_hwi that either returns\nexact HOST_WIDE_INT bit positions and sizes or returns a null\nbase to indicate failure.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-dfa.h (get_ref_base_and_extent): Return the base, size and\n\tmax_size as poly_int64_pods rather than HOST_WIDE_INTs.\n\t(get_ref_base_and_extent_hwi): Declare.\n\t* tree-dfa.c (get_ref_base_and_extent): Return the base, size and\n\tmax_size as poly_int64_pods rather than HOST_WIDE_INTs.\n\t(get_ref_base_and_extent_hwi): New function.\n\t* cfgexpand.c (expand_debug_expr): Update call to\n\tget_ref_base_and_extent.\n\t* dwarf2out.c (add_var_loc_to_decl): Likewise.\n\t* gimple-fold.c (get_base_constructor): Return the offset as a\n\tpoly_int64_pod rather than a HOST_WIDE_INT.\n\t(fold_const_aggregate_ref_1): Track polynomial sizes and offsets.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::set_by_invariant)\n\t(extr_type_from_vtbl_ptr_store): Track polynomial offsets.\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context)\n\t(check_stmt_for_type_change): Use get_ref_base_and_extent_hwi\n\trather than get_ref_base_and_extent.\n\t(ipa_polymorphic_call_context::get_dynamic_type): Likewise.\n\t* ipa-prop.c (ipa_load_from_parm_agg, compute_complex_assign_jump_func)\n\t(get_ancestor_addr_info, determine_locally_known_aggregate_parts):\n\tLikewise.\n\t* ipa-param-manipulation.c (ipa_get_adjustment_candidate): Update\n\tcall to get_ref_base_and_extent.\n\t* tree-sra.c (create_access, get_access_for_expr): Likewise.\n\t* tree-ssa-alias.c (ao_ref_base, aliasing_component_refs_p)\n\t(stmt_kills_ref_p): Likewise.\n\t* tree-ssa-dce.c (mark_aliased_reaching_defs_necessary_1): Likewise.\n\t* tree-ssa-scopedtables.c (avail_expr_hash, equal_mem_array_ref_p):\n\tLikewise.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Likewise.\n\tUse get_ref_base_and_extent_hwi rather than get_ref_base_and_extent\n\twhen calling native_encode_expr.\n\t* tree-ssa-structalias.c (get_constraint_for_component_ref): Update\n\tcall to get_ref_base_and_extent.\n\t(do_structure_copy): Use get_ref_base_and_extent_hwi rather than\n\tget_ref_base_and_extent.\n\t* var-tracking.c (track_expr_p): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255886", "tree": {"sha": "3ba8f3c264cdf88b5f924b21cfa9f2ac097744d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba8f3c264cdf88b5f924b21cfa9f2ac097744d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/comments", "author": null, "committer": null, "parents": [{"sha": "80d0198b739660305da17e12072578b7a99cb777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d0198b739660305da17e12072578b7a99cb777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80d0198b739660305da17e12072578b7a99cb777"}], "stats": {"total": 514, "additions": 291, "deletions": 223}, "files": [{"sha": "85a2e6b194a0127a9d38a194d9426128f30cf6ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -1,3 +1,46 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-dfa.h (get_ref_base_and_extent): Return the base, size and\n+\tmax_size as poly_int64_pods rather than HOST_WIDE_INTs.\n+\t(get_ref_base_and_extent_hwi): Declare.\n+\t* tree-dfa.c (get_ref_base_and_extent): Return the base, size and\n+\tmax_size as poly_int64_pods rather than HOST_WIDE_INTs.\n+\t(get_ref_base_and_extent_hwi): New function.\n+\t* cfgexpand.c (expand_debug_expr): Update call to\n+\tget_ref_base_and_extent.\n+\t* dwarf2out.c (add_var_loc_to_decl): Likewise.\n+\t* gimple-fold.c (get_base_constructor): Return the offset as a\n+\tpoly_int64_pod rather than a HOST_WIDE_INT.\n+\t(fold_const_aggregate_ref_1): Track polynomial sizes and offsets.\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::set_by_invariant)\n+\t(extr_type_from_vtbl_ptr_store): Track polynomial offsets.\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context)\n+\t(check_stmt_for_type_change): Use get_ref_base_and_extent_hwi\n+\trather than get_ref_base_and_extent.\n+\t(ipa_polymorphic_call_context::get_dynamic_type): Likewise.\n+\t* ipa-prop.c (ipa_load_from_parm_agg, compute_complex_assign_jump_func)\n+\t(get_ancestor_addr_info, determine_locally_known_aggregate_parts):\n+\tLikewise.\n+\t* ipa-param-manipulation.c (ipa_get_adjustment_candidate): Update\n+\tcall to get_ref_base_and_extent.\n+\t* tree-sra.c (create_access, get_access_for_expr): Likewise.\n+\t* tree-ssa-alias.c (ao_ref_base, aliasing_component_refs_p)\n+\t(stmt_kills_ref_p): Likewise.\n+\t* tree-ssa-dce.c (mark_aliased_reaching_defs_necessary_1): Likewise.\n+\t* tree-ssa-scopedtables.c (avail_expr_hash, equal_mem_array_ref_p):\n+\tLikewise.\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Likewise.\n+\tUse get_ref_base_and_extent_hwi rather than get_ref_base_and_extent\n+\twhen calling native_encode_expr.\n+\t* tree-ssa-structalias.c (get_constraint_for_component_ref): Update\n+\tcall to get_ref_base_and_extent.\n+\t(do_structure_copy): Use get_ref_base_and_extent_hwi rather than\n+\tget_ref_base_and_extent.\n+\t* var-tracking.c (track_expr_p): Likewise.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "324e0972b50309fe04034390b7563d770a835992", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -4899,7 +4899,7 @@ expand_debug_expr (tree exp)\n \n \t  if (handled_component_p (TREE_OPERAND (exp, 0)))\n \t    {\n-\t      HOST_WIDE_INT bitoffset, bitsize, maxsize;\n+\t      poly_int64 bitoffset, bitsize, maxsize, byteoffset;\n \t      bool reverse;\n \t      tree decl\n \t\t= get_ref_base_and_extent (TREE_OPERAND (exp, 0), &bitoffset,\n@@ -4909,12 +4909,12 @@ expand_debug_expr (tree exp)\n \t\t   || TREE_CODE (decl) == RESULT_DECL)\n \t\t  && (!TREE_ADDRESSABLE (decl)\n \t\t      || target_for_debug_bind (decl))\n-\t\t  && (bitoffset % BITS_PER_UNIT) == 0\n-\t\t  && bitsize > 0\n-\t\t  && bitsize == maxsize)\n+\t\t  && multiple_p (bitoffset, BITS_PER_UNIT, &byteoffset)\n+\t\t  && known_gt (bitsize, 0)\n+\t\t  && known_eq (bitsize, maxsize))\n \t\t{\n \t\t  rtx base = gen_rtx_DEBUG_IMPLICIT_PTR (mode, decl);\n-\t\t  return plus_constant (mode, base, bitoffset / BITS_PER_UNIT);\n+\t\t  return plus_constant (mode, base, byteoffset);\n \t\t}\n \t    }\n "}, {"sha": "1fa76d08af105eac1c7c87a339e829685fe10465", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -5920,17 +5920,15 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n \t  || (TREE_CODE (realdecl) == MEM_REF\n \t      && TREE_CODE (TREE_OPERAND (realdecl, 0)) == ADDR_EXPR))\n \t{\n-\t  HOST_WIDE_INT maxsize;\n \t  bool reverse;\n-\t  tree innerdecl\n-\t    = get_ref_base_and_extent (realdecl, &bitpos, &bitsize, &maxsize,\n-\t\t\t\t       &reverse);\n-\t  if (!DECL_P (innerdecl)\n+\t  tree innerdecl = get_ref_base_and_extent_hwi (realdecl, &bitpos,\n+\t\t\t\t\t\t\t&bitsize, &reverse);\n+\t  if (!innerdecl\n+\t      || !DECL_P (innerdecl)\n \t      || DECL_IGNORED_P (innerdecl)\n \t      || TREE_STATIC (innerdecl)\n-\t      || bitsize <= 0\n-\t      || bitpos + bitsize > 256\n-\t      || bitsize != maxsize)\n+\t      || bitsize == 0\n+\t      || bitpos + bitsize > 256)\n \t    return NULL;\n \t  decl = innerdecl;\n \t}"}, {"sha": "100e013a6031bd9b4eb7aeb2d80aba5241b48386", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -6333,10 +6333,10 @@ gimple_fold_stmt_to_constant (gimple *stmt, tree (*valueize) (tree))\n    is not explicitly available, but it is known to be zero\n    such as 'static const int a;'.  */\n static tree\n-get_base_constructor (tree base, HOST_WIDE_INT *bit_offset,\n+get_base_constructor (tree base, poly_int64_pod *bit_offset,\n \t\t      tree (*valueize)(tree))\n {\n-  HOST_WIDE_INT bit_offset2, size, max_size;\n+  poly_int64 bit_offset2, size, max_size;\n   bool reverse;\n \n   if (TREE_CODE (base) == MEM_REF)\n@@ -6388,7 +6388,7 @@ get_base_constructor (tree base, HOST_WIDE_INT *bit_offset,\n     case COMPONENT_REF:\n       base = get_ref_base_and_extent (base, &bit_offset2, &size, &max_size,\n \t\t\t\t      &reverse);\n-      if (max_size == -1 || size != max_size)\n+      if (!known_size_p (max_size) || maybe_ne (size, max_size))\n \treturn NULL_TREE;\n       *bit_offset +=  bit_offset2;\n       return get_base_constructor (base, bit_offset, valueize);\n@@ -6599,7 +6599,7 @@ tree\n fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n {\n   tree ctor, idx, base;\n-  HOST_WIDE_INT offset, size, max_size;\n+  poly_int64 offset, size, max_size;\n   tree tem;\n   bool reverse;\n \n@@ -6625,23 +6625,23 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n       if (TREE_CODE (TREE_OPERAND (t, 1)) == SSA_NAME\n \t  && valueize\n \t  && (idx = (*valueize) (TREE_OPERAND (t, 1)))\n-\t  && TREE_CODE (idx) == INTEGER_CST)\n+\t  && poly_int_tree_p (idx))\n \t{\n \t  tree low_bound, unit_size;\n \n \t  /* If the resulting bit-offset is constant, track it.  */\n \t  if ((low_bound = array_ref_low_bound (t),\n-\t       TREE_CODE (low_bound) == INTEGER_CST)\n+\t       poly_int_tree_p (low_bound))\n \t      && (unit_size = array_ref_element_size (t),\n \t\t  tree_fits_uhwi_p (unit_size)))\n \t    {\n-\t      offset_int woffset\n-\t\t= wi::sext (wi::to_offset (idx) - wi::to_offset (low_bound),\n+\t      poly_offset_int woffset\n+\t\t= wi::sext (wi::to_poly_offset (idx)\n+\t\t\t    - wi::to_poly_offset (low_bound),\n \t\t\t    TYPE_PRECISION (TREE_TYPE (idx)));\n \n-\t      if (wi::fits_shwi_p (woffset))\n+\t      if (woffset.to_shwi (&offset))\n \t\t{\n-\t\t  offset = woffset.to_shwi ();\n \t\t  /* TODO: This code seems wrong, multiply then check\n \t\t     to see if it fits.  */\n \t\t  offset *= tree_to_uhwi (unit_size);\n@@ -6654,7 +6654,7 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n \t\t    return build_zero_cst (TREE_TYPE (t));\n \t\t  /* Out of bound array access.  Value is undefined,\n \t\t     but don't fold.  */\n-\t\t  if (offset < 0)\n+\t\t  if (maybe_lt (offset, 0))\n \t\t    return NULL_TREE;\n \t\t  /* We can not determine ctor.  */\n \t\t  if (!ctor)\n@@ -6679,14 +6679,14 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n       if (ctor == error_mark_node)\n \treturn build_zero_cst (TREE_TYPE (t));\n       /* We do not know precise address.  */\n-      if (max_size == -1 || max_size != size)\n+      if (!known_size_p (max_size) || maybe_ne (max_size, size))\n \treturn NULL_TREE;\n       /* We can not determine ctor.  */\n       if (!ctor)\n \treturn NULL_TREE;\n \n       /* Out of bound array access.  Value is undefined, but don't fold.  */\n-      if (offset < 0)\n+      if (maybe_lt (offset, 0))\n \treturn NULL_TREE;\n \n       return fold_ctor_reference (TREE_TYPE (t), ctor, offset, size,"}, {"sha": "c01dfdd165dad680b245bf12fa517a2dcd47f1b8", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -627,11 +627,11 @@ ipa_get_adjustment_candidate (tree **expr, bool *convert,\n \t*convert = true;\n     }\n \n-  HOST_WIDE_INT offset, size, max_size;\n+  poly_int64 offset, size, max_size;\n   bool reverse;\n   tree base\n     = get_ref_base_and_extent (**expr, &offset, &size, &max_size, &reverse);\n-  if (!base || size == -1 || max_size == -1)\n+  if (!base || !known_size_p (size) || !known_size_p (max_size))\n     return NULL;\n \n   if (TREE_CODE (base) == MEM_REF)"}, {"sha": "21ae70bf493e3fae55babd40954b1538f546e96f", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -759,7 +759,7 @@ ipa_polymorphic_call_context::set_by_invariant (tree cst,\n \t\t\t\t\t\ttree otr_type,\n \t\t\t\t\t\tHOST_WIDE_INT off)\n {\n-  HOST_WIDE_INT offset2, size, max_size;\n+  poly_int64 offset2, size, max_size;\n   bool reverse;\n   tree base;\n \n@@ -772,7 +772,7 @@ ipa_polymorphic_call_context::set_by_invariant (tree cst,\n \n   cst = TREE_OPERAND (cst, 0);\n   base = get_ref_base_and_extent (cst, &offset2, &size, &max_size, &reverse);\n-  if (!DECL_P (base) || max_size == -1 || max_size != size)\n+  if (!DECL_P (base) || !known_size_p (max_size) || maybe_ne (max_size, size))\n     return false;\n \n   /* Only type inconsistent programs can have otr_type that is\n@@ -899,23 +899,21 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n       base_pointer = walk_ssa_copies (base_pointer, &visited);\n       if (TREE_CODE (base_pointer) == ADDR_EXPR)\n \t{\n-\t  HOST_WIDE_INT size, max_size;\n-\t  HOST_WIDE_INT offset2;\n+\t  HOST_WIDE_INT offset2, size;\n \t  bool reverse;\n \t  tree base\n-\t    = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n-\t\t\t\t       &offset2, &size, &max_size, &reverse);\n+\t    = get_ref_base_and_extent_hwi (TREE_OPERAND (base_pointer, 0),\n+\t\t\t\t\t   &offset2, &size, &reverse);\n+\t  if (!base)\n+\t    break;\n \n-\t  if (max_size != -1 && max_size == size)\n-\t    combine_speculation_with (TYPE_MAIN_VARIANT (TREE_TYPE (base)),\n-\t\t\t\t      offset + offset2,\n-\t\t\t\t      true,\n-\t\t\t\t      NULL /* Do not change outer type.  */);\n+\t  combine_speculation_with (TYPE_MAIN_VARIANT (TREE_TYPE (base)),\n+\t\t\t\t    offset + offset2,\n+\t\t\t\t    true,\n+\t\t\t\t    NULL /* Do not change outer type.  */);\n \n \t  /* If this is a varying address, punt.  */\n-\t  if ((TREE_CODE (base) == MEM_REF || DECL_P (base))\n-\t      && max_size != -1\n-\t      && max_size == size)\n+\t  if (TREE_CODE (base) == MEM_REF || DECL_P (base))\n \t    {\n \t      /* We found dereference of a pointer.  Type of the pointer\n \t\t and MEM_REF is meaningless, but we can look futher.  */\n@@ -1181,7 +1179,7 @@ static tree\n extr_type_from_vtbl_ptr_store (gimple *stmt, struct type_change_info *tci,\n \t\t\t       HOST_WIDE_INT *type_offset)\n {\n-  HOST_WIDE_INT offset, size, max_size;\n+  poly_int64 offset, size, max_size;\n   tree lhs, rhs, base;\n   bool reverse;\n \n@@ -1263,17 +1261,23 @@ extr_type_from_vtbl_ptr_store (gimple *stmt, struct type_change_info *tci,\n \t    }\n \t  return tci->offset > POINTER_SIZE ? error_mark_node : NULL_TREE;\n \t}\n-      if (offset != tci->offset\n-\t  || size != POINTER_SIZE\n-\t  || max_size != POINTER_SIZE)\n+      if (maybe_ne (offset, tci->offset)\n+\t  || maybe_ne (size, POINTER_SIZE)\n+\t  || maybe_ne (max_size, POINTER_SIZE))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"    wrong offset %i!=%i or size %i\\n\",\n-\t\t     (int)offset, (int)tci->offset, (int)size);\n-\t  return offset + POINTER_SIZE <= tci->offset\n-\t         || (max_size != -1\n-\t\t     && tci->offset + POINTER_SIZE > offset + max_size)\n-\t\t ? error_mark_node : NULL;\n+\t    {\n+\t      fprintf (dump_file, \"    wrong offset \");\n+\t      print_dec (offset, dump_file);\n+\t      fprintf (dump_file, \"!=%i or size \", (int) tci->offset);\n+\t      print_dec (size, dump_file);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return (known_le (offset + POINTER_SIZE, tci->offset)\n+\t\t  || (known_size_p (max_size)\n+\t\t      && known_gt (tci->offset + POINTER_SIZE,\n+\t\t\t\t   offset + max_size))\n+\t\t  ? error_mark_node : NULL);\n \t}\n     }\n \n@@ -1403,7 +1407,7 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n       {\n \ttree op = walk_ssa_copies (gimple_call_arg (stmt, 0));\n \ttree type = TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n-\tHOST_WIDE_INT offset = 0, size, max_size;\n+\tHOST_WIDE_INT offset = 0;\n \tbool reverse;\n \n \tif (dump_file)\n@@ -1415,14 +1419,15 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \t/* See if THIS parameter seems like instance pointer.  */\n \tif (TREE_CODE (op) == ADDR_EXPR)\n \t  {\n-\t    op = get_ref_base_and_extent (TREE_OPERAND (op, 0), &offset,\n-\t\t\t\t\t  &size, &max_size, &reverse);\n-\t    if (size != max_size || max_size == -1)\n+\t    HOST_WIDE_INT size;\n+\t    op = get_ref_base_and_extent_hwi (TREE_OPERAND (op, 0),\n+\t\t\t\t\t      &offset, &size, &reverse);\n+\t    if (!op)\n \t      {\n                 tci->speculative++;\n \t        return csftc_abort_walking_p (tci->speculative);\n \t      }\n-\t    if (op && TREE_CODE (op) == MEM_REF)\n+\t    if (TREE_CODE (op) == MEM_REF)\n \t      {\n \t\tif (!tree_fits_shwi_p (TREE_OPERAND (op, 1)))\n \t\t  {\n@@ -1578,7 +1583,6 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n   if (gimple_code (call) == GIMPLE_CALL)\n     {\n       tree ref = gimple_call_fn (call);\n-      HOST_WIDE_INT offset2, size, max_size;\n       bool reverse;\n \n       if (TREE_CODE (ref) == OBJ_TYPE_REF)\n@@ -1608,10 +1612,11 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t\t  && !SSA_NAME_IS_DEFAULT_DEF (ref)\n \t\t  && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref)))\n \t\t{\n+\t\t  HOST_WIDE_INT offset2, size;\n \t\t  tree ref_exp = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ref));\n \t\t  tree base_ref\n-\t\t    = get_ref_base_and_extent (ref_exp, &offset2, &size,\n-\t\t\t\t\t       &max_size, &reverse);\n+\t\t    = get_ref_base_and_extent_hwi (ref_exp, &offset2,\n+\t\t\t\t\t\t   &size, &reverse);\n \n \t\t  /* Finally verify that what we found looks like read from\n \t\t     OTR_OBJECT or from INSTANCE with offset OFFSET.  */"}, {"sha": "071c0d69a20ea4c20c8e0ca3a8e086300557784e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -1071,12 +1071,11 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \t\t\tbool *by_ref_p, bool *guaranteed_unmodified)\n {\n   int index;\n-  HOST_WIDE_INT size, max_size;\n+  HOST_WIDE_INT size;\n   bool reverse;\n-  tree base\n-    = get_ref_base_and_extent (op, offset_p, &size, &max_size, &reverse);\n+  tree base = get_ref_base_and_extent_hwi (op, offset_p, &size, &reverse);\n \n-  if (max_size == -1 || max_size != size || *offset_p < 0)\n+  if (!base)\n     return false;\n \n   if (DECL_P (base))\n@@ -1204,7 +1203,7 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n \t\t\t\t  gcall *call, gimple *stmt, tree name,\n \t\t\t\t  tree param_type)\n {\n-  HOST_WIDE_INT offset, size, max_size;\n+  HOST_WIDE_INT offset, size;\n   tree op1, tc_ssa, base, ssa;\n   bool reverse;\n   int index;\n@@ -1267,11 +1266,8 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n   op1 = TREE_OPERAND (op1, 0);\n   if (TREE_CODE (TREE_TYPE (op1)) != RECORD_TYPE)\n     return;\n-  base = get_ref_base_and_extent (op1, &offset, &size, &max_size, &reverse);\n-  if (TREE_CODE (base) != MEM_REF\n-      /* If this is a varying address, punt.  */\n-      || max_size == -1\n-      || max_size != size)\n+  base = get_ref_base_and_extent_hwi (op1, &offset, &size, &reverse);\n+  if (!base || TREE_CODE (base) != MEM_REF)\n     return;\n   offset += mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n   ssa = TREE_OPERAND (base, 0);\n@@ -1301,7 +1297,7 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n static tree\n get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n {\n-  HOST_WIDE_INT size, max_size;\n+  HOST_WIDE_INT size;\n   tree expr, parm, obj;\n   bool reverse;\n \n@@ -1313,13 +1309,9 @@ get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n     return NULL_TREE;\n   expr = TREE_OPERAND (expr, 0);\n   obj = expr;\n-  expr = get_ref_base_and_extent (expr, offset, &size, &max_size, &reverse);\n+  expr = get_ref_base_and_extent_hwi (expr, offset, &size, &reverse);\n \n-  if (TREE_CODE (expr) != MEM_REF\n-      /* If this is a varying address, punt.  */\n-      || max_size == -1\n-      || max_size != size\n-      || *offset < 0)\n+  if (!expr || TREE_CODE (expr) != MEM_REF)\n     return NULL_TREE;\n   parm = TREE_OPERAND (expr, 0);\n   if (TREE_CODE (parm) != SSA_NAME\n@@ -1581,15 +1573,12 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n \t}\n       else if (TREE_CODE (arg) == ADDR_EXPR)\n \t{\n-\t  HOST_WIDE_INT arg_max_size;\n \t  bool reverse;\n \n \t  arg = TREE_OPERAND (arg, 0);\n-\t  arg_base = get_ref_base_and_extent (arg, &arg_offset, &arg_size,\n-\t\t\t\t\t      &arg_max_size, &reverse);\n-\t  if (arg_max_size == -1\n-\t      || arg_max_size != arg_size\n-\t      || arg_offset < 0)\n+\t  arg_base = get_ref_base_and_extent_hwi (arg, &arg_offset,\n+\t\t\t\t\t\t  &arg_size, &reverse);\n+\t  if (!arg_base)\n \t    return;\n \t  if (DECL_P (arg_base))\n \t    {\n@@ -1604,18 +1593,15 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n     }\n   else\n     {\n-      HOST_WIDE_INT arg_max_size;\n       bool reverse;\n \n       gcc_checking_assert (AGGREGATE_TYPE_P (TREE_TYPE (arg)));\n \n       by_ref = false;\n       check_ref = false;\n-      arg_base = get_ref_base_and_extent (arg, &arg_offset, &arg_size,\n-\t\t\t\t\t  &arg_max_size, &reverse);\n-      if (arg_max_size == -1\n-\t  || arg_max_size != arg_size\n-\t  || arg_offset < 0)\n+      arg_base = get_ref_base_and_extent_hwi (arg, &arg_offset,\n+\t\t\t\t\t      &arg_size, &reverse);\n+      if (!arg_base)\n \treturn;\n \n       ao_ref_init (&r, arg);\n@@ -1631,7 +1617,7 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n     {\n       struct ipa_known_agg_contents_list *n, **p;\n       gimple *stmt = gsi_stmt (gsi);\n-      HOST_WIDE_INT lhs_offset, lhs_size, lhs_max_size;\n+      HOST_WIDE_INT lhs_offset, lhs_size;\n       tree lhs, rhs, lhs_base;\n       bool reverse;\n \n@@ -1647,10 +1633,9 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,\n \t  || contains_bitfld_component_ref_p (lhs))\n \tbreak;\n \n-      lhs_base = get_ref_base_and_extent (lhs, &lhs_offset, &lhs_size,\n-\t\t\t\t\t  &lhs_max_size, &reverse);\n-      if (lhs_max_size == -1\n-\t  || lhs_max_size != lhs_size)\n+      lhs_base = get_ref_base_and_extent_hwi (lhs, &lhs_offset,\n+\t\t\t\t\t      &lhs_size, &reverse);\n+      if (!lhs_base)\n \tbreak;\n \n       if (check_ref)"}, {"sha": "e50bda0582f1052799867fbc4dd79f05d47b4aa9", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 84, "deletions": 60, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -377,15 +377,15 @@ get_or_create_ssa_default_def (struct function *fn, tree var)\n    true, the storage order of the reference is reversed.  */\n \n tree\n-get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n-\t\t\t HOST_WIDE_INT *psize,\n-\t\t\t HOST_WIDE_INT *pmax_size,\n+get_ref_base_and_extent (tree exp, poly_int64_pod *poffset,\n+\t\t\t poly_int64_pod *psize,\n+\t\t\t poly_int64_pod *pmax_size,\n \t\t\t bool *preverse)\n {\n-  offset_int bitsize = -1;\n-  offset_int maxsize;\n+  poly_offset_int bitsize = -1;\n+  poly_offset_int maxsize;\n   tree size_tree = NULL_TREE;\n-  offset_int bit_offset = 0;\n+  poly_offset_int bit_offset = 0;\n   bool seen_variable_array_ref = false;\n \n   /* First get the final access size and the storage order from just the\n@@ -400,11 +400,11 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       if (mode == BLKmode)\n \tsize_tree = TYPE_SIZE (TREE_TYPE (exp));\n       else\n-\tbitsize = int (GET_MODE_BITSIZE (mode));\n+\tbitsize = GET_MODE_BITSIZE (mode);\n     }\n   if (size_tree != NULL_TREE\n-      && TREE_CODE (size_tree) == INTEGER_CST)\n-    bitsize = wi::to_offset (size_tree);\n+      && poly_int_tree_p (size_tree))\n+    bitsize = wi::to_poly_offset (size_tree);\n \n   *preverse = reverse_storage_order_for_component_p (exp);\n \n@@ -419,26 +419,26 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       switch (TREE_CODE (exp))\n \t{\n \tcase BIT_FIELD_REF:\n-\t  bit_offset += wi::to_offset (TREE_OPERAND (exp, 2));\n+\t  bit_offset += wi::to_poly_offset (TREE_OPERAND (exp, 2));\n \t  break;\n \n \tcase COMPONENT_REF:\n \t  {\n \t    tree field = TREE_OPERAND (exp, 1);\n \t    tree this_offset = component_ref_field_offset (exp);\n \n-\t    if (this_offset && TREE_CODE (this_offset) == INTEGER_CST)\n+\t    if (this_offset && poly_int_tree_p (this_offset))\n \t      {\n-\t\toffset_int woffset = (wi::to_offset (this_offset)\n-\t\t\t\t      << LOG2_BITS_PER_UNIT);\n+\t\tpoly_offset_int woffset = (wi::to_poly_offset (this_offset)\n+\t\t\t\t\t   << LOG2_BITS_PER_UNIT);\n \t\twoffset += wi::to_offset (DECL_FIELD_BIT_OFFSET (field));\n \t\tbit_offset += woffset;\n \n \t\t/* If we had seen a variable array ref already and we just\n \t\t   referenced the last field of a struct or a union member\n \t\t   then we have to adjust maxsize by the padding at the end\n \t\t   of our field.  */\n-\t\tif (seen_variable_array_ref && maxsize != -1)\n+\t\tif (seen_variable_array_ref && known_size_p (maxsize))\n \t\t  {\n \t\t    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t\t    tree next = DECL_CHAIN (field);\n@@ -450,14 +450,15 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\ttree fsize = DECL_SIZE_UNIT (field);\n \t\t\ttree ssize = TYPE_SIZE_UNIT (stype);\n \t\t\tif (fsize == NULL\n-\t\t\t    || TREE_CODE (fsize) != INTEGER_CST\n+\t\t\t    || !poly_int_tree_p (fsize)\n \t\t\t    || ssize == NULL\n-\t\t\t    || TREE_CODE (ssize) != INTEGER_CST)\n+\t\t\t    || !poly_int_tree_p (ssize))\n \t\t\t  maxsize = -1;\n \t\t\telse\n \t\t\t  {\n-\t\t\t    offset_int tem = (wi::to_offset (ssize)\n-\t\t\t\t\t      - wi::to_offset (fsize));\n+\t\t\t    poly_offset_int tem\n+\t\t\t      = (wi::to_poly_offset (ssize)\n+\t\t\t\t - wi::to_poly_offset (fsize));\n \t\t\t    tem <<= LOG2_BITS_PER_UNIT;\n \t\t\t    tem -= woffset;\n \t\t\t    maxsize += tem;\n@@ -471,10 +472,10 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t/* We need to adjust maxsize to the whole structure bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us out of the structure otherwise.  */\n-\t\tif (maxsize != -1\n+\t\tif (known_size_p (maxsize)\n \t\t    && csize\n-\t\t    && TREE_CODE (csize) == INTEGER_CST)\n-\t\t  maxsize = wi::to_offset (csize) - bit_offset;\n+\t\t    && poly_int_tree_p (csize))\n+\t\t  maxsize = wi::to_poly_offset (csize) - bit_offset;\n \t\telse\n \t\t  maxsize = -1;\n \t      }\n@@ -488,14 +489,15 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t    tree low_bound, unit_size;\n \n \t    /* If the resulting bit-offset is constant, track it.  */\n-\t    if (TREE_CODE (index) == INTEGER_CST\n+\t    if (poly_int_tree_p (index)\n \t\t&& (low_bound = array_ref_low_bound (exp),\n- \t\t    TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t    poly_int_tree_p (low_bound))\n \t\t&& (unit_size = array_ref_element_size (exp),\n \t\t    TREE_CODE (unit_size) == INTEGER_CST))\n \t      {\n-\t\toffset_int woffset\n-\t\t  = wi::sext (wi::to_offset (index) - wi::to_offset (low_bound),\n+\t\tpoly_offset_int woffset\n+\t\t  = wi::sext (wi::to_poly_offset (index)\n+\t\t\t      - wi::to_poly_offset (low_bound),\n \t\t\t      TYPE_PRECISION (TREE_TYPE (index)));\n \t\twoffset *= wi::to_offset (unit_size);\n \t\twoffset <<= LOG2_BITS_PER_UNIT;\n@@ -512,10 +514,10 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t/* We need to adjust maxsize to the whole array bitsize.\n \t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us outside of the array otherwise.  */\n-\t\tif (maxsize != -1\n+\t\tif (known_size_p (maxsize)\n \t\t    && asize\n-\t\t    && TREE_CODE (asize) == INTEGER_CST)\n-\t\t  maxsize = wi::to_offset (asize) - bit_offset;\n+\t\t    && poly_int_tree_p (asize))\n+\t\t  maxsize = wi::to_poly_offset (asize) - bit_offset;\n \t\telse\n \t\t  maxsize = -1;\n \n@@ -560,11 +562,12 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t     base type boundary.  This needs to include possible trailing\n \t     padding that is there for alignment purposes.  */\n \t  if (seen_variable_array_ref\n-\t      && maxsize != -1\n+\t      && known_size_p (maxsize)\n \t      && (TYPE_SIZE (TREE_TYPE (exp)) == NULL_TREE\n-\t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) != INTEGER_CST\n-\t\t  || (bit_offset + maxsize\n-\t\t      == wi::to_offset (TYPE_SIZE (TREE_TYPE (exp))))))\n+\t\t  || !poly_int_tree_p (TYPE_SIZE (TREE_TYPE (exp)))\n+\t\t  || (maybe_eq\n+\t\t      (bit_offset + maxsize,\n+\t\t       wi::to_poly_offset (TYPE_SIZE (TREE_TYPE (exp)))))))\n \t    maxsize = -1;\n \n \t  /* Hand back the decl for MEM[&decl, off].  */\n@@ -574,12 +577,13 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\texp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n \t      else\n \t\t{\n-\t\t  offset_int off = mem_ref_offset (exp);\n+\t\t  poly_offset_int off = mem_ref_offset (exp);\n \t\t  off <<= LOG2_BITS_PER_UNIT;\n \t\t  off += bit_offset;\n-\t\t  if (wi::fits_shwi_p (off))\n+\t\t  poly_int64 off_hwi;\n+\t\t  if (off.to_shwi (&off_hwi))\n \t\t    {\n-\t\t      bit_offset = off;\n+\t\t      bit_offset = off_hwi;\n \t\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n \t\t    }\n \t\t}\n@@ -594,7 +598,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n     }\n \n  done:\n-  if (!wi::fits_shwi_p (bitsize) || wi::neg_p (bitsize))\n+  if (!bitsize.to_shwi (psize) || maybe_lt (*psize, 0))\n     {\n       *poffset = 0;\n       *psize = -1;\n@@ -603,9 +607,10 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n       return exp;\n     }\n \n-  *psize = bitsize.to_shwi ();\n-\n-  if (!wi::fits_shwi_p (bit_offset))\n+  /* ???  Due to negative offsets in ARRAY_REF we can end up with\n+     negative bit_offset here.  We might want to store a zero offset\n+     in this case.  */\n+  if (!bit_offset.to_shwi (poffset))\n     {\n       *poffset = 0;\n       *pmax_size = -1;\n@@ -625,44 +630,37 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n \t      || (seen_variable_array_ref\n \t\t  && (sz_tree == NULL_TREE\n-\t\t      || TREE_CODE (sz_tree) != INTEGER_CST\n-\t\t      || (bit_offset + maxsize == wi::to_offset (sz_tree)))))\n+\t\t      || !poly_int_tree_p (sz_tree)\n+\t\t      || maybe_eq (bit_offset + maxsize,\n+\t\t\t\t   wi::to_poly_offset (sz_tree)))))\n \t    maxsize = -1;\n \t}\n       /* If maxsize is unknown adjust it according to the size of the\n          base decl.  */\n-      else if (maxsize == -1\n-\t  && DECL_SIZE (exp)\n-\t  && TREE_CODE (DECL_SIZE (exp)) == INTEGER_CST)\n-\tmaxsize = wi::to_offset (DECL_SIZE (exp)) - bit_offset;\n+      else if (!known_size_p (maxsize)\n+\t       && DECL_SIZE (exp)\n+\t       && poly_int_tree_p (DECL_SIZE (exp)))\n+\tmaxsize = wi::to_poly_offset (DECL_SIZE (exp)) - bit_offset;\n     }\n   else if (CONSTANT_CLASS_P (exp))\n     {\n       /* If maxsize is unknown adjust it according to the size of the\n          base type constant.  */\n-      if (maxsize == -1\n+      if (!known_size_p (maxsize)\n \t  && TYPE_SIZE (TREE_TYPE (exp))\n-\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST)\n-\tmaxsize = (wi::to_offset (TYPE_SIZE (TREE_TYPE (exp)))\n+\t  && poly_int_tree_p (TYPE_SIZE (TREE_TYPE (exp))))\n+\tmaxsize = (wi::to_poly_offset (TYPE_SIZE (TREE_TYPE (exp)))\n \t\t   - bit_offset);\n     }\n \n-  /* ???  Due to negative offsets in ARRAY_REF we can end up with\n-     negative bit_offset here.  We might want to store a zero offset\n-     in this case.  */\n-  *poffset = bit_offset.to_shwi ();\n-  if (!wi::fits_shwi_p (maxsize) || wi::neg_p (maxsize))\n+  if (!maxsize.to_shwi (pmax_size)\n+      || maybe_lt (*pmax_size, 0)\n+      || !endpoint_representable_p (*poffset, *pmax_size))\n     *pmax_size = -1;\n-  else\n-    {\n-      *pmax_size = maxsize.to_shwi ();\n-      if (*poffset > HOST_WIDE_INT_MAX - *pmax_size)\n-\t*pmax_size = -1;\n-    }\n \n   /* Punt if *POFFSET + *PSIZE overflows in HOST_WIDE_INT, the callers don't\n      check for such overflows individually and assume it works.  */\n-  if (*psize != -1 && *poffset > HOST_WIDE_INT_MAX - *psize)\n+  if (!endpoint_representable_p (*poffset, *psize))\n     {\n       *poffset = 0;\n       *psize = -1;\n@@ -674,6 +672,32 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   return exp;\n }\n \n+/* Like get_ref_base_and_extent, but for cases in which we only care\n+   about constant-width accesses at constant offsets.  Return null\n+   if the access is anything else.  */\n+\n+tree\n+get_ref_base_and_extent_hwi (tree exp, HOST_WIDE_INT *poffset,\n+\t\t\t     HOST_WIDE_INT *psize, bool *preverse)\n+{\n+  poly_int64 offset, size, max_size;\n+  HOST_WIDE_INT const_offset, const_size;\n+  bool reverse;\n+  tree decl = get_ref_base_and_extent (exp, &offset, &size, &max_size,\n+\t\t\t\t       &reverse);\n+  if (!offset.is_constant (&const_offset)\n+      || !size.is_constant (&const_size)\n+      || const_offset < 0\n+      || !known_size_p (max_size)\n+      || maybe_ne (max_size, const_size))\n+    return NULL_TREE;\n+\n+  *poffset = const_offset;\n+  *psize = const_size;\n+  *preverse = reverse;\n+  return decl;\n+}\n+\n /* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n    denotes the starting address of the memory access EXP.\n    Returns NULL_TREE if the offset is not constant or any component"}, {"sha": "908ab5f684927823f71bd3fc3f628a63e104f38f", "filename": "gcc/tree-dfa.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -29,8 +29,10 @@ extern void debug_dfa_stats (void);\n extern tree ssa_default_def (struct function *, tree);\n extern void set_ssa_default_def (struct function *, tree, tree);\n extern tree get_or_create_ssa_default_def (struct function *, tree);\n-extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n-\t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *, bool *);\n+extern tree get_ref_base_and_extent (tree, poly_int64_pod *, poly_int64_pod *,\n+\t\t\t\t     poly_int64_pod *, bool *);\n+extern tree get_ref_base_and_extent_hwi (tree, HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, bool *);\n extern tree get_addr_base_and_unit_offset_1 (tree, HOST_WIDE_INT *,\n \t\t\t\t\t     tree (*) (tree));\n extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);"}, {"sha": "ee224a31a2ed0d03b870fd3277aceb9ba40362b3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -866,11 +866,20 @@ static struct access *\n create_access (tree expr, gimple *stmt, bool write)\n {\n   struct access *access;\n+  poly_int64 poffset, psize, pmax_size;\n   HOST_WIDE_INT offset, size, max_size;\n   tree base = expr;\n   bool reverse, ptr, unscalarizable_region = false;\n \n-  base = get_ref_base_and_extent (expr, &offset, &size, &max_size, &reverse);\n+  base = get_ref_base_and_extent (expr, &poffset, &psize, &pmax_size,\n+\t\t\t\t  &reverse);\n+  if (!poffset.is_constant (&offset)\n+      || !psize.is_constant (&size)\n+      || !pmax_size.is_constant (&max_size))\n+    {\n+      disqualify_candidate (base, \"Encountered a polynomial-sized access.\");\n+      return NULL;\n+    }\n \n   if (sra_mode == SRA_MODE_EARLY_IPA\n       && TREE_CODE (base) == MEM_REF)\n@@ -3083,7 +3092,8 @@ clobber_subtree (struct access *access, gimple_stmt_iterator *gsi,\n static struct access *\n get_access_for_expr (tree expr)\n {\n-  HOST_WIDE_INT offset, size, max_size;\n+  poly_int64 poffset, psize, pmax_size;\n+  HOST_WIDE_INT offset, max_size;\n   tree base;\n   bool reverse;\n \n@@ -3093,8 +3103,12 @@ get_access_for_expr (tree expr)\n   if (TREE_CODE (expr) == VIEW_CONVERT_EXPR)\n     expr = TREE_OPERAND (expr, 0);\n \n-  base = get_ref_base_and_extent (expr, &offset, &size, &max_size, &reverse);\n-  if (max_size == -1 || !DECL_P (base))\n+  base = get_ref_base_and_extent (expr, &poffset, &psize, &pmax_size,\n+\t\t\t\t  &reverse);\n+  if (!known_size_p (pmax_size)\n+      || !pmax_size.is_constant (&max_size)\n+      || !poffset.is_constant (&offset)\n+      || !DECL_P (base))\n     return NULL;\n \n   if (!bitmap_bit_p (candidate_bitmap, DECL_UID (base)))"}, {"sha": "5c26592e2a3212f621018d973b19c9e21b9d80e2", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -635,15 +635,11 @@ tree\n ao_ref_base (ao_ref *ref)\n {\n   bool reverse;\n-  HOST_WIDE_INT offset, size, max_size;\n \n   if (ref->base)\n     return ref->base;\n-  ref->base = get_ref_base_and_extent (ref->ref, &offset, &size,\n-\t\t\t\t       &max_size, &reverse);\n-  ref->offset = offset;\n-  ref->size = size;\n-  ref->max_size = max_size;\n+  ref->base = get_ref_base_and_extent (ref->ref, &ref->offset, &ref->size,\n+\t\t\t\t       &ref->max_size, &reverse);\n   return ref->base;\n }\n \n@@ -823,7 +819,7 @@ aliasing_component_refs_p (tree ref1,\n     return true;\n   else if (same_p == 1)\n     {\n-      HOST_WIDE_INT offadj, sztmp, msztmp;\n+      poly_int64 offadj, sztmp, msztmp;\n       bool reverse;\n       get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n       offset2 -= offadj;\n@@ -842,7 +838,7 @@ aliasing_component_refs_p (tree ref1,\n     return true;\n   else if (same_p == 1)\n     {\n-      HOST_WIDE_INT offadj, sztmp, msztmp;\n+      poly_int64 offadj, sztmp, msztmp;\n       bool reverse;\n       get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n       offset1 -= offadj;\n@@ -2448,15 +2444,12 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t the access properly.  */\n       if (!ref->max_size_known_p ())\n \treturn false;\n-      HOST_WIDE_INT size, max_size, const_offset;\n-      poly_int64 ref_offset = ref->offset;\n+      poly_int64 size, offset, max_size, ref_offset = ref->offset;\n       bool reverse;\n-      tree base\n-\t= get_ref_base_and_extent (lhs, &const_offset, &size, &max_size,\n-\t\t\t\t   &reverse);\n+      tree base = get_ref_base_and_extent (lhs, &offset, &size, &max_size,\n+\t\t\t\t\t   &reverse);\n       /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n \t so base == ref->base does not always hold.  */\n-      poly_int64 offset = const_offset;\n       if (base != ref->base)\n \t{\n \t  /* Try using points-to info.  */\n@@ -2488,7 +2481,7 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t}\n       /* For a must-alias check we need to be able to constrain\n \t the access properly.  */\n-      if (size == max_size\n+      if (known_eq (size, max_size)\n \t  && known_subrange_p (ref_offset, ref->max_size, offset, size))\n \treturn true;\n     }"}, {"sha": "08f20a3d2c88f996e8bb253356bda27c62f533aa", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -477,7 +477,7 @@ mark_aliased_reaching_defs_necessary_1 (ao_ref *ref, tree vdef, void *data)\n       && !stmt_can_throw_internal (def_stmt))\n     {\n       tree base, lhs = gimple_get_lhs (def_stmt);\n-      HOST_WIDE_INT size, offset, max_size;\n+      poly_int64 size, offset, max_size;\n       bool reverse;\n       ao_ref_base (ref);\n       base\n@@ -488,7 +488,7 @@ mark_aliased_reaching_defs_necessary_1 (ao_ref *ref, tree vdef, void *data)\n \t{\n \t  /* For a must-alias check we need to be able to constrain\n \t     the accesses properly.  */\n-\t  if (size == max_size\n+\t  if (known_eq (size, max_size)\n \t      && known_subrange_p (ref->offset, ref->max_size, offset, size))\n \t    return true;\n \t  /* Or they need to be exactly the same.  */"}, {"sha": "a640edbbd6e64271e2913a9847b0a001e4d55d6f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -1966,7 +1966,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n     {\n       tree ref2 = TREE_OPERAND (gimple_call_arg (def_stmt, 0), 0);\n       tree base2;\n-      HOST_WIDE_INT offset2, size2, maxsize2;\n+      poly_int64 offset2, size2, maxsize2;\n       bool reverse;\n       base2 = get_ref_base_and_extent (ref2, &offset2, &size2, &maxsize2,\n \t\t\t\t       &reverse);\n@@ -1989,7 +1989,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t   && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (def_stmt)) == 0)\n     {\n       tree base2;\n-      HOST_WIDE_INT offset2, size2, maxsize2;\n+      poly_int64 offset2, size2, maxsize2;\n       bool reverse;\n       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n \t\t\t\t       &offset2, &size2, &maxsize2, &reverse);\n@@ -2021,13 +2021,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t\t   && is_gimple_min_invariant (SSA_VAL (gimple_assign_rhs1 (def_stmt))))))\n     {\n       tree base2;\n-      HOST_WIDE_INT offset2, size2, maxsize2;\n+      HOST_WIDE_INT offset2, size2;\n       bool reverse;\n-      base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n-\t\t\t\t       &offset2, &size2, &maxsize2, &reverse);\n-      if (!reverse\n-\t  && maxsize2 != -1\n-\t  && maxsize2 == size2\n+      base2 = get_ref_base_and_extent_hwi (gimple_assign_lhs (def_stmt),\n+\t\t\t\t\t   &offset2, &size2, &reverse);\n+      if (base2\n+\t  && !reverse\n \t  && size2 % BITS_PER_UNIT == 0\n \t  && offset2 % BITS_PER_UNIT == 0\n \t  && operand_equal_p (base, base2, 0)\n@@ -2085,14 +2084,14 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n     {\n       tree base2;\n-      HOST_WIDE_INT offset2, size2, maxsize2;\n+      poly_int64 offset2, size2, maxsize2;\n       bool reverse;\n       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n \t\t\t\t       &offset2, &size2, &maxsize2,\n \t\t\t\t       &reverse);\n       if (!reverse\n-\t  && maxsize2 != -1\n-\t  && maxsize2 == size2\n+\t  && known_size_p (maxsize2)\n+\t  && known_eq (maxsize2, size2)\n \t  && operand_equal_p (base, base2, 0)\n \t  && known_subrange_p (offset, maxsize, offset2, size2)\n \t  /* ???  We can't handle bitfield precision extracts without"}, {"sha": "5177511b7ebc0c039bf06d5ddecc5d58ee72c2e3", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -480,13 +480,13 @@ avail_expr_hash (class expr_hash_elt *p)\n \t     Dealing with both MEM_REF and ARRAY_REF allows us not to care\n \t     about equivalence with other statements not considered here.  */\n \t  bool reverse;\n-\t  HOST_WIDE_INT offset, size, max_size;\n+\t  poly_int64 offset, size, max_size;\n \t  tree base = get_ref_base_and_extent (t, &offset, &size, &max_size,\n \t\t\t\t\t       &reverse);\n \t  /* Strictly, we could try to normalize variable-sized accesses too,\n \t    but here we just deal with the common case.  */\n-\t  if (size != -1\n-\t      && size == max_size)\n+\t  if (known_size_p (max_size)\n+\t      && known_eq (size, max_size))\n \t    {\n \t      enum tree_code code = MEM_REF;\n \t      hstate.add_object (code);\n@@ -520,26 +520,26 @@ equal_mem_array_ref_p (tree t0, tree t1)\n   if (!types_compatible_p (TREE_TYPE (t0), TREE_TYPE (t1)))\n     return false;\n   bool rev0;\n-  HOST_WIDE_INT off0, sz0, max0;\n+  poly_int64 off0, sz0, max0;\n   tree base0 = get_ref_base_and_extent (t0, &off0, &sz0, &max0, &rev0);\n-  if (sz0 == -1\n-      || sz0 != max0)\n+  if (!known_size_p (max0)\n+      || maybe_ne (sz0, max0))\n     return false;\n \n   bool rev1;\n-  HOST_WIDE_INT off1, sz1, max1;\n+  poly_int64 off1, sz1, max1;\n   tree base1 = get_ref_base_and_extent (t1, &off1, &sz1, &max1, &rev1);\n-  if (sz1 == -1\n-      || sz1 != max1)\n+  if (!known_size_p (max1)\n+      || maybe_ne (sz1, max1))\n     return false;\n \n   if (rev0 != rev1)\n     return false;\n \n   /* Types were compatible, so this is a sanity check.  */\n-  gcc_assert (sz0 == sz1);\n+  gcc_assert (known_eq (sz0, sz1));\n \n-  return (off0 == off1) && operand_equal_p (base0, base1, 0);\n+  return known_eq (off0, off1) && operand_equal_p (base0, base1, 0);\n }\n \n /* Compare two hashable_expr structures for equivalence.  They are"}, {"sha": "243cc467915a949f1575423f91231e653fca3805", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -3191,9 +3191,9 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n \t\t\t\t  bool address_p, bool lhs_p)\n {\n   tree orig_t = t;\n-  HOST_WIDE_INT bitsize = -1;\n-  HOST_WIDE_INT bitmaxsize = -1;\n-  HOST_WIDE_INT bitpos;\n+  poly_int64 bitsize = -1;\n+  poly_int64 bitmaxsize = -1;\n+  poly_int64 bitpos;\n   bool reverse;\n   tree forzero;\n \n@@ -3255,8 +3255,8 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n \t ignore this constraint. When we handle pointer subtraction,\n \t we may have to do something cute here.  */\n \n-      if ((unsigned HOST_WIDE_INT)bitpos < get_varinfo (result.var)->fullsize\n-\t  && bitmaxsize != 0)\n+      if (maybe_lt (poly_uint64 (bitpos), get_varinfo (result.var)->fullsize)\n+\t  && maybe_ne (bitmaxsize, 0))\n \t{\n \t  /* It's also not true that the constraint will actually start at the\n \t     right offset, it may start in some padding.  We only care about\n@@ -3268,8 +3268,8 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n \t  cexpr.offset = 0;\n \t  for (curr = get_varinfo (cexpr.var); curr; curr = vi_next (curr))\n \t    {\n-\t      if (ranges_overlap_p (curr->offset, curr->size,\n-\t\t\t\t    bitpos, bitmaxsize))\n+\t      if (ranges_maybe_overlap_p (poly_int64 (curr->offset),\n+\t\t\t\t\t  curr->size, bitpos, bitmaxsize))\n \t\t{\n \t\t  cexpr.var = curr->id;\n \t\t  results->safe_push (cexpr);\n@@ -3302,7 +3302,7 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n \t      results->safe_push (cexpr);\n \t    }\n \t}\n-      else if (bitmaxsize == 0)\n+      else if (known_eq (bitmaxsize, 0))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Access to zero-sized part of variable, \"\n@@ -3317,13 +3317,15 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n       /* If we do not know exactly where the access goes say so.  Note\n \t that only for non-structure accesses we know that we access\n \t at most one subfiled of any variable.  */\n-      if (bitpos == -1\n-\t  || bitsize != bitmaxsize\n+      HOST_WIDE_INT const_bitpos;\n+      if (!bitpos.is_constant (&const_bitpos)\n+\t  || const_bitpos == -1\n+\t  || maybe_ne (bitsize, bitmaxsize)\n \t  || AGGREGATE_TYPE_P (TREE_TYPE (orig_t))\n \t  || result.offset == UNKNOWN_OFFSET)\n \tresult.offset = UNKNOWN_OFFSET;\n       else\n-\tresult.offset += bitpos;\n+\tresult.offset += const_bitpos;\n     }\n   else if (result.type == ADDRESSOF)\n     {\n@@ -3660,14 +3662,17 @@ do_structure_copy (tree lhsop, tree rhsop)\n \t   && (rhsp->type == SCALAR\n \t       || rhsp->type == ADDRESSOF))\n     {\n-      HOST_WIDE_INT lhssize, lhsmaxsize, lhsoffset;\n-      HOST_WIDE_INT rhssize, rhsmaxsize, rhsoffset;\n+      HOST_WIDE_INT lhssize, lhsoffset;\n+      HOST_WIDE_INT rhssize, rhsoffset;\n       bool reverse;\n       unsigned k = 0;\n-      get_ref_base_and_extent (lhsop, &lhsoffset, &lhssize, &lhsmaxsize,\n-\t\t\t       &reverse);\n-      get_ref_base_and_extent (rhsop, &rhsoffset, &rhssize, &rhsmaxsize,\n-\t\t\t       &reverse);\n+      if (!get_ref_base_and_extent_hwi (lhsop, &lhsoffset, &lhssize, &reverse)\n+\t  || !get_ref_base_and_extent_hwi (rhsop, &rhsoffset, &rhssize,\n+\t\t\t\t\t   &reverse))\n+\t{\n+\t  process_all_all_constraints (lhsc, rhsc);\n+\t  return;\n+\t}\n       for (j = 0; lhsc.iterate (j, &lhsp);)\n \t{\n \t  varinfo_t lhsv, rhsv;"}, {"sha": "c1587593397ce7eab4b3e3da006cb5dc5f4f70b5", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/588db50c8cf2c2ea081b2be7c1c3bc5452cdef20/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=588db50c8cf2c2ea081b2be7c1c3bc5452cdef20", "patch": "@@ -5208,20 +5208,20 @@ track_expr_p (tree expr, bool need_rtl)\n \t      || (TREE_CODE (realdecl) == MEM_REF\n \t\t  && TREE_CODE (TREE_OPERAND (realdecl, 0)) == ADDR_EXPR))\n \t    {\n-\t      HOST_WIDE_INT bitsize, bitpos, maxsize;\n+\t      HOST_WIDE_INT bitsize, bitpos;\n \t      bool reverse;\n \t      tree innerdecl\n-\t\t= get_ref_base_and_extent (realdecl, &bitpos, &bitsize,\n-\t\t\t\t\t   &maxsize, &reverse);\n-\t      if (!DECL_P (innerdecl)\n+\t\t= get_ref_base_and_extent_hwi (realdecl, &bitpos,\n+\t\t\t\t\t       &bitsize, &reverse);\n+\t      if (!innerdecl\n+\t\t  || !DECL_P (innerdecl)\n \t\t  || DECL_IGNORED_P (innerdecl)\n \t\t  /* Do not track declarations for parts of tracked record\n \t\t     parameters since we want to track them as a whole.  */\n \t\t  || tracked_record_parameter_p (innerdecl)\n \t\t  || TREE_STATIC (innerdecl)\n-\t\t  || bitsize <= 0\n-\t\t  || bitpos + bitsize > 256\n-\t\t  || bitsize != maxsize)\n+\t\t  || bitsize == 0\n+\t\t  || bitpos + bitsize > 256)\n \t\treturn 0;\n \t      else\n \t\trealdecl = expr;"}]}