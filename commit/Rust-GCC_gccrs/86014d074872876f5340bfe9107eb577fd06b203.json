{"sha": "86014d074872876f5340bfe9107eb577fd06b203", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwMTRkMDc0ODcyODc2ZjUzNDBiZmU5MTA3ZWI1NzdmZDA2YjIwMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-04-01T17:46:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-04-01T17:46:17Z"}, "message": "sched-ebb.c (begin_schedule_ready): Remove second argument.\n\n\t* sched-ebb.c (begin_schedule_ready): Remove second argument.\n\tSplit most of the code into...\n\t(begin_move_insn): ... here.  New function.\n\t(ebb_sched_info): Add a pointer to it.\n\t* haifa-sched.c (scheduled_insns): New static variable.\n\t(sched_extend_ready_list): Allocate it.\n\t(schedule_block): Use it to record the order of scheduled insns.\n\tPerform RTL changes to move insns only after all scheduling\n\tdecisions have been made.\n\t* modulo-sched.c (sms_sched_haifa_sched_info): Add NULL entry for the\n\tbegin_move_insn field.\n\t* sel-sched-ir.c (sched_sel_haifa_sched_info): Likewise.\n\t* sched-int.h (struct haifa_sched_info): Remove second argument\n\tfrom begin_schedule_ready hook.  Add new member begin_move_insn.\n\t* sched-rgn.c (begin_schedule_ready): Remove second argument.\n\t(rgn_const_sched_info): Add NULL entry for the begin_move_insn field.\n\nFrom-SVN: r171843", "tree": {"sha": "3cfbbe26eff243d60d0a43f726d613c2f146bae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cfbbe26eff243d60d0a43f726d613c2f146bae0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86014d074872876f5340bfe9107eb577fd06b203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86014d074872876f5340bfe9107eb577fd06b203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86014d074872876f5340bfe9107eb577fd06b203", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86014d074872876f5340bfe9107eb577fd06b203/comments", "author": null, "committer": null, "parents": [{"sha": "2a6a0d809f0fe62306e21aaad89227205181e0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a6a0d809f0fe62306e21aaad89227205181e0e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a6a0d809f0fe62306e21aaad89227205181e0e4"}], "stats": {"total": 184, "additions": 101, "deletions": 83}, "files": [{"sha": "e5412ef3886e6f1eb7c824c156d85ee3c9023ed4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -15,6 +15,23 @@\n \n \t* sched-ebb.c (schedule_ebbs): Honor the BB_DISABLE_SCHEDULE flag.\n \n+\t* sched-ebb.c (begin_schedule_ready): Remove second argument.\n+\tSplit most of the code into...\n+\t(begin_move_insn): ... here.  New function.\n+\t(ebb_sched_info): Add a pointer to it.\n+\t* haifa-sched.c (scheduled_insns): New static variable.\n+\t(sched_extend_ready_list): Allocate it.\n+\t(schedule_block): Use it to record the order of scheduled insns.\n+\tPerform RTL changes to move insns only after all scheduling\n+\tdecisions have been made.\n+\t* modulo-sched.c (sms_sched_haifa_sched_info): Add NULL entry for the\n+\tbegin_move_insn field.\n+\t* sel-sched-ir.c (sched_sel_haifa_sched_info): Likewise.\n+\t* sched-int.h (struct haifa_sched_info): Remove second argument\n+\tfrom begin_schedule_ready hook.  Add new member begin_move_insn.\n+\t* sched-rgn.c (begin_schedule_ready): Remove second argument.\n+\t(rgn_const_sched_info): Add NULL entry for the begin_move_insn field.\n+\n 2011-04-01  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/spu/t-spu-elf (dp-bit.c): Use > instead of >>."}, {"sha": "70cb22702888b76f7fdc85b606109f978ad706ef", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 59, "deletions": 72, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -302,6 +302,10 @@ static struct ready_list *readyp = &ready;\n /* Scheduling clock.  */\n static int clock_var;\n \n+/* This records the actual schedule.  It is built up during the main phase\n+   of schedule_block, and afterwards used to reorder the insns in the RTL.  */\n+static VEC(rtx, heap) *scheduled_insns;\n+\n static int may_trap_exp (const_rtx, int);\n \n /* Nonzero iff the address is comprised from at most 1 register.  */\n@@ -2813,6 +2817,51 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n     }\n }\n \n+/* This function is called when we have successfully scheduled a\n+   block.  It uses the schedule stored in the scheduled_insns vector\n+   to rearrange the RTL.  PREV_HEAD is used as the anchor to which we\n+   append the scheduled insns; TAIL is the insn after the scheduled\n+   block.  TARGET_BB is the argument passed to schedule_block.  */\n+\n+static void\n+commit_schedule (rtx prev_head, rtx tail, basic_block *target_bb)\n+{\n+  int i;\n+\n+  last_scheduled_insn = prev_head;\n+  for (i = 0; i < (int)VEC_length (rtx, scheduled_insns); i++)\n+    {\n+      rtx insn = VEC_index (rtx, scheduled_insns, i);\n+\n+      if (control_flow_insn_p (last_scheduled_insn)\n+\t  || current_sched_info->advance_target_bb (*target_bb, insn))\n+\t{\n+\t  *target_bb = current_sched_info->advance_target_bb (*target_bb, 0);\n+\n+\t  if (sched_verbose)\n+\t    {\n+\t      rtx x;\n+\n+\t      x = next_real_insn (last_scheduled_insn);\n+\t      gcc_assert (x);\n+\t      dump_new_block_header (1, *target_bb, x, tail);\n+\t    }\n+\n+\t  last_scheduled_insn = bb_note (*target_bb);\n+\t}\n+\n+      if (current_sched_info->begin_move_insn)\n+\t(*current_sched_info->begin_move_insn) (insn, last_scheduled_insn);\n+      move_insn (insn, last_scheduled_insn,\n+\t\t current_sched_info->next_tail);\n+      if (!DEBUG_INSN_P (insn))\n+\treemit_notes (insn);\n+      last_scheduled_insn = insn;\n+    }\n+\n+  VEC_truncate (rtx, scheduled_insns, 0);\n+}\n+\n /* Use forward list scheduling to rearrange insns of block pointed to by\n    TARGET_BB, possibly bringing insns from subsequent blocks in the same\n    region.  */\n@@ -2934,6 +2983,7 @@ schedule_block (basic_block *target_bb)\n \n   advance = 0;\n \n+  gcc_assert (VEC_length (rtx, scheduled_insns) == 0);\n   sort_p = TRUE;\n   /* Loop until all the insns in BB are scheduled.  */\n   while ((*current_sched_info->schedule_more_p) ())\n@@ -2979,31 +3029,12 @@ schedule_block (basic_block *target_bb)\n \t them out right away.  */\n       if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n \t{\n-\t  if (control_flow_insn_p (last_scheduled_insn))\n-\t    {\n-\t      *target_bb = current_sched_info->advance_target_bb\n-\t\t(*target_bb, 0);\n-\n-\t      if (sched_verbose)\n-\t\t{\n-\t\t  rtx x;\n-\n-\t\t  x = next_real_insn (last_scheduled_insn);\n-\t\t  gcc_assert (x);\n-\t\t  dump_new_block_header (1, *target_bb, x, tail);\n-\t\t}\n-\n-\t      last_scheduled_insn = bb_note (*target_bb);\n-\t    }\n-\n \t  while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n \t    {\n \t      rtx insn = ready_remove_first (&ready);\n \t      gcc_assert (DEBUG_INSN_P (insn));\n-\t      (*current_sched_info->begin_schedule_ready) (insn,\n-\t\t\t\t\t\t\t   last_scheduled_insn);\n-\t      move_insn (insn, last_scheduled_insn,\n-\t\t\t current_sched_info->next_tail);\n+\t      (*current_sched_info->begin_schedule_ready) (insn);\n+\t      VEC_safe_push (rtx, heap, scheduled_insns, insn);\n \t      last_scheduled_insn = insn;\n \t      advance = schedule_insn (insn);\n \t      gcc_assert (advance == 0);\n@@ -3165,39 +3196,12 @@ schedule_block (basic_block *target_bb)\n           if (TODO_SPEC (insn) & SPECULATIVE)\n             generate_recovery_code (insn);\n \n-\t  if (control_flow_insn_p (last_scheduled_insn)\n-\t      /* This is used to switch basic blocks by request\n-\t\t from scheduler front-end (actually, sched-ebb.c only).\n-\t\t This is used to process blocks with single fallthru\n-\t\t edge.  If succeeding block has jump, it [jump] will try\n-\t\t move at the end of current bb, thus corrupting CFG.  */\n-\t      || current_sched_info->advance_target_bb (*target_bb, insn))\n-\t    {\n-\t      *target_bb = current_sched_info->advance_target_bb\n-\t\t(*target_bb, 0);\n-\n-\t      if (sched_verbose)\n-\t\t{\n-\t\t  rtx x;\n-\n-\t\t  x = next_real_insn (last_scheduled_insn);\n-\t\t  gcc_assert (x);\n-\t\t  dump_new_block_header (1, *target_bb, x, tail);\n-\t\t}\n-\n-\t      last_scheduled_insn = bb_note (*target_bb);\n-\t    }\n-\n-\t  /* Update counters, etc in the scheduler's front end.  */\n-\t  (*current_sched_info->begin_schedule_ready) (insn,\n-\t\t\t\t\t\t       last_scheduled_insn);\n-\n-\t  move_insn (insn, last_scheduled_insn, current_sched_info->next_tail);\n-\n \t  if (targetm.sched.dispatch (NULL_RTX, IS_DISPATCH_ON))\n \t    targetm.sched.dispatch_do (insn, ADD_TO_DISPATCH_WINDOW);\n \n-\t  reemit_notes (insn);\n+\t  /* Update counters, etc in the scheduler's front end.  */\n+\t  (*current_sched_info->begin_schedule_ready) (insn);\n+ \t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n \t  last_scheduled_insn = insn;\n \n \t  if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n@@ -3236,31 +3240,12 @@ schedule_block (basic_block *target_bb)\n \t  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))\n \t      && (*current_sched_info->schedule_more_p) ())\n \t    {\n-\t      if (control_flow_insn_p (last_scheduled_insn))\n-\t\t{\n-\t\t  *target_bb = current_sched_info->advance_target_bb\n-\t\t    (*target_bb, 0);\n-\n-\t\t  if (sched_verbose)\n-\t\t    {\n-\t\t      rtx x;\n-\n-\t\t      x = next_real_insn (last_scheduled_insn);\n-\t\t      gcc_assert (x);\n-\t\t      dump_new_block_header (1, *target_bb, x, tail);\n-\t\t    }\n-\n-\t\t  last_scheduled_insn = bb_note (*target_bb);\n-\t\t}\n-\n  \t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n \t\t{\n \t\t  insn = ready_remove_first (&ready);\n \t\t  gcc_assert (DEBUG_INSN_P (insn));\n-\t\t  (*current_sched_info->begin_schedule_ready)\n-\t\t    (insn, last_scheduled_insn);\n-\t\t  move_insn (insn, last_scheduled_insn,\n-\t\t\t     current_sched_info->next_tail);\n+\t\t  (*current_sched_info->begin_schedule_ready) (insn);\n+\t\t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n \t\t  advance = schedule_insn (insn);\n \t\t  last_scheduled_insn = insn;\n \t\t  gcc_assert (advance == 0);\n@@ -3321,6 +3306,7 @@ schedule_block (basic_block *target_bb)\n \t  }\n     }\n \n+  commit_schedule (prev_head, tail, target_bb);\n   if (sched_verbose)\n     fprintf (sched_dump, \";;   total time = %d\\n\", clock_var);\n \n@@ -4001,6 +3987,7 @@ sched_extend_ready_list (int new_sched_ready_n_insns)\n     {\n       i = 0;\n       sched_ready_n_insns = 0;\n+      scheduled_insns = VEC_alloc (rtx, heap, new_sched_ready_n_insns);\n     }\n   else\n     i = sched_ready_n_insns + 1;"}, {"sha": "7a113d60c496beccf5789df0729d190d688bcb36", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -1,5 +1,5 @@\n /* Swing Modulo Scheduling implementation.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -275,7 +275,7 @@ static struct haifa_sched_info sms_sched_info =\n   NULL, NULL,\n   0, 0,\n \n-  NULL, NULL, NULL,\n+  NULL, NULL, NULL, NULL,\n   0\n };\n "}, {"sha": "6bb223bbd3bb32065dd652c5820c39574ceae385", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -59,7 +59,7 @@ static basic_block last_bb;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n static void init_ready_list (void);\n-static void begin_schedule_ready (rtx, rtx);\n+static void begin_schedule_ready (rtx);\n static int schedule_more_p (void);\n static const char *ebb_print_insn (const_rtx, int);\n static int rank (rtx, rtx);\n@@ -125,10 +125,15 @@ init_ready_list (void)\n \n /* INSN is being scheduled after LAST.  Update counters.  */\n static void\n-begin_schedule_ready (rtx insn, rtx last)\n+begin_schedule_ready (rtx insn ATTRIBUTE_UNUSED)\n {\n   sched_rgn_n_insns++;\n+}\n \n+/* INSN is being moved to its place in the schedule, after LAST.  */\n+static void\n+begin_move_insn (rtx insn, rtx last)\n+{\n   if (BLOCK_FOR_INSN (insn) == last_bb\n       /* INSN is a jump in the last block, ...  */\n       && control_flow_insn_p (insn)\n@@ -288,6 +293,7 @@ static struct haifa_sched_info ebb_sched_info =\n \n   ebb_add_remove_insn,\n   begin_schedule_ready,\n+  begin_move_insn,\n   advance_target_bb,\n   SCHED_EBB\n   /* We can create new blocks in begin_schedule_ready ().  */"}, {"sha": "d5add3bf2187e266637914f1e66583ab19c4747b", "filename": "gcc/sched-int.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -605,10 +605,15 @@ struct haifa_sched_info\n      parameter == 0) or removed (second parameter == 1).  */\n   void (*add_remove_insn) (rtx, int);\n \n-  /* Called to notify frontend that instruction is being scheduled.\n-     The first parameter - instruction to scheduled, the second parameter -\n-     last scheduled instruction.  */\n-  void (*begin_schedule_ready) (rtx, rtx);\n+  /* Called to notify the frontend that instruction INSN is being\n+     scheduled.  */\n+  void (*begin_schedule_ready) (rtx insn);\n+\n+  /* Called to notify the frontend that an instruction INSN is about to be\n+     moved to its correct place in the final schedule.  This is done for all\n+     insns in order of the schedule.  LAST indicates the last scheduled\n+     instruction.  */\n+  void (*begin_move_insn) (rtx insn, rtx last);\n \n   /* If the second parameter is not NULL, return nonnull value, if the\n      basic block should be advanced."}, {"sha": "2c00907036fa366e3e5e5a45886ed6534844a979", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -2057,7 +2057,7 @@ static int sched_n_insns;\n /* Implementations of the sched_info functions for region scheduling.  */\n static void init_ready_list (void);\n static int can_schedule_ready_p (rtx);\n-static void begin_schedule_ready (rtx, rtx);\n+static void begin_schedule_ready (rtx);\n static ds_t new_ready (rtx, ds_t);\n static int schedule_more_p (void);\n static const char *rgn_print_insn (const_rtx, int);\n@@ -2152,7 +2152,7 @@ can_schedule_ready_p (rtx insn)\n    can_schedule_ready_p () differs from the one passed to\n    begin_schedule_ready ().  */\n static void\n-begin_schedule_ready (rtx insn, rtx last ATTRIBUTE_UNUSED)\n+begin_schedule_ready (rtx insn)\n {\n   /* An interblock motion?  */\n   if (INSN_BB (insn) != target_bb)\n@@ -2369,6 +2369,7 @@ static const struct haifa_sched_info rgn_const_sched_info =\n \n   rgn_add_remove_insn,\n   begin_schedule_ready,\n+  NULL,\n   advance_target_bb,\n   SCHED_RGN\n };"}, {"sha": "67484dd77d9fc86c6012a736e9bbfbb791b7464c", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86014d074872876f5340bfe9107eb577fd06b203/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=86014d074872876f5340bfe9107eb577fd06b203", "patch": "@@ -1,5 +1,6 @@\n /* Instruction scheduling pass.  Selective scheduler and pipeliner.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -5649,6 +5650,7 @@ static struct haifa_sched_info sched_sel_haifa_sched_info =\n \n   NULL, /* add_remove_insn */\n   NULL, /* begin_schedule_ready */\n+  NULL, /* begin_move_insn */\n   NULL, /* advance_target_bb */\n   SEL_SCHED | NEW_BBS\n };"}]}