{"sha": "67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdkYmU1ODI5ZTJmOWNhYzlkZWI3NTY3NjJjZGFmNWE4ODI5Y2IzMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-23T10:01:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-23T10:01:47Z"}, "message": "Move fold_trunc_transparent_mathfn to match.pd\n\nThis moves the fold rules for trunc, floor, ceil, round, nearbyint and\nrint in one go, since they're tested as a group.  Most of the code is\nsupporting the f(x)->x fold when x is known to be integer-valued.\nLike with the non-negative test, this is probably more elegantly handled\nby tracking range information for reals, but until that happens, I think\nwe should handle it analogously to tree_expr_nonnegative_p.\n\nI've incorporated the fix for PR68031 in the new version of\ninteger_valued_real_p.  However, it seemed confusing to test for an\nSSA name at the head of the function rather than the case statement,\nand not fall through to tree_simple_nonnegative_warnv_p (which\nconceptually shouldn't care whether an update is in progress).\nBut tree_simple_nonnegative_warnv_p is a no-op for SSA names,\nso I simply changed it to:\n\n          return (!name_registered_for_update_p (t)\n\t      && depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH)\n\t      && gimple_stmt_nonnegative_warnv_p (SSA_NAME_DEF_STMT (t),\n\t\t\t\t\t\t  strict_overflow_p, depth));\n\nand used that in the new code too.\n\nDoing these folds later meant that IPA would start to use information\nabout the aborting sinf and floor in 20030125-1.c before the folds\nkicked in.  I changed them from noinline to weak to stop that.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* builtins.c (integer_valued_real_p): Move to fold-const.c.\n\t(fold_trunc_transparent_mathfn, fold_builtin_trunc, fold_builtin_floor)\n\t(fold_builtin_ceil, fold_builtin_round): Delete.\n\t(fold_builtin_1): Handle constant trunc, floor, ceil and round\n\targuments here.\n\t* convert.c (convert_to_real): Remove narrowing of rounding\n\tfunctions.\n\t* fold-const.h (integer_valued_real_unary_p)\n\t(integer_valued_real_binary_p, integer_valued_real_call_p)\n\t(integer_valued_real_single_p, integer_valued_real_p): Declare.\n\t* fold-const.c (tree_single_nonnegative_warnv_p): Move\n\tname_registered_for_update_p check to SSA_NAME case statement.\n\tDon't call tree_simple_nonnegative_warnv_p for SSA names.\n\t(integer_valued_real_unary_p, integer_valued_real_binary_p)\n\t(integer_valued_real_call_p, integer_valued_real_single_p)\n\t(integer_valued_real_invalid_p): New functions.\n\t(integer_valued_real_p): Move from fold-const.c and rework\n\tto call the functions above.  Handle SSA names.\n\t* gimple-fold.h (gimple_stmt_integer_valued_real_p): Declare.\n\t* gimple-fold.c (gimple_assign_integer_valued_real_p)\n\t(gimple_call_integer_valued_real_p, gimple_phi_integer_valued_real_p)\n\t(gimple_stmt_integer_valued_real_p): New functions.\n\t* match.pd: Fold f(f(x))->f(x) for fp->fp rounding functions f.\n\tFold f(x)->x for the same f if x is known to be integer-valued.\n\tFold f(extend(x))->extend(f'(x)) if doing so doesn't affect\n\tthe result.  Canonicalize floor(x) as trunc(x) if x is\n\tnonnegative.\n\ngcc/testsuite/\n\t* gcc.c-torture/execute/20030125-1.c (floor, floorf, sin, sinf):\n\tMake weak rather than noinline.\n\t* gcc.dg/builtins-57.c: Compile with -O.\n\t* gcc.dg/torture/builtin-integral-1.c: Skip for -O0.\n\nFrom-SVN: r229221", "tree": {"sha": "2104e5a46faba7156714cceac0b8be8dce7c9b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2104e5a46faba7156714cceac0b8be8dce7c9b63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "735a559c68e208b9dd5b5a4bb7e109289743fbeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735a559c68e208b9dd5b5a4bb7e109289743fbeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/735a559c68e208b9dd5b5a4bb7e109289743fbeb"}], "stats": {"total": 758, "additions": 474, "deletions": 284}, "files": [{"sha": "c699fa66fa67a85c373d02481fc623bd334b5c98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -1,3 +1,33 @@\n+2015-10-23  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* builtins.c (integer_valued_real_p): Move to fold-const.c.\n+\t(fold_trunc_transparent_mathfn, fold_builtin_trunc, fold_builtin_floor)\n+\t(fold_builtin_ceil, fold_builtin_round): Delete.\n+\t(fold_builtin_1): Handle constant trunc, floor, ceil and round\n+\targuments here.\n+\t* convert.c (convert_to_real): Remove narrowing of rounding\n+\tfunctions.\n+\t* fold-const.h (integer_valued_real_unary_p)\n+\t(integer_valued_real_binary_p, integer_valued_real_call_p)\n+\t(integer_valued_real_single_p, integer_valued_real_p): Declare.\n+\t* fold-const.c (tree_single_nonnegative_warnv_p): Move\n+\tname_registered_for_update_p check to SSA_NAME case statement.\n+\tDon't call tree_simple_nonnegative_warnv_p for SSA names.\n+\t(integer_valued_real_unary_p, integer_valued_real_binary_p)\n+\t(integer_valued_real_call_p, integer_valued_real_single_p)\n+\t(integer_valued_real_invalid_p): New functions.\n+\t(integer_valued_real_p): Move from fold-const.c and rework\n+\tto call the functions above.  Handle SSA names.\n+\t* gimple-fold.h (gimple_stmt_integer_valued_real_p): Declare.\n+\t* gimple-fold.c (gimple_assign_integer_valued_real_p)\n+\t(gimple_call_integer_valued_real_p, gimple_phi_integer_valued_real_p)\n+\t(gimple_stmt_integer_valued_real_p): New functions.\n+\t* match.pd: Fold f(f(x))->f(x) for fp->fp rounding functions f.\n+\tFold f(x)->x for the same f if x is known to be integer-valued.\n+\tFold f(extend(x))->extend(f'(x)) if doing so doesn't affect\n+\tthe result.  Canonicalize floor(x) as trunc(x) if x is\n+\tnonnegative.\n+\n 2015-10-23  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-structalias.c (intra_create_variable_infos): Use"}, {"sha": "8b5e3f383a02f0ce6e1b168377866da7cfe4f629", "filename": "gcc/builtins.c", "status": "modified", "additions": 44, "deletions": 240, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -154,16 +154,10 @@ static tree fold_builtin_inf (location_t, tree, int);\n static tree fold_builtin_nan (tree, tree, int);\n static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n-static bool integer_valued_real_p (tree);\n-static tree fold_trunc_transparent_mathfn (location_t, tree, tree);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_pow (location_t, tree, tree, tree, tree);\n static tree fold_builtin_powi (location_t, tree, tree, tree, tree);\n-static tree fold_builtin_trunc (location_t, tree, tree);\n-static tree fold_builtin_floor (location_t, tree, tree);\n-static tree fold_builtin_ceil (location_t, tree, tree);\n-static tree fold_builtin_round (location_t, tree, tree);\n static tree fold_builtin_int_roundingfn (location_t, tree, tree);\n static tree fold_builtin_bitop (tree, tree);\n static tree fold_builtin_strchr (location_t, tree, tree, tree);\n@@ -7320,117 +7314,6 @@ fold_builtin_nan (tree arg, tree type, int quiet)\n   return build_real (type, real);\n }\n \n-/* Return true if the floating point expression T has an integer value.\n-   We also allow +Inf, -Inf and NaN to be considered integer values.  */\n-\n-static bool\n-integer_valued_real_p (tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case FLOAT_EXPR:\n-      return true;\n-\n-    case ABS_EXPR:\n-    case SAVE_EXPR:\n-      return integer_valued_real_p (TREE_OPERAND (t, 0));\n-\n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case BIND_EXPR:\n-      return integer_valued_real_p (TREE_OPERAND (t, 1));\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-    case MIN_EXPR:\n-    case MAX_EXPR:\n-      return integer_valued_real_p (TREE_OPERAND (t, 0))\n-\t     && integer_valued_real_p (TREE_OPERAND (t, 1));\n-\n-    case COND_EXPR:\n-      return integer_valued_real_p (TREE_OPERAND (t, 1))\n-\t     && integer_valued_real_p (TREE_OPERAND (t, 2));\n-\n-    case REAL_CST:\n-      return real_isinteger (TREE_REAL_CST_PTR (t), TYPE_MODE (TREE_TYPE (t)));\n-\n-    CASE_CONVERT:\n-      {\n-\ttree type = TREE_TYPE (TREE_OPERAND (t, 0));\n-\tif (TREE_CODE (type) == INTEGER_TYPE)\n-\t  return true;\n-\tif (TREE_CODE (type) == REAL_TYPE)\n-\t  return integer_valued_real_p (TREE_OPERAND (t, 0));\n-\tbreak;\n-      }\n-\n-    case CALL_EXPR:\n-      switch (builtin_mathfn_code (t))\n-\t{\n-\tCASE_FLT_FN (BUILT_IN_CEIL):\n-\tCASE_FLT_FN (BUILT_IN_FLOOR):\n-\tCASE_FLT_FN (BUILT_IN_NEARBYINT):\n-\tCASE_FLT_FN (BUILT_IN_RINT):\n-\tCASE_FLT_FN (BUILT_IN_ROUND):\n-\tCASE_FLT_FN (BUILT_IN_TRUNC):\n-\t  return true;\n-\n-\tCASE_FLT_FN (BUILT_IN_FMIN):\n-\tCASE_FLT_FN (BUILT_IN_FMAX):\n-\t  return integer_valued_real_p (CALL_EXPR_ARG (t, 0))\n- \t    && integer_valued_real_p (CALL_EXPR_ARG (t, 1));\n-\n-\tdefault:\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  return false;\n-}\n-\n-/* FNDECL is assumed to be a builtin where truncation can be propagated\n-   across (for instance floor((double)f) == (double)floorf (f).\n-   Do the transformation for a call with argument ARG.  */\n-\n-static tree\n-fold_trunc_transparent_mathfn (location_t loc, tree fndecl, tree arg)\n-{\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Integer rounding functions are idempotent.  */\n-  if (fcode == builtin_mathfn_code (arg))\n-    return arg;\n-\n-  /* If argument is already integer valued, and we don't need to worry\n-     about setting errno, there's no need to perform rounding.  */\n-  if (! flag_errno_math && integer_valued_real_p (arg))\n-    return arg;\n-\n-  if (optimize)\n-    {\n-      tree arg0 = strip_float_extensions (arg);\n-      tree ftype = TREE_TYPE (TREE_TYPE (fndecl));\n-      tree newtype = TREE_TYPE (arg0);\n-      tree decl;\n-\n-      if (TYPE_PRECISION (newtype) < TYPE_PRECISION (ftype)\n-\t  && (decl = mathfn_built_in (newtype, fcode)))\n-\treturn fold_convert_loc (loc, ftype,\n-\t\t\t\t build_call_expr_loc (loc, decl, 1,\n-\t\t\t\t\t\t  fold_convert_loc (loc,\n-\t\t\t\t\t\t\t\t    newtype,\n-\t\t\t\t\t\t\t\t    arg0)));\n-    }\n-  return NULL_TREE;\n-}\n-\n /* FNDECL is assumed to be builtin which can narrow the FP type of\n    the argument, for instance lround((double)f) -> lroundf (f).\n    Do the transformation for a call with argument ARG.  */\n@@ -7645,121 +7528,6 @@ fold_builtin_cexp (location_t loc, tree arg0, tree type)\n   return NULL_TREE;\n }\n \n-/* Fold function call to builtin trunc, truncf or truncl with argument ARG.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_trunc (location_t loc, tree fndecl, tree arg)\n-{\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Optimize trunc of constant value.  */\n-  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n-    {\n-      REAL_VALUE_TYPE r, x;\n-      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\n-      x = TREE_REAL_CST (arg);\n-      real_trunc (&r, TYPE_MODE (type), &x);\n-      return build_real (type, r);\n-    }\n-\n-  return fold_trunc_transparent_mathfn (loc, fndecl, arg);\n-}\n-\n-/* Fold function call to builtin floor, floorf or floorl with argument ARG.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_floor (location_t loc, tree fndecl, tree arg)\n-{\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Optimize floor of constant value.  */\n-  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n-    {\n-      REAL_VALUE_TYPE x;\n-\n-      x = TREE_REAL_CST (arg);\n-      if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n-\t{\n-\t  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\t  REAL_VALUE_TYPE r;\n-\n-\t  real_floor (&r, TYPE_MODE (type), &x);\n-\t  return build_real (type, r);\n-\t}\n-    }\n-\n-  /* Fold floor (x) where x is nonnegative to trunc (x).  */\n-  if (tree_expr_nonnegative_p (arg))\n-    {\n-      tree truncfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_TRUNC);\n-      if (truncfn)\n-\treturn build_call_expr_loc (loc, truncfn, 1, arg);\n-    }\n-\n-  return fold_trunc_transparent_mathfn (loc, fndecl, arg);\n-}\n-\n-/* Fold function call to builtin ceil, ceilf or ceill with argument ARG.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_ceil (location_t loc, tree fndecl, tree arg)\n-{\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Optimize ceil of constant value.  */\n-  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n-    {\n-      REAL_VALUE_TYPE x;\n-\n-      x = TREE_REAL_CST (arg);\n-      if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n-\t{\n-\t  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\t  REAL_VALUE_TYPE r;\n-\n-\t  real_ceil (&r, TYPE_MODE (type), &x);\n-\t  return build_real (type, r);\n-\t}\n-    }\n-\n-  return fold_trunc_transparent_mathfn (loc, fndecl, arg);\n-}\n-\n-/* Fold function call to builtin round, roundf or roundl with argument ARG.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_round (location_t loc, tree fndecl, tree arg)\n-{\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Optimize round of constant value.  */\n-  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n-    {\n-      REAL_VALUE_TYPE x;\n-\n-      x = TREE_REAL_CST (arg);\n-      if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n-\t{\n-\t  tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-\t  REAL_VALUE_TYPE r;\n-\n-\t  real_round (&r, TYPE_MODE (type), &x);\n-\t  return build_real (type, r);\n-\t}\n-    }\n-\n-  return fold_trunc_transparent_mathfn (loc, fndecl, arg);\n-}\n-\n /* Fold function call to builtin lround, lroundf or lroundl (or the\n    corresponding long long versions) and other rounding functions.  ARG\n    is the argument to the call.  Return NULL_TREE if no simplification\n@@ -9696,20 +9464,56 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n       return fold_builtin_nan (arg0, type, false);\n \n     CASE_FLT_FN (BUILT_IN_FLOOR):\n-      return fold_builtin_floor (loc, fndecl, arg0);\n+      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n+\t{\n+\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n+\t  if (!REAL_VALUE_ISNAN (x) || !flag_errno_math)\n+\t    {\n+\t      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+\t      REAL_VALUE_TYPE r;\n+\t      real_floor (&r, TYPE_MODE (type), &x);\n+\t      return build_real (type, r);\n+\t    }\n+\t}\n+      break;\n \n     CASE_FLT_FN (BUILT_IN_CEIL):\n-      return fold_builtin_ceil (loc, fndecl, arg0);\n+      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n+\t{\n+\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n+\t  if (!REAL_VALUE_ISNAN (x) || !flag_errno_math)\n+\t    {\n+\t      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+\t      REAL_VALUE_TYPE r;\n+\t      real_ceil (&r, TYPE_MODE (type), &x);\n+\t      return build_real (type, r);\n+\t    }\n+\t}\n+      break;\n \n     CASE_FLT_FN (BUILT_IN_TRUNC):\n-      return fold_builtin_trunc (loc, fndecl, arg0);\n+      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n+\t{\n+\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n+\t  REAL_VALUE_TYPE r;\n+\t  real_trunc (&r, TYPE_MODE (type), &x);\n+\t  return build_real (type, r);\n+\t}\n+      break;\n \n     CASE_FLT_FN (BUILT_IN_ROUND):\n-      return fold_builtin_round (loc, fndecl, arg0);\n-\n-    CASE_FLT_FN (BUILT_IN_NEARBYINT):\n-    CASE_FLT_FN (BUILT_IN_RINT):\n-      return fold_trunc_transparent_mathfn (loc, fndecl, arg0);\n+      if (TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0))\n+\t{\n+\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg0);\n+\t  if (!REAL_VALUE_ISNAN (x) || !flag_errno_math)\n+\t    {\n+\t      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+\t      REAL_VALUE_TYPE r;\n+\t      real_round (&r, TYPE_MODE (type), &x);\n+\t      return build_real (type, r);\n+\t    }\n+\t}\n+      break;\n \n     CASE_FLT_FN (BUILT_IN_ICEIL):\n     CASE_FLT_FN (BUILT_IN_LCEIL):"}, {"sha": "498d3a5c748c8d171382375cdd43809807f31269", "filename": "gcc/convert.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -225,37 +225,6 @@ convert_to_real (tree type, tree expr)\n \t  break;\n \t}\n     }\n-  if (optimize\n-      && (((fcode == BUILT_IN_FLOORL\n-\t   || fcode == BUILT_IN_CEILL\n-\t   || fcode == BUILT_IN_ROUNDL\n-\t   || fcode == BUILT_IN_RINTL\n-\t   || fcode == BUILT_IN_TRUNCL\n-\t   || fcode == BUILT_IN_NEARBYINTL)\n-\t  && (TYPE_MODE (type) == TYPE_MODE (double_type_node)\n-\t      || TYPE_MODE (type) == TYPE_MODE (float_type_node)))\n-\t  || ((fcode == BUILT_IN_FLOOR\n-\t       || fcode == BUILT_IN_CEIL\n-\t       || fcode == BUILT_IN_ROUND\n-\t       || fcode == BUILT_IN_RINT\n-\t       || fcode == BUILT_IN_TRUNC\n-\t       || fcode == BUILT_IN_NEARBYINT)\n-\t      && (TYPE_MODE (type) == TYPE_MODE (float_type_node)))))\n-    {\n-      tree fn = mathfn_built_in (type, fcode);\n-\n-      if (fn)\n-\t{\n-\t  tree arg = strip_float_extensions (CALL_EXPR_ARG (expr, 0));\n-\n-\t  /* Make sure (type)arg0 is an extension, otherwise we could end up\n-\t     changing (float)floor(double d) into floorf((float)d), which is\n-\t     incorrect because (float)d uses round-to-nearest and can round\n-\t     up to the next integer.  */\n-\t  if (TYPE_PRECISION (type) >= TYPE_PRECISION (TREE_TYPE (arg)))\n-\t    return build_call_expr (fn, 1, fold (convert_to_real (type, arg)));\n-\t}\n-    }\n \n   /* Propagate the cast into the operation.  */\n   if (itype != type && FLOAT_TYPE_P (type))"}, {"sha": "6eed7b611c664be5b4147cca5c5752c70594f139", "filename": "gcc/fold-const.c", "status": "modified", "additions": 214, "deletions": 8, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -12896,10 +12896,6 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n bool\n tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n {\n-  if (TREE_CODE (t) == SSA_NAME\n-      && name_registered_for_update_p (t))\n-    return false;\n-\n   if (TYPE_UNSIGNED (TREE_TYPE (t)))\n     return true;\n \n@@ -12923,11 +12919,11 @@ tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n \t If this code misses important cases that unbounded recursion\n \t would not, passes that need this information could be revised\n \t to provide it through dataflow propagation.  */\n-      if (depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH))\n-\treturn gimple_stmt_nonnegative_warnv_p (SSA_NAME_DEF_STMT (t),\n-\t\t\t\t\t\tstrict_overflow_p, depth);\n+      return (!name_registered_for_update_p (t)\n+\t      && depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH)\n+\t      && gimple_stmt_nonnegative_warnv_p (SSA_NAME_DEF_STMT (t),\n+\t\t\t\t\t\t  strict_overflow_p, depth));\n \n-      /* Fallthru.  */\n     default:\n       return tree_simple_nonnegative_warnv_p (TREE_CODE (t), TREE_TYPE (t));\n     }\n@@ -13440,6 +13436,216 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n   return false;\n }\n \n+#define integer_valued_real_p(X) \\\n+  _Pragma (\"GCC error \\\"Use RECURSE for recursive calls\\\"\") 0\n+\n+#define RECURSE(X) \\\n+  ((integer_valued_real_p) (X, depth + 1))\n+\n+/* Return true if the floating point result of (CODE OP0) has an\n+   integer value.  We also allow +Inf, -Inf and NaN to be considered\n+   integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+integer_valued_real_unary_p (tree_code code, tree op0, int depth)\n+{\n+  switch (code)\n+    {\n+    case FLOAT_EXPR:\n+      return true;\n+\n+    case ABS_EXPR:\n+      return RECURSE (op0);\n+\n+    CASE_CONVERT:\n+      {\n+\ttree type = TREE_TYPE (op0);\n+\tif (TREE_CODE (type) == INTEGER_TYPE)\n+\t  return true;\n+\tif (TREE_CODE (type) == REAL_TYPE)\n+\t  return RECURSE (op0);\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Return true if the floating point result of (CODE OP0 OP1) has an\n+   integer value.  We also allow +Inf, -Inf and NaN to be considered\n+   integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+integer_valued_real_binary_p (tree_code code, tree op0, tree op1, int depth)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return RECURSE (op0) && RECURSE (op1);\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Return true if the floating point result of calling FNDECL with arguments\n+   ARG0 and ARG1 has an integer value.  We also allow +Inf, -Inf and NaN to be\n+   considered integer values.  If FNDECL takes fewer than 2 arguments,\n+   the remaining ARGn are null.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+integer_valued_real_call_p (tree fndecl, tree arg0, tree arg1, int depth)\n+{\n+  if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (fndecl))\n+      {\n+      CASE_FLT_FN (BUILT_IN_CEIL):\n+      CASE_FLT_FN (BUILT_IN_FLOOR):\n+      CASE_FLT_FN (BUILT_IN_NEARBYINT):\n+      CASE_FLT_FN (BUILT_IN_RINT):\n+      CASE_FLT_FN (BUILT_IN_ROUND):\n+      CASE_FLT_FN (BUILT_IN_TRUNC):\n+\treturn true;\n+\n+      CASE_FLT_FN (BUILT_IN_FMIN):\n+      CASE_FLT_FN (BUILT_IN_FMAX):\n+\treturn RECURSE (arg0) && RECURSE (arg1);\n+\n+      default:\n+\tbreak;\n+      }\n+  return false;\n+}\n+\n+/* Return true if the floating point expression T (a GIMPLE_SINGLE_RHS)\n+   has an integer value.  We also allow +Inf, -Inf and NaN to be\n+   considered integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+integer_valued_real_single_p (tree t, int depth)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case REAL_CST:\n+      return real_isinteger (TREE_REAL_CST_PTR (t), TYPE_MODE (TREE_TYPE (t)));\n+\n+    case COND_EXPR:\n+      return RECURSE (TREE_OPERAND (t, 1)) && RECURSE (TREE_OPERAND (t, 2));\n+\n+    case SSA_NAME:\n+      /* Limit the depth of recursion to avoid quadratic behavior.\n+\t This is expected to catch almost all occurrences in practice.\n+\t If this code misses important cases that unbounded recursion\n+\t would not, passes that need this information could be revised\n+\t to provide it through dataflow propagation.  */\n+      return (!name_registered_for_update_p (t)\n+\t      && depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH)\n+\t      && gimple_stmt_integer_valued_real_p (SSA_NAME_DEF_STMT (t),\n+\t\t\t\t\t\t    depth));\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Return true if the floating point expression T (a GIMPLE_INVALID_RHS)\n+   has an integer value.  We also allow +Inf, -Inf and NaN to be\n+   considered integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+integer_valued_real_invalid_p (tree t, int depth)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case BIND_EXPR:\n+      return RECURSE (TREE_OPERAND (t, 1));\n+\n+    case SAVE_EXPR:\n+      return RECURSE (TREE_OPERAND (t, 0));\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+#undef RECURSE\n+#undef integer_valued_real_p\n+\n+/* Return true if the floating point expression T has an integer value.\n+   We also allow +Inf, -Inf and NaN to be considered integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+integer_valued_real_p (tree t, int depth)\n+{\n+  if (t == error_mark_node)\n+    return false;\n+\n+  tree_code code = TREE_CODE (t);\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_binary:\n+    case tcc_comparison:\n+      return integer_valued_real_binary_p (code, TREE_OPERAND (t, 0),\n+\t\t\t\t\t   TREE_OPERAND (t, 1), depth);\n+\n+    case tcc_unary:\n+      return integer_valued_real_unary_p (code, TREE_OPERAND (t, 0), depth);\n+\n+    case tcc_constant:\n+    case tcc_declaration:\n+    case tcc_reference:\n+      return integer_valued_real_single_p (t, depth);\n+\n+    default:\n+      break;\n+    }\n+\n+  switch (code)\n+    {\n+    case COND_EXPR:\n+    case SSA_NAME:\n+      return integer_valued_real_single_p (t, depth);\n+\n+    case CALL_EXPR:\n+      {\n+\ttree arg0 = (call_expr_nargs (t) > 0\n+\t\t     ? CALL_EXPR_ARG (t, 0)\n+\t\t     : NULL_TREE);\n+\ttree arg1 = (call_expr_nargs (t) > 1\n+\t\t     ? CALL_EXPR_ARG (t, 1)\n+\t\t     : NULL_TREE);\n+\treturn integer_valued_real_call_p (get_callee_fndecl (t),\n+\t\t\t\t\t   arg0, arg1, depth);\n+      }\n+\n+    default:\n+      return integer_valued_real_invalid_p (t, depth);\n+    }\n+}\n+\n /* Given the components of a binary expression CODE, TYPE, OP0 and OP1,\n    attempt to fold the expression to a constant without modifying TYPE,\n    OP0 or OP1."}, {"sha": "8e49c98b9c5cb6162e342b6dfaf2957000536c41", "filename": "gcc/fold-const.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -139,6 +139,12 @@ extern bool tree_single_nonnegative_warnv_p (tree, bool *, int);\n extern bool tree_call_nonnegative_warnv_p (tree, tree, tree, tree, bool *,\n \t\t\t\t\t   int);\n \n+extern bool integer_valued_real_unary_p (tree_code, tree, int);\n+extern bool integer_valued_real_binary_p (tree_code, tree, tree, int);\n+extern bool integer_valued_real_call_p (tree, tree, tree, int);\n+extern bool integer_valued_real_single_p (tree, int);\n+extern bool integer_valued_real_p (tree, int = 0);\n+\n extern bool fold_real_zero_addition_p (const_tree, const_tree, int);\n extern tree combine_comparisons (location_t, enum tree_code, enum tree_code,\n \t\t\t\t enum tree_code, tree, tree, tree);"}, {"sha": "1869c097d7fb73e39dbbe4e7a1b99938e906d691", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -6266,3 +6266,91 @@ gimple_stmt_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p,\n       return false;\n     }\n }\n+\n+/* Return true if the floating-point value computed by assignment STMT\n+   is known to have an integer value.  We also allow +Inf, -Inf and NaN\n+   to be considered integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+gimple_assign_integer_valued_real_p (gimple *stmt, int depth)\n+{\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  switch (get_gimple_rhs_class (code))\n+    {\n+    case GIMPLE_UNARY_RHS:\n+      return integer_valued_real_unary_p (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t  gimple_assign_rhs1 (stmt), depth);\n+    case GIMPLE_BINARY_RHS:\n+      return integer_valued_real_binary_p (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t   gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t   gimple_assign_rhs2 (stmt), depth);\n+    case GIMPLE_TERNARY_RHS:\n+      return false;\n+    case GIMPLE_SINGLE_RHS:\n+      return integer_valued_real_single_p (gimple_assign_rhs1 (stmt), depth);\n+    case GIMPLE_INVALID_RHS:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Return true if the floating-point value computed by call STMT is known\n+   to have an integer value.  We also allow +Inf, -Inf and NaN to be\n+   considered integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+gimple_call_integer_valued_real_p (gimple *stmt, int depth)\n+{\n+  tree arg0 = (gimple_call_num_args (stmt) > 0\n+\t       ? gimple_call_arg (stmt, 0)\n+\t       : NULL_TREE);\n+  tree arg1 = (gimple_call_num_args (stmt) > 1\n+\t       ? gimple_call_arg (stmt, 1)\n+\t       : NULL_TREE);\n+  return integer_valued_real_call_p (gimple_call_fndecl (stmt),\n+\t\t\t\t     arg0, arg1, depth);\n+}\n+\n+/* Return true if the floating-point result of phi STMT is known to have\n+   an integer value.  We also allow +Inf, -Inf and NaN to be considered\n+   integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+static bool\n+gimple_phi_integer_valued_real_p (gimple *stmt, int depth)\n+{\n+  for (unsigned i = 0; i < gimple_phi_num_args (stmt); ++i)\n+    {\n+      tree arg = gimple_phi_arg_def (stmt, i);\n+      if (!integer_valued_real_single_p (arg, depth + 1))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Return true if the floating-point value computed by STMT is known\n+   to have an integer value.  We also allow +Inf, -Inf and NaN to be\n+   considered integer values.\n+\n+   DEPTH is the current nesting depth of the query.  */\n+\n+bool\n+gimple_stmt_integer_valued_real_p (gimple *stmt, int depth)\n+{\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+      return gimple_assign_integer_valued_real_p (stmt, depth);\n+    case GIMPLE_CALL:\n+      return gimple_call_integer_valued_real_p (stmt, depth);\n+    case GIMPLE_PHI:\n+      return gimple_phi_integer_valued_real_p (stmt, depth);\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "9c24f77d48ae4d2ba10c68c8a383eda5897aefaf", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -120,6 +120,7 @@ gimple_convert_to_ptrofftype (gimple_seq *seq, tree op)\n }\n \n extern bool gimple_stmt_nonnegative_warnv_p (gimple *, bool *, int = 0);\n+extern bool gimple_stmt_integer_valued_real_p (gimple *, int = 0);\n \n /* In gimple-match.c.  */\n extern tree gimple_simplify (enum tree_code, tree, tree,"}, {"sha": "060363656f3620c5eb48ed7a353ce6e19ac55c42", "filename": "gcc/match.pd", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n    zerop\n    CONSTANT_CLASS_P\n    tree_expr_nonnegative_p\n+   integer_valued_real_p\n    integer_pow2p\n    HONOR_NANS)\n \n@@ -70,6 +71,14 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t       BUILT_IN_COPYSIGN\n \t\t\t       BUILT_IN_COPYSIGNL)\n (define_operator_list CABS BUILT_IN_CABSF BUILT_IN_CABS BUILT_IN_CABSL)\n+(define_operator_list TRUNC BUILT_IN_TRUNCF BUILT_IN_TRUNC BUILT_IN_TRUNCL)\n+(define_operator_list FLOOR BUILT_IN_FLOORF BUILT_IN_FLOOR BUILT_IN_FLOORL)\n+(define_operator_list CEIL BUILT_IN_CEILF BUILT_IN_CEIL BUILT_IN_CEILL)\n+(define_operator_list ROUND BUILT_IN_ROUNDF BUILT_IN_ROUND BUILT_IN_ROUNDL)\n+(define_operator_list NEARBYINT BUILT_IN_NEARBYINTF\n+\t\t\t\tBUILT_IN_NEARBYINT\n+\t\t\t\tBUILT_IN_NEARBYINTL)\n+(define_operator_list RINT BUILT_IN_RINTF BUILT_IN_RINT BUILT_IN_RINTL)\n \n /* Simplifications of operations with one constant operand and\n    simplifications to constants or single values.  */\n@@ -2439,6 +2448,23 @@ along with GCC; see the file COPYING3.  If not see\n  (CABS (complex:c @0 real_zerop@1))\n  (abs @0))\n \n+/* trunc(trunc(x)) -> trunc(x), etc.  */\n+(for fns (TRUNC FLOOR CEIL ROUND NEARBYINT RINT)\n+ (simplify\n+  (fns (fns @0))\n+  (fns @0)))\n+/* f(x) -> x if x is integer valued and f does nothing for such values.  */\n+(for fns (TRUNC FLOOR CEIL ROUND NEARBYINT)\n+ (simplify\n+  (fns integer_valued_real_p@0)\n+  @0))\n+/* Same for rint.  We have to check flag_errno_math because\n+   integer_valued_real_p accepts +Inf, -Inf and NaNs as integers.  */\n+(if (!flag_errno_math)\n+ (simplify\n+  (RINT integer_valued_real_p@0)\n+  @0))\n+\n /* Canonicalization of sequences of math builtins.  These rules represent\n    IL simplifications but are not necessarily optimizations.\n \n@@ -2537,6 +2563,57 @@ along with GCC; see the file COPYING3.  If not see\n   (CABS (complex @0 @0))\n   (mult (abs @0) { build_real_truncate (type, dconst_sqrt2 ()); })))\n \n+(if (canonicalize_math_p ())\n+ /* floor(x) -> trunc(x) if x is nonnegative.  */\n+ (for floors (FLOOR)\n+      truncs (TRUNC)\n+  (simplify\n+   (floors tree_expr_nonnegative_p@0)\n+   (truncs @0))))\n+\n+(match double_value_p\n+ @0\n+ (if (TYPE_MAIN_VARIANT (TREE_TYPE (@0)) == double_type_node)))\n+(for froms (BUILT_IN_TRUNCL\n+\t    BUILT_IN_FLOORL\n+\t    BUILT_IN_CEILL\n+\t    BUILT_IN_ROUNDL\n+\t    BUILT_IN_NEARBYINTL\n+\t    BUILT_IN_RINTL)\n+     tos (BUILT_IN_TRUNC\n+\t  BUILT_IN_FLOOR\n+\t  BUILT_IN_CEIL\n+\t  BUILT_IN_ROUND\n+\t  BUILT_IN_NEARBYINT\n+\t  BUILT_IN_RINT)\n+ /* truncl(extend(x)) -> extend(trunc(x)), etc., if x is a double.  */\n+ (if (optimize && canonicalize_math_p ())\n+  (simplify\n+   (froms (convert double_value_p@0))\n+   (convert (tos @0)))))\n+\n+(match float_value_p\n+ @0\n+ (if (TYPE_MAIN_VARIANT (TREE_TYPE (@0)) == float_type_node)))\n+(for froms (BUILT_IN_TRUNCL BUILT_IN_TRUNC\n+\t    BUILT_IN_FLOORL BUILT_IN_FLOOR\n+\t    BUILT_IN_CEILL BUILT_IN_CEIL\n+\t    BUILT_IN_ROUNDL BUILT_IN_ROUND\n+\t    BUILT_IN_NEARBYINTL BUILT_IN_NEARBYINT\n+\t    BUILT_IN_RINTL BUILT_IN_RINT)\n+     tos (BUILT_IN_TRUNCF BUILT_IN_TRUNCF\n+\t  BUILT_IN_FLOORF BUILT_IN_FLOORF\n+\t  BUILT_IN_CEILF BUILT_IN_CEILF\n+\t  BUILT_IN_ROUNDF BUILT_IN_ROUNDF\n+\t  BUILT_IN_NEARBYINTF BUILT_IN_NEARBYINTF\n+\t  BUILT_IN_RINTF BUILT_IN_RINTF)\n+ /* truncl(extend(x)) and trunc(extend(x)) -> extend(truncf(x)), etc.,\n+    if x is a float.  */\n+ (if (optimize && canonicalize_math_p ())\n+  (simplify\n+   (froms (convert float_value_p@0))\n+   (convert (tos @0)))))\n+\n /* cproj(x) -> x if we're ignoring infinities.  */\n (simplify\n  (CPROJ @0)"}, {"sha": "98ad4faabb03abefaaf63622fb96bfc4ef6ec922", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -1,3 +1,10 @@\n+2015-10-23  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.c-torture/execute/20030125-1.c (floor, floorf, sin, sinf):\n+\tMake weak rather than noinline.\n+\t* gcc.dg/builtins-57.c: Compile with -O.\n+\t* gcc.dg/torture/builtin-integral-1.c: Skip for -O0.\n+\n 2015-10-23  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.dg/tree-ssa/restrict-4.c: Add -fno-ipa-icf to dg-options."}, {"sha": "960552c3c3a5b5b4cb8f6a946262446430a6d151", "filename": "gcc/testsuite/gcc.c-torture/execute/20030125-1.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030125-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030125-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030125-1.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -1,5 +1,6 @@\n /* Verify whether math functions are simplified.  */\n /* { dg-require-effective-target c99_runtime } */\n+/* { dg-require-weak } */\n double sin(double);\n double floor(double);\n float \n@@ -29,25 +30,25 @@ main()\n #endif\n \treturn 0;\n }\n-__attribute__ ((noinline))\n+__attribute__ ((weak))\n double\n floor(double a)\n {\n \tabort ();\n }\n-__attribute__ ((noinline))\n+__attribute__ ((weak))\n float\n floorf(float a)\n {\n \treturn a;\n }\n-__attribute__ ((noinline))\n+__attribute__ ((weak))\n double\n sin(double a)\n {\n \treturn a;\n }\n-__attribute__ ((noinline))\n+__attribute__ ((weak))\n float\n sinf(float a)\n {"}, {"sha": "18d40e8f7ffca93008a08c4d3da89a2cb2b21a74", "filename": "gcc/testsuite/gcc.dg/builtins-57.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-57.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do link } */\n-/* { dg-options \"-std=c99 -ffinite-math-only\" } */\n+/* { dg-options \"-std=c99 -ffinite-math-only -O\" } */\n \n #include \"builtins-config.h\"\n "}, {"sha": "f3c3338342e84e797ebebc341ab7300f09f693cd", "filename": "gcc/testsuite/gcc.dg/torture/builtin-integral-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-integral-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67dbe5829e2f9cac9deb756762cdaf5a8829cb31/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-integral-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-integral-1.c?ref=67dbe5829e2f9cac9deb756762cdaf5a8829cb31", "patch": "@@ -10,6 +10,7 @@\n    that various math functions are marked const/pure and can be\n    folded.  */\n /* { dg-options \"-ffinite-math-only -fno-math-errno\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n \n extern int link_failure (int);\n "}]}