{"sha": "b917101e1c2a5318471e217e04f280023cd48c6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkxNzEwMWUxYzJhNTMxODQ3MWUyMTdlMDRmMjgwMDIzY2Q0OGM2YQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:20:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:20:52Z"}, "message": "a-textio.adb, [...]: Extensive changes to private part for wide character encoding\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\n\t* a-textio.adb, a-textio.ads: \n\tExtensive changes to private part for wide character encoding\n\n\t* a-witeio.ads, a-witeio.adb, a-ztexio.ads, a-ztexio.adb\n\t(Look_Ahead): Fix mishandling of encoded sequences\n\tMove declaration of Wch_Con to private part (should not be visible)\n\n\t* ali.adb (Scan_ALI): Set default encoding method to brackets instead of\n\tUTF-8. Probably this is never used, but if it is, brackets is\n\tclearly correct.\n\n\t* bindgen.adb (Get_WC_Encoding): New procedure to properly handle\n\tsetting wide character encoding for no main program case and when\n\tencoding is specified using -W?\n\tInitialize stack limit of environment task if stack limit method of\n\tstack checking is enabled.\n\t(Gen_Adainit_Ada): Use Get_WC_Encoding to output encoding method\n\t(Gen_Adainit_C): Use Get_WC_Encoding to output encoding method\n\t(Get_Main_Unit_Name): New function.\n\t(Gen_Adainit_Ada): Add call to main program for .NET when needed.\n\t(Gen_Output_File): Set Bind_Main_Program to True for .NET\n\n\t* bindusg.adb: Add line for -Wx switch\n\n\t* s-wchcon.adb, s-wchcon.ads: (Is_Start_Of_Encoding): New function\n\tAdd comments\n\tAdd new useful constant WC_Longest_Sequences\n\n\t* switch-b.adb: Clean up handling of -Wx switch\n\tFor -gnatWx, set Wide_Character_Encoding_Method_Specified\n\n\t* switch-c.adb: -gnatg activates warning on assertion errors\n\tFor -gnatWx, set Wide_Character_Encoding_Method_Specified\n\n\t* s-wchcon.adb: (Is_Start_Of_Encoding): New function\n\nFrom-SVN: r130817", "tree": {"sha": "1c8e06d9a692908c2062d3287c702c32b03ea3e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c8e06d9a692908c2062d3287c702c32b03ea3e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b917101e1c2a5318471e217e04f280023cd48c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b917101e1c2a5318471e217e04f280023cd48c6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b917101e1c2a5318471e217e04f280023cd48c6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b917101e1c2a5318471e217e04f280023cd48c6a/comments", "author": null, "committer": null, "parents": [{"sha": "a6e8413cd79b5c1775640ed5916eefdcee06af9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6e8413cd79b5c1775640ed5916eefdcee06af9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6e8413cd79b5c1775640ed5916eefdcee06af9d"}], "stats": {"total": 903, "additions": 740, "deletions": 163}, "files": [{"sha": "3711ab05b380578c0086c49207385e7b3b1e0bdd", "filename": "gcc/ada/a-textio.adb", "status": "modified", "additions": 372, "deletions": 43, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -36,6 +36,8 @@ with Interfaces.C_Streams; use Interfaces.C_Streams;\n \n with System.File_IO;\n with System.CRTL;\n+with System.WCh_Cnv;       use System.WCh_Cnv;\n+with System.WCh_Con;       use System.WCh_Con;\n \n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n@@ -55,6 +57,45 @@ package body Ada.Text_IO is\n \n    use type System.CRTL.size_t;\n \n+   WC_Encoding : Character;\n+   pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Getc_Immed (File : File_Type) return int;\n+   --  This routine is identical to Getc, except that the read is done in\n+   --  Get_Immediate mode (i.e. without waiting for a line return).\n+\n+   function Get_Upper_Half_Char\n+     (C    : Character;\n+      File : File_Type) return Character;\n+   --  This function is shared by Get and Get_Immediate to extract an encoded\n+   --  upper half character value from the given File. The first byte has\n+   --  already been read and is passed in C. The character value is returned as\n+   --  the result, and the file pointer is bumped past the character.\n+   --  Constraint_Error is raised if the encoded value is outside the bounds of\n+   --  type Character.\n+\n+   function Get_Upper_Half_Char_Immed\n+     (C    : Character;\n+      File : File_Type) return Character;\n+   --  This routine is identical to Get_Upper_Half_Char, except that the reads\n+   --  are done in Get_Immediate mode (i.e. without waiting for a line return).\n+\n+   function Has_Upper_Half_Character (Item : String) return Boolean;\n+   --  Returns True if any of the characters is in the range 16#80#-16#FF#\n+\n+   procedure Put_Encoded (File : File_Type; Char : Character);\n+   --  Called to output a character Char to the given File, when the encoding\n+   --  method for the file is other than brackets, and Char is upper half.\n+\n+   procedure Set_WCEM (File : in out File_Type);\n+   --  Called by Open and Create to set the wide character encoding method for\n+   --  the file, processing a WCEM form parameter if one is present. File is\n+   --  IN OUT because it may be closed in case of an error.\n+\n    -------------------\n    -- AFCB_Allocate --\n    -------------------\n@@ -155,6 +196,7 @@ package body Ada.Text_IO is\n                 Text      => True);\n \n       File.Self := File;\n+      Set_WCEM (File);\n    end Create;\n \n    -------------------\n@@ -218,8 +260,10 @@ package body Ada.Text_IO is\n    begin\n       FIO.Check_Read_Status (AP (File));\n \n-      if File.Before_LM then\n+      if File.Before_Upper_Half_Character then\n+         return False;\n \n+      elsif File.Before_LM then\n          if File.Before_LM_PM then\n             return Nextc (File) = EOF;\n          end if;\n@@ -276,7 +320,10 @@ package body Ada.Text_IO is\n    begin\n       FIO.Check_Read_Status (AP (File));\n \n-      if File.Before_LM then\n+      if File.Before_Upper_Half_Character then\n+         return False;\n+\n+      elsif File.Before_LM then\n          return True;\n \n       else\n@@ -310,6 +357,9 @@ package body Ada.Text_IO is\n       if not File.Is_Regular_File then\n          return False;\n \n+      elsif File.Before_Upper_Half_Character then\n+         return False;\n+\n       elsif File.Before_LM then\n          if File.Before_LM_PM then\n             return True;\n@@ -389,7 +439,11 @@ package body Ada.Text_IO is\n    begin\n       FIO.Check_Read_Status (AP (File));\n \n-      if File.Before_LM then\n+      if File.Before_Upper_Half_Character then\n+         File.Before_Upper_Half_Character := False;\n+         Item := File.Saved_Upper_Half_Character;\n+\n+      elsif File.Before_LM then\n          File.Before_LM := False;\n          File.Col := 1;\n \n@@ -486,40 +540,39 @@ package body Ada.Text_IO is\n    -- Get_Immediate --\n    -------------------\n \n-   --  More work required here ???\n-\n    procedure Get_Immediate\n      (File : File_Type;\n       Item : out Character)\n    is\n       ch          : int;\n-      end_of_file : int;\n-\n-      procedure getc_immediate\n-        (stream      : FILEs;\n-         ch          : out int;\n-         end_of_file : out int);\n-      pragma Import (C, getc_immediate, \"getc_immediate\");\n \n    begin\n       FIO.Check_Read_Status (AP (File));\n \n-      if File.Before_LM then\n+      if File.Before_Upper_Half_Character then\n+         File.Before_Upper_Half_Character := False;\n+         Item := File.Saved_Upper_Half_Character;\n+\n+      elsif File.Before_LM then\n          File.Before_LM := False;\n          File.Before_LM_PM := False;\n-         ch := LM;\n+         Item := Character'Val (LM);\n \n       else\n-         getc_immediate (File.Stream, ch, end_of_file);\n+         ch := Getc_Immed (File);\n \n-         if ferror (File.Stream) /= 0 then\n-            raise Device_Error;\n-         elsif end_of_file /= 0 then\n+         if ch = EOF then\n             raise End_Error;\n+         else\n+            if not Is_Start_Of_Encoding\n+                     (Character'Val (ch), File.WC_Method)\n+            then\n+               Item := Character'Val (ch);\n+            else\n+               Item := Get_Upper_Half_Char_Immed (Character'Val (ch), File);\n+            end if;\n          end if;\n       end if;\n-\n-      Item := Character'Val (ch);\n    end Get_Immediate;\n \n    procedure Get_Immediate\n@@ -547,19 +600,17 @@ package body Ada.Text_IO is\n \n    begin\n       FIO.Check_Read_Status (AP (File));\n+      Available := True;\n \n-      --  If we are logically before an end of line, but physically after it,\n-      --  then we just return the end of line character, no I/O is necessary.\n+      if File.Before_Upper_Half_Character then\n+         File.Before_Upper_Half_Character := False;\n+         Item := File.Saved_Upper_Half_Character;\n \n-      if File.Before_LM then\n+      elsif File.Before_LM then\n          File.Before_LM := False;\n          File.Before_LM_PM := False;\n-\n-         Available := True;\n          Item := Character'Val (LM);\n \n-      --  Normal case where a read operation is required\n-\n       else\n          getc_immediate_nowait (File.Stream, ch, end_of_file, avail);\n \n@@ -575,7 +626,14 @@ package body Ada.Text_IO is\n \n          else\n             Available := True;\n-            Item := Character'Val (ch);\n+\n+            if Is_Start_Of_Encoding\n+              (Character'Val (ch), File.WC_Method)\n+            then\n+               Item := Character'Val (ch);\n+            else\n+               Item := Get_Upper_Half_Char_Immed (Character'Val (ch), File);\n+            end if;\n          end if;\n       end if;\n \n@@ -764,6 +822,92 @@ package body Ada.Text_IO is\n       return Get_Line (Current_In);\n    end Get_Line;\n \n+   -------------------------\n+   -- Get_Upper_Half_Char --\n+   -------------------------\n+\n+   function Get_Upper_Half_Char\n+     (C    : Character;\n+      File : File_Type) return Character\n+   is\n+      Result : Wide_Character;\n+\n+      function In_Char return Character;\n+      --  Function used to obtain additional characters it the wide character\n+      --  sequence is more than one character long.\n+\n+      function WC_In is new Char_Sequence_To_Wide_Char (In_Char);\n+\n+      -------------\n+      -- In_Char --\n+      -------------\n+\n+      function In_Char return Character is\n+         ch : constant Integer := Getc (File);\n+      begin\n+         if ch = EOF then\n+            raise End_Error;\n+         else\n+            return Character'Val (ch);\n+         end if;\n+      end In_Char;\n+\n+   --  Start of processing for Get_Upper_Half_Char\n+\n+   begin\n+      Result := WC_In (C, File.WC_Method);\n+\n+      if Wide_Character'Pos (Result) > 16#FF# then\n+         raise Constraint_Error\n+           with \"invalid wide character in Text_'I'O input\";\n+      else\n+         return Character'Val (Wide_Character'Pos (Result));\n+      end if;\n+   end Get_Upper_Half_Char;\n+\n+   -------------------------------\n+   -- Get_Upper_Half_Char_Immed --\n+   -------------------------------\n+\n+   function Get_Upper_Half_Char_Immed\n+     (C    : Character;\n+      File : File_Type) return Character\n+   is\n+      Result : Wide_Character;\n+\n+      function In_Char return Character;\n+      --  Function used to obtain additional characters it the wide character\n+      --  sequence is more than one character long.\n+\n+      function WC_In is new Char_Sequence_To_Wide_Char (In_Char);\n+\n+      -------------\n+      -- In_Char --\n+      -------------\n+\n+      function In_Char return Character is\n+         ch : constant Integer := Getc_Immed (File);\n+      begin\n+         if ch = EOF then\n+            raise End_Error;\n+         else\n+            return Character'Val (ch);\n+         end if;\n+      end In_Char;\n+\n+   --  Start of processing for Get_Upper_Half_Char_Immed\n+\n+   begin\n+      Result := WC_In (C, File.WC_Method);\n+\n+      if Wide_Character'Pos (Result) > 16#FF# then\n+         raise Constraint_Error\n+           with \"invalid wide character in Text_'I'O input\";\n+      else\n+         return Character'Val (Wide_Character'Pos (Result));\n+      end if;\n+   end Get_Upper_Half_Char_Immed;\n+\n    ----------\n    -- Getc --\n    ----------\n@@ -781,6 +925,54 @@ package body Ada.Text_IO is\n       end if;\n    end Getc;\n \n+   ----------------\n+   -- Getc_Immed --\n+   ----------------\n+\n+   function Getc_Immed (File : File_Type) return int is\n+      ch          : int;\n+      end_of_file : int;\n+\n+      procedure getc_immediate\n+        (stream : FILEs; ch : out int; end_of_file : out int);\n+      pragma Import (C, getc_immediate, \"getc_immediate\");\n+\n+   begin\n+      FIO.Check_Read_Status (AP (File));\n+\n+      if File.Before_LM then\n+         File.Before_LM := False;\n+         File.Before_LM_PM := False;\n+         ch := LM;\n+\n+      else\n+         getc_immediate (File.Stream, ch, end_of_file);\n+\n+         if ferror (File.Stream) /= 0 then\n+            raise Device_Error;\n+         elsif end_of_file /= 0 then\n+            return EOF;\n+         end if;\n+      end if;\n+\n+      return ch;\n+   end Getc_Immed;\n+\n+   ------------------------------\n+   -- Has_Upper_Half_Character --\n+   ------------------------------\n+\n+   function Has_Upper_Half_Character (Item : String) return Boolean is\n+   begin\n+      for J in Item'Range loop\n+         if Character'Pos (Item (J)) >= 16#80# then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Has_Upper_Half_Character;\n+\n    -------------\n    -- Is_Open --\n    -------------\n@@ -838,22 +1030,54 @@ package body Ada.Text_IO is\n    begin\n       FIO.Check_Read_Status (AP (File));\n \n+      --  If we are logically before a line mark, we can return immediately\n+\n       if File.Before_LM then\n          End_Of_Line := True;\n          Item := ASCII.NUL;\n \n+      --  If we are before an upper half character just return it (this can\n+      --  happen if there are two calls to Look_Ahead in a row.\n+\n+      elsif File.Before_Upper_Half_Character then\n+         End_Of_Line := False;\n+         Item := File.Saved_Upper_Half_Character;\n+\n+      --  Otherwise we must read a character from the input stream\n+\n       else\n-         ch := Nextc (File);\n+         ch := Getc (File);\n \n          if ch = LM\n            or else ch = EOF\n            or else (ch = PM and then File.Is_Regular_File)\n          then\n             End_Of_Line := True;\n+            Ungetc (ch, File);\n             Item := ASCII.NUL;\n-         else\n+\n+         --  Case where character obtained does not represent the start of an\n+         --  encoded sequence so it stands for itself and we can unget it with\n+         --  no difficulty.\n+\n+         elsif not Is_Start_Of_Encoding\n+                     (Character'Val (ch), File.WC_Method)\n+         then\n             End_Of_Line := False;\n+            Ungetc (ch, File);\n             Item := Character'Val (ch);\n+\n+         --  For the start of an encoding, we read the character using the\n+         --  Get_Upper_Half_Char routine. It will occupy more than one byte\n+         --  so we can't put it back with ungetc. Instead we save it in the\n+         --  control block, setting a flag that everyone interested in reading\n+         --  characters must test before reading the stream.\n+\n+         else\n+            Item := Get_Upper_Half_Char (Character'Val (ch), File);\n+            End_Of_Line := False;\n+            File.Saved_Upper_Half_Character := Item;\n+            File.Before_Upper_Half_Character := True;\n          end if;\n       end if;\n    end Look_Ahead;\n@@ -997,6 +1221,7 @@ package body Ada.Text_IO is\n                 Text      => True);\n \n       File.Self := File;\n+      Set_WCEM (File);\n    end Open;\n \n    ----------\n@@ -1048,8 +1273,19 @@ package body Ada.Text_IO is\n          New_Line (File);\n       end if;\n \n-      if fputc (Character'Pos (Item), File.Stream) = EOF then\n-         raise Device_Error;\n+      --  If lower half character, or brackets encoding, output directly\n+\n+      if Character'Pos (Item) < 16#80#\n+        or else File.WC_Method = WCEM_Brackets\n+      then\n+         if fputc (Character'Pos (Item), File.Stream) = EOF then\n+            raise Device_Error;\n+         end if;\n+\n+      --  Case of upper half character with non-brackets encoding\n+\n+      else\n+         Put_Encoded (File, Item);\n       end if;\n \n       File.Col := File.Col + 1;\n@@ -1065,8 +1301,19 @@ package body Ada.Text_IO is\n          New_Line (Current_Out);\n       end if;\n \n-      if fputc (Character'Pos (Item), Current_Out.Stream) = EOF then\n-         raise Device_Error;\n+      --  If lower half character, or brackets encoding, output directly\n+\n+      if Character'Pos (Item) < 16#80#\n+        or else Default_WCEM = WCEM_Brackets\n+      then\n+         if fputc (Character'Pos (Item), Current_Out.Stream) = EOF then\n+            raise Device_Error;\n+         end if;\n+\n+      --  Case of upper half character with non-brackets encoding\n+\n+      else\n+         Put_Encoded (Current_Out, Item);\n       end if;\n \n       Current_Out.Col := Current_Out.Col + 1;\n@@ -1083,12 +1330,18 @@ package body Ada.Text_IO is\n    begin\n       FIO.Check_Write_Status (AP (File));\n \n+      --  Only have something to do if string is non-null\n+\n       if Item'Length > 0 then\n \n-         --  If we have bounded lines, then do things character by\n-         --  character (this seems a rare case anyway!)\n+         --  If we have bounded lines, or if the file encoding is other than\n+         --  Brackets and the string has at least one upper half character,\n+         --  then output the string character by character.\n \n-         if File.Line_Length /= 0 then\n+         if File.Line_Length /= 0\n+           or else (File.WC_Method /= WCEM_Brackets\n+                      and then Has_Upper_Half_Character (Item))\n+         then\n             for J in Item'Range loop\n                Put (File, Item (J));\n             end loop;\n@@ -1109,6 +1362,31 @@ package body Ada.Text_IO is\n       Put (Current_Out, Item);\n    end Put;\n \n+   -----------------\n+   -- Put_Encoded --\n+   -----------------\n+\n+   procedure Put_Encoded (File : File_Type; Char : Character) is\n+      procedure Out_Char (C : Character);\n+      --  Procedure to output one character of an upper half encoded sequence\n+\n+      procedure WC_Out is new Wide_Char_To_Char_Sequence (Out_Char);\n+\n+      --------------\n+      -- Out_Char --\n+      --------------\n+\n+      procedure Out_Char (C : Character) is\n+      begin\n+         Putc (Character'Pos (C), File);\n+      end Out_Char;\n+\n+   --  Start of processing for Put_Encoded\n+\n+   begin\n+      WC_Out (Wide_Character'Val (Character'Pos (Char)), File.WC_Method);\n+   end Put_Encoded;\n+\n    --------------\n    -- Put_Line --\n    --------------\n@@ -1123,16 +1401,24 @@ package body Ada.Text_IO is\n    begin\n       FIO.Check_Write_Status (AP (File));\n \n-      --  If we have bounded lines, then just do a put and a new line. In\n-      --  this case we will end up doing things character by character in\n-      --  any case, and it is a rare situation.\n+      --  If we have bounded lines, or if the file encoding is other than\n+      --  Brackets and the string has at least one upper half character, then\n+      --  output the string character by character.\n+\n+      if File.Line_Length /= 0\n+        or else (File.WC_Method /= WCEM_Brackets\n+                   and then Has_Upper_Half_Character (Item))\n+      then\n+         for J in Item'Range loop\n+            Put (File, Item (J));\n+         end loop;\n \n-      if File.Line_Length /= 0 then\n-         Put (File, Item);\n          New_Line (File);\n          return;\n       end if;\n \n+      --  Normal case where we do not need to output character by character\n+\n       --  We setup a single string that has the necessary terminators and\n       --  then write it with a single call. The reason for doing this is\n       --  that it gives better behavior for the use of Put_Line in multi-\n@@ -1211,6 +1497,8 @@ package body Ada.Text_IO is\n       pragma Warnings (Off, Discard_ch);\n \n    begin\n+      --  Need to deal with Before_Upper_Half_Character ???\n+\n       if File.Mode /= FCB.In_File then\n          raise Mode_Error;\n       end if;\n@@ -1553,6 +1841,36 @@ package body Ada.Text_IO is\n       Set_Page_Length (Current_Out, To);\n    end Set_Page_Length;\n \n+   --------------\n+   -- Set_WCEM --\n+   --------------\n+\n+   procedure Set_WCEM (File : in out File_Type) is\n+      Start : Natural;\n+      Stop  : Natural;\n+\n+   begin\n+      File.WC_Method := WCEM_Brackets;\n+      FIO.Form_Parameter (File.Form.all, \"wcem\", Start, Stop);\n+\n+      if Start = 0 then\n+         File.WC_Method := WCEM_Brackets;\n+\n+      elsif Start /= 0 then\n+         if Stop = Start then\n+            for J in WC_Encoding_Letters'Range loop\n+               if File.Form (Start) = WC_Encoding_Letters (J) then\n+                  File.WC_Method := J;\n+                  return;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         Close (File);\n+         raise Use_Error with \"invalid WCEM form parameter\";\n+      end if;\n+   end Set_WCEM;\n+\n    ---------------\n    -- Skip_Line --\n    ---------------\n@@ -1640,8 +1958,9 @@ package body Ada.Text_IO is\n                Ungetc (ch, File);\n             end if;\n          end if;\n-\n       end loop;\n+\n+      File.Before_Upper_Half_Character := False;\n    end Skip_Line;\n \n    procedure Skip_Line (Spacing : Positive_Count := 1) is\n@@ -1702,6 +2021,7 @@ package body Ada.Text_IO is\n       File.Page := File.Page + 1;\n       File.Line := 1;\n       File.Col  := 1;\n+      File.Before_Upper_Half_Character := False;\n    end Skip_Page;\n \n    procedure Skip_Page is\n@@ -1901,6 +2221,12 @@ begin\n    -- Initialize Standard Files --\n    -------------------------------\n \n+   for J in WC_Encoding_Method loop\n+      if WC_Encoding = WC_Encoding_Letters (J) then\n+         Default_WCEM := J;\n+      end if;\n+   end loop;\n+\n    --  Note: the names in these files are bogus, and probably it would be\n    --  better for these files to have no names, but the ACVC test insist!\n    --  We use names that are bound to fail in open etc.\n@@ -1915,6 +2241,7 @@ begin\n    Standard_Err.Is_Text_File      := True;\n    Standard_Err.Access_Method     := 'T';\n    Standard_Err.Self              := Standard_Err;\n+   Standard_Err.WC_Method         := Default_WCEM;\n \n    Standard_In.Stream             := stdin;\n    Standard_In.Name               := In_Name'Access;\n@@ -1926,6 +2253,7 @@ begin\n    Standard_In.Is_Text_File       := True;\n    Standard_In.Access_Method      := 'T';\n    Standard_In.Self               := Standard_In;\n+   Standard_In.WC_Method         := Default_WCEM;\n \n    Standard_Out.Stream            := stdout;\n    Standard_Out.Name              := Out_Name'Access;\n@@ -1937,6 +2265,7 @@ begin\n    Standard_Out.Is_Text_File      := True;\n    Standard_Out.Access_Method     := 'T';\n    Standard_Out.Self              := Standard_Out;\n+   Standard_Out.WC_Method         := Default_WCEM;\n \n    FIO.Chain_File (AP (Standard_In));\n    FIO.Chain_File (AP (Standard_Out));"}, {"sha": "8e3926479d5ae5eb1d46121ffc98fb2e9a439193", "filename": "gcc/ada/a-textio.ads", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-textio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-textio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.ads?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -45,6 +45,7 @@ with Ada.IO_Exceptions;\n with Ada.Streams;\n with System;\n with System.File_Control_Block;\n+with System.WCh_Con;\n \n package Ada.Text_IO is\n    pragma Elaborate_Body;\n@@ -334,6 +335,11 @@ private\n    -- Text_IO File Control Block --\n    --------------------------------\n \n+   Default_WCEM : System.WCh_Con.WC_Encoding_Method :=\n+                    System.WCh_Con.WCEM_UTF8;\n+   --  This gets modified during initialization (see body) using\n+   --  the default value established in the call to Set_Globals.\n+\n    package FCB renames System.File_Control_Block;\n \n    type Text_AFCB;\n@@ -366,6 +372,31 @@ private\n       --  after a LM-PM sequence when logically we are before the LM-PM. This\n       --  flag can only be set if Before_LM is also set.\n \n+      WC_Method : System.WCh_Con.WC_Encoding_Method := Default_WCEM;\n+      --  Encoding method to be used for this file. Text_IO does not deal with\n+      --  wide characters, but it does deal with upper half characters in the\n+      --  range 16#80#-16#FF# which may need encoding, e.g. in UTF-8 mode.\n+\n+      Before_Upper_Half_Character : Boolean := False;\n+      --  This flag is set to indicate that an encoded upper half character has\n+      --  been read by Text_IO.Look_Ahead. If it is set to True, then it means\n+      --  that the stream is logically positioned before the character but is\n+      --  physically positioned after it. The character involved must be in\n+      --  the range 16#80#-16#FF#, i.e. if the flag is set, then we know the\n+      --  next character has a code greater than 16#7F#, and the value of this\n+      --  character is saved in Saved_Upper_Half_Character.\n+\n+      Saved_Upper_Half_Character : Character;\n+      --  This field is valid only if Before_Upper_Half_Character is set. It\n+      --  contains an upper-half character read by Look_Ahead. If Look_Ahead\n+      --  reads a character in the range 16#00# to 16#7F#, then it can use\n+      --  ungetc to put it back, but ungetc cannot be called more than once,\n+      --  so for characters above this range, we don't try to back up the\n+      --  file. Instead we save the character in this field and set the flag\n+      --  Before_Upper_Half_Character to True to indicate that we are logically\n+      --  positioned before this character even though the stream is physically\n+      --  positioned after it.\n+\n    end record;\n \n    function AFCB_Allocate (Control_Block : Text_AFCB) return FCB.AFCB_Ptr;"}, {"sha": "64e1988e83f9c4596535ee59ea1481b2f49c4faf", "filename": "gcc/ada/a-witeio.adb", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-witeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-witeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -31,7 +31,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Exceptions;       use Ada.Exceptions;\n with Ada.Streams;          use Ada.Streams;\n with Interfaces.C_Streams; use Interfaces.C_Streams;\n \n@@ -76,9 +75,9 @@ package body Ada.Wide_Text_IO is\n    --  done in Get_Immediate mode (i.e. without waiting for a line return).\n \n    procedure Set_WCEM (File : in out File_Type);\n-   --  Called by Open and Create to set the wide character encoding method\n-   --  for the file, processing a WCEM form parameter if one is present.\n-   --  File is IN OUT because it may be closed in case of an error.\n+   --  Called by Open and Create to set the wide character encoding method for\n+   --  the file, processing a WCEM form parameter if one is present. File is\n+   --  IN OUT because it may be closed in case of an error.\n \n    -------------------\n    -- AFCB_Allocate --\n@@ -249,7 +248,6 @@ package body Ada.Wide_Text_IO is\n          return False;\n \n       elsif File.Before_LM then\n-\n          if File.Before_LM_PM then\n             return Nextc (File) = EOF;\n          end if;\n@@ -420,6 +418,8 @@ package body Ada.Wide_Text_IO is\n          File.Before_Wide_Character := False;\n          Item := File.Saved_Wide_Character;\n \n+      --  Ada.Text_IO checks Before_LM_PM here, shouldn't we do the same???\n+\n       else\n          Get_Character (File, C);\n          Item := Get_Wide_Char (C, File);\n@@ -555,6 +555,8 @@ package body Ada.Wide_Text_IO is\n          Item := Wide_Character'Val (LM);\n \n       else\n+         --  Shouldn't we use getc_immediate_nowait here, like Text_IO???\n+\n          ch := Getc_Immed (File);\n \n          if ch = EOF then\n@@ -749,7 +751,7 @@ package body Ada.Wide_Text_IO is\n          end if;\n       end In_Char;\n \n-   --  Start of processing for In_Char\n+   --  Start of processing for Get_Wide_Char\n \n    begin\n       return WC_In (C, File.WC_Method);\n@@ -904,7 +906,7 @@ package body Ada.Wide_Text_IO is\n          End_Of_Line := True;\n          Item := Wide_Character'Val (0);\n \n-      --  If we are before a wide character, just return it (this happens\n+      --  If we are before a wide character, just return it (this can happen\n       --  if there are two calls to Look_Ahead in a row).\n \n       elsif File.Before_Wide_Character then\n@@ -924,19 +926,21 @@ package body Ada.Wide_Text_IO is\n             Ungetc (ch, File);\n             Item := Wide_Character'Val (0);\n \n-         --  If the character is in the range 16#0000# to 16#007F# it stands\n-         --  for itself and occupies a single byte, so we can unget it with\n+         --  Case where character obtained does not represent the start of an\n+         --  encoded sequence so it stands for itself and we can unget it with\n          --  no difficulty.\n \n-         elsif ch <= 16#0080# then\n+         elsif not Is_Start_Of_Encoding\n+                     (Character'Val (ch), File.WC_Method)\n+         then\n             End_Of_Line := False;\n             Ungetc (ch, File);\n             Item := Wide_Character'Val (ch);\n \n-         --  For a character above this range, we read the character, using\n-         --  the Get_Wide_Char routine. It may well occupy more than one byte\n-         --  so we can't put it back with ungetc. Instead we save it in the\n-         --  control block, setting a flag that everyone interested in reading\n+         --  For the start of an encoding, we read the character using the\n+         --  Get_Wide_Char routine. It will occupy more than one byte so we\n+         --  can't put it back with ungetc. Instead we save it in the control\n+         --  block, setting a flag that everyone interested in reading\n          --  characters must test before reading the stream.\n \n          else\n@@ -1552,7 +1556,7 @@ package body Ada.Wide_Text_IO is\n          end if;\n \n          Close (File);\n-         Raise_Exception (Use_Error'Identity, \"invalid WCEM form parameter\");\n+         raise Use_Error with \"invalid WCEM form parameter\";\n       end if;\n    end Set_WCEM;\n \n@@ -1638,7 +1642,6 @@ package body Ada.Wide_Text_IO is\n                Ungetc (ch, File);\n             end if;\n          end if;\n-\n       end loop;\n \n       File.Before_Wide_Character := False;"}, {"sha": "3d676a9acd69379dc46f3adbc9268d07d6ceed6b", "filename": "gcc/ada/a-witeio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-witeio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-witeio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.ads?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -50,8 +50,6 @@ with System.WCh_Con;\n \n package Ada.Wide_Text_IO is\n \n-   package WCh_Con renames System.WCh_Con;\n-\n    type File_Type is limited private;\n    type File_Mode is (In_File, Out_File, Append_File);\n \n@@ -303,6 +301,8 @@ package Ada.Wide_Text_IO is\n    Layout_Error : exception renames IO_Exceptions.Layout_Error;\n \n private\n+   package WCh_Con renames System.WCh_Con;\n+\n    -----------------------------------\n    -- Handling of Format Characters --\n    -----------------------------------"}, {"sha": "74a60f92093d33691e9486fb86a7b418dbea7780", "filename": "gcc/ada/a-ztexio.adb", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-ztexio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-ztexio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -31,7 +31,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Exceptions;       use Ada.Exceptions;\n with Ada.Streams;          use Ada.Streams;\n with Interfaces.C_Streams; use Interfaces.C_Streams;\n \n@@ -76,9 +75,9 @@ package body Ada.Wide_Wide_Text_IO is\n    --  are done in Get_Immediate mode (i.e. without waiting for a line return).\n \n    procedure Set_WCEM (File : in out File_Type);\n-   --  Called by Open and Create to set the wide character encoding method\n-   --  for the file, processing a WCEM form parameter if one is present.\n-   --  File is IN OUT because it may be closed in case of an error.\n+   --  Called by Open and Create to set the wide character encoding method for\n+   --  the file, processing a WCEM form parameter if one is present. File is\n+   --  IN OUT because it may be closed in case of an error.\n \n    -------------------\n    -- AFCB_Allocate --\n@@ -249,7 +248,6 @@ package body Ada.Wide_Wide_Text_IO is\n          return False;\n \n       elsif File.Before_LM then\n-\n          if File.Before_LM_PM then\n             return Nextc (File) = EOF;\n          end if;\n@@ -420,6 +418,8 @@ package body Ada.Wide_Wide_Text_IO is\n          File.Before_Wide_Wide_Character := False;\n          Item := File.Saved_Wide_Wide_Character;\n \n+      --  Ada.Text_IO checks Before_LM_PM here, shouldn't we do the same???\n+\n       else\n          Get_Character (File, C);\n          Item := Get_Wide_Wide_Char (C, File);\n@@ -555,6 +555,8 @@ package body Ada.Wide_Wide_Text_IO is\n          Item := Wide_Wide_Character'Val (LM);\n \n       else\n+         --  Shouldn't we use getc_immediate_nowait here, like Text_IO???\n+\n          ch := Getc_Immed (File);\n \n          if ch = EOF then\n@@ -904,7 +906,7 @@ package body Ada.Wide_Wide_Text_IO is\n          End_Of_Line := True;\n          Item := Wide_Wide_Character'Val (0);\n \n-      --  If we are before a wide character, just return it (this happens\n+      --  If we are before a wide character, just return it (this can happen\n       --  if there are two calls to Look_Ahead in a row).\n \n       elsif File.Before_Wide_Wide_Character then\n@@ -924,20 +926,22 @@ package body Ada.Wide_Wide_Text_IO is\n             Ungetc (ch, File);\n             Item := Wide_Wide_Character'Val (0);\n \n-         --  If the character is in the range 16#0000# to 16#007F# it stands\n-         --  for itself and occupies a single byte, so we can unget it with\n+         --  Case where character obtained does not represent the start of an\n+         --  encoded sequence so it stands for itself and we can unget it with\n          --  no difficulty.\n \n-         elsif ch <= 16#0080# then\n+         elsif not Is_Start_Of_Encoding\n+                     (Character'Val (ch), File.WC_Method)\n+         then\n             End_Of_Line := False;\n             Ungetc (ch, File);\n             Item := Wide_Wide_Character'Val (ch);\n \n-         --  For a character above this range, we read the character, using\n-         --  the Get_Wide_Wide_Char routine. It may well occupy more than one\n-         --  byte so we can't put it back with ungetc. Instead we save it in\n-         --  the control block, setting a flag that everyone interested in\n-         --  reading characters must test before reading the stream.\n+         --  For the start of an encoding, we read the character using the\n+         --  Get_Wide_Wide_Char routine. It will occupy more than one byte so\n+         --  we can't put it back with ungetc. Instead we save it in the\n+         --  control block, setting a flag that everyone interested in reading\n+         --  characters must test before reading the stream.\n \n          else\n             Item := Get_Wide_Wide_Char (Character'Val (ch), File);\n@@ -1552,7 +1556,7 @@ package body Ada.Wide_Wide_Text_IO is\n          end if;\n \n          Close (File);\n-         Raise_Exception (Use_Error'Identity, \"invalid WCEM form parameter\");\n+         raise Use_Error with \"invalid WCEM form parameter\";\n       end if;\n    end Set_WCEM;\n \n@@ -1638,7 +1642,6 @@ package body Ada.Wide_Wide_Text_IO is\n                Ungetc (ch, File);\n             end if;\n          end if;\n-\n       end loop;\n \n       File.Before_Wide_Wide_Character := False;"}, {"sha": "3010e5172030b116cb3f22850c3114d35ff00c86", "filename": "gcc/ada/a-ztexio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-ztexio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fa-ztexio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztexio.ads?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -50,8 +50,6 @@ with System.WCh_Con;\n \n package Ada.Wide_Wide_Text_IO is\n \n-   package WCh_Con renames System.WCh_Con;\n-\n    type File_Type is limited private;\n    type File_Mode is (In_File, Out_File, Append_File);\n \n@@ -303,6 +301,8 @@ package Ada.Wide_Wide_Text_IO is\n    Layout_Error : exception renames IO_Exceptions.Layout_Error;\n \n private\n+   package WCh_Con renames System.WCh_Con;\n+\n    -----------------------------------\n    -- Handling of Format Characters --\n    -----------------------------------"}, {"sha": "8466ddd91d83e35ff2ebbcf567afe4f0d0254f16", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -824,7 +824,7 @@ package body ALI is\n         Sfile                      => No_File,\n         Task_Dispatching_Policy    => ' ',\n         Time_Slice_Value           => -1,\n-        WC_Encoding                => '8',\n+        WC_Encoding                => 'b',\n         Unit_Exception_Table       => False,\n         Ver                        => (others => ' '),\n         Ver_Len                    => 0,\n@@ -930,13 +930,23 @@ package body ALI is\n \n          else\n             Checkc (' ');\n-            Name_Len := 0;\n \n+            --  Scan out argument\n+\n+            Name_Len := 0;\n             while not At_Eol loop\n                Name_Len := Name_Len + 1;\n                Name_Buffer (Name_Len) := Getc;\n             end loop;\n \n+            --  If -fstack-check, record that it occurred\n+\n+            if Name_Buffer (1 .. Name_Len) = \"-fstack-check\" then\n+               Stack_Check_Switch_Set := True;\n+            end if;\n+\n+            --  Store the argument\n+\n             Args.Increment_Last;\n             Args.Table (Args.Last) := new String'(Name_Buffer (1 .. Name_Len));\n "}, {"sha": "d344959eea12fa8543894c8bedd973ddab1898e7", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 197, "deletions": 56, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -39,7 +39,8 @@ with Table;    use Table;\n with Targparm; use Targparm;\n with Types;    use Types;\n \n-with System.OS_Lib;    use System.OS_Lib;\n+with System.OS_Lib;  use System.OS_Lib;\n+with System.WCh_Con; use System.WCh_Con;\n \n with GNAT.Heap_Sort_A; use GNAT.Heap_Sort_A;\n \n@@ -286,13 +287,22 @@ package body Bindgen is\n    --  This function tries Ada_Main first, and if there is such a clash, then\n    --  it tries Ada_Name_01, Ada_Name_02 ... Ada_Name_99 in sequence.\n \n+   function Get_Main_Unit_Name (S : String) return String;\n+   --  Return the main unit name corresponding to S by replacing '.' with '_'\n+\n    function Get_Main_Name return String;\n    --  This function is used in the Ada main output case to compute the\n    --  correct external main program. It is \"main\" by default, unless the\n    --  flag Use_Ada_Main_Program_Name_On_Target is set, in which case it\n    --  is the name of the Ada main name without the \"_ada\". This default\n    --  can be overridden explicitly using the -Mname binder switch.\n \n+   function Get_WC_Encoding return Character;\n+   --  Return wide character encoding method to set as WC_Encoding in output.\n+   --  If -W has been used, returns the specified encoding, otherwise returns\n+   --  the encoding method used for the main program source. If there is no\n+   --  main program source (-z switch used), returns brackets ('b').\n+\n    function Lt_Linker_Option (Op1, Op2 : Natural) return Boolean;\n    --  Compare linker options, when sorting, first according to\n    --  Is_Internal_File (internal files come later) and then by\n@@ -595,6 +605,40 @@ package body Bindgen is\n          WBI (\"      Handler_Installed : Integer;\");\n          WBI (\"      pragma Import (C, Handler_Installed, \" &\n               \"\"\"__gnat_handler_installed\"\");\");\n+\n+         --  Initialize stack limit variable of the environment task if the\n+         --  stack check method is stack limit and if stack check is enabled.\n+\n+         if Stack_Check_Limits_On_Target\n+           and then (Stack_Check_Default_On_Target or Stack_Check_Switch_Set)\n+         then\n+            WBI (\"\");\n+            WBI (\"      procedure Initialize_Stack_Limit;\");\n+            WBI (\"      pragma Import (C, Initialize_Stack_Limit, \" &\n+                 \"\"\"__gnat_initialize_stack_limit\"\");\");\n+         end if;\n+\n+         if VM_Target = CLI_Target\n+           and then not No_Main_Subprogram\n+         then\n+            WBI (\"\");\n+\n+            if ALIs.Table (ALIs.First).Main_Program = Func then\n+               WBI (\"      Result : Integer;\");\n+               WBI (\"\");\n+               WBI (\"      function Ada_Main_Program return Integer;\");\n+\n+            else\n+               WBI (\"      procedure Ada_Main_Program;\");\n+            end if;\n+\n+            Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+            Name_Len := Name_Len - 2;\n+            WBI (\"      pragma Import (CIL, Ada_Main_Program, \"\"\"\n+                 & Name_Buffer (1 .. Name_Len) & \".\"\n+                 & Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len)) & \"\"\");\");\n+         end if;\n+\n          WBI (\"   begin\");\n \n          Set_String (\"      Main_Priority := \");\n@@ -616,7 +660,8 @@ package body Bindgen is\n          Write_Statement_Buffer;\n \n          Set_String (\"      WC_Encoding := '\");\n-         Set_Char   (ALIs.Table (ALIs.First).WC_Encoding);\n+         Set_Char   (Get_WC_Encoding);\n+\n          Set_String (\"';\");\n          Write_Statement_Buffer;\n \n@@ -736,11 +781,31 @@ package body Bindgen is\n          Write_Statement_Buffer;\n       end if;\n \n+      --  Initialize stack limit variable of the environment task if the\n+      --  stack check method is stack limit and if stack check is enabled.\n+\n+      if Stack_Check_Limits_On_Target\n+        and then (Stack_Check_Default_On_Target or Stack_Check_Switch_Set)\n+      then\n+         WBI (\"\");\n+         WBI (\"      Initialize_Stack_Limit;\");\n+      end if;\n+\n       --  Generate elaboration calls\n \n       WBI (\"\");\n       Gen_Elab_Calls_Ada;\n \n+      if VM_Target = CLI_Target\n+        and then not No_Main_Subprogram\n+      then\n+         if ALIs.Table (ALIs.First).Main_Program = Func then\n+            WBI (\"      Result := Ada_Main_Program;\");\n+         else\n+            WBI (\"      Ada_Main_Program;\");\n+         end if;\n+      end if;\n+\n       WBI (\"   end \" & Ada_Init_Name.all & \";\");\n    end Gen_Adainit_Ada;\n \n@@ -866,7 +931,8 @@ package body Bindgen is\n \n          WBI (\"   extern char __gl_wc_encoding;\");\n          Set_String (\"   __gl_wc_encoding = '\");\n-         Set_Char   (ALIs.Table (ALIs.First).WC_Encoding);\n+         Set_Char (Get_WC_Encoding);\n+\n          Set_String (\"';\");\n          Write_Statement_Buffer;\n \n@@ -966,6 +1032,16 @@ package body Bindgen is\n          WBI (\"     }\");\n       end if;\n \n+      --  Initialize stack limit for the environment task if the stack\n+      --  check method is stack limit and if stack check is enabled.\n+\n+      if Stack_Check_Limits_On_Target\n+        and then (Stack_Check_Default_On_Target or Stack_Check_Switch_Set)\n+      then\n+         WBI (\"\");\n+         WBI (\"   __gnat_initialize_stack_limit ();\");\n+      end if;\n+\n       --  Generate call to set Initialize_Scalar values if needed\n \n       if Initialize_Scalars_Used then\n@@ -2018,7 +2094,10 @@ package body Bindgen is\n \n       if VM_Target /= No_VM then\n          Ada_Bind_File := True;\n-         Bind_Main_Program := False;\n+\n+         if VM_Target = JVM_Target then\n+            Bind_Main_Program := False;\n+         end if;\n       end if;\n \n       --  Override time slice value if -T switch is set\n@@ -2113,12 +2192,13 @@ package body Bindgen is\n \n       Resolve_Binder_Options;\n \n-      if not Suppress_Standard_Library_On_Target then\n-         --  Usually, adafinal is called using a pragma Import C. Since\n-         --  Import C doesn't have the same semantics for JGNAT, we use\n-         --  standard Ada.\n+      if VM_Target /= No_VM then\n+         if not Suppress_Standard_Library_On_Target then\n+\n+            --  Usually, adafinal is called using a pragma Import C. Since\n+            --  Import C doesn't have the same semantics for JGNAT, we use\n+            --  standard Ada.\n \n-         if VM_Target /= No_VM then\n             WBI (\"with System.Standard_Library;\");\n          end if;\n       end if;\n@@ -2129,62 +2209,70 @@ package body Bindgen is\n       --  Main program case\n \n       if Bind_Main_Program then\n+         if VM_Target = No_VM then\n \n-         --  Generate argc/argv stuff unless suppressed\n-\n-         if Command_Line_Args_On_Target\n-           or not Configurable_Run_Time_On_Target\n-         then\n-            WBI (\"\");\n-            WBI (\"   gnat_argc : Integer;\");\n-            WBI (\"   gnat_argv : System.Address;\");\n-            WBI (\"   gnat_envp : System.Address;\");\n-\n-            --  If the standard library is not suppressed, these variables are\n-            --  in the runtime data area for easy access from the runtime\n+            --  Generate argc/argv stuff unless suppressed\n \n-            if not Suppress_Standard_Library_On_Target then\n+            if Command_Line_Args_On_Target\n+              or not Configurable_Run_Time_On_Target\n+            then\n                WBI (\"\");\n-               WBI (\"   pragma Import (C, gnat_argc);\");\n-               WBI (\"   pragma Import (C, gnat_argv);\");\n-               WBI (\"   pragma Import (C, gnat_envp);\");\n+               WBI (\"   gnat_argc : Integer;\");\n+               WBI (\"   gnat_argv : System.Address;\");\n+               WBI (\"   gnat_envp : System.Address;\");\n+\n+               --  If the standard library is not suppressed, these variables\n+               --  are in the runtime data area for easy access from the\n+               --  runtime\n+\n+               if not Suppress_Standard_Library_On_Target then\n+                  WBI (\"\");\n+                  WBI (\"   pragma Import (C, gnat_argc);\");\n+                  WBI (\"   pragma Import (C, gnat_argv);\");\n+                  WBI (\"   pragma Import (C, gnat_envp);\");\n+               end if;\n             end if;\n-         end if;\n \n-         --  Define exit status. Again in normal mode, this is in the\n-         --  run-time library, and is initialized there, but in the\n-         --  configurable runtime case, the variable is declared and\n-         --  initialized in this file.\n+            --  Define exit status. Again in normal mode, this is in the\n+            --  run-time library, and is initialized there, but in the\n+            --  configurable runtime case, the variable is declared and\n+            --  initialized in this file.\n \n-         WBI (\"\");\n+            WBI (\"\");\n \n-         if Configurable_Run_Time_Mode then\n-            if Exit_Status_Supported_On_Target then\n-               WBI (\"   gnat_exit_status : Integer := 0;\");\n+            if Configurable_Run_Time_Mode then\n+               if Exit_Status_Supported_On_Target then\n+                  WBI (\"   gnat_exit_status : Integer := 0;\");\n+               end if;\n+\n+            else\n+               WBI (\"   gnat_exit_status : Integer;\");\n+               WBI (\"   pragma Import (C, gnat_exit_status);\");\n             end if;\n-         else\n-            WBI (\"   gnat_exit_status : Integer;\");\n-            WBI (\"   pragma Import (C, gnat_exit_status);\");\n-         end if;\n-      end if;\n \n-      --  Generate the GNAT_Version and Ada_Main_Program_Name info only for\n-      --  the main program. Otherwise, it can lead under some circumstances\n-      --  to a symbol duplication during the link (for instance when a\n-      --  C program uses 2 Ada libraries)\n+            --  Generate the GNAT_Version and Ada_Main_Program_Name info only\n+            --  for the main program. Otherwise, it can lead under some\n+            --  circumstances to a symbol duplication during the link (for\n+            --  instance when a C program uses 2 Ada libraries)\n+         end if;\n \n-      if Bind_Main_Program then\n          WBI (\"\");\n          WBI (\"   GNAT_Version : constant String :=\");\n          WBI (\"                    \"\"GNAT Version: \" &\n-                                   Gnat_Version_String & \"\"\";\");\n+                                Gnat_Version_String & \"\"\";\");\n          WBI (\"   pragma Export (C, GNAT_Version, \"\"__gnat_version\"\");\");\n \n          WBI (\"\");\n          Set_String (\"   Ada_Main_Program_Name : constant String := \"\"\");\n          Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-         Set_Main_Program_Name;\n-         Set_String (\"\"\" & Ascii.NUL;\");\n+\n+         if VM_Target = No_VM then\n+            Set_Main_Program_Name;\n+            Set_String (\"\"\" & Ascii.NUL;\");\n+         else\n+            Set_String (Name_Buffer (1 .. Name_Len - 2) & \"\"\";\");\n+         end if;\n+\n          Write_Statement_Buffer;\n \n          WBI\n@@ -2212,7 +2300,7 @@ package body Bindgen is\n          WBI (\"   pragma Linker_Constructor (\" & Ada_Init_Name.all & \");\");\n       end if;\n \n-      if Bind_Main_Program then\n+      if Bind_Main_Program and then VM_Target = No_VM then\n \n          --  If we have the standard library, then Break_Start is defined\n          --  there, but when the standard library is suppressed, Break_Start\n@@ -2369,7 +2457,7 @@ package body Bindgen is\n \n       Gen_Adafinal_Ada;\n \n-      if Bind_Main_Program then\n+      if Bind_Main_Program and then VM_Target = No_VM then\n \n          --  When suppressing the standard library then generate dummy body\n          --  for Break_Start\n@@ -2477,6 +2565,16 @@ package body Bindgen is\n          WBI (\"extern void __gnat_stack_usage_initialize (int size);\");\n       end if;\n \n+      --  Initialize stack limit for the environment task if the stack\n+      --  check method is stack limit and if stack check is enabled.\n+\n+      if Stack_Check_Limits_On_Target\n+        and then (Stack_Check_Default_On_Target or Stack_Check_Switch_Set)\n+      then\n+         WBI (\"\");\n+         WBI (\"extern void __gnat_initialize_stack_limit (void);\");\n+      end if;\n+\n       WBI (\"\");\n \n       Gen_Elab_Defs_C;\n@@ -2944,6 +3042,23 @@ package body Bindgen is\n \n    end Gen_Versions_C;\n \n+   ------------------------\n+   -- Get_Main_Unit_Name --\n+   ------------------------\n+\n+   function Get_Main_Unit_Name (S : String) return String is\n+      Result : String := S;\n+\n+   begin\n+      for J in S'Range loop\n+         if Result (J) = '.' then\n+            Result (J) := '_';\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Get_Main_Unit_Name;\n+\n    -----------------------\n    -- Get_Ada_Main_Name --\n    -----------------------\n@@ -2959,14 +3074,8 @@ package body Bindgen is\n       --  ada_<main procedure>.\n \n       if VM_Target /= No_VM then\n-\n-         --  Get main program name\n-\n          Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n-\n-         --  Remove the %b\n-\n-         return \"ada_\" & Name_Buffer (1 .. Name_Len - 2);\n+         return \"ada_\" & Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len - 2));\n       end if;\n \n       --  This loop tries the following possibilities in order\n@@ -3051,6 +3160,38 @@ package body Bindgen is\n       end if;\n    end Get_Main_Name;\n \n+   ---------------------\n+   -- Get_WC_Encoding --\n+   ---------------------\n+\n+   function Get_WC_Encoding return Character is\n+   begin\n+      --  If encoding method specified by -W switch, then return it\n+\n+      if Wide_Character_Encoding_Method_Specified then\n+         return WC_Encoding_Letters (Wide_Character_Encoding_Method);\n+\n+      --  If no main program, and not specified, set brackets, we really have\n+      --  no better choice. If some other encoding is required when there is\n+      --  no main, it must be set explicitly using -Wx.\n+\n+      --  Note: if the ALI file always passed the wide character encoding\n+      --  of every file, then we could use the encoding of the initial\n+      --  specified file, but this information is passed only for potential\n+      --  main programs. We could fix this sometime, but it is a very minor\n+      --  point (wide character default encoding for [Wide_[Wide_]Text_IO\n+      --  when there is no main program).\n+\n+      elsif No_Main_Subprogram then\n+         return 'b';\n+\n+      --  Otherwise if there is a main program, take encoding from it\n+\n+      else\n+         return ALIs.Table (ALIs.First).WC_Encoding;\n+      end if;\n+   end Get_WC_Encoding;\n+\n    ----------------------\n    -- Lt_Linker_Option --\n    ----------------------"}, {"sha": "e5829cf510add410f793e386c6f8a81742e6d139", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -26,6 +26,8 @@\n with Osint;  use Osint;\n with Output; use Output;\n \n+with System.WCh_Con; use System.WCh_Con;\n+\n package body Bindusg is\n \n    Already_Displayed : Boolean := False;\n@@ -222,11 +224,27 @@ package body Bindusg is\n       Write_Line (\"  -v        Verbose mode. Error messages, \" &\n                   \"header, summary output to stdout\");\n \n-      --  Lines for -w switch\n+      --  Line for -w switch\n \n       Write_Line (\"  -wx       Warning mode. (x=s/e for \" &\n                   \"suppress/treat as error)\");\n \n+      --  Line for -W switch\n+\n+      Write_Str  (\"  -W?       Wide character encoding method (\");\n+\n+      for J in WC_Encoding_Method loop\n+         Write_Char (WC_Encoding_Letters (J));\n+\n+         if J = WC_Encoding_Method'Last then\n+            Write_Char (')');\n+         else\n+            Write_Char ('/');\n+         end if;\n+      end loop;\n+\n+      Write_Eol;\n+\n       --  Line for -x switch\n \n       Write_Line (\"  -x        Exclude source files (check object \" &"}, {"sha": "211a58fd8286328e4558a4b760bca51336a9c829", "filename": "gcc/ada/s-wchcon.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fs-wchcon.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fs-wchcon.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcon.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -71,4 +71,18 @@ package body System.WCh_Con is\n       end if;\n    end Get_WC_Encoding_Method;\n \n+   --------------------------\n+   -- Is_Start_Of_Encoding --\n+   --------------------------\n+\n+   function Is_Start_Of_Encoding\n+     (C  : Character;\n+      EM : WC_Encoding_Method) return Boolean\n+   is\n+   begin\n+      return (EM in WC_Upper_Half_Encoding_Method\n+               and then Character'Pos (C) >= 16#80#)\n+        or else (EM in WC_ESC_Encoding_Method and then C = ASCII.ESC);\n+   end Is_Start_Of_Encoding;\n+\n end System.WCh_Con;"}, {"sha": "af0eb7006a33ad3f87c6772409b3b73ac7ec9966", "filename": "gcc/ada/s-wchcon.ads", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fs-wchcon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fs-wchcon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchcon.ads?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -106,36 +106,39 @@ package System.WCh_Con is\n    --  sequence ESC a b c d (five characters, where abcd are ASCII hex\n    --  characters, using upper case for letters). This method is easy\n    --  to deal with in external environments that do not support wide\n-   --  characters, and covers the whole BMP. This is the default encoding\n-   --  method.\n+   --  characters, and covers the whole 16-bit BMP. Codes larger than\n+   --  16#FFFF# are not representable using this encoding method.\n \n    WCEM_Upper : constant WC_Encoding_Method := 2;\n    --  The wide character with encoding 16#abcd#, where the upper bit is on\n    --  (i.e. a is in the range 8-F) is represented as two bytes 16#ab# and\n    --  16#cd#. The second byte may never be a format control character, but\n    --  is not required to be in the upper half. This method can be also used\n    --  for shift-JIS or EUC where the internal coding matches the external\n-   --  coding.\n+   --  coding. Codes larger than 16#FFFF# are not representable using this\n+   --  encoding method.\n \n    WCEM_Shift_JIS : constant WC_Encoding_Method := 3;\n    --  A wide character is represented by a two character sequence 16#ab#\n    --  and 16#cd#, with the restrictions described for upper half encoding\n    --  as described above. The internal character code is the corresponding\n    --  JIS character according to the standard algorithm for Shift-JIS\n    --  conversion. See the body of package System.JIS_Conversions for\n-   --  further details.\n+   --  further details. Codes larger than 16#FFFF are not representable\n+   --  using this encoding method.\n \n    WCEM_EUC : constant WC_Encoding_Method := 4;\n    --  A wide character is represented by a two character sequence 16#ab# and\n    --  16#cd#, with both characters being in the upper half set. The internal\n    --  character code is the corresponding JIS character according to the EUC\n    --  encoding algorithm. See the body of package System.JIS_Conversions for\n-   --  further details.\n+   --  further details. Codes larger than 16#FFFF# are not representable using\n+   --  this encoding method.\n \n    WCEM_UTF8 : constant WC_Encoding_Method := 5;\n-   --  An ISO 10646-1 BMP/Unicode wide character is represented in\n-   --  UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO\n-   --  10646-1/Am.2.  Depending on the character value, a Unicode character\n+   --  An ISO 10646-1 BMP/Unicode wide character is represented in UCS\n+   --  Transformation Format 8 (UTF-8), as defined in Annex R of ISO\n+   --  10646-1/Am.2. Depending on the character value, a Unicode character\n    --  is represented as the one to six byte sequence.\n    --\n    --    16#0000_0000#-16#0000_007f#: 2#0xxxxxxx#\n@@ -151,7 +154,8 @@ package System.WCh_Con is\n    --  where the xxx bits correspond to the left-padded bits of the\n    --  16-bit character value. Note that all lower half ASCII characters\n    --  are represented as ASCII bytes and all upper half characters and\n-   --  other wide characters are represented as sequences of upper-half.\n+   --  other wide characters are represented as sequences of upper-half. This\n+   --  encoding method can represent the entire range of Wide_Wide_Character.\n \n    WCEM_Brackets : constant WC_Encoding_Method := 6;\n    --  A wide character is represented using one of the following sequences:\n@@ -161,7 +165,10 @@ package System.WCh_Con is\n    --    [\"xxxxxx\"]\n    --    [\"xxxxxxxx\"]\n    --\n-   --  where xx are hexadecimal digits representing the character code.\n+   --  where xx are hexadecimal digits representing the character code. This\n+   --  encoding method can represent the entire range of Wide_Wide_Character\n+   --  but in the general case results in ambiguous representations (there is\n+   --  no ambiguity in Ada sources, since the above sequences are illegal Ada).\n \n    WC_Encoding_Letters : constant array (WC_Encoding_Method) of Character :=\n      (WCEM_Hex       => 'h',\n@@ -183,10 +190,20 @@ package System.WCh_Con is\n    --  Encoding methods using an upper half character (16#80#..16#FF) at\n    --  the start of the sequence.\n \n-   WC_Longest_Sequence : constant := 10;\n+   WC_Longest_Sequence : constant := 12;\n    --  The longest number of characters that can be used for a wide character\n    --  or wide wide character sequence for any of the active encoding methods.\n \n+   WC_Longest_Sequences : constant array (WC_Encoding_Method) of Natural :=\n+     (WCEM_Hex       => 5,\n+      WCEM_Upper     => 2,\n+      WCEM_Shift_JIS => 2,\n+      WCEM_EUC       => 2,\n+      WCEM_UTF8      => 6,\n+      WCEM_Brackets  => 12);\n+   --  The longest number of characters that can be used for a wide character\n+   --  or wide wide character sequence using the given encoding method.\n+\n    function Get_WC_Encoding_Method (C : Character) return WC_Encoding_Method;\n    --  Given a character C, returns corresponding encoding method (see array\n    --  WC_Encoding_Letters above). Raises Constraint_Error if not in list.\n@@ -196,4 +213,12 @@ package System.WCh_Con is\n    --  utf8, brackets, return the corresponding encoding method. Raises\n    --  Constraint_Error if not in list.\n \n+   function Is_Start_Of_Encoding\n+     (C  : Character;\n+      EM : WC_Encoding_Method) return Boolean;\n+   pragma Inline (Is_Start_Of_Encoding);\n+   --  Returns True if the Character C is the start of a multi-character\n+   --  encoding sequence for the given encoding method EM. If EM is set to\n+   --  WCEM_Brackets, this function always returns False.\n+\n end System.WCh_Con;"}, {"sha": "793d8da495b178f31dcb2db8b276b897abc16501", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -417,21 +417,21 @@ package body Switch.B is\n          --  Processing for W switch\n \n          when 'W' =>\n-            if Ptr = Max then\n-               Bad_Switch (Switch_Chars);\n-            end if;\n-\n             Ptr := Ptr + 1;\n \n-            for J in WC_Encoding_Method loop\n-               if Switch_Chars (Ptr) = WC_Encoding_Letters (J) then\n-                  Wide_Character_Encoding_Method := J;\n-                  exit;\n+            if Ptr > Max then\n+               Bad_Switch (Switch_Chars);\n+            end if;\n \n-               elsif J = WC_Encoding_Method'Last then\n+            begin\n+               Wide_Character_Encoding_Method :=\n+                 Get_WC_Encoding_Method (Switch_Chars (Ptr));\n+            exception\n+               when Constraint_Error =>\n                   Bad_Switch (Switch_Chars);\n-               end if;\n-            end loop;\n+            end;\n+\n+            Wide_Character_Encoding_Method_Specified := True;\n \n             Upper_Half_Encoding :=\n               Wide_Character_Encoding_Method in"}, {"sha": "bd63fae88f86a1591208e490657e6139620980d8", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b917101e1c2a5318471e217e04f280023cd48c6a/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=b917101e1c2a5318471e217e04f280023cd48c6a", "patch": "@@ -479,6 +479,7 @@ package body Switch.C is\n                Constant_Condition_Warnings     := True;\n                Implementation_Unit_Warnings    := True;\n                Ineffective_Inline_Warnings     := True;\n+               Warn_On_Assertion_Failure       := True;\n                Warn_On_Assumed_Low_Bound       := True;\n                Warn_On_Bad_Fixed_Value         := True;\n                Warn_On_Constant                := True;\n@@ -833,9 +834,11 @@ package body Switch.C is\n                      Bad_Switch (\"-gnatW\" & Switch_Chars (Ptr .. Max));\n                end;\n \n+               Wide_Character_Encoding_Method_Specified := True;\n+\n                Upper_Half_Encoding :=\n                  Wide_Character_Encoding_Method in\n-                 WC_Upper_Half_Encoding_Method;\n+                   WC_Upper_Half_Encoding_Method;\n \n                Ptr := Ptr + 1;\n "}]}