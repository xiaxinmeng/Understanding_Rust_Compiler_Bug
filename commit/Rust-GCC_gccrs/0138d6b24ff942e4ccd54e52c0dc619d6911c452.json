{"sha": "0138d6b24ff942e4ccd54e52c0dc619d6911c452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzOGQ2YjI0ZmY5NDJlNGNjZDU0ZTUyYzBkYzYxOWQ2OTExYzQ1Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-05-09T16:43:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-05-09T16:43:36Z"}, "message": "N3639 C++1y VLA support\n\ngcc/\n\t* gimplify.c (gimplify_vla_decl): Don't touch an existing\n\tDECL_VALUE_EXPR.\ngcc/cp/\n\t* decl.c (compute_array_index_type): Allow VLAs in C++1y mode.\n\t(check_array_initializer): Allow VLA init.\n\t(reshape_init_array_1): Adjust.\n\t(cp_finish_decl): Check for invalid VLA length.\n\t* typeck2.c (process_init_constructor_array): Adjust.\n\t(store_init_value): Use build_vec_init for VLAs.\n\t* semantics.c (add_capture): Capture VLA as ptr+len.\n\t(vla_capture_type): New.\n\t(build_capture_proxy): Rebuild the VLA.\n\t* typeck.c (build_simple_component_ref): Split out from...\n\t(build_ptrmemfunc_access_expr): ...here.\n\t* tree.c (array_of_runtime_bound_p): New.\n\t* init.c (throw_bad_array_length): New.\n\t(build_vec_init): Use it.\n\t* parser.c (cp_convert_range_for): When iterating over a VLA,\n\tuse it directly rather than bind a reference.\n\t* cp-tree.h: Declare new functions.\nlibstdc++-v3/\n\t* libsupc++/new: Add std::bad_array_length.\n\t* libsupc++/bad_array_length.cc: New.\n\t* libsupc++/eh_aux_runtime.cc: Add __cxa_bad_array_length.\n\t* libsupc++/Makefile.in: Build them.\n\t* config/abi/pre/gnu.ver: Add new symbols.\n\t* config/abi/pre/gnu-versioned-namespace.ver: Add new symbols.\n\nFrom-SVN: r198745", "tree": {"sha": "0ff2545c076f920080c2715f42b04536c9c75c62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ff2545c076f920080c2715f42b04536c9c75c62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0138d6b24ff942e4ccd54e52c0dc619d6911c452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0138d6b24ff942e4ccd54e52c0dc619d6911c452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0138d6b24ff942e4ccd54e52c0dc619d6911c452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0138d6b24ff942e4ccd54e52c0dc619d6911c452/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3409c0279cf6f6f230c5d163472686867e2f89d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3409c0279cf6f6f230c5d163472686867e2f89d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3409c0279cf6f6f230c5d163472686867e2f89d"}], "stats": {"total": 361, "additions": 331, "deletions": 30}, "files": [{"sha": "da27792fb3b620463fac9c0a6f3797942dfebfbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -1,5 +1,9 @@\n 2013-05-09  Jason Merrill  <jason@redhat.com>\n \n+\tN3639 C++1y VLA support\n+\t* gimplify.c (gimplify_vla_decl): Don't touch an existing\n+\tDECL_VALUE_EXPR.\n+\n \t* tree.c (build_constructor_va): New.\n \t* tree.h: Declare it.\n "}, {"sha": "57d6a0a67e38f4991aab9dd5e9a55ef8cc327952", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -1,3 +1,24 @@\n+2013-05-09  Jason Merrill  <jason@redhat.com>\n+\n+\tN3639 C++1y VLA support\n+\t* decl.c (compute_array_index_type): Allow VLAs in C++1y mode.\n+\t(check_array_initializer): Allow VLA init.\n+\t(reshape_init_array_1): Adjust.\n+\t(cp_finish_decl): Check for invalid VLA length.\n+\t* typeck2.c (process_init_constructor_array): Adjust.\n+\t(store_init_value): Use build_vec_init for VLAs.\n+\t* semantics.c (add_capture): Capture VLA as ptr+len.\n+\t(vla_capture_type): New.\n+\t(build_capture_proxy): Rebuild the VLA.\n+\t* typeck.c (build_simple_component_ref): Split out from...\n+\t(build_ptrmemfunc_access_expr): ...here.\n+\t* tree.c (array_of_runtime_bound_p): New.\n+\t* init.c (throw_bad_array_length): New.\n+\t(build_vec_init): Use it.\n+\t* parser.c (cp_convert_range_for): When iterating over a VLA,\n+\tuse it directly rather than bind a reference.\n+\t* cp-tree.h: Declare new functions.\n+\n 2013-05-08  Jason Merrill  <jason@redhat.com>\n \n \t* except.c (is_admissible_throw_operand_or_catch_parameter): Check"}, {"sha": "a2f59df9b1a3963881adea910c775646bd7d0c3e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -5358,6 +5358,7 @@ extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree throw_bad_array_new_length\t\t(void);\n+extern tree throw_bad_array_length\t\t(void);\n extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **, int,\n                                                  tsubst_flags_t);\n@@ -5849,6 +5850,7 @@ extern tree get_target_expr\t\t\t(tree);\n extern tree get_target_expr_sfinae\t\t(tree, tsubst_flags_t);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree build_array_of_n_type\t\t(tree, int);\n+extern bool array_of_runtime_bound_p\t\t(tree);\n extern tree build_array_copy\t\t\t(tree);\n extern tree build_vec_init_expr\t\t\t(tree, tree, tsubst_flags_t);\n extern void diagnose_non_constexpr_vec_init\t(tree);\n@@ -6032,6 +6034,7 @@ extern tree cp_build_binary_op                  (location_t,\n \t\t\t\t\t\t enum tree_code, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n #define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n+extern tree build_simple_component_ref\t\t(tree, tree);\n extern tree build_ptrmemfunc_access_expr\t(tree, tree);\n extern tree build_address\t\t\t(tree);\n extern tree build_typed_address\t\t\t(tree, tree);"}, {"sha": "cebd36103b79580f90e7ebbe3f8557efb947d735", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -5064,7 +5064,7 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n \t\t      tsubst_flags_t complain)\n {\n   tree new_init;\n-  bool sized_array_p = (max_index != NULL_TREE);\n+  bool sized_array_p = (max_index && TREE_CONSTANT (max_index));\n   unsigned HOST_WIDE_INT max_index_cst = 0;\n   unsigned HOST_WIDE_INT index;\n \n@@ -5514,15 +5514,12 @@ check_array_initializer (tree decl, tree type, tree init)\n \terror (\"elements of array %q#T have incomplete type\", type);\n       return true;\n     }\n-  /* It is not valid to initialize a VLA.  */\n-  if (init\n+  /* A compound literal can't have variable size.  */\n+  if (init && !decl\n       && ((COMPLETE_TYPE_P (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n \t  || !TREE_CONSTANT (TYPE_SIZE (element_type))))\n     {\n-      if (decl)\n-\terror (\"variable-sized object %qD may not be initialized\", decl);\n-      else\n-\terror (\"variable-sized compound literal\");\n+      error (\"variable-sized compound literal\");\n       return true;\n     }\n   return false;\n@@ -6405,6 +6402,21 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t   && TYPE_FOR_JAVA (type) && MAYBE_CLASS_TYPE_P (type))\n     error (\"non-static data member %qD has Java class type\", decl);\n \n+  if (array_of_runtime_bound_p (type))\n+    {\n+      /* If the VLA bound is larger than half the address space, or less\n+\t than zero, throw std::bad_array_length.  */\n+      tree max = convert (ssizetype, TYPE_MAX_VALUE (TYPE_DOMAIN (type)));\n+      /* C++1y says we should throw for length <= 0, but we have\n+\t historically supported zero-length arrays.  Let's treat that as an\n+\t extension to be disabled by -std=c++NN.  */\n+      int lower = flag_iso ? 0 : -1;\n+      tree comp = build2 (LT_EXPR, boolean_type_node, max, ssize_int (lower));\n+      comp = build3 (COND_EXPR, void_type_node, comp,\n+\t\t     throw_bad_array_length (), void_zero_node);\n+      finish_expr_stmt (comp);\n+    }\n+\n   /* Add this declaration to the statement-tree.  This needs to happen\n      after the call to check_initializer so that the DECL_EXPR for a\n      reference temp is added before the DECL_EXPR for the reference itself.  */\n@@ -8289,7 +8301,7 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n \terror (\"size of array is not an integral constant-expression\");\n       size = integer_one_node;\n     }\n-  else if (pedantic && warn_vla != 0)\n+  else if (cxx_dialect < cxx1y && pedantic && warn_vla != 0)\n     {\n       if (name)\n \tpedwarn (input_location, OPT_Wvla, \"ISO C++ forbids variable length array %qD\", name);"}, {"sha": "d687a8428ce4f53244f50ac24ee3b6006fd4faa3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -2185,6 +2185,20 @@ throw_bad_array_new_length (void)\n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n \n+/* Call __cxa_bad_array_length to indicate that there were too many\n+   initializers.  */\n+\n+tree\n+throw_bad_array_length (void)\n+{\n+  tree fn = get_identifier (\"__cxa_throw_bad_array_length\");\n+  if (!get_global_value_if_present (fn, &fn))\n+    fn = push_throw_library_fn (fn, build_function_type_list (void_type_node,\n+\t\t\t\t\t\t\t      NULL_TREE));\n+\n+  return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -3350,6 +3364,10 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t store_constructor will handle the semantics for us.  */\n \n       stmt_expr = build2 (INIT_EXPR, atype, base, init);\n+      if (length_check)\n+\tstmt_expr = build3 (COND_EXPR, atype, length_check,\n+\t\t\t    throw_bad_array_length (),\n+\t\t\t    stmt_expr);\n       return stmt_expr;\n     }\n \n@@ -3467,6 +3485,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n       if (length_check)\n \t{\n \t  tree throw_call;\n+\t  if (array_of_runtime_bound_p (atype))\n+\t    throw_call = throw_bad_array_length ();\n+\t  else\n \t    throw_call = throw_bad_array_new_length ();\n \t  length_check = build3 (COND_EXPR, void_type_node, length_check,\n \t\t\t\t throw_call, void_zero_node);"}, {"sha": "f65ec970654b796c7751725aa3580a4e217dfea0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -9842,13 +9842,21 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n     begin_expr = end_expr = iter_type = error_mark_node;\n   else\n     {\n-      tree range_temp = build_range_temp (range_expr);\n-      pushdecl (range_temp);\n-      cp_finish_decl (range_temp, range_expr,\n-\t\t      /*is_constant_init*/false, NULL_TREE,\n-\t\t      LOOKUP_ONLYCONVERTING);\n+      tree range_temp;\n \n-      range_temp = convert_from_reference (range_temp);\n+      if (TREE_CODE (range_expr) == VAR_DECL\n+\t  && array_of_runtime_bound_p (TREE_TYPE (range_expr)))\n+\t/* Can't bind a reference to an array of runtime bound.  */\n+\trange_temp = range_expr;\n+      else\n+\t{\n+\t  range_temp = build_range_temp (range_expr);\n+\t  pushdecl (range_temp);\n+\t  cp_finish_decl (range_temp, range_expr,\n+\t\t\t  /*is_constant_init*/false, NULL_TREE,\n+\t\t\t  LOOKUP_ONLYCONVERTING);\n+\t  range_temp = convert_from_reference (range_temp);\n+\t}\n       iter_type = cp_parser_perform_range_for_lookup (range_temp,\n \t\t\t\t\t\t      &begin_expr, &end_expr);\n     }"}, {"sha": "591750315eb9c283acd48798daff661a2c4cf9ce", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -9379,6 +9379,21 @@ build_capture_proxy (tree member)\n     name = DECL_NAME (member);\n \n   type = lambda_proxy_type (object);\n+\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_NAME (type) == NULL_TREE)\n+    {\n+      /* Rebuild the VLA type from the pointer and maxindex.  */\n+      tree field = next_initializable_field (TYPE_FIELDS (type));\n+      tree ptr = build_simple_component_ref (object, field);\n+      field = next_initializable_field (DECL_CHAIN (field));\n+      tree max = build_simple_component_ref (object, field);\n+      type = build_array_type (TREE_TYPE (TREE_TYPE (ptr)),\n+\t\t\t       build_index_type (max));\n+      object = convert (build_reference_type (type), ptr);\n+      object = convert_from_reference (object);\n+    }\n+\n   var = build_decl (input_location, VAR_DECL, name, type);\n   SET_DECL_VALUE_EXPR (var, object);\n   DECL_HAS_VALUE_EXPR_P (var) = 1;\n@@ -9400,6 +9415,28 @@ build_capture_proxy (tree member)\n   return var;\n }\n \n+/* Return a struct containing a pointer and a length for lambda capture of\n+   an array of runtime length.  */\n+\n+static tree\n+vla_capture_type (tree array_type)\n+{\n+  static tree ptr_id, max_id;\n+  if (!ptr_id)\n+    {\n+      ptr_id = get_identifier (\"ptr\");\n+      max_id = get_identifier (\"max\");\n+    }\n+  tree ptrtype = build_pointer_type (TREE_TYPE (array_type));\n+  tree field1 = build_decl (input_location, FIELD_DECL, ptr_id, ptrtype);\n+  tree field2 = build_decl (input_location, FIELD_DECL, max_id, sizetype);\n+  DECL_CHAIN (field2) = field1;\n+  tree type = make_node (RECORD_TYPE);\n+  finish_builtin_struct (type, \"__cap\", field2, NULL_TREE);\n+  TYPE_NAME (type) = NULL_TREE;\n+  return type;\n+}\n+\n /* From an ID and INITIALIZER, create a capture (by reference if\n    BY_REFERENCE_P is true), add it to the capture-list for LAMBDA,\n    and return it.  */\n@@ -9415,7 +9452,22 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n     initializer = build_x_compound_expr_from_list (initializer, ELK_INIT,\n \t\t\t\t\t\t   tf_warning_or_error);\n   type = lambda_capture_field_type (initializer, explicit_init_p);\n-  if (by_reference_p)\n+  if (array_of_runtime_bound_p (type))\n+    {\n+      /* For a VLA, we capture the address of the first element and the\n+\t maximum index, and then reconstruct the VLA for the proxy.  */\n+      gcc_assert (by_reference_p);\n+      tree elt = cp_build_array_ref (input_location, initializer,\n+\t\t\t\t     integer_zero_node, tf_warning_or_error);\n+      tree ctype = vla_capture_type (type);\n+      tree ptr_field = next_initializable_field (TYPE_FIELDS (ctype));\n+      tree nelts_field = next_initializable_field (DECL_CHAIN (ptr_field));\n+      initializer = build_constructor_va (ctype, 2,\n+\t\t\t\t\t  ptr_field, build_address (elt),\n+\t\t\t\t\t  nelts_field, array_type_nelts (type));\n+      type = ctype;\n+    }\n+  else if (by_reference_p)\n     {\n       type = build_reference_type (type);\n       if (!real_lvalue_p (initializer))"}, {"sha": "2df2087afb2d461db59db8e9a9415934fa477b69", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -871,6 +871,21 @@ build_array_of_n_type (tree elt, int n)\n   return build_cplus_array_type (elt, build_index_type (size_int (n - 1)));\n }\n \n+/* True iff T is a C++1y array of runtime bound (VLA).  */\n+\n+bool\n+array_of_runtime_bound_p (tree t)\n+{\n+  if (!t || TREE_CODE (t) != ARRAY_TYPE)\n+    return false;\n+  tree dom = TYPE_DOMAIN (t);\n+  if (!dom)\n+    return false;\n+  tree max = TYPE_MAX_VALUE (dom);\n+  return (!value_dependent_expression_p (max)\n+\t  && !TREE_CONSTANT (max));\n+}\n+\n /* Return a reference type node referring to TO_TYPE.  If RVAL is\n    true, return an rvalue reference type, otherwise return an lvalue\n    reference type.  If a type node exists, reuse it, otherwise create"}, {"sha": "47670f2a5d886af0d7219521e5315bdd27d2ea3a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -2788,6 +2788,19 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n   return expr;\n }\n \n+/* Build a COMPONENT_REF of OBJECT and MEMBER with the appropriate\n+   type.  */\n+\n+tree\n+build_simple_component_ref (tree object, tree member)\n+{\n+  tree type = cp_build_qualified_type (TREE_TYPE (member),\n+\t\t\t\t       cp_type_quals (TREE_TYPE (object)));\n+  return fold_build3_loc (input_location,\n+\t\t\t  COMPONENT_REF, type,\n+\t\t\t  object, member, NULL_TREE);\n+}\n+\n /* Return an expression for the MEMBER_NAME field in the internal\n    representation of PTRMEM, a pointer-to-member function.  (Each\n    pointer-to-member function type gets its own RECORD_TYPE so it is\n@@ -2800,7 +2813,6 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n {\n   tree ptrmem_type;\n   tree member;\n-  tree member_type;\n \n   /* This code is a stripped down version of\n      build_class_member_access_expr.  It does not work to use that\n@@ -2810,11 +2822,7 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n   gcc_assert (TYPE_PTRMEMFUNC_P (ptrmem_type));\n   member = lookup_member (ptrmem_type, member_name, /*protect=*/0,\n \t\t\t  /*want_type=*/false, tf_warning_or_error);\n-  member_type = cp_build_qualified_type (TREE_TYPE (member),\n-\t\t\t\t\t cp_type_quals (ptrmem_type));\n-  return fold_build3_loc (input_location,\n-\t\t      COMPONENT_REF, member_type,\n-\t\t      ptrmem, member, NULL_TREE);\n+  return build_simple_component_ref (ptrmem, member);\n }\n \n /* Given an expression PTR for a pointer, return an expression"}, {"sha": "e0ebae95723dce020b6e37f7b4533a747c7b9325", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -795,10 +795,12 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n      will perform the dynamic initialization.  */\n   if (value != error_mark_node\n       && (TREE_SIDE_EFFECTS (value)\n+\t  || array_of_runtime_bound_p (type)\n \t  || ! reduced_constant_expression_p (value)))\n     {\n       if (TREE_CODE (type) == ARRAY_TYPE\n-\t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (type)))\n+\t  && (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (type))\n+\t      || array_of_runtime_bound_p (type)))\n \t/* For an array, we only need/want a single cleanup region rather\n \t   than one per element.  */\n \treturn build_vec_init (decl, NULL_TREE, value, false, 1,\n@@ -1114,7 +1116,7 @@ process_init_constructor_array (tree type, tree init,\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree domain = TYPE_DOMAIN (type);\n-      if (domain)\n+      if (domain && TREE_CONSTANT (TYPE_MAX_VALUE (domain)))\n \tlen = (tree_to_double_int (TYPE_MAX_VALUE (domain))\n \t       - tree_to_double_int (TYPE_MIN_VALUE (domain))\n \t       + double_int_one)"}, {"sha": "e2ae8932dfae45f35c5efc45e1b789ee49d87e0a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -1382,6 +1382,10 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   gimplify_one_sizepos (&DECL_SIZE (decl), seq_p);\n   gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), seq_p);\n \n+  /* Don't mess with a DECL_VALUE_EXPR set by the front-end.  */\n+  if (DECL_HAS_VALUE_EXPR_P (decl))\n+    return;\n+\n   /* All occurrences of this decl in final gimplified code will be\n      replaced by indirection.  Setting DECL_VALUE_EXPR does two\n      things: First, it lets the rest of the gimplifier know what"}, {"sha": "4cd95d4ef7f91e9d177064a195d1c8451ee73ed1", "filename": "gcc/testsuite/g++.dg/cpp1y/vla2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla2.C?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -0,0 +1,15 @@\n+// N3639 allows initialization and capture of VLAs\n+// { dg-options -std=c++1y }\n+// { dg-do run }\n+\n+void f(int n)\n+{\n+  int ar[n] = { 42 };\n+  auto l = [&] { return ar[0]; };\n+  if (l() != 42) __builtin_abort ();\n+}\n+\n+int main()\n+{\n+  f(1);\n+}"}, {"sha": "a016904604b967833ecf1cbbea737cbff9c9574b", "filename": "gcc/testsuite/g++.dg/cpp1y/vla3.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla3.C?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -0,0 +1,30 @@\n+// Test for throwing bad_array_length on invalid array length\n+// { dg-options -std=c++1y }\n+// { dg-do run }\n+\n+#include <new>\n+\n+int f(int i)\n+{\n+  int ar[i]{1,2,3,4};\n+  return ar[i-1];\n+}\n+\n+void g(int i)\n+{\n+  int ar[i];\n+  ar[0] = 42;\n+}\n+\n+int main()\n+{\n+  int ok = 0;\n+  f(4);\t\t\t\t// OK\n+  try { f(3); }\t\t\t// too small\n+  catch (std::bad_array_length) { ++ok; }\n+  try { g(-24); }\t\t// negative\n+  catch (std::bad_array_length) { ++ok; }\n+\n+  if (ok != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "78b7effd8f796cc38f609d8f11a3ccb542e4f7f7", "filename": "gcc/testsuite/g++.dg/cpp1y/vla4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla4.C?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -0,0 +1,24 @@\n+// Test for range-based for with VLAs.\n+// { dg-options -std=c++1y }\n+// { dg-do run }\n+\n+#include <new>\n+\n+void f(int i)\n+{\n+  int ar[i];\n+  int j = 0;\n+  for (int& x : ar)\n+    x = ++j;\n+  [&ar]{\n+    int k = 0;\n+    for (int x : ar)\n+      if (x != ++k)\n+\t__builtin_abort();\n+  }();\n+}\n+\n+int main()\n+{\n+  f(42);\t\t\t\t// OK\n+}"}, {"sha": "2d72df40382b681d984f0fb35e822d16509e58ff", "filename": "gcc/testsuite/g++.dg/init/array24.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray24.C?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -1,7 +1,7 @@\n // PR c++/29175\n-// { dg-options \"\" }\n+// { dg-options \"-Wno-vla\" }\n \n void foo(int i)\n {\n-  int x[][i] = { 0 }; // { dg-error \"variable-sized|storage size\" }\n+  int x[][i] = { 0 };\n }"}, {"sha": "9bbb771cf2e3071a3002c77c492a3302a6348b9c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -1,3 +1,13 @@\n+2013-05-08  Jason Merrill  <jason@redhat.com>\n+\n+\tAdd std::bad_array_length (N3639)\n+\t* libsupc++/new: Add std::bad_array_length.\n+\t* libsupc++/bad_array_length.cc: New.\n+\t* libsupc++/eh_aux_runtime.cc: Add __cxa_bad_array_length.\n+\t* libsupc++/Makefile.in: Build them.\n+\t* config/abi/pre/gnu.ver: Add new symbols.\n+\t* config/abi/pre/gnu-versioned-namespace.ver: Add new symbols.\n+\n 2013-05-08  Andi Kleen  <ak@linux.intel.com>\n \n \tPR target/55947"}, {"sha": "33a0068e2d7b2fe162f0710b764735f7b34c1584", "filename": "libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -235,6 +235,9 @@ CXXABI_2.0 {\n     __cxa_throw_bad_array_new_length;\n     _Z*St20bad_array_new_length*;\n \n+    __cxa_throw_bad_array_length;\n+    _Z*St16bad_array_length*;\n+\n     # Default function.\n     _ZSt11_Hash_bytesPKv*;\n "}, {"sha": "446a68502e3f026cd72f852afc58526533c275fb", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -1559,6 +1559,9 @@ CXXABI_1.3.7 {\n CXXABI_1.3.8 {\n     __cxa_throw_bad_array_new_length;\n     _Z*St20bad_array_new_length*;\n+\n+    __cxa_throw_bad_array_length;\n+    _Z*St16bad_array_length*;\n } CXXABI_1.3.7;\n \n # Symbols in the support library (libsupc++) supporting transactional memory."}, {"sha": "6ff4d0ce886fdee88ddea5b6b0c8771a226799fb", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -92,8 +92,8 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(bitsdir)\" \\\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libsupc___la_LIBADD =\n am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \\\n-\tbad_alloc.lo bad_array_new.lo bad_cast.lo bad_typeid.lo \\\n-\tclass_type_info.lo \\\n+\tbad_alloc.lo bad_array_length.lo bad_array_new.lo bad_cast.lo \\\n+\tbad_typeid.lo class_type_info.lo \\\n \tdel_op.lo del_opnt.lo del_opv.lo del_opvnt.lo dyncast.lo \\\n \teh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \\\n \teh_exception.lo eh_globals.lo eh_personality.lo eh_ptr.lo \\\n@@ -367,6 +367,7 @@ sources = \\\n \tatexit_arm.cc \\\n \tatexit_thread.cc \\\n \tbad_alloc.cc \\\n+\tbad_array_length.cc \\\n \tbad_array_new.cc \\\n \tbad_cast.cc \\\n \tbad_typeid.cc \\\n@@ -789,16 +790,22 @@ cp-demangle.lo: cp-demangle.c\n cp-demangle.o: cp-demangle.c\n \t$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<\n \n-# Use special rules for the C++11 sources so that the proper flags are passed.\n+# Use special rules for the C++11 and C++1y sources so that the proper\n+# flags are passed.\n+bad_array_length.lo: bad_array_length.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1y -c $<\n+bad_array_length.o: bad_array_length.cc\n+\t$(CXXCOMPILE) -std=gnu++1y -c $<\n+\n bad_array_new.lo: bad_array_new.cc\n \t$(LTCXXCOMPILE) -std=gnu++11 -c $<\n bad_array_new.o: bad_array_new.cc\n \t$(CXXCOMPILE) -std=gnu++11 -c $<\n \n eh_aux_runtime.lo: eh_aux_runtime.cc\n-\t$(LTCXXCOMPILE) -std=gnu++11 -c $<\n+\t$(LTCXXCOMPILE) -std=gnu++1y -c $<\n eh_aux_runtime.o: eh_aux_runtime.cc\n-\t$(CXXCOMPILE) -std=gnu++11 -c $<\n+\t$(CXXCOMPILE) -std=gnu++1y -c $<\n \n eh_ptr.lo: eh_ptr.cc\n \t$(LTCXXCOMPILE) -std=gnu++11 -c $<"}, {"sha": "a63d660f20b7918ed958732af13a8c1699ac4bee", "filename": "libstdc++-v3/libsupc++/bad_array_length.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_array_length.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_array_length.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_array_length.cc?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <new>\n+\n+namespace std {\n+\n+bad_array_length::~bad_array_length() _GLIBCXX_USE_NOEXCEPT { }\n+\n+const char*\n+bad_array_length::what() const _GLIBCXX_USE_NOEXCEPT\n+{\n+  return \"std::bad_array_length\";\n+}\n+\n+} // namespace std"}, {"sha": "cf2c0602e5fe82832b4c40e69fdb7baee71e2d2e", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -154,6 +154,8 @@ namespace __cxxabiv1\n   void\n   __cxa_throw_bad_array_new_length() __attribute__((__noreturn__));\n \n+  void\n+  __cxa_throw_bad_array_length() __attribute__((__noreturn__));\n \n   /**\n    *  @brief Demangling routine."}, {"sha": "806b47981104028db9f87bbde26d9621b2c5b8bf", "filename": "libstdc++-v3/libsupc++/eh_aux_runtime.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -40,3 +40,7 @@ __cxxabiv1::__cxa_bad_typeid ()\n extern \"C\" void\n __cxxabiv1::__cxa_throw_bad_array_new_length ()\n { _GLIBCXX_THROW_OR_ABORT(std::bad_array_new_length()); }\n+\n+extern \"C\" void\n+__cxxabiv1::__cxa_throw_bad_array_length ()\n+{ _GLIBCXX_THROW_OR_ABORT(std::bad_array_length()); }"}, {"sha": "cdf4cab85b9abd10f27e22450818e5d92d843642", "filename": "libstdc++-v3/libsupc++/new", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0138d6b24ff942e4ccd54e52c0dc619d6911c452/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew?ref=0138d6b24ff942e4ccd54e52c0dc619d6911c452", "patch": "@@ -79,6 +79,23 @@ namespace std\n   };\n #endif\n \n+  // We throw this exception for GNU VLAs of negative length in all C++\n+  // dialects, so declare it if we aren't in strict conformance mode.\n+#if __cplusplus > 201103L || !defined(__STRICT_ANSI__)\n+  class bad_array_length : public bad_alloc\n+  {\n+  public:\n+    bad_array_length() throw() { };\n+\n+    // This declaration is not useless:\n+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118\n+    virtual ~bad_array_length() throw();\n+\n+    // See comment in eh_exception.cc.\n+    virtual const char* what() const throw();\n+  };\n+#endif\n+\n   struct nothrow_t { };\n \n   extern const nothrow_t nothrow;"}]}