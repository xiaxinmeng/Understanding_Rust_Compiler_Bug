{"sha": "2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ2YzhlZWExZDdhZTViM2IyYjNjMjUwOGY3OGRlOTE4YzczZjRjNA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-07-23T19:40:28Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-07-23T19:40:28Z"}, "message": "PR libstdc++/70940 optimize pmr::resource_adaptor for allocators using malloc\n\npmr::resource_adaptor can avoid allocating an oversized buffer and doing\nmanual alignment within that buffer when the wrapped allocator is known\nto always meet the requested alignment. Specifically, if the allocator\nis known to use malloc or new directly, then we can call the allocator\ndirectly for any fundamental alignment.\n\n\tPR libstdc++/70940\n\t* include/experimental/memory_resource\n\t(__resource_adaptor_common::_AlignMgr::_M_unadjust): Add assertion.\n\t(__resource_adaptor_common::__guaranteed_alignment): New helper to\n\tgive maximum alignment an allocator guarantees. Specialize for known\n\tallocators using new and malloc.\n\t(__resource_adaptor_imp::do_allocate): Use __guaranteed_alignment.\n\t(__resource_adaptor_imp::do_deallocate): Likewise.\n\t* testsuite/experimental/memory_resource/new_delete_resource.cc:\n\tCheck that new and delete are called with expected sizes.\n\nFrom-SVN: r262935", "tree": {"sha": "2db36a97ddc96b86ee3c32f89c5cfb365cbe2c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2db36a97ddc96b86ee3c32f89c5cfb365cbe2c5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "651a79532c8e87ac096419d9852a295f9e284fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/651a79532c8e87ac096419d9852a295f9e284fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/651a79532c8e87ac096419d9852a295f9e284fe4"}], "stats": {"total": 114, "additions": 94, "deletions": 20}, "files": [{"sha": "ba78ab8e914cc314a2027b31affe42a23c5b0ac1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "patch": "@@ -1,3 +1,16 @@\n+2018-07-23  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/70940\n+\t* include/experimental/memory_resource\n+\t(__resource_adaptor_common::_AlignMgr::_M_unadjust): Add assertion.\n+\t(__resource_adaptor_common::__guaranteed_alignment): New helper to\n+\tgive maximum alignment an allocator guarantees. Specialize for known\n+\tallocators using new and malloc.\n+\t(__resource_adaptor_imp::do_allocate): Use __guaranteed_alignment.\n+\t(__resource_adaptor_imp::do_deallocate): Likewise.\n+\t* testsuite/experimental/memory_resource/new_delete_resource.cc:\n+\tCheck that new and delete are called with expected sizes.\n+\n 2018-07-20  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/86595"}, {"sha": "61273fc2c855e3e38170aa2c6cba9ae7b186ad9a", "filename": "libstdc++-v3/include/experimental/memory_resource", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory_resource?ref=2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "patch": "@@ -36,6 +36,13 @@\n #include <ext/new_allocator.h>\n #include <experimental/bits/lfts_config.h>\n \n+namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<typename _Tp> class malloc_allocator;\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __gnu_cxx\n+\n namespace std {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n@@ -307,6 +314,10 @@ namespace pmr {\n \t  __orig_ptr = __ptr - _S_read<unsigned int>(__end);\n \telse // (__token_size == sizeof(char*))\n \t  __orig_ptr = _S_read<char*>(__end);\n+\t// The adjustment is always less than the requested alignment,\n+\t// so if that isn't true now then either the wrong size was passed\n+\t// to deallocate or the token was overwritten by a buffer overflow:\n+\t__glibcxx_assert(static_cast<size_t>(__ptr - __orig_ptr) < _M_align);\n \treturn __orig_ptr;\n       }\n \n@@ -345,6 +356,23 @@ namespace pmr {\n \t  return __val;\n \t}\n     };\n+\n+    template<typename _Alloc>\n+      struct __guaranteed_alignment : std::integral_constant<size_t, 1> { };\n+\n+    template<typename _Tp>\n+      struct __guaranteed_alignment<__gnu_cxx::new_allocator<_Tp>>\n+      : std::alignment_of<std::max_align_t>::type { };\n+\n+    template<typename _Tp>\n+      struct __guaranteed_alignment<__gnu_cxx::malloc_allocator<_Tp>>\n+      : std::alignment_of<std::max_align_t>::type { };\n+\n+#if _GLIBCXX_USE_ALLOCATOR_NEW\n+    template<typename _Tp>\n+      struct __guaranteed_alignment<std::allocator<_Tp>>\n+      : std::alignment_of<std::max_align_t>::type { };\n+#endif\n   };\n \n   // 8.7.1 __resource_adaptor_imp\n@@ -392,7 +420,7 @@ namespace pmr {\n       virtual void*\n       do_allocate(size_t __bytes, size_t __alignment) override\n       {\n-\tif (__alignment == 1)\n+\tif (__alignment <= __guaranteed_alignment<_Alloc>::value)\n \t  return _M_alloc.allocate(__bytes);\n \n \tconst _AlignMgr __mgr(__bytes, __alignment);\n@@ -407,7 +435,7 @@ namespace pmr {\n       override\n       {\n \tauto __ptr = static_cast<char*>(__p);\n-\tif (__alignment == 1)\n+\tif (__alignment <= __guaranteed_alignment<_Alloc>::value)\n \t  {\n \t    _M_alloc.deallocate(__ptr, __bytes);\n \t    return;"}, {"sha": "a7c4b378b6faeb88e27cd08f88af11d3d852a105", "filename": "libstdc++-v3/testsuite/experimental/memory_resource/new_delete_resource.cc", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fnew_delete_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fnew_delete_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory_resource%2Fnew_delete_resource.cc?ref=2d6c8eea1d7ae5b3b2b3c2508f78de918c73f4c4", "patch": "@@ -18,30 +18,39 @@\n // { dg-do run { target c++14 } }\n \n #include <experimental/memory_resource>\n+#include <cstdlib>\n #include <testsuite_hooks.h>\n \n bool new_called = false;\n bool delete_called = false;\n+std::size_t bytes_allocated = 0;\n \n void* operator new(std::size_t n)\n {\n   new_called = true;\n   if (void* p = malloc(n))\n+  {\n+    bytes_allocated += n;\n     return p;\n+  }\n   throw std::bad_alloc();\n }\n \n void operator delete(void* p)\n {\n   delete_called = true;\n   std::free(p);\n+  bytes_allocated = 0; // assume everything getting deleted\n }\n \n-void operator delete(void* p, std::size_t)\n+void operator delete(void* p, std::size_t n)\n {\n-  ::operator delete(p);\n+  delete_called = true;\n+  std::free(p);\n+  bytes_allocated -= n;\n }\n \n+\n template<std::size_t A>\n   bool aligned(void* p)\n   {\n@@ -92,36 +101,60 @@ test02()\n \n void\n test03()\n+\n {\n   using std::max_align_t;\n   using std::size_t;\n   void* p = nullptr;\n \n+  bytes_allocated = 0;\n+\n   memory_resource* r1 = new_delete_resource();\n   p = r1->allocate(1);\n+  VERIFY( bytes_allocated == 1 );\n   VERIFY( aligned<max_align_t>(p) );\n   r1->deallocate(p, 1);\n-  p = r1->allocate(1, alignof(short));\n+  VERIFY( bytes_allocated == 0 );\n+\n+  p = r1->allocate(2, alignof(char));\n+  VERIFY( bytes_allocated == 2 );\n+  VERIFY( aligned<max_align_t>(p) );\n+  r1->deallocate(p, 2);\n+  VERIFY( bytes_allocated == 0 );\n+\n+  p = r1->allocate(3, alignof(short));\n+  VERIFY( bytes_allocated == 3 );\n   VERIFY( aligned<short>(p) );\n-  r1->deallocate(p, 1, alignof(short));\n-  p = r1->allocate(1, alignof(long));\n+  r1->deallocate(p, 3, alignof(short));\n+  VERIFY( bytes_allocated == 0 );\n+\n+  p = r1->allocate(4, alignof(long));\n+  VERIFY( bytes_allocated == 4 );\n   VERIFY( aligned<long>(p) );\n-  r1->deallocate(p, 1, alignof(long));\n-  constexpr size_t big_al = alignof(max_align_t) * 8;\n-  p = r1->allocate(1, big_al);\n-  VERIFY( aligned<big_al>(p) );\n-  r1->deallocate(p, 1, big_al);\n-\n-  // Test extended alignments\n-  p = r1->allocate(1024, al6);\n+  r1->deallocate(p, 4, alignof(long));\n+  VERIFY( bytes_allocated == 0 );\n+\n+  // Test extended aligments:\n+  p = r1->allocate(777, al6);\n+  VERIFY( bytes_allocated >= 777 );\n+  VERIFY( bytes_allocated < (777 + al6 + 8) );  // reasonable upper bound\n   VERIFY( aligned<al6>(p) );\n-  r1->deallocate(p, 1024, al6);\n-  p = r1->allocate(1024, al12);\n+  r1->deallocate(p, 777, al6);\n+  VERIFY( bytes_allocated == 0 );\n+\n+  p = r1->allocate(888, al12);\n+  VERIFY( bytes_allocated >= 888 );\n+  VERIFY( bytes_allocated < (888 + al12 + 8) );  // reasonable upper bound\n   VERIFY( aligned<al12>(p) );\n-  r1->deallocate(p, 1024, al12);\n-  p = r1->allocate(1024, al18);\n+  r1->deallocate(p, 888, al12);\n+  VERIFY( bytes_allocated == 0 );\n+\n+  p = r1->allocate(999, al18);\n+  VERIFY( bytes_allocated >= 999 );\n+  VERIFY( bytes_allocated < (999 + al18 + 8) );  // reasonable upper bound\n   VERIFY( aligned<al18>(p) );\n-  r1->deallocate(p, 1024, al18);\n+  r1->deallocate(p, 999, al18);\n+  VERIFY( bytes_allocated == 0 );\n }\n \n int main()"}]}