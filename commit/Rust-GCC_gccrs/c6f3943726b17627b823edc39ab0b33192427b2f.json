{"sha": "c6f3943726b17627b823edc39ab0b33192427b2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZmMzk0MzcyNmIxNzYyN2I4MjNlZGMzOWFiMGIzMzE5MjQyN2IyZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T08:47:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T08:47:36Z"}, "message": "[multiple changes]\n\n2009-07-13  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb (Add_RACW_Primitive_Declarations_And_Bodies):\n\tDo not attempt to generate stubs for predefined primitives of\n\tsynchronized interfaces.\n\t(Add_Stub_Type): Factor some code from the PCS-specific variants of\n\tBuild_Stub_Type.\n\n2009-07-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_disp.adb (Override_Dispatching_Operation): Functions inherit the\n\tControlling_Result flag from the operation they override.\n\nFrom-SVN: r149553", "tree": {"sha": "e09534cd9d79590d1e339f466ffb1b69ef387d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e09534cd9d79590d1e339f466ffb1b69ef387d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6f3943726b17627b823edc39ab0b33192427b2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f3943726b17627b823edc39ab0b33192427b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6f3943726b17627b823edc39ab0b33192427b2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f3943726b17627b823edc39ab0b33192427b2f/comments", "author": null, "committer": null, "parents": [{"sha": "d97a04d075dc49259a785e521e2ab6f42f522893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d97a04d075dc49259a785e521e2ab6f42f522893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d97a04d075dc49259a785e521e2ab6f42f522893"}], "stats": {"total": 519, "additions": 272, "deletions": 247}, "files": [{"sha": "4e3a58770ad33f3cb11a61e215ecb2827a45fcc2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f3943726b17627b823edc39ab0b33192427b2f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f3943726b17627b823edc39ab0b33192427b2f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c6f3943726b17627b823edc39ab0b33192427b2f", "patch": "@@ -1,3 +1,16 @@\n+2009-07-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_dist.adb (Add_RACW_Primitive_Declarations_And_Bodies):\n+\tDo not attempt to generate stubs for predefined primitives of\n+\tsynchronized interfaces.\n+\t(Add_Stub_Type): Factor some code from the PCS-specific variants of\n+\tBuild_Stub_Type.\n+\n+2009-07-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_disp.adb (Override_Dispatching_Operation): Functions inherit the\n+\tControlling_Result flag from the operation they override.\n+\n 2009-07-13  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies"}, {"sha": "744c0d4bc7ff2bfa0a6b6cd3bed1994964f1fa76", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 256, "deletions": 246, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f3943726b17627b823edc39ab0b33192427b2f/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f3943726b17627b823edc39ab0b33192427b2f/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=c6f3943726b17627b823edc39ab0b33192427b2f", "patch": "@@ -27,6 +27,7 @@ with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Atag; use Exp_Atag;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -55,17 +56,16 @@ with GNAT.HTable; use GNAT.HTable;\n package body Exp_Dist is\n \n    --  The following model has been used to implement distributed objects:\n-   --  given a designated type D and a RACW type R, then a record of the\n-   --  form:\n+   --  given a designated type D and a RACW type R, then a record of the form:\n \n    --    type Stub is tagged record\n    --       [...declaration similar to s-parint.ads RACW_Stub_Type...]\n    --    end record;\n \n    --  is built. This type has two properties:\n \n-   --    1) Since it has the same structure than RACW_Stub_Type, it can be\n-   --       converted to and from this type to make it suitable for\n+   --    1) Since it has the same structure than RACW_Stub_Type, it can\n+   --       be converted to and from this type to make it suitable for\n    --       System.Partition_Interface.Get_Unique_Remote_Pointer in order\n    --       to avoid memory leaks when the same remote object arrive on the\n    --       same partition through several paths;\n@@ -82,11 +82,10 @@ package body Exp_Dist is\n    --  RCI subprograms are numbered starting at 2. The RCI receiver for\n    --  an RCI package can thus identify calls received through remote\n    --  access-to-subprogram dereferences by the fact that they have a\n-   --  (primitive) subprogram id of 0, and 1 is used for the internal\n-   --  RAS information lookup operation. (This is for the Garlic code\n-   --  generation, where subprograms are identified by numbers; in the\n-   --  PolyORB version, they are identified by name, with a numeric suffix\n-   --  for homonyms.)\n+   --  (primitive) subprogram id of 0, and 1 is used for the internal RAS\n+   --  information lookup operation. (This is for the Garlic code generation,\n+   --  where subprograms are identified by numbers; in the PolyORB version,\n+   --  they are identified by name, with a numeric suffix for homonyms.)\n \n    type Hash_Index is range 0 .. 50;\n \n@@ -95,13 +94,13 @@ package body Exp_Dist is\n    -----------------------\n \n    function Hash (F : Entity_Id) return Hash_Index;\n-   --  DSA expansion associates stubs to distributed object types using\n-   --  a hash table on entity ids.\n+   --  DSA expansion associates stubs to distributed object types using a hash\n+   --  table on entity ids.\n \n    function Hash (F : Name_Id) return Hash_Index;\n    --  The generation of subprogram identifiers requires an overload counter\n-   --  to be associated with each remote subprogram names. These counters\n-   --  are maintained in a hash table on name ids.\n+   --  to be associated with each remote subprogram names. These counters are\n+   --  maintained in a hash table on name ids.\n \n    type Subprogram_Identifiers is record\n       Str_Identifier : String_Id;\n@@ -115,8 +114,8 @@ package body Exp_Dist is\n                          Key        => Entity_Id,\n                          Hash       => Hash,\n                          Equal      => \"=\");\n-   --  Mapping between a remote subprogram and the corresponding\n-   --  subprogram identifiers.\n+   --  Mapping between a remote subprogram and the corresponding subprogram\n+   --  identifiers.\n \n    package Overload_Counter_Table is\n       new Simple_HTable (Header_Num => Hash_Index,\n@@ -125,9 +124,9 @@ package body Exp_Dist is\n                          Key        => Name_Id,\n                          Hash       => Hash,\n                          Equal      => \"=\");\n-   --  Mapping between a subprogram name and an integer that\n-   --  counts the number of defining subprogram names with that\n-   --  Name_Id encountered so far in a given context (an interface).\n+   --  Mapping between a subprogram name and an integer that counts the number\n+   --  of defining subprogram names with that Name_Id encountered so far in a\n+   --  given context (an interface).\n \n    function Get_Subprogram_Ids (Def : Entity_Id) return Subprogram_Identifiers;\n    function Get_Subprogram_Id  (Def : Entity_Id) return String_Id;\n@@ -264,8 +263,8 @@ package body Exp_Dist is\n      (Loc           : Source_Ptr;\n       Prefix        : Entity_Id;\n       Selector_Name : Name_Id) return Node_Id;\n-   --  Return a selected_component whose prefix denotes the given entity,\n-   --  and with the given Selector_Name.\n+   --  Return a selected_component whose prefix denotes the given entity, and\n+   --  with the given Selector_Name.\n \n    function Scope_Of_Spec (Spec : Node_Id) return Entity_Id;\n    --  Return the scope represented by a given spec\n@@ -274,8 +273,8 @@ package body Exp_Dist is\n      (Typ     : Entity_Id;\n       Nam     : Entity_Id;\n       TSS_Nam : TSS_Name_Type);\n-   --  Create a renaming declaration of subprogram Nam,\n-   --  and register it as a TSS for Typ with name TSS_Nam.\n+   --  Create a renaming declaration of subprogram Nam, and register it as a\n+   --  TSS for Typ with name TSS_Nam.\n \n    function Need_Extra_Constrained (Parameter : Node_Id) return Boolean;\n    --  Return True if the current parameter needs an extra formal to reflect\n@@ -563,11 +562,10 @@ package body Exp_Dist is\n \n    procedure Specific_Build_Stub_Type\n      (RACW_Type         : Entity_Id;\n-      Stub_Type         : Entity_Id;\n-      Stub_Type_Decl    : out Node_Id;\n+      Stub_Type_Comps   : out List_Id;\n       RPC_Receiver_Decl : out Node_Id);\n-   --  Build a type declaration for the stub type associated with an RACW\n-   --  type, and the necessary RPC receiver, if applicable. PCS-specific\n+   --  Build a components list for the stub type associated with an RACW type,\n+   --  and build the necessary RPC receiver, if applicable. PCS-specific\n    --  ancillary subprogram for Add_Stub_Type. If no RPC receiver declaration\n    --  is generated, then RPC_Receiver_Decl is set to Empty.\n \n@@ -616,6 +614,10 @@ package body Exp_Dist is\n       Stmts    : List_Id);\n    --  Add receiving stubs to the declarative part of an RCI unit\n \n+   --------------------\n+   -- GARLIC_Support --\n+   --------------------\n+\n    package GARLIC_Support is\n \n       --  Support for generating DSA code that uses the GARLIC PCS\n@@ -657,8 +659,7 @@ package body Exp_Dist is\n \n       procedure Build_Stub_Type\n         (RACW_Type         : Entity_Id;\n-         Stub_Type         : Entity_Id;\n-         Stub_Type_Decl    : out Node_Id;\n+         Stub_Type_Comps   : out List_Id;\n          RPC_Receiver_Decl : out Node_Id);\n \n       function Build_Subprogram_Receiving_Stubs\n@@ -690,6 +691,10 @@ package body Exp_Dist is\n \n    end GARLIC_Support;\n \n+   ---------------------\n+   -- PolyORB_Support --\n+   ---------------------\n+\n    package PolyORB_Support is\n \n       --  Support for generating DSA code that uses the PolyORB PCS\n@@ -731,8 +736,7 @@ package body Exp_Dist is\n \n       procedure Build_Stub_Type\n         (RACW_Type         : Entity_Id;\n-         Stub_Type         : Entity_Id;\n-         Stub_Type_Decl    : out Node_Id;\n+         Stub_Type_Comps   : out List_Id;\n          RPC_Receiver_Decl : out Node_Id);\n \n       function Build_Subprogram_Receiving_Stubs\n@@ -769,6 +773,10 @@ package body Exp_Dist is\n       --  their methods to be accessed as objects, for the implementation of\n       --  remote access-to-subprogram types).\n \n+      -------------\n+      -- Helpers --\n+      -------------\n+\n       package Helpers is\n \n          --  Routines to build distribution helper subprograms for user-defined\n@@ -1146,7 +1154,6 @@ package body Exp_Dist is\n          end if;\n \n       else\n-\n          --  Case of declaring the RACW in another package than its designated\n          --  type: use the private declarations list if present; otherwise\n          --  use the visible declarations.\n@@ -1317,11 +1324,12 @@ package body Exp_Dist is\n                  Is_TSS (Current_Primitive, TSS_Stream_Input)  or else\n                  Is_TSS (Current_Primitive, TSS_Stream_Output) or else\n                  Is_TSS (Current_Primitive, TSS_Stream_Read)   or else\n-                 Is_TSS (Current_Primitive, TSS_Stream_Write))\n+                 Is_TSS (Current_Primitive, TSS_Stream_Write)  or else\n+                 Is_Predefined_Interface_Primitive (Current_Primitive))\n               and then not Is_Hidden (Current_Primitive)\n             then\n                --  The first thing to do is build an up-to-date copy of the\n-               --  spec with all the formals referencing Designated_Type\n+               --  spec with all the formals referencing Controlling_Type\n                --  transformed into formals referencing Stub_Type. Since this\n                --  primitive may have been inherited, go back the alias chain\n                --  until the real primitive has been found.\n@@ -1337,7 +1345,7 @@ package body Exp_Dist is\n                --  Copy the spec from the original declaration for the purpose\n                --  of declaring an overriding subprogram: we need to replace\n                --  the type of each controlling formal with Stub_Type. The\n-               --  primitive may have been declared for Designated_Type or\n+               --  primitive may have been declared for Controlling_Type or\n                --  inherited from some ancestor type for which we do not have\n                --  an easily determined Entity_Id. We have no systematic way\n                --  of knowing which type to substitute Stub_Type for. Instead,\n@@ -1858,8 +1866,9 @@ package body Exp_Dist is\n    is\n       Loc : constant Source_Ptr := Sloc (RACW_Type);\n \n-      Stub_Elements : constant Stub_Structure :=\n-                        Stubs_Table.Get (Designated_Type);\n+      Stub_Elements         : constant Stub_Structure :=\n+                                Stubs_Table.Get (Designated_Type);\n+      Stub_Type_Comps       : List_Id;\n       Stub_Type_Decl        : Node_Id;\n       Stub_Type_Access_Decl : Node_Id;\n \n@@ -1875,18 +1884,32 @@ package body Exp_Dist is\n \n       Existing := False;\n       Stub_Type :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_Internal_Name ('S'));\n+        Make_Defining_Identifier (Loc, Chars => New_Internal_Name ('S'));\n       Set_Ekind (Stub_Type, E_Record_Type);\n       Set_Is_RACW_Stub_Type (Stub_Type);\n       Stub_Type_Access :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_External_Name\n                      (Related_Id => Chars (Stub_Type), Suffix => 'A'));\n \n-      Specific_Build_Stub_Type\n-        (RACW_Type, Stub_Type,\n-         Stub_Type_Decl, RPC_Receiver_Decl);\n+      Specific_Build_Stub_Type (RACW_Type, Stub_Type_Comps, RPC_Receiver_Decl);\n+\n+      Stub_Type_Decl :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Stub_Type,\n+          Type_Definition     =>\n+            Make_Record_Definition (Loc,\n+              Tagged_Present  => True,\n+              Limited_Present => True,\n+              Component_List  =>\n+                Make_Component_List (Loc,\n+                  Component_Items => Stub_Type_Comps)));\n+\n+      --  Does the stub type need to explicitly implement interfaces from the\n+      --  designated type???\n+\n+      --  In particular are there issues in the case where the designated type\n+      --  is a synchronized interface???\n \n       Stub_Type_Access_Decl :=\n         Make_Full_Type_Declaration (Loc,\n@@ -1901,9 +1924,10 @@ package body Exp_Dist is\n       Append_To (Decls, Stub_Type_Access_Decl);\n       Analyze (Last (Decls));\n \n-      --  This is in no way a type derivation, but we fake it to make sure that\n-      --  the dispatching table gets built with the corresponding primitive\n-      --  operations at the right place.\n+      --  We can't directly derive the stub type from the designated type,\n+      --  because we don't want any components or discriminants from the real\n+      --  type, so instead we manually fake a derivation to get an appropriate\n+      --  dispatch table.\n \n       Derive_Subprograms (Parent_Type  => Designated_Type,\n                           Derived_Type => Stub_Type);\n@@ -1930,6 +1954,7 @@ package body Exp_Dist is\n \n    procedure Append_RACW_Bodies (Decls : List_Id; Spec_Id : Entity_Id) is\n       E : Entity_Id;\n+\n    begin\n       E := First_Entity (Spec_Id);\n       while Present (E) loop\n@@ -1960,10 +1985,9 @@ package body Exp_Dist is\n \n       Get_Name_String (N);\n \n-      --  Homonym handling: as in Exp_Dbug, but much simpler,\n-      --  because the only entities for which we have to generate\n-      --  names here need only to be disambiguated within their\n-      --  own scope.\n+      --  Homonym handling: as in Exp_Dbug, but much simpler, because the only\n+      --  entities for which we have to generate names here need only to be\n+      --  disambiguated within their own scope.\n \n       if Overload_Order > 1 then\n          Name_Buffer (Name_Len + 1 .. Name_Len + 2) := \"__\";\n@@ -1972,8 +1996,9 @@ package body Exp_Dist is\n       end if;\n \n       Id := String_From_Name_Buffer;\n-      Subprogram_Identifier_Table.Set (Def,\n-        Subprogram_Identifiers'(Str_Identifier => Id, Int_Identifier => Spn));\n+      Subprogram_Identifier_Table.Set\n+        (Def,\n+         Subprogram_Identifiers'(Str_Identifier => Id, Int_Identifier => Spn));\n    end Assign_Subprogram_Identifier;\n \n    -------------------------------------\n@@ -1988,6 +2013,7 @@ package body Exp_Dist is\n       Decls    : List_Id)\n    is\n       Loc : constant Source_Ptr := Sloc (Object);\n+\n    begin\n       --  Declare a temporary object for the actual, possibly initialized with\n       --  a 'Input/From_Any call.\n@@ -2071,7 +2097,6 @@ package body Exp_Dist is\n          end if;\n \n       else\n-\n          --  General case of a regular object declaration. Object is flagged\n          --  constant unless it has mode out or in out, to allow the backend\n          --  to optimize where possible.\n@@ -4084,8 +4109,8 @@ package body Exp_Dist is\n          Loc : constant Source_Ptr := Sloc (Nod);\n \n          Stream_Parameter : Node_Id;\n-         --  Name of the stream used to transmit parameters to the\n-         --  remote package.\n+         --  Name of the stream used to transmit parameters to the remote\n+         --  package.\n \n          Result_Parameter : Node_Id;\n          --  Name of the result parameter (in non-APC cases) which get the\n@@ -4410,8 +4435,8 @@ package body Exp_Dist is\n             else\n                --  Loop around parameters and assign out (or in out)\n                --  parameters. In the case of RACW, controlling arguments\n-               --  cannot possibly have changed since they are remote, so we do\n-               --  not read them from the stream.\n+               --  cannot possibly have changed since they are remote, so\n+               --  we do not read them from the stream.\n \n                Current_Parameter := First (Ordered_Parameters_List);\n                while Present (Current_Parameter) loop\n@@ -4619,62 +4644,49 @@ package body Exp_Dist is\n \n       procedure Build_Stub_Type\n         (RACW_Type         : Entity_Id;\n-         Stub_Type         : Entity_Id;\n-         Stub_Type_Decl    : out Node_Id;\n+         Stub_Type_Comps   : out List_Id;\n          RPC_Receiver_Decl : out Node_Id)\n       is\n-         Loc    : constant Source_Ptr := Sloc (Stub_Type);\n+         Loc    : constant Source_Ptr := Sloc (RACW_Type);\n          Is_RAS : constant Boolean    := not Comes_From_Source (RACW_Type);\n \n       begin\n-         Stub_Type_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Stub_Type,\n-             Type_Definition     =>\n-               Make_Record_Definition (Loc,\n-                 Tagged_Present  => True,\n-                 Limited_Present => True,\n-                 Component_List  =>\n-                   Make_Component_List (Loc,\n-                     Component_Items => New_List (\n-\n-                       Make_Component_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc, Name_Origin),\n-                         Component_Definition =>\n-                           Make_Component_Definition (Loc,\n-                             Aliased_Present    => False,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (\n-                                 RTE (RE_Partition_ID), Loc))),\n-\n-                       Make_Component_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc, Name_Receiver),\n-                         Component_Definition =>\n-                           Make_Component_Definition (Loc,\n-                             Aliased_Present    => False,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n-\n-                       Make_Component_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc, Name_Addr),\n-                         Component_Definition =>\n-                           Make_Component_Definition (Loc,\n-                             Aliased_Present    => False,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n-\n-                       Make_Component_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc, Name_Asynchronous),\n-                         Component_Definition =>\n-                           Make_Component_Definition (Loc,\n-                             Aliased_Present    => False,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (\n-                                 Standard_Boolean, Loc)))))));\n+         Stub_Type_Comps := New_List (\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_Origin),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (RTE (RE_Partition_ID), Loc))),\n+\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_Receiver),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n+\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_Addr),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (RTE (RE_Unsigned_64), Loc))),\n+\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_Asynchronous),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (Standard_Boolean, Loc))));\n \n          if Is_RAS then\n             RPC_Receiver_Decl := Empty;\n@@ -5193,7 +5205,9 @@ package body Exp_Dist is\n    -------------------------------\n \n    function Get_And_Reset_RACW_Bodies (RACW_Type : Entity_Id) return List_Id is\n-      Desig : constant Entity_Id := Etype (Designated_Type (RACW_Type));\n+      Desig         : constant Entity_Id :=\n+                        Etype (Designated_Type (RACW_Type));\n+\n       Stub_Elements : Stub_Structure := Stubs_Table.Get (Desig);\n \n       Body_Decls : List_Id;\n@@ -5311,15 +5325,15 @@ package body Exp_Dist is\n       Typ : Entity_Id;\n \n    begin\n-      --  If the kind of the parameter is E_Void, then it is not a\n-      --  controlling formal (this can happen in the context of RAS).\n+      --  If the kind of the parameter is E_Void, then it is not a controlling\n+      --  formal (this can happen in the context of RAS).\n \n       if Ekind (Defining_Identifier (Parameter)) = E_Void then\n          return False;\n       end if;\n \n-      --  If the parameter is not a controlling formal, then it cannot\n-      --  be possibly a RACW_Controlling_Formal.\n+      --  If the parameter is not a controlling formal, then it cannot be\n+      --  possibly a RACW_Controlling_Formal.\n \n       if not Is_Controlling_Formal (Defining_Identifier (Parameter)) then\n          return False;\n@@ -5636,7 +5650,6 @@ package body Exp_Dist is\n       is\n          Loc    : constant Source_Ptr := Sloc (RACW_Type);\n          Is_RAS : constant Boolean := not Comes_From_Source (RACW_Type);\n-\n          Fnam   : constant Entity_Id :=\n                     Make_Defining_Identifier (Loc,\n                       Chars => New_External_Name (Chars (RACW_Type), 'F'));\n@@ -5648,8 +5661,8 @@ package body Exp_Dist is\n          Statements       : List_Id;\n          --  Various parts of the subprogram\n \n-         Any_Parameter  : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc, Name_A);\n+         Any_Parameter : constant Entity_Id :=\n+                           Make_Defining_Identifier (Loc, Name_A);\n \n          Asynchronous_Flag : constant Entity_Id :=\n                                Asynchronous_Flags_Table.Get (RACW_Type);\n@@ -5852,19 +5865,17 @@ package body Exp_Dist is\n          Func_Decl : Node_Id;\n          Func_Body : Node_Id;\n \n-         Decls             : List_Id;\n-         Statements        : List_Id;\n+         Decls      : List_Id;\n+         Statements : List_Id;\n          --  Various parts of the subprogram\n \n          RACW_Parameter : constant Entity_Id :=\n                             Make_Defining_Identifier (Loc, Name_R);\n \n-         Reference         : constant Entity_Id :=\n-                               Make_Defining_Identifier\n-                                 (Loc, New_Internal_Name ('R'));\n-         Any               : constant Entity_Id :=\n-                               Make_Defining_Identifier\n-                                 (Loc, New_Internal_Name ('A'));\n+         Reference : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+         Any       : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n \n       begin\n          Func_Spec :=\n@@ -5992,7 +6003,6 @@ package body Exp_Dist is\n          Func_Body : Node_Id;\n \n       begin\n-\n          --  The spec for this subprogram has a dummy 'access RACW' argument,\n          --  which serves only for overloading purposes.\n \n@@ -6314,14 +6324,14 @@ package body Exp_Dist is\n \n          Append_To (Proc_Statements,\n \n-         --  if L then\n+           --  if L then\n \n            Make_Implicit_If_Statement (N,\n              Condition => New_Occurrence_Of (Is_Local, Loc),\n \n              Then_Statements => New_List (\n \n-         --     if A.Target = null then\n+               --  if A.Target = null then\n \n                Make_Implicit_If_Statement (N,\n                  Condition =>\n@@ -6336,7 +6346,7 @@ package body Exp_Dist is\n \n                  Then_Statements => New_List (\n \n-         --        A.Target := Entity_Of (Ref);\n+                   --    A.Target := Entity_Of (Ref);\n \n                    Make_Assignment_Statement (Loc,\n                      Name =>\n@@ -6352,7 +6362,8 @@ package body Exp_Dist is\n                          Parameter_Associations => New_List (\n                            New_Occurrence_Of (Subp_Ref, Loc)))),\n \n-         --        Inc_Usage (A.Target);\n+                   --    Inc_Usage (A.Target);\n+                   --  end if;\n \n                    Make_Procedure_Call_Statement (Loc,\n                      Name => New_Occurrence_Of (RTE (RE_Inc_Usage), Loc),\n@@ -6365,10 +6376,9 @@ package body Exp_Dist is\n                          Selector_Name =>\n                            Make_Identifier (Loc, Name_Target)))))),\n \n-         --     end if;\n-         --     if not All_Calls_Remote then\n-         --        return Fat_Type!(A);\n-         --     end if;\n+                 --     if not All_Calls_Remote then\n+                 --        return Fat_Type!(A);\n+                 --     end if;\n \n                  Make_Implicit_If_Statement (N,\n                    Condition =>\n@@ -6384,15 +6394,15 @@ package body Exp_Dist is\n \n          Append_List_To (Proc_Statements, New_List (\n \n-         --  Stub.Target := Entity_Of (Ref);\n+           --  Stub.Target := Entity_Of (Ref);\n \n            Set_Field (Name_Target,\n              Make_Function_Call (Loc,\n                Name => New_Occurrence_Of (RTE (RE_Entity_Of), Loc),\n                Parameter_Associations => New_List (\n                  New_Occurrence_Of (Subp_Ref, Loc)))),\n \n-         --  Inc_Usage (Stub.Target);\n+           --  Inc_Usage (Stub.Target);\n \n            Make_Procedure_Call_Statement (Loc,\n              Name => New_Occurrence_Of (RTE (RE_Inc_Usage), Loc),\n@@ -6401,12 +6411,12 @@ package body Exp_Dist is\n                  Prefix        => Stub_Ptr,\n                  Selector_Name => Name_Target))),\n \n-         --  E.4.1(9) A remote call is asynchronous if it is a call to\n-         --  a procedure, or a call through a value of an access-to-procedure\n-         --  type, to which a pragma Asynchronous applies.\n+           --  E.4.1(9) A remote call is asynchronous if it is a call to\n+           --  a procedure, or a call through a value of an access-to-procedure\n+           --  type, to which a pragma Asynchronous applies.\n \n-         --    Parameter Asynch_P is true when the procedure is asynchronous;\n-         --    Expression Asynch_T is true when the type is asynchronous.\n+           --    Parameter Asynch_P is true when the procedure is asynchronous;\n+           --    Expression Asynch_T is true when the type is asynchronous.\n \n            Set_Field (Name_Asynchronous,\n              Make_Or_Else (Loc,\n@@ -6669,8 +6679,8 @@ package body Exp_Dist is\n          --  Request object received from neutral layer\n \n          Subp_Id : Entity_Id;\n-         --  Subprogram identifier as received from the neutral\n-         --  distribution core.\n+         --  Subprogram identifier as received from the neutral distribution\n+         --  core.\n \n          Subp_Index : Entity_Id;\n          --  Internal index as determined by matching either the method name\n@@ -6787,9 +6797,9 @@ package body Exp_Dist is\n       begin\n          --  Building receiving stubs consist in several operations:\n \n-         --    - a package RPC receiver must be built. This subprogram\n-         --      will get a Subprogram_Id from the incoming stream\n-         --      and will dispatch the call to the right subprogram;\n+         --    - a package RPC receiver must be built. This subprogram will get\n+         --      a Subprogram_Id from the incoming stream and will dispatch the\n+         --      call to the right subprogram;\n \n          --    - a receiving stub for each subprogram visible in the package\n          --      spec. This stub will read all the parameters from the stream,\n@@ -6837,9 +6847,9 @@ package body Exp_Dist is\n                New_Occurrence_Of (Is_Local, Loc),\n                New_Occurrence_Of (Local_Address, Loc))));\n \n-         --  For each subprogram, the receiving stub will be built and a\n-         --  case statement will be made on the Subprogram_Id to dispatch\n-         --  to the right subprogram.\n+         --  For each subprogram, the receiving stub will be built and a case\n+         --  statement will be made on the Subprogram_Id to dispatch to the\n+         --  right subprogram.\n \n          All_Calls_Remote_E := Boolean_Literals (\n            Has_All_Calls_Remote (Defining_Entity (Pkg_Spec)));\n@@ -7615,44 +7625,31 @@ package body Exp_Dist is\n \n       procedure Build_Stub_Type\n         (RACW_Type         : Entity_Id;\n-         Stub_Type         : Entity_Id;\n-         Stub_Type_Decl    : out Node_Id;\n+         Stub_Type_Comps   : out List_Id;\n          RPC_Receiver_Decl : out Node_Id)\n       is\n-         Loc : constant Source_Ptr := Sloc (Stub_Type);\n-\n-         pragma Unreferenced (RACW_Type);\n+         Loc : constant Source_Ptr := Sloc (RACW_Type);\n \n       begin\n-         Stub_Type_Decl :=\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Stub_Type,\n-             Type_Definition     =>\n-               Make_Record_Definition (Loc,\n-                 Tagged_Present  => True,\n-                 Limited_Present => True,\n-                 Component_List  =>\n-                   Make_Component_List (Loc,\n-                     Component_Items => New_List (\n-\n-                       Make_Component_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc, Name_Target),\n-                         Component_Definition =>\n-                           Make_Component_Definition (Loc,\n-                             Aliased_Present     => False,\n-                             Subtype_Indication  =>\n-                               New_Occurrence_Of (RTE (RE_Entity_Ptr), Loc))),\n-\n-                       Make_Component_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc, Name_Asynchronous),\n-\n-                         Component_Definition =>\n-                           Make_Component_Definition (Loc,\n-                             Aliased_Present    => False,\n-                             Subtype_Indication =>\n-                               New_Occurrence_Of (Standard_Boolean, Loc)))))));\n+         Stub_Type_Comps := New_List (\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_Target),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present     => False,\n+                 Subtype_Indication  =>\n+                   New_Occurrence_Of (RTE (RE_Entity_Ptr), Loc))),\n+\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_Asynchronous),\n+\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (Standard_Boolean, Loc))));\n \n          RPC_Receiver_Decl :=\n            Make_Object_Declaration (Loc,\n@@ -7758,8 +7755,8 @@ package body Exp_Dist is\n \n          Decls : constant List_Id := New_List;\n          --  All the parameters will get declared before calling the real\n-         --  subprograms. Also the out parameters will be declared.\n-         --  At this level, parameters may be unconstrained.\n+         --  subprograms. Also the out parameters will be declared. At this\n+         --  level, parameters may be unconstrained.\n \n          Statements : constant List_Id := New_List;\n \n@@ -7835,8 +7832,10 @@ package body Exp_Dist is\n \n                   --  Controlling formals in distributed object primitive\n                   --  operations are handled specially:\n+\n                   --    - the first controlling formal is used as the\n                   --      target of the call;\n+\n                   --    - the remaining controlling formals are transmitted\n                   --      as RACWs.\n \n@@ -7932,20 +7931,22 @@ package body Exp_Dist is\n                   --  the object declaration and the variable is set using\n                   --  'Input instead of 'Read.\n \n-                  Expr := PolyORB_Support.Helpers.Build_From_Any_Call (\n-                            Etyp, New_Occurrence_Of (Any, Loc), Decls);\n+                  Expr :=\n+                    PolyORB_Support.Helpers.Build_From_Any_Call\n+                      (Etyp, New_Occurrence_Of (Any, Loc), Decls);\n \n                   if Constrained then\n                      Append_To (Statements,\n                        Make_Assignment_Statement (Loc,\n                          Name       => New_Occurrence_Of (Object, Loc),\n                          Expression => Expr));\n                      Expr := Empty;\n-                  else\n-                     null;\n \n+                  else\n                      --  Expr will be used to initialize (and constrain) the\n                      --  parameter when it is declared.\n+\n+                     null;\n                   end if;\n \n                end if;\n@@ -8006,10 +8007,7 @@ package body Exp_Dist is\n                              (Defining_Identifier (Current_Parameter), Loc),\n                          Explicit_Actual_Parameter =>\n                            Make_Explicit_Dereference (Loc,\n-                             Prefix =>\n-                               Unchecked_Convert_To (RACW_Type,\n-                                 OK_Convert_To (RTE (RE_Address),\n-                                   New_Occurrence_Of (Object, Loc))))));\n+                             Prefix => New_Occurrence_Of (Object, Loc))));\n \n                   else\n                      Append_To (Parameter_List,\n@@ -8019,9 +8017,7 @@ package body Exp_Dist is\n                              (Defining_Identifier (Current_Parameter), Loc),\n \n                          Explicit_Actual_Parameter =>\n-                           Unchecked_Convert_To (RACW_Type,\n-                             OK_Convert_To (RTE (RE_Address),\n-                               New_Occurrence_Of (Object, Loc)))));\n+                           New_Occurrence_Of (Object, Loc)));\n                   end if;\n \n                else\n@@ -8201,10 +8197,10 @@ package body Exp_Dist is\n                  Parameter_Type      =>\n                    New_Occurrence_Of (RTE (RE_Request_Access), Loc))));\n \n-         --  An exception raised during the execution of an incoming\n-         --  remote subprogram call and that needs to be sent back\n-         --  to the caller is propagated by the receiving stubs, and\n-         --  will be handled by the caller (the distribution runtime).\n+         --  An exception raised during the execution of an incoming remote\n+         --  subprogram call and that needs to be sent back to the caller is\n+         --  propagated by the receiving stubs, and will be handled by the\n+         --  caller (the distribution runtime).\n \n          if Asynchronous and then not Dynamically_Asynchronous then\n \n@@ -8648,6 +8644,7 @@ package body Exp_Dist is\n                                    New_Occurrence_Of (Rec, Loc),\n                                  Selector_Name =>\n                                    New_Occurrence_Of (Field, Loc)),\n+\n                                Expression =>\n                                  Build_From_Any_Call (Etype (Field),\n                                    Build_Get_Aggregate_Element (Loc,\n@@ -9290,11 +9287,11 @@ package body Exp_Dist is\n          is\n             Loc : constant Source_Ptr := Sloc (N);\n \n-            Typ     : Entity_Id := Etype (N);\n-            U_Type  : Entity_Id;\n-            C_Type  : Entity_Id;\n-            Fnam    : Entity_Id := Empty;\n-            Lib_RE  : RE_Id := RE_Null;\n+            Typ    : Entity_Id := Etype (N);\n+            U_Type : Entity_Id;\n+            C_Type : Entity_Id;\n+            Fnam   : Entity_Id := Empty;\n+            Lib_RE : RE_Id := RE_Null;\n \n          begin\n             --  If N is a selected component, then maybe its Etype has not been\n@@ -9303,6 +9300,7 @@ package body Exp_Dist is\n             if No (Typ) and then Nkind (N) = N_Selected_Component then\n                Typ := Etype (Selector_Name (N));\n             end if;\n+\n             pragma Assert (Present (Typ));\n \n             --  Get full view for private type, completion for incomplete type\n@@ -9731,19 +9729,19 @@ package body Exp_Dist is\n \n                                  Struct_Counter := 0;\n \n-                                 TA_Append_Record_Traversal (\n-                                   Stmts     => VP_Stmts,\n-                                   Clist     => Component_List (Variant),\n-                                   Container => Struct_Any,\n-                                   Counter   => Struct_Counter);\n+                                 TA_Append_Record_Traversal\n+                                   (Stmts     => VP_Stmts,\n+                                    Clist     => Component_List (Variant),\n+                                    Container => Struct_Any,\n+                                    Counter   => Struct_Counter);\n \n                                  --  Append inner struct to union aggregate\n \n                                  Append_To (VP_Stmts,\n                                    Make_Procedure_Call_Statement (Loc,\n                                      Name =>\n-                                       New_Occurrence_Of (\n-                                         RTE (RE_Add_Aggregate_Element), Loc),\n+                                       New_Occurrence_Of\n+                                         (RTE (RE_Add_Aggregate_Element), Loc),\n                                      Parameter_Associations => New_List (\n                                        New_Occurrence_Of (Union_Any, Loc),\n                                        New_Occurrence_Of (Struct_Any, Loc))));\n@@ -9753,8 +9751,8 @@ package body Exp_Dist is\n                                  Append_To (VP_Stmts,\n                                    Make_Procedure_Call_Statement (Loc,\n                                      Name =>\n-                                       New_Occurrence_Of (\n-                                         RTE (RE_Add_Aggregate_Element), Loc),\n+                                       New_Occurrence_Of\n+                                         (RTE (RE_Add_Aggregate_Element), Loc),\n                                        Parameter_Associations => New_List (\n                                           New_Occurrence_Of (Container, Loc),\n                                           New_Occurrence_Of\n@@ -9860,8 +9858,8 @@ package body Exp_Dist is\n \n                      Set_Expression (Any_Decl,\n                        Make_Function_Call (Loc,\n-                         Name => New_Occurrence_Of (\n-                                   RTE (RE_Any_Aggregate_Build), Loc),\n+                         Name => New_Occurrence_Of\n+                                   (RTE (RE_Any_Aggregate_Build), Loc),\n                          Parameter_Associations => New_List (\n                            Result_TC,\n                            Make_Aggregate (Loc,\n@@ -10993,6 +10991,7 @@ package body Exp_Dist is\n                          Name => New_Occurrence_Of (RTE (RE_Get_TC), Loc),\n                          Parameter_Associations => New_List (\n                            New_Occurrence_Of (Any, Loc)));\n+\n                   else\n                      Inner_Any_TypeCode_Expr :=\n                        Make_Function_Call (Loc,\n@@ -11002,6 +11001,7 @@ package body Exp_Dist is\n                                New_Occurrence_Of (Any, Loc),\n                                Make_Integer_Literal (Loc, Ndim)));\n                   end if;\n+\n                else\n                   Inner_Any_TypeCode_Expr :=\n                     Make_Function_Call (Loc,\n@@ -11161,16 +11161,20 @@ package body Exp_Dist is\n       Inst :=\n         Make_Package_Instantiation (Loc,\n           Defining_Unit_Name   =>\n-            Make_Defining_Identifier (Loc, New_Internal_Name ('R')),\n+            Make_Defining_Identifier (Loc,\n+              Chars => New_Internal_Name ('R')),\n+\n           Name                 =>\n             New_Occurrence_Of (RTE (RE_RCI_Locator), Loc),\n+\n           Generic_Associations => New_List (\n             Make_Generic_Association (Loc,\n               Selector_Name                     =>\n                 Make_Identifier (Loc, Name_RCI_Name),\n               Explicit_Generic_Actual_Parameter =>\n                 Make_String_Literal (Loc,\n                   Strval => Pkg_Name)),\n+\n             Make_Generic_Association (Loc,\n               Selector_Name                     =>\n                 Make_Identifier (Loc, Name_Version),\n@@ -11181,8 +11185,9 @@ package body Exp_Dist is\n                   Attribute_Name =>\n                     Name_Version))));\n \n-      RCI_Locator_Table.Set (Defining_Unit_Name (Package_Spec),\n-        Defining_Unit_Name (Inst));\n+      RCI_Locator_Table.Set\n+        (Defining_Unit_Name (Package_Spec),\n+         Defining_Unit_Name (Inst));\n       return Inst;\n    end RCI_Package_Locator;\n \n@@ -11292,11 +11297,11 @@ package body Exp_Dist is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n-            PolyORB_Support.Add_Obj_RPC_Receiver_Completion (Loc,\n-              Decls, RPC_Receiver, Stub_Elements);\n+            PolyORB_Support.Add_Obj_RPC_Receiver_Completion\n+              (Loc, Decls, RPC_Receiver, Stub_Elements);\n          when others =>\n-            GARLIC_Support.Add_Obj_RPC_Receiver_Completion (Loc,\n-              Decls, RPC_Receiver, Stub_Elements);\n+            GARLIC_Support.Add_Obj_RPC_Receiver_Completion\n+              (Loc, Decls, RPC_Receiver, Stub_Elements);\n       end case;\n    end Specific_Add_Obj_RPC_Receiver_Completion;\n \n@@ -11470,12 +11475,14 @@ package body Exp_Dist is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n-            return PolyORB_Support.Build_Stub_Target (Loc,\n-                     Decls, RCI_Locator, Controlling_Parameter);\n+            return\n+              PolyORB_Support.Build_Stub_Target\n+                (Loc, Decls, RCI_Locator, Controlling_Parameter);\n \n          when others =>\n-            return GARLIC_Support.Build_Stub_Target (Loc,\n-                     Decls, RCI_Locator, Controlling_Parameter);\n+            return\n+              GARLIC_Support.Build_Stub_Target\n+                (Loc, Decls, RCI_Locator, Controlling_Parameter);\n       end case;\n    end Specific_Build_Stub_Target;\n \n@@ -11485,24 +11492,25 @@ package body Exp_Dist is\n \n    procedure Specific_Build_Stub_Type\n      (RACW_Type         : Entity_Id;\n-      Stub_Type         : Entity_Id;\n-      Stub_Type_Decl    : out Node_Id;\n+      Stub_Type_Comps   : out List_Id;\n       RPC_Receiver_Decl : out Node_Id)\n    is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n-            PolyORB_Support.Build_Stub_Type (\n-              RACW_Type, Stub_Type,\n-              Stub_Type_Decl, RPC_Receiver_Decl);\n+            PolyORB_Support.Build_Stub_Type\n+              (RACW_Type, Stub_Type_Comps, RPC_Receiver_Decl);\n \n          when others =>\n-            GARLIC_Support.Build_Stub_Type (\n-              RACW_Type, Stub_Type,\n-              Stub_Type_Decl, RPC_Receiver_Decl);\n+            GARLIC_Support.Build_Stub_Type\n+              (RACW_Type, Stub_Type_Comps, RPC_Receiver_Decl);\n       end case;\n    end Specific_Build_Stub_Type;\n \n+   -----------------------------------------------\n+   -- Specific_Build_Subprogram_Receiving_Stubs --\n+   -----------------------------------------------\n+\n    function Specific_Build_Subprogram_Receiving_Stubs\n      (Vis_Decl                 : Node_Id;\n       Asynchronous             : Boolean;\n@@ -11514,22 +11522,24 @@ package body Exp_Dist is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n-            return PolyORB_Support.Build_Subprogram_Receiving_Stubs\n-                     (Vis_Decl,\n-                      Asynchronous,\n-                      Dynamically_Asynchronous,\n-                      Stub_Type,\n-                      RACW_Type,\n-                      Parent_Primitive);\n+            return\n+              PolyORB_Support.Build_Subprogram_Receiving_Stubs\n+                (Vis_Decl,\n+                 Asynchronous,\n+                 Dynamically_Asynchronous,\n+                 Stub_Type,\n+                 RACW_Type,\n+                 Parent_Primitive);\n \n          when others =>\n-            return GARLIC_Support.Build_Subprogram_Receiving_Stubs\n-                     (Vis_Decl,\n-                      Asynchronous,\n-                      Dynamically_Asynchronous,\n-                      Stub_Type,\n-                      RACW_Type,\n-                      Parent_Primitive);\n+            return\n+              GARLIC_Support.Build_Subprogram_Receiving_Stubs\n+                (Vis_Decl,\n+                 Asynchronous,\n+                 Dynamically_Asynchronous,\n+                 Stub_Type,\n+                 RACW_Type,\n+                 Parent_Primitive);\n       end case;\n    end Specific_Build_Subprogram_Receiving_Stubs;\n "}, {"sha": "f64df6f982363f025ecbb5d2ad0b42ea8ef6269d", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f3943726b17627b823edc39ab0b33192427b2f/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f3943726b17627b823edc39ab0b33192427b2f/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=c6f3943726b17627b823edc39ab0b33192427b2f", "patch": "@@ -1775,10 +1775,12 @@ package body Sem_Disp is\n          --  even if non-dispatching, and a call from inside calls the\n          --  overriding operation because it hides the implicit one. To\n          --  indicate that the body of Prev_Op is never called, set its\n-         --  dispatch table entity to Empty.\n+         --  dispatch table entity to Empty. If the overridden operation\n+         --  has a dispatching result, so does the overriding one.\n \n          Set_Alias (Prev_Op, New_Op);\n          Set_DTC_Entity (Prev_Op, Empty);\n+         Set_Has_Controlling_Result (New_Op, Has_Controlling_Result (Prev_Op));\n          return;\n       end if;\n    end Override_Dispatching_Operation;"}]}