{"sha": "be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU1ZmZjNTlhZDg4YzVjZDFjZjZmNTY4ZWM3MzAwMTIyOGNmMjhkNQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2014-11-06T21:08:52Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2014-11-06T21:08:52Z"}, "message": "Preserve original spellings of extended identifiers.\n\nThis patch makes cpplib track the original spellings of extended\nidentifiers, as well as the canonical UTF-8 version, in order to\nfollow standard semantics properly without needing a convoluted and\nundocumented canonicalization in translation phase 1 (see bug 9449\ncomments 39-46 regarding such a canonicalization).\n\nThe spelling is tracked in cpp_identifier and cpp_macro_arg without\nmaking cpp_token any larger.  The original spelling is used for checks\nof duplicate macro definitions, stringizing (see the C++ tests added;\nthis case is only an issue for C++ not C because C makes it\nimplementation-defined whether a \\ is inserted before the \\ of a UCN\nin a string or character constant when stringizing, while C++ does\nnot), pasting (relevant when the result is then stringized for C++)\nand when macro definitions are output as text (e.g. for -d options).\n\nOnce a macro has been defined, only the original spelling of the\nargument names needs keeping in the argument list.  While it is being\ndefined, however, both spellings are needed: the original one for\nsubsequent saving for checks of duplicate macro definitions, and the\ncanonical one which is the node marked specially to generate macro\nargument tokens rather than normal identifier tokens.  The buffer that\nis used to save the original values of the identifier tokens is\nchanged so that it stores both those original values and a pointer to\nthe canonical hash nodes, so that those canonical nodes can be found\nwhen their values need restoring after the macro definition has been\nparsed.\n\nI believe this covers the known standards issues in extended\nidentifiers support (the remaining unimplemented C99 areas in GCC all\nbeing floating-point-related), except for C++ translation of extended\ncharacters to UCNs in phase 1 (which I have no plans to work on).\nThere are however probably issues left with handling of extended\nidentifiers in other places, as listed in\n<https://gcc.gnu.org/ml/gcc-patches/2014-11/msg00337.html> (those\nissues are generally the sort of thing that could be addressed as bugs\noutside development stage 1).  (The bulk of the potential issues Zack\nwas concerned about in 2003-5, that resulted in extended identifiers\nbeing disabled in the absence of -fextended-identifiers, were\neffectively eliminated by the audit and fixes I did in 2009, however;\nthat todo list reflects what was left over after that audit.)\n\nBootstrapped with no regressions on x86_64-unknown-linux-gnu.\n\nlibcpp:\n\t* include/cpp-id-data.h (struct cpp_macro): Update comment\n\tregarding parameters.\n\t* include/cpplib.h (struct cpp_macro_arg, struct cpp_identifier):\n\tAdd spelling fields.\n\t(struct cpp_token): Update comment on macro_arg.\n\t* internal.h (_cpp_save_parameter): Add extra argument.\n\t(_cpp_spell_ident_ucns): New declaration.\n\t* lex.c (lex_identifier): Add SPELLING argument.  Set *SPELLING to\n\toriginal spelling of identifier.\n\t(_cpp_lex_direct): Update calls to lex_identifier.\n\t(_cpp_spell_ident_ucns): New function, factored out of\n\tcpp_spell_token.\n\t(cpp_spell_token): Adjust FORSTRING argument semantics to return\n\toriginal spelling of identifiers.  Use _cpp_spell_ident_ucns in\n\t!FORSTRING case.\n\t(_cpp_equiv_tokens): Check spellings of identifiers and macro\n\targuments are identical.\n\t* macro.c (macro_arg_saved_data): New structure.\n\t(paste_tokens): Use original spellings of identifiers from\n\tcpp_spell_token.\n\t(_cpp_save_parameter): Add argument SPELLING.  Save both canonical\n\tnode and its value.\n\t(parse_params): Update calls to _cpp_save_parameter.\n\t(lex_expansion_token): Save spelling of macro argument tokens.\n\t(_cpp_create_definition): Extract canonical node from saved data.\n\t(cpp_macro_definition): Use UCNs in spelling of macro name.  Use\n\toriginal spellings of macro argument tokens and identifiers.\n\t* traditional.c (scan_parameters): Update call to\n\t_cpp_save_parameter.\n\ngcc:\n\t* doc/invoke.texi (-std=c99, -std=c11): Don't refer to corner\n\tcases of extended identifiers.\n\ngcc/testsuite:\n\t* g++.dg/cpp/ucnid-2.C, g++.dg/cpp/ucnid-3.C,\n\tgcc.dg/cpp/ucnid-11.c, gcc.dg/cpp/ucnid-12.c,\n\tgcc.dg/cpp/ucnid-13.c, gcc.dg/cpp/ucnid-14.c,\n\tgcc.dg/cpp/ucnid-15.c: New tests.\n\nFrom-SVN: r217202", "tree": {"sha": "d1827c82a91ebb41554320d1b791e364d6dd406d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1827c82a91ebb41554320d1b791e364d6dd406d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1b0141be5581d0795c3369dcb9eaf27abe35f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1b0141be5581d0795c3369dcb9eaf27abe35f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f1b0141be5581d0795c3369dcb9eaf27abe35f7"}], "stats": {"total": 289, "additions": 240, "deletions": 49}, "files": [{"sha": "320e0d634e0333b268a97d1ac1bd335d60f1b4f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -1,3 +1,8 @@\n+2014-11-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* doc/invoke.texi (-std=c99, -std=c11): Don't refer to corner\n+\tcases of extended identifiers.\n+\n 2014-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-cfgcleanup.c (fixup_noreturn_call): Do not perform DCE here."}, {"sha": "0819804b4c9d6ef6e55994fb8c916320d4c5ad42", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -1674,7 +1674,7 @@ ISO C90 as modified in amendment 1.\n @itemx iso9899:1999\n @itemx iso9899:199x\n ISO C99.  This standard is substantially completely supported, modulo\n-bugs, corner cases of extended identifiers and floating-point issues\n+bugs and floating-point issues\n (mainly but not entirely relating to optional C99 features from\n Annexes F and G).  See\n @w{@uref{http://gcc.gnu.org/c99status.html}} for more information.  The\n@@ -1684,8 +1684,7 @@ names @samp{c9x} and @samp{iso9899:199x} are deprecated.\n @itemx c1x\n @itemx iso9899:2011\n ISO C11, the 2011 revision of the ISO C standard.  This standard is\n-substantially completely supported, modulo bugs, corner cases of\n-extended identifiers, floating-point issues\n+substantially completely supported, modulo bugs, floating-point issues\n (mainly but not entirely relating to optional C11 features from\n Annexes F and G) and the optional Annexes K (Bounds-checking\n interfaces) and L (Analyzability).  The name @samp{c1x} is deprecated."}, {"sha": "b1397f18d56fbc45be0d1373b8c5cf908f2471b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -1,3 +1,10 @@\n+2014-11-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* g++.dg/cpp/ucnid-2.C, g++.dg/cpp/ucnid-3.C,\n+\tgcc.dg/cpp/ucnid-11.c, gcc.dg/cpp/ucnid-12.c,\n+\tgcc.dg/cpp/ucnid-13.c, gcc.dg/cpp/ucnid-14.c,\n+\tgcc.dg/cpp/ucnid-15.c: New tests.\n+\n 2014-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt43.adb: New test."}, {"sha": "2ffb3c97b18f0891b5147d232bfac272a52f506b", "filename": "gcc/testsuite/g++.dg/cpp/ucnid-2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fucnid-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fucnid-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fucnid-2.C?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,17 @@\n+/* Test stringization of identifiers with UCNs preserves spelling.  */\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define h(s) #s\n+#define str(s) h(s)\n+\n+int\n+main ()\n+{\n+  if (strcmp (str (str (\\u00c1)), \"\\\"\\\\u00c1\\\"\"))\n+    abort ();\n+  if (strcmp (str (str (\\u00C1)), \"\\\"\\\\u00C1\\\"\"))\n+    abort ();\n+}"}, {"sha": "0db9aaaf71b14774911e396b3282b3b5940a8ae7", "filename": "gcc/testsuite/g++.dg/cpp/ucnid-3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fucnid-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fucnid-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fucnid-3.C?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,16 @@\n+/* Test pasting of identifiers with UCNs preserves spelling.  */\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define c(s1, s2) s1 ## s2\n+#define h(s) #s\n+#define str(s) h(s)\n+\n+int\n+main ()\n+{\n+  if (strcmp (str (str (c (\\u00c1, \\u00C1))), \"\\\"\\\\u00c1\\\\u00C1\\\"\"))\n+    abort ();\n+}"}, {"sha": "a44a3eaf4212353a1977079bac66da0b7e3a07cd", "filename": "gcc/testsuite/gcc.dg/cpp/ucnid-11.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-11.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,30 @@\n+/* Test spelling differences in UCNs are properly diagnosed for macro\n+   redefinitions.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+/* Different spelling of UCN in expansion.  */\n+#define m1 \\u00c1 /* { dg-message \"previous definition\" } */\n+#define m1 \\u00C1 /* { dg-error \"redefined\" } */\n+\n+#define m1ok \\u00c1\n+#define m1ok \\u00c1\n+\n+/* Different spelling of UCN in argument name.  */\n+#define m2(\\u00c1) /* { dg-message \"previous definition\" } */\n+#define m2(\\u00C1) /* { dg-error \"redefined\" } */\n+\n+#define m2ok(\\u00c1)\n+#define m2ok(\\u00c1)\n+\n+/* Same spelling in argument name but different spelling when used in\n+   expansion.  */\n+#define m3(\\u00c1) \\u00c1 /* { dg-message \"previous definition\" } */\n+#define m3(\\u00c1) \\u00C1 /* { dg-error \"redefined\" } */\n+\n+#define m3ok(\\u00c1) \\u00C1\n+#define m3ok(\\u00c1) \\u00C1\n+\n+/* Different spelling of the macro name itself is OK.  */\n+#define m4ok\\u00c1\n+#define m4ok\\u00C1"}, {"sha": "2932768607f50dcb0559f95acf9d1d1cb20a6ad4", "filename": "gcc/testsuite/gcc.dg/cpp/ucnid-12.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-12.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,13 @@\n+/* Test spelling differences in UCNs in macro definitions still count\n+   as the same identifier for macro expansion.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+\n+#define m1\\u00c1\n+#ifndef m1\\u00C1\n+#error not defined\n+#endif\n+\n+#define m2(\\u00c1) \\u00C1\n+\n+int i = m2 (0);"}, {"sha": "b8778fbccfabe342edd4e54c0d56ec9b11fe9a0c", "filename": "gcc/testsuite/gcc.dg/cpp/ucnid-13.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-13.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,6 @@\n+/* Verify macros named with UCNs are output in -dD output with UCNs,\n+   not UTF-8.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c99 -dD\" } */\n+/* { dg-final { scan-file ucnid-13.i \"\\\\\\\\U000000c1\" } } */\n+#define \\u00c1 1"}, {"sha": "4653affaceb67fb0e31914d9db43c9f4aa3a6cc5", "filename": "gcc/testsuite/gcc.dg/cpp/ucnid-14.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-14.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,6 @@\n+/* Verify macro definitions with UCNs are output in -dD output with\n+   the original spelling.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c99 -dD\" } */\n+/* { dg-final { scan-file ucnid-14.i \"\\\\\\\\u00c1\" } } */\n+#define a \\u00c1"}, {"sha": "2d73292cf2f99df8a2ba12d635178eb809eb446a", "filename": "gcc/testsuite/gcc.dg/cpp/ucnid-15.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucnid-15.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -0,0 +1,6 @@\n+/* Verify macro definitions with UCNs in argument names are output in\n+   -dD output with the original spelling.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c99 -dD\" } */\n+/* { dg-final { scan-file ucnid-15.i \"#define a\\\\(\\\\\\\\u00c1\\\\) x:\\\\\\\\u00C1:y:\\\\\\\\u00c1:z\" } } */\n+#define a(\\u00c1) x:\\u00C1:y:\\u00c1:z"}, {"sha": "c29fe87e219ba4a083afcca6a2d8c6b44a44fc98", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -1,3 +1,35 @@\n+2014-11-06  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* include/cpp-id-data.h (struct cpp_macro): Update comment\n+\tregarding parameters.\n+\t* include/cpplib.h (struct cpp_macro_arg, struct cpp_identifier):\n+\tAdd spelling fields.\n+\t(struct cpp_token): Update comment on macro_arg.\n+\t* internal.h (_cpp_save_parameter): Add extra argument.\n+\t(_cpp_spell_ident_ucns): New declaration.\n+\t* lex.c (lex_identifier): Add SPELLING argument.  Set *SPELLING to\n+\toriginal spelling of identifier.\n+\t(_cpp_lex_direct): Update calls to lex_identifier.\n+\t(_cpp_spell_ident_ucns): New function, factored out of\n+\tcpp_spell_token.\n+\t(cpp_spell_token): Adjust FORSTRING argument semantics to return\n+\toriginal spelling of identifiers.  Use _cpp_spell_ident_ucns in\n+\t!FORSTRING case.\n+\t(_cpp_equiv_tokens): Check spellings of identifiers and macro\n+\targuments are identical.\n+\t* macro.c (macro_arg_saved_data): New structure.\n+\t(paste_tokens): Use original spellings of identifiers from\n+\tcpp_spell_token.\n+\t(_cpp_save_parameter): Add argument SPELLING.  Save both canonical\n+\tnode and its value.\n+\t(parse_params): Update calls to _cpp_save_parameter.\n+\t(lex_expansion_token): Save spelling of macro argument tokens.\n+\t(_cpp_create_definition): Extract canonical node from saved data.\n+\t(cpp_macro_definition): Use UCNs in spelling of macro name.  Use\n+\toriginal spellings of macro argument tokens and identifiers.\n+\t* traditional.c (scan_parameters): Update call to\n+\t_cpp_save_parameter.\n+\n 2014-11-05  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR preprocessor/9449"}, {"sha": "97a2f670cf5ce14047276b99713d3dfa8bb30b82", "filename": "libcpp/include/cpp-id-data.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Finclude%2Fcpp-id-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Finclude%2Fcpp-id-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpp-id-data.h?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -33,7 +33,9 @@ struct GTY(()) answer {\n /* Each macro definition is recorded in a cpp_macro structure.\n    Variadic macros cannot occur with traditional cpp.  */\n struct GTY(()) cpp_macro {\n-  /* Parameters, if any.  */\n+  /* Parameters, if any.  If parameter names use extended identifiers,\n+     the original spelling of those identifiers, not the canonical\n+     UTF-8 spelling, goes here.  */\n   cpp_hashnode ** GTY ((nested_ptr (union tree_node,\n \t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n \t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\"),"}, {"sha": "7f8e719ef8e9e434dfc9c7800b240cffc9e793bb", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -208,6 +208,12 @@ enum cpp_token_fld_kind {\n struct GTY(()) cpp_macro_arg {\n   /* Argument number.  */\n   unsigned int arg_no;\n+  /* The original spelling of the macro argument token.  */\n+  cpp_hashnode *\n+    GTY ((nested_ptr (union tree_node,\n+\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\")))\n+       spelling;\n };\n \n /* An identifier in the cpp_token union.  */\n@@ -218,6 +224,12 @@ struct GTY(()) cpp_identifier {\n \t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n \t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\")))\n        node;\n+  /* The original spelling of the identifier.  */\n+  cpp_hashnode *\n+    GTY ((nested_ptr (union tree_node,\n+\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\")))\n+       spelling;\n };\n \n /* A preprocessing token.  This has been carefully packed and should\n@@ -238,7 +250,7 @@ struct GTY(()) cpp_token {\n     /* A string, or number.  */\n     struct cpp_string GTY ((tag (\"CPP_TOKEN_FLD_STR\"))) str;\n \n-    /* Argument no. for a CPP_MACRO_ARG.  */\n+    /* Argument no. (and original spelling) for a CPP_MACRO_ARG.  */\n     struct cpp_macro_arg GTY ((tag (\"CPP_TOKEN_FLD_ARG_NO\"))) macro_arg;\n \n     /* Original token no. for a CPP_PASTE (from a sequence of"}, {"sha": "427f4c6def6971cd6e7c4b644f53d7e74543213a", "filename": "libcpp/internal.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -616,7 +616,8 @@ extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);\n extern void _cpp_pop_context (cpp_reader *);\n extern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *,\n \t\t\t\t    const unsigned char *, size_t);\n-extern bool _cpp_save_parameter (cpp_reader *, cpp_macro *, cpp_hashnode *);\n+extern bool _cpp_save_parameter (cpp_reader *, cpp_macro *, cpp_hashnode *,\n+\t\t\t\t cpp_hashnode *);\n extern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *,\n \t\t\t       unsigned int);\n extern const unsigned char *_cpp_builtin_macro_text (cpp_reader *,\n@@ -665,6 +666,7 @@ extern bool _cpp_skip_block_comment (cpp_reader *);\n extern cpp_token *_cpp_temp_token (cpp_reader *);\n extern const cpp_token *_cpp_lex_token (cpp_reader *);\n extern cpp_token *_cpp_lex_direct (cpp_reader *);\n+extern unsigned char *_cpp_spell_ident_ucns (unsigned char *, cpp_hashnode *);\n extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);\n extern void _cpp_init_tokenrun (tokenrun *, unsigned int);\n extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);"}, {"sha": "2247386f829d23464461e2087879e932fe5d5224", "filename": "libcpp/lex.c", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -1302,7 +1302,7 @@ _cpp_lex_identifier (cpp_reader *pfile, const char *name)\n /* Lex an identifier starting at BUFFER->CUR - 1.  */\n static cpp_hashnode *\n lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,\n-\t\tstruct normalize_state *nst)\n+\t\tstruct normalize_state *nst, cpp_hashnode **spelling)\n {\n   cpp_hashnode *result;\n   const uchar *cur;\n@@ -1332,6 +1332,7 @@ lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,\n       } while (forms_identifier_p (pfile, false, nst));\n       result = _cpp_interpret_identifier (pfile, base,\n \t\t\t\t\t  pfile->buffer->cur - base);\n+      *spelling = cpp_lookup (pfile, base, pfile->buffer->cur - base);\n     }\n   else\n     {\n@@ -1340,6 +1341,7 @@ lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,\n \n       result = CPP_HASHNODE (ht_lookup_with_hash (pfile->hash_table,\n \t\t\t\t\t\t  base, len, hash, HT_ALLOC));\n+      *spelling = result;\n     }\n \n   /* Rarely, identifiers require diagnostics when lexed.  */\n@@ -2388,7 +2390,8 @@ _cpp_lex_direct (cpp_reader *pfile)\n       {\n \tstruct normalize_state nst = INITIAL_NORMALIZE_STATE;\n \tresult->val.node.node = lex_identifier (pfile, buffer->cur - 1, false,\n-\t\t\t\t\t\t&nst);\n+\t\t\t\t\t\t&nst,\n+\t\t\t\t\t\t&result->val.node.spelling);\n \twarn_about_normalization (pfile, result, &nst);\n       }\n \n@@ -2666,7 +2669,8 @@ _cpp_lex_direct (cpp_reader *pfile)\n \tif (forms_identifier_p (pfile, true, &nst))\n \t  {\n \t    result->type = CPP_NAME;\n-\t    result->val.node.node = lex_identifier (pfile, base, true, &nst);\n+\t    result->val.node.node = lex_identifier (pfile, base, true, &nst,\n+\t\t\t\t\t\t    &result->val.node.spelling);\n \t    warn_about_normalization (pfile, result, &nst);\n \t    break;\n \t  }\n@@ -2740,11 +2744,35 @@ cpp_digraph2name (enum cpp_ttype type)\n   return digraph_spellings[(int) type - (int) CPP_FIRST_DIGRAPH];\n }\n \n+/* Write the spelling of an identifier IDENT, using UCNs, to BUFFER.\n+   The buffer must already contain the enough space to hold the\n+   token's spelling.  Returns a pointer to the character after the\n+   last character written.  */\n+unsigned char *\n+_cpp_spell_ident_ucns (unsigned char *buffer, cpp_hashnode *ident)\n+{\n+  size_t i;\n+  const unsigned char *name = NODE_NAME (ident);\n+\t  \n+  for (i = 0; i < NODE_LEN (ident); i++)\n+    if (name[i] & ~0x7F)\n+      {\n+\ti += utf8_to_ucn (buffer, name + i) - 1;\n+\tbuffer += 10;\n+      }\n+    else\n+      *buffer++ = name[i];\n+\n+  return buffer;\n+}\n+\n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n    already contain the enough space to hold the token's spelling.\n    Returns a pointer to the character after the last character written.\n    FORSTRING is true if this is to be the spelling after translation\n-   phase 1 (this is different for UCNs).\n+   phase 1 (with the original spelling of extended identifiers), false\n+   if extended identifiers should always be written using UCNs (there is\n+   no option for always writing them in the internal UTF-8 form).\n    FIXME: Would be nice if we didn't need the PFILE argument.  */\n unsigned char *\n cpp_spell_token (cpp_reader *pfile, const cpp_token *token,\n@@ -2773,24 +2801,12 @@ cpp_spell_token (cpp_reader *pfile, const cpp_token *token,\n     case SPELL_IDENT:\n       if (forstring)\n \t{\n-\t  memcpy (buffer, NODE_NAME (token->val.node.node),\n-\t\t  NODE_LEN (token->val.node.node));\n-\t  buffer += NODE_LEN (token->val.node.node);\n+\t  memcpy (buffer, NODE_NAME (token->val.node.spelling),\n+\t\t  NODE_LEN (token->val.node.spelling));\n+\t  buffer += NODE_LEN (token->val.node.spelling);\n \t}\n       else\n-\t{\n-\t  size_t i;\n-\t  const unsigned char * name = NODE_NAME (token->val.node.node);\n-\t  \n-\t  for (i = 0; i < NODE_LEN (token->val.node.node); i++)\n-\t    if (name[i] & ~0x7F)\n-\t      {\n-\t\ti += utf8_to_ucn (buffer, name + i) - 1;\n-\t\tbuffer += 10;\n-\t      }\n-\t    else\n-\t      *buffer++ = NODE_NAME (token->val.node.node)[i];\n-\t}\n+\tbuffer = _cpp_spell_ident_ucns (buffer, token->val.node.node);\n       break;\n \n     case SPELL_LITERAL:\n@@ -2904,9 +2920,11 @@ _cpp_equiv_tokens (const cpp_token *a, const cpp_token *b)\n \treturn (a->type != CPP_PASTE || a->val.token_no == b->val.token_no);\n       case SPELL_NONE:\n \treturn (a->type != CPP_MACRO_ARG\n-\t\t|| a->val.macro_arg.arg_no == b->val.macro_arg.arg_no);\n+\t\t|| (a->val.macro_arg.arg_no == b->val.macro_arg.arg_no\n+\t\t    && a->val.macro_arg.spelling == b->val.macro_arg.spelling));\n       case SPELL_IDENT:\n-\treturn a->val.node.node == b->val.node.node;\n+\treturn (a->val.node.node == b->val.node.node\n+\t\t&& a->val.node.spelling == b->val.node.spelling);\n       case SPELL_LITERAL:\n \treturn (a->val.str.len == b->val.str.len\n \t\t&& !memcmp (a->val.str.text, b->val.str.text,"}, {"sha": "678bf2b625342724e58bb3d580b4ee8d3d6beb86", "filename": "libcpp/macro.c", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -80,6 +80,15 @@ struct macro_arg_token_iter\n #endif\n };\n \n+/* Saved data about an identifier being used as a macro argument\n+   name.  */\n+struct macro_arg_saved_data {\n+  /* The canonical (UTF-8) spelling of this identifier.  */\n+  cpp_hashnode *canonical_node;\n+  /* The previous value of this identifier.  */\n+  union _cpp_hashnode_value value;\n+};\n+\n /* Macro expansion.  */\n \n static int enter_macro_context (cpp_reader *, cpp_hashnode *,\n@@ -590,7 +599,7 @@ paste_tokens (cpp_reader *pfile, source_location location,\n \n   len = cpp_token_len (*plhs) + cpp_token_len (rhs) + 1;\n   buf = (unsigned char *) alloca (len);\n-  end = lhsend = cpp_spell_token (pfile, *plhs, buf, false);\n+  end = lhsend = cpp_spell_token (pfile, *plhs, buf, true);\n \n   /* Avoid comment headers, since they are still processed in stage 3.\n      It is simpler to insert a space here, rather than modifying the\n@@ -600,7 +609,7 @@ paste_tokens (cpp_reader *pfile, source_location location,\n     *end++ = ' ';\n   /* In one obscure case we might see padding here.  */\n   if (rhs->type != CPP_PADDING)\n-    end = cpp_spell_token (pfile, rhs, end, false);\n+    end = cpp_spell_token (pfile, rhs, end, true);\n   *end = '\\n';\n \n   cpp_push_buffer (pfile, buf, end - buf, /* from_stage3 */ true);\n@@ -2748,10 +2757,12 @@ _cpp_free_definition (cpp_hashnode *h)\n   h->flags &= ~(NODE_BUILTIN | NODE_DISABLED | NODE_USED);\n }\n \n-/* Save parameter NODE to the parameter list of macro MACRO.  Returns\n-   zero on success, nonzero if the parameter is a duplicate.  */\n+/* Save parameter NODE (spelling SPELLING) to the parameter list of\n+   macro MACRO.  Returns zero on success, nonzero if the parameter is\n+   a duplicate.  */\n bool\n-_cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node)\n+_cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node,\n+\t\t     cpp_hashnode *spelling)\n {\n   unsigned int len;\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n@@ -2766,17 +2777,20 @@ _cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node)\n       < (macro->paramc + 1) * sizeof (cpp_hashnode *))\n     _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_hashnode *));\n \n-  ((cpp_hashnode **) BUFF_FRONT (pfile->a_buff))[macro->paramc++] = node;\n+  ((cpp_hashnode **) BUFF_FRONT (pfile->a_buff))[macro->paramc++] = spelling;\n   node->flags |= NODE_MACRO_ARG;\n-  len = macro->paramc * sizeof (union _cpp_hashnode_value);\n+  len = macro->paramc * sizeof (struct macro_arg_saved_data);\n   if (len > pfile->macro_buffer_len)\n     {\n       pfile->macro_buffer = XRESIZEVEC (unsigned char, pfile->macro_buffer,\n                                         len);\n       pfile->macro_buffer_len = len;\n     }\n-  ((union _cpp_hashnode_value *) pfile->macro_buffer)[macro->paramc - 1]\n-    = node->value;\n+  struct macro_arg_saved_data save;\n+  save.value = node->value;\n+  save.canonical_node = node;\n+  ((struct macro_arg_saved_data *) pfile->macro_buffer)[macro->paramc - 1]\n+    = save;\n   \n   node->value.arg_index  = macro->paramc;\n   return false;\n@@ -2816,7 +2830,8 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t    }\n \t  prev_ident = 1;\n \n-\t  if (_cpp_save_parameter (pfile, macro, token->val.node.node))\n+\t  if (_cpp_save_parameter (pfile, macro, token->val.node.node,\n+\t\t\t\t   token->val.node.spelling))\n \t    return false;\n \t  continue;\n \n@@ -2839,6 +2854,7 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t  if (!prev_ident)\n \t    {\n \t      _cpp_save_parameter (pfile, macro,\n+\t\t\t\t   pfile->spec_nodes.n__VA_ARGS__,\n \t\t\t\t   pfile->spec_nodes.n__VA_ARGS__);\n \t      pfile->state.va_args_ok = 1;\n \t      if (! CPP_OPTION (pfile, c99)\n@@ -2909,8 +2925,10 @@ lex_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n   if (token->type == CPP_NAME\n       && (token->val.node.node->flags & NODE_MACRO_ARG) != 0)\n     {\n+      cpp_hashnode *spelling = token->val.node.spelling;\n       token->type = CPP_MACRO_ARG;\n       token->val.macro_arg.arg_no = token->val.node.node->value.arg_index;\n+      token->val.macro_arg.spelling = spelling;\n     }\n   else if (CPP_WTRADITIONAL (pfile) && macro->paramc > 0\n \t   && (token->type == CPP_STRING || token->type == CPP_CHAR))\n@@ -3162,9 +3180,11 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   /* Clear the fast argument lookup indices.  */\n   for (i = macro->paramc; i-- > 0; )\n     {\n-      struct cpp_hashnode *node = macro->params[i];\n+      struct macro_arg_saved_data *save =\n+\t&((struct macro_arg_saved_data *) pfile->macro_buffer)[i];\n+      struct cpp_hashnode *node = save->canonical_node;\n       node->flags &= ~ NODE_MACRO_ARG;\n-      node->value = ((union _cpp_hashnode_value *) pfile->macro_buffer)[i];\n+      node->value = save->value;\n     }\n \n   if (!ok)\n@@ -3285,7 +3305,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n \n   macro = node->value.macro;\n   /* Calculate length.  */\n-  len = NODE_LEN (node) + 2;\t\t\t/* ' ' and NUL.  */\n+  len = NODE_LEN (node) * 10 + 2;\t\t/* ' ' and NUL.  */\n   if (macro->fun_like)\n     {\n       len += 4;\t\t/* \"()\" plus possible final \"..\" of named\n@@ -3305,7 +3325,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n \t  cpp_token *token = &macro->exp.tokens[i];\n \n \t  if (token->type == CPP_MACRO_ARG)\n-\t    len += NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]);\n+\t    len += NODE_LEN (token->val.macro_arg.spelling);\n \t  else\n \t    len += cpp_token_len (token);\n \n@@ -3327,8 +3347,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n \n   /* Fill in the buffer.  Start with the macro name.  */\n   buffer = pfile->macro_buffer;\n-  memcpy (buffer, NODE_NAME (node), NODE_LEN (node));\n-  buffer += NODE_LEN (node);\n+  buffer = _cpp_spell_ident_ucns (buffer, node);\n \n   /* Parameter names.  */\n   if (macro->fun_like)\n@@ -3377,12 +3396,12 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n \t  if (token->type == CPP_MACRO_ARG)\n \t    {\n \t      memcpy (buffer,\n-\t\t      NODE_NAME (macro->params[token->val.macro_arg.arg_no - 1]),\n-\t\t      NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]));\n-\t      buffer += NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]);\n+\t\t      NODE_NAME (token->val.macro_arg.spelling),\n+\t\t      NODE_LEN (token->val.macro_arg.spelling));\n+\t      buffer += NODE_LEN (token->val.macro_arg.spelling);\n \t    }\n \t  else\n-\t    buffer = cpp_spell_token (pfile, token, buffer, false);\n+\t    buffer = cpp_spell_token (pfile, token, buffer, true);\n \n \t  if (token->flags & PASTE_LEFT)\n \t    {"}, {"sha": "3d40c2f2122b8236d1a125c998d1c2a9352fabfc", "filename": "libcpp/traditional.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5ffc59ad88c5cd1cf6f568ec73001228cf28d5/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=be5ffc59ad88c5cd1cf6f568ec73001228cf28d5", "patch": "@@ -959,8 +959,9 @@ scan_parameters (cpp_reader *pfile, cpp_macro *macro)\n \n       if (is_idstart (*cur))\n \t{\n+\t  struct cpp_hashnode *id = lex_identifier (pfile, cur);\n \t  ok = false;\n-\t  if (_cpp_save_parameter (pfile, macro, lex_identifier (pfile, cur)))\n+\t  if (_cpp_save_parameter (pfile, macro, id, id))\n \t    break;\n \t  cur = skip_whitespace (pfile, CUR (pfile->context),\n \t\t\t\t true /* skip_comments */);"}]}