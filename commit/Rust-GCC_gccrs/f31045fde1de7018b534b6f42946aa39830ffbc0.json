{"sha": "f31045fde1de7018b534b6f42946aa39830ffbc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxMDQ1ZmRlMWRlNzAxOGI1MzRiNmY0Mjk0NmFhMzk4MzBmZmJjMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-12T22:53:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-12T22:53:47Z"}, "message": "* name-lookup.c (push_class_level_binding): Simplify.\n\nFrom-SVN: r84585", "tree": {"sha": "013a8d6e11bd612bc244ad952c54ea6f9e7aaf07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/013a8d6e11bd612bc244ad952c54ea6f9e7aaf07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f31045fde1de7018b534b6f42946aa39830ffbc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31045fde1de7018b534b6f42946aa39830ffbc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31045fde1de7018b534b6f42946aa39830ffbc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31045fde1de7018b534b6f42946aa39830ffbc0/comments", "author": null, "committer": null, "parents": [{"sha": "5e89a381f9bde6b3959d1ddb6ebaa04df2fb2db8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e89a381f9bde6b3959d1ddb6ebaa04df2fb2db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e89a381f9bde6b3959d1ddb6ebaa04df2fb2db8"}], "stats": {"total": 97, "additions": 49, "deletions": 48}, "files": [{"sha": "5cc789417b56b12947831847e970352e0052df1e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31045fde1de7018b534b6f42946aa39830ffbc0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31045fde1de7018b534b6f42946aa39830ffbc0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f31045fde1de7018b534b6f42946aa39830ffbc0", "patch": "@@ -1,3 +1,7 @@\n+2004-07-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* name-lookup.c (push_class_level_binding): Simplify.\n+\n 2004-07-12  Andrew Pinski  <apinski@apple.com>\n \n \tPR c++/16475"}, {"sha": "b063c0d6f62a9e3c0c8f14df0efacfb65b1422be", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31045fde1de7018b534b6f42946aa39830ffbc0/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31045fde1de7018b534b6f42946aa39830ffbc0/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f31045fde1de7018b534b6f42946aa39830ffbc0", "patch": "@@ -2820,8 +2820,10 @@ push_class_level_binding (tree name, tree x)\n   if (!class_binding_level)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n-  /* Make sure that this new member does not have the same name\n-     as a template parameter.  */\n+  /* Check for invalid member names, if the class is being defined.\n+     This function is also used to restore IDENTIFIER_CLASS_VALUE,\n+     when reentering the class scope, and there is no point in\n+     checking again at that time.  */\n   if (TYPE_BEING_DEFINED (current_class_type))\n     {\n       tree decl = x;\n@@ -2834,40 +2836,41 @@ push_class_level_binding (tree name, tree x)\n \tdecl = TREE_VALUE (decl);\n       \n       check_template_shadow (decl);\n-    }\n \n-  /* [class.mem]\n+      /* [class.mem]\n \n-     If T is the name of a class, then each of the following shall\n-     have a name different from T:\n+\t If T is the name of a class, then each of the following shall\n+\t have a name different from T:\n \n-     -- every static data member of class T;\n+\t -- every static data member of class T;\n \n-     -- every member of class T that is itself a type;\n+\t -- every member of class T that is itself a type;\n \n-     -- every enumerator of every member of class T that is an\n-\tenumerated type;\n+\t -- every enumerator of every member of class T that is an\n+\t    enumerated type;\n \n-     -- every member of every anonymous union that is a member of\n-\tclass T.\n+\t -- every member of every anonymous union that is a member of\n+\t    class T.\n \n-     (Non-static data members were also forbidden to have the same\n-     name as T until TC1.)  */\n-  if ((TREE_CODE (x) == VAR_DECL\n-       || TREE_CODE (x) == CONST_DECL\n-       || (TREE_CODE (x) == TYPE_DECL\n-\t   && !DECL_SELF_REFERENCE_P (x))\n-       /* A data member of an anonymous union.  */\n-       || (TREE_CODE (x) == FIELD_DECL\n-\t   && DECL_CONTEXT (x) != current_class_type))\n-      && DECL_NAME (x) == constructor_name (current_class_type))\n-    {\n-      tree scope = context_for_name_lookup (x);\n-      if (TYPE_P (scope) && same_type_p (scope, current_class_type))\n+\t (Non-static data members were also forbidden to have the same\n+\t name as T until TC1.)  */\n+      if ((TREE_CODE (x) == VAR_DECL\n+\t   || TREE_CODE (x) == CONST_DECL\n+\t   || (TREE_CODE (x) == TYPE_DECL\n+\t       && !DECL_SELF_REFERENCE_P (x))\n+\t   /* A data member of an anonymous union.  */\n+\t   || (TREE_CODE (x) == FIELD_DECL\n+\t       && DECL_CONTEXT (x) != current_class_type))\n+\t  && DECL_NAME (x) == constructor_name (current_class_type))\n \t{\n-\t  error (\"`%D' has the same name as the class in which it is declared\",\n-\t\t x);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+\t  tree scope = context_for_name_lookup (x);\n+\t  if (TYPE_P (scope) && same_type_p (scope, current_class_type))\n+\t    {\n+\t      error (\"`%D' has the same name as the class in which it is \"\n+\t\t     \"declared\",\n+\t\t     x);\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+\t    }\n \t}\n     }\n \n@@ -2906,27 +2909,21 @@ push_class_level_binding (tree name, tree x)\n       else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n-      if (old_decl)\n+      if (old_decl\n+\t  && binding->scope == class_binding_level)\n \t{\n-\t  cp_class_binding *cb;\n-\t  size_t i;\n-\n-\t  /* Find the previous binding of name on the class-shadowed\n-             list, and update it.  */\n-\t  for (i = 0; \n-\t       (cb = VEC_iterate (cp_class_binding,\n-\t\t\t\t  class_binding_level->class_shadowed,\n-\t\t\t\t  i));\n-\t       ++i)\n-\t    if (cb->identifier == name\n-\t\t&& (cb->base.value == old_decl\n-\t\t    || cb->base.type == old_decl))\n-\t      {\n-\t\tbinding->value = x;\n-\t\tINHERITED_VALUE_BINDING_P (binding) = 0;\n-\t\tIDENTIFIER_CLASS_VALUE (name) = x;\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-\t      }\n+\t  binding->value = x;\n+\t  /* It is always safe to clear INHERITED_VALUE_BINDING_P\n+\t     here.  That flag is only set when setup_class_bindings\n+\t     inserts a binding from a base class, and\n+\t     setup_class_bindings only inserts a binding once for\n+\t     every name declared in the class and its base classes.\n+\t     So, if we see a second binding for this name, it must be\n+\t     coming from a definition in the body of the class\n+\t     itself.  */\n+\t  INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t  IDENTIFIER_CLASS_VALUE (name) = x;\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \t}\n     }\n "}]}