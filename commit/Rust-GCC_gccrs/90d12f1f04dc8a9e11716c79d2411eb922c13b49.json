{"sha": "90d12f1f04dc8a9e11716c79d2411eb922c13b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBkMTJmMWYwNGRjOGE5ZTExNzE2Yzc5ZDI0MTFlYjkyMmMxM2I0OQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2008-01-10T16:46:26Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2008-01-10T16:46:26Z"}, "message": "re PR target/34641 (ICE in reload_cse_simplify_operands, at postreload.c:395)\n\n2008-01-10  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\tPR middle-end/34641\n\t* reload.c (push_reload): Add assertions.  All constants from\n\treg_equiv_constant should have been used for replacing the respective\n\tpseudo earlier.\n\t(find_reloads_address): Invoke find_reloads_address_part for\n\tconstant taken from the reg_equiv_constant array.\n\n2008-01-10  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\tPR middle-end/34641\n\t* g++.dg/torture/pr34641.C: New testcase.\n\nFrom-SVN: r131445", "tree": {"sha": "c912dd79c520074e69014d7ec858c8c2b20c84cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c912dd79c520074e69014d7ec858c8c2b20c84cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90d12f1f04dc8a9e11716c79d2411eb922c13b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d12f1f04dc8a9e11716c79d2411eb922c13b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d12f1f04dc8a9e11716c79d2411eb922c13b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d12f1f04dc8a9e11716c79d2411eb922c13b49/comments", "author": null, "committer": null, "parents": [{"sha": "71ae85578b806e93eb8fbd58bfe618c5901b52aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ae85578b806e93eb8fbd58bfe618c5901b52aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71ae85578b806e93eb8fbd58bfe618c5901b52aa"}], "stats": {"total": 232, "additions": 211, "deletions": 21}, "files": [{"sha": "62a4cce53584744bd2f6344fcded89e18fc9f3fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90d12f1f04dc8a9e11716c79d2411eb922c13b49", "patch": "@@ -1,3 +1,12 @@\n+2008-01-10  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\tPR middle-end/34641\n+\t* reload.c (push_reload): Add assertions.  All constants from\n+\treg_equiv_constant should have been used for replacing the respective\n+\tpseudo earlier.\n+\t(find_reloads_address): Invoke find_reloads_address_part for\n+\tconstant taken from the reg_equiv_constant array.\n+\n 2008-01-10  Steven Bosscher  <stevenb.gcc@gmail.com>\n \n \t* tree-ssa-sccvn.h (struct vn_ssa_aux): Make the most accessed"}, {"sha": "5a0da1d59896f1622e4dfbba87f77844fdf686ed", "filename": "gcc/reload.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=90d12f1f04dc8a9e11716c79d2411eb922c13b49", "patch": "@@ -922,29 +922,33 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   if (outmode == VOIDmode && out != 0)\n     outmode = GET_MODE (out);\n \n-  /* If IN is a pseudo register everywhere-equivalent to a constant, and\n-     it is not in a hard register, reload straight from the constant,\n-     since we want to get rid of such pseudo registers.\n-     Often this is done earlier, but not always in find_reloads_address.  */\n+  /* If find_reloads and friends until now missed to replace a pseudo\n+     with a constant of reg_equiv_constant something went wrong\n+     beforehand.\n+     Note that it can't simply be done here if we missed it earlier\n+     since the constant might need to be pushed into the literal pool\n+     and the resulting memref would probably need further\n+     reloading.  */\n   if (in != 0 && REG_P (in))\n     {\n       int regno = REGNO (in);\n \n-      if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n-\t  && reg_equiv_constant[regno] != 0)\n-\tin = reg_equiv_constant[regno];\n+      gcc_assert (regno < FIRST_PSEUDO_REGISTER\n+\t\t  || reg_renumber[regno] >= 0\n+\t\t  || reg_equiv_constant[regno] == NULL_RTX);\n     }\n \n-  /* Likewise for OUT.  Of course, OUT will never be equivalent to\n-     an actual constant, but it might be equivalent to a memory location\n-     (in the case of a parameter).  */\n+  /* reg_equiv_constant only contains constants which are obviously\n+     not appropriate as destination.  So if we would need to replace\n+     the destination pseudo with a constant we are in real\n+     trouble.  */\n   if (out != 0 && REG_P (out))\n     {\n       int regno = REGNO (out);\n \n-      if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n-\t  && reg_equiv_constant[regno] != 0)\n-\tout = reg_equiv_constant[regno];\n+      gcc_assert (regno < FIRST_PSEUDO_REGISTER\n+\t\t  || reg_renumber[regno] >= 0\n+\t\t  || reg_equiv_constant[regno] == NULL_RTX);\n     }\n \n   /* If we have a read-write operand with an address side-effect,\n@@ -4772,15 +4776,12 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n     {\n       regno = REGNO (ad);\n \n-      /* If the register is equivalent to an invariant expression, substitute\n-\t the invariant, and eliminate any eliminable register references.  */\n-      tem = reg_equiv_constant[regno];\n-      if (tem != 0\n-\t  && (tem = eliminate_regs (tem, mode, insn))\n-\t  && strict_memory_address_p (mode, tem))\n+      if (reg_equiv_constant[regno] != 0)\n \t{\n-\t  *loc = ad = tem;\n-\t  return 0;\n+\t  find_reloads_address_part (reg_equiv_constant[regno], loc,\n+\t\t\t\t     base_reg_class (mode, MEM, SCRATCH),\n+\t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n+\t  return 1;\n \t}\n \n       tem = reg_equiv_memory_loc[regno];"}, {"sha": "2f957f0aca64a9a811d01e642134b983f85ef609", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90d12f1f04dc8a9e11716c79d2411eb922c13b49", "patch": "@@ -1,3 +1,8 @@\n+2008-01-10  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\tPR middle-end/34641\n+\t* g++.dg/torture/pr34641.C: New testcase.\n+\n 2008-01-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/34651"}, {"sha": "21115b71f51529b0c58eea97a661ff1c0dfaa011", "filename": "gcc/testsuite/g++.dg/torture/pr34641.C", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34641.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d12f1f04dc8a9e11716c79d2411eb922c13b49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34641.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34641.C?ref=90d12f1f04dc8a9e11716c79d2411eb922c13b49", "patch": "@@ -0,0 +1,175 @@\n+// { dg-require-effective-target fpic }\n+// { dg-options \"-fPIC\" }\n+// { dg-do compile }\n+\n+\n+typedef long unsigned int size_t;\n+extern \"C\" void *\n+malloc (size_t __size)\n+throw () __attribute__ ((__malloc__));\n+     namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  using::size_t;\n+}\n+inline void *operator\n+new (std::size_t, void *__p)\n+throw ()\n+{\n+  return __p;\n+}\n+template < class _T1, class _T2 > struct pair\n+{\n+  _T1 first;\n+  _T2 second;\n+    pair (const _T1 & __a, const _T2 & __b):first (__a), second (__b)\n+  {\n+  }\n+  template < class _U1, class _U2 >\n+    pair (const pair < _U1, _U2 > &__p):first (__p.first), second (__p.second)\n+  {\n+  }\n+};\n+\n+template < class _T1, class _T2 >\n+  inline pair < _T1, _T2 > make_pair (_T1 __x, _T2 __y)\n+{\n+  return pair < _T1, _T2 > (__x, __y);\n+}\n+template < typename _Tp > inline const _Tp &\n+max (const _Tp & __a, const _Tp & __b)\n+{\n+}\n+typedef unsigned short int uint16_t;\n+typedef unsigned long int uintptr_t;\n+typedef uint16_t UChar;\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  struct __numeric_limits_base\n+  {\n+  };\n+  template < typename _Tp > struct numeric_limits:public __numeric_limits_base\n+  {\n+    static _Tp max () throw ()\n+    {\n+    }\n+  };\n+}\n+\n+template < typename T > class VectorBufferBase\n+{\n+public:\n+  void allocateBuffer (size_t newCapacity)\n+  {\n+    if (newCapacity > std::numeric_limits < size_t >::max () / sizeof (T))\n+      *(int *) (uintptr_t) 0xbbadbeef = 0;\n+  }\n+};\n+\n+template < typename T, size_t inlineCapacity > class VectorBuffer;\n+template < typename T > class VectorBuffer < T, 0 >:private VectorBufferBase <\n+  T >\n+{\n+  typedef VectorBufferBase < T > Base;\n+  using Base::allocateBuffer;\n+};\n+\n+template < typename T, size_t inlineCapacity = 0 > class Vector\n+{\n+  typedef VectorBuffer < T, inlineCapacity > Impl;\n+public:\n+  typedef T *iterator;\n+  size_t size () const\n+  {\n+    return m_size;\n+  }\n+  size_t capacity () const\n+  {\n+  }\n+  iterator begin ()\n+  {\n+  }\n+  iterator end ()\n+  {\n+    return begin () + m_size;\n+  }\n+  void shrink (size_t size);\n+  void reserveCapacity (size_t newCapacity);\n+  void clear ()\n+  {\n+    shrink (0);\n+  }\n+  template < typename U > void append (const U &);\n+  void expandCapacity (size_t newMinCapacity);\n+  template < typename U > U * expandCapacity (size_t newMinCapacity, U *);\n+  size_t m_size;\n+  Impl m_impl;\n+};\n+template < typename T, size_t inlineCapacity >\n+  void Vector < T, inlineCapacity >::expandCapacity (size_t newMinCapacity)\n+{\n+  reserveCapacity (max\n+\t\t   (newMinCapacity,\n+\t\t    max (static_cast < size_t > (16),\n+\t\t\t capacity () + capacity () / 4 + 1)));\n+}\n+\n+template < typename T, size_t inlineCapacity >\n+  template < typename U >\n+  inline U * Vector < T,\n+  inlineCapacity >::expandCapacity (size_t newMinCapacity, U * ptr)\n+{\n+  expandCapacity (newMinCapacity);\n+}\n+template < typename T, size_t inlineCapacity >\n+  void Vector < T, inlineCapacity >::reserveCapacity (size_t newCapacity)\n+{\n+  m_impl.allocateBuffer (newCapacity);\n+}\n+template < typename T, size_t inlineCapacity >\n+  template < typename U >\n+  inline void Vector < T, inlineCapacity >::append (const U & val)\n+{\n+  const U *ptr = &val;\n+  if (size () == capacity ())\n+    ptr = expandCapacity (size () + 1, ptr);\n+  new (end ())T (*ptr);\n+}\n+\n+class Range;\n+class TextIterator\n+{\n+public:\n+  explicit TextIterator (const Range *,\n+\t\t\t bool emitCharactersBetweenAllVisiblePositions =\n+\t\t\t false);\n+  bool atEnd () const\n+  {\n+  }\n+  void advance ();\n+  int length () const\n+  {\n+  }\n+};\n+UChar *\n+plainTextToMallocAllocatedBuffer (const Range * r, unsigned &bufferLength)\n+{\n+  static const unsigned cMaxSegmentSize = 1 << 16;\n+  typedef pair < UChar *, unsigned >TextSegment;\n+  Vector < TextSegment > *textSegments = 0;\n+  Vector < UChar > textBuffer;\n+  for (TextIterator it (r); !it.atEnd (); it.advance ())\n+    {\n+      if (textBuffer.size ()\n+\t  && textBuffer.size () + it.length () > cMaxSegmentSize)\n+\t{\n+\t  UChar *newSegmentBuffer =\n+\t    static_cast <\n+\t    UChar * >(malloc (textBuffer.size () * sizeof (UChar)));\n+\t  if (!textSegments)\n+\t    textSegments = new Vector < TextSegment >;\n+\t  textSegments->\n+\t    append (make_pair (newSegmentBuffer, textBuffer.size ()));\n+\t  textBuffer.clear ();\n+\t}\n+    }\n+}"}]}