{"sha": "94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRiZjFhNWZiNzNmYzljNmE5YmY5ODEwYzU2YjNmMTY3ODY2N2YyMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-22T16:19:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-22T16:19:46Z"}, "message": "Update Go library to r60.3 release.\n\nFrom-SVN: r180327", "tree": {"sha": "124c67e5d8255d184b6c9eaf37420f4797cadc66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/124c67e5d8255d184b6c9eaf37420f4797cadc66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/comments", "author": null, "committer": null, "parents": [{"sha": "89b925a66096923d0fc3c8c87bc357d3e0d96a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b925a66096923d0fc3c8c87bc357d3e0d96a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b925a66096923d0fc3c8c87bc357d3e0d96a2f"}], "stats": {"total": 1936, "additions": 308, "deletions": 1628}, "files": [{"sha": "ddb83254278c59007fc04a5c54b88f4e0b587adc", "filename": "gcc/testsuite/go.test/test/interface/fake.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffake.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffake.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Finterface%2Ffake.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -12,20 +12,20 @@ package main\n import \"reflect\"\n \n type T struct {\n-\tf float32\n-\tg float32\n+\tF float32\n+\tG float32\n \n-\ts string\n-\tt string\n+\tS string\n+\tT string\n \n-\tu uint32\n-\tv uint32\n+\tU uint32\n+\tV uint32\n \n-\tw uint32\n-\tx uint32\n+\tW uint32\n+\tX uint32\n \n-\ty uint32\n-\tz uint32\n+\tY uint32\n+\tZ uint32\n }\n \n func add(s, t string) string {\n@@ -40,16 +40,16 @@ func assert(b bool) {\n \n func main() {\n \tvar x T\n-\tx.f = 1.0\n-\tx.g = x.f\n-\tx.s = add(\"abc\", \"def\")\n-\tx.t = add(\"abc\", \"def\")\n-\tx.u = 1\n-\tx.v = 2\n-\tx.w = 1 << 28\n-\tx.x = 2 << 28\n-\tx.y = 0x12345678\n-\tx.z = x.y\n+\tx.F = 1.0\n+\tx.G = x.F\n+\tx.S = add(\"abc\", \"def\")\n+\tx.T = add(\"abc\", \"def\")\n+\tx.U = 1\n+\tx.V = 2\n+\tx.W = 1 << 28\n+\tx.X = 2 << 28\n+\tx.Y = 0x12345678\n+\tx.Z = x.Y\n \n \t// check mem and string\n \tv := reflect.ValueOf(x)"}, {"sha": "8ad9d1e10577b9e1326efa62c9181e720ee10d68", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -1,4 +1,4 @@\n-fd30c132d1bd\n+c1702f36df03\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "ff58d262c36c22e6c0c3709d57ea2300ab06bbf0", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -242,7 +242,6 @@ toolexeclibgoencoding_DATA = \\\n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n-\texp/datafmt.gox \\\n \texp/gui.gox \\\n \texp/norm.gox \\\n \texp/regexp.gox\n@@ -1196,9 +1195,6 @@ go_encoding_hex_files = \\\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n-go_exp_datafmt_files = \\\n-\tgo/exp/datafmt/datafmt.go \\\n-\tgo/exp/datafmt/parser.go\n go_exp_gui_files = \\\n \tgo/exp/gui/gui.go\n go_exp_norm_files = \\\n@@ -1666,7 +1662,6 @@ libgo_go_objs = \\\n \tencoding/git85.lo \\\n \tencoding/hex.lo \\\n \tencoding/pem.lo \\\n-\texp/datafmt.lo \\\n \texp/gui.lo \\\n \texp/norm.lo \\\n \texp/regexp.lo \\\n@@ -2592,15 +2587,6 @@ encoding/pem/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/pem/check\n \n-exp/datafmt.lo: $(go_exp_datafmt_files) bytes.gox fmt.gox go/scanner.gox \\\n-\t\tgo/token.gox io.gox os.gox reflect.gox runtime.gox \\\n-\t\tstrconv.gox strings.gox\n-\t$(BUILDPACKAGE)\n-exp/datafmt/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/datafmt\n-\t@$(CHECK)\n-.PHONY: exp/datafmt/check\n-\n exp/gui.lo: $(go_exp_gui_files) image.gox image/draw.gox os.gox\n \t$(BUILDPACKAGE)\n exp/gui/check: $(CHECK_DEPS)\n@@ -3234,8 +3220,6 @@ encoding/hex.gox: encoding/hex.lo\n encoding/pem.gox: encoding/pem.lo\n \t$(BUILDGOX)\n \n-exp/datafmt.gox: exp/datafmt.lo\n-\t$(BUILDGOX)\n exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n@@ -3461,7 +3445,6 @@ TEST_PACKAGES = \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n \tencoding/pem/check \\\n-\texp/datafmt/check \\\n \texp/norm/check \\\n \texp/regexp/check \\\n \texp/regexp/syntax/check \\"}, {"sha": "1a8741d42b6bfe0ebc34166668e267d714e22adf", "filename": "libgo/Makefile.in", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -159,17 +159,16 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tcrypto/x509/pkix.lo debug/dwarf.lo debug/elf.lo debug/gosym.lo \\\n \tdebug/macho.lo debug/pe.lo encoding/ascii85.lo \\\n \tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n-\tencoding/git85.lo encoding/hex.lo encoding/pem.lo \\\n-\texp/datafmt.lo exp/gui.lo exp/norm.lo exp/regexp.lo \\\n-\texp/gui/x11.lo exp/regexp/syntax.lo exp/template/html.lo \\\n-\tgo/ast.lo go/build.lo go/doc.lo go/parser.lo go/printer.lo \\\n-\tgo/scanner.lo go/token.lo go/typechecker.lo go/types.lo \\\n-\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n-\thttp/cgi.lo http/fcgi.lo http/httptest.lo http/pprof.lo \\\n-\thttp/spdy.lo image/bmp.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo image/tiff.lo image/ycbcr.lo \\\n-\tindex/suffixarray.lo io/ioutil.lo mime/multipart.lo \\\n-\tnet/dict.lo net/textproto.lo old/template.lo \\\n+\tencoding/git85.lo encoding/hex.lo encoding/pem.lo exp/gui.lo \\\n+\texp/norm.lo exp/regexp.lo exp/gui/x11.lo exp/regexp/syntax.lo \\\n+\texp/template/html.lo go/ast.lo go/build.lo go/doc.lo \\\n+\tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n+\tgo/typechecker.lo go/types.lo hash/adler32.lo hash/crc32.lo \\\n+\thash/crc64.lo hash/fnv.lo http/cgi.lo http/fcgi.lo \\\n+\thttp/httptest.lo http/pprof.lo http/spdy.lo image/bmp.lo \\\n+\timage/draw.lo image/gif.lo image/jpeg.lo image/png.lo \\\n+\timage/tiff.lo image/ycbcr.lo index/suffixarray.lo io/ioutil.lo \\\n+\tmime/multipart.lo net/dict.lo net/textproto.lo old/template.lo \\\n \t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n \trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n \tsync/atomic.lo sync/atomic_c.lo syscalls/syscall.lo \\\n@@ -698,7 +697,6 @@ toolexeclibgoencoding_DATA = \\\n \n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n-\texp/datafmt.gox \\\n \texp/gui.gox \\\n \texp/norm.gox \\\n \texp/regexp.gox\n@@ -1567,10 +1565,6 @@ go_encoding_hex_files = \\\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n-go_exp_datafmt_files = \\\n-\tgo/exp/datafmt/datafmt.go \\\n-\tgo/exp/datafmt/parser.go\n-\n go_exp_gui_files = \\\n \tgo/exp/gui/gui.go\n \n@@ -1990,7 +1984,6 @@ libgo_go_objs = \\\n \tencoding/git85.lo \\\n \tencoding/hex.lo \\\n \tencoding/pem.lo \\\n-\texp/datafmt.lo \\\n \texp/gui.lo \\\n \texp/norm.lo \\\n \texp/regexp.lo \\\n@@ -2242,7 +2235,6 @@ TEST_PACKAGES = \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n \tencoding/pem/check \\\n-\texp/datafmt/check \\\n \texp/norm/check \\\n \texp/regexp/check \\\n \texp/regexp/syntax/check \\\n@@ -5171,15 +5163,6 @@ encoding/pem/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/pem/check\n \n-exp/datafmt.lo: $(go_exp_datafmt_files) bytes.gox fmt.gox go/scanner.gox \\\n-\t\tgo/token.gox io.gox os.gox reflect.gox runtime.gox \\\n-\t\tstrconv.gox strings.gox\n-\t$(BUILDPACKAGE)\n-exp/datafmt/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/datafmt\n-\t@$(CHECK)\n-.PHONY: exp/datafmt/check\n-\n exp/gui.lo: $(go_exp_gui_files) image.gox image/draw.gox os.gox\n \t$(BUILDPACKAGE)\n exp/gui/check: $(CHECK_DEPS)\n@@ -5808,8 +5791,6 @@ encoding/hex.gox: encoding/hex.lo\n encoding/pem.gox: encoding/pem.lo\n \t$(BUILDGOX)\n \n-exp/datafmt.gox: exp/datafmt.lo\n-\t$(BUILDGOX)\n exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo"}, {"sha": "6d7e7644276cb1653367bae08acd89684bb20f70", "filename": "libgo/go/exp/datafmt/datafmt.go", "status": "removed", "additions": 0, "deletions": 710, "changes": 710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b925a66096923d0fc3c8c87bc357d3e0d96a2f/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b925a66096923d0fc3c8c87bc357d3e0d96a2f/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt.go?ref=89b925a66096923d0fc3c8c87bc357d3e0d96a2f", "patch": "@@ -1,710 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-/*\tPackage datafmt implements syntax-directed, type-driven formatting\n-\tof arbitrary data structures. Formatting a data structure consists of\n-\ttwo phases: first, a parser reads a format specification and builds a\n-\t\"compiled\" format. Then, the format can be applied repeatedly to\n-\tarbitrary values. Applying a format to a value evaluates to a []byte\n-\tcontaining the formatted value bytes, or nil.\n-\n-\tA format specification is a set of package declarations and format rules:\n-\n-\t\tFormat      = [ Entry { \";\" Entry } [ \";\" ] ] .\n-\t\tEntry       = PackageDecl | FormatRule .\n-\n-\t(The syntax of a format specification is presented in the same EBNF\n-\tnotation as used in the Go language specification. The syntax of white\n-\tspace, comments, identifiers, and string literals is the same as in Go.)\n-\n-\tA package declaration binds a package name (such as 'ast') to a\n-\tpackage import path (such as '\"go/ast\"'). Each package used (in\n-\ta type name, see below) must be declared once before use.\n-\n-\t\tPackageDecl = PackageName ImportPath .\n-\t\tPackageName = identifier .\n-\t\tImportPath  = string .\n-\n-\tA format rule binds a rule name to a format expression. A rule name\n-\tmay be a type name or one of the special names 'default' or '/'.\n-\tA type name may be the name of a predeclared type (for example, 'int',\n-\t'float32', etc.), the package-qualified name of a user-defined type\n-\t(for example, 'ast.MapType'), or an identifier indicating the structure\n-\tof unnamed composite types ('array', 'chan', 'func', 'interface', 'map',\n-\tor 'ptr'). Each rule must have a unique name; rules can be declared in\n-\tany order.\n-\n-\t\tFormatRule  = RuleName \"=\" Expression .\n-\t\tRuleName    = TypeName | \"default\" | \"/\" .\n-\t\tTypeName    = [ PackageName \".\" ] identifier .\n-\n-\tTo format a value, the value's type name is used to select the format rule\n-\t(there is an override mechanism, see below). The format expression of the\n-\tselected rule specifies how the value is formatted. Each format expression,\n-\twhen applied to a value, evaluates to a byte sequence or nil.\n-\n-\tIn its most general form, a format expression is a list of alternatives,\n-\teach of which is a sequence of operands:\n-\n-\t\tExpression  = [ Sequence ] { \"|\" [ Sequence ] } .\n-\t\tSequence    = Operand { Operand } .\n-\n-\tThe formatted result produced by an expression is the result of the first\n-\talternative sequence that evaluates to a non-nil result; if there is no\n-\tsuch alternative, the expression evaluates to nil. The result produced by\n-\tan operand sequence is the concatenation of the results of its operands.\n-\tIf any operand in the sequence evaluates to nil, the entire sequence\n-\tevaluates to nil.\n-\n-\tThere are five kinds of operands:\n-\n-\t\tOperand     = Literal | Field | Group | Option | Repetition .\n-\n-\tLiterals evaluate to themselves, with two substitutions. First,\n-\t%-formats expand in the manner of fmt.Printf, with the current value\n-\tpassed as the parameter. Second, the current indentation (see below)\n-\tis inserted after every newline or form feed character.\n-\n-\t\tLiteral     = string .\n-\n-\tThis table shows string literals applied to the value 42 and the\n-\tcorresponding formatted result:\n-\n-\t\t\"foo\"       foo\n-\t\t\"%x\"        2a\n-\t\t\"x = %d\"    x = 42\n-\t\t\"%#x = %d\"  0x2a = 42\n-\n-\tA field operand is a field name optionally followed by an alternate\n-\trule name. The field name may be an identifier or one of the special\n-\tnames @ or *.\n-\n-\t\tField       = FieldName [ \":\" RuleName ] .\n-\t\tFieldName   = identifier | \"@\" | \"*\" .\n-\n-\tIf the field name is an identifier, the current value must be a struct,\n-\tand there must be a field with that name in the struct. The same lookup\n-\trules apply as in the Go language (for instance, the name of an anonymous\n-\tfield is the unqualified type name). The field name denotes the field\n-\tvalue in the struct. If the field is not found, formatting is aborted\n-\tand an error message is returned. (TODO consider changing the semantics\n-\tsuch that if a field is not found, it evaluates to nil).\n-\n-\tThe special name '@' denotes the current value.\n-\n-\tThe meaning of the special name '*' depends on the type of the current\n-\tvalue:\n-\n-\t\tarray, slice types   array, slice element (inside {} only, see below)\n-\t\tinterfaces           value stored in interface\n-\t\tpointers             value pointed to by pointer\n-\n-\t(Implementation restriction: channel, function and map types are not\n-\tsupported due to missing reflection support).\n-\n-\tFields are evaluated as follows: If the field value is nil, or an array\n-\tor slice element does not exist, the result is nil (see below for details\n-\ton array/slice elements). If the value is not nil the field value is\n-\tformatted (recursively) using the rule corresponding to its type name,\n-\tor the alternate rule name, if given.\n-\n-\tThe following example shows a complete format specification for a\n-\tstruct 'myPackage.Point'. Assume the package\n-\n-\t\tpackage myPackage  // in directory myDir/myPackage\n-\t\ttype Point struct {\n-\t\t\tname string;\n-\t\t\tx, y int;\n-\t\t}\n-\n-\tApplying the format specification\n-\n-\t\tmyPackage \"myDir/myPackage\";\n-\t\tint = \"%d\";\n-\t\thexInt = \"0x%x\";\n-\t\tstring = \"---%s---\";\n-\t\tmyPackage.Point = name \"{\" x \", \" y:hexInt \"}\";\n-\n-\tto the value myPackage.Point{\"foo\", 3, 15} results in\n-\n-\t\t---foo---{3, 0xf}\n-\n-\tFinally, an operand may be a grouped, optional, or repeated expression.\n-\tA grouped expression (\"group\") groups a more complex expression (body)\n-\tso that it can be used in place of a single operand:\n-\n-\t\tGroup       = \"(\" [ Indentation \">>\" ] Body \")\" .\n-\t\tIndentation = Expression .\n-\t\tBody        = Expression .\n-\n-\tA group body may be prefixed by an indentation expression followed by '>>'.\n-\tThe indentation expression is applied to the current value like any other\n-\texpression and the result, if not nil, is appended to the current indentation\n-\tduring the evaluation of the body (see also formatting state, below).\n-\n-\tAn optional expression (\"option\") is enclosed in '[]' brackets.\n-\n-\t\tOption      = \"[\" Body \"]\" .\n-\n-\tAn option evaluates to its body, except that if the body evaluates to nil,\n-\tthe option expression evaluates to an empty []byte. Thus an option's purpose\n-\tis to protect the expression containing the option from a nil operand.\n-\n-\tA repeated expression (\"repetition\") is enclosed in '{}' braces.\n-\n-\t\tRepetition  = \"{\" Body [ \"/\" Separator ] \"}\" .\n-\t\tSeparator   = Expression .\n-\n-\tA repeated expression is evaluated as follows: The body is evaluated\n-\trepeatedly and its results are concatenated until the body evaluates\n-\tto nil. The result of the repetition is the (possibly empty) concatenation,\n-\tbut it is never nil. An implicit index is supplied for the evaluation of\n-\tthe body: that index is used to address elements of arrays or slices. If\n-\tthe corresponding elements do not exist, the field denoting the element\n-\tevaluates to nil (which in turn may terminate the repetition).\n-\n-\tThe body of a repetition may be followed by a '/' and a \"separator\"\n-\texpression. If the separator is present, it is invoked between repetitions\n-\tof the body.\n-\n-\tThe following example shows a complete format specification for formatting\n-\ta slice of unnamed type. Applying the specification\n-\n-\t\tint = \"%b\";\n-\t\tarray = { * / \", \" };  // array is the type name for an unnamed slice\n-\n-\tto the value '[]int{2, 3, 5, 7}' results in\n-\n-\t\t10, 11, 101, 111\n-\n-\tDefault rule: If a format rule named 'default' is present, it is used for\n-\tformatting a value if no other rule was found. A common default rule is\n-\n-\t\tdefault = \"%v\"\n-\n-\tto provide default formatting for basic types without having to specify\n-\ta specific rule for each basic type.\n-\n-\tGlobal separator rule: If a format rule named '/' is present, it is\n-\tinvoked with the current value between literals. If the separator\n-\texpression evaluates to nil, it is ignored.\n-\n-\tFor instance, a global separator rule may be used to punctuate a sequence\n-\tof values with commas. The rules:\n-\n-\t\tdefault = \"%v\";\n-\t\t/ = \", \";\n-\n-\twill format an argument list by printing each one in its default format,\n-\tseparated by a comma and a space.\n-*/\n-package datafmt\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"go/token\"\n-\t\"io\"\n-\t\"os\"\n-\t\"reflect\"\n-\t\"runtime\"\n-)\n-\n-// ----------------------------------------------------------------------------\n-// Format representation\n-\n-// Custom formatters implement the Formatter function type.\n-// A formatter is invoked with the current formatting state, the\n-// value to format, and the rule name under which the formatter\n-// was installed (the same formatter function may be installed\n-// under different names). The formatter may access the current state\n-// to guide formatting and use State.Write to append to the state's\n-// output.\n-//\n-// A formatter must return a boolean value indicating if it evaluated\n-// to a non-nil value (true), or a nil value (false).\n-//\n-type Formatter func(state *State, value interface{}, ruleName string) bool\n-\n-// A FormatterMap is a set of custom formatters.\n-// It maps a rule name to a formatter function.\n-//\n-type FormatterMap map[string]Formatter\n-\n-// A parsed format expression is built from the following nodes.\n-//\n-type (\n-\texpr interface{}\n-\n-\talternatives []expr // x | y | z\n-\n-\tsequence []expr // x y z\n-\n-\tliteral [][]byte // a list of string segments, possibly starting with '%'\n-\n-\tfield struct {\n-\t\tfieldName string // including \"@\", \"*\"\n-\t\truleName  string // \"\" if no rule name specified\n-\t}\n-\n-\tgroup struct {\n-\t\tindent, body expr // (indent >> body)\n-\t}\n-\n-\toption struct {\n-\t\tbody expr // [body]\n-\t}\n-\n-\trepetition struct {\n-\t\tbody, separator expr // {body / separator}\n-\t}\n-\n-\tcustom struct {\n-\t\truleName string\n-\t\tfun      Formatter\n-\t}\n-)\n-\n-// A Format is the result of parsing a format specification.\n-// The format may be applied repeatedly to format values.\n-//\n-type Format map[string]expr\n-\n-// ----------------------------------------------------------------------------\n-// Formatting\n-\n-// An application-specific environment may be provided to Format.Apply;\n-// the environment is available inside custom formatters via State.Env().\n-// Environments must implement copying; the Copy method must return an\n-// complete copy of the receiver. This is necessary so that the formatter\n-// can save and restore an environment (in case of an absent expression).\n-//\n-// If the Environment doesn't change during formatting (this is under\n-// control of the custom formatters), the Copy function can simply return\n-// the receiver, and thus can be very light-weight.\n-//\n-type Environment interface {\n-\tCopy() Environment\n-}\n-\n-// State represents the current formatting state.\n-// It is provided as argument to custom formatters.\n-//\n-type State struct {\n-\tfmt       Format         // format in use\n-\tenv       Environment    // user-supplied environment\n-\terrors    chan os.Error  // not chan *Error (errors <- nil would be wrong!)\n-\thasOutput bool           // true after the first literal has been written\n-\tindent    bytes.Buffer   // current indentation\n-\toutput    bytes.Buffer   // format output\n-\tlinePos   token.Position // position of line beginning (Column == 0)\n-\tdefault_  expr           // possibly nil\n-\tseparator expr           // possibly nil\n-}\n-\n-func newState(fmt Format, env Environment, errors chan os.Error) *State {\n-\ts := new(State)\n-\ts.fmt = fmt\n-\ts.env = env\n-\ts.errors = errors\n-\ts.linePos = token.Position{Line: 1}\n-\n-\t// if we have a default rule, cache its expression for fast access\n-\tif x, found := fmt[\"default\"]; found {\n-\t\ts.default_ = x\n-\t}\n-\n-\t// if we have a global separator rule, cache its expression for fast access\n-\tif x, found := fmt[\"/\"]; found {\n-\t\ts.separator = x\n-\t}\n-\n-\treturn s\n-}\n-\n-// Env returns the environment passed to Format.Apply.\n-func (s *State) Env() interface{} { return s.env }\n-\n-// LinePos returns the position of the current line beginning\n-// in the state's output buffer. Line numbers start at 1.\n-//\n-func (s *State) LinePos() token.Position { return s.linePos }\n-\n-// Pos returns the position of the next byte to be written to the\n-// output buffer. Line numbers start at 1.\n-//\n-func (s *State) Pos() token.Position {\n-\toffs := s.output.Len()\n-\treturn token.Position{Line: s.linePos.Line, Column: offs - s.linePos.Offset, Offset: offs}\n-}\n-\n-// Write writes data to the output buffer, inserting the indentation\n-// string after each newline or form feed character. It cannot return an error.\n-//\n-func (s *State) Write(data []byte) (int, os.Error) {\n-\tn := 0\n-\ti0 := 0\n-\tfor i, ch := range data {\n-\t\tif ch == '\\n' || ch == '\\f' {\n-\t\t\t// write text segment and indentation\n-\t\t\tn1, _ := s.output.Write(data[i0 : i+1])\n-\t\t\tn2, _ := s.output.Write(s.indent.Bytes())\n-\t\t\tn += n1 + n2\n-\t\t\ti0 = i + 1\n-\t\t\ts.linePos.Offset = s.output.Len()\n-\t\t\ts.linePos.Line++\n-\t\t}\n-\t}\n-\tn3, _ := s.output.Write(data[i0:])\n-\treturn n + n3, nil\n-}\n-\n-type checkpoint struct {\n-\tenv       Environment\n-\thasOutput bool\n-\toutputLen int\n-\tlinePos   token.Position\n-}\n-\n-func (s *State) save() checkpoint {\n-\tsaved := checkpoint{nil, s.hasOutput, s.output.Len(), s.linePos}\n-\tif s.env != nil {\n-\t\tsaved.env = s.env.Copy()\n-\t}\n-\treturn saved\n-}\n-\n-func (s *State) restore(m checkpoint) {\n-\ts.env = m.env\n-\ts.output.Truncate(m.outputLen)\n-}\n-\n-func (s *State) error(msg string) {\n-\ts.errors <- os.NewError(msg)\n-\truntime.Goexit()\n-}\n-\n-// TODO At the moment, unnamed types are simply mapped to the default\n-//      names below. For instance, all unnamed arrays are mapped to\n-//      'array' which is not really sufficient. Eventually one may want\n-//      to be able to specify rules for say an unnamed slice of T.\n-//\n-\n-func typename(typ reflect.Type) string {\n-\tswitch typ.Kind() {\n-\tcase reflect.Array:\n-\t\treturn \"array\"\n-\tcase reflect.Slice:\n-\t\treturn \"array\"\n-\tcase reflect.Chan:\n-\t\treturn \"chan\"\n-\tcase reflect.Func:\n-\t\treturn \"func\"\n-\tcase reflect.Interface:\n-\t\treturn \"interface\"\n-\tcase reflect.Map:\n-\t\treturn \"map\"\n-\tcase reflect.Ptr:\n-\t\treturn \"ptr\"\n-\t}\n-\treturn typ.String()\n-}\n-\n-func (s *State) getFormat(name string) expr {\n-\tif fexpr, found := s.fmt[name]; found {\n-\t\treturn fexpr\n-\t}\n-\n-\tif s.default_ != nil {\n-\t\treturn s.default_\n-\t}\n-\n-\ts.error(fmt.Sprintf(\"no format rule for type: '%s'\", name))\n-\treturn nil\n-}\n-\n-// eval applies a format expression fexpr to a value. If the expression\n-// evaluates internally to a non-nil []byte, that slice is appended to\n-// the state's output buffer and eval returns true. Otherwise, eval\n-// returns false and the state remains unchanged.\n-//\n-func (s *State) eval(fexpr expr, value reflect.Value, index int) bool {\n-\t// an empty format expression always evaluates\n-\t// to a non-nil (but empty) []byte\n-\tif fexpr == nil {\n-\t\treturn true\n-\t}\n-\n-\tswitch t := fexpr.(type) {\n-\tcase alternatives:\n-\t\t// append the result of the first alternative that evaluates to\n-\t\t// a non-nil []byte to the state's output\n-\t\tmark := s.save()\n-\t\tfor _, x := range t {\n-\t\t\tif s.eval(x, value, index) {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t\ts.restore(mark)\n-\t\t}\n-\t\treturn false\n-\n-\tcase sequence:\n-\t\t// append the result of all operands to the state's output\n-\t\t// unless a nil result is encountered\n-\t\tmark := s.save()\n-\t\tfor _, x := range t {\n-\t\t\tif !s.eval(x, value, index) {\n-\t\t\t\ts.restore(mark)\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t\treturn true\n-\n-\tcase literal:\n-\t\t// write separator, if any\n-\t\tif s.hasOutput {\n-\t\t\t// not the first literal\n-\t\t\tif s.separator != nil {\n-\t\t\t\tsep := s.separator // save current separator\n-\t\t\t\ts.separator = nil  // and disable it (avoid recursion)\n-\t\t\t\tmark := s.save()\n-\t\t\t\tif !s.eval(sep, value, index) {\n-\t\t\t\t\ts.restore(mark)\n-\t\t\t\t}\n-\t\t\t\ts.separator = sep // enable it again\n-\t\t\t}\n-\t\t}\n-\t\ts.hasOutput = true\n-\t\t// write literal segments\n-\t\tfor _, lit := range t {\n-\t\t\tif len(lit) > 1 && lit[0] == '%' {\n-\t\t\t\t// segment contains a %-format at the beginning\n-\t\t\t\tif lit[1] == '%' {\n-\t\t\t\t\t// \"%%\" is printed as a single \"%\"\n-\t\t\t\t\ts.Write(lit[1:])\n-\t\t\t\t} else {\n-\t\t\t\t\t// use s instead of s.output to get indentation right\n-\t\t\t\t\tfmt.Fprintf(s, string(lit), value.Interface())\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// segment contains no %-formats\n-\t\t\t\ts.Write(lit)\n-\t\t\t}\n-\t\t}\n-\t\treturn true // a literal never evaluates to nil\n-\n-\tcase *field:\n-\t\t// determine field value\n-\t\tswitch t.fieldName {\n-\t\tcase \"@\":\n-\t\t\t// field value is current value\n-\n-\t\tcase \"*\":\n-\t\t\t// indirection: operation is type-specific\n-\t\t\tswitch v := value; v.Kind() {\n-\t\t\tcase reflect.Array:\n-\t\t\t\tif v.Len() <= index {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tvalue = v.Index(index)\n-\n-\t\t\tcase reflect.Slice:\n-\t\t\t\tif v.IsNil() || v.Len() <= index {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tvalue = v.Index(index)\n-\n-\t\t\tcase reflect.Map:\n-\t\t\t\ts.error(\"reflection support for maps incomplete\")\n-\n-\t\t\tcase reflect.Ptr:\n-\t\t\t\tif v.IsNil() {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tvalue = v.Elem()\n-\n-\t\t\tcase reflect.Interface:\n-\t\t\t\tif v.IsNil() {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tvalue = v.Elem()\n-\n-\t\t\tcase reflect.Chan:\n-\t\t\t\ts.error(\"reflection support for chans incomplete\")\n-\n-\t\t\tcase reflect.Func:\n-\t\t\t\ts.error(\"reflection support for funcs incomplete\")\n-\n-\t\t\tdefault:\n-\t\t\t\ts.error(fmt.Sprintf(\"error: * does not apply to `%s`\", value.Type()))\n-\t\t\t}\n-\n-\t\tdefault:\n-\t\t\t// value is value of named field\n-\t\t\tvar field reflect.Value\n-\t\t\tif sval := value; sval.Kind() == reflect.Struct {\n-\t\t\t\tfield = sval.FieldByName(t.fieldName)\n-\t\t\t\tif !field.IsValid() {\n-\t\t\t\t\t// TODO consider just returning false in this case\n-\t\t\t\t\ts.error(fmt.Sprintf(\"error: no field `%s` in `%s`\", t.fieldName, value.Type()))\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tvalue = field\n-\t\t}\n-\n-\t\t// determine rule\n-\t\truleName := t.ruleName\n-\t\tif ruleName == \"\" {\n-\t\t\t// no alternate rule name, value type determines rule\n-\t\t\truleName = typename(value.Type())\n-\t\t}\n-\t\tfexpr = s.getFormat(ruleName)\n-\n-\t\tmark := s.save()\n-\t\tif !s.eval(fexpr, value, index) {\n-\t\t\ts.restore(mark)\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n-\n-\tcase *group:\n-\t\t// remember current indentation\n-\t\tindentLen := s.indent.Len()\n-\n-\t\t// update current indentation\n-\t\tmark := s.save()\n-\t\ts.eval(t.indent, value, index)\n-\t\t// if the indentation evaluates to nil, the state's output buffer\n-\t\t// didn't change - either way it's ok to append the difference to\n-\t\t// the current indentation\n-\t\ts.indent.Write(s.output.Bytes()[mark.outputLen:s.output.Len()])\n-\t\ts.restore(mark)\n-\n-\t\t// format group body\n-\t\tmark = s.save()\n-\t\tb := true\n-\t\tif !s.eval(t.body, value, index) {\n-\t\t\ts.restore(mark)\n-\t\t\tb = false\n-\t\t}\n-\n-\t\t// reset indentation\n-\t\ts.indent.Truncate(indentLen)\n-\t\treturn b\n-\n-\tcase *option:\n-\t\t// evaluate the body and append the result to the state's output\n-\t\t// buffer unless the result is nil\n-\t\tmark := s.save()\n-\t\tif !s.eval(t.body, value, 0) { // TODO is 0 index correct?\n-\t\t\ts.restore(mark)\n-\t\t}\n-\t\treturn true // an option never evaluates to nil\n-\n-\tcase *repetition:\n-\t\t// evaluate the body and append the result to the state's output\n-\t\t// buffer until a result is nil\n-\t\tfor i := 0; ; i++ {\n-\t\t\tmark := s.save()\n-\t\t\t// write separator, if any\n-\t\t\tif i > 0 && t.separator != nil {\n-\t\t\t\t// nil result from separator is ignored\n-\t\t\t\tmark := s.save()\n-\t\t\t\tif !s.eval(t.separator, value, i) {\n-\t\t\t\t\ts.restore(mark)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif !s.eval(t.body, value, i) {\n-\t\t\t\ts.restore(mark)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\treturn true // a repetition never evaluates to nil\n-\n-\tcase *custom:\n-\t\t// invoke the custom formatter to obtain the result\n-\t\tmark := s.save()\n-\t\tif !t.fun(s, value.Interface(), t.ruleName) {\n-\t\t\ts.restore(mark)\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n-\t}\n-\n-\tpanic(\"unreachable\")\n-\treturn false\n-}\n-\n-// Eval formats each argument according to the format\n-// f and returns the resulting []byte and os.Error. If\n-// an error occurred, the []byte contains the partially\n-// formatted result. An environment env may be passed\n-// in which is available in custom formatters through\n-// the state parameter.\n-//\n-func (f Format) Eval(env Environment, args ...interface{}) ([]byte, os.Error) {\n-\tif f == nil {\n-\t\treturn nil, os.NewError(\"format is nil\")\n-\t}\n-\n-\terrors := make(chan os.Error)\n-\ts := newState(f, env, errors)\n-\n-\tgo func() {\n-\t\tfor _, v := range args {\n-\t\t\tfld := reflect.ValueOf(v)\n-\t\t\tif !fld.IsValid() {\n-\t\t\t\terrors <- os.NewError(\"nil argument\")\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tmark := s.save()\n-\t\t\tif !s.eval(s.getFormat(typename(fld.Type())), fld, 0) { // TODO is 0 index correct?\n-\t\t\t\ts.restore(mark)\n-\t\t\t}\n-\t\t}\n-\t\terrors <- nil // no errors\n-\t}()\n-\n-\terr := <-errors\n-\treturn s.output.Bytes(), err\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Convenience functions\n-\n-// Fprint formats each argument according to the format f\n-// and writes to w. The result is the total number of bytes\n-// written and an os.Error, if any.\n-//\n-func (f Format) Fprint(w io.Writer, env Environment, args ...interface{}) (int, os.Error) {\n-\tdata, err := f.Eval(env, args...)\n-\tif err != nil {\n-\t\t// TODO should we print partial result in case of error?\n-\t\treturn 0, err\n-\t}\n-\treturn w.Write(data)\n-}\n-\n-// Print formats each argument according to the format f\n-// and writes to standard output. The result is the total\n-// number of bytes written and an os.Error, if any.\n-//\n-func (f Format) Print(args ...interface{}) (int, os.Error) {\n-\treturn f.Fprint(os.Stdout, nil, args...)\n-}\n-\n-// Sprint formats each argument according to the format f\n-// and returns the resulting string. If an error occurs\n-// during formatting, the result string contains the\n-// partially formatted result followed by an error message.\n-//\n-func (f Format) Sprint(args ...interface{}) string {\n-\tvar buf bytes.Buffer\n-\t_, err := f.Fprint(&buf, nil, args...)\n-\tif err != nil {\n-\t\tvar i interface{} = args\n-\t\tfmt.Fprintf(&buf, \"--- Sprint(%s) failed: %v\", fmt.Sprint(i), err)\n-\t}\n-\treturn buf.String()\n-}"}, {"sha": "87d07165933d44a4a9e3c884f42c57443e0fab73", "filename": "libgo/go/exp/datafmt/datafmt_test.go", "status": "removed", "additions": 0, "deletions": 330, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b925a66096923d0fc3c8c87bc357d3e0d96a2f/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b925a66096923d0fc3c8c87bc357d3e0d96a2f/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fdatafmt_test.go?ref=89b925a66096923d0fc3c8c87bc357d3e0d96a2f", "patch": "@@ -1,330 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package datafmt\n-\n-import (\n-\t\"fmt\"\n-\t\"testing\"\n-\t\"go/token\"\n-)\n-\n-var fset = token.NewFileSet()\n-\n-func parse(t *testing.T, form string, fmap FormatterMap) Format {\n-\tf, err := Parse(fset, \"\", []byte(form), fmap)\n-\tif err != nil {\n-\t\tt.Errorf(\"Parse(%s): %v\", form, err)\n-\t\treturn nil\n-\t}\n-\treturn f\n-}\n-\n-func verify(t *testing.T, f Format, expected string, args ...interface{}) {\n-\tif f == nil {\n-\t\treturn // allow other tests to run\n-\t}\n-\tresult := f.Sprint(args...)\n-\tif result != expected {\n-\t\tt.Errorf(\n-\t\t\t\"result  : `%s`\\nexpected: `%s`\\n\\n\",\n-\t\t\tresult, expected)\n-\t}\n-}\n-\n-func formatter(s *State, value interface{}, rule_name string) bool {\n-\tswitch rule_name {\n-\tcase \"/\":\n-\t\tfmt.Fprintf(s, \"%d %d %d\", s.Pos().Line, s.LinePos().Column, s.Pos().Column)\n-\t\treturn true\n-\tcase \"blank\":\n-\t\ts.Write([]byte{' '})\n-\t\treturn true\n-\tcase \"int\":\n-\t\tif value.(int)&1 == 0 {\n-\t\t\tfmt.Fprint(s, \"even \")\n-\t\t} else {\n-\t\t\tfmt.Fprint(s, \"odd \")\n-\t\t}\n-\t\treturn true\n-\tcase \"nil\":\n-\t\treturn false\n-\tcase \"testing.T\":\n-\t\ts.Write([]byte(\"testing.T\"))\n-\t\treturn true\n-\t}\n-\tpanic(\"unreachable\")\n-\treturn false\n-}\n-\n-func TestCustomFormatters(t *testing.T) {\n-\tfmap0 := FormatterMap{\"/\": formatter}\n-\tfmap1 := FormatterMap{\"int\": formatter, \"blank\": formatter, \"nil\": formatter}\n-\tfmap2 := FormatterMap{\"testing.T\": formatter}\n-\n-\tf := parse(t, `int=`, fmap0)\n-\tverify(t, f, ``, 1, 2, 3)\n-\n-\tf = parse(t, `int=\"#\"`, nil)\n-\tverify(t, f, `###`, 1, 2, 3)\n-\n-\tf = parse(t, `int=\"#\";string=\"%s\"`, fmap0)\n-\tverify(t, f, \"#1 0 1#1 0 7#1 0 13\\n2 0 0foo2 0 8\\n\", 1, 2, 3, \"\\n\", \"foo\", \"\\n\")\n-\n-\tf = parse(t, ``, fmap1)\n-\tverify(t, f, `even odd even odd `, 0, 1, 2, 3)\n-\n-\tf = parse(t, `/ =@:blank; float64=\"#\"`, fmap1)\n-\tverify(t, f, `# # #`, 0.0, 1.0, 2.0)\n-\n-\tf = parse(t, `float64=@:nil`, fmap1)\n-\tverify(t, f, ``, 0.0, 1.0, 2.0)\n-\n-\tf = parse(t, `testing \"testing\"; ptr=*`, fmap2)\n-\tverify(t, f, `testing.T`, t)\n-\n-\t// TODO needs more tests\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Formatting of basic and simple composite types\n-\n-func check(t *testing.T, form, expected string, args ...interface{}) {\n-\tf := parse(t, form, nil)\n-\tif f == nil {\n-\t\treturn // allow other tests to run\n-\t}\n-\tresult := f.Sprint(args...)\n-\tif result != expected {\n-\t\tt.Errorf(\n-\t\t\t\"format  : %s\\nresult  : `%s`\\nexpected: `%s`\\n\\n\",\n-\t\t\tform, result, expected)\n-\t}\n-}\n-\n-func TestBasicTypes(t *testing.T) {\n-\tcheck(t, ``, ``)\n-\tcheck(t, `bool=\":%v\"`, `:true:false`, true, false)\n-\tcheck(t, `int=\"%b %d %o 0x%x\"`, `101010 42 52 0x2a`, 42)\n-\n-\tcheck(t, `int=\"%\"`, `%`, 42)\n-\tcheck(t, `int=\"%%\"`, `%`, 42)\n-\tcheck(t, `int=\"**%%**\"`, `**%**`, 42)\n-\tcheck(t, `int=\"%%%%%%\"`, `%%%`, 42)\n-\tcheck(t, `int=\"%%%d%%\"`, `%42%`, 42)\n-\n-\tconst i = -42\n-\tconst is = `-42`\n-\tcheck(t, `int  =\"%d\"`, is, i)\n-\tcheck(t, `int8 =\"%d\"`, is, int8(i))\n-\tcheck(t, `int16=\"%d\"`, is, int16(i))\n-\tcheck(t, `int32=\"%d\"`, is, int32(i))\n-\tcheck(t, `int64=\"%d\"`, is, int64(i))\n-\n-\tconst u = 42\n-\tconst us = `42`\n-\tcheck(t, `uint  =\"%d\"`, us, uint(u))\n-\tcheck(t, `uint8 =\"%d\"`, us, uint8(u))\n-\tcheck(t, `uint16=\"%d\"`, us, uint16(u))\n-\tcheck(t, `uint32=\"%d\"`, us, uint32(u))\n-\tcheck(t, `uint64=\"%d\"`, us, uint64(u))\n-\n-\tconst f = 3.141592\n-\tconst fs = `3.141592`\n-\tcheck(t, `float64=\"%g\"`, fs, f)\n-\tcheck(t, `float32=\"%g\"`, fs, float32(f))\n-\tcheck(t, `float64=\"%g\"`, fs, float64(f))\n-}\n-\n-func TestArrayTypes(t *testing.T) {\n-\tvar a0 [10]int\n-\tcheck(t, `array=\"array\";`, `array`, a0)\n-\n-\ta1 := [...]int{1, 2, 3}\n-\tcheck(t, `array=\"array\";`, `array`, a1)\n-\tcheck(t, `array={*}; int=\"%d\";`, `123`, a1)\n-\tcheck(t, `array={* / \", \"}; int=\"%d\";`, `1, 2, 3`, a1)\n-\tcheck(t, `array={* / *}; int=\"%d\";`, `12233`, a1)\n-\n-\ta2 := []interface{}{42, \"foo\", 3.14}\n-\tcheck(t, `array={* / \", \"}; interface=*; string=\"bar\"; default=\"%v\";`, `42, bar, 3.14`, a2)\n-}\n-\n-func TestChanTypes(t *testing.T) {\n-\tvar c0 chan int\n-\tcheck(t, `chan=\"chan\"`, `chan`, c0)\n-\n-\tc1 := make(chan int)\n-\tgo func() { c1 <- 42 }()\n-\tcheck(t, `chan=\"chan\"`, `chan`, c1)\n-\t// check(t, `chan=*`, `42`, c1);  // reflection support for chans incomplete\n-}\n-\n-func TestFuncTypes(t *testing.T) {\n-\tvar f0 func() int\n-\tcheck(t, `func=\"func\"`, `func`, f0)\n-\n-\tf1 := func() int { return 42 }\n-\tcheck(t, `func=\"func\"`, `func`, f1)\n-\t// check(t, `func=*`, `42`, f1);  // reflection support for funcs incomplete\n-}\n-\n-func TestMapTypes(t *testing.T) {\n-\tvar m0 map[string]int\n-\tcheck(t, `map=\"map\"`, `map`, m0)\n-\n-\tm1 := map[string]int{}\n-\tcheck(t, `map=\"map\"`, `map`, m1)\n-\t// check(t, `map=*`, ``, m1);  // reflection support for maps incomplete\n-}\n-\n-func TestPointerTypes(t *testing.T) {\n-\tvar p0 *int\n-\tcheck(t, `ptr=\"ptr\"`, `ptr`, p0)\n-\tcheck(t, `ptr=*`, ``, p0)\n-\tcheck(t, `ptr=*|\"nil\"`, `nil`, p0)\n-\n-\tx := 99991\n-\tp1 := &x\n-\tcheck(t, `ptr=\"ptr\"`, `ptr`, p1)\n-\tcheck(t, `ptr=*; int=\"%d\"`, `99991`, p1)\n-}\n-\n-func TestDefaultRule(t *testing.T) {\n-\tcheck(t, `default=\"%v\"`, `42foo3.14`, 42, \"foo\", 3.14)\n-\tcheck(t, `default=\"%v\"; int=\"%x\"`, `abcdef`, 10, 11, 12, 13, 14, 15)\n-\tcheck(t, `default=\"%v\"; int=\"%x\"`, `ab**ef`, 10, 11, \"**\", 14, 15)\n-\tcheck(t, `default=\"%x\"; int=@:default`, `abcdef`, 10, 11, 12, 13, 14, 15)\n-}\n-\n-func TestGlobalSeparatorRule(t *testing.T) {\n-\tcheck(t, `int=\"%d\"; / =\"-\"`, `1-2-3-4`, 1, 2, 3, 4)\n-\tcheck(t, `int=\"%x%x\"; / =\"*\"`, `aa*aa`, 10, 10)\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Formatting of a struct\n-\n-type T1 struct {\n-\ta int\n-}\n-\n-const F1 = `datafmt \"datafmt\";` +\n-\t`int = \"%d\";` +\n-\t`datafmt.T1 = \"<\" a \">\";`\n-\n-func TestStruct1(t *testing.T) { check(t, F1, \"<42>\", T1{42}) }\n-\n-// ----------------------------------------------------------------------------\n-// Formatting of a struct with an optional field (ptr)\n-\n-type T2 struct {\n-\ts string\n-\tp *T1\n-}\n-\n-const F2a = F1 +\n-\t`string = \"%s\";` +\n-\t`ptr = *;` +\n-\t`datafmt.T2 = s [\"-\" p \"-\"];`\n-\n-const F2b = F1 +\n-\t`string = \"%s\";` +\n-\t`ptr = *;` +\n-\t`datafmt.T2 = s (\"-\" p \"-\" | \"empty\");`\n-\n-func TestStruct2(t *testing.T) {\n-\tcheck(t, F2a, \"foo\", T2{\"foo\", nil})\n-\tcheck(t, F2a, \"bar-<17>-\", T2{\"bar\", &T1{17}})\n-\tcheck(t, F2b, \"fooempty\", T2{\"foo\", nil})\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Formatting of a struct with a repetitive field (slice)\n-\n-type T3 struct {\n-\ts string\n-\ta []int\n-}\n-\n-const F3a = `datafmt \"datafmt\";` +\n-\t`default = \"%v\";` +\n-\t`array = *;` +\n-\t`datafmt.T3 = s  {\" \" a a / \",\"};`\n-\n-const F3b = `datafmt \"datafmt\";` +\n-\t`int = \"%d\";` +\n-\t`string = \"%s\";` +\n-\t`array = *;` +\n-\t`nil = ;` +\n-\t`empty = *:nil;` +\n-\t`datafmt.T3 = s [a:empty \": \" {a / \"-\"}]`\n-\n-func TestStruct3(t *testing.T) {\n-\tcheck(t, F3a, \"foo\", T3{\"foo\", nil})\n-\tcheck(t, F3a, \"foo 00, 11, 22\", T3{\"foo\", []int{0, 1, 2}})\n-\tcheck(t, F3b, \"bar\", T3{\"bar\", nil})\n-\tcheck(t, F3b, \"bal: 2-3-5\", T3{\"bal\", []int{2, 3, 5}})\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Formatting of a struct with alternative field\n-\n-type T4 struct {\n-\tx *int\n-\ta []int\n-}\n-\n-const F4a = `datafmt \"datafmt\";` +\n-\t`int = \"%d\";` +\n-\t`ptr = *;` +\n-\t`array = *;` +\n-\t`nil = ;` +\n-\t`empty = *:nil;` +\n-\t`datafmt.T4 = \"<\" (x:empty x | \"-\") \">\" `\n-\n-const F4b = `datafmt \"datafmt\";` +\n-\t`int = \"%d\";` +\n-\t`ptr = *;` +\n-\t`array = *;` +\n-\t`nil = ;` +\n-\t`empty = *:nil;` +\n-\t`datafmt.T4 = \"<\" (a:empty {a / \", \"} | \"-\") \">\" `\n-\n-func TestStruct4(t *testing.T) {\n-\tx := 7\n-\tcheck(t, F4a, \"<->\", T4{nil, nil})\n-\tcheck(t, F4a, \"<7>\", T4{&x, nil})\n-\tcheck(t, F4b, \"<->\", T4{nil, nil})\n-\tcheck(t, F4b, \"<2, 3, 7>\", T4{nil, []int{2, 3, 7}})\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Formatting a struct (documentation example)\n-\n-type Point struct {\n-\tname string\n-\tx, y int\n-}\n-\n-const FPoint = `datafmt \"datafmt\";` +\n-\t`int = \"%d\";` +\n-\t`hexInt = \"0x%x\";` +\n-\t`string = \"---%s---\";` +\n-\t`datafmt.Point = name \"{\" x \", \" y:hexInt \"}\";`\n-\n-func TestStructPoint(t *testing.T) {\n-\tp := Point{\"foo\", 3, 15}\n-\tcheck(t, FPoint, \"---foo---{3, 0xf}\", p)\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Formatting a slice (documentation example)\n-\n-const FSlice = `int = \"%b\";` +\n-\t`array = { * / \", \" }`\n-\n-func TestSlice(t *testing.T) { check(t, FSlice, \"10, 11, 101, 111\", []int{2, 3, 5, 7}) }\n-\n-// TODO add more tests"}, {"sha": "a2ddd389723e754cd0cae204825aec1962fd817e", "filename": "libgo/go/exp/datafmt/parser.go", "status": "removed", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b925a66096923d0fc3c8c87bc357d3e0d96a2f/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b925a66096923d0fc3c8c87bc357d3e0d96a2f/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go?ref=89b925a66096923d0fc3c8c87bc357d3e0d96a2f", "patch": "@@ -1,368 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package datafmt\n-\n-import (\n-\t\"go/scanner\"\n-\t\"go/token\"\n-\t\"os\"\n-\t\"strconv\"\n-\t\"strings\"\n-)\n-\n-// ----------------------------------------------------------------------------\n-// Parsing\n-\n-type parser struct {\n-\tscanner.ErrorVector\n-\tscanner scanner.Scanner\n-\tfile    *token.File\n-\tpos     token.Pos   // token position\n-\ttok     token.Token // one token look-ahead\n-\tlit     string      // token literal\n-\n-\tpacks map[string]string // PackageName -> ImportPath\n-\trules map[string]expr   // RuleName -> Expression\n-}\n-\n-func (p *parser) next() {\n-\tp.pos, p.tok, p.lit = p.scanner.Scan()\n-\tswitch p.tok {\n-\tcase token.CHAN, token.FUNC, token.INTERFACE, token.MAP, token.STRUCT:\n-\t\t// Go keywords for composite types are type names\n-\t\t// returned by reflect. Accept them as identifiers.\n-\t\tp.tok = token.IDENT // p.lit is already set correctly\n-\t}\n-}\n-\n-func (p *parser) init(fset *token.FileSet, filename string, src []byte) {\n-\tp.ErrorVector.Reset()\n-\tp.file = fset.AddFile(filename, fset.Base(), len(src))\n-\tp.scanner.Init(p.file, src, p, scanner.AllowIllegalChars) // return '@' as token.ILLEGAL w/o error message\n-\tp.next()                                                  // initializes pos, tok, lit\n-\tp.packs = make(map[string]string)\n-\tp.rules = make(map[string]expr)\n-}\n-\n-func (p *parser) error(pos token.Pos, msg string) {\n-\tp.Error(p.file.Position(pos), msg)\n-}\n-\n-func (p *parser) errorExpected(pos token.Pos, msg string) {\n-\tmsg = \"expected \" + msg\n-\tif pos == p.pos {\n-\t\t// the error happened at the current position;\n-\t\t// make the error message more specific\n-\t\tmsg += \", found '\" + p.tok.String() + \"'\"\n-\t\tif p.tok.IsLiteral() {\n-\t\t\tmsg += \" \" + p.lit\n-\t\t}\n-\t}\n-\tp.error(pos, msg)\n-}\n-\n-func (p *parser) expect(tok token.Token) token.Pos {\n-\tpos := p.pos\n-\tif p.tok != tok {\n-\t\tp.errorExpected(pos, \"'\"+tok.String()+\"'\")\n-\t}\n-\tp.next() // make progress in any case\n-\treturn pos\n-}\n-\n-func (p *parser) parseIdentifier() string {\n-\tname := p.lit\n-\tp.expect(token.IDENT)\n-\treturn name\n-}\n-\n-func (p *parser) parseTypeName() (string, bool) {\n-\tpos := p.pos\n-\tname, isIdent := p.parseIdentifier(), true\n-\tif p.tok == token.PERIOD {\n-\t\t// got a package name, lookup package\n-\t\tif importPath, found := p.packs[name]; found {\n-\t\t\tname = importPath\n-\t\t} else {\n-\t\t\tp.error(pos, \"package not declared: \"+name)\n-\t\t}\n-\t\tp.next()\n-\t\tname, isIdent = name+\".\"+p.parseIdentifier(), false\n-\t}\n-\treturn name, isIdent\n-}\n-\n-// Parses a rule name and returns it. If the rule name is\n-// a package-qualified type name, the package name is resolved.\n-// The 2nd result value is true iff the rule name consists of a\n-// single identifier only (and thus could be a package name).\n-//\n-func (p *parser) parseRuleName() (string, bool) {\n-\tname, isIdent := \"\", false\n-\tswitch p.tok {\n-\tcase token.IDENT:\n-\t\tname, isIdent = p.parseTypeName()\n-\tcase token.DEFAULT:\n-\t\tname = \"default\"\n-\t\tp.next()\n-\tcase token.QUO:\n-\t\tname = \"/\"\n-\t\tp.next()\n-\tdefault:\n-\t\tp.errorExpected(p.pos, \"rule name\")\n-\t\tp.next() // make progress in any case\n-\t}\n-\treturn name, isIdent\n-}\n-\n-func (p *parser) parseString() string {\n-\ts := \"\"\n-\tif p.tok == token.STRING {\n-\t\ts, _ = strconv.Unquote(p.lit)\n-\t\t// Unquote may fail with an error, but only if the scanner found\n-\t\t// an illegal string in the first place. In this case the error\n-\t\t// has already been reported.\n-\t\tp.next()\n-\t\treturn s\n-\t} else {\n-\t\tp.expect(token.STRING)\n-\t}\n-\treturn s\n-}\n-\n-func (p *parser) parseLiteral() literal {\n-\ts := []byte(p.parseString())\n-\n-\t// A string literal may contain %-format specifiers. To simplify\n-\t// and speed up printing of the literal, split it into segments\n-\t// that start with \"%\" possibly followed by a last segment that\n-\t// starts with some other character.\n-\tvar list []interface{}\n-\ti0 := 0\n-\tfor i := 0; i < len(s); i++ {\n-\t\tif s[i] == '%' && i+1 < len(s) {\n-\t\t\t// the next segment starts with a % format\n-\t\t\tif i0 < i {\n-\t\t\t\t// the current segment is not empty, split it off\n-\t\t\t\tlist = append(list, s[i0:i])\n-\t\t\t\ti0 = i\n-\t\t\t}\n-\t\t\ti++ // skip %; let loop skip over char after %\n-\t\t}\n-\t}\n-\t// the final segment may start with any character\n-\t// (it is empty iff the string is empty)\n-\tlist = append(list, s[i0:])\n-\n-\t// convert list into a literal\n-\tlit := make(literal, len(list))\n-\tfor i := 0; i < len(list); i++ {\n-\t\tlit[i] = list[i].([]byte)\n-\t}\n-\n-\treturn lit\n-}\n-\n-func (p *parser) parseField() expr {\n-\tvar fname string\n-\tswitch p.tok {\n-\tcase token.ILLEGAL:\n-\t\tif p.lit != \"@\" {\n-\t\t\treturn nil\n-\t\t}\n-\t\tfname = \"@\"\n-\t\tp.next()\n-\tcase token.MUL:\n-\t\tfname = \"*\"\n-\t\tp.next()\n-\tcase token.IDENT:\n-\t\tfname = p.parseIdentifier()\n-\tdefault:\n-\t\treturn nil\n-\t}\n-\n-\tvar ruleName string\n-\tif p.tok == token.COLON {\n-\t\tp.next()\n-\t\truleName, _ = p.parseRuleName()\n-\t}\n-\n-\treturn &field{fname, ruleName}\n-}\n-\n-func (p *parser) parseOperand() (x expr) {\n-\tswitch p.tok {\n-\tcase token.STRING:\n-\t\tx = p.parseLiteral()\n-\n-\tcase token.LPAREN:\n-\t\tp.next()\n-\t\tx = p.parseExpression()\n-\t\tif p.tok == token.SHR {\n-\t\t\tp.next()\n-\t\t\tx = &group{x, p.parseExpression()}\n-\t\t}\n-\t\tp.expect(token.RPAREN)\n-\n-\tcase token.LBRACK:\n-\t\tp.next()\n-\t\tx = &option{p.parseExpression()}\n-\t\tp.expect(token.RBRACK)\n-\n-\tcase token.LBRACE:\n-\t\tp.next()\n-\t\tx = p.parseExpression()\n-\t\tvar div expr\n-\t\tif p.tok == token.QUO {\n-\t\t\tp.next()\n-\t\t\tdiv = p.parseExpression()\n-\t\t}\n-\t\tx = &repetition{x, div}\n-\t\tp.expect(token.RBRACE)\n-\n-\tdefault:\n-\t\tx = p.parseField() // may be nil\n-\t}\n-\n-\treturn x\n-}\n-\n-func (p *parser) parseSequence() expr {\n-\tvar list []interface{}\n-\n-\tfor x := p.parseOperand(); x != nil; x = p.parseOperand() {\n-\t\tlist = append(list, x)\n-\t}\n-\n-\t// no need for a sequence if list.Len() < 2\n-\tswitch len(list) {\n-\tcase 0:\n-\t\treturn nil\n-\tcase 1:\n-\t\treturn list[0].(expr)\n-\t}\n-\n-\t// convert list into a sequence\n-\tseq := make(sequence, len(list))\n-\tfor i := 0; i < len(list); i++ {\n-\t\tseq[i] = list[i].(expr)\n-\t}\n-\treturn seq\n-}\n-\n-func (p *parser) parseExpression() expr {\n-\tvar list []interface{}\n-\n-\tfor {\n-\t\tx := p.parseSequence()\n-\t\tif x != nil {\n-\t\t\tlist = append(list, x)\n-\t\t}\n-\t\tif p.tok != token.OR {\n-\t\t\tbreak\n-\t\t}\n-\t\tp.next()\n-\t}\n-\n-\t// no need for an alternatives if list.Len() < 2\n-\tswitch len(list) {\n-\tcase 0:\n-\t\treturn nil\n-\tcase 1:\n-\t\treturn list[0].(expr)\n-\t}\n-\n-\t// convert list into a alternatives\n-\talt := make(alternatives, len(list))\n-\tfor i := 0; i < len(list); i++ {\n-\t\talt[i] = list[i].(expr)\n-\t}\n-\treturn alt\n-}\n-\n-func (p *parser) parseFormat() {\n-\tfor p.tok != token.EOF {\n-\t\tpos := p.pos\n-\n-\t\tname, isIdent := p.parseRuleName()\n-\t\tswitch p.tok {\n-\t\tcase token.STRING:\n-\t\t\t// package declaration\n-\t\t\timportPath := p.parseString()\n-\n-\t\t\t// add package declaration\n-\t\t\tif !isIdent {\n-\t\t\t\tp.error(pos, \"illegal package name: \"+name)\n-\t\t\t} else if _, found := p.packs[name]; !found {\n-\t\t\t\tp.packs[name] = importPath\n-\t\t\t} else {\n-\t\t\t\tp.error(pos, \"package already declared: \"+name)\n-\t\t\t}\n-\n-\t\tcase token.ASSIGN:\n-\t\t\t// format rule\n-\t\t\tp.next()\n-\t\t\tx := p.parseExpression()\n-\n-\t\t\t// add rule\n-\t\t\tif _, found := p.rules[name]; !found {\n-\t\t\t\tp.rules[name] = x\n-\t\t\t} else {\n-\t\t\t\tp.error(pos, \"format rule already declared: \"+name)\n-\t\t\t}\n-\n-\t\tdefault:\n-\t\t\tp.errorExpected(p.pos, \"package declaration or format rule\")\n-\t\t\tp.next() // make progress in any case\n-\t\t}\n-\n-\t\tif p.tok == token.SEMICOLON {\n-\t\t\tp.next()\n-\t\t} else {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tp.expect(token.EOF)\n-}\n-\n-func remap(p *parser, name string) string {\n-\ti := strings.Index(name, \".\")\n-\tif i >= 0 {\n-\t\tpackageName, suffix := name[0:i], name[i:]\n-\t\t// lookup package\n-\t\tif importPath, found := p.packs[packageName]; found {\n-\t\t\tname = importPath + suffix\n-\t\t} else {\n-\t\t\tvar invalidPos token.Position\n-\t\t\tp.Error(invalidPos, \"package not declared: \"+packageName)\n-\t\t}\n-\t}\n-\treturn name\n-}\n-\n-// Parse parses a set of format productions from source src. Custom\n-// formatters may be provided via a map of formatter functions. If\n-// there are no errors, the result is a Format and the error is nil.\n-// Otherwise the format is nil and a non-empty ErrorList is returned.\n-//\n-func Parse(fset *token.FileSet, filename string, src []byte, fmap FormatterMap) (Format, os.Error) {\n-\t// parse source\n-\tvar p parser\n-\tp.init(fset, filename, src)\n-\tp.parseFormat()\n-\n-\t// add custom formatters, if any\n-\tfor name, form := range fmap {\n-\t\tname = remap(&p, name)\n-\t\tif _, found := p.rules[name]; !found {\n-\t\t\tp.rules[name] = &custom{name, form}\n-\t\t} else {\n-\t\t\tvar invalidPos token.Position\n-\t\t\tp.Error(invalidPos, \"formatter already declared: \"+name)\n-\t\t}\n-\t}\n-\n-\treturn p.rules, p.GetError(scanner.NoMultiples)\n-}"}, {"sha": "38218dfdc10fedcdd15144e1153fc3aecc87aeb6", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -61,7 +61,7 @@ type I int\n func (i I) String() string { return Sprintf(\"<%d>\", int(i)) }\n \n type B struct {\n-\ti I\n+\tI I\n \tj int\n }\n \n@@ -83,8 +83,8 @@ func (g G) GoString() string {\n }\n \n type S struct {\n-\tf F // a struct field that Formats\n-\tg G // a struct field that GoStrings\n+\tF F // a struct field that Formats\n+\tG G // a struct field that GoStrings\n }\n \n // A type with a String method with pointer receiver for testing %p\n@@ -332,8 +332,8 @@ var fmttests = []struct {\n \t{\"%+v\", A{1, 2, \"a\", []int{1, 2}}, `{i:1 j:2 s:a x:[1 2]}`},\n \n \t// +v on structs with Stringable items\n-\t{\"%+v\", B{1, 2}, `{i:<1> j:2}`},\n-\t{\"%+v\", C{1, B{2, 3}}, `{i:1 B:{i:<2> j:3}}`},\n+\t{\"%+v\", B{1, 2}, `{I:<1> j:2}`},\n+\t{\"%+v\", C{1, B{2, 3}}, `{i:1 B:{I:<2> j:3}}`},\n \n \t// q on Stringable items\n \t{\"%s\", I(23), `<23>`},\n@@ -349,7 +349,7 @@ var fmttests = []struct {\n \t{\"%#v\", uint64(1<<64 - 1), \"0xffffffffffffffff\"},\n \t{\"%#v\", 1000000000, \"1000000000\"},\n \t{\"%#v\", map[string]int{\"a\": 1, \"b\": 2}, `map[string] int{\"a\":1, \"b\":2}`},\n-\t{\"%#v\", map[string]B{\"a\": {1, 2}, \"b\": {3, 4}}, `map[string] fmt_test.B{\"a\":fmt_test.B{i:1, j:2}, \"b\":fmt_test.B{i:3, j:4}}`},\n+\t{\"%#v\", map[string]B{\"a\": {1, 2}, \"b\": {3, 4}}, `map[string] fmt_test.B{\"a\":fmt_test.B{I:1, j:2}, \"b\":fmt_test.B{I:3, j:4}}`},\n \t{\"%#v\", []string{\"a\", \"b\"}, `[]string{\"a\", \"b\"}`},\n \n \t// slices with other formats\n@@ -384,11 +384,11 @@ var fmttests = []struct {\n \t// Formatter\n \t{\"%x\", F(1), \"<x=F(1)>\"},\n \t{\"%x\", G(2), \"2\"},\n-\t{\"%+v\", S{F(4), G(5)}, \"{f:<v=F(4)> g:5}\"},\n+\t{\"%+v\", S{F(4), G(5)}, \"{F:<v=F(4)> G:5}\"},\n \n \t// GoStringer\n \t{\"%#v\", G(6), \"GoString(6)\"},\n-\t{\"%#v\", S{F(7), G(8)}, \"fmt_test.S{f:<v=F(7)>, g:GoString(8)}\"},\n+\t{\"%#v\", S{F(7), G(8)}, \"fmt_test.S{F:<v=F(7)>, G:GoString(8)}\"},\n \n \t// %T\n \t{\"%T\", (4 - 3i), \"complex128\"},"}, {"sha": "136aebd3362f19d4df01f5d0495bf6e8eb1fd147", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 152, "deletions": 95, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -258,10 +258,8 @@ func Sprintln(a ...interface{}) string {\n // the thing inside the interface, not the interface itself.\n func getField(v reflect.Value, i int) reflect.Value {\n \tval := v.Field(i)\n-\tif i := val; i.Kind() == reflect.Interface {\n-\t\tif inter := i.Interface(); inter != nil {\n-\t\t\treturn reflect.ValueOf(inter)\n-\t\t}\n+\tif val.Kind() == reflect.Interface && !val.IsNil() {\n+\t\tval = val.Elem()\n \t}\n \treturn val\n }\n@@ -288,27 +286,32 @@ func (p *pp) unknownType(v interface{}) {\n \tp.buf.WriteByte('?')\n }\n \n-func (p *pp) badVerb(verb int, val interface{}) {\n+func (p *pp) badVerb(verb int, val interface{}, val1 reflect.Value) {\n \tp.add('%')\n \tp.add('!')\n \tp.add(verb)\n \tp.add('(')\n-\tif val == nil {\n-\t\tp.buf.Write(nilAngleBytes)\n-\t} else {\n+\tswitch {\n+\tcase val != nil:\n \t\tp.buf.WriteString(reflect.TypeOf(val).String())\n \t\tp.add('=')\n \t\tp.printField(val, 'v', false, false, 0)\n+\tcase val1.IsValid():\n+\t\tp.buf.WriteString(val1.Type().String())\n+\t\tp.add('=')\n+\t\tp.printValue(val1, 'v', false, false, 0)\n+\tdefault:\n+\t\tp.buf.Write(nilAngleBytes)\n \t}\n \tp.add(')')\n }\n \n-func (p *pp) fmtBool(v bool, verb int, value interface{}) {\n+func (p *pp) fmtBool(v bool, verb int, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 't', 'v':\n \t\tp.fmt.fmt_boolean(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n@@ -322,7 +325,7 @@ func (p *pp) fmtC(c int64) {\n \tp.fmt.pad(p.runeBuf[0:w])\n }\n \n-func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n+func (p *pp) fmtInt64(v int64, verb int, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(v, 2, signed, ldigits)\n@@ -336,7 +339,7 @@ func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n \t\tif 0 <= v && v <= unicode.MaxRune {\n \t\t\tp.fmt.fmt_qc(v)\n \t\t} else {\n-\t\t\tp.badVerb(verb, value)\n+\t\t\tp.badVerb(verb, value, value1)\n \t\t}\n \tcase 'x':\n \t\tp.fmt.integer(v, 16, signed, ldigits)\n@@ -345,7 +348,7 @@ func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n \tcase 'X':\n \t\tp.fmt.integer(v, 16, signed, udigits)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n@@ -380,7 +383,7 @@ func (p *pp) fmtUnicode(v int64) {\n \tp.fmt.sharp = sharp\n }\n \n-func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n+func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(int64(v), 2, unsigned, ldigits)\n@@ -400,7 +403,7 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n \t\tif 0 <= v && v <= unicode.MaxRune {\n \t\t\tp.fmt.fmt_qc(int64(v))\n \t\t} else {\n-\t\t\tp.badVerb(verb, value)\n+\t\t\tp.badVerb(verb, value, value1)\n \t\t}\n \tcase 'x':\n \t\tp.fmt.integer(int64(v), 16, unsigned, ldigits)\n@@ -409,11 +412,11 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n \tcase 'U':\n \t\tp.fmtUnicode(int64(v))\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n-func (p *pp) fmtFloat32(v float32, verb int, value interface{}) {\n+func (p *pp) fmtFloat32(v float32, verb int, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.fmt_fb32(v)\n@@ -428,11 +431,11 @@ func (p *pp) fmtFloat32(v float32, verb int, value interface{}) {\n \tcase 'G':\n \t\tp.fmt.fmt_G32(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n-func (p *pp) fmtFloat64(v float64, verb int, value interface{}) {\n+func (p *pp) fmtFloat64(v float64, verb int, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.fmt_fb64(v)\n@@ -447,33 +450,33 @@ func (p *pp) fmtFloat64(v float64, verb int, value interface{}) {\n \tcase 'G':\n \t\tp.fmt.fmt_G64(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n-func (p *pp) fmtComplex64(v complex64, verb int, value interface{}) {\n+func (p *pp) fmtComplex64(v complex64, verb int, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c64(v, verb)\n \tcase 'v':\n \t\tp.fmt.fmt_c64(v, 'g')\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n-func (p *pp) fmtComplex128(v complex128, verb int, value interface{}) {\n+func (p *pp) fmtComplex128(v complex128, verb int, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c128(v, verb)\n \tcase 'v':\n \t\tp.fmt.fmt_c128(v, 'g')\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n-func (p *pp) fmtString(v string, verb int, goSyntax bool, value interface{}) {\n+func (p *pp) fmtString(v string, verb int, goSyntax bool, value interface{}, value1 reflect.Value) {\n \tswitch verb {\n \tcase 'v':\n \t\tif goSyntax {\n@@ -490,11 +493,11 @@ func (p *pp) fmtString(v string, verb int, goSyntax bool, value interface{}) {\n \tcase 'q':\n \t\tp.fmt.fmt_q(v)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n-func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interface{}) {\n+func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interface{}, value1 reflect.Value) {\n \tif verb == 'v' || verb == 'd' {\n \t\tif goSyntax {\n \t\t\tp.buf.Write(bytesBytes)\n@@ -529,7 +532,7 @@ func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interf\n \tcase 'q':\n \t\tp.fmt.fmt_q(s)\n \tdefault:\n-\t\tp.badVerb(verb, value)\n+\t\tp.badVerb(verb, value, value1)\n \t}\n }\n \n@@ -539,12 +542,12 @@ func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSynt\n \tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n \t\tu = value.Pointer()\n \tdefault:\n-\t\tp.badVerb(verb, field)\n+\t\tp.badVerb(verb, field, value)\n \t\treturn\n \t}\n \tif goSyntax {\n \t\tp.add('(')\n-\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n+\t\tp.buf.WriteString(value.Type().String())\n \t\tp.add(')')\n \t\tp.add('(')\n \t\tif u == 0 {\n@@ -590,138 +593,192 @@ func (p *pp) catchPanic(val interface{}, verb int) {\n \t}\n }\n \n-func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n-\tif field == nil {\n-\t\tif verb == 'T' || verb == 'v' {\n-\t\t\tp.buf.Write(nilAngleBytes)\n-\t\t} else {\n-\t\t\tp.badVerb(verb, field)\n-\t\t}\n-\t\treturn false\n-\t}\n-\n-\t// Special processing considerations.\n-\t// %T (the value's type) and %p (its address) are special; we always do them first.\n-\tswitch verb {\n-\tcase 'T':\n-\t\tp.printField(reflect.TypeOf(field).String(), 's', false, false, 0)\n-\t\treturn false\n-\tcase 'p':\n-\t\tp.fmtPointer(field, reflect.ValueOf(field), verb, goSyntax)\n-\t\treturn false\n-\t}\n+func (p *pp) handleMethods(field interface{}, verb int, plus, goSyntax bool, depth int) (wasString, handled bool) {\n \t// Is it a Formatter?\n \tif formatter, ok := field.(Formatter); ok {\n+\t\thandled = true\n+\t\twasString = false\n \t\tdefer p.catchPanic(field, verb)\n \t\tformatter.Format(p, verb)\n-\t\treturn false // this value is not a string\n-\n+\t\treturn\n \t}\n \t// Must not touch flags before Formatter looks at them.\n \tif plus {\n \t\tp.fmt.plus = false\n \t}\n+\n \t// If we're doing Go syntax and the field knows how to supply it, take care of it now.\n \tif goSyntax {\n \t\tp.fmt.sharp = false\n \t\tif stringer, ok := field.(GoStringer); ok {\n+\t\t\twasString = false\n+\t\t\thandled = true\n \t\t\tdefer p.catchPanic(field, verb)\n \t\t\t// Print the result of GoString unadorned.\n-\t\t\tp.fmtString(stringer.GoString(), 's', false, field)\n-\t\t\treturn false // this value is not a string\n+\t\t\tp.fmtString(stringer.GoString(), 's', false, field, reflect.Value{})\n+\t\t\treturn\n \t\t}\n \t} else {\n \t\t// Is it a Stringer?\n \t\tif stringer, ok := field.(Stringer); ok {\n+\t\t\twasString = false\n+\t\t\thandled = true\n \t\t\tdefer p.catchPanic(field, verb)\n \t\t\tp.printField(stringer.String(), verb, plus, false, depth)\n-\t\t\treturn false // this value is not a string\n+\t\t\treturn\n \t\t}\n \t}\n+\thandled = false\n+\treturn\n+}\n+\n+func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n+\tif field == nil {\n+\t\tif verb == 'T' || verb == 'v' {\n+\t\t\tp.buf.Write(nilAngleBytes)\n+\t\t} else {\n+\t\t\tp.badVerb(verb, field, reflect.Value{})\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\t// Special processing considerations.\n+\t// %T (the value's type) and %p (its address) are special; we always do them first.\n+\tswitch verb {\n+\tcase 'T':\n+\t\tp.printField(reflect.TypeOf(field).String(), 's', false, false, 0)\n+\t\treturn false\n+\tcase 'p':\n+\t\tp.fmtPointer(field, reflect.ValueOf(field), verb, goSyntax)\n+\t\treturn false\n+\t}\n+\n+\tif wasString, handled := p.handleMethods(field, verb, plus, goSyntax, depth); handled {\n+\t\treturn wasString\n+\t}\n \n \t// Some types can be done without reflection.\n \tswitch f := field.(type) {\n \tcase bool:\n-\t\tp.fmtBool(f, verb, field)\n+\t\tp.fmtBool(f, verb, field, reflect.Value{})\n \t\treturn false\n \tcase float32:\n-\t\tp.fmtFloat32(f, verb, field)\n+\t\tp.fmtFloat32(f, verb, field, reflect.Value{})\n \t\treturn false\n \tcase float64:\n-\t\tp.fmtFloat64(f, verb, field)\n+\t\tp.fmtFloat64(f, verb, field, reflect.Value{})\n \t\treturn false\n \tcase complex64:\n-\t\tp.fmtComplex64(complex64(f), verb, field)\n+\t\tp.fmtComplex64(complex64(f), verb, field, reflect.Value{})\n \t\treturn false\n \tcase complex128:\n-\t\tp.fmtComplex128(f, verb, field)\n+\t\tp.fmtComplex128(f, verb, field, reflect.Value{})\n \t\treturn false\n \tcase int:\n-\t\tp.fmtInt64(int64(f), verb, field)\n+\t\tp.fmtInt64(int64(f), verb, field, reflect.Value{})\n \t\treturn false\n \tcase int8:\n-\t\tp.fmtInt64(int64(f), verb, field)\n+\t\tp.fmtInt64(int64(f), verb, field, reflect.Value{})\n \t\treturn false\n \tcase int16:\n-\t\tp.fmtInt64(int64(f), verb, field)\n+\t\tp.fmtInt64(int64(f), verb, field, reflect.Value{})\n \t\treturn false\n \tcase int32:\n-\t\tp.fmtInt64(int64(f), verb, field)\n+\t\tp.fmtInt64(int64(f), verb, field, reflect.Value{})\n \t\treturn false\n \tcase int64:\n-\t\tp.fmtInt64(f, verb, field)\n+\t\tp.fmtInt64(f, verb, field, reflect.Value{})\n \t\treturn false\n \tcase uint:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax, field, reflect.Value{})\n \t\treturn false\n \tcase uint8:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax, field, reflect.Value{})\n \t\treturn false\n \tcase uint16:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax, field, reflect.Value{})\n \t\treturn false\n \tcase uint32:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax, field, reflect.Value{})\n \t\treturn false\n \tcase uint64:\n-\t\tp.fmtUint64(f, verb, goSyntax, field)\n+\t\tp.fmtUint64(f, verb, goSyntax, field, reflect.Value{})\n \t\treturn false\n \tcase uintptr:\n-\t\tp.fmtUint64(uint64(f), verb, goSyntax, field)\n+\t\tp.fmtUint64(uint64(f), verb, goSyntax, field, reflect.Value{})\n \t\treturn false\n \tcase string:\n-\t\tp.fmtString(f, verb, goSyntax, field)\n+\t\tp.fmtString(f, verb, goSyntax, field, reflect.Value{})\n \t\treturn verb == 's' || verb == 'v'\n \tcase []byte:\n-\t\tp.fmtBytes(f, verb, goSyntax, depth, field)\n+\t\tp.fmtBytes(f, verb, goSyntax, depth, field, reflect.Value{})\n \t\treturn verb == 's'\n \t}\n \n \t// Need to use reflection\n-\tvalue := reflect.ValueOf(field)\n+\treturn p.printReflectValue(reflect.ValueOf(field), verb, plus, goSyntax, depth)\n+}\n+\n+// printValue is like printField but starts with a reflect value, not an interface{} value.\n+func (p *pp) printValue(value reflect.Value, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n+\tif !value.IsValid() {\n+\t\tif verb == 'T' || verb == 'v' {\n+\t\t\tp.buf.Write(nilAngleBytes)\n+\t\t} else {\n+\t\t\tp.badVerb(verb, nil, value)\n+\t\t}\n+\t\treturn false\n+\t}\n \n+\t// Special processing considerations.\n+\t// %T (the value's type) and %p (its address) are special; we always do them first.\n+\tswitch verb {\n+\tcase 'T':\n+\t\tp.printField(value.Type().String(), 's', false, false, 0)\n+\t\treturn false\n+\tcase 'p':\n+\t\tp.fmtPointer(nil, value, verb, goSyntax)\n+\t\treturn false\n+\t}\n+\n+\t// Handle values with special methods.\n+\t// Call always, even when field == nil, because handleMethods clears p.fmt.plus for us.\n+\tvar field interface{}\n+\tif value.CanInterface() {\n+\t\tfield = value.Interface()\n+\t}\n+\tif wasString, handled := p.handleMethods(field, verb, plus, goSyntax, depth); handled {\n+\t\treturn wasString\n+\t}\n+\n+\treturn p.printReflectValue(value, verb, plus, goSyntax, depth)\n+}\n+\n+// printReflectValue is the fallback for both printField and printValue.\n+// It uses reflect to print the value.\n+func (p *pp) printReflectValue(value reflect.Value, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n BigSwitch:\n \tswitch f := value; f.Kind() {\n \tcase reflect.Bool:\n-\t\tp.fmtBool(f.Bool(), verb, field)\n+\t\tp.fmtBool(f.Bool(), verb, nil, value)\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n-\t\tp.fmtInt64(f.Int(), verb, field)\n+\t\tp.fmtInt64(f.Int(), verb, nil, value)\n \tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n-\t\tp.fmtUint64(uint64(f.Uint()), verb, goSyntax, field)\n+\t\tp.fmtUint64(uint64(f.Uint()), verb, goSyntax, nil, value)\n \tcase reflect.Float32, reflect.Float64:\n \t\tif f.Type().Size() == 4 {\n-\t\t\tp.fmtFloat32(float32(f.Float()), verb, field)\n+\t\t\tp.fmtFloat32(float32(f.Float()), verb, nil, value)\n \t\t} else {\n-\t\t\tp.fmtFloat64(float64(f.Float()), verb, field)\n+\t\t\tp.fmtFloat64(float64(f.Float()), verb, nil, value)\n \t\t}\n \tcase reflect.Complex64, reflect.Complex128:\n \t\tif f.Type().Size() == 8 {\n-\t\t\tp.fmtComplex64(complex64(f.Complex()), verb, field)\n+\t\t\tp.fmtComplex64(complex64(f.Complex()), verb, nil, value)\n \t\t} else {\n-\t\t\tp.fmtComplex128(complex128(f.Complex()), verb, field)\n+\t\t\tp.fmtComplex128(complex128(f.Complex()), verb, nil, value)\n \t\t}\n \tcase reflect.String:\n-\t\tp.fmtString(f.String(), verb, goSyntax, field)\n+\t\tp.fmtString(f.String(), verb, goSyntax, nil, value)\n \tcase reflect.Map:\n \t\tif goSyntax {\n \t\t\tp.buf.WriteString(f.Type().String())\n@@ -738,9 +795,9 @@ BigSwitch:\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printField(key.Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(key, verb, plus, goSyntax, depth+1)\n \t\t\tp.buf.WriteByte(':')\n-\t\t\tp.printField(f.MapIndex(key).Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(f.MapIndex(key), verb, plus, goSyntax, depth+1)\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('}')\n@@ -749,7 +806,7 @@ BigSwitch:\n \t\t}\n \tcase reflect.Struct:\n \t\tif goSyntax {\n-\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n+\t\t\tp.buf.WriteString(value.Type().String())\n \t\t}\n \t\tp.add('{')\n \t\tv := f\n@@ -768,20 +825,20 @@ BigSwitch:\n \t\t\t\t\tp.buf.WriteByte(':')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printField(getField(v, i).Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(getField(v, i), verb, plus, goSyntax, depth+1)\n \t\t}\n \t\tp.buf.WriteByte('}')\n \tcase reflect.Interface:\n \t\tvalue := f.Elem()\n \t\tif !value.IsValid() {\n \t\t\tif goSyntax {\n-\t\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n+\t\t\t\tp.buf.WriteString(value.Type().String())\n \t\t\t\tp.buf.Write(nilParenBytes)\n \t\t\t} else {\n \t\t\t\tp.buf.Write(nilAngleBytes)\n \t\t\t}\n \t\t} else {\n-\t\t\treturn p.printField(value.Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\treturn p.printValue(value, verb, plus, goSyntax, depth+1)\n \t\t}\n \tcase reflect.Array, reflect.Slice:\n \t\t// Byte slices are special.\n@@ -797,11 +854,11 @@ BigSwitch:\n \t\t\tfor i := range bytes {\n \t\t\t\tbytes[i] = byte(f.Index(i).Uint())\n \t\t\t}\n-\t\t\tp.fmtBytes(bytes, verb, goSyntax, depth, field)\n+\t\t\tp.fmtBytes(bytes, verb, goSyntax, depth, nil, value)\n \t\t\treturn verb == 's'\n \t\t}\n \t\tif goSyntax {\n-\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n+\t\t\tp.buf.WriteString(value.Type().String())\n \t\t\tp.buf.WriteByte('{')\n \t\t} else {\n \t\t\tp.buf.WriteByte('[')\n@@ -814,7 +871,7 @@ BigSwitch:\n \t\t\t\t\tp.buf.WriteByte(' ')\n \t\t\t\t}\n \t\t\t}\n-\t\t\tp.printField(f.Index(i).Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\tp.printValue(f.Index(i), verb, plus, goSyntax, depth+1)\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('}')\n@@ -829,17 +886,17 @@ BigSwitch:\n \t\t\tswitch a := f.Elem(); a.Kind() {\n \t\t\tcase reflect.Array, reflect.Slice:\n \t\t\t\tp.buf.WriteByte('&')\n-\t\t\t\tp.printField(a.Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\t\tp.printValue(a, verb, plus, goSyntax, depth+1)\n \t\t\t\tbreak BigSwitch\n \t\t\tcase reflect.Struct:\n \t\t\t\tp.buf.WriteByte('&')\n-\t\t\t\tp.printField(a.Interface(), verb, plus, goSyntax, depth+1)\n+\t\t\t\tp.printValue(a, verb, plus, goSyntax, depth+1)\n \t\t\t\tbreak BigSwitch\n \t\t\t}\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteByte('(')\n-\t\t\tp.buf.WriteString(reflect.TypeOf(field).String())\n+\t\t\tp.buf.WriteString(value.Type().String())\n \t\t\tp.buf.WriteByte(')')\n \t\t\tp.buf.WriteByte('(')\n \t\t\tif v == 0 {\n@@ -856,7 +913,7 @@ BigSwitch:\n \t\t}\n \t\tp.fmt0x64(uint64(v), true)\n \tcase reflect.Chan, reflect.Func, reflect.UnsafePointer:\n-\t\tp.fmtPointer(field, value, verb, goSyntax)\n+\t\tp.fmtPointer(nil, value, verb, goSyntax)\n \tdefault:\n \t\tp.unknownType(f)\n \t}"}, {"sha": "a4bc3bb9dcdbb33f3580a88aa19819743cc93015", "filename": "libgo/go/go/ast/print_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -41,10 +41,10 @@ var tests = []struct {\n \t\t4  }`},\n \n \t// structs\n-\t{struct{ x, y int }{42, 991},\n-\t\t`0  struct { x int; y int } {\n-\t\t1  .  x: 42\n-\t\t2  .  y: 991\n+\t{struct{ X, Y int }{42, 991},\n+\t\t`0  struct { X int; Y int } {\n+\t\t1  .  X: 42\n+\t\t2  .  Y: 991\n \t\t3  }`},\n }\n "}, {"sha": "5171e03b188eff626392ed246dcf5ecd1f5bfb19", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -2,10 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package draw provides image composition functions\n-// in the style of the Plan 9 graphics library\n-// (see http://plan9.bell-labs.com/magic/man2html/2/draw)\n-// and the X Render extension.\n+// Package draw provides image composition functions.\n+//\n+// See \"The Go image/draw package\" for an introduction to this package:\n+// http://blog.golang.org/2011/09/go-imagedraw-package.html\n package draw\n \n import ("}, {"sha": "7c7a4b7a778423bc66927359717ed64aa9ea3445", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -3,6 +3,9 @@\n // license that can be found in the LICENSE file.\n \n // Package image implements a basic 2-D image library.\n+//\n+// See \"The Go image package\" for an introduction to this package:\n+// http://blog.golang.org/2011/09/go-image-package.html\n package image\n \n // Config holds an image's color model and dimensions."}, {"sha": "8fa9d3d13003b877619e415cd9131dc9434b65a3", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 90, "deletions": 25, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -853,13 +853,13 @@ func TestIsNil(t *testing.T) {\n \n func TestInterfaceExtraction(t *testing.T) {\n \tvar s struct {\n-\t\tw io.Writer\n+\t\tW io.Writer\n \t}\n \n-\ts.w = os.Stdout\n+\ts.W = os.Stdout\n \tv := Indirect(ValueOf(&s)).Field(0).Interface()\n-\tif v != s.w.(interface{}) {\n-\t\tt.Error(\"Interface() on interface: \", v, s.w)\n+\tif v != s.W.(interface{}) {\n+\t\tt.Error(\"Interface() on interface: \", v, s.W)\n \t}\n }\n \n@@ -1190,18 +1190,18 @@ type D2 struct {\n }\n \n type S0 struct {\n-\ta, b, c int\n+\tA, B, C int\n \tD1\n \tD2\n }\n \n type S1 struct {\n-\tb int\n+\tB int\n \tS0\n }\n \n type S2 struct {\n-\ta int\n+\tA int\n \t*S1\n }\n \n@@ -1216,36 +1216,36 @@ type S1y struct {\n type S3 struct {\n \tS1x\n \tS2\n-\td, e int\n+\tD, E int\n \t*S1y\n }\n \n type S4 struct {\n \t*S4\n-\ta int\n+\tA int\n }\n \n var fieldTests = []FTest{\n \t{struct{}{}, \"\", nil, 0},\n-\t{struct{}{}, \"foo\", nil, 0},\n-\t{S0{a: 'a'}, \"a\", []int{0}, 'a'},\n-\t{S0{}, \"d\", nil, 0},\n-\t{S1{S0: S0{a: 'a'}}, \"a\", []int{1, 0}, 'a'},\n-\t{S1{b: 'b'}, \"b\", []int{0}, 'b'},\n+\t{struct{}{}, \"Foo\", nil, 0},\n+\t{S0{A: 'a'}, \"A\", []int{0}, 'a'},\n+\t{S0{}, \"D\", nil, 0},\n+\t{S1{S0: S0{A: 'a'}}, \"A\", []int{1, 0}, 'a'},\n+\t{S1{B: 'b'}, \"B\", []int{0}, 'b'},\n \t{S1{}, \"S0\", []int{1}, 0},\n-\t{S1{S0: S0{c: 'c'}}, \"c\", []int{1, 2}, 'c'},\n-\t{S2{a: 'a'}, \"a\", []int{0}, 'a'},\n+\t{S1{S0: S0{C: 'c'}}, \"C\", []int{1, 2}, 'c'},\n+\t{S2{A: 'a'}, \"A\", []int{0}, 'a'},\n \t{S2{}, \"S1\", []int{1}, 0},\n-\t{S2{S1: &S1{b: 'b'}}, \"b\", []int{1, 0}, 'b'},\n-\t{S2{S1: &S1{S0: S0{c: 'c'}}}, \"c\", []int{1, 1, 2}, 'c'},\n-\t{S2{}, \"d\", nil, 0},\n+\t{S2{S1: &S1{B: 'b'}}, \"B\", []int{1, 0}, 'b'},\n+\t{S2{S1: &S1{S0: S0{C: 'c'}}}, \"C\", []int{1, 1, 2}, 'c'},\n+\t{S2{}, \"D\", nil, 0},\n \t{S3{}, \"S1\", nil, 0},\n-\t{S3{S2: S2{a: 'a'}}, \"a\", []int{1, 0}, 'a'},\n-\t{S3{}, \"b\", nil, 0},\n-\t{S3{d: 'd'}, \"d\", []int{2}, 0},\n-\t{S3{e: 'e'}, \"e\", []int{3}, 'e'},\n-\t{S4{a: 'a'}, \"a\", []int{1}, 'a'},\n-\t{S4{}, \"b\", nil, 0},\n+\t{S3{S2: S2{A: 'a'}}, \"A\", []int{1, 0}, 'a'},\n+\t{S3{}, \"B\", nil, 0},\n+\t{S3{D: 'd'}, \"D\", []int{2}, 0},\n+\t{S3{E: 'e'}, \"E\", []int{3}, 'e'},\n+\t{S4{A: 'a'}, \"A\", []int{1}, 'a'},\n+\t{S4{}, \"B\", nil, 0},\n }\n \n func TestFieldByIndex(t *testing.T) {\n@@ -1566,3 +1566,68 @@ func TestTagGet(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type Private struct {\n+\tx int\n+\ty **int\n+}\n+\n+func (p *Private) m() {\n+}\n+\n+type Public struct {\n+\tX int\n+\tY **int\n+}\n+\n+func (p *Public) M() {\n+}\n+\n+func TestUnexported(t *testing.T) {\n+\tvar pub Public\n+\tv := ValueOf(&pub)\n+\tisValid(v.Elem().Field(0))\n+\tisValid(v.Elem().Field(1))\n+\tisValid(v.Elem().FieldByName(\"X\"))\n+\tisValid(v.Elem().FieldByName(\"Y\"))\n+\tisValid(v.Type().Method(0).Func)\n+\tisNonNil(v.Elem().Field(0).Interface())\n+\tisNonNil(v.Elem().Field(1).Interface())\n+\tisNonNil(v.Elem().FieldByName(\"X\").Interface())\n+\tisNonNil(v.Elem().FieldByName(\"Y\").Interface())\n+\tisNonNil(v.Type().Method(0).Func.Interface())\n+\n+\tvar priv Private\n+\tv = ValueOf(&priv)\n+\tisValid(v.Elem().Field(0))\n+\tisValid(v.Elem().Field(1))\n+\tisValid(v.Elem().FieldByName(\"x\"))\n+\tisValid(v.Elem().FieldByName(\"y\"))\n+\tisValid(v.Type().Method(0).Func)\n+\tshouldPanic(func() { v.Elem().Field(0).Interface() })\n+\tshouldPanic(func() { v.Elem().Field(1).Interface() })\n+\tshouldPanic(func() { v.Elem().FieldByName(\"x\").Interface() })\n+\tshouldPanic(func() { v.Elem().FieldByName(\"y\").Interface() })\n+\tshouldPanic(func() { v.Type().Method(0).Func.Interface() })\n+}\n+\n+func shouldPanic(f func()) {\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tpanic(\"did not panic\")\n+\t\t}\n+\t}()\n+\tf()\n+}\n+\n+func isNonNil(x interface{}) {\n+\tif x == nil {\n+\t\tpanic(\"nil interface\")\n+\t}\n+}\n+\n+func isValid(v Value) {\n+\tif !v.IsValid() {\n+\t\tpanic(\"zero Value\")\n+\t}\n+}"}, {"sha": "63c28fe2024d37c7fd16a711c7741dd62b46a526", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -104,7 +104,7 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) (b bool\n \t\treturn true\n \tdefault:\n \t\t// Normal equality suffices\n-\t\treturn v1.Interface() == v2.Interface()\n+\t\treturn valueInterface(v1, false) == valueInterface(v2, false)\n \t}\n \n \tpanic(\"Not reached\")"}, {"sha": "0d916e888ae9efea76cabedfd32c9f47cc3463e0", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=94bf1a5fb73fc9c6a9bf9810c56b3f1678667f20", "patch": "@@ -829,37 +829,36 @@ func (v Value) CanInterface() bool {\n \tif iv.kind == Invalid {\n \t\tpanic(&ValueError{\"reflect.Value.CanInterface\", iv.kind})\n \t}\n-\t// TODO(rsc): Check flagRO too.  Decide what to do about asking for\n-\t// interface for a value obtained via an unexported field.\n-\t// If the field were of a known type, say chan int or *sync.Mutex,\n-\t// the caller could interfere with the data after getting the\n-\t// interface.  But fmt.Print depends on being able to look.\n-\t// Now that reflect is more efficient the special cases in fmt\n-\t// might be less important.\n-\treturn v.InternalMethod == 0\n+\treturn v.InternalMethod == 0 && iv.flag&flagRO == 0\n }\n \n // Interface returns v's value as an interface{}.\n // If v is a method obtained by invoking Value.Method\n // (as opposed to Type.Method), Interface cannot return an\n // interface value, so it panics.\n func (v Value) Interface() interface{} {\n-\treturn v.internal().Interface()\n+\treturn valueInterface(v, true)\n }\n \n-func (iv internalValue) Interface() interface{} {\n+func valueInterface(v Value, safe bool) interface{} {\n+\tiv := v.internal()\n+\treturn iv.valueInterface(safe)\n+}\n+\n+func (iv internalValue) valueInterface(safe bool) interface{} {\n \tif iv.kind == 0 {\n \t\tpanic(&ValueError{\"reflect.Value.Interface\", iv.kind})\n \t}\n \tif iv.method {\n \t\tpanic(\"reflect.Value.Interface: cannot create interface value for method with bound receiver\")\n \t}\n-\t/*\n-\t\tif v.flag()&noExport != 0 {\n-\t\t\tpanic(\"reflect.Value.Interface: cannot return value obtained from unexported struct field\")\n-\t\t}\n-\t*/\n \n+\tif safe && iv.flag&flagRO != 0 {\n+\t\t// Do not allow access to unexported values via Interface,\n+\t\t// because they might be pointers that should not be \n+\t\t// writable or methods or function that should not be callable.\n+\t\tpanic(\"reflect.Value.Interface: cannot return value obtained from unexported field or method\")\n+\t}\n \tif iv.kind == Interface {\n \t\t// Special case: return the element inside the interface.\n \t\t// Won't recurse further because an interface cannot contain an interface.\n@@ -1695,7 +1694,7 @@ func convertForAssignment(what string, addr unsafe.Pointer, dst Type, iv interna\n \t\tif addr == nil {\n \t\t\taddr = unsafe.Pointer(new(interface{}))\n \t\t}\n-\t\tx := iv.Interface()\n+\t\tx := iv.valueInterface(false)\n \t\tif dst.NumMethod() == 0 {\n \t\t\t*(*interface{})(addr) = x\n \t\t} else {"}]}