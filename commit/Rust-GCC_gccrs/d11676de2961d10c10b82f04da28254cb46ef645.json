{"sha": "d11676de2961d10c10b82f04da28254cb46ef645", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDExNjc2ZGUyOTYxZDEwYzEwYjgyZjA0ZGEyODI1NGNiNDZlZjY0NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-02-19T12:59:17Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-02-21T20:32:59Z"}, "message": "lra: Stop registers being incorrectly marked live v2 [PR92989]\n\nThis PR is about a case in which the clobbers at the start of\nan EH receiver can lead to registers becoming unnecessarily\nlive in predecessor blocks.  My first attempt at fixing this\nmade sure that we update the bb liveness info based on the\nreal live set:\n\n  http://gcc.gnu.org/g:e648e57efca6ce6d751ef8c2038608817b514fb4\n\nBut it turns out that the clobbered registers were also added to\nthe \"gen\" set of LRA's private liveness problem, where \"gen\" in\nthis context means \"generates a requirement for a live value\".\nSo the clobbered registers could still end up live via that\nmechanism instead.\n\nThis patch therefore reverts the patch above and takes the other\napproach floated in the original patch description: model the full\nclobber by making the registers live and then dead again.\n\nThere's no specific need to revert the original patch, since the\ncode should no longer be sensitive to the order of the bb liveness\nupdate and the modelling of the clobber.  But given that there's\nno specific need to keep the original patch either, it seemed better\nto restore the code to the more well-tested order.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.  OK to install?\n\nRichard\n\n2020-02-19  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR rtl-optimization/PR92989\n\t* lra-lives.c (process_bb_lives): Restore the original order\n\tof the bb liveness update.  Call make_hard_regno_dead for each\n\tregister clobbered at the start of an EH receiver.", "tree": {"sha": "804729188a878d8d4ccf352c9beecebc37303000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/804729188a878d8d4ccf352c9beecebc37303000"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d11676de2961d10c10b82f04da28254cb46ef645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11676de2961d10c10b82f04da28254cb46ef645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11676de2961d10c10b82f04da28254cb46ef645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11676de2961d10c10b82f04da28254cb46ef645/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25f0909af87171395d9ee21cf2873f4d9b5ebc91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f0909af87171395d9ee21cf2873f4d9b5ebc91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f0909af87171395d9ee21cf2873f4d9b5ebc91"}], "stats": {"total": 116, "additions": 64, "deletions": 52}, "files": [{"sha": "17c6587ff37ca7d9e8dad851fd8d41e33fd7824f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11676de2961d10c10b82f04da28254cb46ef645/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11676de2961d10c10b82f04da28254cb46ef645/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d11676de2961d10c10b82f04da28254cb46ef645", "patch": "@@ -1,3 +1,10 @@\n+2020-02-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/PR92989\n+\t* lra-lives.c (process_bb_lives): Restore the original order\n+\tof the bb liveness update.  Call make_hard_regno_dead for each\n+\tregister clobbered at the start of an EH receiver.\n+\n 2020-02-18  Feng Xue  <fxue@os.amperecomputing.com>\n \n \tPR ipa/93763"}, {"sha": "c8780779a1105a773b2c1b3803c90ec34dad2ba4", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11676de2961d10c10b82f04da28254cb46ef645/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11676de2961d10c10b82f04da28254cb46ef645/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=d11676de2961d10c10b82f04da28254cb46ef645", "patch": "@@ -1023,69 +1023,21 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \tmake_hard_regno_live (regno);\n       }\n \n-  bool live_change_p = false;\n-  /* Check if bb border live info was changed.  */\n-  unsigned int live_pseudos_num = 0;\n-  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n-\t\t\t    FIRST_PSEUDO_REGISTER, j, bi)\n-    {\n-      live_pseudos_num++;\n-      if (! sparseset_bit_p (pseudos_live, j))\n-\t{\n-\t  live_change_p = true;\n-\t  if (lra_dump_file != NULL)\n-\t    fprintf (lra_dump_file,\n-\t\t     \"  r%d is removed as live at bb%d start\\n\", j, bb->index);\n-\t  break;\n-\t}\n-    }\n-  if (! live_change_p\n-      && sparseset_cardinality (pseudos_live) != live_pseudos_num)\n-    {\n-      live_change_p = true;\n-      if (lra_dump_file != NULL)\n-\tEXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n-\t  if (! bitmap_bit_p (df_get_live_in (bb), j))\n-\t    fprintf (lra_dump_file,\n-\t\t     \"  r%d is added to live at bb%d start\\n\", j, bb->index);\n-    }\n-\n-  /* The order of this code and the code below is important.  At this\n-     point hard_regs_live does genuinely contain only live registers.\n-     Below we pretend other hard registers are live in order to create\n-     conflicts with pseudos, but this fake live set shouldn't leak out\n-     into the df info.  */\n-  for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n-    {\n-      if (!TEST_HARD_REG_BIT (hard_regs_live, i))\n-\tcontinue;\n-\n-      if (!TEST_HARD_REG_BIT (hard_regs_spilled_into, i))\n-\tcontinue;\n-\n-      if (bitmap_bit_p (df_get_live_in (bb), i))\n-\tcontinue;\n-\n-      live_change_p = true;\n-      if (lra_dump_file)\n-\tfprintf (lra_dump_file,\n-\t\t \"  hard reg r%d is added to live at bb%d start\\n\", i,\n-\t\t bb->index);\n-      bitmap_set_bit (df_get_live_in (bb), i);\n-    }\n-\n   /* Pseudos can't go in stack regs at the start of a basic block that\n      is reached by an abnormal edge.  Likewise for registers that are at\n      least partly call clobbered, because caller-save, fixup_abnormal_edges\n      and possibly the table driven EH machinery are not quite ready to\n      handle such pseudos live across such edges.  */\n   if (bb_has_abnormal_pred (bb))\n     {\n+      HARD_REG_SET clobbers;\n+\n+      CLEAR_HARD_REG_SET (clobbers);\n #ifdef STACK_REGS\n       EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, px)\n \tlra_reg_info[px].no_stack_p = true;\n       for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n-\tmake_hard_regno_live (px);\n+\tSET_HARD_REG_BIT (clobbers, px);\n #endif\n       /* No need to record conflicts for call clobbered regs if we\n \t have nonlocal labels around, as we don't ever try to\n@@ -1105,9 +1057,43 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t  && !HARD_REGISTER_P (pic_offset_table_rtx))\n #endif\n \t      )\n+\t    SET_HARD_REG_BIT (clobbers, px);\n+\n+      clobbers &= ~hard_regs_live;\n+      for (px = 0; HARD_REGISTER_NUM_P (px); px++)\n+\tif (TEST_HARD_REG_BIT (clobbers, px))\n+\t  {\n \t    make_hard_regno_live (px);\n+\t    make_hard_regno_dead (px);\n+\t  }\n     }\n \n+  bool live_change_p = false;\n+  /* Check if bb border live info was changed.  */\n+  unsigned int live_pseudos_num = 0;\n+  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n+\t\t\t    FIRST_PSEUDO_REGISTER, j, bi)\n+    {\n+      live_pseudos_num++;\n+      if (! sparseset_bit_p (pseudos_live, j))\n+\t{\n+\t  live_change_p = true;\n+\t  if (lra_dump_file != NULL)\n+\t    fprintf (lra_dump_file,\n+\t\t     \"  r%d is removed as live at bb%d start\\n\", j, bb->index);\n+\t  break;\n+\t}\n+    }\n+  if (! live_change_p\n+      && sparseset_cardinality (pseudos_live) != live_pseudos_num)\n+    {\n+      live_change_p = true;\n+      if (lra_dump_file != NULL)\n+\tEXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n+\t  if (! bitmap_bit_p (df_get_live_in (bb), j))\n+\t    fprintf (lra_dump_file,\n+\t\t     \"  r%d is added to live at bb%d start\\n\", j, bb->index);\n+    }\n   /* See if we'll need an increment at the end of this basic block.\n      An increment is needed if the PSEUDOS_LIVE set is not empty,\n      to make sure the finish points are set up correctly.  */\n@@ -1127,6 +1113,25 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \tcheck_pseudos_live_through_calls (j, last_call_abi);\n     }\n \n+  for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n+    {\n+      if (!TEST_HARD_REG_BIT (hard_regs_live, i))\n+\tcontinue;\n+\n+      if (!TEST_HARD_REG_BIT (hard_regs_spilled_into, i))\n+\tcontinue;\n+\n+      if (bitmap_bit_p (df_get_live_in (bb), i))\n+\tcontinue;\n+\n+      live_change_p = true;\n+      if (lra_dump_file)\n+\tfprintf (lra_dump_file,\n+\t\t \"  hard reg r%d is added to live at bb%d start\\n\", i,\n+\t\t bb->index);\n+      bitmap_set_bit (df_get_live_in (bb), i);\n+    }\n+\n   if (need_curr_point_incr)\n     next_program_point (curr_point, freq);\n "}]}