{"sha": "5809bb4f78c9aae0f3be3c8d942b6af75ba23a74", "node_id": "C_kwDOANBUbNoAKDU4MDliYjRmNzhjOWFhZTBmM2JlM2M4ZDk0MmI2YWY3NWJhMjNhNzQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-16T12:26:11Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-16T12:26:11Z"}, "message": "c++: further lookup_member simplification\n\nAs a minor followup to r12-7656-gffe9c0a0d3564a, this condenses the\nhandling of ambiguity and access w.r.t. the value of 'protect' so that\nthe logic is more clear.\n\ngcc/cp/ChangeLog:\n\n\t* search.cc (lookup_member): Simplify by handling all values\n\tof protect together in the ambiguous case.  Don't modify protect.", "tree": {"sha": "c6d79ed94b459343f7929e7b63d26430373e8b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6d79ed94b459343f7929e7b63d26430373e8b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5809bb4f78c9aae0f3be3c8d942b6af75ba23a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5809bb4f78c9aae0f3be3c8d942b6af75ba23a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5809bb4f78c9aae0f3be3c8d942b6af75ba23a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5809bb4f78c9aae0f3be3c8d942b6af75ba23a74/comments", "author": null, "committer": null, "parents": [{"sha": "e55c5e24b97ad8ddc44588da18e894c139e02c0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e55c5e24b97ad8ddc44588da18e894c139e02c0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e55c5e24b97ad8ddc44588da18e894c139e02c0a"}], "stats": {"total": 32, "additions": 13, "deletions": 19}, "files": [{"sha": "b86b3a24080eb09241e6aa61a53e15f2d169ba7a", "filename": "gcc/cp/search.cc", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5809bb4f78c9aae0f3be3c8d942b6af75ba23a74/gcc%2Fcp%2Fsearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5809bb4f78c9aae0f3be3c8d942b6af75ba23a74/gcc%2Fcp%2Fsearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.cc?ref=5809bb4f78c9aae0f3be3c8d942b6af75ba23a74", "patch": "@@ -1168,27 +1168,21 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n   if (rval_binfo)\n     type = BINFO_TYPE (rval_binfo);\n \n-  /* If we are not interested in ambiguities, don't report them;\n-     just return NULL_TREE.  */\n-  if (!protect && lfi.ambiguous)\n-    return NULL_TREE;\n-\n-  if (protect == 2)\n-    {\n-      if (lfi.ambiguous)\n-\treturn lfi.ambiguous;\n-      else\n-\tprotect = 0;\n-    }\n-\n-  if (protect == 1 && lfi.ambiguous)\n+  if (lfi.ambiguous)\n     {\n-      if (complain & tf_error)\n+      if (protect == 0)\n+\treturn NULL_TREE;\n+      else if (protect == 1)\n \t{\n-\t  error (\"request for member %qD is ambiguous\", name);\n-\t  print_candidates (lfi.ambiguous);\n+\t  if (complain & tf_error)\n+\t    {\n+\t      error (\"request for member %qD is ambiguous\", name);\n+\t      print_candidates (lfi.ambiguous);\n+\t    }\n+\t  return error_mark_node;\n \t}\n-      return error_mark_node;\n+      else if (protect == 2)\n+\treturn lfi.ambiguous;\n     }\n \n   if (!rval)\n@@ -1213,7 +1207,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n \n     only the first call to \"f\" is valid.  However, if the function is\n     static, we can check.  */\n-  if (protect && !really_overloaded_fn (rval))\n+  if (protect == 1 && !really_overloaded_fn (rval))\n     {\n       tree decl = is_overloaded_fn (rval) ? get_first_fn (rval) : rval;\n       decl = strip_using_decl (decl);"}]}