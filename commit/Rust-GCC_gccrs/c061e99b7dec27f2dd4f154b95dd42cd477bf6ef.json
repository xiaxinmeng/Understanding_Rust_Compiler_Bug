{"sha": "c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "node_id": "C_kwDOANBUbNoAKGMwNjFlOTliN2RlYzI3ZjJkZDRmMTU0Yjk1ZGQ0MmNkNDc3YmY2ZWY", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-08T11:14:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-06T13:29:47Z"}, "message": "[Ada] Fix spurious error for aggregate with box component choice\n\nIt comes from the Volatile_Full_Access (or Atomic) aspect: the aggregate is\neffectively analyzed/resolved twice and this does not work.  It is fixed by\ncalling Is_Full_Access_Aggregate before resolution.\n\ngcc/ada/\n\n\t* exp_aggr.adb (Expand_Record_Aggregate): Do not call\n\tIs_Full_Access_Aggregate here.\n\t* freeze.ads (Is_Full_Access_Aggregate): Delete.\n\t* freeze.adb (Is_Full_Access_Aggregate): Move to...\n\t(Freeze_Entity): Do not call Is_Full_Access_Aggregate here.\n\t* sem_aggr.adb (Is_Full_Access_Aggregate): ...here\n\t(Resolve_Aggregate): Call Is_Full_Access_Aggregate here.", "tree": {"sha": "e8d9d8783702ab2caad007faea03b6663ac1d956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8d9d8783702ab2caad007faea03b6663ac1d956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b33dd7874523af5c244fff3c45be1358815691e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33dd7874523af5c244fff3c45be1358815691e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b33dd7874523af5c244fff3c45be1358815691e4"}], "stats": {"total": 177, "additions": 83, "deletions": 94}, "files": [{"sha": "4493f0ffef74488eeb98aa102c9e68333b98bbb0", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "patch": "@@ -8779,19 +8779,10 @@ package body Exp_Aggr is\n    --  Start of processing for Expand_Record_Aggregate\n \n    begin\n-      --  If the aggregate is to be assigned to a full access variable, we have\n-      --  to prevent a piecemeal assignment even if the aggregate is to be\n-      --  expanded. We create a temporary for the aggregate, and assign the\n-      --  temporary instead, so that the back end can generate an atomic move\n-      --  for it.\n-\n-      if Is_Full_Access_Aggregate (N) then\n-         return;\n-\n       --  No special management required for aggregates used to initialize\n       --  statically allocated dispatch tables\n \n-      elsif Is_Static_Dispatch_Table_Aggregate (N) then\n+      if Is_Static_Dispatch_Table_Aggregate (N) then\n          return;\n \n       --  Case pattern aggregates need to remain as aggregates"}, {"sha": "3a333735cef48dd2b330ed618a7c685aa72b0931", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "patch": "@@ -2309,67 +2309,6 @@ package body Freeze is\n       end loop;\n    end Check_Unsigned_Type;\n \n-   ------------------------------\n-   -- Is_Full_Access_Aggregate --\n-   ------------------------------\n-\n-   function Is_Full_Access_Aggregate (N : Node_Id) return Boolean is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      New_N : Node_Id;\n-      Par   : Node_Id;\n-      Temp  : Entity_Id;\n-      Typ   : Entity_Id;\n-\n-   begin\n-      Par := Parent (N);\n-\n-      --  Array may be qualified, so find outer context\n-\n-      if Nkind (Par) = N_Qualified_Expression then\n-         Par := Parent (Par);\n-      end if;\n-\n-      if not Comes_From_Source (Par) then\n-         return False;\n-      end if;\n-\n-      case Nkind (Par) is\n-         when N_Assignment_Statement =>\n-            Typ := Etype (Name (Par));\n-\n-            if not Is_Full_Access (Typ)\n-              and then not Is_Full_Access_Object (Name (Par))\n-            then\n-               return False;\n-            end if;\n-\n-         when N_Object_Declaration =>\n-            Typ := Etype (Defining_Identifier (Par));\n-\n-            if not Is_Full_Access (Typ)\n-              and then not Is_Full_Access (Defining_Identifier (Par))\n-            then\n-               return False;\n-            end if;\n-\n-         when others =>\n-            return False;\n-      end case;\n-\n-      Temp := Make_Temporary (Loc, 'T', N);\n-      New_N :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Temp,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-          Expression          => Relocate_Node (N));\n-      Insert_Before (Par, New_N);\n-      Analyze (New_N);\n-\n-      Set_Expression (Par, New_Occurrence_Of (Temp, Loc));\n-      return True;\n-   end Is_Full_Access_Aggregate;\n-\n    -----------------------------------------------\n    -- Explode_Initialization_Compound_Statement --\n    -----------------------------------------------\n@@ -6447,20 +6386,6 @@ package body Freeze is\n          then\n             Set_Encoded_Interface_Name\n               (E, Get_Default_External_Name (E));\n-\n-         --  If entity is an atomic object appearing in a declaration and\n-         --  the expression is an aggregate, assign it to a temporary to\n-         --  ensure that the actual assignment is done atomically rather\n-         --  than component-wise (the assignment to the temp may be done\n-         --  component-wise, but that is harmless).\n-\n-         elsif Is_Full_Access (E)\n-           and then Nkind (Parent (E)) = N_Object_Declaration\n-           and then Present (Expression (Parent (E)))\n-           and then Nkind (Expression (Parent (E))) = N_Aggregate\n-           and then Is_Full_Access_Aggregate (Expression (Parent (E)))\n-         then\n-            null;\n          end if;\n \n          --  Subprogram case"}, {"sha": "bf941c60e835be9bf417da5b5d2f9c3e43c66a0a", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "patch": "@@ -177,15 +177,6 @@ package Freeze is\n    --  True when we are processing the body of a primitive with no previous\n    --  spec defined after R is frozen (see Check_Dispatching_Operation).\n \n-   function Is_Full_Access_Aggregate (N : Node_Id) return Boolean;\n-   --  If a full access object is initialized with an aggregate or is assigned\n-   --  an aggregate, we have to prevent a piecemeal access or assignment to the\n-   --  object, even if the aggregate is to be expanded. We create a temporary\n-   --  for the aggregate, and assign the temporary instead, so that the back\n-   --  end can generate an atomic move for it. This is only done in the context\n-   --  of an object declaration or an assignment. Function is a noop and\n-   --  returns false in other contexts.\n-\n    procedure Explode_Initialization_Compound_Statement (E : Entity_Id);\n    --  If Initialization_Statements (E) is an N_Compound_Statement, insert its\n    --  actions in the enclosing list and reset the attribute."}, {"sha": "2cd8807a27720523e9d403fc0fd5de2931416247", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c061e99b7dec27f2dd4f154b95dd42cd477bf6ef/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c061e99b7dec27f2dd4f154b95dd42cd477bf6ef", "patch": "@@ -849,9 +849,81 @@ package body Sem_Aggr is\n       --  Set to True if N represents a simple aggregate with only\n       --  (others => <>), not nested as part of another aggregate.\n \n+      function Is_Full_Access_Aggregate (N : Node_Id) return Boolean;\n+      --  If a full access object is initialized with an aggregate or is\n+      --  assigned an aggregate, we have to prevent a piecemeal access or\n+      --  assignment to the object, even if the aggregate is to be expanded.\n+      --  We create a temporary for the aggregate, and assign the temporary\n+      --  instead, so that the back end can generate an atomic move for it.\n+      --  This is only done in the context of an object declaration or an\n+      --  assignment. Function is a noop and returns false in other contexts.\n+\n       function Within_Aggregate (N : Node_Id) return Boolean;\n       --  Return True if N is part of an N_Aggregate\n \n+      ------------------------------\n+      -- Is_Full_Access_Aggregate --\n+      ------------------------------\n+\n+      function Is_Full_Access_Aggregate (N : Node_Id) return Boolean is\n+         Loc : constant Source_Ptr := Sloc (N);\n+\n+         New_N : Node_Id;\n+         Par   : Node_Id;\n+         Temp  : Entity_Id;\n+         Typ   : Entity_Id;\n+\n+      begin\n+         Par := Parent (N);\n+\n+         --  Aggregate may be qualified, so find outer context\n+\n+         if Nkind (Par) = N_Qualified_Expression then\n+            Par := Parent (Par);\n+         end if;\n+\n+         if not Comes_From_Source (Par) then\n+            return False;\n+         end if;\n+\n+         case Nkind (Par) is\n+            when N_Assignment_Statement =>\n+               Typ := Etype (Name (Par));\n+\n+               if not Is_Full_Access (Typ)\n+                 and then not Is_Full_Access_Object (Name (Par))\n+               then\n+                  return False;\n+               end if;\n+\n+            when N_Object_Declaration =>\n+               Typ := Etype (Defining_Identifier (Par));\n+\n+               if not Is_Full_Access (Typ)\n+                 and then not Is_Full_Access (Defining_Identifier (Par))\n+               then\n+                  return False;\n+               end if;\n+\n+            when others =>\n+               return False;\n+         end case;\n+\n+         Temp := Make_Temporary (Loc, 'T', N);\n+         New_N :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+             Expression          => Relocate_Node (N));\n+         Insert_Action (Par, New_N);\n+\n+         Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+         Analyze_And_Resolve (N, Typ);\n+\n+         return True;\n+      end Is_Full_Access_Aggregate;\n+\n       ----------------------\n       -- Within_Aggregate --\n       ----------------------\n@@ -880,6 +952,16 @@ package body Sem_Aggr is\n         and then not Null_Record_Present (N)\n       then\n          return;\n+\n+      --  If the aggregate is assigned to a full access variable, we have\n+      --  to prevent a piecemeal assignment even if the aggregate is to be\n+      --  expanded. We create a temporary for the aggregate, and assign the\n+      --  temporary instead, so that the back end can generate an atomic move\n+      --  for it. This is properly an expansion activity but it must be done\n+      --  before resolution because aggregate resolution cannot be done twice.\n+\n+      elsif Expander_Active and then Is_Full_Access_Aggregate (N) then\n+         return;\n       end if;\n \n       --  If the aggregate has box-initialized components, its type must be"}]}