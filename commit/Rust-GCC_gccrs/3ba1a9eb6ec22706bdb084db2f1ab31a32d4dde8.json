{"sha": "3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhMWE5ZWI2ZWMyMjcwNmJkYjA4NGRiMmYxYWIzMWEzMmQ0ZGRlOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T09:08:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T09:08:44Z"}, "message": "[multiple changes]\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Allocator): If the expression does not\n\thave a subtype indication and the type is an unconstrained tagged\n\ttype with defaulted discriminants, create an explicit constraint\n\tfor it during analysis to prevent out-of-order freezing actions\n\ton generated classwide types.\n\n2016-05-02  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement):\n\tIn the runtime check that ensures that the tags of source an\n\ttarget match, add missing displacement of the pointer to the\n\tobjects if they cover interface types.\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Old): Do not use\n\tbase type for attribute when type is discrete: transformation\n\tis not needed for such types, and leads to spurious errors if\n\tthe context is a case construct.\n\nFrom-SVN: r235709", "tree": {"sha": "8f9db14e43b5357d9daae884d4381ba2c6a6b63a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f9db14e43b5357d9daae884d4381ba2c6a6b63a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/comments", "author": null, "committer": null, "parents": [{"sha": "fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc1c2d0482260c80cfe8363f96ace9a57f10cbf4"}], "stats": {"total": 131, "additions": 115, "deletions": 16}, "files": [{"sha": "2722c7dfd66e79d1f0c0d6c6459a9edfc1a88a89", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "patch": "@@ -1,3 +1,25 @@\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Allocator): If the expression does not\n+\thave a subtype indication and the type is an unconstrained tagged\n+\ttype with defaulted discriminants, create an explicit constraint\n+\tfor it during analysis to prevent out-of-order freezing actions\n+\ton generated classwide types.\n+\n+2016-05-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement):\n+\tIn the runtime check that ensures that the tags of source an\n+\ttarget match, add missing displacement of the pointer to the\n+\tobjects if they cover interface types.\n+\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Old): Do not use\n+\tbase type for attribute when type is discrete: transformation\n+\tis not needed for such types, and leads to spurious errors if\n+\tthe context is a case construct.\n+\n 2016-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (elaborate_reference_1): Do not bother about"}, {"sha": "6cac7211ec042e31aee8d14ca27e64f285d4a9c4", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "patch": "@@ -2240,21 +2240,51 @@ package body Exp_Ch5 is\n                     and then Is_Tagged_Type (Typ)\n                     and then Is_Tagged_Type (Underlying_Type (Etype (Rhs)))\n                   then\n-                     Append_To (L,\n-                       Make_Raise_Constraint_Error (Loc,\n-                         Condition =>\n-                           Make_Op_Ne (Loc,\n-                             Left_Opnd =>\n-                               Make_Selected_Component (Loc,\n-                                 Prefix        => Duplicate_Subexpr (Lhs),\n-                                 Selector_Name =>\n-                                   Make_Identifier (Loc, Name_uTag)),\n-                             Right_Opnd =>\n-                               Make_Selected_Component (Loc,\n-                                 Prefix        => Duplicate_Subexpr (Rhs),\n-                                 Selector_Name =>\n-                                   Make_Identifier (Loc, Name_uTag))),\n-                         Reason => CE_Tag_Check_Failed));\n+                     declare\n+                        Lhs_Tag : Node_Id;\n+                        Rhs_Tag : Node_Id;\n+\n+                     begin\n+                        if not Is_Interface (Typ) then\n+                           Lhs_Tag :=\n+                             Make_Selected_Component (Loc,\n+                               Prefix        => Duplicate_Subexpr (Lhs),\n+                               Selector_Name =>\n+                                 Make_Identifier (Loc, Name_uTag));\n+                           Rhs_Tag :=\n+                             Make_Selected_Component (Loc,\n+                               Prefix        => Duplicate_Subexpr (Rhs),\n+                               Selector_Name =>\n+                                 Make_Identifier (Loc, Name_uTag));\n+                        else\n+                           --  Displace the pointer to the base of the objects\n+                           --  applying 'Address, which is later expanded into\n+                           --  a call to RE_Base_Address.\n+\n+                           Lhs_Tag :=\n+                             Make_Explicit_Dereference (Loc,\n+                               Prefix =>\n+                                 Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                                   Make_Attribute_Reference (Loc,\n+                                     Prefix => Duplicate_Subexpr (Lhs),\n+                                     Attribute_Name => Name_Address)));\n+                           Rhs_Tag :=\n+                             Make_Explicit_Dereference (Loc,\n+                               Prefix =>\n+                                 Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                                   Make_Attribute_Reference (Loc,\n+                                     Prefix => Duplicate_Subexpr (Rhs),\n+                                     Attribute_Name => Name_Address)));\n+                        end if;\n+\n+                        Append_To (L,\n+                          Make_Raise_Constraint_Error (Loc,\n+                            Condition =>\n+                              Make_Op_Ne (Loc,\n+                                Left_Opnd => Lhs_Tag,\n+                                Right_Opnd => Rhs_Tag),\n+                            Reason => CE_Tag_Check_Failed));\n+                     end;\n                   end if;\n \n                   declare"}, {"sha": "d071f02e737bfc262f3bae4715aea7afca4e8c1b", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "patch": "@@ -4975,8 +4975,16 @@ package body Sem_Attr is\n             --  and does not suffer from the out-of-order issue described\n             --  above. Thus, this expansion is skipped in SPARK mode.\n \n+            --  THe expansion is not relevant for discrete types, that will\n+            --  not generate extra declarations, and where use of the base\n+            --  type may lead to spurious errors if context is a case.\n+\n             if not GNATprove_Mode then\n-               Pref_Typ := Base_Type (Pref_Typ);\n+\n+               if not Is_Discrete_Type (Pref_Typ) then\n+                  Pref_Typ := Base_Type (Pref_Typ);\n+               end if;\n+\n                Set_Etype (N, Pref_Typ);\n                Set_Etype (P, Pref_Typ);\n "}, {"sha": "99827081d0bbf81ea4c41d2a09d36e45d5883076", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=3ba1a9eb6ec22706bdb084db2f1ab31a32d4dde8", "patch": "@@ -583,6 +583,45 @@ package body Sem_Ch4 is\n             --  so that the bounds of the subtype indication are attached to\n             --  the tree in case the allocator is inside a generic unit.\n \n+            --  Finally, if there is no subtype indication and the type is\n+            --  a tagged unconstrained type with discriminants, the designated\n+            --  object is constrained by their default values, and it is\n+            --  simplest to introduce an explicit constraint now. In some cases\n+            --  this is done during expansion, but freeze actions are certain\n+            --  to be emitted in the proper order if constraint is explicit.\n+\n+            if Is_Entity_Name (E) and then Expander_Active then\n+               Find_Type (E);\n+               Type_Id := Entity (E);\n+\n+               if Is_Tagged_Type (Type_Id)\n+                 and then Has_Discriminants (Type_Id)\n+                 and then not Is_Constrained (Type_Id)\n+                 and then Present\n+                   (Discriminant_Default_Value (First_Discriminant (Type_Id)))\n+               then\n+                  declare\n+                     Loc    : constant Source_Ptr := Sloc (E);\n+                     Discr  : Entity_Id := First_Discriminant (Type_Id);\n+                     Constr : constant List_Id := New_List;\n+\n+                  begin\n+                     if Present (Discriminant_Default_Value (Discr)) then\n+                        while Present (Discr) loop\n+                           Append (Discriminant_Default_Value (Discr), Constr);\n+                           Next_Discriminant (Discr);\n+                        end loop;\n+\n+                        Rewrite (E, Make_Subtype_Indication (Loc,\n+                          Subtype_Mark => New_Occurrence_Of (Type_Id, Loc),\n+                          Constraint   =>\n+                            Make_Index_Or_Discriminant_Constraint (Loc,\n+                              Constr)));\n+                     end if;\n+                  end;\n+               end if;\n+            end if;\n+\n             if Nkind (E) = N_Subtype_Indication then\n \n                --  A constraint is only allowed for a composite type in Ada"}]}