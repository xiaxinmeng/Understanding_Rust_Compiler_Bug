{"sha": "5accd82209963c5d048e6096311e9b40b48efd15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjY2Q4MjIwOTk2M2M1ZDA0OGU2MDk2MzExZTliNDBiNDhlZmQxNQ==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@mhpcc.edu", "date": "1998-09-18T20:55:00Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-09-18T20:55:00Z"}, "message": "toplev.c (rest_of_compilation): Set bct_p on second call to loop_optimize.\n\n        * toplev.c (rest_of_compilation): Set bct_p on second call to\n        loop_optimize.\n        * loop.c (loop_optimize, scan_loop, strength_reduce): New argument\n        bct_p.\n        (strength_reduce): Only call analyze_loop_iterations and\n        insert_bct if bct_p set.\n        (check_dbra_loop): Fix typo.\n        (insert_bct): Use word_mode instead of SImode.\n        (instrument_loop_bct): Likewise.  Do not delete iteration count\n        condition code generation insn.  Initialize iteration count before\n        loop start.\n        * rtl.h (loop_optimize): Update prototype.\n        * ginclude/va-ppc.h (va_arg): longlong types in overflow area are\n        not doubleword aligned.\n        * rs6000.c (optimization_options): New function.\n        (secondary_reload_class): Only call true_regnum for PSEUDO_REGs.\n        * rs6000.h (OPTIMIZATION_OPTIONS): Define.\n        (REG_ALLOC_ORDER): Allocate highest numbered condition regsiters\n        first; cr1 can be used for FP record condition insns.\n\nFrom-SVN: r22471", "tree": {"sha": "69eef37b4ea439c3a864ceebed52c671f519c116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69eef37b4ea439c3a864ceebed52c671f519c116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5accd82209963c5d048e6096311e9b40b48efd15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5accd82209963c5d048e6096311e9b40b48efd15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5accd82209963c5d048e6096311e9b40b48efd15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5accd82209963c5d048e6096311e9b40b48efd15/comments", "author": null, "committer": null, "parents": [{"sha": "735955227eeca4e60dad78f414b60e627e8cd207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735955227eeca4e60dad78f414b60e627e8cd207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/735955227eeca4e60dad78f414b60e627e8cd207"}], "stats": {"total": 136, "additions": 100, "deletions": 36}, "files": [{"sha": "e921e814df001b956a3763c5991bb10ccc3234bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -1,3 +1,27 @@\n+Fri Sep 18 23:50:56 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* toplev.c (rest_of_compilation): Set bct_p on second call to\n+\tloop_optimize.\n+\t* loop.c (loop_optimize, scan_loop, strength_reduce): New argument\n+\tbct_p.\n+\t(strength_reduce): Only call analyze_loop_iterations and\n+\tinsert_bct if bct_p set.\n+\t(check_dbra_loop): Fix typo.\n+\t(insert_bct): Use word_mode instead of SImode.\n+\t(instrument_loop_bct): Likewise.  Do not delete iteration count\n+\tcondition code generation insn.  Initialize iteration count before\n+\tloop start.\n+\t* rtl.h (loop_optimize): Update prototype.\n+\n+\t* ginclude/va-ppc.h (va_arg): longlong types in overflow area are\n+\tnot doubleword aligned.\n+\n+\t* rs6000.c (optimization_options): New function.\n+\t(secondary_reload_class): Only call true_regnum for PSEUDO_REGs.\n+\t* rs6000.h (OPTIMIZATION_OPTIONS): Define.\n+\t(REG_ALLOC_ORDER): Allocate highest numbered condition regsiters\n+\tfirst; cr1 can be used for FP record condition insns.\n+\n Fri Sep 18 09:44:55 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/m32r/m32r.h (m32r_block_immediate_operand): Add to"}, {"sha": "e5f199c606681e4bf588b8be3182d5e2ea1998a0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -347,6 +347,20 @@ rs6000_override_options (default_cpu)\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n }\n+\n+void\n+optimization_options (level, size)\n+     int level;\n+     int size ATTRIBUTE_UNUSED;\n+{\n+#if 0\n+#ifdef HAIFA\n+  /* When optimizing, enable use of BCT instruction.  */\n+  if (level >= 1)\n+      flag_branch_on_count_reg = 1;\n+#endif\n+#endif\n+}\n \f\n /* Do anything needed at the start of the asm file.  */\n \n@@ -1305,14 +1319,18 @@ function_arg_padding (mode, type)\n    \n    Windows NT wants anything >= 8 bytes to be double word aligned.\n \n-   V.4 wants long longs to be double word aligned.  */\n+   V.4 wants long longs to be double word aligned.\n+\n+   FP emulation: double precision passed, returned, and same alignment\n+   as long long.  */\n \n int\n function_arg_boundary (mode, type)\n      enum machine_mode mode;\n      tree type;\n {\n-  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && mode == DImode)\n+  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+      && ((mode == DImode) || (TARGET_SOFT_FLOAT && mode == DFmode)))\n     return 64;\n \n   if (DEFAULT_ABI != ABI_NT || TARGET_64BIT)\n@@ -2188,10 +2206,7 @@ secondary_reload_class (class, mode, in)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n      rtx in;\n {\n-  int regno = true_regnum (in);\n-\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    regno = -1;\n+  int regno;\n \n   /* We can not copy a symbolic operand directly into anything other than\n      BASE_REGS for TARGET_ELF.  So indicate that a register from BASE_REGS\n@@ -2203,6 +2218,25 @@ secondary_reload_class (class, mode, in)\n \t  || GET_CODE (in) == CONST))\n     return BASE_REGS;\n \n+  if (GET_CODE (in) == REG)\n+    {\n+      regno = REGNO (in);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  regno = true_regnum (in);\n+\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t    regno = -1;\n+\t}\n+    }\n+  else if (GET_CODE (in) == SUBREG)\n+    {\n+      regno = true_regnum (in);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tregno = -1;\n+    }\n+  else\n+    regno = -1;\n+\n   /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n      into anything.  */\n   if (class == GENERAL_REGS || class == BASE_REGS"}, {"sha": "53c99d617c23b7ddd30fd2da710bc8ed14c79862", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -473,10 +473,17 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    defined, is executed once just after all the command options have\n    been parsed.\n \n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.\n+\n    On the RS/6000 this is used to define the target cpu type.  */\n \n #define OVERRIDE_OPTIONS rs6000_override_options (TARGET_CPU_DEFAULT)\n \n+/* Define this to change the optimizations performed by default.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) optimization_options(LEVEL,SIZE)\n+\n+\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \f\n@@ -712,9 +719,10 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n \tfp13 - fp2\t(not saved; incoming fp arg registers)\n \tfp1\t\t(not saved; return value)\n  \tfp31 - fp14\t(saved; order given to save least number)\n-\tcr1, cr6, cr7\t(not saved or special)\n+\tcr7, cr6\t(not saved or special)\n+\tcr1\t\t(not saved, but used for FP operations)\n \tcr0\t\t(not saved, but used for arithmetic operations)\n-\tcr2, cr3, cr4\t(saved)\n+\tcr4, cr3, cr2\t(saved)\n         r0\t\t(not saved; cannot be base reg)\n \tr9\t\t(not saved; best for TImode)\n \tr11, r10, r8-r4\t(not saved; highest used first to make less conflict)\n@@ -732,7 +740,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    33,\t\t\t\t\t\t\t\\\n    63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,\t\\\n    50, 49, 48, 47, 46, \t\t\t\t\t\\\n-   69, 74, 75, 68, 70, 71, 72,\t\t\t\t\\\n+   75, 74, 69, 68, 72, 71, 70,\t\t\t\t\\\n    0,\t\t\t\t\t\t\t\\\n    9, 11, 10, 8, 7, 6, 5, 4,\t\t\t\t\\\n    3,\t\t\t\t\t\t\t\\"}, {"sha": "736369dbe7de4cbca27c9a3412232c86d8711959", "filename": "gcc/ginclude/va-ppc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Fginclude%2Fva-ppc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Fginclude%2Fva-ppc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-ppc.h?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -158,9 +158,6 @@ __extension__ (*({\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (__va_longlong_p(TYPE) && ((long)__va_overflow(AP) & 4) != 0)\t\\\n-\t__va_overflow(AP) += 4;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n       __ptr = (TYPE *) (void *) (__va_overflow(AP));\t\t\t\\\n       __va_overflow(AP) += __va_size (TYPE) * sizeof (long);\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "b171c75c1e6987ecc7a7df065ddd7701f7897422", "filename": "gcc/loop.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -310,7 +310,7 @@ static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n \t\t\t\t       int *, int)); \n static void note_addr_stored PROTO((rtx, rtx));\n static int loop_reg_used_before_p PROTO((rtx, rtx, rtx, rtx, rtx));\n-static void scan_loop PROTO((rtx, rtx, int));\n+static void scan_loop PROTO((rtx, rtx, int, int));\n #if 0\n static void replace_call_address PROTO((rtx, rtx, rtx));\n #endif\n@@ -324,7 +324,7 @@ static int rtx_equal_for_loop_p PROTO((rtx, rtx, struct movable *));\n static void add_label_notes PROTO((rtx, rtx));\n static void move_movables PROTO((struct movable *, int, int, rtx, rtx, int));\n static int count_nonfixed_reads PROTO((rtx));\n-static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, int));\n+static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, int, int));\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n@@ -440,11 +440,11 @@ init_loop ()\n    (or 0 if none should be output).  */\n \n void\n-loop_optimize (f, dumpfile, unroll_p)\n+loop_optimize (f, dumpfile, unroll_p, bct_p)\n      /* f is the first instruction of a chain of insns for one function */\n      rtx f;\n      FILE *dumpfile;\n-     int unroll_p;\n+     int unroll_p, bct_p;\n {\n   register rtx insn;\n   register int i;\n@@ -589,7 +589,7 @@ loop_optimize (f, dumpfile, unroll_p)\n   for (i = max_loop_num-1; i >= 0; i--)\n     if (! loop_invalid[i] && loop_number_loop_ends[i])\n       scan_loop (loop_number_loop_starts[i], loop_number_loop_ends[i],\n-\t\t unroll_p);\n+\t\t unroll_p, bct_p);\n \n   /* If debugging and unrolling loops, we must replicate the tree nodes\n      corresponding to the blocks inside the loop, so that the original one\n@@ -643,9 +643,9 @@ next_insn_in_loop (insn, start, end, loop_top)\n    write, then we can also mark the memory read as invariant.  */\n \n static void\n-scan_loop (loop_start, end, unroll_p)\n+scan_loop (loop_start, end, unroll_p, bct_p)\n      rtx loop_start, end;\n-     int unroll_p;\n+     int unroll_p, bct_p;\n {\n   register int i;\n   rtx p;\n@@ -1185,7 +1185,7 @@ scan_loop (loop_start, end, unroll_p)\n     {\n       the_movables = movables;\n       strength_reduce (scan_start, end, loop_top,\n-\t\t       insn_count, loop_start, end, unroll_p);\n+\t\t       insn_count, loop_start, end, unroll_p, bct_p);\n     }\n \n   VARRAY_FREE (n_times_set);\n@@ -3579,14 +3579,14 @@ static rtx addr_placeholder;\n \n static void\n strength_reduce (scan_start, end, loop_top, insn_count,\n-\t\t loop_start, loop_end, unroll_p)\n+\t\t loop_start, loop_end, unroll_p, bct_p)\n      rtx scan_start;\n      rtx end;\n      rtx loop_top;\n      int insn_count;\n      rtx loop_start;\n      rtx loop_end;\n-     int unroll_p;\n+     int unroll_p, bct_p;\n {\n   rtx p;\n   rtx set;\n@@ -4106,7 +4106,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      the loop.  Unrolling may update part of this information, and the\n      correct data will be used for generating the BCT.  */\n #ifdef HAVE_decrement_and_branch_on_count\n-  if (HAVE_decrement_and_branch_on_count)\n+  if (HAVE_decrement_and_branch_on_count && bct_p)\n     analyze_loop_iterations (loop_start, loop_end);\n #endif\n #endif  /* HAIFA */\n@@ -4613,7 +4613,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n #ifdef HAIFA\n   /* instrument the loop with bct insn */\n #ifdef HAVE_decrement_and_branch_on_count\n-  if (HAVE_decrement_and_branch_on_count)\n+  if (HAVE_decrement_and_branch_on_count && bct_p)\n     insert_bct (loop_start, loop_end);\n #endif\n #endif  /* HAIFA */\n@@ -6981,7 +6981,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t\t  /* If we have a decrement_and_branch_on_count, prefer\n \t\t     the NE test, since this will allow that instruction to\n \t\t     be generated.  */\n-#if ! defined (HAVE_decrement_and_branch_on_zero) && defined (HAVE_decrement_and_branch_on_count)\n+#if ! defined (HAVE_decrement_and_branch_until_zero) && defined (HAVE_decrement_and_branch_on_count)\n \t\t  && (add_val != 1 || ! vtop)\n #endif\n \t\t  && GET_CODE (comparison_value) == CONST_INT\n@@ -8189,7 +8189,7 @@ insert_bct (loop_start, loop_end)\n \n   /* the only machine mode we work with - is the integer of the size that the\n      machine has */\n-  enum machine_mode loop_var_mode = SImode;\n+  enum machine_mode loop_var_mode = word_mode;\n \n   int loop_num = uid_loop_num [INSN_UID (loop_start)];\n \n@@ -8284,7 +8284,8 @@ insert_bct (loop_start, loop_end)\n   /* try to instrument the loop.  */\n \n   /* Handle the simpler case, where the bounds are known at compile time.  */\n-  if (GET_CODE (initial_value) == CONST_INT && GET_CODE (comparison_value) == CONST_INT)\n+  if (GET_CODE (initial_value) == CONST_INT\n+      && GET_CODE (comparison_value) == CONST_INT)\n     {\n       int n_iterations;\n       int increment_value_abs = INTVAL (increment) * increment_direction;\n@@ -8459,15 +8460,15 @@ instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n   rtx start_label;\n \n   rtx sequence;\n-  enum machine_mode loop_var_mode = SImode;\n+  enum machine_mode loop_var_mode = word_mode;\n \n   if (HAVE_decrement_and_branch_on_count)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"Loop: Inserting BCT\\n\");\n \n-      /* eliminate the check on the old variable */\n-      delete_insn (PREV_INSN (loop_end));\n+      /* Discard original jump to continue loop.  Original compare result\n+\t may still be live, so it cannot be discarded explicitly.  */\n       delete_insn (PREV_INSN (loop_end));\n \n       /* insert the label which will delimit the start of the loop */\n@@ -8488,12 +8489,13 @@ instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n \n       sequence = gen_sequence ();\n       end_sequence ();\n-      emit_insn_after (sequence, loop_start);\n+      emit_insn_before (sequence, loop_start);\n \n       /* insert new comparison on the count register instead of the\n \t old one, generating the needed BCT pattern (that will be\n \t later recognized by assembly generation phase).  */\n-      emit_jump_insn_before (gen_decrement_and_branch_on_count (temp_reg2, start_label),\n+      emit_jump_insn_before (gen_decrement_and_branch_on_count (temp_reg2,\n+\t\t\t\t\t\t\t\tstart_label),\n \t\t\t     loop_end);\n       LABEL_NUSES (start_label)++;\n     }\n@@ -8935,4 +8937,3 @@ replace_label (x, data)\n   return 0;\n }\n \n-     "}, {"sha": "8b88a7e42fdf83499f43832e4aa0f280501a8efd", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -1350,7 +1350,7 @@ extern void print_inline_rtx\t\tPROTO ((FILE *, rtx, int));\n /* In loop.c */\n extern void init_loop\t\t\tPROTO ((void));\n #ifdef BUFSIZ\n-extern void loop_optimize\t\tPROTO ((rtx, FILE *, int));\n+extern void loop_optimize\t\tPROTO ((rtx, FILE *, int, int));\n #endif\n extern void record_excess_regs\t\tPROTO ((rtx, rtx, rtx *));\n "}, {"sha": "86cbcf6f64d8129a50182692186a81a5f7b9927d", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5accd82209963c5d048e6096311e9b40b48efd15/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5accd82209963c5d048e6096311e9b40b48efd15", "patch": "@@ -3519,7 +3519,7 @@ rest_of_compilation (decl)\n \t     {\n \t       /* We only want to perform unrolling once.  */\n \t       \n-\t       loop_optimize (insns, rtl_dump_file, 0);\n+\t       loop_optimize (insns, rtl_dump_file, 0, 0);\n \t       \n \t\n \t       /* The first call to loop_optimize makes some instructions\n@@ -3532,7 +3532,7 @@ rest_of_compilation (decl)\n \t\t  analysis code depends on this information.  */\n \t       reg_scan (insns, max_reg_num (), 1);\n \t     }\n-\t   loop_optimize (insns, rtl_dump_file, flag_unroll_loops);\n+\t   loop_optimize (insns, rtl_dump_file, flag_unroll_loops, 1);\n \t });\n       \n       /* Dump rtl code after loop opt, if we are doing that.  */"}]}