{"sha": "6fc9f7aa731e895585c47d740509b5cd1591e797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZjOWY3YWE3MzFlODk1NTg1YzQ3ZDc0MDUwOWI1Y2QxNTkxZTc5Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-05-26T09:17:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-05-26T09:17:54Z"}, "message": "cp-tree.h (struct lang_decl_decomp): New type.\n\n\t* cp-tree.h (struct lang_decl_decomp): New type.\n\t(struct lang_decl): Add u.decomp.\n\t(LANG_DECL_DECOMP_CHECK): Define.\n\t(DECL_DECOMPOSITION_P): Note it is set also on the vars\n\tfor user identifiers.\n\t(DECL_DECOMP_BASE): Define.\n\t(retrofit_lang_decl): Add extra int = 0 argument.\n\t* lex.c (retrofit_lang_decl): Add SEL argument, if non-zero\n\tuse it to influence the selector choices and for selector\n\t0 to non-zero transition copy old content.\n\t(cxx_dup_lang_specific_decl): Handle DECL_DECOMPOSITION_P.\n\t* decl.c (poplevel): For DECL_DECOMPOSITION_P, check\n\t!DECL_DECOMP_BASE instead of !DECL_VALUE_EXPR.  Adjust warning\n\twording if decl is a structured binding.\n\t(cp_finish_decomp): Pass 4 as the new argument to retrofit_lang_decl.\n\tSet DECL_DECOMP_BASE.  Ignore DECL_READ_P sets from initialization\n\tof individual variables for tuple structured bindings.\n\t(grokdeclarator): Pass 4 as the new argument to retrofit_lang_decl.\n\tClear DECL_DECOMP_BASE.\n\t* decl2.c (mark_used): Mark DECL_DECOMP_BASE TREE_USED as well.\n\t* pt.c (tsubst_decomp_names): Assert DECL_DECOMP_BASE matches what\n\tis expected.\n\t* expr.c (mark_exp_read): Recurse on DECL_DECOMP_BASE instead of\n\tDECL_VALUE_EXPR.\n\n\t* g++.dg/cpp1z/decomp29.C (p): New variable.\n\t(main): Add further tests.\n\nFrom-SVN: r248483", "tree": {"sha": "d6a31e869ca764436905f87f10676d248ddddf01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6a31e869ca764436905f87f10676d248ddddf01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fc9f7aa731e895585c47d740509b5cd1591e797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc9f7aa731e895585c47d740509b5cd1591e797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fc9f7aa731e895585c47d740509b5cd1591e797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc9f7aa731e895585c47d740509b5cd1591e797/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28e0e05badfbdf7930bbd6f3051b07dd7ec37ae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e0e05badfbdf7930bbd6f3051b07dd7ec37ae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e0e05badfbdf7930bbd6f3051b07dd7ec37ae2"}], "stats": {"total": 168, "additions": 147, "deletions": 21}, "files": [{"sha": "8143e8902ac08509836d97900dcdeb7e27d9e25f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -1,3 +1,30 @@\n+2017-05-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (struct lang_decl_decomp): New type.\n+\t(struct lang_decl): Add u.decomp.\n+\t(LANG_DECL_DECOMP_CHECK): Define.\n+\t(DECL_DECOMPOSITION_P): Note it is set also on the vars\n+\tfor user identifiers.\n+\t(DECL_DECOMP_BASE): Define.\n+\t(retrofit_lang_decl): Add extra int = 0 argument.\n+\t* lex.c (retrofit_lang_decl): Add SEL argument, if non-zero\n+\tuse it to influence the selector choices and for selector\n+\t0 to non-zero transition copy old content.\n+\t(cxx_dup_lang_specific_decl): Handle DECL_DECOMPOSITION_P.\n+\t* decl.c (poplevel): For DECL_DECOMPOSITION_P, check\n+\t!DECL_DECOMP_BASE instead of !DECL_VALUE_EXPR.  Adjust warning\n+\twording if decl is a structured binding.\n+\t(cp_finish_decomp): Pass 4 as the new argument to retrofit_lang_decl.\n+\tSet DECL_DECOMP_BASE.  Ignore DECL_READ_P sets from initialization\n+\tof individual variables for tuple structured bindings.\n+\t(grokdeclarator): Pass 4 as the new argument to retrofit_lang_decl.\n+\tClear DECL_DECOMP_BASE.\n+\t* decl2.c (mark_used): Mark DECL_DECOMP_BASE TREE_USED as well.\n+\t* pt.c (tsubst_decomp_names): Assert DECL_DECOMP_BASE matches what\n+\tis expected.\n+\t* expr.c (mark_exp_read): Recurse on DECL_DECOMP_BASE instead of\n+\tDECL_VALUE_EXPR.\n+\n 2017-05-25  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/80605 - __is_standard_layout and zero-length array"}, {"sha": "a471a639742356789c43f5153543a5ac4054481f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -2516,6 +2516,15 @@ struct GTY(()) lang_decl_parm {\n   int index;\n };\n \n+/* Additional DECL_LANG_SPECIFIC information for structured bindings.  */\n+\n+struct GTY(()) lang_decl_decomp {\n+  struct lang_decl_min min;\n+  /* The artificial underlying \"e\" variable of the structured binding\n+     variable.  */\n+  tree base;\n+};\n+\n /* DECL_LANG_SPECIFIC for all types.  It would be nice to just make this a\n    union rather than a struct containing a union as its only field, but\n    tree.h declares it as a struct.  */\n@@ -2527,6 +2536,7 @@ struct GTY(()) lang_decl {\n     struct lang_decl_fn GTY ((tag (\"1\"))) fn;\n     struct lang_decl_ns GTY((tag (\"2\"))) ns;\n     struct lang_decl_parm GTY((tag (\"3\"))) parm;\n+    struct lang_decl_decomp GTY((tag (\"4\"))) decomp;\n   } u;\n };\n \n@@ -2563,6 +2573,13 @@ struct GTY(()) lang_decl {\n     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n   &lt->u.parm; })\n \n+#define LANG_DECL_DECOMP_CHECK(NODE) __extension__\t\t\\\n+({ struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n+  if (!VAR_P (NODE)\t\t\t\t\t\t\\\n+      || lt->u.base.selector != 4)\t\t\t\t\\\n+    lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n+  &lt->u.decomp; })\n+\n #define LANG_DECL_U2_CHECK(NODE, TF) __extension__\t\t\\\n ({  struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n     if (!LANG_DECL_HAS_MIN (NODE) || lt->u.base.u2sel != TF)\t\\\n@@ -2583,6 +2600,9 @@ struct GTY(()) lang_decl {\n #define LANG_DECL_PARM_CHECK(NODE) \\\n   (&DECL_LANG_SPECIFIC (NODE)->u.parm)\n \n+#define LANG_DECL_DECOMP_CHECK(NODE) \\\n+  (&DECL_LANG_SPECIFIC (NODE)->u.decomp)\n+\n #define LANG_DECL_U2_CHECK(NODE, TF) \\\n   (&DECL_LANG_SPECIFIC (NODE)->u.min.u2)\n \n@@ -3816,8 +3836,8 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.var_declared_inline_p \\\n    = true)\n \n-/* Nonzero if NODE is an artificial VAR_DECL for a C++17 decomposition\n-   declaration.  */\n+/* Nonzero if NODE is an artificial VAR_DECL for a C++17 structured binding\n+   declaration or one of VAR_DECLs for the user identifiers in it.  */\n #define DECL_DECOMPOSITION_P(NODE) \\\n   (VAR_P (NODE) && DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n    ? DECL_LANG_SPECIFIC (NODE)->u.base.decomposition_p\t\t\\\n@@ -3826,6 +3846,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.decomposition_p \\\n    = true)\n \n+/* The underlying artificial VAR_DECL for structured binding.  */\n+#define DECL_DECOMP_BASE(NODE) \\\n+  (LANG_DECL_DECOMP_CHECK (NODE)->base)\n+\n /* Nonzero if NODE is an inline VAR_DECL.  In C++17, static data members\n    declared with constexpr specifier are implicitly inline variables.  */\n #define DECL_INLINE_VAR_P(NODE) \\\n@@ -6261,7 +6285,7 @@ extern tree unqualified_name_lookup_error\t(tree,\n extern tree unqualified_fn_lookup_error\t\t(cp_expr);\n extern tree build_lang_decl\t\t\t(enum tree_code, tree, tree);\n extern tree build_lang_decl_loc\t\t\t(location_t, enum tree_code, tree, tree);\n-extern void retrofit_lang_decl\t\t\t(tree);\n+extern void retrofit_lang_decl\t\t\t(tree, int = 0);\n extern tree copy_decl\t\t\t\t(tree CXX_MEM_STAT_INFO);\n extern tree copy_type\t\t\t\t(tree CXX_MEM_STAT_INFO);\n extern tree cxx_make_type\t\t\t(enum tree_code);"}, {"sha": "59cb315d8e01402a19ed3bb41fdfc5c2dd4aa0a7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -658,7 +658,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t    && ! DECL_IN_SYSTEM_HEADER (decl)\n \t    /* For structured bindings, consider only real variables, not\n \t       subobjects.  */\n-\t    && (DECL_DECOMPOSITION_P (decl) ? !DECL_VALUE_EXPR (decl)\n+\t    && (DECL_DECOMPOSITION_P (decl) ? !DECL_DECOMP_BASE (decl)\n \t\t: (DECL_NAME (decl) && !DECL_ARTIFICIAL (decl)))\n \t    && type != error_mark_node\n \t    && (!CLASS_TYPE_P (type)\n@@ -667,16 +667,28 @@ poplevel (int keep, int reverse, int functionbody)\n \t\t\t\t     TYPE_ATTRIBUTES (TREE_TYPE (decl)))))\n \t  {\n \t    if (! TREE_USED (decl))\n-\t      warning_at (DECL_SOURCE_LOCATION (decl),\n-\t\t\t  OPT_Wunused_variable, \"unused variable %qD\", decl);\n+\t      {\n+\t\tif (!DECL_NAME (decl) && DECL_DECOMPOSITION_P (decl))\n+\t\t  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t      OPT_Wunused_variable,\n+\t\t\t      \"unused structured binding declaration\");\n+\t\telse\n+\t\t  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t      OPT_Wunused_variable, \"unused variable %qD\", decl);\n+\t      }\n \t    else if (DECL_CONTEXT (decl) == current_function_decl\n \t\t     // For -Wunused-but-set-variable leave references alone.\n \t\t     && TREE_CODE (TREE_TYPE (decl)) != REFERENCE_TYPE\n \t\t     && errorcount == unused_but_set_errorcount)\n \t      {\n-\t\twarning_at (DECL_SOURCE_LOCATION (decl),\n-\t\t\t    OPT_Wunused_but_set_variable,\n-\t\t\t    \"variable %qD set but not used\", decl);\n+\t\tif (!DECL_NAME (decl) && DECL_DECOMPOSITION_P (decl))\n+\t\t  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t      OPT_Wunused_but_set_variable, \"structured \"\n+\t\t\t      \"binding declaration set but not used\");\n+\t\telse\n+\t\t  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t      OPT_Wunused_but_set_variable,\n+\t\t\t      \"variable %qD set but not used\", decl);\n \t\tunused_but_set_errorcount = errorcount;\n \t      }\n \t  }\n@@ -7361,8 +7373,9 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t    }\n \t  if (processing_template_decl)\n \t    {\n-\t      retrofit_lang_decl (first);\n+\t      retrofit_lang_decl (first, 4);\n \t      SET_DECL_DECOMPOSITION_P (first);\n+\t      DECL_DECOMP_BASE (first) = decl;\n \t    }\n \t  first = DECL_CHAIN (first);\n \t}\n@@ -7375,8 +7388,9 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n   for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))\n     {\n       v[count - i - 1] = d;\n-      retrofit_lang_decl (d);\n+      retrofit_lang_decl (d, 4);\n       SET_DECL_DECOMPOSITION_P (d);\n+      DECL_DECOMP_BASE (d) = decl;\n     }\n \n   tree type = TREE_TYPE (decl);\n@@ -7482,6 +7496,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n       eltscnt = tree_to_uhwi (tsize);\n       if (count != eltscnt)\n \tgoto cnt_mismatch;\n+      int save_read = DECL_READ_P (decl);\t\n       for (unsigned i = 0; i < count; ++i)\n \t{\n \t  location_t sloc = input_location;\n@@ -7514,6 +7529,10 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t    cp_finish_decl (v[i], init, /*constexpr*/false,\n \t\t\t    /*asm*/NULL_TREE, LOOKUP_NORMAL);\n \t}\n+      /* Ignore reads from the underlying decl performed during initialization\n+\t of the individual variables.  If those will be read, we'll mark\n+\t the underlying decl as read at that point.  */\n+      DECL_READ_P (decl) = save_read;\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n     {\n@@ -12295,9 +12314,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t  {\n \t    gcc_assert (declarator && declarator->kind == cdk_decomp);\n \t    DECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n-\t    retrofit_lang_decl (decl);\n+\t    retrofit_lang_decl (decl, 4);\n \t    DECL_ARTIFICIAL (decl) = 1;\n \t    SET_DECL_DECOMPOSITION_P (decl);\n+\t    DECL_DECOMP_BASE (decl) = NULL_TREE;\n \t  }\n       }\n "}, {"sha": "73eeb01fd75c07bc77877b527556f68f9244fb00", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -5027,6 +5027,9 @@ mark_used (tree decl, tsubst_flags_t complain)\n \n   /* Set TREE_USED for the benefit of -Wunused.  */\n   TREE_USED (decl) = 1;\n+  /* And for structured bindings also the underlying decl.  */\n+  if (DECL_DECOMPOSITION_P (decl) && DECL_DECOMP_BASE (decl))\n+    TREE_USED (DECL_DECOMP_BASE (decl)) = 1;\n \n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     return true;"}, {"sha": "8bd341b814e53dd6c00c443b2d53319a309614bd", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -133,8 +133,8 @@ mark_exp_read (tree exp)\n   switch (TREE_CODE (exp))\n     {\n     case VAR_DECL:\n-      if (DECL_VALUE_EXPR (exp))\n-\tmark_exp_read (DECL_VALUE_EXPR (exp));\n+      if (DECL_DECOMPOSITION_P (exp))\n+\tmark_exp_read (DECL_DECOMP_BASE (exp));\n       gcc_fallthrough ();\n     case PARM_DECL:\n       DECL_READ_P (exp) = 1;"}, {"sha": "a9c38ff24a3430fd948ddae6ac0a8e3b0dd4e2e1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -529,16 +529,28 @@ build_lang_decl_loc (location_t loc, enum tree_code code, tree name, tree type)\n    and pushdecl (for functions generated by the back end).  */\n \n void\n-retrofit_lang_decl (tree t)\n+retrofit_lang_decl (tree t, int sel)\n {\n   struct lang_decl *ld;\n   size_t size;\n-  int sel;\n+  size_t oldsize = 0;\n \n   if (DECL_LANG_SPECIFIC (t))\n-    return;\n+    {\n+      if (sel)\n+\t{\n+\t  if (DECL_LANG_SPECIFIC (t)->u.base.selector == sel)\n+\t    return;\n+\t  gcc_assert (DECL_LANG_SPECIFIC (t)->u.base.selector == 0);\n+\t  oldsize = sizeof (struct lang_decl_min);\n+\t}\n+      else\n+\treturn;\n+    }\n \n-  if (TREE_CODE (t) == FUNCTION_DECL)\n+  if (sel == 4)\n+    size = sizeof (struct lang_decl_decomp);\n+  else if (TREE_CODE (t) == FUNCTION_DECL)\n     sel = 1, size = sizeof (struct lang_decl_fn);\n   else if (TREE_CODE (t) == NAMESPACE_DECL)\n     sel = 2, size = sizeof (struct lang_decl_ns);\n@@ -550,6 +562,8 @@ retrofit_lang_decl (tree t)\n     gcc_unreachable ();\n \n   ld = (struct lang_decl *) ggc_internal_cleared_alloc (size);\n+  if (oldsize)\n+    memcpy (ld, DECL_LANG_SPECIFIC (t), oldsize);\n \n   ld->u.base.selector = sel;\n \n@@ -584,6 +598,8 @@ cxx_dup_lang_specific_decl (tree node)\n     size = sizeof (struct lang_decl_ns);\n   else if (TREE_CODE (node) == PARM_DECL)\n     size = sizeof (struct lang_decl_parm);\n+  else if (DECL_DECOMPOSITION_P (node))\n+    size = sizeof (struct lang_decl_decomp);\n   else if (LANG_DECL_HAS_MIN (node))\n     size = sizeof (struct lang_decl_min);\n   else"}, {"sha": "306838550a6055848b9a2904ed555383a326df9f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -15705,6 +15705,7 @@ tsubst_decomp_names (tree decl, tree pattern_decl, tree args,\n \t  return error_mark_node;\n \t}\n       (*cnt)++;\n+      gcc_assert (DECL_DECOMP_BASE (decl2) == pattern_decl);\n       gcc_assert (DECL_HAS_VALUE_EXPR_P (decl2));\n       tree v = DECL_VALUE_EXPR (decl2);\n       DECL_HAS_VALUE_EXPR_P (decl2) = 0;"}, {"sha": "4f73955c6f621ea3ebad1f82ad110aff651b995e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -1,3 +1,8 @@\n+2017-05-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/cpp1z/decomp29.C (p): New variable.\n+\t(main): Add further tests.\n+\n 2017-05-26  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/80842"}, {"sha": "3ccc3839580a517215c6e4fc055a8a1e61dd28cd", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp29.C", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc9f7aa731e895585c47d740509b5cd1591e797/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp29.C?ref=6fc9f7aa731e895585c47d740509b5cd1591e797", "patch": "@@ -5,6 +5,7 @@\n struct A { int i,j,k; };\n \n A f();\n+int p[3];\n \n int z;\n \n@@ -13,14 +14,43 @@ int main()\n   {\n     auto [i,j,k] = f();\t\t// { dg-warning \"unused\" }\n   }\n+  {\n+    [[maybe_unused]] auto [i,j,k] = f();\n+  }\n   {\n     auto [i,j,k] = f();\n     z = i;\n   }\n+  {\n+    auto [i,j,k] = f();\t\t// { dg-warning \"unused\" }\n+    i = 5;\n+  }\n   {\n     auto [i,j] = std::tuple{1,2}; // { dg-warning \"unused\" }\n   }\n-  // No parallel second test, because in this case i and j are variables rather\n-  // than mere bindings, so there isn't a link between them and using i will\n-  // not prevent a warning about unused j.\n+  {\n+    [[maybe_unused]] auto [i,j] = std::tuple{1,2};\n+  }\n+  {\n+    auto [i,j] = std::tuple{1,2};\n+    z = i;\n+  }\n+  {\n+    auto [i,j] = std::tuple{1,2};\n+    i = 5;\n+  }\n+  {\n+    auto [i,j,k] = p;\t\t// { dg-warning \"unused\" }\n+  }\n+  {\n+    [[maybe_unused]] auto [i,j,k] = p;\n+  }\n+  {\n+    auto [i,j,k] = p;\n+    z = i;\n+  }\n+  {\n+    auto [i,j,k] = p;\t\t// { dg-warning \"unused\" }\n+    i = 5;\n+  }\n }"}]}