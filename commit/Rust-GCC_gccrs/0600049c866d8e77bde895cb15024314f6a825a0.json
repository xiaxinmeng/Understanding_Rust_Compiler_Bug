{"sha": "0600049c866d8e77bde895cb15024314f6a825a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYwMDA0OWM4NjZkOGU3N2JkZTg5NWNiMTUwMjQzMTRmNmE4MjVhMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-05-09T04:54:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-05-09T04:54:00Z"}, "message": "re PR tree-optimization/61009 (Incorrect jump threading in dom)\n\n2014-05-08  Jeff Law  <law@redhat.com>\n\n\tPR tree-optimization/61009\n\t* tree-ssa-threadedge.c (thread_through_normal_block): Return a\n\ttri-state rather than a boolean.  When a block is too big to\n\tthread through, inform caller via negative return value.\n\t(thread_across_edge): If a block was too big for normal threading,\n\tthen it's too big for a joiner too, so remove temporary equivalences\n\tand return immediately.\n\n\tPR tree-optimization/61009\n\t* g++.dg/tree-ssa/pr61009.C: New test.\n\nFrom-SVN: r210254", "tree": {"sha": "cbc791c7513ab01df98725b7949cce900c6550c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbc791c7513ab01df98725b7949cce900c6550c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0600049c866d8e77bde895cb15024314f6a825a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0600049c866d8e77bde895cb15024314f6a825a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0600049c866d8e77bde895cb15024314f6a825a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0600049c866d8e77bde895cb15024314f6a825a0/comments", "author": null, "committer": null, "parents": [{"sha": "db48367c49381336fd732ecfd3b2bb48e0a83bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db48367c49381336fd732ecfd3b2bb48e0a83bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db48367c49381336fd732ecfd3b2bb48e0a83bc3"}], "stats": {"total": 127, "additions": 114, "deletions": 13}, "files": [{"sha": "0b27fc823e0a900c8b0f254c76aa2a41cf5384cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0600049c866d8e77bde895cb15024314f6a825a0", "patch": "@@ -1,3 +1,13 @@\n+2014-05-08  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/61009\n+\t* tree-ssa-threadedge.c (thread_through_normal_block): Return a\n+\ttri-state rather than a boolean.  When a block is too big to\n+\tthread through, inform caller via negative return value.\n+\t(thread_across_edge): If a block was too big for normal threading,\n+\tthen it's too big for a joiner too, so remove temporary equivalences\n+\tand return immediately.\n+\n 2014-05-08  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \t    Matthias Klose  <doko@ubuntu.com>\n "}, {"sha": "959763fef5aab703c522489a295f1a22b0d4698f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0600049c866d8e77bde895cb15024314f6a825a0", "patch": "@@ -1,3 +1,8 @@\n+2014-05-08  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/61009\n+\t* g++.dg/tree-ssa/pr61009.C: New test.\n+\n 2014-05-08  Matthias Klose  <doko@ubuntu.com>\n \n \tPR driver/61106"}, {"sha": "4e7bb1a1c7b8807c04d9e6ae0282932874647b82", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr61009.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr61009.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr61009.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr61009.C?ref=0600049c866d8e77bde895cb15024314f6a825a0", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-vrp -std=c++11 -fno-strict-aliasing -fdump-tree-dom1\" } */\n+\n+#include <stdio.h>\n+struct Field {\n+ virtual int Compare(void*, void*);\n+};\n+extern int NKF, NR;\n+extern int idxs[];\n+extern Field* the_field;\n+extern int *incs;\n+extern char** fptrs;\n+inline int doCmp(int this_row_offset, int field_idx) {\n+ void *p = fptrs[field_idx] + this_row_offset * incs[field_idx];\n+ return the_field->Compare(p,0);\n+}\n+bool  Test(void) {\n+\n+ int row_offset = 0;\n+\n+ for (; row_offset < NR; ++row_offset) {\n+\n+   bool is_different = false;\n+   for (int j = 0; j < NKF ; ++j) {\n+     int field_idx = idxs[j];\n+     int cmp = doCmp(row_offset, field_idx);\n+     fprintf (stderr, \"cmp=%d\\n\",cmp);\n+\n+     if (cmp == 0) {\n+       continue;\n+     }\n+     if (cmp > 0) {\n+       is_different = true;\n+       break;\n+     } else {\n+       fprintf (stderr, \"Incorrect\\n\");\n+       return false;\n+     }\n+   }\n+   if (!is_different) {\n+\n+     return false;\n+   }\n+ }\n+\n+ return true;\n+}\n+\n+// The block ending with cmp == 0 should not be threaded.  ie,\n+// there should be a single == 0 comparison in the dump file.\n+\n+// { dg-final { scan-tree-dump-times \"== 0\" 1 \"dom1\" } }\n+// { dg-final { cleanup-tree-dump \"dom1\" } }"}, {"sha": "8e628d5535da2fa808f4e4615337ad2c56367d14", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0600049c866d8e77bde895cb15024314f6a825a0/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=0600049c866d8e77bde895cb15024314f6a825a0", "patch": "@@ -966,9 +966,14 @@ thread_around_empty_blocks (edge taken_edge,\n    SIMPLIFY is a pass-specific function used to simplify statements.\n \n    Our caller is responsible for restoring the state of the expression\n-   and const_and_copies stacks.  */\n+   and const_and_copies stacks.\n \n-static bool\n+   Positive return value is success.  Zero return value is failure, but\n+   the block can still be duplicated as a joiner in a jump thread path,\n+   negative indicates the block should not be duplicated and thus is not\n+   suitable for a joiner in a jump threading path.  */\n+\n+static int\n thread_through_normal_block (edge e,\n \t\t\t     gimple dummy_cond,\n \t\t\t     bool handle_dominating_asserts,\n@@ -990,16 +995,24 @@ thread_through_normal_block (edge e,\n   /* PHIs create temporary equivalences.  */\n   if (!record_temporary_equivalences_from_phis (e, stack, *backedge_seen_p,\n \t\t\t\t\t\tsrc_map, dst_map))\n-    return false;\n+    return 0;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n   gimple stmt\n     = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify,\n \t\t\t\t\t\t\t*backedge_seen_p,\n \t\t\t\t\t\t\tsrc_map, dst_map);\n+\n+  /* If we didn't look at all the statements, the most likely reason is\n+     there were too many and thus duplicating this block is not profitable.\n+\n+     Also note if we do not look at all the statements, then we may not\n+     have invalidated equivalences that are no longer valid if we threaded\n+     around a loop.  Thus we must signal to our caller that this block\n+     is not suitable for use as a joiner in a threading path.  */\n   if (!stmt)\n-    return false;\n+    return -1;\n \n   /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n      will be taken.  */\n@@ -1023,7 +1036,7 @@ thread_through_normal_block (edge e,\n \t  if (dest == NULL\n \t      || dest == e->dest\n \t      || bitmap_bit_p (visited, dest->index))\n-\t    return false;\n+\t    return 0;\n \n \t  /* Only push the EDGE_START_JUMP_THREAD marker if this is\n \t     first edge on the path.  */\n@@ -1057,10 +1070,10 @@ thread_through_normal_block (edge e,\n \t\t\t\t      visited,\n \t\t\t\t      path,\n \t\t\t\t      backedge_seen_p);\n-\t  return true;\n+\t  return 1;\n \t}\n     }\n-  return false;\n+  return 0;\n }\n \n /* We are exiting E->src, see if E->dest ends with a conditional\n@@ -1112,9 +1125,12 @@ thread_across_edge (gimple dummy_cond,\n   if (backedge_seen)\n     simplify = dummy_simplify;\n \n-  if (thread_through_normal_block (e, dummy_cond, handle_dominating_asserts,\n-\t\t\t\t   stack, simplify, path, visited,\n-\t\t\t\t   &backedge_seen, src_map, dst_map))\n+  int threaded = thread_through_normal_block (e, dummy_cond,\n+\t\t\t\t\t      handle_dominating_asserts,\n+\t\t\t\t\t      stack, simplify, path,\n+\t\t\t\t\t      visited, &backedge_seen,\n+\t\t\t\t\t      src_map, dst_map);\n+  if (threaded > 0)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n@@ -1127,10 +1143,27 @@ thread_across_edge (gimple dummy_cond,\n     }\n   else\n     {\n-      /* There should be no edges on the path, so no need to walk through\n-\t the vector entries.  */\n+      /* Negative and zero return values indicate no threading was possible,\n+\t thus there should be no edges on the thread path and no need to walk\n+\t through the vector entries.  */\n       gcc_assert (path->length () == 0);\n       path->release ();\n+\n+      /* A negative status indicates the target block was deemed too big to\n+\t duplicate.  Just quit now rather than trying to use the block as\n+\t a joiner in a jump threading path.\n+\n+\t This prevents unnecessary code growth, but more importantly if we\n+\t do not look at all the statements in the block, then we may have\n+\t missed some invalidations if we had traversed a backedge!  */\n+      if (threaded < 0)\n+\t{\n+\t  BITMAP_FREE (visited);\n+\t  BITMAP_FREE (src_map);\n+\t  BITMAP_FREE (dst_map);\n+\t  remove_temporary_equivalences (stack);\n+\t  return;\n+\t}\n     }\n \n  /* We were unable to determine what out edge from E->dest is taken.  However,\n@@ -1212,7 +1245,7 @@ thread_across_edge (gimple dummy_cond,\n \t\t\t\t\t       handle_dominating_asserts,\n \t\t\t\t\t       stack, simplify, path, visited,\n \t\t\t\t\t       &backedge_seen,\n-\t\t\t\t\t       src_map, dst_map);\n+\t\t\t\t\t       src_map, dst_map) > 0;\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */"}]}