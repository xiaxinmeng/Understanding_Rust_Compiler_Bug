{"sha": "e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlNTNjNzNhMGNmMmUzMjZiYmZkYWNiZTk0ZTRhM2JiNzljZDIxOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-01-26T20:32:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-04T09:11:13Z"}, "message": "[Ada] Remove OpenACC support\n\n2020-06-04  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* back_end.adb, opt.ads, par-prag.adb, sem_ch5.adb,\n\tsem_prag.adb, sinfo.adb, sinfo.ads, snames.ads-tmpl,\n\tdoc/gnat_rm/implementation_defined_pragmas.rst: Remove\n\texperimental support for OpenACC.\n\t* gcc-interface/misc.c, gcc-interface/trans.c,\n\tgcc-interface/lang.opt: Ditto.\n\t* gnat_rm.texi: Regenerate.\n\ngcc/testsuite/\n\n\t* gnat.dg/openacc1.adb: Remove testcase.", "tree": {"sha": "4d750b1859b750133f08307bb32e16ca1cb4dc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d750b1859b750133f08307bb32e16ca1cb4dc76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6b37ab0acd34629a41c694c0f3482c450bbd18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b37ab0acd34629a41c694c0f3482c450bbd18b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b37ab0acd34629a41c694c0f3482c450bbd18b"}], "stats": {"total": 3515, "additions": 837, "deletions": 2678}, "files": [{"sha": "38266fced824501d04fba7349cca6dedb96160cf", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -385,9 +385,6 @@ package body Back_End is\n             elsif Is_Front_End_Switch (Argv) then\n                Scan_Front_End_Switches (Argv, Args, Next_Arg);\n \n-            elsif Argv (Argv'First + 1 .. Argv'Last) = \"fopenacc\" then\n-               Opt.OpenAcc_Enabled := True;\n-\n             --  All non-front-end switches are back-end switches\n \n             else"}, {"sha": "e9e49588021cd38013de0af250356cbadd861327", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -89,158 +89,6 @@ Syntax:\n For the semantics of this pragma, see the entry for aspect ``Abstract_State`` in\n the SPARK 2014 Reference Manual, section 7.1.4.\n \n-Pragma Acc_Parallel\n-===================\n-Syntax:\n-\n-.. code-block:: ada\n-\n-  pragma Acc_Parallel [( ACC_PARALLEL_CLAUSE [, ACC_PARALLEL_CLAUSE... ])];\n-\n-  ACC_PARALLEL_CLAUSE ::=\n-      Acc_If        => boolean_EXPRESSION\n-    | Acc_Private   => IDENTIFIERS\n-    | Async         => integer_EXPRESSION\n-    | Copy          => IDENTIFIERS\n-    | Copy_In       => IDENTIFIERS\n-    | Copy_Out      => IDENTIFIERS\n-    | Create        => IDENTIFIERS\n-    | Default       => None\n-    | Device_Ptr    => IDENTIFIERS\n-    | First_Private => IDENTIFIERS\n-    | Num_Gangs     => integer_EXPRESSION\n-    | Num_Workers   => integer_EXPRESSION\n-    | Present       => IDENTIFIERS\n-    | Reduction     => (REDUCTION_RECORD)\n-    | Vector_Length => integer_EXPRESSION\n-    | Wait          => INTEGERS\n-\n-  REDUCTION_RECORD ::=\n-      \"+\"   => IDENTIFIERS\n-    | \"*\"   => IDENTIFIERS\n-    | \"min\" => IDENTIFIERS\n-    | \"max\" => IDENTIFIERS\n-    | \"or\"  => IDENTIFIERS\n-    | \"and\" => IDENTIFIERS\n-\n-  IDENTIFIERS ::=\n-    | IDENTIFIER\n-    | (IDENTIFIER, IDENTIFIERS)\n-\n-  INTEGERS ::=\n-    | integer_EXPRESSION\n-    | (integer_EXPRESSION, INTEGERS)\n-\n-Requires the :switch:`-fopenacc` flag.\n-\n-Equivalent to the ``parallel`` directive of the OpenAcc standard. This pragma\n-should be placed in loops. It offloads the content of the loop to an\n-accelerator device.\n-\n-For more information about the effect of the clauses, see the OpenAcc\n-specification.\n-\n-Pragma Acc_Loop\n-===============\n-Syntax:\n-\n-.. code-block:: ada\n-\n-  pragma Acc_Loop [( ACC_LOOP_CLAUSE [, ACC_LOOP_CLAUSE... ])];\n-\n-  ACC_LOOP_CLAUSE ::=\n-      Auto\n-    | Collapse        => INTEGER_LITERAL\n-    | Gang            [=> GANG_ARG]\n-    | Independent\n-    | Private         => IDENTIFIERS\n-    | Reduction       => (REDUCTION_RECORD)\n-    | Seq\n-    | Tile            => SIZE_EXPRESSION\n-    | Vector          [=> integer_EXPRESSION]\n-    | Worker          [=> integer_EXPRESSION]\n-\n-  GANG_ARG ::=\n-      integer_EXPRESSION\n-    | Static => SIZE_EXPRESSION\n-\n-  SIZE_EXPRESSION ::=\n-      *\n-    | integer_EXPRESSION\n-\n-Requires the :switch:`-fopenacc` flag.\n-\n-Equivalent to the ``loop`` directive of the OpenAcc standard. This pragma\n-should be placed in for loops after the \"Acc_Parallel\" pragma. It tells the\n-compiler how to parallelize the loop.\n-\n-For more information about the effect of the clauses, see the OpenAcc\n-specification.\n-\n-Pragma Acc_Kernels\n-==================\n-Syntax:\n-\n-.. code-block:: ada\n-\n-  pragma Acc_Kernels [( ACC_KERNELS_CLAUSE [, ACC_KERNELS_CLAUSE...])];\n-\n-  ACC_KERNELS_CLAUSE ::=\n-      Acc_If        => boolean_EXPRESSION\n-    | Async         => integer_EXPRESSION\n-    | Copy          => IDENTIFIERS\n-    | Copy_In       => IDENTIFIERS\n-    | Copy_Out      => IDENTIFIERS\n-    | Create        => IDENTIFIERS\n-    | Default       => None\n-    | Device_Ptr    => IDENTIFIERS\n-    | Num_Gangs     => integer_EXPRESSION\n-    | Num_Workers   => integer_EXPRESSION\n-    | Present       => IDENTIFIERS\n-    | Vector_Length => integer_EXPRESSION\n-    | Wait          => INTEGERS\n-\n-  IDENTIFIERS ::=\n-    | IDENTIFIER\n-    | (IDENTIFIER, IDENTIFIERS)\n-\n-  INTEGERS ::=\n-    | integer_EXPRESSION\n-    | (integer_EXPRESSION, INTEGERS)\n-\n-Requires the :switch:`-fopenacc` flag.\n-\n-Equivalent to the kernels directive of the OpenAcc standard. This pragma should\n-be placed in loops.\n-\n-For more information about the effect of the clauses, see the OpenAcc\n-specification.\n-\n-Pragma Acc_Data\n-===============\n-Syntax:\n-\n-.. code-block:: ada\n-\n-  pragma Acc_Data ([ ACC_DATA_CLAUSE [, ACC_DATA_CLAUSE...]]);\n-\n-  ACC_DATA_CLAUSE ::=\n-      Copy          => IDENTIFIERS\n-    | Copy_In       => IDENTIFIERS\n-    | Copy_Out      => IDENTIFIERS\n-    | Create        => IDENTIFIERS\n-    | Device_Ptr    => IDENTIFIERS\n-    | Present       => IDENTIFIERS\n-\n-Requires the :switch:`-fopenacc` flag.\n-\n-Equivalent to the ``data`` directive of the OpenAcc standard. This pragma\n-should be placed in loops.\n-\n-For more information about the effect of the clauses, see the OpenAcc\n-specification.\n-\n-\n Pragma Ada_83\n =============\n "}, {"sha": "379157c67e9e1ad5ad4b2dd1484d1dfc05de1db2", "filename": "gcc/ada/gcc-interface/lang.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgcc-interface%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgcc-interface%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang.opt?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -104,8 +104,4 @@ fbuiltin-printf\n Ada Undocumented\n Ignored.\n \n-fopenacc\n-Ada LTO\n-; Documented in C but it should be: Enable OpenACC support\n-\n ; This comment is to ensure we retain the blank line above."}, {"sha": "f72122bf5e05b9904d71cf2c629b215662bb9792", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -164,7 +164,6 @@ gnat_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       /* These are handled by the front-end.  */\n       break;\n \n-    case OPT_fopenacc:\n     case OPT_fshort_enums:\n     case OPT_fsigned_char:\n     case OPT_funsigned_char:"}, {"sha": "b60b03d9ebb9e53e7aa8f44767edc235e40b6c83", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 671, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -1336,234 +1336,6 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   return gnu_result;\n }\n \f\n-/* If GNAT_EXPR is an N_Identifier, N_Integer_Literal or N_Operator_Symbol,\n-   call FN on it.  If GNAT_EXPR is an aggregate, call FN on each of its\n-   elements.  In both cases, pass GNU_EXPR and DATA as additional arguments.\n-\n-   This function is used everywhere OpenAcc pragmas are processed if these\n-   pragmas can accept aggregates.  */\n-\n-static tree\n-Iterate_Acc_Clause_Arg (Node_Id gnat_expr, tree gnu_expr,\n-\t\t\ttree (*fn)(Node_Id, tree, void*),\n-\t\t\tvoid* data)\n-{\n-  switch (Nkind (gnat_expr))\n-    {\n-    case N_Aggregate:\n-      if (Present (Expressions (gnat_expr)))\n-\t{\n-\t  for (Node_Id gnat_list_expr = First (Expressions (gnat_expr));\n-\t       Present (gnat_list_expr);\n-\t       gnat_list_expr = Next (gnat_list_expr))\n-\t    gnu_expr = fn (gnat_list_expr, gnu_expr, data);\n-\t}\n-      else if (Present (Component_Associations (gnat_expr)))\n-\t{\n-\t  for (Node_Id gnat_list_expr = First (Component_Associations\n-\t\t\t\t\t       (gnat_expr));\n-\t       Present (gnat_list_expr);\n-\t       gnat_list_expr = Next (gnat_list_expr))\n-\t    gnu_expr = fn (Expression (gnat_list_expr), gnu_expr, data);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-      break;\n-\n-    case N_Identifier:\n-    case N_Integer_Literal:\n-    case N_Operator_Symbol:\n-      gnu_expr = fn (gnat_expr, gnu_expr, data);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return gnu_expr;\n-}\n-\n-/* Same as gnat_to_gnu for a GNAT_NODE referenced within an OpenAcc directive,\n-   undoing transformations that are inappropriate for such context.  */\n-\n-tree\n-Acc_gnat_to_gnu (Node_Id gnat_node)\n-{\n-  tree gnu_result = gnat_to_gnu (gnat_node);\n-\n-    /* If gnat_node is an identifier for a boolean, gnat_to_gnu might have\n-       turned it into `identifier != 0`.  Since arguments to OpenAcc pragmas\n-       need to be writable, we need to return the identifier residing in such\n-       expressions rather than the expression itself.  */\n-    if (Nkind (gnat_node) == N_Identifier\n-\t&& TREE_CODE (gnu_result) == NE_EXPR\n-\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_result, 0))) == BOOLEAN_TYPE\n-\t&& integer_zerop (TREE_OPERAND (gnu_result, 1)))\n-      gnu_result = TREE_OPERAND (gnu_result, 0);\n-\n-  return gnu_result;\n-}\n-\n-/* Turn GNAT_EXPR into a tree node representing an OMP data clause and chain\n-   it to GNU_CLAUSES, a list of pre-existing OMP clauses.  GNAT_EXPR should be\n-   a N_Identifier, this is enforced by the frontend.\n-\n-   This function is called every time translation of an argument for an OpenAcc\n-   clause (e.g. Acc_Parallel(Copy => My_Identifier)) is needed.  */\n-\n-static tree\n-Acc_Data_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void* data)\n-{\n-  const enum gomp_map_kind kind = *((enum gomp_map_kind*) data);\n-  tree gnu_clause\n-    = build_omp_clause (EXPR_LOCATION(gnu_loop_stack->last ()->stmt),\n-\t\t        OMP_CLAUSE_MAP);\n-\n-  gcc_assert (Nkind (gnat_expr) == N_Identifier);\n-  OMP_CLAUSE_DECL (gnu_clause)\n-    = gnat_to_gnu_entity (Entity (gnat_expr), NULL_TREE, false);\n-\n-  TREE_ADDRESSABLE (OMP_CLAUSE_DECL (gnu_clause)) = 1;\n-  OMP_CLAUSE_SET_MAP_KIND (gnu_clause, kind);\n-  OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\n-  return gnu_clause;\n-}\n-\n-/* Turn GNAT_EXPR into a tree node representing an OMP clause and chain it to\n-   GNU_CLAUSES, a list of existing OMP clauses.\n-\n-   This function is used for parsing arguments of non-data clauses (e.g.\n-   Acc_Parallel(Wait => gnatexpr)).  */\n-\n-static tree\n-Acc_Var_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void* data)\n-{\n-  const enum omp_clause_code kind = *((enum omp_clause_code*) data);\n-  tree gnu_clause\n-    = build_omp_clause (EXPR_LOCATION (gnu_loop_stack->last ()->stmt), kind);\n-\n-  OMP_CLAUSE_DECL (gnu_clause) = Acc_gnat_to_gnu (gnat_expr);\n-  OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\n-  return gnu_clause;\n-}\n-\n-/* Turn GNAT_EXPR into a tree OMP clause representing a reduction clause.\n-   GNAT_EXPR has to be a N_Identifier, this is enforced by the frontend.\n-\n-   For example, GNAT_EXPR could be My_Identifier in the following pragma:\n-   Acc_Parallel(Reduction => (\"+\" => My_Identifier)).  */\n-\n-static tree\n-Acc_Reduc_Var_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void* data)\n-{\n-  const tree_code code = *((tree_code*) data);\n-  tree gnu_clause\n-    = build_omp_clause (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t\tOMP_CLAUSE_REDUCTION);\n-\n-  OMP_CLAUSE_DECL (gnu_clause) = Acc_gnat_to_gnu (gnat_expr);\n-  OMP_CLAUSE_REDUCTION_CODE (gnu_clause) = code;\n-  OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\n-  return gnu_clause;\n-}\n-\n-/* Turn GNAT_EXPR into a list of OMP reduction clauses.  GNAT_EXPR has to\n-   follow the structure of a reduction clause, e.g. (\"+\" => Identifier).  */\n-\n-static tree\n-Acc_Reduc_to_gnu (Node_Id gnat_expr)\n-{\n-  tree gnu_clauses = NULL_TREE;\n-\n-  for (Node_Id gnat_op = First (Component_Associations (gnat_expr));\n-       Present (gnat_op);\n-       gnat_op = Next (gnat_op))\n-    {\n-      tree_code code = ERROR_MARK;\n-      String_Id str = Strval (First (Choices (gnat_op)));\n-      switch (Get_String_Char (str, 1))\n-\t{\n-\tcase '+':\n-\t  code = PLUS_EXPR;\n-\t  break;\n-\tcase '*':\n-\t  code = MULT_EXPR;\n-\t  break;\n-\tcase 'm':\n-\t  if (Get_String_Char (str, 2) == 'i'\n-\t      && Get_String_Char (str, 3) == 'n')\n-\t    code = MIN_EXPR;\n-\t  else if (Get_String_Char (str, 2) == 'a'\n-\t\t   && Get_String_Char (str, 3) == 'x')\n-\t    code = MAX_EXPR;\n-\t  break;\n-\tcase 'a':\n-\t  if (Get_String_Char (str, 2) == 'n'\n-\t      && Get_String_Char (str, 3) == 'd')\n-\t    code = TRUTH_ANDIF_EXPR;\n-\t  break;\n-\tcase 'o':\n-\t  if (Get_String_Char (str, 2) == 'r')\n-\t    code = TRUTH_ORIF_EXPR;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      /* Unsupported reduction operation.  This should have been\n-\t caught in sem_prag.adb.  */\n-      gcc_assert (code != ERROR_MARK);\n-\n-      gnu_clauses = Iterate_Acc_Clause_Arg (Expression (gnat_op),\n-\t\t\t\t\t    gnu_clauses,\n-\t\t\t\t\t    Acc_Reduc_Var_to_gnu,\n-\t\t\t\t\t    &code);\n-    }\n-\n-  return gnu_clauses;\n-}\n-\n-/* Turn GNAT_EXPR, either '*' or an integer literal, into a tree_cons.  This is\n-   only used by Acc_Size_List_to_gnu.  */\n-\n-static tree\n-Acc_Size_Expr_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void *)\n-{\n-  tree gnu_expr;\n-\n-  if (Nkind (gnat_expr) == N_Operator_Symbol\n-      && Get_String_Char (Strval (gnat_expr), 1) == '*')\n-    gnu_expr = integer_zero_node;\n-  else\n-    gnu_expr = Acc_gnat_to_gnu (gnat_expr);\n-\n-  return tree_cons (NULL_TREE, gnu_expr, gnu_clauses);\n-}\n-\n-/* Turn GNAT_EXPR, an aggregate of either '*' or integer literals, into an OMP\n-   clause node.\n-\n-   This function is used for the Tile clause of the Loop directive.  This is\n-   what GNAT_EXPR might look like: (1, 1, '*').  */\n-\n-static tree\n-Acc_Size_List_to_gnu (Node_Id gnat_expr)\n-{\n-  tree gnu_clause\n-    = build_omp_clause (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t        OMP_CLAUSE_TILE);\n-  tree gnu_list = Iterate_Acc_Clause_Arg (gnat_expr, NULL_TREE,\n-\t\t\t\t\t  Acc_Size_Expr_to_gnu,\n-\t\t\t\t\t  NULL);\n-\n-  OMP_CLAUSE_TILE_LIST (gnu_clause) = nreverse (gnu_list);\n-\n-  return gnu_clause;\n-}\n-\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Pragma.  Return\n    any statements we generate.  */\n \n@@ -1635,279 +1407,6 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t}\n       break;\n \n-    case Pragma_Acc_Loop:\n-      {\n-\tif (!flag_openacc)\n-\t  break;\n-\n-\ttree gnu_clauses = gnu_loop_stack->last ()->omp_loop_clauses;\n-\n-\tif (!Present (Pragma_Argument_Associations (gnat_node)))\n-\t  break;\n-\n-\tfor (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n-\t     Present (gnat_temp);\n-\t     gnat_temp = Next (gnat_temp))\n-\t  {\n-\t    Node_Id gnat_expr = Expression (gnat_temp);\n-\t    tree gnu_clause = NULL_TREE;\n-\t    enum omp_clause_code kind;\n-\n-\t    if (Chars (gnat_temp) == No_Name)\n-\t      {\n-\t\t/* The clause is an identifier without a parameter.  */\n-\t\tswitch (Chars (gnat_expr))\n-\t\t  {\n-\t\t  case Name_Auto:\n-\t\t    kind = OMP_CLAUSE_AUTO;\n-\t\t    break;\n-\t\t  case Name_Gang:\n-\t\t    kind = OMP_CLAUSE_GANG;\n-\t\t    break;\n-\t\t  case Name_Independent:\n-\t\t    kind = OMP_CLAUSE_INDEPENDENT;\n-\t\t    break;\n-\t\t  case Name_Seq:\n-\t\t    kind = OMP_CLAUSE_SEQ;\n-\t\t    break;\n-\t\t  case Name_Vector:\n-\t\t    kind = OMP_CLAUSE_VECTOR;\n-\t\t    break;\n-\t\t  case Name_Worker:\n-\t\t    kind = OMP_CLAUSE_WORKER;\n-\t\t    break;\n-\t\t  default:\n-\t\t    gcc_unreachable ();\n-\t\t  }\n-\t\tgnu_clause = build_omp_clause (EXPR_LOCATION\n-\t\t\t\t\t       (gnu_loop_stack->last ()->stmt),\n-\t\t\t\t\t       kind);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* The clause is an identifier parameter(s).  */\n-\t\tswitch (Chars (gnat_temp))\n-\t\t  {\n-\t\t  case Name_Collapse:\n-\t\t    gnu_clause = build_omp_clause\n-\t\t      (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t       OMP_CLAUSE_COLLAPSE);\n-\t\t    OMP_CLAUSE_COLLAPSE_EXPR (gnu_clause) =\n-\t\t      Acc_gnat_to_gnu (gnat_expr);\n-\t\t    break;\n-\t\t  case Name_Device_Type:\n-\t\t    /* Unimplemented by GCC yet.  */\n-\t\t    gcc_unreachable ();\n-\t\t    break;\n-\t\t  case Name_Independent:\n-\t\t    gnu_clause = build_omp_clause\n-\t\t      (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t       OMP_CLAUSE_INDEPENDENT);\n-\t\t    break;\n-\t\t  case Name_Acc_Private:\n-\t\t    kind = OMP_CLAUSE_PRIVATE;\n-\t\t    gnu_clause = Iterate_Acc_Clause_Arg (gnat_expr, 0,\n-\t\t\t\t\t\t\t Acc_Var_to_gnu,\n-\t\t\t\t\t\t\t &kind);\n-\t\t    break;\n-\t\t  case Name_Reduction:\n-\t\t    gnu_clause = Acc_Reduc_to_gnu (gnat_expr);\n-\t\t    break;\n-\t\t  case Name_Tile:\n-\t\t    gnu_clause = Acc_Size_List_to_gnu (gnat_expr);\n-\t\t    break;\n-\t\t  case Name_Gang:\n-\t\t  case Name_Vector:\n-\t\t  case Name_Worker:\n-\t\t    /* These are for the Loop+Kernel combination, which is\n-\t\t       unimplemented by the frontend for now.  */\n-\t\t  default:\n-\t\t    gcc_unreachable ();\n-\t\t  }\n-\t      }\n-\t    OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t    gnu_clauses = gnu_clause;\n-\t  }\n-\tgnu_loop_stack->last ()->omp_loop_clauses = gnu_clauses;\n-      }\n-    break;\n-\n-    /* Grouping the transformation of these pragmas together makes sense\n-       because they are mutually exclusive, share most of their clauses and\n-       the verification that each clause can legally appear for the pragma has\n-       been done in the frontend.  */\n-    case Pragma_Acc_Data:\n-    case Pragma_Acc_Kernels:\n-    case Pragma_Acc_Parallel:\n-      {\n-\tif (!flag_openacc)\n-\t  break;\n-\n-\ttree gnu_clauses = gnu_loop_stack->last ()->omp_construct_clauses;\n-\tif (id == Pragma_Acc_Data)\n-\t  gnu_loop_stack->last ()->omp_code = OACC_DATA;\n-\telse if (id == Pragma_Acc_Kernels)\n-\t  gnu_loop_stack->last ()->omp_code = OACC_KERNELS;\n-\telse if (id == Pragma_Acc_Parallel)\n-\t  gnu_loop_stack->last ()->omp_code = OACC_PARALLEL;\n-\telse\n-\t  gcc_unreachable ();\n-\n-\tif (!Present (Pragma_Argument_Associations (gnat_node)))\n-\t  break;\n-\n-\tfor (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n-\t    Present (gnat_temp);\n-\t    gnat_temp = Next (gnat_temp))\n-\t  {\n-\t    Node_Id gnat_expr = Expression (gnat_temp);\n-\t    tree gnu_clause;\n-\t    enum omp_clause_code clause_code;\n-\t    enum gomp_map_kind map_kind;\n-\n-\t    switch (Chars (gnat_temp))\n-\t      {\n-\t      case Name_Async:\n-\t\tgnu_clause = build_omp_clause\n-\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t   OMP_CLAUSE_ASYNC);\n-\t\tOMP_CLAUSE_ASYNC_EXPR (gnu_clause) =\n-\t\t  Acc_gnat_to_gnu (gnat_expr);\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\tgnu_clauses = gnu_clause;\n-\t\tbreak;\n-\n-\t      case Name_Num_Gangs:\n-\t\tgnu_clause = build_omp_clause\n-\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t   OMP_CLAUSE_NUM_GANGS);\n-\t\tOMP_CLAUSE_NUM_GANGS_EXPR (gnu_clause) =\n-\t\t  Acc_gnat_to_gnu (gnat_expr);\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\tgnu_clauses = gnu_clause;\n-\t\tbreak;\n-\n-\t      case Name_Num_Workers:\n-\t\tgnu_clause = build_omp_clause\n-\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t   OMP_CLAUSE_NUM_WORKERS);\n-\t\tOMP_CLAUSE_NUM_WORKERS_EXPR (gnu_clause) =\n-\t\t  Acc_gnat_to_gnu (gnat_expr);\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\tgnu_clauses = gnu_clause;\n-\t\tbreak;\n-\n-\t      case Name_Vector_Length:\n-\t\tgnu_clause = build_omp_clause\n-\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n-\t\t   OMP_CLAUSE_VECTOR_LENGTH);\n-\t\tOMP_CLAUSE_VECTOR_LENGTH_EXPR (gnu_clause) =\n-\t\t  Acc_gnat_to_gnu (gnat_expr);\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\tgnu_clauses = gnu_clause;\n-\t\tbreak;\n-\n-\t      case Name_Wait:\n-\t\tclause_code = OMP_CLAUSE_WAIT;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Var_to_gnu,\n-\t\t\t\t\t\t      &clause_code);\n-\t\tbreak;\n-\n-\t      case Name_Acc_If:\n-\t\tgnu_clause = build_omp_clause (EXPR_LOCATION\n-\t\t\t\t\t       (gnu_loop_stack->last ()->stmt),\n-\t\t\t\t\t       OMP_CLAUSE_IF);\n-\t\tOMP_CLAUSE_IF_MODIFIER (gnu_clause) = ERROR_MARK;\n-\t\tOMP_CLAUSE_IF_EXPR (gnu_clause) = Acc_gnat_to_gnu (gnat_expr);\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\tgnu_clauses = gnu_clause;\n-\t\tbreak;\n-\n-\t      case Name_Copy:\n-\t\tmap_kind = GOMP_MAP_FORCE_TOFROM;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Data_to_gnu,\n-\t\t\t\t\t\t      &map_kind);\n-\t\tbreak;\n-\n-\t      case Name_Copy_In:\n-\t\tmap_kind = GOMP_MAP_FORCE_TO;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Data_to_gnu,\n-\t\t\t\t\t\t      &map_kind);\n-\t\tbreak;\n-\n-\t      case Name_Copy_Out:\n-\t\tmap_kind = GOMP_MAP_FORCE_FROM;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Data_to_gnu,\n-\t\t\t\t\t\t      &map_kind);\n-\t\tbreak;\n-\n-\t      case Name_Present:\n-\t\tmap_kind = GOMP_MAP_FORCE_PRESENT;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Data_to_gnu,\n-\t\t\t\t\t\t      &map_kind);\n-\t\tbreak;\n-\n-\t      case Name_Create:\n-\t\tmap_kind = GOMP_MAP_FORCE_ALLOC;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Data_to_gnu,\n-\t\t\t\t\t\t      &map_kind);\n-\t\tbreak;\n-\n-\t      case Name_Device_Ptr:\n-\t\tmap_kind = GOMP_MAP_FORCE_DEVICEPTR;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Data_to_gnu,\n-\t\t\t\t\t\t      &map_kind);\n-\t\tbreak;\n-\n-\t      case Name_Acc_Private:\n-\t\tclause_code = OMP_CLAUSE_PRIVATE;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Var_to_gnu,\n-\t\t\t\t\t\t      &clause_code);\n-\t\tbreak;\n-\n-\t      case Name_First_Private:\n-\t\tclause_code = OMP_CLAUSE_FIRSTPRIVATE;\n-\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n-\t\t\t\t\t\t      Acc_Var_to_gnu,\n-\t\t\t\t\t\t      &clause_code);\n-\t\tbreak;\n-\n-\t      case Name_Default:\n-\t\tgnu_clause = build_omp_clause (EXPR_LOCATION\n-\t\t\t\t\t       (gnu_loop_stack->last ()->stmt),\n-\t\t\t\t\t       OMP_CLAUSE_DEFAULT);\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\t/* The standard also accepts \"present\" but this isn't\n-\t\t   implemented in GCC yet.  */\n-\t\tOMP_CLAUSE_DEFAULT_KIND (gnu_clause) = OMP_CLAUSE_DEFAULT_NONE;\n-\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n-\t\tgnu_clauses = gnu_clause;\n-\t\tbreak;\n-\n-\t      case Name_Reduction:\n-\t\tgnu_clauses = Acc_Reduc_to_gnu(gnat_expr);\n-\t\tbreak;\n-\n-\t      case Name_Detach:\n-\t      case Name_Attach:\n-\t      case Name_Device_Type:\n-\t\t/* Unimplemented by GCC.  */\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\t  }\n-\tgnu_loop_stack->last ()->omp_construct_clauses = gnu_clauses;\n-      }\n-      break;\n-\n     case Pragma_Loop_Optimize:\n       for (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n \t   Present (gnat_temp);\n@@ -3462,148 +2961,6 @@ independent_iterations_p (tree stmt_list)\n   return true;\n }\n \n-/* Helper for Loop_Statement_to_gnu to translate the body of a loop,\n-   designated by GNAT_LOOP, to which an Acc_Loop pragma applies.  The pragma\n-   arguments might instruct us to collapse a nest of loops, where computation\n-   statements are expected only within the innermost loop, as in:\n-\n-   for I in 1 .. 5 loop\n-      pragma Acc_Parallel;\n-      pragma Acc_Loop(Collapse => 3);\n-      for J in 1 .. 8 loop\n-         for K in 1 .. 4 loop\n-            X (I, J, K) := Y (I, J, K) + 2;\n-         end loop;\n-      end loop;\n-   end loop;\n-\n-   We expect the top of gnu_loop_stack to hold a pointer to the loop info\n-   setup for the translation of GNAT_LOOP, which holds a pointer to the\n-   initial gnu loop stmt node.  We return the new gnu loop statement to\n-   use.  */\n-\n-static tree\n-Acc_Loop_to_gnu (Node_Id gnat_loop)\n-{\n-  tree acc_loop = make_node (OACC_LOOP);\n-  tree acc_bind_expr = NULL_TREE;\n-  Node_Id cur_loop = gnat_loop;\n-  int collapse_count = 1;\n-  tree initv;\n-  tree condv;\n-  tree incrv;\n-\n-  /* Parse the pragmas, adding clauses to the current gnu_loop_stack through\n-     side effects.  */\n-  for (Node_Id tmp = First (Statements (gnat_loop));\n-       Present (tmp) && Nkind (tmp) == N_Pragma;\n-       tmp = Next (tmp))\n-    Pragma_to_gnu(tmp);\n-\n-  /* Find the number of loops that should be collapsed.  */\n-  for (tree tmp = gnu_loop_stack->last ()->omp_loop_clauses; tmp ;\n-       tmp = OMP_CLAUSE_CHAIN (tmp))\n-    if (OMP_CLAUSE_CODE (tmp) == OMP_CLAUSE_COLLAPSE)\n-      collapse_count = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (tmp));\n-    else if (OMP_CLAUSE_CODE (tmp) == OMP_CLAUSE_TILE)\n-      collapse_count = list_length (OMP_CLAUSE_TILE_LIST (tmp));\n-\n-  initv = make_tree_vec (collapse_count);\n-  condv = make_tree_vec (collapse_count);\n-  incrv = make_tree_vec (collapse_count);\n-\n-  start_stmt_group ();\n-  gnat_pushlevel ();\n-\n-  /* For each nested loop that should be collapsed ...  */\n-  for (int count = 0; count < collapse_count; ++count)\n-    {\n-      Node_Id lps =\n-        Loop_Parameter_Specification (Iteration_Scheme (cur_loop));\n-      tree low =\n-        Acc_gnat_to_gnu (Low_Bound (Discrete_Subtype_Definition (lps)));\n-      tree high =\n-        Acc_gnat_to_gnu (High_Bound (Discrete_Subtype_Definition (lps)));\n-      tree variable =\n-\tgnat_to_gnu_entity (Defining_Identifier (lps), NULL_TREE, true);\n-\n-      /* Build the initial value of the variable of the invariant.  */\n-      TREE_VEC_ELT (initv, count) = build2 (MODIFY_EXPR,\n-\t\t\t\t\t    TREE_TYPE (variable),\n-\t\t\t\t\t    variable,\n-\t\t\t\t\t    low);\n-      add_stmt (TREE_VEC_ELT (initv, count));\n-\n-      /* Build the invariant of the loop.  */\n-      TREE_VEC_ELT (condv, count) = build2 (LE_EXPR,\n-\t\t\t\t\t    boolean_type_node,\n-\t\t\t\t\t    variable,\n-\t\t\t\t\t    high);\n-\n-      /* Build the incrementation expression of the loop.  */\n-      TREE_VEC_ELT (incrv, count) =\n-\tbuild2 (MODIFY_EXPR,\n-\t\tTREE_TYPE (variable),\n-\t\tvariable,\n-\t\tbuild2 (PLUS_EXPR,\n-\t\t\tTREE_TYPE (variable),\n-\t\t\tvariable,\n-\t\t\tbuild_int_cst (TREE_TYPE (variable), 1)));\n-\n-      /* Don't process the innermost loop because its statements belong to\n-         another statement group.  */\n-      if (count < collapse_count - 1)\n-\t/* Process the current loop's body.  */\n-\tfor (Node_Id stmt = First (Statements (cur_loop));\n-\t     Present (stmt); stmt = Next (stmt))\n-\t  {\n-\t    /* If we are processsing the outermost loop, it is ok for it to\n-\t       contain pragmas.  */\n-\t    if (Nkind (stmt) == N_Pragma && count == 0)\n-\t      ;\n-\t    /* The frontend might have inserted a N_Object_Declaration in the\n-\t       loop's body to declare the iteration variable of the next loop.\n-\t       It will need to be hoisted before the collapsed loops.  */\n-\t    else if (Nkind (stmt) == N_Object_Declaration)\n-\t      Acc_gnat_to_gnu (stmt);\n-\t    else if (Nkind (stmt) == N_Loop_Statement)\n-\t      cur_loop = stmt;\n-\t    /* Every other kind of statement is prohibited in collapsed\n-               loops.  */\n-\t    else if (count < collapse_count - 1)\n-\t      gcc_unreachable();\n-\t  }\n-    }\n-  gnat_poplevel ();\n-  acc_bind_expr = end_stmt_group ();\n-\n-  /* Parse the innermost loop.  */\n-  start_stmt_group();\n-  for (Node_Id stmt = First (Statements (cur_loop));\n-       Present (stmt);\n-       stmt = Next (stmt))\n-    {\n-      /* When the innermost loop is the only loop, do not parse the pragmas\n-         again.  */\n-      if (Nkind (stmt) == N_Pragma && collapse_count == 1)\n-\tcontinue;\n-      add_stmt (Acc_gnat_to_gnu (stmt));\n-    }\n-\n-  TREE_TYPE (acc_loop) = void_type_node;\n-  OMP_FOR_INIT (acc_loop) = initv;\n-  OMP_FOR_COND (acc_loop) = condv;\n-  OMP_FOR_INCR (acc_loop) = incrv;\n-  OMP_FOR_BODY (acc_loop) = end_stmt_group ();\n-  OMP_FOR_PRE_BODY (acc_loop) = NULL;\n-  OMP_FOR_ORIG_DECLS (acc_loop) = NULL;\n-  OMP_FOR_CLAUSES (acc_loop) = gnu_loop_stack->last ()->omp_loop_clauses;\n-\n-  BIND_EXPR_BODY (acc_bind_expr) = acc_loop;\n-\n-  return acc_bind_expr;\n-}\n-\n /* Helper for Loop_Statement_to_gnu, to translate the body of a loop not\n    subject to any sort of parallelization directive or restriction, designated\n    by GNAT_NODE.\n@@ -4003,34 +3360,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   gnu_loop_info->stmt = gnu_loop_stmt;\n \n   /* Perform the core loop body translation.  */\n-  if (Is_OpenAcc_Loop (gnat_node))\n-    gnu_loop_stmt = Acc_Loop_to_gnu (gnat_node);\n-  else\n-    gnu_loop_stmt = Regular_Loop_to_gnu (gnat_node, &gnu_cond_expr);\n-\n-  /* A gnat_node that has its OpenAcc_Environment flag set needs to be\n-     offloaded.  Note that the OpenAcc_Loop flag is not necessarily set.  */\n-  if (Is_OpenAcc_Environment (gnat_node))\n-    {\n-      tree_code code = gnu_loop_stack->last ()->omp_code;\n-      tree tmp = make_node (code);\n-      TREE_TYPE (tmp) = void_type_node;\n-      if (code == OACC_PARALLEL || code == OACC_KERNELS)\n-\t{\n-\t  OMP_BODY (tmp) = gnu_loop_stmt;\n-\t  OMP_CLAUSES (tmp) = gnu_loop_stack->last ()->omp_construct_clauses;\n-\t}\n-      else if (code == OACC_DATA)\n-\t{\n-\t  OACC_DATA_BODY (tmp) = gnu_loop_stmt;\n-\t  OACC_DATA_CLAUSES (tmp) =\n-\t    gnu_loop_stack->last ()->omp_construct_clauses;\n-\t}\n-      else\n-\tgcc_unreachable();\n-      set_expr_location_from_node (tmp, gnat_node);\n-      gnu_loop_stmt = tmp;\n-    }\n+  gnu_loop_stmt = Regular_Loop_to_gnu (gnat_node, &gnu_cond_expr);\n \n   /* If we have an outer COND_EXPR, that's our result and this loop is its\n      \"true\" statement.  Otherwise, the result is the LOOP_STMT.  */"}, {"sha": "5d98079e94f2b14b88e0e7d0455b1e0784bbe13d", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 834, "deletions": 1005, "changes": 1839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219"}, {"sha": "298da8b97d7b666c52bec86097f2af0a05a20cdd", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -1253,11 +1253,6 @@ package Opt is\n    --  cannot be simultaneous compilations with the object files in the same\n    --  object directory, if project files are used.\n \n-   OpenAcc_Enabled : Boolean := False;\n-   --  GNAT\n-   --  Indicates whether OpenAcc pragmas should be taken into account. Set to\n-   --  True by the use of -fopenacc.\n-\n    type Operating_Mode_Type is (Check_Syntax, Check_Semantics, Generate_Code);\n    pragma Ordered (Operating_Mode_Type);\n    Operating_Mode : Operating_Mode_Type := Generate_Code;"}, {"sha": "45830d97b3af8cd49e8dd71e9dc2b1a17928c347", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -1315,10 +1315,6 @@ begin\n \n       when Pragma_Abort_Defer\n          | Pragma_Abstract_State\n-         | Pragma_Acc_Data\n-         | Pragma_Acc_Kernels\n-         | Pragma_Acc_Loop\n-         | Pragma_Acc_Parallel\n          | Pragma_Aggregate_Individually_Assign\n          | Pragma_Async_Readers\n          | Pragma_Async_Writers"}, {"sha": "269e9ffd686e43cded5909123c6ef70d2b9d8504", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -3388,36 +3388,13 @@ package body Sem_Ch5 is\n       --  The following exception is raised by routine Prepare_Loop_Statement\n       --  to avoid further analysis of a transformed loop.\n \n-      function Disable_Constant (N : Node_Id) return Traverse_Result;\n-      --  If N represents an E_Variable entity, set Is_True_Constant To False\n-\n-      procedure Disable_Constants is new Traverse_Proc (Disable_Constant);\n-      --  Helper for Analyze_Loop_Statement, to unset Is_True_Constant on\n-      --  variables referenced within an OpenACC construct.\n-\n       procedure Prepare_Loop_Statement\n         (Iter            : Node_Id;\n          Stop_Processing : out Boolean);\n       --  Determine whether loop statement N with iteration scheme Iter must be\n       --  transformed prior to analysis, and if so, perform it.\n       --  If Stop_Processing is set to True, should stop further processing.\n \n-      ----------------------\n-      -- Disable_Constant --\n-      ----------------------\n-\n-      function Disable_Constant (N : Node_Id) return Traverse_Result is\n-      begin\n-         if Is_Entity_Name (N)\n-            and then Present (Entity (N))\n-            and then Ekind (Entity (N)) = E_Variable\n-         then\n-            Set_Is_True_Constant (Entity (N), False);\n-         end if;\n-\n-         return OK;\n-      end Disable_Constant;\n-\n       ----------------------------\n       -- Prepare_Loop_Statement --\n       ----------------------------\n@@ -4035,15 +4012,6 @@ package body Sem_Ch5 is\n       if No (Iter) and then not Has_Exit (Ent) then\n          Check_Unreachable_Code (Stmt);\n       end if;\n-\n-      --  Variables referenced within a loop subject to possible OpenACC\n-      --  offloading may be implicitly written to as part of the OpenACC\n-      --  transaction. Clear flags possibly conveying that they are constant,\n-      --  set for example when the code does not explicitly assign them.\n-\n-      if Is_OpenAcc_Environment (Stmt) then\n-         Disable_Constants (Stmt);\n-      end if;\n    end Analyze_Loop_Statement;\n \n    ----------------------------"}, {"sha": "d22ed252d98c8dac69987cdd7c901f4a867d5127", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 695, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -3787,12 +3787,6 @@ package body Sem_Prag is\n       -- Local Subprograms --\n       -----------------------\n \n-      function Acc_First (N : Node_Id) return Node_Id;\n-      --  Helper function to iterate over arguments given to OpenAcc pragmas\n-\n-      function Acc_Next (N : Node_Id) return Node_Id;\n-      --  Helper function to iterate over arguments given to OpenAcc pragmas\n-\n       procedure Ada_2005_Pragma;\n       --  Called for pragmas defined in Ada 2005, that are not in Ada 95. In\n       --  Ada 95 mode, these are implementation defined pragmas, so should be\n@@ -4340,89 +4334,6 @@ package body Sem_Prag is\n       --  which is used for error messages on any constructs violating the\n       --  profile.\n \n-      procedure Validate_Acc_Condition_Clause (Clause : Node_Id);\n-      --  Make sure the argument of a given Acc_If clause is a Boolean\n-\n-      procedure Validate_Acc_Data_Clause (Clause : Node_Id);\n-      --  Make sure the argument of an OpenAcc data clause (e.g. Copy, Copyin,\n-      --  Copyout...) is an identifier or an aggregate of identifiers.\n-\n-      procedure Validate_Acc_Int_Expr_Clause (Clause : Node_Id);\n-      --  Make sure the argument of an OpenAcc clause is an Integer expression\n-\n-      procedure Validate_Acc_Int_Expr_List_Clause (Clause : Node_Id);\n-      --  Make sure the argument of an OpenAcc clause is an Integer expression\n-      --  or a list of Integer expressions.\n-\n-      procedure Validate_Acc_Loop_Collapse (Clause : Node_Id);\n-      --  Make sure that the parent loop of the Acc_Loop(Collapse => N) pragma\n-      --  contains at least N-1 nested loops.\n-\n-      procedure Validate_Acc_Loop_Gang (Clause : Node_Id);\n-      --  Make sure the argument of the Gang clause of a Loop directive is\n-      --  either an integer expression or a (Static => integer expressions)\n-      --  aggregate.\n-\n-      procedure Validate_Acc_Loop_Vector (Clause : Node_Id);\n-      --  When this procedure is called in a construct offloaded by an\n-      --  Acc_Kernels pragma, makes sure that a Vector_Length clause does\n-      --  not exist on said pragma. In all cases, make sure the argument\n-      --  is an Integer expression.\n-\n-      procedure Validate_Acc_Loop_Worker (Clause : Node_Id);\n-      --  When this procedure is called in a construct offloaded by an\n-      --  Acc_Parallel pragma, makes sure that no argument has been given.\n-      --  When this procedure is called in a construct offloaded by an\n-      --  Acc_Kernels pragma and if Loop_Worker was given an argument,\n-      --  makes sure that the Num_Workers clause does not appear on the\n-      --  Acc_Kernels pragma and that the argument is an integer.\n-\n-      procedure Validate_Acc_Name_Reduction (Clause : Node_Id);\n-      --  Make sure the reduction clause is an aggregate made of a string\n-      --  representing a supported reduction operation (i.e. \"+\", \"*\", \"and\",\n-      --  \"or\", \"min\" or \"max\") and either an identifier or aggregate of\n-      --  identifiers.\n-\n-      procedure Validate_Acc_Size_Expressions (Clause : Node_Id);\n-      --  Makes sure that Clause is either an integer expression or an\n-      --  association with a Static as name and a list of integer expressions\n-      --  or \"*\" strings on the right hand side.\n-\n-      ---------------\n-      -- Acc_First --\n-      ---------------\n-\n-      function Acc_First (N : Node_Id) return Node_Id is\n-      begin\n-         if Nkind (N) = N_Aggregate then\n-            if Present (Expressions (N)) then\n-               return First (Expressions (N));\n-\n-            elsif Present (Component_Associations (N)) then\n-               return Expression (First (Component_Associations (N)));\n-            end if;\n-         end if;\n-\n-         return N;\n-      end Acc_First;\n-\n-      --------------\n-      -- Acc_Next --\n-      --------------\n-\n-      function Acc_Next (N : Node_Id) return Node_Id is\n-      begin\n-         if Nkind (Parent (N)) = N_Component_Association then\n-            return Expression (Next (Parent (N)));\n-\n-         elsif Nkind (Parent (N)) = N_Aggregate then\n-            return Next (N);\n-\n-         else\n-            return Empty;\n-         end if;\n-      end Acc_Next;\n-\n       ---------------------\n       -- Ada_2005_Pragma --\n       ---------------------\n@@ -11419,308 +11330,6 @@ package body Sem_Prag is\n          end if;\n       end Set_Ravenscar_Profile;\n \n-      -----------------------------------\n-      -- Validate_Acc_Condition_Clause --\n-      -----------------------------------\n-\n-      procedure Validate_Acc_Condition_Clause (Clause : Node_Id) is\n-      begin\n-         Analyze_And_Resolve (Clause);\n-\n-         if not Is_Boolean_Type (Etype (Clause)) then\n-            Error_Pragma (\"expected a boolean\");\n-         end if;\n-      end Validate_Acc_Condition_Clause;\n-\n-      ------------------------------\n-      -- Validate_Acc_Data_Clause --\n-      ------------------------------\n-\n-      procedure Validate_Acc_Data_Clause (Clause : Node_Id) is\n-         Expr : Node_Id;\n-\n-      begin\n-         Expr := Acc_First (Clause);\n-         while Present (Expr) loop\n-            if Nkind (Expr) /= N_Identifier then\n-               Error_Pragma (\"expected an identifer\");\n-            end if;\n-\n-            Analyze_And_Resolve (Expr);\n-\n-            Expr := Acc_Next (Expr);\n-         end loop;\n-      end Validate_Acc_Data_Clause;\n-\n-      ----------------------------------\n-      -- Validate_Acc_Int_Expr_Clause --\n-      ----------------------------------\n-\n-      procedure Validate_Acc_Int_Expr_Clause (Clause : Node_Id) is\n-      begin\n-         Analyze_And_Resolve (Clause);\n-\n-         if not Is_Integer_Type (Etype (Clause)) then\n-            Error_Pragma_Arg (\"expected an integer\", Clause);\n-         end if;\n-      end Validate_Acc_Int_Expr_Clause;\n-\n-      ---------------------------------------\n-      -- Validate_Acc_Int_Expr_List_Clause --\n-      ---------------------------------------\n-\n-      procedure Validate_Acc_Int_Expr_List_Clause (Clause : Node_Id) is\n-         Expr : Node_Id;\n-\n-      begin\n-         Expr := Acc_First (Clause);\n-         while Present (Expr) loop\n-            Analyze_And_Resolve (Expr);\n-\n-            if not Is_Integer_Type (Etype (Expr)) then\n-               Error_Pragma (\"expected an integer\");\n-            end if;\n-\n-            Expr := Acc_Next (Expr);\n-         end loop;\n-      end Validate_Acc_Int_Expr_List_Clause;\n-\n-      --------------------------------\n-      -- Validate_Acc_Loop_Collapse --\n-      --------------------------------\n-\n-      procedure Validate_Acc_Loop_Collapse (Clause : Node_Id) is\n-         Count    : Uint;\n-         Par_Loop : Node_Id;\n-         Stmt     : Node_Id;\n-\n-      begin\n-         --  Make sure the argument is a positive integer\n-\n-         Analyze_And_Resolve (Clause);\n-\n-         Count := Static_Integer (Clause);\n-         if Count = No_Uint or else Count < 1 then\n-            Error_Pragma_Arg (\"expected a positive integer\", Clause);\n-         end if;\n-\n-         --  Then, make sure we have at least Count-1 tightly-nested loops\n-         --  (i.e. loops with no statements in between).\n-\n-         Par_Loop := Parent (Parent (Parent (Clause)));\n-         Stmt     := First (Statements (Par_Loop));\n-\n-         --  Skip first pragmas in the parent loop\n-\n-         while Present (Stmt) and then Nkind (Stmt) = N_Pragma loop\n-            Next (Stmt);\n-         end loop;\n-\n-         if not Present (Next (Stmt)) then\n-            while Nkind (Stmt) = N_Loop_Statement and Count > 1 loop\n-               Stmt := First (Statements (Stmt));\n-               exit when Present (Next (Stmt));\n-\n-               Count := Count - 1;\n-            end loop;\n-         end if;\n-\n-         if Count > 1 then\n-            Error_Pragma_Arg\n-              (\"Collapse argument too high or loops not tightly nested\",\n-               Clause);\n-         end if;\n-      end Validate_Acc_Loop_Collapse;\n-\n-      ----------------------------\n-      -- Validate_Acc_Loop_Gang --\n-      ----------------------------\n-\n-      procedure Validate_Acc_Loop_Gang (Clause : Node_Id) is\n-      begin\n-         Error_Pragma_Arg (\"Loop_Gang not implemented\", Clause);\n-      end Validate_Acc_Loop_Gang;\n-\n-      ------------------------------\n-      -- Validate_Acc_Loop_Vector --\n-      ------------------------------\n-\n-      procedure Validate_Acc_Loop_Vector (Clause : Node_Id) is\n-      begin\n-         Error_Pragma_Arg (\"Loop_Vector not implemented\", Clause);\n-      end Validate_Acc_Loop_Vector;\n-\n-      -------------------------------\n-      --  Validate_Acc_Loop_Worker --\n-      -------------------------------\n-\n-      procedure Validate_Acc_Loop_Worker (Clause : Node_Id) is\n-      begin\n-         Error_Pragma_Arg (\"Loop_Worker not implemented\", Clause);\n-      end Validate_Acc_Loop_Worker;\n-\n-      ---------------------------------\n-      -- Validate_Acc_Name_Reduction --\n-      ---------------------------------\n-\n-      procedure Validate_Acc_Name_Reduction (Clause : Node_Id) is\n-\n-         --  ??? On top of the following operations, the OpenAcc spec adds the\n-         --  \"bitwise and\", \"bitwise or\" and modulo for C and \".eqv\" and\n-         --  \".neqv\" for Fortran. Can we, should we and how do we support them\n-         --  in Ada?\n-\n-         type Reduction_Op is (Add_Op, Mul_Op, Max_Op, Min_Op, And_Op, Or_Op);\n-\n-         function To_Reduction_Op (Op : String) return Reduction_Op;\n-         --  Convert operator Op described by a String into its corresponding\n-         --  enumeration value.\n-\n-         ---------------------\n-         -- To_Reduction_Op --\n-         ---------------------\n-\n-         function To_Reduction_Op (Op : String) return Reduction_Op is\n-         begin\n-            if Op = \"+\" then\n-               return Add_Op;\n-\n-            elsif Op = \"*\" then\n-               return Mul_Op;\n-\n-            elsif Op = \"max\" then\n-               return Max_Op;\n-\n-            elsif Op = \"min\" then\n-               return Min_Op;\n-\n-            elsif Op = \"and\" then\n-               return And_Op;\n-\n-            elsif Op = \"or\" then\n-               return Or_Op;\n-\n-            else\n-               Error_Pragma (\"unsuported reduction operation\");\n-            end if;\n-         end To_Reduction_Op;\n-\n-         --  Local variables\n-\n-         Seen : constant Elist_Id := New_Elmt_List;\n-\n-         Expr      : Node_Id;\n-         Reduc_Op  : Node_Id;\n-         Reduc_Var : Node_Id;\n-\n-      --  Start of processing for Validate_Acc_Name_Reduction\n-\n-      begin\n-         --  Reduction operations appear in the following form:\n-         --    (\"+\" => (a, b), \"*\" => c)\n-\n-         Expr := First (Component_Associations (Clause));\n-         while Present (Expr) loop\n-            Reduc_Op := First (Choices (Expr));\n-            String_To_Name_Buffer (Strval (Reduc_Op));\n-\n-            case To_Reduction_Op (Name_Buffer (1 .. Name_Len)) is\n-               when Add_Op\n-                  | Mul_Op\n-                  | Max_Op\n-                  | Min_Op\n-               =>\n-                  Reduc_Var := Acc_First (Expression (Expr));\n-                  while Present (Reduc_Var) loop\n-                     Analyze_And_Resolve (Reduc_Var);\n-\n-                     if Contains (Seen, Entity (Reduc_Var)) then\n-                        Error_Pragma (\"variable used in multiple reductions\");\n-\n-                     else\n-                        if Nkind (Reduc_Var) /= N_Identifier\n-                          or not Is_Numeric_Type (Etype (Reduc_Var))\n-                        then\n-                           Error_Pragma\n-                             (\"expected an identifier for a Numeric\");\n-                        end if;\n-\n-                        Append_Elmt (Entity (Reduc_Var), Seen);\n-                     end if;\n-\n-                     Reduc_Var := Acc_Next (Reduc_Var);\n-                  end loop;\n-\n-               when And_Op\n-                  | Or_Op\n-               =>\n-                  Reduc_Var := Acc_First (Expression (Expr));\n-                  while Present (Reduc_Var) loop\n-                     Analyze_And_Resolve (Reduc_Var);\n-\n-                     if Contains (Seen, Entity (Reduc_Var)) then\n-                        Error_Pragma (\"variable used in multiple reductions\");\n-\n-                     else\n-                        if Nkind (Reduc_Var) /= N_Identifier\n-                          or not Is_Boolean_Type (Etype (Reduc_Var))\n-                        then\n-                           Error_Pragma\n-                             (\"expected a variable of type boolean\");\n-                        end if;\n-\n-                        Append_Elmt (Entity (Reduc_Var), Seen);\n-                     end if;\n-\n-                     Reduc_Var := Acc_Next (Reduc_Var);\n-                  end loop;\n-            end case;\n-\n-            Next (Expr);\n-         end loop;\n-      end Validate_Acc_Name_Reduction;\n-\n-      -----------------------------------\n-      -- Validate_Acc_Size_Expressions --\n-      -----------------------------------\n-\n-      procedure Validate_Acc_Size_Expressions (Clause : Node_Id) is\n-         function Validate_Size_Expr (Expr : Node_Id) return Boolean;\n-         --  A size expr is either an integer expression or \"*\"\n-\n-         ------------------------\n-         -- Validate_Size_Expr --\n-         ------------------------\n-\n-         function Validate_Size_Expr (Expr : Node_Id) return Boolean is\n-         begin\n-            if Nkind (Expr) = N_Operator_Symbol then\n-               return Get_String_Char (Strval (Expr), 1) = Get_Char_Code ('*');\n-            end if;\n-\n-            Analyze_And_Resolve (Expr);\n-\n-            return Is_Integer_Type (Etype (Expr));\n-         end Validate_Size_Expr;\n-\n-         --  Local variables\n-\n-         Expr : Node_Id;\n-\n-      --  Start of processing for Validate_Acc_Size_Expressions\n-\n-      begin\n-         Expr := Acc_First (Clause);\n-         while Present (Expr) loop\n-            if not Validate_Size_Expr (Expr) then\n-               Error_Pragma\n-                 (\"Size expressions should be either integers or '*'\");\n-            end if;\n-\n-            Expr := Acc_Next (Expr);\n-         end loop;\n-      end Validate_Acc_Size_Expressions;\n-\n    --  Start of processing for Analyze_Pragma\n \n    begin\n@@ -12664,306 +12273,6 @@ package body Sem_Prag is\n             Analyze_If_Present (Pragma_Initial_Condition);\n          end Abstract_State;\n \n-         --------------\n-         -- Acc_Data --\n-         --------------\n-\n-         when Pragma_Acc_Data => Acc_Data : declare\n-            Clause_Names : constant Name_List :=\n-              (Name_Attach,\n-               Name_Copy,\n-               Name_Copy_In,\n-               Name_Copy_Out,\n-               Name_Create,\n-               Name_Delete,\n-               Name_Detach,\n-               Name_Device_Ptr,\n-               Name_No_Create,\n-               Name_Present);\n-\n-            Clause  : Node_Id;\n-            Clauses : Args_List (Clause_Names'Range);\n-\n-         begin\n-            if not OpenAcc_Enabled then\n-               return;\n-            end if;\n-\n-            GNAT_Pragma;\n-\n-            if Nkind (Parent (N)) /= N_Loop_Statement then\n-               Error_Pragma\n-                 (\"Acc_Data pragma should be placed in loop or block \"\n-                  & \"statements\");\n-            end if;\n-\n-            Gather_Associations (Clause_Names, Clauses);\n-\n-            for Id in Clause_Names'First .. Clause_Names'Last loop\n-               Clause := Clauses (Id);\n-\n-               if Present (Clause) then\n-                  case Clause_Names (Id) is\n-                     when Name_Copy\n-                        | Name_Copy_In\n-                        | Name_Copy_Out\n-                        | Name_Create\n-                        | Name_Device_Ptr\n-                        | Name_Present\n-                     =>\n-                        Validate_Acc_Data_Clause (Clause);\n-\n-                     when Name_Attach\n-                        | Name_Detach\n-                        | Name_Delete\n-                        | Name_No_Create\n-                      =>\n-                        Error_Pragma (\"unsupported pragma clause\");\n-\n-                     when others =>\n-                        raise Program_Error;\n-                  end case;\n-               end if;\n-            end loop;\n-\n-            Set_Is_OpenAcc_Environment (Parent (N));\n-         end Acc_Data;\n-\n-         --------------\n-         -- Acc_Loop --\n-         --------------\n-\n-         when Pragma_Acc_Loop => Acc_Loop : declare\n-            Clause_Names : constant Name_List :=\n-              (Name_Auto,\n-               Name_Collapse,\n-               Name_Gang,\n-               Name_Independent,\n-               Name_Acc_Private,\n-               Name_Reduction,\n-               Name_Seq,\n-               Name_Tile,\n-               Name_Vector,\n-               Name_Worker);\n-\n-            Clause  : Node_Id;\n-            Clauses : Args_List (Clause_Names'Range);\n-            Par     : Node_Id;\n-\n-         begin\n-            if not OpenAcc_Enabled then\n-               return;\n-            end if;\n-\n-            GNAT_Pragma;\n-\n-            --  Make sure the pragma is in an openacc construct\n-\n-            Check_Loop_Pragma_Placement;\n-\n-            Par := Parent (N);\n-            while Present (Par)\n-              and then (Nkind (Par) /= N_Loop_Statement\n-                         or else not Is_OpenAcc_Environment (Par))\n-            loop\n-               Par := Parent (Par);\n-            end loop;\n-\n-            if not Is_OpenAcc_Environment (Par) then\n-               Error_Pragma\n-                 (\"Acc_Loop directive must be associated with an OpenAcc \"\n-                  & \"construct region\");\n-            end if;\n-\n-            Gather_Associations (Clause_Names, Clauses);\n-\n-            for Id in Clause_Names'First .. Clause_Names'Last loop\n-               Clause := Clauses (Id);\n-\n-               if Present (Clause) then\n-                  case Clause_Names (Id) is\n-                     when Name_Auto\n-                        | Name_Independent\n-                        | Name_Seq\n-                     =>\n-                        null;\n-\n-                     when Name_Collapse =>\n-                        Validate_Acc_Loop_Collapse (Clause);\n-\n-                     when Name_Gang =>\n-                        Validate_Acc_Loop_Gang (Clause);\n-\n-                     when Name_Acc_Private =>\n-                        Validate_Acc_Data_Clause (Clause);\n-\n-                     when Name_Reduction =>\n-                        Validate_Acc_Name_Reduction (Clause);\n-\n-                     when Name_Tile =>\n-                        Validate_Acc_Size_Expressions (Clause);\n-\n-                     when Name_Vector =>\n-                        Validate_Acc_Loop_Vector (Clause);\n-\n-                     when Name_Worker =>\n-                        Validate_Acc_Loop_Worker (Clause);\n-\n-                     when others =>\n-                        raise Program_Error;\n-                  end case;\n-               end if;\n-            end loop;\n-\n-            Set_Is_OpenAcc_Loop (Parent (N));\n-         end Acc_Loop;\n-\n-         ----------------------------------\n-         -- Acc_Parallel and Acc_Kernels --\n-         ----------------------------------\n-\n-         when Pragma_Acc_Parallel\n-            | Pragma_Acc_Kernels\n-         =>\n-         Acc_Kernels_Or_Parallel : declare\n-            Clause_Names : constant Name_List :=\n-              (Name_Acc_If,\n-               Name_Async,\n-               Name_Copy,\n-               Name_Copy_In,\n-               Name_Copy_Out,\n-               Name_Create,\n-               Name_Default,\n-               Name_Device_Ptr,\n-               Name_Device_Type,\n-               Name_Num_Gangs,\n-               Name_Num_Workers,\n-               Name_Present,\n-               Name_Vector_Length,\n-               Name_Wait,\n-\n-               --  Parallel only\n-\n-               Name_Acc_Private,\n-               Name_First_Private,\n-               Name_Reduction,\n-\n-               --  Kernels only\n-\n-               Name_Attach,\n-               Name_No_Create);\n-\n-            Clause  : Node_Id;\n-            Clauses : Args_List (Clause_Names'Range);\n-\n-         begin\n-            if not OpenAcc_Enabled then\n-               return;\n-            end if;\n-\n-            GNAT_Pragma;\n-            Check_Loop_Pragma_Placement;\n-\n-            if Nkind (Parent (N)) /= N_Loop_Statement then\n-               Error_Pragma\n-                 (\"pragma should be placed in loop or block statements\");\n-            end if;\n-\n-            Gather_Associations (Clause_Names, Clauses);\n-\n-            for Id in Clause_Names'First .. Clause_Names'Last loop\n-               Clause := Clauses (Id);\n-\n-               if Present (Clause) then\n-                  if Chars (Parent (Clause)) = No_Name then\n-                     Error_Pragma (\"all arguments should be associations\");\n-                  else\n-                     case Clause_Names (Id) is\n-\n-                        --  Note: According to the OpenAcc Standard v2.6,\n-                        --  Async's argument should be optional. Because this\n-                        --  complicates parsing the clause, the argument is\n-                        --  made mandatory. The standard defines two negative\n-                        --  values, acc_async_noval and acc_async_sync. When\n-                        --  given acc_async_noval as value, the clause should\n-                        --  behave as if no argument was given. According to\n-                        --  the standard, acc_async_noval is defined in header\n-                        --  files for C and Fortran, thus this value should\n-                        --  probably be defined in the OpenAcc Ada library once\n-                        --  it is implemented.\n-\n-                        when Name_Async\n-                           | Name_Num_Gangs\n-                           | Name_Num_Workers\n-                           | Name_Vector_Length\n-                        =>\n-                           Validate_Acc_Int_Expr_Clause (Clause);\n-\n-                        when Name_Acc_If =>\n-                           Validate_Acc_Condition_Clause (Clause);\n-\n-                        --  Unsupported by GCC\n-\n-                        when Name_Attach\n-                           | Name_No_Create\n-                        =>\n-                           Error_Pragma (\"unsupported clause\");\n-\n-                        when Name_Acc_Private\n-                           | Name_First_Private\n-                        =>\n-                           if Prag_Id /= Pragma_Acc_Parallel then\n-                              Error_Pragma\n-                                (\"argument is only available for 'Parallel' \"\n-                                 & \"construct\");\n-                           else\n-                              Validate_Acc_Data_Clause (Clause);\n-                           end if;\n-\n-                        when Name_Copy\n-                           | Name_Copy_In\n-                           | Name_Copy_Out\n-                           | Name_Create\n-                           | Name_Device_Ptr\n-                           | Name_Present\n-                        =>\n-                           Validate_Acc_Data_Clause (Clause);\n-\n-                        when Name_Reduction =>\n-                           if Prag_Id /= Pragma_Acc_Parallel then\n-                              Error_Pragma\n-                                (\"argument is only available for 'Parallel' \"\n-                                 & \"construct\");\n-                           else\n-                              Validate_Acc_Name_Reduction (Clause);\n-                           end if;\n-\n-                        when Name_Default =>\n-                           if Chars (Clause) /= Name_None then\n-                              Error_Pragma (\"expected none\");\n-                           end if;\n-\n-                        when Name_Device_Type =>\n-                           Error_Pragma (\"unsupported pragma clause\");\n-\n-                        --  Similar to Name_Async, Name_Wait's arguments should\n-                        --  be optional. However, this can be simulated using\n-                        --  acc_async_noval, hence, we do not bother making the\n-                        --  argument optional for now.\n-\n-                        when Name_Wait =>\n-                           Validate_Acc_Int_Expr_List_Clause (Clause);\n-\n-                        when others =>\n-                           raise Program_Error;\n-                     end case;\n-                  end if;\n-               end if;\n-            end loop;\n-\n-            Set_Is_OpenAcc_Environment (Parent (N));\n-         end Acc_Kernels_Or_Parallel;\n-\n          ------------\n          -- Ada_83 --\n          ------------\n@@ -31173,10 +30482,6 @@ package body Sem_Prag is\n    Sig_Flags : constant array (Pragma_Id) of Int :=\n      (Pragma_Abort_Defer                    => -1,\n       Pragma_Abstract_State                 => -1,\n-      Pragma_Acc_Data                       =>  0,\n-      Pragma_Acc_Kernels                    =>  0,\n-      Pragma_Acc_Loop                       =>  0,\n-      Pragma_Acc_Parallel                   =>  0,\n       Pragma_Ada_83                         => -1,\n       Pragma_Ada_95                         => -1,\n       Pragma_Ada_05                         => -1,"}, {"sha": "687d2fe5d7b0120dcc9aeeb21d6894ff509c77c1", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -2089,22 +2089,6 @@ package body Sinfo is\n       return Flag16 (N);\n    end Is_Null_Loop;\n \n-   function Is_OpenAcc_Environment\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Loop_Statement);\n-      return Flag13 (N);\n-   end Is_OpenAcc_Environment;\n-\n-   function Is_OpenAcc_Loop\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Loop_Statement);\n-      return Flag14 (N);\n-   end Is_OpenAcc_Loop;\n-\n    function Is_Overloaded\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5581,22 +5565,6 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Is_Null_Loop;\n \n-   procedure Set_Is_OpenAcc_Environment\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Loop_Statement);\n-      Set_Flag13 (N, Val);\n-   end Set_Is_OpenAcc_Environment;\n-\n-   procedure Set_Is_OpenAcc_Loop\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Loop_Statement);\n-      Set_Flag14 (N, Val);\n-   end Set_Is_OpenAcc_Loop;\n-\n    procedure Set_Is_Overloaded\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "203bbd40f9085ca5a529b4e47de373ef37674528", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -1841,14 +1841,6 @@ package Sinfo is\n    --    can be determined to be null at compile time. This is used to remove\n    --    the loop entirely at expansion time.\n \n-   --  Is_OpenAcc_Environment (Flag13-Sem)\n-   --    This flag is set in an N_Loop_Statement node if it contains an\n-   --    Acc_Data, Acc_Parallel or Add_Kernels pragma.\n-\n-   --  Is_OpenAcc_Loop (Flag14-Sem)\n-   --    This flag is set in an N_Loop_Statement node if it contains an\n-   --    OpenAcc_Loop pragma.\n-\n    --  Is_Overloaded (Flag5-Sem)\n    --    A flag present in all expression nodes. Used temporarily during\n    --    overloading determination. The setting of this flag is not relevant\n@@ -5054,8 +5046,6 @@ package Sinfo is\n       --  Iteration_Scheme (Node2) (set to Empty if no iteration scheme)\n       --  Statements (List3)\n       --  End_Label (Node4)\n-      --  Is_OpenAcc_Environment (Flag13-Sem)\n-      --  Is_OpenAcc_Loop (Flag14-Sem)\n       --  Has_Created_Identifier (Flag15)\n       --  Is_Null_Loop (Flag16)\n       --  Suppress_Loop_Warnings (Flag17)\n@@ -9784,12 +9774,6 @@ package Sinfo is\n    function Is_Null_Loop\n      (N : Node_Id) return Boolean;    -- Flag16\n \n-   function Is_OpenAcc_Environment\n-     (N : Node_Id) return Boolean;    -- Flag13\n-\n-   function Is_OpenAcc_Loop\n-     (N : Node_Id) return Boolean;    -- Flag14\n-\n    function Is_Overloaded\n      (N : Node_Id) return Boolean;    -- Flag5\n \n@@ -10896,12 +10880,6 @@ package Sinfo is\n    procedure Set_Is_Null_Loop\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n-   procedure Set_Is_OpenAcc_Environment\n-     (N : Node_Id; Val : Boolean := True);    -- Flag13\n-\n-   procedure Set_Is_OpenAcc_Loop\n-     (N : Node_Id; Val : Boolean := True);    -- Flag14\n-\n    procedure Set_Is_Overloaded\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n@@ -13432,8 +13410,6 @@ package Sinfo is\n    pragma Inline (Is_Known_Guaranteed_ABE);\n    pragma Inline (Is_Machine_Number);\n    pragma Inline (Is_Null_Loop);\n-   pragma Inline (Is_OpenAcc_Environment);\n-   pragma Inline (Is_OpenAcc_Loop);\n    pragma Inline (Is_Overloaded);\n    pragma Inline (Is_Power_Of_2_For_Shift);\n    pragma Inline (Is_Prefixed_Call);\n@@ -13798,8 +13774,6 @@ package Sinfo is\n    pragma Inline (Set_Is_Known_Guaranteed_ABE);\n    pragma Inline (Set_Is_Machine_Number);\n    pragma Inline (Set_Is_Null_Loop);\n-   pragma Inline (Set_Is_OpenAcc_Environment);\n-   pragma Inline (Set_Is_OpenAcc_Loop);\n    pragma Inline (Set_Is_Overloaded);\n    pragma Inline (Set_Is_Power_Of_2_For_Shift);\n    pragma Inline (Set_Is_Prefixed_Call);"}, {"sha": "337ce19086dd8bd45fd123db55c7c6e93a1280f1", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e5e53c73a0cf2e326bbfdacbe94e4a3bb79cd219", "patch": "@@ -486,10 +486,6 @@ package Snames is\n \n    Name_Abort_Defer                    : constant Name_Id := N + $; -- GNAT\n    Name_Abstract_State                 : constant Name_Id := N + $; -- GNAT\n-   Name_Acc_Data                       : constant Name_Id := N + $;\n-   Name_Acc_Kernels                    : constant Name_Id := N + $;\n-   Name_Acc_Loop                       : constant Name_Id := N + $;\n-   Name_Acc_Parallel                   : constant Name_Id := N + $;\n    Name_All_Calls_Remote               : constant Name_Id := N + $;\n    Name_Assert                         : constant Name_Id := N + $; -- Ada 05\n    Name_Assert_And_Cut                 : constant Name_Id := N + $; -- GNAT\n@@ -871,35 +867,9 @@ package Snames is\n    Name_Warn                           : constant Name_Id := N + $;\n    Name_Working_Storage                : constant Name_Id := N + $;\n \n-   --  OpenAcc-specific clause names for Parallel, Kernels, Data\n-\n-   Name_Acc_If                         : constant Name_Id := N + $;\n-   Name_Acc_Private                    : constant Name_Id := N + $;\n-   Name_Attach                         : constant Name_Id := N + $;\n-   Name_Copy_In                        : constant Name_Id := N + $;\n-   Name_Copy_Out                       : constant Name_Id := N + $;\n-   Name_Create                         : constant Name_Id := N + $;\n-   Name_Delete                         : constant Name_Id := N + $;\n-   Name_Detach                         : constant Name_Id := N + $;\n-   Name_Device_Ptr                     : constant Name_Id := N + $;\n-   Name_Device_Type                    : constant Name_Id := N + $;\n-   Name_First_Private                  : constant Name_Id := N + $;\n-   Name_No_Create                      : constant Name_Id := N + $;\n-   Name_Num_Gangs                      : constant Name_Id := N + $;\n-   Name_Num_Workers                    : constant Name_Id := N + $;\n-   Name_Present                        : constant Name_Id := N + $;\n-   Name_Reduction                      : constant Name_Id := N + $;\n-   Name_Vector_Length                  : constant Name_Id := N + $;\n-   Name_Wait                           : constant Name_Id := N + $;\n-\n-   --  Loop\n+   --  used by Repinfo JSON I/O\n \n-   Name_Auto                           : constant Name_Id := N + $;\n-   Name_Collapse                       : constant Name_Id := N + $;\n-   Name_Gang                           : constant Name_Id := N + $;\n-   Name_Seq                            : constant Name_Id := N + $;\n-   Name_Tile                           : constant Name_Id := N + $;\n-   Name_Worker                         : constant Name_Id := N + $;\n+   Name_Present                        : constant Name_Id := N + $;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -1934,10 +1904,6 @@ package Snames is\n \n       Pragma_Abort_Defer,\n       Pragma_Abstract_State,\n-      Pragma_Acc_Data,\n-      Pragma_Acc_Kernels,\n-      Pragma_Acc_Loop,\n-      Pragma_Acc_Parallel,\n       Pragma_All_Calls_Remote,\n       Pragma_Assert,\n       Pragma_Assert_And_Cut,"}, {"sha": "ce27a5f48244dc4665c926bcb70091f34dfb26ac", "filename": "gcc/testsuite/gnat.dg/openacc1.adb", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b37ab0acd34629a41c694c0f3482c450bbd18b/gcc%2Ftestsuite%2Fgnat.dg%2Fopenacc1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b37ab0acd34629a41c694c0f3482c450bbd18b/gcc%2Ftestsuite%2Fgnat.dg%2Fopenacc1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopenacc1.adb?ref=a6b37ab0acd34629a41c694c0f3482c450bbd18b", "patch": "@@ -1,12 +0,0 @@\n---  { dg-do compile }\n-\n-procedure OpenAcc1 is\n-   type Integer_Array is array (1 .. 32) of Integer;\n-   Data : Integer_Array;\n-begin\n-   for i in Data'Range loop\n-      pragma Acc_Parallel;\n-      pragma Acc_Loop(Worker);\n-      Data (i) := i;\n-   end loop;\n-end;"}]}