{"sha": "4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiMDk2OGY0ZTNlYjZhZjlhOWExYmE1NzU4ZWJlYTE2OGE0YjJlMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-06T14:38:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-06T14:38:08Z"}, "message": "cp-tree.h (BASELINK_P): New macro.\n\n\t* cp-tree.h (BASELINK_P): New macro.\n\t(SET_BASELINK_P): Likewise.\n\t* init.c (build_member_call): Remove needless assignment in if\n\tstatement.\n\t* search.c (lookup_field_r): Fix handling when we are looking\n\tspecifically for a type; these are not hidden by functions and\n\tvariables.\n\t(lookup_member): Use SET_BASELINK_P.\n\t* tree.c (is_overloaded_fn): Use BASELINK_P.\n\t(really_overloaed_fn): Likewise.\n\t(get_first_fn): Likewise.\n\nFrom-SVN: r26219", "tree": {"sha": "526f3d6032e3d948ddc953c50478e9af7f1575bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/526f3d6032e3d948ddc953c50478e9af7f1575bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/comments", "author": null, "committer": null, "parents": [{"sha": "ab45646c4ec90373b5db6279ef1869bb00c44dcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab45646c4ec90373b5db6279ef1869bb00c44dcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab45646c4ec90373b5db6279ef1869bb00c44dcd"}], "stats": {"total": 158, "additions": 97, "deletions": 61}, "files": [{"sha": "5dd92144328d17335f375aaa4da90ae20bea2426", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -1,3 +1,17 @@\n+1999-04-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (BASELINK_P): New macro.\n+\t(SET_BASELINK_P): Likewise.\n+\t* init.c (build_member_call): Remove needless assignment in if\n+\tstatement.\n+\t* search.c (lookup_field_r): Fix handling when we are looking\n+\tspecifically for a type; these are not hidden by functions and\n+\tvariables.\n+\t(lookup_member): Use SET_BASELINK_P.\n+\t* tree.c (is_overloaded_fn): Use BASELINK_P.\n+\t(really_overloaed_fn): Likewise.\n+\t(get_first_fn): Likewise.\n+\t\n 1999-04-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (lookup_name_current_level): Tweak, and improve"}, {"sha": "0ed7d750232ecf1aebf99029d0b5f2e82c94e546", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -33,14 +33,15 @@ Boston, MA 02111-1307, USA.  */\n       TREE_INDIRECT_USING (in NAMESPACE_DECL).\n       IDENTIFIER_MARKED (used by search routines).\n       LOCAL_BINDING_P (in CPLUS_BINDING)\n-   1:  IDENTIFIER_VIRTUAL_P.\n+   1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       TYPE_USES_COMPLEX_INHERITANCE (in _TYPE).\n       C_DECLARED_LABEL_FLAG.\n       INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n+      BASELINK_P (in TREE_LIST)\n    2: IDENTIFIER_OPNAME_P.\n       BINFO_VBASE_MARKED.\n       BINFO_FIELDS_MARKED.\n@@ -191,6 +192,14 @@ struct tree_overload\n   tree function;\n };\n \n+/* A `baselink' is a TREE_LIST whose TREE_PURPOSE is a BINFO\n+   indicating a particular base class, and whose TREE_VALUE is a\n+   (possibly overloaded) function from that base class.  */\n+#define BASELINK_P(NODE) \\\n+  (TREE_CODE ((NODE)) == TREE_LIST && TREE_LANG_FLAG_1 ((NODE)))\n+#define SET_BASELINK_P(NODE) \\\n+  (TREE_LANG_FLAG_1 ((NODE)) = 1)\n+\n #define WRAPPER_PTR(NODE) (((struct tree_wrapper*)NODE)->u.ptr)\n #define WRAPPER_INT(NODE) (((struct tree_wrapper*)NODE)->u.i)\n "}, {"sha": "2769765ef635e324f558e55a248c53a9d6c3815e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -1443,7 +1443,7 @@ build_member_call (type, name, parmlist)\n   if (method_name == constructor_name (type)\n       || method_name == constructor_name_full (type))\n     return build_functional_cast (type, parmlist);\n-  if ((t = lookup_fnfields (basetype_path, method_name, 0)))\n+  if (lookup_fnfields (basetype_path, method_name, 0))\n     return build_method_call (decl, \n \t\t\t      TREE_CODE (name) == TEMPLATE_ID_EXPR\n \t\t\t      ? name : method_name,"}, {"sha": "7a13a9f1e0d4e865232f73735c3576fb10554339", "filename": "gcc/cp/search.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -1207,17 +1207,20 @@ lookup_field_r (binfo, data)\n {\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n   tree type = BINFO_TYPE (binfo);\n-  tree nval;\n-  int idx;\n+  tree nval = NULL_TREE;\n   int from_dep_base_p;\n \n   /* First, look for a function.  There can't be a function and a data\n      member with the same name, and if there's a function and a type\n      with the same name, the type is hidden by the function.  */\n-  idx = lookup_fnfields_here (type, lfi->name);\n-  if (idx >= 0)\n-    nval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n-  else\n+  if (!lfi->want_type)\n+    {\n+      int idx = lookup_fnfields_here (type, lfi->name);\n+      if (idx >= 0)\n+\tnval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n+    }\n+\n+  if (!nval)\n     /* Look for a data member or type.  */\n     nval = lookup_field_1 (type, lfi->name);\n \n@@ -1226,6 +1229,17 @@ lookup_field_r (binfo, data)\n   if (!nval)\n     return NULL_TREE;\n \n+  /* If we're looking up a type (as with an elaborated type specifier)\n+     we ignore all non-types we find.  */\n+  if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL)\n+    {\n+      nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n+      if (nval)\n+\tnval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n+      else \n+\treturn NULL_TREE;\n+    }\n+\n   /* You must name a template base class with a template-id.  */\n   if (!same_type_p (type, lfi->type) \n       && template_self_reference_p (type, nval))\n@@ -1285,41 +1299,24 @@ lookup_field_r (binfo, data)\n     }\n   else\n     {\n-      /* The new lookup is the best we've got so far.  Verify that\n-\t it's the kind of thing we're looking for.  */\n-      if (lfi->want_type && TREE_CODE (nval) != TYPE_DECL)\n+      /* If the thing we're looking for is a virtual base class, then\n+\t we know we've got what we want at this point; there's no way\n+\t to get an ambiguity.  */\n+      if (VBASE_NAME_P (lfi->name))\n \t{\n-\t  nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n-\t  if (nval)\n-\t    {\n-\t      nval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n-\t      if (!same_type_p (type, lfi->type)\n-\t\t  && template_self_reference_p (type, nval))\n-\t\tnval = NULL_TREE;\n-\t    }\n+\t  lfi->rval = nval;\n+\t  return nval;\n \t}\n \n-      if (nval)\n-\t{\n-\t  /* If the thing we're looking for is a virtual base class,\n-\t     then we know we've got what we want at this point;\n-\t     there's no way to get an ambiguity.  */\n-\t  if (VBASE_NAME_P (lfi->name))\n-\t    {\n-\t      lfi->rval = nval;\n-\t      return nval;\n-\t    }\n-\n-\t  if (from_dep_base_p && TREE_CODE (nval) != TYPE_DECL\n-\t      /* We need to return a member template class so we can\n-\t\t define partial specializations.  Is there a better\n-\t\t way?  */\n-\t      && !DECL_CLASS_TEMPLATE_P (nval))\n-\t    /* The thing we're looking for isn't a type, so the implicit\n-\t       typename extension doesn't apply, so we just pretend we\n-\t       didn't find anything.  */\n-\t    return NULL_TREE;\n-\t}\n+      if (from_dep_base_p && TREE_CODE (nval) != TYPE_DECL\n+\t  /* We need to return a member template class so we can\n+\t     define partial specializations.  Is there a better\n+\t     way?  */\n+\t  && !DECL_CLASS_TEMPLATE_P (nval))\n+\t/* The thing we're looking for isn't a type, so the implicit\n+\t   typename extension doesn't apply, so we just pretend we\n+\t   didn't find anything.  */\n+\treturn NULL_TREE;\n \n       lfi->rval = nval;\n       lfi->from_dep_base_p = from_dep_base_p;\n@@ -1444,8 +1441,11 @@ lookup_member (xbasetype, name, protect, want_type)\n \t\t\t\t\t\tname, name,\n \t\t\t\t\t\tTREE_TYPE (rval)));\n \n-  if (rval && is_overloaded_fn (rval))\n-    rval = scratch_tree_cons (basetype_path, rval, NULL_TREE);\n+  if (rval && is_overloaded_fn (rval)) \n+    {\n+      rval = scratch_tree_cons (basetype_path, rval, NULL_TREE);\n+      SET_BASELINK_P (rval);\n+    }\n \n   return rval;\n }"}, {"sha": "44e958f064d433de57c9f75157794091023d9806", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -1223,21 +1223,9 @@ int\n is_overloaded_fn (x)\n      tree x;\n {\n-  /* XXX A baselink is also considered an overloaded function.\n-     As is a placeholder from push_class_decls.\n-     As is an expression like X::f.  */\n-  if (TREE_CODE (x) == TREE_LIST)\n-    {\n-      if (TREE_PURPOSE (x) == error_mark_node)\n-\t{\n-\t  x = TREE_VALUE (x);\n-\t  my_friendly_assert (TREE_CODE (x) == TREE_LIST, 981121);\n-\t}\n-      my_friendly_assert (TREE_CODE (TREE_PURPOSE (x)) == TREE_VEC\n-\t\t\t  || TREE_CODE (TREE_PURPOSE (x)) == IDENTIFIER_NODE,\n-\t\t\t  388);\n-      x = TREE_VALUE (x);\n-    }\n+  /* A baselink is also considered an overloaded function.  */\n+  if (BASELINK_P (x))\n+    x = TREE_VALUE (x);\n   return (TREE_CODE (x) == FUNCTION_DECL\n \t  || TREE_CODE (x) == TEMPLATE_ID_EXPR\n \t  || DECL_FUNCTION_TEMPLATE_P (x)\n@@ -1248,9 +1236,8 @@ int\n really_overloaded_fn (x)\n      tree x;\n {     \n-  /* A baselink is also considered an overloaded function.\n-     This might also be an ambiguous class member. */\n-  if (TREE_CODE (x) == TREE_LIST)\n+  /* A baselink is also considered an overloaded function.  */\n+  if (BASELINK_P (x))\n     x = TREE_VALUE (x);\n   return (TREE_CODE (x) == OVERLOAD \n \t  && (TREE_CHAIN (x) != NULL_TREE\n@@ -1263,7 +1250,7 @@ get_first_fn (from)\n {\n   my_friendly_assert (is_overloaded_fn (from), 9);\n   /* A baselink is also considered an overloaded function. */\n-  if (TREE_CODE (from) == TREE_LIST)\n+  if (BASELINK_P (from))\n     from = TREE_VALUE (from);\n   return OVL_CURRENT (from);\n }"}, {"sha": "d3c23977abf8a5c92589a80c6fb65d2ebe84622f", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash9.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash9.C?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -0,0 +1,9 @@\n+// Build don't link:\n+// Origin: Jason Merrill <jason@cygnus.com>\n+\n+struct A { };\n+struct B : public A\n+{\n+  int A;\n+};\n+struct C : public B { };"}, {"sha": "bc7dcf5c4c7cf3931e43c398c94fe3212fdbb1cd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash33.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash33.C?ref=4bb0968f4e3eb6af9a9a1ba5758ebea168a4b2e2", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+// Origin: Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>\n+\n+class A {\n+public:\n+        template <class T> T& f(T& t) const;\n+};\n+\n+class B {\n+public:\n+        template <class T> T& f(T& t) const;\n+};\n+\n+class C: public A,B {\n+public:\n+        template <class T> T& f(T& t) const;\n+};"}]}