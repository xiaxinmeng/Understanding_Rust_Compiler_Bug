{"sha": "0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5MDBkZmFmYTkwYTExMTRkMzc2OGYzZmU1ZmU0ZDA3ZjI1MGE5YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-11-28T16:21:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-11-28T16:21:00Z"}, "message": "matrix-reorg.c (analyze_matrix_allocation_site): Remove unused malloc_fname variable.\n\n\t* matrix-reorg.c (analyze_matrix_allocation_site): Remove unused\n\tmalloc_fname variable.\n\t(check_allocation_function): Remove unused gsi and bb_level_0\n\tvariables.\n\t(transform_access_sites): Remove unused d_type_size and d_type_size_k\n\tvariables.\n\t* omega.c (resurrect_subs): Remove unused n variable.\n\t(omega_solve_geq): Remove unused neweqns variable.\n\t* lto-streamer-in.c (lto_read_tree): Remove unused end_marker variable.\n\t* tree-inline.c (declare_return_variable): Remove USE_P argument,\n\treturn use instead of var.\n\t(remap_decl, remap_block): Remove unused fn variable.\n\t(expand_call_inline): Remove unused retvar variable, adjust\n\tdeclare_return_variable caller.\n\t(optimize_inline_calls): Remove unused prev_fn variable.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Remove unused ncopies\n\tvariable.\n\t(vect_create_mask_and_perm): Remove unused group_size and dr_chain_size\n\tvariables.\n\t* tree-ssa-loop-niter.c (split_to_var_and_offset): Handle MINUS_EXPR\n\tproperly.\n\t* tree-vect-loop.c (vect_analyze_loop_form): Remove unused backedge\n\tvariable.\n\t(vect_create_epilog_for_reduction): Remove unused bytesize variable.\n\t* omp-low.c (workshare_safe_to_combine_p): Remove par_entry_bb\n\tparameter.  Remove unused par_stmt variable.\n\t(determine_parallel_type): Adjust workshare_safe_to_combine_p caller.\n\t(expand_omp_sections): Remove unused l1 variable.\n\t(lower_omp_for): Remove unused ilist variable.\n\t* tree-loop-distribution.c (mark_nodes_having_upstream_mem_writes):\n\tRemove unused has_upstream_mem_write_p variable.\n\t* recog.c (decode_asm_operands): Remove unused noperands variable.\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Remove unused size1 and\n\tsize2 variable.\n\t* libgcov.c (__gcov_merge_delta): Remove unused last variable.\n\t* tree-call-cdce.c (gen_conditions_for_pow_int_base): Remove unused\n\tbase_nm variable.\n\t(gen_conditions_for_pow): Remove unused ec variable.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Remove unused size\n\tvariable.\n\t* ipa-struct-reorg.c (program_redefines_malloc_p): Remove unused\n\tfndecl variable.\n\t* tree-ssa-sink.c (statement_sink_location): Remove unused code\n\tvariable.\n\t* regmove.c (copy_src_to_dest): Remove unused insn_uid and move_uid\n\tvariables.\n\t* tree-complex.c (create_one_component_var): Remove unused inner_type\n\tvariable.\n\t* calls.c (emit_call_1): Don't GEN_INT (struct_value_size)\n\tunnecessarily when GEN_*CALL omits that argument.\n\t* regrename.c (regrename_optimize): Remove unused regs_seen variable.\n\t(build_def_use): Remove unused icode variable.\n\t* ipa-pure-const.c (check_call): Remove unused callee and avail\n\tvariables.\n\t* tree-dfa.c (add_referenced_var): Remove unused v_ann variable.\n\t* tree-vect-patterns.c (vect_recog_pow_pattern): Remove unused type\n\tvariable.\n\t(vect_pattern_recog): Remove unused stmt variable.\n\t* sel-sched-ir.c (make_regions_from_the_rest): Remove unused\n\tnew_regions variable.\n\t* postreload.c (reload_cse_simplify_operands): Remove unused mode\n\tvariable.\n\t* tree-parloops.c (create_call_for_reduction_1): Remove unused\n\taddr_type variable.\n\t(create_parallel_loop): Remove unused res variable.\n\t(gen_parallel_loop): Remove unused nloop variable.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Likewise.\n\t* value-prof.c (gimple_mod_subtract_transform,\n\tgimple_stringops_transform): Remove unused value variable.\n\t(gimple_stringops_values_to_profile): Remove unused fcode variable.\n\t* tree-vrp.c (register_new_assert_for): Remove unused found variable.\n\t(vrp_visit_switch_stmt): Remove unused n variable.\n\t* tree-vect-stmts.c (vectorizable_conversion): Remove unused expr\n\tvariable.\n\t(vectorizable_operation): Remove unused shift_p variable.\n\t(vectorizable_store): Remove unused first_stmt_vinfo variable.\n\t* tree-ssa-operands.c (add_stmt_operand): Remove unused v_ann variable.\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Remove unused bb\n\tvariable.\n\t(vect_permute_store_chain): Remove unused scalar_dest variable.\n\t(vect_supportable_dr_alignment): Remove unused invariant_in_outerloop\n\tvariable.\n\t* tree-ssa-threadupdate.c (thread_single_edge): Remove unused\n\tlocal_info variable.\n\t* tree-optimize.c (tree_rest_of_compilation): Remove unused node\n\tvariable.\n\t* optabs.c (expand_binop): Remove unused equiv_value variable.\n\t(emit_libcall_block): Remove unused prev variable.\n\t(init_optabs): Remove unused int_mode variable.\n\t* tree-ssa-structalias.c (scc_visit): Remove unused have_ref_node\n\tvariable.\n\t(do_structure_copy): Remove unused lhsbase and rhsbase variables.\n\t(find_func_aliases): Remove unused rhstype variable.\n\t(ipa_pta_execute): Remove unused varid variable.\ngcc/objc/\n\t* objc-act.c (generate_shared_structures): Remove unused sc_spec and\n\tdecl_specs variables.\n\t(objc_build_message_expr): Remove unused loc variable.\n\t(objc_finish_message_expr): Remove unused saved_rtype variable.\n\t(encode_field_decl): Remove unused type variable.\ngcc/lto/\n\t* lto-lang.c (handle_nonnull_attribute): Remove unused attr_arg_num\n\tvariable.\n\nFrom-SVN: r154726", "tree": {"sha": "2f0efb6b6c95d9e1139b0c9ba7b9f6b91d064161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f0efb6b6c95d9e1139b0c9ba7b9f6b91d064161"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e86b4c032aa6f785d8224d17a121591a19fec986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86b4c032aa6f785d8224d17a121591a19fec986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86b4c032aa6f785d8224d17a121591a19fec986"}], "stats": {"total": 407, "additions": 174, "deletions": 233}, "files": [{"sha": "14101e61c9f54a905f2edad24570e5ea64c45194", "filename": "gcc/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1,3 +1,100 @@\n+2009-11-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* matrix-reorg.c (analyze_matrix_allocation_site): Remove unused\n+\tmalloc_fname variable.\n+\t(check_allocation_function): Remove unused gsi and bb_level_0\n+\tvariables.\n+\t(transform_access_sites): Remove unused d_type_size and d_type_size_k\n+\tvariables.\n+\t* omega.c (resurrect_subs): Remove unused n variable.\n+\t(omega_solve_geq): Remove unused neweqns variable.\n+\t* lto-streamer-in.c (lto_read_tree): Remove unused end_marker variable.\n+\t* tree-inline.c (declare_return_variable): Remove USE_P argument,\n+\treturn use instead of var.\n+\t(remap_decl, remap_block): Remove unused fn variable.\n+\t(expand_call_inline): Remove unused retvar variable, adjust\n+\tdeclare_return_variable caller.\n+\t(optimize_inline_calls): Remove unused prev_fn variable.\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Remove unused ncopies\n+\tvariable.\n+\t(vect_create_mask_and_perm): Remove unused group_size and dr_chain_size\n+\tvariables.\n+\t* tree-ssa-loop-niter.c (split_to_var_and_offset): Handle MINUS_EXPR\n+\tproperly.\n+\t* tree-vect-loop.c (vect_analyze_loop_form): Remove unused backedge\n+\tvariable.\n+\t(vect_create_epilog_for_reduction): Remove unused bytesize variable.\n+\t* omp-low.c (workshare_safe_to_combine_p): Remove par_entry_bb\n+\tparameter.  Remove unused par_stmt variable.\n+\t(determine_parallel_type): Adjust workshare_safe_to_combine_p caller.\n+\t(expand_omp_sections): Remove unused l1 variable.\n+\t(lower_omp_for): Remove unused ilist variable.\n+\t* tree-loop-distribution.c (mark_nodes_having_upstream_mem_writes):\n+\tRemove unused has_upstream_mem_write_p variable.\n+\t* recog.c (decode_asm_operands): Remove unused noperands variable.\n+\t* tree-ssa-alias.c (refs_may_alias_p_1): Remove unused size1 and\n+\tsize2 variable.\n+\t* libgcov.c (__gcov_merge_delta): Remove unused last variable.\n+\t* tree-call-cdce.c (gen_conditions_for_pow_int_base): Remove unused\n+\tbase_nm variable.\n+\t(gen_conditions_for_pow): Remove unused ec variable.\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Remove unused size\n+\tvariable.\n+\t* ipa-struct-reorg.c (program_redefines_malloc_p): Remove unused\n+\tfndecl variable.\n+\t* tree-ssa-sink.c (statement_sink_location): Remove unused code\n+\tvariable.\n+\t* regmove.c (copy_src_to_dest): Remove unused insn_uid and move_uid\n+\tvariables.\n+\t* tree-complex.c (create_one_component_var): Remove unused inner_type\n+\tvariable.\n+\t* calls.c (emit_call_1): Don't GEN_INT (struct_value_size)\n+\tunnecessarily when GEN_*CALL omits that argument.\n+\t* regrename.c (regrename_optimize): Remove unused regs_seen variable.\n+\t(build_def_use): Remove unused icode variable.\n+\t* ipa-pure-const.c (check_call): Remove unused callee and avail\n+\tvariables.\n+\t* tree-dfa.c (add_referenced_var): Remove unused v_ann variable.\n+\t* tree-vect-patterns.c (vect_recog_pow_pattern): Remove unused type\n+\tvariable.\n+\t(vect_pattern_recog): Remove unused stmt variable.\n+\t* sel-sched-ir.c (make_regions_from_the_rest): Remove unused\n+\tnew_regions variable.\n+\t* postreload.c (reload_cse_simplify_operands): Remove unused mode\n+\tvariable.\n+\t* tree-parloops.c (create_call_for_reduction_1): Remove unused\n+\taddr_type variable.\n+\t(create_parallel_loop): Remove unused res variable.\n+\t(gen_parallel_loop): Remove unused nloop variable.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Likewise.\n+\t* value-prof.c (gimple_mod_subtract_transform,\n+\tgimple_stringops_transform): Remove unused value variable.\n+\t(gimple_stringops_values_to_profile): Remove unused fcode variable.\n+\t* tree-vrp.c (register_new_assert_for): Remove unused found variable.\n+\t(vrp_visit_switch_stmt): Remove unused n variable.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Remove unused expr\n+\tvariable.\n+\t(vectorizable_operation): Remove unused shift_p variable.\n+\t(vectorizable_store): Remove unused first_stmt_vinfo variable.\n+\t* tree-ssa-operands.c (add_stmt_operand): Remove unused v_ann variable.\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Remove unused bb\n+\tvariable.\n+\t(vect_permute_store_chain): Remove unused scalar_dest variable.\n+\t(vect_supportable_dr_alignment): Remove unused invariant_in_outerloop\n+\tvariable.\n+\t* tree-ssa-threadupdate.c (thread_single_edge): Remove unused\n+\tlocal_info variable.\n+\t* tree-optimize.c (tree_rest_of_compilation): Remove unused node\n+\tvariable.\n+\t* optabs.c (expand_binop): Remove unused equiv_value variable.\n+\t(emit_libcall_block): Remove unused prev variable.\n+\t(init_optabs): Remove unused int_mode variable.\n+\t* tree-ssa-structalias.c (scc_visit): Remove unused have_ref_node\n+\tvariable.\n+\t(do_structure_copy): Remove unused lhsbase and rhsbase variables.\n+\t(find_func_aliases): Remove unused rhstype variable.\n+\t(ipa_pta_execute): Remove unused varid variable.\n+\n 2009-11-28  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n \n \t* config/avr/avr.h (ASM_OUTPUT_EXTERNAL): Add. "}, {"sha": "fe4bf0dbce55d05b60d31ba7bd62c378e4573705", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -256,10 +256,6 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   rtx call_insn;\n   int already_popped = 0;\n   HOST_WIDE_INT n_popped = RETURN_POPS_ARGS (fndecl, funtype, stack_size);\n-#if defined (HAVE_call) && defined (HAVE_call_value)\n-  rtx struct_value_size_rtx;\n-  struct_value_size_rtx = GEN_INT (struct_value_size);\n-#endif\n \n #ifdef CALL_POPS_ARGS\n   n_popped += CALL_POPS_ARGS (* args_so_far);\n@@ -341,7 +337,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n       else\n \temit_call_insn (GEN_SIBCALL (gen_rtx_MEM (FUNCTION_MODE, funexp),\n \t\t\t\t     rounded_stack_size_rtx, next_arg_reg,\n-\t\t\t\t     struct_value_size_rtx));\n+\t\t\t\t     GEN_INT (struct_value_size)));\n     }\n   else\n #endif\n@@ -357,7 +353,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n       else\n \temit_call_insn (GEN_CALL (gen_rtx_MEM (FUNCTION_MODE, funexp),\n \t\t\t\t  rounded_stack_size_rtx, next_arg_reg,\n-\t\t\t\t  struct_value_size_rtx));\n+\t\t\t\t  GEN_INT (struct_value_size)));\n     }\n   else\n #endif"}, {"sha": "7ee9f5dcf3713a3d7504f419e0c9724c955e76ae", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -259,8 +259,6 @@ check_call (funct_state local, gimple call, bool ipa)\n {\n   int flags = gimple_call_flags (call);\n   tree callee_t = gimple_call_fndecl (call);\n-  struct cgraph_node* callee;\n-  enum availability avail = AVAIL_NOT_AVAILABLE;\n   bool possibly_throws = stmt_could_throw_p (call);\n   bool possibly_throws_externally = (possibly_throws\n   \t\t\t\t     && stmt_can_throw_external (call));\n@@ -299,9 +297,6 @@ check_call (funct_state local, gimple call, bool ipa)\n      graph.  */\n   if (callee_t)\n     {\n-      callee = cgraph_node(callee_t);\n-      avail = cgraph_function_body_availability (callee);\n-\n       /* When bad things happen to bad functions, they cannot be const\n \t or pure.  */\n       if (setjmp_call_p (callee_t))"}, {"sha": "0cb7ccca31b26ed08d70a4b6f6cf323a84433b95", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -3435,13 +3435,10 @@ program_redefines_malloc_p (void)\n   struct cgraph_node *c_node;\n   struct cgraph_node *c_node2;\n   struct cgraph_edge *c_edge;\n-  tree fndecl;\n   tree fndecl2;\n \n   for (c_node = cgraph_nodes; c_node; c_node = c_node->next)\n     {\n-      fndecl = c_node->decl;\n-\n       for (c_edge = c_node->callees; c_edge; c_edge = c_edge->next_callee)\n \t{\n \t  c_node2 = c_edge->callee;"}, {"sha": "af3d9cfba63d6e9106de37f6282c85d15a16d3e8", "filename": "gcc/libgcov.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -675,13 +675,13 @@ void\n __gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n {\n   unsigned i, n_measures;\n-  gcov_type last, value, counter, all;\n+  gcov_type value, counter, all;\n \n   gcc_assert (!(n_counters % 4));\n   n_measures = n_counters / 4;\n   for (i = 0; i < n_measures; i++, counters += 4)\n     {\n-      last = gcov_read_counter ();\n+      /* last = */ gcov_read_counter ();\n       value = gcov_read_counter ();\n       counter = gcov_read_counter ();\n       all = gcov_read_counter ();"}, {"sha": "16ae9b83ee004d055eea1f52620e2f6f6ccb1dcd", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -2597,7 +2597,6 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n \t       enum LTO_tags tag)\n {\n   tree result;\n-  char end_marker;\n   int ix;\n \n   result = lto_materialize_tree (ib, data_in, tag, &ix);\n@@ -2614,7 +2613,7 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n   else if (TREE_CODE (result) == FUNCTION_DECL && !DECL_BUILT_IN (result))\n     lto_register_function_decl_in_symtab (data_in, result);\n \n-  end_marker = lto_input_1_unsigned (ib);\n+  /* end_marker = */ lto_input_1_unsigned (ib);\n \n #ifdef LTO_STREAMER_DEBUG\n   /* Remove the mapping to RESULT's original address set by"}, {"sha": "7e0a0d463530068ad66cbab3fae7c25e52549fde", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1,3 +1,8 @@\n+2009-11-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lto-lang.c (handle_nonnull_attribute): Remove unused attr_arg_num\n+\tvariable.\n+\n 2009-11-19  Rafael Avila de Espindola  <espindola@google.com>\n \n \tPR bootstrap/42096"}, {"sha": "0caa3182dda3643236f4375bbb49c3d0b93404b8", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -285,7 +285,6 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n \t\t\t  bool * ARG_UNUSED (no_add_attrs))\n {\n   tree type = *node;\n-  unsigned HOST_WIDE_INT attr_arg_num;\n \n   /* If no arguments are specified, all pointer arguments should be\n      non-null.  Verify a full prototype is given so that the arguments\n@@ -298,7 +297,7 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n \n   /* Argument list specified.  Verify that each argument number references\n      a pointer argument.  */\n-  for (attr_arg_num = 1; args; args = TREE_CHAIN (args))\n+  for (; args; args = TREE_CHAIN (args))\n     {\n       tree argument;\n       unsigned HOST_WIDE_INT arg_num = 0, ck_num;"}, {"sha": "90e21e57e72070c2039e5c94e81931fcb30820bc", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -821,15 +821,13 @@ analyze_matrix_allocation_site (struct matrix_info *mi, gimple stmt,\n       else\n \t{\n \t  tree malloc_fn_decl;\n-\t  const char *malloc_fname;\n \n \t  malloc_fn_decl = gimple_call_fndecl (stmt);\n \t  if (malloc_fn_decl == NULL_TREE)\n \t    {\n \t      mark_min_matrix_escape_level (mi, level, stmt);\n \t      return;\n \t    }\n-\t  malloc_fname = IDENTIFIER_POINTER (DECL_NAME (malloc_fn_decl));\n \t  if (DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n \t    {\n \t      if (dump_file)\n@@ -1572,8 +1570,6 @@ static int\n check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   int level;\n-  gimple_stmt_iterator gsi;\n-  basic_block bb_level_0;\n   struct matrix_info *mi = (struct matrix_info *) *slot;\n   sbitmap visited;\n \n@@ -1595,9 +1591,6 @@ check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n \n   mark_min_matrix_escape_level (mi, level, NULL);\n \n-  gsi = gsi_for_stmt (mi->malloc_for_level[0]);\n-  bb_level_0 = gsi.bb;\n-\n   /* Check if the expression of the size passed to malloc could be\n      pre-calculated before the malloc of level 0.  */\n   for (level = 1; level < mi->min_indirect_level_escape; level++)\n@@ -1918,10 +1911,6 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t      else\n \t\t{\n \t\t  tree new_offset;\n-\t\t  tree d_type_size, d_type_size_k;\n-\n-\t\t  d_type_size = size_int (mi->dimension_type_size[min_escape_l]);\n-\t\t  d_type_size_k = size_int (mi->dimension_type_size[k + 1]);\n \n \t\t  new_offset =\n \t\t    compute_offset (mi->dimension_type_size[min_escape_l],"}, {"sha": "d6e2b1f54329daff60d527dbfa0998c48098064e", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1,5 +1,11 @@\n 2009-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* objc-act.c (generate_shared_structures): Remove unused sc_spec and\n+\tdecl_specs variables.\n+\t(objc_build_message_expr): Remove unused loc variable.\n+\t(objc_finish_message_expr): Remove unused saved_rtype variable.\n+\t(encode_field_decl): Remove unused type variable.\n+\n \tPR obj-c++/42156\n \t* objc-act.c (objc_build_struct): INIT_TYPE_OBJC_INFO for\n \ttype variants that don't have it initialized yet."}, {"sha": "e39462dcc233caa25884010a716a81c9564e8bda", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -5787,7 +5787,7 @@ generate_category (tree cat)\n static void\n generate_shared_structures (int cls_flags)\n {\n-  tree sc_spec, decl_specs, decl;\n+  tree decl;\n   tree name_expr, super_expr, root_expr;\n   tree my_root_id = NULL_TREE, my_super_id = NULL_TREE;\n   tree cast_type, initlist, protocol_decl;\n@@ -5844,9 +5844,6 @@ generate_shared_structures (int cls_flags)\n \n   /* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */\n \n-  sc_spec = build_tree_list (NULL_TREE, ridpointers[(int) RID_STATIC]);\n-  decl_specs = tree_cons (NULL_TREE, objc_class_template, sc_spec);\n-\n   decl = start_var_decl (objc_class_template,\n \t\t\t IDENTIFIER_POINTER\n \t\t\t (DECL_NAME (UOBJC_METACLASS_decl)));\n@@ -6269,7 +6266,6 @@ tree\n objc_build_message_expr (tree mess)\n {\n   tree receiver = TREE_PURPOSE (mess);\n-  location_t loc;\n   tree sel_name;\n #ifdef OBJCPLUS\n   tree args = TREE_PURPOSE (TREE_VALUE (mess));\n@@ -6281,11 +6277,6 @@ objc_build_message_expr (tree mess)\n   if (TREE_CODE (receiver) == ERROR_MARK || TREE_CODE (args) == ERROR_MARK)\n     return error_mark_node;\n \n-  if (CAN_HAVE_LOCATION_P (receiver))\n-    loc = EXPR_LOCATION (receiver);\n-  else\n-    loc = input_location;\n-\n   /* Obtain the full selector name.  */\n   if (TREE_CODE (args) == IDENTIFIER_NODE)\n     /* A unary selector.  */\n@@ -6448,7 +6439,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n     }\n   else if (rtype)\n     {\n-      tree orig_rtype = rtype, saved_rtype;\n+      tree orig_rtype = rtype;\n \n       if (TREE_CODE (rtype) == POINTER_TYPE)\n \trtype = TREE_TYPE (rtype);\n@@ -6457,7 +6448,6 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t     && TREE_CODE (OBJC_TYPE_NAME (rtype)) == TYPE_DECL\n \t     && DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (rtype)))\n \trtype = DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (rtype));\n-      saved_rtype = rtype;\n       if (TYPED_OBJECT (rtype))\n \t{\n \t  rprotos = TYPE_OBJC_PROTOCOL_LIST (rtype);\n@@ -8311,17 +8301,13 @@ encode_gnu_bitfield (int position, tree type, int size)\n static void\n encode_field_decl (tree field_decl, int curtype, int format)\n {\n-  tree type;\n-\n #ifdef OBJCPLUS\n   /* C++ static members, and things that are not fields at all,\n      should not appear in the encoding.  */\n   if (TREE_CODE (field_decl) != FIELD_DECL || TREE_STATIC (field_decl))\n     return;\n #endif\n \n-  type = TREE_TYPE (field_decl);\n-\n   /* Generate the bitfield typing information, if needed.  Note the difference\n      between GNU and NeXT runtimes.  */\n   if (DECL_BIT_FIELD_TYPE (field_decl))"}, {"sha": "666d4bd616d70752f084d0d2d15de7a050b56ec5", "filename": "gcc/omega.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1978,7 +1978,7 @@ resurrect_subs (omega_pb pb)\n   if (pb->num_subs > 0\n       && please_no_equalities_in_simplified_problems == 0)\n     {\n-      int i, e, n, m;\n+      int i, e, m;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1992,7 +1992,6 @@ resurrect_subs (omega_pb pb)\n \t  omega_unprotect_1 (pb, &i, NULL);\n \n       m = pb->num_subs;\n-      n = MAX (pb->num_vars, pb->safe_vars + m);\n \n       for (e = pb->num_geqs - 1; e >= 0; e--)\n \tif (single_var_geq (&pb->geqs[e], pb->num_vars))\n@@ -3723,7 +3722,6 @@ omega_solve_geq (omega_pb pb, enum omega_result desired_res)\n       int max_splinters = 1;\n       bool exact = false;\n       bool lucky_exact = false;\n-      int neweqns = 0;\n       int best = (INT_MAX);\n       int j = 0, jLe = 0, jLowerBoundCount = 0;\n \n@@ -3862,7 +3860,7 @@ omega_solve_geq (omega_pb pb, enum omega_result desired_res)\n \t      || lucky\n \t      || in_approximate_mode)\n \t    {\n-\t      neweqns = score = upper_bound_count * lower_bound_count;\n+\t      score = upper_bound_count * lower_bound_count;\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file,\n@@ -3898,7 +3896,6 @@ omega_solve_geq (omega_pb pb, enum omega_result desired_res)\n \t\t\t upper_bound_count,\n \t\t\t lower_bound_count, minC, maxC);\n \n-\t      neweqns = upper_bound_count * lower_bound_count;\n \t      score = maxC - minC;\n \n \t      if (best > score)"}, {"sha": "02fea106b07fbf3160ea58a224f793d61d69d6bc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -518,13 +518,10 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n    hack something up here, it is really not worth the aggravation.  */\n \n static bool\n-workshare_safe_to_combine_p (basic_block par_entry_bb, basic_block ws_entry_bb)\n+workshare_safe_to_combine_p (basic_block ws_entry_bb)\n {\n   struct omp_for_data fd;\n-  gimple par_stmt, ws_stmt;\n-\n-  par_stmt = last_stmt (par_entry_bb);\n-  ws_stmt = last_stmt (ws_entry_bb);\n+  gimple ws_stmt = last_stmt (ws_entry_bb);\n \n   if (gimple_code (ws_stmt) == GIMPLE_OMP_SECTIONS)\n     return true;\n@@ -631,7 +628,7 @@ determine_parallel_type (struct omp_region *region)\n \n   if (single_succ (par_entry_bb) == ws_entry_bb\n       && single_succ (ws_exit_bb) == par_exit_bb\n-      && workshare_safe_to_combine_p (par_entry_bb, ws_entry_bb)\n+      && workshare_safe_to_combine_p (ws_entry_bb)\n       && (gimple_omp_parallel_combined_p (last_stmt (par_entry_bb))\n \t  || (last_and_only_stmt (ws_entry_bb)\n \t      && last_and_only_stmt (par_exit_bb))))\n@@ -4647,7 +4644,7 @@ expand_omp_for (struct omp_region *region)\n static void\n expand_omp_sections (struct omp_region *region)\n {\n-  tree t, u, vin = NULL, vmain, vnext, l1, l2;\n+  tree t, u, vin = NULL, vmain, vnext, l2;\n   VEC (tree,heap) *label_vec;\n   unsigned len;\n   basic_block entry_bb, l0_bb, l1_bb, l2_bb, default_bb;\n@@ -4692,12 +4689,10 @@ expand_omp_sections (struct omp_region *region)\n \t      }\n \t}\n       default_bb = create_empty_bb (l1_bb->prev_bb);\n-      l1 = gimple_block_label (l1_bb);\n     }\n   else\n     {\n       default_bb = create_empty_bb (l0_bb);\n-      l1 = NULL_TREE;\n       l2 = gimple_block_label (default_bb);\n     }\n \n@@ -6023,7 +6018,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   tree *rhs_p, block;\n   struct omp_for_data fd;\n   gimple stmt = gsi_stmt (*gsi_p), new_stmt;\n-  gimple_seq omp_for_body, body, dlist, ilist;\n+  gimple_seq omp_for_body, body, dlist;\n   size_t i;\n   struct gimplify_ctx gctx;\n \n@@ -6046,7 +6041,6 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     }\n \n   /* The pre-body and input clauses go before the lowered GIMPLE_OMP_FOR.  */\n-  ilist = NULL;\n   dlist = NULL;\n   body = NULL;\n   lower_rec_input_clauses (gimple_omp_for_clauses (stmt), &body, &dlist, ctx);"}, {"sha": "87067d82e73c2fa822f09eb839959a5e512062aa", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1719,7 +1719,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n     {\n       int i;\n       rtx insns;\n-      rtx equiv_value;\n \n       /* If TARGET is the same as one of the operands, the REG_EQUAL note\n \t won't be accurate, so use a new target.  */\n@@ -1749,13 +1748,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (i == GET_MODE_BITSIZE (mode) / BITS_PER_WORD)\n \t{\n-\t  if (binoptab->code != UNKNOWN)\n-\t    equiv_value\n-\t      = gen_rtx_fmt_ee (binoptab->code, mode,\n-\t\t\t\tcopy_rtx (op0), copy_rtx (op1));\n-\t  else\n-\t    equiv_value = 0;\n-\n \t  emit_insn (insns);\n \t  return target;\n \t}\n@@ -3903,7 +3895,7 @@ void\n emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n {\n   rtx final_dest = target;\n-  rtx prev, next, last, insn;\n+  rtx next, last, insn;\n \n   /* If this is a reg with REG_USERVAR_P set, then it could possibly turn\n      into a MEM later.  Protect the libcall block from this change.  */\n@@ -3980,10 +3972,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n \tbreak;\n     }\n \n-  prev = get_last_insn ();\n-\n   /* Write the remaining insns followed by the final copy.  */\n-\n   for (insn = insns; insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n@@ -6201,7 +6190,6 @@ void\n init_optabs (void)\n {\n   unsigned int i;\n-  enum machine_mode int_mode;\n   static bool reinit;\n \n   libfunc_hash = htab_create_ggc (10, hash_libfunc, eq_libfunc, NULL);\n@@ -6657,11 +6645,8 @@ init_optabs (void)\n   /* The ffs function operates on `int'.  Fall back on it if we do not\n      have a libgcc2 function for that width.  */\n   if (INT_TYPE_SIZE < BITS_PER_WORD)\n-    {\n-      int_mode = mode_for_size (INT_TYPE_SIZE, MODE_INT, 0);\n-      set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n-\t\t\t \"ffs\");\n-    }\n+    set_optab_libfunc (ffs_optab, mode_for_size (INT_TYPE_SIZE, MODE_INT, 0),\n+\t\t       \"ffs\");\n \n   /* Explicitly initialize the bswap libfuncs since we need them to be\n      valid for things other than word_mode.  */"}, {"sha": "f8785821f63e0ee3603be91347f128605695b497", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -407,7 +407,6 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n       cselib_val *v;\n       struct elt_loc_list *l;\n       rtx op;\n-      enum machine_mode mode;\n \n       CLEAR_HARD_REG_SET (equiv_regs[i]);\n \n@@ -420,11 +419,10 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \tcontinue;\n \n       op = recog_data.operand[i];\n-      mode = GET_MODE (op);\n #ifdef LOAD_EXTEND_OP\n       if (MEM_P (op)\n-\t  && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n-\t  && LOAD_EXTEND_OP (mode) != UNKNOWN)\n+\t  && GET_MODE_BITSIZE (GET_MODE (op)) < BITS_PER_WORD\n+\t  && LOAD_EXTEND_OP (GET_MODE (op)) != UNKNOWN)\n \t{\n \t  rtx set = single_set (insn);\n \n@@ -457,7 +455,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t   && SET_DEST (set) == recog_data.operand[1-i])\n \t    {\n \t      validate_change (insn, recog_data.operand_loc[i],\n-\t\t\t       gen_rtx_fmt_e (LOAD_EXTEND_OP (mode),\n+\t\t\t       gen_rtx_fmt_e (LOAD_EXTEND_OP (GET_MODE (op)),\n \t\t\t\t\t      word_mode, op),\n \t\t\t       1);\n \t      validate_change (insn, recog_data.operand_loc[1-i],"}, {"sha": "810270625a26c6c2a650b48fecbd58be03cc71a1", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1496,7 +1496,7 @@ decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n \t\t     const char **constraints, enum machine_mode *modes,\n \t\t     location_t *loc)\n {\n-  int noperands, nbase = 0, n, i;\n+  int nbase = 0, n, i;\n   rtx asmop;\n \n   switch (GET_CODE (body))\n@@ -1556,9 +1556,6 @@ decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n       gcc_unreachable ();\n     }\n \n-  noperands = (ASM_OPERANDS_INPUT_LENGTH (asmop)\n-\t       + ASM_OPERANDS_LABEL_LENGTH (asmop) + nbase);\n-\n   n = ASM_OPERANDS_INPUT_LENGTH (asmop);\n   for (i = 0; i < n; i++)\n     {"}, {"sha": "25fcc52b213b3ce35ce618b7d6ec44ded9afbad8", "filename": "gcc/regmove.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -605,8 +605,6 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest)\n   rtx *p_move_notes;\n   int src_regno;\n   int dest_regno;\n-  int insn_uid;\n-  int move_uid;\n \n   /* A REG_LIVE_LENGTH of -1 indicates the register is equivalent to a constant\n      or memory location and is used infrequently; a REG_LIVE_LENGTH of -2 is\n@@ -662,9 +660,6 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest)\n       *p_move_notes = NULL_RTX;\n       *p_insn_notes = NULL_RTX;\n \n-      insn_uid = INSN_UID (insn);\n-      move_uid = INSN_UID (move_insn);\n-\n       /* Update the various register tables.  */\n       dest_regno = REGNO (dest);\n       INC_REG_N_SETS (dest_regno, 1);"}, {"sha": "e0e8970951389b7d8b636bb43aa81bbf23c8eb08", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -175,7 +175,10 @@ regrename_optimize (void)\n     {\n       struct du_head *all_chains = 0;\n       HARD_REG_SET unavailable;\n+#if 0\n       HARD_REG_SET regs_seen;\n+      CLEAR_HARD_REG_SET (regs_seen);\n+#endif\n \n       id_to_chain = VEC_alloc (du_head_p, heap, 0);\n \n@@ -199,7 +202,6 @@ regrename_optimize (void)\n #endif\n \t}\n \n-      CLEAR_HARD_REG_SET (regs_seen);\n       while (all_chains)\n \t{\n \t  int new_reg, best_new_reg, best_nregs;\n@@ -978,7 +980,7 @@ build_def_use (basic_block bb)\n \t  rtx note;\n \t  rtx old_operands[MAX_RECOG_OPERANDS];\n \t  rtx old_dups[MAX_DUP_OPERANDS];\n-\t  int i, icode;\n+\t  int i;\n \t  int alt;\n \t  int predicated;\n \t  enum rtx_code set_code = SET;\n@@ -1007,7 +1009,6 @@ build_def_use (basic_block bb)\n \t     to be marked unrenamable or even cause us to abort the entire\n \t     basic block.  */\n \n-\t  icode = recog_memoized (insn);\n \t  extract_insn (insn);\n \t  if (! constrain_operands (1))\n \t    fatal_insn_not_found (insn);"}, {"sha": "e864eb40c7a048f7e9fe0bec52eab53e037ba6f2", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -5843,11 +5843,9 @@ make_regions_from_the_rest (void)\n   edge e;\n   edge_iterator ei;\n   int *degree;\n-  int new_regions;\n \n   /* Index in rgn_bb_table where to start allocating new regions.  */\n   cur_rgn_blocks = nr_regions ? RGN_BLOCKS (nr_regions) : 0;\n-  new_regions = nr_regions;\n \n   /* Make regions from all the rest basic blocks - those that don't belong to\n      any loop or belong to irreducible loops.  Prepare the data structures"}, {"sha": "9a27adc94e3a62f11ff5bf3ca5b3a93bb8461551", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -457,7 +457,7 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n                                  unsigned *nconds)\n {\n   gimple base_def;\n-  tree base_nm, base_val0;\n+  tree base_val0;\n   tree base_var, int_type;\n   tree temp, tempn;\n   tree cst0;\n@@ -466,7 +466,6 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n   inp_domain exp_domain;\n \n   base_def = SSA_NAME_DEF_STMT (base);\n-  base_nm = gimple_assign_lhs (base_def);\n   base_val0 = gimple_assign_rhs1 (base_def);\n   base_var = SSA_NAME_VAR (base_val0);\n   int_type = TREE_TYPE (base_var);\n@@ -483,10 +482,10 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n   else if (bit_sz == 16)\n     max_exp = 64;\n   else\n-  {\n-    gcc_assert (bit_sz == MAX_BASE_INT_BIT_SIZE);\n-    max_exp = 32;\n-  }\n+    {\n+      gcc_assert (bit_sz == MAX_BASE_INT_BIT_SIZE);\n+      max_exp = 32;\n+    }\n \n   /* For pow ((double)x, y), generate the following conditions:\n      cond 1:\n@@ -548,7 +547,7 @@ gen_conditions_for_pow (gimple pow_call, VEC (gimple, heap) *conds,\n                         unsigned *nconds)\n {\n   tree base, expn;\n-  enum tree_code bc, ec;\n+  enum tree_code bc;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (check_pow (pow_call));\n@@ -560,12 +559,11 @@ gen_conditions_for_pow (gimple pow_call, VEC (gimple, heap) *conds,\n   expn = gimple_call_arg (pow_call, 1);\n \n   bc = TREE_CODE (base);\n-  ec = TREE_CODE (expn);\n \n   if (bc == REAL_CST)\n-      gen_conditions_for_pow_cst_base (base, expn, conds, nconds);\n+    gen_conditions_for_pow_cst_base (base, expn, conds, nconds);\n   else if (bc == SSA_NAME)\n-      gen_conditions_for_pow_int_base (base, expn, conds, nconds);\n+    gen_conditions_for_pow_int_base (base, expn, conds, nconds);\n   else\n     gcc_unreachable ();\n }"}, {"sha": "53bf11854952e6002b20ae1a4d01a126fced3b42", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -434,11 +434,9 @@ create_one_component_var (tree type, tree orig, const char *prefix,\n   if (DECL_NAME (orig) && !DECL_IGNORED_P (orig))\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_NAME (orig));\n-      tree inner_type;\n \n       DECL_NAME (r) = get_identifier (ACONCAT ((name, suffix, NULL)));\n \n-      inner_type = TREE_TYPE (TREE_TYPE (orig));\n       SET_DECL_DEBUG_EXPR (r, build1 (code, type, orig));\n       DECL_DEBUG_EXPR_IS_FROM (r) = 1;\n       DECL_IGNORED_P (r) = 0;"}, {"sha": "a918f4ba2bd7bfa86ca8b9459a6927f96fb7645b", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -598,9 +598,7 @@ set_default_def (tree var, tree def)\n bool\n add_referenced_var (tree var)\n {\n-  var_ann_t v_ann;\n-\n-  v_ann = get_var_ann (var);\n+  get_var_ann (var);\n   gcc_assert (DECL_P (var));\n \n   /* Insert VAR into the referenced_vars has table if it isn't present.  */"}, {"sha": "a70b5b1cbea91114c4c261f400741c8c1008649f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -118,7 +118,7 @@ eni_weights eni_time_weights;\n \n /* Prototypes.  */\n \n-static tree declare_return_variable (copy_body_data *, tree, tree, tree *);\n+static tree declare_return_variable (copy_body_data *, tree, tree);\n static void remap_block (tree *, copy_body_data *);\n static void copy_bind_expr (tree *, int *, copy_body_data *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n@@ -256,10 +256,8 @@ tree\n remap_decl (tree decl, copy_body_data *id)\n {\n   tree *n;\n-  tree fn;\n \n   /* We only remap local variables in the current function.  */\n-  fn = id->src_fn;\n \n   /* See if we have remapped this declaration.  */\n \n@@ -590,7 +588,6 @@ remap_block (tree *block, copy_body_data *id)\n {\n   tree old_block;\n   tree new_block;\n-  tree fn;\n \n   /* Make the new block.  */\n   old_block = *block;\n@@ -607,8 +604,6 @@ remap_block (tree *block, copy_body_data *id)\n   \t\t\t\t\t&BLOCK_NONLOCALIZED_VARS (new_block),\n \t\t\t\t\tid);\n \n-  fn = id->dst_fn;\n-\n   if (id->transform_lang_insert_block)\n     id->transform_lang_insert_block (new_block);\n \n@@ -2533,13 +2528,11 @@ initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n    is set only for CALL_EXPR_RETURN_SLOT_OPT.  MODIFY_DEST, if non-null,\n    was the LHS of the MODIFY_EXPR to which this call is the RHS.\n \n-   The return value is a (possibly null) value that is the result of the\n-   function as seen by the callee.  *USE_P is a (possibly null) value that\n-   holds the result as seen by the caller.  */\n+   The return value is a (possibly null) value that holds the result\n+   as seen by the caller.  */\n \n static tree\n-declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n-\t\t\t tree *use_p)\n+declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest)\n {\n   tree callee = id->src_fn;\n   tree caller = id->dst_fn;\n@@ -2551,10 +2544,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n   /* We don't need to do anything for functions that don't return\n      anything.  */\n   if (!result || VOID_TYPE_P (callee_type))\n-    {\n-      *use_p = NULL_TREE;\n-      return NULL_TREE;\n-    }\n+    return NULL_TREE;\n \n   /* If there was a return slot, then the return value is the\n      dereferenced address of that object.  */\n@@ -2705,8 +2695,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n   /* Remember this so we can ignore it in remap_decls.  */\n   id->retvar = var;\n \n-  *use_p = use;\n-  return var;\n+  return use;\n }\n \n /* Callback through walk_tree.  Determine if a DECL_INITIAL makes reference\n@@ -3506,7 +3495,7 @@ get_indirect_callee_fndecl (struct cgraph_node *node, gimple stmt)\n static bool\n expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n {\n-  tree retvar, use_retvar;\n+  tree use_retvar;\n   tree fn;\n   struct pointer_map_t *st, *dst;\n   tree return_slot;\n@@ -3725,7 +3714,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n     }\n \n   /* Declare the return variable for the function.  */\n-  retvar = declare_return_variable (id, return_slot, modify_dest, &use_retvar);\n+  use_retvar = declare_return_variable (id, return_slot, modify_dest);\n \n   /* Add local vars in this inlined callee to caller.  */\n   t_step = id->src_cfun->local_decls;\n@@ -3981,7 +3970,6 @@ unsigned int\n optimize_inline_calls (tree fn)\n {\n   copy_body_data id;\n-  tree prev_fn;\n   basic_block bb;\n   int last = n_basic_blocks;\n   struct gimplify_ctx gctx;\n@@ -3998,12 +3986,8 @@ optimize_inline_calls (tree fn)\n   id.src_node = id.dst_node = cgraph_node (fn);\n   id.dst_fn = fn;\n   /* Or any functions that aren't finished yet.  */\n-  prev_fn = NULL_TREE;\n   if (current_function_decl)\n-    {\n-      id.dst_fn = current_function_decl;\n-      prev_fn = current_function_decl;\n-    }\n+    id.dst_fn = current_function_decl;\n \n   id.copy_decl = copy_decl_maybe_to_var;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;"}, {"sha": "3c93f8eddd73d07fad04b4bd799e40d5b54f06cb", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -521,7 +521,6 @@ mark_nodes_having_upstream_mem_writes (struct graph *rdg)\n       {\n \tunsigned i;\n \tVEC (int, heap) *nodes = VEC_alloc (int, heap, 3);\n-\tbool has_upstream_mem_write_p = false;\n \n \tgraphds_dfs (rdg, &v, 1, &nodes, false, NULL);\n \n@@ -539,7 +538,6 @@ mark_nodes_having_upstream_mem_writes (struct graph *rdg)\n \t\t   should be placed in the same partition.  */\n \t\t|| has_anti_dependence (&(rdg->vertices[x])))\n \t      {\n-\t\thas_upstream_mem_write_p = true;\n \t\tbitmap_set_bit (upstream_mem_writes, x);\n \t      }\n \t  }"}, {"sha": "23b7046c60d4c3d7c2083e1464ba2e692c131ace", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -378,14 +378,11 @@ void\n tree_rest_of_compilation (tree fndecl)\n {\n   location_t saved_loc;\n-  struct cgraph_node *node;\n \n   timevar_push (TV_EXPAND);\n \n   gcc_assert (cgraph_global_info_ready);\n \n-  node = cgraph_node (fndecl);\n-\n   /* Initialize the default bitmap obstack.  */\n   bitmap_obstack_initialize (NULL);\n "}, {"sha": "cf019701225c4f2527ba744924c34eb71d23c77f", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -862,13 +862,12 @@ create_call_for_reduction_1 (void **slot, void *data)\n   basic_block bb;\n   basic_block new_bb;\n   edge e;\n-  tree t, addr, addr_type, ref, x;\n+  tree t, addr, ref, x;\n   tree tmp_load, name;\n   gimple load;\n \n   load_struct = fold_build1 (INDIRECT_REF, struct_type, clsn_data->load);\n   t = build3 (COMPONENT_REF, type, load_struct, reduc->field, NULL_TREE);\n-  addr_type = build_pointer_type (type);\n \n   addr = build_addr (t, current_function_decl);\n \n@@ -1405,7 +1404,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n {\n   gimple_stmt_iterator gsi;\n   basic_block bb, paral_bb, for_bb, ex_bb;\n-  tree t, param, res;\n+  tree t, param;\n   gimple stmt, for_stmt, phi, cond_stmt;\n   tree cvar, cvar_init, initvar, cvar_next, cvar_base, type;\n   edge exit, nexit, guard, end, e;\n@@ -1474,7 +1473,6 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n       source_location locus;\n       tree def;\n       phi = gsi_stmt (gsi);\n-      res = PHI_RESULT (phi);\n       stmt = SSA_NAME_DEF_STMT (PHI_ARG_DEF_FROM_EDGE (phi, exit));\n \n       def = PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop));\n@@ -1531,7 +1529,6 @@ static void\n gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n \t\t   unsigned n_threads, struct tree_niter_desc *niter)\n {\n-  struct loop *nloop;\n   loop_iterator li;\n   tree many_iterations_cond, type, nit;\n   tree arg_struct, new_arg_struct;\n@@ -1624,8 +1621,8 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n \n   /* We assume that the loop usually iterates a lot.  */\n   prob = 4 * REG_BR_PROB_BASE / 5;\n-  nloop = loop_version (loop, many_iterations_cond, NULL,\n-\t\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n+  loop_version (loop, many_iterations_cond, NULL,\n+\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n   update_ssa (TODO_update_ssa);\n   free_original_copy_tables ();\n "}, {"sha": "e7137087625f7719ab68efcf1b36ddb2926da4d8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -767,7 +767,6 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n {\n   tree base1, base2;\n   HOST_WIDE_INT offset1 = 0, offset2 = 0;\n-  HOST_WIDE_INT size1 = -1, size2 = -1;\n   HOST_WIDE_INT max_size1 = -1, max_size2 = -1;\n   bool var1_p, var2_p, ind1_p, ind2_p;\n   alias_set_type set;\n@@ -788,11 +787,9 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   /* Decompose the references into their base objects and the access.  */\n   base1 = ao_ref_base (ref1);\n   offset1 = ref1->offset;\n-  size1 = ref1->size;\n   max_size1 = ref1->max_size;\n   base2 = ao_ref_base (ref2);\n   offset2 = ref2->offset;\n-  size2 = ref2->size;\n   max_size2 = ref2->max_size;\n \n   /* We can end up with registers or constants as bases for example from"}, {"sha": "48e20454857f91f73502cc83b9533764ed37b91a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -94,8 +94,10 @@ split_to_var_and_offset (tree expr, tree *var, mpz_t offset)\n \n       *var = op0;\n       /* Always sign extend the offset.  */\n-      off = double_int_sext (tree_to_double_int (op1),\n-\t\t\t     TYPE_PRECISION (type));\n+      off = tree_to_double_int (op1);\n+      if (negate)\n+\toff = double_int_neg (off);\n+      off = double_int_sext (off, TYPE_PRECISION (type));\n       mpz_set_double_int (offset, off, false);\n       break;\n "}, {"sha": "9b6d3a325e67434d7590ff31d8d88fb8e4f318d5", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -653,13 +653,11 @@ static void\n add_stmt_operand (tree *var_p, gimple stmt, int flags)\n {\n   tree var, sym;\n-  var_ann_t v_ann;\n \n   gcc_assert (SSA_VAR_P (*var_p));\n \n   var = *var_p;\n   sym = (TREE_CODE (var) == SSA_NAME ? SSA_NAME_VAR (var) : var);\n-  v_ann = var_ann (sym);\n \n   /* Mark statements with volatile operands.  */\n   if (TREE_THIS_VOLATILE (sym))"}, {"sha": "2027357fd6329ba327677cbfe54b8a95b6df0537", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1023,11 +1023,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n   gimple def_stmt = SSA_NAME_DEF_STMT (vuse);\n   tree fndecl;\n   tree base;\n-  HOST_WIDE_INT offset, size, maxsize;\n+  HOST_WIDE_INT offset, maxsize;\n \n   base = ao_ref_base (ref);\n   offset = ref->offset;\n-  size = ref->size;\n   maxsize = ref->max_size;\n \n   /* If we cannot constrain the size of the reference we cannot"}, {"sha": "bc6a7146b521ffb9c321743359030a6e400a8e42", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -273,7 +273,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n   def_operand_p def_p;\n   ssa_op_iter iter;\n   imm_use_iterator imm_iter;\n-  enum tree_code code;\n \n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n@@ -320,7 +319,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n      to use specific hard registers.\n \n   */\n-  code = gimple_assign_rhs_code (stmt);\n   if (stmt_ends_bb_p (stmt)\n       || gimple_has_side_effects (stmt)\n       || is_hidden_global_store (stmt)"}, {"sha": "753eefee909c7808b98b4bf85d2d9bbd1d1ed80d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1354,7 +1354,6 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t  && si->dfs[VEC_last (unsigned, si->scc_stack)] >= my_dfs)\n \t{\n \t  bitmap scc = BITMAP_ALLOC (NULL);\n-\t  bool have_ref_node = n >= FIRST_REF_NODE;\n \t  unsigned int lowest_node;\n \t  bitmap_iterator bi;\n \n@@ -1366,8 +1365,6 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t      unsigned int w = VEC_pop (unsigned, si->scc_stack);\n \n \t      bitmap_set_bit (scc, w);\n-\t      if (w >= FIRST_REF_NODE)\n-\t\thave_ref_node = true;\n \t    }\n \n \t  lowest_node = bitmap_first_set_bit (scc);\n@@ -3283,14 +3280,11 @@ do_structure_copy (tree lhsop, tree rhsop)\n \t   && (rhsp->type == SCALAR\n \t       || rhsp->type == ADDRESSOF))\n     {\n-      tree lhsbase, rhsbase;\n       HOST_WIDE_INT lhssize, lhsmaxsize, lhsoffset;\n       HOST_WIDE_INT rhssize, rhsmaxsize, rhsoffset;\n       unsigned k = 0;\n-      lhsbase = get_ref_base_and_extent (lhsop, &lhsoffset,\n-\t\t\t\t\t &lhssize, &lhsmaxsize);\n-      rhsbase = get_ref_base_and_extent (rhsop, &rhsoffset,\n-\t\t\t\t\t &rhssize, &rhsmaxsize);\n+      get_ref_base_and_extent (lhsop, &lhsoffset, &lhssize, &lhsmaxsize);\n+      get_ref_base_and_extent (rhsop, &rhsoffset, &rhssize, &rhsmaxsize);\n       for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp);)\n \t{\n \t  varinfo_t lhsv, rhsv;\n@@ -3640,11 +3634,9 @@ find_func_aliases (gimple origt)\n \t  get_constraint_for (gimple_phi_result (t), &lhsc);\n \t  for (i = 0; i < gimple_phi_num_args (t); i++)\n \t    {\n-\t      tree rhstype;\n \t      tree strippedrhs = PHI_ARG_DEF (t, i);\n \n \t      STRIP_NOPS (strippedrhs);\n-\t      rhstype = TREE_TYPE (strippedrhs);\n \t      get_constraint_for (gimple_phi_arg_def (t, i), &rhsc);\n \n \t      for (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n@@ -5681,8 +5673,6 @@ ipa_pta_execute (void)\n   /* Build the constraints.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      unsigned int varid;\n-\n       /* Nodes without a body are not interesting.  Especially do not\n          visit clones at this point for now - we get duplicate decls\n \t there for inline clones at least.  */\n@@ -5696,8 +5686,8 @@ ipa_pta_execute (void)\n       if (node->local.externally_visible)\n \tcontinue;\n \n-      varid = create_function_info_for (node->decl,\n-\t\t\t\t\tcgraph_node_name (node));\n+      create_function_info_for (node->decl,\n+\t\t\t\tcgraph_node_name (node));\n     }\n \n   for (node = cgraph_nodes; node; node = node->next)"}, {"sha": "872de64620e63a5355fe630bead402058692bc08", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -635,7 +635,6 @@ thread_single_edge (edge e)\n   basic_block bb = e->dest;\n   edge eto = (edge) e->aux;\n   struct redirection_data rd;\n-  struct local_info local_info;\n \n   e->aux = NULL;\n \n@@ -657,7 +656,6 @@ thread_single_edge (edge e)\n   /* Otherwise, we need to create a copy.  */\n   update_bb_profile_for_threading (bb, EDGE_FREQUENCY (e), e->count, eto);\n \n-  local_info.bb = bb;\n   rd.outgoing_edge = eto;\n \n   create_block_for_threading (bb, &rd);"}, {"sha": "89918535372463f5f1a75333c5543b6638bfb46e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1885,7 +1885,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     {\n       gimple stmt;\n       stmt_vec_info stmt_info;\n-      basic_block bb;\n       tree base, offset, init;\n \n       if (!dr || !DR_REF (dr))\n@@ -1923,7 +1922,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       init = unshare_expr (DR_INIT (dr));\n \n       /* Update DR field in stmt_vec_info struct.  */\n-      bb = gimple_bb (stmt);\n \n       /* If the dataref is in an inner-loop of the loop that is considered for\n \t for vectorization, we also want to analyze the access relative to\n@@ -2764,13 +2762,10 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n   tree perm_dest, vect1, vect2, high, low;\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-  tree scalar_dest;\n   int i;\n   unsigned int j;\n   enum tree_code high_code, low_code;\n \n-  scalar_dest = gimple_assign_lhs (stmt);\n-\n   /* Check that the operation is supported.  */\n   if (!vect_strided_store_supported (vectype))\n     return false;\n@@ -3382,7 +3377,6 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   enum machine_mode mode = TYPE_MODE (vectype);\n-  bool invariant_in_outerloop = false;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *vect_loop = NULL;\n   bool nested_in_vect_loop = false;\n@@ -3397,13 +3391,6 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n   vect_loop = LOOP_VINFO_LOOP (loop_vinfo);\n   nested_in_vect_loop = nested_in_vect_loop_p (vect_loop, stmt);\n \n-  if (nested_in_vect_loop)\n-    {\n-      tree outerloop_step = STMT_VINFO_DR_STEP (stmt_info);\n-      invariant_in_outerloop =\n-\t(tree_int_cst_compare (outerloop_step, size_zero_node) == 0);\n-    }\n-\n   /* Possibly unaligned access.  */\n \n   /* We can choose between using the implicit realignment scheme (generating"}, {"sha": "d3068b308525d9b67f358713385eb06cedeb87a3", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -2327,7 +2327,6 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n \t\t      tree *cond_expr, gimple_seq *cond_expr_stmt_list)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  struct loop *nloop;\n   basic_block condition_bb;\n   gimple_stmt_iterator gsi, cond_exp_gsi;\n   basic_block merge_bb;\n@@ -2374,8 +2373,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n     return;\n \n   initialize_original_copy_tables ();\n-  nloop = loop_version (loop, *cond_expr, &condition_bb,\n-\t\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n+  loop_version (loop, *cond_expr, &condition_bb,\n+\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n   free_original_copy_tables();\n \n   /* Loop versioning violates an assumption we try to maintain during"}, {"sha": "f160cb458b4ae17c14bde963d667ed292fcdc21a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -889,7 +889,7 @@ vect_analyze_loop_form (struct loop *loop)\n   else\n     {\n       struct loop *innerloop = loop->inner;\n-      edge backedge, entryedge;\n+      edge entryedge;\n \n       /* Nested loop. We currently require that the loop is doubly-nested,\n \t contains a single inner loop, and the number of BBs is exactly 5.\n@@ -943,13 +943,9 @@ vect_analyze_loop_form (struct loop *loop)\n         }\n \n       gcc_assert (EDGE_COUNT (innerloop->header->preds) == 2);\n-      backedge = EDGE_PRED (innerloop->header, 1);\n       entryedge = EDGE_PRED (innerloop->header, 0);\n       if (EDGE_PRED (innerloop->header, 0)->src == innerloop->latch)\n-\t{\n-\t  backedge = EDGE_PRED (innerloop->header, 0);\n-\t  entryedge = EDGE_PRED (innerloop->header, 1);\n-\t}\n+\tentryedge = EDGE_PRED (innerloop->header, 1);\n \n       if (entryedge->src != loop->header\n \t  || !single_exit (innerloop)\n@@ -2890,7 +2886,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   gimple epilog_stmt = NULL;\n   tree new_scalar_dest, new_dest;\n   gimple exit_phi;\n-  tree bitsize, bitpos, bytesize;\n+  tree bitsize, bitpos;\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree adjustment_def;\n   tree vec_initial_def, def;\n@@ -3045,7 +3041,6 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   scalar_type = TREE_TYPE (scalar_dest);\n   new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n   bitsize = TYPE_SIZE (scalar_type);\n-  bytesize = TYPE_SIZE_UNIT (scalar_type);\n \n   /* For MINUS_EXPR the initial vector is [init_val,0,...,0], therefore,\n      partial results are added and not subtracted.  */"}, {"sha": "37b06330f3a6aacaaf28c3845d89a238a6c6dd1b", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -456,16 +456,13 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n static gimple\n vect_recog_pow_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n {\n-  tree type;\n   tree fn, base, exp = NULL;\n   gimple stmt;\n   tree var;\n \n   if (!is_gimple_call (last_stmt) || gimple_call_lhs (last_stmt) == NULL)\n     return NULL;\n \n-  type = gimple_expr_type (last_stmt);\n-\n   fn = gimple_call_fndecl (last_stmt);\n   switch (DECL_FUNCTION_CODE (fn))\n     {\n@@ -812,7 +809,6 @@ vect_pattern_recog (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   unsigned int nbbs = loop->num_nodes;\n   gimple_stmt_iterator si;\n-  gimple stmt;\n   unsigned int i, j;\n   gimple (* vect_recog_func_ptr) (gimple, tree *, tree *);\n \n@@ -826,8 +822,6 @@ vect_pattern_recog (loop_vec_info loop_vinfo)\n       basic_block bb = bbs[i];\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n-          stmt = gsi_stmt (si);\n-\n           /* Scan over all generic vect_recog_xxx_pattern functions.  */\n           for (j = 0; j < NUM_PATTERNS; j++)\n             {"}, {"sha": "3222f8b450e005cc16eda974cc645bf09c5b9ec5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -879,7 +879,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   unsigned int unrolling_factor = 1, nunits;\n   tree vectype, scalar_type;\n   gimple next;\n-  unsigned int vectorization_factor = 0, ncopies;\n+  unsigned int vectorization_factor = 0;\n   int inside_cost = 0, outside_cost = 0, ncopies_for_cost;\n   unsigned int max_nunits = 0;\n   VEC (int, heap) *load_permutation;\n@@ -905,8 +905,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     /* No multitypes in BB SLP.  */\n     vectorization_factor = nunits;\n \n-  ncopies = vectorization_factor / nunits;\n-\n   /* Calculate the unrolling factor.  */\n   unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n   if (unrolling_factor != 1 && !loop_vinfo)\n@@ -1639,13 +1637,11 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n   tree perm_dest;\n   gimple perm_stmt = NULL;\n   stmt_vec_info next_stmt_info;\n-  int i, group_size, stride, dr_chain_size;\n+  int i, stride;\n   tree first_vec, second_vec, data_ref;\n   VEC (tree, heap) *params = NULL;\n \n-  group_size = VEC_length (gimple, SLP_TREE_SCALAR_STMTS (node));\n   stride = SLP_TREE_NUMBER_OF_VEC_STMTS (node) / ncopies;\n-  dr_chain_size = VEC_length (tree, dr_chain);\n \n   /* Initialize the vect stmts of NODE to properly insert the generated\n      stmts later.  */"}, {"sha": "92f21982e3ee9698b777518d77369f30e52c4037", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -1548,7 +1548,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   int nunits_out;\n   tree vectype_out, vectype_in;\n   int ncopies, j;\n-  tree expr;\n   tree rhs_type, lhs_type;\n   tree builtin_decl;\n   enum { NARROW, NONE, WIDEN } modifier;\n@@ -1765,7 +1764,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t    }\n \n \t  /* Arguments are ready. Create the new vector stmt.  */\n-\t  expr = build2 (code1, vectype_out, vec_oprnd0, vec_oprnd1);\n \t  new_stmt = gimple_build_assign_with_ops (code1, vec_dest, vec_oprnd0,\n \t\t\t\t\t\t   vec_oprnd1);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n@@ -1929,7 +1927,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   tree vop0, vop1;\n   unsigned int k;\n-  bool shift_p = false;\n   bool scalar_shift_arg = false;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n@@ -2013,8 +2010,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (code == LSHIFT_EXPR || code == RSHIFT_EXPR || code == LROTATE_EXPR\n       || code == RROTATE_EXPR)\n     {\n-      shift_p = true;\n-\n       /* vector shifted by vector */\n       if (dt[1] == vect_internal_def)\n \t{\n@@ -2893,7 +2888,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool inv_p;\n   VEC(tree,heap) *vec_oprnds = NULL;\n   bool slp = (slp_node != NULL);\n-  stmt_vec_info first_stmt_vinfo;\n   unsigned int vec_num;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n \n@@ -3036,7 +3030,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       first_stmt = stmt;\n       first_dr = dr;\n       group_size = vec_num = 1;\n-      first_stmt_vinfo = stmt_info;\n     }\n \n   if (vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "2d0761b15faacc7ecce10d13ef9ca7d176daa8e2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -3911,7 +3911,6 @@ register_new_assert_for (tree name, tree expr,\n \t\t\t gimple_stmt_iterator si)\n {\n   assert_locus_t n, loc, last_loc;\n-  bool found;\n   basic_block dest_bb;\n \n #if defined ENABLE_CHECKING\n@@ -3960,7 +3959,6 @@ register_new_assert_for (tree name, tree expr,\n      COMP_CODE and VAL could be implemented.  */\n   loc = asserts_for[SSA_NAME_VERSION (name)];\n   last_loc = loc;\n-  found = false;\n   while (loc)\n     {\n       if (loc->comp_code == comp_code\n@@ -5997,7 +5995,7 @@ vrp_visit_switch_stmt (gimple stmt, edge *taken_edge_p)\n {\n   tree op, val;\n   value_range_t *vr;\n-  size_t i = 0, j = 0, n;\n+  size_t i = 0, j = 0;\n   bool take_default;\n \n   *taken_edge_p = NULL;\n@@ -6020,8 +6018,6 @@ vrp_visit_switch_stmt (gimple stmt, edge *taken_edge_p)\n     return SSA_PROP_VARYING;\n \n   /* Find the single edge that is taken from the switch expression.  */\n-  n = gimple_switch_num_labels (stmt);\n-\n   take_default = !find_case_label_range (stmt, vr->min, vr->max, &i, &j);\n \n   /* Check if the range spans no CASE_LABEL. If so, we only reach the default"}, {"sha": "0dde9bf80416a2ffbdc5943634f2abcc20f2db28", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f900dfafa90a1114d3768f3fe5fe4d07f250a9a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=0f900dfafa90a1114d3768f3fe5fe4d07f250a9a", "patch": "@@ -959,7 +959,7 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   histogram_value histogram;\n   enum tree_code code;\n   gcov_type count, wrong_values, all;\n-  tree lhs_type, result, value;\n+  tree lhs_type, result;\n   gcov_type prob1, prob2;\n   unsigned int i, steps;\n   gcov_type count1, count2;\n@@ -982,7 +982,6 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   if (!histogram)\n     return false;\n \n-  value = histogram->hvalue.value;\n   all = 0;\n   wrong_values = 0;\n   for (i = 0; i < histogram->hdata.intvl.steps; i++)\n@@ -1367,7 +1366,6 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   enum built_in_function fcode;\n   histogram_value histogram;\n   gcov_type count, all, val;\n-  tree value;\n   tree dest, src;\n   unsigned int dest_align, src_align;\n   gcov_type prob;\n@@ -1390,7 +1388,6 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_SINGLE_VALUE);\n   if (!histogram)\n     return false;\n-  value = histogram->hvalue.value;\n   val = histogram->hvalue.counters[0];\n   count = histogram->hvalue.counters[1];\n   all = histogram->hvalue.counters[2];\n@@ -1593,15 +1590,13 @@ gimple_stringops_values_to_profile (gimple stmt, histogram_values *values)\n   tree fndecl;\n   tree blck_size;\n   tree dest;\n-  enum built_in_function fcode;\n   int size_arg;\n \n   if (gimple_code (stmt) != GIMPLE_CALL)\n     return;\n   fndecl = gimple_call_fndecl (stmt);\n   if (!fndecl)\n     return;\n-  fcode = DECL_FUNCTION_CODE (fndecl);\n \n   if (!interesting_stringop_to_profile_p (fndecl, stmt, &size_arg))\n     return;"}]}