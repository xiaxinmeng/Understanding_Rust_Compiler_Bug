{"sha": "88b32fc3a7728aac518bb52c53cb7596c49b720c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhiMzJmYzNhNzcyOGFhYzUxOGJiNTJjNTNjYjc1OTZjNDliNzIwYw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2006-10-31T17:58:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:58:48Z"}, "message": "g-awk.adb (Default_Session, [...]): Compile this file in Ada 95 mode, because it violates the new rules for AI-318.\n\n2006-10-31  Bob Duff  <duff@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* g-awk.adb (Default_Session, Current_Session): Compile this file in\n\tAda 95 mode, because it violates the new rules for AI-318.\n\n\t* g-awk.ads: Use overloaded subprograms in every case where we used to\n\thave a default of Current_Session. This makes the code closer to be\n\tcorrect for both Ada 95 and 2005.\n\n\t* g-moreex.adb (Occurrence): Turn off warnings for illegal-in-Ada-2005\n\tcode, relying on the fact that the compiler generates a warning\n\tinstead of an error in -gnatg mode.\n\n\t* lib-xref.ads (Xref_Entity_Letters): Add entry for new\n\tE_Return_Statement entity kind.\n\tAdd an entry for E_Incomplete_Subtype in Xref_Entity_Letters.\n\n\t* par.adb (P_Interface_Type_Definition): Addition of one formal to\n\treport an error if the reserved word abstract has been previously found.\n\t(SS_End_Type): Add E_Return for new extended_return_statement syntax.\n        \n        * par-ch4.adb (P_Aggregate_Or_Paren_Expr): Improve message for\n\tparenthesized range attribute usage\n\t(P_Expression_No_Right_Paren): Add missing comment about error recovery.\n\n\t* par-ch6.adb (P_Return_Object_Declaration): AI-318: Allow \"constant\"\n\tin the syntax for extended_return_statement. This is not in the latest\n\tRM, but the ARG is expected to issue an AI allowing this.\n\t(P_Return_Subtype_Indication,P_Return_Subtype_Indication): Remove\n\tN_Return_Object_Declaration. We now use N_Object_Declaration instead.\n\t(P_Return_Object_Declaration, P_Return_Subtype_Indication,\n\tP_Return_Statement): Parse the new syntax for extended_return_statement.\n\n\t* par-endh.adb (Check_End, Output_End_Deleted, Output_End_Expected,\n\tOutput_End_Missing): Add error-recovery code for the new\n\textended_return_statement syntax; that is, the new E_Return entry on\n\tthe scope stack.\n\n\t* s-auxdec-vms_64.ads, s-auxdec.ads (AST_Handler): Change type from\n\tlimited to nonlimited, because otherwise we violate the new Ada 2005\n\trules about returning limited types in function Create_AST_Handler in\n\ts-asthan.adb.\n\n\t* sem.adb (Analyze): Add cases for new node kinds\n\tN_Extended_Return_Statement and N_Return_Object_Declaration.\n\n\t* sem_aggr.adb (Aggregate_Constraint_Checks): Verify that component\n\ttype is in the same category as type of context before applying check,\n\tto prevent anomalies in instantiations.\n\t(Resolve_Aggregate): Remove test for limited components in aggregates.\n\tIt's unnecessary in Ada 95, because if it has limited components, then\n\tit must be limited. It's wrong in Ada 2005, because limited aggregates\n\tare now allowed.\n\t(Resolve_Record_Aggregate): Move check for limited types later, because\n\tOK_For_Limited_Init requires its argument to have been resolved.\n\t(Get_Value): When copying the component default expression for a\n\tdefaulted association in an aggregate, use the sloc of the aggregate\n\tand not that of the original expression, to prevent spurious\n\telaboration errors, when the expression includes function calls.\n\t(Check_Non_Limited_Type): Correct code for AI-287, extension aggregates\n\twere missing. We also didn't handle qualified expressions. Now also\n\tallow function calls. Use new common routine OK_For_Limited_Init.\n\t(Resolve_Extension_Aggregate): Minor fix to bad error message (started\n\twith space can upper case letter).\n\n        * sem_ch3.ads, sem_ch3.adb (Create_Constrained_Components): Set\n\tHas_Static_Discriminants flag\n        (Record_Type_Declaration): Diagnose an attempt to declare an interface\n        type with discriminants.\n        (Process_Range_Expr_In_Decl): Do validity checks on range\n\t(Build_Discriminant_Constraints): Use updated form of\n\tDenotes_Discriminant.\n\t(Process_Subtype): If the subtype is a private subtype whose full view\n\tis a concurrent subtype, introduce an itype reference to prevent scope\n\tanomalies in gigi.\n\t(Build_Derived_Record_Type, Collect_Interface_Primitives,\n\tRecord_Type_Declaration):  The functionality of the subprograms\n\tCollect_Abstract_Interfaces and Collect_All_Abstract_Interfaces\n\tis now performed by a single routine.\n\t(Build_Derived_Record_Type): If the type definition includes an explicit\n\tindication of limitedness, then the type must be marked as limited here\n\tto ensure that any access discriminants will not be treated as having\n\ta local anonymous access type.\n\t(Check_Abstract_Overriding): Issue a detailed error message when an\n\tabstract subprogram was not overridden due to incorrect mode of its\n\tfirst parameter.\n\t(Analyze_Private_Extension_Declaration): Add support for the analysis of\n\tsynchronized private extension declarations. Verify that the ancestor is\n\ta limited or synchronized interface or in the generic case, the ancestor\n\tis a tagged limited type or synchronized interface and all progenitors\n\tare either limited or synchronized interfaces.\n\tDerived_Type_Declaration): Check for presence of private extension when\n\tdealing with synchronized formal derived types.\n\tProcess_Full_View): Enchance the check done on the usage of \"limited\" by\n\ttesting whether the private view is synchronized.\n\tVerify that a synchronized private view is completed by a protected or\n\ttask type.\n\t(OK_For_Limited_Init_In_05): New function.\n\t(Analyze_Object_Declaration): Move check for limited types later,\n\tbecause OK_For_Limited_Init requires its argument to have been resolved.\n\tAdd -gnatd.l --Use Ada 95 semantics for limited function returns,\n\tin order to alleviate the upward compatibility introduced by AI-318.\n\t(Constrain_Corresponding_Record): If the constraint is for a component\n\tsubtype, mark the itype as frozen, to avoid out-of-scope references to\n\tdiscriminants in the back-end.\n\t(Collect_Implemented_Interfaces): Protect the recursive algorithm of\n\tthis subprogram against wrong sources.\n\t(Get_Discr_Value, Is_Discriminant): Handle properly references to a\n\tdiscriminant of limited type completed with a protected type, when the\n\tdiscriminant is used to constrain a private component of the type, and\n\texpansion is disabled.\n\t(Find_Type_Of_Object): Do not treat a return subtype that is an\n\tanonymous subtype as a local_anonymous_type, because its accessibility\n\tlevel is the return type of the enclosing function.\n\t(Check_Initialization): In -gnatg mode, turn the error \"cannot\n\tinitialize entities of limited type\" into a warning.\n\t(OK_For_Limited_Init): Return true for generated nodes, since it\n\tsometimes violates the legality rules.\n\t(Make_Incomplete_Declaration): If the type for which an incomplete\n\tdeclaration is created happens to be the currently visible entity,\n\tpreserve the homonym chain when removing it from visibility.\n\t(Check_Conventions): Add support for Ada 2005 (AI-430): Conventions of\n\tinherited subprograms.\n\t(Access_Definition): If this is an access to function that is the return\n\ttype of an access_to_function definition, context is a type declaration\n\tand the scope of the anonymous type is the current one.\n\t(Analyze_Subtype_Declaration): Add the defining identifier of a regular\n\tincomplete subtype to the set of private dependents of the original\n\tincomplete type.\n\t(Constrain_Discriminated_Type): Emit an error message whenever an\n\tincomplete subtype is being constrained.\n\t(Process_Incomplete_Dependents): Transform an incomplete subtype into a\n\tcorresponding subtype of the full view of the original incomplete type.\n\t(Check_Incomplete): Properly detect invalid usage of incomplete types\n\tand subtypes.\n\nFrom-SVN: r118273", "tree": {"sha": "b27b24d9bf1dfcca04c420002e7632e08960845e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b27b24d9bf1dfcca04c420002e7632e08960845e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88b32fc3a7728aac518bb52c53cb7596c49b720c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b32fc3a7728aac518bb52c53cb7596c49b720c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b32fc3a7728aac518bb52c53cb7596c49b720c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b32fc3a7728aac518bb52c53cb7596c49b720c/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bae7876b4d3c0e1c5532b00f744a86d1f31d403e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae7876b4d3c0e1c5532b00f744a86d1f31d403e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae7876b4d3c0e1c5532b00f744a86d1f31d403e"}], "stats": {"total": 2813, "additions": 1860, "deletions": 953}, "files": [{"sha": "e530efc15609afe4eb2119bff86312f89f6f9e1b", "filename": "gcc/ada/g-awk.adb", "status": "modified", "additions": 230, "deletions": 29, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fg-awk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fg-awk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2005 AdaCore                      --\n+--                     Copyright (C) 2000-2006 AdaCore                      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+pragma Ada_95;\n+--  This is needed because the pragmas Warnings (Off) in Current_Session and\n+--  Default_Session (see below) do not work when compiling clients of this\n+--  package that instantiate generic units herein.\n+\n pragma Style_Checks (All_Checks);\n --  Turn off alpha ordering check for subprograms, since we cannot\n --  Put Finalize and Initialize in alpha order (see comments).\n@@ -332,13 +337,13 @@ package body GNAT.AWK is\n    --  A function that always returns True\n \n    function Apply_Filters\n-     (Session : Session_Type := Current_Session) return Boolean;\n+     (Session : Session_Type) return Boolean;\n    --  Apply any filters for which the Pattern is True for Session. It returns\n    --  True if a least one filters has been applied (i.e. associated action\n    --  callback has been called).\n \n    procedure Open_Next_File\n-     (Session : Session_Type := Current_Session);\n+     (Session : Session_Type);\n    pragma Inline (Open_Next_File);\n    --  Open next file for Session closing current file if needed. It raises\n    --  End_Error if there is no more file in the table.\n@@ -580,7 +585,7 @@ package body GNAT.AWK is\n \n    procedure Add_File\n      (Filename : String;\n-      Session  : Session_Type := Current_Session)\n+      Session  : Session_Type)\n    is\n       Files : File_Table.Instance renames Session.Data.Files;\n \n@@ -596,6 +601,14 @@ package body GNAT.AWK is\n       end if;\n    end Add_File;\n \n+   procedure Add_File\n+     (Filename : String)\n+   is\n+\n+   begin\n+      Add_File (Filename, Cur_Session);\n+   end Add_File;\n+\n    ---------------\n    -- Add_Files --\n    ---------------\n@@ -604,7 +617,7 @@ package body GNAT.AWK is\n      (Directory             : String;\n       Filenames             : String;\n       Number_Of_Files_Added : out Natural;\n-      Session               : Session_Type := Current_Session)\n+      Session               : Session_Type)\n    is\n       use Directory_Operations;\n \n@@ -636,6 +649,16 @@ package body GNAT.AWK is\n             Session);\n    end Add_Files;\n \n+   procedure Add_Files\n+     (Directory             : String;\n+      Filenames             : String;\n+      Number_Of_Files_Added : out Natural)\n+   is\n+\n+   begin\n+      Add_Files (Directory, Filenames, Number_Of_Files_Added, Cur_Session);\n+   end Add_Files;\n+\n    -----------------\n    -- Always_True --\n    -----------------\n@@ -650,7 +673,7 @@ package body GNAT.AWK is\n    -------------------\n \n    function Apply_Filters\n-     (Session : Session_Type := Current_Session) return Boolean\n+     (Session : Session_Type) return Boolean\n    is\n       Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n       Results : Boolean := False;\n@@ -715,7 +738,13 @@ package body GNAT.AWK is\n \n    function Current_Session return Session_Type is\n    begin\n+      pragma Warnings (Off);\n       return Cur_Session;\n+      --  ???The above return statement violates the Ada 2005 rule forbidding\n+      --  copying of limited objects (see RM-7.5(2.8/2)). When compiled with\n+      --  -gnatg, the compiler gives a warning instead of an error, so we can\n+      --  turn it off.\n+      pragma Warnings (On);\n    end Current_Session;\n \n    ---------------------\n@@ -724,7 +753,13 @@ package body GNAT.AWK is\n \n    function Default_Session return Session_Type is\n    begin\n+      pragma Warnings (Off);\n       return Def_Session;\n+      --  ???The above return statement violates the Ada 2005 rule forbidding\n+      --  copying of limited objects (see RM-7.5(2.8/2)). When compiled with\n+      --  -gnatg, the compiler gives a warning instead of an error, so we can\n+      --  turn it off.\n+      pragma Warnings (On);\n    end Default_Session;\n \n    --------------------\n@@ -733,42 +768,63 @@ package body GNAT.AWK is\n \n    function Discrete_Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return Discrete\n+      Session : Session_Type) return Discrete\n    is\n    begin\n       return Discrete'Value (Field (Rank, Session));\n    end Discrete_Field;\n \n+   function Discrete_Field_Current_Session\n+     (Rank    : Count) return Discrete is\n+      function Do_It is new Discrete_Field (Discrete);\n+   begin\n+      return Do_It (Rank, Cur_Session);\n+   end Discrete_Field_Current_Session;\n+\n    -----------------\n    -- End_Of_Data --\n    -----------------\n \n    function End_Of_Data\n-     (Session : Session_Type := Current_Session) return Boolean\n+     (Session : Session_Type) return Boolean\n    is\n    begin\n       return Session.Data.File_Index = File_Table.Last (Session.Data.Files)\n         and then End_Of_File (Session);\n    end End_Of_Data;\n \n+   function End_Of_Data\n+     return Boolean\n+   is\n+   begin\n+      return End_Of_Data (Cur_Session);\n+   end End_Of_Data;\n+\n    -----------------\n    -- End_Of_File --\n    -----------------\n \n    function End_Of_File\n-     (Session : Session_Type := Current_Session) return Boolean\n+     (Session : Session_Type) return Boolean\n    is\n    begin\n       return Text_IO.End_Of_File (Session.Data.Current_File);\n    end End_Of_File;\n \n+   function End_Of_File\n+     return Boolean\n+   is\n+   begin\n+      return End_Of_File (Cur_Session);\n+   end End_Of_File;\n+\n    -----------\n    -- Field --\n    -----------\n \n    function Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return String\n+      Session : Session_Type) return String\n    is\n       Fields : Field_Table.Instance renames Session.Data.Fields;\n \n@@ -792,9 +848,16 @@ package body GNAT.AWK is\n       end if;\n    end Field;\n \n+   function Field\n+     (Rank    : Count) return String\n+   is\n+   begin\n+      return Field (Rank, Cur_Session);\n+   end Field;\n+\n    function Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return Integer\n+      Session : Session_Type) return Integer\n    is\n    begin\n       return Integer'Value (Field (Rank, Session));\n@@ -808,9 +871,16 @@ package body GNAT.AWK is\n             Session);\n    end Field;\n \n+   function Field\n+     (Rank    : Count) return Integer\n+   is\n+   begin\n+      return Field (Rank, Cur_Session);\n+   end Field;\n+\n    function Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return Float\n+      Session : Session_Type) return Float\n    is\n    begin\n       return Float'Value (Field (Rank, Session));\n@@ -824,12 +894,19 @@ package body GNAT.AWK is\n             Session);\n    end Field;\n \n+   function Field\n+     (Rank    : Count) return Float\n+   is\n+   begin\n+      return Field (Rank, Cur_Session);\n+   end Field;\n+\n    ----------\n    -- File --\n    ----------\n \n    function File\n-     (Session : Session_Type := Current_Session) return String\n+     (Session : Session_Type) return String\n    is\n       Files : File_Table.Instance renames Session.Data.Files;\n \n@@ -841,6 +918,13 @@ package body GNAT.AWK is\n       end if;\n    end File;\n \n+   function File\n+     return String\n+   is\n+   begin\n+      return File (Cur_Session);\n+   end File;\n+\n    --------------------\n    -- For_Every_Line --\n    --------------------\n@@ -849,7 +933,7 @@ package body GNAT.AWK is\n      (Separators : String        := Use_Current;\n       Filename   : String        := Use_Current;\n       Callbacks  : Callback_Mode := None;\n-      Session    : Session_Type  := Current_Session)\n+      Session    : Session_Type)\n    is\n       Quit : Boolean;\n \n@@ -879,13 +963,23 @@ package body GNAT.AWK is\n       Close (Session);\n    end For_Every_Line;\n \n+   procedure For_Every_Line_Current_Session\n+     (Separators : String        := Use_Current;\n+      Filename   : String        := Use_Current;\n+      Callbacks  : Callback_Mode := None)\n+   is\n+      procedure Do_It is new For_Every_Line (Action);\n+   begin\n+      Do_It (Separators, Filename, Callbacks, Cur_Session);\n+   end For_Every_Line_Current_Session;\n+\n    --------------\n    -- Get_Line --\n    --------------\n \n    procedure Get_Line\n      (Callbacks : Callback_Mode := None;\n-      Session   : Session_Type := Current_Session)\n+      Session   : Session_Type)\n    is\n       Filter_Active : Boolean;\n \n@@ -915,59 +1009,94 @@ package body GNAT.AWK is\n       end loop;\n    end Get_Line;\n \n+   procedure Get_Line\n+     (Callbacks : Callback_Mode := None)\n+   is\n+   begin\n+      Get_Line (Callbacks, Cur_Session);\n+   end Get_Line;\n+\n    ----------------------\n    -- Number_Of_Fields --\n    ----------------------\n \n    function Number_Of_Fields\n-     (Session : Session_Type := Current_Session) return Count\n+     (Session : Session_Type) return Count\n    is\n    begin\n       return Count (Field_Table.Last (Session.Data.Fields));\n    end Number_Of_Fields;\n \n+   function Number_Of_Fields\n+     return Count\n+   is\n+   begin\n+      return Number_Of_Fields (Cur_Session);\n+   end Number_Of_Fields;\n+\n    --------------------------\n    -- Number_Of_File_Lines --\n    --------------------------\n \n    function Number_Of_File_Lines\n-     (Session : Session_Type := Current_Session) return Count\n+     (Session : Session_Type) return Count\n    is\n    begin\n       return Count (Session.Data.FNR);\n    end Number_Of_File_Lines;\n \n+   function Number_Of_File_Lines\n+     return Count\n+   is\n+   begin\n+      return Number_Of_File_Lines (Cur_Session);\n+   end Number_Of_File_Lines;\n+\n    ---------------------\n    -- Number_Of_Files --\n    ---------------------\n \n    function Number_Of_Files\n-     (Session : Session_Type := Current_Session) return Natural\n+     (Session : Session_Type) return Natural\n    is\n       Files : File_Table.Instance renames Session.Data.Files;\n    begin\n       return File_Table.Last (Files);\n    end Number_Of_Files;\n \n+   function Number_Of_Files\n+     return Natural\n+   is\n+   begin\n+      return Number_Of_Files (Cur_Session);\n+   end Number_Of_Files;\n+\n    ---------------------\n    -- Number_Of_Lines --\n    ---------------------\n \n    function Number_Of_Lines\n-     (Session : Session_Type := Current_Session) return Count\n+     (Session : Session_Type) return Count\n    is\n    begin\n       return Count (Session.Data.NR);\n    end Number_Of_Lines;\n \n+   function Number_Of_Lines\n+     return Count\n+   is\n+   begin\n+      return Number_Of_Lines (Cur_Session);\n+   end Number_Of_Lines;\n+\n    ----------\n    -- Open --\n    ----------\n \n    procedure Open\n      (Separators : String       := Use_Current;\n       Filename   : String       := Use_Current;\n-      Session    : Session_Type := Current_Session)\n+      Session    : Session_Type)\n    is\n    begin\n       if Text_IO.Is_Open (Session.Data.Current_File) then\n@@ -990,12 +1119,20 @@ package body GNAT.AWK is\n          raise File_Error;\n    end Open;\n \n+   procedure Open\n+     (Separators : String       := Use_Current;\n+      Filename   : String       := Use_Current)\n+   is\n+   begin\n+      Open (Separators, Filename, Cur_Session);\n+   end Open;\n+\n    --------------------\n    -- Open_Next_File --\n    --------------------\n \n    procedure Open_Next_File\n-     (Session : Session_Type := Current_Session)\n+     (Session : Session_Type)\n    is\n       Files : File_Table.Instance renames Session.Data.Files;\n \n@@ -1025,7 +1162,7 @@ package body GNAT.AWK is\n    procedure Parse\n      (Separators : String       := Use_Current;\n       Filename   : String       := Use_Current;\n-      Session    : Session_Type := Current_Session)\n+      Session    : Session_Type)\n    is\n       Filter_Active : Boolean;\n       pragma Unreferenced (Filter_Active);\n@@ -1041,6 +1178,14 @@ package body GNAT.AWK is\n       Close (Session);\n    end Parse;\n \n+   procedure Parse\n+     (Separators : String       := Use_Current;\n+      Filename   : String       := Use_Current)\n+   is\n+   begin\n+      Parse (Separators, Filename, Cur_Session);\n+   end Parse;\n+\n    ---------------------\n    -- Raise_With_Info --\n    ---------------------\n@@ -1143,7 +1288,7 @@ package body GNAT.AWK is\n      (Field   : Count;\n       Pattern : String;\n       Action  : Action_Callback;\n-      Session : Session_Type := Current_Session)\n+      Session : Session_Type)\n    is\n       Filters   : Pattern_Action_Table.Instance renames Session.Data.Filters;\n       U_Pattern : constant Unbounded_String := To_Unbounded_String (Pattern);\n@@ -1156,11 +1301,20 @@ package body GNAT.AWK is\n          Action  => new Actions.Simple_Action'(Proc => Action));\n    end Register;\n \n+   procedure Register\n+     (Field   : Count;\n+      Pattern : String;\n+      Action  : Action_Callback)\n+   is\n+   begin\n+      Register (Field, Pattern, Action, Cur_Session);\n+   end Register;\n+\n    procedure Register\n      (Field   : Count;\n       Pattern : GNAT.Regpat.Pattern_Matcher;\n       Action  : Action_Callback;\n-      Session : Session_Type := Current_Session)\n+      Session : Session_Type)\n    is\n       Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n \n@@ -1174,11 +1328,20 @@ package body GNAT.AWK is\n          Action  => new Actions.Simple_Action'(Proc => Action));\n    end Register;\n \n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Action_Callback)\n+   is\n+   begin\n+      Register (Field, Pattern, Action, Cur_Session);\n+   end Register;\n+\n    procedure Register\n      (Field   : Count;\n       Pattern : GNAT.Regpat.Pattern_Matcher;\n       Action  : Match_Action_Callback;\n-      Session : Session_Type := Current_Session)\n+      Session : Session_Type)\n    is\n       Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n \n@@ -1192,10 +1355,19 @@ package body GNAT.AWK is\n          Action  => new Actions.Match_Action'(Proc => Action));\n    end Register;\n \n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Match_Action_Callback)\n+   is\n+   begin\n+      Register (Field, Pattern, Action, Cur_Session);\n+   end Register;\n+\n    procedure Register\n      (Pattern : Pattern_Callback;\n       Action  : Action_Callback;\n-      Session : Session_Type := Current_Session)\n+      Session : Session_Type)\n    is\n       Filters : Pattern_Action_Table.Instance renames Session.Data.Filters;\n \n@@ -1207,14 +1379,29 @@ package body GNAT.AWK is\n          Action  => new Actions.Simple_Action'(Proc => Action));\n    end Register;\n \n+   procedure Register\n+     (Pattern : Pattern_Callback;\n+      Action  : Action_Callback)\n+   is\n+   begin\n+      Register (Pattern, Action, Cur_Session);\n+   end Register;\n+\n    procedure Register\n      (Action  : Action_Callback;\n-      Session : Session_Type := Current_Session)\n+      Session : Session_Type)\n    is\n    begin\n       Register (Always_True'Access, Action, Session);\n    end Register;\n \n+   procedure Register\n+     (Action  : Action_Callback)\n+   is\n+   begin\n+      Register (Action, Cur_Session);\n+   end Register;\n+\n    -----------------\n    -- Set_Current --\n    -----------------\n@@ -1230,7 +1417,7 @@ package body GNAT.AWK is\n \n    procedure Set_Field_Separators\n      (Separators : String       := Default_Separators;\n-      Session    : Session_Type := Current_Session)\n+      Session    : Session_Type)\n    is\n    begin\n       Free (Session.Data.Separators);\n@@ -1246,13 +1433,20 @@ package body GNAT.AWK is\n       end if;\n    end Set_Field_Separators;\n \n+   procedure Set_Field_Separators\n+     (Separators : String       := Default_Separators)\n+   is\n+   begin\n+      Set_Field_Separators (Separators, Cur_Session);\n+   end Set_Field_Separators;\n+\n    ----------------------\n    -- Set_Field_Widths --\n    ----------------------\n \n    procedure Set_Field_Widths\n      (Field_Widths : Widths_Set;\n-      Session      : Session_Type := Current_Session)\n+      Session      : Session_Type)\n    is\n    begin\n       Free (Session.Data.Separators);\n@@ -1268,6 +1462,13 @@ package body GNAT.AWK is\n       end if;\n    end Set_Field_Widths;\n \n+   procedure Set_Field_Widths\n+     (Field_Widths : Widths_Set)\n+   is\n+   begin\n+      Set_Field_Widths (Field_Widths, Cur_Session);\n+   end Set_Field_Widths;\n+\n    ----------------\n    -- Split_Line --\n    ----------------"}, {"sha": "a854489a8e258f91abbbec4afde826f5dd3110e5", "filename": "gcc/ada/g-awk.ads", "status": "modified", "additions": 106, "deletions": 32, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fg-awk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fg-awk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.ads?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2005, AdaCore                     --\n+--                     Copyright (C) 2000-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@\n --  that a record cannot span multiple lines. The operating procedure is to\n --  read files line by line, with each line being presented to the user of\n --  the package. The interface provides services to access specific fields\n---  in the line. Thus it is possible to control actions takn on a line based\n+--  in the line. Thus it is possible to control actions taken on a line based\n --  on values of some fields. This can be achieved directly or by registering\n --  callbacks triggered on programmed conditions.\n --\n@@ -83,8 +83,8 @@\n --\n --        Examples of these three approaches appear below\n --\n---  There is many ways to use this package. The following discussion shows\n---  three approaches, using the three iterator forms, to using this package.\n+--  There are many ways to use this package. The following discussion shows\n+--  three approaches to using this package, using the three iterator forms.\n --  All examples will use the following file (computer.db):\n --\n --     Pluton;Windows-NT;Pentium III\n@@ -242,7 +242,9 @@ package GNAT.AWK is\n \n    procedure Set_Field_Separators\n      (Separators : String       := Default_Separators;\n-      Session    : Session_Type := Current_Session);\n+      Session    : Session_Type);\n+   procedure Set_Field_Separators\n+     (Separators : String       := Default_Separators);\n    --  Set the field separators. Each character in the string is a field\n    --  separator. When a line is read it will be split by field using the\n    --  separators set here. Separators can be changed at any point and in this\n@@ -253,13 +255,18 @@ package GNAT.AWK is\n \n    procedure Set_FS\n      (Separators : String       := Default_Separators;\n-      Session    : Session_Type := Current_Session)\n+      Session    : Session_Type)\n+     renames Set_Field_Separators;\n+   procedure Set_FS\n+     (Separators : String       := Default_Separators)\n      renames Set_Field_Separators;\n    --  FS is the AWK abbreviation for above service\n \n    procedure Set_Field_Widths\n      (Field_Widths : Widths_Set;\n-      Session      : Session_Type := Current_Session);\n+      Session      : Session_Type);\n+   procedure Set_Field_Widths\n+     (Field_Widths : Widths_Set);\n    --  This is another way to split a line by giving the length (in number of\n    --  characters) of each field in a line. Field widths can be changed at any\n    --  point and in this case the current line is split according to the new\n@@ -270,7 +277,9 @@ package GNAT.AWK is\n \n    procedure Add_File\n      (Filename : String;\n-      Session  : Session_Type := Current_Session);\n+      Session  : Session_Type);\n+   procedure Add_File\n+     (Filename : String);\n    --  Add Filename to the list of file to be processed. There is no limit on\n    --  the number of files that can be added. Files are processed in the order\n    --  they have been added (i.e. the filename list is FIFO). If Filename does\n@@ -280,7 +289,11 @@ package GNAT.AWK is\n      (Directory             : String;\n       Filenames             : String;\n       Number_Of_Files_Added : out Natural;\n-      Session               : Session_Type := Current_Session);\n+      Session               : Session_Type);\n+   procedure Add_Files\n+     (Directory             : String;\n+      Filenames             : String;\n+      Number_Of_Files_Added : out Natural);\n    --  Add all files matching the regular expression Filenames in the specified\n    --  directory to the list of file to be processed. There is no limit on\n    --  the number of files that can be added. Each file is processed in\n@@ -293,44 +306,60 @@ package GNAT.AWK is\n    -------------------------------------\n \n    function Number_Of_Fields\n-     (Session : Session_Type := Current_Session) return Count;\n+     (Session : Session_Type) return Count;\n+   function Number_Of_Fields\n+     return Count;\n    pragma Inline (Number_Of_Fields);\n    --  Returns the number of fields in the current record. It returns 0 when\n    --  no file is being processed.\n \n    function NF\n-     (Session : Session_Type := Current_Session) return Count\n+     (Session : Session_Type) return Count\n+     renames Number_Of_Fields;\n+   function NF\n+     return Count\n      renames Number_Of_Fields;\n    --  AWK abbreviation for above service\n \n    function Number_Of_File_Lines\n-     (Session : Session_Type := Current_Session) return Count;\n+     (Session : Session_Type) return Count;\n+   function Number_Of_File_Lines\n+     return Count;\n    pragma Inline (Number_Of_File_Lines);\n    --  Returns the current line number in the processed file. It returns 0 when\n    --  no file is being processed.\n \n-   function FNR (Session : Session_Type := Current_Session) return Count\n+   function FNR (Session : Session_Type) return Count\n+     renames Number_Of_File_Lines;\n+   function FNR return Count\n      renames Number_Of_File_Lines;\n    --  AWK abbreviation for above service\n \n    function Number_Of_Lines\n-     (Session : Session_Type := Current_Session) return Count;\n+     (Session : Session_Type) return Count;\n+   function Number_Of_Lines\n+     return Count;\n    pragma Inline (Number_Of_Lines);\n    --  Returns the number of line processed until now. This is equal to number\n    --  of line in each already processed file plus FNR. It returns 0 when\n    --  no file is being processed.\n \n-   function NR (Session : Session_Type := Current_Session) return Count\n+   function NR (Session : Session_Type) return Count\n+     renames Number_Of_Lines;\n+   function NR return Count\n      renames Number_Of_Lines;\n    --  AWK abbreviation for above service\n \n    function Number_Of_Files\n-     (Session : Session_Type := Current_Session) return Natural;\n+     (Session : Session_Type) return Natural;\n+   function Number_Of_Files\n+     return Natural;\n    pragma Inline (Number_Of_Files);\n    --  Returns the number of files associated with Session. This is the total\n    --  number of files added with Add_File and Add_Files services.\n \n-   function File (Session : Session_Type := Current_Session) return String;\n+   function File (Session : Session_Type) return String;\n+   function File return String;\n    --  Returns the name of the file being processed. It returns the empty\n    --  string when no file is being processed.\n \n@@ -340,21 +369,27 @@ package GNAT.AWK is\n \n    function Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return String;\n+      Session : Session_Type) return String;\n+   function Field\n+     (Rank    : Count) return String;\n    --  Returns field number Rank value of the current record. If Rank = 0 it\n    --  returns the current record (i.e. the line as read in the file). It\n    --  raises Field_Error if Rank > NF or if Session is not open.\n \n    function Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return Integer;\n+      Session : Session_Type) return Integer;\n+   function Field\n+     (Rank    : Count) return Integer;\n    --  Returns field number Rank value of the current record as an integer. It\n    --  raises Field_Error if Rank > NF or if Session is not open. It\n    --  raises Data_Error if the field value cannot be converted to an integer.\n \n    function Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return Float;\n+      Session : Session_Type) return Float;\n+   function Field\n+     (Rank    : Count) return Float;\n    --  Returns field number Rank value of the current record as a float. It\n    --  raises Field_Error if Rank > NF or if Session is not open. It\n    --  raises Data_Error if the field value cannot be converted to a float.\n@@ -363,7 +398,11 @@ package GNAT.AWK is\n       type Discrete is (<>);\n    function Discrete_Field\n      (Rank    : Count;\n-      Session : Session_Type := Current_Session) return Discrete;\n+      Session : Session_Type) return Discrete;\n+   generic\n+      type Discrete is (<>);\n+   function Discrete_Field_Current_Session\n+     (Rank    : Count) return Discrete;\n    --  Returns field number Rank value of the current record as a type\n    --  Discrete. It raises Field_Error if Rank > NF. It raises Data_Error if\n    --  the field value cannot be converted to type Discrete.\n@@ -398,31 +437,46 @@ package GNAT.AWK is\n      (Field   : Count;\n       Pattern : String;\n       Action  : Action_Callback;\n-      Session : Session_Type := Current_Session);\n+      Session : Session_Type);\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : String;\n+      Action  : Action_Callback);\n    --  Register an Action associated with a Pattern. The pattern here is a\n    --  simple string that must match exactly the field number specified.\n \n    procedure Register\n      (Field   : Count;\n       Pattern : GNAT.Regpat.Pattern_Matcher;\n       Action  : Action_Callback;\n-      Session : Session_Type := Current_Session);\n+      Session : Session_Type);\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Action_Callback);\n    --  Register an Action associated with a Pattern. The pattern here is a\n    --  simple regular expression which must match the field number specified.\n \n    procedure Register\n      (Field   : Count;\n       Pattern : GNAT.Regpat.Pattern_Matcher;\n       Action  : Match_Action_Callback;\n-      Session : Session_Type := Current_Session);\n+      Session : Session_Type);\n+   procedure Register\n+     (Field   : Count;\n+      Pattern : GNAT.Regpat.Pattern_Matcher;\n+      Action  : Match_Action_Callback);\n    --  Same as above but it pass the set of matches to the action\n    --  procedure. This is useful to analyse further why and where a regular\n    --  expression did match.\n \n    procedure Register\n      (Pattern : Pattern_Callback;\n       Action  : Action_Callback;\n-      Session : Session_Type := Current_Session);\n+      Session : Session_Type);\n+   procedure Register\n+     (Pattern : Pattern_Callback;\n+      Action  : Action_Callback);\n    --  Register an Action associated with a Pattern. The pattern here is a\n    --  function that must return a boolean. Action callback will be called if\n    --  the pattern callback returns True and nothing will happen if it is\n@@ -431,7 +485,9 @@ package GNAT.AWK is\n \n    procedure Register\n      (Action  : Action_Callback;\n-      Session : Session_Type := Current_Session);\n+      Session : Session_Type);\n+   procedure Register\n+     (Action  : Action_Callback);\n    --  Register an Action that will be called for every line. This is\n    --  equivalent to a Pattern_Callback function always returning True.\n \n@@ -442,7 +498,10 @@ package GNAT.AWK is\n    procedure Parse\n      (Separators : String := Use_Current;\n       Filename   : String := Use_Current;\n-      Session    : Session_Type := Current_Session);\n+      Session    : Session_Type);\n+   procedure Parse\n+     (Separators : String := Use_Current;\n+      Filename   : String := Use_Current);\n    --  Launch the iterator, it will read every line in all specified\n    --  session's files. Registered callbacks are then called if the associated\n    --  pattern match. It is possible to specify a filename and a set of\n@@ -482,7 +541,10 @@ package GNAT.AWK is\n    procedure Open\n      (Separators : String := Use_Current;\n       Filename   : String := Use_Current;\n-      Session    : Session_Type := Current_Session);\n+      Session    : Session_Type);\n+   procedure Open\n+     (Separators : String := Use_Current;\n+      Filename   : String := Use_Current);\n    --  Open the first file and initialize the unit. This must be called once\n    --  before using Get_Line. It is possible to specify a filename and a set of\n    --  separators directly. This offer a quick way to parse a single file.\n@@ -493,7 +555,9 @@ package GNAT.AWK is\n \n    procedure Get_Line\n      (Callbacks : Callback_Mode := None;\n-      Session   : Session_Type  := Current_Session);\n+      Session   : Session_Type);\n+   procedure Get_Line\n+     (Callbacks : Callback_Mode := None);\n    --  Read a line from the current input file. If the file index is at the\n    --  end of the current input file (i.e. End_Of_File is True) then the\n    --  following file is opened. If there is no more file to be processed,\n@@ -512,14 +576,18 @@ package GNAT.AWK is\n    --  or by an instantiation of For_Every_Line (see below).\n \n    function End_Of_Data\n-     (Session : Session_Type := Current_Session) return Boolean;\n+     (Session : Session_Type) return Boolean;\n+   function End_Of_Data\n+     return Boolean;\n    pragma Inline (End_Of_Data);\n    --  Returns True if there is no more data to be processed in Session. It\n    --  means that the latest session's file is being processed and that\n    --  there is no more data to be read in this file (End_Of_File is True).\n \n    function End_Of_File\n-     (Session : Session_Type := Current_Session) return Boolean;\n+     (Session : Session_Type) return Boolean;\n+   function End_Of_File\n+     return Boolean;\n    pragma Inline (End_Of_File);\n    --  Returns True when there is no more data to be processed on the current\n    --  session's file.\n@@ -542,7 +610,13 @@ package GNAT.AWK is\n      (Separators : String := Use_Current;\n       Filename   : String := Use_Current;\n       Callbacks  : Callback_Mode := None;\n-      Session    : Session_Type := Current_Session);\n+      Session    : Session_Type);\n+   generic\n+      with procedure Action (Quit : in out Boolean);\n+   procedure For_Every_Line_Current_Session\n+     (Separators : String := Use_Current;\n+      Filename   : String := Use_Current;\n+      Callbacks  : Callback_Mode := None);\n    --  This is another iterator. Action will be called for each new\n    --  record. The iterator's termination can be controlled by setting Quit\n    --  to True. It is by default set to False. It is possible to specify a"}, {"sha": "e86d378f1dc8a16905914bb894057d6d90b3d8ba", "filename": "gcc/ada/g-moreex.adb", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fg-moreex.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fg-moreex.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-moreex.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2005, AdaCore                     --\n+--                     Copyright (C) 2000-2006, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,20 +40,39 @@ package body GNAT.Most_Recent_Exception is\n    -- Occurrence --\n    ----------------\n \n-   function Occurrence\n-     return Ada.Exceptions.Exception_Occurrence\n-   is\n+   function Occurrence return Ada.Exceptions.Exception_Occurrence is\n       EOA : constant Ada.Exceptions.Exception_Occurrence_Access :=\n               GNAT.Most_Recent_Exception.Occurrence_Access;\n \n       use type Ada.Exceptions.Exception_Occurrence_Access;\n \n    begin\n+      pragma Warnings (Off);\n       if EOA = null then\n          return Ada.Exceptions.Null_Occurrence;\n       else\n          return EOA.all;\n       end if;\n+      pragma Warnings (On);\n+\n+      --  ???Note that both of the above return statements violate the Ada\n+      --  2005 rule forbidding copying of limited objects (see RM-7.5(2.8/2)).\n+      --  When compiled with -gnatg, the compiler gives a warning instead of\n+      --  an error, so we can turn it off.\n+      --  To fix this, remove the pragmas Warnings above, and use the following\n+      --  code. We can't do that yet, because AI-318 is not yet implemented.\n+      --\n+      --  return Result : Ada.Exceptions.Exception_Occurrence do\n+      --     if EOA = null then\n+      --        Ada.Exceptions.Save_Occurrence\n+      --          (Target => Result,\n+      --           Source => Ada.Exceptions.Null_Occurrence);\n+      --     else\n+      --        Ada.Exceptions.Save_Occurrence\n+      --          (Target => Result,\n+      --           Source => EOA.all);\n+      --     end if;\n+      --  end return;\n    end Occurrence;\n \n    -----------------------"}, {"sha": "c569dfcf5fa64742b301fc79d866602d2282c8fa", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1998-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -441,30 +441,32 @@ package Lib.Xref is\n       E_Limited_Private_Subtype                    => '+',\n \n       E_Incomplete_Type                            => '+',\n+      E_Incomplete_Subtype                         => '+',\n       E_Task_Type                                  => 'T',\n       E_Task_Subtype                               => 'T',\n       E_Protected_Type                             => 'W',\n-      E_Protected_Subtype                          => 'W',\n \n+      E_Protected_Subtype                          => 'W',\n       E_Exception_Type                             => ' ',\n       E_Subprogram_Type                            => ' ',\n       E_Enumeration_Literal                        => 'n',\n       E_Function                                   => 'V',\n-      E_Operator                                   => 'V',\n \n+      E_Operator                                   => 'V',\n       E_Procedure                                  => 'U',\n       E_Entry                                      => 'Y',\n       E_Entry_Family                               => 'Y',\n       E_Block                                      => 'q',\n-      E_Entry_Index_Parameter                      => '*',\n \n+      E_Entry_Index_Parameter                      => '*',\n       E_Exception                                  => 'X',\n       E_Generic_Function                           => 'v',\n       E_Generic_Package                            => 'k',\n       E_Generic_Procedure                          => 'u',\n-      E_Label                                      => 'L',\n \n+      E_Label                                      => 'L',\n       E_Loop                                       => 'l',\n+      E_Return_Statement                           => ' ',\n       E_Package                                    => 'K',\n \n       --  The following entities are not ones to which we gather"}, {"sha": "220c0656eb548546031f45a0063e4606cc2bc35d", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1247,12 +1247,12 @@ package body Ch4 is\n          --  Expression case\n \n          elsif Token = Tok_Right_Paren or else Token in Token_Class_Eterm then\n-\n             if Nkind (Expr_Node) = N_Attribute_Reference\n               and then Attribute_Name (Expr_Node) = Name_Range\n             then\n-               Bad_Range_Attribute (Sloc (Expr_Node));\n-               return Error;\n+               Error_Msg\n+                 (\"|parentheses not allowed for range attribute\", Lparen_Sloc);\n+               return Expr_Node;\n             end if;\n \n             --  Bump paren count of expression, note that if the paren count\n@@ -1563,6 +1563,8 @@ package body Ch4 is\n    --  called in all contexts where a right parenthesis cannot legitimately\n    --  follow an expression.\n \n+   --  Error recovery: can raise Error_Resync\n+\n    function P_Expression_No_Right_Paren return Node_Id is\n    begin\n       return No_Right_Paren (P_Expression);"}, {"sha": "d8f7fdab998900cd9bee41baff8fa220187c0df3", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 190, "deletions": 11, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -37,6 +37,12 @@ package body Ch6 is\n \n    function P_Defining_Designator        return Node_Id;\n    function P_Defining_Operator_Symbol   return Node_Id;\n+   function P_Return_Object_Declaration  return Node_Id;\n+\n+   procedure P_Return_Subtype_Indication (Decl_Node : Node_Id);\n+   --  Decl_Node is a N_Object_Declaration.\n+   --  Set the Null_Exclusion_Present and Object_Definition fields of\n+   --  Decl_Node.\n \n    procedure Check_Junk_Semicolon_Before_Return;\n \n@@ -1285,36 +1291,209 @@ package body Ch6 is\n    -- 6.5  Return Statement --\n    ---------------------------\n \n+   --  SIMPLE_RETURN_STATEMENT ::= return [EXPRESSION];\n+   --\n+   --  EXTENDED_RETURN_STATEMENT ::=\n+   --    return DEFINING_IDENTIFIER : [aliased] RETURN_SUBTYPE_INDICATION\n+   --                                           [:= EXPRESSION] [do\n+   --      HANDLED_SEQUENCE_OF_STATEMENTS\n+   --    end return];\n+   --\n+   --  RETURN_SUBTYPE_INDICATION ::= SUBTYPE_INDICATION | ACCESS_DEFINITION\n+\n    --  RETURN_STATEMENT ::= return [EXPRESSION];\n \n-   --  The caller has checked that the initial token is RETURN\n+   --  Error recovery: can raise Error_Resync\n+\n+   procedure P_Return_Subtype_Indication (Decl_Node : Node_Id) is\n+\n+      --  Note: We don't need to check Ada_Version here, because this is\n+      --  only called in >= Ada 2005 cases anyway.\n+\n+      Not_Null_Present : constant Boolean := P_Null_Exclusion;\n+\n+   begin\n+      Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n+\n+      if Token = Tok_Access then\n+         Set_Object_Definition\n+           (Decl_Node, P_Access_Definition (Not_Null_Present));\n+      else\n+         Set_Object_Definition\n+           (Decl_Node, P_Subtype_Indication (Not_Null_Present));\n+      end if;\n+   end P_Return_Subtype_Indication;\n+\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Return_Object_Declaration return Node_Id is\n+      Return_Obj : Node_Id;\n+      Decl_Node  : Node_Id;\n+\n+   begin\n+      Return_Obj := Token_Node;\n+      Change_Identifier_To_Defining_Identifier (Return_Obj);\n+      Decl_Node := New_Node (N_Object_Declaration, Token_Ptr);\n+      Set_Defining_Identifier (Decl_Node, Return_Obj);\n+\n+      Scan; -- past identifier\n+      Scan; -- past :\n+\n+      --  First an error check, if we have two identifiers in a row, a likely\n+      --  possibility is that the first of the identifiers is an incorrectly\n+      --  spelled keyword. See similar check in P_Identifier_Declarations.\n+\n+      if Token = Tok_Identifier then\n+         declare\n+            SS : Saved_Scan_State;\n+            I2 : Boolean;\n+\n+         begin\n+            Save_Scan_State (SS);\n+            Scan; -- past initial identifier\n+            I2 := (Token = Tok_Identifier);\n+            Restore_Scan_State (SS);\n+\n+            if I2\n+              and then\n+                (Bad_Spelling_Of (Tok_Access)   or else\n+                 Bad_Spelling_Of (Tok_Aliased)  or else\n+                 Bad_Spelling_Of (Tok_Constant))\n+            then\n+               null;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  We allow \"constant\" here (as in \"return Result : constant\n+      --  T...\"). This is not in the latest RM, but the ARG is considering an\n+      --  AI on the subject (see AI05-0015-1), which we expect to be approved.\n+\n+      if Token = Tok_Constant then\n+         Scan; -- past CONSTANT\n+         Set_Constant_Present (Decl_Node);\n+\n+         if Token = Tok_Aliased then\n+            Error_Msg_SC (\"ALIASED should be before CONSTANT\");\n+            Scan; -- past ALIASED\n+            Set_Aliased_Present (Decl_Node);\n+         end if;\n+\n+      elsif Token = Tok_Aliased then\n+         Scan; -- past ALIASED\n+         Set_Aliased_Present (Decl_Node);\n+\n+         if Token = Tok_Constant then\n+            Scan; -- past CONSTANT\n+            Set_Constant_Present (Decl_Node);\n+         end if;\n+      end if;\n+\n+      P_Return_Subtype_Indication (Decl_Node);\n+\n+      if Token = Tok_Colon_Equal then\n+         Scan; -- past :=\n+         Set_Expression (Decl_Node, P_Expression_No_Right_Paren);\n+      end if;\n+\n+      return Decl_Node;\n+   end P_Return_Object_Declaration;\n \n    --  Error recovery: can raise Error_Resync\n \n    function P_Return_Statement return Node_Id is\n+      --  The caller has checked that the initial token is RETURN\n+\n+      function Is_Simple return Boolean;\n+      --  Scan state is just after RETURN (and is left that way).\n+      --  Determine whether this is a simple or extended return statement\n+      --  by looking ahead for \"identifier :\", which implies extended.\n+\n+      ---------------\n+      -- Is_Simple --\n+      ---------------\n+\n+      function Is_Simple return Boolean is\n+         Scan_State : Saved_Scan_State;\n+         Result     : Boolean := True;\n+\n+      begin\n+         if Token = Tok_Identifier then\n+            Save_Scan_State (Scan_State); -- at identifier\n+            Scan; -- past identifier\n+\n+            if Token = Tok_Colon then\n+               Result := False; -- It's an extended_return_statement.\n+            end if;\n+\n+            Restore_Scan_State (Scan_State); -- to identifier\n+         end if;\n+\n+         return Result;\n+      end Is_Simple;\n+\n+      Return_Sloc : constant Source_Ptr := Token_Ptr;\n       Return_Node : Node_Id;\n \n+   --  Start of processing for P_Return_Statement\n+\n    begin\n-      Return_Node := New_Node (N_Return_Statement, Token_Ptr);\n+      Scan; -- past RETURN\n \n-      --  Sloc points to RETURN\n-      --  Expression (Op3)\n+      --  Simple_return_statement, no expression, return an N_Return_Statement\n+      --  node with the expression field left Empty.\n \n-      Scan; -- past RETURN\n+      if Token = Tok_Semicolon then\n+         Scan; -- past ;\n+         Return_Node := New_Node (N_Return_Statement, Return_Sloc);\n \n-      if Token /= Tok_Semicolon then\n+      --  Non-simple case\n \n-         --  If no semicolon, then scan an expression, except that\n-         --  we avoid trying to scan an expression if we are at an\n+      else\n+         --  Simple_return_statement with expression\n+\n+         --  We avoid trying to scan an expression if we are at an\n          --  expression terminator since in that case the best error\n          --  message is probably that we have a missing semicolon.\n \n-         if Token not in Token_Class_Eterm then\n-            Set_Expression (Return_Node, P_Expression_No_Right_Paren);\n+         if Is_Simple then\n+            Return_Node := New_Node (N_Return_Statement, Return_Sloc);\n+\n+            if Token not in Token_Class_Eterm then\n+               Set_Expression (Return_Node, P_Expression_No_Right_Paren);\n+            end if;\n+\n+         --  Extended_return_statement (Ada 2005 only -- AI-318):\n+\n+         else\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_SP\n+                 (\" extended_return_statement is an Ada 2005 extension\");\n+               Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+            end if;\n+\n+            Return_Node := New_Node (N_Extended_Return_Statement, Return_Sloc);\n+            Set_Return_Object_Declarations\n+              (Return_Node, New_List (P_Return_Object_Declaration));\n+\n+            if Token = Tok_Do then\n+               Push_Scope_Stack;\n+               Scope.Table (Scope.Last).Etyp := E_Return;\n+               Scope.Table (Scope.Last).Ecol := Start_Column;\n+               Scope.Table (Scope.Last).Sloc := Return_Sloc;\n+\n+               Scan; -- past DO\n+               Set_Handled_Statement_Sequence\n+                 (Return_Node, P_Handled_Sequence_Of_Statements);\n+               End_Statements;\n+\n+               --  Do we need to handle Error_Resync here???\n+            end if;\n          end if;\n+\n+         TF_Semicolon;\n       end if;\n \n-      TF_Semicolon;\n       return Return_Node;\n    end P_Return_Statement;\n "}, {"sha": "a6d5297799a96e537c053d27a613a9d2620f99e4", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -219,6 +219,10 @@ package body Endh is\n             End_Type := E_Record;\n             Scan; -- past RECORD\n \n+         elsif Token = Tok_Return then\n+            End_Type := E_Return;\n+            Scan; -- past RETURN\n+\n          elsif Token = Tok_Select then\n             End_Type := E_Select;\n             Scan; -- past SELECT\n@@ -800,6 +804,9 @@ package body Endh is\n       elsif End_Type = E_Record then\n          Error_Msg_SC (\"no RECORD for this `END RECORD`!\");\n \n+      elsif End_Type = E_Return then\n+         Error_Msg_SC (\"no RETURN for this `END RETURN`!\");\n+\n       elsif End_Type = E_Select then\n          Error_Msg_SC (\"no SELECT for this `END SELECT`!\");\n \n@@ -859,6 +866,10 @@ package body Endh is\n          Error_Msg_SC\n            (\"`END RECORD;` expected@ for RECORD#!\");\n \n+      elsif End_Type = E_Return then\n+         Error_Msg_SC\n+           (\"`END RETURN;` expected@ for RETURN#!\");\n+\n       elsif End_Type = E_Select then\n          Error_Msg_SC\n            (\"`END SELECT;` expected@ for SELECT#!\");\n@@ -924,6 +935,10 @@ package body Endh is\n          Error_Msg_SC\n            (\"missing `END RECORD;` for RECORD#!\");\n \n+      elsif End_Type = E_Return then\n+         Error_Msg_SC\n+           (\"missing `END RETURN;` for RETURN#!\");\n+\n       elsif End_Type = E_Select then\n          Error_Msg_BC\n            (\"missing `END SELECT;` for SELECT#!\");"}, {"sha": "fabb9ea724f0658bb00b89b94864186237839184", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -433,6 +433,7 @@ is\n        E_If,              -- END IF;\n        E_Loop,            -- END LOOP;\n        E_Record,          -- END RECORD;\n+       E_Return,          -- END RETURN;\n        E_Select,          -- END SELECT;\n        E_Name,            -- END [name];\n        E_Suspicious_Is,   -- END [name]; (case of suspicious IS)\n@@ -604,13 +605,16 @@ is\n       --  declaration of this type for details.\n \n       function P_Interface_Type_Definition\n-        (Is_Synchronized : Boolean) return Node_Id;\n-      --  Ada 2005 (AI-251): Parse the interface type definition part. The\n-      --  parameter Is_Synchronized is True in case of task interfaces,\n-      --  protected interfaces, and synchronized interfaces; it is used to\n-      --  generate a record_definition node. In the rest of cases (limited\n-      --  interfaces and interfaces) we generate a record_definition node if\n-      --  the list of interfaces is empty; otherwise we generate a\n+        (Abstract_Present : Boolean;\n+         Is_Synchronized  : Boolean) return Node_Id;\n+      --  Ada 2005 (AI-251): Parse the interface type definition part. Abstract\n+      --  Present indicates if the reserved word \"abstract\" has been previously\n+      --  found. It is used to report an error message because interface types\n+      --  are by definition abstract tagged. Is_Synchronized is True in case of\n+      --  task interfaces, protected interfaces, and synchronized interfaces;\n+      --  it is used to generate a record_definition node. In the rest of cases\n+      --  (limited interfaces and interfaces) we generate a record_definition\n+      --  node if the list of interfaces is empty; otherwise we generate a\n       --  derived_type_definition node (the first interface in this list is the\n       --  ancestor interface).\n \n@@ -1349,7 +1353,7 @@ begin\n                      Uname : constant String :=\n                                Get_Name_String\n                                  (Unit_Name (Current_Source_Unit));\n-                     Name : String (1 .. Uname'Length - 2);\n+                     Name  : String (1 .. Uname'Length - 2);\n \n                   begin\n                      --  Because Unit_Name includes \"%s\" or \"%b\", we need to"}, {"sha": "49cf8fc9f5ef260e6275fbe4ebf8253bb6a39a44", "filename": "gcc/ada/s-auxdec-vms_64.ads", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fs-auxdec-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fs-auxdec-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms_64.ads?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2006 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -76,7 +76,7 @@ package System.Aux_DEC is\n \n    type Largest_Integer is range Min_Int .. Max_Int;\n \n-   type AST_Handler is limited private;\n+   type AST_Handler is private;\n \n    No_AST_Handler : constant AST_Handler;\n \n@@ -298,17 +298,17 @@ package System.Aux_DEC is\n    procedure Clear_Interlocked\n      (Bit          : in out Boolean;\n       Old_Value    : out Boolean;\n-      Retry_Count  : in Natural;\n+      Retry_Count  : Natural;\n       Success_Flag : out Boolean);\n \n    procedure Set_Interlocked\n      (Bit          : in out Boolean;\n       Old_Value    : out Boolean;\n-      Retry_Count  : in Natural;\n+      Retry_Count  : Natural;\n       Success_Flag : out Boolean);\n \n    procedure Add_Interlocked\n-     (Addend       : in Short_Integer;\n+     (Addend       : Short_Integer;\n       Augend       : in out Aligned_Word;\n       Sign         : out Integer);\n \n@@ -332,67 +332,67 @@ package System.Aux_DEC is\n \n    procedure Add_Atomic\n      (To           : in out Aligned_Integer;\n-      Amount       : in Integer);\n+      Amount       : Integer);\n \n    procedure Add_Atomic\n      (To           : in out Aligned_Integer;\n-      Amount       : in Integer;\n-      Retry_Count  : in Natural;\n+      Amount       : Integer;\n+      Retry_Count  : Natural;\n       Old_Value    : out Integer;\n       Success_Flag : out Boolean);\n \n    procedure Add_Atomic\n      (To           : in out Aligned_Long_Integer;\n-      Amount       : in Long_Integer);\n+      Amount       : Long_Integer);\n \n    procedure Add_Atomic\n      (To           : in out Aligned_Long_Integer;\n-      Amount       : in Long_Integer;\n-      Retry_Count  : in Natural;\n+      Amount       : Long_Integer;\n+      Retry_Count  : Natural;\n       Old_Value    : out Long_Integer;\n       Success_Flag : out Boolean);\n \n    procedure And_Atomic\n      (To           : in out Aligned_Integer;\n-      From         : in Integer);\n+      From         : Integer);\n \n    procedure And_Atomic\n      (To           : in out Aligned_Integer;\n-      From         : in Integer;\n-      Retry_Count  : in Natural;\n+      From         : Integer;\n+      Retry_Count  : Natural;\n       Old_Value    : out Integer;\n       Success_Flag : out Boolean);\n \n    procedure And_Atomic\n      (To           : in out Aligned_Long_Integer;\n-      From         : in Long_Integer);\n+      From         : Long_Integer);\n \n    procedure And_Atomic\n      (To           : in out Aligned_Long_Integer;\n-      From         : in Long_Integer;\n-      Retry_Count  : in Natural;\n+      From         : Long_Integer;\n+      Retry_Count  : Natural;\n       Old_Value    : out Long_Integer;\n       Success_Flag : out Boolean);\n \n    procedure Or_Atomic\n      (To           : in out Aligned_Integer;\n-      From         : in Integer);\n+      From         : Integer);\n \n    procedure Or_Atomic\n      (To           : in out Aligned_Integer;\n-      From         : in Integer;\n-      Retry_Count  : in Natural;\n+      From         : Integer;\n+      Retry_Count  : Natural;\n       Old_Value    : out Integer;\n       Success_Flag : out Boolean);\n \n    procedure Or_Atomic\n      (To           : in out Aligned_Long_Integer;\n-      From         : in Long_Integer);\n+      From         : Long_Integer);\n \n    procedure Or_Atomic\n      (To           : in out Aligned_Long_Integer;\n-      From         : in Long_Integer;\n-      Retry_Count  : in Natural;\n+      From         : Long_Integer;\n+      Retry_Count  : Natural;\n       Old_Value    : out Long_Integer;\n       Success_Flag : out Boolean);\n \n@@ -417,22 +417,22 @@ package System.Aux_DEC is\n       OK_Empty       => +2);\n \n    procedure Insqhi\n-     (Item   : in  Address;\n-      Header : in  Address;\n+     (Item   : Address;\n+      Header : Address;\n       Status : out Insq_Status);\n \n    procedure Remqhi\n-     (Header : in  Address;\n+     (Header : Address;\n       Item   : out Address;\n       Status : out Remq_Status);\n \n    procedure Insqti\n-     (Item   : in  Address;\n-      Header : in  Address;\n+     (Item   : Address;\n+      Header : Address;\n       Status : out Insq_Status);\n \n    procedure Remqti\n-     (Header : in  Address;\n+     (Header : Address;\n       Item   : out Address;\n       Status : out Remq_Status);\n "}, {"sha": "f8238a44e19382319f07eaaf57986be5a74dc932", "filename": "gcc/ada/s-auxdec.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fs-auxdec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fs-auxdec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec.ads?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -66,7 +66,7 @@ package System.Aux_DEC is\n \n    type Largest_Integer is range Min_Int .. Max_Int;\n \n-   type AST_Handler is limited private;\n+   type AST_Handler is private;\n \n    No_AST_Handler : constant AST_Handler;\n "}, {"sha": "8c5a2a569e3e32d4eabb1e0c25ac09aae5ea2d4f", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -184,6 +184,9 @@ package body Sem is\n          when N_Explicit_Dereference =>\n             Analyze_Explicit_Dereference (N);\n \n+         when N_Extended_Return_Statement =>\n+            Analyze_Extended_Return_Statement (N);\n+\n          when N_Extension_Aggregate =>\n             Analyze_Aggregate (N);\n "}, {"sha": "3ee19151372cfa71b16d6c3a965a620f7425ab36", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 42, "deletions": 62, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -40,6 +40,7 @@ with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n+with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n@@ -450,8 +451,12 @@ package body Sem_Aggr is\n             Apply_Scalar_Range_Check (Exp, Check_Typ);\n          end if;\n \n+      --  Verify that target type is also scalar, to prevent view anomalies\n+      --  in instantiations.\n+\n       elsif (Is_Scalar_Type (Exp_Typ)\n-             or else Nkind (Exp) = N_String_Literal)\n+              or else Nkind (Exp) = N_String_Literal)\n+        and then Is_Scalar_Type (Check_Typ)\n         and then Exp_Typ /= Check_Typ\n       then\n          if Is_Entity_Name (Exp)\n@@ -782,19 +787,6 @@ package body Sem_Aggr is\n \n       elsif Nkind (V) /= N_Integer_Literal then\n          return;\n-\n-      elsif Is_Access_Type (Etype (Disc)) then\n-         null;\n-\n-      --  If the bounds of the discriminant type are not compile time known,\n-      --  the back-end will treat this as a variable-size object.\n-\n-      elsif not\n-        (Compile_Time_Known_Value (Type_Low_Bound  (Etype (Disc)))\n-           and then\n-         Compile_Time_Known_Value (Type_High_Bound (Etype (Disc))))\n-      then\n-         return;\n       end if;\n \n       Comp := First_Component (T);\n@@ -899,15 +891,9 @@ package body Sem_Aggr is\n          Error_Msg_CRT (\"aggregate\", N);\n       end if;\n \n-      if Is_Limited_Composite (Typ) then\n-         Error_Msg_N (\"aggregate type cannot have limited component\", N);\n-         Explain_Limited_Type (Typ, N);\n-\n       --  Ada 2005 (AI-287): Limited aggregates allowed\n \n-      elsif Is_Limited_Type (Typ)\n-        and Ada_Version < Ada_05\n-      then\n+      if Is_Limited_Type (Typ) and then Ada_Version < Ada_05 then\n          Error_Msg_N (\"aggregate type cannot be limited\", N);\n          Explain_Limited_Type (Typ, N);\n \n@@ -2114,7 +2100,7 @@ package body Sem_Aggr is\n          end if;\n \n       else\n-         Error_Msg_N (\" No unique type for this aggregate\",  A);\n+         Error_Msg_N (\"no unique type for this aggregate\",  A);\n       end if;\n    end Resolve_Extension_Aggregate;\n \n@@ -2329,40 +2315,6 @@ package body Sem_Aggr is\n          Expr          : Node_Id := Empty;\n          Selector_Name : Node_Id;\n \n-         procedure Check_Non_Limited_Type;\n-         --  Relax check to allow the default initialization of limited types.\n-         --  For example:\n-         --      record\n-         --         C : Lim := (..., others => <>);\n-         --      end record;\n-\n-         ----------------------------\n-         -- Check_Non_Limited_Type --\n-         ----------------------------\n-\n-         procedure Check_Non_Limited_Type is\n-         begin\n-            if Is_Limited_Type (Etype (Compon))\n-               and then Comes_From_Source (Compon)\n-               and then not In_Instance_Body\n-            then\n-               --  Ada 2005 (AI-287): Limited aggregates are allowed\n-\n-               if Ada_Version >= Ada_05\n-                 and then Present (Expression (Assoc))\n-                 and then Nkind (Expression (Assoc)) = N_Aggregate\n-               then\n-                  null;\n-               else\n-                  Error_Msg_N\n-                    (\"initialization not allowed for limited types\", N);\n-                  Explain_Limited_Type (Etype (Compon), Compon);\n-               end if;\n-            end if;\n-         end Check_Non_Limited_Type;\n-\n-      --  Start of processing for Get_Value\n-\n       begin\n          Is_Box_Present := False;\n \n@@ -2387,21 +2339,25 @@ package body Sem_Aggr is\n \n                      --  Ada 2005 (AI-287): In case of default initialization\n                      --  of components, we duplicate the corresponding default\n-                     --  expression (from the record type declaration).\n+                     --  expression (from the record type declaration). The\n+                     --  copy must carry the sloc of the association (not the\n+                     --  original expression) to prevent spurious elaboration\n+                     --  checks when the default includes function calls.\n \n                      if Box_Present (Assoc) then\n                         Others_Box     := True;\n                         Is_Box_Present := True;\n \n                         if Expander_Active then\n-                           return New_Copy_Tree (Expression (Parent (Compon)));\n+                           return\n+                             New_Copy_Tree\n+                               (Expression (Parent (Compon)),\n+                                New_Sloc => Sloc (Assoc));\n                         else\n                            return Expression (Parent (Compon));\n                         end if;\n \n                      else\n-                        Check_Non_Limited_Type;\n-\n                         if Present (Others_Etype) and then\n                            Base_Type (Others_Etype) /= Base_Type (Etype\n                                                                    (Compon))\n@@ -2451,8 +2407,6 @@ package body Sem_Aggr is\n                         end if;\n \n                      else\n-                        Check_Non_Limited_Type;\n-\n                         if Present (Next (Selector_Name)) then\n                            Expr := New_Copy_Tree (Expression (Assoc));\n                         else\n@@ -2479,6 +2433,31 @@ package body Sem_Aggr is\n          return Expr;\n       end Get_Value;\n \n+      procedure Check_Non_Limited_Type (Expr : Node_Id);\n+      --  Relax check to allow the default initialization of limited types.\n+      --  For example:\n+      --      record\n+      --         C : Lim := (..., others => <>);\n+      --      end record;\n+\n+      ----------------------------\n+      -- Check_Non_Limited_Type --\n+      ----------------------------\n+\n+      procedure Check_Non_Limited_Type (Expr : Node_Id) is\n+      begin\n+         if Is_Limited_Type (Etype (Expr))\n+            and then Comes_From_Source (Expr)\n+            and then not In_Instance_Body\n+         then\n+            if not OK_For_Limited_Init (Expr) then\n+               Error_Msg_N\n+                 (\"initialization not allowed for limited types\", N);\n+               Explain_Limited_Type (Etype (Expr), Expr);\n+            end if;\n+         end if;\n+      end Check_Non_Limited_Type;\n+\n       -----------------------\n       -- Resolve_Aggr_Expr --\n       -----------------------\n@@ -2602,6 +2581,7 @@ package body Sem_Aggr is\n          end if;\n \n          Analyze_And_Resolve (Expr, Expr_Type);\n+         Check_Non_Limited_Type (Expr);\n          Check_Non_Static_Context (Expr);\n          Check_Unset_Reference (Expr);\n "}, {"sha": "f4c5ba64bc9e537b9368e0708214fe4c8b332696", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1152, "deletions": 736, "changes": 1888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c"}, {"sha": "ebdb209542246d4a9dfa53277c507a4807230ed4", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b32fc3a7728aac518bb52c53cb7596c49b720c/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=88b32fc3a7728aac518bb52c53cb7596c49b720c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,23 +28,30 @@ with Nlists; use Nlists;\n with Types;  use Types;\n \n package Sem_Ch3  is\n-   procedure Analyze_Component_Declaration              (N : Node_Id);\n-   procedure Analyze_Incomplete_Type_Decl               (N : Node_Id);\n-   procedure Analyze_Itype_Reference                    (N : Node_Id);\n-   procedure Analyze_Number_Declaration                 (N : Node_Id);\n-   procedure Analyze_Object_Declaration                 (N : Node_Id);\n-   procedure Analyze_Others_Choice                      (N : Node_Id);\n-   procedure Analyze_Private_Extension_Declaration      (N : Node_Id);\n-   procedure Analyze_Subtype_Declaration                (N : Node_Id);\n-   procedure Analyze_Subtype_Indication                 (N : Node_Id);\n-   procedure Analyze_Type_Declaration                   (N : Node_Id);\n-   procedure Analyze_Variant_Part                       (N : Node_Id);\n+   procedure Analyze_Component_Declaration         (N : Node_Id);\n+   procedure Analyze_Incomplete_Type_Decl          (N : Node_Id);\n+   procedure Analyze_Itype_Reference               (N : Node_Id);\n+   procedure Analyze_Number_Declaration            (N : Node_Id);\n+   procedure Analyze_Object_Declaration            (N : Node_Id);\n+   procedure Analyze_Others_Choice                 (N : Node_Id);\n+   procedure Analyze_Private_Extension_Declaration (N : Node_Id);\n+   procedure Analyze_Subtype_Indication            (N : Node_Id);\n+   procedure Analyze_Type_Declaration              (N : Node_Id);\n+   procedure Analyze_Variant_Part                  (N : Node_Id);\n+\n+   procedure Analyze_Subtype_Declaration\n+     (N    : Node_Id;\n+      Skip : Boolean := False);\n+   --  Called to analyze a subtype declaration. The parameter Skip is used for\n+   --  Ada 2005 (AI-412). We set to True in order to avoid reentering the\n+   --  defining identifier of N when analyzing a rewritten incomplete subtype\n+   --  declaration.\n \n    function Access_Definition\n      (Related_Nod : Node_Id;\n       N           : Node_Id) return Entity_Id;\n    --  An access definition defines a general access type for a formal\n-   --  parameter.  The procedure is called when processing formals, when\n+   --  parameter. The procedure is called when processing formals, when\n    --  the current scope is the subprogram. The Implicit type is attached\n    --  to the Related_Nod put into the enclosing scope, so that the only\n    --  entities defined in the spec are the formals themselves.\n@@ -100,15 +107,6 @@ package Sem_Ch3  is\n    --  rather than on the declarations that require completion in the package\n    --  declaration.\n \n-   procedure Collect_Interfaces\n-     (N            : Node_Id;\n-      Derived_Type : Entity_Id);\n-   --  Ada 2005 (AI-251): Subsidiary procedure to Build_Derived_Record_Type\n-   --  and Analyze_Formal_Interface_Type.\n-   --  Collect the list of interfaces that are not already implemented by the\n-   --  ancestors. This is the list of interfaces for which we must provide\n-   --  additional tag components.\n-\n    procedure Derive_Subprogram\n      (New_Subp     : in out Entity_Id;\n       Parent_Subp  : Entity_Id;\n@@ -125,8 +123,7 @@ package Sem_Ch3  is\n    procedure Derive_Subprograms\n      (Parent_Type           : Entity_Id;\n       Derived_Type          : Entity_Id;\n-      Generic_Actual        : Entity_Id := Empty;\n-      No_Predefined_Prims   : Boolean   := False);\n+      Generic_Actual        : Entity_Id := Empty);\n    --  To complete type derivation, collect/retrieve the primitive operations\n    --  of the parent type, and replace the subsidiary subtypes with the derived\n    --  type, to build the specs of the inherited ops. For generic actuals, the\n@@ -183,10 +180,25 @@ package Sem_Ch3  is\n \n    procedure Make_Class_Wide_Type (T : Entity_Id);\n    --  A Class_Wide_Type is created for each tagged type definition. The\n-   --  attributes of a class wide type are inherited from those of the type\n-   --  T. If T is introduced by a private declaration, the corresponding\n-   --  class wide type is created at the same time, and therefore there is\n-   --  a private and a full declaration for the class wide type type as well.\n+   --  attributes of a class wide type are inherited from those of the type T.\n+   --  If T is introduced by a private declaration, the corresponding class\n+   --  wide type is created at the same time, and therefore there is a private\n+   --  and a full declaration for the class wide type type as well.\n+\n+   function OK_For_Limited_Init_In_05 (Exp : Node_Id) return Boolean;\n+   --  Presuming Exp is an expression of an inherently limited type, returns\n+   --  True if the expression is allowed in an initialization context by the\n+   --  rules of Ada 2005. We use the rule in RM-7.5(2.1/2), \"...it is an\n+   --  aggregate, a function_call, or a parenthesized expression or\n+   --  qualified_expression whose operand is permitted...\". Note that in Ada\n+   --  95 mode, we sometimes wish to give warnings based on whether the\n+   --  program _would_ be legal in Ada 2005. Note that Exp must already have\n+   --  been resolved, so we can know whether it's a function call (as opposed\n+   --  to an indexed component, for example).\n+\n+   function OK_For_Limited_Init (Exp : Node_Id) return Boolean;\n+   --  Always False in Ada 95 mode. Equivalent to OK_For_Limited_Init_In_05 in\n+   --  Ada 2005 mode.\n \n    procedure Process_Full_View (N : Node_Id; Full_T, Priv_T : Entity_Id);\n    --  Process some semantic actions when the full view of a private type is\n@@ -213,8 +225,8 @@ package Sem_Ch3  is\n    --  pointer of R so that the types get properly frozen. The Check_List\n    --  parameter is used when the subprogram is called from\n    --  Build_Record_Init_Proc and is used to return a set of constraint\n-   --  checking statements generated by the Checks package. R_Check_Off is\n-   --  set to True when the call to Range_Check is to be skipped.\n+   --  checking statements generated by the Checks package. R_Check_Off is set\n+   --  to True when the call to Range_Check is to be skipped.\n \n    function Process_Subtype\n      (S           : Node_Id;"}]}