{"sha": "5fae049dc272144f8e61af94ee0ba42b270915e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhZTA0OWRjMjcyMTQ0ZjhlNjFhZjk0ZWUwYmE0MmIyNzA5MTVlNQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-05-17T19:13:36Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-05-17T19:13:36Z"}, "message": "OpenACC Profiling Interface (incomplete)\n\n\tlibgomp/\n\t* acc_prof.h: New file.\n\t* oacc-profiling.c: Likewise.\n\t* Makefile.am (nodist_libsubinclude_HEADERS, libgomp_la_SOURCES):\n\tAdd these, respectively.\n\t* Makefile.in: Regenerate.\n\t* env.c (initialize_env): Call goacc_profiling_initialize.\n\t* oacc-plugin.c (GOMP_PLUGIN_goacc_thread)\n\t(GOMP_PLUGIN_goacc_profiling_dispatch): New functions.\n\t* oacc-plugin.h (GOMP_PLUGIN_goacc_thread)\n\t(GOMP_PLUGIN_goacc_profiling_dispatch): Declare.\n\t* libgomp.map (OACC_2.5.1): Add acc_prof_lookup,\n\tacc_prof_register, acc_prof_unregister, and acc_register_library.\n\t(GOMP_PLUGIN_1.3): Add GOMP_PLUGIN_goacc_profiling_dispatch, and\n\tGOMP_PLUGIN_goacc_thread.\n\t* oacc-int.h (struct goacc_thread): Add prof_info, api_info,\n\tprof_callbacks_enabled members.\n\t(goacc_prof_enabled, goacc_profiling_initialize)\n\t(_goacc_profiling_dispatch_p, _goacc_profiling_setup_p)\n\t(goacc_profiling_dispatch): Declare.\n\t(GOACC_PROF_ENABLED, GOACC_PROFILING_DISPATCH_P)\n\t(GOACC_PROFILING_SETUP_P): Define.\n\t* oacc-async.c (acc_async_test, acc_async_test_all, acc_wait)\n\t(acc_wait_async, acc_wait_all, acc_wait_all_async): Update for\n\tOpenACC Profiling Interface.\n\t* oacc-cuda.c (acc_get_current_cuda_device)\n\t(acc_get_current_cuda_context, acc_get_cuda_stream)\n\t(acc_set_cuda_stream): Likewise.\n\t* oacc-init.c (acc_init_1, goacc_attach_host_thread_to_device)\n\t(acc_init, acc_set_device_type, acc_get_device_type)\n\t(acc_get_device_num, goacc_lazy_initialize): Likewise.\n\t* oacc-mem.c (acc_malloc, acc_free, memcpy_tofrom_device)\n\t(acc_deviceptr, acc_hostptr, acc_is_present, acc_map_data)\n\t(acc_unmap_data, present_create_copy, delete_copyout)\n\t(update_dev_host): Likewise.\n\t* oacc-parallel.c (GOACC_parallel_keyed, GOACC_data_start)\n\t(GOACC_data_end, GOACC_enter_exit_data, GOACC_update, GOACC_wait):\n\tLikewise.\n\t* plugin/plugin-nvptx.c (nvptx_exec, nvptx_alloc, nvptx_free)\n\t(GOMP_OFFLOAD_openacc_exec, GOMP_OFFLOAD_openacc_async_exec):\n\tLikewise.\n\t* libgomp.texi: Update.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c: New\n\tfile.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c:\n\tLikewise.\n\nFrom-SVN: r271346", "tree": {"sha": "6108e18ecb0a9f9190bb4d03730bba8cd80654f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6108e18ecb0a9f9190bb4d03730bba8cd80654f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fae049dc272144f8e61af94ee0ba42b270915e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fae049dc272144f8e61af94ee0ba42b270915e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fae049dc272144f8e61af94ee0ba42b270915e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fae049dc272144f8e61af94ee0ba42b270915e5/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b48f44bf77a39fefc238a16cf1225c6464c82406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48f44bf77a39fefc238a16cf1225c6464c82406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48f44bf77a39fefc238a16cf1225c6464c82406"}], "stats": {"total": 4475, "additions": 4400, "deletions": 75}, "files": [{"sha": "e0a128f948f78d5ee6578e34f29c80d1a022153e", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -1,3 +1,58 @@\n+2019-05-17  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* acc_prof.h: New file.\n+\t* oacc-profiling.c: Likewise.\n+\t* Makefile.am (nodist_libsubinclude_HEADERS, libgomp_la_SOURCES):\n+\tAdd these, respectively.\n+\t* Makefile.in: Regenerate.\n+\t* env.c (initialize_env): Call goacc_profiling_initialize.\n+\t* oacc-plugin.c (GOMP_PLUGIN_goacc_thread)\n+\t(GOMP_PLUGIN_goacc_profiling_dispatch): New functions.\n+\t* oacc-plugin.h (GOMP_PLUGIN_goacc_thread)\n+\t(GOMP_PLUGIN_goacc_profiling_dispatch): Declare.\n+\t* libgomp.map (OACC_2.5.1): Add acc_prof_lookup,\n+\tacc_prof_register, acc_prof_unregister, and acc_register_library.\n+\t(GOMP_PLUGIN_1.3): Add GOMP_PLUGIN_goacc_profiling_dispatch, and\n+\tGOMP_PLUGIN_goacc_thread.\n+\t* oacc-int.h (struct goacc_thread): Add prof_info, api_info,\n+\tprof_callbacks_enabled members.\n+\t(goacc_prof_enabled, goacc_profiling_initialize)\n+\t(_goacc_profiling_dispatch_p, _goacc_profiling_setup_p)\n+\t(goacc_profiling_dispatch): Declare.\n+\t(GOACC_PROF_ENABLED, GOACC_PROFILING_DISPATCH_P)\n+\t(GOACC_PROFILING_SETUP_P): Define.\n+\t* oacc-async.c (acc_async_test, acc_async_test_all, acc_wait)\n+\t(acc_wait_async, acc_wait_all, acc_wait_all_async): Update for\n+\tOpenACC Profiling Interface.\n+\t* oacc-cuda.c (acc_get_current_cuda_device)\n+\t(acc_get_current_cuda_context, acc_get_cuda_stream)\n+\t(acc_set_cuda_stream): Likewise.\n+\t* oacc-init.c (acc_init_1, goacc_attach_host_thread_to_device)\n+\t(acc_init, acc_set_device_type, acc_get_device_type)\n+\t(acc_get_device_num, goacc_lazy_initialize): Likewise.\n+\t* oacc-mem.c (acc_malloc, acc_free, memcpy_tofrom_device)\n+\t(acc_deviceptr, acc_hostptr, acc_is_present, acc_map_data)\n+\t(acc_unmap_data, present_create_copy, delete_copyout)\n+\t(update_dev_host): Likewise.\n+\t* oacc-parallel.c (GOACC_parallel_keyed, GOACC_data_start)\n+\t(GOACC_data_end, GOACC_enter_exit_data, GOACC_update, GOACC_wait):\n+\tLikewise.\n+\t* plugin/plugin-nvptx.c (nvptx_exec, nvptx_alloc, nvptx_free)\n+\t(GOMP_OFFLOAD_openacc_exec, GOMP_OFFLOAD_openacc_async_exec):\n+\tLikewise.\n+\t* libgomp.texi: Update.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c: New\n+\tfile.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c:\n+\tLikewise.\n+\n 2019-05-13  Chung-Lin Tang <cltang@codesourcery.com>\n \n \t* libgomp-plugin.h (struct goacc_asyncqueue): Declare."}, {"sha": "7d36343a4be12bcbe7ec0c9e3d72c5046a5ac988", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -65,7 +65,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c error.c \\\n \tproc.c sem.c bar.c ptrlock.c time.c fortran.c affinity.c target.c \\\n \tsplay-tree.c libgomp-plugin.c oacc-parallel.c oacc-host.c oacc-init.c \\\n \toacc-mem.c oacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n-\taffinity-fmt.c teams.c\n+\taffinity-fmt.c teams.c oacc-profiling.c\n \n include $(top_srcdir)/plugin/Makefrag.am\n \n@@ -74,7 +74,7 @@ libgomp_la_SOURCES += openacc.f90\n endif\n \n nodist_noinst_HEADERS = libgomp_f.h\n-nodist_libsubinclude_HEADERS = omp.h openacc.h\n+nodist_libsubinclude_HEADERS = omp.h openacc.h acc_prof.h\n if USE_FORTRAN\n nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod \\\n \topenacc_lib.h openacc.f90 openacc.mod openacc_kinds.mod"}, {"sha": "1e2fa89f3af8fdb2f1c1f45c0a5680ca60457fee", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -217,7 +217,7 @@ am_libgomp_la_OBJECTS = alloc.lo atomic.lo barrier.lo critical.lo \\\n \ttarget.lo splay-tree.lo libgomp-plugin.lo oacc-parallel.lo \\\n \toacc-host.lo oacc-init.lo oacc-mem.lo oacc-async.lo \\\n \toacc-plugin.lo oacc-cuda.lo priority_queue.lo affinity-fmt.lo \\\n-\tteams.lo $(am__objects_1)\n+\tteams.lo oacc-profiling.lo $(am__objects_1)\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n AM_V_P = $(am__v_P_@AM_V@)\n am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n@@ -551,7 +551,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n \taffinity.c target.c splay-tree.c libgomp-plugin.c \\\n \toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c \\\n \toacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n-\taffinity-fmt.c teams.c $(am__append_3)\n+\taffinity-fmt.c teams.c oacc-profiling.c $(am__append_3)\n \n # Nvidia PTX OpenACC plugin.\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)\n@@ -575,7 +575,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LIBADD = libgomp.la $(PLUGIN_HSA_LIBS)\n @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LIBTOOLFLAGS = --tag=disable-static\n nodist_noinst_HEADERS = libgomp_f.h\n-nodist_libsubinclude_HEADERS = omp.h openacc.h\n+nodist_libsubinclude_HEADERS = omp.h openacc.h acc_prof.h\n @USE_FORTRAN_TRUE@nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod \\\n @USE_FORTRAN_TRUE@\topenacc_lib.h openacc.f90 openacc.mod openacc_kinds.mod\n \n@@ -753,6 +753,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-mem.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-parallel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-plugin.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-profiling.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/priority_queue.Plo@am__quote@"}, {"sha": "c7a2197d11a9f5db6f7a5d8855f1646de1a5a916", "filename": "libgomp/acc_prof.h", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Facc_prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Facc_prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Facc_prof.h?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,252 @@\n+/* OpenACC Profiling Interface\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   Contributed by Mentor, a Siemens Business.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _ACC_PROF_H\n+#define _ACC_PROF_H 1\n+\n+\n+/* The OpenACC specification doesn't say so explicitly, but as its Profiling\n+   Interface explicitly makes use of, for example, <openacc.h>'s\n+   'acc_device_t', we supposedly are to '#include' that file here.  */\n+\n+#include <openacc.h>\n+\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+/* Events.  */\n+\n+typedef enum acc_event_t\n+{\n+  acc_ev_none = 0,\n+  acc_ev_device_init_start,\n+  acc_ev_device_init_end,\n+  acc_ev_device_shutdown_start,\n+  acc_ev_device_shutdown_end,\n+  acc_ev_runtime_shutdown,\n+  acc_ev_create,\n+  acc_ev_delete,\n+  acc_ev_alloc,\n+  acc_ev_free,\n+  acc_ev_enter_data_start,\n+  acc_ev_enter_data_end,\n+  acc_ev_exit_data_start,\n+  acc_ev_exit_data_end,\n+  acc_ev_update_start,\n+  acc_ev_update_end,\n+  acc_ev_compute_construct_start,\n+  acc_ev_compute_construct_end,\n+  acc_ev_enqueue_launch_start,\n+  acc_ev_enqueue_launch_end,\n+  acc_ev_enqueue_upload_start,\n+  acc_ev_enqueue_upload_end,\n+  acc_ev_enqueue_download_start,\n+  acc_ev_enqueue_download_end,\n+  acc_ev_wait_start,\n+  acc_ev_wait_end,\n+  acc_ev_last\n+} acc_event_t;\n+\n+\n+/* Callbacks Signature.  */\n+\n+/* \"The datatype 'ssize_t' means a signed 32-bit integer for a 32-bit binary\n+   and a 64-bit integer for a 64-bit binary\".  */\n+typedef signed long int _acc_prof_ssize_t;\n+/* \"The datatype 'size_t' means an unsigned 32-bit integer for a 32-bit binary\n+   and a 64-bit integer for a 64-bit binary\".  */\n+typedef unsigned long int _acc_prof_size_t;\n+/* \"The datatype 'int' means a 32-bit integer for both 32-bit and 64-bit\n+   binaries\".  */\n+typedef int _acc_prof_int_t;\n+\n+/* Internal helpers: a struct's 'valid_bytes' may be less than its 'sizeof'.  */\n+#define _ACC_PROF_VALID_BYTES_STRUCT(_struct, _lastfield, _valid_bytes_lastfield) \\\n+  offsetof (_struct, _lastfield) + (_valid_bytes_lastfield)\n+#if 0 /* Untested.  */\n+#define _ACC_PROF_VALID_BYTES_TYPE_N(_type, _n, _valid_bytes_type) \\\n+  ((_n - 1) * sizeof (_type) + (_valid_bytes_type))\n+#endif\n+#define _ACC_PROF_VALID_BYTES_BASICTYPE(_basictype) \\\n+  (sizeof (_basictype))\n+\n+typedef struct acc_prof_info\n+{\n+  acc_event_t event_type;\n+  _acc_prof_int_t valid_bytes;\n+  _acc_prof_int_t version;\n+  acc_device_t device_type;\n+  _acc_prof_int_t device_number;\n+  _acc_prof_int_t thread_id;\n+  _acc_prof_ssize_t async;\n+  _acc_prof_ssize_t async_queue;\n+  const char *src_file;\n+  const char *func_name;\n+  _acc_prof_int_t line_no, end_line_no;\n+  _acc_prof_int_t func_line_no, func_end_line_no;\n+#define _ACC_PROF_INFO_VALID_BYTES \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (acc_prof_info, func_end_line_no, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (_acc_prof_int_t))\n+} acc_prof_info;\n+\n+/* We implement the OpenACC 2.6 Profiling Interface.  */\n+\n+#define _ACC_PROF_INFO_VERSION 201711\n+\n+typedef enum acc_construct_t\n+{\n+  acc_construct_parallel = 0,\n+  acc_construct_kernels,\n+  acc_construct_loop,\n+  acc_construct_data,\n+  acc_construct_enter_data,\n+  acc_construct_exit_data,\n+  acc_construct_host_data,\n+  acc_construct_atomic,\n+  acc_construct_declare,\n+  acc_construct_init,\n+  acc_construct_shutdown,\n+  acc_construct_set,\n+  acc_construct_update,\n+  acc_construct_routine,\n+  acc_construct_wait,\n+  acc_construct_runtime_api,\n+  acc_construct_serial\n+} acc_construct_t;\n+\n+typedef struct acc_data_event_info\n+{\n+  acc_event_t event_type;\n+  _acc_prof_int_t valid_bytes;\n+  acc_construct_t parent_construct;\n+  _acc_prof_int_t implicit;\n+  void *tool_info;\n+  const char *var_name;\n+  _acc_prof_size_t bytes;\n+  const void *host_ptr;\n+  const void *device_ptr;\n+#define _ACC_DATA_EVENT_INFO_VALID_BYTES \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (acc_data_event_info, device_ptr, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (void *))\n+} acc_data_event_info;\n+\n+typedef struct acc_launch_event_info\n+{\n+  acc_event_t event_type;\n+  _acc_prof_int_t valid_bytes;\n+  acc_construct_t parent_construct;\n+  _acc_prof_int_t implicit;\n+  void *tool_info;\n+  const char *kernel_name;\n+  _acc_prof_size_t num_gangs, num_workers, vector_length;\n+#define _ACC_LAUNCH_EVENT_INFO_VALID_BYTES \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (acc_launch_event_info, vector_length, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (_acc_prof_size_t))\n+} acc_launch_event_info;\n+\n+typedef struct acc_other_event_info\n+{\n+  acc_event_t event_type;\n+  _acc_prof_int_t valid_bytes;\n+  acc_construct_t parent_construct;\n+  _acc_prof_int_t implicit;\n+  void *tool_info;\n+#define _ACC_OTHER_EVENT_INFO_VALID_BYTES \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (acc_other_event_info, tool_info, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (void *))\n+} acc_other_event_info;\n+\n+typedef union acc_event_info\n+{\n+  acc_event_t event_type;\n+  acc_data_event_info data_event;\n+  acc_launch_event_info launch_event;\n+  acc_other_event_info other_event;\n+} acc_event_info;\n+\n+typedef enum acc_device_api\n+{\n+  acc_device_api_none = 0,\n+  acc_device_api_cuda,\n+  acc_device_api_opencl,\n+  acc_device_api_coi,\n+  acc_device_api_other\n+} acc_device_api;\n+\n+typedef struct acc_api_info\n+{\n+  acc_device_api device_api;\n+  _acc_prof_int_t valid_bytes;\n+  acc_device_t device_type;\n+  _acc_prof_int_t vendor;\n+  const void *device_handle;\n+  const void *context_handle;\n+  const void *async_handle;\n+#define _ACC_API_INFO_VALID_BYTES \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (acc_api_info, async_handle, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (void *))\n+} acc_api_info;\n+\n+/* Don't tag 'acc_prof_callback' as '__GOACC_NOTHROW': these functions are\n+   provided by user code, and must be expected to do anything.  */\n+typedef void (*acc_prof_callback) (acc_prof_info *, acc_event_info *,\n+\t\t\t\t   acc_api_info *);\n+\n+\n+/* Loading the Library.  */\n+\n+typedef enum acc_register_t\n+{\n+  acc_reg = 0,\n+  acc_toggle = 1,\n+  acc_toggle_per_thread = 2\n+} acc_register_t;\n+\n+typedef void (*acc_prof_reg) (acc_event_t, acc_prof_callback, acc_register_t);\n+extern void acc_prof_register (acc_event_t, acc_prof_callback,\n+\t\t\t       acc_register_t) __GOACC_NOTHROW;\n+extern void acc_prof_unregister (acc_event_t, acc_prof_callback,\n+\t\t\t\t acc_register_t) __GOACC_NOTHROW;\n+typedef void (*acc_query_fn) ();\n+typedef acc_query_fn (*acc_prof_lookup_func) (const char *);\n+extern acc_query_fn acc_prof_lookup (const char *) __GOACC_NOTHROW;\n+/* Don't tag 'acc_register_library' as '__GOACC_NOTHROW': this function can be\n+   overridden by user code, and must be expected to do anything.  */\n+extern void acc_register_library (acc_prof_reg, acc_prof_reg,\n+\t\t\t\t  acc_prof_lookup_func);\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+\n+#endif /* _ACC_PROF_H */"}, {"sha": "29d9f58cba3a82bfb3265282ff2b7e86cfcb5abe", "filename": "libgomp/env.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -1425,5 +1425,7 @@ initialize_env (void)\n   parse_gomp_openacc_dim ();\n \n   goacc_runtime_initialize ();\n+\n+  goacc_profiling_initialize ();\n }\n #endif /* LIBGOMP_OFFLOADED_ONLY */"}, {"sha": "c79430f8d8d139b7a9a4e40bc4f6f2f1749d1cf4", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -476,6 +476,14 @@ OACC_2.5 {\n \tacc_update_self_async_array_h_;\n } OACC_2.0.1;\n \n+OACC_2.5.1 {\n+  global:\n+\tacc_prof_lookup;\n+\tacc_prof_register;\n+\tacc_prof_unregister;\n+\tacc_register_library;\n+} OACC_2.5;\n+\n GOACC_2.0 {\n   global:\n \tGOACC_data_end;\n@@ -515,3 +523,9 @@ GOMP_PLUGIN_1.2 {\n   global:\n \tGOMP_PLUGIN_acc_default_dim;\n } GOMP_PLUGIN_1.1;\n+\n+GOMP_PLUGIN_1.3 {\n+  global:\n+\tGOMP_PLUGIN_goacc_profiling_dispatch;\n+\tGOMP_PLUGIN_goacc_thread;\n+} GOMP_PLUGIN_1.2;"}, {"sha": "6db895f627266e45cb376f1848dec1ae71f373c5", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -111,6 +111,7 @@ changed to GNU Offloading and Multi Processing Runtime Library.\n                                asynchronous operations.\n * OpenACC Library Interoperability:: OpenACC library interoperability with the\n                                NVIDIA CUBLAS library.\n+* OpenACC Profiling Interface::\n * The libgomp ABI::            Notes on the external ABI presented by libgomp.\n * Reporting Bugs::             How to report bugs in the GNU Offloading and\n                                Multi Processing Runtime Library.\n@@ -1897,6 +1898,13 @@ API routines for target platforms.\n * acc_get_current_cuda_context::Get CUDA context handle.\n * acc_get_cuda_stream::         Get CUDA stream handle.\n * acc_set_cuda_stream::         Set CUDA stream handle.\n+\n+API routines for the OpenACC Profiling Interface.\n+\n+* acc_prof_register::           Register callbacks.\n+* acc_prof_unregister::         Unregister callbacks.\n+* acc_prof_lookup::             Obtain inquiry functions.\n+* acc_register_library::        Library registration.\n @end menu\n \n \n@@ -2823,6 +2831,90 @@ A.2.1.4.\n \n \n \n+@node acc_prof_register\n+@section @code{acc_prof_register} -- Register callbacks.\n+@table @asis\n+@item @emph{Description}:\n+This function registers callbacks.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void acc_prof_register (acc_event_t, acc_prof_callback, acc_register_t);}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OpenACC Profiling Interface}\n+\n+@item @emph{Reference}:\n+@uref{https://www.openacc.org, OpenACC specification v2.6}, section\n+5.3.\n+@end table\n+\n+\n+\n+@node acc_prof_unregister\n+@section @code{acc_prof_unregister} -- Unregister callbacks.\n+@table @asis\n+@item @emph{Description}:\n+This function unregisters callbacks.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void acc_prof_unregister (acc_event_t, acc_prof_callback, acc_register_t);}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OpenACC Profiling Interface}\n+\n+@item @emph{Reference}:\n+@uref{https://www.openacc.org, OpenACC specification v2.6}, section\n+5.3.\n+@end table\n+\n+\n+\n+@node acc_prof_lookup\n+@section @code{acc_prof_lookup} -- Obtain inquiry functions.\n+@table @asis\n+@item @emph{Description}:\n+Function to obtain inquiry functions.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_query_fn acc_prof_lookup (const char *);}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OpenACC Profiling Interface}\n+\n+@item @emph{Reference}:\n+@uref{https://www.openacc.org, OpenACC specification v2.6}, section\n+5.3.\n+@end table\n+\n+\n+\n+@node acc_register_library\n+@section @code{acc_register_library} -- Library registration.\n+@table @asis\n+@item @emph{Description}:\n+Function for library registration.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void acc_register_library (acc_prof_reg, acc_prof_reg, acc_prof_lookup_func);}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OpenACC Profiling Interface}, @ref{ACC_PROFLIB}\n+\n+@item @emph{Reference}:\n+@uref{https://www.openacc.org, OpenACC specification v2.6}, section\n+5.3.\n+@end table\n+\n+\n+\n @c ---------------------------------------------------------------------\n @c OpenACC Environment Variables\n @c ---------------------------------------------------------------------\n@@ -2832,11 +2924,14 @@ A.2.1.4.\n \n The variables @env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM}\n are defined by section 4 of the OpenACC specification in version 2.0.\n+The variable @env{ACC_PROFLIB}\n+is defined by section 4 of the OpenACC specification in version 2.6.\n The variable @env{GCC_ACC_NOTIFY} is used for diagnostic purposes.\n \n @menu\n * ACC_DEVICE_TYPE::\n * ACC_DEVICE_NUM::\n+* ACC_PROFLIB::\n * GCC_ACC_NOTIFY::\n @end menu\n \n@@ -2862,6 +2957,19 @@ The variable @env{GCC_ACC_NOTIFY} is used for diagnostic purposes.\n \n \n \n+@node ACC_PROFLIB\n+@section @code{ACC_PROFLIB}\n+@table @asis\n+@item @emph{See also}:\n+@ref{acc_register_library}, @ref{OpenACC Profiling Interface}\n+\n+@item @emph{Reference}:\n+@uref{https://www.openacc.org, OpenACC specification v2.6}, section\n+4.3.\n+@end table\n+\n+\n+\n @node GCC_ACC_NOTIFY\n @section @code{GCC_ACC_NOTIFY}\n @table @asis\n@@ -3077,6 +3185,310 @@ Application Programming Interface\u201d, Version 2.0.}\n \n \n \n+@c ---------------------------------------------------------------------\n+@c OpenACC Profiling Interface\n+@c ---------------------------------------------------------------------\n+\n+@node OpenACC Profiling Interface\n+@chapter OpenACC Profiling Interface\n+\n+@section Implementation Status and Implementation-Defined Behavior\n+\n+We're implementing the OpenACC Profiling Interface as defined by the\n+OpenACC 2.6 specification.  We're clarifying some aspects here as\n+@emph{implementation-defined behavior}, while they're still under\n+discussion within the OpenACC Technical Committee.\n+\n+This implementation is tuned to keep the performance impact as low as\n+possible for the (very common) case that the Profiling Interface is\n+not enabled.  This is relevant, as the Profiling Interface affects all\n+the @emph{hot} code paths (in the target code, not in the offloaded\n+code).  Users of the OpenACC Profiling Interface can be expected to\n+understand that performance will be impacted to some degree once the\n+Profiling Interface has gotten enabled: for example, because of the\n+@emph{runtime} (libgomp) calling into a third-party @emph{library} for\n+every event that has been registered.\n+\n+We're not yet accounting for the fact that @cite{OpenACC events may\n+occur during event processing}.\n+\n+We're not yet implementing initialization via a\n+@code{acc_register_library} function that is either statically linked\n+in, or dynamically via @env{LD_PRELOAD}.\n+Initialization via @code{acc_register_library} functions dynamically\n+loaded via the @env{ACC_PROFLIB} environment variable does work, as\n+does directly calling @code{acc_prof_register},\n+@code{acc_prof_unregister}, @code{acc_prof_lookup}.\n+\n+As currently there are no inquiry functions defined, calls to\n+@code{acc_prof_lookup} will always return @code{NULL}.\n+\n+There aren't separate @emph{start}, @emph{stop} events defined for the\n+event types @code{acc_ev_create}, @code{acc_ev_delete},\n+@code{acc_ev_alloc}, @code{acc_ev_free}.  It's not clear if these\n+should be triggered before or after the actual device-specific call is\n+made.  We trigger them after.\n+\n+Remarks about data provided to callbacks:\n+\n+@table @asis\n+\n+@item @code{acc_prof_info.event_type}\n+It's not clear if for @emph{nested} event callbacks (for example,\n+@code{acc_ev_enqueue_launch_start} as part of a parent compute\n+construct), this should be set for the nested event\n+(@code{acc_ev_enqueue_launch_start}), or if the value of the parent\n+construct should remain (@code{acc_ev_compute_construct_start}).  In\n+this implementation, the value will generally correspond to the\n+innermost nested event type.\n+\n+@item @code{acc_prof_info.device_type}\n+@itemize\n+\n+@item\n+For @code{acc_ev_compute_construct_start}, and in presence of an\n+@code{if} clause with @emph{false} argument, this will still refer to\n+the offloading device type.\n+It's not clear if that's the expected behavior.\n+\n+@item\n+Complementary to the item before, for\n+@code{acc_ev_compute_construct_end}, this is set to\n+@code{acc_device_host} in presence of an @code{if} clause with\n+@emph{false} argument.\n+It's not clear if that's the expected behavior.\n+\n+@end itemize\n+\n+@item @code{acc_prof_info.thread_id}\n+Always @code{-1}; not yet implemented.\n+\n+@item @code{acc_prof_info.async}\n+@itemize\n+\n+@item\n+Not yet implemented correctly for\n+@code{acc_ev_compute_construct_start}.\n+\n+@item\n+In a compute construct, for host-fallback\n+execution/@code{acc_device_host} it will always be\n+@code{acc_async_sync}.\n+It's not clear if that's the expected behavior.\n+\n+@item\n+For @code{acc_ev_device_init_start} and @code{acc_ev_device_init_end},\n+it will always be @code{acc_async_sync}.\n+It's not clear if that's the expected behavior.\n+\n+@end itemize\n+\n+@item @code{acc_prof_info.async_queue}\n+There is no @cite{limited number of asynchronous queues} in libgomp.\n+This will always have the same value as @code{acc_prof_info.async}.\n+\n+@item @code{acc_prof_info.src_file}\n+Always @code{NULL}; not yet implemented.\n+\n+@item @code{acc_prof_info.func_name}\n+Always @code{NULL}; not yet implemented.\n+\n+@item @code{acc_prof_info.line_no}\n+Always @code{-1}; not yet implemented.\n+\n+@item @code{acc_prof_info.end_line_no}\n+Always @code{-1}; not yet implemented.\n+\n+@item @code{acc_prof_info.func_line_no}\n+Always @code{-1}; not yet implemented.\n+\n+@item @code{acc_prof_info.func_end_line_no}\n+Always @code{-1}; not yet implemented.\n+\n+@item @code{acc_event_info.event_type}, @code{acc_event_info.*.event_type}\n+Relating to @code{acc_prof_info.event_type} discussed above, in this\n+implementation, this will always be the same value as\n+@code{acc_prof_info.event_type}.\n+\n+@item @code{acc_event_info.*.parent_construct}\n+@itemize\n+\n+@item\n+Will be @code{acc_construct_parallel} for all OpenACC compute\n+constructs as well as many OpenACC Runtime API calls; should be the\n+one matching the actual construct, or\n+@code{acc_construct_runtime_api}, respectively.\n+\n+@item\n+Will be @code{acc_construct_enter_data} or\n+@code{acc_construct_exit_data} when processing variable mappings\n+specified in OpenACC @emph{declare} directives; should be\n+@code{acc_construct_declare}.\n+\n+@item\n+For implicit @code{acc_ev_device_init_start},\n+@code{acc_ev_device_init_end}, and explicit as well as implicit\n+@code{acc_ev_alloc}, @code{acc_ev_free},\n+@code{acc_ev_enqueue_upload_start}, @code{acc_ev_enqueue_upload_end},\n+@code{acc_ev_enqueue_download_start}, and\n+@code{acc_ev_enqueue_download_end}, will be\n+@code{acc_construct_parallel}; should reflect the real parent\n+construct.\n+\n+@end itemize\n+\n+@item @code{acc_event_info.*.implicit}\n+For @code{acc_ev_alloc}, @code{acc_ev_free},\n+@code{acc_ev_enqueue_upload_start}, @code{acc_ev_enqueue_upload_end},\n+@code{acc_ev_enqueue_download_start}, and\n+@code{acc_ev_enqueue_download_end}, this currently will be @code{1}\n+also for explicit usage.\n+\n+@item @code{acc_event_info.data_event.var_name}\n+Always @code{NULL}; not yet implemented.\n+\n+@item @code{acc_event_info.data_event.host_ptr}\n+For @code{acc_ev_alloc}, and @code{acc_ev_free}, this is always\n+@code{NULL}.\n+\n+@item @code{typedef union acc_api_info}\n+@dots{} as printed in @cite{5.2.3. Third Argument: API-Specific\n+Information}.  This should obviously be @code{typedef @emph{struct}\n+acc_api_info}.\n+\n+@item @code{acc_api_info.device_api}\n+Possibly not yet implemented correctly for\n+@code{acc_ev_compute_construct_start},\n+@code{acc_ev_device_init_start}, @code{acc_ev_device_init_end}:\n+will always be @code{acc_device_api_none} for these event types.\n+For @code{acc_ev_enter_data_start}, it will be\n+@code{acc_device_api_none} in some cases.\n+\n+@item @code{acc_api_info.device_type}\n+Always the same as @code{acc_prof_info.device_type}.\n+\n+@item @code{acc_api_info.vendor}\n+Always @code{-1}; not yet implemented.\n+\n+@item @code{acc_api_info.device_handle}\n+Always @code{NULL}; not yet implemented.\n+\n+@item @code{acc_api_info.context_handle}\n+Always @code{NULL}; not yet implemented.\n+\n+@item @code{acc_api_info.async_handle}\n+Always @code{NULL}; not yet implemented.\n+\n+@end table\n+\n+Remarks about certain event types:\n+\n+@table @asis\n+\n+@item @code{acc_ev_device_init_start}, @code{acc_ev_device_init_end}\n+@itemize\n+\n+@item\n+@c See 'DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT' in\n+@c 'libgomp.oacc-c-c++-common/acc_prof-kernels-1.c',\n+@c 'libgomp.oacc-c-c++-common/acc_prof-parallel-1.c'.\n+Whan a compute construct triggers implicit\n+@code{acc_ev_device_init_start} and @code{acc_ev_device_init_end}\n+events, they currently aren't @emph{nested within} the corresponding\n+@code{acc_ev_compute_construct_start} and\n+@code{acc_ev_compute_construct_end}, but they're currently observed\n+@emph{before} @code{acc_ev_compute_construct_start}.\n+It's not clear what to do: the standard asks us provide a lot of\n+details to the @code{acc_ev_compute_construct_start} callback, without\n+(implicitly) initializing a device before?\n+\n+@item\n+Callbacks for these event types will not be invoked for calls to the\n+@code{acc_set_device_type} and @code{acc_set_device_num} functions.\n+It's not clear if they should be.\n+\n+@end itemize\n+\n+@item @code{acc_ev_enter_data_start}, @code{acc_ev_enter_data_end}, @code{acc_ev_exit_data_start}, @code{acc_ev_exit_data_end}\n+@itemize\n+\n+@item\n+Callbacks for these event types will also be invoked for OpenACC\n+@emph{host_data} constructs.\n+It's not clear if they should be.\n+\n+@item\n+Callbacks for these event types will also be invoked when processing\n+variable mappings specified in OpenACC @emph{declare} directives.\n+It's not clear if they should be.\n+\n+@end itemize\n+\n+@end table\n+\n+Callbacks for the following event types will be invoked, but dispatch\n+and information provided therein has not yet been thoroughly reviewed:\n+\n+@itemize\n+@item @code{acc_ev_alloc}\n+@item @code{acc_ev_free}\n+@item @code{acc_ev_update_start}, @code{acc_ev_update_end}\n+@item @code{acc_ev_enqueue_upload_start}, @code{acc_ev_enqueue_upload_end}\n+@item @code{acc_ev_enqueue_download_start}, @code{acc_ev_enqueue_download_end}\n+@end itemize\n+\n+During device initialization, and finalization, respectively,\n+callbacks for the following event types will not yet be invoked:\n+\n+@itemize\n+@item @code{acc_ev_alloc}\n+@item @code{acc_ev_free}\n+@end itemize\n+\n+Callbacks for the following event types have not yet been implemented,\n+so currently won't be invoked:\n+\n+@itemize\n+@item @code{acc_ev_device_shutdown_start}, @code{acc_ev_device_shutdown_end}\n+@item @code{acc_ev_runtime_shutdown}\n+@item @code{acc_ev_create}, @code{acc_ev_delete}\n+@item @code{acc_ev_wait_start}, @code{acc_ev_wait_end}\n+@end itemize\n+\n+For the following runtime library functions, not all expected\n+callbacks will be invoked (mostly concerning implicit device\n+initialization):\n+\n+@itemize\n+@item @code{acc_get_num_devices}\n+@item @code{acc_set_device_type}\n+@item @code{acc_get_device_type}\n+@item @code{acc_set_device_num}\n+@item @code{acc_get_device_num}\n+@item @code{acc_init}\n+@item @code{acc_shutdown}\n+@end itemize\n+\n+Aside from implicit device initialization, for the following runtime\n+library functions, no callbacks will be invoked for shared-memory\n+offloading devices (it's not clear if they should be):\n+\n+@itemize\n+@item @code{acc_malloc}\n+@item @code{acc_free}\n+@item @code{acc_copyin}, @code{acc_present_or_copyin}, @code{acc_copyin_async}\n+@item @code{acc_create}, @code{acc_present_or_create}, @code{acc_create_async}\n+@item @code{acc_copyout}, @code{acc_copyout_async}, @code{acc_copyout_finalize}, @code{acc_copyout_finalize_async}\n+@item @code{acc_delete}, @code{acc_delete_async}, @code{acc_delete_finalize}, @code{acc_delete_finalize_async}\n+@item @code{acc_update_device}, @code{acc_update_device_async}\n+@item @code{acc_update_self}, @code{acc_update_self_async}\n+@item @code{acc_map_data}, @code{acc_unmap_data}\n+@item @code{acc_memcpy_to_device}, @code{acc_memcpy_to_device_async}\n+@item @code{acc_memcpy_from_device}, @code{acc_memcpy_from_device_async}\n+@end itemize\n+\n+\n+\n @c ---------------------------------------------------------------------\n @c The libgomp ABI\n @c ---------------------------------------------------------------------"}, {"sha": "1760e8c90c63360260e9b014dfd73490e14304e0", "filename": "libgomp/oacc-async.c", "status": "modified", "additions": 100, "deletions": 21, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-async.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-async.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-async.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -43,17 +43,6 @@ get_goacc_thread (void)\n   return thr;\n }\n \n-static struct gomp_device_descr *\n-get_goacc_thread_device (void)\n-{\n-  struct goacc_thread *thr = goacc_thread ();\n-\n-  if (!thr || !thr->dev)\n-    gomp_fatal (\"no device active\");\n-\n-  return thr->dev;\n-}\n-\n static int\n validate_async_val (int async)\n {\n@@ -76,7 +65,10 @@ validate_async_val (int async)\n \n /* Return the asyncqueue to be used for OpenACC async-argument ASYNC.  This\n    might return NULL if no asyncqueue is to be used.  Otherwise, if CREATE,\n-   create the asyncqueue if it doesn't exist yet.  */\n+   create the asyncqueue if it doesn't exist yet.\n+\n+   Unless CREATE, this will not generate any OpenACC Profiling Interface\n+   events.  */\n \n attribute_hidden struct goacc_asyncqueue *\n lookup_goacc_asyncqueue (struct goacc_thread *thr, bool create, int async)\n@@ -152,15 +144,36 @@ acc_async_test (int async)\n   goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);\n   if (!aq)\n     return 1;\n-  else\n-    return thr->dev->openacc.async.test_func (aq);\n+\n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n+  int res = thr->dev->openacc.async.test_func (aq);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+\n+  return res;\n }\n \n int\n acc_async_test_all (void)\n {\n   struct goacc_thread *thr = get_goacc_thread ();\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n   int ret = 1;\n   gomp_mutex_lock (&thr->dev->openacc.async.lock);\n   for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)\n@@ -170,6 +183,13 @@ acc_async_test_all (void)\n \tbreak;\n       }\n   gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+\n   return ret;\n }\n \n@@ -179,8 +199,26 @@ acc_wait (int async)\n   struct goacc_thread *thr = get_goacc_thread ();\n \n   goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);\n-  if (aq && !thr->dev->openacc.async.synchronize_func (aq))\n+  if (!aq)\n+    return;\n+\n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n+  if (!thr->dev->openacc.async.synchronize_func (aq))\n     gomp_fatal (\"wait on %d failed\", async);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n /* acc_async_wait is an OpenACC 1.0 compatibility name for acc_wait.  */\n@@ -205,10 +243,19 @@ acc_wait_async (int async1, int async2)\n   if (!aq1)\n     return;\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async2;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   goacc_aq aq2 = lookup_goacc_asyncqueue (thr, true, async2);\n   /* An async queue is always synchronized with itself.  */\n   if (aq1 == aq2)\n-    return;\n+    goto out_prof;\n \n   if (aq2)\n     {\n@@ -222,18 +269,35 @@ acc_wait_async (int async1, int async2)\n       if (!thr->dev->openacc.async.synchronize_func (aq1))\n \tgomp_fatal (\"wait on %d failed\", async1);\n     }\n+\n+ out_prof:\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void\n acc_wait_all (void)\n {\n-  struct gomp_device_descr *dev = get_goacc_thread_device ();\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n \n   bool ret = true;\n-  gomp_mutex_lock (&dev->openacc.async.lock);\n-  for (goacc_aq_list l = dev->openacc.async.active; l; l = l->next)\n-    ret &= dev->openacc.async.synchronize_func (l->aq);\n-  gomp_mutex_unlock (&dev->openacc.async.lock);\n+  gomp_mutex_lock (&thr->dev->openacc.async.lock);\n+  for (goacc_aq_list l = thr->dev->openacc.async.active; l; l = l->next)\n+    ret &= thr->dev->openacc.async.synchronize_func (l->aq);\n+  gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n \n   if (!ret)\n     gomp_fatal (\"wait all failed\");\n@@ -255,6 +319,15 @@ acc_wait_all_async (int async)\n {\n   struct goacc_thread *thr = get_goacc_thread ();\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   goacc_aq waiting_queue = lookup_goacc_asyncqueue (thr, true, async);\n \n   bool ret = true;\n@@ -270,6 +343,12 @@ acc_wait_all_async (int async)\n     }\n   gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n \n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+\n   if (!ret)\n     gomp_fatal (\"wait all async(%d) failed\", async);\n }"}, {"sha": "07951df5bb0f9cc7aeb5848813d358e0c61dd515", "filename": "libgomp/oacc-cuda.c", "status": "modified", "additions": 71, "deletions": 10, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-cuda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-cuda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-cuda.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -37,21 +37,47 @@ acc_get_current_cuda_device (void)\n {\n   struct goacc_thread *thr = goacc_thread ();\n \n+  void *ret = NULL;\n   if (thr && thr->dev && thr->dev->openacc.cuda.get_current_device_func)\n-    return thr->dev->openacc.cuda.get_current_device_func ();\n+    {\n+      acc_prof_info prof_info;\n+      acc_api_info api_info;\n+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n+      ret = thr->dev->openacc.cuda.get_current_device_func ();\n+\n+      if (profiling_p)\n+\t{\n+\t  thr->prof_info = NULL;\n+\t  thr->api_info = NULL;\n+\t}\n+    }\n \n-  return NULL;\n+  return ret;\n }\n \n void *\n acc_get_current_cuda_context (void)\n {\n   struct goacc_thread *thr = goacc_thread ();\n \n+  void *ret = NULL;\n   if (thr && thr->dev && thr->dev->openacc.cuda.get_current_context_func)\n-    return thr->dev->openacc.cuda.get_current_context_func ();\n- \n-  return NULL;\n+    {\n+      acc_prof_info prof_info;\n+      acc_api_info api_info;\n+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n+      ret = thr->dev->openacc.cuda.get_current_context_func ();\n+\n+      if (profiling_p)\n+\t{\n+\t  thr->prof_info = NULL;\n+\t  thr->api_info = NULL;\n+\t}\n+    }\n+\n+  return ret;\n }\n \n void *\n@@ -62,14 +88,32 @@ acc_get_cuda_stream (int async)\n   if (!async_valid_p (async))\n     return NULL;\n \n+  void *ret = NULL;\n   if (thr && thr->dev && thr->dev->openacc.cuda.get_stream_func)\n     {\n       goacc_aq aq = lookup_goacc_asyncqueue (thr, false, async);\n-      if (aq)\n-\treturn thr->dev->openacc.cuda.get_stream_func (aq);\n+      if (!aq)\n+\treturn ret;\n+\n+      acc_prof_info prof_info;\n+      acc_api_info api_info;\n+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+      if (profiling_p)\n+\t{\n+\t  prof_info.async = async;\n+\t  prof_info.async_queue = prof_info.async;\n+\t}\n+\n+      ret = thr->dev->openacc.cuda.get_stream_func (aq);\n+\n+      if (profiling_p)\n+\t{\n+\t  thr->prof_info = NULL;\n+\t  thr->api_info = NULL;\n+\t}\n     }\n- \n-  return NULL;\n+\n+  return ret;\n }\n \n int\n@@ -87,6 +131,15 @@ acc_set_cuda_stream (int async, void *stream)\n   int ret = -1;\n   if (thr && thr->dev && thr->dev->openacc.cuda.set_stream_func)\n     {\n+      acc_prof_info prof_info;\n+      acc_api_info api_info;\n+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+      if (profiling_p)\n+\t{\n+\t  prof_info.async = async;\n+\t  prof_info.async_queue = prof_info.async;\n+\t}\n+\n       goacc_aq aq = get_goacc_asyncqueue (async);\n       /* Due to not using an asyncqueue for \"acc_async_sync\", this cannot be\n \t used to change the CUDA stream associated with \"acc_async_sync\".  */\n@@ -95,11 +148,19 @@ acc_set_cuda_stream (int async, void *stream)\n \t  assert (async == acc_async_sync);\n \t  gomp_debug (0, \"Refusing request to set CUDA stream associated\"\n \t\t      \" with \\\"acc_async_sync\\\"\\n\");\n-\t  return 0;\n+\t  ret = 0;\n+\t  goto out_prof;\n \t}\n       gomp_mutex_lock (&thr->dev->openacc.async.lock);\n       ret = thr->dev->openacc.cuda.set_stream_func (aq, stream);\n       gomp_mutex_unlock (&thr->dev->openacc.async.lock);\n+\n+    out_prof:\n+      if (profiling_p)\n+\t{\n+\t  thr->prof_info = NULL;\n+\t  thr->api_info = NULL;\n+\t}\n     }\n \n   return ret;"}, {"sha": "e1568c535b32cd08c588393e89691f2a18954397", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 116, "deletions": 8, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -210,8 +210,67 @@ acc_dev_num_out_of_range (acc_device_t d, int ord, int ndevs)\n    held before calling this function.  */\n \n static struct gomp_device_descr *\n-acc_init_1 (acc_device_t d)\n+acc_init_1 (acc_device_t d, acc_construct_t parent_construct, int implicit)\n {\n+  bool check_not_nested_p;\n+  if (implicit)\n+    {\n+      /* In the implicit case, there should (TODO: must?) already be something\n+\t have been set up for an outer construct.  */\n+      check_not_nested_p = false;\n+    }\n+  else\n+    {\n+      check_not_nested_p = true;\n+      /* TODO: should we set 'thr->prof_info' etc. in this case ('acc_init')?\n+\t The problem is, that we don't have 'thr' yet?  (So,\n+\t 'check_not_nested_p = true' also is pointless actually.)  */\n+    }\n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (check_not_nested_p);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_device_init_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = d;\n+      prof_info.device_number = goacc_device_num;\n+      prof_info.thread_id = -1;\n+      prof_info.async = acc_async_sync;\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info device_init_event_info;\n+  if (profiling_p)\n+    {\n+      device_init_event_info.other_event.event_type = prof_info.event_type;\n+      device_init_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      device_init_event_info.other_event.parent_construct = parent_construct;\n+      device_init_event_info.other_event.implicit = implicit;\n+      device_init_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &device_init_event_info, &api_info);\n+\n   struct gomp_device_descr *base_dev, *acc_dev;\n   int ndevs;\n \n@@ -234,6 +293,14 @@ acc_init_1 (acc_device_t d)\n   gomp_init_device (acc_dev);\n   gomp_mutex_unlock (&acc_dev->lock);\n \n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_device_init_end;\n+      device_init_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &device_init_event_info,\n+\t\t\t\t&api_info);\n+    }\n+\n   return base_dev;\n }\n \n@@ -423,7 +490,11 @@ goacc_attach_host_thread_to_device (int ord)\n   thr->dev = acc_dev = &base_dev[ord];\n   thr->saved_bound_dev = NULL;\n   thr->mapped_data = NULL;\n-  \n+  thr->prof_info = NULL;\n+  thr->api_info = NULL;\n+  /* Initially, all callbacks for all events are enabled.  */\n+  thr->prof_callbacks_enabled = true;\n+\n   thr->target_tls\n     = acc_dev->openacc.create_thread_data_func (ord);\n }\n@@ -437,9 +508,7 @@ acc_init (acc_device_t d)\n   gomp_init_targets_once ();\n \n   gomp_mutex_lock (&acc_device_lock);\n-\n-  cached_base_dev = acc_init_1 (d);\n-\n+  cached_base_dev = acc_init_1 (d, acc_construct_runtime_api, 0);\n   gomp_mutex_unlock (&acc_device_lock);\n   \n   goacc_attach_host_thread_to_device (-1);\n@@ -498,6 +567,12 @@ acc_set_device_type (acc_device_t d)\n   struct gomp_device_descr *base_dev, *acc_dev;\n   struct goacc_thread *thr = goacc_thread ();\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    prof_info.device_type = d;\n+\n   gomp_init_targets_once ();\n \n   gomp_mutex_lock (&acc_device_lock);\n@@ -522,6 +597,12 @@ acc_set_device_type (acc_device_t d)\n     }\n \n   goacc_attach_host_thread_to_device (-1);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n ialias (acc_set_device_type)\n@@ -537,12 +618,22 @@ acc_get_device_type (void)\n     res = acc_device_type (thr->base_dev->type);\n   else\n     {\n+      acc_prof_info prof_info;\n+      acc_api_info api_info;\n+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n       gomp_init_targets_once ();\n \n       gomp_mutex_lock (&acc_device_lock);\n       dev = resolve_device (acc_device_default, true);\n       gomp_mutex_unlock (&acc_device_lock);\n       res = acc_device_type (dev->type);\n+\n+      if (profiling_p)\n+\t{\n+\t  thr->prof_info = NULL;\n+\t  thr->api_info = NULL;\n+\t}\n     }\n \n   assert (res != acc_device_default\n@@ -562,12 +653,24 @@ acc_get_device_num (acc_device_t d)\n   if (d >= _ACC_device_hwm)\n     gomp_fatal (\"unknown device type %u\", (unsigned) d);\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    prof_info.device_type = d;\n+\n   gomp_init_targets_once ();\n \n   gomp_mutex_lock (&acc_device_lock);\n   dev = resolve_device (d, true);\n   gomp_mutex_unlock (&acc_device_lock);\n \n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+\n   if (thr && thr->base_dev == dev && thr->dev)\n     return thr->dev->target_id;\n \n@@ -689,8 +792,13 @@ goacc_lazy_initialize (void)\n   if (thr && thr->dev)\n     return;\n \n+  gomp_init_targets_once ();\n+\n+  gomp_mutex_lock (&acc_device_lock);\n   if (!cached_base_dev)\n-    acc_init (acc_device_default);\n-  else\n-    goacc_attach_host_thread_to_device (-1);\n+    cached_base_dev = acc_init_1 (acc_device_default,\n+\t\t\t\t  acc_construct_parallel, 1);\n+  gomp_mutex_unlock (&acc_device_lock);\n+\n+  goacc_attach_host_thread_to_device (-1);\n }"}, {"sha": "5ca9944601e289d926778b95fd2c630552a4070d", "filename": "libgomp/oacc-int.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-int.h?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -40,6 +40,7 @@\n \n #include \"openacc.h\"\n #include \"config.h\"\n+#include \"acc_prof.h\"\n #include <stddef.h>\n #include <stdbool.h>\n #include <stdarg.h>\n@@ -68,6 +69,12 @@ struct goacc_thread\n      strictly push/pop semantics according to lexical scope.  */\n   struct target_mem_desc *mapped_data;\n \n+  /* Data of the OpenACC Profiling Interface.  */\n+  acc_prof_info *prof_info;\n+  acc_api_info *api_info;\n+  /* Per-thread toggle of OpenACC Profiling Interface callbacks.  */\n+  bool prof_callbacks_enabled;\n+\n   /* These structures form a list: this is the next thread in that list.  */\n   struct goacc_thread *next;\n \n@@ -128,6 +135,28 @@ async_synchronous_p (int async)\n   return async == acc_async_sync;\n }\n \n+\n+extern bool goacc_prof_enabled;\n+/* Tune for the (very common) case that profiling is not enabled.  */\n+#define GOACC_PROF_ENABLED \\\n+  (__builtin_expect (__atomic_load_n (&goacc_prof_enabled, \\\n+\t\t\t\t      MEMMODEL_ACQUIRE) == true, false))\n+\n+void goacc_profiling_initialize (void);\n+bool _goacc_profiling_dispatch_p (bool);\n+/* Tune for the (very common) case that profiling is not enabled.  */\n+#define GOACC_PROFILING_DISPATCH_P(...) \\\n+  (GOACC_PROF_ENABLED \\\n+   && _goacc_profiling_dispatch_p (__VA_ARGS__))\n+bool _goacc_profiling_setup_p (struct goacc_thread *,\n+\t\t\t       acc_prof_info *, acc_api_info *);\n+/* Tune for the (very common) case that profiling is not enabled.  */\n+#define GOACC_PROFILING_SETUP_P(...) \\\n+  (GOACC_PROFILING_DISPATCH_P (false) \\\n+   && _goacc_profiling_setup_p (__VA_ARGS__))\n+void goacc_profiling_dispatch (acc_prof_info *, acc_event_info *,\n+\t\t\t       acc_api_info *);\n+\n #ifdef HAVE_ATTRIBUTE_VISIBILITY\n # pragma GCC visibility pop\n #endif"}, {"sha": "0f3832f52b3ed4aa5d74bdd5924e4f3c96d55741", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 112, "deletions": 1, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -108,7 +108,19 @@ acc_malloc (size_t s)\n   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return malloc (s);\n \n-  return thr->dev->alloc_func (thr->dev->target_id, s);\n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n+  void *res = thr->dev->alloc_func (thr->dev->target_id, s);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+\n+  return res;\n }\n \n /* OpenACC 2.0a (3.2.16) doesn't specify what to do in the event\n@@ -131,6 +143,10 @@ acc_free (void *d)\n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return free (d);\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n   gomp_mutex_lock (&acc_dev->lock);\n \n   /* We don't have to call lazy open here, as the ptr value must have\n@@ -151,6 +167,12 @@ acc_free (void *d)\n \n   if (!acc_dev->free_func (acc_dev->target_id, d))\n     gomp_fatal (\"error in freeing device memory in %s\", __FUNCTION__);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n static void\n@@ -172,11 +194,26 @@ memcpy_tofrom_device (bool from, void *d, void *h, size_t s, int async,\n       return;\n     }\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   goacc_aq aq = get_goacc_asyncqueue (async);\n   if (from)\n     gomp_copy_dev2host (thr->dev, aq, h, d, s);\n   else\n     gomp_copy_host2dev (thr->dev, aq, d, h, s, /* TODO: cbuf? */ NULL);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void\n@@ -221,6 +258,9 @@ acc_deviceptr (void *h)\n   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return h;\n \n+  /* In the following, no OpenACC Profiling Interface events can possibly be\n+     generated.  */\n+\n   gomp_mutex_lock (&dev->lock);\n \n   n = lookup_host (dev, h, 1);\n@@ -258,6 +298,9 @@ acc_hostptr (void *d)\n   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return d;\n \n+  /* In the following, no OpenACC Profiling Interface events can possibly be\n+     generated.  */\n+\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_dev (acc_dev->openacc.data_environ, d, 1);\n@@ -295,6 +338,9 @@ acc_is_present (void *h, size_t s)\n   if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return h != NULL;\n \n+  /* In the following, no OpenACC Profiling Interface events can possibly be\n+     generated.  */\n+\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_host (acc_dev, h, s);\n@@ -339,6 +385,10 @@ acc_map_data (void *h, void *d, size_t s)\n \tgomp_fatal (\"[%p,+%d]->[%p,+%d] is a bad map\",\n                     (void *)h, (int)s, (void *)d, (int)s);\n \n+      acc_prof_info prof_info;\n+      acc_api_info api_info;\n+      bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n       gomp_mutex_lock (&acc_dev->lock);\n \n       if (lookup_host (acc_dev, h, s))\n@@ -360,6 +410,12 @@ acc_map_data (void *h, void *d, size_t s)\n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, &devaddrs, &sizes,\n \t\t\t   &kinds, true, GOMP_MAP_VARS_OPENACC);\n       tgt->list[0].key->refcount = REFCOUNT_INFINITY;\n+\n+      if (profiling_p)\n+\t{\n+\t  thr->prof_info = NULL;\n+\t  thr->api_info = NULL;\n+\t}\n     }\n \n   gomp_mutex_lock (&acc_dev->lock);\n@@ -380,6 +436,10 @@ acc_unmap_data (void *h)\n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return;\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+\n   size_t host_size;\n \n   gomp_mutex_lock (&acc_dev->lock);\n@@ -433,6 +493,12 @@ acc_unmap_data (void *h)\n   gomp_mutex_unlock (&acc_dev->lock);\n \n   gomp_unmap_vars (t, true);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n #define FLAG_PRESENT (1 << 0)\n@@ -456,6 +522,15 @@ present_create_copy (unsigned f, void *h, size_t s, int async)\n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return h;\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_host (acc_dev, h, s);\n@@ -518,6 +593,12 @@ present_create_copy (unsigned f, void *h, size_t s, int async)\n       gomp_mutex_unlock (&acc_dev->lock);\n     }\n \n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+\n   return d;\n }\n \n@@ -599,6 +680,15 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return;\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_host (acc_dev, h, s);\n@@ -672,6 +762,12 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void\n@@ -737,6 +833,15 @@ update_dev_host (int is_dev, void *h, size_t s, int async)\n   if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return;\n \n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   gomp_mutex_lock (&acc_dev->lock);\n \n   n = lookup_host (acc_dev, h, s);\n@@ -758,6 +863,12 @@ update_dev_host (int is_dev, void *h, size_t s, int async)\n     gomp_copy_dev2host (acc_dev, aq, h, d, s);\n \n   gomp_mutex_unlock (&acc_dev->lock);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void"}, {"sha": "e56330f6226b35391898a7f10cfe2fd6ff1240d4", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 436, "deletions": 24, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -152,21 +152,75 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n   thr = goacc_thread ();\n   acc_dev = thr->dev;\n \n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      thr->prof_info = &prof_info;\n+\n+      prof_info.event_type = acc_ev_compute_construct_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = acc_device_type (acc_dev->type);\n+      prof_info.device_number = acc_dev->target_id;\n+      prof_info.thread_id = -1;\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info compute_construct_event_info;\n+  if (profiling_p)\n+    {\n+      compute_construct_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      compute_construct_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      compute_construct_event_info.other_event.parent_construct\n+\t= acc_construct_parallel;\n+      compute_construct_event_info.other_event.implicit = 0;\n+      compute_construct_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      thr->api_info = &api_info;\n+\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &compute_construct_event_info,\n+\t\t\t      &api_info);\n+\n   handle_ftn_pointers (mapnum, hostaddrs, sizes, kinds);\n \n   /* Host fallback if \"if\" clause is false or if the current device is set to\n      the host.  */\n   if (flags & GOACC_FLAG_HOST_FALLBACK)\n     {\n+      prof_info.device_type = acc_device_host;\n+      api_info.device_type = prof_info.device_type;\n       goacc_save_and_set_bind (acc_device_host);\n       fn (hostaddrs);\n       goacc_restore_bind ();\n-      return;\n+      goto out_prof;\n     }\n   else if (acc_device_type (acc_dev->type) == acc_device_host)\n     {\n       fn (hostaddrs);\n-      return;\n+      goto out_prof;\n     }\n \n   /* Default: let the runtime choose.  */\n@@ -200,6 +254,13 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n \n \t    if (async == GOMP_LAUNCH_OP_MAX)\n \t      async = va_arg (ap, unsigned);\n+\n+\t    if (profiling_p)\n+\t      {\n+\t\tprof_info.async = async;\n+\t\tprof_info.async_queue = prof_info.async;\n+\t      }\n+\n \t    break;\n \t  }\n \n@@ -233,28 +294,81 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n   else\n     tgt_fn = (void (*)) fn;\n \n+  acc_event_info enter_exit_data_event_info;\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_enter_data_start;\n+      enter_exit_data_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      enter_exit_data_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      enter_exit_data_event_info.other_event.parent_construct\n+\t= compute_construct_event_info.other_event.parent_construct;\n+      enter_exit_data_event_info.other_event.implicit = 1;\n+      enter_exit_data_event_info.other_event.tool_info = NULL;\n+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t\t&api_info);\n+    }\n+\n   goacc_aq aq = get_goacc_asyncqueue (async);\n \n   tgt = gomp_map_vars_async (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,\n \t\t\t     true, GOMP_MAP_VARS_OPENACC);\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_enter_data_end;\n+      enter_exit_data_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t\t&api_info);\n+    }\n   \n   devaddrs = gomp_alloca (sizeof (void *) * mapnum);\n   for (i = 0; i < mapnum; i++)\n     devaddrs[i] = (void *) (tgt->list[i].key->tgt->tgt_start\n \t\t\t    + tgt->list[i].key->tgt_offset\n \t\t\t    + tgt->list[i].offset);\n   if (aq == NULL)\n+    acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs, dims,\n+\t\t\t\ttgt);\n+  else\n+    acc_dev->openacc.async.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,\n+\t\t\t\t      dims, tgt, aq);\n+\n+  if (profiling_p)\n     {\n-      acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,\n-\t\t\t\t  dims, tgt);\n-      /* If running synchronously, unmap immediately.  */\n-      gomp_unmap_vars (tgt, true);\n+      prof_info.event_type = acc_ev_exit_data_start;\n+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;\n+      enter_exit_data_event_info.other_event.tool_info = NULL;\n+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t\t&api_info);\n     }\n+\n+  /* If running synchronously, unmap immediately.  */\n+  if (aq == NULL)\n+    gomp_unmap_vars (tgt, true);\n   else\n+    gomp_unmap_vars_async (tgt, true, aq);\n+\n+  if (profiling_p)\n     {\n-      acc_dev->openacc.async.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs,\n-\t\t\t\t\tdims, tgt, aq);\n-      gomp_unmap_vars_async (tgt, true, aq);\n+      prof_info.event_type = acc_ev_exit_data_end;\n+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t\t&api_info);\n+    }\n+\n+ out_prof:\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_compute_construct_end;\n+      compute_construct_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &compute_construct_event_info,\n+\t\t\t\t&api_info);\n+\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n     }\n }\n \n@@ -293,16 +407,83 @@ GOACC_data_start (int flags_m, size_t mapnum,\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      thr->prof_info = &prof_info;\n+\n+      prof_info.event_type = acc_ev_enter_data_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = acc_device_type (acc_dev->type);\n+      prof_info.device_number = acc_dev->target_id;\n+      prof_info.thread_id = -1;\n+      prof_info.async = acc_async_sync; /* Always synchronous.  */\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info enter_data_event_info;\n+  if (profiling_p)\n+    {\n+      enter_data_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      enter_data_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      enter_data_event_info.other_event.parent_construct = acc_construct_data;\n+      for (int i = 0; i < mapnum; ++i)\n+\tif ((kinds[i] & 0xff) == GOMP_MAP_USE_DEVICE_PTR)\n+\t  {\n+\t    /* If there is one such data mapping kind, then this is actually an\n+\t       OpenACC 'host_data' construct.  (GCC maps the OpenACC\n+\t       'host_data' construct to the OpenACC 'data' construct.)  Apart\n+\t       from artificial test cases (such as an OpenACC 'host_data'\n+\t       construct's (implicit) device initialization when there hasn't\n+\t       been any device data be set up before...), there can't really\n+\t       any meaningful events be generated from OpenACC 'host_data'\n+\t       constructs, though.  */\n+\t    enter_data_event_info.other_event.parent_construct\n+\t      = acc_construct_host_data;\n+\t    break;\n+\t  }\n+      enter_data_event_info.other_event.implicit = 0;\n+      enter_data_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      thr->api_info = &api_info;\n+\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &enter_data_event_info, &api_info);\n+\n   /* Host fallback or 'do nothing'.  */\n   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n       || (flags & GOACC_FLAG_HOST_FALLBACK))\n     {\n+      prof_info.device_type = acc_device_host;\n+      api_info.device_type = prof_info.device_type;\n       tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true,\n \t\t\t   GOMP_MAP_VARS_OPENACC);\n       tgt->prev = thr->mapped_data;\n       thr->mapped_data = tgt;\n \n-      return;\n+      goto out_prof;\n     }\n \n   gomp_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n@@ -311,18 +492,90 @@ GOACC_data_start (int flags_m, size_t mapnum,\n   gomp_debug (0, \"  %s: mappings prepared\\n\", __FUNCTION__);\n   tgt->prev = thr->mapped_data;\n   thr->mapped_data = tgt;\n+\n+ out_prof:\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_enter_data_end;\n+      enter_data_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &enter_data_event_info, &api_info);\n+\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void\n GOACC_data_end (void)\n {\n   struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *acc_dev = thr->dev;\n   struct target_mem_desc *tgt = thr->mapped_data;\n \n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      thr->prof_info = &prof_info;\n+\n+      prof_info.event_type = acc_ev_exit_data_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = acc_device_type (acc_dev->type);\n+      prof_info.device_number = acc_dev->target_id;\n+      prof_info.thread_id = -1;\n+      prof_info.async = acc_async_sync; /* Always synchronous.  */\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info exit_data_event_info;\n+  if (profiling_p)\n+    {\n+      exit_data_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      exit_data_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      exit_data_event_info.other_event.parent_construct = acc_construct_data;\n+      exit_data_event_info.other_event.implicit = 0;\n+      exit_data_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      thr->api_info = &api_info;\n+\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &exit_data_event_info, &api_info);\n+\n   gomp_debug (0, \"  %s: restore mappings\\n\", __FUNCTION__);\n   thr->mapped_data = tgt->prev;\n   gomp_unmap_vars (tgt, true);\n   gomp_debug (0, \"  %s: mappings restored\\n\", __FUNCTION__);\n+\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_exit_data_end;\n+      exit_data_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &exit_data_event_info, &api_info);\n+\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void\n@@ -342,19 +595,6 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n   thr = goacc_thread ();\n   acc_dev = thr->dev;\n \n-  if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-      || (flags & GOACC_FLAG_HOST_FALLBACK))\n-    return;\n-\n-  if (num_waits)\n-    {\n-      va_list ap;\n-\n-      va_start (ap, num_waits);\n-      goacc_wait (async, num_waits, &ap);\n-      va_end (ap);\n-    }\n-\n   /* Determine whether \"finalize\" semantics apply to all mappings of this\n      OpenACC directive.  */\n   bool finalize = false;\n@@ -394,6 +634,77 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t\t      kind);\n     }\n \n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      thr->prof_info = &prof_info;\n+\n+      prof_info.event_type\n+\t= data_enter ? acc_ev_enter_data_start : acc_ev_exit_data_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = acc_device_type (acc_dev->type);\n+      prof_info.device_number = acc_dev->target_id;\n+      prof_info.thread_id = -1;\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info enter_exit_data_event_info;\n+  if (profiling_p)\n+    {\n+      enter_exit_data_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      enter_exit_data_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      enter_exit_data_event_info.other_event.parent_construct\n+\t= data_enter ? acc_construct_enter_data : acc_construct_exit_data;\n+      enter_exit_data_event_info.other_event.implicit = 0;\n+      enter_exit_data_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      thr->api_info = &api_info;\n+\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t      &api_info);\n+\n+  if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+      || (flags & GOACC_FLAG_HOST_FALLBACK))\n+    {\n+      prof_info.device_type = acc_device_host;\n+      api_info.device_type = prof_info.device_type;\n+\n+      goto out_prof;\n+    }\n+\n+  if (num_waits)\n+    {\n+      va_list ap;\n+\n+      va_start (ap, num_waits);\n+      goacc_wait (async, num_waits, &ap);\n+      va_end (ap);\n+    }\n+\n   /* In c, non-pointers and arrays are represented by a single data clause.\n      Dynamically allocated arrays and subarrays are represented by a data\n      clause followed by an internal GOMP_MAP_POINTER.\n@@ -486,6 +797,19 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t    i += pointer - 1;\n \t  }\n       }\n+\n+ out_prof:\n+  if (profiling_p)\n+    {\n+      prof_info.event_type\n+\t= data_enter ? acc_ev_enter_data_end : acc_ev_exit_data_end;\n+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t\t&api_info);\n+\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n static void\n@@ -534,9 +858,64 @@ GOACC_update (int flags_m, size_t mapnum,\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      thr->prof_info = &prof_info;\n+\n+      prof_info.event_type = acc_ev_update_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = acc_device_type (acc_dev->type);\n+      prof_info.device_number = acc_dev->target_id;\n+      prof_info.thread_id = -1;\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info update_event_info;\n+  if (profiling_p)\n+    {\n+      update_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      update_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      update_event_info.other_event.parent_construct = acc_construct_update;\n+      update_event_info.other_event.implicit = 0;\n+      update_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      thr->api_info = &api_info;\n+\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &update_event_info, &api_info);\n+\n   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n       || (flags & GOACC_FLAG_HOST_FALLBACK))\n-    return;\n+    {\n+      prof_info.device_type = acc_device_host;\n+      api_info.device_type = prof_info.device_type;\n+\n+      goto out_prof;\n+    }\n \n   if (num_waits)\n     {\n@@ -608,11 +987,38 @@ GOACC_update (int flags_m, size_t mapnum,\n \t  break;\n \t}\n     }\n+\n+ out_prof:\n+  if (profiling_p)\n+    {\n+      prof_info.event_type = acc_ev_update_end;\n+      update_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &update_event_info, &api_info);\n+\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n void\n GOACC_wait (int async, int num_waits, ...)\n {\n+  goacc_lazy_initialize ();\n+\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  /* No nesting.  */\n+  assert (thr->prof_info == NULL);\n+  assert (thr->api_info == NULL);\n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n   if (num_waits)\n     {\n       va_list ap;\n@@ -625,6 +1031,12 @@ GOACC_wait (int async, int num_waits, ...)\n     acc_wait_all ();\n   else\n     acc_wait_all_async (async);\n+\n+  if (profiling_p)\n+    {\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n }\n \n /* Legacy entry point (GCC 5).  */"}, {"sha": "b4f71a11c18b1f9e84a92e480fb305949f40ba10", "filename": "libgomp/oacc-plugin.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -29,6 +29,7 @@\n #include \"libgomp.h\"\n #include \"oacc-plugin.h\"\n #include \"oacc-int.h\"\n+#include \"acc_prof.h\"\n \n /* This plugin function is now obsolete.  */\n void\n@@ -38,6 +39,14 @@ GOMP_PLUGIN_async_unmap_vars (void *ptr __attribute__((unused)),\n   gomp_fatal (\"invalid plugin function\");\n }\n \n+/* Return the TLS data for the current thread.  */\n+\n+struct goacc_thread *\n+GOMP_PLUGIN_goacc_thread (void)\n+{\n+  return goacc_thread ();\n+}\n+\n /* Return the target-specific part of the TLS data for the current thread.  */\n \n void *\n@@ -57,3 +66,11 @@ GOMP_PLUGIN_acc_default_dim (unsigned int i)\n     }\n   return goacc_default_dims[i];\n }\n+\n+void\n+GOMP_PLUGIN_goacc_profiling_dispatch (acc_prof_info *prof_info,\n+\t\t\t\t      acc_event_info *event_info,\n+\t\t\t\t      acc_api_info *api_info)\n+{\n+  goacc_profiling_dispatch (prof_info, event_info, api_info);\n+}"}, {"sha": "887c6f601253a066df6bd6e657bc8f924d7fc8b9", "filename": "libgomp/oacc-plugin.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.h?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -27,8 +27,15 @@\n #ifndef OACC_PLUGIN_H\n #define OACC_PLUGIN_H 1\n \n+#include \"oacc-int.h\"\n+#include \"acc_prof.h\"\n+\n extern void GOMP_PLUGIN_async_unmap_vars (void *, int);\n+extern struct goacc_thread *GOMP_PLUGIN_goacc_thread (void);\n extern void *GOMP_PLUGIN_acc_thread (void);\n extern int GOMP_PLUGIN_acc_default_dim (unsigned int);\n+extern void GOMP_PLUGIN_goacc_profiling_dispatch (acc_prof_info *,\n+\t\t\t\t\t\t  acc_event_info *,\n+\t\t\t\t\t\t  acc_api_info *);\n \n #endif"}, {"sha": "eff28865089524eed052131ced495dba87367d9c", "filename": "libgomp/oacc-profiling.c", "status": "added", "additions": 662, "deletions": 0, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-profiling.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Foacc-profiling.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-profiling.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,662 @@\n+/* OpenACC Profiling Interface\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   Contributed by Mentor, a Siemens Business.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define _GNU_SOURCE\n+#include \"libgomp.h\"\n+#include \"oacc-int.h\"\n+#include \"secure_getenv.h\"\n+#include \"acc_prof.h\"\n+#include <assert.h>\n+#ifdef HAVE_STRING_H\n+# include <string.h>\n+#endif\n+#ifdef PLUGIN_SUPPORT\n+# include <dlfcn.h>\n+#endif\n+\n+#define STATIC_ASSERT(expr) _Static_assert (expr, \"!(\" #expr \")\")\n+\n+/* Statically assert that the layout of the common fields in the\n+   'acc_event_info' variants matches.  */\n+/* 'event_type' */\n+STATIC_ASSERT (offsetof (acc_event_info, event_type)\n+\t       == offsetof (acc_event_info, data_event.event_type));\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.event_type)\n+\t       == offsetof (acc_event_info, launch_event.event_type));\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.event_type)\n+\t       == offsetof (acc_event_info, other_event.event_type));\n+/* 'valid_bytes' */\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.valid_bytes)\n+\t       == offsetof (acc_event_info, launch_event.valid_bytes));\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.valid_bytes)\n+\t       == offsetof (acc_event_info, other_event.valid_bytes));\n+/* 'parent_construct' */\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.parent_construct)\n+\t       == offsetof (acc_event_info, launch_event.parent_construct));\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.parent_construct)\n+\t       == offsetof (acc_event_info, other_event.parent_construct));\n+/* 'implicit' */\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.implicit)\n+\t       == offsetof (acc_event_info, launch_event.implicit));\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.implicit)\n+\t       == offsetof (acc_event_info, other_event.implicit));\n+/* 'tool_info' */\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.tool_info)\n+\t       == offsetof (acc_event_info, launch_event.tool_info));\n+STATIC_ASSERT (offsetof (acc_event_info, data_event.tool_info)\n+\t       == offsetof (acc_event_info, other_event.tool_info));\n+\n+struct goacc_prof_callback_entry\n+{\n+  acc_prof_callback cb;\n+  int ref;\n+  bool enabled;\n+  struct goacc_prof_callback_entry *next;\n+};\n+\n+/* Use a separate flag to minimize run-time performance impact for the (very\n+   common) case that profiling is not enabled.\n+\n+   Once enabled, we're not going to disable this anymore, anywhere.  We\n+   probably could, by adding appropriate logic to 'acc_prof_register',\n+   'acc_prof_unregister'.  */\n+bool goacc_prof_enabled = false;\n+\n+/* Global state for registered callbacks.\n+   'goacc_prof_callbacks_enabled[acc_ev_none]' acts as a global toggle.  */\n+static bool goacc_prof_callbacks_enabled[acc_ev_last];\n+static struct goacc_prof_callback_entry *goacc_prof_callback_entries[acc_ev_last];\n+/* Lock used to protect access to 'goacc_prof_callbacks_enabled', and\n+   'goacc_prof_callback_entries'.  */\n+static gomp_mutex_t goacc_prof_lock;\n+\n+void\n+goacc_profiling_initialize (void)\n+{\n+  gomp_mutex_init (&goacc_prof_lock);\n+\n+  /* Initially, all callbacks for all events are enabled.  */\n+  for (int i = 0; i < acc_ev_last; ++i)\n+    goacc_prof_callbacks_enabled[i] = true;\n+\n+\n+#ifdef PLUGIN_SUPPORT\n+  char *acc_proflibs = secure_getenv (\"ACC_PROFLIB\");\n+  while (acc_proflibs != NULL && acc_proflibs[0] != '\\0')\n+    {\n+      char *acc_proflibs_sep = strchr (acc_proflibs, ';');\n+      char *acc_proflib;\n+      if (acc_proflibs_sep == acc_proflibs)\n+\t{\n+\t  /* Stray ';' separator: make sure we don't 'dlopen' the main\n+\t     program.  */\n+\t  acc_proflib = NULL;\n+\t}\n+      else\n+\t{\n+\t  if (acc_proflibs_sep != NULL)\n+\t    {\n+\t      /* Single out the first library.  */\n+\t      acc_proflib = gomp_malloc (acc_proflibs_sep - acc_proflibs + 1);\n+\t      memcpy (acc_proflib, acc_proflibs,\n+\t\t      acc_proflibs_sep - acc_proflibs);\n+\t      acc_proflib[acc_proflibs_sep - acc_proflibs] = '\\0';\n+\t    }\n+\t  else\n+\t    {\n+\t      /* No ';' separator, so only one library.  */\n+\t      acc_proflib = acc_proflibs;\n+\t    }\n+\n+\t  gomp_debug (0, \"%s: dlopen (\\\"%s\\\")\\n\", __FUNCTION__, acc_proflib);\n+\t  void *dl_handle = dlopen (acc_proflib, RTLD_LAZY);\n+\t  if (dl_handle != NULL)\n+\t    {\n+\t      typeof (&acc_register_library) a_r_l\n+\t\t= dlsym (dl_handle, \"acc_register_library\");\n+\t      if (a_r_l == NULL)\n+\t\tgoto dl_fail;\n+\t      gomp_debug (0, \"  %s: calling %s:acc_register_library\\n\",\n+\t\t\t  __FUNCTION__, acc_proflib);\n+\t      a_r_l (acc_prof_register, acc_prof_unregister,\n+\t\t     acc_prof_lookup);\n+\t    }\n+\t  else\n+\t    {\n+\t    dl_fail:\n+\t      gomp_error (\"while loading ACC_PROFLIB \\\"%s\\\": %s\",\n+\t\t\t  acc_proflib, dlerror ());\n+\t      if (dl_handle != NULL)\n+\t\t{\n+\t\t  int err = dlclose (dl_handle);\n+\t\t  dl_handle = NULL;\n+\t\t  if (err != 0)\n+\t\t    goto dl_fail;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (acc_proflib != acc_proflibs)\n+\t{\n+\t  free (acc_proflib);\n+\n+\t  acc_proflibs = acc_proflibs_sep + 1;\n+\t}\n+      else\n+\tacc_proflibs = NULL;\n+    }\n+#endif /* PLUGIN_SUPPORT */\n+}\n+\n+void\n+acc_prof_register (acc_event_t ev, acc_prof_callback cb, acc_register_t reg)\n+{\n+  gomp_debug (0, \"%s: ev=%d, cb=%p, reg=%d\\n\",\n+\t      __FUNCTION__, (int) ev, (void *) cb, (int) reg);\n+\n+\n+  /* For any events to be dispatched, the user first has to register a\n+     callback, which makes this here a good place for enabling the whole\n+     machinery.  */\n+  if (!GOACC_PROF_ENABLED)\n+    __atomic_store_n (&goacc_prof_enabled, true, MEMMODEL_RELEASE);\n+\n+\n+  enum\n+  {\n+    EVENT_KIND_BOGUS,\n+    EVENT_KIND_NORMAL,\n+    /* As end events invoke callbacks in the reverse order, we register these\n+       in the reverse order here.  */\n+    EVENT_KIND_END,\n+  } event_kind = EVENT_KIND_BOGUS;\n+  switch (ev)\n+    {\n+    case acc_ev_none:\n+    case acc_ev_device_init_start:\n+    case acc_ev_device_shutdown_start:\n+    case acc_ev_runtime_shutdown:\n+    case acc_ev_create:\n+    case acc_ev_delete:\n+    case acc_ev_alloc:\n+    case acc_ev_free:\n+    case acc_ev_enter_data_start:\n+    case acc_ev_exit_data_start:\n+    case acc_ev_update_start:\n+    case acc_ev_compute_construct_start:\n+    case acc_ev_enqueue_launch_start:\n+    case acc_ev_enqueue_upload_start:\n+    case acc_ev_enqueue_download_start:\n+    case acc_ev_wait_start:\n+      event_kind = EVENT_KIND_NORMAL;\n+      break;\n+    case acc_ev_device_init_end:\n+    case acc_ev_device_shutdown_end:\n+    case acc_ev_enter_data_end:\n+    case acc_ev_exit_data_end:\n+    case acc_ev_update_end:\n+    case acc_ev_compute_construct_end:\n+    case acc_ev_enqueue_launch_end:\n+    case acc_ev_enqueue_upload_end:\n+    case acc_ev_enqueue_download_end:\n+    case acc_ev_wait_end:\n+      event_kind = EVENT_KIND_END;\n+      break;\n+    case acc_ev_last:\n+      break;\n+    }\n+  if (event_kind == EVENT_KIND_BOGUS)\n+    {\n+      /* Silently ignore.  */\n+      gomp_debug (0, \"  ignoring request for bogus 'acc_event_t'\\n\");\n+      return;\n+    }\n+\n+  bool bogus = true;\n+  switch (reg)\n+    {\n+    case acc_reg:\n+    case acc_toggle:\n+    case acc_toggle_per_thread:\n+      bogus = false;\n+      break;\n+    }\n+  if (bogus)\n+    {\n+      /* Silently ignore.  */\n+      gomp_debug (0, \"  ignoring request with bogus 'acc_register_t'\\n\");\n+      return;\n+    }\n+\n+  /* Special cases.  */\n+  if (reg == acc_toggle)\n+    {\n+      if (cb == NULL)\n+\t{\n+\t  gomp_debug (0, \"  globally enabling callbacks\\n\");\n+\t  gomp_mutex_lock (&goacc_prof_lock);\n+\t  /* For 'acc_ev_none', this acts as a global toggle.  */\n+\t  goacc_prof_callbacks_enabled[ev] = true;\n+\t  gomp_mutex_unlock (&goacc_prof_lock);\n+\t  return;\n+\t}\n+      else if (ev == acc_ev_none && cb != NULL)\n+\t{\n+\t  gomp_debug (0, \"  ignoring request\\n\");\n+\t  return;\n+\t}\n+    }\n+  else if (reg == acc_toggle_per_thread)\n+    {\n+      if (ev == acc_ev_none && cb == NULL)\n+\t{\n+\t  gomp_debug (0, \"  thread: enabling callbacks\\n\");\n+\t  goacc_lazy_initialize ();\n+\t  struct goacc_thread *thr = goacc_thread ();\n+\t  thr->prof_callbacks_enabled = true;\n+\t  return;\n+\t}\n+      /* Silently ignore.  */\n+      gomp_debug (0, \"  ignoring bogus request\\n\");\n+      return;\n+    }\n+\n+  gomp_mutex_lock (&goacc_prof_lock);\n+\n+  struct goacc_prof_callback_entry *it, *it_p;\n+  it = goacc_prof_callback_entries[ev];\n+  it_p = NULL;\n+  while (it)\n+    {\n+      if (it->cb == cb)\n+\tbreak;\n+      it_p = it;\n+      it = it->next;\n+    }\n+\n+  switch (reg)\n+    {\n+    case acc_reg:\n+      /* If we already have this callback registered, just increment its\n+\t reference count.  */\n+      if (it != NULL)\n+\t{\n+\t  it->ref++;\n+\t  gomp_debug (0, \"  already registered;\"\n+\t\t      \" incrementing reference count to: %d\\n\", it->ref);\n+\t}\n+      else\n+\t{\n+\t  struct goacc_prof_callback_entry *e\n+\t    = gomp_malloc (sizeof (struct goacc_prof_callback_entry));\n+\t  e->cb = cb;\n+\t  e->ref = 1;\n+\t  e->enabled = true;\n+\t  bool prepend = (event_kind == EVENT_KIND_END);\n+\t  /* If we don't have any callback registered yet, also use the\n+\t     'prepend' code path.  */\n+\t  if (it_p == NULL)\n+\t    prepend = true;\n+\t  if (prepend)\n+\t    {\n+\t      gomp_debug (0, \"  prepending\\n\");\n+\t      e->next = goacc_prof_callback_entries[ev];\n+\t      goacc_prof_callback_entries[ev] = e;\n+\t    }\n+\t  else\n+\t    {\n+\t      gomp_debug (0, \"  appending\\n\");\n+\t      e->next = NULL;\n+\t      it_p->next = e;\n+\t    }\n+\t}\n+      break;\n+\n+    case acc_toggle:\n+      if (it == NULL)\n+\t{\n+\t  gomp_debug (0, \"  ignoring request: is not registered\\n\");\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  gomp_debug (0, \"  enabling\\n\");\n+\t  it->enabled = true;\n+\t}\n+      break;\n+\n+    case acc_toggle_per_thread:\n+      __builtin_unreachable ();\n+    }\n+\n+  gomp_mutex_unlock (&goacc_prof_lock);\n+}\n+\n+void\n+acc_prof_unregister (acc_event_t ev, acc_prof_callback cb, acc_register_t reg)\n+{\n+  gomp_debug (0, \"%s: ev=%d, cb=%p, reg=%d\\n\",\n+\t      __FUNCTION__, (int) ev, (void *) cb, (int) reg);\n+\n+  /* If profiling is not enabled, there cannot be anything to unregister.  */\n+  if (!GOACC_PROF_ENABLED)\n+    return;\n+\n+  if (ev < acc_ev_none\n+      || ev >= acc_ev_last)\n+    {\n+      /* Silently ignore.  */\n+      gomp_debug (0, \"  ignoring request for bogus 'acc_event_t'\\n\");\n+      return;\n+    }\n+\n+  bool bogus = true;\n+  switch (reg)\n+    {\n+    case acc_reg:\n+    case acc_toggle:\n+    case acc_toggle_per_thread:\n+      bogus = false;\n+      break;\n+    }\n+  if (bogus)\n+    {\n+      /* Silently ignore.  */\n+      gomp_debug (0, \"  ignoring request with bogus 'acc_register_t'\\n\");\n+      return;\n+    }\n+\n+  /* Special cases.  */\n+  if (reg == acc_toggle)\n+    {\n+      if (cb == NULL)\n+\t{\n+\t  gomp_debug (0, \"  globally disabling callbacks\\n\");\n+\t  gomp_mutex_lock (&goacc_prof_lock);\n+\t  /* For 'acc_ev_none', this acts as a global toggle.  */\n+\t  goacc_prof_callbacks_enabled[ev] = false;\n+\t  gomp_mutex_unlock (&goacc_prof_lock);\n+\t  return;\n+\t}\n+      else if (ev == acc_ev_none && cb != NULL)\n+\t{\n+\t  gomp_debug (0, \"  ignoring request\\n\");\n+\t  return;\n+\t}\n+    }\n+  else if (reg == acc_toggle_per_thread)\n+    {\n+      if (ev == acc_ev_none && cb == NULL)\n+\t{\n+\t  gomp_debug (0, \"  thread: disabling callbacks\\n\");\n+\t  goacc_lazy_initialize ();\n+\t  struct goacc_thread *thr = goacc_thread ();\n+\t  thr->prof_callbacks_enabled = false;\n+\t  return;\n+\t}\n+      /* Silently ignore.  */\n+      gomp_debug (0, \"  ignoring bogus request\\n\");\n+      return;\n+    }\n+\n+  gomp_mutex_lock (&goacc_prof_lock);\n+\n+  struct goacc_prof_callback_entry *it, *it_p;\n+  it = goacc_prof_callback_entries[ev];\n+  it_p = NULL;\n+  while (it)\n+    {\n+      if (it->cb == cb)\n+\tbreak;\n+      it_p = it;\n+      it = it->next;\n+    }\n+\n+  switch (reg)\n+    {\n+    case acc_reg:\n+      if (it == NULL)\n+\t{\n+\t  /* Silently ignore.  */\n+\t  gomp_debug (0, \"  ignoring bogus request: is not registered\\n\");\n+\t  break;\n+\t}\n+      it->ref--;\n+      gomp_debug (0, \"  decrementing reference count to: %d\\n\", it->ref);\n+      if (it->ref == 0)\n+\t{\n+\t  if (it_p == NULL)\n+\t    goacc_prof_callback_entries[ev] = it->next;\n+\t  else\n+\t    it_p->next = it->next;\n+\t  free (it);\n+\t}\n+      break;\n+\n+    case acc_toggle:\n+      if (it == NULL)\n+\t{\n+\t  gomp_debug (0, \"  ignoring request: is not registered\\n\");\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  gomp_debug (0, \"  disabling\\n\");\n+\t  it->enabled = false;\n+\t}\n+      break;\n+\n+    case acc_toggle_per_thread:\n+      __builtin_unreachable ();\n+    }\n+\n+  gomp_mutex_unlock (&goacc_prof_lock);\n+}\n+\n+acc_query_fn\n+acc_prof_lookup (const char *name)\n+{\n+  gomp_debug (0, \"%s (%s)\\n\",\n+\t      __FUNCTION__, name ?: \"NULL\");\n+\n+  return NULL;\n+}\n+\n+void\n+acc_register_library (acc_prof_reg reg, acc_prof_reg unreg,\n+\t\t      acc_prof_lookup_func lookup)\n+{\n+  gomp_fatal (\"TODO\");\n+}\n+\n+/* Prepare to dispatch events?  */\n+\n+bool\n+_goacc_profiling_dispatch_p (bool check_not_nested_p)\n+{\n+  gomp_debug (0, \"%s\\n\", __FUNCTION__);\n+\n+  bool ret;\n+\n+  struct goacc_thread *thr = goacc_thread ();\n+  if (__builtin_expect (thr == NULL, false))\n+    {\n+      /* If we don't have any per-thread state yet, that means that per-thread\n+\t callback dispatch has not been explicitly disabled (which only a call\n+\t to 'acc_prof_unregister' with 'acc_toggle_per_thread' would do, and\n+\t that would have allocated per-thread state via\n+\t 'goacc_lazy_initialize'); initially, all callbacks for all events are\n+\t enabled.  */\n+      gomp_debug (0, \"  %s: don't have any per-thread state yet\\n\", __FUNCTION__);\n+    }\n+  else\n+    {\n+      if (check_not_nested_p)\n+\t{\n+\t  /* No nesting.  */\n+\t  assert (thr->prof_info == NULL);\n+\t  assert (thr->api_info == NULL);\n+\t}\n+\n+      if (__builtin_expect (!thr->prof_callbacks_enabled, true))\n+\t{\n+\t  gomp_debug (0, \"  %s: disabled for this thread\\n\", __FUNCTION__);\n+\t  ret = false;\n+\t  goto out;\n+\t}\n+    }\n+\n+  gomp_mutex_lock (&goacc_prof_lock);\n+\n+  /* 'goacc_prof_callbacks_enabled[acc_ev_none]' acts as a global toggle.  */\n+  if (__builtin_expect (!goacc_prof_callbacks_enabled[acc_ev_none], true))\n+    {\n+      gomp_debug (0, \"  %s: disabled globally\\n\", __FUNCTION__);\n+      ret = false;\n+      goto out_unlock;\n+    }\n+  else\n+    ret = true;\n+\n+ out_unlock:\n+  gomp_mutex_unlock (&goacc_prof_lock);\n+\n+ out:\n+  return ret;\n+}\n+\n+/* Set up to dispatch events?  */\n+\n+bool\n+_goacc_profiling_setup_p (struct goacc_thread *thr,\n+\t\t\t  acc_prof_info *prof_info, acc_api_info *api_info)\n+{\n+  gomp_debug (0, \"%s (%p)\\n\", __FUNCTION__, thr);\n+\n+  /* If we don't have any per-thread state yet, we can't register 'prof_info'\n+     and 'api_info'.  */\n+  if (__builtin_expect (thr == NULL, false))\n+    {\n+      gomp_debug (0, \"Can't dispatch OpenACC Profiling Interface events for\"\n+\t\t  \" the current call, construct, or directive\\n\");\n+      return false;\n+    }\n+\n+  if (thr->prof_info != NULL)\n+    {\n+      /* Profiling has already been set up for an outer construct.  In this\n+\t case, we continue to use the existing information, and thus return\n+\t 'false' here.\n+\n+\t This can happen, for example, for an 'enter data' directive, which\n+\t sets up profiling, then calls into 'acc_copyin', which should not\n+\t again set up profiling, should not overwrite the existing\n+\t information.  */\n+      return false;\n+    }\n+\n+  thr->prof_info = prof_info;\n+  thr->api_info = api_info;\n+\n+  /* Fill in some defaults.  */\n+\n+  prof_info->event_type = -1; /* Must be set later.  */\n+  prof_info->valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+  prof_info->version = _ACC_PROF_INFO_VERSION;\n+  if (thr->dev)\n+    {\n+      prof_info->device_type = acc_device_type (thr->dev->type);\n+      prof_info->device_number = thr->dev->target_id;\n+    }\n+  else\n+    {\n+      prof_info->device_type = -1;\n+      prof_info->device_number = -1;\n+    }\n+  prof_info->thread_id = -1;\n+  prof_info->async = acc_async_sync;\n+  prof_info->async_queue = prof_info->async;\n+  prof_info->src_file = NULL;\n+  prof_info->func_name = NULL;\n+  prof_info->line_no = -1;\n+  prof_info->end_line_no = -1;\n+  prof_info->func_line_no = -1;\n+  prof_info->func_end_line_no = -1;\n+\n+  api_info->device_api = acc_device_api_none;\n+  api_info->valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+  api_info->device_type = prof_info->device_type;\n+  api_info->vendor = -1;\n+  api_info->device_handle = NULL;\n+  api_info->context_handle = NULL;\n+  api_info->async_handle = NULL;\n+\n+  return true;\n+}\n+\n+/* Dispatch events.\n+\n+   This must only be called if 'GOACC_PROFILING_DISPATCH_P' or\n+   'GOACC_PROFILING_SETUP_P' returned a true result.  */\n+\n+void\n+goacc_profiling_dispatch (acc_prof_info *prof_info, acc_event_info *event_info,\n+\t\t\t  acc_api_info *apt_info)\n+{\n+  acc_event_t event_type = event_info->event_type;\n+  gomp_debug (0, \"%s: event_type=%d\\n\", __FUNCTION__, (int) event_type);\n+  assert (event_type > acc_ev_none\n+\t  && event_type < acc_ev_last);\n+\n+  gomp_mutex_lock (&goacc_prof_lock);\n+\n+  if (!goacc_prof_callbacks_enabled[event_type])\n+    {\n+      gomp_debug (0, \"  disabled for this event type\\n\");\n+\n+      goto out_unlock;\n+    }\n+\n+  for (struct goacc_prof_callback_entry *e\n+\t = goacc_prof_callback_entries[event_type];\n+       e != NULL;\n+       e = e->next)\n+    {\n+      if (!e->enabled)\n+\t{\n+\t  gomp_debug (0, \"  disabled for callback %p\\n\", e->cb);\n+\t  continue;\n+\t}\n+\n+      gomp_debug (0, \"  calling callback %p\\n\", e->cb);\n+      e->cb (prof_info, event_info, apt_info);\n+    }\n+\n+ out_unlock:\n+  gomp_mutex_unlock (&goacc_prof_lock);\n+}"}, {"sha": "3469116cf61025bff338a9d7be9ab08263c12dde", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 190, "deletions": 6, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -37,6 +37,7 @@\n #include \"libgomp-plugin.h\"\n #include \"oacc-plugin.h\"\n #include \"gomp-constants.h\"\n+#include \"oacc-int.h\"\n \n #include <pthread.h>\n #include <cuda.h>\n@@ -904,27 +905,122 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n   // num_gangs\t\tnctaid.x\n   // num_workers\tntid.y\n   // vector length\tntid.x\n+\n+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n+  acc_prof_info *prof_info = thr->prof_info;\n+  acc_event_info enqueue_launch_event_info;\n+  acc_api_info *api_info = thr->api_info;\n+  bool profiling_p = __builtin_expect (prof_info != NULL, false);\n+  if (profiling_p)\n+    {\n+      prof_info->event_type = acc_ev_enqueue_launch_start;\n+\n+      enqueue_launch_event_info.launch_event.event_type\n+\t= prof_info->event_type;\n+      enqueue_launch_event_info.launch_event.valid_bytes\n+\t= _ACC_LAUNCH_EVENT_INFO_VALID_BYTES;\n+      enqueue_launch_event_info.launch_event.parent_construct\n+\t= acc_construct_parallel;\n+      enqueue_launch_event_info.launch_event.implicit = 1;\n+      enqueue_launch_event_info.launch_event.tool_info = NULL;\n+      enqueue_launch_event_info.launch_event.kernel_name = targ_fn->launch->fn;\n+      enqueue_launch_event_info.launch_event.num_gangs\n+\t= dims[GOMP_DIM_GANG];\n+      enqueue_launch_event_info.launch_event.num_workers\n+\t= dims[GOMP_DIM_WORKER];\n+      enqueue_launch_event_info.launch_event.vector_length\n+\t= dims[GOMP_DIM_VECTOR];\n+\n+      api_info->device_api = acc_device_api_cuda;\n+\n+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &enqueue_launch_event_info,\n+\t\t\t\t\t    api_info);\n+    }\n+\n   kargs[0] = &dp;\n   CUDA_CALL_ASSERT (cuLaunchKernel, function,\n \t\t    dims[GOMP_DIM_GANG], 1, 1,\n \t\t    dims[GOMP_DIM_VECTOR], dims[GOMP_DIM_WORKER], 1,\n \t\t    0, stream, kargs, 0);\n \n+  if (profiling_p)\n+    {\n+      prof_info->event_type = acc_ev_enqueue_launch_end;\n+      enqueue_launch_event_info.launch_event.event_type\n+\t= prof_info->event_type;\n+      GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &enqueue_launch_event_info,\n+\t\t\t\t\t    api_info);\n+    }\n+\n   GOMP_PLUGIN_debug (0, \"  %s: kernel %s: finished\\n\", __FUNCTION__,\n \t\t     targ_fn->launch->fn);\n }\n \n void * openacc_get_current_cuda_context (void);\n \n+static void\n+goacc_profiling_acc_ev_alloc (struct goacc_thread *thr, void *dp, size_t s)\n+{\n+  acc_prof_info *prof_info = thr->prof_info;\n+  acc_event_info data_event_info;\n+  acc_api_info *api_info = thr->api_info;\n+\n+  prof_info->event_type = acc_ev_alloc;\n+\n+  data_event_info.data_event.event_type = prof_info->event_type;\n+  data_event_info.data_event.valid_bytes = _ACC_DATA_EVENT_INFO_VALID_BYTES;\n+  data_event_info.data_event.parent_construct = acc_construct_parallel;\n+  data_event_info.data_event.implicit = 1;\n+  data_event_info.data_event.tool_info = NULL;\n+  data_event_info.data_event.var_name = NULL;\n+  data_event_info.data_event.bytes = s;\n+  data_event_info.data_event.host_ptr = NULL;\n+  data_event_info.data_event.device_ptr = dp;\n+\n+  api_info->device_api = acc_device_api_cuda;\n+\n+  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info, api_info);\n+}\n+\n static void *\n nvptx_alloc (size_t s)\n {\n   CUdeviceptr d;\n \n   CUDA_CALL_ERET (NULL, cuMemAlloc, &d, s);\n+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n+  bool profiling_p\n+    = __builtin_expect (thr != NULL && thr->prof_info != NULL, false);\n+  if (profiling_p)\n+    goacc_profiling_acc_ev_alloc (thr, (void *) d, s);\n+\n   return (void *) d;\n }\n \n+static void\n+goacc_profiling_acc_ev_free (struct goacc_thread *thr, void *p)\n+{\n+  acc_prof_info *prof_info = thr->prof_info;\n+  acc_event_info data_event_info;\n+  acc_api_info *api_info = thr->api_info;\n+\n+  prof_info->event_type = acc_ev_free;\n+\n+  data_event_info.data_event.event_type = prof_info->event_type;\n+  data_event_info.data_event.valid_bytes = _ACC_DATA_EVENT_INFO_VALID_BYTES;\n+  data_event_info.data_event.parent_construct = acc_construct_parallel;\n+  data_event_info.data_event.implicit = 1;\n+  data_event_info.data_event.tool_info = NULL;\n+  data_event_info.data_event.var_name = NULL;\n+  data_event_info.data_event.bytes = -1;\n+  data_event_info.data_event.host_ptr = NULL;\n+  data_event_info.data_event.device_ptr = p;\n+\n+  api_info->device_api = acc_device_api_cuda;\n+\n+  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info, api_info);\n+}\n+\n static bool\n nvptx_free (void *p, struct ptx_device *ptx_dev)\n {\n@@ -952,6 +1048,12 @@ nvptx_free (void *p, struct ptx_device *ptx_dev)\n     }\n \n   CUDA_CALL (cuMemFree, (CUdeviceptr) p);\n+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n+  bool profiling_p\n+    = __builtin_expect (thr != NULL && thr->prof_info != NULL, false);\n+  if (profiling_p)\n+    goacc_profiling_acc_ev_free (thr, p);\n+\n   return true;\n }\n \n@@ -1250,22 +1352,61 @@ GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,\n {\n   GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n \n+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n+  acc_prof_info *prof_info = thr->prof_info;\n+  acc_event_info data_event_info;\n+  acc_api_info *api_info = thr->api_info;\n+  bool profiling_p = __builtin_expect (prof_info != NULL, false);\n+\n   void **hp = NULL;\n   CUdeviceptr dp = 0;\n \n   if (mapnum > 0)\n     {\n-      hp = alloca (mapnum * sizeof (void *));\n+      size_t s = mapnum * sizeof (void *);\n+      hp = alloca (s);\n       for (int i = 0; i < mapnum; i++)\n \thp[i] = (devaddrs[i] ? devaddrs[i] : hostaddrs[i]);\n-      CUDA_CALL_ASSERT (cuMemAlloc, &dp, mapnum * sizeof (void *));\n+      CUDA_CALL_ASSERT (cuMemAlloc, &dp, s);\n+      if (profiling_p)\n+\tgoacc_profiling_acc_ev_alloc (thr, (void *) dp, s);\n     }\n \n   /* Copy the (device) pointers to arguments to the device (dp and hp might in\n      fact have the same value on a unified-memory system).  */\n   if (mapnum > 0)\n-    CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, (void *) hp,\n-\t\t      mapnum * sizeof (void *));\n+    {\n+      if (profiling_p)\n+\t{\n+\t  prof_info->event_type = acc_ev_enqueue_upload_start;\n+\n+\t  data_event_info.data_event.event_type = prof_info->event_type;\n+\t  data_event_info.data_event.valid_bytes\n+\t    = _ACC_DATA_EVENT_INFO_VALID_BYTES;\n+\t  data_event_info.data_event.parent_construct\n+\t    = acc_construct_parallel;\n+\t  data_event_info.data_event.implicit = 1; /* Always implicit.  */\n+\t  data_event_info.data_event.tool_info = NULL;\n+\t  data_event_info.data_event.var_name = NULL;\n+\t  data_event_info.data_event.bytes = mapnum * sizeof (void *);\n+\t  data_event_info.data_event.host_ptr = hp;\n+\t  data_event_info.data_event.device_ptr = (const void *) dp;\n+\n+\t  api_info->device_api = acc_device_api_cuda;\n+\n+\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n+\t\t\t\t\t\tapi_info);\n+\t}\n+      CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, (void *) hp,\n+\t\t\tmapnum * sizeof (void *));\n+      if (profiling_p)\n+\t{\n+\t  prof_info->event_type = acc_ev_enqueue_upload_end;\n+\t  data_event_info.data_event.event_type = prof_info->event_type;\n+\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n+\t\t\t\t\t\tapi_info);\n+\t}\n+    }\n \n   nvptx_exec (fn, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc,\n \t      dp, NULL);\n@@ -1277,7 +1418,10 @@ GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,\n \t\t       maybe_abort_msg);\n   else if (r != CUDA_SUCCESS)\n     GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n+\n   CUDA_CALL_ASSERT (cuMemFree, dp);\n+  if (profiling_p)\n+    goacc_profiling_acc_ev_free (thr, (void *) dp);\n }\n \n static void\n@@ -1296,31 +1440,71 @@ GOMP_OFFLOAD_openacc_async_exec (void (*fn) (void *), size_t mapnum,\n {\n   GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n \n+  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n+  acc_prof_info *prof_info = thr->prof_info;\n+  acc_event_info data_event_info;\n+  acc_api_info *api_info = thr->api_info;\n+  bool profiling_p = __builtin_expect (prof_info != NULL, false);\n+\n   void **hp = NULL;\n   CUdeviceptr dp = 0;\n   void **block = NULL;\n \n   if (mapnum > 0)\n     {\n-      block = (void **) GOMP_PLUGIN_malloc ((mapnum + 2) * sizeof (void *));\n+      size_t s = mapnum * sizeof (void *);\n+      block = (void **) GOMP_PLUGIN_malloc (2 * sizeof (void *) + s);\n       hp = block + 2;\n       for (int i = 0; i < mapnum; i++)\n \thp[i] = (devaddrs[i] ? devaddrs[i] : hostaddrs[i]);\n-      CUDA_CALL_ASSERT (cuMemAlloc, &dp, mapnum * sizeof (void *));\n+      CUDA_CALL_ASSERT (cuMemAlloc, &dp, s);\n+      if (profiling_p)\n+\tgoacc_profiling_acc_ev_alloc (thr, (void *) dp, s);\n     }\n \n   /* Copy the (device) pointers to arguments to the device (dp and hp might in\n      fact have the same value on a unified-memory system).  */\n   if (mapnum > 0)\n     {\n+      if (profiling_p)\n+\t{\n+\t  prof_info->event_type = acc_ev_enqueue_upload_start;\n+\n+\t  data_event_info.data_event.event_type = prof_info->event_type;\n+\t  data_event_info.data_event.valid_bytes\n+\t    = _ACC_DATA_EVENT_INFO_VALID_BYTES;\n+\t  data_event_info.data_event.parent_construct\n+\t    = acc_construct_parallel;\n+\t  data_event_info.data_event.implicit = 1; /* Always implicit.  */\n+\t  data_event_info.data_event.tool_info = NULL;\n+\t  data_event_info.data_event.var_name = NULL;\n+\t  data_event_info.data_event.bytes = mapnum * sizeof (void *);\n+\t  data_event_info.data_event.host_ptr = hp;\n+\t  data_event_info.data_event.device_ptr = (const void *) dp;\n+\n+\t  api_info->device_api = acc_device_api_cuda;\n+\n+\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n+\t\t\t\t\t\tapi_info);\n+\t}\n+\n       CUDA_CALL_ASSERT (cuMemcpyHtoDAsync, dp, (void *) hp,\n \t\t\tmapnum * sizeof (void *), aq->cuda_stream);\n       block[0] = (void *) dp;\n \n       struct nvptx_thread *nvthd =\n \t(struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();\n       block[1] = (void *) nvthd->ptx_dev;\n+\n+      if (profiling_p)\n+\t{\n+\t  prof_info->event_type = acc_ev_enqueue_upload_end;\n+\t  data_event_info.data_event.event_type = prof_info->event_type;\n+\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n+\t\t\t\t\t\tapi_info);\n+\t}\n     }\n+\n   nvptx_exec (fn, mapnum, hostaddrs, devaddrs, dims, targ_mem_desc,\n \t      dp, aq->cuda_stream);\n "}, {"sha": "d929bfd80a4fb380b9489e79e68c328a4349c859", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-dispatch-1.c", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-dispatch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-dispatch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-dispatch-1.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,353 @@\n+/* Test dispatch of events to callbacks.  */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+\n+#include <acc_prof.h>\n+\n+\n+/* Use explicit 'copyin' clauses, to work around \"'firstprivate'\n+   optimizations\", which will cause the value at the point of call to be used\n+   (*before* any potential modifications done in callbacks), as opposed to its\n+   address being taken, which then later gets dereferenced (*after* any\n+   modifications done in callbacks).  */\n+#define COPYIN(...) copyin(__VA_ARGS__)\n+\n+\n+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)\n+\n+\n+static int state = -1;\n+\n+#define STATE_OP(state, op) \\\n+  do \\\n+    { \\\n+      typeof (state) state_o = (state); \\\n+      (void) state_o; \\\n+      (state)op; \\\n+      DEBUG_printf(\"state: %d -> %d\\n\", state_o, (state)); \\\n+    } \\\n+  while (0)\n+\n+\n+static void cb_compute_construct_start_1 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 0\n+\t  || state == 10\n+\t  || state == 30\n+\t  || state == 41\n+\t  || state == 51\n+\t  || state == 91\n+\t  || state == 101\n+\t  || state == 151);\n+  STATE_OP (state, ++);\n+}\n+\n+static void cb_compute_construct_start_2 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 1\n+\t  || state == 11\n+\t  || state == 40\n+\t  || state == 50\n+\t  || state == 90\n+\t  || state == 100\n+\t  || state == 150);\n+  STATE_OP (state, ++);\n+}\n+\n+static void cb_compute_construct_end_1 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 14\n+\t  || state == 21\n+\t  || state == 32\n+\t  || state == 42\n+\t  || state == 80\n+\t  || state == 103\n+\t  || state == 152);\n+  STATE_OP (state, ++);\n+}\n+\n+static void cb_compute_construct_end_2 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 13\n+\t  || state == 43\n+\t  || state == 102\n+\t  || state == 154);\n+  STATE_OP (state, ++);\n+}\n+\n+static void cb_compute_construct_end_3 (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 12\n+\t  || state == 20\n+\t  || state == 31\n+\t  || state == 44\n+\t  || state == 81\n+\t  || state == 104\n+\t  || state == 153);\n+  STATE_OP (state, ++);\n+}\n+\n+\n+static acc_prof_reg reg;\n+static acc_prof_reg unreg;\n+static acc_prof_lookup_func lookup;\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  reg = reg_;\n+  unreg = unreg_;\n+  lookup = lookup_;\n+}\n+\n+\n+int main()\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  STATE_OP (state, = 0);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_reg);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 2);\n+  }\n+  assert (state == 2);\n+\n+  STATE_OP (state, = 10);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 12);\n+  }\n+  assert (state == 15);\n+\n+  STATE_OP (state, = 20);\n+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_toggle);\n+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_toggle);\n+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_toggle);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_toggle);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 20);\n+  }\n+  assert (state == 20);\n+\n+  STATE_OP (state, = 30);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_toggle);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_toggle);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_toggle);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_toggle);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_toggle);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 31);\n+  }\n+  assert (state == 33);\n+\n+  STATE_OP (state, = 40);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_2, acc_reg);\n+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 42);\n+  }\n+  assert (state == 45);\n+\n+  STATE_OP (state, = 50);\n+  unreg (acc_ev_compute_construct_end, NULL, acc_toggle);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 52);\n+  }\n+  assert (state == 52);\n+\n+  STATE_OP (state, = 60);\n+  unreg (acc_ev_compute_construct_end, NULL, acc_toggle);\n+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);\n+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 60);\n+  }\n+  assert (state == 60);\n+\n+  STATE_OP (state, = 70);\n+  unreg (acc_ev_compute_construct_start, NULL, acc_toggle);\n+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 70);\n+  }\n+  assert (state == 70);\n+\n+  STATE_OP (state, = 80);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  reg (acc_ev_compute_construct_end, NULL, acc_toggle);\n+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 80);\n+  }\n+  assert (state == 82);\n+\n+  STATE_OP (state, = 90);\n+  reg (acc_ev_compute_construct_start, NULL, acc_toggle);\n+  unreg (acc_ev_compute_construct_end, NULL, acc_toggle);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_2, acc_reg);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 92);\n+  }\n+  assert (state == 92);\n+\n+  STATE_OP (state, = 100);\n+  reg (acc_ev_compute_construct_end, NULL, acc_toggle);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 102);\n+  }\n+  assert (state == 105);\n+\n+  STATE_OP (state, = 110);\n+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle);\n+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 110);\n+  }\n+  assert (state == 110);\n+\n+  STATE_OP (state, = 120);\n+  unreg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 120);\n+  }\n+  assert (state == 120);\n+\n+  STATE_OP (state, = 130);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_3, acc_reg);\n+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 130);\n+  }\n+  assert (state == 130);\n+\n+  STATE_OP (state, = 140);\n+  unreg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start_1, acc_reg);\n+  unreg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end_1, acc_reg);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 140);\n+  }\n+  assert (state == 140);\n+\n+  STATE_OP (state, = 150);\n+  reg (/* TODO */ (acc_event_t) 0, NULL, acc_toggle_per_thread);\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+    assert (state_init == 152);\n+  }\n+  assert (state == 155);\n+\n+  return 0;\n+}"}, {"sha": "b356feb8108ca7add09963ee373adb4f690f6456", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-init-1.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,316 @@\n+/* Test dispatch of events to callbacks.  */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <acc_prof.h>\n+\n+\n+/* Use explicit 'copyin' clauses, to work around \"'firstprivate'\n+   optimizations\", which will cause the value at the point of call to be used\n+   (*before* any potential modifications done in callbacks), as opposed to its\n+   address being taken, which then later gets dereferenced (*after* any\n+   modifications done in callbacks).  */\n+#define COPYIN(...) copyin(__VA_ARGS__)\n+\n+\n+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)\n+\n+\n+static int state = -1;\n+\n+#define STATE_OP(state, op) \\\n+  do \\\n+    { \\\n+      typeof (state) state_o = (state); \\\n+      (void) state_o; \\\n+      (state)op; \\\n+      DEBUG_printf(\"state: %d -> %d\\n\", state_o, (state)); \\\n+    } \\\n+  while (0)\n+\n+\n+static acc_device_t acc_device_type;\n+static int acc_device_num;\n+static int acc_async;\n+\n+\n+struct tool_info\n+{\n+  acc_event_info event_info;\n+  struct tool_info *nested;\n+};\n+struct tool_info *tool_info;\n+\n+static void cb_device_init_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 0\n+\t  || state == 100);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info == NULL);\n+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info != NULL);\n+  tool_info->nested = NULL;\n+\n+  assert (prof_info->event_type == acc_ev_device_init_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  if (state == 1)\n+    assert (prof_info->device_type == acc_device_host);\n+  else\n+    assert (prof_info->device_type == acc_device_default);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_runtime_api);\n+  assert (event_info->other_event.implicit == 0);\n+  assert (event_info->other_event.tool_info == NULL);\n+\n+  assert (api_info->device_api == acc_device_api_none);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info;\n+}\n+\n+static void cb_device_init_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 1\n+\t  || state == 101);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_device_init_start);\n+\n+  assert (prof_info->event_type == acc_ev_device_init_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  if (state == 2)\n+    assert (prof_info->device_type == acc_device_host);\n+  else\n+    assert (prof_info->device_type == acc_device_default);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_runtime_api);\n+  assert (event_info->other_event.implicit == 0);\n+  assert (event_info->other_event.tool_info == tool_info);\n+\n+  assert (api_info->device_api == acc_device_api_none);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  free (tool_info);\n+  tool_info = NULL;\n+}\n+\n+static void cb_compute_construct_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 10\n+\t  || state == 110);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info == NULL);\n+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info != NULL);\n+  tool_info->nested = NULL;\n+\n+  assert (prof_info->event_type == acc_ev_compute_construct_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == /* TODO acc_async */ acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 0);\n+  assert (event_info->other_event.tool_info == NULL);\n+\n+  assert (api_info->device_api == acc_device_api_none);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info;\n+}\n+\n+static void cb_compute_construct_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 11\n+\t  || state == 111);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested == NULL);\n+\n+  assert (prof_info->event_type == acc_ev_compute_construct_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  if (acc_device_type == acc_device_host)\n+    assert (prof_info->async == acc_async_sync);\n+  else\n+    assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 0);\n+  assert (event_info->other_event.tool_info == tool_info);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  free (tool_info);\n+  tool_info = NULL;\n+}\n+\n+\n+static acc_prof_reg reg;\n+static acc_prof_reg unreg;\n+static acc_prof_lookup_func lookup;\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  reg = reg_;\n+  unreg = unreg_;\n+  lookup = lookup_;\n+}\n+\n+\n+int main()\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  STATE_OP (state, = 0);\n+  reg (acc_ev_device_init_start, cb_device_init_start, acc_reg);\n+  reg (acc_ev_device_init_end, cb_device_init_end, acc_reg);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end, acc_reg);\n+  assert (state == 0);\n+\n+  acc_init (acc_device_host);\n+  assert (state == 2);\n+\n+  STATE_OP (state, = 10);\n+\n+  acc_device_type = acc_get_device_type ();\n+  acc_device_num = acc_get_device_num (acc_device_type);\n+  acc_async = 12;\n+\n+  {\n+    int state_init;\n+#pragma acc parallel async(acc_async) COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+#pragma acc wait\n+    assert (state_init == 11);\n+  }\n+  assert (state == 12);\n+\n+  STATE_OP (state, = 90);\n+  acc_shutdown (acc_device_host);\n+  assert (state == 90);\n+\n+\n+  STATE_OP (state, = 100);\n+  acc_init (acc_device_default);\n+  assert (state == 102);\n+\n+  STATE_OP (state, = 110);\n+\n+  acc_device_type = acc_get_device_type ();\n+  acc_device_num = acc_get_device_num (acc_device_type);\n+  acc_async = 12;\n+\n+  {\n+    int state_init;\n+#pragma acc parallel async(acc_async) COPYIN(state) copyout(state_init)\n+    {\n+      state_init = state;\n+    }\n+#pragma acc wait\n+    assert (state_init == 111);\n+  }\n+  assert (state == 112);\n+\n+  STATE_OP (state, = 190);\n+  acc_shutdown (acc_device_default);\n+  assert (state == 190);\n+\n+  return 0;\n+}"}, {"sha": "7cfc364e4113fd11a255ed349eda389a8e9026ce", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-kernels-1.c", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-kernels-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-kernels-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-kernels-1.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,229 @@\n+/* Test dispatch of events to callbacks.  */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <acc_prof.h>\n+\n+\n+/* Use explicit 'copyin' clauses, to work around \"'firstprivate'\n+   optimizations\", which will cause the value at the point of call to be used\n+   (*before* any potential modifications done in callbacks), as opposed to its\n+   address being taken, which then later gets dereferenced (*after* any\n+   modifications done in callbacks).  */\n+#define COPYIN(...) copyin(__VA_ARGS__)\n+\n+\n+/* See the 'DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT' reference in\n+   'libgomp.texi'.  */\n+#define DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT 0\n+\n+\n+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)\n+\n+\n+volatile // TODO PR90488\n+static int state = -1;\n+\n+#define STATE_OP(state, op) \\\n+  do \\\n+    { \\\n+      typeof (state) state_o = (state); \\\n+      (void) state_o; \\\n+      (state)op; \\\n+      DEBUG_printf(\"state: %d -> %d\\n\", state_o, (state)); \\\n+    } \\\n+  while (0)\n+\n+\n+static acc_device_t acc_device_type;\n+static int acc_device_num;\n+static int num_gangs, num_workers, vector_length;\n+\n+\n+static void cb_enqueue_launch_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (acc_device_type != acc_device_host);\n+\n+  assert (state == 0);\n+  STATE_OP (state, = 1);\n+\n+  assert (prof_info->event_type == acc_ev_enqueue_launch_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->launch_event.event_type == prof_info->event_type);\n+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->launch_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->launch_event.implicit == 1);\n+  assert (event_info->launch_event.tool_info == NULL);\n+  assert (event_info->launch_event.kernel_name != NULL);\n+  {\n+    const char *s = strstr (event_info->launch_event.kernel_name, \"main\");\n+    assert (s != NULL);\n+    s = strstr (s, \"omp_fn\");\n+    assert (s != NULL);\n+  }\n+  if (num_gangs < 1)\n+    assert (event_info->launch_event.num_gangs >= 1);\n+  else\n+    {\n+#ifdef __OPTIMIZE__\n+      assert (event_info->launch_event.num_gangs == num_gangs);\n+#else\n+      /* No parallelized OpenACC 'kernels' constructs.  Unparallelized OpenACC\n+\t 'kernels' constructs must get launched as 1 x 1 x 1 GPU kernels.  */\n+      assert (event_info->launch_event.num_gangs == 1);\n+#endif\n+    }\n+  if (num_workers < 1)\n+    assert (event_info->launch_event.num_workers >= 1);\n+  else\n+    {\n+#ifdef __OPTIMIZE__\n+      assert (event_info->launch_event.num_workers == num_workers);\n+#else\n+      /* See 'num_gangs' above.  */\n+      assert (event_info->launch_event.num_workers == 1);\n+#endif\n+    }\n+  if (vector_length < 1)\n+    assert (event_info->launch_event.vector_length >= 1);\n+  else if (acc_device_type == acc_device_nvidia) /* ... is special.  */\n+    assert (event_info->launch_event.vector_length == 32);\n+  else\n+    {\n+#ifdef __OPTIMIZE__\n+      assert (event_info->launch_event.vector_length == vector_length);\n+#else\n+      /* See 'num_gangs' above.  */\n+      assert (event_info->launch_event.vector_length == 1);\n+#endif\n+    }\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+}\n+\n+\n+static acc_prof_reg reg;\n+static acc_prof_reg unreg;\n+static acc_prof_lookup_func lookup;\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  reg = reg_;\n+  unreg = unreg_;\n+  lookup = lookup_;\n+}\n+\n+\n+int main()\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  STATE_OP (state, = 0);\n+  reg (acc_ev_enqueue_launch_start, cb_enqueue_launch_start, acc_reg);\n+  assert (state == 0);\n+\n+  acc_device_type = acc_get_device_type ();\n+  acc_device_num = acc_get_device_num (acc_device_type);\n+  assert (state == 0);\n+\n+  /* Parallelism dimensions: compiler/runtime decides.  */\n+  STATE_OP (state, = 0);\n+  num_gangs = num_workers = vector_length = 0;\n+  {\n+#define N 100\n+    int x[N];\n+#pragma acc kernels\n+    {\n+      for (int i = 0; i < N; ++i)\n+\tx[i] = i * i;\n+    }\n+    if (acc_device_type == acc_device_host)\n+      assert (state == 0); /* No 'acc_ev_enqueue_launch_start'.  */\n+    else\n+      assert (state == 1);\n+    for (int i = 0; i < N; ++i)\n+      if (x[i] != i * i)\n+\t__builtin_abort ();\n+#undef N\n+  }\n+\n+  /* Parallelism dimensions: literal.  */\n+  STATE_OP (state, = 0);\n+  num_gangs = 30;\n+  num_workers = 3;\n+  vector_length = 5;\n+  {\n+#define N 100\n+    int x[N];\n+#pragma acc kernels \\\n+  num_gangs (30) num_workers (3) vector_length (5)\n+    /* { dg-prune-output \"using vector_length \\\\(32\\\\), ignoring 5\" } */\n+    {\n+      for (int i = 0; i < N; ++i)\n+\tx[i] = i * i;\n+    }\n+    if (acc_device_type == acc_device_host)\n+      assert (state == 0); /* No 'acc_ev_enqueue_launch_start'.  */\n+    else\n+      assert (state == 1);\n+    for (int i = 0; i < N; ++i)\n+      if (x[i] != i * i)\n+\t__builtin_abort ();\n+#undef N\n+  }\n+\n+  /* Parallelism dimensions: variable.  */\n+  STATE_OP (state, = 0);\n+  num_gangs = 22;\n+  num_workers = 5;\n+  vector_length = 7;\n+  {\n+#define N 100\n+    int x[N];\n+#pragma acc kernels \\\n+  num_gangs (num_gangs) num_workers (num_workers) vector_length (vector_length)\n+    /* { dg-prune-output \"using vector_length \\\\(32\\\\), ignoring runtime setting\" } */\n+    {\n+      for (int i = 0; i < N; ++i)\n+\tx[i] = i * i;\n+    }\n+    if (acc_device_type == acc_device_host)\n+      assert (state == 0); /* No 'acc_ev_enqueue_launch_start'.  */\n+    else\n+      assert (state == 1);\n+    for (int i = 0; i < N; ++i)\n+      if (x[i] != i * i)\n+\t__builtin_abort ();\n+#undef N\n+  }\n+\n+  return 0;\n+}"}, {"sha": "ac6eb48cbbef860e996fd94c277099effa52f2a3", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c", "status": "added", "additions": 719, "deletions": 0, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-parallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-parallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-parallel-1.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,719 @@\n+/* Test dispatch of events to callbacks.  */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <acc_prof.h>\n+\n+\n+/* Use explicit 'copyin' clauses, to work around \"'firstprivate'\n+   optimizations\", which will cause the value at the point of call to be used\n+   (*before* any potential modifications done in callbacks), as opposed to its\n+   address being taken, which then later gets dereferenced (*after* any\n+   modifications done in callbacks).  */\n+#define COPYIN(...) copyin(__VA_ARGS__)\n+\n+\n+/* See the 'DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT' reference in\n+   libgomp.texi.  */\n+#define DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT 0\n+\n+\n+/* Do we expect to see 'acc_ev_exit_data_start' and 'acc_ev_exit_data_end'\n+   after a compute construct with an 'async' clause?  */\n+#define ASYNC_EXIT_DATA 1\n+\n+\n+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)\n+\n+\n+static int state = -1;\n+\n+#define STATE_OP(state, op) \\\n+  do \\\n+    { \\\n+      typeof (state) state_o = (state); \\\n+      (void) state_o; \\\n+      (state)op; \\\n+      DEBUG_printf(\"state: %d -> %d\\n\", state_o, (state)); \\\n+    } \\\n+  while (0)\n+\n+\n+static acc_device_t acc_device_type;\n+static int acc_device_num;\n+static int acc_async;\n+\n+\n+struct tool_info\n+{\n+  acc_event_info event_info;\n+  struct tool_info *nested;\n+};\n+struct tool_info *tool_info;\n+\n+static void cb_device_init_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n+  assert (state == 1\n+\t  || state == 101);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested == NULL);\n+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info->nested != NULL);\n+  tool_info->nested->nested = NULL;\n+#else\n+  assert (state == 0\n+\t  || state == 100);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info == NULL);\n+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info != NULL);\n+  tool_info->nested = NULL;\n+#endif\n+\n+  assert (prof_info->event_type == acc_ev_device_init_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_default);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 1);\n+  assert (event_info->other_event.tool_info == NULL);\n+\n+  assert (api_info->device_api == acc_device_api_none);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n+  tool_info->nested->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info->nested;\n+#else\n+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info;\n+#endif\n+}\n+\n+static void cb_device_init_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n+  assert (state == 2\n+\t  || state == 102);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested != NULL);\n+  assert (tool_info->nested->event_info.other_event.event_type == acc_ev_device_init_start);\n+#else\n+  assert (state == 1\n+\t  || state == 101);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_device_init_start);\n+#endif\n+\n+  assert (prof_info->event_type == acc_ev_device_init_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_default);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 1);\n+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n+  assert (event_info->other_event.tool_info == tool_info->nested);\n+#else\n+  assert (event_info->other_event.tool_info == tool_info);\n+#endif\n+\n+  assert (api_info->device_api == acc_device_api_none);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n+  free (tool_info->nested);\n+  tool_info->nested = NULL;\n+#else\n+  free (tool_info);\n+  tool_info = NULL;\n+#endif\n+}\n+\n+static void cb_enter_data_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 3\n+\t  || state == 103);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested == NULL);\n+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info->nested != NULL);\n+  tool_info->nested->nested = NULL;\n+\n+  assert (prof_info->event_type == acc_ev_enter_data_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 1);\n+  assert (event_info->other_event.tool_info == NULL);\n+\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  tool_info->nested->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info->nested;\n+}\n+\n+static void cb_enter_data_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 4\n+\t  || state == 104);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested != NULL);\n+  assert (tool_info->nested->event_info.other_event.event_type == acc_ev_enter_data_start);\n+\n+  assert (prof_info->event_type == acc_ev_enter_data_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 1);\n+  assert (event_info->other_event.tool_info == tool_info->nested);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  free (tool_info->nested);\n+  tool_info->nested = NULL;\n+}\n+\n+static void cb_exit_data_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 7\n+#if ASYNC_EXIT_DATA\n+\t  || state == 107\n+#endif\n+\t  );\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested == NULL);\n+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info->nested != NULL);\n+  tool_info->nested->nested = NULL;\n+\n+  assert (prof_info->event_type == acc_ev_exit_data_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 1);\n+  assert (event_info->other_event.tool_info == NULL);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  tool_info->nested->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info->nested;\n+}\n+\n+static void cb_exit_data_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (state == 8\n+#if ASYNC_EXIT_DATA\n+\t  || state == 108\n+#endif\n+\t  );\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested != NULL);\n+  assert (tool_info->nested->event_info.other_event.event_type == acc_ev_exit_data_start);\n+\n+  assert (prof_info->event_type == acc_ev_exit_data_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 1);\n+  assert (event_info->other_event.tool_info == tool_info->nested);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  free (tool_info->nested);\n+  tool_info->nested = NULL;\n+}\n+\n+static void cb_compute_construct_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+#if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n+  assert (state == 0\n+\t  || state == 100);\n+  if (state == 100)\n+    {\n+      /* Compensate for the missing 'acc_ev_device_init_start' and\n+\t 'acc_ev_device_init_end'.  */\n+      state += 2;\n+    }\n+#else\n+  if (state == 100)\n+    {\n+      /* Compensate for the missing 'acc_ev_device_init_start' and\n+\t 'acc_ev_device_init_end'.  */\n+      state += 2;\n+    }\n+  assert (state == 2\n+\t  || state == 102);\n+#endif\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info == NULL);\n+  tool_info = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info != NULL);\n+  tool_info->nested = NULL;\n+\n+  assert (prof_info->event_type == acc_ev_compute_construct_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == /* TODO acc_async */ acc_async_sync);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 0);\n+  assert (event_info->other_event.tool_info == NULL);\n+\n+  assert (api_info->device_api == acc_device_api_none);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  tool_info->event_info.other_event.event_type = event_info->other_event.event_type;\n+  event_info->other_event.tool_info = tool_info;\n+\n+  if (acc_device_type == acc_device_host)\n+    {\n+      /* Compensate for the missing 'acc_ev_enter_data_start'.  */\n+      state += 1;\n+    }\n+}\n+\n+static void cb_compute_construct_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  if (acc_device_type == acc_device_host)\n+    {\n+      /* Compensate for the missing 'acc_ev_enter_data_end'.  */\n+      state += 1;\n+      /* Compensate for the missing 'acc_ev_enqueue_launch_start' and\n+\t 'acc_ev_enqueue_launch_end'.  */\n+      state += 2;\n+      /* Compensate for the missing 'acc_ev_exit_data_start' and\n+\t 'acc_ev_exit_data_end'.  */\n+      state += 2;\n+    }\n+#if !ASYNC_EXIT_DATA\n+  else if (acc_async != acc_async_sync)\n+    {\n+      /* Compensate for the missing 'acc_ev_exit_data_start' and\n+\t 'acc_ev_exit_data_end'.  */\n+      state += 2;\n+    }\n+#endif\n+  assert (state == 9\n+\t  || state == 109);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested == NULL);\n+\n+  assert (prof_info->event_type == acc_ev_compute_construct_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  if (acc_device_type == acc_device_host)\n+    assert (prof_info->async == acc_async_sync);\n+  else\n+    assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->other_event.event_type == prof_info->event_type);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->other_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->other_event.implicit == 0);\n+  assert (event_info->other_event.tool_info == tool_info);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  free (tool_info);\n+  tool_info = NULL;\n+}\n+\n+static void cb_enqueue_launch_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (acc_device_type != acc_device_host);\n+\n+  assert (state == 5\n+\t  || state == 105);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested == NULL);\n+  tool_info->nested = (struct tool_info *) malloc(sizeof *tool_info);\n+  assert (tool_info->nested != NULL);\n+  tool_info->nested->nested = NULL;\n+\n+  assert (prof_info->event_type == acc_ev_enqueue_launch_start);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->launch_event.event_type == prof_info->event_type);\n+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->launch_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->launch_event.implicit == 1);\n+  assert (event_info->launch_event.tool_info == NULL);\n+  assert (event_info->launch_event.kernel_name != NULL);\n+  {\n+    const char *s = strstr (event_info->launch_event.kernel_name, \"main\");\n+    assert (s != NULL);\n+    s = strstr (s, \"omp_fn\");\n+    assert (s != NULL);\n+  }\n+  assert (event_info->launch_event.num_gangs >= 1);\n+  assert (event_info->launch_event.num_workers >= 1);\n+  assert (event_info->launch_event.vector_length >= 1);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  tool_info->nested->event_info.launch_event.event_type = event_info->launch_event.event_type;\n+  tool_info->nested->event_info.launch_event.kernel_name = strdup (event_info->launch_event.kernel_name);\n+  tool_info->nested->event_info.launch_event.num_gangs = event_info->launch_event.num_gangs;\n+  tool_info->nested->event_info.launch_event.num_workers = event_info->launch_event.num_workers;\n+  tool_info->nested->event_info.launch_event.vector_length = event_info->launch_event.vector_length;\n+  event_info->other_event.tool_info = tool_info->nested;\n+}\n+\n+static void cb_enqueue_launch_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  assert (acc_device_type != acc_device_host);\n+\n+  assert (state == 6\n+\t  || state == 106);\n+  STATE_OP (state, ++);\n+\n+  assert (tool_info != NULL);\n+  assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n+  assert (tool_info->nested != NULL);\n+  assert (tool_info->nested->event_info.launch_event.event_type == acc_ev_enqueue_launch_start);\n+  assert (tool_info->nested->event_info.launch_event.kernel_name != NULL);\n+  assert (tool_info->nested->event_info.launch_event.num_gangs >= 1);\n+  assert (tool_info->nested->event_info.launch_event.num_workers >= 1);\n+  assert (tool_info->nested->event_info.launch_event.vector_length >= 1);\n+\n+  assert (prof_info->event_type == acc_ev_enqueue_launch_end);\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (prof_info->version == _ACC_PROF_INFO_VERSION);\n+  assert (prof_info->device_type == acc_device_type);\n+  assert (prof_info->device_number == acc_device_num);\n+  assert (prof_info->thread_id == -1);\n+  assert (prof_info->async == acc_async);\n+  assert (prof_info->async_queue == prof_info->async);\n+  assert (prof_info->src_file == NULL);\n+  assert (prof_info->func_name == NULL);\n+  assert (prof_info->line_no == -1);\n+  assert (prof_info->end_line_no == -1);\n+  assert (prof_info->func_line_no == -1);\n+  assert (prof_info->func_end_line_no == -1);\n+\n+  assert (event_info->launch_event.event_type == prof_info->event_type);\n+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);\n+  assert (event_info->launch_event.parent_construct == acc_construct_parallel);\n+  assert (event_info->launch_event.implicit == 1);\n+  assert (event_info->launch_event.tool_info == tool_info->nested);\n+  assert (event_info->launch_event.kernel_name != NULL);\n+  assert (strcmp (event_info->launch_event.kernel_name, tool_info->nested->event_info.launch_event.kernel_name) == 0);\n+  assert (event_info->launch_event.num_gangs == tool_info->nested->event_info.launch_event.num_gangs);\n+  assert (event_info->launch_event.num_workers == tool_info->nested->event_info.launch_event.num_workers);\n+  assert (event_info->launch_event.vector_length == tool_info->nested->event_info.launch_event.vector_length);\n+\n+  if (acc_device_type == acc_device_host)\n+    assert (api_info->device_api == acc_device_api_none);\n+  else\n+    assert (api_info->device_api == acc_device_api_cuda);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+  assert (api_info->device_type == prof_info->device_type);\n+  assert (api_info->vendor == -1);\n+  assert (api_info->device_handle == NULL);\n+  assert (api_info->context_handle == NULL);\n+  assert (api_info->async_handle == NULL);\n+\n+  free ((void *) tool_info->nested->event_info.launch_event.kernel_name);\n+  free (tool_info->nested);\n+  tool_info->nested = NULL;\n+}\n+\n+\n+static acc_prof_reg reg;\n+static acc_prof_reg unreg;\n+static acc_prof_lookup_func lookup;\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  reg = reg_;\n+  unreg = unreg_;\n+  lookup = lookup_;\n+}\n+\n+\n+int main()\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  STATE_OP (state, = 0);\n+  reg (acc_ev_device_init_start, cb_device_init_start, acc_reg);\n+  reg (acc_ev_device_init_end, cb_device_init_end, acc_reg);\n+  reg (acc_ev_enter_data_start, cb_enter_data_start, acc_reg);\n+  reg (acc_ev_enter_data_end, cb_enter_data_end, acc_reg);\n+  reg (acc_ev_exit_data_start, cb_exit_data_start, acc_reg);\n+  reg (acc_ev_exit_data_end, cb_exit_data_end, acc_reg);\n+  reg (acc_ev_compute_construct_start, cb_compute_construct_start, acc_reg);\n+  reg (acc_ev_compute_construct_end, cb_compute_construct_end, acc_reg);\n+  reg (acc_ev_enqueue_launch_start, cb_enqueue_launch_start, acc_reg);\n+  reg (acc_ev_enqueue_launch_end, cb_enqueue_launch_end, acc_reg);\n+  assert (state == 0);\n+\n+  acc_device_type = acc_get_device_type ();\n+  acc_device_num = acc_get_device_num (acc_device_type);\n+  acc_async = acc_async_sync;\n+  assert (state == 0);\n+\n+  {\n+    int state_init;\n+#pragma acc parallel COPYIN(state) copyout(state_init)\n+    {\n+      asm volatile (\"\" : : : \"memory\"); // TODO PR90488\n+\n+      state_init = state;\n+    }\n+    assert (state_init == 4);\n+  }\n+  assert (state == 10);\n+\n+  STATE_OP (state, = 100);\n+\n+  acc_async = 12;\n+  {\n+    int state_init;\n+#pragma acc parallel async(acc_async) COPYIN(state) copyout(state_init)\n+    {\n+      asm volatile (\"\" : : : \"memory\"); // TODO PR90488\n+\n+      state_init = state;\n+    }\n+#pragma acc wait\n+    assert (state_init == 104);\n+  }\n+  assert (state == 110);\n+\n+  return 0;\n+}"}, {"sha": "5b58c51d4c42bbd3a6eb522b05ff47813977a55d", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-valid_bytes-1.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-valid_bytes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-valid_bytes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-valid_bytes-1.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,226 @@\n+/* Test the 'valid_bytes' magic.  */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+\n+#include <acc_prof.h>\n+\n+\n+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)\n+\n+\n+static int ev_count_data;\n+\n+static void cb_data_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s %d\\n\", __FUNCTION__, prof_info->event_type);\n+\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (event_info->data_event.valid_bytes == _ACC_DATA_EVENT_INFO_VALID_BYTES);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+\n+  ++ev_count_data;\n+}\n+\n+static int ev_count_launch;\n+\n+static void cb_launch_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s %d\\n\", __FUNCTION__, prof_info->event_type);\n+\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (event_info->launch_event.valid_bytes == _ACC_LAUNCH_EVENT_INFO_VALID_BYTES);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+\n+  ++ev_count_launch;\n+}\n+\n+static int ev_count_other;\n+\n+static void cb_other_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s %d\\n\", __FUNCTION__, prof_info->event_type);\n+\n+  assert (prof_info->valid_bytes == _ACC_PROF_INFO_VALID_BYTES);\n+  assert (event_info->other_event.valid_bytes == _ACC_OTHER_EVENT_INFO_VALID_BYTES);\n+  assert (api_info->valid_bytes == _ACC_API_INFO_VALID_BYTES);\n+\n+  ++ev_count_other;\n+}\n+\n+\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  reg_ (acc_ev_device_init_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_device_init_end, cb_other_event, acc_reg);\n+  reg_ (acc_ev_device_shutdown_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_device_shutdown_end, cb_other_event, acc_reg);\n+  reg_ (acc_ev_runtime_shutdown, cb_other_event, acc_reg);\n+  reg_ (acc_ev_create, cb_data_event, acc_reg);\n+  reg_ (acc_ev_delete, cb_data_event, acc_reg);\n+  reg_ (acc_ev_alloc, cb_data_event, acc_reg);\n+  reg_ (acc_ev_free, cb_data_event, acc_reg);\n+  reg_ (acc_ev_enter_data_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_enter_data_end, cb_other_event, acc_reg);\n+  reg_ (acc_ev_exit_data_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_exit_data_end, cb_other_event, acc_reg);\n+  reg_ (acc_ev_update_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_update_end, cb_other_event, acc_reg);\n+  reg_ (acc_ev_compute_construct_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_compute_construct_end, cb_other_event, acc_reg);\n+  reg_ (acc_ev_enqueue_launch_start, cb_launch_event, acc_reg);\n+  reg_ (acc_ev_enqueue_launch_end, cb_launch_event, acc_reg);\n+  reg_ (acc_ev_enqueue_upload_start, cb_data_event, acc_reg);\n+  reg_ (acc_ev_enqueue_upload_end, cb_data_event, acc_reg);\n+  reg_ (acc_ev_enqueue_download_start, cb_data_event, acc_reg);\n+  reg_ (acc_ev_enqueue_download_end, cb_data_event, acc_reg);\n+  reg_ (acc_ev_wait_start, cb_other_event, acc_reg);\n+  reg_ (acc_ev_wait_end, cb_other_event, acc_reg);\n+}\n+\n+\n+/* Basic struct.  */\n+typedef struct A\n+{\n+  int a;\n+  int b;\n+#define VALID_BYTES_A \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (A, b, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (int))\n+} A;\n+\n+/* Add a 'char' field.  */\n+typedef struct B\n+{\n+  int a;\n+  int b;\n+  char c;\n+#define VALID_BYTES_B \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (B, c, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (char))\n+} B;\n+\n+/* Add another 'char' field.  */\n+typedef struct C\n+{\n+  int a;\n+  int b;\n+  char c, d;\n+#define VALID_BYTES_C \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (C, d, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (char))\n+} C;\n+\n+/* Add two 'void *' fields.  */\n+typedef struct D\n+{\n+  int a;\n+  int b;\n+  char c, d;\n+  void *e;\n+  void *f;\n+#define VALID_BYTES_D \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (D, f, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (void *))\n+} D;\n+\n+/* Add another three 'char' fields.  */\n+typedef struct E\n+{\n+  int a;\n+  int b;\n+  char c, d;\n+  void *e;\n+  void *f;\n+  char g, h, i;\n+#define VALID_BYTES_E \\\n+  _ACC_PROF_VALID_BYTES_STRUCT (E, i, \\\n+\t\t\t\t_ACC_PROF_VALID_BYTES_BASICTYPE (char))\n+} E;\n+\n+\n+int main()\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  A A1;\n+  DEBUG_printf (\"s=%zd, vb=%zd\\n\", sizeof A1, VALID_BYTES_A);\n+  assert (VALID_BYTES_A <= sizeof A1);\n+  DEBUG_printf (\"&A1=%p, &A1.b=%p\\n\", &A1, &A1.b);\n+  assert (((char *) &A1) + VALID_BYTES_A == (char *) (&A1.b + 1));\n+\n+  B B1;\n+  DEBUG_printf (\"s=%zd, vb=%zd\\n\", sizeof B1, VALID_BYTES_B);\n+  assert (VALID_BYTES_B <= sizeof B1);\n+  DEBUG_printf (\"&B1=%p, &B1.c=%p\\n\", &B1, &B1.c);\n+  assert (((char *) &B1) + VALID_BYTES_B == (char *) (&B1.c + 1));\n+\n+  assert (VALID_BYTES_B == VALID_BYTES_A + 1 * sizeof (char));\n+\n+  C C1;\n+  DEBUG_printf (\"s=%zd, vb=%zd\\n\", sizeof C1, VALID_BYTES_C);\n+  assert (VALID_BYTES_C <= sizeof C1);\n+  DEBUG_printf (\"&C1=%p, &C1.d=%p\\n\", &C1, &C1.d);\n+  assert (((char *) &C1) + VALID_BYTES_C == (char *) (&C1.d + 1));\n+\n+  assert (VALID_BYTES_C == VALID_BYTES_B + 1 * sizeof (char));\n+\n+  D D1;\n+  DEBUG_printf (\"s=%zd, vb=%zd\\n\", sizeof D1, VALID_BYTES_D);\n+  assert (VALID_BYTES_D <= sizeof D1);\n+  DEBUG_printf (\"&D1=%p, &D1.f=%p\\n\", &D1, &D1.f);\n+  assert (((char *) &D1) + VALID_BYTES_D == (char *) (&D1.f + 1));\n+\n+  assert (VALID_BYTES_D > VALID_BYTES_C);\n+\n+  E E1;\n+  DEBUG_printf (\"s=%zd, vb=%zd\\n\", sizeof E1, VALID_BYTES_E);\n+  assert (VALID_BYTES_E <= sizeof E1);\n+  DEBUG_printf (\"&E1=%p, &E1.i=%p\\n\", &E1, &E1.i);\n+  assert (((char *) &E1) + VALID_BYTES_E == (char *) (&E1.i + 1));\n+\n+  assert (VALID_BYTES_E == VALID_BYTES_D + 3 * sizeof (char));\n+\n+  ev_count_data = 0;\n+  ev_count_launch = 0;\n+  ev_count_other = 0;\n+\n+  /* Trigger tests done in 'cb_*' functions.  */\n+  int host;\n+#pragma acc parallel copyout (host)\n+  {\n+    asm volatile (\"\" : : : \"memory\"); // TODO PR90488\n+\n+    host = acc_on_device (acc_device_host);\n+  }\n+\n+  DEBUG_printf (\"ev_count_data = %d\\n\", ev_count_data);\n+  if (host)\n+    assert (ev_count_data == 0);\n+  else\n+    {\n+      /* We don't know exactly how many data events to expect, but we at least\n+\t expect some.  */\n+      assert (ev_count_data > 0);\n+    }\n+\n+  DEBUG_printf (\"ev_count_launch = %d\\n\", ev_count_launch);\n+  if (host)\n+    assert (ev_count_data == 0);\n+  else\n+    {\n+      /* We expect two launch events, 'acc_ev_enqueue_launch_start',\n+\t 'acc_ev_enqueue_launch_end'.  */\n+      assert (ev_count_launch == 2);\n+    }\n+\n+  DEBUG_printf (\"ev_count_other = %d\\n\", ev_count_other);\n+  /* We don't know exactly how many other events to expect, but we at least\n+     expect 'acc_ev_device_init_start', 'acc_ev_device_init_end',\n+     'acc_ev_compute_construct_start', 'acc_ev_compute_construct_end'.  */\n+  assert (ev_count_other >= 4);\n+\n+  return 0;\n+}"}, {"sha": "f53786871671180b62c434362d604a5ae9c2492e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-version-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-version-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fae049dc272144f8e61af94ee0ba42b270915e5/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-version-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-version-1.c?ref=5fae049dc272144f8e61af94ee0ba42b270915e5", "patch": "@@ -0,0 +1,76 @@\n+/* Test the 'version' field of 'acc_prof_info'.  */\n+\n+#undef NDEBUG\n+#include <assert.h>\n+\n+#include <acc_prof.h>\n+\n+\n+#define DEBUG_printf(...) //__builtin_printf (__VA_ARGS__)\n+\n+\n+static int ev_count;\n+\n+\n+static void cb_any_event (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  DEBUG_printf (\"%s %d\\n\", __FUNCTION__, prof_info->event_type);\n+\n+  assert (prof_info->version == 201711);\n+\n+  ++ev_count;\n+}\n+\n+\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  DEBUG_printf (\"%s\\n\", __FUNCTION__);\n+\n+  reg_ (acc_ev_device_init_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_device_init_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_device_shutdown_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_device_shutdown_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_runtime_shutdown, cb_any_event, acc_reg);\n+  reg_ (acc_ev_create, cb_any_event, acc_reg);\n+  reg_ (acc_ev_delete, cb_any_event, acc_reg);\n+  reg_ (acc_ev_alloc, cb_any_event, acc_reg);\n+  reg_ (acc_ev_free, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enter_data_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enter_data_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_exit_data_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_exit_data_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_update_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_update_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_compute_construct_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_compute_construct_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enqueue_launch_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enqueue_launch_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enqueue_upload_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enqueue_upload_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enqueue_download_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_enqueue_download_end, cb_any_event, acc_reg);\n+  reg_ (acc_ev_wait_start, cb_any_event, acc_reg);\n+  reg_ (acc_ev_wait_end, cb_any_event, acc_reg);\n+}\n+\n+\n+int main()\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  ev_count = 0;\n+\n+  /* Trigger tests done in 'cb_*' functions.  */\n+#pragma acc parallel\n+  {\n+    asm volatile (\"\" : : : \"memory\"); // TODO PR90488\n+  }\n+\n+  DEBUG_printf (\"ev_count = %d\\n\", ev_count);\n+  /* We don't know exactly how many events to expect, but we at least expect\n+     'acc_ev_device_init_start', 'acc_ev_device_init_end',\n+     'acc_ev_compute_construct_start', 'acc_ev_compute_construct_end'.  */\n+  assert (ev_count >= 4);\n+\n+  return 0;\n+}"}]}