{"sha": "7609e7209a9078fec27fa04108cb5b8173911cbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYwOWU3MjA5YTkwNzhmZWMyN2ZhMDQxMDhjYjViODE3MzkxMWNiZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-14T01:14:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-14T01:14:42Z"}, "message": "reload.h (compute_use_by_pseudos): Declare.\n\n\t* reload.h (compute_use_by_pseudos): Declare.\n\t* reload1.c (spilled_pseudos, insns_need_reload): New variables.\n\t(something_needs_reloads): Delete variable.\n\t(finish_spills): New function.\n\t(compute_use_by_pseudos): New function.\n\t(delete_caller_save_insns): Lose argument FIRST.  All callers changed.\n\tUse the reload_insn_chain instead of walking the rtl directly.\n\t(reload): Allocate and free spilled_pseudos.\n\tEnsure that all calls of spill_hard_reg are followed by a call to\n\tfinish_spills.\n\tUse the insns_need_reload list instead of something_needs_reloads\n\tto find out if reload_as_needed must be called.\n\tClear unused_insn_chains at the end.\n\t(calculate_needs_all_insns): Lose FIRST parameter.  All callers\n\tchanged.\n\tDelete code to keep track of current basic block.\n\tWalk reload_insn_chain instead of the rtl structure.  Build the\n\tinsns_need_reload chain.\n\tRemember which insns need reloading/elimination by setting the\n\tappropriate fields in struct insn_chain, not by putting modes on the\n\tinsn.\n\t(calculate_needs): Lose THIS_BLOCK arg.  Accept arg CHAIN instead of\n\targ INSN.  All callers changed.\n\tDelete declaration of struct needs.\n\tDon't set something_needs_reloads.\n\tRecord insn needs in the CHAIN argument.\n\t(spill_hard_reg): Record the affected pseudos in spilled_pseudos.\n\t(reload_as_needed): Lose FIRST arg.  All callers changed.\n\tWalk the reload_insn_chain instead of the rtx structure.\n\tDelete code to keep track of current basic block.\n\tRename one of the NEXT variables to OLD_NEXT.\n\t(allocate_reload_reg): Accept arg CHAIN instead of arg INSN.  All\n\tcallers changed.\n\t(choose_reload_regs): Likewise.\n\t(emit_reload_insns): Replace INSN and BB args with arg CHAIN.  All\n\tcallers changed.\n\t* caller-save.c (MOVE_MAX_WORDS): New macro.  Use it throughout\n\tinstead of (MOVE_MAX / UNITS_PER_WORD) computation.\n\t(hard_regs_live, hard_regs_need_restore): Delete variables.\n\t(n_regs_saved): Now static.\n\t(referenced_regs, this_insn_sets): New variables.\n\t(setup_save_areas): Restructure the code a bit.\n\t(restore_referenced_regs): Delete function.\n\t(mark_referenced_regs): New function, similar to the old\n\trestore_referenced_regs, but mark registers in referenced_regs.\n\t(clear_reg_live): Delete function.\n\t(mark_set_regs): Renamed from set_reg_live.  All callers changed.\n\tOnly mark registers in this_insn_sets.\n\t(save_call_clobbered_regs): Rework this function to walk the\n\treload_insn_chain instead of using the list of instructions directly.\n\tDelete code to keep track of register lives, compute live regs on the\n\tfly from information in the chain.\n\tInstead of calling restore_referenced_regs, use mark_referenced_regs,\n\tthen walk the set it computes and call insert_restore as appropriate.\n\t(insert_restore): Lose INSN and BLOCK args.  Add CHAIN arg.  All\n\tcallers changed.\n\tRestructure the code a bit.  Test hard_regs_saved instead of\n\thard_regs_need_restore.\n\t(insert_save): Lose INSN and BLOCK args.  Add CHAIN and TO_SAVE\n\targs.  All callers changed.\n\tRestructure the code a bit.  Use TO_SAVE to determine which regs to\n\tsave instead of more complicated test.\n\t(insert_one_arg): Lose INSN and BLOCK args.  Add CHAIN arg.  All\n\tcallers changed.\n\tCreate a new insn_chain structure for the new insn and place it\n\tinto the chain.\n\t* rtl.texi: Update documentation to reflect that reload no longer\n\tputs modes on the insns.\n\nFrom-SVN: r23074", "tree": {"sha": "8f1b292892caa4aeb492c7a6f25f71e36de8762d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f1b292892caa4aeb492c7a6f25f71e36de8762d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7609e7209a9078fec27fa04108cb5b8173911cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7609e7209a9078fec27fa04108cb5b8173911cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7609e7209a9078fec27fa04108cb5b8173911cbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7609e7209a9078fec27fa04108cb5b8173911cbe/comments", "author": null, "committer": null, "parents": [{"sha": "f5964dd9ca04e0dc625f84cb1bfd0b6e871002a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5964dd9ca04e0dc625f84cb1bfd0b6e871002a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5964dd9ca04e0dc625f84cb1bfd0b6e871002a9"}], "stats": {"total": 952, "additions": 514, "deletions": 438}, "files": [{"sha": "2168f56bed960c8f39407892df1dbf30855805df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7609e7209a9078fec27fa04108cb5b8173911cbe", "patch": "@@ -1,3 +1,90 @@\n+Tue Oct 13 22:12:11 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* reload.h (compute_use_by_pseudos): Declare.\n+\n+\t* reload1.c (spilled_pseudos, insns_need_reload): New variables.\n+\t(something_needs_reloads): Delete variable.\n+\t(finish_spills): New function.\n+\t(compute_use_by_pseudos): New function.\n+\n+\t(delete_caller_save_insns): Lose argument FIRST.  All callers changed.\n+\tUse the reload_insn_chain instead of walking the rtl directly.\n+\n+\t(reload): Allocate and free spilled_pseudos.\n+\tEnsure that all calls of spill_hard_reg are followed by a call to\n+\tfinish_spills.\n+\tUse the insns_need_reload list instead of something_needs_reloads\n+\tto find out if reload_as_needed must be called.\n+\tClear unused_insn_chains at the end.\n+\n+\t(calculate_needs_all_insns): Lose FIRST parameter.  All callers\n+\tchanged.\n+\tDelete code to keep track of current basic block.\n+\tWalk reload_insn_chain instead of the rtl structure.  Build the\n+\tinsns_need_reload chain.\n+\tRemember which insns need reloading/elimination by setting the\n+\tappropriate fields in struct insn_chain, not by putting modes on the\n+\tinsn.\n+\n+\t(calculate_needs): Lose THIS_BLOCK arg.  Accept arg CHAIN instead of\n+\targ INSN.  All callers changed.\n+\tDelete declaration of struct needs.\n+\tDon't set something_needs_reloads.\n+\tRecord insn needs in the CHAIN argument.\n+\n+\t(spill_hard_reg): Record the affected pseudos in spilled_pseudos.\n+\n+\t(reload_as_needed): Lose FIRST arg.  All callers changed.\n+\tWalk the reload_insn_chain instead of the rtx structure.\n+\tDelete code to keep track of current basic block.\n+\tRename one of the NEXT variables to OLD_NEXT.\n+\n+\t(allocate_reload_reg): Accept arg CHAIN instead of arg INSN.  All\n+\tcallers changed.\n+\t(choose_reload_regs): Likewise.\n+\n+\t(emit_reload_insns): Replace INSN and BB args with arg CHAIN.  All\n+\tcallers changed.\n+\t\n+\t* caller-save.c (MOVE_MAX_WORDS): New macro.  Use it throughout\n+\tinstead of (MOVE_MAX / UNITS_PER_WORD) computation.\n+\t(hard_regs_live, hard_regs_need_restore): Delete variables.\n+\t(n_regs_saved): Now static.\n+\t(referenced_regs, this_insn_sets): New variables.\n+\n+\t(setup_save_areas): Restructure the code a bit.\n+\n+\t(restore_referenced_regs): Delete function.\n+\t(mark_referenced_regs): New function, similar to the old\n+\trestore_referenced_regs, but mark registers in referenced_regs.\n+\n+\t(clear_reg_live): Delete function.\n+\t(mark_set_regs): Renamed from set_reg_live.  All callers changed.\n+\tOnly mark registers in this_insn_sets.\n+\n+\t(save_call_clobbered_regs): Rework this function to walk the\n+\treload_insn_chain instead of using the list of instructions directly.\n+\tDelete code to keep track of register lives, compute live regs on the\n+\tfly from information in the chain.\n+\tInstead of calling restore_referenced_regs, use mark_referenced_regs,\n+\tthen walk the set it computes and call insert_restore as appropriate.\n+\n+\t(insert_restore): Lose INSN and BLOCK args.  Add CHAIN arg.  All\n+\tcallers changed.\n+\tRestructure the code a bit.  Test hard_regs_saved instead of\n+\thard_regs_need_restore.\n+\t(insert_save): Lose INSN and BLOCK args.  Add CHAIN and TO_SAVE\n+\targs.  All callers changed.\n+\tRestructure the code a bit.  Use TO_SAVE to determine which regs to\n+\tsave instead of more complicated test.\n+\t(insert_one_arg): Lose INSN and BLOCK args.  Add CHAIN arg.  All\n+\tcallers changed.\n+\tCreate a new insn_chain structure for the new insn and place it\n+\tinto the chain.\n+\n+\t* rtl.texi: Update documentation to reflect that reload no longer\n+\tputs modes on the insns.\n+\n 1998-10-14  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>\n \n \t* function.c (purge_addressof_1): Force the first argument of a"}, {"sha": "cbb19fba1a60f055e7672633b1e113edb27325af", "filename": "gcc/caller-save.c", "status": "modified", "additions": 261, "deletions": 298, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=7609e7209a9078fec27fa04108cb5b8173911cbe", "patch": "@@ -39,6 +39,8 @@ Boston, MA 02111-1307, USA.  */\n #define MIN_UNITS_PER_WORD UNITS_PER_WORD\n #endif\n \n+#define MOVE_MAX_WORDS (MOVE_MAX / UNITS_PER_WORD)\n+\n /* Modes for each hard register that we can save.  The smallest mode is wide\n    enough to save the entire contents of the register.  When saving the\n    register because it is live we first try to save in multi-register modes.\n@@ -64,29 +66,31 @@ static enum insn_code\n static enum insn_code \n   reg_restore_code[FIRST_PSEUDO_REGISTER][MAX_MOVE_MAX / MIN_UNITS_PER_WORD + 1];\n \n-/* Set of hard regs currently live (during scan of all insns).  */\n-\n-static HARD_REG_SET hard_regs_live;\n-\n /* Set of hard regs currently residing in save area (during insn scan).  */\n \n static HARD_REG_SET hard_regs_saved;\n \n-/* Set of hard regs which need to be restored before referenced.  */\n+/* Number of registers currently in hard_regs_saved.  */\n \n-static HARD_REG_SET hard_regs_need_restore;\n+static int n_regs_saved;\n \n-/* Number of registers currently in hard_regs_saved.  */\n+/* Computed by mark_referenced_regs, all regs referenced in a given\n+   insn.  */\n+static HARD_REG_SET referenced_regs;\n \n-int n_regs_saved;\n+/* Computed in mark_set_regs, holds all registers set by the current\n+   instruction.  */\n+static HARD_REG_SET this_insn_sets;\n \n-static void set_reg_live\t\tPROTO((rtx, rtx));\n-static void clear_reg_live\t\tPROTO((rtx));\n-static void restore_referenced_regs\tPROTO((rtx, rtx, int));\n-static int insert_restore\t\tPROTO((rtx, int, int, int, int));\n-static int insert_save\t\t\tPROTO((rtx, int, int, int));\n-static void insert_one_insn\t\tPROTO((rtx, int, enum rtx_code,\n-\t\t\t\t\t       rtx, int));\n+\n+static void mark_set_regs\t\tPROTO((rtx, rtx));\n+static void mark_referenced_regs\tPROTO((rtx));\n+static int insert_save\t\t\tPROTO((struct insn_chain *, int, int,\n+\t\t\t\t\t       HARD_REG_SET *));\n+static int insert_restore\t\tPROTO((struct insn_chain *, int, int,\n+\t\t\t\t\t       int));\n+static void insert_one_insn\t\tPROTO((struct insn_chain *, int,\n+\t\t\t\t\t       enum insn_code, rtx));\n \f\n /* Initialize for caller-save.\n \n@@ -115,7 +119,7 @@ init_caller_save ()\n     {\n       if (call_used_regs[i] && ! call_fixed_regs[i])\n \t{\n-\t  for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n+\t  for (j = 1; j <= MOVE_MAX_WORDS; j++)\n \t    {\n \t      regno_save_mode[i][j] = HARD_REGNO_CALLER_SAVE_MODE (i, j);\n \t      if (regno_save_mode[i][j] == VOIDmode && j == 1)\n@@ -172,7 +176,7 @@ init_caller_save ()\n   start_sequence ();\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n+    for (j = 1; j <= MOVE_MAX_WORDS; j++)\n       if (regno_save_mode[i][j] != VOIDmode)\n         {\n \t  rtx mem = gen_rtx_MEM (regno_save_mode[i][j], address);\n@@ -221,7 +225,7 @@ init_save_areas ()\n   int i, j;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n+    for (j = 1; j <= MOVE_MAX_WORDS; j++)\n       regno_save_mem[i][j] = 0;\n }\n \n@@ -275,18 +279,16 @@ setup_save_areas ()\n      in a manner which allows multi-register saves/restores to be done.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    for (j = MOVE_MAX / UNITS_PER_WORD; j > 0; j--)\n+    for (j = MOVE_MAX_WORDS; j > 0; j--)\n       {\n-\tint ok = 1;\n-\tint do_save;\n+\tint do_save = 1;\n \n \t/* If no mode exists for this size, try another.  Also break out\n \t   if we have already saved this hard register.  */\n \tif (regno_save_mode[i][j] == VOIDmode || regno_save_mem[i][1] != 0)\n \t  continue;\n \n \t/* See if any register in this group has been saved.  */\n-\tdo_save = 1;\n \tfor (k = 0; k < j; k++)\n \t  if (regno_save_mem[i + k][1])\n \t    {\n@@ -297,189 +299,171 @@ setup_save_areas ()\n \t  continue;\n \n \tfor (k = 0; k < j; k++)\n+\t  if (! TEST_HARD_REG_BIT (hard_regs_used, i + k))\n \t    {\n-\t      int regno = i + k;\n-\t      ok &= (TEST_HARD_REG_BIT (hard_regs_used, regno) != 0);\n+\t      do_save = 0;\n+\t      break;\n \t    }\n+\tif (! do_save)\n+\t  continue;\n \n \t/* We have found an acceptable mode to store in.  */\n-\tif (ok)\n+\tregno_save_mem[i][j]\n+\t  = assign_stack_local (regno_save_mode[i][j],\n+\t\t\t\tGET_MODE_SIZE (regno_save_mode[i][j]), 0);\n+\n+\t/* Setup single word save area just in case...  */\n+\tfor (k = 0; k < j; k++)\n \t  {\n+\t    /* This should not depend on WORDS_BIG_ENDIAN.\n+\t       The order of words in regs is the same as in memory.  */\n+\t    rtx temp = gen_rtx_MEM (regno_save_mode[i+k][1], \n+\t\t\t\t    XEXP (regno_save_mem[i][j], 0));\n \n-\t    regno_save_mem[i][j]\n-\t      = assign_stack_local (regno_save_mode[i][j],\n-\t\t\t\t    GET_MODE_SIZE (regno_save_mode[i][j]), 0);\n-\n-\t    /* Setup single word save area just in case...  */\n-\t    for (k = 0; k < j; k++)\n-\t      {\n-\t\t/* This should not depend on WORDS_BIG_ENDIAN.\n-\t\t   The order of words in regs is the same as in memory.  */\n-\t\trtx temp = gen_rtx_MEM (regno_save_mode[i+k][1], \n-\t\t\t\t\tXEXP (regno_save_mem[i][j], 0));\n-\n-\t\tregno_save_mem[i+k][1] \n-\t\t  = adj_offsettable_operand (temp, k * UNITS_PER_WORD);\n-\t      }\n+\t    regno_save_mem[i+k][1] \n+\t      = adj_offsettable_operand (temp, k * UNITS_PER_WORD);\n \t  }\n       }\n-\n-  return;\n }\n \f\n /* Find the places where hard regs are live across calls and save them.  */\n-\n void\n save_call_clobbered_regs ()\n {\n-  rtx insn;\n-  int b;\n+  struct insn_chain *chain, *next;\n+\n+  CLEAR_HARD_REG_SET (hard_regs_saved);\n+  n_regs_saved = 0;\n \n-  for (b = 0; b < n_basic_blocks; b++)\n+  for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n-      regset regs_live = basic_block_live_at_start[b];\n-      int i, j;\n-      int regno;\n-\n-      /* Compute hard regs live at start of block -- this is the\n-\t real hard regs marked live, plus live pseudo regs that\n-\t have been renumbered to hard regs.  No registers have yet been\n-\t saved because we restore all of them before the end of the basic\n-\t block.  */\n-\n-      REG_SET_TO_HARD_REG_SET (hard_regs_live, regs_live);\n-      CLEAR_HARD_REG_SET (hard_regs_saved);\n-      CLEAR_HARD_REG_SET (hard_regs_need_restore);\n-      n_regs_saved = 0;\n-\n-      EXECUTE_IF_SET_IN_REG_SET (regs_live, 0, i,\n-\t\t\t\t {\n-\t\t\t\t   if ((regno = reg_renumber[i]) >= 0)\n-\t\t\t\t     for (j = regno;\n-\t\t\t\t\t  j < regno + HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\t\t\t\tPSEUDO_REGNO_MODE (i));\n-\t\t\t\t\t  j++)\n-\t\t\t\t       SET_HARD_REG_BIT (hard_regs_live, j);\n-\t\t\t\t });\n-\n-      /* Now scan the insns in the block, keeping track of what hard\n-\t regs are live as we go.  When we see a call, save the live\n-\t call-clobbered hard regs.  */\n-\n-      for (insn = basic_block_head[b]; ; insn = NEXT_INSN (insn))\n+      rtx insn = chain->insn;\n+      enum rtx_code code = GET_CODE (insn);\n+\n+      next = chain->next;\n+\n+      if (chain->is_caller_save_insn)\n+\tabort ();\n+\n+      if (GET_RTX_CLASS (code) == 'i')\n \t{\n-\t  RTX_CODE code = GET_CODE (insn);\n+\t  /* If some registers have been saved, see if INSN references\n+\t     any of them.  We must restore them before the insn if so.  */\n \n-\t  if (GET_RTX_CLASS (code) == 'i')\n+\t  if (n_regs_saved)\n \t    {\n-\t      rtx link;\n-\n-\t      /* If some registers have been saved, see if INSN references\n-\t\t any of them.  We must restore them before the insn if so.  */\n-\n-\t      if (n_regs_saved)\n-\t\trestore_referenced_regs (PATTERN (insn), insn, b);\n-\n-\t      /* NB: the normal procedure is to first enliven any\n-\t\t registers set by insn, then deaden any registers that\n-\t\t had their last use at insn.  This is incorrect now,\n-\t\t since multiple pseudos may have been mapped to the\n-\t\t same hard reg, and the death notes are ambiguous.  So\n-\t\t it must be done in the other, safe, order.  */\n-\n-\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\t  clear_reg_live (XEXP (link, 0));\n-\n-\t      /* When we reach a call, we need to save all registers that are\n-\t\t live, call-used, not fixed, and not already saved.  We must\n-\t\t test at this point because registers that die in a CALL_INSN\n-\t\t are not live across the call and likewise for registers that\n-\t\t are born in the CALL_INSN.\n-\t\t \n-\t\t If registers are filled with parameters for this function,\n-\t\t and some of these are also being set by this function, then\n-\t\t they will not appear to die (no REG_DEAD note for them),\n-\t\t to check if in fact they do, collect the set registers in\n-\t\t hard_regs_live first.  */\n-\n-\t      if (code == CALL_INSN)\n-\t\t{\n-\t\t  HARD_REG_SET this_call_sets;\n-\t\t  {\n-\t\t    HARD_REG_SET old_hard_regs_live;\n-\n-\t\t    /* Save the hard_regs_live information.  */\n-\t\t    COPY_HARD_REG_SET (old_hard_regs_live, hard_regs_live);\n-\n-\t\t    /* Now calculate hard_regs_live for this CALL_INSN\n-\t\t       only.  */\n-\t\t    CLEAR_HARD_REG_SET (hard_regs_live);\n-\t\t    note_stores (PATTERN (insn), set_reg_live);\n-\t\t    COPY_HARD_REG_SET (this_call_sets, hard_regs_live);\n-\n-\t\t    /* Restore the hard_regs_live information.  */\n-\t\t    COPY_HARD_REG_SET (hard_regs_live, old_hard_regs_live);\n-\t\t  }\n-\n-\t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\t    if (call_used_regs[regno] && ! call_fixed_regs[regno]\n-\t\t        && TEST_HARD_REG_BIT (hard_regs_live, regno)\n-\t\t\t/* It must not be set by this instruction.  */\n-\t\t        && ! TEST_HARD_REG_BIT (this_call_sets, regno)\n-\t\t        && ! TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t\t      regno += insert_save (insn, 1, regno, b);\n-\n-\t\t  /* Put the information for this CALL_INSN on top of what\n-\t\t     we already had.  */\n-\t\t  IOR_HARD_REG_SET (hard_regs_live, this_call_sets);\n-\t\t  COPY_HARD_REG_SET (hard_regs_need_restore, hard_regs_saved);\n-\n-\t\t  /* Must recompute n_regs_saved.  */\n-\t\t  n_regs_saved = 0;\n-\t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\t    if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t\t      n_regs_saved++;\n-\t\t}\n+\t      int regno;\n+\n+\t      if (code == JUMP_INSN)\n+\t\t/* Restore all registers if this is a JUMP_INSN.  */\n+\t\tCOPY_HARD_REG_SET (referenced_regs, hard_regs_saved);\n \t      else\n \t\t{\n-\t\t  note_stores (PATTERN (insn), set_reg_live);\n-#ifdef AUTO_INC_DEC\n-\t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\t    if (REG_NOTE_KIND (link) == REG_INC)\n-\t\t      set_reg_live (XEXP (link, 0), NULL_RTX);\n-#endif\n+\t\t  CLEAR_HARD_REG_SET (referenced_regs);\n+\t\t  mark_referenced_regs (PATTERN (insn));\n+\t\t  AND_HARD_REG_SET (referenced_regs, hard_regs_saved);\n \t\t}\n \n-\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_UNUSED)\n-\t\t  clear_reg_live (XEXP (link, 0));\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif (TEST_HARD_REG_BIT (referenced_regs, regno))\n+\t\t  regno += insert_restore (chain, 1, regno, MOVE_MAX_WORDS);\n \t    }\n \n-\t  if (insn == basic_block_end[b])\n-\t    break;\n-\t}\n+\t  if (code == CALL_INSN)\n+\t    {\n+\t      rtx x;\n+\t      int regno, nregs;\n+\t      HARD_REG_SET hard_regs_to_save;\n+\n+\t      /* Use the register life information in CHAIN to compute which\n+\t\t regs are live before the call.  */\n+\t      REG_SET_TO_HARD_REG_SET (hard_regs_to_save, chain->live_before);\n+\t      compute_use_by_pseudos (&hard_regs_to_save, chain->live_before);\n+\n+\t      /* Record all registers set in this call insn.  These don't need\n+\t\t to be saved.  */\n+\t      CLEAR_HARD_REG_SET (this_insn_sets);\n+\t      note_stores (PATTERN (insn), mark_set_regs);\n+\n+\t      /* Compute which hard regs must be saved before this call.  */\n+\t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, call_fixed_reg_set);\n+\t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, this_insn_sets);\n+\t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, hard_regs_saved);\n+\t      AND_HARD_REG_SET (hard_regs_to_save, call_used_reg_set);\n+\n+\t      /* Registers used for function parameters need not be saved.  */\n+\t      for (x = CALL_INSN_FUNCTION_USAGE (insn); x != 0;\n+\t\t   x = XEXP (x, 1))\n+\t\t{\n+\t\t  rtx y;\n+\n+\t\t  if (GET_CODE (XEXP (x, 0)) != USE)\n+\t\t    continue;\n+\t\t  y = XEXP (XEXP (x, 0), 0);\n+\t\t  if (GET_CODE (y) != REG)\n+\t\t    abort ();\n+\t\t  regno = REGNO (y);\n+\t\t  if (REGNO (y) >= FIRST_PSEUDO_REGISTER)\n+\t\t    abort ();\n+\t\t  nregs = HARD_REGNO_NREGS (regno, GET_MODE (y));\n+\t\t  while (nregs-- > 0)\n+\t\t    CLEAR_HARD_REG_BIT (hard_regs_to_save, regno + nregs);\n+\t\t}\n \n-      /* At the end of the basic block, we must restore any registers that\n-\t remain saved.  If the last insn in the block is a JUMP_INSN, put\n-\t the restore before the insn, otherwise, put it after the insn.  */\n+\t      /* Neither do registers for which we find a death note.  */\n+\t      for (x = REG_NOTES (insn); x != 0; x = XEXP (x, 1))\n+\t\t{\n+\t\t  rtx y = XEXP (x, 0);\n+\n+\t\t  if (REG_NOTE_KIND (x) != REG_DEAD)\n+\t\t    continue;\n+\t\t  if (GET_CODE (y) != REG)\n+\t\t    abort ();\n+\t\t  regno = REGNO (y);\n+\n+\t\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t\t    regno = reg_renumber[regno];\n+\t\t  if (regno < 0)\n+\t\t    continue;\n+\t\t  nregs = HARD_REGNO_NREGS (regno, GET_MODE (y));\n+\t\t  while (nregs-- > 0)\n+\t\t    CLEAR_HARD_REG_BIT (hard_regs_to_save, regno + nregs);\t\t  \n+\t\t}\n+\t\t\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n+\t\t  regno += insert_save (chain, 1, regno, &hard_regs_to_save);\n+\n+\t      /* Must recompute n_regs_saved.  */\n+\t      n_regs_saved = 0;\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n+\t\t  n_regs_saved++;\n+\t    }\n+\t}\n \n-      if (n_regs_saved)\n-\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t  if (TEST_HARD_REG_BIT (hard_regs_need_restore, regno))\n-\t    regno += insert_restore (insn, GET_CODE (insn) == JUMP_INSN,\n-\t\t\t\t     regno,\n-\t\t\t\t     MOVE_MAX / UNITS_PER_WORD, b);\n-    }\n+      if (chain->next == 0 || chain->next->block > chain->block)\n+\t{\n+\t  int regno;\n+\t  /* At the end of the basic block, we must restore any registers that\n+\t     remain saved.  If the last insn in the block is a JUMP_INSN, put\n+\t     the restore before the insn, otherwise, put it after the insn.  */\n+\n+\t  if (n_regs_saved)\n+\t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t      if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n+\t\tregno += insert_restore (chain, GET_CODE (insn) == JUMP_INSN,\n+\t\t\t\t\t regno, MOVE_MAX_WORDS);\n+\t}\n+    }  \n }\n \n /* Here from note_stores when an insn stores a value in a register.\n-   Set the proper bit or bits in hard_regs_live.  All pseudos that have\n+   Set the proper bit or bits in this_insn_sets.  All pseudos that have\n    been assigned hard regs have had their register number changed already,\n    so we can ignore pseudos.  */\n-\n static void\n-set_reg_live (reg, setter)\n+mark_set_regs (reg, setter)\n      rtx reg;\n      rtx setter ATTRIBUTE_UNUSED;\n {\n@@ -500,104 +484,71 @@ set_reg_live (reg, setter)\n   endregno = regno + HARD_REGNO_NREGS (regno, mode);\n \n   for (i = regno; i < endregno; i++)\n-    {\n-      SET_HARD_REG_BIT (hard_regs_live, i);\n-      CLEAR_HARD_REG_BIT (hard_regs_saved, i);\n-      CLEAR_HARD_REG_BIT (hard_regs_need_restore, i);\n-    }\n+    SET_HARD_REG_BIT (this_insn_sets, i);\n }\n \n-/* Here when a REG_DEAD note records the last use of a reg.  Clear\n-   the appropriate bit or bits in hard_regs_live.  Again we can ignore\n-   pseudos.  */\n-\n-static void\n-clear_reg_live (reg)\n-     rtx reg;\n-{\n-  register int regno, endregno, i;\n-\n-  if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  regno = REGNO (reg);\n-  endregno= regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\n-  for (i = regno; i < endregno; i++)\n-    {\n-      CLEAR_HARD_REG_BIT (hard_regs_live, i);\n-      CLEAR_HARD_REG_BIT (hard_regs_need_restore, i);\n-      CLEAR_HARD_REG_BIT (hard_regs_saved, i);\n-    }\n-}      \n-\f\n-/* If any register currently residing in the save area is referenced in X,\n-   which is part of INSN, emit code to restore the register in front of\n-   INSN.  */\n-\n+/* Walk X and record all referenced registers in REFERENCED_REGS.  */\n static void\n-restore_referenced_regs (x, insn, block)\n+mark_referenced_regs (x)\n      rtx x;\n-     rtx insn;\n-     int block;\n {\n   enum rtx_code code = GET_CODE (x);\n   char *fmt;\n   int i, j;\n \n-  if (code == CLOBBER)\n-    return;\n+  if (code == SET)\n+    mark_referenced_regs (SET_SRC (x));\n+  if (code == SET || code == CLOBBER)\n+    {\n+      x = SET_DEST (x);\n+      code = GET_CODE (x);\n+      if (code == REG || code == PC || code == CC0\n+\t  || (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG))\n+\treturn;\n+    }\n+  if (code == MEM || code == SUBREG)\n+    {\n+      x = XEXP (x, 0);\n+      code = GET_CODE (x);\n+    }\n \n   if (code == REG)\n     {\n       int regno = REGNO (x);\n+      int hardregno = (regno < FIRST_PSEUDO_REGISTER ? regno\n+\t\t       : reg_renumber[regno]);\n \n-      /* If this is a pseudo, scan its memory location, since it might\n-\t involve the use of another register, which might be saved.  */\n-\n-      if (regno >= FIRST_PSEUDO_REGISTER\n-\t  && reg_equiv_mem[regno] != 0)\n-\trestore_referenced_regs (XEXP (reg_equiv_mem[regno], 0),\n-\t\t\t\t insn, block);\n-      else if (regno >= FIRST_PSEUDO_REGISTER\n-\t       && reg_equiv_address[regno] != 0)\n-\trestore_referenced_regs (reg_equiv_address[regno],\n-\t\t\t\t insn, block);\n-\n-      /* Otherwise if this is a hard register, restore any piece of it that\n-\t is currently saved.  */\n-\n-      else if (regno < FIRST_PSEUDO_REGISTER)\n+      if (hardregno >= 0)\n \t{\n-\t  int numregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t  /* Save at most SAVEREGS at a time.  This can not be larger than\n-\t     MOVE_MAX, because that causes insert_restore to fail.  */\n-\t  int saveregs = MIN (numregs, MOVE_MAX / UNITS_PER_WORD);\n-\t  int endregno = regno + numregs;\n-\n-\t  for (i = regno; i < endregno; i++)\n-\t    if (TEST_HARD_REG_BIT (hard_regs_need_restore, i))\n-\t      i += insert_restore (insn, 1, i, saveregs, block);\n+\t  int nregs = HARD_REGNO_NREGS (hardregno, GET_MODE (x));\n+\t  while (nregs-- > 0)\n+\t    SET_HARD_REG_BIT (referenced_regs, hardregno + nregs);\n \t}\n-\n+      /* If this is a pseudo that did not get a hard register, scan its\n+\t memory location, since it might involve the use of another\n+\t register, which might be saved.  */\n+      else if (reg_equiv_mem[regno] != 0)\n+\tmark_referenced_regs (XEXP (reg_equiv_mem[regno], 0));\n+      else if (reg_equiv_address[regno] != 0)\n+\tmark_referenced_regs (reg_equiv_address[regno]);\n       return;\n     }\n-\t  \n+\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\trestore_referenced_regs (XEXP (x, i), insn, block);\n+\tmark_referenced_regs (XEXP (x, i));\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  restore_referenced_regs (XVECEXP (x, i, j), insn, block);\n+\t  mark_referenced_regs (XVECEXP (x, i, j));\n     }\n }\n \f\n-/* Insert a sequence of insns to restore REGNO.  Place these insns in front\n-   of or after INSN (determined by BEFORE_P).   MAXRESTORE is the maximum\n-   number of registers which should be restored during this call.  It should\n-   never be less than 1 since we only work with entire registers.\n+/* Insert a sequence of insns to restore.  Place these insns in front of\n+   CHAIN if BEFORE_P is nonzero, behind the insn otherwise.  MAXRESTORE is\n+   the maximum number of registers which should be restored during this call.\n+   It should never be less than 1 since we only work with entire registers.\n \n    Note that we have verified in init_caller_save that we can do this\n    with a simple SET, so use it.  Set INSN_CODE to what we save there\n@@ -608,18 +559,16 @@ restore_referenced_regs (x, insn, block)\n    Return the extra number of registers saved.  */\n \n static int\n-insert_restore (insn, before_p, regno, maxrestore, block)\n-     rtx insn;\n+insert_restore (chain, before_p, regno, maxrestore)\n+     struct insn_chain *chain;\n      int before_p;\n      int regno;\n      int maxrestore;\n-     int block;\n {\n+  int i;\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n   int numregs = 0;\n-  int i, j, k;\n-  int ok;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -631,63 +580,63 @@ insert_restore (insn, before_p, regno, maxrestore, block)\n   if (regno_save_mem[regno][1] == 0)\n     abort ();\n \n-  /* Get the pattern to emit and update our status.  */\n+  /* Get the pattern to emit and update our status.\n \n-  /* See if we can restore `maxrestore' registers at once.  Work\n+     See if we can restore `maxrestore' registers at once.  Work\n      backwards to the single register case.  */\n   for (i = maxrestore; i > 0; i--)\n     {\n-      ok = 1;\n-      if (regno_save_mem[regno][i])\n-\tfor (j = 0; j < i; j++)\n-\t  {\n-\t    if (! TEST_HARD_REG_BIT (hard_regs_need_restore, regno + j))\n-\t      ok = 0;\n-\t  }\n-      else\n+      int j, k;\n+      int ok = 1;\n+\n+      if (regno_save_mem[regno][i] == 0)\n \tcontinue;\n \n+      for (j = 0; j < i; j++)\n+\tif (! TEST_HARD_REG_BIT (hard_regs_saved, regno + j))\n+\t  {\n+\t    ok = 0;\n+\t    break;\n+\t  }\n       /* Must do this one restore at a time */\n       if (! ok)\n \tcontinue;\n-\t    \n+\n       pat = gen_rtx_SET (VOIDmode,\n \t\t\t gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]), \n \t\t\t\t      regno), \n \t\t\t regno_save_mem[regno][i]);\n       code = reg_restore_code[regno][i];\n \n-\n       /* Clear status for all registers we restored.  */\n       for (k = 0; k < i; k++)\n \t{\n-\t  CLEAR_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n+\t  CLEAR_HARD_REG_BIT (hard_regs_saved, regno + k);\n \t  n_regs_saved--;\n \t}\n \n       numregs = i;\n       break;\n     }\n \n-  insert_one_insn (insn, before_p, code, pat, block);\n+  insert_one_insn (chain, before_p, code, pat);\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n \n-/* Like insert_restore, but emit code to save REGNO.  */\n+/* Like insert_restore above, but save registers instead.  */\n static int\n-insert_save (insn, before_p, regno, block)\n-     rtx insn;\n+insert_save (chain, before_p, regno, to_save)\n+     struct insn_chain *chain;\n      int before_p;\n      int regno;\n-     int block;\n+     HARD_REG_SET *to_save;\n {\n+  int i;\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n   int numregs = 0;\n-  int i, j, k;\n-  int ok;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -699,24 +648,23 @@ insert_save (insn, before_p, regno, block)\n   if (regno_save_mem[regno][1] == 0)\n     abort ();\n \n-  /* Get the pattern to emit and update our status.  */\n+  /* Get the pattern to emit and update our status.\n \n-  /* See if we can save several registers with a single instruction.  \n+     See if we can save several registers with a single instruction.  \n      Work backwards to the single register case.  */\n-  for (i = MOVE_MAX / UNITS_PER_WORD; i > 0; i--)\n+  for (i = MOVE_MAX_WORDS; i > 0; i--)\n     {\n-      ok = 1;\n-      if (regno_save_mem[regno][i] != 0)\n-\tfor (j = 0; j < i; j++)\n-\t  {\n-\t    if (! call_used_regs[regno + j] || call_fixed_regs[regno + j]\n-\t\t|| ! TEST_HARD_REG_BIT (hard_regs_live, regno + j)\n-\t\t|| TEST_HARD_REG_BIT (hard_regs_saved, regno + j))\n-\t      ok = 0;\n-\t  }\n-      else \n+      int j, k;\n+      int ok = 1;\n+      if (regno_save_mem[regno][i] == 0)\n \tcontinue;\n \n+      for (j = 0; j < i; j++)\n+\tif (! TEST_HARD_REG_BIT (*to_save, regno + j))\n+\t  {\n+\t    ok = 0;\n+\t    break;\n+\t  }\n       /* Must do this one save at a time */\n       if (! ok)\n \tcontinue;\n@@ -730,31 +678,30 @@ insert_save (insn, before_p, regno, block)\n       for (k = 0; k < i; k++)\n \t{\n \t  SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n-\t  SET_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n \t  n_regs_saved++;\n \t}\n \n       numregs = i;\n       break;\n     }\n \n-  insert_one_insn (insn, before_p, code, pat, block);\n+  insert_one_insn (chain, before_p, code, pat);\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n \n-/* Emit one insn, set the code, and update basic block boundaries.  */\n+/* Emit a new caller-save insn and set the code.  */\n static void\n-insert_one_insn (insn, before_p, code, pat, block)\n-     rtx insn;\n+insert_one_insn (chain, before_p, code, pat)\n+     struct insn_chain *chain;\n      int before_p;\n-     enum rtx_code code;\n+     enum insn_code code;\n      rtx pat;\n-     int block;\n {\n-  rtx insert_point = insn;\n-  rtx new;\n+  rtx insn = chain->insn;\n+  struct insn_chain *new;\n+  \n #ifdef HAVE_cc0\n   /* If INSN references CC0, put our insns in front of the insn that sets\n      CC0.  This is always safe, since the only way we could be passed an\n@@ -765,21 +712,37 @@ insert_one_insn (insn, before_p, code, pat, block)\n   if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n       && before_p\n       && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n-    insert_point = prev_nonnote_insn (insn);\n+    chain = chain->prev, insn = chain->insn;\n #endif\n \n+  new = new_insn_chain ();\n   if (before_p)\n     {\n-      new = emit_insn_before (pat, insert_point);\n-      if (insert_point == basic_block_head[block])\n-\tbasic_block_head[block] = new;\n+      new->prev = chain->prev;\n+      if (new->prev != 0)\n+\tnew->prev->next = new;\n+      else\n+\treload_insn_chain = new;\n+\n+      chain->prev = new;\n+      new->next = chain;\n+      new->insn = emit_insn_before (pat, insn);\n+      if (chain->insn == basic_block_head[chain->block])\n+\tbasic_block_head[chain->block] = new->insn;\n     }\n   else\n     {\n-      new = emit_insn_after (pat, insert_point);\n-      if (insert_point == basic_block_end[block])\n-\tbasic_block_end[block] = new;\n+      new->next = chain->next;\n+      if (new->next != 0)\n+\tnew->next->prev = new;\n+      chain->next = new;\n+      new->prev = chain;\n+      new->insn = emit_insn_after (pat, insn);\n+      if (chain->insn == basic_block_end[chain->block])\n+\tbasic_block_end[chain->block] = new->insn;\n     }\n+  new->block = chain->block;\n+  new->is_caller_save_insn = 1;\n \n-  INSN_CODE (new) = code;\n+  INSN_CODE (new->insn) = code;\n }"}, {"sha": "41d66164db49a0efd1a160e9e169c870d95c879f", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=7609e7209a9078fec27fa04108cb5b8173911cbe", "patch": "@@ -215,6 +215,7 @@ extern struct insn_chain *reload_insn_chain;\n /* Allocate a new insn_chain structure.  */\n extern struct insn_chain *new_insn_chain\tPROTO((void));\n \n+extern void compute_use_by_pseudos\t\tPROTO((HARD_REG_SET *, regset));\n #endif\n \n /* Functions from reload.c:  */"}, {"sha": "a9925cbaf9e19e1a9837a61e1fe40c4bd28d68f7", "filename": "gcc/reload1.c", "status": "modified", "additions": 164, "deletions": 137, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=7609e7209a9078fec27fa04108cb5b8173911cbe", "patch": "@@ -177,12 +177,10 @@ static short spill_regs[FIRST_PSEUDO_REGISTER];\n    registers.  This information is used in reorg.c, to help figure out\n    what registers are live at any point.  It is assumed that all spill_regs\n    are dead at every CODE_LABEL.  */\n-\n HARD_REG_SET used_spill_regs;\n \n /* Index of last register assigned as a spill register.  We allocate in\n    a round-robin fashion.  */\n-\n static int last_spill_reg;\n \n /* Describes order of preference for putting regs into spill_regs.\n@@ -213,32 +211,29 @@ static HARD_REG_SET counted_for_nongroups;\n    value indicates the level of indirect addressing supported, e.g., two\n    means that (MEM (MEM (REG n))) is also valid if (REG n) does not get\n    a hard register.  */\n-\n static char spill_indirect_levels;\n \n /* Nonzero if indirect addressing is supported when the innermost MEM is\n    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n    which these are valid is the same as spill_indirect_levels, above.   */\n-\n char indirect_symref_ok;\n \n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n-\n char double_reg_address_ok;\n \n /* Record the stack slot for each spilled hard register.  */\n-\n static rtx spill_stack_slot[FIRST_PSEUDO_REGISTER];\n \n /* Width allocated so far for that stack slot.  */\n-\n static int spill_stack_slot_width[FIRST_PSEUDO_REGISTER];\n \n+/* Record which pseudos needed to be spilled.  */\n+static regset spilled_pseudos;\n+\n /* Indexed by register class and basic block number, nonzero if there is\n    any need for a spill register of that class in that basic block.\n    The pointer is 0 if we did stupid allocation and don't know\n    the structure of basic blocks.  */\n-\n char *basic_block_needs[N_REG_CLASSES];\n \n /* First uid used by insns created by reload in this function.\n@@ -247,7 +242,6 @@ int reload_first_uid;\n \n /* Flag set by local-alloc or global-alloc if anything is live in\n    a call-clobbered reg across calls.  */\n-\n int caller_save_needed;\n \n /* The register class to use for a base register when reloading an\n@@ -297,6 +291,9 @@ extern rtx forced_labels;\n /* List of insn_chain instructions, one for every insn that reload needs to\n    examine.  */\n struct insn_chain *reload_insn_chain;\n+\n+/* List of insns needing reloads.  */\n+static struct insn_chain *insns_need_reload;\n \f\n /* This structure is used to record information about register eliminations.\n    Each array entry describes one possible way of eliminating a register\n@@ -360,8 +357,8 @@ static int num_labels;\n struct hard_reg_n_uses { int regno; int uses; };\n \f\n static void dump_needs\t\t\tPROTO((FILE *));\n-static int calculate_needs_all_insns\tPROTO((rtx, int));\n-static int calculate_needs\t\tPROTO((int, rtx, rtx, int));\n+static int calculate_needs_all_insns\tPROTO((int));\n+static int calculate_needs\t\tPROTO((struct insn_chain *, rtx, int));\n static int find_reload_regs\t\tPROTO((int, FILE *));\n static int find_tworeg_group\t\tPROTO((int, int, FILE *));\n static int find_group\t\t\tPROTO((int, int, FILE *));\n@@ -371,7 +368,7 @@ static void count_possible_groups\tPROTO((int *, enum machine_mode *,\n static int modes_equiv_for_class_p\tPROTO((enum machine_mode,\n \t\t\t\t\t       enum machine_mode,\n \t\t\t\t\t       enum reg_class));\n-static void delete_caller_save_insns\tPROTO((rtx));\n+static void delete_caller_save_insns\tPROTO((void));\n static void spill_failure\t\tPROTO((rtx));\n static int new_spill_reg\t\tPROTO((int, int, int *, int *, int,\n \t\t\t\t\t       FILE *));\n@@ -384,11 +381,12 @@ static void set_initial_elim_offsets\tPROTO((void));\n static void init_elim_table\t\tPROTO((void));\n static void update_eliminables\t\tPROTO((HARD_REG_SET *));\n static int spill_hard_reg\t\tPROTO((int, int, FILE *, int));\n+static void finish_spills\t\tPROTO((int, FILE *));\n static void scan_paradoxical_subregs\tPROTO((rtx));\n static int hard_reg_use_compare\t\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n static void order_regs_for_reload\tPROTO((void));\n static int compare_spill_regs\t\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n-static void reload_as_needed\t\tPROTO((rtx, int));\n+static void reload_as_needed\t\tPROTO((int));\n static void forget_old_reloads_1\tPROTO((rtx, rtx));\n static int reload_reg_class_lower\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n@@ -399,10 +397,10 @@ static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type, int));\n static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx, rtx, int));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n-static int allocate_reload_reg\t\tPROTO((int, rtx, int, int));\n-static void choose_reload_regs\t\tPROTO((rtx, rtx));\n+static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int, int));\n+static void choose_reload_regs\t\tPROTO((struct insn_chain *, rtx));\n static void merge_assigned_reloads\tPROTO((rtx));\n-static void emit_reload_insns\t\tPROTO((rtx, int));\n+static void emit_reload_insns\t\tPROTO((struct insn_chain *));\n static void delete_output_reload\tPROTO((rtx, int, rtx));\n static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n@@ -560,10 +558,29 @@ new_insn_chain ()\n   return c;\n }\n \n+/* Small utility function to set all regs in hard reg set TO which are\n+   allocated to pseudos in regset FROM.  */\n+void\n+compute_use_by_pseudos (to, from)\n+     HARD_REG_SET *to;\n+     regset from;\n+{\n+  int regno;\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (from, FIRST_PSEUDO_REGISTER, regno,\n+     {\n+       int r = reg_renumber[regno];\n+       int nregs;\n+       if (r < 0)\n+\t abort ();\n+       nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno));\n+       while (nregs-- > 0)\n+\t SET_HARD_REG_BIT (*to, r + nregs);\n+     });\n+}\n+\n /* Global variables used by reload and its subroutines.  */\n \n-/* Set during calculate_needs if an insn needs reloading.  */\n-static int something_needs_reloads;\n /* Set during calculate_needs if an insn needs register elimination.  */\n static int something_needs_elimination;\n \n@@ -866,6 +883,8 @@ reload (first, global, dumpfile)\n   if (! SMALL_REGISTER_CLASSES)\n     COPY_HARD_REG_SET (forbidden_regs, bad_spill_regs);\n \n+  spilled_pseudos = ALLOCA_REG_SET ();\n+\n   /* Spill any hard regs that we know we can't eliminate.  */\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     if (! ep->can_eliminate)\n@@ -876,6 +895,8 @@ reload (first, global, dumpfile)\n     spill_hard_reg (HARD_FRAME_POINTER_REGNUM, global, dumpfile, 1);\n #endif\n \n+  finish_spills (global, dumpfile);\n+\n   if (global)\n     for (i = 0; i < N_REG_CLASSES; i++)\n       {\n@@ -894,8 +915,7 @@ reload (first, global, dumpfile)\n      reg does not necessarily imply any pseudo reg was spilled;\n      sometimes we find a reload reg that no pseudo reg was allocated in.  */\n   something_changed = 1;\n-  /* This flag is set if there are any insns that require reloading.  */\n-  something_needs_reloads = 0;\n+\n   /* This flag is set if there are any insns that require register\n      eliminations.  */\n   something_needs_elimination = 0;\n@@ -1002,7 +1022,7 @@ reload (first, global, dumpfile)\n \t  reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n \t}\n \n-      something_changed |= calculate_needs_all_insns (first, global);\n+      something_changed |= calculate_needs_all_insns (global);\n \n       /* If we allocated any new memory locations, make another pass\n \t since it might have changed elimination offsets.  */\n@@ -1024,6 +1044,8 @@ reload (first, global, dumpfile)\n \t    }\n       }\n \n+      finish_spills (global, dumpfile);\n+\n       /* If all needs are met, we win.  */\n \n       for (i = 0; i < N_REG_CLASSES; i++)\n@@ -1075,8 +1097,10 @@ reload (first, global, dumpfile)\n       if (failure)\n \tgoto failed;\n \n+      finish_spills (global, dumpfile);\n+\n       if (something_changed)\n-\tdelete_caller_save_insns (first);\n+\tdelete_caller_save_insns ();\n     }\n \n   /* If global-alloc was run, notify it of any register eliminations we have\n@@ -1111,8 +1135,8 @@ reload (first, global, dumpfile)\n      by generating move instructions to move the must-be-register\n      values into or out of the reload registers.  */\n \n-  if (something_needs_reloads || something_needs_elimination)\n-    reload_as_needed (first, global);\n+  if (insns_need_reload != 0 || something_needs_elimination)\n+    reload_as_needed (global);\n \n   /* If we were able to eliminate the frame pointer, show that it is no\n      longer live at the start of any basic block.  If it ls live by\n@@ -1225,8 +1249,6 @@ reload (first, global, dumpfile)\n \twarning (\"frame size too large for reliable stack checking\");\n     }\n \n-  obstack_free (&reload_obstack, reload_startobj);\n-\n   /* Indicate that we no longer have known memory locations or constants.  */\n   if (reg_equiv_constant)\n     free (reg_equiv_constant);\n@@ -1245,35 +1267,37 @@ reload (first, global, dumpfile)\n   free (reg_equiv_address);\n   free (reg_max_ref_width);\n \n+  FREE_REG_SET (spilled_pseudos);\n+\n   CLEAR_HARD_REG_SET (used_spill_regs);\n   for (i = 0; i < n_spills; i++)\n     SET_HARD_REG_BIT (used_spill_regs, spill_regs[i]);\n \n+  /* Free all the insn_chain structures at once.  */\n+  obstack_free (&reload_obstack, reload_startobj);\n+  unused_insn_chains = 0;\n+\n   return failure;\n }\n \n /* Walk the insns of the current function, starting with FIRST, and collect\n    information about the need to do register elimination and the need to\n    perform reloads.  */\n static int\n-calculate_needs_all_insns (first, global)\n-     rtx first;\n+calculate_needs_all_insns (global)\n      int global;\n {\n-  rtx insn;\n   int something_changed = 0;\n   rtx after_call = 0;\n-  /* Keep track of which basic blocks are needing the reloads.  */\n-  int this_block = 0;\n+  struct insn_chain **pprev_reload = &insns_need_reload;\n+  struct insn_chain *chain;\n \n   /* Compute the most additional registers needed by any instruction.\n      Collect information separately for each class of regs.  */\n-\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n+  \n+  for (chain = reload_insn_chain; chain; chain = chain->next)\n     {\n-      if (global && this_block + 1 < n_basic_blocks\n-\t  && insn == basic_block_head[this_block+1])\n-\t++this_block;\n+      rtx insn = chain->insn;\n \n       /* If this is a label, a JUMP_INSN, or has REG_NOTES (which\n \t might include REG_LABEL), we need to see what effects this\n@@ -1326,23 +1350,9 @@ calculate_needs_all_insns (first, global)\n \t\t\tspill_reg_order);\n \n \t  /* Remember for later shortcuts which insns had any reloads or\n-\t     register eliminations.\n-\n-\t     One might think that it would be worthwhile to mark insns\n-\t     that need register replacements but not reloads, but this is\n-\t     not safe because find_reloads may do some manipulation of\n-\t     the insn (such as swapping commutative operands), which would\n-\t     be lost when we restore the old pattern after register\n-\t     replacement.  So the actions of find_reloads must be redone in\n-\t     subsequent passes or in reload_as_needed.\n-\n-\t     However, it is safe to mark insns that need reloads\n-\t     but not register replacement.  */\n-\n-\t  PUT_MODE (insn, (did_elimination ? QImode\n-\t\t\t   : n_reloads ? HImode\n-\t\t\t   : GET_MODE (insn) == DImode ? DImode\n-\t\t\t   : VOIDmode));\n+\t     register eliminations.  */\n+\t  chain->need_elim = did_elimination;\n+\t  chain->need_reload = n_reloads > 0;\n \n \t  /* Discard any register replacements done.  */\n \t  if (did_elimination)\n@@ -1355,12 +1365,15 @@ calculate_needs_all_insns (first, global)\n \t    }\n \n \t  if (n_reloads != 0)\n-\t    something_changed |= calculate_needs (this_block, insn,\n-\t\t\t\t\t\t  avoid_return_reg, global);\n+\t    {\n+\t      *pprev_reload = chain;\n+\t      pprev_reload = &chain->next_need_reload;\n+\t      something_changed |= calculate_needs (chain, avoid_return_reg,\n+\t\t\t\t\t\t    global);\n+\t    }\n \t}\n-\n-      /* Note that there is a continue statement above.  */\n     }\n+  *pprev_reload = 0;\n   return something_changed;\n }\n \n@@ -1383,21 +1396,15 @@ calculate_needs_all_insns (first, global)\n    inputs and outputs.  */\n \n static int\n-calculate_needs (this_block, insn, avoid_return_reg, global)\n-     int this_block;\n-     rtx insn, avoid_return_reg;\n+calculate_needs (chain, avoid_return_reg, global)\n+     struct insn_chain *chain;\n+     rtx avoid_return_reg;\n      int global;\n {\n+  rtx insn = chain->insn;\n   int something_changed = 0;\n   int i;\n \n-  struct needs\n-  {\n-    /* [0] is normal, [1] is nongroup.  */\n-    int regs[2][N_REG_CLASSES];\n-    int groups[N_REG_CLASSES];\n-  };\n-\n   /* Each `struct needs' corresponds to one RELOAD_... type.  */\n   struct {\n     struct needs other;\n@@ -1413,7 +1420,6 @@ calculate_needs (this_block, insn, avoid_return_reg, global)\n     struct needs out_addr_addr[MAX_RECOG_OPERANDS];\n   } insn_needs;\n \n-  something_needs_reloads = 1;\n   bzero ((char *) &insn_needs, sizeof insn_needs);\n \n   /* Count each reload once in every class\n@@ -1441,9 +1447,9 @@ calculate_needs (this_block, insn, avoid_return_reg, global)\n \t in this basic block.  We do not use insn_needs and\n \t insn_groups because they are overly conservative for\n \t this purpose.  */\n-      if (global && ! basic_block_needs[(int) class][this_block])\n+      if (global && ! basic_block_needs[(int) class][chain->block])\n \t{\n-\t  basic_block_needs[(int) class][this_block] = 1;\n+\t  basic_block_needs[(int) class][chain->block] = 1;\n \t  something_changed = 1;\n \t}\n \n@@ -1703,6 +1709,10 @@ calculate_needs (this_block, insn, avoid_return_reg, global)\n \t  max_nongroups_insn[i] = insn;\n \t}\n     }\n+\n+  /* Record the needs for later.  */\n+  chain->need = insn_needs.other;\n+\n   return something_changed;\n }\n \n@@ -2064,41 +2074,39 @@ dump_needs (dumpfile)\n /* Delete all insns that were inserted by emit_caller_save_insns during\n    this iteration.  */\n static void\n-delete_caller_save_insns (first)\n-     rtx first;\n+delete_caller_save_insns ()\n {\n-  rtx insn = first;\n-  int b = -1;\n+  struct insn_chain *c = reload_insn_chain;\n \n-  while (insn != 0)\n+  while (c != 0)\n     {\n-      if (b + 1 != n_basic_blocks\n-\t  && basic_block_head[b + 1] == insn)\n-\tb++;\n-\n-      while (insn != 0 && INSN_UID (insn) >= reload_first_uid)\n+      while (c != 0 && c->is_caller_save_insn)\n \t{\n-\t  rtx next = NEXT_INSN (insn);\n-\t  rtx prev = PREV_INSN (insn);\n-\n-\t  if (insn == basic_block_head[b])\n-\t    basic_block_head[b] = next;\n-\t  if (insn == basic_block_end[b])\n-\t    basic_block_end[b] = prev;\n-\n-\t  if (next != 0)\n-\t    PREV_INSN (next) = prev;\n-\t  if (prev != 0)\n-\t    NEXT_INSN (prev) = next;\n-\n-\t  insn = next;\n-\n-\t  if (b + 1 != n_basic_blocks\n-\t      && basic_block_head[b + 1] == insn)\n-\t    b++;\n+\t  struct insn_chain *next = c->next;\n+\t  rtx insn = c->insn;\n+\n+\t  if (insn == basic_block_head[c->block])\n+\t    basic_block_head[c->block] = NEXT_INSN (insn);\n+\t  if (insn == basic_block_end[c->block])\n+\t    basic_block_end[c->block] = PREV_INSN (insn);\n+\t  if (c == reload_insn_chain)\n+\t    reload_insn_chain = next;\n+\n+\t  if (NEXT_INSN (insn) != 0)\n+\t    PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n+\t  if (PREV_INSN (insn) != 0)\n+\t    NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n+\n+\t  if (next)\n+\t    next->prev = c->prev;\n+\t  if (c->prev)\n+\t    c->prev->next = next;\n+\t  c->next = unused_insn_chains;\n+\t  unused_insn_chains = c;\n+\t  c = next;\n \t}\n-      if (insn != 0)\n-\tinsn = NEXT_INSN (insn);\n+      if (c != 0)\n+\tc = c->next;\n     }\n }\n \f\n@@ -3809,6 +3817,10 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n \t  retry_global_alloc (i, forbidden_regs);\n \n \talter_reg (i, regno);\n+\n+\tif (reg_renumber[i] == -1)\n+\t  SET_REGNO_REG_SET (spilled_pseudos, i);\n+\n \tif (dumpfile)\n \t  {\n \t    if (reg_renumber[i] == -1)\n@@ -3821,6 +3833,22 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n \n   return something_changed;\n }\n+\n+/* Clear the contents of spilled_pseudos from the life information in all\n+   insn chains.  */\n+static void\n+finish_spills (global, dumpfile)\n+     int global;\n+     FILE *dumpfile;\n+{\n+  struct insn_chain *chain;\n+\n+  for (chain = reload_insn_chain; chain; chain = chain->next)\n+    {\n+      AND_COMPL_REG_SET (chain->live_before, spilled_pseudos);\n+      AND_COMPL_REG_SET (chain->live_after, spilled_pseudos);\n+    }\n+}\n \f\n /* Find all paradoxical subregs within X and update reg_max_ref_width. \n    Also mark any hard registers used to store user variables as\n@@ -4025,13 +4053,11 @@ compare_spill_regs (r1p, r2p)\n    as the insns are scanned.  */\n \n static void\n-reload_as_needed (first, live_known)\n-     rtx first;\n+reload_as_needed (live_known)\n      int live_known;\n {\n-  register rtx insn;\n+  struct insn_chain *chain;\n   register int i;\n-  int this_block = 0;\n   rtx x;\n   rtx after_call = 0;\n \n@@ -4068,14 +4094,10 @@ reload_as_needed (first, live_known)\n \tspill_reg_order[spill_regs[i]] = i;\n     }\n \n-  for (insn = first; insn;)\n+  for (chain = reload_insn_chain; chain; chain = chain->next)\n     {\n-      register rtx next = NEXT_INSN (insn);\n-\n-      /* Notice when we move to a new basic block.  */\n-      if (live_known && this_block + 1 < n_basic_blocks\n-\t  && insn == basic_block_head[this_block+1])\n-\t++this_block;\n+      rtx insn = chain->insn;\n+      rtx old_next = NEXT_INSN (insn);\n \n       /* If we pass a label, copy the offsets from the label information\n \t into the current offsets of each elimination.  */\n@@ -4133,17 +4155,21 @@ reload_as_needed (first, live_known)\n \n \t  /* If we need to do register elimination processing, do so.\n \t     This might delete the insn, in which case we are done.  */\n-\t  if (num_eliminable && GET_MODE (insn) == QImode)\n+\t  if (num_eliminable && chain->need_elim)\n \t    {\n \t      eliminate_regs_in_insn (insn, 1);\n \t      if (GET_CODE (insn) == NOTE)\n-\t\t{\n-\t\t  insn = next;\n-\t\t  continue;\n-\t\t}\n+\t\tcontinue;\n \t    }\n \n-\t  if (GET_MODE (insn) == VOIDmode)\n+\t  /* If need_elim is nonzero but need_reload is zero, one might think\n+\t     that we could simply set n_reloads to 0.  However, find_reloads\n+\t     could have done some manipulation of the insn (such as swapping\n+\t     commutative operands), and these manipulations are lost during\n+\t     the first pass for every insn that needs register elimination.\n+\t     So the actions of find_reloads must be redone here.  */\n+\n+\t  if (! chain->need_elim && ! chain->need_reload)\n \t    n_reloads = 0;\n \t  /* First find the pseudo regs that must be reloaded for this insn.\n \t     This info is returned in the tables reload_... (see reload.h).\n@@ -4170,7 +4196,7 @@ reload_as_needed (first, live_known)\n \n \t      for (class = 0; class < N_REG_CLASSES; class++)\n \t\tif (basic_block_needs[class] != 0\n-\t\t    && basic_block_needs[class][this_block] == 0)\n+\t\t    && basic_block_needs[class][chain->block] == 0)\n \t\t  for (i = 0; i < n_reloads; i++)\n \t\t    if (class == (int) reload_reg_class[i]\n \t\t\t&& reload_reg_rtx[i] == 0\n@@ -4183,7 +4209,7 @@ reload_as_needed (first, live_known)\n \t\t reusing reload regs from previous insns, or else output\n \t\t load insns to reload them.  Maybe output store insns too.\n \t\t Record the choices of reload reg in reload_reg_rtx.  */\n-\t      choose_reload_regs (insn, avoid_return_reg);\n+\t      choose_reload_regs (chain, avoid_return_reg);\n \n \t      /* Merge any reloads that we didn't combine for fear of \n \t\t increasing the number of spill registers needed but now\n@@ -4193,7 +4219,7 @@ reload_as_needed (first, live_known)\n \n \t      /* Generate the insns to reload operands into or out of\n \t\t their reload regs.  */\n-\t      emit_reload_insns (insn, this_block);\n+\t      emit_reload_insns (chain);\n \n \t      /* Substitute the chosen reload regs from reload_reg_rtx\n \t\t into the insn's body (or perhaps into the bodies of other\n@@ -4229,7 +4255,7 @@ reload_as_needed (first, live_known)\n \n \t  /* There may have been CLOBBER insns placed after INSN.  So scan\n \t     between INSN and NEXT and use them to forget old reloads.  */\n-\t  for (x = NEXT_INSN (insn); x != next; x = NEXT_INSN (x))\n+\t  for (x = NEXT_INSN (insn); x != old_next; x = NEXT_INSN (x))\n \t    if (GET_CODE (x) == INSN && GET_CODE (PATTERN (x)) == CLOBBER)\n \t      note_stores (PATTERN (x), forget_old_reloads_1);\n \n@@ -4271,8 +4297,6 @@ reload_as_needed (first, live_known)\n \t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i);\n #endif\n \n-      insn = next;\n-\n #ifdef USE_C_ALLOCA\n       alloca (0);\n #endif\n@@ -5216,12 +5240,13 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum)\n    or 0 if we couldn't find a spill reg and we didn't change anything.  */\n \n static int\n-allocate_reload_reg (r, insn, last_reload, noerror)\n+allocate_reload_reg (chain, r, last_reload, noerror)\n+     struct insn_chain *chain;\n      int r;\n-     rtx insn;\n      int last_reload;\n      int noerror;\n {\n+  rtx insn = chain->insn;\n   int i;\n   int pass;\n   int count;\n@@ -5422,10 +5447,11 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n    finding a reload reg in the proper class.  */\n \n static void\n-choose_reload_regs (insn, avoid_return_reg)\n-     rtx insn;\n+choose_reload_regs (chain, avoid_return_reg)\n+     struct insn_chain *chain;\n      rtx avoid_return_reg;\n {\n+  rtx insn = chain->insn;\n   register int i, j;\n   int max_group_size = 1;\n   enum reg_class group_class = NO_REGS;\n@@ -5668,7 +5694,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t   || reload_secondary_p[reload_order[i]])\n \t\t  && ! reload_optional[reload_order[i]]\n \t\t  && reload_reg_rtx[reload_order[i]] == 0)\n-\t\tallocate_reload_reg (reload_order[i], insn, 0, inheritance);\n+\t\tallocate_reload_reg (chain, reload_order[i], 0, inheritance);\n #endif\n \n \t  /* First see if this pseudo is already available as reloaded\n@@ -5994,7 +6020,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t  if (i == n_reloads)\n \t    continue;\n \n-\t  allocate_reload_reg (r, insn, j == n_reloads - 1, inheritance);\n+\t  allocate_reload_reg (chain, r, j == n_reloads - 1, inheritance);\n #endif\n \t}\n \n@@ -6013,7 +6039,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t  if (reload_reg_rtx[r] != 0 || reload_optional[r])\n \t    continue;\n \n-\t  if (! allocate_reload_reg (r, insn, j == n_reloads - 1, inheritance))\n+\t  if (! allocate_reload_reg (chain, r, j == n_reloads - 1, inheritance))\n \t    break;\n \t}\n \n@@ -6312,10 +6338,11 @@ merge_assigned_reloads (insn)\n /* Output insns to reload values in and out of the chosen reload regs.  */\n \n static void\n-emit_reload_insns (insn, bb)\n-     rtx insn;\n-     int bb;\n+emit_reload_insns (chain)\n+     struct insn_chain *chain;\n {\n+  rtx insn = chain->insn;\n+\n   register int j;\n   rtx input_reload_insns[MAX_RECOG_OPERANDS];\n   rtx other_input_address_reload_insns = 0;\n@@ -7259,10 +7286,10 @@ emit_reload_insns (insn, bb)\n   /* Keep basic block info up to date.  */\n   if (n_basic_blocks)\n     {\n-      if (basic_block_head[bb] == insn)\n-        basic_block_head[bb] = NEXT_INSN (before_insn);\n-      if (basic_block_end[bb] == insn)\n-        basic_block_end[bb] = PREV_INSN (following_insn);\n+      if (basic_block_head[chain->block] == insn)\n+        basic_block_head[chain->block] = NEXT_INSN (before_insn);\n+      if (basic_block_end[chain->block] == insn)\n+        basic_block_end[chain->block] = PREV_INSN (following_insn);\n     }\n \n   /* Move death notes from INSN"}, {"sha": "61aeb850e88d13b2687c17f14f558d87b9387c9a", "filename": "gcc/rtl.texi", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7609e7209a9078fec27fa04108cb5b8173911cbe/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=7609e7209a9078fec27fa04108cb5b8173911cbe", "patch": "@@ -2372,9 +2372,7 @@ These codes are printed symbolically when they appear in debugging dumps.\n @cindex @code{HImode}, in @code{insn}\n @cindex @code{QImode}, in @code{insn}\n The machine mode of an insn is normally @code{VOIDmode}, but some\n-phases use the mode for various purposes; for example, the reload pass\n-sets it to @code{HImode} if the insn needs reloading but not register\n-elimination and @code{QImode} if both are required. \n+phases use the mode for various purposes. \n \n The common subexpression elimination pass sets the mode of an insn to\n @code{QImode} when it is the first insn in a block that has already"}]}