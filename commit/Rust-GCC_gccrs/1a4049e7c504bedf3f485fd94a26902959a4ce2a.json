{"sha": "1a4049e7c504bedf3f485fd94a26902959a4ce2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0MDQ5ZTdjNTA0YmVkZjNmNDg1ZmQ5NGEyNjkwMjk1OWE0Y2UyYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-08-17T07:17:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-08-17T07:17:56Z"}, "message": "invoke.texi (-Wsizeof-pointer-memaccess): Document.\n\n\t* doc/invoke.texi (-Wsizeof-pointer-memaccess): Document.\nc/\n\t* c-tree.h (c_last_sizeof_arg): Declare.\n\t* c-parser.c (struct c_tree_loc_pair): New type.\n\t(c_parser_expr_list): Add sizeof_arg argument.  Fill it in if\n\tnon-NULL.\n\t(c_parser_attributes, c_parser_objc_keywordexpr): Adjust callers.\n\t(c_parser_postfix_expression_after_primary): Likewise.  Call\n\tsizeof_pointer_memaccess_warning if needed.\n\t(sizeof_ptr_memacc_comptypes): New function.\n\t* c-typeck.c (c_last_sizeof_arg): New global variable.\n\t(c_expr_sizeof_expr, c_expr_sizeof_type): Initialize it.\ncp/\n\t* cp-tree.def (SIZEOF_EXPR): Move to c-common.def.\nc-family/\n\t* c-common.c (sizeof_pointer_memaccess_warning): New function.\n\t* c.opt (-Wsizeof-pointer-memaccess): Add new option.\n\t* c-opts.c (c_common_handle_option): Enable it for -Wall.\n\t* c-common.h (sizeof_pointer_memaccess_warning): Add prototype.\n\t* c-common.def (SIZEOF_EXPR): Moved here from cp-tree.def.\nfortran/\n\t* array.c (gfc_match_array_ref): Fix up memset arguments.\ntestsuite/\n\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: New test.\n\nFrom-SVN: r190467", "tree": {"sha": "4109785fceb3bc788cf4f9ee1e8a0fc71649fdfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4109785fceb3bc788cf4f9ee1e8a0fc71649fdfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4049e7c504bedf3f485fd94a26902959a4ce2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4049e7c504bedf3f485fd94a26902959a4ce2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4049e7c504bedf3f485fd94a26902959a4ce2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4049e7c504bedf3f485fd94a26902959a4ce2a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "138f5acd18aafd07cd4a034cb8e879dd0621544b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138f5acd18aafd07cd4a034cb8e879dd0621544b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/138f5acd18aafd07cd4a034cb8e879dd0621544b"}], "stats": {"total": 1010, "additions": 983, "deletions": 27}, "files": [{"sha": "c10e2f8b29ce735cdb1c287da84706e3235aecdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,3 +1,7 @@\n+2012-08-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* doc/invoke.texi (-Wsizeof-pointer-memaccess): Document.\n+\n 2012-08-16  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* config/mips/mips-dsp.md (mips_dpau_h_qbl, mips_dpau_h_qbr)"}, {"sha": "2ce3f59e4939ae440d15bed19c180119a080bcd2", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,3 +1,11 @@\n+2012-08-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.c (sizeof_pointer_memaccess_warning): New function.\n+\t* c.opt (-Wsizeof-pointer-memaccess): Add new option.\n+\t* c-opts.c (c_common_handle_option): Enable it for -Wall.\n+\t* c-common.h (sizeof_pointer_memaccess_warning): Add prototype.\n+\t* c-common.def (SIZEOF_EXPR): Moved here from cp-tree.def.\n+\n 2012-08-10  Richard Guenther  <rguenther@suse.de>\n \n \t* c-pretty-print.c (pp_c_expression): Handle anonymous SSA names."}, {"sha": "502613ae8df41de7c43647267358431142c0fd75", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1841,6 +1841,149 @@ strict_aliasing_warning (tree otype, tree type, tree expr)\n   return false;\n }\n \n+/* Warn about memset (&a, 0, sizeof (&a)); and similar mistakes with\n+   sizeof as last operand of certain builtins.  */\n+\n+void\n+sizeof_pointer_memaccess_warning (location_t loc, tree callee,\n+\t\t\t\t  VEC(tree, gc) *params, tree sizeof_arg,\n+\t\t\t\t  bool (*comp_types) (tree, tree))\n+{\n+  tree type, dest = NULL_TREE, src = NULL_TREE, tem;\n+  bool strop = false;\n+\n+  if (TREE_CODE (callee) != FUNCTION_DECL\n+      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n+      || sizeof_arg == error_mark_node\n+      || VEC_length (tree, params) <= 1)\n+    return;\n+\n+  type = TYPE_P (sizeof_arg) ? sizeof_arg : TREE_TYPE (sizeof_arg);\n+  if (!POINTER_TYPE_P (type))\n+    return;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+    case BUILT_IN_STRNCMP:\n+    case BUILT_IN_STRNCASECMP:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCAT:\n+      strop = true;\n+      /* FALLTHRU */\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMCMP:\n+      if (VEC_length (tree, params) < 3)\n+\treturn;\n+      src = VEC_index (tree, params, 1);\n+      dest = VEC_index (tree, params, 0);\n+      break;\n+    case BUILT_IN_MEMSET:\n+      if (VEC_length (tree, params) < 3)\n+\treturn;\n+      dest = VEC_index (tree, params, 0);\n+      break;\n+    case BUILT_IN_STRNDUP:\n+      src = VEC_index (tree, params, 0);\n+      strop = true;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (dest\n+      && (tem = tree_strip_nop_conversions (dest))\n+      && POINTER_TYPE_P (TREE_TYPE (tem))\n+      && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n+    return;\n+\n+  if (src\n+      && (tem = tree_strip_nop_conversions (src))\n+      && POINTER_TYPE_P (TREE_TYPE (tem))\n+      && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n+    return;\n+\n+  if (dest)\n+    {\n+      if (!TYPE_P (sizeof_arg)\n+\t  && operand_equal_p (dest, sizeof_arg, 0)\n+\t  && comp_types (TREE_TYPE (dest), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the destination; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the destination; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the destination; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (dest))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (dest), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the destination; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (dest),\n+\t\t      TREE_TYPE (TREE_TYPE (dest)));\n+\t  return;\n+\t}\n+    }\n+\n+  if (src)\n+    {\n+      if (!TYPE_P (sizeof_arg)\n+\t  && operand_equal_p (src, sizeof_arg, 0)\n+\t  && comp_types (TREE_TYPE (src), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the source; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (src))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (src), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the source; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (src),\n+\t\t      TREE_TYPE (TREE_TYPE (src)));\n+\t  return;\n+\t}\n+    }\n+}\n+\n /* Warn for unlikely, improbable, or stupid DECL declarations\n    of `main'.  */\n "}, {"sha": "b6df9a3f3eee7f8b0556681c49b53a0f8fe7d2cc", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -2,7 +2,7 @@\n    additional tree codes used in the GNU C compiler (see tree.def\n    for the standard codes).\n    Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998,\n-   1999, 2000, 2001, 2004, 2005, 2007, 2009, 2010\n+   1999, 2000, 2001, 2004, 2005, 2007, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Written by Benjamin Chelf <chelf@codesourcery.com>\n \n@@ -53,6 +53,10 @@ DEFTREECODE (EXCESS_PRECISION_EXPR, \"excess_precision_expr\", tcc_expression, 1)\n    number.  */\n DEFTREECODE (USERDEF_LITERAL, \"userdef_literal\", tcc_exceptional, 3)\n \n+/* Represents a 'sizeof' expression during C++ template expansion,\n+   or for the purpose of -Wsizeof-pointer-memaccess warning.  */\n+DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", tcc_expression, 1)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "9298e3d81707a47098b3e7eebef14ecef6fe3f39", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for c-common.c.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002,\n+   2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -768,6 +768,9 @@ extern tree fix_string_type (tree);\n extern void constant_expression_warning (tree);\n extern void constant_expression_error (tree);\n extern bool strict_aliasing_warning (tree, tree, tree);\n+extern void sizeof_pointer_memaccess_warning (location_t, tree,\n+\t\t\t\t\t      VEC(tree, gc) *, tree,\n+\t\t\t\t\t      bool (*) (tree, tree));\n extern void warnings_for_convert_and_check (tree, tree, tree);\n extern tree convert_and_check (tree, tree);\n extern void overflow_warning (location_t, tree);"}, {"sha": "29121b5d474ce2199a27268608fcbbd536e99419", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,6 +1,6 @@\n /* C/ObjC/C++ command line option handling.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,\n+   2012 Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n This file is part of GCC.\n@@ -374,6 +374,7 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n       warn_return_type = value;\n       warn_sequence_point = value;\t/* Was C only.  */\n       warn_switch = value;\n+      warn_sizeof_pointer_memaccess = value;\n       if (warn_strict_aliasing == -1)\n \tset_Wstrict_aliasing (&global_options, value);\n       warn_address = value;"}, {"sha": "914d110597d612242972d27ac0773f6151e5af68", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -474,6 +474,9 @@ Wmissing-field-initializers\n C ObjC C++ ObjC++ Var(warn_missing_field_initializers) Warning EnabledBy(Wextra)\n Warn about missing fields in struct initializers\n \n+Wsizeof-pointer-memaccess\n+C ObjC C++ ObjC++ Var(warn_sizeof_pointer_memaccess) Warning\n+\n Wsuggest-attribute=format\n C ObjC C++ ObjC++ Var(warn_suggest_attribute_format) Warning\n Warn about functions which might be candidates for format attributes"}, {"sha": "72b5a4d3aa2c683a5ad46f5fd5dbf892f0ac0cd8", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,3 +1,16 @@\n+2012-08-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-tree.h (c_last_sizeof_arg): Declare.\n+\t* c-parser.c (struct c_tree_loc_pair): New type.\n+\t(c_parser_expr_list): Add sizeof_arg argument.  Fill it in if\n+\tnon-NULL.\n+\t(c_parser_attributes, c_parser_objc_keywordexpr): Adjust callers.\n+\t(c_parser_postfix_expression_after_primary): Likewise.  Call\n+\tsizeof_pointer_memaccess_warning if needed.\n+\t(sizeof_ptr_memacc_comptypes): New function.\n+\t* c-typeck.c (c_last_sizeof_arg): New global variable.\n+\t(c_expr_sizeof_expr, c_expr_sizeof_type): Initialize it.\n+\n 2012-07-24  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* c-lang.h (lang_decl): Add variable_size GTY option."}, {"sha": "7536dc56f05cd28f2274609fc20e30959ff0d99b", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1111,6 +1111,12 @@ enum c_parser_prec {\n   NUM_PRECS\n };\n \n+/* Expression and its location.  */\n+struct c_tree_loc_pair {\n+  tree expr;\n+  location_t loc;\n+};\n+\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n@@ -1179,7 +1185,8 @@ static tree c_parser_transaction_cancel (c_parser *);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static VEC(tree,gc) *c_parser_expr_list (c_parser *, bool, bool,\n-\t\t\t\t\t VEC(tree,gc) **);\n+\t\t\t\t\t VEC(tree,gc) **,\n+\t\t\t\t\t struct c_tree_loc_pair *);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -3578,7 +3585,8 @@ c_parser_attributes (c_parser *parser)\n \t\t{\n \t\t  tree tree_list;\n \t\t  c_parser_consume_token (parser);\n-\t\t  expr_list = c_parser_expr_list (parser, false, true, NULL);\n+\t\t  expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t\t  NULL, NULL);\n \t\t  tree_list = build_tree_list_vec (expr_list);\n \t\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n \t\t  release_tree_vector (expr_list);\n@@ -3590,7 +3598,8 @@ c_parser_attributes (c_parser *parser)\n \t\tattr_args = NULL_TREE;\n \t      else\n \t\t{\n-\t\t  expr_list = c_parser_expr_list (parser, false, true, NULL);\n+\t\t  expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t\t  NULL, NULL);\n \t\t  attr_args = build_tree_list_vec (expr_list);\n \t\t  release_tree_vector (expr_list);\n \t\t}\n@@ -6845,6 +6854,15 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   return c_parser_postfix_expression_after_primary (parser, start_loc, expr);\n }\n \n+/* Callback function for sizeof_pointer_memaccess_warning to compare\n+   types.  */\n+\n+static bool\n+sizeof_ptr_memacc_comptypes (tree type1, tree type2)\n+{\n+  return comptypes (type1, type2) == 1;\n+}\n+\n /* Parse a postfix expression after the initial primary or compound\n    literal; that is, parse a series of postfix operators.\n \n@@ -6857,6 +6875,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n {\n   struct c_expr orig_expr;\n   tree ident, idx;\n+  struct c_tree_loc_pair sizeof_arg;\n   VEC(tree,gc) *exprlist;\n   VEC(tree,gc) *origtypes;\n   while (true)\n@@ -6877,14 +6896,22 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_OPEN_PAREN:\n \t  /* Function call.  */\n \t  c_parser_consume_token (parser);\n+\t  sizeof_arg.expr = NULL_TREE;\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t    exprlist = NULL;\n \t  else\n-\t    exprlist = c_parser_expr_list (parser, true, false, &origtypes);\n+\t    exprlist = c_parser_expr_list (parser, true, false, &origtypes,\n+\t\t\t\t\t   &sizeof_arg);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  orig_expr = expr;\n \t  mark_exp_read (expr.value);\n+\t  if (warn_sizeof_pointer_memaccess\n+\t      && sizeof_arg.expr != NULL_TREE)\n+\t    sizeof_pointer_memaccess_warning (sizeof_arg.loc,\n+\t\t\t\t\t      expr.value, exprlist,\n+\t\t\t\t\t      sizeof_arg.expr,\n+\t\t\t\t\t      sizeof_ptr_memacc_comptypes);\n \t  /* FIXME diagnostics: Ideally we want the FUNCNAME, not the\n \t     \"(\" after the FUNCNAME, which is what we have now.    */\n \t  expr.value = build_function_call_vec (op_loc, expr.value, exprlist,\n@@ -7045,19 +7072,24 @@ c_parser_expression_conv (c_parser *parser)\n \n static VEC(tree,gc) *\n c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n-\t\t    VEC(tree,gc) **p_orig_types)\n+\t\t    VEC(tree,gc) **p_orig_types,\n+\t\t    struct c_tree_loc_pair *sizeof_arg)\n {\n   VEC(tree,gc) *ret;\n   VEC(tree,gc) *orig_types;\n   struct c_expr expr;\n   location_t loc = c_parser_peek_token (parser)->location;\n+  location_t sizeof_arg_loc = UNKNOWN_LOCATION;\n \n   ret = make_tree_vector ();\n   if (p_orig_types == NULL)\n     orig_types = NULL;\n   else\n     orig_types = make_tree_vector ();\n \n+  if (sizeof_arg != NULL\n+      && c_parser_next_token_is_keyword (parser, RID_SIZEOF))\n+    sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n     expr = default_function_array_read_conversion (loc, expr);\n@@ -7070,6 +7102,11 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n     {\n       c_parser_consume_token (parser);\n       loc = c_parser_peek_token (parser)->location;\n+      if (sizeof_arg != NULL\n+\t  && c_parser_next_token_is_keyword (parser, RID_SIZEOF))\n+\tsizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n+      else\n+\tsizeof_arg_loc = UNKNOWN_LOCATION;\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n \texpr = default_function_array_read_conversion (loc, expr);\n@@ -7079,6 +7116,20 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n       if (orig_types != NULL)\n \tVEC_safe_push (tree, gc, orig_types, expr.original_type);\n     }\n+  if (sizeof_arg != NULL)\n+    {\n+      if (sizeof_arg_loc != UNKNOWN_LOCATION\n+\t  && expr.original_code == SIZEOF_EXPR)\n+\t{\n+\t  sizeof_arg->expr = c_last_sizeof_arg;\n+\t  sizeof_arg->loc = sizeof_arg_loc;\n+\t}\n+      else\n+\t{\n+\t  sizeof_arg->expr = NULL_TREE;\n+\t  sizeof_arg->loc = UNKNOWN_LOCATION;\n+\t}\n+    }\n   if (orig_types != NULL)\n     *p_orig_types = orig_types;\n   return ret;\n@@ -8157,7 +8208,8 @@ static tree\n c_parser_objc_keywordexpr (c_parser *parser)\n {\n   tree ret;\n-  VEC(tree,gc) *expr_list = c_parser_expr_list (parser, true, true, NULL);\n+  VEC(tree,gc) *expr_list = c_parser_expr_list (parser, true, true,\n+\t\t\t\t\t\tNULL, NULL);\n   if (VEC_length (tree, expr_list) == 1)\n     {\n       /* Just return the expression, remove a level of"}, {"sha": "c07d994975d6604b9d68d44816fde68ae9028b69", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,7 +1,7 @@\n /* Definitions for C parsing and type checking.\n    Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011,\n+   2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -573,6 +573,8 @@ extern int in_alignof;\n extern int in_sizeof;\n extern int in_typeof;\n \n+extern tree c_last_sizeof_arg;\n+\n extern struct c_switch *c_switch_stack;\n \n extern tree c_objc_common_truthvalue_conversion (location_t, tree);"}, {"sha": "99920ef288b140eabd1d08ceb3afdc3126bc891e", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,7 +1,7 @@\n /* Build expressions with type checking for C compiler.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011, 2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -67,6 +67,10 @@ int in_sizeof;\n /* The level of nesting inside \"typeof\".  */\n int in_typeof;\n \n+/* The argument of last parsed sizeof expression, only to be tested\n+   if expr.original_code == SIZEOF_EXPR.  */\n+tree c_last_sizeof_arg;\n+\n /* Nonzero if we've already printed a \"missing braces around initializer\"\n    message within this initializer.  */\n static int missing_braces_mentioned;\n@@ -2603,7 +2607,8 @@ c_expr_sizeof_expr (location_t loc, struct c_expr expr)\n       tree folded_expr = c_fully_fold (expr.value, require_constant_value,\n \t\t\t\t       &expr_const_operands);\n       ret.value = c_sizeof (loc, TREE_TYPE (folded_expr));\n-      ret.original_code = ERROR_MARK;\n+      c_last_sizeof_arg = expr.value;\n+      ret.original_code = SIZEOF_EXPR;\n       ret.original_type = NULL;\n       if (c_vla_type_p (TREE_TYPE (folded_expr)))\n \t{\n@@ -2631,7 +2636,8 @@ c_expr_sizeof_type (location_t loc, struct c_type_name *t)\n   bool type_expr_const = true;\n   type = groktypename (t, &type_expr, &type_expr_const);\n   ret.value = c_sizeof (loc, type);\n-  ret.original_code = ERROR_MARK;\n+  c_last_sizeof_arg = type;\n+  ret.original_code = SIZEOF_EXPR;\n   ret.original_type = NULL;\n   if ((type_expr || TREE_CODE (ret.value) == INTEGER_CST)\n       && c_vla_type_p (type))"}, {"sha": "87fc86ff50c45a9c8932bce86a39ebb5df070341", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,3 +1,7 @@\n+2012-08-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.def (SIZEOF_EXPR): Move to c-common.def.\n+\n 2012-08-14   Diego Novillo  <dnovillo@google.com>\n \n \tMerge from cxx-conversion branch.  Re-write VEC in C++."}, {"sha": "b5ed167ca37136545e101d0b08c1ce9051b7898d", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -2,7 +2,7 @@\n    additional tree codes used in the GNU C++ compiler (see tree.def\n    for the standard codes).\n    Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998, 2003, 2004, 2005,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2010, 2011\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -333,9 +333,6 @@ DEFTREECODE (TAG_DEFN, \"tag_defn\", tcc_expression, 0)\n /* Represents an 'offsetof' expression during template expansion.  */\n DEFTREECODE (OFFSETOF_EXPR, \"offsetof_expr\", tcc_expression, 1)\n \n-/* Represents a 'sizeof' expression during template expansion.  */\n-DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", tcc_expression, 1)\n-\n /* Represents the -> operator during template expansion.  */\n DEFTREECODE (ARROW_EXPR, \"arrow_expr\", tcc_expression, 1)\n "}, {"sha": "ae22ca9aa0c4115199b1064ec500e9fe7c425564", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -263,9 +263,9 @@ Objective-C and Objective-C++ Dialects}.\n -Wpointer-arith  -Wno-pointer-to-int-cast @gol\n -Wredundant-decls @gol\n -Wreturn-type  -Wsequence-point  -Wshadow @gol\n--Wsign-compare  -Wsign-conversion  -Wstack-protector @gol\n--Wstack-usage=@var{len} -Wstrict-aliasing -Wstrict-aliasing=n @gol\n--Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n+-Wsign-compare  -Wsign-conversion  -Wsizeof-pointer-memaccess @gol\n+-Wstack-protector -Wstack-usage=@var{len} -Wstrict-aliasing @gol\n+-Wstrict-aliasing=n @gol -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{]} @gol\n -Wmissing-format-attribute @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum -Wsync-nand @gol\n@@ -4327,6 +4327,16 @@ value, like assigning a signed integer expression to an unsigned\n integer variable. An explicit cast silences the warning. In C, this\n option is enabled also by @option{-Wconversion}.\n \n+@item -Wsizeof-pointer-memaccess\n+@opindex Wsizeof-pointer-memaccess\n+@opindex Wno-sizeof-pointer-memaccess\n+Warn for suspicious length parameters to certain string and memory built-in\n+functions if the argument uses @code{sizeof}.  This warning warns e.g.@:\n+about @code{memset (ptr, 0, sizeof (ptr));} if @code{ptr} is not an array,\n+but a pointer, and suggests a possible fix, or about\n+@code{memcpy (&foo, ptr, sizeof (&foo));}.  This warning is enabled by\n+@option{-Wall}.\n+\n @item -Waddress\n @opindex Waddress\n @opindex Wno-address"}, {"sha": "77e98a01d6c21a33df3a6328f5a9e6328b5fa3ac", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,3 +1,7 @@\n+2012-08-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* array.c (gfc_match_array_ref): Fix up memset arguments.\n+\n 2012-08-16   Diego Novillo  <dnovillo@google.com>\n \n \tRevert"}, {"sha": "07fecd8aaf387dcb1075922c1ed2d3d7b9a5aab7", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,6 +1,6 @@\n /* Array things\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011, 2012 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -159,7 +159,7 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n   match m;\n   bool matched_bracket = false;\n \n-  memset (ar, '\\0', sizeof (ar));\n+  memset (ar, '\\0', sizeof (*ar));\n \n   ar->where = gfc_current_locus;\n   ar->as = as;"}, {"sha": "e680b76516960b4878831828db64050a25d76d81", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -1,3 +1,7 @@\n+2012-08-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: New test.\n+\n 2012-08-16  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54236"}, {"sha": "3897518de63814078b02143a30a4c4981e2f4a73", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4049e7c504bedf3f485fd94a26902959a4ce2a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=1a4049e7c504bedf3f485fd94a26902959a4ce2a", "patch": "@@ -0,0 +1,698 @@\n+/* Test -Wsizeof-pointer-memaccess warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+/* Test just twice, once with -O0 non-fortified, once with -O2 fortified.  */\n+/* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memset (void *, int, size_t);\n+extern void *memcpy (void *__restrict, const void *__restrict, size_t);\n+extern void *memmove (void *__restrict, const void *__restrict, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *strncpy (char *__restrict, const char *__restrict, size_t);\n+extern char *strncat (char *__restrict, const char *__restrict, size_t);\n+extern char *strndup (const char *, size_t);\n+extern int strncmp (const char *, const char *, size_t);\n+extern int strncasecmp (const char *, const char *, size_t);\n+\n+#ifdef __OPTIMIZE__\n+# define bos(ptr) __builtin_object_size (ptr, 1)\n+# define bos0(ptr) __builtin_object_size (ptr, 0)\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memset (void *dest, int c, size_t len)\n+{\n+  return __builtin___memset_chk (dest, c, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memcpy (void *__restrict dest, const void *__restrict src, size_t len)\n+{\n+  return __builtin___memcpy_chk (dest, src, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memmove (void *dest, const void *src, size_t len)\n+{\n+  return __builtin___memmove_chk (dest, src, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+strncpy (char *__restrict dest, const char *__restrict src, size_t len)\n+{\n+  return __builtin___strncpy_chk (dest, src, len, bos (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+strncat (char *dest, const char *src, size_t len)\n+{\n+  return __builtin___strncat_chk (dest, src, len, bos (dest));\n+}\n+#endif\n+\n+struct A { short a, b; int c, d; long e, f; };\n+typedef struct A TA;\n+typedef struct A *PA;\n+typedef TA *PTA;\n+struct B {};\n+typedef struct B TB;\n+typedef struct B *PB;\n+typedef TB *PTB;\n+typedef int X[3][3][3];\n+\n+int\n+f1 (void *x, int z)\n+{\n+  struct A a, *pa1 = &a;\n+  TA *pa2 = &a;\n+  PA pa3 = &a;\n+  PTA pa4 = &a;\n+  memset (&a, 0, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memset (pa1, 0, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa2, 0, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa3, 0, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa4, 0, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa1, 0, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pa2, 0, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pa3, 0, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pa4, 0, sizeof (__typeof (pa4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (&a, x, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memcpy (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa2, x, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa4, x, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa1, x, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pa2, x, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pa3, x, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pa4, x, sizeof (__typeof (pa4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (x, &a, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memcpy (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa2, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa4, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa1, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pa2, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pa3, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pa4, sizeof (__typeof (pa4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (&a, x, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memmove (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa2, x, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa4, x, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa1, x, sizeof (struct A *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pa2, x, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pa3, x, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pa4, x, sizeof (__typeof (pa4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (x, &a, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memmove (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa2, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa4, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa1, sizeof (struct A *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pa2, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pa4, sizeof (__typeof (pa4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += memcmp (&a, x, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  z += memcmp (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pa2, x, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pa4, x, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pa1, x, sizeof (struct A *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pa2, x, sizeof (PTA));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pa3, x, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += memcmp (x, &a, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  z += memcmp (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa2, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa4, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa1, sizeof (struct A *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pa2, sizeof (PTA));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  memset (&a, 0, sizeof a);\n+  memset (&a, 0, sizeof (a));\n+  memset (&a, 0, sizeof (struct A));\n+  memset (&a, 0, sizeof (const struct A));\n+  memset (&a, 0, sizeof (volatile struct A));\n+  memset (&a, 0, sizeof (volatile const struct A));\n+  memset (&a, 0, sizeof (TA));\n+  memset (&a, 0, sizeof (__typeof (*&a)));\n+  memset (pa1, 0, sizeof (*pa1));\n+  memset (pa2, 0, sizeof (*pa3));\n+  memset (pa3, 0, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memset ((void *) &a, 0, sizeof (&a));\n+  memset ((char *) &a, 0, sizeof (&a));\n+  memset (&a, 0, sizeof (&a) + 0);\n+  memset (&a, 0, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (&a, x, sizeof a);\n+  memcpy (&a, x, sizeof (a));\n+  memcpy (&a, x, sizeof (struct A));\n+  memcpy (&a, x, sizeof (const struct A));\n+  memcpy (&a, x, sizeof (volatile struct A));\n+  memcpy (&a, x, sizeof (volatile const struct A));\n+  memcpy (&a, x, sizeof (TA));\n+  memcpy (&a, x, sizeof (__typeof (*&a)));\n+  memcpy (pa1, x, sizeof (*pa1));\n+  memcpy (pa2, x, sizeof (*pa3));\n+  memcpy (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy ((void *) &a, x, sizeof (&a));\n+  memcpy ((char *) &a, x, sizeof (&a));\n+  memcpy (&a, x, sizeof (&a) + 0);\n+  memcpy (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (x, &a, sizeof a);\n+  memcpy (x, &a, sizeof (a));\n+  memcpy (x, &a, sizeof (struct A));\n+  memcpy (x, &a, sizeof (const struct A));\n+  memcpy (x, &a, sizeof (volatile struct A));\n+  memcpy (x, &a, sizeof (volatile const struct A));\n+  memcpy (x, &a, sizeof (TA));\n+  memcpy (x, &a, sizeof (__typeof (*&a)));\n+  memcpy (x, pa1, sizeof (*pa1));\n+  memcpy (x, pa2, sizeof (*pa3));\n+  memcpy (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy (x, (void *) &a, sizeof (&a));\n+  memcpy (x, (char *) &a, sizeof (&a));\n+  memcpy (x, &a, sizeof (&a) + 0);\n+  memcpy (x, &a, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memmove (&a, x, sizeof a);\n+  memmove (&a, x, sizeof (a));\n+  memmove (&a, x, sizeof (struct A));\n+  memmove (&a, x, sizeof (const struct A));\n+  memmove (&a, x, sizeof (volatile struct A));\n+  memmove (&a, x, sizeof (volatile const struct A));\n+  memmove (&a, x, sizeof (TA));\n+  memmove (&a, x, sizeof (__typeof (*&a)));\n+  memmove (pa1, x, sizeof (*pa1));\n+  memmove (pa2, x, sizeof (*pa3));\n+  memmove (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove ((void *) &a, x, sizeof (&a));\n+  memmove ((char *) &a, x, sizeof (&a));\n+  memmove (&a, x, sizeof (&a) + 0);\n+  memmove (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memmove (x, &a, sizeof a);\n+  memmove (x, &a, sizeof (a));\n+  memmove (x, &a, sizeof (struct A));\n+  memmove (x, &a, sizeof (const struct A));\n+  memmove (x, &a, sizeof (volatile struct A));\n+  memmove (x, &a, sizeof (volatile const struct A));\n+  memmove (x, &a, sizeof (TA));\n+  memmove (x, &a, sizeof (__typeof (*&a)));\n+  memmove (x, pa1, sizeof (*pa1));\n+  memmove (x, pa2, sizeof (*pa3));\n+  memmove (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove (x, (void *) &a, sizeof (&a));\n+  memmove (x, (char *) &a, sizeof (&a));\n+  memmove (x, &a, sizeof (&a) + 0);\n+  memmove (x, &a, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  z += memcmp (&a, x, sizeof a);\n+  z += memcmp (&a, x, sizeof (a));\n+  z += memcmp (&a, x, sizeof (struct A));\n+  z += memcmp (&a, x, sizeof (const struct A));\n+  z += memcmp (&a, x, sizeof (volatile struct A));\n+  z += memcmp (&a, x, sizeof (volatile const struct A));\n+  z += memcmp (&a, x, sizeof (TA));\n+  z += memcmp (&a, x, sizeof (__typeof (*&a)));\n+  z += memcmp (pa1, x, sizeof (*pa1));\n+  z += memcmp (pa2, x, sizeof (*pa3));\n+  z += memcmp (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += memcmp ((void *) &a, x, sizeof (&a));\n+  z += memcmp ((char *) &a, x, sizeof (&a));\n+  z += memcmp (&a, x, sizeof (&a) + 0);\n+  z += memcmp (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  z += memcmp (x, &a, sizeof a);\n+  z += memcmp (x, &a, sizeof (a));\n+  z += memcmp (x, &a, sizeof (struct A));\n+  z += memcmp (x, &a, sizeof (const struct A));\n+  z += memcmp (x, &a, sizeof (volatile struct A));\n+  z += memcmp (x, &a, sizeof (volatile const struct A));\n+  z += memcmp (x, &a, sizeof (TA));\n+  z += memcmp (x, &a, sizeof (__typeof (*&a)));\n+  z += memcmp (x, pa1, sizeof (*pa1));\n+  z += memcmp (x, pa2, sizeof (*pa3));\n+  z += memcmp (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += memcmp (x, (void *) &a, sizeof (&a));\n+  z += memcmp (x, (char *) &a, sizeof (&a));\n+  z += memcmp (x, &a, sizeof (&a) + 0);\n+  z += memcmp (x, &a, 0 + sizeof (&a));\n+\n+  return z;\n+}\n+\n+int\n+f2 (void *x, int z)\n+{\n+  struct B b, *pb1 = &b;\n+  TB *pb2 = &b;\n+  PB pb3 = &b;\n+  PTB pb4 = &b;\n+  memset (&b, 0, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memset (pb1, 0, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb2, 0, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb3, 0, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb4, 0, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb1, 0, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pb2, 0, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pb3, 0, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pb4, 0, sizeof (__typeof (pb4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (&b, x, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memcpy (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb2, x, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb4, x, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb1, x, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pb2, x, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pb3, x, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pb4, x, sizeof (__typeof (pb4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (x, &b, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memcpy (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb2, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb4, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb1, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pb2, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pb3, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pb4, sizeof (__typeof (pb4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (&b, x, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memmove (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb2, x, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb4, x, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb1, x, sizeof (struct B *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pb2, x, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pb3, x, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pb4, x, sizeof (__typeof (pb4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (x, &b, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memmove (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb2, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb4, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb1, sizeof (struct B *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pb2, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pb4, sizeof (__typeof (pb4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += memcmp (&b, x, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  z += memcmp (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pb2, x, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pb4, x, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (pb1, x, sizeof (struct B *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pb2, x, sizeof (PTB));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pb3, x, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += memcmp (x, &b, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  z += memcmp (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb2, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb4, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb1, sizeof (struct B *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pb2, sizeof (PTB));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  memset (&b, 0, sizeof b);\n+  memset (&b, 0, sizeof (b));\n+  memset (&b, 0, sizeof (struct B));\n+  memset (&b, 0, sizeof (const struct B));\n+  memset (&b, 0, sizeof (volatile struct B));\n+  memset (&b, 0, sizeof (volatile const struct B));\n+  memset (&b, 0, sizeof (TB));\n+  memset (&b, 0, sizeof (__typeof (*&b)));\n+  memset (pb1, 0, sizeof (*pb1));\n+  memset (pb2, 0, sizeof (*pb3));\n+  memset (pb3, 0, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memset ((void *) &b, 0, sizeof (&b));\n+  memset ((char *) &b, 0, sizeof (&b));\n+  memset (&b, 0, sizeof (&b) + 0);\n+  memset (&b, 0, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (&b, x, sizeof b);\n+  memcpy (&b, x, sizeof (b));\n+  memcpy (&b, x, sizeof (struct B));\n+  memcpy (&b, x, sizeof (const struct B));\n+  memcpy (&b, x, sizeof (volatile struct B));\n+  memcpy (&b, x, sizeof (volatile const struct B));\n+  memcpy (&b, x, sizeof (TB));\n+  memcpy (&b, x, sizeof (__typeof (*&b)));\n+  memcpy (pb1, x, sizeof (*pb1));\n+  memcpy (pb2, x, sizeof (*pb3));\n+  memcpy (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy ((void *) &b, x, sizeof (&b));\n+  memcpy ((char *) &b, x, sizeof (&b));\n+  memcpy (&b, x, sizeof (&b) + 0);\n+  memcpy (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (x, &b, sizeof b);\n+  memcpy (x, &b, sizeof (b));\n+  memcpy (x, &b, sizeof (struct B));\n+  memcpy (x, &b, sizeof (const struct B));\n+  memcpy (x, &b, sizeof (volatile struct B));\n+  memcpy (x, &b, sizeof (volatile const struct B));\n+  memcpy (x, &b, sizeof (TB));\n+  memcpy (x, &b, sizeof (__typeof (*&b)));\n+  memcpy (x, pb1, sizeof (*pb1));\n+  memcpy (x, pb2, sizeof (*pb3));\n+  memcpy (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy (x, (void *) &b, sizeof (&b));\n+  memcpy (x, (char *) &b, sizeof (&b));\n+  memcpy (x, &b, sizeof (&b) + 0);\n+  memcpy (x, &b, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memmove (&b, x, sizeof b);\n+  memmove (&b, x, sizeof (b));\n+  memmove (&b, x, sizeof (struct B));\n+  memmove (&b, x, sizeof (const struct B));\n+  memmove (&b, x, sizeof (volatile struct B));\n+  memmove (&b, x, sizeof (volatile const struct B));\n+  memmove (&b, x, sizeof (TB));\n+  memmove (&b, x, sizeof (__typeof (*&b)));\n+  memmove (pb1, x, sizeof (*pb1));\n+  memmove (pb2, x, sizeof (*pb3));\n+  memmove (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove ((void *) &b, x, sizeof (&b));\n+  memmove ((char *) &b, x, sizeof (&b));\n+  memmove (&b, x, sizeof (&b) + 0);\n+  memmove (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memmove (x, &b, sizeof b);\n+  memmove (x, &b, sizeof (b));\n+  memmove (x, &b, sizeof (struct B));\n+  memmove (x, &b, sizeof (const struct B));\n+  memmove (x, &b, sizeof (volatile struct B));\n+  memmove (x, &b, sizeof (volatile const struct B));\n+  memmove (x, &b, sizeof (TB));\n+  memmove (x, &b, sizeof (__typeof (*&b)));\n+  memmove (x, pb1, sizeof (*pb1));\n+  memmove (x, pb2, sizeof (*pb3));\n+  memmove (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove (x, (void *) &b, sizeof (&b));\n+  memmove (x, (char *) &b, sizeof (&b));\n+  memmove (x, &b, sizeof (&b) + 0);\n+  memmove (x, &b, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  z += memcmp (&b, x, sizeof b);\n+  z += memcmp (&b, x, sizeof (b));\n+  z += memcmp (&b, x, sizeof (struct B));\n+  z += memcmp (&b, x, sizeof (const struct B));\n+  z += memcmp (&b, x, sizeof (volatile struct B));\n+  z += memcmp (&b, x, sizeof (volatile const struct B));\n+  z += memcmp (&b, x, sizeof (TB));\n+  z += memcmp (&b, x, sizeof (__typeof (*&b)));\n+  z += memcmp (pb1, x, sizeof (*pb1));\n+  z += memcmp (pb2, x, sizeof (*pb3));\n+  z += memcmp (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += memcmp ((void *) &b, x, sizeof (&b));\n+  z += memcmp ((char *) &b, x, sizeof (&b));\n+  z += memcmp (&b, x, sizeof (&b) + 0);\n+  z += memcmp (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  z += memcmp (x, &b, sizeof b);\n+  z += memcmp (x, &b, sizeof (b));\n+  z += memcmp (x, &b, sizeof (struct B));\n+  z += memcmp (x, &b, sizeof (const struct B));\n+  z += memcmp (x, &b, sizeof (volatile struct B));\n+  z += memcmp (x, &b, sizeof (volatile const struct B));\n+  z += memcmp (x, &b, sizeof (TB));\n+  z += memcmp (x, &b, sizeof (__typeof (*&b)));\n+  z += memcmp (x, pb1, sizeof (*pb1));\n+  z += memcmp (x, pb2, sizeof (*pb3));\n+  z += memcmp (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += memcmp (x, (void *) &b, sizeof (&b));\n+  z += memcmp (x, (char *) &b, sizeof (&b));\n+  z += memcmp (x, &b, sizeof (&b) + 0);\n+  z += memcmp (x, &b, 0 + sizeof (&b));\n+\n+  return z;\n+}\n+\n+int\n+f3 (void *x, char *y, int z, X w)\n+{\n+  unsigned char *y1 = (unsigned char *) __builtin_alloca (z + 16);\n+  char buf1[7];\n+  signed char buf2[z + 32];\n+  long buf3[17];\n+  int *buf4[9];\n+  signed char *y2 = buf2;\n+  char c;\n+  char *y3;\n+  memset (y, 0, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memset (y1, 0, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memset (y2, 0, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memset (&c, 0, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memset (w, 0, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  memcpy (y, x, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memcpy (y1, x, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memcpy (y2, x, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memcpy (&c, x, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memcpy (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  memcpy (x, y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memcpy (x, y1, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memcpy (x, y2, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memcpy (x, &c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memcpy (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  memmove (y, x, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memmove (y1, x, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memmove (y2, x, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memmove (&c, x, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memmove (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  memmove (x, y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memmove (x, y1, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memmove (x, y2, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memmove (x, &c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memmove (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  z += memcmp (y, x, sizeof (y));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  z += memcmp (y1, x, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  z += memcmp (y2, x, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  z += memcmp (&c, x, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  z += memcmp (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  z += memcmp (x, y, sizeof (y));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  z += memcmp (x, y1, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  z += memcmp (x, y2, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  z += memcmp (x, &c, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  z += memcmp (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  /* These are correct, no warning.  */\n+  memset (y, 0, sizeof (*y));\n+  memset (y1, 0, sizeof (*y2));\n+  memset (buf1, 0, sizeof buf1);\n+  memset (buf3, 0, sizeof (buf3));\n+  memset (&buf3[0], 0, sizeof (buf3));\n+  memset (&buf4[0], 0, sizeof (buf4));\n+  memset (w, 0, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memset ((void *) y, 0, sizeof (y));\n+  memset ((char *) y1, 0, sizeof (y2));\n+  memset (y, 0, sizeof (y) + 0);\n+  memset (y1, 0, 0 + sizeof (y2));\n+  memset ((void *) &c, 0, sizeof (&c));\n+  memset ((signed char *) &c, 0, sizeof (&c));\n+  memset (&c, 0, sizeof (&c) + 0);\n+  memset (&c, 0, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (y, x, sizeof (*y));\n+  memcpy (y1, x, sizeof (*y2));\n+  memcpy (buf1, x, sizeof buf1);\n+  memcpy (buf3, x, sizeof (buf3));\n+  memcpy (&buf3[0], x, sizeof (buf3));\n+  memcpy (&buf4[0], x, sizeof (buf4));\n+  memcpy (&y3, y, sizeof (y3));\n+  memcpy ((char *) &y3, y, sizeof (y3));\n+  memcpy (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy ((void *) y, x, sizeof (y));\n+  memcpy ((char *) y1, x, sizeof (y2));\n+  memcpy (y, x, sizeof (y) + 0);\n+  memcpy (y1, x, 0 + sizeof (y2));\n+  memcpy ((void *) &c, x, sizeof (&c));\n+  memcpy ((signed char *) &c, x, sizeof (&c));\n+  memcpy (&c, x, sizeof (&c) + 0);\n+  memcpy (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (x, y, sizeof (*y));\n+  memcpy (x, y1, sizeof (*y2));\n+  memcpy (x, buf1, sizeof buf1);\n+  memcpy (x, buf3, sizeof (buf3));\n+  memcpy (x, &buf3[0], sizeof (buf3));\n+  memcpy (x, &buf4[0], sizeof (buf4));\n+  memcpy (y, &y3, sizeof (y3));\n+  memcpy (y, (char *) &y3, sizeof (y3));\n+  memcpy (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy (x, (void *) y, sizeof (y));\n+  memcpy (x, (char *) y1, sizeof (y2));\n+  memcpy (x, y, sizeof (y) + 0);\n+  memcpy (x, y1, 0 + sizeof (y2));\n+  memcpy (x, (void *) &c, sizeof (&c));\n+  memcpy (x, (signed char *) &c, sizeof (&c));\n+  memcpy (x, &c, sizeof (&c) + 0);\n+  memcpy (x, &c, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memmove (y, x, sizeof (*y));\n+  memmove (y1, x, sizeof (*y2));\n+  memmove (buf1, x, sizeof buf1);\n+  memmove (buf3, x, sizeof (buf3));\n+  memmove (&buf3[0], x, sizeof (buf3));\n+  memmove (&buf4[0], x, sizeof (buf4));\n+  memmove (&y3, y, sizeof (y3));\n+  memmove ((char *) &y3, y, sizeof (y3));\n+  memmove (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove ((void *) y, x, sizeof (y));\n+  memmove ((char *) y1, x, sizeof (y2));\n+  memmove (y, x, sizeof (y) + 0);\n+  memmove (y1, x, 0 + sizeof (y2));\n+  memmove ((void *) &c, x, sizeof (&c));\n+  memmove ((signed char *) &c, x, sizeof (&c));\n+  memmove (&c, x, sizeof (&c) + 0);\n+  memmove (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memmove (x, y, sizeof (*y));\n+  memmove (x, y1, sizeof (*y2));\n+  memmove (x, buf1, sizeof buf1);\n+  memmove (x, buf3, sizeof (buf3));\n+  memmove (x, &buf3[0], sizeof (buf3));\n+  memmove (x, &buf4[0], sizeof (buf4));\n+  memmove (y, &y3, sizeof (y3));\n+  memmove (y, (char *) &y3, sizeof (y3));\n+  memmove (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove (x, (void *) y, sizeof (y));\n+  memmove (x, (char *) y1, sizeof (y2));\n+  memmove (x, y, sizeof (y) + 0);\n+  memmove (x, y1, 0 + sizeof (y2));\n+  memmove (x, (void *) &c, sizeof (&c));\n+  memmove (x, (signed char *) &c, sizeof (&c));\n+  memmove (x, &c, sizeof (&c) + 0);\n+  memmove (x, &c, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  z += memcmp (y, x, sizeof (*y));\n+  z += memcmp (y1, x, sizeof (*y2));\n+  z += memcmp (buf1, x, sizeof buf1);\n+  z += memcmp (buf3, x, sizeof (buf3));\n+  z += memcmp (&buf3[0], x, sizeof (buf3));\n+  z += memcmp (&buf4[0], x, sizeof (buf4));\n+  z += memcmp (&y3, y, sizeof (y3));\n+  z += memcmp ((char *) &y3, y, sizeof (y3));\n+  z += memcmp (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += memcmp ((void *) y, x, sizeof (y));\n+  z += memcmp ((char *) y1, x, sizeof (y2));\n+  z += memcmp (y, x, sizeof (y) + 0);\n+  z += memcmp (y1, x, 0 + sizeof (y2));\n+  z += memcmp ((void *) &c, x, sizeof (&c));\n+  z += memcmp ((signed char *) &c, x, sizeof (&c));\n+  z += memcmp (&c, x, sizeof (&c) + 0);\n+  z += memcmp (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  z += memcmp (x, y, sizeof (*y));\n+  z += memcmp (x, y1, sizeof (*y2));\n+  z += memcmp (x, buf1, sizeof buf1);\n+  z += memcmp (x, buf3, sizeof (buf3));\n+  z += memcmp (x, &buf3[0], sizeof (buf3));\n+  z += memcmp (x, &buf4[0], sizeof (buf4));\n+  z += memcmp (y, &y3, sizeof (y3));\n+  z += memcmp (y, (char *) &y3, sizeof (y3));\n+  z += memcmp (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += memcmp (x, (void *) y, sizeof (y));\n+  z += memcmp (x, (char *) y1, sizeof (y2));\n+  z += memcmp (x, y, sizeof (y) + 0);\n+  z += memcmp (x, y1, 0 + sizeof (y2));\n+  z += memcmp (x, (void *) &c, sizeof (&c));\n+  z += memcmp (x, (signed char *) &c, sizeof (&c));\n+  z += memcmp (x, &c, sizeof (&c) + 0);\n+  z += memcmp (x, &c, 0 + sizeof (&c));\n+\n+  return z;\n+}\n+\n+int\n+f4 (char *x, char **y, int z)\n+{\n+  const char *s1 = \"foobarbaz\";\n+  const char *s2 = \"abcde12345678\";\n+  strncpy (x, s1, sizeof (s1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  strncat (x, s2, sizeof (s2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  y[0] = strndup (s1, sizeof (s1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  z += strncmp (s1, s2, sizeof (s1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  z += strncmp (s1, s2, sizeof (s2));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  z += strncasecmp (s1, s2, sizeof (s1));   /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  z += strncasecmp (s1, s2, sizeof (s2));   /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  const char s3[] = \"foobarbaz\";\n+  const char s4[] = \"abcde12345678\";\n+  strncpy (x, s3, sizeof (s3));\n+  strncat (x, s4, sizeof (s4));\n+  y[1] = strndup (s3, sizeof (s3));\n+  z += strncmp (s3, s4, sizeof (s3));\n+  z += strncmp (s3, s4, sizeof (s4));\n+  z += strncasecmp (s3, s4, sizeof (s3));\n+  z += strncasecmp (s3, s4, sizeof (s4));\n+\n+  return z;\n+}\n+\n+/* { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" } */"}]}