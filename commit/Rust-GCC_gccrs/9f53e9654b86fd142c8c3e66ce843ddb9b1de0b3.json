{"sha": "9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY1M2U5NjU0Yjg2ZmQxNDJjOGMzZTY2Y2U4NDNkZGI5YjFkZTBiMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-03-13T06:10:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-13T06:10:23Z"}, "message": "re PR target/5901 ([IA64] misplaced .body)\n\n        PR optimization/5901\n        * function.c (reposition_prologue_and_epilogue_notes): Position\n        the markers after/before the last/first insn not deleted.\n\nFrom-SVN: r50715", "tree": {"sha": "a1e4931ef78ae5e20fe5c661e7f9e42a98de6573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1e4931ef78ae5e20fe5c661e7f9e42a98de6573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3/comments", "author": null, "committer": null, "parents": [{"sha": "5b43fed17bf58c31f3151dd37966e7a9b85a309e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b43fed17bf58c31f3151dd37966e7a9b85a309e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b43fed17bf58c31f3151dd37966e7a9b85a309e"}], "stats": {"total": 99, "additions": 55, "deletions": 44}, "files": [{"sha": "39de91fe4c38cf3da3fe048dec7a6d42f3180b91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3", "patch": "@@ -1,5 +1,12 @@\n 2002-03-12  Richard Henderson  <rth@redhat.com>\n \n+\tPR optimization/5901\n+\t* function.c (reposition_prologue_and_epilogue_notes): Position\n+\tthe markers after/before the last/first insn not deleted.\n+\n+2002-03-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR optimization/5878\n \t* config/arc/arc.h, config/cris/cris.h, config/i386/i386.h,\n \tconfig/m68k/m68k.h, config/s390/s390.h, config/sparc/sparc.h\n \t(PIC_OFFSET_TABLE_REGNUM): Conditionalize on flag_pic."}, {"sha": "b451eefcc893757c24341ca6282d9b0928ecdac8", "filename": "gcc/function.c", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9f53e9654b86fd142c8c3e66ce843ddb9b1de0b3", "patch": "@@ -7782,86 +7782,90 @@ reposition_prologue_and_epilogue_notes (f)\n      rtx f ATTRIBUTE_UNUSED;\n {\n #if defined (HAVE_prologue) || defined (HAVE_epilogue)\n+  rtx insn, last, note;\n   int len;\n \n   if ((len = VARRAY_SIZE (prologue)) > 0)\n     {\n-      rtx insn, note = 0;\n+      last = 0, note = 0;\n \n       /* Scan from the beginning until we reach the last prologue insn.\n \t We apparently can't depend on basic_block_{head,end} after\n \t reorg has run.  */\n-      for (insn = f; len && insn; insn = NEXT_INSN (insn))\n+      for (insn = f; insn; insn = NEXT_INSN (insn))\n \t{\n \t  if (GET_CODE (insn) == NOTE)\n \t    {\n \t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n \t\tnote = insn;\n \t    }\n-\t  else if ((len -= contains (insn, prologue)) == 0)\n+\t  else if (contains (insn, prologue))\n \t    {\n-\t      rtx next;\n-\t      /* Find the prologue-end note if we haven't already, and\n-\t\t move it to just after the last prologue insn.  */\n-\t      if (note == 0)\n-\t\t{\n-\t\t  for (note = insn; (note = NEXT_INSN (note));)\n-\t\t    if (GET_CODE (note) == NOTE\n-\t\t\t&& NOTE_LINE_NUMBER (note) == NOTE_INSN_PROLOGUE_END)\n-\t\t      break;\n-\t\t}\n+\t      last = insn;\n+\t      if (--len == 0)\n+\t\tbreak;\n+\t    }\n+\t}\n+\t\t\n+      if (last)\n+\t{\n+\t  rtx next;\n \n-\t      next = NEXT_INSN (note);\n+\t  /* Find the prologue-end note if we haven't already, and\n+\t     move it to just after the last prologue insn.  */\n+\t  if (note == 0)\n+\t    {\n+\t      for (note = last; (note = NEXT_INSN (note));)\n+\t\tif (GET_CODE (note) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (note) == NOTE_INSN_PROLOGUE_END)\n+\t\t  break;\n+\t    }\n \n-\t      /* Whether or not we can depend on BLOCK_HEAD,\n-\t\t attempt to keep it up-to-date.  */\n-\t      if (BLOCK_HEAD (0) == note)\n-\t\tBLOCK_HEAD (0) = next;\n+\t  next = NEXT_INSN (note);\n \n-\t      remove_insn (note);\n-\t      /* Avoid placing note between CODE_LABEL and BASIC_BLOCK note.  */\n-\t      if (GET_CODE (insn) == CODE_LABEL)\n-\t\tinsn = NEXT_INSN (insn);\n-\t      add_insn_after (note, insn);\n-\t    }\n+\t  /* Avoid placing note between CODE_LABEL and BASIC_BLOCK note.  */\n+\t  if (GET_CODE (last) == CODE_LABEL)\n+\t    last = NEXT_INSN (last);\n+\t  reorder_insns (note, note, last);\n \t}\n     }\n \n   if ((len = VARRAY_SIZE (epilogue)) > 0)\n     {\n-      rtx insn, note = 0;\n+      last = 0, note = 0;\n \n       /* Scan from the end until we reach the first epilogue insn.\n \t We apparently can't depend on basic_block_{head,end} after\n \t reorg has run.  */\n-      for (insn = get_last_insn (); len && insn; insn = PREV_INSN (insn))\n+      for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n \t{\n \t  if (GET_CODE (insn) == NOTE)\n \t    {\n \t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n \t\tnote = insn;\n \t    }\n-\t  else if ((len -= contains (insn, epilogue)) == 0)\n+\t  else if (contains (insn, epilogue))\n \t    {\n-\t      /* Find the epilogue-begin note if we haven't already, and\n-\t\t move it to just before the first epilogue insn.  */\n-\t      if (note == 0)\n-\t\t{\n-\t\t  for (note = insn; (note = PREV_INSN (note));)\n-\t\t    if (GET_CODE (note) == NOTE\n-\t\t\t&& NOTE_LINE_NUMBER (note) == NOTE_INSN_EPILOGUE_BEG)\n-\t\t      break;\n-\t\t}\n-\n-\t      /* Whether or not we can depend on BLOCK_HEAD,\n-\t\t attempt to keep it up-to-date.  */\n-\t      if (n_basic_blocks\n-\t\t  && BLOCK_HEAD (n_basic_blocks-1) == insn)\n-\t\tBLOCK_HEAD (n_basic_blocks-1) = note;\n+\t      last = insn;\n+\t      if (--len == 0)\n+\t\tbreak;\n+\t    }\n+\t}\n \n-\t      remove_insn (note);\n-\t      add_insn_before (note, insn);\n+      if (last)\n+\t{\n+\t  /* Find the epilogue-begin note if we haven't already, and\n+\t     move it to just before the first epilogue insn.  */\n+\t  if (note == 0)\n+\t    {\n+\t      for (note = insn; (note = PREV_INSN (note));)\n+\t\tif (GET_CODE (note) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (note) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t  break;\n \t    }\n+\n+\t  if (PREV_INSN (last) != note)\n+\t    reorder_insns (note, note, PREV_INSN (last));\n \t}\n     }\n #endif /* HAVE_prologue or HAVE_epilogue */"}]}