{"sha": "98daafa0b3decfb3efa2f2427f7b6e13de660541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThkYWFmYTBiM2RlY2ZiM2VmYTJmMjQyN2Y3YjZlMTNkZTY2MDU0MQ==", "commit": {"author": {"name": "Evandro Menezes", "email": "evandro@gcc.gnu.org", "date": "2016-06-13T19:02:56Z"}, "committer": {"name": "Evandro Menezes", "email": "evandro@gcc.gnu.org", "date": "2016-06-13T19:02:56Z"}, "message": "[AArch64] Emit square root using the Newton series\n\n2016-06-13  Evandro Menezes  <e.menezes@samsung.com>\n            Wilco Dijkstra  <wilco.dijkstra@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_emit_approx_rsqrt): Replace with new function\n\t\"aarch64_emit_approx_sqrt\".\n\t(cpu_approx_modes): New member \"sqrt\".\n\t* config/aarch64/aarch64.c\n\t(generic_approx_modes): New member \"sqrt\".\n\t(exynosm1_approx_modes): Likewise.\n\t(xgene1_approx_modes): Likewise.\n\t(aarch64_emit_approx_rsqrt): Replace with new function\n\t\"aarch64_emit_approx_sqrt\".\n\t(aarch64_override_options_after_change_1): Handle new option.\n\t* config/aarch64/aarch64-simd.md\n\t(rsqrt<mode>2): Use new function instead.\n\t(sqrt<mode>2): New expansion and insn definitions.\n\t* config/aarch64/aarch64.md: Likewise.\n\t* config/aarch64/aarch64.opt\n\t(mlow-precision-sqrt): Add new option description.\n\t* doc/invoke.texi (mlow-precision-sqrt): Likewise.\n\nFrom-SVN: r237396", "tree": {"sha": "ff0040ae43db233ff1f4aed503351f1a05556755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff0040ae43db233ff1f4aed503351f1a05556755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98daafa0b3decfb3efa2f2427f7b6e13de660541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98daafa0b3decfb3efa2f2427f7b6e13de660541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98daafa0b3decfb3efa2f2427f7b6e13de660541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98daafa0b3decfb3efa2f2427f7b6e13de660541/comments", "author": null, "committer": null, "parents": [{"sha": "9acc9cbeb8570573b8d73053453d65becc2d386a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9acc9cbeb8570573b8d73053453d65becc2d386a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9acc9cbeb8570573b8d73053453d65becc2d386a"}], "stats": {"total": 163, "additions": 124, "deletions": 39}, "files": [{"sha": "eb33118d0317360e131877ee3e151702ee74a3d0", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=98daafa0b3decfb3efa2f2427f7b6e13de660541", "patch": "@@ -192,7 +192,8 @@ struct cpu_branch_cost\n /* Allowed modes for approximations.  */\n struct cpu_approx_modes\n {\n-  const unsigned int recip_sqrt; /* Reciprocal square root.  */\n+  const unsigned int sqrt;\t\t/* Square root.  */\n+  const unsigned int recip_sqrt;\t/* Reciprocal square root.  */\n };\n \n struct tune_params\n@@ -302,6 +303,7 @@ int aarch64_branch_cost (bool, bool);\n enum aarch64_symbol_type aarch64_classify_symbolic_expression (rtx);\n bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);\n bool aarch64_constant_address_p (rtx);\n+bool aarch64_emit_approx_sqrt (rtx, rtx, bool);\n bool aarch64_expand_movmem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);\n@@ -383,7 +385,6 @@ void aarch64_register_pragmas (void);\n void aarch64_relayout_simd_types (void);\n void aarch64_reset_previous_fndecl (void);\n void aarch64_save_restore_target_globals (tree);\n-void aarch64_emit_approx_rsqrt (rtx, rtx);\n \n /* Initialize builtins for SIMD intrinsics.  */\n void init_aarch64_simd_builtins (void);"}, {"sha": "f99d92e0b881bc3535acbe6a8aefcdf2ac6299e7", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=98daafa0b3decfb3efa2f2427f7b6e13de660541", "patch": "@@ -405,7 +405,7 @@\n \t\t     UNSPEC_RSQRT))]\n   \"TARGET_SIMD\"\n {\n-  aarch64_emit_approx_rsqrt (operands[0], operands[1]);\n+  aarch64_emit_approx_sqrt (operands[0], operands[1], true);\n   DONE;\n })\n \n@@ -4298,7 +4298,16 @@\n \n ;; sqrt\n \n-(define_insn \"sqrt<mode>2\"\n+(define_expand \"sqrt<mode>2\"\n+  [(set (match_operand:VDQF 0 \"register_operand\")\n+\t(sqrt:VDQF (match_operand:VDQF 1 \"register_operand\")))]\n+  \"TARGET_SIMD\"\n+{\n+  if (aarch64_emit_approx_sqrt (operands[0], operands[1], false))\n+    DONE;\n+})\n+\n+(define_insn \"*sqrt<mode>2\"\n   [(set (match_operand:VDQF 0 \"register_operand\" \"=w\")\n         (sqrt:VDQF (match_operand:VDQF 1 \"register_operand\" \"w\")))]\n   \"TARGET_SIMD\""}, {"sha": "865798824611dbe8a8a24e2ddc1c187cc5535554", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 78, "deletions": 32, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=98daafa0b3decfb3efa2f2427f7b6e13de660541", "patch": "@@ -396,18 +396,21 @@ static const struct cpu_branch_cost cortexa57_branch_cost =\n /* Generic approximation modes.  */\n static const cpu_approx_modes generic_approx_modes =\n {\n+  AARCH64_APPROX_NONE,\t/* sqrt  */\n   AARCH64_APPROX_NONE\t/* recip_sqrt  */\n };\n \n /* Approximation modes for Exynos M1.  */\n static const cpu_approx_modes exynosm1_approx_modes =\n {\n+  AARCH64_APPROX_ALL,\t/* sqrt  */\n   AARCH64_APPROX_ALL\t/* recip_sqrt  */\n };\n \n /* Approximation modes for X-Gene 1.  */\n static const cpu_approx_modes xgene1_approx_modes =\n {\n+  AARCH64_APPROX_NONE,\t/* sqrt  */\n   AARCH64_APPROX_ALL\t/* recip_sqrt  */\n };\n \n@@ -7370,10 +7373,10 @@ aarch64_builtin_reciprocal (tree fndecl)\n \n typedef rtx (*rsqrte_type) (rtx, rtx);\n \n-/* Select reciprocal square root initial estimate\n-   insn depending on machine mode.  */\n+/* Select reciprocal square root initial estimate insn depending on machine\n+   mode.  */\n \n-rsqrte_type\n+static rsqrte_type\n get_rsqrte_type (machine_mode mode)\n {\n   switch (mode)\n@@ -7389,10 +7392,9 @@ get_rsqrte_type (machine_mode mode)\n \n typedef rtx (*rsqrts_type) (rtx, rtx, rtx);\n \n-/* Select reciprocal square root Newton-Raphson step\n-   insn depending on machine mode.  */\n+/* Select reciprocal square root series step insn depending on machine mode.  */\n \n-rsqrts_type\n+static rsqrts_type\n get_rsqrts_type (machine_mode mode)\n {\n   switch (mode)\n@@ -7406,46 +7408,84 @@ get_rsqrts_type (machine_mode mode)\n   }\n }\n \n-/* Emit instruction sequence to compute the reciprocal square root using the\n-   Newton-Raphson series.  Iterate over the series twice for SF\n-   and thrice for DF.  */\n+/* Emit instruction sequence to compute either the approximate square root\n+   or its approximate reciprocal, depending on the flag RECP, and return\n+   whether the sequence was emitted or not.  */\n \n-void\n-aarch64_emit_approx_rsqrt (rtx dst, rtx src)\n+bool\n+aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n {\n-  machine_mode mode = GET_MODE (src);\n-  gcc_assert (\n-    mode == SFmode || mode == V2SFmode || mode == V4SFmode\n-\t|| mode == DFmode || mode == V2DFmode);\n-\n-  rtx xsrc = gen_reg_rtx (mode);\n-  emit_move_insn (xsrc, src);\n-  rtx x0 = gen_reg_rtx (mode);\n+  machine_mode mode = GET_MODE (dst);\n+  machine_mode mmsk = mode_for_vector\n+\t\t        (int_mode_for_mode (GET_MODE_INNER (mode)),\n+\t\t\t GET_MODE_NUNITS (mode));\n+  bool use_approx_sqrt_p = (!recp\n+\t\t\t    && (flag_mlow_precision_sqrt\n+\t\t\t        || (aarch64_tune_params.approx_modes->sqrt\n+\t\t\t\t    & AARCH64_APPROX_MODE (mode))));\n+  bool use_approx_rsqrt_p = (recp\n+\t\t\t     && (flag_mrecip_low_precision_sqrt\n+\t\t\t\t || (aarch64_tune_params.approx_modes->recip_sqrt\n+\t\t\t\t     & AARCH64_APPROX_MODE (mode))));\n+\n+  if (!flag_finite_math_only\n+      || flag_trapping_math\n+      || !flag_unsafe_math_optimizations\n+      || !(use_approx_sqrt_p || use_approx_rsqrt_p)\n+      || optimize_function_for_size_p (cfun))\n+    return false;\n \n-  emit_insn ((*get_rsqrte_type (mode)) (x0, xsrc));\n+  rtx xmsk = gen_reg_rtx (mmsk);\n+  if (!recp)\n+    /* When calculating the approximate square root, compare the argument with\n+       0.0 and create a mask.  */\n+    emit_insn (gen_rtx_SET (xmsk, gen_rtx_NEG (mmsk, gen_rtx_EQ (mmsk, src,\n+\t\t\t\t\t\t\t  CONST0_RTX (mode)))));\n \n-  bool double_mode = (mode == DFmode || mode == V2DFmode);\n+  /* Estimate the approximate reciprocal square root.  */\n+  rtx xdst = gen_reg_rtx (mode);\n+  emit_insn ((*get_rsqrte_type (mode)) (xdst, src));\n \n-  int iterations = double_mode ? 3 : 2;\n+  /* Iterate over the series twice for SF and thrice for DF.  */\n+  int iterations = (GET_MODE_INNER (mode) == DFmode) ? 3 : 2;\n \n-  /* Optionally iterate over the series one less time than otherwise.  */\n-  if (flag_mrecip_low_precision_sqrt)\n+  /* Optionally iterate over the series once less for faster performance\n+     while sacrificing the accuracy.  */\n+  if ((recp && flag_mrecip_low_precision_sqrt)\n+      || (!recp && flag_mlow_precision_sqrt))\n     iterations--;\n \n-  for (int i = 0; i < iterations; ++i)\n+  /* Iterate over the series to calculate the approximate reciprocal square\n+     root.  */\n+  rtx x1 = gen_reg_rtx (mode);\n+  while (iterations--)\n     {\n-      rtx x1 = gen_reg_rtx (mode);\n       rtx x2 = gen_reg_rtx (mode);\n-      rtx x3 = gen_reg_rtx (mode);\n-      emit_set_insn (x2, gen_rtx_MULT (mode, x0, x0));\n+      emit_set_insn (x2, gen_rtx_MULT (mode, xdst, xdst));\n+\n+      emit_insn ((*get_rsqrts_type (mode)) (x1, src, x2));\n \n-      emit_insn ((*get_rsqrts_type (mode)) (x3, xsrc, x2));\n+      if (iterations > 0)\n+\temit_set_insn (xdst, gen_rtx_MULT (mode, xdst, x1));\n+    }\n+\n+  if (!recp)\n+    {\n+      /* Qualify the approximate reciprocal square root when the argument is\n+\t 0.0 by squashing the intermediary result to 0.0.  */\n+      rtx xtmp = gen_reg_rtx (mmsk);\n+      emit_set_insn (xtmp, gen_rtx_AND (mmsk, gen_rtx_NOT (mmsk, xmsk),\n+\t\t\t\t\t      gen_rtx_SUBREG (mmsk, xdst, 0)));\n+      emit_move_insn (xdst, gen_rtx_SUBREG (mode, xtmp, 0));\n \n-      emit_set_insn (x1, gen_rtx_MULT (mode, x0, x3));\n-      x0 = x1;\n+      /* Calculate the approximate square root.  */\n+      emit_set_insn (xdst, gen_rtx_MULT (mode, xdst, src));\n     }\n \n-  emit_move_insn (dst, x0);\n+  /* Finalize the approximation.  */\n+  emit_set_insn (dst, gen_rtx_MULT (mode, xdst, x1));\n+\n+  return true;\n }\n \n /* Return the number of instructions that can be issued per cycle.  */\n@@ -7975,6 +8015,12 @@ aarch64_override_options_after_change_1 (struct gcc_options *opts)\n       && (aarch64_cmodel == AARCH64_CMODEL_TINY\n \t  || aarch64_cmodel == AARCH64_CMODEL_TINY_PIC))\n     aarch64_nopcrelative_literal_loads = false;\n+\n+  /* When enabling the lower precision Newton series for the square root, also\n+     enable it for the reciprocal square root, since the latter is an\n+     intermediary step for the former.  */\n+  if (flag_mlow_precision_sqrt)\n+    flag_mrecip_low_precision_sqrt = true;\n }\n \n /* 'Unpack' up the internal tuning structs and update the options"}, {"sha": "b031eb24c8681e8aa3001a741eac4244d6c92b95", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=98daafa0b3decfb3efa2f2427f7b6e13de660541", "patch": "@@ -4733,7 +4733,16 @@\n   [(set_attr \"type\" \"ffarith<s>\")]\n )\n \n-(define_insn \"sqrt<mode>2\"\n+(define_expand \"sqrt<mode>2\"\n+  [(set (match_operand:GPF 0 \"register_operand\")\n+        (sqrt:GPF (match_operand:GPF 1 \"register_operand\")))]\n+  \"TARGET_FLOAT\"\n+{\n+  if (aarch64_emit_approx_sqrt (operands[0], operands[1], false))\n+    DONE;\n+})\n+\n+(define_insn \"*sqrt<mode>2\"\n   [(set (match_operand:GPF 0 \"register_operand\" \"=w\")\n         (sqrt:GPF (match_operand:GPF 1 \"register_operand\" \"w\")))]\n   \"TARGET_FLOAT\""}, {"sha": "3c4e7ae386c908ea55e6c19bde8f5dbdb53e1514", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=98daafa0b3decfb3efa2f2427f7b6e13de660541", "patch": "@@ -151,5 +151,13 @@ PC relative literal loads.\n \n mlow-precision-recip-sqrt\n Common Var(flag_mrecip_low_precision_sqrt) Optimization\n-When calculating the reciprocal square root approximation,\n-uses one less step than otherwise, thus reducing latency and precision.\n+Enable the reciprocal square root approximation.  Enabling this reduces\n+precision of reciprocal square root results to about 16 bits for\n+single precision and to 32 bits for double precision.\n+\n+mlow-precision-sqrt\n+Common Var(flag_mlow_precision_sqrt) Optimization\n+Enable the square root approximation.  Enabling this reduces\n+precision of square root results to about 16 bits for\n+single precision and to 32 bits for double precision.\n+If enabled, it implies -mlow-precision-recip-sqrt."}, {"sha": "53aa6b85ce67e552a34a870ed68aea27bce23b96", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98daafa0b3decfb3efa2f2427f7b6e13de660541/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=98daafa0b3decfb3efa2f2427f7b6e13de660541", "patch": "@@ -576,6 +576,7 @@ Objective-C and Objective-C++ Dialects}.\n -mfix-cortex-a53-835769  -mno-fix-cortex-a53-835769 @gol\n -mfix-cortex-a53-843419  -mno-fix-cortex-a53-843419 @gol\n -mlow-precision-recip-sqrt -mno-low-precision-recip-sqrt@gol\n+-mlow-precision-sqrt -mno-low-precision-sqrt@gol\n -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}}\n \n @emph{Adapteva Epiphany Options}\n@@ -13028,6 +13029,17 @@ This option only has an effect if @option{-ffast-math} or\n precision of reciprocal square root results to about 16 bits for\n single precision and to 32 bits for double precision.\n \n+@item -mlow-precision-sqrt\n+@item -mno-low-precision-sqrt\n+@opindex -mlow-precision-sqrt\n+@opindex -mno-low-precision-sqrt\n+Enable or disable the square root approximation.\n+This option only has an effect if @option{-ffast-math} or\n+@option{-funsafe-math-optimizations} is used as well.  Enabling this reduces\n+precision of square root results to about 16 bits for\n+single precision and to 32 bits for double precision.\n+If enabled, it implies @option{-mlow-precision-recip-sqrt}.\n+\n @item -march=@var{name}\n @opindex march\n Specify the name of the target architecture and, optionally, one or"}]}