{"sha": "7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZhYTFiYmI1ZDAyMDZjYzgzZjIwYzExNDVmNjEyZjc3NTRmZGNmMw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-07-18T17:30:38Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-07-18T17:30:38Z"}, "message": "re PR target/30652 (SSE expansion is missing for isinf() and other fpclassify functions)\n\n\tPR target/30652\n\tPR middle-end/20558\n\n\t* builtins.c (expand_builtin_interclass_mathfn): Provide a\n\tgeneric fallback for isinf.\n\t* c-cppbuiltin.c (builtin_define_float_constants): Move FP max\n\tcalculation code ...\n\t* real.c (get_max_float): ... to here.\n\t* real.h (get_max_float): New.\n\ntestsuite:\n\t* gcc.dg/pr28796-1.c: Add more cases.\n\t* gcc.dg/pr28796-2.c: Likewise.\n\nFrom-SVN: r126724", "tree": {"sha": "eb2db58c64bbaba8f0181d8d24ef99a386911de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb2db58c64bbaba8f0181d8d24ef99a386911de5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/comments", "author": null, "committer": null, "parents": [{"sha": "b5d32c25372d1e0604bbd8471d735e46215dbe03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d32c25372d1e0604bbd8471d735e46215dbe03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5d32c25372d1e0604bbd8471d735e46215dbe03"}], "stats": {"total": 207, "additions": 176, "deletions": 31}, "files": [{"sha": "87ae99a53e500a9f188111166de884d3578e4c00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -1,3 +1,15 @@\n+2007-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR target/30652\n+\tPR middle-end/20558\n+\n+\t* builtins.c (expand_builtin_interclass_mathfn): Provide a\n+\tgeneric fallback for isinf.\n+\t* c-cppbuiltin.c (builtin_define_float_constants): Move FP max\n+\tcalculation code ...\n+\t* real.c (get_max_float): ... to here.\n+\t* real.h (get_max_float): New.\n+\n 2007-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tPR middle-end/32668"}, {"sha": "e92e56fbff73c5e2776f921e87a4237fb29b7f56", "filename": "gcc/builtins.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -2275,6 +2275,30 @@ expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n       return target;\n     }\n \n+  /* If there is no optab, try generic code.  */\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+      tree result;\n+\n+    CASE_FLT_FN (BUILT_IN_ISINF):\n+      {\n+\t/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */\n+\ttree const isgr_fn = built_in_decls[BUILT_IN_ISGREATER];\n+\ttree const type = TREE_TYPE (arg);\n+\tREAL_VALUE_TYPE r;\n+\tchar buf[128];\n+\n+\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n+\treal_from_string (&r, buf);\n+\tresult = build_call_expr (isgr_fn, 2,\n+\t\t\t\t  fold_build1 (ABS_EXPR, type, arg),\n+\t\t\t\t  build_real (type, r));\n+\treturn expand_expr (result, target, VOIDmode, EXPAND_NORMAL);\n+      }\n+    default:\n+      break;\n+    }\n+\n   target = expand_call (exp, target, target == const0_rtx);\n \n   return target;"}, {"sha": "653c5e484426c92c75d281eb5264260fcc43ee4e", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -200,31 +200,8 @@ builtin_define_float_constants (const char *name_prefix,\n   /* Since, for the supported formats, B is always a power of 2, we\n      construct the following numbers directly as a hexadecimal\n      constants.  */\n-\n-  /* The maximum representable finite floating-point number,\n-     (1 - b**-p) * b**emax  */\n-  {\n-    int i, n;\n-    char *p;\n-\n-    strcpy (buf, \"0x0.\");\n-    n = fmt->p;\n-    for (i = 0, p = buf + 4; i + 3 < n; i += 4)\n-      *p++ = 'f';\n-    if (i < n)\n-      *p++ = \"08ce\"[n - i];\n-    sprintf (p, \"p%d\", fmt->emax);\n-    if (fmt->pnan < fmt->p)\n-      {\n-\t/* This is an IBM extended double format made up of two IEEE\n-\t   doubles.  The value of the long double is the sum of the\n-\t   values of the two parts.  The most significant part is\n-\t   required to be the value of the long double rounded to the\n-\t   nearest double.  Rounding means we need a slightly smaller\n-\t   value for LDBL_MAX.  */\n-\tbuf[4 + fmt->pnan / 4] = \"7bde\"[fmt->pnan % 4];\n-      }\n-  }\n+  get_max_float (fmt, buf, sizeof (buf));\n+  \n   sprintf (name, \"__%s_MAX__\", name_prefix);\n   builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix, fp_cast);\n "}, {"sha": "258ecf6635bb2831cd959fa9812668040b5401a7", "filename": "gcc/real.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -4835,3 +4835,35 @@ real_isinteger (const REAL_VALUE_TYPE *c, enum machine_mode mode)\n   real_trunc (&cint, mode, c);\n   return real_identical (c, &cint);\n }\n+\n+/* Write into BUF the maximum representable finite floating-point\n+   number, (1 - b**-p) * b**emax for a given FP format FMT as a hex\n+   float string.  LEN is the size of BUF, and the buffer must be large\n+   enough to contain the resulting string.  */\n+\n+void\n+get_max_float (const struct real_format *fmt, char *buf, size_t len)\n+{\n+  int i, n;\n+  char *p;\n+\n+  strcpy (buf, \"0x0.\");\n+  n = fmt->p;\n+  for (i = 0, p = buf + 4; i + 3 < n; i += 4)\n+    *p++ = 'f';\n+  if (i < n)\n+    *p++ = \"08ce\"[n - i];\n+  sprintf (p, \"p%d\", fmt->emax);\n+  if (fmt->pnan < fmt->p)\n+    {\n+      /* This is an IBM extended double format made up of two IEEE\n+\t doubles.  The value of the long double is the sum of the\n+\t values of the two parts.  The most significant part is\n+\t required to be the value of the long double rounded to the\n+\t nearest double.  Rounding means we need a slightly smaller\n+\t value for LDBL_MAX.  */\n+      buf[4 + fmt->pnan / 4] = \"7bde\"[fmt->pnan % 4];\n+    }\n+\n+  gcc_assert (strlen (buf) < len);\n+}"}, {"sha": "68ad362849da5fec58f8ae8e0f74899df1d3b0b8", "filename": "gcc/real.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -438,4 +438,8 @@ extern void mpfr_from_real (mpfr_ptr, const REAL_VALUE_TYPE *, mp_rnd_t);\n /* Check whether the real constant value given is an integer.  */\n extern bool real_isinteger (const REAL_VALUE_TYPE *c, enum machine_mode mode);\n \n+/* Write into BUF the maximum representable finite floating-point\n+   number, (1 - b**-p) * b**emax for a given FP format FMT as a hex\n+   float string.  BUF must be large enough to contain the result.  */\n+extern void get_max_float (const struct real_format *, char *, size_t);\n #endif /* ! GCC_REAL_H */"}, {"sha": "1c48519a21216b392e96b4c263686cdceecc1429", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -1,3 +1,8 @@\n+2007-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/pr28796-1.c: Add more cases.\n+\t* gcc.dg/pr28796-2.c: Likewise.\n+\n 2007-07-17  Janus Weil  <jaydub66@gmail.com>\n \n \tPR fortran/32535"}, {"sha": "d200b1a682c2689e4e13eb14054b8df8fc213b93", "filename": "gcc/testsuite/gcc.dg/pr28796-1.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-1.c?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -1,17 +1,48 @@\n /* { dg-do link } */\n /* { dg-options \"-ffinite-math-only\" } */\n \n+extern void link_error(void);\n+\n float f;\n+double d;\n+long double ld;\n \n int main()\n {\n   if (__builtin_isunordered (f, f) != 0)\n     link_error ();\n+  if (__builtin_isunordered (d, d) != 0)\n+    link_error ();\n+  if (__builtin_isunordered (ld, ld) != 0)\n+    link_error ();\n+\n   if (__builtin_isnan (f) != 0)\n     link_error ();\n+  if (__builtin_isnan (d) != 0)\n+    link_error ();\n+  if (__builtin_isnan (ld) != 0)\n+    link_error ();\n+  if (__builtin_isnanf (f) != 0)\n+    link_error ();\n+  if (__builtin_isnanl (ld) != 0)\n+    link_error ();\n+\n   if (__builtin_finite (f) != 1)\n     link_error ();\n+  if (__builtin_finite (d) != 1)\n+    link_error ();\n+  if (__builtin_finite (ld) != 1)\n+    link_error ();\n+  if (__builtin_finitef (f) != 1)\n+    link_error ();\n+  if (__builtin_finitel (ld) != 1)\n+    link_error ();\n+\n   if (f != f)\n     link_error ();\n+  if (d != d)\n+    link_error ();\n+  if (ld != ld)\n+    link_error ();\n   return 0;\n }"}, {"sha": "254548496465cea8f05fd2704e449d8b1838c9cb", "filename": "gcc/testsuite/gcc.dg/pr28796-2.c", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7faa1bbb5d0206cc83f20c1145f612f7754fdcf3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c?ref=7faa1bbb5d0206cc83f20c1145f612f7754fdcf3", "patch": "@@ -4,19 +4,79 @@\n \n extern void abort (void);\n \n-void foo(float f)\n+void __attribute__ ((__noinline__))\n+foo_1 (float f, double d, long double ld,\n+       int res_unord, int res_isnan, int res_isinf, int res_isfin)\n {\n-  if (__builtin_isunordered (f, f) != 1)\n+  if (__builtin_isunordered (f, 0) != res_unord)\n     abort ();\n-  if (__builtin_isnan (f) != 1)\n+  if (__builtin_isunordered (0, f) != res_unord)\n     abort ();\n-  if (__builtin_finite (f) != 0)\n+  if (__builtin_isunordered (d, 0) != res_unord)\n+    abort ();\n+  if (__builtin_isunordered (0, d) != res_unord)\n+    abort ();\n+  if (__builtin_isunordered (ld, 0) != res_unord)\n+    abort ();\n+  if (__builtin_isunordered (0, ld) != res_unord)\n+    abort ();\n+\n+  if (__builtin_isnan (f) != res_isnan)\n+    abort ();\n+  if (__builtin_isnan (d) != res_isnan)\n+    abort ();\n+  if (__builtin_isnan (ld) != res_isnan)\n+    abort ();\n+  if (__builtin_isnanf (f) != res_isnan)\n+    abort ();\n+  if (__builtin_isnanl (ld) != res_isnan)\n+    abort ();\n+\n+  if (__builtin_isinf (f) != res_isinf)\n+    abort ();\n+  if (__builtin_isinf (d) != res_isinf)\n+    abort ();\n+  if (__builtin_isinf (ld) != res_isinf)\n+    abort ();\n+  if (__builtin_isinff (f) != res_isinf)\n+    abort ();\n+  if (__builtin_isinfl (ld) != res_isinf)\n+    abort ();\n+\n+  if (__builtin_finite (f) != res_isfin)\n+    abort ();\n+  if (__builtin_finite (d) != res_isfin)\n     abort ();\n }\n \n+void __attribute__ ((__noinline__))\n+foo (float f, double d, long double ld,\n+     int res_unord, int res_isnan, int res_isinf, int res_isfin)\n+{\n+  foo_1 (f, d, ld, res_unord, res_isnan, res_isinf, res_isfin);\n+  foo_1 (-f, -d, -ld, res_unord, res_isnan, res_isinf, res_isfin);\n+}\n+\n int main()\n {\n-  float f = __builtin_nanf(\"\");\n-  foo(f);\n+  float f;\n+  double d;\n+  long double ld;\n+  \n+  f = __builtin_nanf(\"\"); d = __builtin_nan(\"\"); ld = __builtin_nanl(\"\");\n+  foo(f, d, ld, /*unord=*/ 1, /*isnan=*/ 1, /*isinf=*/ 0, /*isfin=*/ 0);\n+\n+  f = __builtin_inff(); d = __builtin_inf(); ld = __builtin_infl();\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0);\n+\n+  f = 0; d = 0; ld = 0;\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1);\n+\n+  f = __FLT_MIN__; d = __DBL_MIN__; ld = __LDBL_MIN__;\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1);\n+\n+  f = __FLT_MAX__; d = __DBL_MAX__; ld = __LDBL_MAX__;\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1);\n+\n   return 0;\n }"}]}