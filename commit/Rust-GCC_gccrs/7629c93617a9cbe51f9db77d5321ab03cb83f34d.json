{"sha": "7629c93617a9cbe51f9db77d5321ab03cb83f34d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYyOWM5MzYxN2E5Y2JlNTFmOWRiNzdkNTMyMWFiMDNjYjgzZjM0ZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-29T03:20:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-29T03:20:43Z"}, "message": "(last_block_end_note):  New variable.\n\n(remember_end_note):  New function.\n(expand_end_bindings): Save NOTE_INSN_BLOCK_END in last_block_end_note.\n\n(struct goto_fixup): New field context.\n(fixup_cleanups): Function deleted.\n(fixup_gotos): Put the fixup in a block, and put that block\ninto its proper place.  Use sequences, not reorder_insns.\n\nFrom-SVN: r1990", "tree": {"sha": "f57a1d8ad96cfe85b6fed1dc0d93a1ffa7e4f21d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f57a1d8ad96cfe85b6fed1dc0d93a1ffa7e4f21d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7629c93617a9cbe51f9db77d5321ab03cb83f34d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7629c93617a9cbe51f9db77d5321ab03cb83f34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7629c93617a9cbe51f9db77d5321ab03cb83f34d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7629c93617a9cbe51f9db77d5321ab03cb83f34d/comments", "author": null, "committer": null, "parents": [{"sha": "6a286015a1a81e5de6f47ecf5f711aefa08984d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a286015a1a81e5de6f47ecf5f711aefa08984d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a286015a1a81e5de6f47ecf5f711aefa08984d1"}], "stats": {"total": 93, "additions": 62, "deletions": 31}, "files": [{"sha": "87b4a6aa2c3276f58e0ef249262552f67319c3b8", "filename": "gcc/stmt.c", "status": "modified", "additions": 62, "deletions": 31, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7629c93617a9cbe51f9db77d5321ab03cb83f34d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7629c93617a9cbe51f9db77d5321ab03cb83f34d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=7629c93617a9cbe51f9db77d5321ab03cb83f34d", "patch": "@@ -70,6 +70,13 @@ int expr_stmts_for_value;\n static tree last_expr_type;\n static rtx last_expr_value;\n \n+/* Each time we expand the end of a binding contour (in `expand_end_bindings')\n+   and we emit a new NOTE_INSN_BLOCK_END note, we save a pointer to it here.\n+   This is used by the `remember_end_note' function to record the endpoint\n+   of each generated block in its associated BLOCK node.  */\n+\n+static rtx last_block_end_note;\n+\n /* Number of binding contours started so far in this function.  */\n \n int block_start_count;\n@@ -178,7 +185,6 @@ static int expand_fixup ();\n void fixup_gotos ();\n void free_temp_slots ();\n static void expand_cleanups ();\n-static void fixup_cleanups ();\n static void expand_null_return_1 ();\n static int tail_recursion_args ();\n static void do_jump_if_equal ();\n@@ -384,6 +390,8 @@ struct goto_fixup\n   /* The LABEL_DECL that this jump is jumping to, or 0\n      for break, continue or return.  */\n   tree target;\n+  /* The BLOCK for the place where this goto was found.  */\n+  tree context;\n   /* The CODE_LABEL rtx that this is jumping to.  */\n   rtx target_rtl;\n   /* Number of binding contours started in current function\n@@ -815,6 +823,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n       fixup->before_jump = last_insn ? last_insn : get_last_insn ();\n       fixup->target = tree_label;\n       fixup->target_rtl = rtl_label;\n+      fixup->context = current_block ();\n       fixup->block_start_count = block_start_count;\n       fixup->stack_level = 0;\n       fixup->cleanup_list_list\n@@ -875,6 +884,9 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t If so, we can finalize it.  */\n       else if (PREV_INSN (f->target_rtl) != 0)\n \t{\n+\t  register rtx cleanup_insns;\n+\t  tree newblock;\n+\n \t  /* Get the first non-label after the label\n \t     this goto jumps to.  If that's before this scope begins,\n \t     we don't have a jump into the scope.  */\n@@ -903,7 +915,15 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t      DECL_REGISTER (f->target) = 1;\n \t    }\n \n-\t  /* Execute cleanups for blocks this jump exits.  */\n+\t  /* We will expand the cleanups into a sequence of their own and\n+\t     then later on we will attach this new sequence to the insn\n+\t     stream just ahead of the actual jump insn.  */\n+\n+\t  start_sequence ();\n+\n+\t  pushlevel (0);\n+\n+\t  /* Expand the cleanups for blocks this jump exits.  */\n \t  if (f->cleanup_list_list)\n \t    {\n \t      tree lists;\n@@ -912,13 +932,39 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t\t   Do their cleanups.  */\n \t\tif (TREE_ADDRESSABLE (lists)\n \t\t    && TREE_VALUE (lists) != 0)\n-\t\t  fixup_cleanups (TREE_VALUE (lists), &f->before_jump);\n+\t\t  {\n+\t\t    expand_cleanups (TREE_VALUE (lists), 0);\n+\t\t    /* Pop any pushes done in the cleanups,\n+\t\t       in case function is about to return.  */\n+\t\t    do_pending_stack_adjust ();\n+\t\t  }\n \t    }\n \n \t  /* Restore stack level for the biggest contour that this\n \t     jump jumps out of.  */\n \t  if (f->stack_level)\n \t    emit_stack_restore (SAVE_BLOCK, f->stack_level, f->before_jump);\n+\n+\t  /* Finish up the sequence containing the insns which implement the\n+\t     necessary cleanups, and then attach that whole sequence to the\n+\t     insn stream just ahead of the actual jump insn.  Attaching it\n+\t     at that point insures that any cleanups which are in fact\n+\t     implicit C++ object destructions (which must be executed upon\n+\t     leaving the block) appear (to the debugger) to be taking place\n+\t     in an area of the generated code where the object(s) being\n+\t     destructed are still \"in scope\".  */\n+\n+\t  cleanup_insns = get_insns ();\n+\t  newblock = poplevel (1, 0, 0);\n+\n+\t  end_sequence ();\n+\t  emit_insns_after (cleanup_insns, f->before_jump);\n+\n+\t  /* Put the new block into its proper context.  */\n+\t  BLOCK_SUBBLOCKS (f->context) \n+\t    = chainon (BLOCK_SUBBLOCKS (f->context), newblock);\n+\t  BLOCK_SUPERCONTEXT (newblock) = f->context;\n+\n \t  f->before_jump = 0;\n \t}\n     }\n@@ -2457,6 +2503,18 @@ expand_start_bindings (exit_flag)\n   push_temp_slots ();\n }\n \n+/* Given a pointer to a BLOCK node, save a pointer to the most recently\n+   generated NOTE_INSN_BLOCK_END in the BLOCK_END_NOTE field of the given\n+   BLOCK node.  */\n+\n+void\n+remember_end_note (block)\n+     register tree block;\n+{\n+  BLOCK_END_NOTE (block) = last_block_end_note;\n+  last_block_end_note = NULL_RTX;\n+}\n+\n /* Generate RTL code to terminate a binding contour.\n    VARS is the chain of VAR_DECL nodes\n    for the variables bound in this contour.\n@@ -2667,7 +2725,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n      just going out of scope, so they are in scope for their cleanups.  */\n \n   if (mark_ends)\n-    emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+    last_block_end_note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n   else\n     /* Get rid of the beginning-mark if we don't make an end-mark.  */\n     NOTE_LINE_NUMBER (thisblock->data.block.first_insn) = NOTE_INSN_DELETED;\n@@ -3031,33 +3089,6 @@ expand_cleanups (list, dont_do)\n       }\n }\n \n-/* Expand a list of cleanups for a goto fixup.\n-   The expansion is put into the insn chain after the insn *BEFORE_JUMP\n-   and *BEFORE_JUMP is set to the insn that now comes before the jump.  */\n-\n-static void\n-fixup_cleanups (list, before_jump)\n-     tree list;\n-     rtx *before_jump;\n-{\n-  rtx beyond_jump = get_last_insn ();\n-  rtx new_before_jump;\n-\n-  expand_cleanups (list, NULL_TREE);\n-  /* Pop any pushes done in the cleanups,\n-     in case function is about to return.  */\n-  do_pending_stack_adjust ();\n-\n-  new_before_jump = get_last_insn ();\n-\n-  if (beyond_jump != new_before_jump)\n-    {\n-      /* If cleanups expand to nothing, don't reorder.  */\n-      reorder_insns (NEXT_INSN (beyond_jump), new_before_jump, *before_jump);\n-      *before_jump = new_before_jump;\n-    }\n-}\n-\n /* Move all cleanups from the current block_stack\n    to the containing block_stack, where they are assumed to\n    have been created.  If anything can cause a temporary to"}]}