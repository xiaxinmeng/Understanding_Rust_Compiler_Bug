{"sha": "2ee887f2725c1f074859ae85735f08bffca23dfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlODg3ZjI3MjVjMWYwNzQ4NTlhZTg1NzM1ZjA4YmZmY2EyM2RmYg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-09T22:43:25Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-09T22:43:25Z"}, "message": "81st Cygnus<->FSF merge\n\nFrom-SVN: r11187", "tree": {"sha": "dbdec03f770326fec3f6cb1f409d09b2e0054728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbdec03f770326fec3f6cb1f409d09b2e0054728"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ee887f2725c1f074859ae85735f08bffca23dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee887f2725c1f074859ae85735f08bffca23dfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee887f2725c1f074859ae85735f08bffca23dfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee887f2725c1f074859ae85735f08bffca23dfb/comments", "author": null, "committer": null, "parents": [{"sha": "258ae59d66b7d11bffebd6917492030f8fbca189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258ae59d66b7d11bffebd6917492030f8fbca189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258ae59d66b7d11bffebd6917492030f8fbca189"}], "stats": {"total": 683, "additions": 368, "deletions": 315}, "files": [{"sha": "72617e03ce69080e14a3286b9245db0aa1838747", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 89, "deletions": 6, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -1,3 +1,92 @@\n+Thu Feb  8 15:15:14 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (grokfndecl): Move code that looks for virtuals in base\n+ \tclasses...\n+\t* class.c (fixup_virtual): ... to a new function.\n+\t(finish_struct_1): Call it.\n+\n+\t* cp-tree.h: Declare warn_sign_compare.\n+\n+\t* typeck.c (build_binary_op_nodefault): Check warn_sign_compare\n+        rather than extra_warnings to decide whether to warn about\n+        comparison of signed and unsigned.\n+\n+\t* decl2.c (lang_decode_option): Handle warn_sign_compare.  -Wall\n+        implies -Wsign-compare.  -Wall doesn't imply -W.\n+\n+Wed Feb  7 15:27:57 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_component_ref): Fix to handle anon unions in base\n+\tclasses as well.\n+\n+Wed Feb  7 14:29:12 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* class.c (resolves_to_fixed_type_p): Delete code dealing with\n+\ta WITH_CLEANUP_EXPR, since we don't generate them any more.\n+\t* cvt.c (build_up_reference): Likewise.\n+\t* decl.c (grok_reference_init): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* tree.c (real_lvalue_p): Likewise.\n+\t(lvalue_p): Likewise.\n+\t(build_cplus_new): Likewise.\n+\t(unsave_expr_now): Likewise.\n+\t* typeck.c (unary_complex_lvalue, build_modify_expr,\n+\tc_expand_return): Likewise.\n+\n+Tue Feb  6 13:39:22 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\tMake the C++ front-end pay attention to attributes for structures.\n+\t* class.c (finish_struct): New argument ATTRIBUTES, passed down into\n+\tfinish_struct_1.\n+ \t(finish_struct_1): New argument ATTRIBUTES; call cplus_decl_attributes.\n+\tTake out old round_up_size use and setting the DECL_ALIGN possibly\n+\tusing it.  Take out setting of TYPE_ALIGN to round_up_size, which\n+\tcan override what the attribute set.\n+\t* cp-tree.h (finish_struct): Update prototype.\n+\t* parse.y (template_instantiate_once): Pass a NULL_TREE for the\n+\tattributes to finish_struct.\n+\t(structsp): For a CLASS decl, add maybe_attribute to rule and pass that\n+\tvalue down into finish_struct.\n+\t* Makefile.in (CONFLICTS): Switch to 7 shift/reduce conflicts.\n+\n+Tue Feb  6 13:12:15 1996  Per Bothner  <bothner@kalessin.cygnus.com>\n+\n+\t* decl.c (poplevel):  Re-word dead for local handling.\n+\t(pushdecl):  Remove useless DECL_DEAD_FOR_LOCAL test.\n+\t(cp_finish_decl):  If is_for_scope, check for duplicates so\n+\twe can disable is_for_scope.  Otherwise, preserve_temp_slots.\n+\n+\t* lex.c (do_identifier):  Use global binding in preference of\n+\tdead for local variable.\n+\n+Mon Feb  5 17:46:46 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (initializing_context): Handle anon union changes, the\n+\tcontext where fields of anon unions can be initialized now has to be\n+\tfound by walking up the TYPE_CONTEXT chain.\n+\n+Fri Feb  2 14:54:04 1996  Doug Evans  <dje@charmed.cygnus.com>\n+\n+\t* decl.c (start_decl): #ifdef out code to set DECL_COMMON\n+\tif ASM_OUTPUT{,_ALIGNED}_BSS is defined.\n+\t(obscure_complex_init): If bss is supported, always set\n+\tDECL_INITIAL to error_mark_node.\n+\n+Thu Feb  1 16:19:56 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (is_friend): Make sure there's a context before we see if\n+\tit's an aggr type.\n+\n+Thu Feb  1 15:44:53 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (is_friend): Classes are not friendly with nested classes.\n+\n+Thu Feb  1 15:27:37 1996  Doug Evans  <dje@charmed.cygnus.com>\n+\n+\t* lex.c (check_newline): Pass last character read to HANDLE_PRAGMA,\n+\tand record its result.\n+\n Thu Feb  1 09:27:01 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (finish_struct_anon): Switch around code to not move anon\n@@ -10187,9 +10276,3 @@ Mon Nov  8 13:50:49 1993  Jason Merrill  (jason@deneb.cygnus.com)\n Tue Sep  7 20:03:33 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* cp-decl.c: Allow references and template type parameters as well\n-\n-Local Variables:\n-eval: (auto-fill-mode)\n-left-margin: 8\n-fill-column: 76\n-End:"}, {"sha": "8bfbb125cc38b7220705b583815c65bb3bb2fe88", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -196,7 +196,7 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n-CONFLICTS = expect 5 shift/reduce conflicts and 38 reduce/reduce conflicts.\n+CONFLICTS = expect 7 shift/reduce conflicts and 38 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)"}, {"sha": "a5c8f386650e88cbbe97b3ac246fe9ca0d15e261", "filename": "gcc/cp/class.c", "status": "modified", "additions": 83, "deletions": 23, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -2753,6 +2753,77 @@ mark_overriders (fndecl, base_fndecls)\n     }\n }\n \n+/* If this declaration supersedes the declaration of\n+   a method declared virtual in the base class, then\n+   mark this field as being virtual as well.  */\n+\n+void\n+fixup_virtual (decl, ctype)\n+     tree decl, ctype;\n+{\n+  tree binfos = BINFO_BASETYPES (TYPE_BINFO (ctype));\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  int virtualp = DECL_VIRTUAL_P (decl);\n+\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo))\n+\t  || flag_all_virtual == 1)\n+\t{\n+\t  tree tmp = get_matching_virtual\n+\t    (base_binfo, decl,\n+\t     DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)));\n+\t  if (tmp)\n+\t    {\n+\t      /* If this function overrides some virtual in some base\n+\t\t class, then the function itself is also necessarily\n+\t\t virtual, even if the user didn't explicitly say so.  */\n+\t      DECL_VIRTUAL_P (decl) = 1;\n+\n+\t      /* The TMP we really want is the one from the deepest\n+\t\t baseclass on this path, taking care not to\n+\t\t duplicate if we have already found it (via another\n+\t\t path to its virtual baseclass.  */\n+\t      if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n+\t\t{\n+\t\t  cp_error_at (\"method `%D' may not be declared static\",\n+\t\t\t       decl);\n+\t\t  cp_error_at (\"(since `%D' declared virtual in base class.)\",\n+\t\t\t       tmp);\n+\t\t  break;\n+\t\t}\n+\t      virtualp = 1;\n+\n+\t      {\n+\t\t/* The argument types may have changed... */\n+\t\ttree type = TREE_TYPE (decl);\n+\t\ttree argtypes = TYPE_ARG_TYPES (type);\n+\t\ttree base_variant = TREE_TYPE (TREE_VALUE (argtypes));\n+\t\ttree raises = TYPE_RAISES_EXCEPTIONS (type);\n+\n+\t\targtypes = commonparms (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (tmp))),\n+\t\t\t\t\tTREE_CHAIN (argtypes));\n+\t\t/* But the return type has not.  */\n+\t\ttype = build_cplus_method_type (base_variant, TREE_TYPE (type), argtypes);\n+\t\tif (raises)\n+\t\t  type = build_exception_variant (type, raises);\n+\t\tTREE_TYPE (decl) = type;\n+\t\tDECL_VINDEX (decl)\n+\t\t  = tree_cons (NULL_TREE, tmp, DECL_VINDEX (decl));\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  if (virtualp)\n+    {\n+      if (DECL_VINDEX (decl) == NULL_TREE)\n+\tDECL_VINDEX (decl) = error_mark_node;\n+      IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)) = 1;\n+    }\n+}\n+\n /* Warn about hidden virtual functions that are not overridden in t.  */\n void\n warn_hidden (t)\n@@ -2889,6 +2960,8 @@ extern int interface_only, interface_unknown;\n    TREE_LIST elements, whose TREE_PURPOSE field tells what access\n    the list has, and the TREE_VALUE slot gives the actual fields.\n \n+   ATTRIBUTES is the set of decl attributes to be applied, if any.\n+\n    If flag_all_virtual == 1, then we lay all functions into\n    the virtual function table, as though they were declared\n    virtual.  Constructors do not lay down in the virtual function table.\n@@ -2920,13 +2993,11 @@ extern int interface_only, interface_unknown;\n    or otherwise in a type-consistent manner.  */\n \n tree\n-finish_struct_1 (t, warn_anon)\n-     tree t;\n+finish_struct_1 (t, attributes, warn_anon)\n+     tree t, attributes;\n      int warn_anon;\n {\n   int old;\n-  int round_up_size = 1;\n-\n   tree name = TYPE_IDENTIFIER (t);\n   enum tree_code code = TREE_CODE (t);\n   tree fields = TYPE_FIELDS (t);\n@@ -2986,6 +3057,8 @@ finish_struct_1 (t, warn_anon)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n+  cplus_decl_attributes (t, attributes, NULL_TREE);\n+\n #if 0\n   /* This is in general too late to do this.  I moved the main case up to\n      left_curly, what else needs to move?  */\n@@ -3104,6 +3177,8 @@ finish_struct_1 (t, warn_anon)\n       DECL_SAVED_INSNS (x) = NULL_RTX;\n       DECL_FIELD_SIZE (x) = 0;\n \n+      fixup_virtual (x, t);\n+\n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n       if (DECL_VINDEX (x)\n@@ -3329,13 +3404,7 @@ finish_struct_1 (t, warn_anon)\n \t      if (width == 0)\n \t\t{\n #ifdef EMPTY_FIELD_BOUNDARY\n-\t\t  /* field size 0 => mark following field as \"aligned\" */\n-\t\t  if (TREE_CHAIN (x))\n-\t\t    DECL_ALIGN (TREE_CHAIN (x))\n-\t\t      = MAX (DECL_ALIGN (TREE_CHAIN (x)), EMPTY_FIELD_BOUNDARY);\n-\t\t  /* field of size 0 at the end => round up the size.  */\n-\t\t  else\n-\t\t    round_up_size = EMPTY_FIELD_BOUNDARY;\n+\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n #endif\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n \t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n@@ -3716,10 +3785,6 @@ finish_struct_1 (t, warn_anon)\n \n   TYPE_FIELDS (t) = fields;\n \n-  /* If there's a :0 field at the end, round the size to the\n-     EMPTY_FIELD_BOUNDARY.  */\n-  TYPE_ALIGN (t) = round_up_size;\n-\n   /* Pass layout information about base classes to layout_type, if any.  */\n   if (n_baseclasses)\n     {\n@@ -4168,9 +4233,8 @@ finish_struct_1 (t, warn_anon)\n }\n \n tree\n-finish_struct (t, list_of_fieldlists, warn_anon)\n-     tree t;\n-     tree list_of_fieldlists;\n+finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n+     tree t, list_of_fieldlists, attributes;\n      int warn_anon;\n {\n   tree fields = NULL_TREE;\n@@ -4301,7 +4365,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       return t;\n     }\n   else\n-    return finish_struct_1 (t, warn_anon);\n+    return finish_struct_1 (t, attributes, warn_anon);\n }\n \f\n /* Return non-zero if the effective type of INSTANCE is static.\n@@ -4374,10 +4438,6 @@ resolves_to_fixed_type_p (instance, nonnull)\n     case COMPONENT_REF:\n       return resolves_to_fixed_type_p (TREE_OPERAND (instance, 1), nonnull);\n \n-    case WITH_CLEANUP_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (instance, 0)) == ADDR_EXPR)\n-\treturn resolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n-      /* fall through... */\n     case VAR_DECL:\n     case FIELD_DECL:\n       if (TREE_CODE (TREE_TYPE (instance)) == ARRAY_TYPE"}, {"sha": "fabc3e115b80403c83f6473ae99c41e982ad2028", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -37,7 +37,7 @@ DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", \"e\", 2)\n \n /* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n    mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs,\n-   WITH_CLEANUP_EXPRs, CALL_EXPRs and RTL_EXPRs, that are protected\n+   CALL_EXPRs and RTL_EXPRs, that are protected\n    from being evaluated more than once should be reset so that a new\n    expand_expr call of this expr will cause those to be re-evaluated.\n    This is useful when we want to reuse a tree in different places,"}, {"sha": "05f12b99ce672193ae218b91bba9f003e3419672", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -219,6 +219,10 @@ extern int warn_redundant_decls;\n \n extern int warn_missing_braces;\n \n+/* Warn about comparison of signed and unsigned values.  */\n+\n+extern int warn_sign_compare;\n+\n /* Warn about a subscript that has type char.  */\n \n extern int warn_char_subscripts;\n@@ -1061,7 +1065,7 @@ struct lang_decl\n #endif\n \n /* In a VAR_DECL for a variable declared in a for statement,\n-   this is the shadowed variable. */\n+   this is the shadowed (local) variable. */\n #define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT(NODE)\n \n /* Points back to the decl which caused this lang_decl to be allocated.  */\n@@ -1936,7 +1940,7 @@ extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n-extern tree finish_struct\t\t\tPROTO((tree, tree, int));\n+extern tree finish_struct\t\t\tPROTO((tree, tree, tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n extern void init_class_processing\t\tPROTO((void));\n extern void pushclass\t\t\t\tPROTO((tree, int));"}, {"sha": "b45823d0260994f5e87636aaecba1c33390a13f9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -565,12 +565,6 @@ build_up_reference (type, arg, flags, checkconst)\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 1),\n \t\t\t\t\tLOOKUP_PROTECT, checkconst));\n \n-    case WITH_CLEANUP_EXPR:\n-      return build (WITH_CLEANUP_EXPR, type,\n-\t\t    build_up_reference (type, TREE_OPERAND (targ, 0),\n-\t\t\t\t\tLOOKUP_PROTECT, checkconst),\n-\t\t    0, TREE_OPERAND (targ, 2));\n-\n     case BIND_EXPR:\n       arg = TREE_OPERAND (targ, 1);\n       if (arg == NULL_TREE)\n@@ -593,12 +587,7 @@ build_up_reference (type, arg, flags, checkconst)\n       if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n \t{\n \t  temp = build_cplus_new (argtype, targ, 1);\n-\t  if (TREE_CODE (temp) == WITH_CLEANUP_EXPR)\n-\t    rval = build (WITH_CLEANUP_EXPR, type,\n-\t\t\t  build1 (ADDR_EXPR, type, TREE_OPERAND (temp, 0)),\n-\t\t\t  0, TREE_OPERAND (temp, 2));\n-\t  else\n-\t    rval = build1 (ADDR_EXPR, type, temp);\n+\t  rval = build1 (ADDR_EXPR, type, temp);\n \t  goto done;\n \t}\n       else if (flags&INDIRECT_BIND)"}, {"sha": "f3f16f85deec2fc2a00a4893fa090c4a80cbf3b7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 111, "deletions": 153, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -580,7 +580,8 @@ struct binding_level\n     /* This is set for a namespace binding level.  */\n     unsigned namespace_p : 1;\n \n-    /* True if this level is that of a for-statement. */\n+    /* True if this level is that of a for-statement where we need to\n+       worry about ambiguous (traditional or ANSI) scope rules. */\n     unsigned is_for_scope : 1;\n \n     /* One bit left for this word.  */\n@@ -1086,26 +1087,31 @@ poplevel (keep, reverse, functionbody)\n \n   /* Clear out the meanings of the local variables of this level.  */\n \n-  for (link = current_binding_level->dead_vars_from_for;\n-       link != NULL_TREE; link = TREE_CHAIN (link))\n-    {\n-      if (DECL_DEAD_FOR_LOCAL (link))\n-\t{\n-\t  tree id = DECL_NAME (link);\n-\t  if (IDENTIFIER_LOCAL_VALUE (id) == link)\n-\t    IDENTIFIER_LOCAL_VALUE (id) = DECL_SHADOWED_FOR_VAR (link);\n-\t}\n-    }\n-\n   if (current_binding_level->is_for_scope && flag_new_for_scope == 1)\n     {\n+      struct binding_level *outer = current_binding_level->level_chain;\n       for (link = decls; link; link = TREE_CHAIN (link))\n \t{\n \t  if (TREE_CODE (link) == VAR_DECL)\n \t    DECL_DEAD_FOR_LOCAL (link) = 1;\n \t}\n+\n+      /* Save declarations made in a 'for' statement so we can support pre-ANSI\n+\t 'for' scoping semantics. */\n+\n+      for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+\t{\n+\t  tree id = TREE_PURPOSE (link);\n+\t  tree decl = IDENTIFIER_LOCAL_VALUE (id);\n+\n+\t  /* In this case keep the dead for-decl visible,\n+\t     but remember what (if anything) it shadowed. */\n+\t  DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n+\t  TREE_CHAIN (decl) = outer->dead_vars_from_for;\n+\t  outer->dead_vars_from_for = decl;\n+\t}\n     }\n-  else\n+  else /* Not special for scope. */\n     {\n       for (link = decls; link; link = TREE_CHAIN (link))\n \t{\n@@ -1123,50 +1129,42 @@ poplevel (keep, reverse, functionbody)\n \t      IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n \t    }\n \t}\n-    }\n \n-  /* Restore all name-meanings of the outer levels\n-     that were shadowed by this level.  */\n+      /* Restore all name-meanings of the outer levels\n+\t that were shadowed by this level.  */\n \n-  if (current_binding_level->is_for_scope && flag_new_for_scope == 1)\n-    {\n-      struct binding_level *outer = current_binding_level->level_chain;\n-      for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+      for (link = current_binding_level->shadowed;\n+\t   link; link = TREE_CHAIN (link))\n+\tIDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\n+      /* We first restore the regular decls and *then* the dead_vars_from_for\n+\t to handle this case:\n+\n+\t int i; // i#1\n+\t {\n+\t   for (int i; ; ) { ...} // i#2\n+           int i; // i#3\n+\t } // we are here\n+\n+\t In this case, we want remove the binding for i#3, restoring\n+\t that of i#2.  Then we want to remove the binding for i#2,\n+\t and restore that of i#1. */\n+\n+      link = current_binding_level->dead_vars_from_for;\n+      for (; link != NULL_TREE; link = TREE_CHAIN (link))\n \t{\n-\t  tree id = TREE_PURPOSE (link);\n-\t  tree decl = IDENTIFIER_LOCAL_VALUE (id);\n-\t  if (DECL_DEAD_FOR_LOCAL (decl))\n-\t    DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n-\t  else\n-\t    IDENTIFIER_LOCAL_VALUE (id) = TREE_VALUE (link);\n+\t  tree id = DECL_NAME (link);\n+\t  if (IDENTIFIER_LOCAL_VALUE (id) == link)\n+\t    IDENTIFIER_LOCAL_VALUE (id) = DECL_SHADOWED_FOR_VAR (link);\n \t}\n \n-      /* Save declarations made in a 'for' statement so we can support pre-ANSI\n-\t 'for' scoping semantics. */\n-\n-      /* We append the current names of for-variables to those from previous\n-\t declarations, so that when we get around to do an poplevel\n-\t on the OUTER level, we restore the any shadowed readl bindings.\n-\t Note that the new names are put first on the combined list,\n-\t so they get to be restored first.  This is important if there are\n-\t two for-loops using the same for-variable in the same block.\n-\t The binding we really want restored is whatever binding was shadowed\n-\t by the *first* for-variable, not the binding shadowed by the\n-\t second for-variable (which would be the first for-variable). */\n-      outer->dead_vars_from_for\n-\t= chainon (current_binding_level->names, outer->dead_vars_from_for);\n-    }\n-  else\n-    {\n-      for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-\tIDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+      for (link = current_binding_level->class_shadowed;\n+\t   link; link = TREE_CHAIN (link))\n+\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+      for (link = current_binding_level->type_shadowed;\n+\t   link; link = TREE_CHAIN (link))\n+\tIDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n     }\n-  for (link = current_binding_level->class_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-  for (link = current_binding_level->type_shadowed;\n-       link; link = TREE_CHAIN (link))\n-    IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \n   /* If the level being exited is the top level of a function,\n      check over all the labels.  */\n@@ -3003,9 +3001,7 @@ pushdecl (x)\n \t{\n \t  file = DECL_SOURCE_FILE (t);\n \t  line = DECL_SOURCE_LINE (t);\n-\t  if (TREE_CODE (x) == VAR_DECL && DECL_DEAD_FOR_LOCAL (x))\n-\t    ; /* This is OK. */\n-\t  else if (TREE_CODE (t) == PARM_DECL)\n+\t  if (TREE_CODE (t) == PARM_DECL)\n \t    {\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n \t\tfatal (\"parse errors have confused me too much\");\n@@ -5821,7 +5817,8 @@ start_decl (declarator, declspecs, initialized, raises)\n     tem = decl;\n   else\n     tem = pushdecl (decl);\n-\t     \n+\n+#if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n   /* Tell the back-end to use or not use .common as appropriate.  If we say\n      -fconserve-space, we want this to save space, at the expense of wrong\n      semantics.  If we say -fno-conserve-space, we want this to produce\n@@ -5830,6 +5827,7 @@ start_decl (declarator, declspecs, initialized, raises)\n      the linker can't match it with storage from other files, and we may\n      save some disk space.  */\n   DECL_COMMON (tem) = flag_conserve_space || ! TREE_PUBLIC (tem);\n+#endif\n \n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n@@ -5957,23 +5955,15 @@ grok_reference_init (decl, type, init, cleanupp)\n \t don't get burned by \"aggressive\" cleanup policy.  */\n       if (TYPE_NEEDS_DESTRUCTOR (subtype))\n \t{\n-\t  if (TREE_CODE (init) == WITH_CLEANUP_EXPR)\n+\t  if (TREE_CODE (tmp) == ADDR_EXPR)\n+\t    tmp = TREE_OPERAND (tmp, 0);\n+\t  if (TREE_CODE (tmp) == TARGET_EXPR)\n \t    {\n-\t      *cleanupp = TREE_OPERAND (init, 2);\n-\t      TREE_OPERAND (init, 2) = error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TREE_CODE (tmp) == ADDR_EXPR)\n-\t\ttmp = TREE_OPERAND (tmp, 0);\n-\t      if (TREE_CODE (tmp) == TARGET_EXPR)\n-\t\t{\n-\t\t  *cleanupp = build_delete\n-\t\t    (build_pointer_type (subtype),\n-\t\t     build_unary_op (ADDR_EXPR, TREE_OPERAND (tmp, 0), 0),\n-\t\t     integer_two_node, LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n-\t\t  TREE_OPERAND (tmp, 2) = error_mark_node;\n-\t\t}\n+\t      *cleanupp = build_delete\n+\t\t(build_pointer_type (subtype),\n+\t\t build_unary_op (ADDR_EXPR, TREE_OPERAND (tmp, 0), 0),\n+\t\t integer_two_node, LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n+\t      TREE_OPERAND (tmp, 2) = error_mark_node;\n \t    }\n \t}\n \n@@ -6024,10 +6014,12 @@ obscure_complex_init (decl, init)\n \treturn NULL_TREE;\n     }\n \n+#if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n   if (toplevel_bindings_p () && ! DECL_COMMON (decl))\n     DECL_INITIAL (decl) = build (CONSTRUCTOR, TREE_TYPE (decl), NULL_TREE,\n \t\t\t\t NULL_TREE);\n   else\n+#endif\n     DECL_INITIAL (decl) = error_mark_node;\n \n   return init;\n@@ -6346,18 +6338,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       if (!DECL_EXTERNAL (decl) && TYPE_NEEDS_DESTRUCTOR (type))\n \t{\n \t  int yes = suspend_momentary ();\n-\n-\t  /* If INIT comes from a functional cast, use the cleanup\n-\t     we built for that.  Otherwise, make our own cleanup.  */\n-\t  if (init && TREE_CODE (init) == WITH_CLEANUP_EXPR\n-\t      && comptypes (TREE_TYPE (decl), TREE_TYPE (init), 1))\n-\t    {\n-\t      cleanup = TREE_OPERAND (init, 2);\n-\t      init = TREE_OPERAND (init, 0);\n-\t      current_binding_level->have_cleanups = 1;\n-\t    }\n-\t  else\n-\t    cleanup = maybe_build_cleanup (decl);\n+\t  cleanup = maybe_build_cleanup (decl);\n \t  resume_momentary (yes);\n \t}\n     }\n@@ -6532,6 +6513,52 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t}\n \t    }\n \n+\t  if (current_binding_level->is_for_scope)\n+\t    {\n+\t      struct binding_level *outer = current_binding_level->level_chain;\n+\n+\t      /* Check to see if the same name is already bound at\n+\t\t the outer level, either because it was directly declared,\n+\t\t or because a dead for-decl got preserved.  In either case,\n+\t\t the code would not have been valid under the traditional\n+\t\t scope rules, so clear is_for_scope for the\n+\t\t current_binding_level.\n+\n+\t\t Otherwise, we need to preserve the temp slot for decl\n+\t\t to last into the outer binding level. */\n+\n+\t      int handling_dead_for_vars = 0;\n+\t      tree link = outer->names;\n+\t      for (; ; link = TREE_CHAIN (link))\n+\t\t{\n+\t\t  if (link == NULL && handling_dead_for_vars == 0)\n+\t\t    {\n+\t\t      link = outer->dead_vars_from_for;\n+\t\t      handling_dead_for_vars = 1;\n+\t\t    }\n+\t\t  if (link == NULL)\n+\t\t    {\n+\t\t      if (DECL_RTL (decl) && GET_CODE (DECL_RTL (decl)) == MEM)\n+\t\t\tpreserve_temp_slots (DECL_RTL (decl));\n+\t\t      break;\n+\t\t    }\n+\t\t  if (DECL_NAME (link) == DECL_NAME (decl))\n+\t\t    {\n+\t\t      if (handling_dead_for_vars)\n+\t\t\t{\n+\t\t\t  tree shadowing\n+\t\t\t    = purpose_member (DECL_NAME (decl),\n+\t\t\t\t\t      current_binding_level->shadowed);\n+\t\t\t  if (shadowing && TREE_VALUE (shadowing) == link)\n+\t\t\t    TREE_VALUE (shadowing)\n+\t\t\t      = DECL_SHADOWED_FOR_VAR (link);\n+\t\t\t}\n+\t\t      current_binding_level->is_for_scope = 0;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  push_temp_slots ();\n \t  push_temp_slots ();\n \t  target_temp_slot_level = temp_slot_level;\n@@ -7027,81 +7054,12 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t\t\t\t   TREE_VALUE (attrlist));\n \t  make_decl_rtl (decl, NULL_PTR, 1);\n \t}\n-\n-      /* If this declaration supersedes the declaration of\n-\t a method declared virtual in the base class, then\n-\t mark this field as being virtual as well.  */\n-      {\n-\ttree binfos = BINFO_BASETYPES (TYPE_BINFO (ctype));\n-\tint i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-\tfor (i = 0; i < n_baselinks; i++)\n-\t  {\n-\t    tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t    if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo))\n-\t\t|| flag_all_virtual == 1)\n-\t      {\n-\t\ttmp = get_matching_virtual (base_binfo, decl,\n-\t\t\t\t\t    flags == DTOR_FLAG);\n-\t\tif (tmp)\n-\t\t  {\n-\t\t    /* If this function overrides some virtual in some base\n-\t\t       class, then the function itself is also necessarily\n-\t\t       virtual, even if the user didn't explicitly say so.  */\n-\t\t    DECL_VIRTUAL_P (decl) = 1;\n-\n-\t\t    /* The TMP we really want is the one from the deepest\n-\t\t       baseclass on this path, taking care not to\n-\t\t       duplicate if we have already found it (via another\n-\t\t       path to its virtual baseclass.  */\n-\t\t    if (staticp)\n-\t\t      {\n-\t\t\tcp_error (\"method `%D' may not be declared static\",\n-\t\t\t\t  decl);\n-\t\t\tcp_error_at (\"(since `%D' declared virtual in base class.)\",\n-\t\t\t\t     tmp);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    virtualp = 1;\n-\n-\t\t    {\n-\t\t      /* The argument types may have changed... */\n-\t\t      tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\t\t      tree base_variant = TREE_TYPE (TREE_VALUE (argtypes));\n-\n-\t\t      argtypes = commonparms (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (tmp))),\n-\t\t\t\t\t      TREE_CHAIN (argtypes));\n-\t\t      /* But the return type has not.  */\n-\t\t      type = build_cplus_method_type (base_variant, TREE_TYPE (type), argtypes);\n-\t\t      if (raises)\n-\t\t\t{\n-\t\t\t  type = build_exception_variant (type, raises);\n-\t\t\t  raises = TYPE_RAISES_EXCEPTIONS (type);\n-\t\t\t}\n-\t\t      TREE_TYPE (decl) = type;\n-\t\t      DECL_VINDEX (decl)\n-\t\t\t= tree_cons (NULL_TREE, tmp, DECL_VINDEX (decl));\n-\t\t    }\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n       if (virtualp)\n \t{\n+\t  DECL_VIRTUAL_P (decl) = 1;\n \t  if (DECL_VINDEX (decl) == NULL_TREE)\n \t    DECL_VINDEX (decl) = error_mark_node;\n \t  IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)) = 1;\n-\t  if (ctype && CLASSTYPE_VTABLE_NEEDS_WRITING (ctype)\n-\t      /* If this function is derived from a template, don't\n-\t\t make it public.  This shouldn't be here, but there's\n-\t\t no good way to override the interface pragmas for one\n-\t\t function or class only.  Bletch.  */\n-\t      && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (ctype)) == NULL_TREE\n-\t      && (write_virtuals == 2\n-\t\t  || (write_virtuals == 3\n-\t\t      && CLASSTYPE_INTERFACE_KNOWN (ctype))))\n-\t    TREE_PUBLIC (decl) = 1;\n \t}\n     }\n   return decl;"}, {"sha": "b7ce4f0270027a9c7a84819d59b678df36da868f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -196,6 +196,10 @@ int warn_redundant_decls;\n \n int warn_missing_braces;\n \n+/* Warn about comparison of signed and unsigned values.  */\n+\n+int warn_sign_compare;\n+\n /* Warn about *printf or *scanf format/argument anomalies. */\n \n int warn_format;\n@@ -541,6 +545,8 @@ lang_decode_option (p)\n \twarn_redundant_decls = setting;\n       else if (!strcmp (p, \"missing-braces\"))\n \twarn_missing_braces = setting;\n+      else if (!strcmp (p, \"sign-compare\"))\n+\twarn_sign_compare = setting;\n       else if (!strcmp (p, \"format\"))\n \twarn_format = setting;\n       else if (!strcmp (p, \"conversion\"))\n@@ -565,7 +571,6 @@ lang_decode_option (p)\n \t;\t\t\t/* cpp handles this one.  */\n       else if (!strcmp (p, \"all\"))\n \t{\n-\t  extra_warnings = setting;\n \t  warn_return_type = setting;\n \t  warn_unused = setting;\n \t  warn_implicit = setting;\n@@ -574,6 +579,7 @@ lang_decode_option (p)\n \t  warn_format = setting;\n \t  warn_parentheses = setting;\n \t  warn_missing_braces = setting;\n+\t  warn_sign_compare = setting;\n \t  warn_extern_inline = setting;\n \t  warn_nonvdtor = setting;\n \t  /* We save the value of warn_uninitialized, since if they put"}, {"sha": "a2d786cc70f9752fd261db48661068cd73b15ff8", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -1082,12 +1082,6 @@ dump_expr (t, nop)\n       }\n       break;\n \n-    case WITH_CLEANUP_EXPR:\n-      /* Note that this only works for G++ cleanups.  If somebody\n-\t builds a general cleanup, there's no way to represent it.  */\n-      dump_expr (TREE_OPERAND (t, 0), 0);\n-      break;\n-\n     case TARGET_EXPR:\n       /* Note that this only works for G++ target exprs.  If somebody\n \t builds a general TARGET_EXPR, there's no way to represent that"}, {"sha": "c5ec252a17a557ff8bcab13bf3bdb90ee2cb8ca8", "filename": "gcc/cp/init.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -865,6 +865,20 @@ do_member_init (s_id, name, init)\n   expand_member_init (build_indirect_ref (base, NULL_PTR), name, init);\n }\n \n+/* Find the context in which this FIELD can be initialized.  */\n+static tree\n+initializing_context (field)\n+     tree field;\n+{\n+  tree t = DECL_CONTEXT (field);\n+\n+  /* Anonymous union members can be initialized in the first enclosing\n+     non-anonymous union context.  */\n+  while (t && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+    t = TYPE_CONTEXT (t);\n+  return t;\n+}\n+\n /* Function to give error message if member initialization specification\n    is erroneous.  FIELD is the member we decided to initialize.\n    TYPE is the type for which the initialization is being performed.\n@@ -880,7 +894,7 @@ member_init_ok_or_else (field, type, member_name)\n {\n   if (field == error_mark_node)\n     return 0;\n-  if (field == NULL_TREE || DECL_CONTEXT (field) != type)\n+  if (field == NULL_TREE || initializing_context (field) != type)\n     {\n       cp_error (\"class `%T' does not have any field named `%s'\", type,\n \t\tmember_name);\n@@ -2204,7 +2218,14 @@ is_friend (type, supplicant)\n     tree context;\n \n     if (! declp)\n-      context = DECL_CONTEXT (TYPE_NAME (supplicant));\n+      {\n+\t/* Are we a nested or local class?  If so, we aren't friends\n+           with the CONTEXT.  */\n+\tif (IS_AGGR_TYPE (supplicant))\n+\t  context = NULL_TREE;\n+\telse\n+\t  context = DECL_CONTEXT (TYPE_NAME (supplicant));\n+      }\n     else if (DECL_FUNCTION_MEMBER_P (supplicant))\n       context = DECL_CLASS_CONTEXT (supplicant);\n     else"}, {"sha": "7febe10520d25984e2ae70b9a753bf8b937bffe8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -2283,8 +2283,7 @@ check_newline ()\n                  tricks.  */\n \t      else\n \t\t{\n-\t\t  ungetc (c, finput);\n-\t\t  HANDLE_PRAGMA (finput);\n+\t\t  c = HANDLE_PRAGMA (finput, c);\n \t\t}\n #endif\n #endif\n@@ -2940,6 +2939,11 @@ do_identifier (token)\n   if (TREE_CODE (id) == VAR_DECL && DECL_DEAD_FOR_LOCAL (id))\n     {\n       tree shadowed = DECL_SHADOWED_FOR_VAR (id);\n+      while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n+\t     && DECL_DEAD_FOR_LOCAL (shadowed))\n+\tshadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n+      if (!shadowed)\n+\tshadowed = IDENTIFIER_GLOBAL_VALUE (DECL_NAME (id));\n       if (shadowed)\n \t{\n \t  if (!DECL_ERROR_REPORTED (id))"}, {"sha": "49e7dd25924e0d3f24abb70ebd6db739ccd16bea", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -901,7 +901,7 @@ template_instantiate_once:\n \t\t}\n \t  left_curly opt.component_decl_list '}'\n \t\t{\n-\t\t  tree t = finish_struct ($<ttype>3, $5, 0);\n+\t\t  tree t = finish_struct ($<ttype>3, $5, NULL_TREE, 0);\n \n \t\t  pop_obstacks ();\n \t\t  end_template_instantiation ($1);\n@@ -2187,7 +2187,7 @@ structsp:\n \t| TYPENAME_KEYWORD complex_type_name\n \t\t{ $$ = $2; }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n-\t| class_head left_curly opt.component_decl_list '}'\n+\t| class_head left_curly opt.component_decl_list '}' maybe_attribute\n \t\t{\n \t\t  int semi;\n \t\t  tree id;\n@@ -2209,7 +2209,7 @@ structsp:\n \t\t    /* $$ = $1 from default rule.  */;\n \t\t  else\n \t\t    {\n-\t\t      $$ = finish_struct ($$, $3, semi);\n+\t\t      $$ = finish_struct ($$, $3, $5, semi);\n \t\t      if (semi) note_got_semicolon ($$);\n \t\t    }\n "}, {"sha": "e34cf5bab94dffaed182d56fa05af573a1538671", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -74,9 +74,6 @@ real_lvalue_p (ref)\n \treturn 1;\n       break;\n \n-    case WITH_CLEANUP_EXPR:\n-      return real_lvalue_p (TREE_OPERAND (ref, 0));\n-\n       /* A currently unresolved scope ref.  */\n     case SCOPE_REF:\n       my_friendly_abort (103);\n@@ -147,9 +144,6 @@ lvalue_p (ref)\n \treturn 1;\n       break;\n \n-    case WITH_CLEANUP_EXPR:\n-      return lvalue_p (TREE_OPERAND (ref, 0));\n-\n     case TARGET_EXPR:\n       return 1;\n \n@@ -206,12 +200,7 @@ lvalue_or_else (ref, string)\n \n    Build an encapsulation of the initialization to perform\n    and return it so that it can be processed by language-independent\n-   and language-specific expression expanders.\n-\n-   If WITH_CLEANUP_P is nonzero, we build a cleanup for this expression.\n-   Otherwise, cleanups are not built here.  For example, when building\n-   an initialization for a stack slot, since the called function handles\n-   the cleanup, we would not want to do it here.  */\n+   and language-specific expression expanders.  */\n tree\n build_cplus_new (type, init, with_cleanup_p)\n      tree type;\n@@ -231,19 +220,6 @@ build_cplus_new (type, init, with_cleanup_p)\n   TREE_SIDE_EFFECTS (rval) = 1;\n   TREE_ADDRESSABLE (rval) = 1;\n \n-#if 0\n-  if (with_cleanup_p && TYPE_NEEDS_DESTRUCTOR (type))\n-    {\n-      TREE_OPERAND (rval, 2) = error_mark_node;\n-      rval = build (WITH_CLEANUP_EXPR, type, rval, 0,\n-\t\t    build_delete (build_pointer_type (type),\n-\t\t\t\t  build_unary_op (ADDR_EXPR, slot, 0),\n-\t\t\t\t  integer_two_node,\n-\t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0));\n-      TREE_SIDE_EFFECTS (rval) = 1;\n-      TREE_ADDRESSABLE (rval) = 1;\n-    }\n-#endif\n   return rval;\n }\n \n@@ -1808,11 +1784,6 @@ unsave_expr_now (expr)\n \t    }\n \t}\n       break;\n-      \n-    case WITH_CLEANUP_EXPR:\n-      warning (\"WITH_CLEANUP_EXPR reused inside UNSAVE_EXPR\");\n-      RTL_EXPR_RTL (expr) = NULL_RTX;\n-      break;\n     }\n \n   switch (TREE_CODE_CLASS (code))"}, {"sha": "0c47de9d7953a7e87509a27b54d74b1da5b38a4e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 73, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee887f2725c1f074859ae85735f08bffca23dfb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2ee887f2725c1f074859ae85735f08bffca23dfb", "patch": "@@ -1798,9 +1798,42 @@ build_component_ref (datum, component, basetype_path, protect)\n \t}\n     }\n \n+  /* See if we have to do any conversions so that we pick up the field from the\n+     right context.  */\n   if (DECL_FIELD_CONTEXT (field) != basetype)\n     {\n       tree context = DECL_FIELD_CONTEXT (field);\n+      tree base = context;\n+      while (base != basetype && ANON_AGGRNAME_P (TYPE_IDENTIFIER (base)))\n+\t{\n+\t  base = TYPE_CONTEXT (base);\n+\t}\n+\n+      /* Handle base classes here...  */\n+      if (base != basetype && TYPE_USES_COMPLEX_INHERITANCE (basetype))\n+\t{\n+\t  tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n+\t  if (integer_zerop (addr))\n+\t    {\n+\t      error (\"invalid reference to NULL ptr, use ptr-to-member instead\");\n+\t      return error_mark_node;\n+\t    }\n+\t  if (VBASE_NAME_P (DECL_NAME (field)))\n+\t    {\n+\t      /* It doesn't matter which vbase pointer we grab, just\n+\t\t find one of them.  */\n+\t      tree binfo = get_binfo (base,\n+\t\t\t\t      TREE_TYPE (TREE_TYPE (addr)), 0);\n+\t      addr = convert_pointer_to_real (binfo, addr);\n+\t    }\n+\t  else\n+\t    addr = convert_pointer_to (base, addr);\n+\t  datum = build_indirect_ref (addr, NULL_PTR);\n+\t  my_friendly_assert (datum != error_mark_node, 311);\n+\t}\n+      basetype = base;\n+ \n+      /* Handle things from anon unions here...  */\n       if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n \t{\n \t  tree subfield = lookup_anon_field (basetype, context);\n@@ -1810,28 +1843,6 @@ build_component_ref (datum, component, basetype_path, protect)\n \t}\n     }\n \n-  if (DECL_FIELD_CONTEXT (field) != basetype\n-      && TYPE_USES_COMPLEX_INHERITANCE (basetype))\n-    {\n-      tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n-      if (integer_zerop (addr))\n-\t{\n-\t  error (\"invalid reference to NULL ptr, use ptr-to-member instead\");\n-\t  return error_mark_node;\n-\t}\n-      if (VBASE_NAME_P (DECL_NAME (field)))\n-\t  {\n-\t    /* It doesn't matter which vbase pointer we grab, just\n-\t       find one of them.  */\n-\t    tree binfo = get_binfo (DECL_FIELD_CONTEXT (field),\n-\t\t\t\t    TREE_TYPE (TREE_TYPE (addr)), 0);\n-\t    addr = convert_pointer_to_real (binfo, addr);\n-\t  }\n-\telse\n-\t  addr = convert_pointer_to (DECL_FIELD_CONTEXT (field), addr);\n-      datum = build_indirect_ref (addr, NULL_PTR);\n-      my_friendly_assert (datum != error_mark_node, 311);\n-    }\n   ref = fold (build (COMPONENT_REF, TREE_TYPE (field),\n \t\t     break_out_cleanups (datum), field));\n \n@@ -3486,7 +3497,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  resultcode = xresultcode;\n \t}\n \n-      if (short_compare && extra_warnings)\n+      if (short_compare && warn_sign_compare)\n \t{\n \t  int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n \t  int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n@@ -4308,14 +4319,6 @@ unary_complex_lvalue (code, arg)\n       return build (COMPOUND_EXPR, TREE_TYPE (real_result), arg, real_result);\n     }\n \n-  if (TREE_CODE (arg) == WITH_CLEANUP_EXPR)\n-    {\n-      tree real_result = build_unary_op (code, TREE_OPERAND (arg, 0), 0);\n-      real_result = build (WITH_CLEANUP_EXPR, TREE_TYPE (real_result),\n-\t\t\t   real_result, 0, TREE_OPERAND (arg, 2));\n-      return real_result;\n-    }\n-\n   if (TREE_CODE (TREE_TYPE (arg)) == FUNCTION_TYPE\n       || TREE_CODE (TREE_TYPE (arg)) == METHOD_TYPE\n       || TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n@@ -4402,17 +4405,6 @@ unary_complex_lvalue (code, arg)\n     if (TREE_CODE (arg) == SAVE_EXPR && TREE_CODE (targ) == INDIRECT_REF)\n       return build (SAVE_EXPR, build_pointer_type (TREE_TYPE (arg)),\n \t\t     TREE_OPERAND (targ, 0), current_function_decl, NULL);\n-\n-    /* We shouldn't wrap WITH_CLEANUP_EXPRs inside of SAVE_EXPRs, but in case\n-       we do, here's how to handle it.  */\n-    if (TREE_CODE (arg) == SAVE_EXPR && TREE_CODE (targ) == WITH_CLEANUP_EXPR)\n-      {\n-#if 0\n-\t/* Not really a bug, but something to turn on when testing.  */\n-\tcompiler_error (\"WITH_CLEANUP_EXPR wrapped in SAVE_EXPR\");\n-#endif\n-\treturn unary_complex_lvalue (ADDR_EXPR, targ);\n-      }\n   }\n \n   /* Don't let anything else be handled specially.  */\n@@ -5661,38 +5653,10 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t\t TREE_OPERAND (newrhs, 2))));\n \t}\n     }\n-  else if (modifycode != INIT_EXPR && TREE_CODE (newrhs) == WITH_CLEANUP_EXPR)\n-    {\n-      tree cleanup = TREE_OPERAND (newrhs, 2);\n-      tree slot;\n-\n-      /* Finish up by running cleanups and having the \"value\" of the lhs.  */\n-      tree exprlist = tree_cons (NULL_TREE, cleanup,\n-\t\t\t\t build_tree_list (NULL_TREE, lhs));\n-      newrhs = TREE_OPERAND (newrhs, 0);\n-      if (TREE_CODE (newrhs) == TARGET_EXPR)\n-\t  slot = TREE_OPERAND (newrhs, 0);\n-      else if (TREE_CODE (newrhs) == ADDR_EXPR)\n-\t{\n-\t  /* Bad but valid.  */\n-\t  slot = newrhs;\n-\t  warning (\"address taken of temporary object\");\n-\t}\n-      else\n-\tmy_friendly_abort (118);\n-\n-      /* Copy the value computed in SLOT into LHS.  */\n-      exprlist = tree_cons (NULL_TREE,\n-\t\t\t    build_modify_expr (lhs, modifycode, slot),\n-\t\t\t    exprlist);\n-      /* Evaluate the expression that needs CLEANUP.  This will\n-\t compute the value into SLOT.  */\n-      exprlist = tree_cons (NULL_TREE, newrhs, exprlist);\n-      result = convert (lhstype, build_compound_expr (exprlist));\n-    }\n   else\n     result = build (modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR,\n \t\t    lhstype, lhs, newrhs);\n+\n   TREE_SIDE_EFFECTS (result) = 1;\n \n   /* If we got the LHS in a different type for storing in,\n@@ -6788,8 +6752,7 @@ c_expand_return (retval)\n \t{\n \t  whats_returned = TREE_OPERAND (whats_returned, 0);\n \t  while (TREE_CODE (whats_returned) == NEW_EXPR\n-\t\t || TREE_CODE (whats_returned) == TARGET_EXPR\n-\t\t || TREE_CODE (whats_returned) == WITH_CLEANUP_EXPR)\n+\t\t || TREE_CODE (whats_returned) == TARGET_EXPR)\n \t    {\n \t      /* Get the target.  */\n \t      whats_returned = TREE_OPERAND (whats_returned, 0);"}]}