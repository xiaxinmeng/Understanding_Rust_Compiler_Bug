{"sha": "25eadeeaa2a0da50bd591c38de899140a413323e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlYWRlZWFhMmEwZGE1MGJkNTkxYzM4ZGU4OTkxNDBhNDEzMzIzZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-25T09:04:53Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-25T09:04:53Z"}, "message": "[Ada] Spurious secondary stack depletion\n\nThis patch reimplements the secondary stack allocation logic to eliminate an\nissue which causes the memory index to overflow while the stack itself uses\nvery little memory, thus causing a spurious Storage_Error.\n\nThe issue in details:\n\nThe total amount of memory that the secondary stack can accomodate is dictated\nby System.Parameters.Size_Type which is really an Integer, giving roughly 2 GB\nof storage.\n\nThe secondary stack is comprised of multiple frames which logically form a\ncontiguous array of memory. Each frame maintans a range over which it operates,\nwhere\n\n   Low  bound = Previous frame's high bound + 1\n   High bound = Previous frame's high bound + Frame size\n\nThe allocation logic starts by first checking whether the current top frame\n(which may not be the \"last\" frame in the secondary stack) has enough memory to\nfit an object. If it does, then that frame is used. If it does not, the logic\nthen examines the subsequent frames, while carrying out the following actions:\n\n   * If the frame is too small to fit the object, it is deleted\n\n   * If the frame is big enough to fit the object, it is used\n\nIf all the frames were too small (and thus deleted), a new frame is added which\nis big enough to fit the object.\n\nDue to an issue with the deletion logic, the last frame would never be deleted.\nSince any new frame's range is based on the previous frame's range, the new\nrange would keep growing, even though the secondary stack may have very few\nframes in use. Eventually this growth overflows the memory index type.\n\nThe overflow of the memory index type happens only when the secondary stack\nis full, and thus signals a Storage_Error. Due to the spurious growth of the\nranges, the overflow happens much faster and results in a bogus stack depleton.\n\nThe issue manifests only when each new memory request to the secondary stack is\nslightly bigger than the previous memory request, thus prompring the secondary\nstack to delete all its frames, and create a new one.\n\n2018-05-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-secsta.adb (SS_Allocate): Reimplemented.\n\t(SS_Allocate_Dynamic): New routine. The allocation logic is now split\n\tinto three distring cases rather than in one loop which attempts to\n\thandle all three cases. This rewrite eliminates an issue where the last\n\tframe of the stack cannot be freed, thus causing the memory range of a\n\tnew frame to approach the overflow point of the memory index type.\n\tSince the overflow is logically treated as a\n\ttoo-much-memory-on-the-stack scenario, it causes a bogus Storage_Error.\n\t(SS_Allocate_Static): New routine. The routine factorizes the static\n\tsecondary stack-related code from the former SS_Allocate.\n\ngcc/testsuite/\n\n\t* gnat.dg/sec_stack2.adb: New testcase.\n\nFrom-SVN: r260736", "tree": {"sha": "cd2656d1a114774469fe05bdc4932cd1f9934a2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd2656d1a114774469fe05bdc4932cd1f9934a2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25eadeeaa2a0da50bd591c38de899140a413323e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25eadeeaa2a0da50bd591c38de899140a413323e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25eadeeaa2a0da50bd591c38de899140a413323e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25eadeeaa2a0da50bd591c38de899140a413323e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd42db1f3ae2e01d8d69237b07e69b3e104d43ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd42db1f3ae2e01d8d69237b07e69b3e104d43ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd42db1f3ae2e01d8d69237b07e69b3e104d43ee"}], "stats": {"total": 551, "additions": 431, "deletions": 120}, "files": [{"sha": "73dec9d74d637d6f05727729ce626bbc3d04cbbd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=25eadeeaa2a0da50bd591c38de899140a413323e", "patch": "@@ -1,3 +1,16 @@\n+2018-05-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* libgnat/s-secsta.adb (SS_Allocate): Reimplemented.\n+\t(SS_Allocate_Dynamic): New routine. The allocation logic is now split\n+\tinto three distring cases rather than in one loop which attempts to\n+\thandle all three cases. This rewrite eliminates an issue where the last\n+\tframe of the stack cannot be freed, thus causing the memory range of a\n+\tnew frame to approach the overflow point of the memory index type.\n+\tSince the overflow is logically treated as a\n+\ttoo-much-memory-on-the-stack scenario, it causes a bogus Storage_Error.\n+\t(SS_Allocate_Static): New routine. The routine factorizes the static\n+\tsecondary stack-related code from the former SS_Allocate.\n+\n 2018-05-25  Sergey Rybin  <rybin@adacore.com>\n \n \t* doc/gnat_ugn/gnat_and_program_execution.rst: Add description of '-U'"}, {"sha": "164f7ed6e2bbc92ce9fdd55cdcb9f8db30571bbc", "filename": "gcc/ada/libgnat/s-secsta.adb", "status": "modified", "additions": 324, "deletions": 120, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Fada%2Flibgnat%2Fs-secsta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Fada%2Flibgnat%2Fs-secsta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-secsta.adb?ref=25eadeeaa2a0da50bd591c38de899140a413323e", "patch": "@@ -33,185 +33,386 @@ pragma Compiler_Unit_Warning;\n \n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n-with System.Soft_Links;\n \n-package body System.Secondary_Stack is\n-\n-   package SSL renames System.Soft_Links;\n+with System.Parameters;       use System.Parameters;\n+with System.Soft_Links;       use System.Soft_Links;\n+with System.Storage_Elements; use System.Storage_Elements;\n \n-   use type System.Parameters.Size_Type;\n+package body System.Secondary_Stack is\n \n    procedure Free is new Ada.Unchecked_Deallocation (Chunk_Id, Chunk_Ptr);\n    --  Free a dynamically allocated chunk\n \n+   procedure SS_Allocate_Dynamic\n+     (Stack       : SS_Stack_Ptr;\n+      Mem_Request : SS_Ptr;\n+      Addr        : out Address);\n+   pragma Inline (SS_Allocate_Dynamic);\n+   --  Allocate enough space on dynamic secondary stack Stack to accommodate an\n+   --  object of size Mem_Request. Addr denotes the address where the object is\n+   --  to be placed.\n+\n+   procedure SS_Allocate_Static\n+     (Stack       : SS_Stack_Ptr;\n+      Mem_Request : SS_Ptr;\n+      Addr        : out Address);\n+   pragma Inline (SS_Allocate_Static);\n+   --  Allocate enough space on static secondary stack Stack to accommodate an\n+   --  object of size Mem_Request. Addr denotes the address where the object is\n+   --  to be placed.\n+\n    -----------------\n    -- SS_Allocate --\n    -----------------\n \n    procedure SS_Allocate\n      (Addr         : out Address;\n-      Storage_Size : SSE.Storage_Count)\n+      Storage_Size : Storage_Count)\n    is\n-      use type System.Storage_Elements.Storage_Count;\n+      function Round_Up (Size : Storage_Count) return SS_Ptr;\n+      pragma Inline (Round_Up);\n+      --  Round up Size to the nearest multiple of the maximum alignment on the\n+      --  target.\n+\n+      function Round_Up_Overflows (Size : Storage_Count) return Boolean;\n+      pragma Inline (Round_Up_Overflows);\n+      --  Determine whether a round up of Size to the nearest multiple of the\n+      --  maximum alignment will overflow the operation.\n+\n+      --------------\n+      -- Round_Up --\n+      --------------\n+\n+      function Round_Up (Size : Storage_Count) return SS_Ptr is\n+         Max_Align : constant SS_Ptr := SS_Ptr (Standard'Maximum_Alignment);\n+\n+      begin\n+         return ((SS_Ptr (Size) + Max_Align - 1) / Max_Align) * Max_Align;\n+      end Round_Up;\n+\n+      ------------------------\n+      -- Round_Up_Overflows --\n+      ------------------------\n+\n+      function Round_Up_Overflows (Size : Storage_Count) return Boolean is\n+         Max_Align : constant Storage_Count := Standard'Maximum_Alignment;\n+\n+      begin\n+         return Storage_Count (SS_Ptr'Last) - Max_Align < Size;\n+      end Round_Up_Overflows;\n+\n+      --  Local variables\n+\n+      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n+      --  The secondary stack of the current task\n \n-      Max_Align   : constant SS_Ptr := SS_Ptr (Standard'Maximum_Alignment);\n       Mem_Request : SS_Ptr;\n \n-      Stack       : constant SS_Stack_Ptr := SSL.Get_Sec_Stack.all;\n+   --  Start of processing for SS_Allocate\n+\n    begin\n-      --  Round up Storage_Size to the nearest multiple of the max alignment\n-      --  value for the target. This ensures efficient stack access. First\n-      --  perform a check to ensure that the rounding operation does not\n-      --  overflow SS_Ptr.\n-\n-      if SSE.Storage_Count (SS_Ptr'Last) - Standard'Maximum_Alignment <\n-        Storage_Size\n-      then\n+      --  It should not be possible to allocate an object of size zero\n+\n+      pragma Assert (Storage_Size > 0);\n+\n+      --  Round up the requested allocation size to the nearest multiple of the\n+      --  maximum alignment value for the target. This ensures efficient stack\n+      --  access. Check that the rounding operation does not overflow SS_Ptr.\n+\n+      if Round_Up_Overflows (Storage_Size) then\n          raise Storage_Error;\n       end if;\n \n-      Mem_Request := ((SS_Ptr (Storage_Size) + Max_Align - 1) / Max_Align) *\n-                       Max_Align;\n+      Mem_Request := Round_Up (Storage_Size);\n \n-      --  Case of fixed secondary stack\n+      if Sec_Stack_Dynamic then\n+         SS_Allocate_Dynamic (Stack, Mem_Request, Addr);\n \n-      if not SP.Sec_Stack_Dynamic then\n-         --  Check if max stack usage is increasing\n+      else\n+         SS_Allocate_Static (Stack, Mem_Request, Addr);\n+      end if;\n+   end SS_Allocate;\n+\n+   -------------------------\n+   -- SS_Allocate_Dynamic --\n+   -------------------------\n+\n+   procedure SS_Allocate_Dynamic\n+     (Stack       : SS_Stack_Ptr;\n+      Mem_Request : SS_Ptr;\n+      Addr        : out Address)\n+   is\n+      procedure Delete_Chunk (Chunk : in out Chunk_Ptr);\n+      pragma Inline (Delete_Chunk);\n+      --  Unchain chunk Chunk from the secondary stack and delete it\n \n-         if Stack.Max - Stack.Top - Mem_Request < 0 then\n+      procedure Link_Chunks (First : Chunk_Ptr; Second : Chunk_Ptr);\n+      pragma Inline (Link_Chunks);\n+      --  Link chunk Second to chunk First\n \n-            --  If so, check if the stack is exceeded, noting Stack.Top points\n-            --  to the first free byte (so the value of Stack.Top on a fully\n-            --  allocated stack will be Stack.Size + 1). The comparison is\n-            --  formed to prevent integer overflows.\n+      procedure Update_Max;\n+      pragma Inline (Update_Max);\n+      --  Raise the Max watermark if needed, based on Stack.Top\n \n-            if Stack.Size - Stack.Top - Mem_Request < -1 then\n-               raise Storage_Error;\n-            end if;\n+      ------------------\n+      -- Delete_Chunk --\n+      ------------------\n+\n+      procedure Delete_Chunk (Chunk : in out Chunk_Ptr) is\n+         Next : constant Chunk_Ptr := Chunk.Next;\n+         Prev : constant Chunk_Ptr := Chunk.Prev;\n+\n+      begin\n+         --  A chunk must always succeed another chunk. In the base case, that\n+         --  chunk is the Internal_Chunk.\n+\n+         pragma Assert (Prev /= null);\n+\n+         Chunk.Next := null;    --        Chunk --> X\n+         Chunk.Prev := null;    --  X <-- Chunk\n+\n+         --  The chunk being deleted is the last chunk\n \n-            --  Record new max usage\n+         if Next = null then\n+            Prev.Next := null;  --  Prev --> X\n \n-            Stack.Max := Stack.Top + Mem_Request;\n+         --  Otherwise link both the Prev and Next chunks\n+\n+         else\n+            Link_Chunks (Prev, Next);\n          end if;\n \n-         --  Set resulting address and update top of stack pointer\n+         Free (Chunk);\n+      end Delete_Chunk;\n+\n+      -----------------\n+      -- Link_Chunks --\n+      -----------------\n \n-         Addr := Stack.Internal_Chunk.Mem (Stack.Top)'Address;\n+      procedure Link_Chunks (First : Chunk_Ptr; Second : Chunk_Ptr) is\n+      begin\n+         First.Next  := Second;  --  First --> Second\n+         Second.Prev := First;   --  First <-- Second\n+      end Link_Chunks;\n+\n+      ----------------\n+      -- Update_Max --\n+      ----------------\n+\n+      procedure Update_Max is\n+      begin\n+         if Stack.Top > Stack.Max then\n+            Stack.Max := Stack.Top;\n+         end if;\n+      end Update_Max;\n+\n+      --  Local variables\n+\n+      Chunk      : Chunk_Ptr;\n+      Chunk_Size : SS_Ptr;\n+      Next_Chunk : Chunk_Ptr;\n+      Top_Chunk  : Chunk_Ptr;\n+\n+   --  Start of processing for SS_Allocate_Dynamic\n+\n+   begin\n+      --  Find the chunk where Top lives by going in reverse, starting from\n+      --  Current_Chunk.\n+      --\n+      --          Top\n+      --          |\n+      --    +--------+ --> +----------+ --> +-----------------+\n+      --    |#####|  |     |####      |     |###########      |\n+      --    +--------+ <-- +----------+ <-- +-----------------+\n+      --                                             ^\n+      --                                        Current_Chunk\n+\n+      Top_Chunk := Stack.Current_Chunk;\n+\n+      while Top_Chunk.First > Stack.Top loop\n+         Top_Chunk := Top_Chunk.Prev;\n+      end loop;\n+\n+      --  Inspect Top_Chunk to determine whether the remaining space is big\n+      --  enough to fit the object.\n+      --\n+      --      Addr Top\n+      --      |    |\n+      --    +--------+ ...\n+      --    |######| |\n+      --    +--------+ ...\n+      --         ^\n+      --     Top_Chunk\n+\n+      if Top_Chunk.Last - Stack.Top + 1 >= Mem_Request then\n+         Addr      := Top_Chunk.Mem (Stack.Top)'Address;\n          Stack.Top := Stack.Top + Mem_Request;\n+         Update_Max;\n \n-      --  Case of dynamic secondary stack\n+         return;\n+      end if;\n \n-      else\n-         declare\n-            Chunk                : Chunk_Ptr;\n-            Chunk_Size           : SS_Ptr;\n-            To_Be_Released_Chunk : Chunk_Ptr;\n+      --  At this point it is known that Top_Chunk is not big enough to fit\n+      --  the object. Examine subsequent chunks using the following criteria:\n+      --\n+      --    * If a chunk is too small to fit the object, delete it\n+      --\n+      --    * If a chunk is big enough to fit the object, use that chunk\n \n-         begin\n-            Chunk := Stack.Current_Chunk;\n+      Chunk := Top_Chunk.Next;\n+      while Chunk /= null loop\n \n-            --  The Current_Chunk may not be the best one if a lot of release\n-            --  operations have taken place. Go down the stack if necessary.\n+         --  Capture the next chunk in case the current one is deleted\n \n-            while Chunk.First > Stack.Top loop\n-               Chunk := Chunk.Prev;\n-            end loop;\n+         Next_Chunk := Chunk.Next;\n \n-            --  Find out if the available memory in the current chunk is\n-            --  sufficient, if not, go to the next one and eventually create\n-            --  the necessary room.\n+         --  The current chunk is too small to fit the object and must be\n+         --  deleted to avoid creating a hole in the secondary stack. Note\n+         --  that this may delete the Current_Chunk.\n \n-            while Chunk.Last - Stack.Top - Mem_Request < -1 loop\n-               if Chunk.Next /= null then\n-                  --  Release unused non-first empty chunk\n+         if Chunk.Last - Chunk.First + 1 < Mem_Request then\n+            Delete_Chunk (Chunk);\n \n-                  if Chunk.Prev /= null and then Chunk.First = Stack.Top then\n-                     To_Be_Released_Chunk := Chunk;\n-                     Chunk := Chunk.Prev;\n-                     Chunk.Next := To_Be_Released_Chunk.Next;\n-                     To_Be_Released_Chunk.Next.Prev := Chunk;\n-                     Free (To_Be_Released_Chunk);\n-                  end if;\n+         --  Otherwise the chunk is big enough to fit the object. Use this\n+         --  chunk to store the object.\n+         --\n+         --                    Addr   Top\n+         --                    |      |\n+         --    +--------+ --> +----------+ ... ...................\n+         --    |#####   |     |#######|  |     :                 :\n+         --    +--------+ <-- +----------+ ... ...................\n+         --        ^               ^                    ^\n+         --    Top_Chunk         Chunk             Current_Chunk\n \n-               --  Create a new chunk\n+         else\n+            Addr      := Chunk.Mem (Chunk.First)'Address;\n+            Stack.Top := Chunk.First + Mem_Request;\n+            Update_Max;\n \n-               else\n-                  --  The new chunk should be no smaller than the default\n-                  --  chunk size to minimize the amount of secondary stack\n-                  --  management.\n+            return;\n+         end if;\n \n-                  if Mem_Request <= Stack.Size then\n-                     Chunk_Size := Stack.Size;\n-                  else\n-                     Chunk_Size := Mem_Request;\n-                  end if;\n+         Chunk := Next_Chunk;\n+      end loop;\n \n-                  --  Check that the indexing limits are not exceeded\n+      --  At this point one of the following outcomes took place:\n+      --\n+      --    * Top_Chunk is the last chunk in the secondary stack\n+      --\n+      --    * Top_Chunk was not the last chunk originally. It was followed by\n+      --      chunks which were too small to fit the object and as a result\n+      --      were deleted, thus making Top_Chunk the last chunk.\n \n-                  if SS_Ptr'Last - Chunk.Last - Chunk_Size < 0 then\n-                     raise Storage_Error;\n-                  end if;\n+      pragma Assert (Top_Chunk.Next = null);\n \n-                  Chunk.Next :=\n-                    new Chunk_Id\n-                      (First => Chunk.Last + 1,\n-                       Last  => Chunk.Last + Chunk_Size);\n+      --  Create a new chunk big enough to fit the object. The size of the\n+      --  chunk must be at least the minimum default size.\n \n-                  Chunk.Next.Prev := Chunk;\n-               end if;\n+      if Mem_Request <= Stack.Size then\n+         Chunk_Size := Stack.Size;\n+      else\n+         Chunk_Size := Mem_Request;\n+      end if;\n \n-               Chunk     := Chunk.Next;\n-               Stack.Top := Chunk.First;\n-            end loop;\n+      --  Check that the indexing limits are not exceeded\n \n-            --  Resulting address is the address pointed by Stack.Top\n+      if SS_Ptr'Last - Top_Chunk.Last < Chunk_Size then\n+         raise Storage_Error;\n+      end if;\n \n-            Addr                := Chunk.Mem (Stack.Top)'Address;\n-            Stack.Top           := Stack.Top + Mem_Request;\n-            Stack.Current_Chunk := Chunk;\n+      Chunk :=\n+        new Chunk_Id\n+              (First => Top_Chunk.Last + 1,\n+               Last  => Top_Chunk.Last + Chunk_Size);\n+\n+      --  Grow the secondary stack by adding the new chunk to Top_Chunk. The\n+      --  new chunk also becomes the Current_Chunk because it is the last in\n+      --  the list of chunks.\n+      --\n+      --                    Addr      Top\n+      --                    |         |\n+      --    +--------+ --> +-------------+\n+      --    |#####   |     |##########|  |\n+      --    +--------+ <-- +-------------+\n+      --        ^                ^\n+      --    Top_Chunk       Current_Chunk\n+\n+      Link_Chunks (Top_Chunk, Chunk);\n+      Stack.Current_Chunk := Chunk;\n+\n+      Addr      := Chunk.Mem (Chunk.First)'Address;\n+      Stack.Top := Chunk.First + Mem_Request;\n+      Update_Max;\n+   end SS_Allocate_Dynamic;\n+\n+   ------------------------\n+   -- SS_Allocate_Static --\n+   ------------------------\n+\n+   procedure SS_Allocate_Static\n+     (Stack       : SS_Stack_Ptr;\n+      Mem_Request : SS_Ptr;\n+      Addr        : out Address)\n+   is\n+   begin\n+      --  Check if the max stack usage is increasing\n \n-            --  Record new max usage\n+      if Stack.Max - Stack.Top < Mem_Request then\n \n-            if Stack.Top > Stack.Max then\n-               Stack.Max := Stack.Top;\n-            end if;\n+         --  Check if the stack will be exceeded. Note that Stack.Top points to\n+         --  the first free byte, therefore the Stack.Top of a fully allocated\n+         --  stack is equal to Stack.Size + 1. This check prevents overflow.\n \n-         end;\n+         if Stack.Size - Stack.Top + 1 < Mem_Request then\n+            raise Storage_Error;\n+         end if;\n+\n+         --  Record new max usage\n+\n+         Stack.Max := Stack.Top + Mem_Request;\n       end if;\n-   end SS_Allocate;\n+\n+      --  Set resulting address and update top of stack pointer\n+      --\n+      --        Addr   Top\n+      --        |      |\n+      --    +-------------------+\n+      --    |##########|        |\n+      --    +-------------------+\n+      --              ^\n+      --        Internal_Chunk\n+\n+      Addr      := Stack.Internal_Chunk.Mem (Stack.Top)'Address;\n+      Stack.Top := Stack.Top + Mem_Request;\n+   end SS_Allocate_Static;\n \n    -------------\n    -- SS_Free --\n    -------------\n \n    procedure SS_Free (Stack : in out SS_Stack_Ptr) is\n       procedure Free is\n-         new Ada.Unchecked_Deallocation (SS_Stack, SS_Stack_Ptr);\n+        new Ada.Unchecked_Deallocation (SS_Stack, SS_Stack_Ptr);\n+\n+      Chunk : Chunk_Ptr;\n+\n    begin\n       --  If using dynamic secondary stack, free any external chunks\n \n       if SP.Sec_Stack_Dynamic then\n-         declare\n-            Chunk : Chunk_Ptr;\n+         Chunk := Stack.Current_Chunk;\n \n-            procedure Free is\n-              new Ada.Unchecked_Deallocation (Chunk_Id, Chunk_Ptr);\n+         --  Go to top of linked list and free backwards. Do not free the\n+         --  internal chunk as it is part of SS_Stack.\n \n-         begin\n-            Chunk := Stack.Current_Chunk;\n-\n-            --  Go to top of linked list and free backwards. Do not free the\n-            --  internal chunk as it is part of SS_Stack.\n-\n-            while Chunk.Next /= null loop\n-               Chunk := Chunk.Next;\n-            end loop;\n+         while Chunk.Next /= null loop\n+            Chunk := Chunk.Next;\n+         end loop;\n \n-            while Chunk.Prev /= null loop\n-               Chunk := Chunk.Prev;\n-               Free (Chunk.Next);\n-            end loop;\n-         end;\n+         while Chunk.Prev /= null loop\n+            Chunk := Chunk.Prev;\n+            Free (Chunk.Next);\n+         end loop;\n       end if;\n \n       if Stack.Freeable then\n@@ -224,7 +425,8 @@ package body System.Secondary_Stack is\n    ----------------\n \n    function SS_Get_Max return Long_Long_Integer is\n-      Stack : constant SS_Stack_Ptr := SSL.Get_Sec_Stack.all;\n+      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n+\n    begin\n       --  Stack.Max points to the first untouched byte in the stack, thus the\n       --  maximum number of bytes that have been allocated on the stack is one\n@@ -238,7 +440,7 @@ package body System.Secondary_Stack is\n    -------------\n \n    procedure SS_Info is\n-      Stack : constant SS_Stack_Ptr := SSL.Get_Sec_Stack.all;\n+      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n    begin\n       Put_Line (\"Secondary Stack information:\");\n \n@@ -257,8 +459,8 @@ package body System.Secondary_Stack is\n \n       else\n          declare\n-            Nb_Chunks : Integer   := 1;\n             Chunk     : Chunk_Ptr := Stack.Current_Chunk;\n+            Nb_Chunks : Integer   := 1;\n \n          begin\n             while Chunk.Prev /= null loop\n@@ -273,8 +475,9 @@ package body System.Secondary_Stack is\n             --  Current Chunk information\n \n             --  Note that First of each chunk is one more than Last of the\n-            --  previous one, so Chunk.Last is the total size of all chunks; we\n-            --  don't need to walk all the chunks to compute the total size.\n+            --  previous one, so Chunk.Last is the total size of all chunks;\n+            --  we do not need to walk all the chunks to compute the total\n+            --  size.\n \n             Put_Line (\"  Total size              : \"\n                       & SS_Ptr'Image (Chunk.Last)\n@@ -301,9 +504,8 @@ package body System.Secondary_Stack is\n      (Stack : in out SS_Stack_Ptr;\n       Size  : SP.Size_Type := SP.Unspecified_Size)\n    is\n-      use Parameters;\n-\n       Stack_Size : Size_Type;\n+\n    begin\n       --  If Stack is not null then the stack has been allocated outside the\n       --  package (by the compiler or the user) and all that is left to do is\n@@ -317,6 +519,7 @@ package body System.Secondary_Stack is\n \n       if Stack = null then\n          if Size = Unspecified_Size then\n+\n             --  Cover the case when bootstraping with an old compiler that does\n             --  not set Default_SS_Size.\n \n@@ -393,7 +596,8 @@ package body System.Secondary_Stack is\n    -------------\n \n    function SS_Mark return Mark_Id is\n-      Stack : constant SS_Stack_Ptr := SSL.Get_Sec_Stack.all;\n+      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n+\n    begin\n       return (Sec_Stack => Stack, Sptr => Stack.Top);\n    end SS_Mark;"}, {"sha": "b48eaec980c1f829390527d74bbe5d807aedd17a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25eadeeaa2a0da50bd591c38de899140a413323e", "patch": "@@ -1,3 +1,7 @@\n+2018-05-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/sec_stack2.adb: New testcase.\n+\n 2018-05-25  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/interface6.adb: New testcase."}, {"sha": "d07f45c6bd7447eea76f70579fc3e2f3919b9070", "filename": "gcc/testsuite/gnat.dg/sec_stack2.adb", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Ftestsuite%2Fgnat.dg%2Fsec_stack2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25eadeeaa2a0da50bd591c38de899140a413323e/gcc%2Ftestsuite%2Fgnat.dg%2Fsec_stack2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsec_stack2.adb?ref=25eadeeaa2a0da50bd591c38de899140a413323e", "patch": "@@ -0,0 +1,90 @@\n+--  { dg-do run }\n+--  { dg-options \"-gnatws\" }\n+\n+with Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;\n+with Ada.Text_IO;            use Ada.Text_IO;\n+with System.Parameters;      use System.Parameters;\n+with System.Secondary_Stack; use System.Secondary_Stack;\n+\n+procedure Sec_Stack2 is\n+   procedure Overflow_SS_Index;\n+   --  Create a scenario where the frame index of the secondary stack overflows\n+   --  while the stack itself uses little memory.\n+\n+   -----------------------\n+   -- Overflow_SS_Index --\n+   -----------------------\n+\n+   procedure Overflow_SS_Index is\n+      Max_Iterations : constant := 20_000;\n+      --  The approximate number of iterations needed to overflow the frame\n+      --  index type on a 64bit target.\n+\n+      Algn : constant Positive := Positive (Standard'Maximum_Alignment);\n+      --  The maximum alignment of the target\n+\n+      Size : constant Positive := Positive (Runtime_Default_Sec_Stack_Size);\n+      --  The default size of the secondary stack on the target\n+\n+      Base_Str : constant String (1 .. Size) := (others => 'a');\n+      --  A string big enough to fill the static frame of the secondary stack\n+\n+      Small_Str : constant String (1 .. Algn) := (others => 'a');\n+      --  A string small enough to cause a new round up to the nearest multiple\n+      --  of the maximum alignment on the target at each new iteration of the\n+      --  loop.\n+\n+      Base_US : Unbounded_String := To_Unbounded_String (Base_Str);\n+      --  Unbounded version of the base string\n+\n+      procedure SS_Print is new SS_Info (Put_Line);\n+\n+   begin\n+      for Iteration in 1 .. Max_Iterations loop\n+\n+          --  Grow the base string by a small amount at each iteration of the\n+          --  loop.\n+\n+          Append (Base_US, Small_Str);\n+\n+          --  Convert the unbounded base into a new base. This causes routine\n+          --  To_String to allocates the new base on the secondary stack. Since\n+          --  the new base is slignly bigger than the previous base, the stack\n+          --  would have to create a new frame.\n+\n+          --  Due to an issue with frame reclamation, the last frame (which is\n+          --  also not big enough to fit the new base) is never reclaimed. This\n+          --  causes the range of the new frame to shift toward the overflow\n+          --  point of the frame index type.\n+\n+          begin\n+             declare\n+                New_Base_Str : constant String := To_String (Base_US);\n+             begin null; end;\n+\n+          exception\n+             when Storage_Error =>\n+                Put_Line (\"ERROR: SS depleted\");\n+                Put_Line (\"Iteration:\" & Iteration'Img);\n+                Put_Line (\"SS_Size  :\" & Size'Img);\n+                Put_Line (\"SS_Algn  :\" & Algn'Img);\n+\n+                SS_Print;\n+                exit;\n+\n+             when others =>\n+                Put_Line (\"ERROR: unexpected exception\");\n+                exit;\n+          end;\n+      end loop;\n+   end Overflow_SS_Index;\n+\n+--  Start of processing for SS_Depletion\n+\n+begin\n+   --  This issue manifests only on targets with a dynamic secondary stack\n+\n+   if Sec_Stack_Dynamic then\n+      Overflow_SS_Index;\n+   end if;\n+end Sec_Stack2;"}]}