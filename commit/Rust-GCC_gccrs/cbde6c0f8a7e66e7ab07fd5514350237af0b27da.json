{"sha": "cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JkZTZjMGY4YTdlNjZlN2FiMDdmZDU1MTQzNTAyMzdhZjBiMjdkYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-03-31T09:52:01Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-03-31T09:52:01Z"}, "message": "2013-03-31  Tobias Burnus  <burnus@net-b.de>\n\n        * class.c (finalization_scalarizer,\n        * finalizer_insert_packed_call,\n        generate_finalization_wrapper): Avoid segfault with absent SIZE=\n        argment to TRANSFER and use correct result kind for SIZE.\n        * intrinsic.c (gfc_isym_id_by_intmod): Also handle ids of\n        nonmodules.\n        * trans.c (gfc_build_final_call): Handle coarrays.\n\nFrom-SVN: r197281", "tree": {"sha": "ebc1007627c0a3cb951bfc2f5965ec9dba0181db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebc1007627c0a3cb951bfc2f5965ec9dba0181db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a38b34f18e6d518689d109a86dbf5084d11b4140", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38b34f18e6d518689d109a86dbf5084d11b4140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38b34f18e6d518689d109a86dbf5084d11b4140"}], "stats": {"total": 83, "additions": 55, "deletions": 28}, "files": [{"sha": "92a5f00c0a29597fc765393a68f6ccce63f547e7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "patch": "@@ -1,3 +1,12 @@\n+2013-03-31  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* class.c (finalization_scalarizer, finalizer_insert_packed_call,\n+\tgenerate_finalization_wrapper): Avoid segfault with absent SIZE=\n+\targment to TRANSFER and use correct result kind for SIZE.\n+\t* intrinsic.c (gfc_isym_id_by_intmod): Also handle ids of\n+\tnonmodules.\n+\t* trans.c (gfc_build_final_call): Handle coarrays.\n+\n 2013-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* trans-expr.c (build_memcmp_call):  New function."}, {"sha": "42c7fa6a5dbaf36d69c11d59e6b0ae18884714ca", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "patch": "@@ -956,15 +956,18 @@ finalization_scalarizer (gfc_symbol *array, gfc_symbol *ptr,\n   block->resolved_sym = block->symtree->n.sym;\n   block->resolved_sym->attr.flavor = FL_PROCEDURE;\n   block->resolved_sym->attr.intrinsic = 1;\n+  block->resolved_sym->attr.subroutine = 1;\n   block->resolved_sym->from_intmod = INTMOD_ISO_C_BINDING;\n   block->resolved_sym->intmod_sym_id = ISOCBINDING_F_POINTER;\n+  block->resolved_isym = gfc_intrinsic_subroutine_by_id (GFC_ISYM_C_F_POINTER);\n   gfc_commit_symbol (block->resolved_sym);\n \n   /* C_F_POINTER's first argument: TRANSFER ( <addr>, c_intptr_t).  */\n   block->ext.actual = gfc_get_actual_arglist ();\n   block->ext.actual->next = gfc_get_actual_arglist ();\n   block->ext.actual->next->expr = gfc_get_int_expr (gfc_index_integer_kind,\n \t\t\t\t\t\t    NULL, 0);\n+  block->ext.actual->next->next = gfc_get_actual_arglist (); /* SIZE. */\n \n   /* The <addr> part: TRANSFER (C_LOC (array), c_intptr_t).  */\n \n@@ -976,7 +979,7 @@ finalization_scalarizer (gfc_symbol *array, gfc_symbol *ptr,\n   expr->symtree->n.sym->intmod_sym_id = ISOCBINDING_LOC;\n   expr->symtree->n.sym->attr.intrinsic = 1;\n   expr->symtree->n.sym->from_intmod = INTMOD_ISO_C_BINDING;\n-  expr->value.function.esym = expr->symtree->n.sym;\n+  expr->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_C_LOC);\n   expr->value.function.actual = gfc_get_actual_arglist ();\n   expr->value.function.actual->expr\n \t    = gfc_lval_expr_from_sym (array);\n@@ -987,9 +990,9 @@ finalization_scalarizer (gfc_symbol *array, gfc_symbol *ptr,\n \n   /* TRANSFER.  */\n   expr2 = gfc_build_intrinsic_call (sub_ns, GFC_ISYM_TRANSFER, \"transfer\",\n-\t\t\t\t    gfc_current_locus, 2, expr,\n+\t\t\t\t    gfc_current_locus, 3, expr,\n \t\t\t\t    gfc_get_int_expr (gfc_index_integer_kind,\n-\t\t\t\t\t\t      NULL, 0));\n+\t\t\t\t\t\t      NULL, 0), NULL);\n   expr2->ts.type = BT_INTEGER;\n   expr2->ts.kind = gfc_index_integer_kind;\n \n@@ -1200,9 +1203,9 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   size_expr->value.op.op1\n \t= gfc_build_intrinsic_call (sub_ns, GFC_ISYM_STORAGE_SIZE,\n \t\t\t\t    \"storage_size\", gfc_current_locus, 2,\n-\t\t\t\t    gfc_lval_expr_from_sym (array));\n+\t\t\t\t    gfc_lval_expr_from_sym (array),\n \t\t\t\t    gfc_get_int_expr (gfc_index_integer_kind,\n-\t\t\t\t\t\t      NULL, 0);\n+\t\t\t\t\t\t      NULL, 0));\n \n   /* NUMERIC_STORAGE_SIZE.  */\n   size_expr->value.op.op2 = gfc_get_int_expr (gfc_index_integer_kind, NULL,\n@@ -1215,7 +1218,6 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n \t\t\t|| is_contiguous)\n \t\t   || 0 == size_expr.  */\n   block->expr1 = gfc_get_expr ();\n-  block->expr1->expr_type = EXPR_FUNCTION;\n   block->expr1->ts.type = BT_LOGICAL;\n   block->expr1->ts.kind = gfc_default_logical_kind;\n   block->expr1->expr_type = EXPR_OP;\n@@ -1234,8 +1236,9 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n \t= gfc_lval_expr_from_sym (byte_stride);\n   expr->value.op.op2 = size_expr;\n \n-  /* If strides aren't allowd (not assumed shape or CONTIGUOUS),\n+  /* If strides aren't allowed (not assumed shape or CONTIGUOUS),\n      add is_contiguous check.  */\n+\n   if (fini->proc_tree->n.sym->formal->sym->as->type != AS_ASSUMED_SHAPE\n       || fini->proc_tree->n.sym->formal->sym->attr.contiguous)\n     {\n@@ -1315,15 +1318,17 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n       gfc_expr *shape_expr;\n       tmp_array->as->lower[i] = gfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\t  NULL, 1);\n-      /* SIZE (array, dim=i+1, kind=default_kind).  */\n+      /* SIZE (array, dim=i+1, kind=gfc_index_integer_kind).  */\n       shape_expr\n \t= gfc_build_intrinsic_call (sub_ns, GFC_ISYM_SIZE, \"size\",\n \t\t\t\t    gfc_current_locus, 3,\n \t\t\t\t    gfc_lval_expr_from_sym (array),\n \t\t\t\t    gfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\t      NULL, i+1),\n \t\t\t\t    gfc_get_int_expr (gfc_default_integer_kind,\n-\t\t\t\t\t\t      NULL, 0));\n+\t\t\t\t\t\t      NULL,\n+\t\t\t\t\t\t      gfc_index_integer_kind));\n+      shape_expr->ts.kind = gfc_index_integer_kind;\n       tmp_array->as->upper[i] = shape_expr;\n     }\n   gfc_set_sym_referenced (tmp_array);\n@@ -1346,7 +1351,6 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n \n   /* Offset calculation for the new array: idx * size of type (in bytes).  */\n   offset2 = gfc_get_expr ();\n-  offset2 = block->ext.actual->expr;\n   offset2->expr_type = EXPR_OP;\n   offset2->value.op.op = INTRINSIC_TIMES;\n   offset2->value.op.op1 = gfc_lval_expr_from_sym (idx);\n@@ -1365,13 +1369,15 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n \t\t\t\t\t  sub_ns);\n   block2 = block2->next;\n   block2->next = finalization_scalarizer (tmp_array, ptr2, offset2, sub_ns);\n+  block2 = block2->next;\n \n   /* ptr2 = ptr.  */\n   block2->next = XCNEW (gfc_code);\n-  block2->next->op = EXEC_ASSIGN;\n-  block2->next->loc = gfc_current_locus;\n-  block2->next->expr1 = gfc_lval_expr_from_sym (ptr2);\n-  block2->next->expr2 = gfc_lval_expr_from_sym (ptr);\n+  block2 = block2->next;\n+  block2->op = EXEC_ASSIGN;\n+  block2->loc = gfc_current_locus;\n+  block2->expr1 = gfc_lval_expr_from_sym (ptr2);\n+  block2->expr2 = gfc_lval_expr_from_sym (ptr);\n \n   /* Call now the user's final subroutine. */\n   block->next  = XCNEW (gfc_code);\n@@ -1414,7 +1420,8 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n \t\t\t\t\t  gfc_lval_expr_from_sym (offset),\n \t\t\t\t\t  sub_ns);\n   block2 = block2->next;\n-  block2->next = finalization_scalarizer (tmp_array, ptr2, offset2, sub_ns);\n+  block2->next = finalization_scalarizer (tmp_array, ptr2,\n+\t\t\t\t\t  gfc_copy_expr (offset2), sub_ns);\n   block2 = block2->next;\n \n   /* ptr = ptr2.  */\n@@ -1799,7 +1806,9 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t\t\t\t    gfc_lval_expr_from_sym (array),\n \t\t\t\t    gfc_lval_expr_from_sym (idx),\n \t\t\t\t    gfc_get_int_expr (gfc_index_integer_kind,\n-\t\t\t\t\t\t      NULL, 0));\n+\t\t\t\t\t\t      NULL,\n+\t\t\t\t\t\t      gfc_index_integer_kind));\n+  block->expr2->value.op.op2->ts.kind = gfc_index_integer_kind;\n   block->expr2->ts = idx->ts;\n \n   /* if (strides(idx) /= sizes(idx-1)) is_contiguous = .false.  */\n@@ -1960,7 +1969,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t    block->ext.block.case_list->low\n \t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n \t  block->ext.block.case_list->high\n-\t\t= block->ext.block.case_list->low;\n+\t\t= gfc_copy_expr (block->ext.block.case_list->low);\n \n \t  /* CALL fini_rank (array) - possibly with packing.  */\n           if (fini->proc_tree->n.sym->formal->sym->attr.dimension)"}, {"sha": "64df29656844f5103edee557f345afe3be995ee9", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "patch": "@@ -813,7 +813,9 @@ find_sym (gfc_intrinsic_sym *start, int n, const char *name)\n gfc_isym_id\n gfc_isym_id_by_intmod (intmod_id from_intmod, int intmod_sym_id)\n {\n-  if (from_intmod == INTMOD_ISO_C_BINDING)\n+  if (from_intmod == INTMOD_NONE)\n+    return (gfc_isym_id) intmod_sym_id;\n+  else if (from_intmod == INTMOD_ISO_C_BINDING)\n     return (gfc_isym_id) c_interop_kinds_table[intmod_sym_id].value;\n   else if (from_intmod == INTMOD_ISO_FORTRAN_ENV)\n     switch (intmod_sym_id)\n@@ -829,9 +831,7 @@ gfc_isym_id_by_intmod (intmod_id from_intmod, int intmod_sym_id)\n \tgcc_unreachable ();\n       }\n   else\n-    {\n-      gcc_unreachable ();\n-    }\n+    gcc_unreachable ();\n   return (gfc_isym_id) 0;\n }\n "}, {"sha": "8211573e1b396f3caf296cfe0946b2984df0d0b0", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbde6c0f8a7e66e7ab07fd5514350237af0b27da/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=cbde6c0f8a7e66e7ab07fd5514350237af0b27da", "patch": "@@ -1031,6 +1031,7 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n   stmtblock_t block;\n   gfc_se se;\n   tree final_fndecl, array, size, tmp;\n+  symbol_attribute attr;\n \n   gcc_assert (final_wrapper->expr_type == EXPR_VARIABLE);\n   gcc_assert (var);\n@@ -1041,6 +1042,8 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n   if (POINTER_TYPE_P (TREE_TYPE (final_fndecl)))\n     final_fndecl = build_fold_indirect_ref_loc (input_location, final_fndecl);\n \n+  attr = gfc_expr_attr (var);\n+\n   if (ts.type == BT_DERIVED)\n     {\n       tree elem_size;\n@@ -1052,8 +1055,12 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n \n       gfc_init_se (&se, NULL);\n       se.want_pointer = 1;\n-      if (var->rank || gfc_expr_attr (var).dimension)\n+      if (var->rank || attr.dimension\n+\t  || (attr.codimension && attr.allocatable\n+\t      && gfc_option.coarray == GFC_FCOARRAY_LIB))\n \t{\n+\t  if (var->rank == 0)\n+\t    se.want_coarray = 1;\n \t  se.descriptor_only = 1;\n \t  gfc_conv_expr_descriptor (&se, var);\n \t  array = se.expr;\n@@ -1062,7 +1069,6 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n \t}\n       else\n \t{\n-\t  symbol_attribute attr;\n \t  gfc_clear_attr (&attr);\n \t  gfc_conv_expr (&se, var);\n \t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n@@ -1087,22 +1093,25 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,\n       size = se.expr;\n \n       array_expr = gfc_copy_expr (var);\n-      gfc_add_data_component (array_expr);\n       gfc_init_se (&se, NULL);\n       se.want_pointer = 1;\n-      if (array_expr->rank || gfc_expr_attr (array_expr).dimension)\n+      if (array_expr->rank || attr.dimension\n+\t  || (attr.codimension && attr.allocatable\n+\t      && gfc_option.coarray == GFC_FCOARRAY_LIB))\n \t{\n+\t  gfc_add_class_array_ref (array_expr);\n+\t  if (array_expr->rank == 0)\n+\t    se.want_coarray = 1;\n \t  se.descriptor_only = 1;\n-\t  gfc_conv_expr_descriptor (&se, var);\n+\t  gfc_conv_expr_descriptor (&se, array_expr);\n \t  array = se.expr;\n \t  if (! POINTER_TYPE_P (TREE_TYPE (array)))\n \t    array = gfc_build_addr_expr (NULL, array);\n \t}\n       else\n \t{\n-\t  symbol_attribute attr;\n-\n \t  gfc_clear_attr (&attr);\n+\t  gfc_add_data_component (array_expr);\n \t  gfc_conv_expr (&se, array_expr);\n \t  gcc_assert (se.pre.head == NULL_TREE && se.post.head == NULL_TREE);\n \t  array = se.expr;"}]}