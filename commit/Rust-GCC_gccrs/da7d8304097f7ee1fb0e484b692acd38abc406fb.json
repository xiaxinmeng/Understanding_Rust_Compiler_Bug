{"sha": "da7d8304097f7ee1fb0e484b692acd38abc406fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3ZDgzMDQwOTdmN2VlMWZiMGU0ODRiNjkyYWNkMzhhYmM0MDZmYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-22T02:03:17Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-22T02:03:17Z"}, "message": "ChangeLog: Follow spelling conventions.\n\n\t* ChangeLog: Follow spelling conventions.\n\t* ChangeLog.0: Likewise.\n\t* ChangeLog.1: Likewise.\n\t* ChangeLog.2: Likewise.\n\t* ChangeLog.3: Likewise.\n\t* ChangeLog.4: Likewise.\n\t* ChangeLog.5: Likewise.\n\t* ChangeLog.6: Likewise.\n\t* FSFChangeLog.10: Likewise.\n\t* FSFChangeLog.11: Likewise.\n\t* alias.c: Likewise.\n\t* basic-block.h: Likewise.\n\t* c-aux-info.c: Likewise.\n\t* c-common.c: Likewise.\n\t* c-common.h: Likewise.\n\t* c-decl.c: Likewise.\n\t* c-format.c: Likewise.\n\t* c-semantics.c: Likewise.\n\t* c-typeck.c: Likewise.\n\t* calls.c: Likewise.\n\t* cfganal.c: Likewise.\n\t* cfgloop.c: Likewise.\n\t* collect2.c: Likewise.\n\t* combine.c: Likewise.\n\t* conflict.c: Likewise.\n\t* cppexp.c: Likewise.\n\t* cppfiles.c: Likewise.\n\t* cpphash.h: Likewise.\n\t* cppinit.c: Likewise.\n\t* cpplex.c: Likewise.\n\t* cpplib.c: Likewise.\n\t* cpplib.h: Likewise.\n\t* cppmacro.c: Likewise.\n\t* cse.c: Likewise.\n\nFrom-SVN: r57398", "tree": {"sha": "46c3473e2a4ca056cf463861491452bb0f47b6a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46c3473e2a4ca056cf463861491452bb0f47b6a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da7d8304097f7ee1fb0e484b692acd38abc406fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7d8304097f7ee1fb0e484b692acd38abc406fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da7d8304097f7ee1fb0e484b692acd38abc406fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7d8304097f7ee1fb0e484b692acd38abc406fb/comments", "author": null, "committer": null, "parents": [{"sha": "330cc6c7b82eb339ca4af2f7fd10918bb705f69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330cc6c7b82eb339ca4af2f7fd10918bb705f69d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/330cc6c7b82eb339ca4af2f7fd10918bb705f69d"}], "stats": {"total": 323, "additions": 180, "deletions": 143}, "files": [{"sha": "59176736c3eb304fffa3eab2a505c6c36e0a430d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -1,3 +1,40 @@\n+2002-09-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* ChangeLog: Follow spelling conventions.\n+\t* ChangeLog.0: Likewise.\n+\t* ChangeLog.1: Likewise.\n+\t* ChangeLog.2: Likewise.\n+\t* ChangeLog.3: Likewise.\n+\t* ChangeLog.4: Likewise.\n+\t* ChangeLog.5: Likewise.\n+\t* ChangeLog.6: Likewise.\n+\t* FSFChangeLog.10: Likewise.\n+\t* FSFChangeLog.11: Likewise.\n+\t* alias.c: Likewise.\n+\t* basic-block.h: Likewise.\n+\t* c-aux-info.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-common.h: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-format.c: Likewise.\n+\t* c-semantics.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* cfganal.c: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* collect2.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* conflict.c: Likewise.\n+\t* cppexp.c: Likewise.\n+\t* cppfiles.c: Likewise.\n+\t* cpphash.h: Likewise.\n+\t* cppinit.c: Likewise.\n+\t* cpplex.c: Likewise.\n+\t* cpplib.c: Likewise.\n+\t* cpplib.h: Likewise.\n+\t* cppmacro.c: Likewise.\n+\t* cse.c: Likewise.\n+\n 2002-09-21  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* netbsd-aout.h (NETBSD_LINK_SPEC_AOUT): New, takes old definition of\n@@ -6080,7 +6117,7 @@ Wed Jul 17 17:08:06 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \tAdd DF_HI_REGS.\n \t(CLASS_CANNOT_CHANGE_MODE, CLASS_CANNOT_CHANGE_MODE_P): Allow\n \tlowpart fp regs - only for big endian for now.\n-\t(LEGITIMATE_CONSTANT_P): Don't allow non-zero float vectors\n+\t(LEGITIMATE_CONSTANT_P): Don't allow nonzero float vectors\n \twhen FPU is in use.\n \t(EXTRA_CONTRAINT_U): Check against CONST0_RTX.\n \t(LOAD_EXTEND_OP): NIL for SImode.\n@@ -11123,7 +11160,7 @@ Tue Jun  4 19:29:42 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* gengtype.c (get_output_file): Include headers in gtype-desc.c\n \texplicitly rather than deducing them from file names.\n \t(write_gc_structure_fields): Handle arrays of structures.\n-\t(main): Return non-zero exit code if errors occur during output.\n+\t(main): Return nonzero exit code if errors occur during output.\n \t* emit-rtl.c (mem_attrs_mark): Delete.\n \t(init_emit_once): Use canonical name for mem_attrs marker procedure.\n \t* Makefile.in (gtype-desc.o): Explicitly name dependencies.\n@@ -16778,7 +16815,7 @@ Tue Apr 30 09:31:59 2002  Jeffrey A Law  (law@redhat.com)\n \t2001-10-02  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* haifa-sched.c (max_issue): Remove last_p argument.  Only return\n-\tnon-zero if the highest-priority instruction could be scheduled.\n+\tnonzero if the highest-priority instruction could be scheduled.\n \t(choose_ready): Remove last argument from max_issue call.\n \n \t2001-09-28  David S. Miller  <davem@redhat.com>\n@@ -22348,7 +22385,7 @@ Tue Mar  5 18:31:27 CET 2002  Jan Hubicka  <jh@suse.cz>\n \t(LINK_SPEC): Don't defsym __.MMIX.start..text if linking\n \trelocatably.  Always produce ELF, not mmo if linking relocatably.\n \t* config/mmix/mmix.c (mmix_encode_section_info): If new parameter\n-\tfirst is non-zero, don't add symbol prefix.\n+\tfirst is nonzero, don't add symbol prefix.\n \t* config/mmix/mmix-protos.h (mmix_encode_section_info): Tweak\n \tprototype accordingly.\n \n@@ -23408,7 +23445,7 @@ Thu Feb 21 15:35:46 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \tPR c/4389\n \t* tree.c (host_integerp): Ensure that the constant integer is\n \trepresentable in a HOST_WIDE_INT or an unsigned HOST_WIDE_INT\n-\twhen pos is zero or non-zero respectively.  Clarify comment.\n+\twhen pos is zero or nonzero respectively.  Clarify comment.\n \t* c-format.c (check_format_info_recurse): Fix host_integerp\n \tusage; the pos argument should be zero when assigning to a\n \tsigned HOST_WIDE_INT.\n@@ -27558,7 +27595,7 @@ Fri Jan 11 09:25:05 2002  Nicola Pero  <n.pero@mi.flashnet.it>\n \t* config/alpha/alpha.md (call_osf_1_er, call_value_osf_1_er): Take a\n \tnew operand with the sequence number for the lituse.  When splitting\n \tthe insns, use gen_movdi_er_high_g and generate a sequence number.\n-\t(gen_movdi_er_high_g): Print the sequence number if non-zero.\n+\t(gen_movdi_er_high_g): Print the sequence number if nonzero.\n \n 2002-01-10  Aldy Hernandez  <aldyh@redhat.com>\n \n@@ -27727,7 +27764,7 @@ Thu Jan 10 22:35:54 CET 2002  Jan Hubicka  <jh@suse.cz>\n \t* alias.c (find_base_value): Add cases for HIGH, PRE_INC, PRE_DEC,\n \tPOST_INC, POST_DEC, PRE_MODIFY, and POST_MODIFY.\n \t(find_base_term): Add cases for TRUNCATE, PRE_MODIFY, and POST_MODIFY.\n-\tRecurse for any operand of AND as long as constant is non-zero.\n+\tRecurse for any operand of AND as long as constant is nonzero.\n \n 2002-01-10  Kazu Hirata  <kazu@hxi.com>\n "}, {"sha": "4ed06520ca47e535201f23b62694b3bb590c96ba", "filename": "gcc/ChangeLog.0", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.0", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.0", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.0?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -6574,8 +6574,8 @@ Wed Mar 11 12:05:20 1998  Teemu Torma  <tot@trema.com>\n \t* gthr.h: Changed the comment about return values.\n \t* gthr-solaris.h (__gthread_once): Do not use errno; return the\n \terror number instead of -1.\n-\t(__gthread_key_create): Any non-zero return value is an error.\n-\t* libgcc2.c (eh_context_initialize): Check for non-zero return\n+\t(__gthread_key_create): Any nonzero return value is an error.\n+\t* libgcc2.c (eh_context_initialize): Check for nonzero return\n \tvalue from __gthread_once.\n \tCheck that the value of get_eh_context was really changed.\n \n@@ -10440,7 +10440,7 @@ Tue Nov  4 20:36:50 1997  Richard Henderson  (rth@cygnus.com)\n \n \t* alpha.c (alpha_handle_trap_shadows): Init sum.defd to zero.\n \n-\t* alpha.md (attr trap): Make TRAP_YES non-zero for sanity's sake.\n+\t* alpha.md (attr trap): Make TRAP_YES nonzero for sanity's sake.\n \n Tue Nov  4 18:49:42 1997  Jeffrey A Law  (law@cygnus.com)\n "}, {"sha": "d22f0bf7ab23447e9a3051df19ca1c7a2cd0f2ad", "filename": "gcc/ChangeLog.1", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.1?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -2152,7 +2152,7 @@ Fri Apr  2 12:58:26 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n Fri Apr  2 12:19:17 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (*db): Enable pattern if TARGET_LOOP_UNSIGNED\n-\tis non-zero.\n+\tis nonzero.\n \t(movstrqi_small, movstrqi_large, *cmpstrqi): Add + modifier to address\n \tregister constraints.\n \t(*movhi_clobber+1): Modify splitter pattern to handle destination\n@@ -5184,10 +5184,10 @@ Mon Feb  8 21:31:06 1999  Richard Henderson  <rth@cygnus.com>\n \t(scan_loop): ... moved out of here.  Always initialize.\n \tTest loop_has_call instead of reg_single_usage not zero.\n \tFree reg_single_usage after strength reduction.\n-\t(count_loop_regs_set): Assume single_usage non-zero.\n+\t(count_loop_regs_set): Assume single_usage nonzero.\n \t(combine_givs_used_by_other): Test reg_single_usage.\n \t(load_mems_and_recount_loop_regs_set): Remove reg_single_usage\n-\tas a parameter.  Assume non-zero.\n+\tas a parameter.  Assume nonzero.\n \n 1999-02-08  Zack Weinberg  <zack@midnite.ec.rhno.columbia.edu>\n \n@@ -10282,7 +10282,7 @@ Wed Oct 28 16:46:07 1998  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>\n Wed Oct 28 14:06:49 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* dwarfout.c (dwarfout_file_scope_decl): If DECL_CONTEXT, don't abort\n-\tif pending_types is non-zero.\n+\tif pending_types is nonzero.\n \t(dwarfout_finish): Verify pending_types is zero before finishing.\n \n Wed Oct 28 10:29:09 1998  Nick Clifton  <nickc@cygnus.com>\n@@ -11967,7 +11967,7 @@ Fri Oct  9 14:26:44 1998  Jeffrey A Law  (law@cygnus.com)\n \n Fri Oct  9 11:44:47 1998  David Edelsohn  <edelsohn@gnu.org>\n \n-\t* loop.c (insert_bct): Ensure loop_iteration_var non-zero before use.\n+\t* loop.c (insert_bct): Ensure loop_iteration_var nonzero before use.\n \n Thu Oct  8 21:59:47 1998  Dave Brolley  <brolley@cygnus.com>\n \n@@ -13059,7 +13059,7 @@ Sat Sep 19 12:05:09 1998  Richard Henderson  <rth@cygnus.com>\n Sat Sep 19 07:33:36 1998  Richard Earnshaw  (rearnsha@arm.com)\n \n \t* arm.c (add_constant): New parameter address_only, change caller.\n-\tSet it non-zero if taking the address of an item in the pool.\n+\tSet it nonzero if taking the address of an item in the pool.\n \t(arm_reorg): Handle cases where we need the address of an item in\n \tthe pool.\n "}, {"sha": "a7cff363cd6c36ae53f404dc0d0e29590366c8ac", "filename": "gcc/ChangeLog.2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.2?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -3567,7 +3567,7 @@ Sat Oct 30 14:31:48 1999  Richard Henderson  <rth@cygnus.com>\n \t(ggc_alloc_obj): Likewise.  Use a different pattern than poison_pages.\n \t(ggc_collect): Poison before sweeping.\n \t* ggc-simple.c: Update pre-function commentary.\n-\t(ggc_alloc_obj): Poison non-zeroed memory.\n+\t(ggc_alloc_obj): Poison nonzeroed memory.\n \n Sat Oct 30 14:28:52 1999  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "067d9adb68f813fe56f580b4ffbd59d5de879cce", "filename": "gcc/ChangeLog.3", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.3?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -1353,7 +1353,7 @@ Wed Jun  7 20:34:33 2000  Denis Chertykov  <denisc@overta.ru>\n \t* c-common.h (c_language_kind): New type.\n \t(c_language): New variab.e\n \t* c-common.c (lang_get_alias_set): Don't put structures in\n-\tnon-zero alias sets in C++.\n+\tnonzero alias sets in C++.\n \t* c-decl.c (c_language): Define it.\n \t* c-lex.c (doing_objc_thang): Remove.\n \t* c-tree.h (doing_objc_thang): Make it a macro.\n@@ -1538,7 +1538,7 @@ Mon Jun  5 06:46:28 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2000-06-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n-\t* Makefile.in (intl.*): Honor non-zero exit codes in the intl\n+\t* Makefile.in (intl.*): Honor nonzero exit codes in the intl\n \tsubdir.\n \n 2000-06-03  Geoff Keating  <geoffk@cygnus.com>\n@@ -7957,7 +7957,7 @@ Wed Apr  5 18:03:31 2000  Toshiyasu Morita  (toshi.morita@sega.com)\n 2000-04-05  Chris Demetriou  <cgd@netbsd.org>\n \n \t* mips.h (MASK_DEBUG_A, MASK_DEBUG_B, MASK_DEBUG_C): Zero the\n-\tremaining non-zero debugging masks.\n+\tremaining nonzero debugging masks.\n \n Wed Apr  5 09:44:07 2000  Jeffrey A Law  (law@cygnus.com)\n "}, {"sha": "0580d7ac8f0d18cc4bb3564da446620aea095305", "filename": "gcc/ChangeLog.4", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.4?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -2120,7 +2120,7 @@ Tue Dec  5 20:09:14 2000  Jeffrey A Law  (law@cygnus.com)\n \t(expand_builtin_strrchr): Use it.\n \t(builtin_memset_read_str): New function.\n \t(expand_builtin_memset): Use target_char_cast.\n-\tTry to optimize memset with second argument non-zero using\n+\tTry to optimize memset with second argument nonzero using\n \tstore_by_pieces.\n \n 2000-11-30  Marek Michalkiewicz  <marekm@linux.org.pl>\n@@ -13799,7 +13799,7 @@ Wed Jul 19 01:22:15 CEST 2000  Marc Espie  <espie@cvs.openbsd.org>\n \n 2000-07-18  Jakub Jelinek  <jakub@redhat.com>\n \n-\t* calls.c (store_arg): Return non-zero if sibcall_failure is desired.\n+\t* calls.c (store_arg): Return nonzero if sibcall_failure is desired.\n \t(expand_call): Adjust caller.\n \n 2000-07-17  Gabriel Dos Reis  <gdr@codesourcery.com>"}, {"sha": "9bd21c1a544fa61d68c2703689b3d8fa90e23dcb", "filename": "gcc/ChangeLog.5", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.5", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.5", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.5?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -2903,7 +2903,7 @@ Thu May 24 15:56:48 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* config/ia64/ia64.md (nonlocal_goto): Reverse label and frame pointer\n \tparameters to __ia64_nonlocal_goto. Flag as NO_RETURN.\n \t* config/ia64/ia64.c (ia64_expand_epilogue): Make sure we are issuing\n-\t\"r2\" to the assembly file. Only issue allocs with non-zero parameters.\n+\t\"r2\" to the assembly file. Only issue allocs with nonzero parameters.\n \n 2001-05-22  Loren J. Rittle  <ljrittle@acm.org>\n \t    David O'Brien  <obrien@freebsd.org>\n@@ -5194,7 +5194,7 @@ Wed Apr 25 17:09:50 2001  J\"orn Rennecke <amylaar@redhat.com>\n 2001-04-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* emit-rtl.c (subreg_hard_regno): Only do HARD_REGNO_MODE_OK check\n-\tif check_mode is non-zero.\n+\tif check_mode is nonzero.\n \n 2001-04-25  Jakub Jelinek  <jakub@redhat.com>\n \n@@ -11558,7 +11558,7 @@ Mon Jan 29 20:38:19 2001  Christopher Faylor <cgf@cygnus.com>\n \t(really_start_incremental_init): Clear it.\n \t(push_init_level): Save constructor_range_stack and clear it if\n \tpushing explicit braces.\n-\t(pop_init_level): abort if constructor_range_stack is non-zero at\n+\t(pop_init_level): abort if constructor_range_stack is nonzero at\n \texplicit closing brace.  Restore saved constructor_range_stack if\n \tnot implicit.\n \n@@ -12652,7 +12652,7 @@ Sat Jan 13 09:53:32 MET 2001  Jan Hubicka  <jh@suse.cz>\n \t(pending_init_member): Rename to...\n \t(find_init_member): ...this function.  Call set_nonincremental_init\n \tif necessary.  Compare values of purpose index trees, not the trees\n-\tthemselves.  Return the actual value, not just non-zero if something\n+\tthemselves.  Return the actual value, not just nonzero if something\n \tis found.\n \t(output_init_element): Remove checks for duplicates.\n \tIf field has zero size, only check the initializer for correctness."}, {"sha": "f311c0719859dbaf61de1b11aab45329c1e83243", "filename": "gcc/ChangeLog.6", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.6", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FChangeLog.6", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.6?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -16219,7 +16219,7 @@ Thu Jul 26 14:04:03 EDT 2001  John Wehle  (john@feith.com)\n \t* flow.c (update_life_info): Simplify the CFG and\n \trecalculate the global regs which are alive when\n \tremoving dead code during a global update.\n-\t(propagate_block): Return non-zero if an INSN is\n+\t(propagate_block): Return nonzero if an INSN is\n \tdeleted.\n \n 2001-07-26  Rainer Orth <ro@TechFak.Uni-Bielefeld.DE>"}, {"sha": "80ad88320d0ab141493adb6b9f653d73262c9b4f", "filename": "gcc/FSFChangeLog.10", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FFSFChangeLog.10", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FFSFChangeLog.10", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FFSFChangeLog.10?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -5704,7 +5704,7 @@ Sun Aug 13 14:50:58 1995  Jim Wilson  <wilson@chestnut.cygnus.com>\n \t* Makefile.in (gfloat.h): Add a - before the rm command.\n \n \t* loop.c (find_and_verify_loops): Set dest_loop only if\n-\tJUMP_LABEL (insn) is non-zero.\n+\tJUMP_LABEL (insn) is nonzero.\n \n Mon Jul 31 14:31:53 1995  Ian Lance Taylor  <ian@cygnus.com>\n \n@@ -8841,7 +8841,7 @@ Sat Apr 15 13:26:34 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n Sat Apr 15 12:11:46 1995  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* alpha/alpha.c (output_epilog): Initialize fp_offset to 0, and\n-\tmake sure it's non-zero before we try to use it to restore the\n+\tmake sure it's nonzero before we try to use it to restore the\n \tframe pointer.\n \n Fri Apr 14 19:45:05 1995  Jason Merrill  <jason@phydeaux.cygnus.com>"}, {"sha": "1614a695f602f1827c5ac54cab6d2899e2767d51", "filename": "gcc/FSFChangeLog.11", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FFSFChangeLog.11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2FFSFChangeLog.11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FFSFChangeLog.11?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -3114,7 +3114,7 @@ Wed Aug 27 20:15:53 1997  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(braf_branch_p, align_length, fixup_addr_diff_vecs): Likewise.\n \t(addr_diff_vec_adjust, get_dest_uid, gen_far_branch): Likewise.\n \t(split_branches, regs_used, gen_block_redirect): Likewise.\n-\t(from_compare): Can't compare non-zero DImode constant directly.\n+\t(from_compare): Can't compare nonzero DImode constant directly.\n \tEmit special code for TARGET_SH3E floating point with code == GE.\n \tForce 0.0 into a register for SH3E.\n \t(print_operand): Add ','.\n@@ -3935,7 +3935,7 @@ Mon Aug  4 08:06:48 1997  Bernd Schmidt  <crux@pool.informatik.rwth-aachen.de>\n \tinteger argument of push_reload.\n \n \t* rtlanal.c (may_trap_p): Fix unintended fall-through so divisions by\n-\tnon-zero constants are handled properly.  Return 1 for FP divisions.\n+\tnonzero constants are handled properly.  Return 1 for FP divisions.\n \n Mon Aug  4 06:52:20 1997  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n \n@@ -5105,7 +5105,7 @@ Thu Jun 19 21:18:20 1997  Jim Wilson  <wilson@cygnus.com>\n \n Thu Jun 19 14:55:49 1997  Brendan Kehoe  <brendan@cygnus.com>\n \n-\t* toplev.c (xmalloc): Only give the fatal msg if SIZE is non-zero.\n+\t* toplev.c (xmalloc): Only give the fatal msg if SIZE is nonzero.\n \n Sun Apr 27 23:19:13 1997  Ulrich Drepper  <drepper@cygnus.com>\n \n@@ -9711,7 +9711,7 @@ Sun Oct 20 20:01:09 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n Fri Oct 18 13:32:13 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n \n \t* rs6000.md (float conversion insns): Generate correct code\n-\tif the bit 15 of rs6000_fpmem_offset is non-zero.\n+\tif the bit 15 of rs6000_fpmem_offset is nonzero.\n \n Thu Oct 17 23:22:03 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n@@ -14430,7 +14430,7 @@ Thu Apr  4 11:40:55 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n \n Wed Apr  3 14:10:16 1996  Jim Wilson  <wilson@chestnut.cygnus.com>\n \n-\t* expr.c (emit_push_insn): Clobber register only if it is non-zero.\n+\t* expr.c (emit_push_insn): Clobber register only if it is nonzero.\n \n Wed Apr  3 11:31:55 1996  Jeffrey A. Law  <law@cygnus.com>\n "}, {"sha": "914b1532e5d7192c6408879d48d3c18af7456cd6", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -2199,8 +2199,8 @@ canon_true_dependence (mem, mem_mode, mem_addr, x, varies)\n \t\t\t\t\t      varies);\n }\n \n-/* Returns non-zero if a write to X might alias a previous read from\n-   (or, if WRITEP is non-zero, a write to) MEM.  */\n+/* Returns nonzero if a write to X might alias a previous read from\n+   (or, if WRITEP is nonzero, a write to) MEM.  */\n \n static int\n write_dependence_p (mem, x, writep)\n@@ -2389,7 +2389,7 @@ nonlocal_mentioned_p_1 (loc, data)\n   return 0;\n }\n \n-/* Returns non-zero if X might mention something which is not\n+/* Returns nonzero if X might mention something which is not\n    local to the function and is not constant.  */\n \n static int\n@@ -2487,7 +2487,7 @@ nonlocal_referenced_p_1 (loc, data)\n   return 0;\n }\n \n-/* Returns non-zero if X might reference something which is not\n+/* Returns nonzero if X might reference something which is not\n    local to the function and is not constant.  */\n \n static int\n@@ -2567,7 +2567,7 @@ nonlocal_set_p_1 (loc, data)\n   return 0;\n }\n \n-/* Returns non-zero if X might set something which is not\n+/* Returns nonzero if X might set something which is not\n    local to the function and is not constant.  */\n \n static int"}, {"sha": "10c895408f22fafc5ee6551f113c7563bb52ee51", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -435,7 +435,7 @@ struct loop\n   /* Link to the next (sibling) loop.  */\n   struct loop *next;\n \n-  /* Non-zero if the loop is invalid (e.g., contains setjmp.).  */\n+  /* Nonzero if the loop is invalid (e.g., contains setjmp.).  */\n   int invalid;\n \n   /* Auxiliary info specific to a pass.  */\n@@ -444,10 +444,10 @@ struct loop\n   /* The following are currently used by loop.c but they are likely to\n      disappear as loop.c is converted to use the CFG.  */\n \n-  /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n+  /* Nonzero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n   rtx vtop;\n \n-  /* Non-zero if the loop has a NOTE_INSN_LOOP_CONT.\n+  /* Nonzero if the loop has a NOTE_INSN_LOOP_CONT.\n      A continue statement will generate a branch to NEXT_INSN (cont).  */\n   rtx cont;\n \n@@ -770,7 +770,7 @@ typedef struct conflict_graph_def *conflict_graph;\n \n /* Callback function when enumerating conflicts.  The arguments are\n    the smaller and larger regno in the conflict.  Returns zero if\n-   enumeration is to continue, non-zero to halt enumeration.  */\n+   enumeration is to continue, nonzero to halt enumeration.  */\n typedef int (*conflict_graph_enum_fn) PARAMS ((int, int, void *));\n \n "}, {"sha": "761fa848606b8cd2e37bd3db130de2586ea3b502", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -188,7 +188,7 @@ gen_formal_list_for_type (fntype, style)\n /* For the generation of an ANSI prototype for a function definition, we have\n    to look at the formal parameter list of the function's own \"type\" to\n    determine if the function's formal parameter list should end with an\n-   ellipsis.  Given a tree node, the following function will return non-zero\n+   ellipsis.  Given a tree node, the following function will return nonzero\n    if the \"function type\" parameter list should end with an ellipsis.  */\n \n static int\n@@ -471,7 +471,7 @@ gen_type (ret_val, t, style)\n \n    The given entity may be either a variable or a function.\n \n-   If the \"is_func_definition\" parameter is non-zero, assume that the thing\n+   If the \"is_func_definition\" parameter is nonzero, assume that the thing\n    we are generating a declaration for is a FUNCTION_DECL node which is\n    associated with a function definition.  In this case, we can assume that\n    an attached list of DECL nodes for function formal arguments is present.  */"}, {"sha": "62458d66ff1deac1e3157c7e63bebe377b11f085", "filename": "gcc/c-common.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -581,26 +581,26 @@ int warn_implicit = 1;\n \n int warn_ctor_dtor_privacy = 1;\n \n-/* Non-zero means warn in function declared in derived class has the\n+/* Nonzero means warn in function declared in derived class has the\n    same name as a virtual in the base class, but fails to match the\n    type signature of any virtual function in the base class.  */\n \n int warn_overloaded_virtual;\n \n-/* Non-zero means warn when declaring a class that has a non virtual\n+/* Nonzero means warn when declaring a class that has a non virtual\n    destructor, when it really ought to have a virtual one.  */\n \n int warn_nonvdtor;\n \n-/* Non-zero means warn when the compiler will reorder code.  */\n+/* Nonzero means warn when the compiler will reorder code.  */\n \n int warn_reorder;\n \n-/* Non-zero means warn when synthesis behavior differs from Cfront's.  */\n+/* Nonzero means warn when synthesis behavior differs from Cfront's.  */\n \n int warn_synth;\n \n-/* Non-zero means warn when we convert a pointer to member function\n+/* Nonzero means warn when we convert a pointer to member function\n    into a pointer to (void or function).  */\n \n int warn_pmf2ptr = 1;\n@@ -2780,12 +2780,12 @@ c_common_truthvalue_conversion (expr)\n     case ABS_EXPR:\n     case FLOAT_EXPR:\n     case FFS_EXPR:\n-      /* These don't change whether an object is non-zero or zero.  */\n+      /* These don't change whether an object is nonzero or zero.  */\n       return c_common_truthvalue_conversion (TREE_OPERAND (expr, 0));\n \n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n-      /* These don't change whether an object is zero or non-zero, but\n+      /* These don't change whether an object is zero or nonzero, but\n \t we can't ignore them if their second arg has side-effects.  */\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n \treturn build (COMPOUND_EXPR, boolean_type_node, TREE_OPERAND (expr, 1),\n@@ -3868,7 +3868,7 @@ expand_tree_builtin (function, params, coerced_params)\n   return NULL_TREE;\n }\n \n-/* Returns non-zero if CODE is the code for a statement.  */\n+/* Returns nonzero if CODE is the code for a statement.  */\n \n int\n statement_code_p (code)"}, {"sha": "f15dbf18bf50377c7624fb1419f691df6180674e", "filename": "gcc/c-common.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -253,12 +253,12 @@ struct stmt_tree_s GTY(()) {\n   tree x_last_expr_type;\n   /* The last filename we recorded.  */\n   const char *x_last_expr_filename;\n-  /* In C++, Non-zero if we should treat statements as full\n+  /* In C++, Nonzero if we should treat statements as full\n      expressions.  In particular, this variable is no-zero if at the\n      end of a statement we should destroy any temporaries created\n      during that statement.  Similarly, if, at the end of a block, we\n      should destroy any local variables in this block.  Normally, this\n-     variable is non-zero, since those are the normal semantics of\n+     variable is nonzero, since those are the normal semantics of\n      C++.\n \n      However, in order to represent aggregate initialization code as\n@@ -751,26 +751,26 @@ extern int warn_implicit;\n \n extern int warn_ctor_dtor_privacy;\n \n-/* Non-zero means warn in function declared in derived class has the\n+/* Nonzero means warn in function declared in derived class has the\n    same name as a virtual in the base class, but fails to match the\n    type signature of any virtual function in the base class.  */\n \n extern int warn_overloaded_virtual;\n \n-/* Non-zero means warn when declaring a class that has a non virtual\n+/* Nonzero means warn when declaring a class that has a non virtual\n    destructor, when it really ought to have a virtual one.  */\n \n extern int warn_nonvdtor;\n \n-/* Non-zero means warn when the compiler will reorder code.  */\n+/* Nonzero means warn when the compiler will reorder code.  */\n \n extern int warn_reorder;\n \n-/* Non-zero means warn when synthesis behavior differs from Cfront's.  */\n+/* Nonzero means warn when synthesis behavior differs from Cfront's.  */\n \n extern int warn_synth;\n \n-/* Non-zero means warn when we convert a pointer to member function\n+/* Nonzero means warn when we convert a pointer to member function\n    into a pointer to (void or function).  */\n \n extern int warn_pmf2ptr;\n@@ -1088,7 +1088,7 @@ extern tree strip_array_types                   PARAMS ((tree));\n #define STMT_LINENO(NODE)\t\t\t\\\n   (TREE_COMPLEXITY ((NODE)))\n \n-/* If non-zero, the STMT_LINENO for NODE is the line at which the\n+/* If nonzero, the STMT_LINENO for NODE is the line at which the\n    function ended.  */\n #define STMT_LINENO_FOR_FN_P(NODE)\t\t\\\n   (TREE_LANG_FLAG_2 ((NODE)))"}, {"sha": "dba2737182eb02c9a2f6825b45d1793fdf1ca43f", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -2691,8 +2691,8 @@ shadow_tag_warned (declspecs, warned)\n /* Construct an array declarator.  EXPR is the expression inside [], or\n    NULL_TREE.  QUALS are the type qualifiers inside the [] (to be applied\n    to the pointer to which a parameter array is converted).  STATIC_P is\n-   non-zero if \"static\" is inside the [], zero otherwise.  VLA_UNSPEC_P\n-   is non-zero is the array is [*], a VLA of unspecified length which is\n+   nonzero if \"static\" is inside the [], zero otherwise.  VLA_UNSPEC_P\n+   is nonzero is the array is [*], a VLA of unspecified length which is\n    nevertheless a complete type (not currently implemented by GCC),\n    zero otherwise.  The declarator is constructed as an ARRAY_REF\n    (to be decoded by grokdeclarator), whose operand 0 is what's on the\n@@ -2725,7 +2725,7 @@ build_array_declarator (expr, quals, static_p, vla_unspec_p)\n \n /* Set the type of an array declarator.  DECL is the declarator, as\n    constructed by build_array_declarator; TYPE is what appears on the left\n-   of the [] and goes in operand 0.  ABSTRACT_P is non-zero if it is an\n+   of the [] and goes in operand 0.  ABSTRACT_P is nonzero if it is an\n    abstract declarator, zero otherwise; this is used to reject static and\n    type qualifiers in abstract declarators, where they are not in the\n    C99 grammar.  */\n@@ -6426,7 +6426,7 @@ c_expand_deferred_function (fndecl)\n     }\n }\n \n-/* Generate the RTL for the body of FNDECL.  If NESTED_P is non-zero,\n+/* Generate the RTL for the body of FNDECL.  If NESTED_P is nonzero,\n    then we are already in the process of generating RTL for another\n    function.  If can_defer_p is zero, we won't attempt to defer the\n    generation of RTL.  */\n@@ -6769,7 +6769,7 @@ c_dup_lang_specific_decl (decl)\n    functions are not called from anywhere in the C front end, but as\n    these changes continue, that will change.  */\n \n-/* Returns non-zero if the current statement is a full expression,\n+/* Returns nonzero if the current statement is a full expression,\n    i.e. temporaries created during that statement should be destroyed\n    at the end of the statement.  */\n "}, {"sha": "a8066df523571547073b697a3d816e795cb09094", "filename": "gcc/c-format.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -439,7 +439,7 @@ typedef struct\n   /* The flag character in question (0 for end of array).  */\n   const int flag_char;\n   /* Zero if this entry describes the flag character in general, or a\n-     non-zero character that may be found in flags2 if it describes the\n+     nonzero character that may be found in flags2 if it describes the\n      flag when used with certain formats only.  If the latter, only\n      the first such entry found that applies to the current conversion\n      specifier is used; the values of `name' and `long_name' it supplies\n@@ -469,11 +469,11 @@ typedef struct\n   const int flag_char1;\n   /* The second flag character.  */\n   const int flag_char2;\n-  /* Non-zero if the message should say that the first flag is ignored with\n+  /* Nonzero if the message should say that the first flag is ignored with\n      the second, zero if the combination should simply be objected to.  */\n   const int ignored;\n   /* Zero if this entry applies whenever this flag combination occurs,\n-     a non-zero character from flags2 if it only applies in some\n+     a nonzero character from flags2 if it only applies in some\n      circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */\n   const int predicate;\n } format_flag_pair;"}, {"sha": "70699a047bcd3692b9dc54871c56b38ef916a162", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -335,7 +335,7 @@ genrtl_expr_stmt (expr)\n    whether to (1) save the value of the expression, (0) discard it or\n    (-1) use expr_stmts_for_value to tell.  The use of -1 is\n    deprecated, and retained only for backward compatibility.\n-   MAYBE_LAST is non-zero if this EXPR_STMT might be the last statement\n+   MAYBE_LAST is nonzero if this EXPR_STMT might be the last statement\n    in expression statement.  */\n \n void "}, {"sha": "1bca1bfb8587ff84bb9d2340ba379a747bf79cdf", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -5555,7 +5555,7 @@ pop_init_level (implicit)\n }\n \n /* Common handling for both array range and field name designators.\n-   ARRAY argument is non-zero for array ranges.  Returns zero for success.  */\n+   ARRAY argument is nonzero for array ranges.  Returns zero for success.  */\n \n static int\n set_designator (array)"}, {"sha": "d4e3f00958934a7444c9940e58f08affc43fab6a", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -91,7 +91,7 @@ struct arg_data\n   /* Number of registers to use.  0 means put the whole arg in registers.\n      Also 0 if not passed in registers.  */\n   int partial;\n-  /* Non-zero if argument must be passed on stack.\n+  /* Nonzero if argument must be passed on stack.\n      Note that some arguments may be passed on the stack\n      even though pass_on_stack is zero, just because FUNCTION_ARG says so.\n      pass_on_stack identifies arguments that *cannot* go in registers.  */\n@@ -126,7 +126,7 @@ struct arg_data\n   struct args_size alignment_pad;\n };\n \n-/* A vector of one char per byte of stack space.  A byte if non-zero if\n+/* A vector of one char per byte of stack space.  A byte if nonzero if\n    the corresponding stack location has been used.\n    This vector is used to prevent a function call within an argument from\n    clobbering any stack already set up.  */\n@@ -1965,7 +1965,7 @@ combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n /* Scan X expression if it does not dereference any argument slots\n    we already clobbered by tail call arguments (as noted in stored_args_map\n    bitmap).\n-   Return non-zero if X expression dereferences such argument slots,\n+   Return nonzero if X expression dereferences such argument slots,\n    zero otherwise.  */\n \n static int\n@@ -2028,7 +2028,7 @@ check_sibcall_argument_overlap_1 (x)\n /* Scan sequence after INSN if it does not dereference any argument slots\n    we already clobbered by tail call arguments (as noted in stored_args_map\n    bitmap).  Add stack slots for ARG to stored_args_map bitmap afterwards.\n-   Return non-zero if sequence after INSN dereferences such argument slots,\n+   Return nonzero if sequence after INSN dereferences such argument slots,\n    zero otherwise.  */\n \n static int\n@@ -4280,7 +4280,7 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value,\n \n    FNDECL is the declaration of the function we are calling.\n \n-   Return non-zero if this arg should cause sibcall failure,\n+   Return nonzero if this arg should cause sibcall failure,\n    zero otherwise.  */\n \n static int"}, {"sha": "bc8fff2510b1fb026a49d1286c10055cb46949eb", "filename": "gcc/cfganal.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -97,7 +97,7 @@ can_fallthru (src, target)\n }\n \f\n /* Mark the back edges in DFS traversal.\n-   Return non-zero if a loop (natural or otherwise) is present.\n+   Return nonzero if a loop (natural or otherwise) is present.\n    Inspired by Depth_First_Search_PP described in:\n \n      Advanced Compiler Design and Implementation\n@@ -370,7 +370,7 @@ flow_call_edges_add (blocks)\n }\n \n /* Find unreachable blocks.  An unreachable block will have 0 in\n-   the reachable bit in block->flags.  A non-zero value indicates the\n+   the reachable bit in block->flags.  A nonzero value indicates the\n    block is reachable.  */\n \n void\n@@ -781,8 +781,8 @@ flow_reverse_top_sort_order_compute (rts_order)\n }\n \n /* Compute the depth first search order and store in the array\n-  DFS_ORDER if non-zero, marking the nodes visited in VISITED.  If\n-  RC_ORDER is non-zero, return the reverse completion number for each\n+  DFS_ORDER if nonzero, marking the nodes visited in VISITED.  If\n+  RC_ORDER is nonzero, return the reverse completion number for each\n   node.  Returns the number of nodes visited.  A depth first search\n   tries to get as far away from the starting point as quickly as\n   possible.  */\n@@ -1027,7 +1027,7 @@ flow_preorder_transversal_compute (pot_order)\n /* Initialize the data structures used for depth-first search on the\n    reverse graph.  If INITIALIZE_STACK is nonzero, the exit block is\n    added to the basic block stack.  DATA is the current depth-first\n-   search context.  If INITIALIZE_STACK is non-zero, there is an\n+   search context.  If INITIALIZE_STACK is nonzero, there is an\n    element on the stack.  */\n \n static void"}, {"sha": "0a2829f5c185a7cdb2ea718d65f518fe92a81698", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -90,7 +90,7 @@ flow_loops_cfg_dump (loops, file)\n     }\n }\n \n-/* Return non-zero if the nodes of LOOP are a subset of OUTER.  */\n+/* Return nonzero if the nodes of LOOP are a subset of OUTER.  */\n \n bool\n flow_loop_nested_p (outer, loop)\n@@ -949,7 +949,7 @@ flow_loops_update (loops, flags)\n   return flow_loops_find (loops, flags);\n }\n \n-/* Return non-zero if basic block BB belongs to LOOP.  */\n+/* Return nonzero if basic block BB belongs to LOOP.  */\n bool\n flow_bb_inside_loop_p (loop, bb)\n      const struct loop *loop;\n@@ -964,7 +964,7 @@ flow_bb_inside_loop_p (loop, bb)\n   return loop == source_loop || flow_loop_nested_p (loop, source_loop);\n }\n \n-/* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */\n+/* Return nonzero if edge E enters header of LOOP from outside of LOOP.  */\n \n bool\n flow_loop_outside_edge_p (loop, e)"}, {"sha": "c26838427d7972cc51fc10f4fe37b9df03d082f2", "filename": "gcc/collect2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -1491,7 +1491,7 @@ main (argc, argv)\n }\n \n \f\n-/* Wait for a process to finish, and exit if a non-zero status is found.  */\n+/* Wait for a process to finish, and exit if a nonzero status is found.  */\n \n int\n collect_wait (prog)"}, {"sha": "5b7b5a92bf76dfb240138c43620903b29c623be6", "filename": "gcc/combine.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -221,7 +221,7 @@ static int need_refresh;\n \t\t\t\tregister was assigned\n    reg_last_set_table_tick\trecords the value of label_tick when a\n \t\t\t\tvalue using the register is assigned\n-   reg_last_set_invalid\t\tset to non-zero when it is not valid\n+   reg_last_set_invalid\t\tset to nonzero when it is not valid\n \t\t\t\tto use the value of this register in some\n \t\t\t\tregister's value\n \n@@ -230,7 +230,7 @@ static int need_refresh;\n    and the register being validly contained in some other expression in the\n    table.\n \n-   Entry I in reg_last_set_value is valid if it is non-zero, and either\n+   Entry I in reg_last_set_value is valid if it is nonzero, and either\n    reg_n_sets[i] is 1 or reg_last_set_label[i] == label_tick.\n \n    Register I may validly appear in any expression returned for the value\n@@ -242,7 +242,7 @@ static int need_refresh;\n    not validly appear in an expression, the register is replaced by\n    something that won't match, (clobber (const_int 0)).\n \n-   reg_last_set_invalid[i] is set non-zero when register I is being assigned\n+   reg_last_set_invalid[i] is set nonzero when register I is being assigned\n    to and reg_last_set_table_tick[i] == label_tick.  */\n \n /* Record last value assigned to (hard or pseudo) register n.  */\n@@ -259,7 +259,7 @@ static int *reg_last_set_label;\n \n static int *reg_last_set_table_tick;\n \n-/* Set non-zero if references to register n in expressions should not be\n+/* Set nonzero if references to register n in expressions should not be\n    used.  */\n \n static char *reg_last_set_invalid;\n@@ -497,7 +497,7 @@ do_SUBST_INT (into, newval)\n /* Main entry point for combiner.  F is the first insn of the function.\n    NREGS is the first unused pseudo-reg number.\n \n-   Return non-zero if the combiner has turned an indirect jump\n+   Return nonzero if the combiner has turned an indirect jump\n    instruction into a direct jump.  */\n int\n combine_instructions (f, nregs)\n@@ -1285,13 +1285,13 @@ sets_function_arg_p (pat)\n    case, we would be getting the wrong value of I2DEST into I3, so we\n    must reject the combination.  This case occurs when I2 and I1 both\n    feed into I3, rather than when I1 feeds into I2, which feeds into I3.\n-   If I1_NOT_IN_SRC is non-zero, it means that finding I1 in the source\n+   If I1_NOT_IN_SRC is nonzero, it means that finding I1 in the source\n    of a SET must prevent combination from occurring.\n \n    Before doing the above check, we first try to expand a field assignment\n    into a set of logical operations.\n \n-   If PI3_DEST_KILLED is non-zero, it is a pointer to a location in which\n+   If PI3_DEST_KILLED is nonzero, it is a pointer to a location in which\n    we place a register that is both set and used within I3.  If more than one\n    such register is detected, we fail.\n \n@@ -1497,7 +1497,7 @@ cant_combine_insn_p (insn)\n    If we did the combination, return the insn at which combine should\n    resume scanning.\n \n-   Set NEW_DIRECT_JUMP_P to a non-zero value if try_combine creates a\n+   Set NEW_DIRECT_JUMP_P to a nonzero value if try_combine creates a\n    new direct jump instruction.  */\n \n static rtx\n@@ -3107,7 +3107,7 @@ find_split_point (loc, insn)\n \tcase AND:\n \t  /* If we are AND'ing with a large constant that is only a single\n \t     bit and the result is only being used in a context where we\n-\t     need to know if it is zero or non-zero, replace it with a bit\n+\t     need to know if it is zero or nonzero, replace it with a bit\n \t     extraction.  This will avoid the large constant, which might\n \t     have taken more than one insn to make.  If the constant were\n \t     not a valid argument to the AND but took only one insn to make,\n@@ -3335,10 +3335,10 @@ find_split_point (loc, insn)\n \n    `n_occurrences' is incremented each time FROM is replaced.\n \n-   IN_DEST is non-zero if we are processing the SET_DEST of a SET.\n+   IN_DEST is nonzero if we are processing the SET_DEST of a SET.\n \n-   UNIQUE_COPY is non-zero if each substitution must be unique.  We do this\n-   by copying if `n_occurrences' is non-zero.  */\n+   UNIQUE_COPY is nonzero if each substitution must be unique.  We do this\n+   by copying if `n_occurrences' is nonzero.  */\n \n static rtx\n subst (x, from, to, in_dest, unique_copy)\n@@ -5980,15 +5980,15 @@ expand_field_assignment (x)\n    code that understands the USE is this routine.  If it is not removed,\n    it will cause the resulting insn not to match.\n \n-   UNSIGNEDP is non-zero for an unsigned reference and zero for a\n+   UNSIGNEDP is nonzero for an unsigned reference and zero for a\n    signed reference.\n \n-   IN_DEST is non-zero if this is a reference in the destination of a\n-   SET.  This is used when a ZERO_ or SIGN_EXTRACT isn't needed.  If non-zero,\n+   IN_DEST is nonzero if this is a reference in the destination of a\n+   SET.  This is used when a ZERO_ or SIGN_EXTRACT isn't needed.  If nonzero,\n    a STRICT_LOW_PART will be used, if zero, ZERO_EXTEND or SIGN_EXTEND will\n    be used.\n \n-   IN_COMPARE is non-zero if we are in a COMPARE.  This means that a\n+   IN_COMPARE is nonzero if we are in a COMPARE.  This means that a\n    ZERO_EXTRACT should be built even for bits starting at bit 0.\n \n    MODE is the desired mode of the result (if IN_DEST == 0).\n@@ -6476,7 +6476,7 @@ make_compound_operation (x, in_code)\n \t       : in_code == COMPARE ? SET : in_code);\n \n   /* Process depending on the code of this operation.  If NEW is set\n-     non-zero, it will be returned.  */\n+     nonzero, it will be returned.  */\n \n   switch (code)\n     {\n@@ -6753,7 +6753,7 @@ get_pos_from_mask (m, plen)\n    Return a possibly simplified expression, but always convert X to\n    MODE.  If X is a CONST_INT, AND the CONST_INT with MASK.\n \n-   Also, if REG is non-zero and X is a register equal in value to REG,\n+   Also, if REG is nonzero and X is a register equal in value to REG,\n    replace X with REG.\n \n    If JUST_SELECT is nonzero, don't optimize by noticing that bits in MASK\n@@ -7363,7 +7363,7 @@ if_then_else_cond (x, ptrue, pfalse)\n \t}\n \n       /* See if we have PLUS, IOR, XOR, MINUS or UMAX, where one of the\n-\t operands is zero when the other is non-zero, and vice-versa,\n+\t operands is zero when the other is nonzero, and vice-versa,\n \t and STORE_FLAG_VALUE is 1 or -1.  */\n \n       if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n@@ -8067,7 +8067,7 @@ simplify_and_const_int (x, mode, varop, constop)\n    this.  This macro avoids accidental uses of num_sign_bit_copies.  */\n #define num_sign_bit_copies()\n \n-/* Given an expression, X, compute which bits in X can be non-zero.\n+/* Given an expression, X, compute which bits in X can be nonzero.\n    We don't care about bits outside of those defined in MODE.\n \n    For most X this is simply GET_MODE_MASK (GET_MODE (MODE)), but if X is\n@@ -8283,7 +8283,7 @@ nonzero_bits (x, mode)\n     case SIGN_EXTEND:\n       /* If the sign bit is known clear, this is the same as ZERO_EXTEND.\n \t Otherwise, show all the bits in the outer mode but not the inner\n-\t may be non-zero.  */\n+\t may be nonzero.  */\n       inner_nz = nonzero_bits (XEXP (x, 0), mode);\n       if (GET_MODE (XEXP (x, 0)) != VOIDmode)\n \t{\n@@ -8321,7 +8321,7 @@ nonzero_bits (x, mode)\n     case MOD:   case UMOD:\n       /* We can apply the rules of arithmetic to compute the number of\n \t high- and low-order zero bits of these operations.  We start by\n-\t computing the width (position of the highest-order non-zero bit)\n+\t computing the width (position of the highest-order nonzero bit)\n \t and the number of low-order zero bits for each value.  */\n       {\n \tunsigned HOST_WIDE_INT nz0 = nonzero_bits (XEXP (x, 0), mode);\n@@ -9031,7 +9031,7 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n }\n \f\n /* Simplify a shift of VAROP by COUNT bits.  CODE says what kind of shift.\n-   The result of the shift is RESULT_MODE.  X, if non-zero, is an expression\n+   The result of the shift is RESULT_MODE.  X, if nonzero, is an expression\n    that we started with.\n \n    The shift is normally computed in the widest mode we find in VAROP, as\n@@ -10781,7 +10781,7 @@ simplify_comparison (code, pop0, pop1)\n \t  break;\n \n \tcase IOR:\n-\t  /* The sign bit of (ior (plus X (const_int -1)) X) is non-zero\n+\t  /* The sign bit of (ior (plus X (const_int -1)) X) is nonzero\n \t     iff X <= 0.  */\n \t  if (sign_bit_comparison_p && GET_CODE (XEXP (op0, 0)) == PLUS\n \t      && XEXP (XEXP (op0, 0), 1) == constm1_rtx\n@@ -11582,7 +11582,7 @@ check_promoted_subreg (insn, x)\n    mentioned in *LOC are valid when *LOC was part of a value set when\n    label_tick == TICK.  Return 0 if some are not.\n \n-   If REPLACE is non-zero, replace the invalid reference with\n+   If REPLACE is nonzero, replace the invalid reference with\n    (clobber (const_int 0)) and return 1.  This replacement is useful because\n    we often can get useful information about the form of a value (e.g., if\n    it was produced by a shift that always produces -1 or 0) even though\n@@ -11795,7 +11795,7 @@ reg_dead_at_p_1 (dest, x, data)\n     reg_dead_flag = (GET_CODE (x) == CLOBBER) ? 1 : -1;\n }\n \n-/* Return non-zero if REG is known to be dead at INSN.\n+/* Return nonzero if REG is known to be dead at INSN.\n \n    We scan backwards from INSN.  If we hit a REG_DEAD note or a CLOBBER\n    referencing REG, it is dead.  If we hit a SET referencing REG, it is\n@@ -12469,7 +12469,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \tcase REG_DEAD:\n \t  /* If the register is used as an input in I3, it dies there.\n-\t     Similarly for I2, if it is non-zero and adjacent to I3.\n+\t     Similarly for I2, if it is nonzero and adjacent to I3.\n \n \t     If the register is not used as an input in either I3 or I2\n \t     and it is not one of the registers we were supposed to eliminate,"}, {"sha": "48ca1d69e67cfb16f39c766b9b6df8bbc49ea77a", "filename": "gcc/conflict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -183,7 +183,7 @@ conflict_graph_delete (graph)\n }\n \n /* Adds a conflict to GRAPH between regs REG1 and REG2, which must be\n-   distinct.  Returns non-zero, unless the conflict is already present\n+   distinct.  Returns nonzero, unless the conflict is already present\n    in GRAPH, in which case it does nothing and returns zero.  */\n \n int\n@@ -232,7 +232,7 @@ conflict_graph_add (graph, reg1, reg2)\n   return 1;\n }\n \n-/* Returns non-zero if a conflict exists in GRAPH between regs REG1\n+/* Returns nonzero if a conflict exists in GRAPH between regs REG1\n    and REG2.  */\n \n int"}, {"sha": "d4ea2fc185459cb9a259bf0cc8de4e0226cf4ba6", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -1551,7 +1551,7 @@ num_div_op (pfile, lhs, rhs, op)\n       return lhs;\n     }\n \n-  /* First non-zero bit of RHS is bit I.  Do naive division by\n+  /* First nonzero bit of RHS is bit I.  Do naive division by\n      shifting the RHS fully left, and subtracting from LHS if LHS is\n      at least as big, and then repeating but with one less shift.\n      This is not very efficient, but is easy to understand.  */"}, {"sha": "ac6fa8ab7db673bddcaca4407f993dd11a11249e", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -658,7 +658,7 @@ report_missing_guard (n, b)\n }\n \n /* Create a dependency for file FNAME, or issue an error message as\n-   appropriate.  ANGLE_BRACKETS is non-zero if the file was bracketed\n+   appropriate.  ANGLE_BRACKETS is nonzero if the file was bracketed\n    like <..>.  */\n static void\n handle_missing_header (pfile, fname, angle_brackets)"}, {"sha": "16e8dfe08fe38331f9577f44c3527d252a94bf0f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -99,7 +99,7 @@ struct cpp_macro\n   /* If macro defined in system header.  */\n   unsigned int syshdr   : 1;\n \n-  /* Non-zero if it has been expanded or had its existence tested.  */\n+  /* Nonzero if it has been expanded or had its existence tested.  */\n   unsigned int used     : 1;\n };\n \n@@ -141,7 +141,7 @@ struct search_path\n      of an earlier directory on the search path.  */\n   ino_t ino;\n   dev_t dev;\n-  /* Non-zero if it is a system include directory.  */\n+  /* Nonzero if it is a system include directory.  */\n   int sysp;\n   /* Mapping of file names for this directory.  Only used on MS-DOS\n      and related platforms.  */\n@@ -372,7 +372,7 @@ struct cpp_reader\n   tokenrun base_run, *cur_run;\n   unsigned int lookaheads;\n \n-  /* Non-zero prevents the lexer from re-using the token runs.  */\n+  /* Nonzero prevents the lexer from re-using the token runs.  */\n   unsigned int keep_tokens;\n \n   /* Error counter for exit code.  */"}, {"sha": "8ec1b0e4bf4a8577ba9526c99a7f65c6238a9eb9", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -194,7 +194,7 @@ path_include (pfile, list, path)\n \n /* Append DIR to include path PATH.  DIR must be allocated on the\n    heap; this routine takes responsibility for freeing it.  CXX_AWARE\n-   is non-zero if the header contains extern \"C\" guards for C++,\n+   is nonzero if the header contains extern \"C\" guards for C++,\n    otherwise it is zero.  */\n static void\n append_include_chain (pfile, dir, path, cxx_aware)\n@@ -840,7 +840,7 @@ init_standard_includes (pfile)\n }\n \n /* Pushes a command line -imacro and -include file indicated by P onto\n-   the buffer stack.  Returns non-zero if successful.  */\n+   the buffer stack.  Returns nonzero if successful.  */\n static bool\n push_include (pfile, p)\n      cpp_reader *pfile;"}, {"sha": "d57f5bd0c2b872fddcb9c2a55e393f914d877ccf", "filename": "gcc/cpplex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -252,7 +252,7 @@ get_effective_char (pfile)\n \n /* Skip a C-style block comment.  We find the end of the comment by\n    seeing if an asterisk is before every '/' we encounter.  Returns\n-   non-zero if comment terminated by EOF, zero otherwise.  */\n+   nonzero if comment terminated by EOF, zero otherwise.  */\n static int\n skip_block_comment (pfile)\n      cpp_reader *pfile;\n@@ -297,7 +297,7 @@ skip_block_comment (pfile)\n }\n \n /* Skip a C++ line comment, leaving buffer->cur pointing to the\n-   terminating newline.  Handles escaped newlines.  Returns non-zero\n+   terminating newline.  Handles escaped newlines.  Returns nonzero\n    if a multiline comment.  */\n static int\n skip_line_comment (pfile)\n@@ -561,7 +561,7 @@ parse_slow (pfile, cur, number_p, plen)\n }\n \n /* Parse a number, beginning with character C, skipping embedded\n-   backslash-newlines.  LEADING_PERIOD is non-zero if there was a \".\"\n+   backslash-newlines.  LEADING_PERIOD is nonzero if there was a \".\"\n    before C.  Place the result in NUMBER.  */\n static void\n parse_number (pfile, number, leading_period)"}, {"sha": "c954448cbd3e24d25708b544121f337f309dda85", "filename": "gcc/cpplib.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -300,7 +300,7 @@ prepare_directive_trad (pfile)\n   pfile->state.prevent_expansion++;\n }\n \n-/* Output diagnostics for a directive DIR.  INDENTED is non-zero if\n+/* Output diagnostics for a directive DIR.  INDENTED is nonzero if\n    the '#' was indented.  */\n static void\n directive_diagnostics (pfile, dir, indented)\n@@ -336,10 +336,10 @@ directive_diagnostics (pfile, dir, indented)\n     }\n }\n \n-/* Check if we have a known directive.  INDENTED is non-zero if the\n+/* Check if we have a known directive.  INDENTED is nonzero if the\n    '#' of the directive was indented.  This function is in this file\n    to save unnecessarily exporting dtable etc. to cpplex.c.  Returns\n-   non-zero if the line of tokens has been handled, zero if we should\n+   nonzero if the line of tokens has been handled, zero if we should\n    continue processing the line.  */\n int\n _cpp_handle_directive (pfile, indented)\n@@ -1686,7 +1686,7 @@ find_answer (node, candidate)\n }\n \n /* Test an assertion within a preprocessor conditional.  Returns\n-   non-zero on failure, zero on success.  On success, the result of\n+   nonzero on failure, zero on success.  On success, the result of\n    the test is written into VALUE.  */\n int\n _cpp_test_assertion (pfile, value)"}, {"sha": "b22aaa118d88de78e66081300a12fe17aa6d5ce2", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -659,7 +659,7 @@ cpp_num cpp_num_sign_extend PARAMS ((cpp_num, size_t));\n #define DL_ICE\t\t\t0x04\n /* Extracts a diagnostic level from an int.  */\n #define DL_EXTRACT(l)\t\t(l & 0xf)\n-/* Non-zero if a diagnostic level is one of the warnings.  */\n+/* Nonzero if a diagnostic level is one of the warnings.  */\n #define DL_WARNING_P(l)\t\t(DL_EXTRACT (l) >= DL_WARNING \\\n \t\t\t\t && DL_EXTRACT (l) <= DL_PEDWARN)\n "}, {"sha": "b8fb792de885aed425d90d987b3a426f7202def9", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -414,7 +414,7 @@ stringify_arg (pfile, arg)\n   return new_string_token (pfile, dest - len, len);\n }\n \n-/* Try to paste two tokens.  On success, return non-zero.  In any\n+/* Try to paste two tokens.  On success, return nonzero.  In any\n    case, PLHS is updated to point to the pasted token, which is\n    guaranteed to not have the PASTE_LEFT flag set.  */\n static bool\n@@ -1240,7 +1240,7 @@ _cpp_backup_tokens (pfile, count)\n \n /* #define directive parsing and handling.  */\n \n-/* Returns non-zero if a macro redefinition warning is required.  */\n+/* Returns nonzero if a macro redefinition warning is required.  */\n static bool\n warn_of_redefinition (pfile, node, macro2)\n      cpp_reader *pfile;\n@@ -1294,7 +1294,7 @@ _cpp_free_definition (h)\n }\n \n /* Save parameter NODE to the parameter list of macro MACRO.  Returns\n-   zero on success, non-zero if the parameter is a duplicate.  */\n+   zero on success, nonzero if the parameter is a duplicate.  */\n bool\n _cpp_save_parameter (pfile, macro, node)\n      cpp_reader *pfile;\n@@ -1534,7 +1534,7 @@ create_iso_definition (pfile, macro)\n   return true;\n }\n \n-/* Parse a macro and save its expansion.  Returns non-zero on success.  */\n+/* Parse a macro and save its expansion.  Returns nonzero on success.  */\n bool\n _cpp_create_definition (pfile, node)\n      cpp_reader *pfile;"}, {"sha": "706fe80f4ebca2b9a30c128330a6fb99ee968289", "filename": "gcc/cse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d8304097f7ee1fb0e484b692acd38abc406fb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=da7d8304097f7ee1fb0e484b692acd38abc406fb", "patch": "@@ -2768,9 +2768,9 @@ cse_rtx_varies_p (x, from_alias)\n    replace each register reference inside it\n    with the \"oldest\" equivalent register.\n \n-   If INSN is non-zero and we are replacing a pseudo with a hard register\n+   If INSN is nonzero and we are replacing a pseudo with a hard register\n    or vice versa, validate_change is used to ensure that INSN remains valid\n-   after we make our substitution.  The calls are made with IN_GROUP non-zero\n+   after we make our substitution.  The calls are made with IN_GROUP nonzero\n    so apply_change_group must be called upon the outermost return from this\n    function (unless INSN is zero).  The result of apply_change_group can\n    generally be discarded since the changes we are making are optional.  */\n@@ -3125,7 +3125,7 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \n   while (arg2 == CONST0_RTX (GET_MODE (arg1)))\n     {\n-      /* Set non-zero when we find something of interest.  */\n+      /* Set nonzero when we find something of interest.  */\n       rtx x = 0;\n       int reverse_code = 0;\n       struct table_elt *p = 0;\n@@ -5004,7 +5004,7 @@ cse_insn (insn, libcall_insn)\n       int src_folded_regcost = MAX_COST;\n       int src_related_regcost = MAX_COST;\n       int src_elt_regcost = MAX_COST;\n-      /* Set non-zero if we need to call force_const_mem on with the\n+      /* Set nonzero if we need to call force_const_mem on with the\n \t contents of src_folded before using it.  */\n       int src_folded_force_flag = 0;\n \n@@ -5344,9 +5344,9 @@ cse_insn (insn, libcall_insn)\n       if (src == src_folded)\n \tsrc_folded = 0;\n \n-      /* At this point, ELT, if non-zero, points to a class of expressions\n+      /* At this point, ELT, if nonzero, points to a class of expressions\n          equivalent to the source of this SET and SRC, SRC_EQV, SRC_FOLDED,\n-\t and SRC_RELATED, if non-zero, each contain additional equivalent\n+\t and SRC_RELATED, if nonzero, each contain additional equivalent\n \t expressions.  Prune these latter expressions by deleting expressions\n \t already in the equivalence class.\n \n@@ -6831,10 +6831,10 @@ cse_set_around_loop (x, insn, loop_start)\n    the total number of SETs in all the insns of the block, the last insn of the\n    block, and the branch path.\n \n-   The branch path indicates which branches should be followed.  If a non-zero\n+   The branch path indicates which branches should be followed.  If a nonzero\n    path size is specified, the block should be rescanned and a different set\n    of branches will be taken.  The branch path is only used if\n-   FLAG_CSE_FOLLOW_JUMPS or FLAG_CSE_SKIP_BLOCKS is non-zero.\n+   FLAG_CSE_FOLLOW_JUMPS or FLAG_CSE_SKIP_BLOCKS is nonzero.\n \n    DATA is a pointer to a struct cse_basic_block_data, defined below, that is\n    used to describe the block.  It is filled in with the information about\n@@ -6860,7 +6860,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n   /* Update the previous branch path, if any.  If the last branch was\n      previously TAKEN, mark it NOT_TAKEN.  If it was previously NOT_TAKEN,\n      shorten the path by one and look at the previous branch.  We know that\n-     at least one branch must have been taken if PATH_SIZE is non-zero.  */\n+     at least one branch must have been taken if PATH_SIZE is nonzero.  */\n   while (path_size > 0)\n     {\n       if (data->path[path_size - 1].status != NOT_TAKEN)\n@@ -7205,7 +7205,7 @@ cse_main (f, nregs, after_loop, file)\n    block.  NEXT_BRANCH points to the branch path when following jumps or\n    a null path when not following jumps.\n \n-   AROUND_LOOP is non-zero if we are to try to cse around to the start of a\n+   AROUND_LOOP is nonzero if we are to try to cse around to the start of a\n    loop.  This is true when we are being called for the last time on a\n    block and this CSE pass is before loop.c.  */\n "}]}