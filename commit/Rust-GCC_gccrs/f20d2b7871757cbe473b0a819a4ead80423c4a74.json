{"sha": "f20d2b7871757cbe473b0a819a4ead80423c4a74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIwZDJiNzg3MTc1N2NiZTQ3M2IwYTgxOWE0ZWFkODA0MjNjNGE3NA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-10-27T16:21:14Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-10-27T16:21:14Z"}, "message": "re PR libstdc++/12750 (time_get::_M_extract_via_format doesn't deal with 'e')\n\n2003-10-27  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/12750\n\t* include/bits/locale_facets.tcc\n\t(time_get::_M_extract_via_format): Deal with code 'e'.\n\t* testsuite/22_locale/time_get/get_date/char/12750.cc: New.\n\t* testsuite/22_locale/time_get/get_date/wchar_t/12750.cc: Ditto.\n\n\t* include/bits/locale_facets.tcc\n\t(time_get::_M_extract_via_format): Tweak to absolutely avoid\n\tdereferencing end iterators.\n\n\t* include/bits/locale_facets.h (__verify_grouping):\n\tConst-ify second parameter.\n\t* include/bits/locale_facets.tcc (__verify_grouping): Ditto.\n\t* src/locale-inst.cc (__verify_grouping): Ditto.\n\n2003-10-27  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get::_M_extract_float):\n\tVarious things: 1- Avoid absolutely end iterator dereferences;\n\t2- Improve performance-wise the code skipping leading zeros;\n\t3- Fix two bugs wrt early bail out in case of parsing errors\n\t(see testcases); 4- General clean up.\n\t(num_get::_M_extract_int): Likewise, except 3-. Additionally,\n\tuse __builtin_expect to favor base 10 inputs.\n\t* testsuite/22_locale/num_get/get/char/7.cc: New.\n\t* testsuite/22_locale/num_get/get/wchar_t/7.cc: Ditto.\n\nFrom-SVN: r72987", "tree": {"sha": "1cf1419af9a6f8fe862d4ddb744df766be294bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cf1419af9a6f8fe862d4ddb744df766be294bb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f20d2b7871757cbe473b0a819a4ead80423c4a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20d2b7871757cbe473b0a819a4ead80423c4a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20d2b7871757cbe473b0a819a4ead80423c4a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20d2b7871757cbe473b0a819a4ead80423c4a74/comments", "author": null, "committer": null, "parents": [{"sha": "436d77152ec4cab4dc3837ce5b30dc09cf8a234b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436d77152ec4cab4dc3837ce5b30dc09cf8a234b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/436d77152ec4cab4dc3837ce5b30dc09cf8a234b"}], "stats": {"total": 485, "additions": 402, "deletions": 83}, "files": [{"sha": "6dd3bf5a2a8c24e2ccb0906696975805e26c3bce", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -1,3 +1,32 @@\n+2003-10-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/12750\n+\t* include/bits/locale_facets.tcc\n+\t(time_get::_M_extract_via_format): Deal with code 'e'.\n+\t* testsuite/22_locale/time_get/get_date/char/12750.cc: New.\n+\t* testsuite/22_locale/time_get/get_date/wchar_t/12750.cc: Ditto.\n+\n+\t* include/bits/locale_facets.tcc\n+\t(time_get::_M_extract_via_format): Tweak to absolutely avoid\n+\tdereferencing end iterators.\n+\n+\t* include/bits/locale_facets.h (__verify_grouping):\n+\tConst-ify second parameter.\n+\t* include/bits/locale_facets.tcc (__verify_grouping): Ditto.\n+\t* src/locale-inst.cc (__verify_grouping): Ditto.\n+\n+2003-10-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get::_M_extract_float):\n+\tVarious things: 1- Avoid absolutely end iterator dereferences;\n+\t2- Improve performance-wise the code skipping leading zeros;\n+\t3- Fix two bugs wrt early bail out in case of parsing errors\n+\t(see testcases); 4- General clean up.\n+\t(num_get::_M_extract_int): Likewise, except 3-. Additionally,\n+\tuse __builtin_expect to favor base 10 inputs.\n+\t* testsuite/22_locale/num_get/get/char/7.cc: New.\n+\t* testsuite/22_locale/num_get/get/wchar_t/7.cc: Ditto.\n+\n 2003-10-26  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/22_locale/money_put/put/char/1.cc: Clean up."}, {"sha": "f55685d09a6bd938eec6422c65a25655257c65c7", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -125,7 +125,7 @@ namespace std\n   template<typename _CharT>\n     bool\n     __verify_grouping(const basic_string<_CharT>& __grouping, \n-\t\t      basic_string<_CharT>& __grouping_tmp);\n+\t\t      const basic_string<_CharT>& __grouping_tmp);\n \n   // Used by both numeric and monetary facets.\n   // Inserts \"group separator\" characters into an array of characters."}, {"sha": "25f684dce577b00dcfc83d72f9f3023411dcc308", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 96, "deletions": 81, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -144,51 +144,50 @@ namespace std\n       const _CharT* __lit = __lc->_M_atoms_in;\n \n       // First check for sign.\n-      int __pos = 0;\n-      char_type  __c = *__beg;\n-      const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n-      if ((__plus || __traits_type::eq(__c, __lit[_S_iminus])) \n-\t  && __beg != __end)\n-\t{\n-\t  __xtrc += __plus ? _S_atoms_in[_S_iplus] : _S_atoms_in[_S_iminus];\n-\t  ++__pos;\n-\t  __c = *(++__beg);\n-\t}\n-\n-      // Next, strip leading zeros.\n-      bool __found_zero = false;\n-      while (__traits_type::eq(__c, __lit[_S_izero]) && __beg != __end)\n+      if (__beg != __end)\n \t{\n-\t  __c = *(++__beg);\n-\t  __found_zero = true;\n+\t  const char_type __c = *__beg;\n+\t  const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n+\t  if (__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n+\t    {\n+\t      __xtrc += __plus ? _S_atoms_in[_S_iplus]\n+\t\t               : _S_atoms_in[_S_iminus];\n+\t      ++__beg;\n+\t    }\n \t}\n-      if (__found_zero)\n+\t  \n+      // Next, look for a zero...\n+      bool __found_mantissa = false;\n+      if (__beg != __end && __traits_type::eq(*__beg, __lit[_S_izero]))\n \t{\n \t  __xtrc += _S_atoms_in[_S_izero];\n-\t  ++__pos;\n+\t  __found_mantissa = true;\n+\t  ++__beg;\n+\t  // ... and skip the additional ones.\n+\t  for (; __beg != __end\n+\t\t && __traits_type::eq(*__beg, __lit[_S_izero]); ++__beg);\n \t}\n \n       // Only need acceptable digits for floating point numbers.\n       bool __found_dec = false;\n       bool __found_sci = false;\n       string __found_grouping;\n-      const size_t __len = _S_iE - _S_izero + 1;\n       int __sep_pos = 0;\n       bool __e;\n       while (__beg != __end)\n         {\n \t  // Only look in digits.\n+\t  const char_type __c = *__beg;\n           const char_type* __p = __traits_type::find(__lit + _S_izero, 10, \n \t\t\t\t\t\t     __c);\n-\n-          // NB: strchr returns true for __c == 0x0\n+          // NB: strchr returns true for *__beg == 0x0\n           if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n-\t      ++__pos;\n \t      __xtrc += _S_atoms_in[__p - __lit];\n+\t      __found_mantissa = true;\n \t      ++__sep_pos;\n-\t      __c = *(++__beg);\n+\t      ++__beg;\n \t    }\n           else if (__traits_type::eq(__c, __lc->_M_thousands_sep) \n \t\t   && __lc->_M_use_grouping && !__found_dec)\n@@ -199,7 +198,7 @@ namespace std\n                 {\n                   __found_grouping += static_cast<char>(__sep_pos);\n                   __sep_pos = 0;\n-\t\t  __c = *(++__beg);\n+\t\t  ++__beg;\n                 }\n               else\n \t\t{\n@@ -215,28 +214,28 @@ namespace std\n \t      // must be adjusted only if __dec comes after some __sep.\n \t      if (__found_grouping.size())\n \t\t__found_grouping += static_cast<char>(__sep_pos);\n-\t      ++__pos;\n \t      __xtrc += '.';\n-\t      __c = *(++__beg);\n \t      __found_dec = true;\n+\t      ++__beg;\n \t    }\n \t  else if ((__e = __traits_type::eq(__c, __lit[_S_ie]) \n \t\t    || __traits_type::eq(__c, __lit[_S_iE])) \n-\t\t   && !__found_sci && __pos)\n+\t\t   && __found_mantissa && !__found_sci)\n \t    {\n \t      // Scientific notation.\n-\t      ++__pos;\n \t      __xtrc += __e ? _S_atoms_in[_S_ie] : _S_atoms_in[_S_iE];\n-\t      __c = *(++__beg);\n-\n+\t      ++__beg;\n+\t      \n \t      // Remove optional plus or minus sign, if they exist.\n-\t      const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n-\t      if (__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n+\t      if (__beg != __end)\n \t\t{\n-\t\t  ++__pos;\n-\t\t  __xtrc += __plus ? _S_atoms_in[_S_iplus] \n-\t\t                   : _S_atoms_in[_S_iminus];\n-\t\t  __c = *(++__beg);\n+\t\t  const bool __plus = __traits_type::eq(*__beg, __lit[_S_iplus]);\n+\t\t  if (__plus || __traits_type::eq(*__beg, __lit[_S_iminus]))\n+\t\t    {\n+\t\t      __xtrc += __plus ? _S_atoms_in[_S_iplus] \n+\t\t\t               : _S_atoms_in[_S_iminus];\n+\t\t      ++__beg;\n+\t\t    }\n \t\t}\n \t      __found_sci = true;\n \t    }\n@@ -288,55 +287,62 @@ namespace std\n \t__base = 10;\n \n       // First check for sign.\n-      char_type  __c = *__beg;\n-      const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n-      if ((__plus || __traits_type::eq(__c, __lit[_S_iminus])) \n-\t  && __beg != __end)\n+      if (__beg != __end)\n \t{\n-\t  __xtrc += __plus ? _S_atoms_in[_S_iplus] : _S_atoms_in[_S_iminus];\n-\t  __c = *(++__beg);\n+\t  const char_type __c = *__beg;\n+\t  const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n+\t  if (__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n+\t    {\n+\t      __xtrc += __plus ? _S_atoms_in[_S_iplus]\n+\t\t               : _S_atoms_in[_S_iminus];\n+\t      ++__beg;\n+\t    }\n \t}\n \n-      // Next, strip leading zeros and check required digits for base formats.\n-      if (__base == 10)\n+      // Next, look for leading zeros and check required digits for base formats.\n+      if (__builtin_expect(__base == 10, true))\n \t{\n-\t  bool __found_zero = false;\n-\t  while (__traits_type::eq(__c, __lit[_S_izero]) && __beg != __end)\n-\t    {\n-\t      __c = *(++__beg);\n-\t      __found_zero = true;\n-\t    }\n-\t  if (__found_zero)\n+\t  // Look for a zero...\n+\t  if (__beg != __end && __traits_type::eq(*__beg, __lit[_S_izero]))\n \t    {\n \t      __xtrc += _S_atoms_in[_S_izero];\n-\t      if (__basefield == 0)\n-\t\t{\t      \n-\t\t  const bool __x = __traits_type::eq(__c, __lit[_S_ix]);\n-\t\t  if ((__x || __traits_type::eq(__c, __lit[_S_iX]))\n-\t\t      && __beg != __end)\n+\t      ++__beg;\n+\t      // ... and skip the additional ones.\n+\t      for (; __beg != __end\n+\t\t     && __traits_type::eq(*__beg, __lit[_S_izero]); ++__beg);\n+\t      \n+\t      // Check required digits.\n+\t      if (__beg != __end && __basefield == 0)\n+\t\t{\t  \n+\t\t  const bool __x = __traits_type::eq(*__beg, __lit[_S_ix]);\n+\t\t  if (__x || __traits_type::eq(*__beg, __lit[_S_iX]))\n \t\t    {\n-\t\t      __xtrc += __x ? _S_atoms_in[_S_ix] : _S_atoms_in[_S_iX];\n-\t\t      __c = *(++__beg);\n+\t\t      __xtrc += __x ? _S_atoms_in[_S_ix] \n+\t\t\t            : _S_atoms_in[_S_iX];\n \t\t      __base = 16;\n+\t\t      ++__beg;\t\t      \n \t\t    }\n \t\t  else \n \t\t    __base = 8;\n-\t\t}\n+\t\t}\t      \n \t    }\n \t}\n       else if (__base == 16)\n \t{\n-\t  if (__traits_type::eq(__c, __lit[_S_izero]) && __beg != __end)\n+\t  if (__beg != __end && __traits_type::eq(*__beg, __lit[_S_izero]))\n \t    {\n \t      __xtrc += _S_atoms_in[_S_izero];\n-\t      __c = *(++__beg); \n-\n-\t      const bool __x = __traits_type::eq(__c, __lit[_S_ix]);\n-\t      if ((__x || __traits_type::eq(__c, __lit[_S_iX]))\n-\t\t  && __beg != __end)\n+\t      ++__beg; \n+\t      \n+\t      if (__beg != __end)\n \t\t{\n-\t\t  __xtrc += __x ? _S_atoms_in[_S_ix] : _S_atoms_in[_S_iX];\n-\t\t  __c = *(++__beg);\n+\t\t  const bool __x = __traits_type::eq(*__beg, __lit[_S_ix]);\n+\t\t  if (__x || __traits_type::eq(*__beg, __lit[_S_iX]))\n+\t\t    {\n+\t\t      __xtrc += __x ? _S_atoms_in[_S_ix] \n+\t\t\t            : _S_atoms_in[_S_iX];\n+\t\t      ++__beg;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -347,30 +353,28 @@ namespace std\n \n       // Extract.\n       string __found_grouping;\n-      const char_type __sep = __lc->_M_thousands_sep;\n       int __sep_pos = 0;\n-      while (__beg != __end)\n+      for (; __beg != __end; ++__beg)\n         {\n-          const char_type* __p = __traits_type::find(__lit + _S_izero, \n-\t\t\t\t\t\t     __len,  __c);\n-\n+\t  const char_type __c = *__beg;\n+          const char_type* __p = __traits_type::find(__lit + _S_izero,\n+\t\t\t\t\t\t     __len, __c);\n           // NB: strchr returns true for __c == 0x0\n           if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n \t      __xtrc += _S_atoms_in[__p - __lit];\n \t      ++__sep_pos;\n-\t      __c = *(++__beg);\n \t    }\n-          else if (__traits_type::eq(__c, __sep) && __lc->_M_use_grouping)\n+          else if (__traits_type::eq(__c, __lc->_M_thousands_sep)\n+\t\t   && __lc->_M_use_grouping)\n \t    {\n               // NB: Thousands separator at the beginning of a string\n               // is a no-no, as is two consecutive thousands separators.\n               if (__sep_pos)\n                 {\n                   __found_grouping += static_cast<char>(__sep_pos);\n                   __sep_pos = 0;\n-\t\t  __c = *(++__beg);\n                 }\n               else\n \t\t{\n@@ -1609,6 +1613,18 @@ namespace std\n \t\t  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2, \n \t\t\t\t __ctype, __err);\n \t\t  break;\n+\t\tcase 'e':\n+\t\t  // Day [1, 31], with single digits preceded by\n+\t\t  // space. [tm_mday]\n+\t\t  if (__ctype.is(ctype_base::space, *__beg))\n+\t\t    _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9, 1,\n+\t\t\t\t   __ctype, __err);\n+\t\t  else if (*__beg != __ctype.widen('0'))\n+\t\t    _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31, 2,\n+\t\t\t\t   __ctype, __err);\t\t    \n+\t\t  else\n+\t\t    __err |= ios_base::failbit;\n+\t\t  break;\t\t    \n \t\tcase 'D':\n \t\t  // Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]\n \t\t  __cs = \"%m/%d/%y\";\n@@ -1660,7 +1676,7 @@ namespace std\n \t\t  if (__ctype.narrow(*__beg, 0) == '\\t')\n \t\t    ++__beg;\n \t\t  else\n-\t\t__err |= ios_base::failbit;\n+\t\t    __err |= ios_base::failbit;\n \t\t  break;\n \t\tcase 'T':\n \t\t  // Equivalent to (%H:%M:%S).\n@@ -1707,10 +1723,9 @@ namespace std\n \t\t\t\t      14, __err);\n \t\t      \n \t\t      // GMT requires special effort.\n-\t\t      char_type __c = *__beg;\n-\t\t      if (!__err && __tmp == 0 \n-\t\t\t  && (__c == __ctype.widen('-') \n-\t\t\t      || __c == __ctype.widen('+')))\n+\t\t      if (__beg != __end && !__err && __tmp == 0\n+\t\t\t  && (*__beg == __ctype.widen('-') \n+\t\t\t      || *__beg == __ctype.widen('+')))\n \t\t\t{\n \t\t\t  _M_extract_num(__beg, __end, __tmp, 0, 23, 2,\n \t\t\t\t\t  __ctype, __err);\n@@ -2245,7 +2260,7 @@ namespace std\n   template<typename _CharT>\n     bool\n     __verify_grouping(const basic_string<_CharT>& __grouping, \n-\t\t      basic_string<_CharT>& __grouping_tmp)\n+\t\t      const basic_string<_CharT>& __grouping_tmp)\n     {         \n       size_t __i = 0;\n       size_t __j = 0;"}, {"sha": "cb3304d27d9b7b962a5f33dc2d4b6181263090cf", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -233,7 +233,8 @@ namespace std\n \n   template\n     bool\n-    __verify_grouping<C>(const basic_string<C>&, basic_string<C>&);\n+    __verify_grouping<C>(const basic_string<C>&,\n+\t\t\t const basic_string<C>&);\n \n   template class __pad<C, char_traits<C> >;\n "}, {"sha": "7e8e69dda896717bd815c57c0088c025012e646a", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/char/7.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F7.cc?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -0,0 +1,58 @@\n+// 2003-10-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  // cache the num_get facet\n+  istringstream iss;\n+  const num_get<char>& ng = use_facet<num_get<char> >(iss.getloc()); \n+  ios_base::iostate err = ios_base::goodbit;\n+  iterator_type end;\n+  double d;\n+\n+  iss.str(\"+e3\");\n+  end = ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == 'e' );\n+\n+  iss.str(\".e+1\");\n+  iss.clear();\n+  err = ios_base::goodbit;\n+  end = ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == 'e' );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "fdb9ee7ac36d797bb50359447d5696db99440845", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/7.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F7.cc?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -0,0 +1,58 @@\n+// 2003-10-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<wchar_t> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  // cache the num_get facet\n+  wistringstream iss;\n+  const num_get<wchar_t>& ng = use_facet<num_get<wchar_t> >(iss.getloc()); \n+  ios_base::iostate err = ios_base::goodbit;\n+  iterator_type end;\n+  double d;\n+\n+  iss.str(L\"+e3\");\n+  end = ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'e' );\n+\n+  iss.str(L\".e+1\");\n+  iss.clear();\n+  err = ios_base::goodbit;\n+  end = ng.get(iss.rdbuf(), 0, iss, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'e' );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "99e4aeac048cde18cb39c6ad8ae7d37720856675", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_date/char/12750.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fchar%2F12750.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fchar%2F12750.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fchar%2F12750.cc?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -0,0 +1,79 @@\n+// 2003-10-27 Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.5.1.1 time_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/12750\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> iterator_type;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  // basic construction\n+  locale loc_is = __gnu_test::try_named_locale(\"is_IS\");\n+\n+  // create an ostream-derived object, cache the time_get facet\n+  iterator_type end;\n+\n+  istringstream iss;\n+  const time_get<char>& tim_get = use_facet<time_get<char> >(iss.getloc()); \n+\n+  const ios_base::iostate good = ios_base::goodbit;\n+  ios_base::iostate errorstate = good;\n+\n+  // create \"C\" time objects\n+  const tm time_bday01 = { 0, 0, 12, 2, 9, 103, 4, 274, -1 };\n+  const tm time_bday02 = { 0, 0, 12, 26, 9, 103, 0, 298, -1 };\n+\n+  // inspection of named locales, is_IS\n+  iss.imbue(loc_is);\n+\n+  iss.str(\"Fim  2.Okt 2003\");\n+  iterator_type is_it01(iss);\n+  tm time01;\n+  errorstate = good;\n+  tim_get.get_date(is_it01, end, iss, errorstate, &time01);\n+  VERIFY( time01.tm_mon == time_bday01.tm_mon );\n+  VERIFY( time01.tm_mday == time_bday01.tm_mday );\n+  VERIFY( time01.tm_year == time_bday01.tm_year );\n+  VERIFY( errorstate == ios_base::eofbit );\n+\n+  iss.str(\"Sun 26.Okt 2003\");\n+  iterator_type is_it02(iss);\n+  tm time02;\n+  errorstate = good;\n+  tim_get.get_date(is_it02, end, iss, errorstate, &time02);\n+  VERIFY( time02.tm_mon == time_bday02.tm_mon );\n+  VERIFY( time02.tm_mday == time_bday02.tm_mday );\n+  VERIFY( time02.tm_year == time_bday02.tm_year );\n+  VERIFY( errorstate == ios_base::eofbit );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c122d6598dc4da4d47adf76aa51ff127982584a1", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_date/wchar_t/12750.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fwchar_t%2F12750.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20d2b7871757cbe473b0a819a4ead80423c4a74/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fwchar_t%2F12750.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fwchar_t%2F12750.cc?ref=f20d2b7871757cbe473b0a819a4ead80423c4a74", "patch": "@@ -0,0 +1,79 @@\n+// 2003-10-27 Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.5.1.1 time_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/12750\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<wchar_t> iterator_type;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  // basic construction\n+  locale loc_is = __gnu_test::try_named_locale(\"is_IS\");\n+\n+  // create an ostream-derived object, cache the time_get facet\n+  iterator_type end;\n+\n+  wistringstream iss;\n+  const time_get<wchar_t>& tim_get = use_facet<time_get<wchar_t> >(iss.getloc()); \n+\n+  const ios_base::iostate good = ios_base::goodbit;\n+  ios_base::iostate errorstate = good;\n+\n+  // create \"C\" time objects\n+  const tm time_bday01 = { 0, 0, 12, 2, 9, 103, 4, 274, -1 };\n+  const tm time_bday02 = { 0, 0, 12, 26, 9, 103, 0, 298, -1 };\n+\n+  // inspection of named locales, is_IS\n+  iss.imbue(loc_is);\n+\n+  iss.str(L\"Fim  2.Okt 2003\");\n+  iterator_type is_it01(iss);\n+  tm time01;\n+  errorstate = good;\n+  tim_get.get_date(is_it01, end, iss, errorstate, &time01);\n+  VERIFY( time01.tm_mon == time_bday01.tm_mon );\n+  VERIFY( time01.tm_mday == time_bday01.tm_mday );\n+  VERIFY( time01.tm_year == time_bday01.tm_year );\n+  VERIFY( errorstate == ios_base::eofbit );\n+\n+  iss.str(L\"Sun 26.Okt 2003\");\n+  iterator_type is_it02(iss);\n+  tm time02;\n+  errorstate = good;\n+  tim_get.get_date(is_it02, end, iss, errorstate, &time02);\n+  VERIFY( time02.tm_mon == time_bday02.tm_mon );\n+  VERIFY( time02.tm_mday == time_bday02.tm_mday );\n+  VERIFY( time02.tm_year == time_bday02.tm_year );\n+  VERIFY( errorstate == ios_base::eofbit );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}