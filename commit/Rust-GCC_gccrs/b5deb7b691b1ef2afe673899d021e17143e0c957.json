{"sha": "b5deb7b691b1ef2afe673899d021e17143e0c957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVkZWI3YjY5MWIxZWYyYWZlNjczODk5ZDAyMWUxNzE0M2UwYzk1Nw==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-08-27T13:34:14Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-08-27T13:34:14Z"}, "message": "Separate target-specific initialization from general back-end initialization.\n\n2007-08-27  Sandra Loosemore  <sandra@codesourcery.com>\n\t    David Ung  <davidu@mips.com>\n            Nigel Stephens <nigel@mips.com>\n\n\tgcc/\n\tSeparate target-specific initialization from general\n\tback-end initialization.\n\n\t* toplev.c (init_alignments): New, split out from...\n\t(process_options): ...here.\n\t(backend_init_target):  New, split out from...\n\t(backend_init): ...here.\n\t(lang_dependent_init_target):  New, split out from...\n\t(lang_dependent_init): ...here.\n\t(target_reinit): New.\n\t* toplev.h (target_reinit): Declare.\n\t* expr.c (init_expr_target): Renamed from init_expr_once, since it\n\tnow can be called more than once.  Update comments.\n\t* expr.h (init_expr_target): Likewise.\n\t* alias.c (init_alias_target): Renamed from init_alias_once, since it\n\tnow can be called more than once.  Explicitly zero\n\tstatic_reg_base_value.\n\t* emit-rtl.c (init_emit_regs): New, split out from...\n\t(init_emit_once): Here.\n\t* regclass.c (initial_fixed_regs, initial_call_used_regs): Make\n\tnon-const, so that changes from command-line arguments can overwrite\n\tvalues provided by the static initializers.\n\t(initial_call_really_used_regs): New, used similarly to the above.\n\t(initial_reg_names): Likewise.\n\t(last_mode_for_init_move_cost): Promoted function-local static to\n\tfile-scope static to make it accessible outside init_move_cost.\n\t(init_reg_sets): Do not initialize fixed_regs and call_used_regs yet.\n\tDo not initialize inv_reg_alloc_order yet, either.  Do initialize\n\treg_names since it is needed for parsing command-line options.\n\t(init_move_cost): Use last_mode_for_init_move_cost instead of\n\tfunction-local static.\n\t(init_reg_sets_1): Initialize fixed_regs, call_used_regs, and\n\tcall_really_used_regs now.  Reinitialize reg_names.  Also\n\tinitialize inv_reg_alloc_order.  Zero reg_class_subunion and\n\treg_class_superunion.  Clear losing_caller_save_reg_set.\n\tPreserve global registers if called more than once.  Reset\n\tmove cost, may_move_in_cost, may_move_out_cost, and\n\tlast_mode_for_init_move_cost.\n\t(init_reg_modes_target): Renamed from init_reg_modes_once, since it\n\tcan now be invoked more than once.  Update comments.\n\t(init_regs): Update comments.\n\t(fix_register): Update initial_fixed_regs, initial_call_used_regs,\n\tand initial_call_really_used_regs, instead of the non-initial \n        variables.  This allows us to save the command-line register settings\n\tafter target reinitialization.\n\t(init_reg_autoinc): Zero forbidden_inc_dec_classes.\n\t* rtl.h (init_emit_regs): Declare.\n\t(init_reg_modes_target, init_alias_target): Renamed as described\n\tabove.\n\t* reload1.c (init_reload): Update comments.\n\t* optabs.c (init_optabs): Likewise.\n\t* cfgloopanal.c (init_set_costs): Explicitly zero target_avail_regs.\n\t\n\n\nCo-Authored-By: David Ung <davidu@mips.com>\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r127832", "tree": {"sha": "d01f0d513ddee192c39d3e09c5ac2bddde1ae691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d01f0d513ddee192c39d3e09c5ac2bddde1ae691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5deb7b691b1ef2afe673899d021e17143e0c957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5deb7b691b1ef2afe673899d021e17143e0c957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5deb7b691b1ef2afe673899d021e17143e0c957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5deb7b691b1ef2afe673899d021e17143e0c957/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "107d76762a6f541f673fa79e7a4cecef22a85c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107d76762a6f541f673fa79e7a4cecef22a85c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/107d76762a6f541f673fa79e7a4cecef22a85c2a"}], "stats": {"total": 481, "additions": 344, "deletions": 137}, "files": [{"sha": "e88e7c95765a2a40e27704db6fdf919eb3631f84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -1,3 +1,60 @@\n+2007-08-27  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    David Ung  <davidu@mips.com>\n+            Nigel Stephens <nigel@mips.com>\n+\n+\tSeparate target-specific initialization from general\n+\tback-end initialization.\n+\n+\t* toplev.c (init_alignments): New, split out from...\n+\t(process_options): ...here.\n+\t(backend_init_target):  New, split out from...\n+\t(backend_init): ...here.\n+\t(lang_dependent_init_target):  New, split out from...\n+\t(lang_dependent_init): ...here.\n+\t(target_reinit): New.\n+\t* toplev.h (target_reinit): Declare.\n+\t* expr.c (init_expr_target): Renamed from init_expr_once, since it\n+\tnow can be called more than once.  Update comments.\n+\t* expr.h (init_expr_target): Likewise.\n+\t* alias.c (init_alias_target): Renamed from init_alias_once, since it\n+\tnow can be called more than once.  Explicitly zero\n+\tstatic_reg_base_value.\n+\t* emit-rtl.c (init_emit_regs): New, split out from...\n+\t(init_emit_once): Here.\n+\t* regclass.c (initial_fixed_regs, initial_call_used_regs): Make\n+\tnon-const, so that changes from command-line arguments can overwrite\n+\tvalues provided by the static initializers.\n+\t(initial_call_really_used_regs): New, used similarly to the above.\n+\t(initial_reg_names): Likewise.\n+\t(last_mode_for_init_move_cost): Promoted function-local static to\n+\tfile-scope static to make it accessible outside init_move_cost.\n+\t(init_reg_sets): Do not initialize fixed_regs and call_used_regs yet.\n+\tDo not initialize inv_reg_alloc_order yet, either.  Do initialize\n+\treg_names since it is needed for parsing command-line options.\n+\t(init_move_cost): Use last_mode_for_init_move_cost instead of\n+\tfunction-local static.\n+\t(init_reg_sets_1): Initialize fixed_regs, call_used_regs, and\n+\tcall_really_used_regs now.  Reinitialize reg_names.  Also\n+\tinitialize inv_reg_alloc_order.  Zero reg_class_subunion and\n+\treg_class_superunion.  Clear losing_caller_save_reg_set.\n+\tPreserve global registers if called more than once.  Reset\n+\tmove cost, may_move_in_cost, may_move_out_cost, and\n+\tlast_mode_for_init_move_cost.\n+\t(init_reg_modes_target): Renamed from init_reg_modes_once, since it\n+\tcan now be invoked more than once.  Update comments.\n+\t(init_regs): Update comments.\n+\t(fix_register): Update initial_fixed_regs, initial_call_used_regs,\n+\tand initial_call_really_used_regs, instead of the non-initial \n+        variables.  This allows us to save the command-line register settings\n+\tafter target reinitialization.\n+\t(init_reg_autoinc): Zero forbidden_inc_dec_classes.\n+\t* rtl.h (init_emit_regs): Declare.\n+\t(init_reg_modes_target, init_alias_target): Renamed as described\n+\tabove.\n+\t* reload1.c (init_reload): Update comments.\n+\t* optabs.c (init_optabs): Likewise.\n+\t* cfgloopanal.c (init_set_costs): Explicitly zero target_avail_regs.\n+\t\n 2007-08-26  Chao-ying Fu  <fu@mips.com>\n \n \t* rtl.h (XCNMPFV): Preserve const-ness of parameters through use of"}, {"sha": "870fbc47adb381fd86249c0259159e6e015cd6e6", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -2325,10 +2325,12 @@ output_dependence (const_rtx mem, const_rtx x)\n \f\n \n void\n-init_alias_once (void)\n+init_alias_target (void)\n {\n   int i;\n \n+  memset (static_reg_base_value, 0, sizeof static_reg_base_value);\n+\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     /* Check whether this register can hold an incoming pointer\n        argument.  FUNCTION_ARG_REGNO_P tests outgoing register"}, {"sha": "c00d1c501be93703e362ac52a3a976904158992a", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -334,6 +334,7 @@ init_set_costs (void)\n   rtx mem = validize_mem (gen_rtx_MEM (SImode, addr));\n   unsigned i;\n \n+  target_avail_regs = 0;\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i)\n \t&& !fixed_regs[i])"}, {"sha": "6a4604d40e946ba55dc3b6dd2e1661cd10a9497d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -5260,6 +5260,74 @@ gen_rtx_CONST_VECTOR (enum machine_mode mode, rtvec v)\n   return gen_rtx_raw_CONST_VECTOR (mode, v);\n }\n \n+/* Initialise global register information required by all functions.  */\n+\n+void\n+init_emit_regs (void)\n+{\n+  int i;\n+\n+  /* Reset register attributes */\n+  htab_empty (reg_attrs_htab);\n+\n+  /* We need reg_raw_mode, so initialize the modes now.  */\n+  init_reg_modes_target ();\n+\n+  /* Assign register numbers to the globally defined register rtx.  */\n+  pc_rtx = gen_rtx_PC (VOIDmode);\n+  cc0_rtx = gen_rtx_CC0 (VOIDmode);\n+  stack_pointer_rtx = gen_raw_REG (Pmode, STACK_POINTER_REGNUM);\n+  frame_pointer_rtx = gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);\n+  hard_frame_pointer_rtx = gen_raw_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n+  arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n+  virtual_incoming_args_rtx =\n+    gen_raw_REG (Pmode, VIRTUAL_INCOMING_ARGS_REGNUM);\n+  virtual_stack_vars_rtx =\n+    gen_raw_REG (Pmode, VIRTUAL_STACK_VARS_REGNUM);\n+  virtual_stack_dynamic_rtx =\n+    gen_raw_REG (Pmode, VIRTUAL_STACK_DYNAMIC_REGNUM);\n+  virtual_outgoing_args_rtx =\n+    gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);\n+  virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n+\n+  /* Initialize RTL for commonly used hard registers.  These are\n+     copied into regno_reg_rtx as we begin to compile each function.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    static_regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);\n+\n+#ifdef RETURN_ADDRESS_POINTER_REGNUM\n+  return_address_pointer_rtx\n+    = gen_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n+#endif\n+\n+#ifdef STATIC_CHAIN_REGNUM\n+  static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+  if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n+    static_chain_incoming_rtx\n+      = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n+  else\n+#endif\n+    static_chain_incoming_rtx = static_chain_rtx;\n+#endif\n+\n+#ifdef STATIC_CHAIN\n+  static_chain_rtx = STATIC_CHAIN;\n+\n+#ifdef STATIC_CHAIN_INCOMING\n+  static_chain_incoming_rtx = STATIC_CHAIN_INCOMING;\n+#else\n+  static_chain_incoming_rtx = static_chain_rtx;\n+#endif\n+#endif\n+\n+  if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n+    pic_offset_table_rtx = gen_raw_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n+  else\n+    pic_offset_table_rtx = NULL_RTX;\n+}\n+\n /* Create some permanent unique rtl objects shared between all functions.\n    LINE_NUMBERS is nonzero if line numbers are to be generated.  */\n \n@@ -5270,9 +5338,6 @@ init_emit_once (int line_numbers)\n   enum machine_mode mode;\n   enum machine_mode double_mode;\n \n-  /* We need reg_raw_mode, so initialize the modes now.  */\n-  init_reg_modes_once ();\n-\n   /* Initialize the CONST_INT, CONST_DOUBLE, CONST_FIXED, and memory attribute\n      hash tables.  */\n   const_int_htab = htab_create_ggc (37, const_int_htab_hash,\n@@ -5321,34 +5386,6 @@ init_emit_once (int line_numbers)\n \n   ptr_mode = mode_for_size (POINTER_SIZE, GET_MODE_CLASS (Pmode), 0);\n \n-  /* Assign register numbers to the globally defined register rtx.\n-     This must be done at runtime because the register number field\n-     is in a union and some compilers can't initialize unions.  */\n-\n-  pc_rtx = gen_rtx_PC (VOIDmode);\n-  cc0_rtx = gen_rtx_CC0 (VOIDmode);\n-  stack_pointer_rtx = gen_raw_REG (Pmode, STACK_POINTER_REGNUM);\n-  frame_pointer_rtx = gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);\n-  if (hard_frame_pointer_rtx == 0)\n-    hard_frame_pointer_rtx = gen_raw_REG (Pmode,\n-\t\t\t\t\t  HARD_FRAME_POINTER_REGNUM);\n-  if (arg_pointer_rtx == 0)\n-    arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n-  virtual_incoming_args_rtx =\n-    gen_raw_REG (Pmode, VIRTUAL_INCOMING_ARGS_REGNUM);\n-  virtual_stack_vars_rtx =\n-    gen_raw_REG (Pmode, VIRTUAL_STACK_VARS_REGNUM);\n-  virtual_stack_dynamic_rtx =\n-    gen_raw_REG (Pmode, VIRTUAL_STACK_DYNAMIC_REGNUM);\n-  virtual_outgoing_args_rtx =\n-    gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);\n-  virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n-\n-  /* Initialize RTL for commonly used hard registers.  These are\n-     copied into regno_reg_rtx as we begin to compile each function.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    static_regno_reg_rtx[i] = gen_raw_REG (reg_raw_mode[i], i);\n-\n #ifdef INIT_EXPANDERS\n   /* This is to initialize {init|mark|free}_machine_status before the first\n      call to push_function_context_to.  This is needed by the Chill front\n@@ -5558,36 +5595,6 @@ init_emit_once (int line_numbers)\n   const_tiny_rtx[0][(int) BImode] = const0_rtx;\n   if (STORE_FLAG_VALUE == 1)\n     const_tiny_rtx[1][(int) BImode] = const1_rtx;\n-\n-#ifdef RETURN_ADDRESS_POINTER_REGNUM\n-  return_address_pointer_rtx\n-    = gen_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n-#endif\n-\n-#ifdef STATIC_CHAIN_REGNUM\n-  static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-\n-#ifdef STATIC_CHAIN_INCOMING_REGNUM\n-  if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n-    static_chain_incoming_rtx\n-      = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n-  else\n-#endif\n-    static_chain_incoming_rtx = static_chain_rtx;\n-#endif\n-\n-#ifdef STATIC_CHAIN\n-  static_chain_rtx = STATIC_CHAIN;\n-\n-#ifdef STATIC_CHAIN_INCOMING\n-  static_chain_incoming_rtx = STATIC_CHAIN_INCOMING;\n-#else\n-  static_chain_incoming_rtx = static_chain_rtx;\n-#endif\n-#endif\n-\n-  if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n-    pic_offset_table_rtx = gen_raw_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n }\n \f\n /* Produce exact duplicate of insn INSN after AFTER."}, {"sha": "9f321c80ad9c146909403865598cf65faef8ec52", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -243,11 +243,12 @@ enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n #endif\n \f\n-/* This is run once per compilation to set up which modes can be used\n-   directly in memory and to initialize the block move optab.  */\n+/* This is run to set up which modes can be used\n+   directly in memory and to initialize the block move optab.  It is run\n+   at the beginning of compilation and when the target is reinitialized.  */\n \n void\n-init_expr_once (void)\n+init_expr_target (void)\n {\n   rtx insn, pat;\n   enum machine_mode mode;"}, {"sha": "f9532eceb96207c7897a70e0d6238cc4cc1b3628", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -352,9 +352,9 @@ extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n \f\n /* Functions from expr.c:  */\n \n-/* This is run once per compilation to set up which modes can be used\n-   directly in memory and to initialize the block move optab.  */\n-extern void init_expr_once (void);\n+/* This is run during target initialization to set up which modes can be \n+   used directly in memory and to initialize the block move optab.  */\n+extern void init_expr_target (void);\n \n /* This is run at the start of compiling a function.  */\n extern void init_expr (void);"}, {"sha": "f2b47fc4f685bb9b930597dffbf570afb58cbc1e", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -5563,7 +5563,7 @@ set_conv_libfunc (convert_optab optable, enum machine_mode tmode,\n     convert_optab_handler (optable, tmode, fmode)->libfunc = 0;\n }\n \n-/* Call this once to initialize the contents of the optabs\n+/* Call this to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n \n void"}, {"sha": "c41ec4d9bfce6bc7e8031686427e9daca5ab8b4a", "filename": "gcc/regclass.c", "status": "modified", "additions": 93, "deletions": 28, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -81,7 +81,7 @@ HARD_REG_SET fixed_reg_set;\n \n /* Data for initializing the above.  */\n \n-static const char initial_fixed_regs[] = FIXED_REGISTERS;\n+static char initial_fixed_regs[] = FIXED_REGISTERS;\n \n /* Indexed by hard register number, contains 1 for registers\n    that are fixed use or are clobbered by function calls.\n@@ -100,15 +100,16 @@ HARD_REG_SET losing_caller_save_reg_set;\n \n /* Data for initializing the above.  */\n \n-static const char initial_call_used_regs[] = CALL_USED_REGISTERS;\n+static char initial_call_used_regs[] = CALL_USED_REGISTERS;\n \n /* This is much like call_used_regs, except it doesn't have to\n    be a superset of FIXED_REGISTERS. This vector indicates\n    what is really call clobbered, and is used when defining\n    regs_invalidated_by_call.  */\n \n #ifdef CALL_REALLY_USED_REGISTERS\n-char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n+static char initial_call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n+char call_really_used_regs[FIRST_PSEUDO_REGISTER];\n #endif\n \n #ifdef CALL_REALLY_USED_REGISTERS\n@@ -192,7 +193,11 @@ enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n /* Array containing all of the register names.  */\n \n-const char * reg_names[] = REGISTER_NAMES;\n+const char * reg_names[FIRST_PSEUDO_REGISTER];\n+\n+/* Data for initializing the above.  */\n+\n+const char * initial_reg_names[] = REGISTER_NAMES;\n \n /* Array containing all of the register class names.  */\n \n@@ -230,6 +235,9 @@ static move_table *may_move_in_cost[MAX_MACHINE_MODE];\n \n static move_table *may_move_out_cost[MAX_MACHINE_MODE];\n \n+/* Keep track of the last mode we initialized move costs for.  */\n+static int last_mode_for_init_move_cost;\n+\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n /* These are the classes that regs which are auto-incremented or decremented\n@@ -298,19 +306,12 @@ init_reg_sets (void)\n \t  SET_HARD_REG_BIT (reg_class_contents[i], j);\n     }\n \n-  /* Sanity check: make sure the target macros FIXED_REGISTERS and\n-     CALL_USED_REGISTERS had the right number of initializers.  */\n-  gcc_assert (sizeof fixed_regs == sizeof initial_fixed_regs);\n-  gcc_assert (sizeof call_used_regs == sizeof initial_call_used_regs);\n-\n-  memcpy (fixed_regs, initial_fixed_regs, sizeof fixed_regs);\n-  memcpy (call_used_regs, initial_call_used_regs, sizeof call_used_regs);\n   memset (global_regs, 0, sizeof global_regs);\n \n-#ifdef REG_ALLOC_ORDER\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    inv_reg_alloc_order[reg_alloc_order[i]] = i;\n-#endif\n+  /* Processing of command-line options like -ffixed needs to know the\n+     initial set of register names, so initialize that now.  */\n+  gcc_assert (sizeof reg_names == sizeof initial_reg_names);\n+  memcpy (reg_names, initial_reg_names, sizeof reg_names);\n }\n \n /* Initialize may_move_cost and friends for mode M.  */\n@@ -319,7 +320,6 @@ static void\n init_move_cost (enum machine_mode m)\n {\n   static unsigned short last_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n-  static int last_mode = -1;\n   bool all_match = true;\n   unsigned int i, j;\n \n@@ -339,14 +339,14 @@ init_move_cost (enum machine_mode m)\n \t  all_match &= (last_move_cost[i][j] == cost);\n \t  last_move_cost[i][j] = cost;\n \t}\n-  if (all_match && last_mode != -1)\n+  if (all_match && last_mode_for_init_move_cost != -1)\n     {\n-      move_cost[m] = move_cost[last_mode];\n-      may_move_in_cost[m] = may_move_in_cost[last_mode];\n-      may_move_out_cost[m] = may_move_out_cost[last_mode];\n+      move_cost[m] = move_cost[last_mode_for_init_move_cost];\n+      may_move_in_cost[m] = may_move_in_cost[last_mode_for_init_move_cost];\n+      may_move_out_cost[m] = may_move_out_cost[last_mode_for_init_move_cost];\n       return;\n     }\n-  last_mode = m;\n+  last_mode_for_init_move_cost = m;\n   move_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n \t\t\t\t\t* N_REG_CLASSES);\n   may_move_in_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n@@ -412,6 +412,31 @@ init_reg_sets_1 (void)\n   unsigned int i, j;\n   unsigned int /* enum machine_mode */ m;\n \n+  /* Sanity check:  make sure the target macros FIXED_REGISTERS and\n+     CALL_USED_REGISTERS had the right number of initializers.  */\n+  gcc_assert (sizeof fixed_regs == sizeof initial_fixed_regs);\n+  gcc_assert (sizeof call_used_regs == sizeof initial_call_used_regs);\n+\n+  memcpy (fixed_regs, initial_fixed_regs, sizeof fixed_regs);\n+  memcpy (call_used_regs, initial_call_used_regs, sizeof call_used_regs);\n+\n+  /* Likewise for call_really_used_regs.  */\n+#ifdef CALL_REALLY_USED_REGISTERS\n+  gcc_assert (sizeof call_really_used_regs\n+\t      == sizeof initial_call_really_used_regs);\n+  memcpy (call_really_used_regs, initial_call_really_used_regs,\n+\t  sizeof call_really_used_regs);\n+#endif\n+\n+  /* And similarly for reg_names.  */\n+  gcc_assert (sizeof reg_names == sizeof initial_reg_names);\n+  memcpy (reg_names, initial_reg_names, sizeof reg_names);\n+\n+#ifdef REG_ALLOC_ORDER\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    inv_reg_alloc_order[reg_alloc_order[i]] = i;\n+#endif\n+\n   /* This macro allows the fixed or call-used registers\n      and the register classes to depend on target flags.  */\n \n@@ -431,6 +456,7 @@ init_reg_sets_1 (void)\n      reg_class_subunion[I][J] gets the largest-numbered reg-class\n      that is contained in the union of classes I and J.  */\n \n+  memset (reg_class_subunion, 0, sizeof reg_class_subunion);\n   for (i = 0; i < N_REG_CLASSES; i++)\n     {\n       for (j = 0; j < N_REG_CLASSES; j++)\n@@ -453,6 +479,7 @@ init_reg_sets_1 (void)\n      reg_class_superunion[I][J] gets the smallest-numbered reg-class\n      containing the union of classes I and J.  */\n \n+  memset (reg_class_superunion, 0, sizeof reg_class_superunion);\n   for (i = 0; i < N_REG_CLASSES; i++)\n     {\n       for (j = 0; j < N_REG_CLASSES; j++)\n@@ -511,6 +538,7 @@ init_reg_sets_1 (void)\n   CLEAR_HARD_REG_SET (call_used_reg_set);\n   CLEAR_HARD_REG_SET (call_fixed_reg_set);\n   CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n+  CLEAR_HARD_REG_SET (losing_caller_save_reg_set);\n \n   memcpy (call_fixed_regs, fixed_regs, sizeof call_fixed_regs);\n \n@@ -564,6 +592,18 @@ init_reg_sets_1 (void)\n \tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n     }\n \n+  /* Preserve global registers if called more than once.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (global_regs[i])\n+\t{\n+\t  fixed_regs[i] = call_used_regs[i] = call_fixed_regs[i] = 1;\n+\t  SET_HARD_REG_BIT (fixed_reg_set, i);\n+\t  SET_HARD_REG_BIT (call_used_reg_set, i);\n+\t  SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t}\n+    }\n+\n   memset (have_regs_of_mode, 0, sizeof (have_regs_of_mode));\n   memset (contains_reg_of_mode, 0, sizeof (contains_reg_of_mode));\n   for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n@@ -582,14 +622,36 @@ init_reg_sets_1 (void)\n \t     have_regs_of_mode [m] = 1;\n \t  }\n      }\n+\n+  /* Reset move_cost and friends, making sure we only free shared\n+     table entries once.  */\n+  for (i = 0; i < MAX_MACHINE_MODE; i++)\n+    if (move_cost[i])\n+      {\n+\tfor (j = 0; j < i && move_cost[i] != move_cost[j]; j++)\n+\t  ;\n+\tif (i == j)\n+\t  {\n+\t    free (move_cost[i]);\n+\t    free (may_move_in_cost[i]);\n+\t    free (may_move_out_cost[i]);\n+\t  }\n+      }\n+  memset (move_cost, 0, sizeof move_cost);\n+  memset (may_move_in_cost, 0, sizeof may_move_in_cost);\n+  memset (may_move_out_cost, 0, sizeof may_move_out_cost);\n+  last_mode_for_init_move_cost = -1;\n }\n \n /* Compute the table of register modes.\n    These values are used to record death information for individual registers\n-   (as opposed to a multi-register mode).  */\n+   (as opposed to a multi-register mode).\n+   This function might be invoked more than once, if the target has support\n+   for changing register usage conventions on a per-function basis.\n+*/\n \n void\n-init_reg_modes_once (void)\n+init_reg_modes_target (void)\n {\n   int i, j;\n \n@@ -611,8 +673,10 @@ init_reg_modes_once (void)\n     }\n }\n \n-/* Finish initializing the register sets and\n-   initialize the register modes.  */\n+/* Finish initializing the register sets and initialize the register modes.\n+   This function might be invoked more than once, if the target has support\n+   for changing register usage conventions on a per-function basis.\n+*/\n \n void\n init_regs (void)\n@@ -782,11 +846,11 @@ fix_register (const char *name, int fixed, int call_used)\n \t}\n       else\n \t{\n-\t  fixed_regs[i] = fixed;\n-\t  call_used_regs[i] = call_used;\n+\t  initial_fixed_regs[i] = fixed;\n+\t  initial_call_used_regs[i] = call_used;\n #ifdef CALL_REALLY_USED_REGISTERS\n \t  if (fixed == 0)\n-\t    call_really_used_regs[i] = call_used;\n+\t    initial_call_really_used_regs[i] = call_used;\n #endif\n \t}\n     }\n@@ -1157,6 +1221,7 @@ init_reg_autoinc (void)\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   int i;\n \n+  memset (forbidden_inc_dec_class, 0, sizeof forbidden_inc_dec_classes);\n   for (i = 0; i < N_REG_CLASSES; i++)\n     {\n       rtx r = gen_rtx_raw_REG (VOIDmode, 0);"}, {"sha": "41789696685575737fc01147b081f4d515126e30", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -448,7 +448,8 @@ static int reloads_conflict (int, int);\n static rtx gen_reload (rtx, rtx, int, enum reload_type);\n static rtx emit_insn_if_valid_for_reload (rtx);\n \f\n-/* Initialize the reload pass once per compilation.  */\n+/* Initialize the reload pass.  This is called at the beginning of compilation\n+   and may be called again if the target is reinitialized.  */\n \n void\n init_reload (void)"}, {"sha": "859965858483bddd74e0f069c3b1637810ca0c0b", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -2077,6 +2077,7 @@ extern int get_max_uid (void);\n extern int in_sequence_p (void);\n extern void force_next_line_note (void);\n extern void init_emit (void);\n+extern void init_emit_regs (void);\n extern void init_emit_once (int);\n extern void push_topmost_sequence (void);\n extern void pop_topmost_sequence (void);\n@@ -2186,7 +2187,7 @@ extern void build_insn_chain (rtx);\n extern int reg_classes_intersect_p (enum reg_class, enum reg_class);\n extern int reg_class_subset_p (enum reg_class, enum reg_class);\n extern void globalize_reg (int);\n-extern void init_reg_modes_once (void);\n+extern void init_reg_modes_target (void);\n extern void init_regs (void);\n extern void init_fake_stack_mems (void);\n extern void init_reg_sets (void);\n@@ -2254,7 +2255,7 @@ extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,\n extern int read_dependence (const_rtx, const_rtx);\n extern int anti_dependence (const_rtx, const_rtx);\n extern int output_dependence (const_rtx, const_rtx);\n-extern void init_alias_once (void);\n+extern void init_alias_target (void);\n extern void init_alias_analysis (void);\n extern void end_alias_analysis (void);\n extern bool memory_modified_in_insn_p (const_rtx, const_rtx);"}, {"sha": "fe7918fd7368ec782d71393c854a15cf414919e5", "filename": "gcc/toplev.c", "status": "modified", "additions": 107, "deletions": 37, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -1685,6 +1685,31 @@ target_supports_section_anchors_p (void)\n   return true;\n }\n \n+/* Default the align_* variables to 1 if they're still unset, and\n+   set up the align_*_log variables.  */\n+static void\n+init_alignments (void)\n+{\n+  if (align_loops <= 0)\n+    align_loops = 1;\n+  if (align_loops_max_skip > align_loops)\n+    align_loops_max_skip = align_loops - 1;\n+  align_loops_log = floor_log2 (align_loops * 2 - 1);\n+  if (align_jumps <= 0)\n+    align_jumps = 1;\n+  if (align_jumps_max_skip > align_jumps)\n+    align_jumps_max_skip = align_jumps - 1;\n+  align_jumps_log = floor_log2 (align_jumps * 2 - 1);\n+  if (align_labels <= 0)\n+    align_labels = 1;\n+  align_labels_log = floor_log2 (align_labels * 2 - 1);\n+  if (align_labels_max_skip > align_labels)\n+    align_labels_max_skip = align_labels - 1;\n+  if (align_functions <= 0)\n+    align_functions = 1;\n+  align_functions_log = floor_log2 (align_functions * 2 - 1);\n+}\n+\n /* Process the options that have been parsed.  */\n static void\n process_options (void)\n@@ -1730,23 +1755,6 @@ process_options (void)\n   else\n     aux_base_name = \"gccaux\";\n \n-  /* Set up the align_*_log variables, defaulting them to 1 if they\n-     were still unset.  */\n-  if (align_loops <= 0) align_loops = 1;\n-  if (align_loops_max_skip > align_loops || !align_loops)\n-    align_loops_max_skip = align_loops - 1;\n-  align_loops_log = floor_log2 (align_loops * 2 - 1);\n-  if (align_jumps <= 0) align_jumps = 1;\n-  if (align_jumps_max_skip > align_jumps || !align_jumps)\n-    align_jumps_max_skip = align_jumps - 1;\n-  align_jumps_log = floor_log2 (align_jumps * 2 - 1);\n-  if (align_labels <= 0) align_labels = 1;\n-  align_labels_log = floor_log2 (align_labels * 2 - 1);\n-  if (align_labels_max_skip > align_labels || !align_labels)\n-    align_labels_max_skip = align_labels - 1;\n-  if (align_functions <= 0) align_functions = 1;\n-  align_functions_log = floor_log2 (align_functions * 2 - 1);\n-\n   /* Unrolling all loops implies that standard loop unrolling must also\n      be done.  */\n   if (flag_unroll_all_loops)\n@@ -1998,7 +2006,50 @@ process_options (void)\n     }\n }\n \n-/* Initialize the compiler back end.  */\n+/* This function can be called multiple times to reinitialize the compiler\n+   back end when register classes or instruction sets have changed,\n+   before each function.  */\n+static void\n+backend_init_target (void)\n+{\n+  /* Initialize alignment variables.  */\n+  init_alignments ();\n+\n+  /* This reinitializes hard_frame_pointer, and calls init_reg_modes_target()\n+     to initialize reg_raw_mode[].  */\n+  init_emit_regs ();\n+\n+  /* This invokes target hooks to set fixed_reg[] etc, which is\n+     mode-dependent.  */\n+  init_regs ();\n+\n+  /* This depends on stack_pointer_rtx.  */\n+  init_fake_stack_mems ();\n+\n+  /* Sets static_base_value[HARD_FRAME_POINTER_REGNUM], which is\n+     mode-dependent.  */\n+  init_alias_target ();\n+\n+  /* Depends on HARD_FRAME_POINTER_REGNUM.  */\n+  init_reload ();\n+\n+  /* The following initialization functions need to generate rtl, so\n+     provide a dummy function context for them.  */\n+  init_dummy_function_start ();\n+\n+  /* rtx_cost is mode-dependent, so cached values need to be recomputed\n+     on a mode change.  */\n+  init_expmed ();\n+\n+  /* We may need to recompute regno_save_code[] and regno_restore_code[]\n+     after a mode change as well.  */\n+  if (flag_caller_saves)\n+    init_caller_save ();\n+  expand_dummy_function_end ();\n+}\n+\n+/* Initialize the compiler back end.  This function is called only once,\n+   when starting the compiler.  */\n static void\n backend_init (void)\n {\n@@ -2011,19 +2062,34 @@ backend_init (void)\n \t\t    || flag_test_coverage);\n \n   init_rtlanal ();\n-  init_regs ();\n-  init_fake_stack_mems ();\n-  init_alias_once ();\n   init_inline_once ();\n-  init_reload ();\n   init_varasm_once ();\n \n+  /* Initialize the target-specific back end pieces.  */\n+  backend_init_target ();\n+}\n+\n+/* Initialize things that are both lang-dependent and target-dependent.\n+   This function can be called more than once if target parameters change.  */\n+static void\n+lang_dependent_init_target (void)\n+{\n+  /* This creates various _DECL nodes, so needs to be called after the\n+     front end is initialized.  It also depends on the HAVE_xxx macros\n+     generated from the target machine description.  */\n+  init_optabs ();\n+\n   /* The following initialization functions need to generate rtl, so\n      provide a dummy function context for them.  */\n   init_dummy_function_start ();\n-  init_expmed ();\n-  if (flag_caller_saves)\n-    init_caller_save ();\n+\n+  /* Do the target-specific parts of expr initialization.  */\n+  init_expr_target ();\n+\n+  /* Although the actions of init_set_costs are language-independent,\n+     it uses optabs, so we cannot call it from backend_init.  */\n+  init_set_costs ();\n+\n   expand_dummy_function_end ();\n }\n \n@@ -2048,21 +2114,12 @@ lang_dependent_init (const char *name)\n \n   init_asm_output (name);\n \n-  /* These create various _DECL nodes, so need to be called after the\n+  /* This creates various _DECL nodes, so needs to be called after the\n      front end is initialized.  */\n   init_eh ();\n-  init_optabs ();\n-\n-  /* The following initialization functions need to generate rtl, so\n-     provide a dummy function context for them.  */\n-  init_dummy_function_start ();\n-  init_expr_once ();\n-\n-  /* Although the actions of init_set_costs are language-independent,\n-     it uses optabs, so we cannot call it from backend_init.  */\n-  init_set_costs ();\n \n-  expand_dummy_function_end ();\n+  /* Do the target-specific parts of the initialization.  */\n+  lang_dependent_init_target ();\n \n   /* If dbx symbol table desired, initialize writing it and output the\n      predefined types.  */\n@@ -2082,6 +2139,19 @@ lang_dependent_init (const char *name)\n   return 1;\n }\n \n+\n+/* Reinitialize everything when target parameters, such as register usage,\n+   have changed.  */\n+void\n+target_reinit (void)\n+{\n+  /* Reinitialise RTL backend.  */\n+  backend_init_target ();\n+\n+  /* Reinitialize lang-dependent parts.  */\n+  lang_dependent_init_target ();\n+}\n+\n void\n dump_memory_report (bool final)\n {"}, {"sha": "2397dee6dbfbe6e39d98dc682cf7d01d80c6a400", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5deb7b691b1ef2afe673899d021e17143e0c957/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=b5deb7b691b1ef2afe673899d021e17143e0c957", "patch": "@@ -101,6 +101,8 @@ extern void write_global_declarations (void);\n \n extern void dump_memory_report (bool);\n \n+extern void target_reinit (void);\n+\n /* A unique local time stamp, might be zero if none is available.  */\n extern unsigned local_tick;\n "}]}