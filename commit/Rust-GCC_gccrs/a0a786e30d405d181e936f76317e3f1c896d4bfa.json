{"sha": "a0a786e30d405d181e936f76317e3f1c896d4bfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhNzg2ZTMwZDQwNWQxODFlOTM2Zjc2MzE3ZTNmMWM4OTZkNGJmYQ==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2010-10-05T09:26:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-05T09:26:00Z"}, "message": "gnatcmd.adb, [...] (Project_Search_Path): New type.\n\n2010-10-05  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, prj-proc.adb, prj-part.adb, prj-ext.adb, prj-ext.ads,\n\tswitch-m.adb, clean.adb, prj-nmsc.adb, prj-nmsc.ads, prj-env.adb,\n\tprj-env.ads, prj-tree.adb, prj-tree.ads (Project_Search_Path): New type.\n\nFrom-SVN: r164969", "tree": {"sha": "d6903f3f2b63fe455d17e373f993509b5a0bf01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6903f3f2b63fe455d17e373f993509b5a0bf01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a786e30d405d181e936f76317e3f1c896d4bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a786e30d405d181e936f76317e3f1c896d4bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a786e30d405d181e936f76317e3f1c896d4bfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a786e30d405d181e936f76317e3f1c896d4bfa/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9f5f49ae6d54cac2a967ffdfab8b7b4a113cb9"}], "stats": {"total": 1403, "additions": 735, "deletions": 668}, "files": [{"sha": "6f239a3573b4769424d807396cfe001e4e1ddf85", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -1,3 +1,9 @@\n+2010-10-05  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, prj-proc.adb, prj-part.adb, prj-ext.adb, prj-ext.ads,\n+\tswitch-m.adb, clean.adb, prj-nmsc.adb, prj-nmsc.ads, prj-env.adb,\n+\tprj-env.ads, prj-tree.adb, prj-tree.ads (Project_Search_Path): New type.\n+\n 2010-10-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_ch5.adb (Make_Field_Expr): Revert previous change (removed)."}, {"sha": "8174e91e5edd8f305b185aa17cf38be84b533791", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -1692,8 +1692,9 @@ package body Clean is\n                            Add_Lib_Search_Dir (Arg (4 .. Arg'Last));\n \n                         elsif Arg (3) = 'P' then\n-                           Prj.Ext.Add_Search_Project_Directory\n-                             (Project_Node_Tree, Arg (4 .. Arg'Last));\n+                           Prj.Env.Add_Directories\n+                             (Project_Node_Tree.Project_Path,\n+                              Arg (4 .. Arg'Last));\n \n                         else\n                            Bad_Argument;"}, {"sha": "855a08dcf0a3a726e5a2965c0e0dc336332a08a7", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -1668,8 +1668,9 @@ begin\n                   elsif Argv'Length > 3\n                     and then Argv (Argv'First + 1 .. Argv'First + 2) = \"aP\"\n                   then\n-                     Add_Search_Project_Directory\n-                       (Project_Node_Tree, Argv (Argv'First + 3 .. Argv'Last));\n+                     Prj.Env.Add_Directories\n+                       (Project_Node_Tree.Project_Path,\n+                        Argv (Argv'First + 3 .. Argv'Last));\n \n                      Remove_Switch (Arg_Num);\n "}, {"sha": "cb01145d24a70635cad789c88ff7f28fd1b68148", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 451, "deletions": 3, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -24,17 +24,29 @@\n ------------------------------------------------------------------------------\n \n with Fmap;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with Hostparm;\n+with Makeutl;                   use Makeutl;\n with Opt;\n-with Osint;    use Osint;\n-with Output;   use Output;\n-with Prj.Com;  use Prj.Com;\n+with Osint;                     use Osint;\n+with Output;                    use Output;\n+with Prj.Com;                   use Prj.Com;\n+with Sdefault;\n with Tempdir;\n \n package body Prj.Env is\n \n    Buffer_Initial : constant := 1_000;\n    --  Initial size of Buffer\n \n+   Uninitialized_Prefix : constant String := '#' & Path_Separator;\n+   --  Prefix to indicate that the project path has not been initilized yet.\n+   --  Must be two characters long\n+\n+   No_Project_Default_Dir : constant String := \"-\";\n+   --  Indicator in the project path to indicate that the default search\n+   --  directories should not be added to the path\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -97,6 +109,11 @@ package body Prj.Env is\n    --  Return a project that is either Project or an extended ancestor of\n    --  Project that itself is not extended.\n \n+   procedure Initialize_Project_Path\n+     (Self : in out Project_Search_Path; Target_Name : String);\n+   --  Initialize Current_Project_Path.\n+   --  Does nothing if the path has already been initialized properly\n+\n    ----------------------\n    -- Ada_Include_Path --\n    ----------------------\n@@ -1739,4 +1756,435 @@ package body Prj.Env is\n       return Result;\n    end Ultimate_Extension_Of;\n \n+   ---------------------\n+   -- Add_Directories --\n+   ---------------------\n+\n+   procedure Add_Directories\n+     (Self : in out Project_Search_Path;\n+      Path : String)\n+   is\n+      Tmp : String_Access;\n+   begin\n+      if Self.Path = null then\n+         Self.Path := new String'(Uninitialized_Prefix & Path);\n+      else\n+         Tmp := Self.Path;\n+         Self.Path := new String'(Tmp.all & Path_Separator & Path);\n+         Free (Tmp);\n+      end if;\n+   end Add_Directories;\n+\n+   -----------------------------\n+   -- Initialize_Project_Path --\n+   -----------------------------\n+\n+   procedure Initialize_Project_Path\n+     (Self : in out Project_Search_Path; Target_Name : String)\n+   is\n+      Add_Default_Dir : Boolean := True;\n+      First           : Positive;\n+      Last            : Positive;\n+      New_Len         : Positive;\n+      New_Last        : Positive;\n+\n+      Ada_Project_Path : constant String := \"ADA_PROJECT_PATH\";\n+      Gpr_Project_Path : constant String := \"GPR_PROJECT_PATH\";\n+      --  Name of alternate env. variable that contain path name(s) of\n+      --  directories where project files may reside. GPR_PROJECT_PATH has\n+      --  precedence over ADA_PROJECT_PATH.\n+\n+      Gpr_Prj_Path : String_Access;\n+      Ada_Prj_Path : String_Access;\n+      --  The path name(s) of directories where project files may reside.\n+      --  May be empty.\n+\n+   begin\n+      --  If already initialized, nothing else to do\n+      if Self.Path /= null\n+        and then Self.Path (Self.Path'First) /= '#'\n+      then\n+         return;\n+      end if;\n+\n+      --  The current directory is always first in the search path. Since the\n+      --  Project_Path currently starts with '#:' as a sign that it isn't\n+      --  initialized, we simply replace '#' with '.'\n+\n+      if Self.Path = null then\n+         Self.Path := new String'('.' & Path_Separator);\n+      else\n+         Self.Path (Self.Path'First) := '.';\n+      end if;\n+\n+      --  Then the reset of the project path (if any) currently contains the\n+      --  directories added through Add_Search_Project_Directory\n+\n+      --  If environment variables are defined and not empty, add their content\n+\n+      Gpr_Prj_Path := Getenv (Gpr_Project_Path);\n+      Ada_Prj_Path := Getenv (Ada_Project_Path);\n+\n+      if Gpr_Prj_Path.all /= \"\" then\n+         Add_Directories (Self, Gpr_Prj_Path.all);\n+      end if;\n+\n+      Free (Gpr_Prj_Path);\n+\n+      if Ada_Prj_Path.all /= \"\" then\n+         Add_Directories (Self, Ada_Prj_Path.all);\n+      end if;\n+\n+      Free (Ada_Prj_Path);\n+\n+      --  Copy to Name_Buffer, since we will need to manipulate the path\n+\n+      Name_Len := Self.Path'Length;\n+      Name_Buffer (1 .. Name_Len) := Self.Path.all;\n+\n+      --  Scan the directory path to see if \"-\" is one of the directories.\n+      --  Remove each occurrence of \"-\" and set Add_Default_Dir to False.\n+      --  Also resolve relative paths and symbolic links.\n+\n+      First := 3;\n+      loop\n+         while First <= Name_Len\n+           and then (Name_Buffer (First) = Path_Separator)\n+         loop\n+            First := First + 1;\n+         end loop;\n+\n+         exit when First > Name_Len;\n+\n+         Last := First;\n+\n+         while Last < Name_Len\n+           and then Name_Buffer (Last + 1) /= Path_Separator\n+         loop\n+            Last := Last + 1;\n+         end loop;\n+\n+         --  If the directory is \"-\", set Add_Default_Dir to False and\n+         --  remove from path.\n+\n+         if Name_Buffer (First .. Last) = No_Project_Default_Dir then\n+            Add_Default_Dir := False;\n+\n+            for J in Last + 1 .. Name_Len loop\n+               Name_Buffer (J - No_Project_Default_Dir'Length - 1) :=\n+                 Name_Buffer (J);\n+            end loop;\n+\n+            Name_Len := Name_Len - No_Project_Default_Dir'Length - 1;\n+\n+            --  After removing the '-', go back one character to get the next\n+            --  directory correctly.\n+\n+            Last := Last - 1;\n+\n+         elsif not Hostparm.OpenVMS\n+           or else not Is_Absolute_Path (Name_Buffer (First .. Last))\n+         then\n+            --  On VMS, only expand relative path names, as absolute paths\n+            --  may correspond to multi-valued VMS logical names.\n+\n+            declare\n+               New_Dir : constant String :=\n+                           Normalize_Pathname\n+                             (Name_Buffer (First .. Last),\n+                              Resolve_Links => Opt.Follow_Links_For_Dirs);\n+\n+            begin\n+               --  If the absolute path was resolved and is different from\n+               --  the original, replace original with the resolved path.\n+\n+               if New_Dir /= Name_Buffer (First .. Last)\n+                 and then New_Dir'Length /= 0\n+               then\n+                  New_Len := Name_Len + New_Dir'Length - (Last - First + 1);\n+                  New_Last := First + New_Dir'Length - 1;\n+                  Name_Buffer (New_Last + 1 .. New_Len) :=\n+                    Name_Buffer (Last + 1 .. Name_Len);\n+                  Name_Buffer (First .. New_Last) := New_Dir;\n+                  Name_Len := New_Len;\n+                  Last := New_Last;\n+               end if;\n+            end;\n+         end if;\n+\n+         First := Last + 1;\n+      end loop;\n+\n+      Free (Self.Path);\n+\n+      --  Set the initial value of Current_Project_Path\n+\n+      if Add_Default_Dir then\n+         declare\n+            Prefix : String_Ptr := Sdefault.Search_Dir_Prefix;\n+\n+         begin\n+            if Prefix = null then\n+               Prefix := new String'(Executable_Prefix_Path);\n+\n+               if Prefix.all /= \"\" then\n+                  if Target_Name /= \"\" then\n+                     Add_Str_To_Name_Buffer\n+                       (Path_Separator & Prefix.all &\n+                        \"lib\" & Directory_Separator & \"gpr\" &\n+                        Directory_Separator & Target_Name);\n+                  end if;\n+\n+                  Add_Str_To_Name_Buffer\n+                    (Path_Separator & Prefix.all &\n+                     \"share\" & Directory_Separator & \"gpr\");\n+                  Add_Str_To_Name_Buffer\n+                    (Path_Separator & Prefix.all &\n+                     \"lib\" & Directory_Separator & \"gnat\");\n+               end if;\n+\n+            else\n+               Self.Path :=\n+                 new String'(Name_Buffer (1 .. Name_Len) & Path_Separator &\n+                             Prefix.all &\n+                             \"..\" &  Directory_Separator &\n+                             \"..\" & Directory_Separator &\n+                             \"..\" & Directory_Separator & \"gnat\");\n+            end if;\n+\n+            Free (Prefix);\n+         end;\n+      end if;\n+\n+      if Self.Path = null then\n+         Self.Path := new String'(Name_Buffer (1 .. Name_Len));\n+      end if;\n+   end Initialize_Project_Path;\n+\n+   --------------\n+   -- Get_Path --\n+   --------------\n+\n+   procedure Get_Path\n+     (Self : in out Project_Search_Path;\n+      Path : out String_Access)\n+   is\n+   begin\n+      Initialize_Project_Path (Self, \"\");  --  ??? Target_Name unspecified\n+      Path := Self.Path;\n+   end Get_Path;\n+\n+   ---------------\n+   -- Deep_Copy --\n+   ---------------\n+\n+   function Deep_Copy\n+     (Self : Project_Search_Path) return Project_Search_Path is\n+   begin\n+      if Self.Path = null then\n+         return Project_Search_Path'\n+           (Path => null, Cache => Projects_Paths.Nil);\n+      else\n+         return Project_Search_Path'\n+           (Path => new String'(Self.Path.all),\n+            Cache => Projects_Paths.Nil);\n+      end if;\n+   end Deep_Copy;\n+\n+   ------------------\n+   -- Find_Project --\n+   ------------------\n+\n+   procedure Find_Project\n+     (Self               : in out Project_Search_Path;\n+      Project_File_Name  : String;\n+      Directory          : String;\n+      Path               : out Namet.Path_Name_Type)\n+   is\n+      File : constant String := Project_File_Name;\n+      --  Have to do a copy, in case the parameter is Name_Buffer, which we\n+      --  modify below\n+\n+      function Try_Path_Name (Path : String) return String_Access;\n+      pragma Inline (Try_Path_Name);\n+      --  Try the specified Path\n+\n+      -------------------\n+      -- Try_Path_Name --\n+      -------------------\n+\n+      function Try_Path_Name (Path : String) return String_Access is\n+         First    : Natural;\n+         Last     : Natural;\n+         Result   : String_Access := null;\n+\n+      begin\n+         if Current_Verbosity = High then\n+            Write_Str  (\"   Trying \");\n+            Write_Line (Path);\n+         end if;\n+\n+         if Is_Absolute_Path (Path) then\n+            if Is_Regular_File (Path) then\n+               Result := new String'(Path);\n+            end if;\n+\n+         else\n+            --  Because we don't want to resolve symbolic links, we cannot use\n+            --  Locate_Regular_File. So, we try each possible path\n+            --  successively.\n+\n+            First := Self.Path'First;\n+            while First <= Self.Path'Last loop\n+               while First <= Self.Path'Last\n+                 and then Self.Path (First) = Path_Separator\n+               loop\n+                  First := First + 1;\n+               end loop;\n+\n+               exit when First > Self.Path'Last;\n+\n+               Last := First;\n+               while Last < Self.Path'Last\n+                 and then Self.Path (Last + 1) /= Path_Separator\n+               loop\n+                  Last := Last + 1;\n+               end loop;\n+\n+               Name_Len := 0;\n+\n+               if not Is_Absolute_Path (Self.Path (First .. Last)) then\n+                  Add_Str_To_Name_Buffer (Get_Current_Dir);  -- ??? System call\n+                  Add_Char_To_Name_Buffer (Directory_Separator);\n+               end if;\n+\n+               Add_Str_To_Name_Buffer (Self.Path (First .. Last));\n+               Add_Char_To_Name_Buffer (Directory_Separator);\n+               Add_Str_To_Name_Buffer (Path);\n+\n+               if Current_Verbosity = High then\n+                  Write_Str  (\"   Testing file \");\n+                  Write_Line (Name_Buffer (1 .. Name_Len));\n+               end if;\n+\n+               if Is_Regular_File (Name_Buffer (1 .. Name_Len)) then\n+                  Result := new String'(Name_Buffer (1 .. Name_Len));\n+                  exit;\n+               end if;\n+\n+               First := Last + 1;\n+            end loop;\n+         end if;\n+\n+         return Result;\n+      end Try_Path_Name;\n+\n+      --  Local Declarations\n+\n+      Result    : String_Access;\n+      Has_Dot   : Boolean := False;\n+      Key       : Name_Id;\n+\n+   --  Start of processing for Project_Path_Name_Of\n+\n+   begin\n+      Initialize_Project_Path (Self, \"\");\n+\n+      if Current_Verbosity = High then\n+         Write_Str  (\"Searching for project (\"\"\");\n+         Write_Str  (File);\n+         Write_Str  (\"\"\", \"\"\");\n+         Write_Str  (Directory);\n+         Write_Line (\"\"\");\");\n+      end if;\n+\n+      --  Check the project cache\n+\n+      Name_Len := File'Length;\n+      Name_Buffer (1 .. Name_Len) := File;\n+      Key := Name_Find;\n+      Path := Projects_Paths.Get (Self.Cache, Key);\n+\n+      if Path /= No_Path then\n+         return;\n+      end if;\n+\n+      --  Check if File contains an extension (a dot before a\n+      --  directory separator). If it is the case we do not try project file\n+      --  with an added extension as it is not possible to have multiple dots\n+      --  on a project file name.\n+\n+      Check_Dot : for K in reverse File'Range loop\n+         if File (K) = '.' then\n+            Has_Dot := True;\n+            exit Check_Dot;\n+         end if;\n+\n+         exit Check_Dot when File (K) = Directory_Separator\n+           or else File (K) = '/';\n+      end loop Check_Dot;\n+\n+      if not Is_Absolute_Path (File) then\n+\n+         --  First we try <directory>/<file_name>.<extension>\n+\n+         if not Has_Dot then\n+            Result := Try_Path_Name\n+              (Directory & Directory_Separator &\n+               File & Project_File_Extension);\n+         end if;\n+\n+         --  Then we try <directory>/<file_name>\n+\n+         if Result = null then\n+            Result := Try_Path_Name (Directory & Directory_Separator & File);\n+         end if;\n+      end if;\n+\n+      --  Then we try <file_name>.<extension>\n+\n+      if Result = null and then not Has_Dot then\n+         Result := Try_Path_Name (File & Project_File_Extension);\n+      end if;\n+\n+      --  Then we try <file_name>\n+\n+      if Result = null then\n+         Result := Try_Path_Name (File);\n+      end if;\n+\n+      --  If we cannot find the project file, we return an empty string\n+\n+      if Result = null then\n+         Path := Namet.No_Path;\n+         return;\n+\n+      else\n+         declare\n+            Final_Result : constant String :=\n+                             GNAT.OS_Lib.Normalize_Pathname\n+                               (Result.all,\n+                                Directory      => Directory,\n+                                Resolve_Links  => Opt.Follow_Links_For_Files,\n+                                Case_Sensitive => True);\n+         begin\n+            Free (Result);\n+            Name_Len := Final_Result'Length;\n+            Name_Buffer (1 .. Name_Len) := Final_Result;\n+            Path := Name_Find;\n+            Projects_Paths.Set (Self.Cache, Key, Path);\n+         end;\n+      end if;\n+   end Find_Project;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Self : in out Project_Search_Path) is\n+   begin\n+      Free (Self.Path);\n+      Projects_Paths.Reset (Self.Cache);\n+   end Free;\n+\n end Prj.Env;"}, {"sha": "83e078319f8f249edcba743127188cb9542a295d", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,9 @@\n --  This package implements services for Project-aware tools, mostly related\n --  to the environment (configuration pragma files, path files, mapping files).\n \n+with GNAT.Dynamic_HTables;\n+with System.OS_Lib;\n+\n package Prj.Env is\n \n    procedure Initialize (In_Tree : Project_Tree_Ref);\n@@ -152,4 +155,72 @@ package Prj.Env is\n    --  Iterate through all the object directories of a project, including\n    --  those of imported or modified projects.\n \n+   ------------------\n+   -- Project Path --\n+   ------------------\n+\n+   type Project_Search_Path is private;\n+   --  An abstraction of the project path. This object provides subprograms to\n+   --  search for projects on the path (and caches the results for more\n+   --  efficiency).\n+\n+   procedure Free (Self : in out Project_Search_Path);\n+   --  Free the memory used by Self\n+\n+   procedure Add_Directories\n+     (Self : in out Project_Search_Path;\n+      Path : String);\n+   --  Add one or more directories to the path.\n+   --  Directories added with this procedure are added in order after the\n+   --  current directory and before the path given by the environment variable\n+   --  GPR_PROJECT_PATH. A value of \"-\" will remove the default project\n+   --  directory from the project path.\n+   --\n+   --  Calls to this subprogram must be performed before the first call to\n+   --  Find_Project below, or PATH will be added at the end of the search\n+   --  path.\n+\n+   procedure Get_Path\n+     (Self : in out Project_Search_Path;\n+      Path : out String_Access);\n+   --  Return the current value of the project path, either the value set\n+   --  during elaboration of the package or, if procedure Set_Project_Path has\n+   --  been called, the value set by the last call to Set_Project_Path.\n+   --  The returned value must not be modified.\n+\n+   procedure Find_Project\n+     (Self               : in out Project_Search_Path;\n+      Project_File_Name  : String;\n+      Directory          : String;\n+      Path               : out Namet.Path_Name_Type);\n+   --  Search for a the project with the given name either in Directory (which\n+   --  often will be the directory contain the project we are currently\n+   --  parsing and which we found a reference to another project), or in the\n+   --  project path. Extra_Project_Path contains additional directories to\n+   --  search.\n+   --  Project_File_Name can optionally contain directories, and the extension\n+   --  (.gpr) for the file name is optional.\n+   --  Returns No_Name if no such project was found.\n+\n+   function Deep_Copy (Self : Project_Search_Path) return Project_Search_Path;\n+   --  Return a deep copy of Self. The result can be modified independently of\n+   --  Self, and must be freed by the caller\n+\n+private\n+   package Projects_Paths is new GNAT.Dynamic_HTables.Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Path_Name_Type,\n+      No_Element => No_Path,\n+      Key        => Name_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+\n+   type Project_Search_Path is record\n+      Path : System.OS_Lib.String_Access;\n+      --  As a special case, if the first character is '#:\" or this variable is\n+      --  unset, this means that the PATH has not been fully initialized yet\n+      --  (although subprograms above will properly take care of that).\n+\n+      Cache : Projects_Paths.Instance;\n+   end record;\n end Prj.Env;"}, {"sha": "cb2cca24e576d940fa82aa603dc3a2a96f50b7ea", "filename": "gcc/ada/prj-ext.adb", "status": "modified", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-ext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-ext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -23,26 +23,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Hostparm;\n-with Makeutl;       use Makeutl;\n-with Opt;\n with Osint;         use Osint;\n with Prj.Tree;      use Prj.Tree;\n-with Sdefault;\n \n package body Prj.Ext is\n \n-   No_Project_Default_Dir : constant String := \"-\";\n-   --  Indicator in the project path to indicate that the default search\n-   --  directories should not be added to the path\n-\n-   Uninitialized_Prefix : constant String := '#' & Path_Separator;\n-   --  Prefix to indicate that the project path has not been initilized yet.\n-   --  Must be two characters long\n-\n-   procedure Initialize_Project_Path (Tree : Prj.Tree.Project_Node_Tree_Ref);\n-   --  Initialize Current_Project_Path\n-\n    ---------\n    -- Add --\n    ---------\n@@ -65,25 +50,6 @@ package body Prj.Ext is\n       Name_To_Name_HTable.Set (Tree.External_References, The_Key, The_Value);\n    end Add;\n \n-   ----------------------------------\n-   -- Add_Search_Project_Directory --\n-   ----------------------------------\n-\n-   procedure Add_Search_Project_Directory\n-     (Tree : Prj.Tree.Project_Node_Tree_Ref;\n-      Path : String)\n-   is\n-      Tmp : String_Access;\n-   begin\n-      if Tree.Project_Path = null then\n-         Tree.Project_Path := new String'(Uninitialized_Prefix & Path);\n-      else\n-         Tmp := Tree.Project_Path;\n-         Tree.Project_Path := new String'(Tmp.all & Path_Separator & Path);\n-         Free (Tmp);\n-      end if;\n-   end Add_Search_Project_Directory;\n-\n    -----------\n    -- Check --\n    -----------\n@@ -109,197 +75,6 @@ package body Prj.Ext is\n       return False;\n    end Check;\n \n-   -----------------------------\n-   -- Initialize_Project_Path --\n-   -----------------------------\n-\n-   procedure Initialize_Project_Path (Tree : Prj.Tree.Project_Node_Tree_Ref) is\n-      Add_Default_Dir : Boolean := True;\n-      First           : Positive;\n-      Last            : Positive;\n-      New_Len         : Positive;\n-      New_Last        : Positive;\n-\n-      Ada_Project_Path : constant String := \"ADA_PROJECT_PATH\";\n-      Gpr_Project_Path : constant String := \"GPR_PROJECT_PATH\";\n-      --  Name of alternate env. variable that contain path name(s) of\n-      --  directories where project files may reside. GPR_PROJECT_PATH has\n-      --  precedence over ADA_PROJECT_PATH.\n-\n-      Gpr_Prj_Path : String_Access := Getenv (Gpr_Project_Path);\n-      Ada_Prj_Path : String_Access := Getenv (Ada_Project_Path);\n-      --  The path name(s) of directories where project files may reside.\n-      --  May be empty.\n-\n-   begin\n-      --  The current directory is always first in the search path. Since the\n-      --  Project_Path currently starts with '#:' as a sign that it isn't\n-      --  initialized, we simply replace '#' with '.'\n-\n-      if Tree.Project_Path = null then\n-         Tree.Project_Path := new String'('.' & Path_Separator);\n-      else\n-         Tree.Project_Path (Tree.Project_Path'First) := '.';\n-      end if;\n-\n-      --  Then the reset of the project path (if any) currently contains the\n-      --  directories added through Add_Search_Project_Directory\n-\n-      --  If environment variables are defined and not empty, add their content\n-\n-      if Gpr_Prj_Path.all /= \"\" then\n-         Add_Search_Project_Directory (Tree, Gpr_Prj_Path.all);\n-      end if;\n-\n-      Free (Gpr_Prj_Path);\n-\n-      if Ada_Prj_Path.all /= \"\" then\n-         Add_Search_Project_Directory (Tree, Ada_Prj_Path.all);\n-      end if;\n-\n-      Free (Ada_Prj_Path);\n-\n-      --  Copy to Name_Buffer, since we will need to manipulate the path\n-\n-      Name_Len := Tree.Project_Path'Length;\n-      Name_Buffer (1 .. Name_Len) := Tree.Project_Path.all;\n-\n-      --  Scan the directory path to see if \"-\" is one of the directories.\n-      --  Remove each occurrence of \"-\" and set Add_Default_Dir to False.\n-      --  Also resolve relative paths and symbolic links.\n-\n-      First := 3;\n-      loop\n-         while First <= Name_Len\n-           and then (Name_Buffer (First) = Path_Separator)\n-         loop\n-            First := First + 1;\n-         end loop;\n-\n-         exit when First > Name_Len;\n-\n-         Last := First;\n-\n-         while Last < Name_Len\n-           and then Name_Buffer (Last + 1) /= Path_Separator\n-         loop\n-            Last := Last + 1;\n-         end loop;\n-\n-         --  If the directory is \"-\", set Add_Default_Dir to False and\n-         --  remove from path.\n-\n-         if Name_Buffer (First .. Last) = No_Project_Default_Dir then\n-            Add_Default_Dir := False;\n-\n-            for J in Last + 1 .. Name_Len loop\n-               Name_Buffer (J - No_Project_Default_Dir'Length - 1) :=\n-                 Name_Buffer (J);\n-            end loop;\n-\n-            Name_Len := Name_Len - No_Project_Default_Dir'Length - 1;\n-\n-            --  After removing the '-', go back one character to get the next\n-            --  directory correctly.\n-\n-            Last := Last - 1;\n-\n-         elsif not Hostparm.OpenVMS\n-           or else not Is_Absolute_Path (Name_Buffer (First .. Last))\n-         then\n-            --  On VMS, only expand relative path names, as absolute paths\n-            --  may correspond to multi-valued VMS logical names.\n-\n-            declare\n-               New_Dir : constant String :=\n-                           Normalize_Pathname\n-                             (Name_Buffer (First .. Last),\n-                              Resolve_Links => Opt.Follow_Links_For_Dirs);\n-\n-            begin\n-               --  If the absolute path was resolved and is different from\n-               --  the original, replace original with the resolved path.\n-\n-               if New_Dir /= Name_Buffer (First .. Last)\n-                 and then New_Dir'Length /= 0\n-               then\n-                  New_Len := Name_Len + New_Dir'Length - (Last - First + 1);\n-                  New_Last := First + New_Dir'Length - 1;\n-                  Name_Buffer (New_Last + 1 .. New_Len) :=\n-                    Name_Buffer (Last + 1 .. Name_Len);\n-                  Name_Buffer (First .. New_Last) := New_Dir;\n-                  Name_Len := New_Len;\n-                  Last := New_Last;\n-               end if;\n-            end;\n-         end if;\n-\n-         First := Last + 1;\n-      end loop;\n-\n-      Free (Tree.Project_Path);\n-\n-      --  Set the initial value of Current_Project_Path\n-\n-      if Add_Default_Dir then\n-         declare\n-            Prefix : String_Ptr := Sdefault.Search_Dir_Prefix;\n-\n-         begin\n-            if Prefix = null then\n-               Prefix := new String'(Executable_Prefix_Path);\n-\n-               if Prefix.all /= \"\" then\n-                  if Tree.Target_Name /= null\n-                    and then Tree.Target_Name.all /= \"\"\n-                  then\n-                     Add_Str_To_Name_Buffer\n-                       (Path_Separator & Prefix.all &\n-                        \"lib\" & Directory_Separator & \"gpr\" &\n-                        Directory_Separator & Tree.Target_Name.all);\n-                  end if;\n-\n-                  Add_Str_To_Name_Buffer\n-                    (Path_Separator & Prefix.all &\n-                     \"share\" & Directory_Separator & \"gpr\");\n-                  Add_Str_To_Name_Buffer\n-                    (Path_Separator & Prefix.all &\n-                     \"lib\" & Directory_Separator & \"gnat\");\n-               end if;\n-\n-            else\n-               Tree.Project_Path :=\n-                 new String'(Name_Buffer (1 .. Name_Len) & Path_Separator &\n-                             Prefix.all &\n-                             \"..\" &  Directory_Separator &\n-                             \"..\" & Directory_Separator &\n-                             \"..\" & Directory_Separator & \"gnat\");\n-            end if;\n-\n-            Free (Prefix);\n-         end;\n-      end if;\n-\n-      if Tree.Project_Path = null then\n-         Tree.Project_Path := new String'(Name_Buffer (1 .. Name_Len));\n-      end if;\n-   end Initialize_Project_Path;\n-\n-   ------------------\n-   -- Project_Path --\n-   ------------------\n-\n-   function Project_Path (Tree : Project_Node_Tree_Ref) return String is\n-   begin\n-      if Tree.Project_Path = null\n-        or else Tree.Project_Path (Tree.Project_Path'First) = '#'\n-      then\n-         Initialize_Project_Path (Tree);\n-      end if;\n-\n-      return Tree.Project_Path.all;\n-   end Project_Path;\n-\n    -----------\n    -- Reset --\n    -----------\n@@ -309,18 +84,6 @@ package body Prj.Ext is\n       Name_To_Name_HTable.Reset (Tree.External_References);\n    end Reset;\n \n-   ----------------------\n-   -- Set_Project_Path --\n-   ----------------------\n-\n-   procedure Set_Project_Path\n-     (Tree     : Project_Node_Tree_Ref;\n-      New_Path : String) is\n-   begin\n-      Free (Tree.Project_Path);\n-      Tree.Project_Path := new String'(New_Path);\n-   end Set_Project_Path;\n-\n    --------------\n    -- Value_Of --\n    --------------"}, {"sha": "1fb389c4a7cf9f62fd856565a93b024cb182f5ac", "filename": "gcc/ada/prj-ext.ads", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-ext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-ext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.ads?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,34 +30,6 @@ with Prj.Tree;\n \n package Prj.Ext is\n \n-   ------------------\n-   -- Project Path --\n-   ------------------\n-\n-   procedure Add_Search_Project_Directory\n-     (Tree : Prj.Tree.Project_Node_Tree_Ref;\n-      Path : String);\n-   --  Add a directory to the project path. Directories added with this\n-   --  procedure are added in order after the current directory and before\n-   --  the path given by the environment variable GPR_PROJECT_PATH. A value\n-   --  of \"-\" will remove the default project directory from the project path.\n-   --\n-   --  Calls to this subprogram must be performed before the first call to\n-   --  Project_Path below, or PATH will be added at the end of the search\n-   --  path.\n-\n-   function Project_Path (Tree : Prj.Tree.Project_Node_Tree_Ref) return String;\n-   --  Return the current value of the project path, either the value set\n-   --  during elaboration of the package or, if procedure Set_Project_Path has\n-   --  been called, the value set by the last call to Set_Project_Path.\n-\n-   procedure Set_Project_Path\n-     (Tree     : Prj.Tree.Project_Node_Tree_Ref;\n-      New_Path : String);\n-   --  Give a new value to the project path. The new value New_Path should\n-   --  always start with the current directory (\".\") and the path separators\n-   --  should be the correct ones for the platform.\n-\n    -------------------------\n    -- External References --\n    -------------------------"}, {"sha": "482ecb77d94b339334dcce17ce2a1e5f8819a4d2", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -149,6 +149,7 @@ package body Prj.Nmsc is\n \n    type Tree_Processing_Data is record\n       Tree           : Project_Tree_Ref;\n+      Node_Tree      : Prj.Tree.Project_Node_Tree_Ref;\n       File_To_Source : Files_Htable.Instance;\n       Flags          : Prj.Processing_Flags;\n    end record;\n@@ -173,9 +174,10 @@ package body Prj.Nmsc is\n    --  projects do not have the same library names.\n \n    procedure Initialize\n-     (Data  : out Tree_Processing_Data;\n-      Tree  : Project_Tree_Ref;\n-      Flags : Prj.Processing_Flags);\n+     (Data      : out Tree_Processing_Data;\n+      Tree      : Project_Tree_Ref;\n+      Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags     : Prj.Processing_Flags);\n    --  Initialize Data\n \n    procedure Free (Data : in out Tree_Processing_Data);\n@@ -6574,14 +6576,16 @@ package body Prj.Nmsc is\n    ----------------\n \n    procedure Initialize\n-     (Data  : out Tree_Processing_Data;\n-      Tree  : Project_Tree_Ref;\n-      Flags : Prj.Processing_Flags)\n+     (Data      : out Tree_Processing_Data;\n+      Tree      : Project_Tree_Ref;\n+      Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags     : Prj.Processing_Flags)\n    is\n    begin\n       Files_Htable.Reset (Data.File_To_Source);\n-      Data.Tree  := Tree;\n-      Data.Flags := Flags;\n+      Data.Tree      := Tree;\n+      Data.Node_Tree := Node_Tree;\n+      Data.Flags     := Flags;\n    end Initialize;\n \n    ----------\n@@ -7611,6 +7615,7 @@ package body Prj.Nmsc is\n    procedure Process_Naming_Scheme\n      (Tree         : Project_Tree_Ref;\n       Root_Project : Project_Id;\n+      Node_Tree    : Prj.Tree.Project_Node_Tree_Ref;\n       Flags        : Processing_Flags)\n    is\n       procedure Recursive_Check\n@@ -7644,7 +7649,7 @@ package body Prj.Nmsc is\n    --  Start of processing for Process_Naming_Scheme\n    begin\n       Lib_Data_Table.Init;\n-      Initialize (Data, Tree => Tree, Flags => Flags);\n+      Initialize (Data, Tree => Tree, Node_Tree => Node_Tree, Flags => Flags);\n       Check_All_Projects (Root_Project, Data, Imported_First => True);\n       Free (Data);\n "}, {"sha": "ce57e9007c19dfbd15ef157c99ac4677194d107d", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,11 +25,14 @@\n \n --  Find source dirs and source files for a project\n \n+with Prj.Tree;\n+\n private package Prj.Nmsc is\n \n    procedure Process_Naming_Scheme\n      (Tree         : Project_Tree_Ref;\n       Root_Project : Project_Id;\n+      Node_Tree    : Prj.Tree.Project_Node_Tree_Ref;\n       Flags        : Processing_Flags);\n    --  Perform consistency and semantic checks on all the projects in the tree.\n    --  This procedure interprets the various case statements in the project"}, {"sha": "93b6f260b57a836e132f1fcf9a8f4a571da05769", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 163, "deletions": 365, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -29,8 +29,8 @@ with Osint;    use Osint;\n with Output;   use Output;\n with Prj.Com;  use Prj.Com;\n with Prj.Dect;\n+with Prj.Env;  use Prj.Env;\n with Prj.Err;  use Prj.Err;\n-with Prj.Ext;  use Prj.Ext;\n with Sinput;   use Sinput;\n with Sinput.P; use Sinput.P;\n with Snames;\n@@ -39,7 +39,6 @@ with Table;\n with Ada.Characters.Handling; use Ada.Characters.Handling;\n with Ada.Exceptions;          use Ada.Exceptions;\n \n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.HTable;               use GNAT.HTable;\n \n package body Prj.Part is\n@@ -118,14 +117,6 @@ package body Prj.Part is\n    --  need to have a virtual extending project, to avoid processing the same\n    --  project twice.\n \n-   package Projects_Paths is new GNAT.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Path_Name_Type,\n-      No_Element => No_Path,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n    function Has_Circular_Dependencies\n      (Flags               : Processing_Flags;\n       Normed_Path_Name    : Path_Name_Type;\n@@ -186,7 +177,7 @@ package body Prj.Part is\n      (In_Tree           : Project_Node_Tree_Ref;\n       Project           : out Project_Node_Id;\n       Extends_All       : out Boolean;\n-      Path_Name         : String;\n+      Path_Name_Id      : Path_Name_Type;\n       Extended          : Boolean;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n@@ -239,13 +230,6 @@ package body Prj.Part is\n    --  Is_Config_File should be set to True if the project represents a config\n    --  file (.cgpr) since some specific checks apply.\n \n-   function Project_Path_Name_Of\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Project_File_Name : String;\n-      Directory         : String) return String;\n-   --  Returns the path name of a project file. Returns an empty string\n-   --  if project file cannot be found.\n-\n    function Project_Name_From\n      (Path_Name      : String;\n       Is_Config_File : Boolean) return Name_Id;\n@@ -472,6 +456,7 @@ package body Prj.Part is\n       Real_Project_File_Name : String_Access :=\n                                  Osint.To_Canonical_File_Spec\n                                    (Project_File_Name);\n+      Path_Name_Id : Path_Name_Type;\n \n    begin\n       if Real_Project_File_Name = null then\n@@ -480,153 +465,146 @@ package body Prj.Part is\n \n       Project := Empty_Node;\n \n-      Projects_Paths.Reset;\n-\n-      if Current_Verbosity >= Medium then\n-         Write_Str (\"GPR_PROJECT_PATH=\"\"\");\n-         Write_Str (Project_Path (In_Tree));\n-         Write_Line (\"\"\"\");\n-      end if;\n-\n-      declare\n-         Path_Name : constant String :=\n-                       Project_Path_Name_Of (In_Tree,\n-                                             Real_Project_File_Name.all,\n-                                             Directory   => Current_Directory);\n+      Find_Project (In_Tree.Project_Path,\n+                    Project_File_Name => Real_Project_File_Name.all,\n+                    Directory         => Current_Directory,\n+                    Path              => Path_Name_Id);\n+      Free (Real_Project_File_Name);\n \n-      begin\n-         Free (Real_Project_File_Name);\n+      Prj.Err.Initialize;\n+      Prj.Err.Scanner.Set_Comment_As_Token (Store_Comments);\n+      Prj.Err.Scanner.Set_End_Of_Line_As_Token (Store_Comments);\n \n-         Prj.Err.Initialize;\n-         Prj.Err.Scanner.Set_Comment_As_Token (Store_Comments);\n-         Prj.Err.Scanner.Set_End_Of_Line_As_Token (Store_Comments);\n-\n-         --  Parse the main project file\n-\n-         if Path_Name = \"\" then\n+      if Path_Name_Id = No_Path then\n+         declare\n+            P : String_Access;\n+         begin\n+            Get_Path (In_Tree.Project_Path, Path => P);\n             Prj.Com.Fail\n               (\"project file \"\"\"\n                & Project_File_Name\n                & \"\"\" not found in \"\n-               & Project_Path (In_Tree));\n+               & P.all);\n             Project := Empty_Node;\n             return;\n-         end if;\n+         end;\n+      end if;\n \n-         begin\n-            Parse_Single_Project\n-              (In_Tree           => In_Tree,\n-               Project           => Project,\n-               Extends_All       => Dummy,\n-               Path_Name         => Path_Name,\n-               Extended          => False,\n-               From_Extended     => None,\n-               In_Limited        => False,\n-               Packages_To_Check => Packages_To_Check,\n-               Depth             => 0,\n-               Current_Dir       => Current_Directory,\n-               Is_Config_File    => Is_Config_File,\n-               Flags             => Flags);\n+      --  Parse the main project file\n \n-         exception\n-            when Types.Unrecoverable_Error =>\n-               --  Unrecoverable_Error is raised when a line is too long.\n-               --  A meaningful error message will be displayed later.\n-               Project := Empty_Node;\n-         end;\n+      begin\n+         Parse_Single_Project\n+           (In_Tree           => In_Tree,\n+            Project           => Project,\n+            Extends_All       => Dummy,\n+            Path_Name_Id      => Path_Name_Id,\n+            Extended          => False,\n+            From_Extended     => None,\n+            In_Limited        => False,\n+            Packages_To_Check => Packages_To_Check,\n+            Depth             => 0,\n+            Current_Dir       => Current_Directory,\n+            Is_Config_File    => Is_Config_File,\n+            Flags             => Flags);\n \n-         --  If Project is an extending-all project, create the eventual\n-         --  virtual extending projects and check that there are no illegally\n-         --  imported projects.\n+      exception\n+         when Types.Unrecoverable_Error =>\n+            --  Unrecoverable_Error is raised when a line is too long.\n+            --  A meaningful error message will be displayed later.\n+            Project := Empty_Node;\n+      end;\n \n-         if Present (Project)\n-           and then Is_Extending_All (Project, In_Tree)\n-         then\n-            --  First look for projects that potentially need a virtual\n-            --  extending project.\n+      --  If Project is an extending-all project, create the eventual\n+      --  virtual extending projects and check that there are no illegally\n+      --  imported projects.\n \n-            Virtual_Hash.Reset;\n-            Processed_Hash.Reset;\n+      if Present (Project)\n+        and then Is_Extending_All (Project, In_Tree)\n+      then\n+         --  First look for projects that potentially need a virtual\n+         --  extending project.\n \n-            --  Mark the extending all project as processed, to avoid checking\n-            --  the imported projects in case of a \"limited with\" on this\n-            --  extending all project.\n+         Virtual_Hash.Reset;\n+         Processed_Hash.Reset;\n \n-            Processed_Hash.Set (Project, True);\n+         --  Mark the extending all project as processed, to avoid checking\n+         --  the imported projects in case of a \"limited with\" on this\n+         --  extending all project.\n \n-            declare\n-               Declaration : constant Project_Node_Id :=\n-                               Project_Declaration_Of (Project, In_Tree);\n-            begin\n-               Look_For_Virtual_Projects_For\n-                 (Extended_Project_Of (Declaration, In_Tree), In_Tree,\n-                  Potentially_Virtual => False);\n-            end;\n+         Processed_Hash.Set (Project, True);\n \n-            --  Now, check the projects directly imported by the main project.\n-            --  Remove from the potentially virtual any project extended by one\n-            --  of these imported projects. For non extending imported\n-            --  projects, check that they do not belong to the project tree of\n-            --  the project being \"extended-all\" by the main project.\n+         declare\n+            Declaration : constant Project_Node_Id :=\n+              Project_Declaration_Of (Project, In_Tree);\n+         begin\n+            Look_For_Virtual_Projects_For\n+              (Extended_Project_Of (Declaration, In_Tree), In_Tree,\n+               Potentially_Virtual => False);\n+         end;\n \n-            declare\n-               With_Clause : Project_Node_Id;\n-               Imported    : Project_Node_Id := Empty_Node;\n-               Declaration : Project_Node_Id := Empty_Node;\n+         --  Now, check the projects directly imported by the main project.\n+         --  Remove from the potentially virtual any project extended by one\n+         --  of these imported projects. For non extending imported\n+         --  projects, check that they do not belong to the project tree of\n+         --  the project being \"extended-all\" by the main project.\n \n-            begin\n-               With_Clause := First_With_Clause_Of (Project, In_Tree);\n-               while Present (With_Clause) loop\n-                  Imported := Project_Node_Of (With_Clause, In_Tree);\n+         declare\n+            With_Clause : Project_Node_Id;\n+            Imported    : Project_Node_Id := Empty_Node;\n+            Declaration : Project_Node_Id := Empty_Node;\n \n-                  if Present (Imported) then\n-                     Declaration := Project_Declaration_Of (Imported, In_Tree);\n+         begin\n+            With_Clause := First_With_Clause_Of (Project, In_Tree);\n+            while Present (With_Clause) loop\n+               Imported := Project_Node_Of (With_Clause, In_Tree);\n \n-                     if Extended_Project_Of (Declaration, In_Tree) /=\n-                               Empty_Node\n-                     then\n-                        loop\n-                           Imported :=\n-                             Extended_Project_Of (Declaration, In_Tree);\n-                           exit when No (Imported);\n-                           Virtual_Hash.Remove (Imported);\n-                           Declaration :=\n-                             Project_Declaration_Of (Imported, In_Tree);\n-                        end loop;\n-                     end if;\n+               if Present (Imported) then\n+                  Declaration := Project_Declaration_Of (Imported, In_Tree);\n+\n+                  if Extended_Project_Of (Declaration, In_Tree) /=\n+                    Empty_Node\n+                  then\n+                     loop\n+                        Imported :=\n+                          Extended_Project_Of (Declaration, In_Tree);\n+                        exit when No (Imported);\n+                        Virtual_Hash.Remove (Imported);\n+                        Declaration :=\n+                          Project_Declaration_Of (Imported, In_Tree);\n+                     end loop;\n                   end if;\n+               end if;\n \n-                  With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n-               end loop;\n-            end;\n+               With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n+            end loop;\n+         end;\n \n-            --  Now create all the virtual extending projects\n+         --  Now create all the virtual extending projects\n \n-            declare\n-               Proj : Project_Node_Id := Virtual_Hash.Get_First;\n-            begin\n-               while Present (Proj) loop\n-                  Create_Virtual_Extending_Project (Proj, Project, In_Tree);\n-                  Proj := Virtual_Hash.Get_Next;\n-               end loop;\n-            end;\n-         end if;\n+         declare\n+            Proj : Project_Node_Id := Virtual_Hash.Get_First;\n+         begin\n+            while Present (Proj) loop\n+               Create_Virtual_Extending_Project (Proj, Project, In_Tree);\n+               Proj := Virtual_Hash.Get_Next;\n+            end loop;\n+         end;\n+      end if;\n \n-         --  If there were any kind of error during the parsing, serious\n-         --  or not, then the parsing fails.\n+      --  If there were any kind of error during the parsing, serious\n+      --  or not, then the parsing fails.\n \n-         if Err_Vars.Total_Errors_Detected > 0 then\n-            Project := Empty_Node;\n-         end if;\n+      if Err_Vars.Total_Errors_Detected > 0 then\n+         Project := Empty_Node;\n+      end if;\n \n-         if No (Project) or else Always_Errout_Finalize then\n-            Prj.Err.Finalize;\n+      if No (Project) or else Always_Errout_Finalize then\n+         Prj.Err.Finalize;\n \n-            --  Reinitialize to avoid duplicate warnings later on\n+         --  Reinitialize to avoid duplicate warnings later on\n \n-            Prj.Err.Initialize;\n-         end if;\n-      end;\n+         Prj.Err.Initialize;\n+      end if;\n \n    exception\n       when X : others =>\n@@ -769,6 +747,7 @@ package body Prj.Part is\n \n       Current_With : With_Record;\n       Extends_All  : Boolean := False;\n+      Imported_Path_Name_Id : Path_Name_Type;\n \n    begin\n       --  Set Current_Project to the last project in the current list, if the\n@@ -787,51 +766,48 @@ package body Prj.Part is\n          Current_With_Clause := Current_With.Next;\n \n          if Limited_Withs = Current_With.Limited_With then\n-            declare\n-               Original_Path : constant String :=\n-                                 Get_Name_String (Current_With.Path);\n+            Find_Project\n+              (In_Tree.Project_Path,\n+               Project_File_Name => Get_Name_String (Current_With.Path),\n+               Directory         => Project_Directory_Path,\n+               Path              => Imported_Path_Name_Id);\n \n-               Imported_Path_Name : constant String :=\n-                                      Project_Path_Name_Of\n-                                        (In_Tree,\n-                                         Original_Path,\n-                                         Project_Directory_Path);\n-\n-               Resolved_Path : constant String :=\n-                                 Normalize_Pathname\n-                                   (Imported_Path_Name,\n-                                    Directory      => Current_Dir,\n-                                    Resolve_Links  =>\n-                                      Opt.Follow_Links_For_Files,\n-                                    Case_Sensitive => True);\n+            if Imported_Path_Name_Id = No_Path then\n \n-               Withed_Project : Project_Node_Id := Empty_Node;\n+               --  The project file cannot be found\n \n-            begin\n-               if Imported_Path_Name = \"\" then\n+               Error_Msg_File_1 := File_Name_Type (Current_With.Path);\n+               Error_Msg\n+                 (Flags, \"unknown project file: {\", Current_With.Location);\n \n-                  --  The project file cannot be found\n+               --  If this is not imported by the main project file, display\n+               --  the import path.\n \n-                  Error_Msg_File_1 := File_Name_Type (Current_With.Path);\n-                  Error_Msg\n-                    (Flags, \"unknown project file: {\", Current_With.Location);\n+               if Project_Stack.Last > 1 then\n+                  for Index in reverse 1 .. Project_Stack.Last loop\n+                     Error_Msg_File_1 :=\n+                       File_Name_Type\n+                         (Project_Stack.Table (Index).Path_Name);\n+                     Error_Msg\n+                       (Flags, \"\\imported by {\", Current_With.Location);\n+                  end loop;\n+               end if;\n \n-                  --  If this is not imported by the main project file, display\n-                  --  the import path.\n+            else\n+               --  New with clause\n \n-                  if Project_Stack.Last > 1 then\n-                     for Index in reverse 1 .. Project_Stack.Last loop\n-                        Error_Msg_File_1 :=\n-                          File_Name_Type\n-                            (Project_Stack.Table (Index).Path_Name);\n-                        Error_Msg\n-                          (Flags, \"\\imported by {\", Current_With.Location);\n-                     end loop;\n-                  end if;\n+               declare\n+                  Resolved_Path : constant String :=\n+                                 Normalize_Pathname\n+                                   (Get_Name_String (Imported_Path_Name_Id),\n+                                    Directory      => Current_Dir,\n+                                    Resolve_Links  =>\n+                                      Opt.Follow_Links_For_Files,\n+                                    Case_Sensitive => True);\n \n-               else\n-                  --  New with clause\n+                  Withed_Project : Project_Node_Id := Empty_Node;\n \n+               begin\n                   Previous_Project := Current_Project;\n \n                   if No (Current_Project) then\n@@ -890,7 +866,7 @@ package body Prj.Part is\n                        (In_Tree           => In_Tree,\n                         Project           => Withed_Project,\n                         Extends_All       => Extends_All,\n-                        Path_Name         => Imported_Path_Name,\n+                        Path_Name_Id      => Imported_Path_Name_Id,\n                         Extended          => False,\n                         From_Extended     => From_Extended,\n                         In_Limited        => Limited_Withs,\n@@ -939,8 +915,8 @@ package body Prj.Part is\n                         Set_Is_Extending_All (Current_Project, In_Tree);\n                      end if;\n                   end if;\n-               end if;\n-            end;\n+               end;\n+            end if;\n          end if;\n       end loop;\n    end Post_Parse_Context_Clause;\n@@ -1132,7 +1108,7 @@ package body Prj.Part is\n      (In_Tree           : Project_Node_Tree_Ref;\n       Project           : out Project_Node_Id;\n       Extends_All       : out Boolean;\n-      Path_Name         : String;\n+      Path_Name_Id      : Path_Name_Type;\n       Extended          : Boolean;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n@@ -1142,6 +1118,8 @@ package body Prj.Part is\n       Is_Config_File    : Boolean;\n       Flags             : Processing_Flags)\n    is\n+      Path_Name : constant String := Get_Name_String (Path_Name_Id);\n+\n       Normed_Path_Name    : Path_Name_Type;\n       Canonical_Path_Name : Path_Name_Type;\n       Project_Directory   : Path_Name_Type;\n@@ -1397,7 +1375,7 @@ package body Prj.Part is\n \n          --  Make sure that gnatmake will use mapping files\n \n-         Create_Mapping_File := True;\n+         Opt.Create_Mapping_File := True;\n \n          --  We are extending another project\n \n@@ -1557,16 +1535,15 @@ package body Prj.Part is\n             declare\n                Original_Path_Name : constant String :=\n                                       Get_Name_String (Token_Name);\n-\n-               Extended_Project_Path_Name : constant String :=\n-                                              Project_Path_Name_Of\n-                                                (In_Tree,\n-                                                 Original_Path_Name,\n-                                                 Get_Name_String\n-                                                   (Project_Directory));\n-\n+               Extended_Project_Path_Name_Id : Path_Name_Type;\n             begin\n-               if Extended_Project_Path_Name = \"\" then\n+               Find_Project\n+                 (In_Tree.Project_Path,\n+                  Project_File_Name => Original_Path_Name,\n+                  Directory         => Get_Name_String (Project_Directory),\n+                  Path              => Extended_Project_Path_Name_Id);\n+\n+               if Extended_Project_Path_Name_Id = No_Path then\n \n                   --  We could not find the project file to extend\n \n@@ -1604,7 +1581,7 @@ package body Prj.Part is\n                        (In_Tree           => In_Tree,\n                         Project           => Extended_Project,\n                         Extends_All       => Extends_All,\n-                        Path_Name         => Extended_Project_Path_Name,\n+                        Path_Name_Id      => Extended_Project_Path_Name_Id,\n                         Extended          => True,\n                         From_Extended     => From_Ext,\n                         In_Limited        => In_Limited,\n@@ -2010,183 +1987,4 @@ package body Prj.Part is\n       end loop;\n    end Project_Name_From;\n \n-   --------------------------\n-   -- Project_Path_Name_Of --\n-   --------------------------\n-\n-   function Project_Path_Name_Of\n-     (In_Tree           : Project_Node_Tree_Ref;\n-      Project_File_Name : String;\n-      Directory         : String) return String\n-   is\n-\n-      function Try_Path_Name (Path : String) return String_Access;\n-      pragma Inline (Try_Path_Name);\n-      --  Try the specified Path\n-\n-      -------------------\n-      -- Try_Path_Name --\n-      -------------------\n-\n-      function Try_Path_Name (Path : String) return String_Access is\n-         Prj_Path : constant String := Project_Path (In_Tree);\n-         First    : Natural;\n-         Last     : Natural;\n-         Result   : String_Access := null;\n-\n-      begin\n-         if Current_Verbosity = High then\n-            Write_Str  (\"   Trying \");\n-            Write_Line (Path);\n-         end if;\n-\n-         if Is_Absolute_Path (Path) then\n-            if Is_Regular_File (Path) then\n-               Result := new String'(Path);\n-            end if;\n-\n-         else\n-            --  Because we don't want to resolve symbolic links, we cannot use\n-            --  Locate_Regular_File. So, we try each possible path\n-            --  successively.\n-\n-            First := Prj_Path'First;\n-            while First <= Prj_Path'Last loop\n-               while First <= Prj_Path'Last\n-                 and then Prj_Path (First) = Path_Separator\n-               loop\n-                  First := First + 1;\n-               end loop;\n-\n-               exit when First > Prj_Path'Last;\n-\n-               Last := First;\n-               while Last < Prj_Path'Last\n-                 and then Prj_Path (Last + 1) /= Path_Separator\n-               loop\n-                  Last := Last + 1;\n-               end loop;\n-\n-               Name_Len := 0;\n-\n-               if not Is_Absolute_Path (Prj_Path (First .. Last)) then\n-                  Add_Str_To_Name_Buffer (Get_Current_Dir);\n-                  Add_Char_To_Name_Buffer (Directory_Separator);\n-               end if;\n-\n-               Add_Str_To_Name_Buffer (Prj_Path (First .. Last));\n-               Add_Char_To_Name_Buffer (Directory_Separator);\n-               Add_Str_To_Name_Buffer (Path);\n-\n-               if Is_Regular_File (Name_Buffer (1 .. Name_Len)) then\n-                  Result := new String'(Name_Buffer (1 .. Name_Len));\n-                  exit;\n-               end if;\n-\n-               First := Last + 1;\n-            end loop;\n-         end if;\n-\n-         return Result;\n-      end Try_Path_Name;\n-\n-      --  Local Declarations\n-\n-      Result    : String_Access;\n-      Result_Id : Path_Name_Type;\n-      Has_Dot   : Boolean := False;\n-      Key       : Name_Id;\n-\n-   --  Start of processing for Project_Path_Name_Of\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Write_Str  (\"Project_Path_Name_Of (\"\"\");\n-         Write_Str  (Project_File_Name);\n-         Write_Str  (\"\"\", \"\"\");\n-         Write_Str  (Directory);\n-         Write_Line (\"\"\");\");\n-      end if;\n-\n-      --  Check the project cache\n-\n-      Name_Len := Project_File_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Project_File_Name;\n-      Key := Name_Find;\n-      Result_Id := Projects_Paths.Get (Key);\n-\n-      if Result_Id /= No_Path then\n-         return Get_Name_String (Result_Id);\n-      end if;\n-\n-      --  Check if Project_File_Name contains an extension (a dot before a\n-      --  directory separator). If it is the case we do not try project file\n-      --  with an added extension as it is not possible to have multiple dots\n-      --  on a project file name.\n-\n-      Check_Dot : for K in reverse Project_File_Name'Range loop\n-         if Project_File_Name (K) = '.' then\n-            Has_Dot := True;\n-            exit Check_Dot;\n-         end if;\n-\n-         exit Check_Dot when Project_File_Name (K) = Directory_Separator\n-           or else Project_File_Name (K) = '/';\n-      end loop Check_Dot;\n-\n-      if not Is_Absolute_Path (Project_File_Name) then\n-\n-         --  First we try <directory>/<file_name>.<extension>\n-\n-         if not Has_Dot then\n-            Result := Try_Path_Name\n-              (Directory & Directory_Separator &\n-               Project_File_Name & Project_File_Extension);\n-         end if;\n-\n-         --  Then we try <directory>/<file_name>\n-\n-         if Result = null then\n-            Result := Try_Path_Name\n-              (Directory & Directory_Separator & Project_File_Name);\n-         end if;\n-      end if;\n-\n-      --  Then we try <file_name>.<extension>\n-\n-      if Result = null and then not Has_Dot then\n-         Result := Try_Path_Name (Project_File_Name & Project_File_Extension);\n-      end if;\n-\n-      --  Then we try <file_name>\n-\n-      if Result = null then\n-         Result := Try_Path_Name (Project_File_Name);\n-      end if;\n-\n-      --  If we cannot find the project file, we return an empty string\n-\n-      if Result = null then\n-         return \"\";\n-\n-      else\n-         declare\n-            Final_Result : constant String :=\n-                             GNAT.OS_Lib.Normalize_Pathname\n-                               (Result.all,\n-                                Directory      => Directory,\n-                                Resolve_Links  => Opt.Follow_Links_For_Files,\n-                                Case_Sensitive => True);\n-         begin\n-            Free (Result);\n-            Name_Len := Final_Result'Length;\n-            Name_Buffer (1 .. Name_Len) := Final_Result;\n-            Result_Id := Name_Find;\n-\n-            Projects_Paths.Set (Key, Result_Id);\n-            return Final_Result;\n-         end;\n-      end if;\n-   end Project_Path_Name_Of;\n-\n end Prj.Part;"}, {"sha": "c517a47147b897e365b6a2e518a8a354067ecb37", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -76,9 +76,10 @@ package body Prj.Proc is\n    --  the package or project with declarations Decl.\n \n    procedure Check\n-     (In_Tree : Project_Tree_Ref;\n-      Project : Project_Id;\n-      Flags   : Processing_Flags);\n+     (In_Tree   : Project_Tree_Ref;\n+      Project   : Project_Id;\n+      Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags     : Processing_Flags);\n    --  Set all projects to not checked, then call Recursive_Check for the\n    --  main project Project. Project is set to No_Project if errors occurred.\n    --  Current_Dir is for optimization purposes, avoiding extra system calls.\n@@ -270,12 +271,13 @@ package body Prj.Proc is\n    -----------\n \n    procedure Check\n-     (In_Tree : Project_Tree_Ref;\n-      Project : Project_Id;\n-      Flags   : Processing_Flags)\n+     (In_Tree   : Project_Tree_Ref;\n+      Project   : Project_Id;\n+      Node_Tree : Prj.Tree.Project_Node_Tree_Ref;\n+      Flags     : Processing_Flags)\n    is\n    begin\n-      Process_Naming_Scheme (In_Tree, Project, Flags);\n+      Process_Naming_Scheme (In_Tree, Project, Node_Tree, Flags);\n \n       --  Set the Other_Part field for the units\n \n@@ -2316,7 +2318,7 @@ package body Prj.Proc is\n       Success := True;\n \n       if Project /= No_Project then\n-         Check (In_Tree, Project, Flags);\n+         Check (In_Tree, Project, From_Project_Node_Tree, Flags);\n       end if;\n \n       --  If main project is an extending all project, set object directory of"}, {"sha": "55f21950b1a12ce43621ffda656fd0bf5221dcab", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,6 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Osint;   use Osint;\n+with Prj.Env; use Prj.Env;\n with Prj.Err;\n \n with Ada.Unchecked_Deallocation;"}, {"sha": "889d3f179132f80a706412139999d5f642bf6b2d", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -31,6 +31,7 @@ with GNAT.Dynamic_Tables;\n with Table;\n \n with Prj.Attr; use Prj.Attr;\n+with Prj.Env;\n \n package Prj.Tree is\n \n@@ -1474,12 +1475,7 @@ package Prj.Tree is\n       --  The target name, if any, specified with the gprbuild or gprclean\n       --  switch --target=.\n \n-      Project_Path : String_Access := null;\n-      --  The project path, manipulated through subprograms in prj-ext.ads.\n-      --  As a special case, if the first character is '#:\" or this variable is\n-      --  unset, this means that the PATH has not been fully initialized yet\n-      --  (although subprograms prj-ext.ads will properly take care of that).\n-      --\n+      Project_Path : Prj.Env.Project_Search_Path;\n       --  The project path is tree specific, since we might want to load\n       --  simultaneously multiple projects, each with its own search path, in\n       --  particular when using different compilers with different default"}, {"sha": "ce2f74521695d3cd1059dbb875c559022aa206ff", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a786e30d405d181e936f76317e3f1c896d4bfa/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=a0a786e30d405d181e936f76317e3f1c896d4bfa", "patch": "@@ -28,7 +28,7 @@ with Makeutl;  use Makeutl;\n with Osint;    use Osint;\n with Opt;      use Opt;\n with Prj;      use Prj;\n-with Prj.Ext;  use Prj.Ext;\n+with Prj.Env;  use Prj.Env;\n with Table;\n \n package body Switch.M is\n@@ -664,8 +664,8 @@ package body Switch.M is\n          elsif Switch_Chars'Length > 3\n            and then Switch_Chars (Ptr .. Ptr + 1) = \"aP\"\n          then\n-            Add_Search_Project_Directory\n-              (Project_Node_Tree,\n+            Add_Directories\n+              (Project_Node_Tree.Project_Path,\n                Switch_Chars (Ptr + 2 .. Switch_Chars'Last));\n \n          elsif C = 'v' and then Switch_Chars'Length = 3 then\n@@ -813,7 +813,7 @@ package body Switch.M is\n                --  Processing for C switch\n \n                when 'C' =>\n-                  Create_Mapping_File := True;\n+                  Opt.Create_Mapping_File := True;\n \n                --  Processing for D switch\n "}]}