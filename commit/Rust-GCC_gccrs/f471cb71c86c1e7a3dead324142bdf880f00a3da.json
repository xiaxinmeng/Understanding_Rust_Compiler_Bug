{"sha": "f471cb71c86c1e7a3dead324142bdf880f00a3da", "node_id": "C_kwDOANBUbNoAKGY0NzFjYjcxYzg2YzFlN2EzZGVhZDMyNDE0MmJkZjg4MGYwMGEzZGE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-07T18:29:30Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-07T18:29:30Z"}, "message": "libstdc++: Implement ranges::cartesian_product_view from P2374R4\n\nThis also implements the proposed resolutions of the tentatively ready\nLWG issues 3760, 3761 and 3801 for cartesian_product_view.\n\nI'm not sure how/if we should implement the recommended practice of:\n\n  iterator::difference_type should be the smallest signed-integer-like\n  type that is sufficiently wide to store the product of the maximum\n  sizes of all underlying ranges if such a type exists\n\nbecause for e.g.\n\n  extern std::vector<int> x, y;\n  auto v = views::cartesian_product(x, y);\n\nIIUC it'd mean difference_type should be __int128 (on 64-bit systems),\nwhich seems quite wasteful: in practice the size of any cartesian product\nprobably won't exceed the precision of say ptrdiff_t, and using anything\nlarger will just incur unnecessary space/time overhead.  It's also\nprobably not worth the complexity to use less precision than ptrdiff_t\n(when possible) either.  So this patch defines difference_type as\n\n  common_type_t<ptrdiff_t, range_difference_t<_First>, range_difference_t<_Vs>...>\n\nwhich should mean it's least as large as the difference_type of each\nunderlying range, and at least as large as ptrdiff_t.  This patch also\nadds assertions to catch any overflow that occurs due to this choice of\ndifference_type.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__maybe_const_t): New alias for\n\t__detail::__maybe_const_t.\n\t(__detail::__cartesian_product_is_random_access): Define.\n\t(__detail::__cartesian_product_common_arg): Define.\n\t(__detail::__cartesian_product_is_bidirectional): Define.\n\t(__detail::__cartesian_product_is_common): Define.\n\t(__detail::__cartesian_product_is_sized): Define.\n\t(__detail::__cartesian_is_sized_sentinel): Define.\n\t(__detail::__cartesian_common_arg_end): Define.\n\t(cartesian_product_view): Define.\n\t(cartesian_product_view::_Iterator): Define.\n\t(views::__detail::__can_cartesian_product_view): Define.\n\t(views::_CartesianProduct, views::cartesian_product): Define.\n\t* testsuite/std/ranges/cartesian_product/1.cc: New test.", "tree": {"sha": "ae715f3e7969bde217e8a3bfd49cb4ca15d236f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae715f3e7969bde217e8a3bfd49cb4ca15d236f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f471cb71c86c1e7a3dead324142bdf880f00a3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f471cb71c86c1e7a3dead324142bdf880f00a3da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f471cb71c86c1e7a3dead324142bdf880f00a3da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f471cb71c86c1e7a3dead324142bdf880f00a3da/comments", "author": null, "committer": null, "parents": [{"sha": "42f42d70c6ab1dea0a9c2c3ed435890156759aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f42d70c6ab1dea0a9c2c3ed435890156759aef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f42d70c6ab1dea0a9c2c3ed435890156759aef"}], "stats": {"total": 699, "additions": 699, "deletions": 0}, "files": [{"sha": "959886a1a550dc01c1ce9aa5d34c11b34287075e", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f471cb71c86c1e7a3dead324142bdf880f00a3da/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f471cb71c86c1e7a3dead324142bdf880f00a3da/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=f471cb71c86c1e7a3dead324142bdf880f00a3da", "patch": "@@ -829,6 +829,9 @@ namespace __detail\n \n } // namespace __detail\n \n+// Shorthand for __detail::__maybe_const_t.\n+using __detail::__maybe_const_t;\n+\n namespace views::__adaptor\n {\n   // True if the range adaptor _Adaptor can be applied with _Args.\n@@ -7973,6 +7976,516 @@ namespace views::__adaptor\n \n     inline constexpr _Stride stride;\n   }\n+\n+  namespace __detail\n+  {\n+    template<bool _Const, typename _First, typename... _Vs>\n+      concept __cartesian_product_is_random_access\n+\t= (random_access_range<__maybe_const_t<_Const, _First>>\n+\t   && ...\n+\t   && (random_access_range<__maybe_const_t<_Const, _Vs>>\n+\t       && sized_range<__maybe_const_t<_Const, _Vs>>));\n+\n+    template<typename _Range>\n+      concept __cartesian_product_common_arg\n+\t= common_range<_Range> || (sized_range<_Range> && random_access_range<_Range>);\n+\n+    template<bool _Const, typename _First, typename... _Vs>\n+      concept __cartesian_product_is_bidirectional\n+\t= (bidirectional_range<__maybe_const_t<_Const, _First>>\n+\t   && ...\n+\t   && (bidirectional_range<__maybe_const_t<_Const, _Vs>>\n+\t       && __cartesian_product_common_arg<__maybe_const_t<_Const, _Vs>>));\n+\n+    template<typename _First, typename... _Vs>\n+      concept __cartesian_product_is_common = __cartesian_product_common_arg<_First>;\n+\n+    template<typename... _Vs>\n+      concept __cartesian_product_is_sized = (sized_range<_Vs> && ...);\n+\n+    template<bool _Const, template<typename> class FirstSent, typename _First, typename... _Vs>\n+      concept __cartesian_is_sized_sentinel\n+\t= (sized_sentinel_for<FirstSent<__maybe_const_t<_Const, _First>>,\n+\t\t\t      iterator_t<__maybe_const_t<_Const, _First>>>\n+\t   && ...\n+\t   && (sized_range<__maybe_const_t<_Const, _Vs>>\n+\t       && sized_sentinel_for<iterator_t<__maybe_const_t<_Const, _Vs>>,\n+\t\t\t\t     iterator_t<__maybe_const_t<_Const, _Vs>>>));\n+\n+    template<__cartesian_product_common_arg _Range>\n+      constexpr auto\n+      __cartesian_common_arg_end(_Range& __r)\n+      {\n+\tif constexpr (common_range<_Range>)\n+\t  return ranges::end(__r);\n+\telse\n+\t  return ranges::begin(__r) + ranges::distance(__r);\n+      }\n+  } // namespace __detail\n+\n+  template<input_range _First, forward_range... _Vs>\n+    requires (view<_First> && ... && view<_Vs>)\n+  class cartesian_product_view : public view_interface<cartesian_product_view<_First, _Vs...>>\n+  {\n+    tuple<_First, _Vs...> _M_bases;\n+\n+    template<bool> class _Iterator;\n+\n+    static auto\n+    _S_difference_type()\n+    {\n+      // TODO: Implement the recommended practice of using the smallest\n+      // sufficiently wide type according to the maximum sizes of the\n+      // underlying ranges?\n+      return common_type_t<ptrdiff_t,\n+\t\t\t   range_difference_t<_First>,\n+\t\t\t   range_difference_t<_Vs>...>{};\n+    }\n+\n+  public:\n+    cartesian_product_view() = default;\n+\n+    constexpr explicit\n+    cartesian_product_view(_First __first, _Vs... __rest)\n+    : _M_bases(std::move(__first), std::move(__rest)...)\n+    { }\n+\n+    constexpr _Iterator<false>\n+    begin() requires (!__detail::__simple_view<_First> || ... || !__detail::__simple_view<_Vs>)\n+    { return _Iterator<false>(*this, __detail::__tuple_transform(ranges::begin, _M_bases)); }\n+\n+    constexpr _Iterator<true>\n+    begin() const requires (range<const _First> && ... && range<const _Vs>)\n+    { return _Iterator<true>(*this, __detail::__tuple_transform(ranges::begin, _M_bases)); }\n+\n+    constexpr _Iterator<false>\n+    end() requires ((!__detail::__simple_view<_First> || ... || !__detail::__simple_view<_Vs>)\n+\t\t    && __detail::__cartesian_product_is_common<_First, _Vs...>)\n+    {\n+      bool __empty_tail = [this]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn (ranges::empty(std::get<1 + _Is>(_M_bases)) || ...);\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+\n+      auto __it = __detail::__tuple_transform(ranges::begin, _M_bases);\n+      if (!__empty_tail)\n+\tstd::get<0>(__it) = __detail::__cartesian_common_arg_end(std::get<0>(_M_bases));\n+      return _Iterator<false>{*this, std::move(__it)};\n+    }\n+\n+    constexpr _Iterator<true>\n+    end() const requires __detail::__cartesian_product_is_common<const _First, const _Vs...>\n+    {\n+      bool __empty_tail = [this]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn (ranges::empty(std::get<1 + _Is>(_M_bases)) || ...);\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+\n+      auto __it = __detail::__tuple_transform(ranges::begin, _M_bases);\n+      if (!__empty_tail)\n+\tstd::get<0>(__it) = __detail::__cartesian_common_arg_end(std::get<0>(_M_bases));\n+      return _Iterator<true>{*this, std::move(__it)};\n+    }\n+\n+    constexpr default_sentinel_t\n+    end() const noexcept\n+    { return default_sentinel; }\n+\n+    constexpr auto\n+    size() requires __detail::__cartesian_product_is_sized<_First, _Vs...>\n+    {\n+      using _ST = __detail::__make_unsigned_like_t<decltype(_S_difference_type())>;\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\tauto __size = static_cast<_ST>(1);\n+#ifdef _GLIBCXX_ASSERTIONS\n+\tif constexpr (integral<_ST>)\n+\t  {\n+\t    bool __overflow\n+\t      = (__builtin_mul_overflow(__size,\n+\t\t\t\t\tstatic_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))),\n+\t\t\t\t\t&__size)\n+\t\t || ...);\n+\t    __glibcxx_assert(!__overflow);\n+\t  }\n+\telse\n+#endif\n+\t  __size = (static_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))) * ...);\n+\treturn __size;\n+      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n+    }\n+\n+    constexpr auto\n+    size() const requires __detail::__cartesian_product_is_sized<const _First, const _Vs...>\n+    {\n+      using _ST = __detail::__make_unsigned_like_t<decltype(_S_difference_type())>;\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\tauto __size = static_cast<_ST>(1);\n+#ifdef _GLIBCXX_ASSERTIONS\n+\tif constexpr (integral<_ST>)\n+\t  {\n+\t    bool __overflow\n+\t      = (__builtin_mul_overflow(__size,\n+\t\t\t\t\tstatic_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))),\n+\t\t\t\t\t&__size)\n+\t\t || ...);\n+\t    __glibcxx_assert(!__overflow);\n+\t  }\n+\telse\n+#endif\n+\t  __size = (static_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))) * ...);\n+\treturn __size;\n+      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n+    }\n+  };\n+\n+  template<typename... _Vs>\n+    cartesian_product_view(_Vs&&...) -> cartesian_product_view<views::all_t<_Vs>...>;\n+\n+  template<input_range _First, forward_range... _Vs>\n+    requires (view<_First> && ... && view<_Vs>)\n+  template<bool _Const>\n+  class cartesian_product_view<_First, _Vs...>::_Iterator\n+  {\n+    using _Parent = __maybe_const_t<_Const, cartesian_product_view>;\n+    _Parent* _M_parent = nullptr;\n+    __detail::__tuple_or_pair_t<iterator_t<__maybe_const_t<_Const, _First>>,\n+\t\t\t\titerator_t<__maybe_const_t<_Const, _Vs>>...> _M_current;\n+\n+    constexpr\n+    _Iterator(_Parent& __parent, decltype(_M_current) __current)\n+    : _M_parent(std::__addressof(__parent)),\n+      _M_current(std::move(__current))\n+    { }\n+\n+    static auto\n+    _S_iter_concept()\n+    {\n+      if constexpr (__detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>)\n+\treturn random_access_iterator_tag{};\n+      else if constexpr (__detail::__cartesian_product_is_bidirectional<_Const, _First, _Vs...>)\n+\treturn bidirectional_iterator_tag{};\n+      else if constexpr (forward_range<__maybe_const_t<_Const, _First>>)\n+\treturn forward_iterator_tag{};\n+      else\n+\treturn input_iterator_tag{};\n+    }\n+\n+    friend cartesian_product_view;\n+\n+  public:\n+    using iterator_category = input_iterator_tag;\n+    using iterator_concept = decltype(_S_iter_concept());\n+    using value_type\n+      = __detail::__tuple_or_pair_t<range_value_t<__maybe_const_t<_Const, _First>>,\n+\t\t\t\t    range_value_t<__maybe_const_t<_Const, _Vs>>...>;\n+    using reference\n+      = __detail::__tuple_or_pair_t<range_reference_t<__maybe_const_t<_Const, _First>>,\n+\t\t\t\t    range_reference_t<__maybe_const_t<_Const, _Vs>>...>;\n+    using difference_type = decltype(cartesian_product_view::_S_difference_type());\n+\n+    _Iterator() requires forward_range<__maybe_const_t<_Const, _First>> = default;\n+\n+    constexpr\n+    _Iterator(_Iterator<!_Const> __i)\n+      requires _Const\n+\t&& (convertible_to<iterator_t<_First>, iterator_t<const _First>>\n+\t    && ... && convertible_to<iterator_t<_Vs>, iterator_t<const _Vs>>)\n+    : _M_parent(std::__addressof(__i._M_parent)),\n+      _M_current(std::move(__i._M_current))\n+    { }\n+\n+    constexpr auto\n+    operator*() const\n+    {\n+      auto __f = [](auto& __i) -> decltype(auto) {\n+\treturn *__i;\n+      };\n+      return __detail::__tuple_transform(__f, _M_current);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      _M_next();\n+      return *this;\n+    }\n+\n+    constexpr void\n+    operator++(int)\n+    { ++*this; }\n+\n+    constexpr _Iterator\n+    operator++(int) requires forward_range<__maybe_const_t<_Const, _First>>\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--()\n+      requires __detail::__cartesian_product_is_bidirectional<_Const, _First, _Vs...>\n+    {\n+      _M_prev();\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int)\n+      requires __detail::__cartesian_product_is_bidirectional<_Const, _First, _Vs...>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator+=(difference_type __x)\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    {\n+      _M_advance(__x);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator&\n+    operator-=(difference_type __x)\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    { return *this += -__x; }\n+\n+    constexpr reference\n+    operator[](difference_type __n) const\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    { return *((*this) + __n); }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+      requires equality_comparable<iterator_t<__maybe_const_t<_Const, _First>>>\n+    { return __x._M_current == __y._M_current; }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, default_sentinel_t)\n+    {\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn ((std::get<_Is>(__x._M_current)\n+\t\t == ranges::end(std::get<_Is>(__x._M_parent->_M_bases)))\n+\t\t|| ...);\n+      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n+    }\n+\n+    friend constexpr auto\n+    operator<=>(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__all_random_access<_Const, _First, _Vs...>\n+    { return __x._M_current <=> __y._M_current; }\n+\n+    friend constexpr _Iterator\n+    operator+(_Iterator __x, difference_type __y)\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    { return __x += __y; }\n+\n+    friend constexpr _Iterator\n+    operator+(difference_type __x, _Iterator __y)\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    { return __y += __x; }\n+\n+    friend constexpr _Iterator\n+    operator-(_Iterator __x, difference_type __y)\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    { return __x -= __y; }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__cartesian_is_sized_sentinel<_Const, iterator_t, _First, _Vs...>\n+    { return __x._M_distance_from(__y._M_current); }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __i, default_sentinel_t)\n+      requires __detail::__cartesian_is_sized_sentinel<_Const, sentinel_t, _First, _Vs...>\n+    {\n+      tuple __end_tuple = [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn tuple{ranges::end(std::get<0>(__i._M_parent->_M_bases)),\n+\t\t     ranges::begin(std::get<1 + _Is>(__i._M_parent->_M_bases))...};\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+      return __i._M_distance_from(__end_tuple);\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(default_sentinel_t, const _Iterator& __i)\n+      requires __detail::__cartesian_is_sized_sentinel<_Const, sentinel_t, _First, _Vs...>\n+    { return -(__i - default_sentinel); }\n+\n+    friend constexpr auto\n+    iter_move(const _Iterator& __i)\n+    { return __detail::__tuple_transform(ranges::iter_move, __i._M_current); }\n+\n+    friend constexpr void\n+    iter_swap(const _Iterator& __l, const _Iterator& __r)\n+      requires (indirectly_swappable<iterator_t<__maybe_const_t<_Const, _First>>>\n+\t\t&& ...\n+\t\t&& indirectly_swappable<iterator_t<__maybe_const_t<_Const, _Vs>>>)\n+    {\n+      [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\t(ranges::iter_swap(std::get<_Is>(__l._M_current), std::get<_Is>(__r._M_current)), ...);\n+      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n+    }\n+\n+  private:\n+    template<size_t _Nm = sizeof...(_Vs)>\n+    constexpr void\n+    _M_next()\n+    {\n+      auto& __it = std::get<_Nm>(_M_current);\n+      ++__it;\n+      if constexpr (_Nm > 0)\n+\tif (__it == ranges::end(std::get<_Nm>(_M_parent->_M_bases)))\n+\t  {\n+\t    __it = ranges::begin(std::get<_Nm>(_M_parent->_M_bases));\n+\t    _M_next<_Nm - 1>();\n+\t  }\n+    }\n+\n+    template<size_t _Nm = sizeof...(_Vs)>\n+    constexpr void\n+    _M_prev()\n+    {\n+      auto& __it = std::get<_Nm>(_M_current);\n+      if (__it == ranges::begin(std::get<_Nm>(_M_parent->_M_bases)))\n+\t{\n+\t  __it = __detail::__cartesian_common_arg_end(std::get<_Nm>(_M_parent->_M_bases));\n+\t  if constexpr (_Nm > 0)\n+\t    _M_prev<_Nm - 1>();\n+\t}\n+      --__it;\n+    }\n+\n+    template<size_t _Nm = sizeof...(_Vs)>\n+    constexpr void\n+    _M_advance(difference_type __x)\n+      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n+    {\n+      if (__x == 1)\n+\t_M_next<_Nm>();\n+      else if (__x == -1)\n+\t_M_prev<_Nm>();\n+      else if (__x != 0)\n+\t{\n+\t  // Constant time iterator advancement.\n+\t  auto& __r = std::get<_Nm>(_M_parent->_M_bases);\n+\t  auto& __it = std::get<_Nm>(_M_current);\n+\t  if constexpr (_Nm == 0)\n+\t    {\n+#ifdef _GLIBCXX_ASSERTIONS\n+\t      auto __size = ranges::ssize(__r);\n+\t      auto __begin = ranges::begin(__r);\n+\t      auto __offset = __it - __begin;\n+\t      __glibcxx_assert(__offset + __x >= 0 && __offset + __x <= __size);\n+#endif\n+\t      __it += __x;\n+\t    }\n+\t  else\n+\t    {\n+\t      auto __size = ranges::ssize(__r);\n+\t      auto __begin = ranges::begin(__r);\n+\t      auto __offset = __it - __begin;\n+\t      __offset += __x;\n+\t      __x = __offset / __size;\n+\t      __offset %= __size;\n+\t      if (__offset < 0)\n+\t\t{\n+\t\t  __offset = __size + __offset;\n+\t\t  --__x;\n+\t\t}\n+\t      __it = __begin + __offset;\n+\t      _M_advance<_Nm - 1>(__x);\n+\t    }\n+\t}\n+    }\n+\n+    template<typename _Tuple>\n+    constexpr difference_type\n+    _M_distance_from(const _Tuple& __t) const\n+    {\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\tauto __sum = static_cast<difference_type>(0);\n+#ifdef _GLIBCXX_ASSERTIONS\n+\tif constexpr (integral<difference_type>)\n+\t  {\n+\t    bool __overflow\n+\t      = (__builtin_add_overflow(__sum, _M_scaled_distance<_Is>(__t), &__sum)\n+\t\t || ...);\n+\t    __glibcxx_assert(!__overflow);\n+\t  }\n+\telse\n+#endif\n+\t  __sum = (_M_scaled_distance<_Is>(__t) + ...);\n+\treturn __sum;\n+      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n+    }\n+\n+    template<size_t _Nm, typename _Tuple>\n+    constexpr difference_type\n+    _M_scaled_distance(const _Tuple& __t) const\n+    {\n+      auto __dist = static_cast<difference_type>(std::get<_Nm>(_M_current)\n+\t\t\t\t\t\t - std::get<_Nm>(__t));\n+#ifdef _GLIBCXX_ASSERTIONS\n+      if constexpr (integral<difference_type>)\n+\t{\n+\t  bool __overflow = __builtin_mul_overflow(__dist, _M_scaled_size<_Nm+1>(), &__dist);\n+\t  __glibcxx_assert(!__overflow);\n+\t}\n+      else\n+#endif\n+\t__dist *= _M_scaled_size<_Nm+1>();\n+      return __dist;\n+    }\n+\n+    template<size_t _Nm>\n+    constexpr difference_type\n+    _M_scaled_size() const\n+    {\n+      if constexpr (_Nm <= sizeof...(_Vs))\n+\t{\n+\t  auto __size = static_cast<difference_type>(ranges::size\n+\t\t\t\t\t\t     (std::get<_Nm>(_M_parent->_M_bases)));\n+#ifdef _GLIBCXX_ASSERTIONS\n+\t  if constexpr (integral<difference_type>)\n+\t    {\n+\t      bool __overflow = __builtin_mul_overflow(__size, _M_scaled_size<_Nm+1>(), &__size);\n+\t      __glibcxx_assert(!__overflow);\n+\t    }\n+\t  else\n+#endif\n+\t    __size *= _M_scaled_size<_Nm+1>();\n+\t  return __size;\n+\t}\n+      else\n+\treturn static_cast<difference_type>(1);\n+    }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename... _Ts>\n+\tconcept __can_cartesian_product_view\n+\t  = requires { cartesian_product_view<all_t<_Ts>...>(std::declval<_Ts>()...); };\n+    }\n+\n+    struct _CartesianProduct\n+    {\n+      template<typename... _Ts>\n+\trequires (sizeof...(_Ts) == 0 || __detail::__can_cartesian_product_view<_Ts...>)\n+\tconstexpr auto\n+\toperator() [[nodiscard]] (_Ts&&... __ts) const\n+\t{\n+\t  if constexpr (sizeof...(_Ts) == 0)\n+\t    return views::empty<tuple<>>;\n+\t  else\n+\t    return cartesian_product_view<all_t<_Ts>...>(std::forward<_Ts>(__ts)...);\n+\t}\n+    };\n+\n+    inline constexpr _CartesianProduct cartesian_product;\n+  }\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "d6e4b538b20bc48c433dbe421bab02715e57c439", "filename": "libstdc++-v3/testsuite/std/ranges/cartesian_product/1.cc", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f471cb71c86c1e7a3dead324142bdf880f00a3da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fcartesian_product%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f471cb71c86c1e7a3dead324142bdf880f00a3da/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fcartesian_product%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fcartesian_product%2F1.cc?ref=f471cb71c86c1e7a3dead324142bdf880f00a3da", "patch": "@@ -0,0 +1,186 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 3};\n+  int y[] = {4, 5, 6};\n+  int z[] = {7, 8};\n+  int w[] = {9};\n+\n+  auto v0 = views::cartesian_product();\n+  VERIFY( ranges::end(v0) - ranges::begin(v0) == 0 );\n+  VERIFY( ranges::size(v0) == 0 );\n+  VERIFY( ranges::empty(v0) );\n+\n+  auto v1 = views::cartesian_product(x);\n+  VERIFY( ranges::end(v1) - ranges::begin(v1) == 3 );\n+  VERIFY( ranges::size(v1) == 3 );\n+  VERIFY( ranges::equal(v1 | views::keys, x) );\n+  VERIFY( std::get<0>(v1[0]) == 1 );\n+  VERIFY( std::get<0>(v1[1]) == 2 );\n+  VERIFY( std::get<0>(v1[2]) == 3 );\n+  VERIFY( ranges::equal(v1 | views::reverse | views::keys, x | views::reverse));\n+\n+  auto v2 = views::cartesian_product(x, y);\n+  VERIFY( ranges::size(v2) == 9 );\n+  VERIFY( ranges::end(v2) - ranges::begin(v2) == 9 );\n+  VERIFY( ranges::equal(v2 | views::keys,   (int[]){1, 1, 1, 2, 2, 2, 3, 3, 3}));\n+  VERIFY( ranges::equal(v2 | views::values, (int[]){4, 5, 6, 4, 5, 6, 4, 5, 6}));\n+  VERIFY( ranges::equal(v2 | views::reverse | views::keys,   (int[]){3, 3, 3, 2, 2, 2, 1, 1, 1}) );\n+  VERIFY( ranges::equal(v2 | views::reverse | views::values, (int[]){6, 5, 4, 6, 5, 4, 6, 5, 4}) );\n+\n+  auto v3 = views::cartesian_product(x, y, z);\n+  VERIFY( ranges::size(v3) == 18 );\n+  VERIFY( ranges::equal(v3, (std::tuple<int,int,int>[]){{1,4,7}, {1,4,8}, {1,5,7}, {1,5,8},\n+\t\t\t\t\t\t\t{1,6,7}, {1,6,8}, {2,4,7}, {2,4,8},\n+\t\t\t\t\t\t\t{2,5,7}, {2,5,8}, {2,6,7}, {2,6,8},\n+\t\t\t\t\t\t\t{3,4,7}, {3,4,8}, {3,5,7}, {3,5,8},\n+\t\t\t\t\t\t\t{3,6,7}, {3,6,8}}) );\n+\n+  auto v4 = views::cartesian_product(x, y, z, w);\n+  VERIFY( ranges::size(v4) == 18 );\n+  VERIFY( ranges::equal(v4 | views::elements<3>, views::repeat(9, 18)) );\n+\n+  auto i4 = v4.begin(), j4 = i4 + 1;\n+  VERIFY( j4 > i4 );\n+  VERIFY( i4[0] == std::tuple(1, 4, 7, 9) );\n+  VERIFY( i4 + 18 == v4.end() );\n+  i4 += 5;\n+  VERIFY( i4 != v4.begin() );\n+  VERIFY( i4 - 5 == v4.begin() );\n+  VERIFY( *i4 == std::tuple(1, 6, 8, 9) );\n+  VERIFY( i4 - 5 != i4 );\n+  i4 -= 3;\n+  VERIFY( *i4 == std::tuple(1, 5, 7, 9) );\n+  VERIFY( j4 + 1 == i4 );\n+  ranges::iter_swap(i4, j4);\n+  VERIFY( *j4 == std::tuple(1, 5, 7, 9) );\n+  VERIFY( *i4 == std::tuple(1, 4, 8, 9) );\n+\n+  return true;\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2};\n+  __gnu_test::test_input_range<int> rx(x);\n+  auto v = views::cartesian_product(rx, x);\n+  auto i = v.begin();\n+  std::default_sentinel_t s = v.end();\n+  VERIFY( i != s );\n+  VERIFY( std::get<0>(*i) == 1 && std::get<1>(*i) == 1 );\n+  ++i;\n+  VERIFY( i != s );\n+  VERIFY( std::get<0>(*i) == 1 && std::get<1>(*i) == 2 );\n+  ++i;\n+  VERIFY( i != s );\n+  VERIFY( std::get<0>(*i) == 2 && std::get<1>(*i) == 1 );\n+  ++i;\n+  VERIFY( i != s );\n+  VERIFY( std::get<0>(*i) == 2 && std::get<1>(*i) == 2 );\n+  ++i;\n+  VERIFY( i == s );\n+}\n+\n+void\n+test03()\n+{\n+  int x[2];\n+  __gnu_test::test_input_range<int> rx(x);\n+  auto v = views::cartesian_product(views::counted(rx.begin(), 2), x);\n+  VERIFY( v.size() == 4 );\n+  auto i = v.begin();\n+  std::default_sentinel_t s = v.end();\n+  VERIFY( i - s == -4 );\n+  VERIFY( s - i == 4 );\n+  ++i;\n+  VERIFY( i - s == -3 );\n+  VERIFY( s - i == 3 );\n+  ++i;\n+  VERIFY( i - s == -2 );\n+  VERIFY( s - i == 2 );\n+  ++i;\n+  VERIFY( i - s == -1 );\n+  VERIFY( s - i == 1 );\n+  ++i;\n+  VERIFY( i - s == 0 );\n+  VERIFY( s - i == 0 );\n+}\n+\n+void\n+test04()\n+{\n+  // Exhaustively verify correctness of our iterator addition implementation\n+  // (which runs in constant time) for this 24-element cartesian_product_view.\n+  int x[4], y[3], z[2], w[1];\n+  auto v = views::cartesian_product(x, y, z, w);\n+\n+  auto n = ranges::ssize(v);\n+  for (int i = 0; i <= n; i++)\n+    for (int j = 0; i + j <= n; j++)\n+      {\n+\tauto b1 = v.begin();\n+\tfor (int k = 0; k < i + j; k++)\n+\t  ++b1;\n+\tVERIFY( b1 - v.begin() == i + j );\n+\tauto b2 = (v.begin() + i) + j;\n+\tauto b3 = v.begin() + (i + j);\n+\tVERIFY( b1 == b2 && b2 == b3 );\n+\n+\tauto e1 = v.end();\n+\tfor (int k = 0; k < i + j; k++)\n+\t  --e1;\n+\tVERIFY( v.end() - e1 == i + j );\n+\tauto e2 = (v.end() - i) - j;\n+\tauto e3 = v.end() - (i + j);\n+\tVERIFY( e1 == e2 && e2 == e3 );\n+      }\n+}\n+\n+void\n+test05()\n+{\n+#if __SIZEOF_INT128__\n+  auto r = views::iota(__int128(0), __int128(5));\n+#else\n+  auto r = views::iota(0ll, 5ll);\n+#endif\n+  auto v = views::cartesian_product(r, r);\n+  VERIFY( ranges::size(v) == 25 );\n+  VERIFY( v.end() - v.begin() == 25 );\n+  VERIFY( v.begin() + ranges::ssize(v) - v.begin() == 25 );\n+}\n+\n+constexpr bool\n+test06()\n+{\n+  int x[] = {1, 2, 3};\n+  auto v = views::cartesian_product(x, views::empty<int>, x);\n+  VERIFY( ranges::size(v) == 0 );\n+  VERIFY( ranges::begin(v) == ranges::end(v) );\n+  VERIFY( ranges::begin(v) - ranges::begin(v) == 0 );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  static_assert(test06());\n+}"}]}