{"sha": "7963ac373a00ea0f077cb26898a2896bfa389c17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk2M2FjMzczYTAwZWEwZjA3N2NiMjY4OThhMjg5NmJmYTM4OWMxNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-15T02:26:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-15T02:26:55Z"}, "message": "(shift_cost): Now a vector.\n\n(shiftadd_cost): New vector for cost of (N * a + b) instructions.\n(shiftsub_cost): New vector for cost of (N * a - b) instructions.\n(lea_cost): Removed.\n(init_expmed): Initialize new vectors.  Use ASHIFT, not LSHIFT.\nRemove code initializing lea_cost.\n(enum alg_code): New definition.\n(synth_mult): Rewrite for better algorithms and faster operation.\n(expand_mult): Rewrite code for constant multiplication.\n\nFrom-SVN: r3735", "tree": {"sha": "6a293f6ccb972cb7a5c875d48b07aaec4b9aa94e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a293f6ccb972cb7a5c875d48b07aaec4b9aa94e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7963ac373a00ea0f077cb26898a2896bfa389c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7963ac373a00ea0f077cb26898a2896bfa389c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7963ac373a00ea0f077cb26898a2896bfa389c17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7963ac373a00ea0f077cb26898a2896bfa389c17/comments", "author": null, "committer": null, "parents": [{"sha": "f00528875739bbe8089a2a498aa3fbcbbb4512cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f00528875739bbe8089a2a498aa3fbcbbb4512cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f00528875739bbe8089a2a498aa3fbcbbb4512cb"}], "stats": {"total": 503, "additions": 238, "deletions": 265}, "files": [{"sha": "3a6f0d8ec7a300e9c3026da891f3a159a83f2919", "filename": "gcc/expmed.c", "status": "modified", "additions": 238, "deletions": 265, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7963ac373a00ea0f077cb26898a2896bfa389c17/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7963ac373a00ea0f077cb26898a2896bfa389c17/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=7963ac373a00ea0f077cb26898a2896bfa389c17", "patch": "@@ -50,7 +50,10 @@ int mult_is_very_cheap;\n static int sdiv_pow2_cheap, smod_pow2_cheap;\n \n /* Cost of various pieces of RTL.  */\n-static int add_cost, shift_cost, mult_cost, negate_cost, lea_cost;\n+static int add_cost, mult_cost, negate_cost;\n+static int shift_cost[BITS_PER_WORD];\n+static int shiftadd_cost[BITS_PER_WORD];\n+static int shiftsub_cost[BITS_PER_WORD];\n \n /* Max scale factor for scaled address in lea instruction.  */\n static int lea_max_mul;\n@@ -63,44 +66,47 @@ init_expmed ()\n      to see what insns exist.  */\n   rtx reg = gen_rtx (REG, word_mode, FIRST_PSEUDO_REGISTER);\n   rtx pow2 = GEN_INT (32);\n-  rtx lea;\n+  rtx shift_tmp, shiftadd_tmp, shiftsub_tmp;\n   HOST_WIDE_INT i;\n   int dummy;\n+  int m;\n \n   add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg), SET);\n-  shift_cost = rtx_cost (gen_rtx (LSHIFT, word_mode, reg,\n-\t\t\t\t  /* Using a constant gives better\n-\t\t\t\t     estimate of typical costs.\n-\t\t\t\t     1 or 2 might have quirks.  */\n-\t\t\t\t  GEN_INT (3)), SET);\n+\n+  shift_tmp = gen_rtx (ASHIFT, word_mode, reg, const0_rtx);\n+  shiftadd_tmp = gen_rtx (PLUS, word_mode, gen_rtx (MULT, word_mode, reg, const0_rtx), reg);\n+  shiftsub_tmp = gen_rtx (MINUS, word_mode, gen_rtx (MULT, word_mode, reg, const0_rtx), reg);\n+\n+  init_recog ();\n+  /* Using 0 as second argument of recog in the loop is not quite right,\n+     but what else is there to do?  */\n+  for (m = 1; m < BITS_PER_WORD; m++)\n+    {\n+      shift_cost[m] = shiftadd_cost[m] = shiftsub_cost[m] = 32000;\n+      XEXP (shift_tmp, 1) = GEN_INT (m);\n+      if (recog (gen_rtx (SET, VOIDmode, reg, shift_tmp), 0, &dummy) >= 0)\n+\tshift_cost[m] = rtx_cost (shift_tmp, SET);\n+      XEXP (XEXP (shiftadd_tmp, 0), 1) = GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      if (recog (gen_rtx (SET, VOIDmode, reg, shiftadd_tmp), 0, &dummy) >= 0)\n+\tshiftadd_cost[m] = rtx_cost (shiftadd_tmp, SET);\n+      XEXP (XEXP (shiftsub_tmp, 0), 1) = GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      if (recog (gen_rtx (SET, VOIDmode, reg, shiftsub_tmp), 0, &dummy) >= 0)\n+\tshiftsub_cost[m] = rtx_cost (shiftsub_tmp, SET);\n+    }\n+\n   mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg), SET);\n   negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg), SET);\n \n   /* 999999 is chosen to avoid any plausible faster special case.  */\n   mult_is_very_cheap\n     = (rtx_cost (gen_rtx (MULT, word_mode, reg, GEN_INT (999999)), SET)\n-       < rtx_cost (gen_rtx (LSHIFT, word_mode, reg, GEN_INT (7)), SET));\n+       < rtx_cost (gen_rtx (ASHIFT, word_mode, reg, GEN_INT (7)), SET));\n \n   sdiv_pow2_cheap\n     = rtx_cost (gen_rtx (DIV, word_mode, reg, pow2), SET) <= 2 * add_cost;\n   smod_pow2_cheap\n     = rtx_cost (gen_rtx (MOD, word_mode, reg, pow2), SET) <= 2 * add_cost;\n \n-  init_recog ();\n-  for (i = 2;; i <<= 1)\n-    {\n-      lea = gen_rtx (SET, VOIDmode, reg,\n-\t\t     gen_rtx (PLUS, word_mode,\n-\t\t\t      gen_rtx (MULT, word_mode, reg, GEN_INT (i)),\n-\t\t\t      reg));\n-      /* Using 0 as second argument is not quite right,\n-\t but what else is there to do?  */\n-      if (recog (lea, 0, &dummy) < 0)\n-\tbreak;\n-      lea_max_mul = i;\n-      lea_cost = rtx_cost (SET_SRC (lea), SET);\n-    }\n-\n   /* Free the objects we just allocated.  */\n   obfree (free_point);\n }\n@@ -1716,42 +1722,49 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n   return temp;\n }\n \f\n-enum alg_code { alg_add, alg_subtract, alg_compound };\n+enum alg_code { alg_none, alg_add_t_m2, alg_sub_t_m2,\n+\t\t  alg_add_factor, alg_sub_factor,\n+\t\t  alg_add_t2_m, alg_sub_t2_m,\n+alg_add, alg_subtract, alg_factor, alg_shiftop };\n \n /* This structure records a sequence of operations.\n    `ops' is the number of operations recorded.\n    `cost' is their total cost.\n    The operations are stored in `op' and the corresponding\n    integer coefficients in `coeff'.\n    These are the operations:\n-   alg_add       Add to the total the multiplicand times the coefficient.\n-   alg_subtract  Subtract the multiplicand times the coefficient.\n-   alg_compound  This coefficient plus or minus the following one\n-                 is multiplied into the total.  The following operation\n-                 is alg_add or alg_subtract to indicate whether to add\n-\t\t or subtract the two coefficients.  */\n+   alg_add_t_m2\t\ttotal := total + multiplicand * coeff;\n+   alg_sub_t_m2\t\ttotal := total - multiplicand * coeff;\n+   alg_add_factor\ttotal := total * coeff + total;\n+   alg_sub_factor\ttotal := total * coeff - total;\n+   alg_add_t2_m\t\ttotal := total * coeff + multiplicand;\n+   alg_sub_t2_m\t\ttotal := total * coeff - multiplicand;\n+*/\n \n #ifndef MAX_BITS_PER_WORD\n #define MAX_BITS_PER_WORD BITS_PER_WORD\n #endif\n \n struct algorithm\n {\n-  int cost;\n-  unsigned int ops;\n+  short cost;\n+  short ops;\n+/* The size of the OP and COEFF fields are not directly related to the\n+   word size, but that is the worst-case algorithm for any machine for\n+   the multiplicand 10101010101...  */\n   enum alg_code op[MAX_BITS_PER_WORD];\n-  unsigned HOST_WIDE_INT coeff[MAX_BITS_PER_WORD];\n+  char coeff[MAX_BITS_PER_WORD];\n };\n \n /* Compute and return the best algorithm for multiplying by T.\n-   Assume that add insns cost ADD_COST and shifts cost SHIFT_COST.\n-   Return cost -1 if would cost more than MAX_COST.  */\n+   The algorithm must cost less than cost_limit\n+   If retval.cost >= COST_LIMIT, no algorithm was found and all\n+   other field of the returned struct are undefined.  */\n \n static struct algorithm\n-synth_mult (t, add_cost, shift_cost, max_cost)\n+synth_mult (t, cost_limit)\n      unsigned HOST_WIDE_INT t;\n-     int add_cost, shift_cost;\n-     int max_cost;\n+     int cost_limit;\n {\n   int m, n;\n   struct algorithm *best_alg\n@@ -1760,160 +1773,146 @@ synth_mult (t, add_cost, shift_cost, max_cost)\n     = (struct algorithm *)alloca (sizeof (struct algorithm));\n   unsigned int cost;\n \n-  /* No matter what happens, we want to return a valid algorithm.  */\n-  best_alg->cost = max_cost;\n+  /* Indicate that no algorithm is yet found.  If no algorithm\n+     is found, this value will be returned and indicate failure.  */\n+  best_alg->cost = cost_limit;\n   best_alg->ops = 0;\n \n-  /* Is t an exponent of 2, so we can just do a shift?  */\n+  if (cost_limit < 0)\n+    return *best_alg;\n \n-  if ((t & -t) == t)\n+  /* Is t an exponent of 2, so we can just do a shift?  */\n+  if ((t & (t - 1)) == 0)\n     {\n       if (t > 1)\n \t{\n-\t  if (max_cost >= shift_cost)\n+\t  m = exact_log2 (t);\n+\t  if (shift_cost[m] < cost_limit)\n \t    {\n-\t      best_alg->cost = shift_cost;\n+\t      best_alg->cost = shift_cost[m];\n \t      best_alg->ops = 1;\n-\t      best_alg->op[0] = alg_add;\n-\t      best_alg->coeff[0] = t;\n+\t      best_alg->op[0] = alg_add_t_m2;\n+\t      best_alg->coeff[0] = m;\n \t    }\n-\t  else\n-\t    best_alg->cost = -1;\n-\t}\n-      else if (t == 1)\n-\t{\n-\t  if (max_cost >= 0)\n-\t    best_alg->cost = 0;\n \t}\n       else\n+\t/* t == 0 or t == 1 takes no instructions.  */\n \tbest_alg->cost = 0;\n \n       return *best_alg;\n     }\n \n-  /* If MAX_COST just permits as little as an addition (or less), we won't\n-     succeed in synthesizing an algorithm for t.  Return immediately with\n-     an indication of failure.  */\n-  if (max_cost <= add_cost)\n-    {\n-      best_alg->cost = -1;\n-      return *best_alg;\n-    }\n-\n   /* Look for factors of t of the form\n-     t = q(2**m +- 1), 2 <= m <= floor(log2(t)) - 1.\n+     t = q(2**m +- 1), 2 <= m <= floor(log2(t - 1)).\n      If we find such a factor, we can multiply by t using an algorithm that\n-     multiplies by q, shift the result by m and add/subtract it to itself.  */\n+     multiplies by q, shift the result by m and add/subtract it to itself.\n \n-  for (m = floor_log2 (t) - 1; m >= 2; m--)\n+     We search for large factors first and loop down, even if large factors\n+     are less probable than small; if we find a large factor we will find a\n+     good sequence quickly, and therefore be able to prune (by decreasing\n+     COST_LIMIT) the search.  */\n+\n+  for (m = floor_log2 (t - 1); m >= 2; m--)\n     {\n-      HOST_WIDE_INT m_exp_2 = (HOST_WIDE_INT) 1 << m;\n-      HOST_WIDE_INT d;\n+      unsigned HOST_WIDE_INT d;\n \n-      d = m_exp_2 + 1;\n-      if (t % d == 0)\n+      d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n+      if (t % d == 0 && t > d)\n \t{\n-\t  HOST_WIDE_INT q = t / d;\n+\t  unsigned HOST_WIDE_INT q = t / d;\n \n-\t  cost = add_cost + shift_cost * 2;\n+\t  if (shiftadd_cost[m] <= add_cost + shift_cost[m])\n+\t    cost = shiftadd_cost[m];\n+\t  else\n+\t    cost = add_cost + shift_cost[m];\n \n-\t  *alg_in = synth_mult (q, add_cost, shift_cost,\n-\t\t\t\tMIN (max_cost, best_alg->cost) - cost);\n+\t  *alg_in = synth_mult (q, cost_limit - cost);\n \n-\t  if (alg_in->cost >= 0)\n+\t  cost += alg_in->cost;\n+\t  if (cost < best_alg->cost)\n \t    {\n-\t      cost += alg_in->cost;\n-\n-\t      if (cost < best_alg->cost)\n-\t\t{\n-\t\t  struct algorithm *x;\n-\t\t  x = alg_in;\n-\t\t  alg_in = best_alg;\n-\t\t  best_alg = x;\n-\t\t  best_alg->coeff[best_alg->ops] = m_exp_2;\n-\t\t  best_alg->op[best_alg->ops++] = alg_compound;\n-\t\t  best_alg->coeff[best_alg->ops] = 1;\n-\t\t  best_alg->op[best_alg->ops++] = alg_add;\n-\t\t  best_alg->cost = cost;\n-\t\t}\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops++] = alg_add_factor;\n+\t      best_alg->cost = cost_limit = cost;\n \t    }\n \t}\n \n-      d = m_exp_2 - 1;\n-      if (t % d == 0)\n+      d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n+      if (t % d == 0 && t > d)\n \t{\n-\t  HOST_WIDE_INT q = t / d;\n+\t  unsigned HOST_WIDE_INT q = t / d;\n \n-\t  cost = add_cost + shift_cost * 2;\n+\t  if (shiftsub_cost[m] <= add_cost + shift_cost[m])\n+\t    cost = shiftsub_cost[m];\n+\t  else\n+\t    cost = add_cost + shift_cost[m];\n \n-\t  *alg_in = synth_mult (q, add_cost, shift_cost,\n-\t\t\t\tMIN (max_cost, best_alg->cost) - cost);\n+\t  *alg_in = synth_mult (q, cost_limit - cost);\n \n-\t  if (alg_in->cost >= 0)\n+\t  cost += alg_in->cost;\n+\t  if (cost < best_alg->cost)\n \t    {\n-\t      cost += alg_in->cost;\n-\n-\t      if (cost < best_alg->cost)\n-\t\t{\n-\t\t  struct algorithm *x;\n-\t\t  x = alg_in;\n-\t\t  alg_in = best_alg;\n-\t\t  best_alg = x;\n-\t\t  best_alg->coeff[best_alg->ops] = m_exp_2;\n-\t\t  best_alg->op[best_alg->ops++] = alg_compound;\n-\t\t  best_alg->coeff[best_alg->ops] = 1;\n-\t\t  best_alg->op[best_alg->ops++] = alg_subtract;\n-\t\t  best_alg->cost = cost;\n-\t\t}\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops++] = alg_sub_factor;\n+\t      best_alg->cost = cost_limit = cost;\n \t    }\n \t}\n     }\n \n-  /* Try load effective address instructions, i.e. do a*3, a*5, a*9.  */\n-\n-  {\n-    HOST_WIDE_INT q;\n-    HOST_WIDE_INT w;\n+  /* Try shift-and-add (load effective address) instructions,\n+     i.e. do a*3, a*5, a*9.  */\n+  if ((t & 1) != 0)\n+    {\n+      unsigned HOST_WIDE_INT q;\n \n-    q = t & -t;\t\t\t/* get out lsb */\n-    w = (t - q) & -(t - q);\t/* get out next lsb */\n+      q = t - 1;\n+      q = q & -q;\n+      m = exact_log2 (q);\n+      cost = shiftadd_cost[m];\n+      if (cost < cost_limit)\n+\t{\n+\t  *alg_in = synth_mult ((t - 1) >> m, cost_limit - cost);\n \n-    if (w / q <= lea_max_mul)\n-      {\n-\tcost = lea_cost + (q != 1 ? shift_cost : 0);\n+\t  cost += alg_in->cost;\n+\t  if (cost < best_alg->cost)\n+\t    {\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops++] = alg_add_t2_m;\n+\t      best_alg->cost = cost_limit = cost;\n+\t    }\n+\t}\n \n-\t*alg_in = synth_mult (t - q - w, add_cost, shift_cost,\n-\t\t\t      MIN (max_cost, best_alg->cost) - cost);\n+      q = t + 1;\n+      q = q & -q;\n+      m = exact_log2 (q);\n+      cost = shiftsub_cost[m];\n+      if (cost < cost_limit)\n+\t{\n+\t  *alg_in = synth_mult ((t + 1) >> m, cost_limit - cost);\n \n-\tif (alg_in->cost >= 0)\n-\t  {\n-\t    cost += alg_in->cost;\n-\n-\t    /* Use <= to prefer this method to the factoring method\n-\t       when the cost appears the same, because this method\n-\t       uses fewer temporary registers.  */\n-\t    if (cost <= best_alg->cost)\n-\t      {\n-\t\tstruct algorithm *x;\n-\t\tx = alg_in;\n-\t\talg_in = best_alg;\n-\t\tbest_alg = x;\n-\t\tbest_alg->coeff[best_alg->ops] = w;\n-\t\tbest_alg->op[best_alg->ops++] = alg_add;\n-\t\tbest_alg->coeff[best_alg->ops] = q;\n-\t\tbest_alg->op[best_alg->ops++] = alg_add;\n-\t\tbest_alg->cost = cost;\n-\t      }\n-\t  }\n-      }\n-  }\n+\t  cost += alg_in->cost;\n+\t  if (cost < best_alg->cost)\n+\t    {\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->coeff[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops++] = alg_sub_t2_m;\n+\t      best_alg->cost = cost_limit = cost;\n+\t    }\n+\t}\n+    }\n \n-  /* Now, use the good old method to add or subtract at the leftmost\n+  /* Now, use the simple method of adding or subtracting at the leftmost\n      1-bit.  */\n-\n   {\n-    HOST_WIDE_INT q;\n-    HOST_WIDE_INT w;\n+    unsigned HOST_WIDE_INT q;\n+    unsigned HOST_WIDE_INT w;\n \n     q = t & -t;\t\t\t/* get out lsb */\n     for (w = q; (w & t) != 0; w <<= 1)\n@@ -1925,63 +1924,46 @@ synth_mult (t, add_cost, shift_cost, max_cost)\n       {\n \t/* There are many bits in a row.  Make 'em by subtraction.  */\n \n+\tm = exact_log2 (q);\n \tcost = add_cost;\n \tif (q != 1)\n-\t  cost += shift_cost;\n+\t  cost += shift_cost[m];\n \n-\t*alg_in = synth_mult (t + q, add_cost, shift_cost,\n-\t\t\t      MIN (max_cost, best_alg->cost) - cost);\n+\t*alg_in = synth_mult (t + q, cost_limit - cost);\n \n-\tif (alg_in->cost >= 0)\n+\tcost += alg_in->cost;\n+\tif (cost < best_alg->cost)\n \t  {\n-\t    cost += alg_in->cost;\n-\n-\t    /* Use <= to prefer this method to the factoring method\n-\t       when the cost appears the same, because this method\n-\t       uses fewer temporary registers.  */\n-\t    if (cost <= best_alg->cost)\n-\t      {\n-\t\tstruct algorithm *x;\n-\t\tx = alg_in;\n-\t\talg_in = best_alg;\n-\t\tbest_alg = x;\n-\t\tbest_alg->coeff[best_alg->ops] = q;\n-\t\tbest_alg->op[best_alg->ops++] = alg_subtract;\n-\t\tbest_alg->cost = cost;\n-\t      }\n+\t    struct algorithm *x;\n+\t    x = alg_in, alg_in = best_alg, best_alg = x;\n+\t    best_alg->coeff[best_alg->ops] = m;\n+\t    best_alg->op[best_alg->ops++] = alg_sub_t_m2;\n+\t    best_alg->cost = cost_limit = cost;\n \t  }\n       }\n     else\n       {\n-\t/* There's only one bit at the left.  Make it by addition.  */\n+\t/* There's only one or two bit at the left.  Make it by addition.  */\n \n+\tm = exact_log2 (q);\n \tcost = add_cost;\n \tif (q != 1)\n-\t  cost += shift_cost;\n+\t  cost += shift_cost[m];\n \n-\t*alg_in = synth_mult (t - q, add_cost, shift_cost,\n-\t\t\t      MIN (max_cost, best_alg->cost) - cost);\n+\t*alg_in = synth_mult (t - q, cost_limit - cost);\n \n-\tif (alg_in->cost >= 0)\n+\tcost += alg_in->cost;\n+\tif (cost < best_alg->cost)\n \t  {\n-\t    cost += alg_in->cost;\n-\n-\t    if (cost <= best_alg->cost)\n-\t      {\n-\t\tstruct algorithm *x;\n-\t\tx = alg_in;\n-\t\talg_in = best_alg;\n-\t\tbest_alg = x;\n-\t\tbest_alg->coeff[best_alg->ops] = q;\n-\t\tbest_alg->op[best_alg->ops++] = alg_add;\n-\t\tbest_alg->cost = cost;\n-\t      }\n+\t    struct algorithm *x;\n+\t    x = alg_in, alg_in = best_alg, best_alg = x;\n+\t    best_alg->coeff[best_alg->ops] = m;\n+\t    best_alg->op[best_alg->ops++] = alg_add_t_m2;\n+\t    best_alg->cost = cost_limit = cost;\n \t  }\n       }\n   }\n \n-  if (best_alg->cost >= max_cost)\n-    best_alg->cost = -1;\n   return *best_alg;\n }\n \f\n@@ -2021,8 +2003,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n       struct algorithm alg;\n       struct algorithm neg_alg;\n       int negate = 0;\n-      HOST_WIDE_INT absval = INTVAL (op1);\n-      rtx last;\n+      HOST_WIDE_INT val = INTVAL (op1);\n \n       /* Try to do the computation two ways: multiply by the negative of OP1\n \t and then negate, or do the multiplication directly.  The latter is\n@@ -2031,21 +2012,20 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t has a factor of 2**m +/- 1, while the negated value does not or\n \t vice versa.  */\n \n-      alg = synth_mult (absval, add_cost, shift_cost, mult_cost);\n-      neg_alg = synth_mult (- absval, add_cost, shift_cost,\n+      alg = synth_mult (val, mult_cost);\n+      neg_alg = synth_mult (- val,\n \t\t\t    (alg.cost >= 0 ? alg.cost : mult_cost)\n \t\t\t    - negate_cost);\n \n-      if (neg_alg.cost >= 0 && neg_alg.cost + negate_cost < alg.cost)\n-\talg = neg_alg, negate = 1, absval = - absval;\n+      if (neg_alg.cost + negate_cost < alg.cost)\n+\talg = neg_alg, negate = 1, val = - val;\n \n-      if (alg.cost >= 0)\n+      if (alg.cost < mult_cost)\n \t{\n \t  /* If we found something, it must be cheaper than multiply.\n \t     So use it.  */\n-\t  int opno = 0;\n+\t  int opno;\n \t  rtx accum, tem;\n-\t  int factors_seen = 0;\n \n \t  op0 = protect_from_queue (op0, 0);\n \n@@ -2058,88 +2038,81 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t    accum = copy_to_mode_reg (mode, op0);\n \t  else\n \t    {\n-\t      /* 1 if this is the last in a series of adds and subtracts.  */\n-\t      int last = (1 == alg.ops || alg.op[1] == alg_compound);\n-\t      int log = floor_log2 (alg.coeff[0]);\n-\t      if (! factors_seen && ! last)\n-\t\tlog -= floor_log2 (alg.coeff[1]);\n-\n-\t      if (alg.op[0] != alg_add)\n+\t      int log = alg.coeff[0];\n+\t      enum alg_code op = alg.op[0];\n+\t      if (op == alg_add_t_m2)\n+\t\t{\n+\t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t}\n+\t      else if (op == alg_add_t2_m)\n+\t\t{\n+\t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n+\t\t\t\t\t accum);\n+\t\t}\n+\t      else if (op == alg_sub_t2_m)\n+\t\t{\n+\t\t  accum = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n+\t\t\t\t\t accum);\n+\t\t}\n+\t      else\n \t\tabort ();\n-\t      accum = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t    build_int_2 (log, 0), NULL_RTX, 0);\n \t    }\n-   \n-\t  while (++opno < alg.ops)\n+\n+\t  for (opno = 1; opno < alg.ops; opno++)\n \t    {\n-\t      int log = floor_log2 (alg.coeff[opno]);\n-\t      /* 1 if this is the last in a series of adds and subtracts.  */\n-\t      int last = (opno + 1 == alg.ops\n-\t\t\t  || alg.op[opno + 1] == alg_compound);\n-\n-\t      /* If we have not yet seen any separate factors (alg_compound)\n-\t\t then turn op0<<a1 + op0<<a2 + op0<<a3... into\n-\t\t (op0<<(a1-a2) + op0)<<(a2-a3) + op0...  */\n+\t      int log = alg.coeff[opno];\n \t      switch (alg.op[opno])\n \t\t{\n-\t\tcase alg_add:\n-\t\t  if (factors_seen)\n-\t\t    {\n-\t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n-\t\t\t\t\t     accum);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (! last)\n-\t\t\tlog -= floor_log2 (alg.coeff[opno + 1]);\n-\t\t      accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n-\t\t\t\t\t     accum);\n-\t\t      accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t\t    build_int_2 (log, 0), accum, 0);\n-\t\t    }\n+\t\tcase alg_add_t_m2:\n+\t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n+\t\t\t\t\t accum);\n \t\t  break;\n \n-\t\tcase alg_subtract:\n-\t\t  if (factors_seen)\n-\t\t    {\n-\t\t      tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t\t\t  build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n-\t\t\t\t\t     accum);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (! last)\n-\t\t\tlog -= floor_log2 (alg.coeff[opno + 1]);\n-\t\t      accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n-\t\t\t\t\t     accum);\n-\t\t      accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t\t    build_int_2 (log, 0), accum, 0);\n-\t\t    }\n+\t\tcase alg_sub_t_m2:\n+\t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n+\t\t\t\t\t accum);\n+\t\t  break;\n \n+\t\tcase alg_add_t2_m:\n+\t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n+\t\t\t\t\t accum);\n \t\t  break;\n \n-\t\tcase alg_compound:\n-\t\t  factors_seen = 1;\n+\t\tcase alg_sub_t2_m:\n+\t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n+\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n+\t\t\t\t\t accum);\n+\t\t  break;\n+\n+\t\tcase alg_add_factor:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (PLUS, mode, tem, accum),\n+\t\t\t\t\t tem);\n+\t\t  break;\n \n-\t\t  log = floor_log2 (alg.coeff[opno + 1]);\n-\t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  opno++;\n-\t\t  if (alg.op[opno] == alg_add)\n-\t\t    accum = force_operand (gen_rtx (PLUS, mode, tem, accum),\n-\t\t\t\t\t   tem);\n-\t\t  else\n-\t\t    accum = force_operand (gen_rtx (MINUS, mode, tem, accum),\n-\t\t\t\t\t   tem);\n+\t\tcase alg_sub_factor:\n+\t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n+\t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t  accum = force_operand (gen_rtx (MINUS, mode, tem, accum),\n+\t\t\t\t\t tem);\n+\t\t  break;\n \t\t}\n \t    }\n \n-\t  /* Write a REG_EQUAL note on the last insn so that we can cse \n+\t  /* Write a REG_EQUAL note on the last insn so that we can cse\n \t     multiplication sequences.  We need not do this if we were\n \t     multiplying by a power of two, since only one insn would have\n \t     been generated.\n@@ -2150,13 +2123,13 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \n \t     Torbjorn: Can you do this?  */\n \n-\t  if (exact_log2 (absval) < 0)\n+\t  if (exact_log2 (val) < 0)\n \t    {\n-\t      last = get_last_insn ();\n+\t      rtx last = get_last_insn ();\n \t      REG_NOTES (last)\n \t\t= gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t   gen_rtx (MULT, mode, op0, \n-\t\t\t\t    negate ? GEN_INT (absval) : op1),\n+\t\t\t   gen_rtx (MULT, mode, op0,\n+\t\t\t\t    negate ? GEN_INT (val) : op1),\n \t\t\t   REG_NOTES (last));\n \t    }\n \n@@ -2166,7 +2139,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n     }\n \n   /* This used to use umul_optab if unsigned,\n-     but I think that for non-widening multiply there is no difference\n+     but for non-widening multiply there is no difference\n      between signed and unsigned.  */\n   op0 = expand_binop (mode, smul_optab,\n \t\t      op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);"}]}