{"sha": "428db0baaae865326c65df831e2386a2fe7ac1d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI4ZGIwYmFhYWU4NjUzMjZjNjVkZjgzMWUyMzg2YTJmZTdhYzFkOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-03T15:59:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-03T15:59:17Z"}, "message": "tree-vect-data-refs.c (vect_analyze_data_refs): Do not collect data references here.\n\n2015-11-03  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Do not collect\n\tdata references here.\n\t* tree-vect-loop.c: Include cgraph.h.\n\t(vect_analyze_loop_2): Collect data references here.\n\t* tree-vect-slp.c (find_bb_location): Inline ...\n\t(vect_slp_bb): ... here.  Renamed from vect_slp_analyze_bb.\n\tFactor in vect_slp_transform_bb.\n\t(vect_slp_transform_bb): Removed.\n\t(vect_slp_analyze_bb_1): Collect data references here.\n\t* tree-vectorizer.c (pass_slp_vectorize::execute): Call\n\tvect_slp_bb.\n\t* tree-vectorizer.h (vect_slp_bb): Declare.\n\t(vect_slp_analyze_bb): Remove.\n\t(vect_slp_transform_bb): Remove.\n\t(find_bb_location): Remove.\n\t(vect_analyze_data_refs): Remove stmt count reference parameter.\n\nFrom-SVN: r229712", "tree": {"sha": "14fd654f2deb08fb5911c76d73a47e9da1de21bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14fd654f2deb08fb5911c76d73a47e9da1de21bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/428db0baaae865326c65df831e2386a2fe7ac1d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428db0baaae865326c65df831e2386a2fe7ac1d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428db0baaae865326c65df831e2386a2fe7ac1d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428db0baaae865326c65df831e2386a2fe7ac1d9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7372dfe4bb0ac7c2d5a5c980e0084437f14cef8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7372dfe4bb0ac7c2d5a5c980e0084437f14cef8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7372dfe4bb0ac7c2d5a5c980e0084437f14cef8b"}], "stats": {"total": 345, "additions": 150, "deletions": 195}, "files": [{"sha": "d00b074d4aa34589d70f1b0335ff00935815c363", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=428db0baaae865326c65df831e2386a2fe7ac1d9", "patch": "@@ -1,3 +1,22 @@\n+2015-11-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Do not collect\n+\tdata references here.\n+\t* tree-vect-loop.c: Include cgraph.h.\n+\t(vect_analyze_loop_2): Collect data references here.\n+\t* tree-vect-slp.c (find_bb_location): Inline ...\n+\t(vect_slp_bb): ... here.  Renamed from vect_slp_analyze_bb.\n+\tFactor in vect_slp_transform_bb.\n+\t(vect_slp_transform_bb): Removed.\n+\t(vect_slp_analyze_bb_1): Collect data references here.\n+\t* tree-vectorizer.c (pass_slp_vectorize::execute): Call\n+\tvect_slp_bb.\n+\t* tree-vectorizer.h (vect_slp_bb): Declare.\n+\t(vect_slp_analyze_bb): Remove.\n+\t(vect_slp_transform_bb): Remove.\n+\t(find_bb_location): Remove.\n+\t(vect_analyze_data_refs): Remove stmt count reference parameter.\n+\n 2015-11-03  Evgeny Stupachenko  <evstupac@gmail.com>\n \n \t* multiple_target.c (create_dispatcher_calls): Add target check"}, {"sha": "3de71fb309451ec72ce8df7b57b8ef023c03f0ac", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 100, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=428db0baaae865326c65df831e2386a2fe7ac1d9", "patch": "@@ -3245,120 +3245,24 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n */\n \n bool\n-vect_analyze_data_refs (vec_info *vinfo, int *min_vf, unsigned *n_stmts)\n+vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n {\n   struct loop *loop = NULL;\n-  basic_block bb = NULL;\n   unsigned int i;\n-  vec<data_reference_p> datarefs;\n   struct data_reference *dr;\n   tree scalar_type;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_refs ===\\n\");\n+\t\t     \"=== vect_analyze_data_refs ===\\n\");\n \n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n-    {\n-      basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-\n-      loop = LOOP_VINFO_LOOP (loop_vinfo);\n-      datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-      if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo)))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                     \"not vectorized: loop contains function calls\"\n-\t                     \" or data references that cannot be analyzed\\n\");\n-\t  return false;\n-\t}\n-\n-      for (i = 0; i < loop->num_nodes; i++)\n-\t{\n-\t  gimple_stmt_iterator gsi;\n-\n-\t  for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    {\n-\t      gimple *stmt = gsi_stmt (gsi);\n-\t      if (is_gimple_debug (stmt))\n-\t\tcontinue;\n-\t      ++*n_stmts;\n-\t      if (!find_data_references_in_stmt (loop, stmt, &datarefs))\n-\t\t{\n-\t\t  if (is_gimple_call (stmt) && loop->safelen)\n-\t\t    {\n-\t\t      tree fndecl = gimple_call_fndecl (stmt), op;\n-\t\t      if (fndecl != NULL_TREE)\n-\t\t\t{\n-\t\t\t  struct cgraph_node *node = cgraph_node::get (fndecl);\n-\t\t\t  if (node != NULL && node->simd_clones != NULL)\n-\t\t\t    {\n-\t\t\t      unsigned int j, n = gimple_call_num_args (stmt);\n-\t\t\t      for (j = 0; j < n; j++)\n-\t\t\t\t{\n-\t\t\t\t  op = gimple_call_arg (stmt, j);\n-\t\t\t\t  if (DECL_P (op)\n-\t\t\t\t      || (REFERENCE_CLASS_P (op)\n-\t\t\t\t\t  && get_base_address (op)))\n-\t\t\t\t    break;\n-\t\t\t\t}\n-\t\t\t      op = gimple_call_lhs (stmt);\n-\t\t\t      /* Ignore #pragma omp declare simd functions\n-\t\t\t\t if they don't have data references in the\n-\t\t\t\t call stmt itself.  */\n-\t\t\t      if (j == n\n-\t\t\t\t  && !(op\n-\t\t\t\t       && (DECL_P (op)\n-\t\t\t\t\t   || (REFERENCE_CLASS_P (op)\n-\t\t\t\t\t       && get_base_address (op)))))\n-\t\t\t\tcontinue;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  LOOP_VINFO_DATAREFS (loop_vinfo) = datarefs;\n-\t\t  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"not vectorized: loop contains function \"\n-\t\t\t\t     \"calls or data references that cannot \"\n-\t\t\t\t     \"be analyzed\\n\");\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\t}\n-\n-      LOOP_VINFO_DATAREFS (loop_vinfo) = datarefs;\n-    }\n-  else\n-    {\n-      bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n-      gimple_stmt_iterator gsi;\n-\n-      bb = BB_VINFO_BB (bb_vinfo);\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_debug (stmt))\n-\t    continue;\n-\t  ++*n_stmts;\n-\t  if (!find_data_references_in_stmt (NULL, stmt,\n-\t\t\t\t\t     &BB_VINFO_DATAREFS (bb_vinfo)))\n-\t    {\n-\t      /* Mark the rest of the basic-block as unvectorizable.  */\n-\t      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t{\n-\t\t  stmt = gsi_stmt (gsi);\n-\t\t  STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)) = false;\n-\t\t}\n-\t      break;\n-\t    }\n-\t}\n-\n-      datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n-    }\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   /* Go through the data-refs, check that the analysis succeeded.  Update\n      pointer from stmt_vec_info struct to DR and vectype.  */\n \n+  vec<data_reference_p> datarefs = vinfo->datarefs;\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       gimple *stmt;"}, {"sha": "43ada18ac7cfebbff06f43b68639a69873ea5c65", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=428db0baaae865326c65df831e2386a2fe7ac1d9", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"gimple-fold.h\"\n+#include \"cgraph.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -1584,13 +1585,74 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   unsigned int n_stmts = 0;\n \n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n-     and analyze their evolution in the loop.  Also adjust the minimal\n-     vectorization factor according to the loads and stores.\n+     and analyze their evolution in the loop.  */\n \n-     FORNOW: Handle only simple, array references, which\n-     alignment can be forced, and aligned pointer-references.  */\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+\n+  loop_p loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: loop contains function calls\"\n+\t\t\t \" or data references that cannot be analyzed\\n\");\n+      return false;\n+    }\n+\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n+\t !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\tif (is_gimple_debug (stmt))\n+\t  continue;\n+\t++n_stmts;\n+\tif (!find_data_references_in_stmt (loop, stmt,\n+\t\t\t\t\t   &LOOP_VINFO_DATAREFS (loop_vinfo)))\n+\t  {\n+\t    if (is_gimple_call (stmt) && loop->safelen)\n+\t      {\n+\t\ttree fndecl = gimple_call_fndecl (stmt), op;\n+\t\tif (fndecl != NULL_TREE)\n+\t\t  {\n+\t\t    cgraph_node *node = cgraph_node::get (fndecl);\n+\t\t    if (node != NULL && node->simd_clones != NULL)\n+\t\t      {\n+\t\t\tunsigned int j, n = gimple_call_num_args (stmt);\n+\t\t\tfor (j = 0; j < n; j++)\n+\t\t\t  {\n+\t\t\t    op = gimple_call_arg (stmt, j);\n+\t\t\t    if (DECL_P (op)\n+\t\t\t\t|| (REFERENCE_CLASS_P (op)\n+\t\t\t\t    && get_base_address (op)))\n+\t\t\t      break;\n+\t\t\t  }\n+\t\t\top = gimple_call_lhs (stmt);\n+\t\t\t/* Ignore #pragma omp declare simd functions\n+\t\t\t   if they don't have data references in the\n+\t\t\t   call stmt itself.  */\n+\t\t\tif (j == n\n+\t\t\t    && !(op\n+\t\t\t\t && (DECL_P (op)\n+\t\t\t\t     || (REFERENCE_CLASS_P (op)\n+\t\t\t\t\t && get_base_address (op)))))\n+\t\t\t  continue;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    if (dump_enabled_p ())\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"not vectorized: loop contains function \"\n+\t\t\t       \"calls or data references that cannot \"\n+\t\t\t       \"be analyzed\\n\");\n+\t    return false;\n+\t  }\n+      }\n+\n+  /* Analyze the data references and also adjust the minimal\n+     vectorization factor according to the loads and stores.  */\n \n-  ok = vect_analyze_data_refs (loop_vinfo, &min_vf, &n_stmts);\n+  ok = vect_analyze_data_refs (loop_vinfo, &min_vf);\n   if (!ok)\n     {\n       if (dump_enabled_p ())"}, {"sha": "35808eb9c8a5b61e79929c22e35b60bb025a5ccb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 55, "deletions": 73, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=428db0baaae865326c65df831e2386a2fe7ac1d9", "patch": "@@ -40,28 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"langhooks.h\"\n #include \"gimple-walk.h\"\n-\n-/* Extract the location of the basic block in the source code.\n-   Return the basic block location if succeed and NULL if not.  */\n-\n-source_location\n-find_bb_location (basic_block bb)\n-{\n-  gimple *stmt = NULL;\n-  gimple_stmt_iterator si;\n-\n-  if (!bb)\n-    return UNKNOWN_LOCATION;\n-\n-  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-    {\n-      stmt = gsi_stmt (si);\n-      if (gimple_location (stmt) != UNKNOWN_LOCATION)\n-        return gimple_location (stmt);\n-    }\n-\n-  return UNKNOWN_LOCATION;\n-}\n+#include \"dbgcnt.h\"\n \n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n@@ -2361,7 +2340,31 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (!bb_vinfo)\n     return NULL;\n \n-  if (!vect_analyze_data_refs (bb_vinfo, &min_vf, &n_stmts))\n+  /* Gather all data references in the basic-block.  */\n+\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      ++n_stmts;\n+      if (!find_data_references_in_stmt (NULL, stmt,\n+\t\t\t\t\t &BB_VINFO_DATAREFS (bb_vinfo)))\n+\t{\n+\t  /* Mark the rest of the basic-block as unvectorizable.  */\n+\t  for (; !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      stmt = gsi_stmt (gsi);\n+\t      STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)) = false;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  /* Analyze the data references.  */\n+\n+  if (!vect_analyze_data_refs (bb_vinfo, &min_vf))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2499,8 +2502,11 @@ vect_slp_analyze_bb_1 (basic_block bb)\n }\n \n \n-bb_vec_info\n-vect_slp_analyze_bb (basic_block bb)\n+/* Main entry for the BB vectorizer.  Analyze and transform BB, returns\n+   true if anything in the basic-block was vectorized.  */\n+\n+bool\n+vect_slp_bb (basic_block bb)\n {\n   bb_vec_info bb_vinfo;\n   int insns = 0;\n@@ -2517,6 +2523,8 @@ vect_slp_analyze_bb (basic_block bb)\n           && !gimple_nop_p (stmt)\n           && gimple_code (stmt) != GIMPLE_LABEL)\n         insns++;\n+      if (gimple_location (stmt) != UNKNOWN_LOCATION)\n+\tvect_location = gimple_location (stmt);\n     }\n \n   if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n@@ -2526,7 +2534,7 @@ vect_slp_analyze_bb (basic_block bb)\n \t\t\t \"not vectorized: too many instructions in \"\n \t\t\t \"basic block.\\n\");\n \n-      return NULL;\n+      return false;\n     }\n \n   /* Autodetect first vector size we try.  */\n@@ -2537,14 +2545,33 @@ vect_slp_analyze_bb (basic_block bb)\n     {\n       bb_vinfo = vect_slp_analyze_bb_1 (bb);\n       if (bb_vinfo)\n-        return bb_vinfo;\n+\t{\n+\t  if (!dbg_cnt (vect_slp))\n+\t    {\n+\t      destroy_bb_vec_info (bb_vinfo);\n+\t      return false;\n+\t    }\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB\\n\");\n+\n+\t  vect_schedule_slp (bb_vinfo);\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"BASIC BLOCK VECTORIZED\\n\");\n+\n+\t  destroy_bb_vec_info (bb_vinfo);\n+\n+\t  return true;\n+\t}\n \n       destroy_bb_vec_info (bb_vinfo);\n \n       vector_sizes &= ~current_vector_size;\n       if (vector_sizes == 0\n           || current_vector_size == 0)\n-        return NULL;\n+        return false;\n \n       /* Try the next biggest vector size.  */\n       current_vector_size = 1 << floor_log2 (vector_sizes);\n@@ -3533,48 +3560,3 @@ vect_schedule_slp (vec_info *vinfo)\n \n   return is_store;\n }\n-\n-\n-/* Vectorize the basic block.  */\n-\n-void\n-vect_slp_transform_bb (basic_block bb)\n-{\n-  bb_vec_info bb_vinfo = vec_info_for_bb (bb);\n-  gimple_stmt_iterator si;\n-\n-  gcc_assert (bb_vinfo);\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB\\n\");\n-\n-  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-    {\n-      gimple *stmt = gsi_stmt (si);\n-      stmt_vec_info stmt_info;\n-\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"------>SLPing statement: \");\n-          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_NOTE, \"\\n\");\n-        }\n-\n-      stmt_info = vinfo_for_stmt (stmt);\n-      gcc_assert (stmt_info);\n-\n-      /* Schedule all the SLP instances when the first SLP stmt is reached.  */\n-      if (STMT_SLP_TYPE (stmt_info))\n-        {\n-          vect_schedule_slp (bb_vinfo);\n-          break;\n-        }\n-    }\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"BASIC BLOCK VECTORIZED\\n\");\n-\n-  destroy_bb_vec_info (bb_vinfo);\n-}"}, {"sha": "7b3d9a331a91127ea0facee82219b83f94c3def3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=428db0baaae865326c65df831e2386a2fe7ac1d9", "patch": "@@ -696,18 +696,9 @@ pass_slp_vectorize::execute (function *fun)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      vect_location = find_bb_location (bb);\n-\n-      if (vect_slp_analyze_bb (bb))\n-        {\n-          if (!dbg_cnt (vect_slp))\n-            break;\n-\n-          vect_slp_transform_bb (bb);\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t     \"basic block vectorized\\n\");\n-        }\n+      if (vect_slp_bb (bb))\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t \"basic block vectorized\\n\");\n     }\n \n   free_stmt_vec_info_vec ();"}, {"sha": "f77a4eb4313feb217a25d53e3723ee3da097f395", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428db0baaae865326c65df831e2386a2fe7ac1d9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=428db0baaae865326c65df831e2386a2fe7ac1d9", "patch": "@@ -1010,7 +1010,7 @@ extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern tree vect_check_gather_scatter (gimple *, loop_vec_info, tree *, tree *,\n \t\t\t\t       int *);\n-extern bool vect_analyze_data_refs (vec_info *, int *, unsigned *);\n+extern bool vect_analyze_data_refs (vec_info *, int *);\n extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n \t\t\t\t      gimple **, bool, bool *,\n@@ -1072,10 +1072,7 @@ extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree,\n \t\t\t       vec<vec<tree> > *, int);\n-\n-extern source_location find_bb_location (basic_block);\n-extern bb_vec_info vect_slp_analyze_bb (basic_block);\n-extern void vect_slp_transform_bb (basic_block);\n+extern bool vect_slp_bb (basic_block);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}