{"sha": "8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQxN2Y0YjI4ZWI2MGE4YzNlYWU3ZDYxNzI2YTU3YzQ2OGUxOWI4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:43:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:43:52Z"}, "message": "[multiple changes]\n\n2011-10-13  Fedor Rybin  <frybin@adacore.com>\n\n\t* gnat_ugn.texi: Add gnattest section.\n\n2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb: Do not create body of renaming if declaration has\n\terrors.\n\n2011-10-13  Olivier Hainque  <hainque@adacore.com>\n\n\t* init.c (__gnat_error_handler - vxworks case): Restrict sigtramp calls\n\tfurther, to the ppc+kernel case only.\n\n2011-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Allocator): Comment reformatting.\n\t* exp_ch6.adb (Add_Unconstrained_Actuals_To_Build_In_Place_Call):\n\tDo not create a pool formal on .NET/JVM.\n\t(Expand_N_Extended_Return_Statement): Alphabetize local\n\tvariables. Do not create a renaming of the build-in-place pool\n\tparameter on .NET/JVM.\t(Make_Build_In_Place_Call_In_Allocator):\n\tAdd the user-defined pool only on non-VM targets.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Alphabetize\n\tlocal variables.  Do not add a pool actual on .NET/JVM.\n\t* sem_ch6.adb: Add with and use clause for Targparm.\n\t(Create_Extra_Formals): Add build-in-place pool formal only on\n\tnon-VM targets.\n\t* rtsfind.ads: Alphabetize entries.\n\nFrom-SVN: r179906", "tree": {"sha": "6084b399269b8db763f9195e3dae8b9830eead87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6084b399269b8db763f9195e3dae8b9830eead87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/comments", "author": null, "committer": null, "parents": [{"sha": "4674dd2104ea80247a6fda5e95ff27120ba48062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4674dd2104ea80247a6fda5e95ff27120ba48062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4674dd2104ea80247a6fda5e95ff27120ba48062"}], "stats": {"total": 675, "additions": 603, "deletions": 72}, "files": [{"sha": "8b75024450522eb012a40729a68e780c62abf7e6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -1,3 +1,33 @@\n+2011-10-13  Fedor Rybin  <frybin@adacore.com>\n+\n+\t* gnat_ugn.texi: Add gnattest section.\n+\n+2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb: Do not create body of renaming if declaration has\n+\terrors.\n+\n+2011-10-13  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* init.c (__gnat_error_handler - vxworks case): Restrict sigtramp calls\n+\tfurther, to the ppc+kernel case only.\n+\n+2011-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Allocator): Comment reformatting.\n+\t* exp_ch6.adb (Add_Unconstrained_Actuals_To_Build_In_Place_Call):\n+\tDo not create a pool formal on .NET/JVM.\n+\t(Expand_N_Extended_Return_Statement): Alphabetize local\n+\tvariables. Do not create a renaming of the build-in-place pool\n+\tparameter on .NET/JVM.\t(Make_Build_In_Place_Call_In_Allocator):\n+\tAdd the user-defined pool only on non-VM targets.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Alphabetize\n+\tlocal variables.  Do not add a pool actual on .NET/JVM.\n+\t* sem_ch6.adb: Add with and use clause for Targparm.\n+\t(Create_Extra_Formals): Add build-in-place pool formal only on\n+\tnon-VM targets.\n+\t* rtsfind.ads: Alphabetize entries.\n+\n 2011-10-13  Sergey Rybin  <rybin@adacore.com>\n \n \t* gnat_ugn.texi: Minor correction."}, {"sha": "d0536f762a081d6ee262ad436f38a21b59afd850", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -3526,8 +3526,8 @@ package body Exp_Ch4 is\n       end if;\n \n       --  Set the storage pool and find the appropriate version of Allocate to\n-      --  call. But don't overwrite the storage pool if it is already set,\n-      --  which can happen for build-in-place function returns (see\n+      --  call. Do not overwrite the storage pool if it is already set, which\n+      --  can happen for build-in-place function returns (see\n       --  Exp_Ch4.Expand_N_Extended_Return_Statement).\n \n       if No (Storage_Pool (N)) then"}, {"sha": "abcd9cd4e6c9ccdaec088c5927f5ac347a44ca28", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 74, "deletions": 53, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -311,13 +311,15 @@ package body Exp_Ch6 is\n       Add_Extra_Actual_To_Call\n         (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n \n-      --  Pass the Storage_Pool parameter\n-\n-      Pool_Formal := Build_In_Place_Formal (Function_Id, BIP_Storage_Pool);\n-      Analyze_And_Resolve (Pool_Actual, Etype (Pool_Formal));\n-      Add_Extra_Actual_To_Call\n-        (Function_Call, Pool_Formal, Pool_Actual);\n+      --  Pass the Storage_Pool parameter. This parameter is omitted on .NET\n+      --  and JVM as those targets do not support pools.\n \n+      if VM_Target = No_VM then\n+         Pool_Formal := Build_In_Place_Formal (Function_Id, BIP_Storage_Pool);\n+         Analyze_And_Resolve (Pool_Actual, Etype (Pool_Formal));\n+         Add_Extra_Actual_To_Call\n+           (Function_Call, Pool_Formal, Pool_Actual);\n+      end if;\n    end Add_Unconstrained_Actuals_To_Build_In_Place_Call;\n \n    -----------------------------------------------------------\n@@ -5132,17 +5134,17 @@ package body Exp_Ch6 is\n                     Build_In_Place_Formal (Par_Func, BIP_Alloc_Form);\n \n                   declare\n-                     Ref_Type       : Entity_Id;\n-                     Ptr_Type_Decl  : Node_Id;\n+                     Pool_Id        : constant Entity_Id :=\n+                                        Make_Temporary (Loc, 'P');\n                      Alloc_Obj_Id   : Entity_Id;\n                      Alloc_Obj_Decl : Node_Id;\n                      Alloc_If_Stmt  : Node_Id;\n-                     SS_Allocator   : Node_Id;\n                      Heap_Allocator : Node_Id;\n-\n                      Pool_Decl      : Node_Id;\n                      Pool_Allocator : Node_Id;\n-                     Pool_Id : constant Entity_Id := Make_Temporary (Loc, 'P');\n+                     Ptr_Type_Decl  : Node_Id;\n+                     Ref_Type       : Entity_Id;\n+                     SS_Allocator   : Node_Id;\n \n                   begin\n                      --  Reuse the itype created for the function's implicit\n@@ -5237,23 +5239,33 @@ package body Exp_Ch6 is\n                      end if;\n \n                      --  The Pool_Allocator is just like the Heap_Allocator,\n-                     --  except we set Storage_Pool and Procedure_To_Call so it\n-                     --  will use the user-defined storage pool.\n+                     --  except we set Storage_Pool and Procedure_To_Call so\n+                     --  it will use the user-defined storage pool.\n \n                      Pool_Allocator := New_Copy_Tree (Heap_Allocator);\n-                     Pool_Decl :=\n-                       Make_Object_Renaming_Declaration (Loc,\n-                         Defining_Identifier => Pool_Id,\n-                         Subtype_Mark        =>\n-                           New_Reference_To (RTE (RE_Root_Storage_Pool), Loc),\n-                         Name                =>\n-                           Make_Explicit_Dereference (Loc,\n-                             New_Reference_To\n-                               (Build_In_Place_Formal\n-                                  (Par_Func, BIP_Storage_Pool), Loc)));\n-                     Set_Storage_Pool (Pool_Allocator, Pool_Id);\n-                     Set_Procedure_To_Call\n-                       (Pool_Allocator, RTE (RE_Allocate_Any));\n+\n+                     --  Do not generate the renaming of the build-in-place\n+                     --  pool parameter on .NET/JVM because the parameter is\n+                     --  not created in the first place.\n+\n+                     if VM_Target = No_VM then\n+                        Pool_Decl :=\n+                          Make_Object_Renaming_Declaration (Loc,\n+                            Defining_Identifier => Pool_Id,\n+                            Subtype_Mark        =>\n+                              New_Reference_To\n+                                (RTE (RE_Root_Storage_Pool), Loc),\n+                            Name                =>\n+                              Make_Explicit_Dereference (Loc,\n+                                New_Reference_To\n+                                  (Build_In_Place_Formal\n+                                     (Par_Func, BIP_Storage_Pool), Loc)));\n+                        Set_Storage_Pool (Pool_Allocator, Pool_Id);\n+                        Set_Procedure_To_Call\n+                          (Pool_Allocator, RTE (RE_Allocate_Any));\n+                     else\n+                        Pool_Decl := Make_Null_Statement (Loc);\n+                     end if;\n \n                      --  If the No_Allocators restriction is active, then only\n                      --  an allocator for secondary stack allocation is needed.\n@@ -7686,20 +7698,14 @@ package body Exp_Ch6 is\n       --  operations. ???\n \n       else\n-         --  No user-defined pool; pass an allocation parameter indicating that\n-         --  the function should allocate its result on the heap.\n-\n-         if No (Associated_Storage_Pool (Acc_Type)) then\n-\n-            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n-              (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n-\n-         --  User-defined pool; pass an allocation parameter indicating that\n-         --  the function should allocate its result in the pool, and pass the\n-         --  pool.  We need 'Unrestricted_Access here, because 'Access is\n-         --  illegal, because the storage pool is not aliased.\n+         --  Case of a user-defined storage pool. Pass an allocation parameter\n+         --  indicating that the function should allocate its result in the\n+         --  pool, and pass the pool. Use 'Unrestricted_Access because the\n+         --  pool may not be aliased.\n \n-         else\n+         if VM_Target = No_VM\n+           and then Present (Associated_Storage_Pool (Acc_Type))\n+         then\n             Add_Unconstrained_Actuals_To_Build_In_Place_Call\n               (Func_Call, Function_Id, Alloc_Form => User_Storage_Pool,\n                Pool_Actual =>\n@@ -7708,6 +7714,13 @@ package body Exp_Ch6 is\n                      New_Reference_To\n                        (Associated_Storage_Pool (Acc_Type), Loc),\n                    Attribute_Name => Name_Unrestricted_Access));\n+\n+         --  No user-defined pool; pass an allocation parameter indicating that\n+         --  the function should allocate its result on the heap.\n+\n+         else\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n          end if;\n \n          Add_Finalization_Master_Actual_To_Build_In_Place_Call\n@@ -8059,20 +8072,20 @@ package body Exp_Ch6 is\n       Loc             : Source_Ptr;\n       Obj_Def_Id      : constant Entity_Id :=\n                           Defining_Identifier (Object_Decl);\n-\n-      Func_Call       : Node_Id := Function_Call;\n-      Function_Id     : Entity_Id;\n-      Result_Subt     : Entity_Id;\n-      Caller_Object   : Node_Id;\n-      Call_Deref      : Node_Id;\n-      Ref_Type        : Entity_Id;\n-      Ptr_Typ_Decl    : Node_Id;\n-      Def_Id          : Entity_Id;\n-      New_Expr        : Node_Id;\n       Enclosing_Func  : constant Entity_Id :=\n                           Enclosing_Subprogram (Obj_Def_Id);\n+      Call_Deref      : Node_Id;\n+      Caller_Object   : Node_Id;\n+      Def_Id          : Entity_Id;\n       Fmaster_Actual  : Node_Id := Empty;\n+      Func_Call       : Node_Id := Function_Call;\n+      Function_Id     : Entity_Id;\n+      Pool_Actual     : Node_Id;\n+      Ptr_Typ_Decl    : Node_Id;\n       Pass_Caller_Acc : Boolean := False;\n+      New_Expr        : Node_Id;\n+      Ref_Type        : Entity_Id;\n+      Result_Subt     : Entity_Id;\n \n    begin\n       --  Step past qualification or unchecked conversion (the latter can occur\n@@ -8128,17 +8141,25 @@ package body Exp_Ch6 is\n          --  has an unconstrained or tagged result type).\n \n          if Needs_BIP_Alloc_Form (Enclosing_Func) then\n+            if VM_Target = No_VM then\n+               Pool_Actual :=\n+                 New_Reference_To (Build_In_Place_Formal\n+                   (Enclosing_Func, BIP_Storage_Pool), Loc);\n+\n+            --  The build-in-place pool formal is not built on .NET/JVM\n+\n+            else\n+               Pool_Actual := Empty;\n+            end if;\n+\n             Add_Unconstrained_Actuals_To_Build_In_Place_Call\n               (Func_Call,\n                Function_Id,\n                Alloc_Form_Exp =>\n                  New_Reference_To\n                    (Build_In_Place_Formal (Enclosing_Func, BIP_Alloc_Form),\n                     Loc),\n-               Pool_Actual =>\n-                 New_Reference_To\n-                   (Build_In_Place_Formal (Enclosing_Func, BIP_Storage_Pool),\n-                    Loc));\n+               Pool_Actual => Pool_Actual);\n \n          --  Otherwise, if enclosing function has a constrained result subtype,\n          --  then caller allocation will be used."}, {"sha": "b82fb80cecaeaccce83bbdf79c007040b7dd7eff", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -1407,7 +1407,12 @@ package body Freeze is\n                Decl := Unit_Declaration_Node (E);\n \n                if Nkind (Decl) = N_Subprogram_Renaming_Declaration then\n-                  Build_And_Analyze_Renamed_Body (Decl, E, After);\n+                  if Error_Posted (Decl) then\n+                     Set_Has_Completion (E);\n+\n+                  else\n+                     Build_And_Analyze_Renamed_Body (Decl, E, After);\n+                  end if;\n \n                elsif Nkind (Decl) = N_Subprogram_Declaration\n                  and then Present (Corresponding_Body (Decl))"}, {"sha": "849a98097a216a994d722339188bba168fa0adcd", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -192,6 +192,7 @@ AdaCore@*\n * Stack Related Facilities::\n * Verifying Properties Using gnatcheck::\n * Creating Sample Bodies Using gnatstub::\n+* Creating Test Drivers Using gnattest::\n * Generating Ada Bindings for C and C++ headers::\n * Other Utility Programs::\n * Running and Debugging Ada Programs::\n@@ -468,6 +469,22 @@ Sample Bodies Using gnatstub\n * Running gnatstub::\n * Switches for gnatstub::\n \n+Creating Test Drivers Using gnattest\n+\n+* Running gnattest::\n+* Switches for gnattest::\n+* Project Attributes for gnattest::\n+* Simple Test Driver::\n+* Setting Up and Tearing Down Testing Environment::\n+* Reusing Previously Written Tests::\n+* Default Test Behavior::\n+* Testing Primitive Operations of Tagged Types::\n+* Test Inheritance::\n+* Liskov Substitution Principle Check::\n+* Testing with Contracts::\n+* Additional Tests::\n+* Current Limitations::\n+\n Other Utility Programs\n \n * Using Other Utility Programs with GNAT::\n@@ -813,6 +830,10 @@ a utility that checks Ada code against a set of rules.\n @ref{Creating Sample Bodies Using gnatstub}, discusses @code{gnatstub},\n a utility that generates empty but compilable bodies for library units.\n \n+@item\n+@ref{Creating Test Drivers Using gnattest}, discusses @code{gnattest},\n+a utility that generates unit testing templates for library units.\n+\n @item\n @ref{Generating Ada Bindings for C and C++ headers}, describes how to\n generate automatically Ada bindings from C and C++ headers.\n@@ -17644,6 +17665,457 @@ Verbose mode: generate version information.\n \n @end table\n \n+@c *********************************\n+@node Creating Test Drivers Using gnattest\n+@chapter Creating Test Drivers Using @command{gnattest}\n+@findex gnattest\n+\n+@noindent\n+@command{gnattest} is an ASIS-based utility that creates template tests\n+(test stubs) as well as test driver infrastructure (harness) for unit testing\n+of Ada source code.\n+\n+In order to process source files from the project, @command{gnattest} has to\n+semantically analyze these Ada sources. Therefore, test templates can only be\n+generated for legal Ada units. If a unit is dependent on some other units,\n+those units should be among source files of the project or of other projects\n+imported by this one.\n+\n+Generated stubs and harness are based on AUnit testing framework. AUnit\n+framework is an Ada adaptation of Java and C++ unit testing frameworks.\n+While it is advised that gnattest users read AUnit manual, deep knowledge\n+of AUnit is not necessary for using gnattest. For correct operation of\n+@command{gnattest} AUnit should be installed on default project path.\n+\n+@menu\n+* Running gnattest::\n+* Switches for gnattest::\n+* Project Attributes for gnattest::\n+* Simple Test Driver::\n+* Setting Up and Tearing Down Testing Environment::\n+* Reusing Previously Written Tests::\n+* Default Test Behavior::\n+* Testing Primitive Operations of Tagged Types::\n+* Test Inheritance::\n+* Liskov Substitution Principle Check::\n+* Testing with Contracts::\n+* Additional Tests::\n+* Current Limitations::\n+@end menu\n+\n+@node Running gnattest\n+@section Running @command{gnattest}\n+\n+@noindent\n+@command{gnattest} has the command-line interface of the form\n+\n+@smallexample\n+@c $ gnattest @var{-Pprojname} @ovar{switches} @var{filename} @ovar{directory}\n+@c Expanding @ovar macro inline (explanation in macro def comments)\n+$ gnattest @var{-Pprojname} @r{[}@var{--harness-dir=dirname}@r{]} @r{[}@var{switches}@r{]} @var{filename} @r{[}-cargs @var{gcc_switches}@r{]}\n+@end smallexample\n+\n+@noindent\n+where\n+@table @var\n+\n+@item -Pprojname\n+specifies the project that allow locating the source files. If no [filenames]\n+are provided on the command line, all project sources are used as input.\n+\n+@item --harness-dir=dirname\n+specifies directory to put harness packages and project file for the test\n+driver. The harness dir should be either specified by that switch or by\n+corresponding attribute in the argument project file.\n+\n+@item filename\n+is the name of the source file that contains a library unit package declaration\n+for which a test package must be created. The file name may contain the path\n+information.\n+\n+@item @samp{@var{gcc_switches}} is a list of switches for\n+@command{gcc}. They will be passed on to all compiler invocations made by\n+@command{gnatstub} to generate the ASIS trees. Here you can provide\n+@option{^-I^/INCLUDE_DIRS=^} switches to form the source search path,\n+use the @option{-gnatec} switch to set the configuration file,\n+use the @option{-gnat05} switch if sources should be compiled in\n+Ada 2005 mode etc.\n+\n+@item switches\n+is an optional sequence of switches as described in the next section\n+\n+@end table\n+\n+@node Switches for gnattest\n+@section Switches for @command{gnattest}\n+\n+@table @option\n+@c !sort!\n+\n+@item --harness-only\n+@cindex @option{--harness-only} (@command{gnattest})\n+When this option is given, @command{gnattest} creates a harness for all\n+sources treating them as test packages.\n+\n+@item --additional-tests=@var{projname}\n+@cindex @option{--additional-tests} (@command{gnattest})\n+Sources described in @var{projname} are considered potential additional\n+manual tests to be added to the test suite.\n+\n+@item -r\n+@cindex @option{-r} (@command{gnattest})\n+Consider recursively all sources from all projects.\n+\n+@item -q\n+@cindex @option{-q} (@command{gnattest})\n+Supresses non-critical output messages.\n+\n+@item -v\n+@cindex @option{-v} (@command{gnattest})\n+Verbose mode: generate version information.\n+\n+@item --liskov\n+@cindex @option{--liskov} (@command{gnattest})\n+Enables Liskov verification: run all tests from all parents in order\n+to check substitutability.\n+\n+@item --stub-default=@var{val}\n+@cindex @option{--stub-default} (@command{gnattest})\n+Specifies the default behavior of generated stubs. @var{val} can be either\n+\"fail\" or \"pass\", \"fail\" being the default.\n+\n+@item --separate-root=@var{dirname}\n+@cindex @option{--separate-root} (@command{gnattest})\n+Directory hierarchy of tested sources is recreated in the @var{dirname} directory,\n+test packages are placed in corresponding dirs.\n+\n+@item --subdir=@var{dirname}\n+@cindex @option{--subdir} (@command{gnattest})\n+Test packages are placed in subdirectories. That's the default output mode since\n+it does not require any additional input from the user. Subdirs called \"tests\"\n+will be created by default.\n+\n+@end table\n+\n+Separate root ans subdir output modes cannot be used at the same time.\n+\n+@node Project Attributes for gnattest\n+@section Project Attributes for @command{gnattest}\n+\n+@noindent\n+\n+Most of the command line options can be also given to the tool by adding\n+special attributes to the project file. Those attributes should be put in\n+package gnattest. Here is the list of the attributes.\n+\n+@itemize @bullet\n+\n+@item Separate_Stub_Root\n+is used to select the same output mode as with the --separate-root option.\n+This attribute cannot be used togather with Stub_Subdir.\n+\n+@item Stub_Subdir\n+is used to select the same output mode as with the --sudbir option.\n+This attribute cannot be used togather with Separate_Stub_Root.\n+\n+@item Harness_Dir\n+is used to specify the directory to place harness packages and project\n+file for the test driver, otherwise specified by --harness-dir.\n+\n+@item Additional_Tests\n+is used to specify the project file otherwise given by\n+--additional-tests switch.\n+\n+@item Stubs_Default\n+is used to specify the default behaviour of test stubs, otherwise\n+specified by --stub-default option. The value for this attribute\n+shoul be either \"pass\" or \"fail\"\n+\n+@end itemize\n+\n+All those attributes can be overridden from command line if needed.\n+Other @command{gnattest} switches can also be passed via the project\n+file as an attribute list called GNATtest_Switches.\n+\n+@node Simple Test Driver\n+@section Simple Test Driver\n+\n+@noindent\n+\n+@command{gnattest} works with package specifications. The basic functionality\n+of @command{gnattest} is creating one test stub per one subprogram declared\n+in package specification. This can be observes on a very simple example\n+located at\n+\n+@smallexample\n+examples/lib1\n+@end smallexample\n+\n+This is a simple package containing one subprogram. By running gnattest\n+\n+@smallexample\n+$ gnattest --harness-dir=driver -Plib1.gpr\n+@end smallexample\n+\n+a test driver is created. It can be compiled and run:\n+\n+@smallexample\n+$ cd driver\n+$ gprbuild -Ptest_driver\n+$ test_runner\n+@end smallexample\n+\n+One failed test with diagnosis \"test not implemented\" is reported.\n+Since no special output option was specified the test package Lib1.Tests\n+is located in\n+\n+@smallexample\n+examples/lib1/src/tests\n+@end smallexample\n+\n+For each package containing testable subprograms a child test package is\n+generated. It contains one test routine per tested subprogram. Each\n+declaration of test subprogram has a comment cpecifying to which tested\n+subprogram it corresponds. All the test routines have separated bodies.\n+The test routine locates at lib1-tests-test_inc_5eaee3.adb has a single\n+statement - procedure Assert. It has two arguments: the boolean expression\n+which we want to check and the diagnosis message to display if the condition\n+is false.\n+\n+That is where actual testing code should be written after a proper setup.\n+An actual check can be performed by replacing the stubbing code with\n+\n+@smallexample @c ada\n+Assert (Inc (1) = 2, \"wrong incrementation\");\n+@end smallexample\n+\n+After recompiling and running the test driver one successfully passed test\n+is reported.\n+\n+@node Setting Up and Tearing Down Testing Environment\n+@section Setting Up and Tearing Down Testing Environment\n+\n+@noindent\n+\n+Besides test routines themselves, each test package has an inner package\n+Env_Mgmt that has two procedures: User_Set_Up and User_Tear_Down.\n+User_Set_Up is called before each test routine of the package and\n+User_Tear_Down is called after each test routine. Those two procedures can\n+be used to perform necessary initialization and finalization,\n+memory allocation etc.\n+\n+@node Reusing Previously Written Tests\n+@section Reusing Previously Written Tests\n+\n+@noindent\n+\n+Bodies of test routines and env_mgmt packages are never overridden after they\n+were created once. As long as the name of the subprogram, full expanded Ada\n+names and order of it's parameters are the same, the old test routine will\n+fit in it's place.\n+\n+This can be demonstrated with the presious example. By uncommenting declaration\n+and body of function Dec in lib1.ads and lib1.adb, running\n+@command{gnattest} on the project and then running the test driver:\n+\n+@smallexample\n+gnattest --harness-dir=driver -Plib1.gpr\n+cd driver\n+gprbuild -Ptest_driver\n+test_runner\n+@end smallexample\n+\n+the old test is not replaced with a stub neither lost.\n+\n+@node Default Test Behavior\n+@section Default Test Behavior\n+\n+@noindent\n+\n+Generated test driver can treat all unimplemented tests in two ways:\n+either count them all as failed (this is usefull to see which tests are still\n+left to implement) or as  passed (to sort out unimplemented ones from those\n+actually failing for a reason).\n+\n+Test driver accepts a switch to specify this behavior: --stub-default=val,\n+where val is either \"pass\" or \"fail\" (exactly as for @command{gnattest}).\n+\n+The default behavior of the test driver is set with the same switch\n+passed to gnattest when generating the test driver.\n+\n+Passing it to the driver generated on the first example\n+\n+@smallexample\n+test_runer --stub-default=pass\n+@end smallexample\n+\n+makes both tests pass, even the unimplemented one.\n+\n+@node Testing Primitive Operations of Tagged Types\n+@section Testing Primitive Operations of Tagged Types\n+\n+@noindent\n+\n+Creating test stubs for primitive operations of tagged types have a number\n+of features. Test routines for all primitives of a given tagged type are\n+placed in a separate child package named after the tagged type (so if you\n+have tagged type T in package P all tests for primitives of T will be in\n+P.T_Tests).\n+\n+By running gnattest on the second example (actual tests for this example\n+are already written so no need to worry if the tool reports that 0 new stubs\n+were generated).\n+\n+@smallexample\n+cd examples/lib2\n+gnattest --harness-dir=driver -Plib2.gpr\n+@end smallexample\n+\n+Taking a closer look at the test type declared in the test package\n+Speed1.Controller_Tests is necessary. It is declared in\n+\n+@smallexample\n+examples/lib2/src/tests\n+@end smallexample\n+\n+Test types are direct or indirect descendants of\n+AUnit.Test_Fixtures.Test_Fixture type. For non-primitive tested subprograms\n+there is no need for the user to care about them. However when generating\n+test packages for primitive operations, there are some things the user\n+should know.\n+\n+Type Test_Controller has component that allows to assign it all kinds of\n+derivations of type Controller. And if you look at the specification of\n+package Speed2.Auto_Controller, you can see, that Test_Auto_Controller\n+actually derives from Test_Controller rather that AUnit type Test_Fixture.\n+Thus test types repeat the hierarchy of tested types.\n+\n+The User_Set_Up procedure of Env_Mgmt package corresponding to a test package\n+of primitive operations of type T assigns Fixture with a reference to an\n+object of that exact type T. Notice however, that if the tagged type has\n+discriminants, the User_Set_Up does has only a commented template of setting\n+up the fixture since filling th discriminant with actual value is up\n+to the user.\n+\n+The knowledge of the structure if test types allows to have additional testing\n+without additional effort. Those possibilities are described below.\n+\n+@node Test Inheritance\n+@section Test Inheritance\n+\n+@noindent\n+\n+Since test type hierarchy repeats the hierarchy of tested types, the\n+inheritance of tests take place. An example of such inheritance can be\n+shown by running the test driver generated for second example. As previously\n+mentioned, actual tests are already written for this example.\n+\n+@smallexample\n+cd examples/lib2/driver\n+gprbuild -Ptest_driver\n+test_runner\n+@end smallexample\n+\n+There are 6 passed tests while there are only 5 testable subprograms. Test\n+routine for function Speed has been inherited and ran against objects of the\n+derived type.\n+\n+@node Liskov Substitution Principle Check\n+@section Liskov Substitution Principle Check\n+\n+@noindent\n+\n+Liskov substitution principle (LSP) is a principle in object-oriented\n+programming. It states that, in a computer program if S is a subtype of T,\n+then objects of type T may be replaced with objects of type S (i.e., objects\n+of type S may be substitutes for objects of type T), without altering any of\n+the desirable properties of that program.\n+\n+In the example used for previous section there clearly have a violation of LSP.\n+The overriding function Adjust_Speed in package Speed2 removes the\n+functionality of the overridden function. Gnattest has a special option to run\n+overridden parent tests against objects of the type which have overriding\n+primitives.\n+\n+@smallexample\n+gnattest --harness-dir=driver --liskov -Plib2.gpr\n+cd driver\n+gprbuild -Ptest_driver\n+test_runner\n+@end smallexample\n+\n+While all the tests pass by themselves, the parent test for Adjust_Speed fails\n+against object of derived type.\n+\n+@node Testing with Contracts\n+@section Testing with Contracts\n+\n+@noindent\n+\n+@command{gnattest} supports pragmas Precondition, Postcondition and Test_Case.\n+Test routines are generated one per each Test_Case associated with a tested\n+subprogram. Those test routines have special wrappers for tested functions\n+that have composition of pre- and postcondition of the subprogram an\n+\"requires\" and \"ensures\" of the Test_Case (depending on the mode pre- and post\n+either count for Nominal mode or do not for Robustness mode).\n+\n+The thirg example demonstrates how it works:\n+\n+@smallexample\n+cd examples/lib3\n+gnattest --harness-dir=driver -Plib3.gpr\n+@end smallexample\n+\n+Putting actual checks within the range of the contract does not cause any\n+error reports. For example, for the test routine which corresponds to\n+test case 1\n+\n+@smallexample @c ada\n+Assert (Sqrt (9.0) = 3.0, \"wrong sqrt\");\n+@end smallexample\n+\n+and for the test routine corresponding to test case 2\n+\n+@smallexample @c ada\n+Assert (Sqrt (-5.0) = -1.0, \"wrong error indication\");\n+@end smallexample\n+\n+are acceptable:\n+\n+@smallexample\n+cd driver\n+gprbuild -Ptest_driver\n+test_runner\n+@end smallexample\n+\n+However, by by changing 9.0 to 25.0 and 3.0 to 5.0 for example you can get\n+a precondition violation for test case one. Also by putting any otherwise\n+correct but positive pair of numbers to the second test routine you can also\n+get a precondition violation. Postconditions are checked and reported\n+the same way.\n+\n+@node Additional Tests\n+@section Additional Tests\n+\n+@noindent\n+@command{gnattest} can add already existing testing code to the driver along\n+with new stubs. This solves the legacy problem: no need to rewrite all the\n+tests. The only thing required is a project file that has all the desired\n+test units (and all their dependencies) as it's source files.\n+\n+@node Current Limitations\n+@section Current Limitations\n+\n+@noindent\n+\n+The tool currently does not support following features:\n+\n+@itemize @bullet\n+@item generic tests for generic packages and package instantiations\n+@item tests for protected operations and entries\n+@item acpects Pre-, Postcondition and Test_Case\n+@end itemize\n+\n @c *********************************\n @node Generating Ada Bindings for C and C++ headers\n @chapter Generating Ada Bindings for C and C++ headers"}, {"sha": "9ac475da3c53e604b5d9c5f03dc3cfe197a7312a", "filename": "gcc/ada/init.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -2014,13 +2014,13 @@ __gnat_error_handler (int sig, void *si, struct sigcontext *sc)\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-#if defined (__PPC__)\n-  /* On PowerPC, we process signals through a Call Frame Info trampoline,\n-     voiding the need for myriads of fallback_frame_state variants in the\n-     ZCX runtime.  We have no simple way to distinguish ZCX from SJLJ here,\n-     so we do this for SJLJ as well even though this is not necessary.\n-     This only incurs a few extra instructions and a tiny amount of extra\n-     stack usage.  */\n+#if defined (__PPC__) && defined(_WRS_KERNEL)\n+  /* On PowerPC, kernel mode, we process signals through a Call Frame Info\n+     trampoline, voiding the need for myriads of fallback_frame_state\n+     variants in the ZCX runtime.  We have no simple way to distinguish ZCX\n+     from SJLJ here, so we do this for SJLJ as well even though this is not\n+     necessary.  This only incurs a few extra instructions and a tiny\n+     amount of extra stack usage.  */\n \n   #include \"sigtramp.h\"\n "}, {"sha": "b7a02066b77e8c2619fa38b931f5055570488ff5", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -1346,10 +1346,10 @@ package Rtsfind is\n      RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n \n-     RE_Root_Storage_Pool_Ptr,           -- System.Storage_Pools\n      RE_Allocate_Any,                    -- System.Storage_Pools\n      RE_Deallocate_Any,                  -- System.Storage_Pools\n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n+     RE_Root_Storage_Pool_Ptr,           -- System.Storage_Pools\n \n      RE_Allocate_Any_Controlled,         -- System.Storage_Pools.Subpools\n      RE_Deallocate_Any_Controlled,       -- System.Storage_Pools.Subpools\n@@ -2543,10 +2543,10 @@ package Rtsfind is\n      RE_Storage_Offset                   => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n \n-     RE_Root_Storage_Pool_Ptr            => System_Storage_Pools,\n      RE_Allocate_Any                     => System_Storage_Pools,\n      RE_Deallocate_Any                   => System_Storage_Pools,\n      RE_Root_Storage_Pool                => System_Storage_Pools,\n+     RE_Root_Storage_Pool_Ptr            => System_Storage_Pools,\n \n      RE_Allocate_Any_Controlled          => System_Storage_Pools_Subpools,\n      RE_Deallocate_Any_Controlled        => System_Storage_Pools_Subpools,"}, {"sha": "2e9c97f90ae19c004c68ea6ae51570892d51ded0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8417f4b28eb60a8c3eae7d61726a57c468e19b8d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8417f4b28eb60a8c3eae7d61726a57c468e19b8d", "patch": "@@ -78,6 +78,7 @@ with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Style;\n with Stylesw;  use Stylesw;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -6483,14 +6484,16 @@ package body Sem_Ch6 is\n                    (E, Standard_Natural,\n                     E, BIP_Formal_Suffix (BIP_Alloc_Form));\n \n-               --  Whenever we need BIP_Alloc_Form, we also need\n-               --  BIP_Storage_Pool, in case BIP_Alloc_Form indicates to use a\n-               --  user-defined pool.\n+               --  Add BIP_Storage_Pool, in case BIP_Alloc_Form indicates to\n+               --  use a user-defined pool. This formal is not added on .NET\n+               --  and JVM as those targets do not support pools.\n \n-               Discard :=\n-                 Add_Extra_Formal\n-                   (E, RTE (RE_Root_Storage_Pool_Ptr),\n-                    E, BIP_Formal_Suffix (BIP_Storage_Pool));\n+               if VM_Target = No_VM then\n+                  Discard :=\n+                    Add_Extra_Formal\n+                      (E, RTE (RE_Root_Storage_Pool_Ptr),\n+                       E, BIP_Formal_Suffix (BIP_Storage_Pool));\n+               end if;\n             end if;\n \n             --  In the case of functions whose result type needs finalization,"}]}