{"sha": "89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkwNjZmMTBmNWRiYjllNjE5MmNkMmFlMjllYzBmNjgxNWNlMWQ2MA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-09-07T00:15:47Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-09-07T00:15:47Z"}, "message": "RuleBasedCollator.java (clone): Rewrote.\n\n\t* java/text/RuleBasedCollator.java (clone): Rewrote.\n\t(RuleBasedCollator(RuleBasedCollator)): Removed.\n\t* java/text/MessageFormat.java: Re-merged from Classpath.\n\t* java/text/DecimalFormat.java: Re-merged from Classpath.\n\nFrom-SVN: r45458", "tree": {"sha": "3b0e9627227e608f5c734780cbf7d70418dd82bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b0e9627227e608f5c734780cbf7d70418dd82bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/comments", "author": null, "committer": null, "parents": [{"sha": "cffb260138eff6ba20037f3017b24cbe4b0fae03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffb260138eff6ba20037f3017b24cbe4b0fae03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cffb260138eff6ba20037f3017b24cbe4b0fae03"}], "stats": {"total": 941, "additions": 497, "deletions": 444}, "files": [{"sha": "d15be6ab39ccf1ac5b73bb3e082a71001e3beb4f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "patch": "@@ -1,3 +1,10 @@\n+2001-09-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/text/RuleBasedCollator.java (clone): Rewrote.\n+\t(RuleBasedCollator(RuleBasedCollator)): Removed.\n+\t* java/text/MessageFormat.java: Re-merged from Classpath.\n+\t* java/text/DecimalFormat.java: Re-merged from Classpath.\n+\n 2001-09-06  Anthony Green  <green@redhat.com>\n \n \t* include/jvm.h: Declare _Jv_RegisterResource."}, {"sha": "edf340027ed4ad3543a57f69b959d6340e94a4bc", "filename": "libjava/java/text/DecimalFormat.java", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormat.java?ref=89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "patch": "@@ -350,21 +350,9 @@ public void applyPattern (String pattern)\n \n   public Object clone ()\n   {\n-    return new DecimalFormat (this);\n-  }\n-\n-  private DecimalFormat (DecimalFormat dup)\n-  {\n-    decimalSeparatorAlwaysShown = dup.decimalSeparatorAlwaysShown;\n-    groupingSize = dup.groupingSize;\n-    minExponentDigits = dup.minExponentDigits;\n-    multiplier = dup.multiplier;\n-    negativePrefix = dup.negativePrefix;\n-    negativeSuffix = dup.negativeSuffix;\n-    positivePrefix = dup.positivePrefix;\n-    positiveSuffix = dup.positiveSuffix;\n-    symbols = (DecimalFormatSymbols) dup.symbols.clone();\n-    useExponentialNotation = dup.useExponentialNotation;\n+    DecimalFormat c = (DecimalFormat) super.clone ();\n+    c.symbols = (DecimalFormatSymbols) symbols.clone ();\n+    return c;\n   }\n \n   public DecimalFormat ()"}, {"sha": "4470f6136cc876e0fdfecd942749e1c15dbb399f", "filename": "libjava/java/text/MessageFormat.java", "status": "modified", "additions": 482, "deletions": 416, "changes": 898, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2Fjava%2Ftext%2FMessageFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2Fjava%2Ftext%2FMessageFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FMessageFormat.java?ref=89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "patch": "@@ -33,14 +33,14 @@\n \n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n+ * @author Jorge Aliss <jaliss@hotmail.com>\n  * @date March 3, 1999\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n  * Status:  Believed complete and correct to 1.2, except serialization.\n  *          and parsing.\n  */\n-\n final class MessageFormatElement\n {\n   // Argument number.\n@@ -64,70 +64,70 @@\n \n   // Recompute the locale-based formatter.\n   void setLocale (Locale loc)\n-    {\n-      if (type == null)\n-\t;\n-      else if (type.equals(\"number\"))\n-\t{\n-\t  formatClass = java.lang.Number.class;\n-\n-\t  if (style == null)\n-\t    format = NumberFormat.getInstance(loc);\n-\t  else if (style.equals(\"currency\"))\n-\t    format = NumberFormat.getCurrencyInstance(loc);\n-\t  else if (style.equals(\"percent\"))\n-\t    format = NumberFormat.getPercentInstance(loc);\n-\t  else if (style.equals(\"integer\"))\n-\t    {\n-\t      NumberFormat nf = NumberFormat.getNumberInstance(loc);\n-\t      nf.setMaximumFractionDigits(0);\n-\t      nf.setGroupingUsed(false);\n-\t      format = nf;\n-\t    }\n-\t  else\n-\t    {\n-\t      format = NumberFormat.getNumberInstance(loc);\n-\t      DecimalFormat df = (DecimalFormat) format;\n-\t      df.applyPattern(style);\n-\t    }\n-\t}\n-      else if (type.equals(\"time\") || type.equals(\"date\"))\n-\t{\n-\t  formatClass = java.util.Date.class;\n-\n-\t  int val = DateFormat.DEFAULT;\n-\t  if (style == null)\n-\t    ;\n-\t  else if (style.equals(\"short\"))\n-\t    val = DateFormat.SHORT;\n-\t  else if (style.equals(\"medium\"))\n-\t    val = DateFormat.MEDIUM;\n-\t  else if (style.equals(\"long\"))\n-\t    val = DateFormat.LONG;\n-\t  else if (style.equals(\"full\"))\n-\t    val = DateFormat.FULL;\n-\n-\t  if (type.equals(\"time\"))\n-\t    format = DateFormat.getTimeInstance(val, loc);\n-\t  else\n-\t    format = DateFormat.getDateInstance(val, loc);\n-\n-\t  if (style != null && val == DateFormat.DEFAULT)\n-\t    {\n-\t      SimpleDateFormat sdf = (SimpleDateFormat) format;\n-\t      sdf.applyPattern(style);\n-\t    }\n-\t}\n-      else if (type.equals(\"choice\"))\n-\t{\n-\t  formatClass = java.lang.Number.class;\n-\n-\t  if (style == null)\n-\t    throw new\n-\t      IllegalArgumentException (\"style required for choice format\");\n-\t  format = new ChoiceFormat (style);\n-\t}\n-    }\n+  {\n+    if (type == null)\n+      ;\n+    else if (type.equals(\"number\"))\n+      {\n+\tformatClass = java.lang.Number.class;\n+\n+\tif (style == null)\n+\t  format = NumberFormat.getInstance(loc);\n+\telse if (style.equals(\"currency\"))\n+\t  format = NumberFormat.getCurrencyInstance(loc);\n+\telse if (style.equals(\"percent\"))\n+\t  format = NumberFormat.getPercentInstance(loc);\n+\telse if (style.equals(\"integer\"))\n+\t  {\n+\t    NumberFormat nf = NumberFormat.getNumberInstance(loc);\n+\t    nf.setMaximumFractionDigits(0);\n+\t    nf.setGroupingUsed(false);\n+\t    format = nf;\n+\t  }\n+\telse\n+\t  {\n+\t    format = NumberFormat.getNumberInstance(loc);\n+\t    DecimalFormat df = (DecimalFormat) format;\n+\t    df.applyPattern(style);\n+\t  }\n+      }\n+    else if (type.equals(\"time\") || type.equals(\"date\"))\n+      {\n+\tformatClass = java.util.Date.class;\n+\n+\tint val = DateFormat.DEFAULT;\n+\tif (style == null)\n+\t  ;\n+\telse if (style.equals(\"short\"))\n+\t  val = DateFormat.SHORT;\n+\telse if (style.equals(\"medium\"))\n+\t  val = DateFormat.MEDIUM;\n+\telse if (style.equals(\"long\"))\n+\t  val = DateFormat.LONG;\n+\telse if (style.equals(\"full\"))\n+\t  val = DateFormat.FULL;\n+\n+\tif (type.equals(\"time\"))\n+\t  format = DateFormat.getTimeInstance(val, loc);\n+\telse\n+\t  format = DateFormat.getDateInstance(val, loc);\n+\n+\tif (style != null && val == DateFormat.DEFAULT)\n+\t  {\n+\t    SimpleDateFormat sdf = (SimpleDateFormat) format;\n+\t    sdf.applyPattern(style);\n+\t  }\n+      }\n+    else if (type.equals(\"choice\"))\n+      {\n+\tformatClass = java.lang.Number.class;\n+\n+\tif (style == null)\n+\t  throw new\n+\t    IllegalArgumentException (\"style required for choice format\");\n+\tformat = new ChoiceFormat (style);\n+      }\n+  }\n }\n \n public class MessageFormat extends Format\n@@ -137,403 +137,469 @@ public class MessageFormat extends Format\n   // string.  Throws IllegalArgumentException on error.\n   private static final int scanString (String pat, int index,\n \t\t\t\t       StringBuffer buffer)\n-    {\n-      int max = pat.length();\n-      buffer.setLength(0);\n-      for (; index < max; ++index)\n-\t{\n-\t  char c = pat.charAt(index);\n-\t  if (c == '\\'' && index + 2 < max && pat.charAt(index + 2) == '\\'')\n-\t    {\n-\t      buffer.append(pat.charAt(index + 1));\n-\t      index += 2;\n-\t    }\n-\t  else if (c == '\\'' && index + 1 < max\n-\t\t   && pat.charAt(index + 1) == '\\'')\n-\t    {\n-\t      buffer.append(c);\n-\t      ++index;\n-\t    }\n-\t  else if (c == '{')\n-\t    break;\n-\t  else if (c == '}')\n-\t    throw new IllegalArgumentException ();\n-\t  else\n+  {\n+    int max = pat.length();\n+    buffer.setLength(0);\n+    for (; index < max; ++index)\n+      {\n+\tchar c = pat.charAt(index);\n+\tif (c == '\\'' && index + 2 < max && pat.charAt(index + 2) == '\\'')\n+\t  {\n+\t    buffer.append(pat.charAt(index + 1));\n+\t    index += 2;\n+\t  }\n+\telse if (c == '\\'' && index + 1 < max\n+\t\t && pat.charAt(index + 1) == '\\'')\n+\t  {\n \t    buffer.append(c);\n-\t}\n-      return index;\n-    }\n+\t    ++index;\n+\t  }\n+\telse if (c == '{')\n+\t  break;\n+\telse if (c == '}')\n+\t  throw new IllegalArgumentException ();\n+\telse\n+\t  buffer.append(c);\n+      }\n+    return index;\n+  }\n \n   // This helper retrieves a single part of a format element.  Returns\n   // the index of the terminating character.\n   private static final int scanFormatElement (String pat, int index,\n \t\t\t\t\t      StringBuffer buffer,\n \t\t\t\t\t      char term)\n-    {\n-      int max = pat.length();\n-      buffer.setLength(0);\n-      int brace_depth = 1;\n-\n-      for (; index < max; ++index)\n-\t{\n-\t  char c = pat.charAt(index);\n-\t  if (c == '\\'' && index + 2 < max && pat.charAt(index + 2) == '\\'')\n-\t    {\n-\t      buffer.append(c);\n-\t      buffer.append(pat.charAt(index + 1));\n-\t      buffer.append(c);\n-\t      index += 2;\n-\t    }\n-\t  else if (c == '\\'' && index + 1 < max\n-\t\t   && pat.charAt(index + 1) == '\\'')\n-\t    {\n-\t      buffer.append(c);\n-\t      ++index;\n-\t    }\n-\t  else if (c == '{')\n-\t    {\n-\t      buffer.append(c);\n-\t      ++brace_depth;\n-\t    }\n-\t  else if (c == '}')\n-\t    {\n-\t      if (--brace_depth == 0)\n-\t\tbreak;\n-\t      buffer.append(c);\n-\t    }\n-\t  // Check for TERM after braces, because TERM might be `}'.\n-\t  else if (c == term)\n-\t    break;\n-\t  else\n+  {\n+    int max = pat.length();\n+    buffer.setLength(0);\n+    int brace_depth = 1;\n+\n+    for (; index < max; ++index)\n+      {\n+\tchar c = pat.charAt(index);\n+\tif (c == '\\'' && index + 2 < max && pat.charAt(index + 2) == '\\'')\n+\t  {\n+\t    buffer.append(c);\n+\t    buffer.append(pat.charAt(index + 1));\n+\t    buffer.append(c);\n+\t    index += 2;\n+\t  }\n+\telse if (c == '\\'' && index + 1 < max\n+\t\t && pat.charAt(index + 1) == '\\'')\n+\t  {\n \t    buffer.append(c);\n-\t}\n-      return index;\n-    }\n+\t    ++index;\n+\t  }\n+\telse if (c == '{')\n+\t  {\n+\t    buffer.append(c);\n+\t    ++brace_depth;\n+\t  }\n+\telse if (c == '}')\n+\t  {\n+\t    if (--brace_depth == 0)\n+\t      break;\n+\t    buffer.append(c);\n+\t  }\n+\t// Check for TERM after braces, because TERM might be `}'.\n+\telse if (c == term)\n+\t  break;\n+\telse\n+\t  buffer.append(c);\n+      }\n+    return index;\n+  }\n \n   // This is used to parse a format element and whatever non-format\n   // text might trail it.\n   private static final int scanFormat (String pat, int index,\n \t\t\t\t       StringBuffer buffer, Vector elts,\n \t\t\t\t       Locale locale)\n-    {\n-      MessageFormatElement mfe = new MessageFormatElement ();\n-      elts.addElement(mfe);\n-\n-      int max = pat.length();\n-\n-      // Skip the opening `{'.\n-      ++index;\n-\n-      // Fetch the argument number.\n-      index = scanFormatElement (pat, index, buffer, ',');\n-      try\n-\t{\n-\t  mfe.argNumber = Integer.parseInt(buffer.toString());\n-\t}\n-      catch (NumberFormatException nfx)\n-\t{\n-\t  throw new IllegalArgumentException ();\n-\t}\n-\n-      // Extract the element format.\n-      if (index < max && pat.charAt(index) == ',')\n-\t{\n-\t  index = scanFormatElement (pat, index + 1, buffer, ',');\n-\t  mfe.type = buffer.toString();\n-\n-\t  // Extract the style.\n-\t  if (index < max && pat.charAt(index) == ',')\n-\t    {\n-\t      index = scanFormatElement (pat, index + 1, buffer, '}');\n-\t      mfe.style = buffer.toString ();\n-\t    }\n-\t}\n-\n-      // Advance past the last terminator.\n-      if (index >= max || pat.charAt(index) != '}')\n+  {\n+    MessageFormatElement mfe = new MessageFormatElement ();\n+    elts.addElement(mfe);\n+\n+    int max = pat.length();\n+\n+    // Skip the opening `{'.\n+    ++index;\n+\n+    // Fetch the argument number.\n+    index = scanFormatElement (pat, index, buffer, ',');\n+    try\n+      {\n+\tmfe.argNumber = Integer.parseInt(buffer.toString());\n+      }\n+    catch (NumberFormatException nfx)\n+      {\n \tthrow new IllegalArgumentException ();\n-      ++index;\n-\n-      // Now fetch trailing string.\n-      index = scanString (pat, index, buffer);\n-      mfe.trailer = buffer.toString ();\n-\n-      mfe.setLocale(locale);\n-\n-      return index;\n-    }\n-\n+      }\n+\n+    // Extract the element format.\n+    if (index < max && pat.charAt(index) == ',')\n+      {\n+\tindex = scanFormatElement (pat, index + 1, buffer, ',');\n+\tmfe.type = buffer.toString();\n+\n+\t// Extract the style.\n+\tif (index < max && pat.charAt(index) == ',')\n+\t  {\n+\t    index = scanFormatElement (pat, index + 1, buffer, '}');\n+\t    mfe.style = buffer.toString ();\n+\t  }\n+      }\n+\n+    // Advance past the last terminator.\n+    if (index >= max || pat.charAt(index) != '}')\n+      throw new IllegalArgumentException ();\n+    ++index;\n+\n+    // Now fetch trailing string.\n+    index = scanString (pat, index, buffer);\n+    mfe.trailer = buffer.toString ();\n+\n+    mfe.setLocale(locale);\n+\n+    return index;\n+  }\n+\n+  /**\n+   * Applies the specified pattern to this MessageFormat.\n+   *\n+   * @param aPattern The Pattern\n+   */\n   public void applyPattern (String newPattern)\n-    {\n-      pattern = newPattern;\n+  {\n+    pattern = newPattern;\n \n-      StringBuffer tempBuffer = new StringBuffer ();\n+    StringBuffer tempBuffer = new StringBuffer ();\n \n-      int index = scanString (newPattern, 0, tempBuffer);\n-      leader = tempBuffer.toString();\n+    int index = scanString (newPattern, 0, tempBuffer);\n+    leader = tempBuffer.toString();\n \n-      Vector elts = new Vector ();\n-      while (index < newPattern.length())\n-\tindex = scanFormat (newPattern, index, tempBuffer, elts, locale);\n+    Vector elts = new Vector ();\n+    while (index < newPattern.length())\n+      index = scanFormat (newPattern, index, tempBuffer, elts, locale);\n \n-      elements = new MessageFormatElement[elts.size()];\n-      elts.copyInto(elements);\n-    }\n+    elements = new MessageFormatElement[elts.size()];\n+    elts.copyInto(elements);\n+  }\n \n+  /**\n+   * Overrides Format.clone()\n+   */\n   public Object clone ()\n-    {\n-      MessageFormat c = new MessageFormat ();\n-      c.setLocale(locale);\n-      c.applyPattern(pattern);\n-      return (Object) c;\n-    }\n-\n+  {\n+    MessageFormat c = (MessageFormat) super.clone ();\n+    c.elements = (MessageFormatElement[]) elements.clone ();\n+    return c;\n+  }\n+\n+  /**\n+   * Overrides Format.equals(Object obj)\n+   */\n   public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof MessageFormat))\n-\treturn false;\n-      MessageFormat mf = (MessageFormat) obj;\n-      return (pattern.equals(mf.pattern)\n-\t      && locale.equals(mf.locale));\n-    }\n-\n+  {\n+    if (! (obj instanceof MessageFormat))\n+      return false;\n+    MessageFormat mf = (MessageFormat) obj;\n+    return (pattern.equals(mf.pattern)\n+\t    && locale.equals(mf.locale));\n+  }\n+\n+  /**\n+   * A convinience method to format patterns.\n+   *\n+   * @param aPattern The pattern used when formatting.\n+   * @param arguments The array containing the objects to be formatted.\n+   */\n   public static String format (String pattern, Object arguments[])\n-    {\n-      MessageFormat mf = new MessageFormat (pattern);\n-      StringBuffer sb = new StringBuffer ();\n-      FieldPosition fp = new FieldPosition (NumberFormat.INTEGER_FIELD);\n-      return mf.format(arguments, sb, fp).toString();\n-    }\n-\n+  {\n+    MessageFormat mf = new MessageFormat (pattern);\n+    StringBuffer sb = new StringBuffer ();\n+    FieldPosition fp = new FieldPosition (NumberFormat.INTEGER_FIELD);\n+    return mf.format(arguments, sb, fp).toString();\n+  }\n+\n+  /**\n+   * Returns the pattern with the formatted objects.\n+   *\n+   * @param source The array containing the objects to be formatted.\n+   * @param result The StringBuffer where the text is appened.\n+   * @param fp A FieldPosition object (it is ignored).\n+   */\n   public final StringBuffer format (Object arguments[], StringBuffer appendBuf,\n \t\t\t\t    FieldPosition ignore)\n-    {\n-      appendBuf.append(leader);\n-\n-      for (int i = 0; i < elements.length; ++i)\n-\t{\n-\t  if (elements[i].argNumber >= arguments.length)\n-\t    throw new IllegalArgumentException ();\n-\t  Object thisArg = arguments[elements[i].argNumber];\n-\n-\t  Format formatter = null;\n-\t  if (elements[i].setFormat != null)\n-\t    formatter = elements[i].setFormat;\n-\t  else if (elements[i].format != null)\n-\t    {\n-\t      if (elements[i].formatClass != null\n-\t\t  && ! elements[i].formatClass.isInstance(thisArg))\n-\t\tthrow new IllegalArgumentException ();\n-\t      formatter = elements[i].format;\n-\t    }\n-\t  else if (thisArg instanceof Number)\n-\t    formatter = NumberFormat.getInstance(locale);\n-\t  else if (thisArg instanceof Date)\n-\t    formatter = DateFormat.getTimeInstance(DateFormat.DEFAULT, locale);\n-\t  else\n-\t    appendBuf.append(thisArg);\n-\n-\t  if (formatter != null)\n-\t    {\n-\t      // Special-case ChoiceFormat.\n-\t      if (formatter instanceof ChoiceFormat)\n-\t\t{\n-\t\t  StringBuffer buf = new StringBuffer ();\n-\t\t  // FIXME: don't actually know what is correct here.\n-\t\t  // Can a sub-format refer to any argument, or just\n-\t\t  // the single argument passed to it?  Must test\n-\t\t  // against JDK.\n-\t\t  formatter.format(thisArg, buf, ignore);\n-\t\t  MessageFormat mf = new MessageFormat ();\n-\t\t  mf.setLocale(locale);\n-\t\t  mf.applyPattern(buf.toString());\n-\t\t  formatter = mf;\n-\t\t}\n-\t      formatter.format(thisArg, appendBuf, ignore);\n-\t    }\n-\n-\t  appendBuf.append(elements[i].trailer);\n-\t}\n-\n-      return appendBuf;\n-    }\n+  {\n+    appendBuf.append(leader);\n \n+    for (int i = 0; i < elements.length; ++i)\n+      {\n+\tif (elements[i].argNumber >= arguments.length)\n+\t  throw new IllegalArgumentException ();\n+\tObject thisArg = arguments[elements[i].argNumber];\n+\n+\tFormat formatter = null;\n+\tif (elements[i].setFormat != null)\n+\t  formatter = elements[i].setFormat;\n+\telse if (elements[i].format != null)\n+\t  {\n+\t    if (elements[i].formatClass != null\n+\t\t&& ! elements[i].formatClass.isInstance(thisArg))\n+\t      throw new IllegalArgumentException ();\n+\t    formatter = elements[i].format;\n+\t  }\n+\telse if (thisArg instanceof Number)\n+\t  formatter = NumberFormat.getInstance(locale);\n+\telse if (thisArg instanceof Date)\n+\t  formatter = DateFormat.getTimeInstance(DateFormat.DEFAULT, locale);\n+\telse\n+\t  appendBuf.append(thisArg);\n+\n+\tif (formatter != null)\n+\t  {\n+\t    // Special-case ChoiceFormat.\n+\t    if (formatter instanceof ChoiceFormat)\n+\t      {\n+\t\tStringBuffer buf = new StringBuffer ();\n+\t\t// FIXME: don't actually know what is correct here.\n+\t\t// Can a sub-format refer to any argument, or just\n+\t\t// the single argument passed to it?  Must test\n+\t\t// against JDK.\n+\t\tformatter.format(thisArg, buf, ignore);\n+\t\tMessageFormat mf = new MessageFormat ();\n+\t\tmf.setLocale(locale);\n+\t\tmf.applyPattern(buf.toString());\n+\t\tformatter = mf;\n+\t      }\n+\t    formatter.format(thisArg, appendBuf, ignore);\n+\t  }\n+\n+\tappendBuf.append(elements[i].trailer);\n+      }\n+\n+    return appendBuf;\n+  }\n+\n+  /**\n+   * Returns the pattern with the formatted objects.\n+   *\n+   * @param source The object to be formatted.\n+   * @param result The StringBuffer where the text is appened.\n+   * @param fp A FieldPosition object (it is ignored).\n+   */\n   public final StringBuffer format (Object singleArg, StringBuffer appendBuf,\n \t\t\t\t    FieldPosition ignore)\n-    {\n-      Object[] args;\n-\n-      if (singleArg instanceof Object[])\n-\t{\n-\t  // This isn't specified in any manual, but it follows the\n-\t  // JDK implementation.\n-\t  args = (Object[]) singleArg;\n-\t}\n-      else\n-\t{\n-\t  args = new Object[1];\n-\t  args[0] = singleArg;\n-\t}\n-      return format (args, appendBuf, ignore);\n-    }\n-\n+  {\n+    Object[] args;\n+\n+    if (singleArg instanceof Object[])\n+      {\n+\t// This isn't specified in any manual, but it follows the\n+\t// JDK implementation.\n+\targs = (Object[]) singleArg;\n+      }\n+    else\n+      {\n+\targs = new Object[1];\n+\targs[0] = singleArg;\n+      }\n+    return format (args, appendBuf, ignore);\n+  }\n+\n+  /**\n+   * Returns an array with the Formats for\n+   * the arguments.\n+   */\n   public Format[] getFormats ()\n-    {\n-      Format[] f = new Format[elements.length];\n-      for (int i = elements.length - 1; i >= 0; --i)\n-\tf[i] = elements[i].setFormat;\n-      return f;\n-    }\n-\n+  {\n+    Format[] f = new Format[elements.length];\n+    for (int i = elements.length - 1; i >= 0; --i)\n+      f[i] = elements[i].setFormat;\n+    return f;\n+  }\n+\n+  /**\n+   * Returns the locale.\n+   */\n   public Locale getLocale ()\n-    {\n-      return locale;\n-    }\n+  {\n+    return locale;\n+  }\n \n+  /**\n+   * Overrides Format.hashCode()\n+   */\n   public int hashCode ()\n-    {\n-      // FIXME: not a very good hash.\n-      return pattern.hashCode() + locale.hashCode();\n-    }\n+  {\n+    // FIXME: not a very good hash.\n+    return pattern.hashCode() + locale.hashCode();\n+  }\n \n   private MessageFormat ()\n-    {\n-    }\n-\n+  {\n+  }\n+\n+  /**\n+   * Creates a new MessageFormat object with\n+   * the specified pattern\n+   *\n+   * @param aPattern The Pattern\n+   */\n   public MessageFormat (String pattern)\n-    {\n-      locale = Locale.getDefault();\n-      applyPattern (pattern);\n-    }\n+  {\n+    locale = Locale.getDefault();\n+    applyPattern (pattern);\n+  }\n \n   public Object[] parse (String sourceStr, ParsePosition pos)\n-    {\n-      // Check initial text.\n-      int index = pos.getIndex();\n-      if (! sourceStr.startsWith(leader, index))\n-\t{\n-\t  pos.setErrorIndex(index);\n-\t  return null;\n-\t}\n-      index += leader.length();\n-\n-      Vector results = new Vector (elements.length, 1);\n-      // Now check each format.\n-      for (int i = 0; i < elements.length; ++i)\n-\t{\n-\t  Format formatter = null;\n-\t  if (elements[i].setFormat != null)\n-\t    formatter = elements[i].setFormat;\n-\t  else if (elements[i].format != null)\n-\t    formatter = elements[i].format;\n-\n-\t  Object value = null;\n-\t  if (formatter instanceof ChoiceFormat)\n-\t    {\n-\t      // We must special-case a ChoiceFormat because it might\n-\t      // have recursive formatting.\n-\t      ChoiceFormat cf = (ChoiceFormat) formatter;\n-\t      String[] formats = (String[]) cf.getFormats();\n-\t      double[] limits = (double[]) cf.getLimits();\n-\t      MessageFormat subfmt = new MessageFormat ();\n-\t      subfmt.setLocale(locale);\n-\t      ParsePosition subpos = new ParsePosition (index);\n-\n-\t      int j;\n-\t      for (j = 0; value == null && j < limits.length; ++j)\n-\t\t{\n-\t\t  subfmt.applyPattern(formats[j]);\n-\t\t  subpos.setIndex(index);\n-\t\t  value = subfmt.parse(sourceStr, subpos);\n-\t\t}\n-\t      if (value != null)\n-\t\t{\n-\t\t  index = subpos.getIndex();\n-\t\t  value = new Double (limits[j]);\n-\t\t}\n-\t    }\n-\t  else if (formatter != null)\n-\t    {\n-\t      pos.setIndex(index);\n-\t      value = formatter.parseObject(sourceStr, pos);\n-\t      if (value != null)\n-\t\tindex = pos.getIndex();\n-\t    }\n-\t  else\n-\t    {\n-\t      // We have a String format.  This can lose in a number\n-\t      // of ways, but we give it a shot.\n-\t      int next_index = sourceStr.indexOf(elements[i].trailer, index);\n-\t      if (next_index == -1)\n-\t\t{\n-\t\t  pos.setErrorIndex(index);\n-\t\t  return null;\n-\t\t}\n-\t      value = sourceStr.substring(index, next_index);\n-\t      index = next_index;\n-\t    }\n-\n-\t  if (value == null\n-\t      || ! sourceStr.startsWith(elements[i].trailer, index))\n-\t    {\n-\t      pos.setErrorIndex(index);\n-\t      return null;\n-\t    }\n-\n-\t  if (elements[i].argNumber >= results.size())\n-\t    results.setSize(elements[i].argNumber + 1);\n-\t  results.setElementAt(value, elements[i].argNumber);\n-\n-\t  index += elements[i].trailer.length();\n-\t}\n-\n-      Object[] r = new Object[results.size()];\n-      results.copyInto(r);\n-      return r;\n-    }\n+  {\n+    // Check initial text.\n+    int index = pos.getIndex();\n+    if (! sourceStr.startsWith(leader, index))\n+      {\n+\tpos.setErrorIndex(index);\n+\treturn null;\n+      }\n+    index += leader.length();\n+\n+    Vector results = new Vector (elements.length, 1);\n+    // Now check each format.\n+    for (int i = 0; i < elements.length; ++i)\n+      {\n+\tFormat formatter = null;\n+\tif (elements[i].setFormat != null)\n+\t  formatter = elements[i].setFormat;\n+\telse if (elements[i].format != null)\n+\t  formatter = elements[i].format;\n+\n+\tObject value = null;\n+\tif (formatter instanceof ChoiceFormat)\n+\t  {\n+\t    // We must special-case a ChoiceFormat because it might\n+\t    // have recursive formatting.\n+\t    ChoiceFormat cf = (ChoiceFormat) formatter;\n+\t    String[] formats = (String[]) cf.getFormats();\n+\t    double[] limits = (double[]) cf.getLimits();\n+\t    MessageFormat subfmt = new MessageFormat ();\n+\t    subfmt.setLocale(locale);\n+\t    ParsePosition subpos = new ParsePosition (index);\n+\n+\t    int j;\n+\t    for (j = 0; value == null && j < limits.length; ++j)\n+\t      {\n+\t\tsubfmt.applyPattern(formats[j]);\n+\t\tsubpos.setIndex(index);\n+\t\tvalue = subfmt.parse(sourceStr, subpos);\n+\t      }\n+\t    if (value != null)\n+\t      {\n+\t\tindex = subpos.getIndex();\n+\t\tvalue = new Double (limits[j]);\n+\t      }\n+\t  }\n+\telse if (formatter != null)\n+\t  {\n+\t    pos.setIndex(index);\n+\t    value = formatter.parseObject(sourceStr, pos);\n+\t    if (value != null)\n+\t      index = pos.getIndex();\n+\t  }\n+\telse\n+\t  {\n+\t    // We have a String format.  This can lose in a number\n+\t    // of ways, but we give it a shot.\n+\t    int next_index = sourceStr.indexOf(elements[i].trailer, index);\n+\t    if (next_index == -1)\n+\t      {\n+\t\tpos.setErrorIndex(index);\n+\t\treturn null;\n+\t      }\n+\t    value = sourceStr.substring(index, next_index);\n+\t    index = next_index;\n+\t  }\n+\n+\tif (value == null\n+\t    || ! sourceStr.startsWith(elements[i].trailer, index))\n+\t  {\n+\t    pos.setErrorIndex(index);\n+\t    return null;\n+\t  }\n+\n+\tif (elements[i].argNumber >= results.size())\n+\t  results.setSize(elements[i].argNumber + 1);\n+\tresults.setElementAt(value, elements[i].argNumber);\n+\n+\tindex += elements[i].trailer.length();\n+      }\n+\n+    Object[] r = new Object[results.size()];\n+    results.copyInto(r);\n+    return r;\n+  }\n \n   public Object[] parse (String sourceStr) throws ParseException\n-    {\n-      ParsePosition pp = new ParsePosition (0);\n-      Object[] r = parse (sourceStr, pp);\n-      if (r == null)\n-\tthrow new ParseException (\"couldn't parse string\", pp.getErrorIndex());\n-      return r;\n-    }\n+  {\n+    ParsePosition pp = new ParsePosition (0);\n+    Object[] r = parse (sourceStr, pp);\n+    if (r == null)\n+      throw new ParseException (\"couldn't parse string\", pp.getErrorIndex());\n+    return r;\n+  }\n \n   public Object parseObject (String sourceStr, ParsePosition pos)\n-    {\n-      return parse (sourceStr, pos);\n-    }\n-\n+  {\n+    return parse (sourceStr, pos);\n+  }\n+\n+  /**\n+   * Sets the format for the argument at an specified\n+   * index.\n+   *\n+   * @param index The index.\n+   * @format The Format object.\n+   */\n   public void setFormat (int variableNum, Format newFormat)\n-    {\n-      elements[variableNum].setFormat = newFormat;\n-    }\n-\n+  {\n+    elements[variableNum].setFormat = newFormat;\n+  }\n+\n+  /**\n+   * Sets the formats for the arguments.\n+   *\n+   * @param formats An array of Format objects.\n+   */\n   public void setFormats (Format[] newFormats)\n-    {\n-      if (newFormats.length < elements.length)\n-\tthrow new IllegalArgumentException ();\n-      int len = Math.min(newFormats.length, elements.length);\n-      for (int i = 0; i < len; ++i)\n-\telements[i].setFormat = newFormats[i];\n-    }\n-\n+  {\n+    if (newFormats.length < elements.length)\n+      throw new IllegalArgumentException ();\n+    int len = Math.min(newFormats.length, elements.length);\n+    for (int i = 0; i < len; ++i)\n+      elements[i].setFormat = newFormats[i];\n+  }\n+\n+  /**\n+   * Sets the locale.\n+   *\n+   * @param locale A Locale\n+   */\n   public void setLocale (Locale loc)\n-    {\n-      locale = loc;\n-      if (elements != null)\n-\t{\n-\t  for (int i = 0; i < elements.length; ++i)\n-\t    elements[i].setLocale(loc);\n-\t}\n-    }\n-\n+  {\n+    locale = loc;\n+    if (elements != null)\n+      {\n+\tfor (int i = 0; i < elements.length; ++i)\n+\t  elements[i].setLocale(loc);\n+      }\n+  }\n+\n+  /**\n+   * Returns the pattern.\n+   */\n   public String toPattern ()\n-    {\n-      return pattern;\n-    }\n+  {\n+    return pattern;\n+  }\n \n   // The pattern string.\n   private String pattern;"}, {"sha": "e8662a827a6242b05f520a01b85fad778adee971", "filename": "libjava/java/text/RuleBasedCollator.java", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java?ref=89066f10f5dbb9e6192cd2ae29ec0f6815ce1d60", "patch": "@@ -1,6 +1,6 @@\n // RuleBasedCollator.java - Concrete class for locale-based string compare.\n \n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -39,7 +39,10 @@ public class RuleBasedCollator extends Collator\n {\n   public Object clone ()\n   {\n-    return new RuleBasedCollator (this);\n+    RuleBasedCollator c = (RuleBasedCollator) super.clone ();\n+    c.map = (Hashtable) map.clone ();\n+    c.prefixes = (Hashtable) map.clone ();\n+    return c;\n   }\n \n   // A helper for CollationElementIterator.next().\n@@ -352,17 +355,6 @@ public RuleBasedCollator (String rules) throws ParseException\n       }\n   }\n \n-  // This is a helper for clone.\n-  private RuleBasedCollator (RuleBasedCollator other)\n-  {\n-    frenchAccents = other.frenchAccents;\n-    rules = other.rules;\n-    decmp = other.decmp;\n-    strength = other.strength;\n-    map = other.map;\n-    prefixes = other.prefixes;\n-  }\n-\n   // True if we are using French-style accent ordering.\n   private boolean frenchAccents;\n "}]}