{"sha": "acd663ee8d130f87133566064f02b94bedcea9d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNkNjYzZWU4ZDEzMGY4NzEzMzU2NjA2NGYwMmI5NGJlZGNlYTlkNA==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-02-08T11:20:39Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-02-08T11:20:39Z"}, "message": "lex.c (java_read_char): Fixed utf8 decoding.\n\nFri Jan 29 18:19:02 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* lex.c (java_read_char): Fixed utf8 decoding.\n\t(java_unicode_2_utf8): Fixed utf8 encoding in the 0x800-0xffff\n \trange.\n\t* parse.y (valid_builtin_assignconv_identity_widening_p): Fixed\n \tcomments. Local variable `all_primitive' is gone. Broadened\n \tacceptance of `0' to floating point targets. `long' can now be\n \twidened to `double' or `float'.\n\t(valid_method_invocation_conversion_p): Added leading\n \tcomment. Fixed tabulation.\n\t(build_string_concatenation): Optimize out left or right empty\n \tstring constants.\n\nFrom-SVN: r25078", "tree": {"sha": "fe8affd6a54b3a7c6a1eeab7a46a96cb0e85bed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe8affd6a54b3a7c6a1eeab7a46a96cb0e85bed2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acd663ee8d130f87133566064f02b94bedcea9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd663ee8d130f87133566064f02b94bedcea9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd663ee8d130f87133566064f02b94bedcea9d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd663ee8d130f87133566064f02b94bedcea9d4/comments", "author": null, "committer": null, "parents": [{"sha": "5f784c1db94c3df95d307b9d0688778e0ed7679a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f784c1db94c3df95d307b9d0688778e0ed7679a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f784c1db94c3df95d307b9d0688778e0ed7679a"}], "stats": {"total": 186, "additions": 118, "deletions": 68}, "files": [{"sha": "6cd7a3d7616174e125a7bab62c8103240fbba6ea", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=acd663ee8d130f87133566064f02b94bedcea9d4", "patch": "@@ -46,6 +46,20 @@ Mon Feb  1 20:44:47 1999  Per Bothner  <bothner@cygnus.com>\n \n \t* parse.y (java_complete_lhs):  Don't complain about unreachable\n \texit condition in a do-while statement.\n+\t\n+Fri Jan 29 18:19:02 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* lex.c (java_read_char): Fixed utf8 decoding.\n+\t(java_unicode_2_utf8): Fixed utf8 encoding in the 0x800-0xffff\n+ \trange.\n+\t* parse.y (valid_builtin_assignconv_identity_widening_p): Fixed\n+ \tcomments. Local variable `all_primitive' is gone. Broadened\n+ \tacceptance of `0' to floating point targets. `long' can now be\n+ \twidened to `double' or `float'.\n+\t(valid_method_invocation_conversion_p): Added leading\n+ \tcomment. Fixed tabulation.\n+\t(build_string_concatenation): Optimize out left or right empty\n+ \tstring constants.\n \n Thu Jan 28 18:51:26 1999  Per Bothner  <bothner@cygnus.com>\n "}, {"sha": "1765a156a42ea77ed943d335f00729db97abf319", "filename": "gcc/java/lex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=acd663ee8d130f87133566064f02b94bedcea9d4", "patch": "@@ -216,19 +216,19 @@ java_read_char ()\n     return UEOF;\n   else\n     {\n-      if (c & (0xe0 == 0xc0))\n+      if ((c & 0xe0) == 0xc0)\n         {\n           c1 = GETC ();\n-\t  if (c1 & (0xc0 == 0x80))\n+\t  if ((c1 & 0xc0) == 0x80)\n \t    return (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n \t}\n-      else if (c & (0xf0 == 0xe0))\n+      else if ((c & 0xf0) == 0xe0)\n         {\n           c1 = GETC ();\n-\t  if (c1 & (0xc0 == 0x80))\n+\t  if ((c1 & 0xc0) == 0x80)\n \t    {\n \t      c2 = GETC ();\n-\t      if (c2 & (0xc0 == 0x80))\n+\t      if ((c2 & 0xc0) == 0x80)\n \t        return (unicode_t)(((c & 0xf) << 12) + \n \t\t\t\t   (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n \t    }\n@@ -1274,7 +1274,7 @@ java_unicode_2_utf8 (unicode)\n       obstack_1grow (&temporary_obstack,\n \t\t     (unsigned char)(0x80 | (unicode & 0x0fc0) >> 6));\n       obstack_1grow (&temporary_obstack,\n-\t\t     (unsigned char)(0x80 | (unicode & 0x003f) >> 12));\n+\t\t     (unsigned char)(0x80 | (unicode & 0x003f)));\n     }\n }\n "}, {"sha": "59cbf09236f35b3130452636cb68049e5a1eabae", "filename": "gcc/java/parse.c", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=acd663ee8d130f87133566064f02b94bedcea9d4", "patch": "@@ -2251,7 +2251,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/share/misc/bison.simple\"\n+#line 3 \"/usr/cygnus/gnupro-98r2/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2268,7 +2268,7 @@ static const short yycheck[] = {     3,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n@@ -2444,7 +2444,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/share/misc/bison.simple\"\n+#line 196 \"/usr/cygnus/gnupro-98r2/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4702,7 +4702,7 @@ case 492:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/share/misc/bison.simple\"\n+#line 498 \"/usr/cygnus/gnupro-98r2/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -11232,24 +11232,22 @@ static int\n valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n      tree lhs_type, rhs_type;\n {\n-  int all_primitive;\n-\n+  /* 5.1.1: This is the identity conversion part. */\n   if (lhs_type == rhs_type)\n     return 1;\n \n   /* Sometimes, instead of passing a type, we pass integer_zero_node\n-     so we know that an integral type can accomodate it */\n-  if (JINTEGRAL_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n+     so we know that a numeric type can accomodate it */\n+  if (JNUMERIC_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n     return 1;\n \n-  all_primitive = \n-    JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n-\n-  if (!all_primitive)\n+  /* Reject non primitive types */\n+  if (!JPRIMITIVE_TYPE_P (lhs_type) || !JPRIMITIVE_TYPE_P (rhs_type))\n     return 0;\n \n-  /* byte, even if it's smaller than a char can't be converted into a\n-     char. Short can't too, but the < test below takes care of that */\n+  /* 5.1.2: widening primitive conversion. byte, even if it's smaller\n+     than a char can't be converted into a char. Short can't too, but\n+     the < test below takes care of that */\n   if (lhs_type == char_type_node && rhs_type == byte_type_node)\n     return 0;\n \n@@ -11263,13 +11261,13 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n \t  || rhs_type == promoted_boolean_type_node))\n     return 1;\n \n-  if (JINTEGRAL_TYPE_P (rhs_type)\n-      && ((TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type))\n-\t  || (JFLOAT_TYPE_P (lhs_type) &&\n-\t      TYPE_PRECISION (rhs_type) == TYPE_PRECISION (lhs_type))))\n-    return 1;\n-  else if (JFLOAT_TYPE_P (rhs_type)\n-\t   && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))\n+  /* From here, an integral is widened if its precision is smaller\n+     than the precision of the LHS or if the LHS is a floating point\n+     type, or the RHS is a float and the RHS a double. */\n+  if ((JINTEGRAL_TYPE_P (rhs_type) && JINTEGRAL_TYPE_P (lhs_type) \n+       && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))\n+      || (JINTEGRAL_TYPE_P (rhs_type) && JFLOAT_TYPE_P (lhs_type))\n+      || (rhs_type == float_type_node && lhs_type == double_type_node))\n     return 1;\n \n   return 0;\n@@ -11418,16 +11416,18 @@ do_unary_numeric_promotion (arg)\n   return arg;\n }\n \n+/* Return a non zero value if SOURCE can be converted into DEST using\n+   the method invocation conversion rule (5.3).  */\n static int\n valid_method_invocation_conversion_p (dest, source)\n      tree dest, source;\n {\n   return (((JPRIMITIVE_TYPE_P (source) || (source == integer_zero_node))\n-\t    && JPRIMITIVE_TYPE_P (dest)\n-\t    && valid_builtin_assignconv_identity_widening_p (dest, source))\n-\t   || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n-\t       && (JREFERENCE_TYPE_P (dest) || JNULLP_TYPE_P (dest))\n-\t       && valid_ref_assignconv_cast_p (source, dest, 0)));\n+\t   && JPRIMITIVE_TYPE_P (dest)\n+\t   && valid_builtin_assignconv_identity_widening_p (dest, source))\n+\t  || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n+\t      && (JREFERENCE_TYPE_P (dest) || JNULLP_TYPE_P (dest))\n+\t      && valid_ref_assignconv_cast_p (source, dest, 0)));\n }\n \n /* Build an incomplete binop expression. */\n@@ -11937,20 +11937,33 @@ build_string_concatenation (op1, op2)\n   if ((result = string_constant_concatenation (op1, op2)))\n     return result;\n \n-  /* If operands are string constant, turn then into object references */\n+  /* Discard null constants on either sides of the expression */\n+  if (TREE_CODE (op1) == STRING_CST && !TREE_STRING_LENGTH (op1))\n+    {\n+      op1 = op2;\n+      op2 = NULL_TREE;\n+    }\n+  else if (TREE_CODE (op2) == STRING_CST && !TREE_STRING_LENGTH (op2))\n+    op2 = NULL_TREE;\n \n+  /* If operands are string constant, turn then into object references */\n   if (TREE_CODE (op1) == STRING_CST)\n     op1 = patch_string_cst (op1);\n-  if (TREE_CODE (op2) == STRING_CST)\n+  if (op2 && TREE_CODE (op2) == STRING_CST)\n     op2 = patch_string_cst (op2);\n \n+  /* If either one of the constant is null and the other non null\n+     operand is a String object, return it. */\n+  if (JSTRING_TYPE_P (TREE_TYPE (op1)) && !op2)\n+    return op1;\n+\n   /* If OP1 isn't already a StringBuffer, create and\n      initialize a new one */\n   if (!IS_CRAFTED_STRING_BUFFER_P (op1))\n     {\n       /* Two solutions here: \n \t 1) OP1 is a string reference, we call new StringBuffer(OP1)\n-\t 2) Op2 is something else, we call new StringBuffer().append(OP1). */\n+\t 2) OP1 is something else, we call new StringBuffer().append(OP1). */\n       if (JSTRING_TYPE_P (TREE_TYPE (op1)))\n \top1 = BUILD_STRING_BUFFER (op1);\n       else\n@@ -11960,10 +11973,15 @@ build_string_concatenation (op1, op2)\n \t}\n     }\n \n-  /* No longer the last node holding a crafted StringBuffer */\n-  IS_CRAFTED_STRING_BUFFER_P (op1) = 0;\n-  /* Create a node for `{new...,xxx}.append (op2)' */\n-  op1 = make_qualified_primary (op1, BUILD_APPEND (op2), 0);\n+  if (op2)\n+    {\n+      /* OP1 is no longer the last node holding a crafted StringBuffer */\n+      IS_CRAFTED_STRING_BUFFER_P (op1) = 0;\n+      /* Create a node for `{new...,xxx}.append (op2)' */\n+      if (op2)\n+\top1 = make_qualified_primary (op1, BUILD_APPEND (op2), 0);\n+    }\n+\n   /* Mark the last node holding a crafted StringBuffer */\n   IS_CRAFTED_STRING_BUFFER_P (op1) = 1;\n   "}, {"sha": "0dbdc2a80e6ba2e662c26149be3fb894f9722a74", "filename": "gcc/java/parse.y", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd663ee8d130f87133566064f02b94bedcea9d4/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=acd663ee8d130f87133566064f02b94bedcea9d4", "patch": "@@ -8594,24 +8594,22 @@ static int\n valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n      tree lhs_type, rhs_type;\n {\n-  int all_primitive;\n-\n+  /* 5.1.1: This is the identity conversion part. */\n   if (lhs_type == rhs_type)\n     return 1;\n \n   /* Sometimes, instead of passing a type, we pass integer_zero_node\n-     so we know that an integral type can accomodate it */\n-  if (JINTEGRAL_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n+     so we know that a numeric type can accomodate it */\n+  if (JNUMERIC_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n     return 1;\n \n-  all_primitive = \n-    JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n-\n-  if (!all_primitive)\n+  /* Reject non primitive types */\n+  if (!JPRIMITIVE_TYPE_P (lhs_type) || !JPRIMITIVE_TYPE_P (rhs_type))\n     return 0;\n \n-  /* byte, even if it's smaller than a char can't be converted into a\n-     char. Short can't too, but the < test below takes care of that */\n+  /* 5.1.2: widening primitive conversion. byte, even if it's smaller\n+     than a char can't be converted into a char. Short can't too, but\n+     the < test below takes care of that */\n   if (lhs_type == char_type_node && rhs_type == byte_type_node)\n     return 0;\n \n@@ -8625,13 +8623,13 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n \t  || rhs_type == promoted_boolean_type_node))\n     return 1;\n \n-  if (JINTEGRAL_TYPE_P (rhs_type)\n-      && ((TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type))\n-\t  || (JFLOAT_TYPE_P (lhs_type) &&\n-\t      TYPE_PRECISION (rhs_type) == TYPE_PRECISION (lhs_type))))\n-    return 1;\n-  else if (JFLOAT_TYPE_P (rhs_type)\n-\t   && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))\n+  /* From here, an integral is widened if its precision is smaller\n+     than the precision of the LHS or if the LHS is a floating point\n+     type, or the RHS is a float and the RHS a double. */\n+  if ((JINTEGRAL_TYPE_P (rhs_type) && JINTEGRAL_TYPE_P (lhs_type) \n+       && (TYPE_PRECISION (rhs_type) < TYPE_PRECISION (lhs_type)))\n+      || (JINTEGRAL_TYPE_P (rhs_type) && JFLOAT_TYPE_P (lhs_type))\n+      || (rhs_type == float_type_node && lhs_type == double_type_node))\n     return 1;\n \n   return 0;\n@@ -8780,16 +8778,18 @@ do_unary_numeric_promotion (arg)\n   return arg;\n }\n \n+/* Return a non zero value if SOURCE can be converted into DEST using\n+   the method invocation conversion rule (5.3).  */\n static int\n valid_method_invocation_conversion_p (dest, source)\n      tree dest, source;\n {\n   return (((JPRIMITIVE_TYPE_P (source) || (source == integer_zero_node))\n-\t    && JPRIMITIVE_TYPE_P (dest)\n-\t    && valid_builtin_assignconv_identity_widening_p (dest, source))\n-\t   || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n-\t       && (JREFERENCE_TYPE_P (dest) || JNULLP_TYPE_P (dest))\n-\t       && valid_ref_assignconv_cast_p (source, dest, 0)));\n+\t   && JPRIMITIVE_TYPE_P (dest)\n+\t   && valid_builtin_assignconv_identity_widening_p (dest, source))\n+\t  || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n+\t      && (JREFERENCE_TYPE_P (dest) || JNULLP_TYPE_P (dest))\n+\t      && valid_ref_assignconv_cast_p (source, dest, 0)));\n }\n \n /* Build an incomplete binop expression. */\n@@ -9299,20 +9299,33 @@ build_string_concatenation (op1, op2)\n   if ((result = string_constant_concatenation (op1, op2)))\n     return result;\n \n-  /* If operands are string constant, turn then into object references */\n+  /* Discard null constants on either sides of the expression */\n+  if (TREE_CODE (op1) == STRING_CST && !TREE_STRING_LENGTH (op1))\n+    {\n+      op1 = op2;\n+      op2 = NULL_TREE;\n+    }\n+  else if (TREE_CODE (op2) == STRING_CST && !TREE_STRING_LENGTH (op2))\n+    op2 = NULL_TREE;\n \n+  /* If operands are string constant, turn then into object references */\n   if (TREE_CODE (op1) == STRING_CST)\n     op1 = patch_string_cst (op1);\n-  if (TREE_CODE (op2) == STRING_CST)\n+  if (op2 && TREE_CODE (op2) == STRING_CST)\n     op2 = patch_string_cst (op2);\n \n+  /* If either one of the constant is null and the other non null\n+     operand is a String object, return it. */\n+  if (JSTRING_TYPE_P (TREE_TYPE (op1)) && !op2)\n+    return op1;\n+\n   /* If OP1 isn't already a StringBuffer, create and\n      initialize a new one */\n   if (!IS_CRAFTED_STRING_BUFFER_P (op1))\n     {\n       /* Two solutions here: \n \t 1) OP1 is a string reference, we call new StringBuffer(OP1)\n-\t 2) Op2 is something else, we call new StringBuffer().append(OP1). */\n+\t 2) OP1 is something else, we call new StringBuffer().append(OP1). */\n       if (JSTRING_TYPE_P (TREE_TYPE (op1)))\n \top1 = BUILD_STRING_BUFFER (op1);\n       else\n@@ -9322,10 +9335,15 @@ build_string_concatenation (op1, op2)\n \t}\n     }\n \n-  /* No longer the last node holding a crafted StringBuffer */\n-  IS_CRAFTED_STRING_BUFFER_P (op1) = 0;\n-  /* Create a node for `{new...,xxx}.append (op2)' */\n-  op1 = make_qualified_primary (op1, BUILD_APPEND (op2), 0);\n+  if (op2)\n+    {\n+      /* OP1 is no longer the last node holding a crafted StringBuffer */\n+      IS_CRAFTED_STRING_BUFFER_P (op1) = 0;\n+      /* Create a node for `{new...,xxx}.append (op2)' */\n+      if (op2)\n+\top1 = make_qualified_primary (op1, BUILD_APPEND (op2), 0);\n+    }\n+\n   /* Mark the last node holding a crafted StringBuffer */\n   IS_CRAFTED_STRING_BUFFER_P (op1) = 1;\n   "}]}