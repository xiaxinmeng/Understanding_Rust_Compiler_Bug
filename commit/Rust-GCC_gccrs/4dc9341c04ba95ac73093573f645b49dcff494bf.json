{"sha": "4dc9341c04ba95ac73093573f645b49dcff494bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRjOTM0MWMwNGJhOTVhYzczMDkzNTczZjY0NWI0OWRjZmY0OTRiZg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-11-30T10:42:29Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-11-30T10:42:29Z"}, "message": "flow.c (flow_nodes_print, [...]): New functions.\n\n\t* flow.c (flow_nodes_print, flow_loops_cfg_dump): New functions.\n\t(flow_loop_nested_p, flow_loops_dump, flow_loops_free): Likewise.\n\t(flow_loop_exits_find, flow_loop_nodes_find): Likewise.\n\t(flow_depth_first_order_compute, flow_loop_pre_header_find): Likewise.\n\t(flow_loop_tree_node_add, flow_loops_tree_build): Likewise.\n\t(flow_loop_level_compute, low_loops_level_compute): Likewise.\n\t(flow_loops_find, flow_loop_outside_edge_p): Likewise.\n\t* basic-block.h: Protect from multiple inclusion.\n\t(flow_loops_find, flow_loops_free, flow_loop_dump): Add protoypes.\n\t(struct loops, struct loop): Define structures.\n\t* sbitmap.c (sbitmap_a_subset_b_p): New function.\n\t* sbitmap.h: Protect from multiple inclusion.\n\t(sbitmap_a_subset_b_p): Add prototype.\n\t* Makefile.in (LOOP_H): New macro.\n\t(stmt.o, integrate.o, loop.o, unroll.o): Replace loop.h with LOOP_H.\n\nFrom-SVN: r30720", "tree": {"sha": "0419ba31de201d068da7e9c24838800282059223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0419ba31de201d068da7e9c24838800282059223"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dc9341c04ba95ac73093573f645b49dcff494bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dc9341c04ba95ac73093573f645b49dcff494bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dc9341c04ba95ac73093573f645b49dcff494bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dc9341c04ba95ac73093573f645b49dcff494bf/comments", "author": null, "committer": null, "parents": [{"sha": "edecd81faa008b1d15af7c5ef1c1f9eeb9854635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edecd81faa008b1d15af7c5ef1c1f9eeb9854635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edecd81faa008b1d15af7c5ef1c1f9eeb9854635"}], "stats": {"total": 822, "additions": 818, "deletions": 4}, "files": [{"sha": "facaadc5698193dfa989d44f1699073b264e2112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4dc9341c04ba95ac73093573f645b49dcff494bf", "patch": "@@ -1,3 +1,21 @@\n+1999-11-30  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* flow.c (flow_nodes_print, flow_loops_cfg_dump): New functions.\n+\t(flow_loop_nested_p, flow_loops_dump, flow_loops_free): Likewise.\n+\t(flow_loop_exits_find, flow_loop_nodes_find): Likewise.\n+\t(flow_depth_first_order_compute, flow_loop_pre_header_find): Likewise.\n+\t(flow_loop_tree_node_add, flow_loops_tree_build): Likewise.\n+\t(flow_loop_level_compute, low_loops_level_compute): Likewise.\n+\t(flow_loops_find, flow_loop_outside_edge_p): Likewise.\n+\t* basic-block.h: Protect from multiple inclusion.\n+\t(flow_loops_find, flow_loops_free, flow_loop_dump): Add protoypes.\n+\t(struct loops, struct loop): Define structures.\n+\t* sbitmap.c (sbitmap_a_subset_b_p): New function.\n+\t* sbitmap.h: Protect from multiple inclusion.\n+\t(sbitmap_a_subset_b_p): Add prototype.\n+\t* Makefile.in (LOOP_H): New macro.\n+\t(stmt.o, integrate.o, loop.o, unroll.o): Replace loop.h with LOOP_H.\n+\n Tue Nov 30 01:34:47 1999  Philippe De Muyter  <phdm@macqel.be>\n \n \t* cppinit.c (CAT): The argument list of this macro may not contain"}, {"sha": "61144c4f14ccc051a1e98967b949103da230bf99", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4dc9341c04ba95ac73093573f645b49dcff494bf", "patch": "@@ -748,6 +748,7 @@ DEMANGLE_H = $(srcdir)/../include/demangle.h\n RECOG_H = recog.h\n EXPR_H = expr.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H)\n+LOOP_H = loop.h varray.h\n #\f\n # Language makefile fragments.\n \n@@ -1484,7 +1485,7 @@ function.o : function.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h ggc.h\n stmt.o : stmt.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) except.h \\\n-   loop.h $(RECOG_H) toplev.h output.h varray.h ggc.h\n+   $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h ggc.h\n except.o : except.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-flags.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h except.h toplev.h intl.h ggc.h\n@@ -1527,7 +1528,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    integrate.h insn-flags.h insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n-   intl.h function.h output.h $(RECOG_H) except.h toplev.h loop.h\n+   intl.h function.h output.h $(RECOG_H) except.h toplev.h $(LOOP_H)\n jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h insn-attr.h\n@@ -1550,11 +1551,11 @@ lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h function.h insn-config.h \\\n    ggc.h\n-loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\\n+loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h $(LOOP_H) insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n    $(BASIC_BLOCK_H) function.h toplev.h varray.h except.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n-   integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) loop.h toplev.h varray.h\n+   integrate.h $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h varray.h\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    insn-flags.h function.h except.h"}, {"sha": "ef7276e0b873023bf7c58b2f362a63541c24db51", "filename": "gcc/basic-block.h", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4dc9341c04ba95ac73093573f645b49dcff494bf", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef _BASIC_BLOCK_H\n+#define _BASIC_BLOCK_H 1\n \n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n@@ -222,6 +224,92 @@ extern void remove_fake_edges\t\tPROTO ((void));\n extern void add_noreturn_fake_exit_edges\tPROTO ((void));\n extern void flow_delete_insn_chain\tPROTO((rtx, rtx));\n \n+\n+/* Structure to hold information for each natural loop.  */\n+struct loop\n+{\n+  int num;\n+\n+  /* Basic block of loop header.  */\n+  basic_block header;\n+\n+  /* Basic block of loop latch.  */\n+  basic_block latch;\n+\n+  /* Basic block of loop pre-header or NULL if it does not exist.  */\n+  basic_block pre_header;\n+\n+  /* Bitmap of blocks contained within the loop.  */\n+  sbitmap nodes;\n+\n+  /* Number of blocks contained within the loop.  */\n+  int num_nodes;\n+\n+  /* Array of edges that exit the loop.  */\n+  edge *exits;\n+\n+  /* Number of edges that exit the loop.  */\n+  int num_exits;\n+\n+  /* The loop nesting depth.  */\n+  int depth;\n+\n+  /* The height of the loop (enclosed loop levels) within the loop\n+     hierarchy tree.  */\n+  int level;\n+\n+  /* The outer (parent) loop or NULL if outermost loop.  */\n+  struct loop *outer;\n+\n+  /* The first inner (child) loop or NULL if innermost loop.  */\n+  struct loop *inner;\n+\n+  /* Link to the next (sibling) loop.  */\n+  struct loop *next;\n+\n+  /* Non-zero if the loop shares a header with another loop.  */\n+  int shared;\n+\n+  /* Non-zero if the loop is invalid (e.g., contains setjmp.).  */\n+  int invalid;\n+\n+  /* Auxiliary info specific to a pass.  */\n+  void *info;\n+};\n+\n+\n+/* Structure to hold CFG information about natural loops within a function.  */\n+struct loops\n+{\n+  /* Number of natural loops in the function.  */\n+  int num;\n+\n+  /* Array of natural loop descriptors (scanning this array in reverse order\n+     will find the inner loops before their enclosing outer loops).  */\n+  struct loop *array;\n+\n+  /* Pointer to root of loop heirachy tree.  */\n+  struct loop *tree;\n+\n+  /* Information derived from the CFG.  */\n+  struct cfg\n+  {\n+    /* The bitmap vector of dominators or NULL if not computed.  */\n+    sbitmap *dom;\n+\n+    /* The ordering of the basic blocks in a depth first search.  */\n+    int *dfs_order;\n+  } cfg;\n+\n+  /* Headers shared by multiple loops that should be merged.  */\n+  sbitmap shared_headers;\n+};\n+\n+extern int flow_loops_find PROTO ((struct loops *));\n+extern void flow_loops_free PROTO ((struct loops *));\n+extern void flow_loops_dump PROTO ((const struct loops *, FILE *, int));\n+\n+\n /* This structure maintains an edge list vector.  */\n struct edge_list \n {\n@@ -295,3 +383,5 @@ extern void compute_available\t\tPROTO ((sbitmap *, sbitmap *,\n /* In emit-rtl.c.  */\n extern rtx emit_block_insn_after\tPROTO((rtx, rtx, basic_block));\n extern rtx emit_block_insn_before\tPROTO((rtx, rtx, basic_block));\n+\n+#endif /* _BASIC_BLOCK_H */"}, {"sha": "f147b7e4e5140d50a10970995319d50391b82720", "filename": "gcc/flow.c", "status": "modified", "additions": 681, "deletions": 0, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4dc9341c04ba95ac73093573f645b49dcff494bf", "patch": "@@ -6332,3 +6332,684 @@ add_noreturn_fake_exit_edges ()\n     if (BASIC_BLOCK (x)->succ == NULL)\n       make_edge (NULL, BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n+\f\n+/* Dump the list of basic blocks in the bitmap NODES.  */\n+static void \n+flow_nodes_print (str, nodes, file)\n+     const char *str;\n+     const sbitmap nodes;\n+     FILE *file;\n+{\n+  int node;\n+\n+  fprintf (file, \"%s { \", str);\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {fprintf (file, \"%d \", node);});\n+  fputs (\"}\\n\", file);\n+}\n+\n+\n+/* Dump the list of exiting edges in the array EDGES.  */\n+static void \n+flow_exits_print (str, edges, num_edges, file)\n+     const char *str;\n+     const edge *edges;\n+     int num_edges;\n+     FILE *file;\n+{\n+  int i;\n+\n+  fprintf (file, \"%s { \", str);\n+  for (i = 0; i < num_edges; i++)\n+    fprintf (file, \"%d->%d \", edges[i]->src->index, edges[i]->dest->index);\n+  fputs (\"}\\n\", file);\n+}\n+\n+\n+/* Dump loop related CFG information.  */\n+static void\n+flow_loops_cfg_dump (loops, file)\n+     const struct loops *loops;\n+     FILE *file;\n+{\n+  int i;\n+\n+  if (! loops->num || ! file || ! loops->cfg.dom)\n+    return;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      edge succ;\n+\n+      fprintf (file, \";; %d succs { \", i);\n+      for (succ = BASIC_BLOCK (i)->succ; succ; succ = succ->succ_next)\n+\tfprintf (file, \"%d \", succ->dest->index);\n+      flow_nodes_print (\"} dom\", loops->cfg.dom[i], file);\t\n+    }\n+\n+\n+  /* Dump the DFS node order.  */\n+  if (loops->cfg.dfs_order)\n+    {\n+      fputs (\";; DFS order: \", file);\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tfprintf (file, \"%d \", loops->cfg.dfs_order[i]);\n+      fputs (\"\\n\", file);\n+    }\n+}\n+\n+\n+/* Return non-zero if the nodes of LOOP are a subset of OUTER.  */\n+int\n+flow_loop_nested_p (outer, loop)\n+     struct loop *outer;\n+     struct loop *loop;\n+{\n+  return sbitmap_a_subset_b_p (loop->nodes, outer->nodes);\n+}\n+\n+\n+/* Dump the loop information specified by LOOPS to the stream FILE.  */\n+void \n+flow_loops_dump (loops, file, verbose)\n+     const struct loops *loops;\n+     FILE *file;\n+     int verbose;\n+{\n+  int i;\n+  int num_loops;\n+\n+  num_loops = loops->num;\n+  if (! num_loops || ! file)\n+    return;\n+\n+  fprintf (file, \";; %d loops found\\n\", num_loops);\n+\n+  for (i = 0; i < num_loops; i++)\n+    {\n+      struct loop *loop = &loops->array[i];\n+\n+      fprintf (file, \";; loop %d (%d to %d):\\n\"\n+\t       \";;   header %d, latch %d, pre-header %d,\"\n+\t       \" depth %d, level %d, outer %d\\n\",\n+\t       i, INSN_UID (loop->header->head), INSN_UID (loop->latch->end),\n+\t       loop->header->index, loop->latch->index,\n+\t       loop->pre_header ? loop->pre_header->index : -1, \n+\t       loop->depth, loop->level,\n+\t       loop->outer ? (loop->outer - loops->array) : -1);\n+      fprintf (file, \";;   %d\", loop->num_nodes);\n+      flow_nodes_print (\" nodes\", loop->nodes, file);\n+      fprintf (file, \";;   %d\", loop->num_exits);\n+      flow_exits_print (\" exits\", loop->exits, loop->num_exits, file);\n+\n+      if (loop->shared)\n+\t{\n+\t  int j;\n+\n+\t  for (j = 0; j < i; j++)\n+\t    {\n+\t      struct loop *oloop = &loops->array[j];\n+\n+\t      if (loop->header == oloop->header)\n+\t\t{\n+\t\t  int disjoint;\n+\t\t  int smaller;\n+\n+\t\t  smaller = loop->num_nodes < oloop->num_nodes;\n+\n+\t\t  /* If the union of LOOP and OLOOP is different than\n+\t\t     the larger of LOOP and OLOOP then LOOP and OLOOP\n+\t\t     must be disjoint.  */\n+\t\t  disjoint = ! flow_loop_nested_p (smaller ? loop : oloop);\n+\t\t  fprintf (file, \";; loop header %d shared by loops %d, %d\"\n+\t\t\t   \" %s\\n\",\n+\t\t\t   loop->header->index, i, j,\n+\t\t\t   disjoint ? \"disjoint\" : \"nested\");\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (verbose)\n+\t{\n+\t  /* Print diagnostics to compare our concept of a loop with\n+\t     what the loop notes say.  */\n+\t  if (GET_CODE (PREV_INSN (loop->header->head)) != NOTE\n+\t      || NOTE_LINE_NUMBER (PREV_INSN (loop->header->head))\n+\t      != NOTE_INSN_LOOP_BEG)\n+\t    fprintf (file, \";; No NOTE_INSN_LOOP_BEG at %d\\n\", \n+\t\t     INSN_UID (PREV_INSN (loop->header->head)));\n+\t  if (GET_CODE (NEXT_INSN (loop->latch->end)) != NOTE\n+\t      || NOTE_LINE_NUMBER (NEXT_INSN (loop->latch->end))\n+\t      != NOTE_INSN_LOOP_END)\n+\t    fprintf (file, \";; No NOTE_INSN_LOOP_END at %d\\n\",\n+\t\t     INSN_UID (NEXT_INSN (loop->latch->end)));\n+\t}\n+    }\n+\n+  if (verbose)\n+    flow_loops_cfg_dump (loops, file);\n+}\n+\n+\n+/* Free all the memory allocated for LOOPS.  */\n+void \n+flow_loops_free (loops)\n+       struct loops *loops;\n+{\n+  if (loops->array)\n+    {\n+      int i;\n+\n+      if (! loops->num)\n+\tabort ();\n+\n+      /* Free the loop descriptors.  */\n+      for (i = 0; i < loops->num; i++)\n+\t{\n+\t  struct loop *loop = &loops->array[i];\n+\t  \n+\t  if (loop->nodes)\n+\t    sbitmap_free (loop->nodes);\n+\t  if (loop->exits)\n+\t    free (loop->exits);\n+\t}\n+      free (loops->array);\n+      loops->array = NULL;\n+      \n+      if (loops->cfg.dom)\n+\tsbitmap_vector_free (loops->cfg.dom);\n+      if (loops->cfg.dfs_order)\n+\tfree (loops->cfg.dfs_order);\n+\n+      sbitmap_free (loops->shared_headers);\n+    }\n+}\n+\n+\n+/* Find the exits from the loop using the bitmap of loop nodes NODES\n+   and store in EXITS array.  Return the number of exits from the\n+   loop.  */\n+static int\n+flow_loop_exits_find (nodes, exits)\n+     const sbitmap nodes;\n+     edge **exits;\n+{\n+  edge e;\n+  int node;\n+  int num_exits;\n+\n+  *exits = NULL;\n+\n+  /* Check all nodes within the loop to see if there are any\n+     successors not in the loop.  Note that a node may have multiple\n+     exiting edges.  */\n+  num_exits = 0;\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {\n+    for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)\n+      {\n+\tbasic_block dest = e->dest;\t  \n+\n+\tif (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index))\n+\t    num_exits++;\n+      }\n+  });\n+\n+  if (! num_exits)\n+    return 0;\n+\n+  *exits = (edge *) xmalloc (num_exits * sizeof (edge *));\n+\n+  /* Store all exiting edges into an array.  */\n+  num_exits = 0;\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {\n+    for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)\n+      {\n+\tbasic_block dest = e->dest;\t  \n+\n+\tif (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index))\n+\t  (*exits)[num_exits++] = e;\n+      }\n+  });\n+\n+  return num_exits;\n+}\n+\n+\n+/* Find the nodes contained within the loop with header HEADER and\n+   latch LATCH and store in NODES.  Return the number of nodes within\n+   the loop.  */\n+static int \n+flow_loop_nodes_find (header, latch, nodes)\n+     basic_block header;\n+     basic_block latch;\n+     sbitmap nodes;\n+{\n+  basic_block *stack;\n+  int sp;\n+  int num_nodes = 0;\n+\n+  stack = (basic_block *) xmalloc (n_basic_blocks * sizeof (basic_block));\n+  sp = 0;\n+\n+  /* Start with only the loop header in the set of loop nodes.  */\n+  sbitmap_zero (nodes);\n+  SET_BIT (nodes, header->index);\n+  num_nodes++;\n+\n+  /* Push the loop latch on to the stack.  */\n+  if (! TEST_BIT (nodes, latch->index))\n+    {\n+      SET_BIT (nodes, latch->index);\n+      num_nodes++;\n+      stack[sp++] = latch;\n+    }\n+\n+  while (sp)\n+    {\n+      basic_block node;\n+      edge e;\n+\n+      node = stack[--sp];\n+      for (e = node->pred; e; e = e->pred_next)\n+\t{\n+\t  basic_block ancestor = e->src;\n+\t  \n+\t  /* If each ancestor not marked as part of loop, add to set of\n+\t     loop nodes and push on to stack.  */\n+\t  if (ancestor != ENTRY_BLOCK_PTR\n+\t      && ! TEST_BIT (nodes, ancestor->index))\n+\t    {\n+\t      SET_BIT (nodes, ancestor->index);\n+\t      num_nodes++;\n+\t      stack[sp++] = ancestor;\n+\t    }\n+\t}\n+    }\n+  free (stack);\n+  return num_nodes;\n+}\n+\n+\n+/* Compute the depth first search order and store in the array\n+   DFS_ORDER, marking the nodes visited in VISITED.  Returns the\n+   number of nodes visited.  */\n+static int\n+flow_depth_first_order_compute (dfs_order)\n+     int *dfs_order;\n+{\n+  edge e;\n+  edge *stack;\n+  int sp;\n+  int dfsnum = 0;\n+  sbitmap visited;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = (edge *) xmalloc (n_basic_blocks * sizeof (edge));\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = sbitmap_alloc (n_basic_blocks);\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (visited);\n+  \n+  /* Start with the first successor edge from the entry block.  */\n+  e = ENTRY_BLOCK_PTR->succ;\n+  while (e)\n+    {\n+      basic_block src = e->src;\n+      basic_block dest = e->dest;\n+      \n+      /* Mark that we have visited this node.  */\n+      if (src != ENTRY_BLOCK_PTR)\n+\tSET_BIT (visited, src->index);\n+\n+      /* If this node has not been visited before, push the current\n+\t edge on to the stack and proceed with the first successor\n+\t edge of this node.  */\n+      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index)\n+\t  && dest->succ)\n+\t{\n+\t  stack[sp++] = e;\n+\t  e = dest->succ;\n+\t}\n+      else\n+\t{\n+\t  if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index)\n+\t      && ! dest->succ)\n+\t    {\n+\t      /* DEST has no successors (for example, a non-returning\n+                 function is called) so do not push the current edge\n+                 but carry on with its next successor.  */\n+\t      dfs_order[dest->index] = n_basic_blocks - ++dfsnum;\n+\t      SET_BIT (visited, dest->index);\n+\t    }\n+\n+\t  while (! e->succ_next && src != ENTRY_BLOCK_PTR)\n+\t    {\n+\t      dfs_order[src->index] = n_basic_blocks - ++dfsnum;\n+\n+\t      /* Pop edge off stack.  */\n+\t      e = stack[--sp];\n+\t      src = e->src;\n+\t    }\n+\t  e = e->succ_next;\n+\t}\n+    }\n+  free (stack);\n+  sbitmap_free (visited);\n+\n+  /* The number of nodes visited should not be greater than\n+     n_basic_blocks.  */\n+  if (dfsnum > n_basic_blocks)\n+    abort ();\n+\n+  /* There are some nodes left in the CFG that are unreachable.  */\n+  if (dfsnum < n_basic_blocks)\n+    abort ();\n+  return dfsnum;\n+}\n+\n+\n+/* Return the block for the pre-header of the loop with header\n+   HEADER where DOM specifies the dominator information.  Return NULL if\n+   there is no pre-header.  */\n+static basic_block\n+flow_loop_pre_header_find (header, dom)\n+     basic_block header;\n+     const sbitmap *dom;     \n+{\n+  basic_block pre_header;\n+  edge e;\n+\n+  /* If block p is a predecessor of the header and is the only block\n+     that the header does not dominate, then it is the pre-header.  */\n+  pre_header = NULL;\n+  for (e = header->pred; e; e = e->pred_next)\n+    {\n+      basic_block node = e->src;\n+      \n+      if (node != ENTRY_BLOCK_PTR\n+\t  && ! TEST_BIT (dom[node->index], header->index))\n+\t{\n+\t  if (pre_header == NULL)\n+\t    pre_header = node;\n+\t  else\n+\t    {\n+\t      /* There are multiple edges into the header from outside \n+\t\t the loop so there is no pre-header block.  */\n+\t      pre_header = NULL;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return pre_header;\n+}\n+\n+\n+/* Add LOOP to the loop hierarchy tree so that it is a sibling or a\n+   descendant of ROOT.  */\n+static void\n+flow_loop_tree_node_add (root, loop)\n+     struct loop *root;\n+     struct loop *loop;\n+{\n+  struct loop *outer;\n+\n+  if (! loop)\n+    return;\n+\n+  for (outer = root; outer; outer = outer->next)\n+    {\n+      if (flow_loop_nested_p (outer, loop))\n+\t{\n+\t  if (outer->inner)\n+\t    {\n+\t      /* Add LOOP as a sibling or descendent of OUTER->INNER.  */\n+\t      flow_loop_tree_node_add (outer->inner, loop);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Add LOOP as child of OUTER.  */\n+\t      outer->inner = loop;\n+\t      loop->outer = outer;\n+\t      loop->next = NULL;\n+\t    }\n+\t  return;\n+\t}\n+    }\n+  /* Add LOOP as a sibling of ROOT.  */\n+  loop->next = root->next;\n+  root->next = loop;\n+  loop->outer = root->outer;\n+}\n+\n+\n+/* Build the loop hierarchy tree for LOOPS.  */\n+static void\n+flow_loops_tree_build (loops)\n+       struct loops *loops;\n+{\n+  int i;\n+  int num_loops;\n+\n+  num_loops = loops->num;\n+  if (! num_loops)\n+    return;\n+\n+  /* Root the loop hierarchy tree with the first loop found.\n+     Since we used a depth first search this should be the \n+     outermost loop.  */\n+  loops->tree = &loops->array[0];\n+  loops->tree->outer = loops->tree->inner = loops->tree->next = NULL;\n+\n+  /* Add the remaining loops to the tree.  */\n+  for (i = 1; i < num_loops; i++)\n+    flow_loop_tree_node_add (loops->tree, &loops->array[i]);\n+}\n+\n+\n+/* Helper function to compute loop nesting depth and enclosed loop level\n+   for the natural loop specified by LOOP at the loop depth DEPTH.   \n+   Returns the loop level.  */\n+static int\n+flow_loop_level_compute (loop, depth)\n+     struct loop *loop;\n+     int depth;\n+{\n+  struct loop *inner;\n+  int level = 0;\n+\n+  if (! loop)\n+    return 0;\n+\n+  /* Traverse loop tree assigning depth and computing level as the\n+     maximum level of all the inner loops of this loop.  The loop\n+     level is equivalent to the height of the loop in the loop tree\n+     and corresponds to the number of enclosed loop levels.  */\n+  for (inner = loop->inner; inner; inner = inner->next)\n+    {\n+      int ilevel;\n+\n+      ilevel = flow_loop_level_compute (inner, depth + 1) + 1;\n+\n+      if (ilevel > level)\n+\tlevel = ilevel;\n+    }\n+  loop->level = level;\n+  loop->depth = depth;\n+  return level;\n+}\n+\n+\n+/* Compute the loop nesting depth and enclosed loop level for the loop\n+   hierarchy tree specfied by LOOPS.  Return the maximum enclosed loop\n+   level.  */\n+static int \n+flow_loops_level_compute (loops)\n+     struct loops *loops;\n+{\n+  return flow_loop_level_compute (loops->tree, 0);\n+}\n+\n+\n+/* Find all the natural loops in the function and save in LOOPS structure.\n+   Return the number of natural loops found.  */\n+int \n+flow_loops_find (loops)\n+       struct loops *loops;\n+{\n+  int i;\n+  int b;\n+  int num_loops;\n+  edge e;\n+  sbitmap headers;\n+  sbitmap *dom;\n+  int *dfs_order;\n+  \n+  loops->num = 0;\n+  loops->array = NULL;\n+  loops->tree = NULL;\n+  dfs_order = NULL;\n+\n+  /* Taking care of this degenerate case makes the rest of\n+     this code simpler.  */\n+  if (n_basic_blocks == 0)\n+    return 0;\n+\n+  /* Compute the dominators.  */\n+  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  compute_flow_dominators (dom, NULL);\n+\n+  /* Count the number of loop edges (back edges).  This should be the\n+     same as the number of natural loops.  */\n+  num_loops = 0;\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      for (e = BASIC_BLOCK (b)->pred; e; e = e->pred_next)\n+\t{\n+\t  basic_block latch = e->src;\n+\t  \n+\t  /* Look for back edges where a predecessor is dominated\n+\t     by this block.  A natural loop has a single entry\n+\t     node (header) that dominates all the nodes in the\n+\t     loop.  It also has single back edge to the header\n+\t     from a latch node.  Note that multiple natural loops\n+\t     may share the same header.  */\n+\t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index], b))\n+\t    num_loops++;\n+\t}\n+    }\n+  \n+  if (num_loops)\n+    {\n+      /* Compute depth first search order of the CFG so that outer\n+\t natural loops will be found before inner natural loops.  */\n+      dfs_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+      flow_depth_first_order_compute (dfs_order);\n+\n+      /* Allocate loop structures.  */\n+      loops->array = (struct loop *)\n+\txcalloc (num_loops, sizeof (struct loop));\n+      \n+      headers = sbitmap_alloc (n_basic_blocks);\n+      sbitmap_zero (headers);\n+\n+      loops->shared_headers = sbitmap_alloc (n_basic_blocks);\n+      sbitmap_zero (loops->shared_headers);\n+\n+      /* Find and record information about all the natural loops\n+\t in the CFG.  */\n+      num_loops = 0;\n+      for (b = 0; b < n_basic_blocks; b++)\n+\t{\n+\t  basic_block header;\n+\n+\t  /* Search the nodes of the CFG in DFS order that we can find\n+\t     outer loops first.  */\n+\t  header = BASIC_BLOCK (dfs_order[b]);\n+\t  \n+\t  /* Look for all the possible latch blocks for this header.  */\n+\t  for (e = header->pred; e; e = e->pred_next)\n+\t    {\n+\t      basic_block latch = e->src;\n+\t      \n+\t      /* Look for back edges where a predecessor is dominated\n+\t\t by this block.  A natural loop has a single entry\n+\t\t node (header) that dominates all the nodes in the\n+\t\t loop.  It also has single back edge to the header\n+\t\t from a latch node.  Note that multiple natural loops\n+\t\t may share the same header.  */\n+\t      if (latch != ENTRY_BLOCK_PTR\n+\t\t  && TEST_BIT (dom[latch->index], header->index))\n+\t\t{\n+\t\t  struct loop *loop;\n+\t\t  \n+\t\t  loop = loops->array + num_loops;\n+\t\t  \n+\t\t  loop->header = header;\n+\t\t  loop->latch = latch;\n+\t\t  \n+\t\t  /* Keep track of blocks that are loop headers so\n+\t\t     that we can tell which loops should be merged.  */\n+\t\t  if (TEST_BIT (headers, header->index))\n+\t\t    SET_BIT (loops->shared_headers, header->index);\n+\t\t  SET_BIT (headers, header->index);\n+\t\t  \n+\t\t  /* Find nodes contained within the loop.  */\n+\t\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n+\t\t  loop->num_nodes =\n+\t\t    flow_loop_nodes_find (header, latch, loop->nodes);\n+\t\t  \n+\t\t  /* Find edges which exit the loop.  Note that a node\n+\t\t     may have several exit edges.  */\n+\t\t  loop->num_exits\n+\t\t    = flow_loop_exits_find (loop->nodes, &loop->exits);\n+\n+\t\t  /* Look to see if the loop has a pre-header node.  */\n+\t\t  loop->pre_header \n+\t\t    = flow_loop_pre_header_find (header, dom);\n+\n+\t\t  num_loops++;\n+\t\t}\n+\t    }\n+\t}\n+      \n+      /* Natural loops with shared headers may either be disjoint or\n+\t nested.  Disjoint loops with shared headers cannot be inner\n+\t loops and should be merged.  For now just mark loops that share\n+\t headers.  */\n+      for (i = 0; i < num_loops; i++)\n+\tif (TEST_BIT (loops->shared_headers, loops->array[i].header->index))\n+\t  loops->array[i].shared = 1;\n+\n+      sbitmap_free (headers);\n+    }\n+\n+  loops->num = num_loops;\n+\n+  /* Save CFG derived information to avoid recomputing it.  */\n+  loops->cfg.dom = dom;\n+  loops->cfg.dfs_order = dfs_order;\n+\n+  /* Build the loop hierarchy tree.  */\n+  flow_loops_tree_build (loops);\n+\n+  /* Assign the loop nesting depth and enclosed loop level for each\n+     loop.  */\n+  flow_loops_level_compute (loops);\n+\n+  return num_loops;\n+}\n+\n+\n+/* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */\n+int\n+flow_loop_outside_edge_p (loop, e)\n+     const struct loop *loop;\n+     edge e;\n+{\n+  if (e->dest != loop->header)\n+    abort ();\n+  return (e->src == ENTRY_BLOCK_PTR)\n+    || ! TEST_BIT (loop->nodes, e->src->index);\n+}"}, {"sha": "dece5e5ef250e3342e9aba25d37e3009b48965ab", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=4dc9341c04ba95ac73093573f645b49dcff494bf", "patch": "@@ -265,6 +265,25 @@ sbitmap_a_or_b (dst, a, b)\n     }\n   return changed;\n }\n+/* Return non-zero if A is a subset of B.  */\n+\n+int\n+sbitmap_a_subset_b_p (a, b)\n+     sbitmap a, b;\n+{\n+  int i;\n+  sbitmap_ptr ap, bp;\n+\n+  ap = a->elms;\n+  bp = b->elms;\n+  for (i = 0; i < a->size; i++)\n+    {\n+      if ((*ap | *bp) != *bp)\n+\treturn 0;\n+      ap++; bp++;\n+    }\n+  return 1;\n+}\n \n /* Set DST to be (A or (B and C)).\n    Return non-zero if any change is made.  */"}, {"sha": "1fc300412238fd5c80a59c8a52afdc562152a924", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dc9341c04ba95ac73093573f645b49dcff494bf/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=4dc9341c04ba95ac73093573f645b49dcff494bf", "patch": "@@ -18,6 +18,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef _SBITMAP_H\n+#define _SBITMAP_H 1\n+\n /* It's not clear yet whether using bitmap.[ch] will be a win.\n    It should be straightforward to convert so for now we keep things simple\n    while more important issues are dealt with.  */\n@@ -109,6 +112,7 @@ extern int sbitmap_a_or_b_and_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n extern int sbitmap_a_and_b_or_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n extern int sbitmap_a_and_b PROTO ((sbitmap, sbitmap, sbitmap));\n extern int sbitmap_a_or_b PROTO ((sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_subset_b_p PROTO ((sbitmap, sbitmap));\n \n struct int_list;\n extern void sbitmap_intersect_of_predsucc PROTO ((sbitmap, sbitmap *,\n@@ -129,3 +133,4 @@ extern void sbitmap_intersection_of_preds    PROTO ((sbitmap, sbitmap *, int));\n extern void sbitmap_union_of_succs\t     PROTO ((sbitmap, sbitmap *, int));\n extern void sbitmap_union_of_preds\t     PROTO ((sbitmap, sbitmap *, int));\n \n+#endif /* _SBITMAP_H */"}]}