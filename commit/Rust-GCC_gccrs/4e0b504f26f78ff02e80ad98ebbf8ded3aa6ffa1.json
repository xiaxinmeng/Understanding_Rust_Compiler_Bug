{"sha": "4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1", "node_id": "C_kwDOANBUbNoAKDRlMGI1MDRmMjZmNzhmZjAyZTgwYWQ5OGViYmY4ZGVkM2FhNmZmYTE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-01-10T12:48:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-01-10T15:53:51Z"}, "message": "tree-optimization/106293 - missed DSE with virtual LC PHI\n\nDegenerate virtual PHIs can break DSEs fragile heuristic as to what\ndefs it can handle for further processing.  The following enhances\nit to look through degenerate PHIs by means of a worklist, processing\nthe degenerate PHI defs uses to the defs array.  The rewrite of\nvirtuals into loop-closed SSA caused this to issue appear more often.\nThe patch itself is mostly re-indenting the new loop body.\n\n\tPR tree-optimization/106293\n\t* tree-ssa-dse.cc (dse_classify_store): Use a worklist to\n\tprocess degenerate PHI defs.\n\n\t* gcc.dg/tree-ssa/ssa-dse-46.c: New testcase.", "tree": {"sha": "5fe5af8efc582baee5bab8fd36d7c18e15338c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fe5af8efc582baee5bab8fd36d7c18e15338c9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "851e1ba03f9de699a754dd8648fc151c3e26d697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851e1ba03f9de699a754dd8648fc151c3e26d697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851e1ba03f9de699a754dd8648fc151c3e26d697"}], "stats": {"total": 204, "additions": 121, "deletions": 83}, "files": [{"sha": "68b36433ffcf43946fb4883965e5036b39d647dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-46.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-46.c?ref=4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse1\" } */\n+\n+int a;\n+static long b = 4073709551612, d;\n+short c;\n+void foo();\n+char e(int **f) {\n+  **f = 0;\n+  if (a) {\n+    unsigned long *g = &b;\n+    unsigned long **h = &g;\n+    for (; d;) {\n+      foo();\n+      for (; c;) {\n+        unsigned long ***i = &h;\n+      }\n+    }\n+  }\n+  return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"&b\" \"dse1\" } } */"}, {"sha": "46ab57d575408feb0073f14d204662447cd835c1", "filename": "gcc/tree-ssa-dse.cc", "status": "modified", "additions": 98, "deletions": 83, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1/gcc%2Ftree-ssa-dse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1/gcc%2Ftree-ssa-dse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.cc?ref=4e0b504f26f78ff02e80ad98ebbf8ded3aa6ffa1", "patch": "@@ -984,108 +984,123 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n       else\n \tdefvar = gimple_vdef (temp);\n \n-      /* If we're instructed to stop walking at region boundary, do so.  */\n-      if (defvar == stop_at_vuse)\n-\treturn DSE_STORE_LIVE;\n-\n       auto_vec<gimple *, 10> defs;\n       gphi *first_phi_def = NULL;\n       gphi *last_phi_def = NULL;\n-      FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n+\n+      auto_vec<tree, 10> worklist;\n+      worklist.quick_push (defvar);\n+\n+      do\n \t{\n-\t  /* Limit stmt walking.  */\n-\t  if (++cnt > param_dse_max_alias_queries_per_store)\n-\t    {\n-\t      fail = true;\n-\t      break;\n-\t    }\n+\t  defvar = worklist.pop ();\n+\t  /* If we're instructed to stop walking at region boundary, do so.  */\n+\t  if (defvar == stop_at_vuse)\n+\t    return DSE_STORE_LIVE;\n \n-\t  /* In simple cases we can look through PHI nodes, but we\n-\t     have to be careful with loops and with memory references\n-\t     containing operands that are also operands of PHI nodes.\n-\t     See gcc.c-torture/execute/20051110-*.c.  */\n-\t  if (gimple_code (use_stmt) == GIMPLE_PHI)\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n \t    {\n-\t      /* If we already visited this PHI ignore it for further\n-\t\t processing.  */\n-\t      if (!bitmap_bit_p (visited,\n-\t\t\t\t SSA_NAME_VERSION (PHI_RESULT (use_stmt))))\n+\t      /* Limit stmt walking.  */\n+\t      if (++cnt > param_dse_max_alias_queries_per_store)\n \t\t{\n-\t\t  /* If we visit this PHI by following a backedge then we have\n-\t\t     to make sure ref->ref only refers to SSA names that are\n-\t\t     invariant with respect to the loop represented by this\n-\t\t     PHI node.  */\n-\t\t  if (dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt),\n-\t\t\t\t      gimple_bb (use_stmt))\n-\t\t      && !for_each_index (ref->ref ? &ref->ref : &ref->base,\n-\t\t\t\t\t  check_name, gimple_bb (use_stmt)))\n-\t\t    return DSE_STORE_LIVE;\n-\t\t  defs.safe_push (use_stmt);\n-\t\t  if (!first_phi_def)\n-\t\t    first_phi_def = as_a <gphi *> (use_stmt);\n-\t\t  last_phi_def = as_a <gphi *> (use_stmt);\n+\t\t  fail = true;\n+\t\t  break;\n \t\t}\n-\t    }\n-\t  /* If the statement is a use the store is not dead.  */\n-\t  else if (ref_maybe_used_by_stmt_p (use_stmt, ref))\n-\t    {\n-\t      if (dse_stmt_to_dr_map\n-\t\t  && ref->ref\n-\t\t  && is_gimple_assign (use_stmt))\n+\n+\t      /* In simple cases we can look through PHI nodes, but we\n+\t\t have to be careful with loops and with memory references\n+\t\t containing operands that are also operands of PHI nodes.\n+\t\t See gcc.c-torture/execute/20051110-*.c.  */\n+\t      if (gimple_code (use_stmt) == GIMPLE_PHI)\n \t\t{\n-\t\t  if (!dra)\n-\t\t    dra.reset (create_data_ref (NULL, NULL, ref->ref, stmt,\n-\t\t\t\t\t\tfalse, false));\n-\t\t  bool existed_p;\n-\t\t  data_reference_p &drb\n-\t\t    = dse_stmt_to_dr_map->get_or_insert (use_stmt, &existed_p);\n-\t\t  if (!existed_p)\n-\t\t    drb = create_data_ref (NULL, NULL,\n-\t\t\t\t\t   gimple_assign_rhs1 (use_stmt),\n-\t\t\t\t\t   use_stmt, false, false);\n-\t\t  if (!dr_may_alias_p (dra.get (), drb, NULL))\n+\t\t  /* Look through single-argument PHIs.  */\n+\t\t  if (gimple_phi_num_args (use_stmt) == 1)\n+\t\t    worklist.safe_push (gimple_phi_result (use_stmt));\n+\n+\t\t  /* If we already visited this PHI ignore it for further\n+\t\t     processing.  */\n+\t\t  else if (!bitmap_bit_p (visited,\n+\t\t\t\t\t  SSA_NAME_VERSION\n+\t\t\t\t\t    (PHI_RESULT (use_stmt))))\n \t\t    {\n-\t\t      if (gimple_vdef (use_stmt))\n-\t\t\tdefs.safe_push (use_stmt);\n-\t\t      continue;\n+\t\t      /* If we visit this PHI by following a backedge then we\n+\t\t\t have to make sure ref->ref only refers to SSA names\n+\t\t\t that are invariant with respect to the loop\n+\t\t\t represented by this PHI node.  */\n+\t\t      if (dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt),\n+\t\t\t\t\t  gimple_bb (use_stmt))\n+\t\t\t  && !for_each_index (ref->ref ? &ref->ref : &ref->base,\n+\t\t\t\t\t      check_name, gimple_bb (use_stmt)))\n+\t\t\treturn DSE_STORE_LIVE;\n+\t\t      defs.safe_push (use_stmt);\n+\t\t      if (!first_phi_def)\n+\t\t\tfirst_phi_def = as_a <gphi *> (use_stmt);\n+\t\t      last_phi_def = as_a <gphi *> (use_stmt);\n \t\t    }\n \t\t}\n+\t      /* If the statement is a use the store is not dead.  */\n+\t      else if (ref_maybe_used_by_stmt_p (use_stmt, ref))\n+\t\t{\n+\t\t  if (dse_stmt_to_dr_map\n+\t\t      && ref->ref\n+\t\t      && is_gimple_assign (use_stmt))\n+\t\t    {\n+\t\t      if (!dra)\n+\t\t\tdra.reset (create_data_ref (NULL, NULL, ref->ref, stmt,\n+\t\t\t\t\t\t    false, false));\n+\t\t      bool existed_p;\n+\t\t      data_reference_p &drb\n+\t\t\t= dse_stmt_to_dr_map->get_or_insert (use_stmt,\n+\t\t\t\t\t\t\t     &existed_p);\n+\t\t      if (!existed_p)\n+\t\t\tdrb = create_data_ref (NULL, NULL,\n+\t\t\t\t\t       gimple_assign_rhs1 (use_stmt),\n+\t\t\t\t\t       use_stmt, false, false);\n+\t\t      if (!dr_may_alias_p (dra.get (), drb, NULL))\n+\t\t\t{\n+\t\t\t  if (gimple_vdef (use_stmt))\n+\t\t\t    defs.safe_push (use_stmt);\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n \n-\t      /* Handle common cases where we can easily build an ao_ref\n-\t\t structure for USE_STMT and in doing so we find that the\n-\t\t references hit non-live bytes and thus can be ignored.\n+\t\t  /* Handle common cases where we can easily build an ao_ref\n+\t\t     structure for USE_STMT and in doing so we find that the\n+\t\t     references hit non-live bytes and thus can be ignored.\n \n-\t\t TODO: We can also use modref summary to handle calls.  */\n-\t      if (byte_tracking_enabled\n-\t\t  && is_gimple_assign (use_stmt))\n-\t\t{\n-\t\t  ao_ref use_ref;\n-\t\t  ao_ref_init (&use_ref, gimple_assign_rhs1 (use_stmt));\n-\t\t  if (valid_ao_ref_for_dse (&use_ref)\n-\t\t      && operand_equal_p (use_ref.base, ref->base,\n-\t\t\t\t\t  OEP_ADDRESS_OF)\n-\t\t      && !live_bytes_read (&use_ref, ref, live_bytes))\n+\t\t     TODO: We can also use modref summary to handle calls.  */\n+\t\t  if (byte_tracking_enabled\n+\t\t      && is_gimple_assign (use_stmt))\n \t\t    {\n-\t\t      /* If this is a store, remember it as we possibly\n-\t\t\t need to walk the defs uses.  */\n-\t\t      if (gimple_vdef (use_stmt))\n-\t\t\tdefs.safe_push (use_stmt);\n-\t\t      continue;\n+\t\t      ao_ref use_ref;\n+\t\t      ao_ref_init (&use_ref, gimple_assign_rhs1 (use_stmt));\n+\t\t      if (valid_ao_ref_for_dse (&use_ref)\n+\t\t\t  && operand_equal_p (use_ref.base, ref->base,\n+\t\t\t\t\t      OEP_ADDRESS_OF)\n+\t\t\t  && !live_bytes_read (&use_ref, ref, live_bytes))\n+\t\t\t{\n+\t\t\t  /* If this is a store, remember it as we possibly\n+\t\t\t     need to walk the defs uses.  */\n+\t\t\t  if (gimple_vdef (use_stmt))\n+\t\t\t    defs.safe_push (use_stmt);\n+\t\t\t  continue;\n+\t\t\t}\n \t\t    }\n-\t\t}\n \n-\t      fail = true;\n-\t      break;\n+\t\t  fail = true;\n+\t\t  break;\n+\t\t}\n+\t      /* We have visited ourselves already so ignore STMT for the\n+\t\t purpose of chaining.  */\n+\t      else if (use_stmt == stmt)\n+\t\t;\n+\t      /* If this is a store, remember it as we possibly need to walk the\n+\t\t defs uses.  */\n+\t      else if (gimple_vdef (use_stmt))\n+\t\tdefs.safe_push (use_stmt);\n \t    }\n-\t  /* We have visited ourselves already so ignore STMT for the\n-\t     purpose of chaining.  */\n-\t  else if (use_stmt == stmt)\n-\t    ;\n-\t  /* If this is a store, remember it as we possibly need to walk the\n-\t     defs uses.  */\n-\t  else if (gimple_vdef (use_stmt))\n-\t    defs.safe_push (use_stmt);\n \t}\n+      while (!fail && !worklist.is_empty ());\n \n       if (fail)\n \t{"}]}