{"sha": "ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ2YzQ4MzFhOWFjYTQ3NjRiNDU3MzRhZTMxYzlmNmU4ZWFjNGNhYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-16T11:06:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-16T11:06:25Z"}, "message": "re PR tree-optimization/45623 (GCC 4.5.[01] breaks our ffi on Linux64. ABI break?)\n\n2010-09-16  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/45623\n\t* tree-ssa-structalias.c (get_constraint_for_ptr_offset): Adjust.\n\t(get_constraint_for_component_ref): If computing a constraint\n\tfor the rhs handle type punning through unions.\n\t(get_constraint_for_address_of): Adjust.\n\t(get_constraint_for_1): Likewise.\n\t(get_constraint_for): Likewise.\n\t(get_constraint_for_rhs): New function.\n\t(do_structure_copy): Adjust.\n\t(make_constraint_to): Likewise.\n\t(handle_const_call): Likewise.\n\t(find_func_aliases): Likewise.\n\t(process_ipa_clobber): Likewise.\n\t(create_variable_info_for): Likewise.\n\n\t* gcc.dg/torture/pr45623.c: New testcase.\n\nFrom-SVN: r164333", "tree": {"sha": "0668baf35a808838597ae97ba541f699d53e4a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0668baf35a808838597ae97ba541f699d53e4a0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff802fa1f343ad103f939306af07337d9562f1f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff802fa1f343ad103f939306af07337d9562f1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff802fa1f343ad103f939306af07337d9562f1f3"}], "stats": {"total": 133, "additions": 110, "deletions": 23}, "files": [{"sha": "bfaed4f9a738edeedbabac7cb089c3006d7da390", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "patch": "@@ -1,3 +1,20 @@\n+2010-09-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45623\n+\t* tree-ssa-structalias.c (get_constraint_for_ptr_offset): Adjust.\n+\t(get_constraint_for_component_ref): If computing a constraint\n+\tfor the rhs handle type punning through unions.\n+\t(get_constraint_for_address_of): Adjust.\n+\t(get_constraint_for_1): Likewise.\n+\t(get_constraint_for): Likewise.\n+\t(get_constraint_for_rhs): New function.\n+\t(do_structure_copy): Adjust.\n+\t(make_constraint_to): Likewise.\n+\t(handle_const_call): Likewise.\n+\t(find_func_aliases): Likewise.\n+\t(process_ipa_clobber): Likewise.\n+\t(create_variable_info_for): Likewise.\n+\n 2010-09-16  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vectorizer.c: Fix documentation."}, {"sha": "8baa140bad355ba73d24b3bbd9ba004289b30dc3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "patch": "@@ -1,3 +1,8 @@\n+2010-09-16  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45623\n+\t* gcc.dg/torture/pr45623.c: New testcase.\n+\n 2010-09-16  Ira Rosen  <irar@il.ibm.com>\n \n \t* gcc.dg/vect/bb-slp-8.c: Fix documentation, add space between function"}, {"sha": "2f07d2554b56eb0a765c0119e4377881985b7fbe", "filename": "gcc/testsuite/gcc.dg/torture/pr45623.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45623.c?ref=ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+\n+#include <stdint.h>\n+\n+extern void abort (void);\n+\n+char *s1 = \"foo\";\n+char *s2 = \"bar\";\n+\n+char **ss1 = &s1;\n+\n+typedef union jsval_layout\n+{\n+    uint64_t asBits;\n+    char **ptr;\n+} jsval_layout;\n+\n+int main()\n+{\n+  jsval_layout l, m;\n+  l.ptr = ss1;\n+  m.asBits = l.asBits;\n+  char ** data = m.ptr;\n+  *data = s2;\n+  if (s1 != s2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "486e9b36d5dbca6da0481242256c80430ecd546c", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6c4831a9aca4764b45734ae31c9f6e8eac4cac/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ed6c4831a9aca4764b45734ae31c9f6e8eac4cac", "patch": "@@ -532,8 +532,9 @@ struct constraint_expr\n typedef struct constraint_expr ce_s;\n DEF_VEC_O(ce_s);\n DEF_VEC_ALLOC_O(ce_s, heap);\n-static void get_constraint_for_1 (tree, VEC(ce_s, heap) **, bool);\n+static void get_constraint_for_1 (tree, VEC(ce_s, heap) **, bool, bool);\n static void get_constraint_for (tree, VEC(ce_s, heap) **);\n+static void get_constraint_for_rhs (tree, VEC(ce_s, heap) **);\n static void do_deref (VEC (ce_s, heap) **);\n \n /* Our set constraints are made up of two constraint expressions, one\n@@ -2994,7 +2995,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n      does not change the points-to solution.  */\n   if (!use_field_sensitive)\n     {\n-      get_constraint_for (ptr, results);\n+      get_constraint_for_rhs (ptr, results);\n       return;\n     }\n \n@@ -3014,7 +3015,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \trhsoffset = UNKNOWN_OFFSET;\n     }\n \n-  get_constraint_for (ptr, results);\n+  get_constraint_for_rhs (ptr, results);\n   if (rhsoffset == 0)\n     return;\n \n@@ -3092,11 +3093,13 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \n \n /* Given a COMPONENT_REF T, return the constraint_expr vector for it.\n-   If address_p is true the result will be taken its address of.  */\n+   If address_p is true the result will be taken its address of.\n+   If lhs_p is true then the constraint expression is assumed to be used\n+   as the lhs.  */\n \n static void\n get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n-\t\t\t\t  bool address_p)\n+\t\t\t\t  bool address_p, bool lhs_p)\n {\n   tree orig_t = t;\n   HOST_WIDE_INT bitsize = -1;\n@@ -3124,11 +3127,34 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n       return;\n     }\n \n+  /* Handle type-punning through unions.  If we are extracting a pointer\n+     from a union via a possibly type-punning access that pointer\n+     points to anything, similar to a conversion of an integer to\n+     a pointer.  */\n+  if (!lhs_p)\n+    {\n+      tree u;\n+      for (u = t;\n+\t   TREE_CODE (u) == COMPONENT_REF || TREE_CODE (u) == ARRAY_REF;\n+\t   u = TREE_OPERAND (u, 0))\n+\tif (TREE_CODE (u) == COMPONENT_REF\n+\t    && TREE_CODE (TREE_TYPE (TREE_OPERAND (u, 0))) == UNION_TYPE)\n+\t  {\n+\t    struct constraint_expr temp;\n+\n+\t    temp.offset = 0;\n+\t    temp.var = anything_id;\n+\t    temp.type = ADDRESSOF;\n+\t    VEC_safe_push (ce_s, heap, *results, &temp);\n+\t    return;\n+\t  }\n+    }\n+\n   t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);\n \n   /* Pretend to take the address of the base, we'll take care of\n      adding the required subset of sub-fields below.  */\n-  get_constraint_for_1 (t, results, true);\n+  get_constraint_for_1 (t, results, true, lhs_p);\n   gcc_assert (VEC_length (ce_s, *results) == 1);\n   result = VEC_last (ce_s, *results);\n \n@@ -3257,8 +3283,6 @@ do_deref (VEC (ce_s, heap) **constraints)\n     }\n }\n \n-static void get_constraint_for_1 (tree, VEC (ce_s, heap) **, bool);\n-\n /* Given a tree T, return the constraint expression for taking the\n    address of it.  */\n \n@@ -3268,7 +3292,7 @@ get_constraint_for_address_of (tree t, VEC (ce_s, heap) **results)\n   struct constraint_expr *c;\n   unsigned int i;\n \n-  get_constraint_for_1 (t, results, true);\n+  get_constraint_for_1 (t, results, true, true);\n \n   FOR_EACH_VEC_ELT (ce_s, *results, i, c)\n     {\n@@ -3282,7 +3306,8 @@ get_constraint_for_address_of (tree t, VEC (ce_s, heap) **results)\n /* Given a tree T, return the constraint expression for it.  */\n \n static void\n-get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n+get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n+\t\t      bool lhs_p)\n {\n   struct constraint_expr temp;\n \n@@ -3354,10 +3379,11 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t  case ARRAY_REF:\n \t  case ARRAY_RANGE_REF:\n \t  case COMPONENT_REF:\n-\t    get_constraint_for_component_ref (t, results, address_p);\n+\t    get_constraint_for_component_ref (t, results, address_p, lhs_p);\n \t    return;\n \t  case VIEW_CONVERT_EXPR:\n-\t    get_constraint_for_1 (TREE_OPERAND (t, 0), results, address_p);\n+\t    get_constraint_for_1 (TREE_OPERAND (t, 0), results, address_p,\n+\t\t\t\t  lhs_p);\n \t    return;\n \t  /* We are missing handling for TARGET_MEM_REF here.  */\n \t  default:;\n@@ -3382,7 +3408,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t\t{\n \t\t  struct constraint_expr *rhsp;\n \t\t  unsigned j;\n-\t\t  get_constraint_for_1 (val, &tmp, address_p);\n+\t\t  get_constraint_for_1 (val, &tmp, address_p, lhs_p);\n \t\t  FOR_EACH_VEC_ELT (ce_s, tmp, j, rhsp)\n \t\t    VEC_safe_push (ce_s, heap, *results, rhsp);\n \t\t  VEC_truncate (ce_s, tmp, 0);\n@@ -3419,7 +3445,18 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n {\n   gcc_assert (VEC_length (ce_s, *results) == 0);\n \n-  get_constraint_for_1 (t, results, false);\n+  get_constraint_for_1 (t, results, false, true);\n+}\n+\n+/* Given a gimple tree T, return the constraint expression vector for it\n+   to be used as the rhs of a constraint.  */\n+\n+static void\n+get_constraint_for_rhs (tree t, VEC (ce_s, heap) **results)\n+{\n+  gcc_assert (VEC_length (ce_s, *results) == 0);\n+\n+  get_constraint_for_1 (t, results, false, false);\n }\n \n \n@@ -3461,7 +3498,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n   unsigned j;\n \n   get_constraint_for (lhsop, &lhsc);\n-  get_constraint_for (rhsop, &rhsc);\n+  get_constraint_for_rhs (rhsop, &rhsc);\n   lhsp = VEC_index (ce_s, lhsc, 0);\n   rhsp = VEC_index (ce_s, rhsc, 0);\n   if (lhsp->type == DEREF\n@@ -3531,7 +3568,7 @@ make_constraint_to (unsigned id, tree op)\n   includes.offset = 0;\n   includes.type = SCALAR;\n \n-  get_constraint_for (op, &rhsc);\n+  get_constraint_for_rhs (op, &rhsc);\n   FOR_EACH_VEC_ELT (ce_s, rhsc, j, c)\n     process_constraint (new_constraint (includes, *c));\n   VEC_free (ce_s, heap, rhsc);\n@@ -3904,7 +3941,7 @@ handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n \t  VEC(ce_s, heap) *argc = NULL;\n \t  unsigned i;\n \t  struct constraint_expr *argp;\n-\t  get_constraint_for (arg, &argc);\n+\t  get_constraint_for_rhs (arg, &argc);\n \t  FOR_EACH_VEC_ELT (ce_s, argc, i, argp)\n \t    VEC_safe_push (ce_s, heap, *results, argp);\n \t  VEC_free(ce_s, heap, argc);\n@@ -4038,7 +4075,7 @@ find_func_aliases (gimple origt)\n \t      tree strippedrhs = PHI_ARG_DEF (t, i);\n \n \t      STRIP_NOPS (strippedrhs);\n-\t      get_constraint_for (gimple_phi_arg_def (t, i), &rhsc);\n+\t      get_constraint_for_rhs (gimple_phi_arg_def (t, i), &rhsc);\n \n \t      FOR_EACH_VEC_ELT (ce_s, lhsc, j, c)\n \t\t{\n@@ -4322,7 +4359,7 @@ find_func_aliases (gimple origt)\n \t      if (!could_have_pointers (arg))\n \t\tcontinue;\n \n-\t      get_constraint_for (arg, &rhsc);\n+\t      get_constraint_for_rhs (arg, &rhsc);\n \t      lhs = get_function_part_constraint (fi, fi_parm_base + j);\n \t      while (VEC_length (ce_s, rhsc) != 0)\n \t\t{\n@@ -4417,7 +4454,7 @@ find_func_aliases (gimple origt)\n \t\t    && !(POINTER_TYPE_P (gimple_expr_type (t))\n \t\t\t && !POINTER_TYPE_P (TREE_TYPE (rhsop))))\n \t\t   || gimple_assign_single_p (t))\n-\t    get_constraint_for (rhsop, &rhsc);\n+\t    get_constraint_for_rhs (rhsop, &rhsc);\n \t  else\n \t    {\n \t      temp.type = ADDRESSOF;\n@@ -4468,7 +4505,7 @@ find_func_aliases (gimple origt)\n \t  unsigned i;\n \n \t  lhs = get_function_part_constraint (fi, fi_result);\n-\t  get_constraint_for (gimple_return_retval (t), &rhsc);\n+\t  get_constraint_for_rhs (gimple_return_retval (t), &rhsc);\n \t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n \t}\n@@ -4549,7 +4586,7 @@ process_ipa_clobber (varinfo_t fi, tree ptr)\n   VEC(ce_s, heap) *ptrc = NULL;\n   struct constraint_expr *c, lhs;\n   unsigned i;\n-  get_constraint_for (ptr, &ptrc);\n+  get_constraint_for_rhs (ptr, &ptrc);\n   lhs = get_function_part_constraint (fi, fi_clobbers);\n   FOR_EACH_VEC_ELT (ce_s, ptrc, i, c)\n     process_constraint (new_constraint (lhs, *c));\n@@ -5430,7 +5467,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  VEC (ce_s, heap) *rhsc = NULL;\n \t  struct constraint_expr lhs, *rhsp;\n \t  unsigned i;\n-\t  get_constraint_for (DECL_INITIAL (decl), &rhsc);\n+\t  get_constraint_for_rhs (DECL_INITIAL (decl), &rhsc);\n \t  lhs.var = vi->id;\n \t  lhs.offset = 0;\n \t  lhs.type = SCALAR;"}]}