{"sha": "0354c0c70b2a090a3705fffd6a87313233b5516d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1NGMwYzcwYjJhMDkwYTM3MDVmZmZkNmE4NzMxMzIzM2I1NTE2ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-06-25T08:56:24Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-06-25T08:56:24Z"}, "message": "With large parts from Jim Wilson:\n\n\tPR target/43902\n\t* tree-pretty-print.c (dump_generic_node, op_code_prio): Add\n\tWIDEN_MULT_PLUS_EXPR and WIDEN_MULT_MINUS_EXPR.\n\t* optabs.c (optab_for_tree_code): Likewise.\n\t(expand_widen_pattern_expr): Likewise.\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): New function, broken\n\tout of execute_optimize_widening_mul.\n\t(convert_plusminus_to_widen): New function.\n\t(execute_optimize_widening_mul): Use the two new functions.\n\t* expr.c (expand_expr_real_2): Add support for GIMPLE_TERNARY_RHS.\n\tRemove code to generate widening multiply-accumulate.  Add support\n\tfor WIDEN_MULT_PLUS_EXPR and WIDEN_MULT_MINUS_EXPR.\n\t* gimple-pretty-print.c (dump_ternary_rhs): New function.\n\t(dump_gimple_assign): Call it when appropriate.\n\t* tree.def (WIDEN_MULT_PLUS_EXPR, WIDEN_MULT_MINUS_EXPR): New codes.\n\t* cfgexpand.c (gimple_assign_rhs_to_tree): Likewise.\n\t(expand_gimple_stmt_1): Likewise.\n\t(expand_debug_expr): Support WIDEN_MULT_PLUS_EXPR and\n\tWIDEN_MULT_MINUS_EXPR.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Likewise.\n\t* gimple.c (extract_ops_from_tree_1): Renamed from\n\textract_ops_from_tree.  Add new arg for a third operand; fill it.\n\t(gimple_build_assign_stat): Support operations with three operands.\n\t(gimple_build_assign_with_ops_stat): Likewise.\n\t(gimple_assign_set_rhs_from_tree): Likewise.\n\t(gimple_assign_set_rhs_with_ops_1): Renamed from\n\tgimple_assign_set_rhs_with_ops.  Add new arg for a third operand.\n\t(get_gimple_rhs_num_ops): Support GIMPLE_TERNARY_RHS.\n\t(get_gimple_rhs_num_ops): Handle WIDEN_MULT_PLUS_EXPR and\n\tWIDEN_MULT_MINUS_EXPR.\n\t* gimple.h (enum gimple_rhs_class): Add GIMPLE_TERNARY_RHS.\n\t(extract_ops_from_tree_1): Adjust declaration.\n\t(gimple_assign_set_rhs_with_ops_1): Likewise.\n\t(gimple_build_assign_with_ops): Pass NULL for last operand.\n\t(gimple_build_assign_with_ops3): New macro.\n\t(gimple_assign_rhs3, gimple_assign_rhs3_ptr, gimple_assign_set_rhs3,\n\tgimple_assign_set_rhs_with_ops, extract_ops_from_tree): New inline\n\tfunctions.\n\t* tree-cfg.c (verify_gimple_assign_ternary): New static function.\n\t(verify_gimple_assign): Call it.\n\t* doc/gimple.texi (Manipulating operands): Document GIMPLE_TERNARY_RHS.\n\t(Tuple specific accessors, subsection GIMPLE_ASSIGN): Document new\n\tfunctions for dealing with three-operand statements.\n\t* tree.c (commutative_ternary_tree_code): New function.\n\t* tree.h (commutative_ternary_tree_code): Declare it.\n\t* tree-vrp.c (gimple_assign_nonnegative_warnv_p): Return false for ternary\n\tstatements.\n\t(gimple_assign_nonzero_warnv_p): Likewise.\n\t* tree-ssa-sccvn.c (stmt_has_constants): Handle GIMPLE_TERNARY_RHS.\n\t* tree-ssa-ccp.c (get_rhs_assign_op_for_ccp): New static function.\n\t(ccp_fold): Use it.  Handle GIMPLE_TERNARY_RHS.\n\t* tree-ssa-dom.c (enum expr_kind): Add EXPR_TERNARY.\n\t(struct hashtable_expr): New member ternary in the union.\n\t(initialize_hash_element): Handle GIMPLE_TERNARY_RHS.\n\t(hashable_expr_equal_p): Fix indentation.  Handle EXPR_TERNARY.\n\t(iterative_hash_hashable_expr): Likewise.\n\t(print_expr_hash_elt): Handle EXPR_TERNARY.\n\t* gimple-fold.c (fold_gimple_assign): Handle GIMPLE_TERNARY_RHS.\n\t* tree-ssa-threadedge.c (fold_assignment_stmt): Remove useless break\n\tstatements.  Handle GIMPLE_TERNARY_RHS.\n\ntestsuite/\n\tPR target/43902\n\t* gcc.target/mips/madd-9.c: New test.\n\nFrom-SVN: r161366", "tree": {"sha": "5a50f0008cf354dc460d1db0b3077d133fe49dbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a50f0008cf354dc460d1db0b3077d133fe49dbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0354c0c70b2a090a3705fffd6a87313233b5516d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0354c0c70b2a090a3705fffd6a87313233b5516d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0354c0c70b2a090a3705fffd6a87313233b5516d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0354c0c70b2a090a3705fffd6a87313233b5516d/comments", "author": null, "committer": null, "parents": [{"sha": "38f78b0c69999b7e2eec2ce58a02d08b24be7f43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f78b0c69999b7e2eec2ce58a02d08b24be7f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f78b0c69999b7e2eec2ce58a02d08b24be7f43"}], "stats": {"total": 1051, "additions": 763, "deletions": 288}, "files": [{"sha": "3dd890761dc4619c0ab3f6614fa6734233223738", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -1,3 +1,68 @@\n+2010-06-25  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tWith large parts from Jim Wilson:\n+\tPR target/43902\n+\t* tree-pretty-print.c (dump_generic_node, op_code_prio): Add\n+\tWIDEN_MULT_PLUS_EXPR and WIDEN_MULT_MINUS_EXPR.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t(expand_widen_pattern_expr): Likewise.\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): New function, broken\n+\tout of execute_optimize_widening_mul.\n+\t(convert_plusminus_to_widen): New function.\n+\t(execute_optimize_widening_mul): Use the two new functions.\n+\t* expr.c (expand_expr_real_2): Add support for GIMPLE_TERNARY_RHS.\n+\tRemove code to generate widening multiply-accumulate.  Add support\n+\tfor WIDEN_MULT_PLUS_EXPR and WIDEN_MULT_MINUS_EXPR.\n+\t* gimple-pretty-print.c (dump_ternary_rhs): New function.\n+\t(dump_gimple_assign): Call it when appropriate.\n+\t* tree.def (WIDEN_MULT_PLUS_EXPR, WIDEN_MULT_MINUS_EXPR): New codes.\n+\t* cfgexpand.c (gimple_assign_rhs_to_tree): Likewise.\n+\t(expand_gimple_stmt_1): Likewise.\n+\t(expand_debug_expr): Support WIDEN_MULT_PLUS_EXPR and\n+\tWIDEN_MULT_MINUS_EXPR.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Likewise.\n+\t* gimple.c (extract_ops_from_tree_1): Renamed from\n+\textract_ops_from_tree.  Add new arg for a third operand; fill it.\n+\t(gimple_build_assign_stat): Support operations with three operands.\n+\t(gimple_build_assign_with_ops_stat): Likewise.\n+\t(gimple_assign_set_rhs_from_tree): Likewise.\n+\t(gimple_assign_set_rhs_with_ops_1): Renamed from\n+\tgimple_assign_set_rhs_with_ops.  Add new arg for a third operand.\n+\t(get_gimple_rhs_num_ops): Support GIMPLE_TERNARY_RHS.\n+\t(get_gimple_rhs_num_ops): Handle WIDEN_MULT_PLUS_EXPR and\n+\tWIDEN_MULT_MINUS_EXPR.\n+\t* gimple.h (enum gimple_rhs_class): Add GIMPLE_TERNARY_RHS.\n+\t(extract_ops_from_tree_1): Adjust declaration.\n+\t(gimple_assign_set_rhs_with_ops_1): Likewise.\n+\t(gimple_build_assign_with_ops): Pass NULL for last operand.\n+\t(gimple_build_assign_with_ops3): New macro.\n+\t(gimple_assign_rhs3, gimple_assign_rhs3_ptr, gimple_assign_set_rhs3,\n+\tgimple_assign_set_rhs_with_ops, extract_ops_from_tree): New inline\n+\tfunctions.\n+\t* tree-cfg.c (verify_gimple_assign_ternary): New static function.\n+\t(verify_gimple_assign): Call it.\n+\t* doc/gimple.texi (Manipulating operands): Document GIMPLE_TERNARY_RHS.\n+\t(Tuple specific accessors, subsection GIMPLE_ASSIGN): Document new\n+\tfunctions for dealing with three-operand statements.\n+\t* tree.c (commutative_ternary_tree_code): New function.\n+\t* tree.h (commutative_ternary_tree_code): Declare it.\n+\t* tree-vrp.c (gimple_assign_nonnegative_warnv_p): Return false for ternary\n+\tstatements.\n+\t(gimple_assign_nonzero_warnv_p): Likewise.\n+\t* tree-ssa-sccvn.c (stmt_has_constants): Handle GIMPLE_TERNARY_RHS.\n+\t* tree-ssa-ccp.c (get_rhs_assign_op_for_ccp): New static function.\n+\t(ccp_fold): Use it.  Handle GIMPLE_TERNARY_RHS.\n+\t* tree-ssa-dom.c (enum expr_kind): Add EXPR_TERNARY.\n+\t(struct hashtable_expr): New member ternary in the union.\n+\t(initialize_hash_element): Handle GIMPLE_TERNARY_RHS.\n+\t(hashable_expr_equal_p): Fix indentation.  Handle EXPR_TERNARY.\n+\t(iterative_hash_hashable_expr): Likewise.\n+\t(print_expr_hash_elt): Handle EXPR_TERNARY.\n+\t* gimple-fold.c (fold_gimple_assign): Handle GIMPLE_TERNARY_RHS.\n+\t* tree-ssa-threadedge.c (fold_assignment_stmt): Remove useless break\n+\tstatements.  Handle GIMPLE_TERNARY_RHS.\n+\n 2010-06-25  Jan Hubicka  <jh@suse.cz>\n \n \t* doc/invoke.texi (-Wsuggest-attribute): Add noreturn."}, {"sha": "0d8026e75a15121344e4573f672c433145c76c9d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -68,7 +68,13 @@ gimple_assign_rhs_to_tree (gimple stmt)\n \n   grhs_class = get_gimple_rhs_class (gimple_expr_code (stmt));\n \n-  if (grhs_class == GIMPLE_BINARY_RHS)\n+  if (grhs_class == GIMPLE_TERNARY_RHS)\n+    t = build3 (gimple_assign_rhs_code (stmt),\n+\t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\tgimple_assign_rhs1 (stmt),\n+\t\tgimple_assign_rhs2 (stmt),\n+\t\tgimple_assign_rhs3 (stmt));\n+  else if (grhs_class == GIMPLE_BINARY_RHS)\n     t = build2 (gimple_assign_rhs_code (stmt),\n \t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n \t\tgimple_assign_rhs1 (stmt),\n@@ -1889,6 +1895,9 @@ expand_gimple_stmt_1 (gimple stmt)\n \t    ops.type = TREE_TYPE (lhs);\n \t    switch (get_gimple_rhs_class (gimple_expr_code (stmt)))\n \t      {\n+\t\tcase GIMPLE_TERNARY_RHS:\n+\t\t  ops.op2 = gimple_assign_rhs3 (stmt);\n+\t\t  /* Fallthru */\n \t\tcase GIMPLE_BINARY_RHS:\n \t\t  ops.op1 = gimple_assign_rhs2 (stmt);\n \t\t  /* Fallthru */\n@@ -2239,6 +2248,8 @@ expand_debug_expr (tree exp)\n \t{\n \tcase COND_EXPR:\n \tcase DOT_PROD_EXPR:\n+\tcase WIDEN_MULT_PLUS_EXPR:\n+\tcase WIDEN_MULT_MINUS_EXPR:\n \t  goto ternary;\n \n \tcase TRUTH_ANDIF_EXPR:\n@@ -3025,6 +3036,8 @@ expand_debug_expr (tree exp)\n       return NULL;\n \n     case WIDEN_MULT_EXPR:\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n       if (SCALAR_INT_MODE_P (GET_MODE (op0))\n \t  && SCALAR_INT_MODE_P (mode))\n \t{\n@@ -3037,7 +3050,13 @@ expand_debug_expr (tree exp)\n \t    op1 = simplify_gen_unary (ZERO_EXTEND, mode, op1, inner_mode);\n \t  else\n \t    op1 = simplify_gen_unary (SIGN_EXTEND, mode, op1, inner_mode);\n-\t  return gen_rtx_MULT (mode, op0, op1);\n+\t  op0 = gen_rtx_MULT (mode, op0, op1);\n+\t  if (TREE_CODE (exp) == WIDEN_MULT_EXPR)\n+\t    return op0;\n+\t  else if (TREE_CODE (exp) == WIDEN_MULT_PLUS_EXPR)\n+\t    return gen_rtx_PLUS (mode, op0, op2);\n+\t  else\n+\t    return gen_rtx_MINUS (mode, op2, op0);\n \t}\n       return NULL;\n "}, {"sha": "984f00bd65aa4d0a44b2495ff6a2d06e519abf9a", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -546,6 +546,9 @@ gimple_rhs_class}\n @item @code{GIMPLE_INVALID_RHS}\n The tree cannot be used as a GIMPLE operand.\n \n+@item @code{GIMPLE_TERNARY_RHS}\n+The tree is a valid GIMPLE ternary operation.\n+\n @item @code{GIMPLE_BINARY_RHS}\n The tree is a valid GIMPLE binary operation.\n \n@@ -567,10 +570,11 @@ from @code{c = a op b ? x : y}.  Something similar occurs with\n expressions should be flattened into the operand vector.\n @end itemize\n \n-For tree nodes in the categories @code{GIMPLE_BINARY_RHS} and\n-@code{GIMPLE_UNARY_RHS}, they cannot be stored inside tuples directly.\n-They first need to be flattened and separated into individual\n-components.  For instance, given the GENERIC expression\n+For tree nodes in the categories @code{GIMPLE_TERNARY_RHS},\n+@code{GIMPLE_BINARY_RHS} and @code{GIMPLE_UNARY_RHS}, they cannot be\n+stored inside tuples directly.  They first need to be flattened and\n+separated into individual components.  For instance, given the GENERIC\n+expression\n \n @smallexample\n a = b + c\n@@ -1073,7 +1077,16 @@ Return the second operand on the @code{RHS} of assignment statement @code{G}.\n Return the address of the second operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_assign_rhs3 (gimple g)\n+Return the third operand on the @code{RHS} of assignment statement @code{G}.\n+@end deftypefn\n  \n+@deftypefn {GIMPLE function} tree *gimple_assign_rhs3_ptr (gimple g)\n+Return the address of the third operand on the @code{RHS} of assignment\n+statement @code{G}.\n+@end deftypefn\n+\n @deftypefn {GIMPLE function} void gimple_assign_set_lhs (gimple g, tree lhs)\n Set @code{LHS} to be the @code{LHS} operand of assignment statement @code{G}.\n @end deftypefn\n@@ -1083,17 +1096,13 @@ Set @code{RHS} to be the first operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree gimple_assign_rhs2 (gimple g)\n-Return the second operand on the @code{RHS} of assignment statement @code{G}.\n-@end deftypefn\n- \n-@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)\n-Return a pointer to the second operand on the @code{RHS} of assignment\n+@deftypefn {GIMPLE function} void gimple_assign_set_rhs2 (gimple g, tree rhs)\n+Set @code{RHS} to be the second operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} void gimple_assign_set_rhs2 (gimple g, tree rhs)\n-Set @code{RHS} to be the second operand on the @code{RHS} of assignment\n+@deftypefn {GIMPLE function} void gimple_assign_set_rhs3 (gimple g, tree rhs)\n+Set @code{RHS} to be the third operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n  "}, {"sha": "4f659872574e3e461800698b95d1cb0dcc3b932f", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 106, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -7239,8 +7239,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n   rtx subtarget, original_target;\n   int ignore;\n   bool reduce_bit_field;\n-  gimple subexp0_def, subexp1_def;\n-  tree top0, top1;\n   location_t loc = ops->location;\n   tree treeop0, treeop1;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n@@ -7260,7 +7258,8 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n      exactly those that are valid in gimple expressions that aren't\n      GIMPLE_SINGLE_RHS (or invalid).  */\n   gcc_assert (get_gimple_rhs_class (code) == GIMPLE_UNARY_RHS\n-\t      || get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS);\n+\t      || get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS\n+\t      || get_gimple_rhs_class (code) == GIMPLE_TERNARY_RHS);\n \n   ignore = (target == const0_rtx\n \t    || ((CONVERT_EXPR_CODE_P (code)\n@@ -7435,58 +7434,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t\t\t    fold_convert_loc (loc, ssizetype,\n \t\t\t\t\t\t      treeop1));\n     case PLUS_EXPR:\n-\n-      /* Check if this is a case for multiplication and addition.  */\n-      if ((TREE_CODE (type) == INTEGER_TYPE\n-\t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n-\t  && (subexp0_def = get_def_for_expr (treeop0,\n-\t\t\t\t\t      MULT_EXPR)))\n-\t{\n-\t  tree subsubexp0, subsubexp1;\n-\t  gimple subsubexp0_def, subsubexp1_def;\n-\t  enum tree_code this_code;\n-\n-\t  this_code = TREE_CODE (type) == INTEGER_TYPE ? NOP_EXPR\n-\t\t\t\t\t\t       : FIXED_CONVERT_EXPR;\n-\t  subsubexp0 = gimple_assign_rhs1 (subexp0_def);\n-\t  subsubexp0_def = get_def_for_expr (subsubexp0, this_code);\n-\t  subsubexp1 = gimple_assign_rhs2 (subexp0_def);\n-\t  subsubexp1_def = get_def_for_expr (subsubexp1, this_code);\n-\t  if (subsubexp0_def && subsubexp1_def\n-\t      && (top0 = gimple_assign_rhs1 (subsubexp0_def))\n-\t      && (top1 = gimple_assign_rhs1 (subsubexp1_def))\n-\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t\t  < TYPE_PRECISION (TREE_TYPE (subsubexp0)))\n-\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (top1)))\n-\t      && (TYPE_UNSIGNED (TREE_TYPE (top0))\n-\t\t  == TYPE_UNSIGNED (TREE_TYPE (top1))))\n-\t    {\n-\t      tree op0type = TREE_TYPE (top0);\n-\t      enum machine_mode innermode = TYPE_MODE (op0type);\n-\t      bool zextend_p = TYPE_UNSIGNED (op0type);\n-\t      bool sat_p = TYPE_SATURATING (TREE_TYPE (subsubexp0));\n-\t      if (sat_p == 0)\n-\t\tthis_optab = zextend_p ? umadd_widen_optab : smadd_widen_optab;\n-\t      else\n-\t\tthis_optab = zextend_p ? usmadd_widen_optab\n-\t\t\t\t       : ssmadd_widen_optab;\n-\t      if (mode == GET_MODE_2XWIDER_MODE (innermode)\n-\t\t  && (optab_handler (this_optab, mode)->insn_code\n-\t\t      != CODE_FOR_nothing))\n-\t\t{\n-\t\t  expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n-\t\t\t\t   EXPAND_NORMAL);\n-\t\t  op2 = expand_expr (treeop1, subtarget,\n-\t\t\t\t     VOIDmode, EXPAND_NORMAL);\n-\t\t  temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n-\t\t\t\t\t    target, unsignedp);\n-\t\t  gcc_assert (temp);\n-\t\t  return REDUCE_BIT_FIELD (temp);\n-\t\t}\n-\t    }\n-\t}\n-\n       /* If we are adding a constant, a VAR_DECL that is sp, fp, or ap, and\n \t something else, make sure we add the register to the constant and\n \t then to the other thing.  This case can occur during strength\n@@ -7601,57 +7548,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n       return REDUCE_BIT_FIELD (simplify_gen_binary (PLUS, mode, op0, op1));\n \n     case MINUS_EXPR:\n-      /* Check if this is a case for multiplication and subtraction.  */\n-      if ((TREE_CODE (type) == INTEGER_TYPE\n-\t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n-\t  && (subexp1_def = get_def_for_expr (treeop1,\n-\t\t\t\t\t      MULT_EXPR)))\n-\t{\n-\t  tree subsubexp0, subsubexp1;\n-\t  gimple subsubexp0_def, subsubexp1_def;\n-\t  enum tree_code this_code;\n-\n-\t  this_code = TREE_CODE (type) == INTEGER_TYPE ? NOP_EXPR\n-\t\t\t\t\t\t       : FIXED_CONVERT_EXPR;\n-\t  subsubexp0 = gimple_assign_rhs1 (subexp1_def);\n-\t  subsubexp0_def = get_def_for_expr (subsubexp0, this_code);\n-\t  subsubexp1 = gimple_assign_rhs2 (subexp1_def);\n-\t  subsubexp1_def = get_def_for_expr (subsubexp1, this_code);\n-\t  if (subsubexp0_def && subsubexp1_def\n-\t      && (top0 = gimple_assign_rhs1 (subsubexp0_def))\n-\t      && (top1 = gimple_assign_rhs1 (subsubexp1_def))\n-\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t\t  < TYPE_PRECISION (TREE_TYPE (subsubexp0)))\n-\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (top1)))\n-\t      && (TYPE_UNSIGNED (TREE_TYPE (top0))\n-\t\t  == TYPE_UNSIGNED (TREE_TYPE (top1))))\n-\t    {\n-\t      tree op0type = TREE_TYPE (top0);\n-\t      enum machine_mode innermode = TYPE_MODE (op0type);\n-\t      bool zextend_p = TYPE_UNSIGNED (op0type);\n-\t      bool sat_p = TYPE_SATURATING (TREE_TYPE (subsubexp0));\n-\t      if (sat_p == 0)\n-\t\tthis_optab = zextend_p ? umsub_widen_optab : smsub_widen_optab;\n-\t      else\n-\t\tthis_optab = zextend_p ? usmsub_widen_optab\n-\t\t\t\t       : ssmsub_widen_optab;\n-\t      if (mode == GET_MODE_2XWIDER_MODE (innermode)\n-\t\t  && (optab_handler (this_optab, mode)->insn_code\n-\t\t      != CODE_FOR_nothing))\n-\t\t{\n-\t\t  expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n-\t\t\t\t   EXPAND_NORMAL);\n-\t\t  op2 = expand_expr (treeop0, subtarget,\n-\t\t\t\t     VOIDmode, EXPAND_NORMAL);\n-\t\t  temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n-\t\t\t\t\t    target, unsignedp);\n-\t\t  gcc_assert (temp);\n-\t\t  return REDUCE_BIT_FIELD (temp);\n-\t\t}\n-\t    }\n-\t}\n-\n       /* For initializers, we are allowed to return a MINUS of two\n \t symbolic constants.  Here we handle all cases when both operands\n \t are constant.  */\n@@ -7692,6 +7588,14 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n       goto binop2;\n \n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n+      expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+      op2 = expand_normal (ops->op2);\n+      target = expand_widen_pattern_expr (ops, op0, op1, op2,\n+\t\t\t\t\t  target, unsignedp);\n+      return target;\n+\n     case WIDEN_MULT_EXPR:\n       /* If first operand is constant, swap them.\n \t Thus the following special case checks need only"}, {"sha": "a37b4a3bd65c9ea9df926f3797bc3540bf10df59", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -986,6 +986,33 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n         }\n       break;\n \n+    case GIMPLE_TERNARY_RHS:\n+      result = fold_ternary_loc (loc, subcode,\n+\t\t\t\t TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t\t gimple_assign_rhs1 (stmt),\n+\t\t\t\t gimple_assign_rhs2 (stmt),\n+\t\t\t\t gimple_assign_rhs3 (stmt));\n+\n+      if (result)\n+        {\n+          STRIP_USELESS_TYPE_CONVERSION (result);\n+          if (valid_gimple_rhs_p (result))\n+\t    return result;\n+\n+\t  /* Fold might have produced non-GIMPLE, so if we trust it blindly\n+\t     we lose canonicalization opportunities.  Do not go again\n+\t     through fold here though, or the same non-GIMPLE will be\n+\t     produced.  */\n+          if (commutative_ternary_tree_code (subcode)\n+              && tree_swap_operands_p (gimple_assign_rhs1 (stmt),\n+                                       gimple_assign_rhs2 (stmt), false))\n+            return build3 (subcode, TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t   gimple_assign_rhs2 (stmt),\n+\t\t\t   gimple_assign_rhs1 (stmt),\n+\t\t\t   gimple_assign_rhs3 (stmt));\n+        }\n+      break;\n+\n     case GIMPLE_INVALID_RHS:\n       gcc_unreachable ();\n     }"}, {"sha": "491eae3b51bf01d71657bfaabb9f251be3c45eb1", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -377,6 +377,34 @@ dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n     }\n }\n \n+/* Helper for dump_gimple_assign.  Print the ternary RHS of the\n+   assignment GS.  BUFFER, SPC and FLAGS are as in dump_gimple_stmt.  */\n+\n+static void\n+dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  const char *p;\n+  enum tree_code code = gimple_assign_rhs_code (gs);\n+  switch (code)\n+    {\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n+      for (p = tree_code_name [(int) code]; *p; p++)\n+\tpp_character (buffer, TOUPPER (*p));\n+      pp_string (buffer, \" <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n+      pp_character (buffer, '>');\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n \n /* Dump the gimple assignment GS.  BUFFER, SPC and FLAGS are as in\n    dump_gimple_stmt.  */\n@@ -419,6 +447,8 @@ dump_gimple_assign (pretty_printer *buffer, gimple gs, int spc, int flags)\n         dump_unary_rhs (buffer, gs, spc, flags);\n       else if (gimple_num_ops (gs) == 3)\n         dump_binary_rhs (buffer, gs, spc, flags);\n+      else if (gimple_num_ops (gs) == 4)\n+        dump_ternary_rhs (buffer, gs, spc, flags);\n       else\n         gcc_unreachable ();\n       if (!(flags & TDF_RHS_ONLY))"}, {"sha": "0a5f6fb97d13982a35871a19249e2d9c91582f64", "filename": "gcc/gimple.c", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -305,31 +305,40 @@ gimple_build_call_from_tree (tree t)\n \n \n /* Extract the operands and code for expression EXPR into *SUBCODE_P,\n-   *OP1_P and *OP2_P respectively.  */\n+   *OP1_P, *OP2_P and *OP3_P respectively.  */\n \n void\n-extract_ops_from_tree (tree expr, enum tree_code *subcode_p, tree *op1_p,\n-\t\t       tree *op2_p)\n+extract_ops_from_tree_1 (tree expr, enum tree_code *subcode_p, tree *op1_p,\n+\t\t\t tree *op2_p, tree *op3_p)\n {\n   enum gimple_rhs_class grhs_class;\n \n   *subcode_p = TREE_CODE (expr);\n   grhs_class = get_gimple_rhs_class (*subcode_p);\n \n-  if (grhs_class == GIMPLE_BINARY_RHS)\n+  if (grhs_class == GIMPLE_TERNARY_RHS)\n     {\n       *op1_p = TREE_OPERAND (expr, 0);\n       *op2_p = TREE_OPERAND (expr, 1);\n+      *op3_p = TREE_OPERAND (expr, 2);\n+    }\n+  else if (grhs_class == GIMPLE_BINARY_RHS)\n+    {\n+      *op1_p = TREE_OPERAND (expr, 0);\n+      *op2_p = TREE_OPERAND (expr, 1);\n+      *op3_p = NULL_TREE;\n     }\n   else if (grhs_class == GIMPLE_UNARY_RHS)\n     {\n       *op1_p = TREE_OPERAND (expr, 0);\n       *op2_p = NULL_TREE;\n+      *op3_p = NULL_TREE;\n     }\n   else if (grhs_class == GIMPLE_SINGLE_RHS)\n     {\n       *op1_p = expr;\n       *op2_p = NULL_TREE;\n+      *op3_p = NULL_TREE;\n     }\n   else\n     gcc_unreachable ();\n@@ -345,10 +354,10 @@ gimple\n gimple_build_assign_stat (tree lhs, tree rhs MEM_STAT_DECL)\n {\n   enum tree_code subcode;\n-  tree op1, op2;\n+  tree op1, op2, op3;\n \n-  extract_ops_from_tree (rhs, &subcode, &op1, &op2);\n-  return gimple_build_assign_with_ops_stat (subcode, lhs, op1, op2\n+  extract_ops_from_tree_1 (rhs, &subcode, &op1, &op2, &op3);\n+  return gimple_build_assign_with_ops_stat (subcode, lhs, op1, op2, op3\n   \t\t\t\t\t    PASS_MEM_STAT);\n }\n \n@@ -359,7 +368,7 @@ gimple_build_assign_stat (tree lhs, tree rhs MEM_STAT_DECL)\n \n gimple\n gimple_build_assign_with_ops_stat (enum tree_code subcode, tree lhs, tree op1,\n-                                   tree op2 MEM_STAT_DECL)\n+                                   tree op2, tree op3 MEM_STAT_DECL)\n {\n   unsigned num_ops;\n   gimple p;\n@@ -378,6 +387,12 @@ gimple_build_assign_with_ops_stat (enum tree_code subcode, tree lhs, tree op1,\n       gimple_assign_set_rhs2 (p, op2);\n     }\n \n+  if (op3)\n+    {\n+      gcc_assert (num_ops > 3);\n+      gimple_assign_set_rhs3 (p, op3);\n+    }\n+\n   return p;\n }\n \n@@ -1955,22 +1970,22 @@ void\n gimple_assign_set_rhs_from_tree (gimple_stmt_iterator *gsi, tree expr)\n {\n   enum tree_code subcode;\n-  tree op1, op2;\n+  tree op1, op2, op3;\n \n-  extract_ops_from_tree (expr, &subcode, &op1, &op2);\n-  gimple_assign_set_rhs_with_ops (gsi, subcode, op1, op2);\n+  extract_ops_from_tree_1 (expr, &subcode, &op1, &op2, &op3);\n+  gimple_assign_set_rhs_with_ops_1 (gsi, subcode, op1, op2, op3);\n }\n \n \n /* Set the RHS of assignment statement pointed-to by GSI to CODE with\n-   operands OP1 and OP2.\n+   operands OP1, OP2 and OP3.\n \n    NOTE: The statement pointed-to by GSI may be reallocated if it\n    did not have enough operand slots.  */\n \n void\n-gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n-\t\t\t\ttree op1, tree op2)\n+gimple_assign_set_rhs_with_ops_1 (gimple_stmt_iterator *gsi, enum tree_code code,\n+\t\t\t\t  tree op1, tree op2, tree op3)\n {\n   unsigned new_rhs_ops = get_gimple_rhs_num_ops (code);\n   gimple stmt = gsi_stmt (*gsi);\n@@ -1994,6 +2009,8 @@ gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n   gimple_assign_set_rhs1 (stmt, op1);\n   if (new_rhs_ops > 1)\n     gimple_assign_set_rhs2 (stmt, op2);\n+  if (new_rhs_ops > 2)\n+    gimple_assign_set_rhs3 (stmt, op3);\n }\n \n \n@@ -2473,6 +2490,8 @@ get_gimple_rhs_num_ops (enum tree_code code)\n     return 1;\n   else if (rhs_class == GIMPLE_BINARY_RHS)\n     return 2;\n+  else if (rhs_class == GIMPLE_TERNARY_RHS)\n+    return 3;\n   else\n     gcc_unreachable ();\n }\n@@ -2489,6 +2508,8 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == TRUTH_OR_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == TRUTH_XOR_EXPR) ? GIMPLE_BINARY_RHS\t\t\t    \\\n    : (SYM) == TRUTH_NOT_EXPR ? GIMPLE_UNARY_RHS\t\t\t\t    \\\n+   : ((SYM) == WIDEN_MULT_PLUS_EXPR\t\t\t\t\t    \\\n+      || (SYM) == WIDEN_MULT_MINUS_EXPR) ? GIMPLE_TERNARY_RHS\t\t    \\\n    : ((SYM) == COND_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == CONSTRUCTOR\t\t\t\t\t\t    \\\n       || (SYM) == OBJ_TYPE_REF\t\t\t\t\t\t    \\"}, {"sha": "ffc344178d73c963a7cdddf410c22a63cc54c517", "filename": "gcc/gimple.h", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -77,6 +77,7 @@ extern void gimple_check_failed (const_gimple, const char *, int,          \\\n enum gimple_rhs_class\n {\n   GIMPLE_INVALID_RHS,\t/* The expression cannot be used on the RHS.  */\n+  GIMPLE_TERNARY_RHS,\t/* The expression is a ternary operation.  */\n   GIMPLE_BINARY_RHS,\t/* The expression is a binary operation.  */\n   GIMPLE_UNARY_RHS,\t/* The expression is a unary operation.  */\n   GIMPLE_SINGLE_RHS\t/* The expression is a single object (an SSA\n@@ -803,12 +804,14 @@ gimple gimple_build_return (tree);\n gimple gimple_build_assign_stat (tree, tree MEM_STAT_DECL);\n #define gimple_build_assign(l,r) gimple_build_assign_stat (l, r MEM_STAT_INFO)\n \n-void extract_ops_from_tree (tree, enum tree_code *, tree *, tree *);\n+void extract_ops_from_tree_1 (tree, enum tree_code *, tree *, tree *, tree *);\n \n gimple gimple_build_assign_with_ops_stat (enum tree_code, tree, tree,\n-\t\t\t\t\t  tree MEM_STAT_DECL);\n-#define gimple_build_assign_with_ops(c,o1,o2,o3) \\\n-  gimple_build_assign_with_ops_stat (c, o1, o2, o3 MEM_STAT_INFO)\n+\t\t\t\t\t  tree, tree MEM_STAT_DECL);\n+#define gimple_build_assign_with_ops(c,o1,o2,o3)\t\t\t\\\n+  gimple_build_assign_with_ops_stat (c, o1, o2, o3, NULL_TREE MEM_STAT_INFO)\n+#define gimple_build_assign_with_ops3(c,o1,o2,o3,o4)\t\t\t\\\n+  gimple_build_assign_with_ops_stat (c, o1, o2, o3, o4 MEM_STAT_INFO)\n \n gimple gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n #define gimple_build_debug_bind(var,val,stmt)\t\t\t\\\n@@ -870,8 +873,8 @@ bool gimple_assign_single_p (gimple);\n bool gimple_assign_unary_nop_p (gimple);\n void gimple_set_bb (gimple, struct basic_block_def *);\n void gimple_assign_set_rhs_from_tree (gimple_stmt_iterator *, tree);\n-void gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *, enum tree_code,\n-\t\t\t\t     tree, tree);\n+void gimple_assign_set_rhs_with_ops_1 (gimple_stmt_iterator *, enum tree_code,\n+\t\t\t\t       tree, tree, tree);\n tree gimple_get_lhs (const_gimple);\n void gimple_set_lhs (gimple, tree);\n void gimple_replace_lhs (gimple, tree);\n@@ -1810,6 +1813,63 @@ gimple_assign_set_rhs2 (gimple gs, tree rhs)\n   gimple_set_op (gs, 2, rhs);\n }\n \n+/* Return the third operand on the RHS of assignment statement GS.\n+   If GS does not have two operands, NULL is returned instead.  */\n+\n+static inline tree\n+gimple_assign_rhs3 (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n+\n+  if (gimple_num_ops (gs) >= 4)\n+    return gimple_op (gs, 3);\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Return a pointer to the third operand on the RHS of assignment\n+   statement GS.  */\n+\n+static inline tree *\n+gimple_assign_rhs3_ptr (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n+  return gimple_op_ptr (gs, 3);\n+}\n+\n+\n+/* Set RHS to be the third operand on the RHS of assignment statement GS.  */\n+\n+static inline void\n+gimple_assign_set_rhs3 (gimple gs, tree rhs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_ASSIGN);\n+\n+  gimple_set_op (gs, 3, rhs);\n+}\n+\n+/* A wrapper around gimple_assign_set_rhs_with_ops_1, for callers which expect\n+   to see only a maximum of two operands.  */\n+\n+static inline void\n+gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n+\t\t\t\ttree op1, tree op2)\n+{\n+  gimple_assign_set_rhs_with_ops_1 (gsi, code, op1, op2, NULL);\n+}\n+\n+/* A wrapper around extract_ops_from_tree_1, for callers which expect\n+   to see only a maximum of two operands.  */\n+\n+static inline void\n+extract_ops_from_tree (tree expr, enum tree_code *code, tree *op0,\n+\t\t       tree *op1)\n+{\n+  tree op2;\n+  extract_ops_from_tree_1 (expr, code, op0, op1, &op2);\n+  gcc_assert (op2 == NULL_TREE);\n+}\n+\n /* Returns true if GS is a nontemporal move.  */\n \n static inline bool"}, {"sha": "38de4916c100e3c16c5a26143233c782c3246450", "filename": "gcc/optabs.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -407,6 +407,20 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     case DOT_PROD_EXPR:\n       return TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab;\n \n+    case WIDEN_MULT_PLUS_EXPR:\n+      return (TYPE_UNSIGNED (type)\n+\t      ? (TYPE_SATURATING (type)\n+\t\t ? usmadd_widen_optab : umadd_widen_optab)\n+\t      : (TYPE_SATURATING (type)\n+\t\t ? ssmadd_widen_optab : smadd_widen_optab));\n+\n+    case WIDEN_MULT_MINUS_EXPR:\n+      return (TYPE_UNSIGNED (type)\n+\t      ? (TYPE_SATURATING (type)\n+\t\t ? usmsub_widen_optab : umsub_widen_optab)\n+\t      : (TYPE_SATURATING (type)\n+\t\t ? ssmsub_widen_optab : smsub_widen_optab));\n+\n     case REDUC_MAX_EXPR:\n       return TYPE_UNSIGNED (type) ? reduc_umax_optab : reduc_smax_optab;\n \n@@ -546,7 +560,12 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));\n   widen_pattern_optab =\n     optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n-  icode = (int) optab_handler (widen_pattern_optab, tmode0)->insn_code;\n+  if (ops->code == WIDEN_MULT_PLUS_EXPR\n+      || ops->code == WIDEN_MULT_MINUS_EXPR)\n+    icode = (int) optab_handler (widen_pattern_optab,\n+\t\t\t\t TYPE_MODE (TREE_TYPE (ops->op2)))->insn_code;\n+  else\n+    icode = (int) optab_handler (widen_pattern_optab, tmode0)->insn_code;\n   gcc_assert (icode != CODE_FOR_nothing);\n   xmode0 = insn_data[icode].operand[1].mode;\n "}, {"sha": "9a397e2d1ec51d1c2d61c22a882f42943e8d8738", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -1,3 +1,9 @@\n+2010-06-25  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tFrom Jim Wilson:\n+\tPR target/43902\n+\t* gcc.target/mips/madd-9.c: New test.\n+\n 2010-06-25  Shujing Zhao  <pearly.zhao@oracle.com>\n \n \tPR c/44517"}, {"sha": "25dbd18a5106c6dc6f23efafb8a837be9eb6f4fc", "filename": "gcc/testsuite/gcc.target/mips/madd-9.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmadd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmadd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmadd-9.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 isa_rev>=1 -mgp32\" } */\n+/* { dg-final { scan-assembler-not \"\\tmul\\t\" } } */\n+/* { dg-final { scan-assembler \"\\tmadd\\t\" } } */\n+\n+NOMIPS16 long long\n+f1 (int *a, int *b, int n)\n+{\n+  long long int x;\n+  int i;\n+\n+  x = 0;\n+  for (i = 0; i < n; i++)\n+    x += (long long) a[i] * b[i];\n+  return x;\n+}"}, {"sha": "943aa5a9164efb0e6ce238fa7c24fab56ae5bb99", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -3533,6 +3533,65 @@ verify_gimple_assign_binary (gimple stmt)\n   return false;\n }\n \n+/* Verify a gimple assignment statement STMT with a ternary rhs.\n+   Returns true if anything is wrong.  */\n+\n+static bool\n+verify_gimple_assign_ternary (gimple stmt)\n+{\n+  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree lhs_type = TREE_TYPE (lhs);\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs1_type = TREE_TYPE (rhs1);\n+  tree rhs2 = gimple_assign_rhs2 (stmt);\n+  tree rhs2_type = TREE_TYPE (rhs2);\n+  tree rhs3 = gimple_assign_rhs3 (stmt);\n+  tree rhs3_type = TREE_TYPE (rhs3);\n+\n+  if (!is_gimple_reg (lhs)\n+      && !(optimize == 0\n+\t   && TREE_CODE (lhs_type) == COMPLEX_TYPE))\n+    {\n+      error (\"non-register as LHS of ternary operation\");\n+      return true;\n+    }\n+\n+  if (!is_gimple_val (rhs1)\n+      || !is_gimple_val (rhs2)\n+      || !is_gimple_val (rhs3))\n+    {\n+      error (\"invalid operands in ternary operation\");\n+      return true;\n+    }\n+\n+  /* First handle operations that involve different types.  */\n+  switch (rhs_code)\n+    {\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n+      if ((!INTEGRAL_TYPE_P (rhs1_type)\n+\t   && !FIXED_POINT_TYPE_P (rhs1_type))\n+\t  || !useless_type_conversion_p (rhs1_type, rhs2_type)\n+\t  || !useless_type_conversion_p (lhs_type, rhs3_type)\n+\t  || 2 * TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (lhs_type)\n+\t  || TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (rhs2_type))\n+\t{\n+\t  error (\"type mismatch in widening multiply-accumulate expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n /* Verify a gimple assignment statement STMT with a single rhs.\n    Returns true if anything is wrong.  */\n \n@@ -3679,6 +3738,9 @@ verify_gimple_assign (gimple stmt)\n     case GIMPLE_BINARY_RHS:\n       return verify_gimple_assign_binary (stmt);\n \n+    case GIMPLE_TERNARY_RHS:\n+      return verify_gimple_assign_ternary (stmt);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "bbbaa40d15e07452cb57ab070a7e9e1cc96f3e7f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -3238,6 +3238,8 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case WIDEN_SUM_EXPR:\n     case WIDEN_MULT_EXPR:\n     case DOT_PROD_EXPR:\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n \n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:"}, {"sha": "f7bbef43a1852668ac5f74e976a86f692eaf1f4d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -1947,6 +1947,26 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case WIDEN_MULT_PLUS_EXPR:\n+      pp_string (buffer, \" WIDEN_MULT_PLUS_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case WIDEN_MULT_MINUS_EXPR:\n+      pp_string (buffer, \" WIDEN_MULT_MINUS_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     case OMP_PARALLEL:\n       pp_string (buffer, \"#pragma omp parallel\");\n       dump_omp_clauses (buffer, OMP_PARALLEL_CLAUSES (node), spc, flags);\n@@ -2440,6 +2460,8 @@ op_code_prio (enum tree_code code)\n     case VEC_WIDEN_MULT_LO_EXPR:\n     case WIDEN_MULT_EXPR:\n     case DOT_PROD_EXPR:\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:"}, {"sha": "be4509c237c255e5037fd79809e7228c9f510e71", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -839,6 +839,23 @@ ccp_visit_phi_node (gimple phi)\n     return SSA_PROP_NOT_INTERESTING;\n }\n \n+/* Get operand number OPNR from the rhs of STMT.  Before returning it,\n+   simplify it to a constant if possible.  */\n+\n+static tree\n+get_rhs_assign_op_for_ccp (gimple stmt, int opnr)\n+{\n+  tree op = gimple_op (stmt, opnr);\n+  \n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      prop_value_t *val = get_value (op);\n+      if (val->lattice_val == CONSTANT)\n+\top = get_value (op)->value;\n+    }\n+  return op;\n+}\n+\n /* CCP specific front-end to the non-destructive constant folding\n    routines.\n \n@@ -961,15 +978,7 @@ ccp_fold (gimple stmt)\n                  Note that we know the single operand must be a constant,\n                  so this should almost always return a simplified RHS.  */\n               tree lhs = gimple_assign_lhs (stmt);\n-              tree op0 = gimple_assign_rhs1 (stmt);\n-\n-              /* Simplify the operand down to a constant.  */\n-              if (TREE_CODE (op0) == SSA_NAME)\n-                {\n-                  prop_value_t *val = get_value (op0);\n-                  if (val->lattice_val == CONSTANT)\n-                    op0 = get_value (op0)->value;\n-                }\n+              tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n \n \t      /* Conversions are useless for CCP purposes if they are\n \t\t value-preserving.  Thus the restrictions that\n@@ -1006,23 +1015,8 @@ ccp_fold (gimple stmt)\n           case GIMPLE_BINARY_RHS:\n             {\n               /* Handle binary operators that can appear in GIMPLE form.  */\n-              tree op0 = gimple_assign_rhs1 (stmt);\n-              tree op1 = gimple_assign_rhs2 (stmt);\n-\n-              /* Simplify the operands down to constants when appropriate.  */\n-              if (TREE_CODE (op0) == SSA_NAME)\n-                {\n-                  prop_value_t *val = get_value (op0);\n-                  if (val->lattice_val == CONSTANT)\n-                    op0 = val->value;\n-                }\n-\n-              if (TREE_CODE (op1) == SSA_NAME)\n-                {\n-                  prop_value_t *val = get_value (op1);\n-                  if (val->lattice_val == CONSTANT)\n-                    op1 = val->value;\n-                }\n+              tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n+              tree op1 = get_rhs_assign_op_for_ccp (stmt, 2);\n \n \t      /* Fold &foo + CST into an invariant reference if possible.  */\n \t      if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n@@ -1039,6 +1033,17 @@ ccp_fold (gimple stmt)\n \t\t\t\t  gimple_expr_type (stmt), op0, op1);\n             }\n \n+          case GIMPLE_TERNARY_RHS:\n+            {\n+              /* Handle binary operators that can appear in GIMPLE form.  */\n+              tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n+              tree op1 = get_rhs_assign_op_for_ccp (stmt, 2);\n+              tree op2 = get_rhs_assign_op_for_ccp (stmt, 3);\n+\n+              return fold_ternary_loc (loc, subcode,\n+\t\t\t\t       gimple_expr_type (stmt), op0, op1, op2);\n+            }\n+\n           default:\n             gcc_unreachable ();\n           }"}, {"sha": "d15df31238d6b057599dc8bbe68757ca766dd305", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 82, "deletions": 32, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -51,6 +51,7 @@ enum expr_kind\n   EXPR_SINGLE,\n   EXPR_UNARY,\n   EXPR_BINARY,\n+  EXPR_TERNARY,\n   EXPR_CALL\n };\n \n@@ -61,7 +62,8 @@ struct hashable_expr\n   union {\n     struct { tree rhs; } single;\n     struct { enum tree_code op;  tree opnd; } unary;\n-    struct { enum tree_code op;  tree opnd0; tree opnd1; } binary;\n+    struct { enum tree_code op;  tree opnd0, opnd1; } binary;\n+    struct { enum tree_code op;  tree opnd0, opnd1, opnd2; } ternary;\n     struct { tree fn; bool pure; size_t nargs; tree *args; } call;\n   } ops;\n };\n@@ -211,22 +213,30 @@ initialize_hash_element (gimple stmt, tree lhs,\n       switch (get_gimple_rhs_class (subcode))\n         {\n         case GIMPLE_SINGLE_RHS:\n-          expr->kind = EXPR_SINGLE;\n-          expr->ops.single.rhs = gimple_assign_rhs1 (stmt);\n-          break;\n+\t  expr->kind = EXPR_SINGLE;\n+\t  expr->ops.single.rhs = gimple_assign_rhs1 (stmt);\n+\t  break;\n         case GIMPLE_UNARY_RHS:\n-          expr->kind = EXPR_UNARY;\n+\t  expr->kind = EXPR_UNARY;\n \t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n-          expr->ops.unary.op = subcode;\n-          expr->ops.unary.opnd = gimple_assign_rhs1 (stmt);\n-          break;\n+\t  expr->ops.unary.op = subcode;\n+\t  expr->ops.unary.opnd = gimple_assign_rhs1 (stmt);\n+\t  break;\n         case GIMPLE_BINARY_RHS:\n-          expr->kind = EXPR_BINARY;\n+\t  expr->kind = EXPR_BINARY;\n \t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n-          expr->ops.binary.op = subcode;\n-          expr->ops.binary.opnd0 = gimple_assign_rhs1 (stmt);\n-          expr->ops.binary.opnd1 = gimple_assign_rhs2 (stmt);\n-          break;\n+\t  expr->ops.binary.op = subcode;\n+\t  expr->ops.binary.opnd0 = gimple_assign_rhs1 (stmt);\n+\t  expr->ops.binary.opnd1 = gimple_assign_rhs2 (stmt);\n+\t  break;\n+        case GIMPLE_TERNARY_RHS:\n+\t  expr->kind = EXPR_TERNARY;\n+\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t  expr->ops.ternary.op = subcode;\n+\t  expr->ops.ternary.opnd0 = gimple_assign_rhs1 (stmt);\n+\t  expr->ops.ternary.opnd1 = gimple_assign_rhs2 (stmt);\n+\t  expr->ops.ternary.opnd2 = gimple_assign_rhs3 (stmt);\n+\t  break;\n         default:\n           gcc_unreachable ();\n         }\n@@ -371,23 +381,40 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n                               expr1->ops.unary.opnd, 0);\n \n     case EXPR_BINARY:\n-      {\n-        if (expr0->ops.binary.op != expr1->ops.binary.op)\n-          return false;\n-\n-        if (operand_equal_p (expr0->ops.binary.opnd0,\n-                             expr1->ops.binary.opnd0, 0)\n-            && operand_equal_p (expr0->ops.binary.opnd1,\n-                                expr1->ops.binary.opnd1, 0))\n-          return true;\n-\n-        /* For commutative ops, allow the other order.  */\n-        return (commutative_tree_code (expr0->ops.binary.op)\n-                && operand_equal_p (expr0->ops.binary.opnd0,\n-                                    expr1->ops.binary.opnd1, 0)\n-                && operand_equal_p (expr0->ops.binary.opnd1,\n-                                    expr1->ops.binary.opnd0, 0));\n-      }\n+      if (expr0->ops.binary.op != expr1->ops.binary.op)\n+\treturn false;\n+\n+      if (operand_equal_p (expr0->ops.binary.opnd0,\n+\t\t\t   expr1->ops.binary.opnd0, 0)\n+\t  && operand_equal_p (expr0->ops.binary.opnd1,\n+\t\t\t      expr1->ops.binary.opnd1, 0))\n+\treturn true;\n+\n+      /* For commutative ops, allow the other order.  */\n+      return (commutative_tree_code (expr0->ops.binary.op)\n+\t      && operand_equal_p (expr0->ops.binary.opnd0,\n+\t\t\t\t  expr1->ops.binary.opnd1, 0)\n+\t      && operand_equal_p (expr0->ops.binary.opnd1,\n+\t\t\t\t  expr1->ops.binary.opnd0, 0));\n+\n+    case EXPR_TERNARY:\n+      if (expr0->ops.ternary.op != expr1->ops.ternary.op\n+\t  || !operand_equal_p (expr0->ops.ternary.opnd2,\n+\t\t\t       expr1->ops.ternary.opnd2, 0))\n+\treturn false;\n+\n+      if (operand_equal_p (expr0->ops.ternary.opnd0,\n+\t\t\t   expr1->ops.ternary.opnd0, 0)\n+\t  && operand_equal_p (expr0->ops.ternary.opnd1,\n+\t\t\t      expr1->ops.ternary.opnd1, 0))\n+\treturn true;\n+\n+      /* For commutative ops, allow the other order.  */\n+      return (commutative_ternary_tree_code (expr0->ops.ternary.op)\n+\t      && operand_equal_p (expr0->ops.ternary.opnd0,\n+\t\t\t\t  expr1->ops.ternary.opnd1, 0)\n+\t      && operand_equal_p (expr0->ops.ternary.opnd1,\n+\t\t\t\t  expr1->ops.ternary.opnd0, 0));\n \n     case EXPR_CALL:\n       {\n@@ -450,15 +477,28 @@ iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n     case EXPR_BINARY:\n       val = iterative_hash_object (expr->ops.binary.op, val);\n       if (commutative_tree_code (expr->ops.binary.op))\n-          val = iterative_hash_exprs_commutative (expr->ops.binary.opnd0,\n-                                                  expr->ops.binary.opnd1, val);\n+\tval = iterative_hash_exprs_commutative (expr->ops.binary.opnd0,\n+\t\t\t\t\t\texpr->ops.binary.opnd1, val);\n       else\n         {\n           val = iterative_hash_expr (expr->ops.binary.opnd0, val);\n           val = iterative_hash_expr (expr->ops.binary.opnd1, val);\n         }\n       break;\n \n+    case EXPR_TERNARY:\n+      val = iterative_hash_object (expr->ops.ternary.op, val);\n+      if (commutative_ternary_tree_code (expr->ops.ternary.op))\n+\tval = iterative_hash_exprs_commutative (expr->ops.ternary.opnd0,\n+\t\t\t\t\t\texpr->ops.ternary.opnd1, val);\n+      else\n+        {\n+          val = iterative_hash_expr (expr->ops.ternary.opnd0, val);\n+          val = iterative_hash_expr (expr->ops.ternary.opnd1, val);\n+        }\n+      val = iterative_hash_expr (expr->ops.ternary.opnd2, val);\n+      break;\n+\n     case EXPR_CALL:\n       {\n         size_t i;\n@@ -511,6 +551,16 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n         print_generic_expr (stream, element->expr.ops.binary.opnd1, 0);\n         break;\n \n+      case EXPR_TERNARY:\n+        fprintf (stream, \" %s <\", tree_code_name[element->expr.ops.ternary.op]);\n+        print_generic_expr (stream, element->expr.ops.ternary.opnd0, 0);\n+\tfputs (\", \", stream);\n+        print_generic_expr (stream, element->expr.ops.ternary.opnd1, 0);\n+\tfputs (\", \", stream);\n+        print_generic_expr (stream, element->expr.ops.ternary.opnd2, 0);\n+\tfputs (\">\", stream);\n+        break;\n+\n       case EXPR_CALL:\n         {\n           size_t i;"}, {"sha": "c8c649282734b60c5a0fc91617fe5bb6d22278d0", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 192, "deletions": 83, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -1262,6 +1262,190 @@ struct gimple_opt_pass pass_optimize_bswap =\n  }\n };\n \n+/* Process a single gimple statement STMT, which has a MULT_EXPR as\n+   its rhs, and try to convert it into a WIDEN_MULT_EXPR.  The return\n+   value is true iff we converted the statement.  */\n+\n+static bool\n+convert_mult_to_widen (gimple stmt)\n+{\n+  gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n+  tree type1 = NULL, type2 = NULL;\n+  tree rhs1, rhs2, rhs1_convop = NULL, rhs2_convop = NULL;\n+  enum tree_code rhs1_code, rhs2_code;\n+  tree type;\n+\n+  type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\n+  if (TREE_CODE (type) != INTEGER_TYPE)\n+    return false;\n+\n+  rhs1 = gimple_assign_rhs1 (stmt);\n+  rhs2 = gimple_assign_rhs2 (stmt);\n+\n+  if (TREE_CODE (rhs1) == SSA_NAME)\n+    {\n+      rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);\n+      if (!is_gimple_assign (rhs1_stmt))\n+\treturn false;\n+      rhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n+      if (!CONVERT_EXPR_CODE_P (rhs1_code))\n+\treturn false;\n+      rhs1_convop = gimple_assign_rhs1 (rhs1_stmt);\n+      type1 = TREE_TYPE (rhs1_convop);\n+      if (TYPE_PRECISION (type1) * 2 != TYPE_PRECISION (type))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (rhs1) != INTEGER_CST)\n+    return false;\n+\n+  if (TREE_CODE (rhs2) == SSA_NAME)\n+    {\n+      rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n+      if (!is_gimple_assign (rhs2_stmt))\n+\treturn false;\n+      rhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n+      if (!CONVERT_EXPR_CODE_P (rhs2_code))\n+\treturn false;\n+      rhs2_convop = gimple_assign_rhs1 (rhs2_stmt);\n+      type2 = TREE_TYPE (rhs2_convop);\n+      if (TYPE_PRECISION (type2) * 2 != TYPE_PRECISION (type))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (rhs2) != INTEGER_CST)\n+    return false;\n+\n+  if (rhs1_stmt == NULL && rhs2_stmt == NULL)\n+    return false;\n+\n+  /* Verify that the machine can perform a widening multiply in this\n+     mode/signedness combination, otherwise this transformation is\n+     likely to pessimize code.  */\n+  if ((rhs1_stmt == NULL || TYPE_UNSIGNED (type1))\n+      && (rhs2_stmt == NULL || TYPE_UNSIGNED (type2))\n+      && (optab_handler (umul_widen_optab, TYPE_MODE (type))\n+\t  ->insn_code == CODE_FOR_nothing))\n+    return false;\n+  else if ((rhs1_stmt == NULL || !TYPE_UNSIGNED (type1))\n+\t   && (rhs2_stmt == NULL || !TYPE_UNSIGNED (type2))\n+\t   && (optab_handler (smul_widen_optab, TYPE_MODE (type))\n+\t       ->insn_code == CODE_FOR_nothing))\n+    return false;\n+  else if (rhs1_stmt != NULL && rhs2_stmt != NULL\n+\t   && (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n+\t   && (optab_handler (usmul_widen_optab, TYPE_MODE (type))\n+\t       ->insn_code == CODE_FOR_nothing))\n+    return false;\n+\n+  if ((rhs1_stmt == NULL && !int_fits_type_p (rhs1, type2))\n+      || (rhs2_stmt == NULL && !int_fits_type_p (rhs2, type1)))\n+    return false;\n+\n+  if (rhs1_stmt == NULL)\n+    gimple_assign_set_rhs1 (stmt, fold_convert (type2, rhs1));\n+  else\n+    gimple_assign_set_rhs1 (stmt, rhs1_convop);\n+  if (rhs2_stmt == NULL)\n+    gimple_assign_set_rhs2 (stmt, fold_convert (type1, rhs2));\n+  else\n+    gimple_assign_set_rhs2 (stmt, rhs2_convop);\n+  gimple_assign_set_rhs_code (stmt, WIDEN_MULT_EXPR);\n+  update_stmt (stmt);\n+  return true;\n+}\n+\n+/* Process a single gimple statement STMT, which is found at the\n+   iterator GSI and has a either a PLUS_EXPR or a MINUS_EXPR as its\n+   rhs (given by CODE), and try to convert it into a\n+   WIDEN_MULT_PLUS_EXPR or a WIDEN_MULT_MINUS_EXPR.  The return value\n+   is true iff we converted the statement.  */\n+\n+static bool\n+convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n+\t\t\t    enum tree_code code)\n+{\n+  gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n+  tree type;\n+  tree lhs, rhs1, rhs2, mult_rhs1, mult_rhs2, add_rhs;\n+  enum tree_code rhs1_code = ERROR_MARK, rhs2_code = ERROR_MARK;\n+  optab this_optab;\n+  enum tree_code wmult_code;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  type = TREE_TYPE (lhs);\n+  if (TREE_CODE (type) != INTEGER_TYPE)\n+    return false;\n+\n+  if (code == MINUS_EXPR)\n+    wmult_code = WIDEN_MULT_MINUS_EXPR;\n+  else\n+    wmult_code = WIDEN_MULT_PLUS_EXPR;\n+\n+  /* Verify that the machine can perform a widening multiply\n+     accumulate in this mode/signedness combination, otherwise\n+     this transformation is likely to pessimize code.  */\n+  this_optab = optab_for_tree_code (wmult_code, type, optab_default);\n+  if (optab_handler (this_optab, TYPE_MODE (type))->insn_code\n+      == CODE_FOR_nothing)\n+    return false;\n+\n+  rhs1 = gimple_assign_rhs1 (stmt);\n+  rhs2 = gimple_assign_rhs2 (stmt);\n+\n+  if (TREE_CODE (rhs1) == SSA_NAME)\n+    {\n+      rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);\n+      if (is_gimple_assign (rhs1_stmt))\n+\trhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n+    }\n+  else\n+    return false;\n+\n+  if (TREE_CODE (rhs2) == SSA_NAME)\n+    {\n+      rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n+      if (is_gimple_assign (rhs2_stmt))\n+\trhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n+    }\n+  else\n+    return false;\n+\n+  if (rhs1_code == MULT_EXPR)\n+    {\n+      if (!convert_mult_to_widen (rhs1_stmt))\n+\treturn false;\n+      rhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n+    }\n+  if (rhs2_code == MULT_EXPR)\n+    {\n+      if (!convert_mult_to_widen (rhs2_stmt))\n+\treturn false;\n+      rhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n+    }\n+  \n+  if (code == PLUS_EXPR && rhs1_code == WIDEN_MULT_EXPR)\n+    {\n+      mult_rhs1 = gimple_assign_rhs1 (rhs1_stmt);\n+      mult_rhs2 = gimple_assign_rhs2 (rhs1_stmt);\n+      add_rhs = rhs2;\n+    }\n+  else if (rhs2_code == WIDEN_MULT_EXPR)\n+    {\n+      mult_rhs1 = gimple_assign_rhs1 (rhs2_stmt);\n+      mult_rhs2 = gimple_assign_rhs2 (rhs2_stmt);\n+      add_rhs = rhs1;\n+    }\n+  else\n+    return false;\n+\n+  /* ??? May need some type verification here?  */\n+\n+  gimple_assign_set_rhs_with_ops_1 (gsi, wmult_code, mult_rhs1, mult_rhs2,\n+\t\t\t\t    add_rhs);\n+  update_stmt (gsi_stmt (*gsi));\n+  return true;\n+}\n+\n /* Find integer multiplications where the operands are extended from\n    smaller types, and replace the MULT_EXPR with a WIDEN_MULT_EXPR\n    where appropriate.  */\n@@ -1279,94 +1463,19 @@ execute_optimize_widening_mul (void)\n       for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n         {\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n-\t  tree type, type1 = NULL, type2 = NULL;\n-\t  tree rhs1, rhs2, rhs1_convop = NULL, rhs2_convop = NULL;\n-\t  enum tree_code rhs1_code, rhs2_code;\n-\n-\t  if (!is_gimple_assign (stmt)\n-\t      || gimple_assign_rhs_code (stmt) != MULT_EXPR)\n-\t    continue;\n-\n-\t  type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t  enum tree_code code;\n \n-\t  if (TREE_CODE (type) != INTEGER_TYPE)\n+\t  if (!is_gimple_assign (stmt))\n \t    continue;\n \n-\t  rhs1 = gimple_assign_rhs1 (stmt);\n-\t  rhs2 = gimple_assign_rhs2 (stmt);\n-\n-\t  if (TREE_CODE (rhs1) == SSA_NAME)\n-\t    {\n-\t      rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);\n-\t      if (!is_gimple_assign (rhs1_stmt))\n-\t\tcontinue;\n-\t      rhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n-\t      if (!CONVERT_EXPR_CODE_P (rhs1_code))\n-\t\tcontinue;\n-\t      rhs1_convop = gimple_assign_rhs1 (rhs1_stmt);\n-\t      type1 = TREE_TYPE (rhs1_convop);\n-\t      if (TYPE_PRECISION (type1) * 2 != TYPE_PRECISION (type))\n-\t\tcontinue;\n-\t    }\n-\t  else if (TREE_CODE (rhs1) != INTEGER_CST)\n-\t    continue;\n-\n-\t  if (TREE_CODE (rhs2) == SSA_NAME)\n-\t    {\n-\t      rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n-\t      if (!is_gimple_assign (rhs2_stmt))\n-\t\tcontinue;\n-\t      rhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n-\t      if (!CONVERT_EXPR_CODE_P (rhs2_code))\n-\t\tcontinue;\n-\t      rhs2_convop = gimple_assign_rhs1 (rhs2_stmt);\n-\t      type2 = TREE_TYPE (rhs2_convop);\n-\t      if (TYPE_PRECISION (type2) * 2 != TYPE_PRECISION (type))\n-\t\tcontinue;\n-\t    }\n-\t  else if (TREE_CODE (rhs2) != INTEGER_CST)\n-\t    continue;\n-\n-\t  if (rhs1_stmt == NULL && rhs2_stmt == NULL)\n-\t    continue;\n-\n-\t  /* Verify that the machine can perform a widening multiply in this\n-\t     mode/signedness combination, otherwise this transformation is\n-\t     likely to pessimize code.  */\n-\t  if ((rhs1_stmt == NULL || TYPE_UNSIGNED (type1))\n-\t      && (rhs2_stmt == NULL || TYPE_UNSIGNED (type2))\n-\t      && (optab_handler (umul_widen_optab, TYPE_MODE (type))\n-\t\t  ->insn_code == CODE_FOR_nothing))\n-\t    continue;\n-\t  else if ((rhs1_stmt == NULL || !TYPE_UNSIGNED (type1))\n-\t\t   && (rhs2_stmt == NULL || !TYPE_UNSIGNED (type2))\n-\t\t   && (optab_handler (smul_widen_optab, TYPE_MODE (type))\n-\t\t       ->insn_code == CODE_FOR_nothing))\n-\t    continue;\n-\t  else if (rhs1_stmt != NULL && rhs2_stmt != 0\n-\t\t   && (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n-\t\t   && (optab_handler (usmul_widen_optab, TYPE_MODE (type))\n-\t\t       ->insn_code == CODE_FOR_nothing))\n-\t    continue;\n-\n-\t  if ((rhs1_stmt == NULL && !int_fits_type_p (rhs1, type2))\n-\t      || (rhs2_stmt == NULL && !int_fits_type_p (rhs2, type1)))\n-\t    continue;\n-\n-\t  if (rhs1_stmt == NULL)\n-\t    gimple_assign_set_rhs1 (stmt, fold_convert (type2, rhs1));\n-\t  else\n-\t    gimple_assign_set_rhs1 (stmt, rhs1_convop);\n-\t  if (rhs2_stmt == NULL)\n-\t    gimple_assign_set_rhs2 (stmt, fold_convert (type1, rhs2));\n-\t  else\n-\t    gimple_assign_set_rhs2 (stmt, rhs2_convop);\n-\t  gimple_assign_set_rhs_code (stmt, WIDEN_MULT_EXPR);\n-\t  update_stmt (stmt);\n-\t  changed = true;\n+\t  code = gimple_assign_rhs_code (stmt);\n+\t  if (code == MULT_EXPR)\n+\t    changed |= convert_mult_to_widen (stmt);\n+\t  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n+\t    changed |= convert_plusminus_to_widen (&gsi, stmt, code);\n \t}\n     }\n+\n   return (changed ? TODO_dump_func | TODO_update_ssa | TODO_verify_ssa\n \t  | TODO_verify_stmts : 0);\n }"}, {"sha": "b784a68b18eeeaec2eaf23f03af782439ccbdca9", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -988,11 +988,13 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \n     case DOT_PROD_EXPR:\n     case REALIGN_LOAD_EXPR:\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n       {\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n-        get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n-        get_expr_operands (stmt, &TREE_OPERAND (expr, 2), flags);\n-        return;\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), flags);\n+\treturn;\n       }\n \n     case FUNCTION_DECL:"}, {"sha": "b27fe0c0bc54d9312dcb4f67c15fefbae86ef1b0", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -2352,6 +2352,10 @@ stmt_has_constants (gimple stmt)\n     case GIMPLE_BINARY_RHS:\n       return (is_gimple_min_invariant (gimple_assign_rhs1 (stmt))\n \t      || is_gimple_min_invariant (gimple_assign_rhs2 (stmt)));\n+    case GIMPLE_TERNARY_RHS:\n+      return (is_gimple_min_invariant (gimple_assign_rhs1 (stmt))\n+\t      || is_gimple_min_invariant (gimple_assign_rhs2 (stmt))\n+\t      || is_gimple_min_invariant (gimple_assign_rhs3 (stmt)));\n     case GIMPLE_SINGLE_RHS:\n       /* Constants inside reference ops are rarely interesting, but\n \t it can take a lot of looking to find them.  */"}, {"sha": "9aca36ced62e6072191461e346914c0fa8bef8a7", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -242,22 +242,31 @@ fold_assignment_stmt (gimple stmt)\n \n         return fold (rhs);\n       }\n-      break;\n+\n     case GIMPLE_UNARY_RHS:\n       {\n         tree lhs = gimple_assign_lhs (stmt);\n         tree op0 = gimple_assign_rhs1 (stmt);\n         return fold_unary (subcode, TREE_TYPE (lhs), op0);\n       }\n-      break;\n+\n     case GIMPLE_BINARY_RHS:\n       {\n         tree lhs = gimple_assign_lhs (stmt);\n         tree op0 = gimple_assign_rhs1 (stmt);\n         tree op1 = gimple_assign_rhs2 (stmt);\n         return fold_binary (subcode, TREE_TYPE (lhs), op0, op1);\n       }\n-      break;\n+\n+    case GIMPLE_TERNARY_RHS:\n+      {\n+        tree lhs = gimple_assign_lhs (stmt);\n+        tree op0 = gimple_assign_rhs1 (stmt);\n+        tree op1 = gimple_assign_rhs2 (stmt);\n+        tree op2 = gimple_assign_rhs3 (stmt);\n+        return fold_ternary (subcode, TREE_TYPE (lhs), op0, op1, op2);\n+      }\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "efeb4747788e76f42ee009e2a4a45282dcf05a25", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -865,6 +865,8 @@ gimple_assign_nonnegative_warnv_p (gimple stmt, bool *strict_overflow_p)\n \t\t\t\t\t      gimple_assign_rhs1 (stmt),\n \t\t\t\t\t      gimple_assign_rhs2 (stmt),\n \t\t\t\t\t      strict_overflow_p);\n+    case GIMPLE_TERNARY_RHS:\n+      return false;\n     case GIMPLE_SINGLE_RHS:\n       return tree_single_nonnegative_warnv_p (gimple_assign_rhs1 (stmt),\n \t\t\t\t\t      strict_overflow_p);\n@@ -936,6 +938,8 @@ gimple_assign_nonzero_warnv_p (gimple stmt, bool *strict_overflow_p)\n \t\t\t\t\t  gimple_assign_rhs1 (stmt),\n \t\t\t\t\t  gimple_assign_rhs2 (stmt),\n \t\t\t\t\t  strict_overflow_p);\n+    case GIMPLE_TERNARY_RHS:\n+      return false;\n     case GIMPLE_SINGLE_RHS:\n       return tree_single_nonzero_warnv_p (gimple_assign_rhs1 (stmt),\n \t\t\t\t\t  strict_overflow_p);"}, {"sha": "a02ac395a336d96df9916b26df229f83790a1005", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -6540,6 +6540,23 @@ commutative_tree_code (enum tree_code code)\n   return false;\n }\n \n+/* Return true if CODE represents a ternary tree code for which the\n+   first two operands are commutative.  Otherwise return false.  */\n+bool\n+commutative_ternary_tree_code (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    case WIDEN_MULT_PLUS_EXPR:\n+    case WIDEN_MULT_MINUS_EXPR:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n /* Generate a hash value for an expression.  This can be used iteratively\n    by passing a previous result as the VAL argument.\n "}, {"sha": "e09debf0cddce8375ecc551ad0949ffc286383bc", "filename": "gcc/tree.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -1080,6 +1080,18 @@ DEFTREECODE (WIDEN_SUM_EXPR, \"widen_sum_expr\", tcc_binary, 2)\n    the arguments from type t1 to type t2, and then multiplying them.  */\n DEFTREECODE (WIDEN_MULT_EXPR, \"widen_mult_expr\", tcc_binary, 2)\n \n+/* Widening multiply-accumulate.\n+   The first two arguments are of type t1.\n+   The third argument and the result are of type t2, such as t2 is at least\n+   twice the size of t1.  t1 and t2 must be integral or fixed-point types.\n+   The expression is equivalent to a WIDEN_MULT_EXPR operation\n+   of the first two operands followed by an add or subtract of the third\n+   operand.  */\n+DEFTREECODE (WIDEN_MULT_PLUS_EXPR, \"widen_mult_plus_expr\", tcc_expression, 3)\n+/* This is like the above, except in the final expression the multiply result\n+   is subtracted from t3.  */\n+DEFTREECODE (WIDEN_MULT_MINUS_EXPR, \"widen_mult_plus_expr\", tcc_expression, 3)\n+\n /* Whole vector left/right shift in bits.\n    Operand 0 is a vector to be shifted.\n    Operand 1 is an integer shift amount in bits.  */"}, {"sha": "967b4b273723f7de8a7f2a32398af67483ad5b0d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0354c0c70b2a090a3705fffd6a87313233b5516d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0354c0c70b2a090a3705fffd6a87313233b5516d", "patch": "@@ -4820,6 +4820,7 @@ extern tree get_callee_fndecl (const_tree);\n extern int type_num_arguments (const_tree);\n extern bool associative_tree_code (enum tree_code);\n extern bool commutative_tree_code (enum tree_code);\n+extern bool commutative_ternary_tree_code (enum tree_code);\n extern tree upper_bound_in_type (tree, tree);\n extern tree lower_bound_in_type (tree, tree);\n extern int operand_equal_for_phi_arg_p (const_tree, const_tree);"}]}