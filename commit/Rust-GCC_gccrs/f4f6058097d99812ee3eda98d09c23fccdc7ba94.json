{"sha": "f4f6058097d99812ee3eda98d09c23fccdc7ba94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmNjA1ODA5N2Q5OTgxMmVlM2VkYTk4ZDA5YzIzZmNjZGM3YmE5NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:20:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:20:11Z"}, "message": "[70/77] Make expand_fix/float check for scalar modes\n\nThe expand_float code:\n\n  /* Unsigned integer, and no way to convert directly.  Convert as signed,\n     then unconditionally adjust the result.  */\n\nand the expand_fix code:\n\n  /* For an unsigned conversion, there is one more way to do it.\n     If we have a signed conversion, we generate code that compares\n     the real value to the largest representable positive number.  If if\n     is smaller, the conversion is done normally.  Otherwise, subtract\n     one plus the highest signed number, convert, and add it back.\n\nare restricted to scalars, since the expansion branches on a\ncomparison of the value.  This patch makes that explicit.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs.c (expand_float): Explicitly check for scalars before\n\tusing a branching expansion.\n\t(expand_fix): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251521", "tree": {"sha": "9b897ae816e321979e17f0257c4398cc8f52bb63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b897ae816e321979e17f0257c4398cc8f52bb63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4f6058097d99812ee3eda98d09c23fccdc7ba94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f6058097d99812ee3eda98d09c23fccdc7ba94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f6058097d99812ee3eda98d09c23fccdc7ba94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f6058097d99812ee3eda98d09c23fccdc7ba94/comments", "author": null, "committer": null, "parents": [{"sha": "4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e084bc3ce764a73312cefdda9a4736b8e27b5d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e084bc3ce764a73312cefdda9a4736b8e27b5d1"}], "stats": {"total": 51, "additions": 33, "deletions": 18}, "files": [{"sha": "c4407d6852d90abaec601bb02dc8db680aa4099d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f6058097d99812ee3eda98d09c23fccdc7ba94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f6058097d99812ee3eda98d09c23fccdc7ba94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4f6058097d99812ee3eda98d09c23fccdc7ba94", "patch": "@@ -1,3 +1,11 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs.c (expand_float): Explicitly check for scalars before\n+\tusing a branching expansion.\n+\t(expand_fix): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d3ceabab8f05c9373ace0193683b348714f8ed7c", "filename": "gcc/optabs.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f6058097d99812ee3eda98d09c23fccdc7ba94/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f6058097d99812ee3eda98d09c23fccdc7ba94/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f4f6058097d99812ee3eda98d09c23fccdc7ba94", "patch": "@@ -4637,6 +4637,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n {\n   enum insn_code icode;\n   rtx target = to;\n+  scalar_mode from_mode, to_mode;\n   machine_mode fmode, imode;\n   bool can_do_signed = false;\n \n@@ -4686,7 +4687,10 @@ expand_float (rtx to, rtx from, int unsignedp)\n \n   /* Unsigned integer, and no way to convert directly.  Convert as signed,\n      then unconditionally adjust the result.  */\n-  if (unsignedp && can_do_signed)\n+  if (unsignedp\n+      && can_do_signed\n+      && is_a <scalar_mode> (GET_MODE (to), &to_mode)\n+      && is_a <scalar_mode> (GET_MODE (from), &from_mode))\n     {\n       rtx_code_label *label = gen_label_rtx ();\n       rtx temp;\n@@ -4696,19 +4700,19 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t least as wide as the target.  Using FMODE will avoid rounding woes\n \t with unsigned values greater than the signed maximum value.  */\n \n-      FOR_EACH_MODE_FROM (fmode, GET_MODE (to))\n-\tif (GET_MODE_PRECISION (GET_MODE (from)) < GET_MODE_BITSIZE (fmode)\n-\t    && can_float_p (fmode, GET_MODE (from), 0) != CODE_FOR_nothing)\n+      FOR_EACH_MODE_FROM (fmode, to_mode)\n+\tif (GET_MODE_PRECISION (from_mode) < GET_MODE_BITSIZE (fmode)\n+\t    && can_float_p (fmode, from_mode, 0) != CODE_FOR_nothing)\n \t  break;\n \n       if (fmode == VOIDmode)\n \t{\n \t  /* There is no such mode.  Pretend the target is wide enough.  */\n-\t  fmode = GET_MODE (to);\n+\t  fmode = to_mode;\n \n \t  /* Avoid double-rounding when TO is narrower than FROM.  */\n \t  if ((significand_size (fmode) + 1)\n-\t      < GET_MODE_PRECISION (GET_MODE (from)))\n+\t      < GET_MODE_PRECISION (from_mode))\n \t    {\n \t      rtx temp1;\n \t      rtx_code_label *neglabel = gen_label_rtx ();\n@@ -4720,7 +4724,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t\t  || GET_MODE (target) != fmode)\n \t\ttarget = gen_reg_rtx (fmode);\n \n-\t      imode = GET_MODE (from);\n+\t      imode = from_mode;\n \t      do_pending_stack_adjust ();\n \n \t      /* Test whether the sign bit is set.  */\n@@ -4760,7 +4764,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n       /* If we are about to do some arithmetic to correct for an\n \t unsigned operand, do it in a pseudo-register.  */\n \n-      if (GET_MODE (to) != fmode\n+      if (to_mode != fmode\n \t  || !REG_P (to) || REGNO (to) < FIRST_PSEUDO_REGISTER)\n \ttarget = gen_reg_rtx (fmode);\n \n@@ -4771,11 +4775,11 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t correct its value by 2**bitwidth.  */\n \n       do_pending_stack_adjust ();\n-      emit_cmp_and_jump_insns (from, const0_rtx, GE, NULL_RTX, GET_MODE (from),\n+      emit_cmp_and_jump_insns (from, const0_rtx, GE, NULL_RTX, from_mode,\n \t\t\t       0, label);\n \n \n-      real_2expN (&offset, GET_MODE_PRECISION (GET_MODE (from)), fmode);\n+      real_2expN (&offset, GET_MODE_PRECISION (from_mode), fmode);\n       temp = expand_binop (fmode, add_optab, target,\n \t\t\t   const_double_from_real_value (offset, fmode),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n@@ -4903,19 +4907,22 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      2^63.  The subtraction of 2^63 should not generate any rounding as it\n      simply clears out that bit.  The rest is trivial.  */\n \n-  if (unsignedp && GET_MODE_PRECISION (GET_MODE (to)) <= HOST_BITS_PER_WIDE_INT)\n+  scalar_int_mode to_mode;\n+  if (unsignedp\n+      && is_a <scalar_int_mode> (GET_MODE (to), &to_mode)\n+      && HWI_COMPUTABLE_MODE_P (to_mode))\n     FOR_EACH_MODE_FROM (fmode, GET_MODE (from))\n-      if (CODE_FOR_nothing != can_fix_p (GET_MODE (to), fmode, 0, &must_trunc)\n+      if (CODE_FOR_nothing != can_fix_p (to_mode, fmode, 0, &must_trunc)\n \t  && (!DECIMAL_FLOAT_MODE_P (fmode)\n-\t      || GET_MODE_BITSIZE (fmode) > GET_MODE_PRECISION (GET_MODE (to))))\n+\t      || GET_MODE_BITSIZE (fmode) > GET_MODE_PRECISION (to_mode)))\n \t{\n \t  int bitsize;\n \t  REAL_VALUE_TYPE offset;\n \t  rtx limit;\n \t  rtx_code_label *lab1, *lab2;\n \t  rtx_insn *insn;\n \n-\t  bitsize = GET_MODE_PRECISION (GET_MODE (to));\n+\t  bitsize = GET_MODE_PRECISION (to_mode);\n \t  real_2expN (&offset, bitsize - 1, fmode);\n \t  limit = const_double_from_real_value (offset, fmode);\n \t  lab1 = gen_label_rtx ();\n@@ -4941,23 +4948,23 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \t  target = expand_binop (GET_MODE (from), sub_optab, from, limit,\n \t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t  expand_fix (to, target, 0);\n-\t  target = expand_binop (GET_MODE (to), xor_optab, to,\n+\t  target = expand_binop (to_mode, xor_optab, to,\n \t\t\t\t gen_int_mode\n \t\t\t\t (HOST_WIDE_INT_1 << (bitsize - 1),\n-\t\t\t\t  GET_MODE (to)),\n+\t\t\t\t  to_mode),\n \t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n \n \t  if (target != to)\n \t    emit_move_insn (to, target);\n \n \t  emit_label (lab2);\n \n-\t  if (optab_handler (mov_optab, GET_MODE (to)) != CODE_FOR_nothing)\n+\t  if (optab_handler (mov_optab, to_mode) != CODE_FOR_nothing)\n \t    {\n \t      /* Make a place for a REG_NOTE and add it.  */\n \t      insn = emit_move_insn (to, to);\n \t      set_dst_reg_note (insn, REG_EQUAL,\n-\t\t\t\tgen_rtx_fmt_e (UNSIGNED_FIX, GET_MODE (to),\n+\t\t\t\tgen_rtx_fmt_e (UNSIGNED_FIX, to_mode,\n \t\t\t\t\t       copy_rtx (from)),\n \t\t\t\tto);\n \t    }"}]}