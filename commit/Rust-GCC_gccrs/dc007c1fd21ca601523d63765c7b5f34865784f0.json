{"sha": "dc007c1fd21ca601523d63765c7b5f34865784f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwMDdjMWZkMjFjYTYwMTUyM2Q2Mzc2NWM3YjVmMzQ4NjU3ODRmMA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2010-11-22T16:20:16Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2010-11-22T16:20:16Z"}, "message": "re PR bootstrap/44970 (Revision 162270 failed to bootstrap)\n\n2010-11-22  Paolo Bonzini<bonzini@gnu.org>\n\n\tPR bootstrap/44970\n\t* Makefile.in (fwprop.o) Add sparseset.h.\n\t* fwprop.c: Include sparseset.h\n\t(struct find_occurrence_data, find_occurrence_callback,\n\tfind_occurrence): Remove.\n\t(active_defs, active_defs_check, register_active_defs,\n\tupdate_df_init, update_uses): New.\n\t(update_df): Rewrite.\n\t(try_fwprop_subst, forward_propagate_asm): Add calls to\n\tupdate_df_init and update_df.\n\t(fwprop_init): Allocate active_defs and active_defs_check.\n\t(fwprop_done): Free them.\n\t(fwprop, fwprop_addr): Adjust comments.\n\t* df.h (df_uses_create): Declare.\n\t* df-scan.c (df_install_ref_incremental): Break out of df_ref_create.\n\t(df_ref_create): Return result of df_ref_create_structure directly.\n\t(df_ref_create_structure): Call df_install_ref_incremental when\n\tno collection_rec is passed.\n\t(df_ref_record): Do not create multiword hard reg info when no\n\tcollection_rec is passed.\n\t(df_uses_create): New.\n\nFrom-SVN: r167038", "tree": {"sha": "19195f547cbd268188abcb3d1113a7d0cb5c5be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19195f547cbd268188abcb3d1113a7d0cb5c5be6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc007c1fd21ca601523d63765c7b5f34865784f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc007c1fd21ca601523d63765c7b5f34865784f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc007c1fd21ca601523d63765c7b5f34865784f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc007c1fd21ca601523d63765c7b5f34865784f0/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47f647e44f933272c7d0c2a707ff537369b30ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47f647e44f933272c7d0c2a707ff537369b30ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47f647e44f933272c7d0c2a707ff537369b30ca0"}], "stats": {"total": 250, "additions": 154, "deletions": 96}, "files": [{"sha": "a4513b7e4423c7c6c1f4d9cb43bb3e92901847b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc007c1fd21ca601523d63765c7b5f34865784f0", "patch": "@@ -1,3 +1,27 @@\n+2010-11-22  Paolo Bonzini<bonzini@gnu.org>\n+\n+\tPR bootstrap/44970\n+\t* Makefile.in (fwprop.o) Add sparseset.h.\n+\t* fwprop.c: Include sparseset.h\n+\t(struct find_occurrence_data, find_occurrence_callback,\n+\tfind_occurrence): Remove.\n+\t(active_defs, active_defs_check, register_active_defs,\n+\tupdate_df_init, update_uses): New.\n+\t(update_df): Rewrite.\n+\t(try_fwprop_subst, forward_propagate_asm): Add calls to\n+\tupdate_df_init and update_df.\n+\t(fwprop_init): Allocate active_defs and active_defs_check.\n+\t(fwprop_done): Free them.\n+\t(fwprop, fwprop_addr): Adjust comments.\n+\t* df.h (df_uses_create): Declare.\n+\t* df-scan.c (df_install_ref_incremental): Break out of df_ref_create.\n+\t(df_ref_create): Return result of df_ref_create_structure directly.\n+\t(df_ref_create_structure): Call df_install_ref_incremental when\n+\tno collection_rec is passed.\n+\t(df_ref_record): Do not create multiword hard reg info when no\n+\tcollection_rec is passed.\n+\t(df_uses_create): New. \n+\n 2010-11-21  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR middle-end/43057"}, {"sha": "57e049c071a1b7de7cdd3c915550cbe510899a15", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=dc007c1fd21ca601523d63765c7b5f34865784f0", "patch": "@@ -3115,7 +3115,7 @@ dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \\\n    output.h $(DF_H) alloc-pool.h $(TIMEVAR_H) $(TREE_PASS_H) $(TARGET_H) \\\n-   $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) domwalk.h\n+   $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) domwalk.h sparseset.h\n web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) \\\n    insn-config.h $(RECOG_H) $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H)"}, {"sha": "1400d2569b0cd246fe0fddf7f9ad9923751bc520", "filename": "gcc/df-scan.c", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=dc007c1fd21ca601523d63765c7b5f34865784f0", "patch": "@@ -122,6 +122,7 @@ static void df_uses_record (struct df_collection_rec *,\n \t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    int ref_flags);\n \n+static void df_install_ref_incremental (df_ref);\n static df_ref df_ref_create_structure (enum df_ref_class,\n \t\t\t\t       struct df_collection_rec *, rtx, rtx *,\n \t\t\t\t       basic_block, struct df_insn_info *,\n@@ -680,6 +681,19 @@ df_scan_blocks (void)\n     }\n }\n \n+/* Create new refs under address LOC within INSN.  This function is\n+   only used externally.  REF_FLAGS must be either 0 or DF_REF_IN_NOTE,\n+   depending on whether LOC is inside PATTERN (INSN) or a note.  */\n+\n+void\n+df_uses_create (rtx *loc, rtx insn, int ref_flags)\n+{\n+  gcc_assert (!(ref_flags & ~DF_REF_IN_NOTE));\n+  df_uses_record (NULL, loc, DF_REF_REG_USE,\n+                  BLOCK_FOR_INSN (insn),\n+                  DF_INSN_INFO_GET (insn),\n+                  ref_flags);\n+}\n \n /* Create a new ref of type DF_REF_TYPE for register REG at address\n    LOC within INSN of BB.  This function is only used externally.  */\n@@ -690,13 +704,6 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n \t       enum df_ref_type ref_type,\n \t       int ref_flags)\n {\n-  df_ref ref;\n-  struct df_reg_info **reg_info;\n-  struct df_ref_info *ref_info;\n-  df_ref *ref_rec;\n-  df_ref **ref_rec_ptr;\n-  unsigned int count = 0;\n-  bool add_to_table;\n   enum df_ref_class cl;\n \n   df_grow_reg_info ();\n@@ -708,8 +715,24 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n     cl = DF_REF_REGULAR;\n   else\n     cl = DF_REF_BASE;\n-  ref = df_ref_create_structure (cl, NULL, reg, loc, bb, DF_INSN_INFO_GET (insn),\n-                                 ref_type, ref_flags);\n+\n+  return df_ref_create_structure (cl, NULL, reg, loc, bb,\n+                                  DF_INSN_INFO_GET (insn),\n+                                  ref_type, ref_flags);\n+}\n+\n+static void\n+df_install_ref_incremental (df_ref ref)\n+{\n+  struct df_reg_info **reg_info;\n+  struct df_ref_info *ref_info;\n+  df_ref *ref_rec;\n+  df_ref **ref_rec_ptr;\n+  unsigned int count = 0;\n+  bool add_to_table;\n+\n+  rtx insn = DF_REF_INSN (ref);\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n \n   if (DF_REF_REG_DEF_P (ref))\n     {\n@@ -798,8 +821,6 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n      to mark the block dirty ourselves.  */\n   if (!DEBUG_INSN_P (DF_REF_INSN (ref)))\n     df_set_bb_dirty (bb);\n-\n-  return ref;\n }\n \n \n@@ -2796,6 +2817,8 @@ df_ref_create_structure (enum df_ref_class cl,\n       else\n \tVEC_safe_push (df_ref, stack, collection_rec->use_vec, this_ref);\n     }\n+  else\n+    df_install_ref_incremental (this_ref);\n \n   return this_ref;\n }\n@@ -2839,7 +2862,8 @@ df_ref_record (enum df_ref_class cl,\n       /*  If this is a multiword hardreg, we create some extra\n \t  datastructures that will enable us to easily build REG_DEAD\n \t  and REG_UNUSED notes.  */\n-      if ((endregno != regno + 1) && insn_info)\n+      if (collection_rec\n+\t  && (endregno != regno + 1) && insn_info)\n \t{\n \t  /* Sets to a subreg of a multiword register are partial.\n \t     Sets to a non-subreg of a multiword register are not.  */"}, {"sha": "a9bc3664d2f5836173ed6567d8a6dfa385c6a502", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=dc007c1fd21ca601523d63765c7b5f34865784f0", "patch": "@@ -980,6 +980,7 @@ extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block,\n \t\t\t     enum df_ref_type, int ref_flags);\n+extern void df_uses_create (rtx *, rtx, int);\n extern void df_ref_remove (df_ref);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);\n extern void df_insn_delete (basic_block, unsigned int);"}, {"sha": "7f29ffb5afbdabc71c16e77d80e58aedd58c67e7", "filename": "gcc/fwprop.c", "status": "modified", "additions": 92, "deletions": 83, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc007c1fd21ca601523d63765c7b5f34865784f0/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=dc007c1fd21ca601523d63765c7b5f34865784f0", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"toplev.h\"\n \n+#include \"sparseset.h\"\n #include \"timevar.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n@@ -849,84 +850,95 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n }\n \n \f\n-struct find_occurrence_data\n-{\n-  rtx find;\n-  rtx *retval;\n-};\n+static df_ref *active_defs;\n+#ifdef ENABLE_CHECKING\n+static sparseset active_defs_check;\n+#endif\n \n-/* Callback for for_each_rtx, used in find_occurrence.\n-   See if PX is the rtx we have to find.  Return 1 to stop for_each_rtx\n-   if successful, or 0 to continue traversing otherwise.  */\n+/* Fill the ACTIVE_DEFS array with the use->def link for the registers\n+   mentioned in USE_REC.  Register the valid entries in ACTIVE_DEFS_CHECK\n+   too, for checking purposes.  */\n \n-static int\n-find_occurrence_callback (rtx *px, void *data)\n+static void\n+register_active_defs (df_ref *use_rec)\n {\n-  struct find_occurrence_data *fod = (struct find_occurrence_data *) data;\n-  rtx x = *px;\n-  rtx find = fod->find;\n-\n-  if (x == find)\n+  while (*use_rec)\n     {\n-      fod->retval = px;\n-      return 1;\n-    }\n+      df_ref use = *use_rec++;\n+      df_ref def = get_def_for_use (use);\n+      int regno = DF_REF_REGNO (use);\n \n-  return 0;\n+#ifdef ENABLE_CHECKING\n+      sparseset_set_bit (active_defs_check, regno);\n+#endif\n+      active_defs[regno] = def;\n+    }\n }\n \n-/* Return a pointer to one of the occurrences of register FIND in *PX.  */\n \n-static rtx *\n-find_occurrence (rtx *px, rtx find)\n+/* Build the use->def links that we use to update the dataflow info\n+   for new uses.  Note that building the links is very cheap and if\n+   it were done earlier, they could be used to rule out invalid\n+   propagations (in addition to what is done in all_uses_available_at).\n+   I'm not doing this yet, though.  */\n+\n+static void\n+update_df_init (rtx def_insn, rtx insn)\n {\n-  struct find_occurrence_data data;\n+#ifdef ENABLE_CHECKING\n+  sparseset_clear (active_defs_check);\n+#endif\n+  register_active_defs (DF_INSN_USES (def_insn));\n+  register_active_defs (DF_INSN_USES (insn));\n+  register_active_defs (DF_INSN_EQ_USES (insn));\n+}\n \n-  gcc_assert (REG_P (find)\n-\t      || (GET_CODE (find) == SUBREG\n-\t\t  && REG_P (SUBREG_REG (find))));\n \n-  data.find = find;\n-  data.retval = NULL;\n-  for_each_rtx (px, find_occurrence_callback, &data);\n-  return data.retval;\n-}\n+/* Update the USE_DEF_REF array for the given use, using the active definitions\n+   in the ACTIVE_DEFS array to match pseudos to their def. */\n \n-\f\n-/* Inside INSN, the expression rooted at *LOC has been changed, moving some\n-   uses from USE_VEC.  Find those that are present, and create new items\n-   in the data flow object of the pass.  Mark any new uses as having the\n-   given TYPE.  */\n-static void\n-update_df (rtx insn, rtx *loc, df_ref *use_rec, enum df_ref_type type,\n-\t   int new_flags)\n+static inline void\n+update_uses (df_ref *use_rec)\n {\n-  bool changed = false;\n-\n-  /* Add a use for the registers that were propagated.  */\n   while (*use_rec)\n     {\n-      df_ref use = *use_rec;\n-      df_ref orig_use = use, new_use;\n-      rtx *new_loc = find_occurrence (loc, DF_REF_REG (orig_use));\n-      use_rec++;\n+      df_ref use = *use_rec++;\n+      int regno = DF_REF_REGNO (use);\n \n-      if (!new_loc)\n-\tcontinue;\n+      /* Set up the use-def chain.  */\n+      if (DF_REF_ID (use) >= (int) VEC_length (df_ref, use_def_ref))\n+        VEC_safe_grow_cleared (df_ref, heap, use_def_ref,\n+                               DF_REF_ID (use) + 1);\n \n-      /* Add a new insn use.  Use the original type, because it says if the\n-         use was within a MEM.  */\n-      new_use = df_ref_create (DF_REF_REG (orig_use), new_loc,\n-\t\t\t       insn, BLOCK_FOR_INSN (insn),\n-\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags);\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (sparseset_bit_p (active_defs_check, regno));\n+#endif\n+      VEC_replace (df_ref, use_def_ref, DF_REF_ID (use), active_defs[regno]);\n+    }\n+}\n \n-      /* Set up the use-def chain.  */\n-      gcc_assert (DF_REF_ID (new_use) == (int) VEC_length (df_ref, use_def_ref));\n-      VEC_safe_push (df_ref, heap, use_def_ref, get_def_for_use (orig_use));\n-      changed = true;\n+\n+/* Update the USE_DEF_REF array for the uses in INSN.  Only update note\n+   uses if NOTES_ONLY is true.  */\n+\n+static void\n+update_df (rtx insn, rtx note)\n+{\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\n+  if (note)\n+    {\n+      df_uses_create (&XEXP (note, 0), insn, DF_REF_IN_NOTE);\n+      df_notes_rescan (insn);\n+    }\n+  else\n+    {\n+      df_uses_create (&PATTERN (insn), insn, 0);\n+      df_insn_rescan (insn);\n+      update_uses (DF_INSN_INFO_USES (insn_info));\n     }\n-  if (changed)\n-    df_insn_rescan (insn);\n+\n+  update_uses (DF_INSN_INFO_EQ_USES (insn_info));\n }\n \n \n@@ -940,13 +952,14 @@ static bool\n try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_equal)\n {\n   rtx insn = DF_REF_INSN (use);\n-  enum df_ref_type type = DF_REF_TYPE (use);\n-  int flags = DF_REF_FLAGS (use);\n   rtx set = single_set (insn);\n+  rtx note = NULL_RTX;\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n   int old_cost = 0;\n   bool ok;\n \n+  update_df_init (def_insn, insn);\n+\n   /* forward_propagate_subreg may be operating on an instruction with\n      multiple sets.  If so, assume the cost of the new instruction is\n      not greater than the old one.  */\n@@ -991,14 +1004,6 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n     {\n       confirm_change_group ();\n       num_changes++;\n-\n-      df_ref_remove (use);\n-      if (!CONSTANT_P (new_rtx))\n-\t{\n-\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n-\t  update_df (insn, loc, DF_INSN_INFO_USES (insn_info), type, flags);\n-\t  update_df (insn, loc, DF_INSN_INFO_EQ_USES (insn_info), type, flags);\n-\t}\n     }\n   else\n     {\n@@ -1011,21 +1016,13 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n \t  if (dump_file)\n \t    fprintf (dump_file, \" Setting REG_EQUAL note\\n\");\n \n-\t  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (new_rtx));\n-\n-\t  /* ??? Is this still necessary if we add the note through\n-\t     set_unique_reg_note?  */\n-          if (!CONSTANT_P (new_rtx))\n-\t    {\n-\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n-\t      update_df (insn, loc, DF_INSN_INFO_USES (insn_info),\n-\t\t\t type, DF_REF_IN_NOTE);\n-\t      update_df (insn, loc, DF_INSN_INFO_EQ_USES (insn_info),\n-\t\t\t type, DF_REF_IN_NOTE);\n-\t    }\n+\t  note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (new_rtx));\n \t}\n     }\n \n+  if ((ok || note) && !CONSTANT_P (new_rtx))\n+    update_df (insn, note);\n+\n   return ok;\n }\n \n@@ -1153,6 +1150,7 @@ forward_propagate_asm (df_ref use, rtx def_insn, rtx def_set, rtx reg)\n   if (use_vec[0] && use_vec[1])\n     return false;\n \n+  update_df_init (def_insn, use_insn);\n   speed_p = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));\n   asm_operands = NULL_RTX;\n   switch (GET_CODE (use_pat))\n@@ -1203,6 +1201,7 @@ forward_propagate_asm (df_ref use, rtx def_insn, rtx def_set, rtx reg)\n   if (num_changes_pending () == 0 || !apply_change_group ())\n     return false;\n \n+  update_df (use_insn, NULL);\n   num_changes++;\n   return true;\n }\n@@ -1382,6 +1381,11 @@ fwprop_init (void)\n \n   build_single_def_use_links ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n+  active_defs = XNEWVEC (df_ref, max_reg_num ());\n+#ifdef ENABLE_CHECKING\n+  active_defs_check = sparseset_alloc (max_reg_num ());\n+#endif\n }\n \n static void\n@@ -1390,6 +1394,11 @@ fwprop_done (void)\n   loop_optimizer_finalize ();\n \n   VEC_free (df_ref, heap, use_def_ref);\n+  free (active_defs);\n+#ifdef ENABLE_CHECKING\n+  sparseset_free (active_defs_check);\n+#endif\n+\n   free_dominance_info (CDI_DOMINATORS);\n   cleanup_cfg (0);\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n@@ -1416,7 +1425,7 @@ fwprop (void)\n \n   fwprop_init ();\n \n-  /* Go through all the uses.  update_df will create new ones at the\n+  /* Go through all the uses.  df_uses_create will create new ones at the\n      end, and we'll go through them as well.\n \n      Do not forward propagate addresses into loops until after unrolling.\n@@ -1463,7 +1472,7 @@ fwprop_addr (void)\n   unsigned i;\n   fwprop_init ();\n \n-  /* Go through all the uses.  update_df will create new ones at the\n+  /* Go through all the uses.  df_uses_create will create new ones at the\n      end, and we'll go through them as well.  */\n   for (i = 0; i < DF_USES_TABLE_SIZE (); i++)\n     {"}]}