{"sha": "d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBhY2I5MzljOTI5ZGQ4YWQwZTRjYmZlY2ExZjBjNDljYjY5N2M3Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-17T17:59:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-17T17:59:20Z"}, "message": "rx: Implement cstoresf4.\n\nFrom-SVN: r168923", "tree": {"sha": "b105448070f929fc3c39d6d0c02008834fb45ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b105448070f929fc3c39d6d0c02008834fb45ba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72/comments", "author": null, "committer": null, "parents": [{"sha": "c06fc3d9a0fabd681491e8e87049174ff201e90f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c06fc3d9a0fabd681491e8e87049174ff201e90f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c06fc3d9a0fabd681491e8e87049174ff201e90f"}], "stats": {"total": 94, "additions": 94, "deletions": 0}, "files": [{"sha": "9045f868f9fc1589cc5770130f4094280f68ca9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72", "patch": "@@ -1,5 +1,7 @@\n 2011-01-17  Richard Henderson  <rth@redhat.com>\n \n+\t* config/rx/rx.md (cstoresf4, *cstoresf4): New patterns.\n+\n \t* config/rx/rx.c (rx_print_operand): Remove workaround for\n \tunsplit comparison operations.\n "}, {"sha": "cdae1cd75ff13ebcf81085f568cbeb357bf36c5b", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=d0acb939c929dd8ad0e4cbfeca1f0c49cb697c72", "patch": "@@ -739,6 +739,98 @@\n   [(set_attr \"length\" \"3\")]\n )\n \n+(define_expand \"cstoresf4\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (match_operator:SI 1 \"comparison_operator\"\n+\t\t    [(match_operand:SF 2 \"register_operand\" \"\")\n+\t\t     (match_operand:SF 3 \"register_operand\" \"\")]))\n+\t     (clobber (match_scratch:SI 4))])]\n+  \"ALLOW_RX_FPU_INSNS\"\n+{\n+  enum rtx_code cmp1, cmp2;\n+\n+  /* If the comparison needs swapping of operands, do that now.\n+     Do not split the comparison in two yet.  */\n+  if (rx_split_fp_compare (GET_CODE (operands[0]), &cmp1, &cmp2))\n+    {\n+      rtx op2, op3;\n+\n+      if (cmp2 != UNKNOWN)\n+\t{\n+\t  gcc_assert (cmp1 == UNORDERED);\n+\t  if (cmp2 == GT)\n+\t    cmp1 = UNGT;\n+\t  else if (cmp2 == LE)\n+\t    cmp1 = UNLE;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      op2 = operands[3];\n+      op3 = operands[2];\n+      operands[0] = gen_rtx_fmt_ee (cmp1, VOIDmode, op2, op3);\n+      operands[2] = op2;\n+      operands[3] = op3;\n+    }\n+})\n+\n+(define_insn_and_split \"*cstoresf4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 4 \"rx_fp_comparison_operator\"\n+\t [(match_operand:SF 2 \"register_operand\" \"r\")\n+\t  (match_operand:SF 3 \"rx_source_operand\" \"rFiQ\")]))\n+   (clobber (match_scratch:SI 1 \"=r\"))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  enum rtx_code cmp0, cmp1, cmp2;\n+  rtx flags, x;\n+  bool swap;\n+\n+  cmp0 = GET_CODE (operands[4]);\n+  swap = rx_split_fp_compare (cmp0, &cmp1, &cmp2);\n+  gcc_assert (!swap);\n+\n+  flags = gen_rtx_REG (CC_Fmode, CC_REG);\n+  x = gen_rtx_COMPARE (CC_Fmode, operands[2], operands[3]);\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+  emit_insn (x);\n+\n+  x = gen_rtx_fmt_ee (cmp1, SImode, flags, const0_rtx);\n+  x = gen_rtx_SET (VOIDmode, operands[0], x);\n+  emit_insn (x);\n+\n+  if (cmp0 == LTGT)\n+    {\n+      /* The one case of LTGT needs to be split into ORDERED && NE.  */\n+      x = gen_rtx_fmt_ee (EQ, VOIDmode, flags, const0_rtx);\n+      x = gen_rtx_IF_THEN_ELSE (SImode, x, const0_rtx, operands[0]);\n+      x = gen_rtx_SET (VOIDmode, operands[0], x);\n+      emit_insn (x);\n+    }\n+  else if (cmp2 == EQ || cmp2 == NE)\n+    {\n+      /* Oring the two flags can be performed with a movcc operation.  */\n+      x = gen_rtx_fmt_ee (cmp2, VOIDmode, flags, const0_rtx);\n+      x = gen_rtx_IF_THEN_ELSE (SImode, x, const1_rtx, operands[0]);\n+      x = gen_rtx_SET (VOIDmode, operands[0], x);\n+      emit_insn (x);\n+    }\n+  else if (cmp2 != UNKNOWN)\n+    {\n+      /* We can't use movcc, but need to or in another compare.\n+\t Do this by storing the second operation into the scratch.  */\n+      x = gen_rtx_fmt_ee (cmp2, SImode, flags, const0_rtx);\n+      x = gen_rtx_SET (VOIDmode, operands[1], x);\n+      emit_insn (x);\n+\n+      emit_insn (gen_iorsi3 (operands[0], operands[0], operands[1]));\n+    }\n+  DONE;\n+})\n+\n (define_expand \"movsicc\"\n   [(parallel\n     [(set (match_operand:SI                  0 \"register_operand\")"}]}