{"sha": "63f5d5b818319129217e41bcb23db53f99ff11b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNmNWQ1YjgxODMxOTEyOTIxN2U0MWJjYjIzZGI1M2Y5OWZmMTFiMA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-12-10T03:45:40Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-12-10T03:45:40Z"}, "message": "remove gengtype support for param_is use_param, if_marked and splay tree allocators\n\ngcc/\n\n\t* plugin.c, plugin.def, ggc.h, ggc-common.c, gengtype.h, gengtype.c,\n\tgengtype-state.c, gengtype-parse.c, gentype-lex.l, gcc-plugin.h,\n\tdoc/plugins.texi, doc/gty.texi: Remove support for if_marked and\n\tparam_is.\n\ninclude/\n\n\t* hashtab.h, splay-tree.h: Remove GTY markers.\n\nFrom-SVN: r218558", "tree": {"sha": "d68af710e723e37215793eba5a9d183e68b6f322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d68af710e723e37215793eba5a9d183e68b6f322"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63f5d5b818319129217e41bcb23db53f99ff11b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f5d5b818319129217e41bcb23db53f99ff11b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f5d5b818319129217e41bcb23db53f99ff11b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f5d5b818319129217e41bcb23db53f99ff11b0/comments", "author": null, "committer": null, "parents": [{"sha": "59bce71381be24449aaf902bc1bc64a12b373bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bce71381be24449aaf902bc1bc64a12b373bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59bce71381be24449aaf902bc1bc64a12b373bf4"}], "stats": {"total": 1036, "additions": 100, "deletions": 936}, "files": [{"sha": "49ab6b38b2e3c6a2e600f66ad690c552ebd5998c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -1,3 +1,10 @@\n+2014-12-09  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* plugin.c, plugin.def, ggc.h, ggc-common.c, gengtype.h, gengtype.c,\n+\tgengtype-state.c, gengtype-parse.c, gentype-lex.l, gcc-plugin.h,\n+\tdoc/plugins.texi, doc/gty.texi: Remove support for if_marked and\n+\tparam_is.\n+\n 2014-12-10  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/53513"}, {"sha": "aa6f84f9697d375636b29e25e5121f1b2dbac40f", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -245,54 +245,6 @@ The @code{desc} and @code{tag} options can also be used for inheritance\n to denote which subclass an instance is.  See @ref{Inheritance and GTY}\n for more information.\n \n-@findex param_is\n-@findex use_param\n-@item param_is (@var{type})\n-@itemx use_param\n-\n-Sometimes it's convenient to define some data structure to work on\n-generic pointers (that is, @code{PTR}) and then use it with a specific\n-type.  @code{param_is} specifies the real type pointed to, and\n-@code{use_param} says where in the generic data structure that type\n-should be put.\n-\n-For instance, to have a @code{htab_t} that points to trees, one would\n-write the definition of @code{htab_t} like this:\n-@smallexample\n-typedef struct GTY(()) @{\n-  @dots{}\n-  void ** GTY ((use_param, @dots{})) entries;\n-  @dots{}\n-@} htab_t;\n-@end smallexample\n-and then declare variables like this:\n-@smallexample\n-  static htab_t GTY ((param_is (union tree_node))) ict;\n-@end smallexample\n-\n-@findex param@var{n}_is\n-@findex use_param@var{n}\n-@item param@var{n}_is (@var{type})\n-@itemx use_param@var{n}\n-\n-In more complicated cases, the data structure might need to work on\n-several different types, which might not necessarily all be pointers.\n-For this, @code{param1_is} through @code{param9_is} may be used to\n-specify the real type of a field identified by @code{use_param1} through\n-@code{use_param9}.\n-\n-@findex use_params\n-@item use_params\n-\n-When a structure contains another structure that is parameterized,\n-there's no need to do anything special, the inner structure inherits the\n-parameters of the outer one.  When a structure contains a pointer to a\n-parameterized structure, the type machinery won't automatically detect\n-this (it could, it just doesn't yet), so it's necessary to tell it that\n-the pointed-to structure should use the same parameters as the outer\n-structure.  This is done by marking the pointer with the\n-@code{use_params} option.\n-\n @findex cache\n @item cache\n \n@@ -309,23 +261,6 @@ garbage collection runs, there's no need to mark anything pointed to\n by this variable, it can just be set to @code{NULL} instead.  This is used\n to keep a list of free structures around for re-use.\n \n-@findex if_marked\n-@item if_marked (\"@var{expression}\")\n-\n-Suppose you want some kinds of object to be unique, and so you put them\n-in a hash table.  If garbage collection marks the hash table, these\n-objects will never be freed, even if the last other reference to them\n-goes away.  GGC has special handling to deal with this: if you use the\n-@code{if_marked} option on a global hash table, GGC will call the\n-routine whose name is the parameter to the option on each hash table\n-entry.  If the routine returns nonzero, the hash table entry will\n-be marked as usual.  If the routine returns zero, the hash table entry\n-will be deleted.\n-\n-The routine @code{ggc_marked_p} can be used to determine if an element\n-has been marked already; in fact, the usual case is to use\n-@code{if_marked (\"ggc_marked_p\")}.\n-\n @findex mark_hook\n @item mark_hook (\"@var{hook-routine-name}\")\n "}, {"sha": "96df5066d59f6615030ec4df9b5960484556215e", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -185,7 +185,6 @@ enum plugin_event\n   PLUGIN_GGC_MARKING,           /* Extend the GGC marking. */\n   PLUGIN_GGC_END,               /* Called at end of GGC. */\n   PLUGIN_REGISTER_GGC_ROOTS,    /* Register an extra GGC root table. */\n-  PLUGIN_REGISTER_GGC_CACHES,   /* Register an extra GGC cache table. */\n   PLUGIN_ATTRIBUTES,            /* Called during attribute registration */\n   PLUGIN_START_UNIT,            /* Called before processing a translation unit.  */\n   PLUGIN_PRAGMAS,               /* Called during pragma registration. */\n@@ -233,10 +232,9 @@ the arguments:\n @item @code{void *user_data}: Pointer to plugin-specific data.\n @end itemize\n \n-For the @i{PLUGIN_PASS_MANAGER_SETUP}, @i{PLUGIN_INFO},\n-@i{PLUGIN_REGISTER_GGC_ROOTS} and @i{PLUGIN_REGISTER_GGC_CACHES}\n-pseudo-events the @code{callback} should be null, and the\n-@code{user_data} is specific.\n+For the @i{PLUGIN_PASS_MANAGER_SETUP}, @i{PLUGIN_INFO}, and\n+@i{PLUGIN_REGISTER_GGC_ROOTS} pseudo-events the @code{callback} should be null,\n+and the @code{user_data} is specific.\n \n When the @i{PLUGIN_PRAGMAS} event is triggered (with a null pointer as\n data from GCC), plugins may register their own pragmas.  Notice that\n@@ -321,21 +319,22 @@ done by registering a callback (called with a null @code{gcc_data})\n for the @code{PLUGIN_GGC_MARKING} event. Such callbacks can call the\n @code{ggc_set_mark} routine, preferably through the @code{ggc_mark} macro\n (and conversely, these routines should usually not be used in plugins\n-outside of the @code{PLUGIN_GGC_MARKING} event).\n+outside of the @code{PLUGIN_GGC_MARKING} event).  Plugins that wish to hold\n+weak references to gc data may also use this event to drop weak references when\n+the object is about to be collected.  The @code{ggc_marked_p} function can be\n+used to tell if an object is marked, or is about to  be collected.  The\n+@code{gt_clear_cache} overloads which some types define may also be of use in\n+managing weak references.\n \n Some plugins may need to add extra GGC root tables, e.g. to handle their own\n @code{GTY}-ed data. This can be done with the @code{PLUGIN_REGISTER_GGC_ROOTS}\n pseudo-event with a null callback and the extra root table (of type @code{struct\n-ggc_root_tab*}) as @code{user_data}.  Plugins that want to use the\n-@code{if_marked} hash table option can add the extra GGC cache tables generated\n-by @code{gengtype} using the @code{PLUGIN_REGISTER_GGC_CACHES} pseudo-event with\n-a null callback and the extra cache table (of type @code{struct ggc_cache_tab*})\n-as @code{user_data}.  Running the @code{gengtype -p @var{source-dir}\n-@var{file-list} @var{plugin*.c} ...} utility generates these extra root tables.\n+ggc_root_tab*}) as @code{user_data}.  Running the\n+ @code{gengtype -p @var{source-dir} @var{file-list} @var{plugin*.c} ...}\n+utility generates these extra root tables.\n \n You should understand the details of memory management inside GCC\n-before using @code{PLUGIN_GGC_MARKING}, @code{PLUGIN_REGISTER_GGC_ROOTS}\n-or @code{PLUGIN_REGISTER_GGC_CACHES}.\n+before using @code{PLUGIN_GGC_MARKING} or @code{PLUGIN_REGISTER_GGC_ROOTS}.\n \n \n @node Plugins description"}, {"sha": "6ebb8f0154a5e392cf995830056a8a6d40381829", "filename": "gcc/gcc-plugin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgcc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgcc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-plugin.h?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -150,8 +150,8 @@ extern int get_event_last (void);\n int get_named_event_id (const char *name, enum insert_option insert);\n \n /* This is also called without a callback routine for the\n-   PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, PLUGIN_REGISTER_GGC_ROOTS and\n-   PLUGIN_REGISTER_GGC_CACHES pseudo-events, with a specific user_data.\n+   PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO and PLUGIN_REGISTER_GGC_ROOTS\n+   pseudo-events, with a specific user_data.\n   */\n \n extern void register_callback (const char *plugin_name,"}, {"sha": "d5a6cc838ff685cf76ccff297e4be6172e7c378d", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -126,10 +126,6 @@ CXX_KEYWORD inline|public:|private:|protected:|template|operator|friend|static\n \"nested_ptr\"/{EOID}\t\t{ return NESTED_PTR; }\n \"user\"/{EOID}\t\t\t{ return USER_GTY; }\n [0-9]+\t\t\t\t{ return NUM; }\n-\"param\"[0-9]*\"_is\"/{EOID}\t\t{\n-  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);\n-  return PARAM_IS;\n-}\n \n {IWORD}({WS}{IWORD})*/{EOID}\t\t|\n \"ENUM_BITFIELD\"{WS}?\"(\"{WS}?{ID}{WS}?\")\"\t{"}, {"sha": "f99b853cd663bdbcf9d61af51e340c98c4ca41fc", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -538,7 +538,6 @@ nestedptr_optvalue (options_p prev)\n /* One GTY(()) option:\n    ID str_optvalue_opt\n    | PTR_ALIAS type_optvalue\n-   | PARAM_IS type_optvalue\n    | NESTED_PTR nestedptr_optvalue\n */\n static options_p\n@@ -553,9 +552,6 @@ option (options_p prev)\n       advance ();\n       return type_optvalue (prev, \"ptr_alias\");\n \n-    case PARAM_IS:\n-      return type_optvalue (prev, advance ());\n-\n     case NESTED_PTR:\n       advance ();\n       return nestedptr_optvalue (prev);"}, {"sha": "9eaf07804dd8d186233a955205e83a4a07b8cd4c", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 3, "deletions": 142, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -54,8 +54,6 @@ type_lineloc (const_type_p ty)\n     case TYPE_USER_STRUCT:\n     case TYPE_UNDEFINED:\n       return CONST_CAST (struct fileloc*, &ty->u.s.line);\n-    case TYPE_PARAM_STRUCT:\n-      return CONST_CAST (struct fileloc*, &ty->u.param_struct.line);\n     case TYPE_SCALAR:\n     case TYPE_STRING:\n     case TYPE_POINTER:\n@@ -180,7 +178,6 @@ class state_writer : public s_expr_writer\n   void write_state_user_struct_type (type_p current);\n   void write_state_union_type (type_p current);\n   void write_state_lang_struct_type (type_p current);\n-  void write_state_param_struct_type (type_p current);\n   void write_state_pointer_type (type_p current);\n   void write_state_array_type (type_p current);\n   void write_state_gc_used (enum gc_used_enum gus);\n@@ -190,7 +187,6 @@ class state_writer : public s_expr_writer\n   int write_state_pair_list (pair_p list);\n   void write_state_typedefs (void);\n   void write_state_structures (void);\n-  void write_state_param_structs (void);\n   void write_state_variables (void);\n   void write_state_srcdir (void);\n   void write_state_files_list (void);\n@@ -635,7 +631,6 @@ state_token_is_name (struct state_token_st *p, const char *name)\n  * We want to serialize :\n  *          - typedefs list\n  *          - structures list\n- *          - param_structs list\n  *          - variables list\n  *\n  * So, we have one routine for each kind of data.  The main writing\n@@ -1023,29 +1018,6 @@ state_writer::write_state_lang_struct_type (type_p current)\n   end_s_expr ();\n }\n \n-/* Write a parametrized structure GTY type.  */\n-void\n-state_writer::write_state_param_struct_type (type_p current)\n-{\n-  int i;\n-\n-  write_any_indent (0);\n-  fprintf (state_file, \"param_struct \");\n-  write_state_common_type_content (current);\n-  write_state_type (current->u.param_struct.stru);\n-  for (i = 0; i < NUM_PARAM; i++)\n-    {\n-      if (current->u.param_struct.param[i] != NULL)\n-\twrite_state_type (current->u.param_struct.param[i]);\n-      else\n-\t{\n-\t  write_any_indent (0);\n-\t  fprintf (state_file, \"nil \");\n-\t}\n-    }\n-  write_state_fileloc (&current->u.param_struct.line);\n-}\n-\n /* Write a pointer type.  */\n void\n state_writer::write_state_pointer_type (type_p current)\n@@ -1166,9 +1138,6 @@ state_writer::write_state_type (type_p current)\n \tcase TYPE_LANG_STRUCT:\n \t  write_state_lang_struct_type (current);\n \t  break;\n-\tcase TYPE_PARAM_STRUCT:\n-\t  write_state_param_struct_type (current);\n-\t  break;\n \tcase TYPE_SCALAR:\n \t  write_state_scalar_type (current);\n \t  break;\n@@ -1225,10 +1194,9 @@ state_writer::write_state_pair_list (pair_p list)\n \n }\n \n-/* When writing imported linked lists, like typedefs, structures,\n-   param_structs, ... we count their length first and write it.  These\n-   eases the reading, and enables an extra verification on the number\n-   of actually read items.  */\n+/* When writing imported linked lists, like typedefs, structures, ... we count\n+   their length first and write it.  This eases the reading, and enables an\n+   extra verification on the number of actually read items.  */\n \n /* Write our typedefs.  */\n void\n@@ -1270,25 +1238,6 @@ state_writer::write_state_structures (void)\n     printf (\"%s wrote %d structures in state\\n\", progname, nbstruct);\n }\n \n-/* Write our param_struct-s.  */\n-void\n-state_writer::write_state_param_structs (void)\n-{\n-  int nbparamstruct = 0;\n-  type_p current;\n-\n-  for (current = param_structs; current != NULL; current = current->next)\n-    nbparamstruct++;\n-\n-  begin_s_expr (\"param_structs\");\n-  fprintf (state_file, \"%d\", nbparamstruct);\n-\n-  for (current = param_structs; current != NULL; current = current->next)\n-    write_state_type (current);\n-\n-  end_s_expr ();\n-}\n-\n /* Write our variables.  */\n void\n state_writer::write_state_variables (void)\n@@ -1425,7 +1374,6 @@ write_state (const char *state_path)\n   sw.write_state_files_list ();\n   sw.write_state_structures ();\n   sw.write_state_typedefs ();\n-  sw.write_state_param_structs ();\n   sw.write_state_variables ();\n   write_state_trailer ();\n   statelen = ftell (state_file);\n@@ -1810,34 +1758,6 @@ read_state_lang_struct_type (type_p type)\n }\n \n \n-/* Read a param_struct type for GTY parametrized structures.  */\n-static void\n-read_state_param_struct_type (type_p type)\n-{\n-  int i;\n-  struct state_token_st *t0;\n-\n-  type->kind = TYPE_PARAM_STRUCT;\n-  read_state_common_type_content (type);\n-  DBGPRINTF (\"read param_struct type @%p #%d\",\n-\t     (void *) type, type->state_number);\n-  read_state_type (&(type->u.param_struct.stru));\n-\n-  for (i = 0; i < NUM_PARAM; i++)\n-    {\n-      t0 = peek_state_token (0);\n-      if (state_token_is_name (t0, \"nil\"))\n-\t{\n-\t  type->u.param_struct.param[i] = NULL;\n-\t  next_state_tokens (1);\n-\t}\n-      else\n-\tread_state_type (&(type->u.param_struct.param[i]));\n-    }\n-  read_state_fileloc (&(type->u.param_struct.line));\n-}\n-\n-\n /* Read the gc used information.  */\n static void\n read_state_gc_used (enum gc_used_enum *pgus)\n@@ -1939,12 +1859,6 @@ read_state_type (type_p *current)\n \t      next_state_tokens (1);\n \t      read_state_lang_struct_type (*current);\n \t    }\n-\t  else if (state_token_is_name (t0, \"param_struct\"))\n-\t    {\n-\t      *current = XCNEW (struct type);\n-\t      next_state_tokens (1);\n-\t      read_state_param_struct_type (*current);\n-\t    }\n \t  else if (state_token_is_name (t0, \"pointer\"))\n \t    {\n \t      *current = XCNEW (struct type);\n@@ -2440,58 +2354,6 @@ read_state_structures (type_p *structures)\n }\n \n \n-/* Read the param_struct-s.  */\n-static void\n-read_state_param_structs (type_p *param_structs)\n-{\n-  int nbparamstructs = 0;\n-  int countparamstructs = 0;\n-  type_p head = NULL;\n-  type_p previous = NULL;\n-  type_p tmp;\n-  struct state_token_st *t0 = peek_state_token (0);\n-  struct state_token_st *t1 = peek_state_token (1);\n-  struct state_token_st *t2 = peek_state_token (2);\n-\n-  if (state_token_kind (t0) == STOK_LEFTPAR\n-      && state_token_is_name (t1, \"!param_structs\")\n-      && state_token_kind (t2) == STOK_INTEGER)\n-    {\n-      nbparamstructs = t2->stok_un.stok_num;\n-      next_state_tokens (3);\n-      t0 = t1 = t2 = NULL;\n-      t0 = peek_state_token (0);\n-      while (state_token_kind (t0) != STOK_RIGHTPAR)\n-\t{\n-\t  tmp = NULL;\n-\t  read_state_type (&tmp);\n-\t  if (head == NULL)\n-\t    {\n-\t      head = tmp;\n-\t      previous = head;\n-\t    }\n-\t  else\n-\t    {\n-\t      previous->next = tmp;\n-\t      previous = tmp;\n-\t    }\n-\t  t0 = peek_state_token (0);\n-\t  countparamstructs++;\n-\t}\n-      next_state_tokens (1);\n-    }\n-  else\n-    fatal_reading_state (t0, \"Bad param_structs syntax\");\n-  t0 = peek_state_token (0);\n-  if (countparamstructs != nbparamstructs)\n-    fatal_reading_state_printf\n-      (t0,\n-       \"invalid number of param_structs expected %d got %d\",\n-       nbparamstructs, countparamstructs);\n-  *param_structs = head;\n-}\n-\n-\n /* Read the variables.  */\n static void\n read_state_variables (pair_p *variables)\n@@ -2738,7 +2600,6 @@ read_state (const char *path)\n       (NULL_STATE_TOKEN, \"input error while reading state [%s]\",\n        xstrerror (errno));\n   read_state_typedefs (&typedefs);\n-  read_state_param_structs (&param_structs);\n   read_state_variables (&variables);\n   read_state_trailer ();\n "}, {"sha": "04b77471bd2445da0e074810af56307adfd469ef", "filename": "gcc/gengtype.c", "status": "modified", "additions": 55, "deletions": 537, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -186,7 +186,7 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n {\n   int nb_types = 0, nb_scalar = 0, nb_string = 0;\n   int nb_struct = 0, nb_union = 0, nb_array = 0, nb_pointer = 0;\n-  int nb_lang_struct = 0, nb_param_struct = 0;\n+  int nb_lang_struct = 0;\n   int nb_user_struct = 0, nb_undefined = 0;\n   type_p p = NULL;\n   for (p = t; p; p = p->next)\n@@ -220,9 +220,6 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n \tcase TYPE_LANG_STRUCT:\n \t  nb_lang_struct++;\n \t  break;\n-\tcase TYPE_PARAM_STRUCT:\n-\t  nb_param_struct++;\n-\t  break;\n \tcase TYPE_NONE:\n \t  gcc_unreachable ();\n \t}\n@@ -235,9 +232,8 @@ dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n     fprintf (stderr, \"@@%%@@ %d structs, %d unions\\n\", nb_struct, nb_union);\n   if (nb_pointer > 0 || nb_array > 0)\n     fprintf (stderr, \"@@%%@@ %d pointers, %d arrays\\n\", nb_pointer, nb_array);\n-  if (nb_lang_struct > 0 || nb_param_struct > 0)\n-    fprintf (stderr, \"@@%%@@ %d lang_structs, %d param_structs\\n\",\n-\t     nb_lang_struct, nb_param_struct);\n+  if (nb_lang_struct > 0)\n+    fprintf (stderr, \"@@%%@@ %d lang_structs\\n\", nb_lang_struct);\n   if (nb_user_struct > 0)\n     fprintf (stderr, \"@@%%@@ %d user_structs\\n\", nb_user_struct);\n   if (nb_undefined > 0)\n@@ -519,10 +515,8 @@ struct type scalar_char = {\n \n pair_p typedefs = NULL;\n type_p structures = NULL;\n-type_p param_structs = NULL;\n pair_p variables = NULL;\n \n-static type_p find_param_structure (type_p t, type_p param[NUM_PARAM]);\n static type_p adjust_field_tree_exp (type_p t, options_p opt);\n static type_p adjust_field_rtx_def (type_p t, options_p opt);\n \n@@ -872,34 +866,6 @@ find_structure (const char *name, enum typekind kind)\n   return s;\n }\n \n-/* Return the previously-defined parameterized structure for structure\n-   T and parameters PARAM, or a new parameterized empty structure or\n-   union if none was defined previously.  */\n-\n-static type_p\n-find_param_structure (type_p t, type_p param[NUM_PARAM])\n-{\n-  type_p res;\n-\n-  for (res = param_structs; res; res = res->next)\n-    if (res->u.param_struct.stru == t\n-\t&& memcmp (res->u.param_struct.param, param,\n-\t\t   sizeof (type_p) * NUM_PARAM) == 0)\n-      break;\n-  if (res == NULL)\n-    {\n-      type_count++;\n-      res = XCNEW (struct type);\n-      res->kind = TYPE_PARAM_STRUCT;\n-      res->next = param_structs;\n-      res->state_number = -type_count;\n-      param_structs = res;\n-      res->u.param_struct.stru = t;\n-      memcpy (res->u.param_struct.param, param, sizeof (type_p) * NUM_PARAM);\n-    }\n-  return res;\n-}\n-\n /* Return a scalar type with name NAME.  */\n \n type_p\n@@ -1462,12 +1428,6 @@ adjust_field_type (type_p t, options_p opt)\n {\n   int length_p = 0;\n   const int pointer_p = t->kind == TYPE_POINTER;\n-  type_p params[NUM_PARAM];\n-  int params_p = 0;\n-  int i;\n-\n-  for (i = 0; i < NUM_PARAM; i++)\n-    params[i] = NULL;\n \n   for (; opt; opt = opt->next)\n     if (strcmp (opt->name, \"length\") == 0)\n@@ -1482,31 +1442,6 @@ adjust_field_type (type_p t, options_p opt)\n \t  }\n \tlength_p = 1;\n       }\n-    else if ((strcmp (opt->name, \"param_is\") == 0\n-\t      || (strncmp (opt->name, \"param\", 5) == 0\n-\t\t  && ISDIGIT (opt->name[5])\n-\t\t  && strcmp (opt->name + 6, \"_is\") == 0))\n-\t     && opt->kind == OPTION_TYPE)\n-      {\n-\tint num = ISDIGIT (opt->name[5]) ? opt->name[5] - '0' : 0;\n-\n-\tif (!union_or_struct_p (t)\n-\t    && (t->kind != TYPE_POINTER || !union_or_struct_p (t->u.p)))\n-\t  {\n-\t    error_at_line (&lexer_line,\n-\t\t\t   \"option `%s' may only be applied to structures or structure pointers\",\n-\t\t\t   opt->name);\n-\t    return t;\n-\t  }\n-\n-\tparams_p = 1;\n-\tif (params[num] != NULL)\n-\t  error_at_line (&lexer_line, \"duplicate `%s' option\", opt->name);\n-\tif (!ISDIGIT (opt->name[5]))\n-\t  params[num] = create_pointer (opt->info.type);\n-\telse\n-\t  params[num] = opt->info.type;\n-      }\n     else if (strcmp (opt->name, \"special\") == 0\n \t     && opt->kind == OPTION_STRING)\n       {\n@@ -1519,16 +1454,6 @@ adjust_field_type (type_p t, options_p opt)\n \t  error_at_line (&lexer_line, \"unknown special `%s'\", special_name);\n       }\n \n-  if (params_p)\n-    {\n-      type_p realt;\n-\n-      if (pointer_p)\n-\tt = t->u.p;\n-      realt = find_param_structure (t, params);\n-      t = pointer_p ? create_pointer (realt) : realt;\n-    }\n-\n   if (!length_p\n       && pointer_p && t->u.p->kind == TYPE_SCALAR && t->u.p->u.scalar_is_char)\n     return &string_type;\n@@ -1541,27 +1466,23 @@ adjust_field_type (type_p t, options_p opt)\n }\n \f\n \n-static void set_gc_used_type (type_p, enum gc_used_enum, type_p *,\n-\t\t\t      bool = false);\n+static void set_gc_used_type (type_p, enum gc_used_enum, bool = false);\n static void set_gc_used (pair_p);\n \n /* Handle OPT for set_gc_used_type.  */\n \n static void\n process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n-\t\t    int *pass_param, int *length, int *skip,\n-\t\t    type_p *nested_ptr)\n+\t\t    int *length, int *skip, type_p *nested_ptr)\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n     if (strcmp (o->name, \"ptr_alias\") == 0 && level == GC_POINTED_TO\n \t&& o->kind == OPTION_TYPE)\n       set_gc_used_type (o->info.type,\n-\t\t\tGC_POINTED_TO, NULL);\n+\t\t\tGC_POINTED_TO);\n     else if (strcmp (o->name, \"maybe_undef\") == 0)\n       *maybe_undef = 1;\n-    else if (strcmp (o->name, \"use_params\") == 0)\n-      *pass_param = 1;\n     else if (strcmp (o->name, \"length\") == 0)\n       *length = 1;\n     else if (strcmp (o->name, \"skip\") == 0)\n@@ -1595,7 +1516,7 @@ process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n    'EnumValue' is a type.  */\n \n static void\n-set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM],\n+set_gc_used_type (type_p t, enum gc_used_enum level,\n \t\t  bool allow_undefined_types)\n {\n   if (t->gc_used >= level)\n@@ -1614,44 +1535,36 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM],\n \ttype_p dummy2;\n \tbool allow_undefined_field_types = (t->kind == TYPE_USER_STRUCT);\n \n-\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy, &dummy,\n+\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy,\n \t\t\t    &dummy2);\n \n \tif (t->u.s.base_class)\n-\t  set_gc_used_type (t->u.s.base_class, level, param,\n-\t\t\t    allow_undefined_types);\n+\t  set_gc_used_type (t->u.s.base_class, level, allow_undefined_types);\n \t/* Anything pointing to a base class might actually be pointing\n \t   to a subclass.  */\n \tfor (type_p subclass = t->u.s.first_subclass; subclass;\n \t     subclass = subclass->u.s.next_sibling_class)\n-\t  set_gc_used_type (subclass, level, param,\n-\t\t\t    allow_undefined_types);\n+\t  set_gc_used_type (subclass, level, allow_undefined_types);\n \n \tFOR_ALL_INHERITED_FIELDS(t, f)\n \t  {\n \t    int maybe_undef = 0;\n-\t    int pass_param = 0;\n \t    int length = 0;\n \t    int skip = 0;\n \t    type_p nested_ptr = NULL;\n-\t    process_gc_options (f->opt, level, &maybe_undef, &pass_param,\n-\t\t\t\t&length, &skip, &nested_ptr);\n+\t    process_gc_options (f->opt, level, &maybe_undef, &length, &skip,\n+\t\t\t\t&nested_ptr);\n \n \t    if (nested_ptr && f->type->kind == TYPE_POINTER)\n-\t      set_gc_used_type (nested_ptr, GC_POINTED_TO,\n-\t\t\t\tpass_param ? param : NULL);\n+\t      set_gc_used_type (nested_ptr, GC_POINTED_TO);\n \t    else if (length && f->type->kind == TYPE_POINTER)\n-\t      set_gc_used_type (f->type->u.p, GC_USED, NULL);\n+\t      set_gc_used_type (f->type->u.p, GC_USED);\n \t    else if (maybe_undef && f->type->kind == TYPE_POINTER)\n-\t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO, NULL);\n-\t    else if (pass_param && f->type->kind == TYPE_POINTER && param)\n-\t      set_gc_used_type (find_param_structure (f->type->u.p, param),\n-\t\t\t\tGC_POINTED_TO, NULL);\n+\t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO);\n \t    else if (skip)\n \t      ;\t\t\t/* target type is not used through this field */\n \t    else\n-\t      set_gc_used_type (f->type, GC_USED, pass_param ? param : NULL,\n-\t\t\t\tallow_undefined_field_types);\n+\t      set_gc_used_type (f->type, GC_USED, allow_undefined_field_types);\n \t  }\n \tbreak;\n       }\n@@ -1666,32 +1579,16 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM],\n       break;\n \n     case TYPE_POINTER:\n-      set_gc_used_type (t->u.p, GC_POINTED_TO, NULL);\n+      set_gc_used_type (t->u.p, GC_POINTED_TO);\n       break;\n \n     case TYPE_ARRAY:\n-      set_gc_used_type (t->u.a.p, GC_USED, param);\n+      set_gc_used_type (t->u.a.p, GC_USED);\n       break;\n \n     case TYPE_LANG_STRUCT:\n       for (t = t->u.s.lang_struct; t; t = t->next)\n-\tset_gc_used_type (t, level, param);\n-      break;\n-\n-    case TYPE_PARAM_STRUCT:\n-      {\n-\tint i;\n-\tfor (i = 0; i < NUM_PARAM; i++)\n-\t  if (t->u.param_struct.param[i] != 0)\n-\t    set_gc_used_type (t->u.param_struct.param[i], GC_USED, NULL);\n-      }\n-      if (t->u.param_struct.stru->gc_used == GC_POINTED_TO)\n-\tlevel = GC_POINTED_TO;\n-      else\n-\tlevel = GC_USED;\n-      t->u.param_struct.stru->gc_used = GC_UNUSED;\n-      set_gc_used_type (t->u.param_struct.stru, level,\n-\t\t\tt->u.param_struct.param);\n+\tset_gc_used_type (t, level);\n       break;\n \n     default:\n@@ -1708,7 +1605,7 @@ set_gc_used (pair_p variables)\n   pair_p p;\n   for (p = variables; p; p = p->next)\n     {\n-      set_gc_used_type (p->type, GC_USED, NULL);\n+      set_gc_used_type (p->type, GC_USED);\n       nbvars++;\n     };\n   if (verbosity_level >= 2)\n@@ -2540,27 +2437,25 @@ static void output_escaped_param (struct walk_type_data *d,\n \t\t\t\t  const char *, const char *);\n static void output_mangled_typename (outf_p, const_type_p);\n static void walk_type (type_p t, struct walk_type_data *d);\n-static void write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n+static void write_func_for_structure (type_p orig_s, type_p s,\n \t\t\t\t      const struct write_types_data *wtd);\n static void write_types_process_field\n   (type_p f, const struct walk_type_data *d);\n static void write_types (outf_p output_header,\n \t\t\t type_p structures,\n-\t\t\t type_p param_structs,\n \t\t\t const struct write_types_data *wtd);\n static void write_types_local_process_field\n   (type_p f, const struct walk_type_data *d);\n-static void write_local_func_for_structure\n-  (const_type_p orig_s, type_p s, type_p *param);\n+static void write_local_func_for_structure (const_type_p orig_s, type_p s);\n static void write_local (outf_p output_header,\n-\t\t\t type_p structures, type_p param_structs);\n+\t\t\t type_p structures);\n static int contains_scalar_p (type_p t);\n static void put_mangled_filename (outf_p, const input_file *);\n static void finish_root_table (struct flist *flp, const char *pfx,\n \t\t\t       const char *tname, const char *lastname,\n \t\t\t       const char *name);\n static void write_root (outf_p, pair_p, type_p, const char *, int,\n-\t\t\tstruct fileloc *, const char *, bool);\n+\t\t\tstruct fileloc *, bool);\n static void write_array (outf_p f, pair_p v,\n \t\t\t const struct write_types_data *wtd);\n static void write_roots (pair_p, bool);\n@@ -2579,7 +2474,6 @@ struct walk_type_data\n   int counter;\n   const struct fileloc *line;\n   lang_bitmap bitmap;\n-  type_p *param;\n   int used_length;\n   type_p orig_s;\n   const char *reorder_fn;\n@@ -2660,15 +2554,6 @@ output_mangled_typename (outf_p of, const_type_p t)\n \t    free (CONST_CAST (char *, id_for_tag));\n \t}\n \tbreak;\n-      case TYPE_PARAM_STRUCT:\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < NUM_PARAM; i++)\n-\t    if (t->u.param_struct.param[i] != NULL)\n-\t      output_mangled_typename (of, t->u.param_struct.param[i]);\n-\t  output_mangled_typename (of, t->u.param_struct.stru);\n-\t}\n-\tbreak;\n       case TYPE_ARRAY:\n \tgcc_unreachable ();\n       }\n@@ -2793,8 +2678,7 @@ walk_subclasses (type_p base, struct walk_type_data *d,\n    containing the current object, D->OPT is a list of options to\n    apply, D->INDENT is the current indentation level, D->LINE is used\n    to print error messages, D->BITMAP indicates which languages to\n-   print the structure for, and D->PARAM is the current parameter\n-   (from an enclosing param_is option).  */\n+   print the structure for.  */\n \n static void\n walk_type (type_p t, struct walk_type_data *d)\n@@ -2803,8 +2687,6 @@ walk_type (type_p t, struct walk_type_data *d)\n   const char *desc = NULL;\n   const char *type_tag = NULL;\n   int maybe_undef_p = 0;\n-  int use_param_num = -1;\n-  int use_params_p = 0;\n   int atomic_p = 0;\n   options_p oo;\n   const struct nested_ptr_data *nested_ptr_d = NULL;\n@@ -2815,11 +2697,6 @@ walk_type (type_p t, struct walk_type_data *d)\n       length = oo->info.string;\n     else if (strcmp (oo->name, \"maybe_undef\") == 0)\n       maybe_undef_p = 1;\n-    else if (strncmp (oo->name, \"use_param\", 9) == 0\n-\t     && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n-      use_param_num = oo->name[9] == '\\0' ? 0 : oo->name[9] - '0';\n-    else if (strcmp (oo->name, \"use_params\") == 0)\n-      use_params_p = 1;\n     else if (strcmp (oo->name, \"desc\") == 0 && oo->kind == OPTION_STRING)\n       desc = oo->info.string;\n     else if (strcmp (oo->name, \"mark_hook\") == 0)\n@@ -2839,11 +2716,6 @@ walk_type (type_p t, struct walk_type_data *d)\n       atomic_p = 1;\n     else if (strcmp (oo->name, \"default\") == 0)\n       ;\n-    else if (strcmp (oo->name, \"param_is\") == 0)\n-      ;\n-    else if (strncmp (oo->name, \"param\", 5) == 0\n-\t     && ISDIGIT (oo->name[5]) && strcmp (oo->name + 6, \"_is\") == 0)\n-      ;\n     else if (strcmp (oo->name, \"chain_next\") == 0)\n       ;\n     else if (strcmp (oo->name, \"chain_prev\") == 0)\n@@ -2862,39 +2734,6 @@ walk_type (type_p t, struct walk_type_data *d)\n   if (d->used_length)\n     length = NULL;\n \n-  if (use_params_p)\n-    {\n-      int pointer_p = t->kind == TYPE_POINTER;\n-\n-      if (pointer_p)\n-\tt = t->u.p;\n-      if (!union_or_struct_p (t))\n-\terror_at_line (d->line, \"`use_params' option on unimplemented type\");\n-      else\n-\tt = find_param_structure (t, d->param);\n-      if (pointer_p)\n-\tt = create_pointer (t);\n-    }\n-\n-  if (use_param_num != -1)\n-    {\n-      if (d->param != NULL && d->param[use_param_num] != NULL)\n-\t{\n-\t  type_p nt = d->param[use_param_num];\n-\n-\t  if (t->kind == TYPE_ARRAY)\n-\t    nt = create_array (nt, t->u.a.len);\n-\t  else if (length != NULL && t->kind == TYPE_POINTER)\n-\t    nt = create_pointer (nt);\n-\t  d->needs_cast_p = (t->kind != TYPE_POINTER\n-\t\t\t     && (nt->kind == TYPE_POINTER\n-\t\t\t\t || nt->kind == TYPE_STRING));\n-\t  t = nt;\n-\t}\n-      else\n-\terror_at_line (d->line, \"no parameter defined for `%s'\", d->val);\n-    }\n-\n   if (maybe_undef_p\n       && (t->kind != TYPE_POINTER || !union_or_struct_p (t->u.p)))\n     {\n@@ -2947,8 +2786,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n \tif (!length)\n \t  {\n-\t    if (!union_or_struct_p (t->u.p)\n-\t\t&& t->u.p->kind != TYPE_PARAM_STRUCT)\n+\t    if (!union_or_struct_p (t->u.p))\n \t      {\n \t\terror_at_line (d->line,\n \t\t\t       \"field `%s' is pointer to unimplemented type\",\n@@ -3221,7 +3059,6 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    const char *tagid = NULL;\n \t    int skip_p = 0;\n \t    int default_p = 0;\n-\t    int use_param_p = 0;\n \t    const char *fieldlength = NULL;\n \t    char *newval;\n \n@@ -3240,9 +3077,6 @@ walk_type (type_p t, struct walk_type_data *d)\n \t      else if (strcmp (oo->name, \"reorder\") == 0\n \t\t  && oo->kind == OPTION_STRING)\n \t\td->reorder_fn = oo->info.string;\n-\t      else if (strncmp (oo->name, \"use_param\", 9) == 0\n-\t\t       && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n-\t\tuse_param_p = 1;\n \t      else if (strcmp (oo->name, \"length\") == 0\n \t\t       && oo->kind == OPTION_STRING)\n \t\tfieldlength = oo->info.string;\n@@ -3290,10 +3124,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    d->used_length = false;\n \t    d->in_record_p = !union_p;\n \n-\t    if (union_p && use_param_p && d->param == NULL)\n-\t      oprintf (d->of, \"%*sgcc_unreachable ();\\n\", d->indent, \"\");\n-\t    else\n-\t      walk_type (f->type, d);\n+\t    walk_type (f->type, d);\n \n \t    d->in_record_p = false;\n \n@@ -3369,16 +3200,6 @@ walk_type (type_p t, struct walk_type_data *d)\n       }\n       break;\n \n-    case TYPE_PARAM_STRUCT:\n-      {\n-\ttype_p *oldparam = d->param;\n-\n-\td->param = t->u.param_struct.param;\n-\twalk_type (t->u.param_struct.stru, d);\n-\td->param = oldparam;\n-      }\n-      break;\n-\n     case TYPE_USER_STRUCT:\n       d->process_field (t, d);\n       break;\n@@ -3447,7 +3268,6 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n-    case TYPE_PARAM_STRUCT:\n     case TYPE_USER_STRUCT:\n       if (f->kind == TYPE_USER_STRUCT && !d->in_ptr_field)\n \t{\n@@ -3483,20 +3303,13 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n    reference struct S */\n \n static outf_p\n-get_output_file_for_structure (const_type_p s, type_p *param)\n+get_output_file_for_structure (const_type_p s)\n {\n   const input_file *fn;\n-  int i;\n \n   gcc_assert (union_or_struct_p (s));\n   fn = s->u.s.line.file;\n \n-  /* This is a hack, and not the good kind either.  */\n-  for (i = NUM_PARAM - 1; i >= 0; i--)\n-    if (param && param[i] && param[i]->kind == TYPE_POINTER\n-\t&& union_or_struct_p (param[i]->u.p))\n-      fn = param[i]->u.p->u.s.line.file;\n-\n   /* The call to get_output_file_with_visibility may update fn by\n      caching its result inside, so we need the CONST_CAST.  */\n   return get_output_file_with_visibility (CONST_CAST (input_file*, fn));\n@@ -3566,11 +3379,6 @@ write_marker_function_name (outf_p of, type_p s, const char *prefix)\n       if (id_for_tag != s->u.s.tag)\n \tfree (CONST_CAST (char *, id_for_tag));\n     }\n-  else if (s->kind == TYPE_PARAM_STRUCT)\n-    {\n-      oprintf (of, \"gt_%s_\", prefix);\n-      output_mangled_typename (of, s);\n-    }\n   else\n     gcc_unreachable ();\n }\n@@ -3582,16 +3390,6 @@ write_marker_function_name (outf_p of, type_p s, const char *prefix)\n static void\n write_user_func_for_structure_ptr (outf_p of, type_p s, const write_types_data *wtd)\n {\n-  /* Parameterized structures are not supported in user markers. There\n-     is no way for the marker function to know which specific type\n-     to use to generate the call to the void * entry point.  For\n-     instance, a marker for struct htab may need to call different\n-     routines to mark the fields, depending on the paramN_is attributes.\n-\n-     A user-defined marker that accepts 'struct htab' as its argument\n-     would not know which variant to call. Generating several entry\n-     points accepting 'struct htab' would cause multiply-defined\n-     errors during compilation.  */\n   gcc_assert (union_or_struct_p (s));\n \n   type_p alias_of = NULL;\n@@ -3684,15 +3482,14 @@ write_user_marking_functions (type_p s,\n }\n \n \n-/* For S, a structure that's part of ORIG_S, and using parameters\n-   PARAM, write out a routine that:\n+/* For S, a structure that's part of ORIG_S write out a routine that:\n    - Takes a parameter, a void * but actually of type *S\n    - If SEEN_ROUTINE returns nonzero, calls write_types_process_field on each\n    field of S or its substructures and (in some cases) things\n    that are pointed to by S.  */\n \n static void\n-write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n+write_func_for_structure (type_p orig_s, type_p s,\n \t\t\t  const struct write_types_data *wtd)\n {\n   const char *chain_next = NULL;\n@@ -3721,7 +3518,7 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n     }\n \n   memset (&d, 0, sizeof (d));\n-  d.of = get_output_file_for_structure (s, param);\n+  d.of = get_output_file_for_structure (s);\n \n   bool for_user = false;\n   for (opt = s->u.s.opt; opt; opt = opt->next)\n@@ -3752,7 +3549,6 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n   d.opt = s->u.s.opt;\n   d.line = &s->u.s.line;\n   d.bitmap = s->u.s.bitmap;\n-  d.param = param;\n   d.prev_val[0] = \"*x\";\n   d.prev_val[1] = \"not valid postage\";\t/* Guarantee an error.  */\n   d.prev_val[3] = \"x\";\n@@ -3894,7 +3690,7 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n /* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n-write_types (outf_p output_header, type_p structures, type_p param_structs,\n+write_types (outf_p output_header, type_p structures,\n \t     const struct write_types_data *wtd)\n {\n   int nbfun = 0;\t\t/* Count the emitted functions.  */\n@@ -3965,24 +3761,6 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t  }\n       }\n \n-  for (s = param_structs; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO)\n-      {\n-\ttype_p stru = s->u.param_struct.stru;\n-\n-\t/* Declare the marker procedure.  */\n-\toprintf (output_header, \"extern void gt_%s_\", wtd->prefix);\n-\toutput_mangled_typename (output_header, s);\n-\toprintf (output_header, \" (void *);\\n\");\n-\n-\tif (stru->u.s.line.file == NULL)\n-\t  {\n-\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\",\n-\t\t     stru->u.s.tag);\n-\t    continue;\n-\t  }\n-      }\n-\n   /* At last we emit the functions code.  */\n   oprintf (output_header, \"\\n/* functions code */\\n\");\n   for (s = structures; s; s = s->next)\n@@ -4006,15 +3784,15 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t\tnbfun++;\n \t\tDBGPRINTF (\"writing func #%d lang_struct ss @ %p '%s'\",\n \t\t\t   nbfun, (void*) ss, ss->u.s.tag);\n-\t\twrite_func_for_structure (s, ss, NULL, wtd);\n+\t\twrite_func_for_structure (s, ss, wtd);\n \t      }\n \t  }\n \telse\n \t  {\n \t    nbfun++;\n \t    DBGPRINTF (\"writing func #%d struct s @ %p '%s'\",\n \t\t       nbfun, (void*) s, s->u.s.tag);\n-\t    write_func_for_structure (s, s, NULL, wtd);\n+\t    write_func_for_structure (s, s, wtd);\n \t  }\n       }\n     else\n@@ -4025,38 +3803,6 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t\t   (int) s->gc_used);\n       }\n \n-  for (s = param_structs; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO)\n-      {\n-\ttype_p *param = s->u.param_struct.param;\n-\ttype_p stru = s->u.param_struct.stru;\n-\tif (stru->u.s.line.file == NULL)\n-\t  continue;\n-\tif (stru->kind == TYPE_LANG_STRUCT)\n-\t  {\n-\t    type_p ss;\n-\t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n-\t      {\n-\t\tnbfun++;\n-\t\tDBGPRINTF (\"writing func #%d param lang_struct ss @ %p '%s'\",\n-\t\t\t   nbfun, (void*) ss,  ss->u.s.tag);\n-\t\twrite_func_for_structure (s, ss, param, wtd);\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    nbfun++;\n-\t    DBGPRINTF (\"writing func #%d param struct s @ %p stru @ %p '%s'\",\n-\t\t       nbfun, (void*) s,\n-\t\t       (void*) stru,  stru->u.s.tag);\n-\t    write_func_for_structure (s, stru, param, wtd);\n-\t  }\n-      }\n-    else\n-      { \n-\t/* Param structure s is not pointed to, so should be ignored.  */\n-\tDBGPRINTF (\"ignored s @ %p\", (void*)s);\n-      }\n   if (verbosity_level >= 2)\n     printf (\"%s emitted %d routines for %s\\n\",\n \t    progname, nbfun, wtd->comment);\n@@ -4094,7 +3840,6 @@ write_types_local_user_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n-    case TYPE_PARAM_STRUCT:\n     case TYPE_STRING:\n       oprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n       break;\n@@ -4175,7 +3920,6 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_STRUCT:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n-    case TYPE_PARAM_STRUCT:\n     case TYPE_STRING:\n       oprintf (d->of, \"%*sif ((void *)(%s) == this_obj)\\n\", d->indent, \"\",\n \t       d->prev_val[3]);\n@@ -4210,7 +3954,7 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n */\n \n static void\n-write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n+write_local_func_for_structure (const_type_p orig_s, type_p s)\n {\n   struct walk_type_data d;\n \n@@ -4220,12 +3964,11 @@ write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n     return;\n \n   memset (&d, 0, sizeof (d));\n-  d.of = get_output_file_for_structure (s, param);\n+  d.of = get_output_file_for_structure (s);\n   d.process_field = write_types_local_process_field;\n   d.opt = s->u.s.opt;\n   d.line = &s->u.s.line;\n   d.bitmap = s->u.s.bitmap;\n-  d.param = param;\n   d.prev_val[0] = d.prev_val[2] = \"*x\";\n   d.prev_val[1] = \"not valid postage\";\t/* Guarantee an error.  */\n   d.prev_val[3] = \"x\";\n@@ -4276,7 +4019,7 @@ write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n /* Write out local marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n-write_local (outf_p output_header, type_p structures, type_p param_structs)\n+write_local (outf_p output_header, type_p structures)\n {\n   type_p s;\n \n@@ -4323,39 +4066,10 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \t  {\n \t    type_p ss;\n \t    for (ss = s->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_local_func_for_structure (s, ss, NULL);\n+\t      write_local_func_for_structure (s, ss);\n \t  }\n \telse\n-\t  write_local_func_for_structure (s, s, NULL);\n-      }\n-\n-  for (s = param_structs; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO)\n-      {\n-\ttype_p *param = s->u.param_struct.param;\n-\ttype_p stru = s->u.param_struct.stru;\n-\n-\t/* Declare the marker procedure.  */\n-\toprintf (output_header, \"extern void gt_pch_p_\");\n-\toutput_mangled_typename (output_header, s);\n-\toprintf (output_header,\n-\t\t \"\\n    (void *, void *, gt_pointer_operator, void *);\\n\");\n-\n-\tif (stru->u.s.line.file == NULL)\n-\t  {\n-\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\",\n-\t\t     stru->u.s.tag);\n-\t    continue;\n-\t  }\n-\n-\tif (stru->kind == TYPE_LANG_STRUCT)\n-\t  {\n-\t    type_p ss;\n-\t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_local_func_for_structure (s, ss, param);\n-\t  }\n-\telse\n-\t  write_local_func_for_structure (s, stru, param);\n+\t  write_local_func_for_structure (s, s);\n       }\n }\n \n@@ -4576,7 +4290,7 @@ start_root_entry (outf_p f, pair_p v, const char *name, struct fileloc *line)\n \n static void\n write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n-\t\t  int has_length, struct fileloc *line, const char *if_marked,\n+\t\t  int has_length, struct fileloc *line,\n \t\t  bool emit_pch, type_p field_type, const char *field_name)\n {\n   struct pair newv;\n@@ -4596,7 +4310,7 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n   else if (field_type->kind == TYPE_ARRAY)\n     v = NULL;\n   write_root (f, v, field_type, ACONCAT ((name, \".\", field_name, NULL)),\n-\t      has_length, line, if_marked, emit_pch);\n+\t      has_length, line, emit_pch);\n }\n \n /* Write out to F the table entry and any marker routines needed to\n@@ -4611,12 +4325,11 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n      - the C variable that contains NAME, if NAME is not part of an array.\n \n    LINE is the line of the C source that declares the root variable.\n-   HAS_LENGTH is nonzero iff V was a variable-length array.  IF_MARKED\n-   is nonzero iff we are building the root table for hash table caches.  */\n+   HAS_LENGTH is nonzero iff V was a variable-length array.  */\n \n static void\n write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n-\t    struct fileloc *line, const char *if_marked, bool emit_pch)\n+\t    struct fileloc *line, bool emit_pch)\n {\n   switch (type->kind)\n     {\n@@ -4635,8 +4348,6 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t      else if (strcmp (o->name, \"desc\") == 0\n \t\t       && o->kind == OPTION_STRING)\n \t\tdesc = o->info.string;\n-\t      else if (strcmp (o->name, \"param_is\") == 0)\n-\t\t;\n \t      else\n \t\terror_at_line (line,\n \t\t\t       \"field `%s' of global `%s' has unknown option `%s'\",\n@@ -4667,8 +4378,8 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\t    validf = ufld;\n \t\t  }\n \t\tif (validf != NULL)\n-\t\t  write_field_root (f, v, type, name, 0, line, if_marked,\n-\t\t\t\t    emit_pch, validf->type,\n+\t\t  write_field_root (f, v, type, name, 0, line, emit_pch,\n+\t\t\t\t    validf->type,\n \t\t\t\t    ACONCAT ((fld->name, \".\",\n \t\t\t\t\t      validf->name, NULL)));\n \t      }\n@@ -4677,8 +4388,8 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\t\t     \"global `%s.%s' has `desc' option but is not union\",\n \t\t\t     name, fld->name);\n \t    else\n-\t      write_field_root (f, v, type, name, 0, line, if_marked,\n-\t\t\t\temit_pch, fld->type, fld->name);\n+\t      write_field_root (f, v, type, name, 0, line, emit_pch, fld->type,\n+\t\t\t\tfld->name);\n \t  }\n       }\n       break;\n@@ -4687,8 +4398,7 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n       {\n \tchar *newname;\n \tnewname = xasprintf (\"%s[0]\", name);\n-\twrite_root (f, v, type->u.a.p, newname, has_length, line, if_marked,\n-\t\t    emit_pch);\n+\twrite_root (f, v, type->u.a.p, newname, has_length, line, emit_pch);\n \tfree (newname);\n       }\n       break;\n@@ -4720,18 +4430,6 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t    if (id_for_tag != tp->u.s.tag)\n \t      free (CONST_CAST (char *, id_for_tag));\n \t  }\n-\telse if (!has_length && tp->kind == TYPE_PARAM_STRUCT)\n-\t  {\n-\t    oprintf (f, \"    &gt_ggc_m_\");\n-\t    output_mangled_typename (f, tp);\n-\t    if (emit_pch)\n-\t      {\n-\t\toprintf (f, \",\\n    &gt_pch_n_\");\n-\t\toutput_mangled_typename (f, tp);\n-\t      }\n-\t    else\n-\t      oprintf (f, \",\\n    NULL\");\n-\t  }\n \telse if (has_length\n \t\t && (tp->kind == TYPE_POINTER || union_or_struct_p (tp)))\n \t  {\n@@ -4747,8 +4445,6 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\t\t   \"global `%s' is pointer to unimplemented type\",\n \t\t\t   name);\n \t  }\n-\tif (if_marked)\n-\t  oprintf (f, \",\\n    &%s\", if_marked);\n \toprintf (f, \"\\n  },\\n\");\n       }\n       break;\n@@ -4771,7 +4467,6 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n     case TYPE_UNDEFINED:\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n-    case TYPE_PARAM_STRUCT:\n       error_at_line (line, \"global `%s' is unimplemented type\", name);\n     }\n }\n@@ -4791,7 +4486,6 @@ write_array (outf_p f, pair_p v, const struct write_types_data *wtd)\n   d.line = &v->line;\n   d.opt = v->opt;\n   d.bitmap = get_lang_bitmap (v->line.file);\n-  d.param = NULL;\n \n   d.prev_val[3] = prevval3 = xasprintf (\"&%s\", v->name);\n \n@@ -4849,13 +4543,6 @@ write_roots (pair_p variables, bool emit_pch)\n \t  length = o->info.string;\n \telse if (strcmp (o->name, \"deletable\") == 0)\n \t  deletable_p = 1;\n-\telse if (strcmp (o->name, \"param_is\") == 0)\n-\t  ;\n-\telse if (strncmp (o->name, \"param\", 5) == 0\n-\t\t && ISDIGIT (o->name[5]) && strcmp (o->name + 6, \"_is\") == 0)\n-\t  ;\n-\telse if (strcmp (o->name, \"if_marked\") == 0)\n-\t  ;\n \telse if (strcmp (o->name, \"cache\") == 0)\n \t  ;\n \telse\n@@ -4902,8 +4589,7 @@ write_roots (pair_p variables, bool emit_pch)\n       for (o = v->opt; o; o = o->next)\n \tif (strcmp (o->name, \"length\") == 0)\n \t  length_p = 1;\n-\telse if (strcmp (o->name, \"deletable\") == 0\n-\t\t || strcmp (o->name, \"if_marked\") == 0)\n+\telse if (strcmp (o->name, \"deletable\") == 0)\n \t  skip_p = 1;\n \n       if (skip_p)\n@@ -4921,7 +4607,7 @@ write_roots (pair_p variables, bool emit_pch)\n \t  oprintf (f, \"[] = {\\n\");\n \t}\n \n-      write_root (f, v, v->type, v->name, length_p, &v->line, NULL, emit_pch);\n+      write_root (f, v, v->type, v->name, length_p, &v->line, emit_pch);\n     }\n \n   finish_root_table (flp, \"ggc_r\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n@@ -4938,8 +4624,6 @@ write_roots (pair_p variables, bool emit_pch)\n       for (o = v->opt; o; o = o->next)\n \tif (strcmp (o->name, \"deletable\") == 0)\n \t  skip_p = 0;\n-\telse if (strcmp (o->name, \"if_marked\") == 0)\n-\t  skip_p = 1;\n \n       if (skip_p)\n \tcontinue;\n@@ -4963,52 +4647,6 @@ write_roots (pair_p variables, bool emit_pch)\n   finish_root_table (flp, \"ggc_rd\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n \t\t     \"gt_ggc_deletable_rtab\");\n \n-  for (v = variables; v; v = v->next)\n-    {\n-      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n-\t\t\t\t\t\t\t      v->line.file));\n-      struct flist *fli;\n-      const char *if_marked = NULL;\n-      int length_p = 0;\n-      options_p o;\n-\n-      for (o = v->opt; o; o = o->next)\n-\tif (strcmp (o->name, \"length\") == 0)\n-\t  length_p = 1;\n-\telse if (strcmp (o->name, \"if_marked\") == 0\n-\t\t       && o->kind == OPTION_STRING)\n-\t  if_marked = o->info.string;\n-       if (if_marked == NULL)\n-\tcontinue;\n-      if (v->type->kind != TYPE_POINTER\n-\t  || v->type->u.p->kind != TYPE_PARAM_STRUCT\n-\t  || v->type->u.p->u.param_struct.stru != find_structure (\"htab\",\n-\t                                                          TYPE_STRUCT))\n-\t{\n-\t  error_at_line (&v->line,\n-\t\t\t \"if_marked option used but not hash table\");\n-\t  continue;\n-\t}\n-\n-      for (fli = flp; fli; fli = fli->next)\n-\tif (fli->f == f)\n-\t  break;\n-      if (!fli->started_p)\n-\t{\n-\t  fli->started_p = 1;\n-\n-\t  oprintf (f, \"EXPORTED_CONST struct ggc_cache_tab gt_ggc_rc_\");\n-\t  put_mangled_filename (f, v->line.file);\n-\t  oprintf (f, \"[] = {\\n\");\n-\t}\n-\n-      write_root (f, v, v->type->u.p->u.param_struct.param[0],\n-\t\t  v->name, length_p, &v->line, if_marked, emit_pch);\n-    }\n-\n-  finish_root_table (flp, \"ggc_rc\", \"LAST_GGC_CACHE_TAB\", \"ggc_cache_tab\",\n-\t\t     \"gt_ggc_cache_rtab\");\n-\n   for (v = variables; v; v = v->next)\n     {\n       outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n@@ -5043,42 +4681,6 @@ write_roots (pair_p variables, bool emit_pch)\n   if (!emit_pch)\n     return;\n \n-  for (v = variables; v; v = v->next)\n-    {\n-      outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n-\t\t\t\t\t\t\t      v->line.file));\n-      struct flist *fli;\n-      int length_p = 0;\n-      int if_marked_p = 0;\n-      options_p o;\n-\n-      for (o = v->opt; o; o = o->next)\n-\tif (strcmp (o->name, \"length\") == 0)\n-\t  length_p = 1;\n-\telse if (strcmp (o->name, \"if_marked\") == 0)\n-\t  if_marked_p = 1;\n-\n-      if (!if_marked_p)\n-\tcontinue;\n-\n-      for (fli = flp; fli; fli = fli->next)\n-\tif (fli->f == f)\n-\t  break;\n-      if (!fli->started_p)\n-\t{\n-\t  fli->started_p = 1;\n-\n-\t  oprintf (f, \"EXPORTED_CONST struct ggc_root_tab gt_pch_rc_\");\n-\t  put_mangled_filename (f, v->line.file);\n-\t  oprintf (f, \"[] = {\\n\");\n-\t}\n-\n-      write_root (f, v, v->type, v->name, length_p, &v->line, NULL, emit_pch);\n-    }\n-\n-  finish_root_table (flp, \"pch_rc\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n-\t\t     \"gt_pch_cache_rtab\");\n-\n   for (v = variables; v; v = v->next)\n     {\n       outf_p f = get_output_file_with_visibility (CONST_CAST (input_file*,\n@@ -5088,8 +4690,7 @@ write_roots (pair_p variables, bool emit_pch)\n       options_p o;\n \n       for (o = v->opt; o; o = o->next)\n-\tif (strcmp (o->name, \"deletable\") == 0\n-\t    || strcmp (o->name, \"if_marked\") == 0)\n+\tif (strcmp (o->name, \"deletable\") == 0)\n \t  {\n \t    skip_p = 1;\n \t    break;\n@@ -5146,59 +4747,13 @@ output_typename (outf_p of, const_type_p t)\n     case TYPE_LANG_STRUCT:\n       oprintf (of, \"%s\", t->u.s.tag);\n       break;\n-    case TYPE_PARAM_STRUCT:\n-      {\n-\tint i;\n-\tfor (i = 0; i < NUM_PARAM; i++)\n-\t  if (t->u.param_struct.param[i] != NULL)\n-\t    {\n-\t      output_typename (of, t->u.param_struct.param[i]);\n-\t      oprintf (of, \"_\");\n-\t    }\n-\toutput_typename (of, t->u.param_struct.stru);\n-\tbreak;\n-      }\n     case TYPE_NONE:\n     case TYPE_UNDEFINED:\n     case TYPE_ARRAY:\n       gcc_unreachable ();\n     }\n }\n \n-/* Writes a typed GC allocator for type S that is suitable as a callback for\n-   the splay tree implementation in libiberty.  */\n-\n-static void\n-write_splay_tree_allocator_def (const_type_p s)\n-{\n-  outf_p of = get_output_file_with_visibility (NULL);\n-  oprintf (of, \"void * ggc_alloc_splay_tree_\");\n-  output_typename (of, s);\n-  oprintf (of, \" (int sz, void * nl)\\n\");\n-  oprintf (of, \"{\\n\");\n-  oprintf (of, \"  return ggc_splay_alloc (sz, nl);\\n\");\n-  oprintf (of, \"}\\n\\n\");\n-}\n-\n-/* Writes typed GC allocators for PARAM_STRUCTS that are suitable as callbacks\n-   for the splay tree implementation in libiberty.  */\n-\n-static void\n-write_splay_tree_allocators (const_type_p param_structs)\n-{\n-  const_type_p s;\n-\n-  oprintf (header_file, \"\\n/* Splay tree callback allocators.  */\\n\");\n-  for (s = param_structs; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO)\n-      {\n-\toprintf (header_file, \"extern void * ggc_alloc_splay_tree_\");\n-\toutput_typename (header_file, s);\n-\toprintf (header_file, \" (int, void *);\\n\");\n-\twrite_splay_tree_allocator_def (s);\n-      }\n-}\n-\n #define INDENT 2\n \n /* Dumps the value of typekind KIND.  */\n@@ -5236,9 +4791,6 @@ dump_typekind (int indent, enum typekind kind)\n     case TYPE_LANG_STRUCT:\n       printf (\"TYPE_LANG_STRUCT\");\n       break;\n-    case TYPE_PARAM_STRUCT:\n-      printf (\"TYPE_PARAM_STRUCT\");\n-      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -5349,25 +4901,6 @@ dump_type_u_a (int indent, type_p t)\n   dump_type_list (indent + INDENT, t->u.a.p);\n }\n \n-/* Recursively dumps the parameterized struct T.  */\n-\n-static void\n-dump_type_u_param_struct (int indent, type_p t)\n-{\n-  int i;\n-  gcc_assert (t->kind == TYPE_PARAM_STRUCT);\n-  printf (\"%*cu.param_struct.stru:\\n\", indent, ' ');\n-  dump_type_list (indent, t->u.param_struct.stru);\n-  dump_fileloc (indent, t->u.param_struct.line);\n-  for (i = 0; i < NUM_PARAM; i++)\n-    {\n-      if (t->u.param_struct.param[i] == NULL)\n-\tcontinue;\n-      printf (\"%*cu.param_struct.param[%d]:\\n\", indent, ' ', i);\n-      dump_type (indent + INDENT, t->u.param_struct.param[i]);\n-    }\n-}\n-\n /* Recursively dumps the type list T.  */\n \n static void\n@@ -5428,9 +4961,6 @@ dump_type (int indent, type_p t)\n     case TYPE_ARRAY:\n       dump_type_u_a (indent + INDENT, t);\n       break;\n-    case TYPE_PARAM_STRUCT:\n-      dump_type_u_param_struct (indent + INDENT, t);\n-      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -5480,7 +5010,6 @@ dump_everything (void)\n {\n   dump_pair_list (\"typedefs\", typedefs);\n   dump_structures (\"structures\", structures);\n-  dump_structures (\"param_structs\", param_structs);\n   dump_pair_list (\"variables\", variables);\n \n   /* Allocated with the first call to dump_type.  */\n@@ -5716,7 +5245,6 @@ main (int argc, char **argv)\n \t       inputlist, read_state_filename);\n       read_state (read_state_filename);\n       DBGPRINT_COUNT_TYPE (\"structures after read_state\", structures);\n-      DBGPRINT_COUNT_TYPE (\"param_structs after read_state\", param_structs);\n     }\n   else if (inputlist)\n     {\n@@ -5755,8 +5283,6 @@ main (int argc, char **argv)\n \t\tprogname, (int) num_gt_files, type_count);\n \n       DBGPRINT_COUNT_TYPE (\"structures after parsing\", structures);\n-      DBGPRINT_COUNT_TYPE (\"param_structs after parsing\", param_structs);\n-\n     }\n   else\n     fatal (\"either an input list or a read state file should be given\");\n@@ -5801,8 +5327,6 @@ main (int argc, char **argv)\n \n   gen_rtx_next ();\n \n-  /* The call to set_gc_used may indirectly call find_param_structure\n-     hence enlarge the param_structs list of types.  */\n   set_gc_used (variables);\n \n   for (type_p t = structures; t; t = t->next)\n@@ -5816,15 +5340,14 @@ main (int argc, char **argv)\n \t  }\n \n       if (for_user)\n-\tset_gc_used_type (t, GC_POINTED_TO, NULL);\n+\tset_gc_used_type (t, GC_POINTED_TO);\n     }\n  /* The state at this point is read from the state input file or by\n     parsing source files and optionally augmented by parsing plugin\n     source files.  Write it now.  */\n   if (write_state_filename)\n     {\n       DBGPRINT_COUNT_TYPE (\"structures before write_state\", structures);\n-      DBGPRINT_COUNT_TYPE (\"param_structs before write_state\", param_structs);\n \n       if (hit_error)\n \tfatal (\"didn't write state file %s after errors\", \n@@ -5850,20 +5373,15 @@ main (int argc, char **argv)\n   output_header = plugin_output ? plugin_output : header_file;\n   DBGPRINT_COUNT_TYPE (\"structures before write_types outputheader\",\n \t\t       structures);\n-  DBGPRINT_COUNT_TYPE (\"param_structs before write_types outputheader\",\n-\t\t       param_structs);\n \n-  write_types (output_header, structures, param_structs, &ggc_wtd);\n+  write_types (output_header, structures, &ggc_wtd);\n   if (plugin_files == NULL)\n     {\n       DBGPRINT_COUNT_TYPE (\"structures before write_types headerfil\",\n \t\t\t   structures);\n-      DBGPRINT_COUNT_TYPE (\"param_structs before write_types headerfil\",\n-\t\t\t   param_structs);\n-      write_types (header_file, structures, param_structs, &pch_wtd);\n-      write_local (header_file, structures, param_structs);\n+      write_types (header_file, structures, &pch_wtd);\n+      write_local (header_file, structures);\n     }\n-  write_splay_tree_allocators (param_structs);\n   write_roots (variables, plugin_files == NULL);\n   write_rtx_next ();\n   close_output_files ();"}, {"sha": "e4596039a01ee209e652afa01267e8d28cc17319", "filename": "gcc/gengtype.h", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -124,7 +124,6 @@ extern struct fileloc lexer_line;\n    gengtype.c & in gengtype-state.c files.  */\n extern pair_p typedefs;\n extern type_p structures;\n-extern type_p param_structs;\n extern pair_p variables;\n \n /* An enum for distinguishing GGC vs PCH.  */\n@@ -153,11 +152,6 @@ enum typekind {\n   TYPE_LANG_STRUCT,     /* GCC front-end language specific structs.\n                            Various languages may have homonymous but\n                            different structs.  */\n-  TYPE_PARAM_STRUCT,    /* Type for parametrized structs, e.g. hash_t\n-                           hash-tables, ...  See (param_is, use_param,\n-                           param1_is, param2_is,... use_param1,\n-                           use_param_2,... use_params) GTY\n-                           options.  */\n   TYPE_USER_STRUCT\t/* User defined type.  Walkers and markers for\n \t\t\t   this type are assumed to be provided by the\n \t\t\t   user.  */\n@@ -246,20 +240,16 @@ enum gc_used_enum {\n   GC_POINTED_TO\n };\n \n-/* We can have at most ten type parameters in parameterized structures.  */\n-#define NUM_PARAM 10\n-\n /* Our type structure describes all types handled by gengtype.  */\n struct type {\n   /* Discriminating kind, cannot be TYPE_NONE.  */\n   enum typekind kind;\n \n   /* For top-level structs or unions, the 'next' field links the\n-     global list 'structures' or 'param_structs'; for lang_structs,\n-     their homonymous structs are linked using this 'next' field.  The\n-     homonymous list starts at the s.lang_struct field of the\n-     lang_struct.  See the new_structure function for details.  This is\n-     tricky!  */\n+     global list 'structures'; for lang_structs, their homonymous structs are\n+     linked using this 'next' field.  The homonymous list starts at the\n+     s.lang_struct field of the lang_struct.  See the new_structure function\n+     for details.  This is tricky!  */\n   type_p next;\n \n   /* State number used when writing & reading the persistent state.  A\n@@ -325,14 +315,6 @@ struct type {\n       const char *len;          /* The string if any giving its length.  */\n     } a;\n \n-    /* When TYPE_PARAM_STRUCT for (param_is, use_param, param1_is,\n-       param2_is, ... use_param1, use_param_2, ... use_params) GTY\n-       options.  */\n-    struct {\n-      type_p stru;              /* The generic GTY-ed type.  */\n-      type_p param[NUM_PARAM];  /* The actual parameter types.  */\n-      struct fileloc line;      /* The source location.  */\n-    } param_struct;\n   } u;\n };\n \n@@ -376,8 +358,6 @@ type_fileloc (type_p t)\n     return NULL;\n   if (union_or_struct_p (t))\n     return &t->u.s.line;\n-  if  (t->kind == TYPE_PARAM_STRUCT)\n-    return &t->u.param_struct.line;\n   return NULL;\n }\n \n@@ -488,7 +468,6 @@ enum gty_token\n   PTR_ALIAS,\n   NESTED_PTR,\n   USER_GTY,\n-  PARAM_IS,\n   NUM,\n   SCALAR,\n   ID,\n@@ -499,7 +478,7 @@ enum gty_token\n \n   /* print_token assumes that any token >= FIRST_TOKEN_WITH_VALUE may have\n      a meaningful value to be printed.  */\n-  FIRST_TOKEN_WITH_VALUE = PARAM_IS\n+  FIRST_TOKEN_WITH_VALUE = USER_GTY\n };\n \n "}, {"sha": "b935fc6a1ab246c188e24b66fc5dcd258125b818", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -45,30 +45,13 @@ static ggc_statistics *ggc_stats;\n \n struct traversal_state;\n \n-static int ggc_htab_delete (void **, void *);\n static int compare_ptr_data (const void *, const void *);\n static void relocate_ptrs (void *, void *);\n static void write_pch_globals (const struct ggc_root_tab * const *tab,\n \t\t\t       struct traversal_state *state);\n \n /* Maintain global roots that are preserved during GC.  */\n \n-/* Process a slot of an htab by deleting it if it has not been marked.  */\n-\n-static int\n-ggc_htab_delete (void **slot, void *info)\n-{\n-  const struct ggc_cache_tab *r = (const struct ggc_cache_tab *) info;\n-\n-  if (! (*r->marked_p) (*slot))\n-    htab_clear_slot (*r->base, slot);\n-  else\n-    (*r->cb) (*slot);\n-\n-  return 1;\n-}\n-\n-\n /* This extra vector of dynamically registered root_tab-s is used by\n    ggc_mark_roots and gives the ability to dynamically add new GGC root\n    tables, for instance from some plugins; this vector is on the heap\n@@ -86,41 +69,6 @@ ggc_register_root_tab (const struct ggc_root_tab* rt)\n     extra_root_vec.safe_push (rt);\n }\n \n-/* This extra vector of dynamically registered cache_tab-s is used by\n-   ggc_mark_roots and gives the ability to dynamically add new GGC cache\n-   tables, for instance from some plugins; this vector is on the heap\n-   since it is used by GGC internally.  */\n-typedef const struct ggc_cache_tab *const_ggc_cache_tab_t;\n-static vec<const_ggc_cache_tab_t> extra_cache_vec;\n-\n-/* Dynamically register a new GGC cache table CT. This is useful for\n-   plugins. */\n-\n-void\n-ggc_register_cache_tab (const struct ggc_cache_tab* ct)\n-{\n-  if (ct)\n-    extra_cache_vec.safe_push (ct);\n-}\n-\n-/* Scan a hash table that has objects which are to be deleted if they are not\n-   already marked.  */\n-\n-static void\n-ggc_scan_cache_tab (const_ggc_cache_tab_t ctp)\n-{\n-  const struct ggc_cache_tab *cti;\n-\n-  for (cti = ctp; cti->base != NULL; cti++)\n-    if (*cti->base)\n-      {\n-        ggc_set_mark (*cti->base);\n-        htab_traverse_noresize (*cti->base, ggc_htab_delete,\n-                                CONST_CAST (void *, (const void *)cti));\n-        ggc_set_mark ((*cti->base)->entries);\n-      }\n-}\n-\n /* Mark all the roots in the table RT.  */\n \n static void\n@@ -140,8 +88,6 @@ ggc_mark_roots (void)\n {\n   const struct ggc_root_tab *const *rt;\n   const_ggc_root_tab_t rtp, rti;\n-  const struct ggc_cache_tab *const *ct;\n-  const_ggc_cache_tab_t ctp;\n   size_t i;\n \n   for (rt = gt_ggc_deletable_rtab; *rt; rt++)\n@@ -157,16 +103,8 @@ ggc_mark_roots (void)\n   if (ggc_protect_identifiers)\n     ggc_mark_stringpool ();\n \n-  /* Now scan all hash tables that have objects which are to be deleted if\n-     they are not already marked.  */\n-  for (ct = gt_ggc_cache_rtab; *ct; ct++)\n-    ggc_scan_cache_tab (*ct);\n-\n   gt_clear_caches ();\n \n-  FOR_EACH_VEC_ELT (extra_cache_vec, i, ctp)\n-    ggc_scan_cache_tab (ctp);\n-\n   if (! ggc_protect_identifiers)\n     ggc_purge_stringpool ();\n \n@@ -503,11 +441,6 @@ gt_pch_save (FILE *f)\n       for (i = 0; i < rti->nelt; i++)\n \t(*rti->pchw)(*(void **)((char *)rti->base + rti->stride * i));\n \n-  for (rt = gt_pch_cache_rtab; *rt; rt++)\n-    for (rti = *rt; rti->base != NULL; rti++)\n-      for (i = 0; i < rti->nelt; i++)\n-\t(*rti->pchw)(*(void **)((char *)rti->base + rti->stride * i));\n-\n   /* Prepare the objects for writing, determine addresses and such.  */\n   state.f = f;\n   state.d = init_ggc_pch ();\n@@ -543,7 +476,6 @@ gt_pch_save (FILE *f)\n \n   /* Write out all the global pointers, after translation.  */\n   write_pch_globals (gt_ggc_rtab, &state);\n-  write_pch_globals (gt_pch_cache_rtab, &state);\n \n   /* Pad the PCH file so that the mmapped area starts on an allocation\n      granularity (usually page) boundary.  */\n@@ -693,13 +625,6 @@ gt_pch_restore (FILE *f)\n \t\t   sizeof (void *), 1, f) != 1)\n \t  fatal_error (\"can%'t read PCH file: %m\");\n \n-  for (rt = gt_pch_cache_rtab; *rt; rt++)\n-    for (rti = *rt; rti->base != NULL; rti++)\n-      for (i = 0; i < rti->nelt; i++)\n-\tif (fread ((char *)rti->base + rti->stride * i,\n-\t\t   sizeof (void *), 1, f) != 1)\n-\t  fatal_error (\"can%'t read PCH file: %m\");\n-\n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n     fatal_error (\"can%'t read PCH file: %m\");\n "}, {"sha": "2389f94498c4c5ba4cc1525ee8a98883d07bfd88", "filename": "gcc/ggc.h", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -73,23 +73,8 @@ struct ggc_root_tab {\n /* Pointers to arrays of ggc_root_tab, terminated by NULL.  */\n extern const struct ggc_root_tab * const gt_ggc_rtab[];\n extern const struct ggc_root_tab * const gt_ggc_deletable_rtab[];\n-extern const struct ggc_root_tab * const gt_pch_cache_rtab[];\n extern const struct ggc_root_tab * const gt_pch_scalar_rtab[];\n \n-/* Structure for hash table cache marking.  */\n-struct htab;\n-struct ggc_cache_tab {\n-  struct htab * *base;\n-  size_t nelt;\n-  size_t stride;\n-  gt_pointer_walker cb;\n-  gt_pointer_walker pchw;\n-  int (*marked_p) (const void *);\n-};\n-#define LAST_GGC_CACHE_TAB { NULL, 0, 0, NULL, NULL, NULL }\n-/* Pointers to arrays of ggc_cache_tab, terminated by NULL.  */\n-extern const struct ggc_cache_tab * const gt_ggc_cache_rtab[];\n-\n /* If EXPR is not NULL and previously unmarked, mark it and evaluate\n    to true.  Otherwise evaluate to false.  */\n #define ggc_test_and_set_mark(EXPR) \\\n@@ -251,27 +236,6 @@ ggc_alloc_atomic (size_t s CXX_MEM_STAT_INFO)\n     return ggc_internal_alloc (s PASS_MEM_STAT);\n }\n \n-extern void *ggc_cleared_alloc_htab_ignore_args (size_t, size_t)\n-  ATTRIBUTE_MALLOC;\n-\n-extern void *ggc_cleared_alloc_ptr_array_two_args (size_t, size_t)\n-  ATTRIBUTE_MALLOC;\n-\n-#define htab_create_ggc(SIZE, HASH, EQ, DEL) \\\n-  htab_create_typed_alloc (SIZE, HASH, EQ, DEL,\t\\\n-\t\t\t   ggc_cleared_alloc_htab_ignore_args,\t\t\\\n-\t\t\t   ggc_cleared_alloc_ptr_array_two_args,\t\\\n-\t\t\t   ggc_free)\n-\n-#define splay_tree_new_ggc(COMPARE, ALLOC_TREE, ALLOC_NODE)\t\t     \\\n-  splay_tree_new_typed_alloc (COMPARE, NULL, NULL, &ALLOC_TREE, &ALLOC_NODE, \\\n-\t\t\t      &ggc_splay_dont_free, NULL)\n-\n-extern void *ggc_splay_alloc (int, void *)\n-  ATTRIBUTE_MALLOC;\n-\n-extern void ggc_splay_dont_free (void *, void *);\n-\n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n    null-terminated string and the memory sized accordingly.  */\n@@ -292,10 +256,6 @@ extern void ggc_grow (void);\n    plugins.  Does nothing if the passed pointer is NULL. */\n extern void ggc_register_root_tab (const struct ggc_root_tab *);\n \n-/* Register an additional cache table.  This can be useful for some\n-   plugins.  Does nothing if the passed pointer is NULL. */\n-extern void ggc_register_cache_tab (const struct ggc_cache_tab *);\n-\n /* Read objects previously saved with gt_pch_save from F.  */\n extern void gt_pch_restore (FILE *f);\n \f"}, {"sha": "5482f7915beda9d625c648d9dafb0f9661e3a3f4", "filename": "gcc/plugin.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -420,10 +420,6 @@ register_callback (const char *plugin_name,\n \tgcc_assert (!callback);\n         ggc_register_root_tab ((const struct ggc_root_tab*) user_data);\n \tbreak;\n-      case PLUGIN_REGISTER_GGC_CACHES:\n-\tgcc_assert (!callback);\n-        ggc_register_cache_tab ((const struct ggc_cache_tab*) user_data);\n-\tbreak;\n       case PLUGIN_EVENT_FIRST_DYNAMIC:\n       default:\n \tif (event < PLUGIN_EVENT_FIRST_DYNAMIC || event >= event_last)\n@@ -546,7 +542,6 @@ invoke_plugin_callbacks_full (int event, void *gcc_data)\n \n       case PLUGIN_PASS_MANAGER_SETUP:\n       case PLUGIN_REGISTER_GGC_ROOTS:\n-      case PLUGIN_REGISTER_GGC_CACHES:\n         gcc_assert (false);\n     }\n "}, {"sha": "cbda3ad3f1af823d238cff2bb96b62ee1f8f7ee1", "filename": "gcc/plugin.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fplugin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/gcc%2Fplugin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.def?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -51,9 +51,6 @@ DEFEVENT (PLUGIN_GGC_END)\n /* Register an extra GGC root table. */\n DEFEVENT (PLUGIN_REGISTER_GGC_ROOTS)\n \n-/* Register an extra GGC cache table. */\n-DEFEVENT (PLUGIN_REGISTER_GGC_CACHES)\n-\n /* Called during attribute registration.  */\n DEFEVENT (PLUGIN_ATTRIBUTES)\n "}, {"sha": "f264b27501f7d8a996a501df441a913e3dc62ddd", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -1,3 +1,7 @@\n+2014-12-09  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hashtab.h, splay-tree.h: Remove GTY markers.\n+\n 2014-12-08  Mark Wielaard  <mjw@redhat.com>\n \n \tPR debug/60782"}, {"sha": "188b8494db2d9d35dc7f7f659376c8466a78042d", "filename": "include/hashtab.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/include%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/include%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhashtab.h?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -39,10 +39,6 @@ extern \"C\" {\n \n #include \"ansidecl.h\"\n \n-#ifndef GTY\n-#define GTY(X)\n-#endif\n-\n /* The type for a hash code.  */\n typedef unsigned int hashval_t;\n \n@@ -97,7 +93,7 @@ typedef void (*htab_free_with_arg) (void *, void *);\n    functions mentioned below.  The size of this structure is subject to\n    change.  */\n \n-struct GTY(()) htab {\n+struct htab {\n   /* Pointer to hash function.  */\n   htab_hash hash_f;\n \n@@ -108,7 +104,7 @@ struct GTY(()) htab {\n   htab_del del_f;\n \n   /* Table itself.  */\n-  void ** GTY ((use_param, length (\"%h.size\"))) entries;\n+  void **entries;\n \n   /* Current size (in entries) of the hash table.  */\n   size_t size;\n@@ -132,7 +128,7 @@ struct GTY(()) htab {\n   htab_free free_f;\n \n   /* Alternate allocate/free functions, which take an extra argument.  */\n-  void * GTY((skip)) alloc_arg;\n+  void *alloc_arg;\n   htab_alloc_with_arg alloc_with_arg_f;\n   htab_free_with_arg free_with_arg_f;\n "}, {"sha": "ec48a1fa5b8f384833ef29c5ee7566839fbe15e2", "filename": "include/splay-tree.h", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f5d5b818319129217e41bcb23db53f99ff11b0/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f5d5b818319129217e41bcb23db53f99ff11b0/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=63f5d5b818319129217e41bcb23db53f99ff11b0", "patch": "@@ -44,10 +44,6 @@ extern \"C\" {\n #include <inttypes.h>\n #endif\n \n-#ifndef GTY\n-#define GTY(X)\n-#endif\n-\n /* Use typedefs for the key and data types to facilitate changing\n    these types, if necessary.  These types should be sufficiently wide\n    that any pointer or scalar can be cast to these types, and then\n@@ -86,22 +82,22 @@ typedef void *(*splay_tree_allocate_fn) (int, void *);\n typedef void (*splay_tree_deallocate_fn) (void *, void *);\n \n /* The nodes in the splay tree.  */\n-struct GTY(()) splay_tree_node_s {\n+struct splay_tree_node_s {\n   /* The key.  */\n-  splay_tree_key GTY ((use_param1)) key;\n+  splay_tree_key key;\n \n   /* The value.  */\n-  splay_tree_value GTY ((use_param2)) value;\n+  splay_tree_value value;\n \n   /* The left and right children, respectively.  */\n-  splay_tree_node GTY ((use_params)) left;\n-  splay_tree_node GTY ((use_params)) right;\n+  splay_tree_node left;\n+  splay_tree_node right;\n };\n \n /* The splay tree itself.  */\n-struct GTY(()) splay_tree_s {\n+struct splay_tree_s {\n   /* The root of the tree.  */\n-  splay_tree_node GTY ((use_params)) root;\n+  splay_tree_node root;\n \n   /* The comparision function.  */\n   splay_tree_compare_fn comp;\n@@ -119,7 +115,7 @@ struct GTY(()) splay_tree_s {\n   splay_tree_deallocate_fn deallocate;\n \n   /* Parameter for allocate/free functions.  */\n-  void * GTY((skip)) allocate_data;\n+  void *allocate_data;\n };\n \n typedef struct splay_tree_s *splay_tree;"}]}