{"sha": "f3222b793db6b9a79d23e019b0395f0907597e75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMyMjJiNzkzZGI2YjlhNzlkMjNlMDE5YjAzOTVmMDkwNzU5N2U3NQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-19T20:51:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-19T20:51:09Z"}, "message": "emit_move et al return rtx_insn *\n\n2014-08-19  David Malcolm  <dmalcolm@redhat.com>\n\n\t* expr.h (emit_move_insn): Strengthen return type from rtx to\n\trtx_insn *.\n\t(emit_move_insn_1): Likewise.\n\t(emit_move_complex_push): Likewise.\n\t(emit_move_complex_parts): Likewise.\n\n\t* expr.c (emit_move_via_integer): Strengthen return type from rtx\n\tto rtx_insn *.  Replace use of NULL_RTX with NULL when working\n\twith insns.\n\t(emit_move_complex_push): Strengthen return type from rtx to\n\trtx_insn *.\n\t(emit_move_complex): Likewise, also for local \"ret\".\n\t(emit_move_ccmode): Likewise.\n\t(emit_move_multi_word): Likewise for return type and locals\n\t\"last_insn\", \"seq\".\n\t(emit_move_insn_1): Likewise for return type and locals \"result\",\n\t\"ret\".\n\t(emit_move_insn): Likewise for return type and local \"last_insn\".\n\t(compress_float_constant): Likewise.\n\nFrom-SVN: r214195", "tree": {"sha": "a137d7fa019883bc91608e7bfe8e36562ac11349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a137d7fa019883bc91608e7bfe8e36562ac11349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3222b793db6b9a79d23e019b0395f0907597e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3222b793db6b9a79d23e019b0395f0907597e75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3222b793db6b9a79d23e019b0395f0907597e75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3222b793db6b9a79d23e019b0395f0907597e75/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd459bf87c0662db04a840f15d2e914f1ae536fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd459bf87c0662db04a840f15d2e914f1ae536fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd459bf87c0662db04a840f15d2e914f1ae536fa"}], "stats": {"total": 79, "additions": 52, "deletions": 27}, "files": [{"sha": "c089c7728153505ccd4c4fd8c429968bf1811d4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3222b793db6b9a79d23e019b0395f0907597e75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3222b793db6b9a79d23e019b0395f0907597e75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3222b793db6b9a79d23e019b0395f0907597e75", "patch": "@@ -1,3 +1,25 @@\n+2014-08-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* expr.h (emit_move_insn): Strengthen return type from rtx to\n+\trtx_insn *.\n+\t(emit_move_insn_1): Likewise.\n+\t(emit_move_complex_push): Likewise.\n+\t(emit_move_complex_parts): Likewise.\n+\n+\t* expr.c (emit_move_via_integer): Strengthen return type from rtx\n+\tto rtx_insn *.  Replace use of NULL_RTX with NULL when working\n+\twith insns.\n+\t(emit_move_complex_push): Strengthen return type from rtx to\n+\trtx_insn *.\n+\t(emit_move_complex): Likewise, also for local \"ret\".\n+\t(emit_move_ccmode): Likewise.\n+\t(emit_move_multi_word): Likewise for return type and locals\n+\t\"last_insn\", \"seq\".\n+\t(emit_move_insn_1): Likewise for return type and locals \"result\",\n+\t\"ret\".\n+\t(emit_move_insn): Likewise for return type and local \"last_insn\".\n+\t(compress_float_constant): Likewise.\n+\n 2014-08-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* emit-rtl.h (emit_copy_of_insn_after): Strengthen return type"}, {"sha": "920d47b81eb04c02094e237684cd3e2777b6cc92", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3222b793db6b9a79d23e019b0395f0907597e75/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3222b793db6b9a79d23e019b0395f0907597e75/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f3222b793db6b9a79d23e019b0395f0907597e75", "patch": "@@ -134,7 +134,7 @@ static void store_by_pieces_1 (struct store_by_pieces_d *, unsigned int);\n static void store_by_pieces_2 (insn_gen_fn, machine_mode,\n \t\t\t       struct store_by_pieces_d *);\n static tree clear_storage_libcall_fn (int);\n-static rtx compress_float_constant (rtx, rtx);\n+static rtx_insn *compress_float_constant (rtx, rtx);\n static rtx get_subtarget (rtx);\n static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     HOST_WIDE_INT, enum machine_mode,\n@@ -3159,7 +3159,7 @@ emit_move_change_mode (enum machine_mode new_mode,\n    an integer mode of the same size as MODE.  Returns the instruction\n    emitted, or NULL if such a move could not be generated.  */\n \n-static rtx\n+static rtx_insn *\n emit_move_via_integer (enum machine_mode mode, rtx x, rtx y, bool force)\n {\n   enum machine_mode imode;\n@@ -3168,19 +3168,19 @@ emit_move_via_integer (enum machine_mode mode, rtx x, rtx y, bool force)\n   /* There must exist a mode of the exact size we require.  */\n   imode = int_mode_for_mode (mode);\n   if (imode == BLKmode)\n-    return NULL_RTX;\n+    return NULL;\n \n   /* The target must support moves in this mode.  */\n   code = optab_handler (mov_optab, imode);\n   if (code == CODE_FOR_nothing)\n-    return NULL_RTX;\n+    return NULL;\n \n   x = emit_move_change_mode (imode, mode, x, force);\n   if (x == NULL_RTX)\n-    return NULL_RTX;\n+    return NULL;\n   y = emit_move_change_mode (imode, mode, y, force);\n   if (y == NULL_RTX)\n-    return NULL_RTX;\n+    return NULL;\n   return emit_insn (GEN_FCN (code) (x, y));\n }\n \n@@ -3245,7 +3245,7 @@ emit_move_resolve_push (enum machine_mode mode, rtx x)\n    X is known to satisfy push_operand, and MODE is known to be complex.\n    Returns the last instruction emitted.  */\n \n-rtx\n+rtx_insn *\n emit_move_complex_push (enum machine_mode mode, rtx x, rtx y)\n {\n   enum machine_mode submode = GET_MODE_INNER (mode);\n@@ -3288,7 +3288,7 @@ emit_move_complex_push (enum machine_mode mode, rtx x, rtx y)\n /* A subroutine of emit_move_complex.  Perform the move from Y to X\n    via two moves of the parts.  Returns the last instruction emitted.  */\n \n-rtx\n+rtx_insn *\n emit_move_complex_parts (rtx x, rtx y)\n {\n   /* Show the output dies here.  This is necessary for SUBREGs\n@@ -3307,7 +3307,7 @@ emit_move_complex_parts (rtx x, rtx y)\n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n    MODE is known to be complex.  Returns the last instruction emitted.  */\n \n-static rtx\n+static rtx_insn *\n emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n {\n   bool try_int;\n@@ -3347,7 +3347,7 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n \n   if (try_int)\n     {\n-      rtx ret;\n+      rtx_insn *ret;\n \n       /* For memory to memory moves, optimal behavior can be had with the\n \t existing block move logic.  */\n@@ -3369,10 +3369,10 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n    MODE is known to be MODE_CC.  Returns the last instruction emitted.  */\n \n-static rtx\n+static rtx_insn *\n emit_move_ccmode (enum machine_mode mode, rtx x, rtx y)\n {\n-  rtx ret;\n+  rtx_insn *ret;\n \n   /* Assume all MODE_CC modes are equivalent; if we have movcc, use it.  */\n   if (mode != CCmode)\n@@ -3429,11 +3429,12 @@ undefined_operand_subword_p (const_rtx op, int i)\n    pattern.  Note that you will get better code if you define such\n    patterns, even if they must turn into multiple assembler instructions.  */\n \n-static rtx\n+static rtx_insn *\n emit_move_multi_word (enum machine_mode mode, rtx x, rtx y)\n {\n-  rtx last_insn = 0;\n-  rtx seq, inner;\n+  rtx_insn *last_insn = 0;\n+  rtx_insn *seq;\n+  rtx inner;\n   bool need_clobber;\n   int i;\n \n@@ -3509,7 +3510,7 @@ emit_move_multi_word (enum machine_mode mode, rtx x, rtx y)\n    Called just like emit_move_insn, but assumes X and Y\n    are basically valid.  */\n \n-rtx\n+rtx_insn *\n emit_move_insn_1 (rtx x, rtx y)\n {\n   enum machine_mode mode = GET_MODE (x);\n@@ -3528,7 +3529,7 @@ emit_move_insn_1 (rtx x, rtx y)\n   if (GET_MODE_CLASS (mode) == MODE_DECIMAL_FLOAT\n       || ALL_FIXED_POINT_MODE_P (mode))\n     {\n-      rtx result = emit_move_via_integer (mode, x, y, true);\n+      rtx_insn *result = emit_move_via_integer (mode, x, y, true);\n \n       /* If we can't find an integer mode, use multi words.  */\n       if (result)\n@@ -3546,7 +3547,7 @@ emit_move_insn_1 (rtx x, rtx y)\n      fits within a HOST_WIDE_INT.  */\n   if (!CONSTANT_P (y) || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      rtx ret = emit_move_via_integer (mode, x, y, lra_in_progress);\n+      rtx_insn *ret = emit_move_via_integer (mode, x, y, lra_in_progress);\n \n       if (ret)\n \t{\n@@ -3565,12 +3566,13 @@ emit_move_insn_1 (rtx x, rtx y)\n \n    Return the last instruction emitted.  */\n \n-rtx\n+rtx_insn *\n emit_move_insn (rtx x, rtx y)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx y_cst = NULL_RTX;\n-  rtx last_insn, set;\n+  rtx_insn *last_insn;\n+  rtx set;\n \n   gcc_assert (mode != BLKmode\n \t      && (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode));\n@@ -3628,7 +3630,7 @@ emit_move_insn (rtx x, rtx y)\n    perform the extension directly from constant or memory, then emit the\n    move as an extension.  */\n \n-static rtx\n+static rtx_insn *\n compress_float_constant (rtx x, rtx y)\n {\n   enum machine_mode dstmode = GET_MODE (x);\n@@ -3650,7 +3652,8 @@ compress_float_constant (rtx x, rtx y)\n        srcmode = GET_MODE_WIDER_MODE (srcmode))\n     {\n       enum insn_code ic;\n-      rtx trunc_y, last_insn;\n+      rtx trunc_y;\n+      rtx_insn *last_insn;\n \n       /* Skip if the target can't extend this way.  */\n       ic = can_extend_p (dstmode, srcmode, 0);\n@@ -3710,7 +3713,7 @@ compress_float_constant (rtx x, rtx y)\n       return last_insn;\n     }\n \n-  return NULL_RTX;\n+  return NULL;\n }\n \f\n /* Pushing data onto the stack.  */"}, {"sha": "756c89488d526a1ad802f76bfd42159e9ff16a73", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3222b793db6b9a79d23e019b0395f0907597e75/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3222b793db6b9a79d23e019b0395f0907597e75/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f3222b793db6b9a79d23e019b0395f0907597e75", "patch": "@@ -402,13 +402,13 @@ extern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT,\n \t\t\t    void *, unsigned int, bool, int);\n \n /* Emit insns to set X from Y.  */\n-extern rtx emit_move_insn (rtx, rtx);\n+extern rtx_insn *emit_move_insn (rtx, rtx);\n \n /* Emit insns to set X from Y, with no frills.  */\n-extern rtx emit_move_insn_1 (rtx, rtx);\n+extern rtx_insn *emit_move_insn_1 (rtx, rtx);\n \n-extern rtx emit_move_complex_push (enum machine_mode, rtx, rtx);\n-extern rtx emit_move_complex_parts (rtx, rtx);\n+extern rtx_insn *emit_move_complex_push (enum machine_mode, rtx, rtx);\n+extern rtx_insn *emit_move_complex_parts (rtx, rtx);\n extern rtx emit_move_resolve_push (enum machine_mode, rtx);\n \n /* Push a block of length SIZE (perhaps variable)"}]}