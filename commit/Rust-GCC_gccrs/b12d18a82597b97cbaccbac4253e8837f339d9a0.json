{"sha": "b12d18a82597b97cbaccbac4253e8837f339d9a0", "node_id": "C_kwDOANBUbNoAKGIxMmQxOGE4MjU5N2I5N2NiYWNjYmFjNDI1M2U4ODM3ZjMzOWQ5YTA", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-07-05T22:01:22Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-21T15:24:59Z"}, "message": "[Ada] Add assertions to Uintp\n\ngcc/ada/\n\n\t* uintp.ads, uintp.adb: Add assertions.\n\t(Ubool, Opt_Ubool): New \"boolean\" subtypes.\n\t(UI_Is_In_Int_Range): The parameter should probably be\n\tValid_Uint, but we don't change that for now, because it causes\n\tfailures in gigi.\n\t* sem_util.ads, sem_util.adb (Is_True, Is_False,\n\tStatic_Boolean): Use Opt_Ubool subtype.  Document the fact that\n\tIs_True (No_Uint) = True.  Implement Is_False in terms of\n\tIs_True.  We considered changing Static_Boolean to return Uint_1\n\tin case of error, but that doesn't fit in well with\n\tStatic_Integer.\n\t(Has_Compatible_Alignment_Internal): Deal with cases where Offs\n\tis No_Uint. Change one \"and\" to \"and then\" to ensure we don't\n\tpass No_Uint to \">\", which would violate the new assertions.\n\t* exp_util.adb, freeze.adb, sem_ch13.adb: Avoid violating new\n\tassertions in Uintp.", "tree": {"sha": "0ebb150fd5c953a4fc9dd1c8baa9d6a4d13a5027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ebb150fd5c953a4fc9dd1c8baa9d6a4d13a5027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b12d18a82597b97cbaccbac4253e8837f339d9a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12d18a82597b97cbaccbac4253e8837f339d9a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b12d18a82597b97cbaccbac4253e8837f339d9a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12d18a82597b97cbaccbac4253e8837f339d9a0/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97a5ed2071fffe85ee1a07e0655740162e4cce64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a5ed2071fffe85ee1a07e0655740162e4cce64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a5ed2071fffe85ee1a07e0655740162e4cce64"}], "stats": {"total": 655, "additions": 375, "deletions": 280}, "files": [{"sha": "966548151190da43d8feef0c0132e3f063cdff69", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -4892,6 +4892,9 @@ package body Exp_Util is\n       then\n          return False;\n \n+      elsif not Known_Normalized_First_Bit (Comp) then\n+         return True;\n+\n       --  Otherwise if the component is not byte aligned, we know we have the\n       --  nasty unaligned case.\n "}, {"sha": "15ce832b1d20e756d93f9eae7388a084ff7a4c88", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -1268,9 +1268,13 @@ package body Freeze is\n \n             if Present (Component_Clause (Comp)) then\n                Comp_Byte_Aligned :=\n-                 (Normalized_First_Bit (Comp) mod System_Storage_Unit = 0)\n+                 Known_Normalized_First_Bit (Comp)\n                    and then\n-                 (Esize (Comp) mod System_Storage_Unit = 0);\n+                 Known_Esize (Comp)\n+                   and then\n+                 Normalized_First_Bit (Comp) mod System_Storage_Unit = 0\n+                   and then\n+                 Esize (Comp) mod System_Storage_Unit = 0;\n             else\n                Comp_Byte_Aligned := not Is_Packed (Encl_Type);\n             end if;"}, {"sha": "b6face3136d2a8dbc807acc7e7cdf4a47a0a8b12", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -7824,7 +7824,7 @@ package body Sem_Ch13 is\n             if Duplicate_Clause then\n                null;\n \n-            elsif Is_Elementary_Type (U_Ent) then\n+            elsif Is_Elementary_Type (U_Ent) and then Present (Size) then\n                if Size /= System_Storage_Unit\n                  and then Size /= System_Storage_Unit * 2\n                  and then Size /= System_Storage_Unit * 3\n@@ -11903,9 +11903,23 @@ package body Sem_Ch13 is\n                --------\n \n                function Lt (Op1, Op2 : Natural) return Boolean is\n+                  K1 : constant Boolean :=\n+                    Known_Component_Bit_Offset (Comps (Op1));\n+                  K2 : constant Boolean :=\n+                    Known_Component_Bit_Offset (Comps (Op2));\n+                  --  Record representation clauses can be incomplete, so the\n+                  --  Component_Bit_Offsets can be unknown.\n                begin\n-                  return Component_Bit_Offset (Comps (Op1))\n-                       < Component_Bit_Offset (Comps (Op2));\n+                  if K1 then\n+                     if K2 then\n+                        return Component_Bit_Offset (Comps (Op1))\n+                             < Component_Bit_Offset (Comps (Op2));\n+                     else\n+                        return True;\n+                     end if;\n+                  else\n+                     return K2;\n+                  end if;\n                end Lt;\n \n                ----------"}, {"sha": "5fd72667e99d6a16bbe6ee01e7f3adeed23e76ba", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -11802,7 +11802,7 @@ package body Sem_Util is\n          --  Set to a factor of the offset from the base object when Expr is a\n          --  selected or indexed component, based on Component_Bit_Offset and\n          --  Component_Size respectively. A negative value is used to represent\n-         --  a value which is not known at compile time.\n+         --  a value that is not known at compile time.\n \n          procedure Check_Prefix;\n          --  Checks the prefix recursively in the case where the expression\n@@ -11910,7 +11910,7 @@ package body Sem_Util is\n          --  If we have a null offset, the result is entirely determined by\n          --  the base object and has already been computed recursively.\n \n-         if Offs = Uint_0 then\n+         if Present (Offs) and then Offs = Uint_0 then\n             null;\n \n          --  Case where we know the alignment of the object\n@@ -11932,7 +11932,7 @@ package body Sem_Util is\n                else\n                   --  If we have an offset, see if it is compatible\n \n-                  if Present (Offs) and Offs > Uint_0 then\n+                  if Present (Offs) and then Offs > Uint_0 then\n                      if Offs mod (System_Storage_Unit * ObjA) /= 0 then\n                         Set_Result (Known_Incompatible);\n                      end if;\n@@ -17549,9 +17549,9 @@ package body Sem_Util is\n    -- Is_False --\n    --------------\n \n-   function Is_False (U : Uint) return Boolean is\n+   function Is_False (U : Opt_Ubool) return Boolean is\n    begin\n-      return (U = 0);\n+      return not Is_True (U);\n    end Is_False;\n \n    ---------------------------\n@@ -21047,9 +21047,9 @@ package body Sem_Util is\n    -- Is_True --\n    -------------\n \n-   function Is_True (U : Uint) return Boolean is\n+   function Is_True (U : Opt_Ubool) return Boolean is\n    begin\n-      return U /= 0;\n+      return No (U) or else U = Uint_1;\n    end Is_True;\n \n    --------------------------------------\n@@ -28498,7 +28498,7 @@ package body Sem_Util is\n    -- Static_Boolean --\n    --------------------\n \n-   function Static_Boolean (N : Node_Id) return Uint is\n+   function Static_Boolean (N : Node_Id) return Opt_Ubool is\n    begin\n       Analyze_And_Resolve (N, Standard_Boolean);\n "}, {"sha": "7c89585137e6b81a6572d2e29e016e20c2eb3fb2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -2054,11 +2054,17 @@ package Sem_Util is\n    --    3) An if expression with at least one EVF dependent_expression\n    --    4) A case expression with at least one EVF dependent_expression\n \n-   function Is_False (U : Uint) return Boolean;\n+   function Is_False (U : Opt_Ubool) return Boolean;\n    pragma Inline (Is_False);\n-   --  The argument is a Uint value which is the Boolean'Pos value of a Boolean\n-   --  operand (i.e. is either 0 for False, or 1 for True). This function tests\n-   --  if it is False (i.e. zero).\n+   --  True if U is Boolean'Pos (False) (i.e. Uint_0)\n+\n+   function Is_True (U : Opt_Ubool) return Boolean;\n+   pragma Inline (Is_True);\n+   --  True if U is Boolean'Pos (True) (i.e. Uint_1). Also True if U is\n+   --  No_Uint; we allow No_Uint because Static_Boolean returns that in\n+   --  case of error. It doesn't really matter whether the error case is\n+   --  considered True or False, but we don't want this to blow up in that\n+   --  case.\n \n    function Is_Fixed_Model_Number (U : Ureal; T : Entity_Id) return Boolean;\n    --  Returns True iff the number U is a model number of the fixed-point type\n@@ -2422,12 +2428,6 @@ package Sem_Util is\n    --  unconditional transfer of control at run time, i.e. the following\n    --  statement definitely will not be executed.\n \n-   function Is_True (U : Uint) return Boolean;\n-   pragma Inline (Is_True);\n-   --  The argument is a Uint value which is the Boolean'Pos value of a Boolean\n-   --  operand (i.e. is either 0 for False, or 1 for True). This function tests\n-   --  if it is True (i.e. non-zero).\n-\n    function Is_Unchecked_Conversion_Instance (Id : Entity_Id) return Boolean;\n    --  Determine whether an arbitrary entity denotes an instance of function\n    --  Ada.Unchecked_Conversion.\n@@ -3219,7 +3219,7 @@ package Sem_Util is\n    --  predefined unit. The _Par version should be called only from the parser;\n    --  the _Sem version should be called only during semantic analysis.\n \n-   function Static_Boolean (N : Node_Id) return Uint;\n+   function Static_Boolean (N : Node_Id) return Opt_Ubool;\n    --  This function analyzes the given expression node and then resolves it\n    --  as Standard.Boolean. If the result is static, then Uint_1 or Uint_0 is\n    --  returned corresponding to the value, otherwise an error message is"}, {"sha": "dad4e9bcf8949a7e0a8d7053052a1dd80a93342c", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 172, "deletions": 133, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -110,12 +110,12 @@ package body Uintp is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Direct (U : Uint) return Boolean;\n+   function Direct (U : Valid_Uint) return Boolean;\n    pragma Inline (Direct);\n    --  Returns True if U is represented directly\n \n-   function Direct_Val (U : Uint) return Int;\n-   --  U is a Uint for is represented directly. The returned result is the\n+   function Direct_Val (U : Valid_Uint) return Int;\n+   --  U is a Uint that is represented directly. The returned result is the\n    --  value represented.\n \n    function GCD (Jin, Kin : Int) return Int;\n@@ -129,7 +129,7 @@ package body Uintp is\n    --  UI_Image, and false for UI_Write, and Format is copied from the Format\n    --  parameter to UI_Image or UI_Write.\n \n-   procedure Init_Operand (UI : Uint; Vec : out UI_Vector);\n+   procedure Init_Operand (UI : Valid_Uint; Vec : out UI_Vector);\n    pragma Inline (Init_Operand);\n    --  This procedure puts the value of UI into the vector in canonical\n    --  multiple precision format. The parameter should be of the correct size\n@@ -141,7 +141,7 @@ package body Uintp is\n \n    function Vector_To_Uint\n      (In_Vec   : UI_Vector;\n-      Negative : Boolean) return Uint;\n+      Negative : Boolean) return Valid_Uint;\n    --  Functions that calculate values in UI_Vectors, call this function to\n    --  create and return the Uint value. In_Vec contains the multiple precision\n    --  (Base) representation of a non-negative value. Leading zeroes are\n@@ -155,7 +155,7 @@ package body Uintp is\n    --  processing of signs is something that is done by the caller before\n    --  calling Vector_To_Uint.\n \n-   function Least_Sig_Digit (Arg : Uint) return Int;\n+   function Least_Sig_Digit (Arg : Valid_Uint) return Int;\n    pragma Inline (Least_Sig_Digit);\n    --  Returns the Least Significant Digit of Arg quickly. When the given Uint\n    --  is less than 2**15, the value returned is the input value, in this case\n@@ -165,38 +165,49 @@ package body Uintp is\n    --  two.\n \n    procedure Most_Sig_2_Digits\n-     (Left      : Uint;\n-      Right     : Uint;\n+     (Left      : Valid_Uint;\n+      Right     : Valid_Uint;\n       Left_Hat  : out Int;\n       Right_Hat : out Int);\n    --  Returns leading two significant digits from the given pair of Uint's.\n    --  Mathematically: returns Left / (Base**K) and Right / (Base**K) where\n    --  K is as small as possible S.T. Right_Hat < Base * Base. It is required\n    --  that Left >= Right for the algorithm to work.\n \n-   function N_Digits (Input : Uint) return Int;\n+   function N_Digits (Input : Valid_Uint) return Int;\n    pragma Inline (N_Digits);\n    --  Returns number of \"digits\" in a Uint\n \n    procedure UI_Div_Rem\n-     (Left, Right       : Uint;\n+     (Left, Right       : Valid_Uint;\n       Quotient          : out Uint;\n       Remainder         : out Uint;\n       Discard_Quotient  : Boolean := False;\n       Discard_Remainder : Boolean := False);\n    --  Compute Euclidean division of Left by Right. If Discard_Quotient is\n-   --  False then the quotient is returned in Quotient (otherwise Quotient is\n-   --  set to No_Uint). If Discard_Remainder is False, then the remainder is\n-   --  returned in Remainder (otherwise Remainder is set to No_Uint).\n+   --  False then the quotient is returned in Quotient. If Discard_Remainder\n+   --  is False, then the remainder is returned in Remainder.\n    --\n-   --  If Discard_Quotient is True, Quotient is set to No_Uint\n-   --  If Discard_Remainder is True, Remainder is set to No_Uint\n+   --  If Discard_Quotient is True, Quotient is set to No_Uint.\n+   --  If Discard_Remainder is True, Remainder is set to No_Uint.\n+\n+   function UI_Modular_Exponentiation\n+     (B      : Valid_Uint;\n+      E      : Valid_Uint;\n+      Modulo : Valid_Uint) return Valid_Uint with Unreferenced;\n+   --  Efficiently compute (B**E) rem Modulo\n+\n+   function UI_Modular_Inverse\n+     (N : Valid_Uint; Modulo : Valid_Uint) return Valid_Uint with Unreferenced;\n+   --  Compute the multiplicative inverse of N in modular arithmetics with the\n+   --  given Modulo (uses Euclid's algorithm). Note: the call is considered\n+   --  to be erroneous (and the behavior is undefined) if n is not invertible.\n \n    ------------\n    -- Direct --\n    ------------\n \n-   function Direct (U : Uint) return Boolean is\n+   function Direct (U : Valid_Uint) return Boolean is\n    begin\n       return Int (U) <= Int (Uint_Direct_Last);\n    end Direct;\n@@ -205,7 +216,7 @@ package body Uintp is\n    -- Direct_Val --\n    ----------------\n \n-   function Direct_Val (U : Uint) return Int is\n+   function Direct_Val (U : Valid_Uint) return Int is\n    begin\n       pragma Assert (Direct (U));\n       return Int (U) - Int (Uint_Direct_Bias);\n@@ -252,8 +263,8 @@ package body Uintp is\n       Format    : UI_Format)\n    is\n       Marks  : constant Uintp.Save_Mark := Uintp.Mark;\n-      Base   : Uint;\n-      Ainput : Uint;\n+      Base   : Valid_Uint;\n+      Ainput : Valid_Uint;\n \n       Digs_Output : Natural := 0;\n       --  Counts digits output. In hex mode, but not in decimal mode, we\n@@ -277,16 +288,16 @@ package body Uintp is\n       --  Output non-zero exponent. Note that we only use the exponent form in\n       --  the buffer case, so we know that To_Buffer is true.\n \n-      procedure Image_Uint (U : Uint);\n+      procedure Image_Uint (U : Valid_Uint);\n       --  Internal procedure to output characters of non-negative Uint\n \n       -------------------\n       -- Better_In_Hex --\n       -------------------\n \n       function Better_In_Hex return Boolean is\n-         T16 : constant Uint := Uint_2**Int'(16);\n-         A   : Uint;\n+         T16 : constant Valid_Uint := Uint_2**Int'(16);\n+         A   : Valid_Uint;\n \n       begin\n          A := UI_Abs (Input);\n@@ -364,11 +375,11 @@ package body Uintp is\n       -- Image_Uint --\n       ----------------\n \n-      procedure Image_Uint (U : Uint) is\n+      procedure Image_Uint (U : Valid_Uint) is\n          H : constant array (Int range 0 .. 15) of Character :=\n                \"0123456789ABCDEF\";\n \n-         Q, R : Uint;\n+         Q, R : Valid_Uint;\n       begin\n          UI_Div_Rem (U, Base, Q, R);\n \n@@ -431,7 +442,7 @@ package body Uintp is\n    -- Init_Operand --\n    -------------------\n \n-   procedure Init_Operand (UI : Uint; Vec : out UI_Vector) is\n+   procedure Init_Operand (UI : Valid_Uint; Vec : out UI_Vector) is\n       Loc : Int;\n \n       pragma Assert (Vec'First = Int'(1));\n@@ -482,7 +493,7 @@ package body Uintp is\n    -- Least_Sig_Digit --\n    ---------------------\n \n-   function Least_Sig_Digit (Arg : Uint) return Int is\n+   function Least_Sig_Digit (Arg : Valid_Uint) return Int is\n       V : Int;\n \n    begin\n@@ -518,8 +529,8 @@ package body Uintp is\n    -----------------------\n \n    procedure Most_Sig_2_Digits\n-     (Left      : Uint;\n-      Right     : Uint;\n+     (Left      : Valid_Uint;\n+      Right     : Valid_Uint;\n       Left_Hat  : out Int;\n       Right_Hat : out Int)\n    is\n@@ -580,9 +591,7 @@ package body Uintp is\n    -- N_Digits --\n    ---------------\n \n-   --  Note: N_Digits returns 1 for No_Uint\n-\n-   function N_Digits (Input : Uint) return Int is\n+   function N_Digits (Input : Valid_Uint) return Int is\n    begin\n       if Direct (Input) then\n          if Direct_Val (Input) >= Base then\n@@ -600,7 +609,7 @@ package body Uintp is\n    -- Num_Bits --\n    --------------\n \n-   function Num_Bits (Input : Uint) return Nat is\n+   function Num_Bits (Input : Valid_Uint) return Nat is\n       Bits : Nat;\n       Num  : Nat;\n \n@@ -661,15 +670,15 @@ package body Uintp is\n \n    procedure Release (M : Save_Mark) is\n    begin\n-      Uints.Set_Last   (Uint'Max (M.Save_Uint,   Uints_Min));\n+      Uints.Set_Last   (Valid_Uint'Max (M.Save_Uint, Uints_Min));\n       Udigits.Set_Last (Int'Max  (M.Save_Udigit, Udigits_Min));\n    end Release;\n \n    ----------------------\n    -- Release_And_Save --\n    ----------------------\n \n-   procedure Release_And_Save (M : Save_Mark; UI : in out Uint) is\n+   procedure Release_And_Save (M : Save_Mark; UI : in out Valid_Uint) is\n    begin\n       if Direct (UI) then\n          Release (M);\n@@ -695,7 +704,7 @@ package body Uintp is\n       end if;\n    end Release_And_Save;\n \n-   procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Uint) is\n+   procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Valid_Uint) is\n    begin\n       if Direct (UI1) then\n          Release_And_Save (M, UI2);\n@@ -741,7 +750,7 @@ package body Uintp is\n    -- UI_Abs --\n    -------------\n \n-   function UI_Abs (Right : Uint) return Uint is\n+   function UI_Abs (Right : Valid_Uint) return Unat is\n    begin\n       if Right < Uint_0 then\n          return -Right;\n@@ -754,18 +763,23 @@ package body Uintp is\n    -- UI_Add --\n    -------------\n \n-   function UI_Add (Left : Int; Right : Uint) return Uint is\n+   function UI_Add (Left : Int; Right : Valid_Uint) return Valid_Uint is\n    begin\n       return UI_Add (UI_From_Int (Left), Right);\n    end UI_Add;\n \n-   function UI_Add (Left : Uint; Right : Int) return Uint is\n+   function UI_Add (Left : Valid_Uint; Right : Int) return Valid_Uint is\n    begin\n       return UI_Add (Left, UI_From_Int (Right));\n    end UI_Add;\n \n-   function UI_Add (Left : Uint; Right : Uint) return Uint is\n+   function UI_Add (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint is\n    begin\n+      pragma Assert (Present (Left));\n+      pragma Assert (Present (Right));\n+      --  Assertions are here in case we're called from C++ code, which does\n+      --  not check the predicates.\n+\n       --  Simple cases of direct operands and addition of zero\n \n       if Direct (Left) then\n@@ -930,7 +944,7 @@ package body Uintp is\n    -- UI_Decimal_Digits_Hi --\n    --------------------------\n \n-   function UI_Decimal_Digits_Hi (U : Uint) return Nat is\n+   function UI_Decimal_Digits_Hi (U : Valid_Uint) return Nat is\n    begin\n       --  The maximum value of a \"digit\" is 32767, which is 5 decimal digits,\n       --  so an N_Digit number could take up to 5 times this number of digits.\n@@ -944,7 +958,7 @@ package body Uintp is\n    -- UI_Decimal_Digits_Lo --\n    --------------------------\n \n-   function UI_Decimal_Digits_Lo (U : Uint) return Nat is\n+   function UI_Decimal_Digits_Lo (U : Valid_Uint) return Nat is\n    begin\n       --  The maximum value of a \"digit\" is 32767, which is more than four\n       --  decimal digits, but not a full five digits. The easily computed\n@@ -959,24 +973,27 @@ package body Uintp is\n    -- UI_Div --\n    ------------\n \n-   function UI_Div (Left : Int; Right : Uint) return Uint is\n+   function UI_Div (Left : Int; Right : Nonzero_Uint) return Valid_Uint is\n    begin\n       return UI_Div (UI_From_Int (Left), Right);\n    end UI_Div;\n \n-   function UI_Div (Left : Uint; Right : Int) return Uint is\n+   function UI_Div\n+     (Left : Valid_Uint; Right : Nonzero_Int) return Valid_Uint\n+   is\n    begin\n       return UI_Div (Left, UI_From_Int (Right));\n    end UI_Div;\n \n-   function UI_Div (Left, Right : Uint) return Uint is\n-      Quotient  : Uint;\n-      Remainder : Uint;\n-      pragma Warnings (Off, Remainder);\n+   function UI_Div\n+     (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint\n+   is\n+      Quotient  : Valid_Uint;\n+      Ignored_Remainder : Uint;\n    begin\n       UI_Div_Rem\n         (Left, Right,\n-         Quotient, Remainder,\n+         Quotient, Ignored_Remainder,\n          Discard_Remainder => True);\n       return Quotient;\n    end UI_Div;\n@@ -986,7 +1003,7 @@ package body Uintp is\n    ----------------\n \n    procedure UI_Div_Rem\n-     (Left, Right       : Uint;\n+     (Left, Right       : Valid_Uint;\n       Quotient          : out Uint;\n       Remainder         : out Uint;\n       Discard_Quotient  : Boolean := False;\n@@ -1260,14 +1277,13 @@ package body Uintp is\n             if not Discard_Remainder then\n                declare\n                   Remainder_V : UI_Vector (1 .. R_Length);\n-                  Discard_Int : Int;\n-                  pragma Warnings (Off, Discard_Int);\n+                  Ignore : Int;\n                begin\n                   pragma Assert (D /= Int'(0));\n                   UI_Div_Vector\n                     (Dividend (Dividend'Last - R_Length + 1 .. Dividend'Last),\n                      D,\n-                     Remainder_V, Discard_Int);\n+                     Remainder_V, Ignore);\n                   Remainder := Vector_To_Uint (Remainder_V, L_Vec (1) < Int_0);\n                end;\n             end if;\n@@ -1279,17 +1295,17 @@ package body Uintp is\n    -- UI_Eq --\n    ------------\n \n-   function UI_Eq (Left : Int; Right : Uint) return Boolean is\n+   function UI_Eq (Left : Int; Right : Valid_Uint) return Boolean is\n    begin\n       return not UI_Ne (UI_From_Int (Left), Right);\n    end UI_Eq;\n \n-   function UI_Eq (Left : Uint; Right : Int) return Boolean is\n+   function UI_Eq (Left : Valid_Uint; Right : Int) return Boolean is\n    begin\n       return not UI_Ne (Left, UI_From_Int (Right));\n    end UI_Eq;\n \n-   function UI_Eq (Left : Uint; Right : Uint) return Boolean is\n+   function UI_Eq (Left : Valid_Uint; Right : Valid_Uint) return Boolean is\n    begin\n       return not UI_Ne (Left, Right);\n    end UI_Eq;\n@@ -1298,22 +1314,24 @@ package body Uintp is\n    -- UI_Expon --\n    --------------\n \n-   function UI_Expon (Left : Int; Right : Uint) return Uint is\n+   function UI_Expon (Left : Int; Right : Unat) return Valid_Uint is\n    begin\n       return UI_Expon (UI_From_Int (Left), Right);\n    end UI_Expon;\n \n-   function UI_Expon (Left : Uint; Right : Int) return Uint is\n+   function UI_Expon (Left : Valid_Uint; Right : Nat) return Valid_Uint is\n    begin\n       return UI_Expon (Left, UI_From_Int (Right));\n    end UI_Expon;\n \n-   function UI_Expon (Left : Int; Right : Int) return Uint is\n+   function UI_Expon (Left : Int; Right : Nat) return Valid_Uint is\n    begin\n       return UI_Expon (UI_From_Int (Left), UI_From_Int (Right));\n    end UI_Expon;\n \n-   function UI_Expon (Left : Uint; Right : Uint) return Uint is\n+   function UI_Expon\n+     (Left : Valid_Uint; Right : Unat) return Valid_Uint\n+   is\n    begin\n       pragma Assert (Right >= Uint_0);\n \n@@ -1386,9 +1404,9 @@ package body Uintp is\n       --  If we fall through, then we have the general case (see Knuth 4.6.3)\n \n       declare\n-         N       : Uint := Right;\n-         Squares : Uint := Left;\n-         Result  : Uint := Uint_1;\n+         N       : Valid_Uint := Right;\n+         Squares : Valid_Uint := Left;\n+         Result  : Valid_Uint := Uint_1;\n          M       : constant Uintp.Save_Mark := Uintp.Mark;\n \n       begin\n@@ -1411,7 +1429,7 @@ package body Uintp is\n    -- UI_From_CC --\n    ----------------\n \n-   function UI_From_CC (Input : Char_Code) return Uint is\n+   function UI_From_CC (Input : Char_Code) return Valid_Uint is\n    begin\n       return UI_From_Int (Int (Input));\n    end UI_From_CC;\n@@ -1420,12 +1438,12 @@ package body Uintp is\n    -- UI_From_Int --\n    -----------------\n \n-   function UI_From_Int (Input : Int) return Uint is\n+   function UI_From_Int (Input : Int) return Valid_Uint is\n       U : Uint;\n \n    begin\n       if Min_Direct <= Input and then Input <= Max_Direct then\n-         return Uint (Int (Uint_Direct_Bias) + Input);\n+         return Valid_Uint (Int (Uint_Direct_Bias) + Input);\n       end if;\n \n       --  If already in the hash table, return entry\n@@ -1466,7 +1484,7 @@ package body Uintp is\n    -- UI_From_Integral --\n    ----------------------\n \n-   function UI_From_Integral (Input : In_T) return Uint is\n+   function UI_From_Integral (Input : In_T) return Valid_Uint is\n    begin\n       --  If in range of our normal conversion function, use it so we can use\n       --  direct access and our cache.\n@@ -1487,7 +1505,7 @@ package body Uintp is\n             --  Base is defined so that 3 Uint digits is sufficient to hold the\n             --  largest possible Int value.\n \n-            U : Uint;\n+            U : Valid_Uint;\n             V : UI_Vector (1 .. Max_For_In_T);\n \n          begin\n@@ -1517,16 +1535,16 @@ package body Uintp is\n \n    --  We use the same notation as Knuth (U_Hat standing for the obvious)\n \n-   function UI_GCD (Uin, Vin : Uint) return Uint is\n-      U, V : Uint;\n+   function UI_GCD (Uin, Vin : Valid_Uint) return Valid_Uint is\n+      U, V : Valid_Uint;\n       --  Copies of Uin and Vin\n \n       U_Hat, V_Hat : Int;\n       --  The most Significant digits of U,V\n \n       A, B, C, D, T, Q, Den1, Den2 : Int;\n \n-      Tmp_UI : Uint;\n+      Tmp_UI : Valid_Uint;\n       Marks  : constant Uintp.Save_Mark := Uintp.Mark;\n       Iterations : Integer := 0;\n \n@@ -1619,17 +1637,17 @@ package body Uintp is\n    -- UI_Ge --\n    ------------\n \n-   function UI_Ge (Left : Int; Right : Uint) return Boolean is\n+   function UI_Ge (Left : Int; Right : Valid_Uint) return Boolean is\n    begin\n       return not UI_Lt (UI_From_Int (Left), Right);\n    end UI_Ge;\n \n-   function UI_Ge (Left : Uint; Right : Int) return Boolean is\n+   function UI_Ge (Left : Valid_Uint; Right : Int) return Boolean is\n    begin\n       return not UI_Lt (Left, UI_From_Int (Right));\n    end UI_Ge;\n \n-   function UI_Ge (Left : Uint; Right : Uint) return Boolean is\n+   function UI_Ge (Left : Valid_Uint; Right : Valid_Uint) return Boolean is\n    begin\n       return not UI_Lt (Left, Right);\n    end UI_Ge;\n@@ -1638,17 +1656,17 @@ package body Uintp is\n    -- UI_Gt --\n    ------------\n \n-   function UI_Gt (Left : Int; Right : Uint) return Boolean is\n+   function UI_Gt (Left : Int; Right : Valid_Uint) return Boolean is\n    begin\n       return UI_Lt (Right, UI_From_Int (Left));\n    end UI_Gt;\n \n-   function UI_Gt (Left : Uint; Right : Int) return Boolean is\n+   function UI_Gt (Left : Valid_Uint; Right : Int) return Boolean is\n    begin\n       return UI_Lt (UI_From_Int (Right), Left);\n    end UI_Gt;\n \n-   function UI_Gt (Left : Uint; Right : Uint) return Boolean is\n+   function UI_Gt (Left : Valid_Uint; Right : Valid_Uint) return Boolean is\n    begin\n       return UI_Lt (Left => Right, Right => Left);\n    end UI_Gt;\n@@ -1681,29 +1699,32 @@ package body Uintp is\n \n       pragma Assert (Uint_Int_First /= Uint_0);\n \n+      if No (Input) then -- Preserve old behavior\n+         return True;\n+      end if;\n+\n       if Direct (Input) then\n          return True;\n       else\n-         return Input >= Uint_Int_First\n-           and then Input <= Uint_Int_Last;\n+         return Input >= Uint_Int_First and then Input <= Uint_Int_Last;\n       end if;\n    end UI_Is_In_Int_Range;\n \n    ------------\n    -- UI_Le --\n    ------------\n \n-   function UI_Le (Left : Int; Right : Uint) return Boolean is\n+   function UI_Le (Left : Int; Right : Valid_Uint) return Boolean is\n    begin\n       return not UI_Lt (Right, UI_From_Int (Left));\n    end UI_Le;\n \n-   function UI_Le (Left : Uint; Right : Int) return Boolean is\n+   function UI_Le (Left : Valid_Uint; Right : Int) return Boolean is\n    begin\n       return not UI_Lt (UI_From_Int (Right), Left);\n    end UI_Le;\n \n-   function UI_Le (Left : Uint; Right : Uint) return Boolean is\n+   function UI_Le (Left : Valid_Uint; Right : Valid_Uint) return Boolean is\n    begin\n       return not UI_Lt (Left => Right, Right => Left);\n    end UI_Le;\n@@ -1712,18 +1733,23 @@ package body Uintp is\n    -- UI_Lt --\n    ------------\n \n-   function UI_Lt (Left : Int; Right : Uint) return Boolean is\n+   function UI_Lt (Left : Int; Right : Valid_Uint) return Boolean is\n    begin\n       return UI_Lt (UI_From_Int (Left), Right);\n    end UI_Lt;\n \n-   function UI_Lt (Left : Uint; Right : Int) return Boolean is\n+   function UI_Lt (Left : Valid_Uint; Right : Int) return Boolean is\n    begin\n       return UI_Lt (Left, UI_From_Int (Right));\n    end UI_Lt;\n \n-   function UI_Lt (Left : Uint; Right : Uint) return Boolean is\n+   function UI_Lt (Left : Valid_Uint; Right : Valid_Uint) return Boolean is\n    begin\n+      pragma Assert (Present (Left));\n+      pragma Assert (Present (Right));\n+      --  Assertions are here in case we're called from C++ code, which does\n+      --  not check the predicates.\n+\n       --  Quick processing for identical arguments\n \n       if Int (Left) = Int (Right) then\n@@ -1805,17 +1831,17 @@ package body Uintp is\n    -- UI_Max --\n    ------------\n \n-   function UI_Max (Left : Int; Right : Uint) return Uint is\n+   function UI_Max (Left : Int; Right : Valid_Uint) return Valid_Uint is\n    begin\n       return UI_Max (UI_From_Int (Left), Right);\n    end UI_Max;\n \n-   function UI_Max (Left : Uint; Right : Int) return Uint is\n+   function UI_Max (Left : Valid_Uint; Right : Int) return Valid_Uint is\n    begin\n       return UI_Max (Left, UI_From_Int (Right));\n    end UI_Max;\n \n-   function UI_Max (Left : Uint; Right : Uint) return Uint is\n+   function UI_Max (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint is\n    begin\n       if Left >= Right then\n          return Left;\n@@ -1828,17 +1854,17 @@ package body Uintp is\n    -- UI_Min --\n    ------------\n \n-   function UI_Min (Left : Int; Right : Uint) return Uint is\n+   function UI_Min (Left : Int; Right : Valid_Uint) return Valid_Uint is\n    begin\n       return UI_Min (UI_From_Int (Left), Right);\n    end UI_Min;\n \n-   function UI_Min (Left : Uint; Right : Int) return Uint is\n+   function UI_Min (Left : Valid_Uint; Right : Int) return Valid_Uint is\n    begin\n       return UI_Min (Left, UI_From_Int (Right));\n    end UI_Min;\n \n-   function UI_Min (Left : Uint; Right : Uint) return Uint is\n+   function UI_Min (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint is\n    begin\n       if Left <= Right then\n          return Left;\n@@ -1851,18 +1877,22 @@ package body Uintp is\n    -- UI_Mod --\n    -------------\n \n-   function UI_Mod (Left : Int; Right : Uint) return Uint is\n+   function UI_Mod (Left : Int; Right : Nonzero_Uint) return Valid_Uint is\n    begin\n       return UI_Mod (UI_From_Int (Left), Right);\n    end UI_Mod;\n \n-   function UI_Mod (Left : Uint; Right : Int) return Uint is\n+   function UI_Mod\n+     (Left : Valid_Uint; Right : Nonzero_Int) return Valid_Uint\n+   is\n    begin\n       return UI_Mod (Left, UI_From_Int (Right));\n    end UI_Mod;\n \n-   function UI_Mod (Left : Uint; Right : Uint) return Uint is\n-      Urem : constant Uint := Left rem Right;\n+   function UI_Mod\n+     (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint\n+   is\n+      Urem : constant Valid_Uint := Left rem Right;\n \n    begin\n       if (Left < Uint_0) = (Right < Uint_0)\n@@ -1879,15 +1909,15 @@ package body Uintp is\n    -------------------------------\n \n    function UI_Modular_Exponentiation\n-     (B      : Uint;\n-      E      : Uint;\n-      Modulo : Uint) return Uint\n+     (B      : Valid_Uint;\n+      E      : Valid_Uint;\n+      Modulo : Valid_Uint) return Valid_Uint\n    is\n       M : constant Save_Mark := Mark;\n \n-      Result   : Uint := Uint_1;\n-      Base     : Uint := B;\n-      Exponent : Uint := E;\n+      Result   : Valid_Uint := Uint_1;\n+      Base     : Valid_Uint := B;\n+      Exponent : Valid_Uint := E;\n \n    begin\n       while Exponent /= Uint_0 loop\n@@ -1907,15 +1937,17 @@ package body Uintp is\n    -- UI_Modular_Inverse --\n    ------------------------\n \n-   function UI_Modular_Inverse (N : Uint; Modulo : Uint) return Uint is\n+   function UI_Modular_Inverse\n+     (N : Valid_Uint; Modulo : Valid_Uint) return Valid_Uint\n+   is\n       M : constant Save_Mark := Mark;\n-      U : Uint;\n-      V : Uint;\n-      Q : Uint;\n-      R : Uint;\n-      X : Uint;\n-      Y : Uint;\n-      T : Uint;\n+      U : Valid_Uint;\n+      V : Valid_Uint;\n+      Q : Valid_Uint;\n+      R : Valid_Uint;\n+      X : Valid_Uint;\n+      Y : Valid_Uint;\n+      T : Valid_Uint;\n       S : Int := 1;\n \n    begin\n@@ -1951,17 +1983,17 @@ package body Uintp is\n    -- UI_Mul --\n    ------------\n \n-   function UI_Mul (Left : Int; Right : Uint) return Uint is\n+   function UI_Mul (Left : Int; Right : Valid_Uint) return Valid_Uint is\n    begin\n       return UI_Mul (UI_From_Int (Left), Right);\n    end UI_Mul;\n \n-   function UI_Mul (Left : Uint; Right : Int) return Uint is\n+   function UI_Mul (Left : Valid_Uint; Right : Int) return Valid_Uint is\n    begin\n       return UI_Mul (Left, UI_From_Int (Right));\n    end UI_Mul;\n \n-   function UI_Mul (Left : Uint; Right : Uint) return Uint is\n+   function UI_Mul (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint is\n    begin\n       --  Case where product fits in the range of a 32-bit integer\n \n@@ -2019,20 +2051,24 @@ package body Uintp is\n    -- UI_Ne --\n    ------------\n \n-   function UI_Ne (Left : Int; Right : Uint) return Boolean is\n+   function UI_Ne (Left : Int; Right : Valid_Uint) return Boolean is\n    begin\n       return UI_Ne (UI_From_Int (Left), Right);\n    end UI_Ne;\n \n-   function UI_Ne (Left : Uint; Right : Int) return Boolean is\n+   function UI_Ne (Left : Valid_Uint; Right : Int) return Boolean is\n    begin\n       return UI_Ne (Left, UI_From_Int (Right));\n    end UI_Ne;\n \n-   function UI_Ne (Left : Uint; Right : Uint) return Boolean is\n+   function UI_Ne (Left : Valid_Uint; Right : Valid_Uint) return Boolean is\n    begin\n-      --  Quick processing for identical arguments. Note that this takes\n-      --  care of the case of two No_Uint arguments.\n+      pragma Assert (Present (Left));\n+      pragma Assert (Present (Right));\n+      --  Assertions are here in case we're called from C++ code, which does\n+      --  not check the predicates.\n+\n+      --  Quick processing for identical arguments\n \n       if Int (Left) = Int (Right) then\n          return False;\n@@ -2090,7 +2126,7 @@ package body Uintp is\n    -- UI_Negate --\n    ----------------\n \n-   function UI_Negate (Right : Uint) return Uint is\n+   function UI_Negate (Right : Valid_Uint) return Valid_Uint is\n    begin\n       --  Case where input is directly represented. Note that since the range\n       --  of Direct values is non-symmetrical, the result may not be directly\n@@ -2123,20 +2159,23 @@ package body Uintp is\n    -- UI_Rem --\n    -------------\n \n-   function UI_Rem (Left : Int; Right : Uint) return Uint is\n+   function UI_Rem (Left : Int; Right : Nonzero_Uint) return Valid_Uint is\n    begin\n       return UI_Rem (UI_From_Int (Left), Right);\n    end UI_Rem;\n \n-   function UI_Rem (Left : Uint; Right : Int) return Uint is\n+   function UI_Rem\n+     (Left : Valid_Uint; Right : Nonzero_Int) return Valid_Uint\n+   is\n    begin\n       return UI_Rem (Left, UI_From_Int (Right));\n    end UI_Rem;\n \n-   function UI_Rem (Left, Right : Uint) return Uint is\n-      Remainder : Uint;\n-      Quotient  : Uint;\n-      pragma Warnings (Off, Quotient);\n+   function UI_Rem\n+     (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint\n+   is\n+      Remainder : Valid_Uint;\n+      Ignored_Quotient  : Uint;\n \n    begin\n       pragma Assert (Right /= Uint_0);\n@@ -2146,7 +2185,8 @@ package body Uintp is\n \n       else\n          UI_Div_Rem\n-           (Left, Right, Quotient, Remainder, Discard_Quotient => True);\n+           (Left, Right, Ignored_Quotient, Remainder,\n+            Discard_Quotient => True);\n          return Remainder;\n       end if;\n    end UI_Rem;\n@@ -2155,17 +2195,17 @@ package body Uintp is\n    -- UI_Sub --\n    ------------\n \n-   function UI_Sub (Left : Int; Right : Uint) return Uint is\n+   function UI_Sub (Left : Int; Right : Valid_Uint) return Valid_Uint is\n    begin\n       return UI_Add (Left, -Right);\n    end UI_Sub;\n \n-   function UI_Sub (Left : Uint; Right : Int) return Uint is\n+   function UI_Sub (Left : Valid_Uint; Right : Int) return Valid_Uint is\n    begin\n       return UI_Add (Left, -Right);\n    end UI_Sub;\n \n-   function UI_Sub (Left : Uint; Right : Uint) return Uint is\n+   function UI_Sub (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint is\n    begin\n       if Direct (Left) and then Direct (Right) then\n          return UI_From_Int (Direct_Val (Left) - Direct_Val (Right));\n@@ -2178,7 +2218,7 @@ package body Uintp is\n    -- UI_To_CC --\n    --------------\n \n-   function UI_To_CC (Input : Uint) return Char_Code is\n+   function UI_To_CC (Input : Valid_Uint) return Char_Code is\n    begin\n       if Direct (Input) then\n          return Char_Code (Direct_Val (Input));\n@@ -2309,8 +2349,7 @@ package body Uintp is\n \n    function Vector_To_Uint\n      (In_Vec   : UI_Vector;\n-      Negative : Boolean)\n-      return     Uint\n+      Negative : Boolean) return Valid_Uint\n    is\n       Size : Int;\n       Val  : Int;\n@@ -2330,9 +2369,9 @@ package body Uintp is\n \n             if Size = Int_1 then\n                if Negative then\n-                  return Uint (Int (Uint_Direct_Bias) - In_Vec (J));\n+                  return Valid_Uint (Int (Uint_Direct_Bias) - In_Vec (J));\n                else\n-                  return Uint (Int (Uint_Direct_Bias) + In_Vec (J));\n+                  return Valid_Uint (Int (Uint_Direct_Bias) + In_Vec (J));\n                end if;\n \n             --  Positive two digit values may be in direct representation range\n@@ -2341,7 +2380,7 @@ package body Uintp is\n                Val := In_Vec (J) * Base + In_Vec (J + 1);\n \n                if Val <= Max_Direct then\n-                  return Uint (Int (Uint_Direct_Bias) + Val);\n+                  return Valid_Uint (Int (Uint_Direct_Bias) + Val);\n                end if;\n             end if;\n "}, {"sha": "75bc5581fb50af01bd03d410a1ffd987b38e04a1", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 158, "deletions": 123, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12d18a82597b97cbaccbac4253e8837f339d9a0/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=b12d18a82597b97cbaccbac4253e8837f339d9a0", "patch": "@@ -91,12 +91,18 @@ package Uintp is\n    Uint_Minus_128 : constant Uint;\n \n    function No (X : Uint) return Boolean is (X = No_Uint);\n+   --  Note that this is using the predefined \"=\", not the \"=\" declared below,\n+   --  which would blow up on No_Uint.\n+\n    function Present (X : Uint) return Boolean is (not No (X));\n \n    subtype Valid_Uint is Uint with Predicate => Present (Valid_Uint);\n    subtype Unat is Valid_Uint with Predicate => Unat >= Uint_0; -- natural\n    subtype Upos is Valid_Uint with Predicate => Upos >= Uint_1; -- positive\n    subtype Nonzero_Uint is Valid_Uint with Predicate => Nonzero_Uint /= Uint_0;\n+   subtype Ubool is Valid_Uint with Predicate => Ubool in Uint_0 | Uint_1;\n+   subtype Opt_Ubool is Uint with\n+     Predicate => No (Opt_Ubool) or else Opt_Ubool in Ubool;\n \n    -----------------\n    -- Subprograms --\n@@ -107,141 +113,131 @@ package Uintp is\n    --  unit, these are among the few tables that can be expanded during\n    --  gigi processing.\n \n-   function UI_Abs (Right : Uint) return Uint;\n+   function UI_Abs (Right : Valid_Uint) return Unat;\n    pragma Inline (UI_Abs);\n    --  Returns abs function of universal integer\n \n-   function UI_Add (Left : Uint; Right : Uint) return Uint;\n-   function UI_Add (Left : Int;  Right : Uint) return Uint;\n-   function UI_Add (Left : Uint; Right : Int)  return Uint;\n+   function UI_Add (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint;\n+   function UI_Add (Left : Int;  Right : Valid_Uint) return Valid_Uint;\n+   function UI_Add (Left : Valid_Uint; Right : Int)  return Valid_Uint;\n    --  Returns sum of two integer values\n \n-   function UI_Decimal_Digits_Hi (U : Uint) return Nat;\n+   function UI_Decimal_Digits_Hi (U : Valid_Uint) return Nat;\n    --  Returns an estimate of the number of decimal digits required to\n    --  represent the absolute value of U. This estimate is correct or high,\n    --  i.e. it never returns a value that is too low. The accuracy of the\n    --  estimate affects only the effectiveness of comparison optimizations\n    --  in Urealp.\n \n-   function UI_Decimal_Digits_Lo (U : Uint) return Nat;\n+   function UI_Decimal_Digits_Lo (U : Valid_Uint) return Nat;\n    --  Returns an estimate of the number of decimal digits required to\n    --  represent the absolute value of U. This estimate is correct or low,\n    --  i.e. it never returns a value that is too high. The accuracy of the\n    --  estimate affects only the effectiveness of comparison optimizations\n    --  in Urealp.\n \n-   function UI_Div (Left : Uint; Right : Uint) return Uint;\n-   function UI_Div (Left : Int;  Right : Uint) return Uint;\n-   function UI_Div (Left : Uint; Right : Int)  return Uint;\n+   function UI_Div (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint;\n+   function UI_Div (Left : Int;  Right : Nonzero_Uint) return Valid_Uint;\n+   function UI_Div (Left : Valid_Uint; Right : Nonzero_Int)  return Valid_Uint;\n    --  Returns quotient of two integer values. Fatal error if Right = 0\n \n-   function UI_Eq (Left : Uint; Right : Uint) return Boolean;\n-   function UI_Eq (Left : Int;  Right : Uint) return Boolean;\n-   function UI_Eq (Left : Uint; Right : Int)  return Boolean;\n+   function UI_Eq (Left : Valid_Uint; Right : Valid_Uint) return Boolean;\n+   function UI_Eq (Left : Int;  Right : Valid_Uint) return Boolean;\n+   function UI_Eq (Left : Valid_Uint; Right : Int)  return Boolean;\n    pragma Inline (UI_Eq);\n    --  Compares integer values for equality\n \n-   function UI_Expon (Left : Uint; Right : Uint) return Uint;\n-   function UI_Expon (Left : Int;  Right : Uint) return Uint;\n-   function UI_Expon (Left : Uint; Right : Int)  return Uint;\n-   function UI_Expon (Left : Int;  Right : Int)  return Uint;\n+   function UI_Expon (Left : Valid_Uint; Right : Unat) return Valid_Uint;\n+   function UI_Expon (Left : Int;  Right : Unat) return Valid_Uint;\n+   function UI_Expon (Left : Valid_Uint; Right : Nat)  return Valid_Uint;\n+   function UI_Expon (Left : Int;  Right : Nat)  return Valid_Uint;\n    --  Returns result of exponentiating two integer values.\n    --  Fatal error if Right is negative.\n \n-   function UI_GCD (Uin, Vin : Uint) return Uint;\n+   function UI_GCD (Uin, Vin : Valid_Uint) return Valid_Uint;\n    --  Computes GCD of input values. Assumes Uin >= Vin >= 0\n \n-   function UI_Ge (Left : Uint; Right : Uint) return Boolean;\n-   function UI_Ge (Left : Int;  Right : Uint) return Boolean;\n-   function UI_Ge (Left : Uint; Right : Int)  return Boolean;\n+   function UI_Ge (Left : Valid_Uint; Right : Valid_Uint) return Boolean;\n+   function UI_Ge (Left : Int;  Right : Valid_Uint) return Boolean;\n+   function UI_Ge (Left : Valid_Uint; Right : Int)  return Boolean;\n    pragma Inline (UI_Ge);\n    --  Compares integer values for greater than or equal\n \n-   function UI_Gt (Left : Uint; Right : Uint) return Boolean;\n-   function UI_Gt (Left : Int;  Right : Uint) return Boolean;\n-   function UI_Gt (Left : Uint; Right : Int)  return Boolean;\n+   function UI_Gt (Left : Valid_Uint; Right : Valid_Uint) return Boolean;\n+   function UI_Gt (Left : Int;  Right : Valid_Uint) return Boolean;\n+   function UI_Gt (Left : Valid_Uint; Right : Int)  return Boolean;\n    pragma Inline (UI_Gt);\n    --  Compares integer values for greater than\n \n    function UI_Is_In_Int_Range (Input : Uint) return Boolean;\n    pragma Inline (UI_Is_In_Int_Range);\n-   --  Determines if universal integer is in Int range\n+   --  Determines if universal integer is in Int range.\n+   --  Input should probably be of type Valid_Uint.\n \n-   function UI_Le (Left : Uint; Right : Uint) return Boolean;\n-   function UI_Le (Left : Int;  Right : Uint) return Boolean;\n-   function UI_Le (Left : Uint; Right : Int)  return Boolean;\n+   function UI_Le (Left : Valid_Uint; Right : Valid_Uint) return Boolean;\n+   function UI_Le (Left : Int;  Right : Valid_Uint) return Boolean;\n+   function UI_Le (Left : Valid_Uint; Right : Int)  return Boolean;\n    pragma Inline (UI_Le);\n    --  Compares integer values for less than or equal\n \n-   function UI_Lt (Left : Uint; Right : Uint) return Boolean;\n-   function UI_Lt (Left : Int;  Right : Uint) return Boolean;\n-   function UI_Lt (Left : Uint; Right : Int)  return Boolean;\n+   function UI_Lt (Left : Valid_Uint; Right : Valid_Uint) return Boolean;\n+   function UI_Lt (Left : Int;  Right : Valid_Uint) return Boolean;\n+   function UI_Lt (Left : Valid_Uint; Right : Int)  return Boolean;\n    --  Compares integer values for less than\n \n-   function UI_Max (Left : Uint; Right : Uint) return Uint;\n-   function UI_Max (Left : Int;  Right : Uint) return Uint;\n-   function UI_Max (Left : Uint; Right : Int)  return Uint;\n+   function UI_Max (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint;\n+   function UI_Max (Left : Int;  Right : Valid_Uint) return Valid_Uint;\n+   function UI_Max (Left : Valid_Uint; Right : Int)  return Valid_Uint;\n    --  Returns maximum of two integer values\n \n-   function UI_Min (Left : Uint; Right : Uint) return Uint;\n-   function UI_Min (Left : Int;  Right : Uint) return Uint;\n-   function UI_Min (Left : Uint; Right : Int)  return Uint;\n+   function UI_Min (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint;\n+   function UI_Min (Left : Int;  Right : Valid_Uint) return Valid_Uint;\n+   function UI_Min (Left : Valid_Uint; Right : Int)  return Valid_Uint;\n    --  Returns minimum of two integer values\n \n-   function UI_Mod (Left : Uint; Right : Uint) return Uint;\n-   function UI_Mod (Left : Int;  Right : Uint) return Uint;\n-   function UI_Mod (Left : Uint; Right : Int)  return Uint;\n+   function UI_Mod (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint;\n+   function UI_Mod (Left : Int;  Right : Nonzero_Uint) return Valid_Uint;\n+   function UI_Mod (Left : Valid_Uint; Right : Nonzero_Int)  return Valid_Uint;\n    pragma Inline (UI_Mod);\n    --  Returns mod function of two integer values\n \n-   function UI_Mul (Left : Uint; Right : Uint) return Uint;\n-   function UI_Mul (Left : Int;  Right : Uint) return Uint;\n-   function UI_Mul (Left : Uint; Right : Int)  return Uint;\n+   function UI_Mul (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint;\n+   function UI_Mul (Left : Int;  Right : Valid_Uint) return Valid_Uint;\n+   function UI_Mul (Left : Valid_Uint; Right : Int)  return Valid_Uint;\n    --  Returns product of two integer values\n \n-   function UI_Ne (Left : Uint; Right : Uint) return Boolean;\n-   function UI_Ne (Left : Int;  Right : Uint) return Boolean;\n-   function UI_Ne (Left : Uint; Right : Int)  return Boolean;\n+   function UI_Ne (Left : Valid_Uint; Right : Valid_Uint) return Boolean;\n+   function UI_Ne (Left : Int;  Right : Valid_Uint) return Boolean;\n+   function UI_Ne (Left : Valid_Uint; Right : Int)  return Boolean;\n    pragma Inline (UI_Ne);\n    --  Compares integer values for inequality\n \n-   function UI_Negate (Right : Uint) return Uint;\n+   function UI_Negate (Right : Valid_Uint) return Valid_Uint;\n    pragma Inline (UI_Negate);\n    --  Returns negative of universal integer\n \n-   function UI_Rem (Left : Uint; Right : Uint) return Uint;\n-   function UI_Rem (Left : Int;  Right : Uint) return Uint;\n-   function UI_Rem (Left : Uint; Right : Int)  return Uint;\n+   function UI_Rem (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint;\n+   function UI_Rem (Left : Int;  Right : Nonzero_Uint) return Valid_Uint;\n+   function UI_Rem (Left : Valid_Uint; Right : Nonzero_Int)  return Valid_Uint;\n    --  Returns rem of two integer values\n \n-   function UI_Sub (Left : Uint; Right : Uint) return Uint;\n-   function UI_Sub (Left : Int;  Right : Uint) return Uint;\n-   function UI_Sub (Left : Uint; Right : Int)  return Uint;\n+   function UI_Sub (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint;\n+   function UI_Sub (Left : Int;  Right : Valid_Uint) return Valid_Uint;\n+   function UI_Sub (Left : Valid_Uint; Right : Int)  return Valid_Uint;\n    pragma Inline (UI_Sub);\n    --  Returns difference of two integer values\n \n-   function UI_Modular_Exponentiation\n-     (B      : Uint;\n-      E      : Uint;\n-      Modulo : Uint) return Uint;\n-   --  Efficiently compute (B**E) rem Modulo\n-\n-   function UI_Modular_Inverse (N : Uint; Modulo : Uint) return Uint;\n-   --  Compute the multiplicative inverse of N in modular arithmetics with the\n-   --  given Modulo (uses Euclid's algorithm). Note: the call is considered\n-   --  to be erroneous (and the behavior is undefined) if n is not invertible.\n-\n-   function UI_From_Int (Input : Int) return Uint;\n+   function UI_From_Int (Input : Int) return Valid_Uint;\n    --  Converts Int value to universal integer form\n \n    generic\n       type In_T is range <>;\n-   function UI_From_Integral (Input : In_T) return Uint;\n+   function UI_From_Integral (Input : In_T) return Valid_Uint;\n    --  Likewise, but converts from any integer type. Must not be applied to\n    --  biased types (instantiation will provide a warning if actual is a biased\n    --  type).\n \n-   function UI_From_CC (Input : Char_Code) return Uint;\n+   function UI_From_CC (Input : Char_Code) return Valid_Uint;\n    --  Converts Char_Code value to universal integer form\n \n    function UI_To_Int (Input : Valid_Uint) return Int;\n@@ -253,11 +249,11 @@ package Uintp is\n    --  Converts universal integer value to Unsigned_64. Constraint_Error if\n    --  value is not in appropriate range.\n \n-   function UI_To_CC (Input : Uint) return Char_Code;\n+   function UI_To_CC (Input : Valid_Uint) return Char_Code;\n    --  Converts universal integer value to Char_Code. Constraint_Error if value\n    --  is not in Char_Code range.\n \n-   function Num_Bits (Input : Uint) return Nat;\n+   function Num_Bits (Input : Valid_Uint) return Nat;\n    --  Approximate number of binary bits in given universal integer. This\n    --  function is used for capacity checks, and it can be one bit off\n    --  without affecting its usage.\n@@ -313,58 +309,97 @@ package Uintp is\n    -- Operator Renamings --\n    ------------------------\n \n-   function \"+\" (Left : Uint; Right : Uint) return Uint renames UI_Add;\n-   function \"+\" (Left : Int;  Right : Uint) return Uint renames UI_Add;\n-   function \"+\" (Left : Uint; Right : Int)  return Uint renames UI_Add;\n-\n-   function \"/\" (Left : Uint; Right : Uint) return Uint renames UI_Div;\n-   function \"/\" (Left : Int;  Right : Uint) return Uint renames UI_Div;\n-   function \"/\" (Left : Uint; Right : Int)  return Uint renames UI_Div;\n-\n-   function \"*\" (Left : Uint; Right : Uint) return Uint renames UI_Mul;\n-   function \"*\" (Left : Int;  Right : Uint) return Uint renames UI_Mul;\n-   function \"*\" (Left : Uint; Right : Int)  return Uint renames UI_Mul;\n-\n-   function \"-\" (Left : Uint; Right : Uint) return Uint renames UI_Sub;\n-   function \"-\" (Left : Int;  Right : Uint) return Uint renames UI_Sub;\n-   function \"-\" (Left : Uint; Right : Int)  return Uint renames UI_Sub;\n-\n-   function \"**\"  (Left : Uint; Right : Uint) return Uint renames UI_Expon;\n-   function \"**\"  (Left : Uint; Right : Int)  return Uint renames UI_Expon;\n-   function \"**\"  (Left : Int;  Right : Uint) return Uint renames UI_Expon;\n-   function \"**\"  (Left : Int;  Right : Int)  return Uint renames UI_Expon;\n-\n-   function \"abs\" (Real : Uint) return Uint renames UI_Abs;\n-\n-   function \"mod\" (Left : Uint; Right : Uint) return Uint renames UI_Mod;\n-   function \"mod\" (Left : Int;  Right : Uint) return Uint renames UI_Mod;\n-   function \"mod\" (Left : Uint; Right : Int)  return Uint renames UI_Mod;\n-\n-   function \"rem\" (Left : Uint; Right : Uint) return Uint renames UI_Rem;\n-   function \"rem\" (Left : Int;  Right : Uint) return Uint renames UI_Rem;\n-   function \"rem\" (Left : Uint; Right : Int)  return Uint renames UI_Rem;\n-\n-   function \"-\"   (Real : Uint) return Uint renames UI_Negate;\n-\n-   function \"=\"   (Left : Uint; Right : Uint) return Boolean renames UI_Eq;\n-   function \"=\"   (Left : Int;  Right : Uint) return Boolean renames UI_Eq;\n-   function \"=\"   (Left : Uint; Right : Int)  return Boolean renames UI_Eq;\n-\n-   function \">=\"  (Left : Uint; Right : Uint) return Boolean renames UI_Ge;\n-   function \">=\"  (Left : Int;  Right : Uint) return Boolean renames UI_Ge;\n-   function \">=\"  (Left : Uint; Right : Int)  return Boolean renames UI_Ge;\n-\n-   function \">\"   (Left : Uint; Right : Uint) return Boolean renames UI_Gt;\n-   function \">\"   (Left : Int;  Right : Uint) return Boolean renames UI_Gt;\n-   function \">\"   (Left : Uint; Right : Int)  return Boolean renames UI_Gt;\n-\n-   function \"<=\"  (Left : Uint; Right : Uint) return Boolean renames UI_Le;\n-   function \"<=\"  (Left : Int;  Right : Uint) return Boolean renames UI_Le;\n-   function \"<=\"  (Left : Uint; Right : Int)  return Boolean renames UI_Le;\n-\n-   function \"<\"   (Left : Uint; Right : Uint) return Boolean renames UI_Lt;\n-   function \"<\"   (Left : Int;  Right : Uint) return Boolean renames UI_Lt;\n-   function \"<\"   (Left : Uint; Right : Int)  return Boolean renames UI_Lt;\n+   function \"+\" (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint\n+     renames UI_Add;\n+   function \"+\" (Left : Int;  Right : Valid_Uint) return Valid_Uint\n+     renames UI_Add;\n+   function \"+\" (Left : Valid_Uint; Right : Int)  return Valid_Uint\n+     renames UI_Add;\n+\n+   function \"/\" (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint\n+     renames UI_Div;\n+   function \"/\" (Left : Int;  Right : Nonzero_Uint) return Valid_Uint\n+     renames UI_Div;\n+   function \"/\" (Left : Valid_Uint; Right : Nonzero_Int)  return Valid_Uint\n+     renames UI_Div;\n+\n+   function \"*\" (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint\n+     renames UI_Mul;\n+   function \"*\" (Left : Int;  Right : Valid_Uint) return Valid_Uint\n+     renames UI_Mul;\n+   function \"*\" (Left : Valid_Uint; Right : Int)  return Valid_Uint\n+     renames UI_Mul;\n+\n+   function \"-\" (Left : Valid_Uint; Right : Valid_Uint) return Valid_Uint\n+     renames UI_Sub;\n+   function \"-\" (Left : Int;  Right : Valid_Uint) return Valid_Uint\n+     renames UI_Sub;\n+   function \"-\" (Left : Valid_Uint; Right : Int)  return Valid_Uint\n+     renames UI_Sub;\n+\n+   function \"**\"  (Left : Valid_Uint; Right : Unat) return Valid_Uint\n+     renames UI_Expon;\n+   function \"**\"  (Left : Valid_Uint; Right : Nat)  return Valid_Uint\n+     renames UI_Expon;\n+   function \"**\"  (Left : Int;  Right : Unat) return Valid_Uint\n+     renames UI_Expon;\n+   function \"**\"  (Left : Int;  Right : Nat)  return Valid_Uint\n+     renames UI_Expon;\n+\n+   function \"abs\" (Real : Valid_Uint) return Unat\n+     renames UI_Abs;\n+\n+   function \"mod\" (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint\n+     renames UI_Mod;\n+   function \"mod\" (Left : Int;  Right : Nonzero_Uint) return Valid_Uint\n+     renames UI_Mod;\n+   function \"mod\" (Left : Valid_Uint; Right : Nonzero_Int)  return Valid_Uint\n+     renames UI_Mod;\n+\n+   function \"rem\" (Left : Valid_Uint; Right : Nonzero_Uint) return Valid_Uint\n+     renames UI_Rem;\n+   function \"rem\" (Left : Int;  Right : Nonzero_Uint) return Valid_Uint\n+     renames UI_Rem;\n+   function \"rem\" (Left : Valid_Uint; Right : Nonzero_Int)  return Valid_Uint\n+     renames UI_Rem;\n+\n+   function \"-\"   (Real : Valid_Uint) return Valid_Uint\n+     renames UI_Negate;\n+\n+   function \"=\"   (Left : Valid_Uint; Right : Valid_Uint) return Boolean\n+     renames UI_Eq;\n+   function \"=\"   (Left : Int;  Right : Valid_Uint) return Boolean\n+     renames UI_Eq;\n+   function \"=\"   (Left : Valid_Uint; Right : Int)  return Boolean\n+     renames UI_Eq;\n+\n+   function \">=\"  (Left : Valid_Uint; Right : Valid_Uint) return Boolean\n+     renames UI_Ge;\n+   function \">=\"  (Left : Int;  Right : Valid_Uint) return Boolean\n+     renames UI_Ge;\n+   function \">=\"  (Left : Valid_Uint; Right : Int)  return Boolean\n+     renames UI_Ge;\n+\n+   function \">\"   (Left : Valid_Uint; Right : Valid_Uint) return Boolean\n+     renames UI_Gt;\n+   function \">\"   (Left : Int;  Right : Valid_Uint) return Boolean\n+     renames UI_Gt;\n+   function \">\"   (Left : Valid_Uint; Right : Int)  return Boolean\n+     renames UI_Gt;\n+\n+   function \"<=\"  (Left : Valid_Uint; Right : Valid_Uint) return Boolean\n+     renames UI_Le;\n+   function \"<=\"  (Left : Int;  Right : Valid_Uint) return Boolean\n+     renames UI_Le;\n+   function \"<=\"  (Left : Valid_Uint; Right : Int)  return Boolean\n+     renames UI_Le;\n+\n+   function \"<\"   (Left : Valid_Uint; Right : Valid_Uint) return Boolean\n+     renames UI_Lt;\n+   function \"<\"   (Left : Int;  Right : Valid_Uint) return Boolean\n+     renames UI_Lt;\n+   function \"<\"   (Left : Valid_Uint; Right : Int)  return Boolean\n+     renames UI_Lt;\n \n    -----------------------------\n    -- Mark/Release Processing --\n@@ -384,12 +419,12 @@ package Uintp is\n    procedure Release (M : Save_Mark);\n    --  Release storage allocated since mark was noted\n \n-   procedure Release_And_Save (M : Save_Mark; UI : in out Uint);\n+   procedure Release_And_Save (M : Save_Mark; UI : in out Valid_Uint);\n    --  Like Release, except that the given Uint value (which is typically among\n    --  the data being released) is recopied after the release, so that it is\n    --  the most recent item, and UI is updated to point to its copied location.\n \n-   procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Uint);\n+   procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Valid_Uint);\n    --  Like Release, except that the given Uint values (which are typically\n    --  among the data being released) are recopied after the release, so that\n    --  they are the most recent items, and UI1 and UI2 are updated if necessary\n@@ -493,7 +528,7 @@ private\n    --  UI_Mul to efficiently compute the product in this case.\n \n    type Save_Mark is record\n-      Save_Uint   : Uint;\n+      Save_Uint   : Valid_Uint;\n       Save_Udigit : Int;\n    end record;\n "}]}