{"sha": "3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I5ZGQ3NjkyYmZkZGUzZmY4MTNmZTM1ZjBlMGI4MjIxMTMyYjBmOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-02T14:29:44Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-05-02T14:29:44Z"}, "message": "bfin.c (emit_link_insn, [...]): Use gcc_assert or gcc_unreachable as appropriate.\n\n\t* config/bfin/bfin.c (emit_link_insn, effective_address_32bit_p,\n\tprint_address_operand, print_operand, legitimize_pic_address,\n\tasm_conditional_branch, bfin_gen_compare, output_push_multiple,\n\toutput_pop_multiple): Use gcc_assert or gcc_unreachable as\n\tappropriate.\n\t* config/bfin/bfin.md (movsf splitter, beq, bne): Likewise.\n\nCo-Authored-By: Bernd Schmidt <bernd.schmidt@analog.com>\n\nFrom-SVN: r99096", "tree": {"sha": "f505041cb2ac1365eef4f7680035d491906335e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f505041cb2ac1365eef4f7680035d491906335e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/comments", "author": null, "committer": null, "parents": [{"sha": "1e872f31fbc1a24624417b33a2c9bcda1664fcb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e872f31fbc1a24624417b33a2c9bcda1664fcb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e872f31fbc1a24624417b33a2c9bcda1664fcb1"}], "stats": {"total": 116, "additions": 59, "deletions": 57}, "files": [{"sha": "8acf495c6b5aaa028b9d00cd9f6b634b56506ac1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "patch": "@@ -1,3 +1,13 @@\n+2005-05-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (emit_link_insn, effective_address_32bit_p,\n+\tprint_address_operand, print_operand, legitimize_pic_address,\n+\tasm_conditional_branch, bfin_gen_compare, output_push_multiple,\n+\toutput_pop_multiple): Use gcc_assert or gcc_unreachable as\n+\tappropriate.\n+\t* config/bfin/bfin.md (movsf splitter, beq, bne): Likewise.\n+\n 2005-05-02  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* doc/passes.texi: Document vectorization pass."}, {"sha": "a9b59f2bbda3b245b2f4cb3771551f114a32c0cf", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "patch": "@@ -518,8 +518,7 @@ emit_link_insn (rtx spreg, HOST_WIDE_INT frame_size)\n   for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n     {\n       rtx set = XVECEXP (PATTERN (insn), 0, i);\n-      if (GET_CODE (set) != SET)\n-\tabort ();\n+      gcc_assert (GET_CODE (set) == SET);\n       RTX_FRAME_RELATED_P (set) = 1;\n     }\n \n@@ -879,11 +878,12 @@ effective_address_32bit_p (rtx op, enum machine_mode mode)\n   mode = GET_MODE (op);\n   op = XEXP (op, 0);\n \n-  if (REG_P (op) || GET_CODE (op) == POST_INC\n-      || GET_CODE (op) == PRE_DEC || GET_CODE (op) == POST_DEC)\n-    return 0;\n   if (GET_CODE (op) != PLUS)\n-    abort ();\n+    {\n+      gcc_assert (REG_P (op) || GET_CODE (op) == POST_INC\n+\t\t  || GET_CODE (op) == PRE_DEC || GET_CODE (op) == POST_DEC);\n+      return 0;\n+    }\n \n   offset = INTVAL (XEXP (op, 1));\n \n@@ -918,9 +918,6 @@ bfin_address_cost (rtx addr ATTRIBUTE_UNUSED)\n void\n print_address_operand (FILE *file, rtx x)\n {\n-  if (GET_CODE (x) == MEM) \n-    abort ();\n-\n   switch (GET_CODE (x))\n     {\n     case PLUS:\n@@ -943,7 +940,9 @@ print_address_operand (FILE *file, rtx x)\n       break;\n \n     default:\n+      gcc_assert (GET_CODE (x) != MEM);\n       print_operand (file, x, 0);\n+      break;\n     }\n }\n \n@@ -1074,8 +1073,7 @@ print_operand (FILE *file, rtx x, char code)\n \t    }\n \t  else if (code == 'T')\n \t    {\n-\t      if (REGNO (x) > 7)\n-\t\tabort ();\n+\t      gcc_assert (D_REGNO_P (REGNO (x)));\n \t      fprintf (file, \"%s\", byte_reg_names[REGNO (x)]);\n \t    }\n \t  else \n@@ -1117,15 +1115,20 @@ print_operand (FILE *file, rtx x, char code)\n \t  break;\n \n \tcase UNSPEC:\n-\t  if (XINT (x, 1) == UNSPEC_MOVE_PIC)\n+\t  switch (XINT (x, 1))\n \t    {\n+\t    case UNSPEC_MOVE_PIC:\n \t      output_addr_const (file, XVECEXP (x, 0, 0));\n \t      fprintf (file, \"@GOT\");\n+\t      break;\n+\n+\t    case UNSPEC_LIBRARY_OFFSET:\n+\t      fprintf (file, \"_current_shared_library_p5_offset_\");\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\t  else if (XINT (x, 1) == UNSPEC_LIBRARY_OFFSET)\n-\t    fprintf (file, \"_current_shared_library_p5_offset_\");\n-\t  else\n-\t    abort ();\n \t  break;\n \n \tdefault:\n@@ -1389,8 +1392,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t{\n \t  if (reg == 0)\n \t    {\n-\t      if (no_new_pseudos)\n-\t\tabort ();\n+\t      gcc_assert (!no_new_pseudos);\n \t      reg = gen_reg_rtx (Pmode);\n \t    }\n \n@@ -1422,17 +1424,15 @@ legitimize_pic_address (rtx orig, rtx reg)\n       if (GET_CODE (addr) == CONST)\n \t{\n \t  addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) != PLUS)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (addr) == PLUS);\n \t}\n \n       if (XEXP (addr, 0) == pic_offset_table_rtx)\n \treturn orig;\n \n       if (reg == 0)\n \t{\n-\t  if (no_new_pseudos)\n-\t    abort ();\n+\t  gcc_assert (!no_new_pseudos);\n \t  reg = gen_reg_rtx (Pmode);\n \t}\n \n@@ -1442,11 +1442,8 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n       if (GET_CODE (addr) == CONST_INT)\n \t{\n-\t  if (! reload_in_progress && ! reload_completed)\n-\t    addr = force_reg (Pmode, addr);\n-\t  else\n-\t    /* If we reach here, then something is seriously wrong.  */\n-\t    abort ();\n+\t  gcc_assert (! reload_in_progress && ! reload_completed);\n+\t  addr = force_reg (Pmode, addr);\n \t}\n \n       if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n@@ -1824,8 +1821,7 @@ asm_conditional_branch (rtx insn, rtx *operands, int n_nops, int predict_taken)\n   int bp = predict_taken && len == 0 ? 1 : cbranch_predicted_taken_p (insn);\n   int idx = (bp << 1) | (GET_CODE (operands[0]) == EQ ? BRF : BRT);\n   output_asm_insn (ccbranch_templates[idx][len], operands);\n-  if (n_nops > 0 && bp)\n-    abort ();\n+  gcc_assert (n_nops == 0 || !bp);\n   if (len == 0)\n     while (n_nops-- > 0)\n       output_asm_insn (\"nop;\", NULL);\n@@ -1846,10 +1842,8 @@ bfin_gen_compare (rtx cmp, enum machine_mode mode ATTRIBUTE_UNUSED)\n      do not need to emit another comparison.  */\n   if (GET_MODE (op0) == BImode)\n     {\n-      if ((code == NE || code == EQ) && op1 == const0_rtx)\n-\ttem = op0, code2 = code;\n-      else\n-\tabort ();\n+      gcc_assert ((code == NE || code == EQ) && op1 == const0_rtx);\n+      tem = op0, code2 = code;\n     }\n   else\n     {\n@@ -2283,15 +2277,19 @@ void\n output_push_multiple (rtx insn, rtx *operands)\n {\n   char buf[80];\n+  int ok;\n+  \n   /* Validate the insn again, and compute first_[dp]reg_to_save. */\n-  if (! push_multiple_operation (PATTERN (insn), VOIDmode))\n-    abort ();\n+  ok = push_multiple_operation (PATTERN (insn), VOIDmode);\n+  gcc_assert (ok);\n+  \n   if (first_dreg_to_save == 8)\n     sprintf (buf, \"[--sp] = ( p5:%d );\\n\", first_preg_to_save);\n   else if (first_preg_to_save == 6)\n     sprintf (buf, \"[--sp] = ( r7:%d );\\n\", first_dreg_to_save);\n   else\n-    sprintf (buf, \"[--sp] = ( r7:%d, p5:%d );\\n\", first_dreg_to_save, first_preg_to_save);\n+    sprintf (buf, \"[--sp] = ( r7:%d, p5:%d );\\n\",\n+\t     first_dreg_to_save, first_preg_to_save);\n \n   output_asm_insn (buf, operands);\n }\n@@ -2303,16 +2301,19 @@ void\n output_pop_multiple (rtx insn, rtx *operands)\n {\n   char buf[80];\n+  int ok;\n+  \n   /* Validate the insn again, and compute first_[dp]reg_to_save. */\n-  if (! pop_multiple_operation (PATTERN (insn), VOIDmode))\n-    abort ();\n+  ok = pop_multiple_operation (PATTERN (insn), VOIDmode);\n+  gcc_assert (ok);\n \n   if (first_dreg_to_save == 8)\n     sprintf (buf, \"( p5:%d ) = [sp++];\\n\", first_preg_to_save);\n   else if (first_preg_to_save == 6)\n     sprintf (buf, \"( r7:%d ) = [sp++];\\n\", first_dreg_to_save);\n   else\n-    sprintf (buf, \"( r7:%d, p5:%d ) = [sp++];\\n\", first_dreg_to_save, first_preg_to_save);\n+    sprintf (buf, \"( r7:%d, p5:%d ) = [sp++];\\n\",\n+\t     first_dreg_to_save, first_preg_to_save);\n \n   output_asm_insn (buf, operands);\n }"}, {"sha": "332787fda379cbb255c370cfbd93fb98a4855531", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=3b9dd7692bfdde3ff813fe35f0e0b8221132b0f8", "patch": "@@ -550,8 +550,7 @@\n   long values;\n   REAL_VALUE_TYPE value;\n \n-  if (GET_CODE (operands[1]) != CONST_DOUBLE)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == CONST_DOUBLE);\n \n   REAL_VALUE_FROM_CONST_DOUBLE (value, operands[1]);\n   REAL_VALUE_TO_TARGET_SINGLE (value, values);\n@@ -1432,14 +1431,9 @@\n      do not need to emit another comparison.  */\n   if (GET_MODE (bfin_compare_op0) == BImode)\n     {\n-      if (bfin_compare_op1 == const0_rtx)\n-\t{\n-\t  emit_insn (gen_cbranchbi4 (operands[2], op0, op1,\n-\t\t\t\t     operands[0]));\n-\t  DONE;\n-\t}\n-      else\n-\tabort ();\n+      gcc_assert (bfin_compare_op1 == const0_rtx);\n+      emit_insn (gen_cbranchbi4 (operands[2], op0, op1, operands[0]));\n+      DONE;\n     }\n \n   operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n@@ -1458,14 +1452,11 @@\n      do not need to emit another comparison.  */\n   if (GET_MODE (bfin_compare_op0) == BImode)\n     {\n-      if (bfin_compare_op1 == const0_rtx)\n-\t{\n-\t  rtx cmp = gen_rtx_NE (BImode, op0, op1);\n-\t  emit_insn (gen_cbranchbi4 (cmp, op0, op1, operands[0]));\n-\t  DONE;\n-\t}\n-      else\n-\tabort ();\n+      rtx cmp = gen_rtx_NE (BImode, op0, op1);\n+\n+      gcc_assert (bfin_compare_op1 == const0_rtx);\n+      emit_insn (gen_cbranchbi4 (cmp, op0, op1, operands[0]));\n+      DONE;\n     }\n \n   operands[1] = bfin_cc_rtx;\t/* hard register: CC */"}]}