{"sha": "546a65d9a8ac46ba01bfec34d964732481fa3949", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2YTY1ZDlhOGFjNDZiYTAxYmZlYzM0ZDk2NDczMjQ4MWZhMzk0OQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-06-05T17:51:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-06-05T17:51:39Z"}, "message": "re PR fortran/43895 ([OOP] internal compiler error: verify_ssa failed)\n\n2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43895\n\t* trans-array.c (structure_alloc_comps): Dereference scalar\n\t'decl' if it is a REFERENCE_TYPE. Tidy expressions containing\n\tTREE_TYPE (decl).\n\n2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43895\n\t* gfortran.dg/alloc_comp_class_1.f90 : New test.\n\nFrom-SVN: r160326", "tree": {"sha": "cc3a75a2f0419f8afc36c12f32c8a69560e46d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc3a75a2f0419f8afc36c12f32c8a69560e46d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546a65d9a8ac46ba01bfec34d964732481fa3949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546a65d9a8ac46ba01bfec34d964732481fa3949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546a65d9a8ac46ba01bfec34d964732481fa3949", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546a65d9a8ac46ba01bfec34d964732481fa3949/comments", "author": null, "committer": null, "parents": [{"sha": "7ae3cd3dfad1b2d747f002d59fd35002a8083709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ae3cd3dfad1b2d747f002d59fd35002a8083709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ae3cd3dfad1b2d747f002d59fd35002a8083709"}], "stats": {"total": 65, "additions": 59, "deletions": 6}, "files": [{"sha": "d9ab021cd87ca021f589ae2a4af50d11a59b3a19", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=546a65d9a8ac46ba01bfec34d964732481fa3949", "patch": "@@ -1,3 +1,10 @@\n+2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43895\n+\t* trans-array.c (structure_alloc_comps): Dereference scalar\n+\t'decl' if it is a REFERENCE_TYPE. Tidy expressions containing\n+\tTREE_TYPE (decl).\n+\n 2010-06-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gfortranspec.c (append_arg, lang_specific_driver): Use"}, {"sha": "575dd0258a1153325cfe1ee571a121eabf61b9c0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=546a65d9a8ac46ba01bfec34d964732481fa3949", "patch": "@@ -5938,6 +5938,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   gfc_loopinfo loop;\n   stmtblock_t fnblock;\n   stmtblock_t loopbody;\n+  tree decl_type;\n   tree tmp;\n   tree comp;\n   tree dcmp;\n@@ -5951,21 +5952,28 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n   gfc_init_block (&fnblock);\n \n-  if (POINTER_TYPE_P (TREE_TYPE (decl)) && rank != 0)\n+  decl_type = TREE_TYPE (decl);\n+\n+  if ((POINTER_TYPE_P (decl_type) && rank != 0)\n+\t|| (TREE_CODE (decl_type) == REFERENCE_TYPE && rank == 0))\n+\n     decl = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t    decl);\n \n+  /* Just in case in gets dereferenced.  */\n+  decl_type = TREE_TYPE (decl);\n+\n   /* If this an array of derived types with allocatable components\n      build a loop and recursively call this function.  */\n-  if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t|| GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+  if (TREE_CODE (decl_type) == ARRAY_TYPE\n+\t|| GFC_DESCRIPTOR_TYPE_P (decl_type))\n     {\n       tmp = gfc_conv_array_data (decl);\n       var = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     tmp);\n \t\n       /* Get the number of elements - 1 and set the counter.  */\n-      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+      if (GFC_DESCRIPTOR_TYPE_P (decl_type))\n \t{\n \t  /* Use the descriptor for an allocatable array.  Since this\n \t     is a full array reference, we only need the descriptor\n@@ -5981,7 +5989,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       else\n \t{\n \t  /*  Otherwise use the TYPE_DOMAIN information.  */\n-\t  tmp =  array_type_nelts (TREE_TYPE (decl));\n+\t  tmp =  array_type_nelts (decl_type);\n \t  tmp = fold_convert (gfc_array_index_type, tmp);\n \t}\n \n@@ -5998,7 +6006,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n         {\n \t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))\n \t    {\n-\t      tmp = gfc_duplicate_allocatable (dest, decl, TREE_TYPE(decl), rank);\n+\t      tmp = gfc_duplicate_allocatable (dest, decl, decl_type, rank);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  tmp = build_fold_indirect_ref_loc (input_location,"}, {"sha": "37caab695fc67163f84b65b5521dba9f3a846306", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=546a65d9a8ac46ba01bfec34d964732481fa3949", "patch": "@@ -1,3 +1,8 @@\n+2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43895\n+\t* gfortran.dg/alloc_comp_class_1.f90 : New test.\n+\n 2010-06-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/44361"}, {"sha": "c783f49ff77f097c4dc063289b7ccbc595731110", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_class_1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546a65d9a8ac46ba01bfec34d964732481fa3949/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_1.f90?ref=546a65d9a8ac46ba01bfec34d964732481fa3949", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! Test the fix for PR43895, in which the dummy 'a' was not\n+! dereferenced for the deallocation of component 'a', as required\n+! for INTENT(OUT).\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module d_mat_mod\n+  type  :: base_sparse_mat\n+  end type base_sparse_mat\n+\n+  type, extends(base_sparse_mat) :: d_base_sparse_mat\n+    integer :: i\n+  end type d_base_sparse_mat\n+\n+  type :: d_sparse_mat\n+    class(d_base_sparse_mat), allocatable  :: a \n+  end type d_sparse_mat\n+end module d_mat_mod\n+\n+  use d_mat_mod\n+  type(d_sparse_mat) :: b\n+  allocate (b%a)\n+  b%a%i = 42\n+  call bug14 (b)\n+  if (allocated (b%a)) call abort\n+contains\n+  subroutine bug14(a)\n+    implicit none\n+    type(d_sparse_mat), intent(out) :: a\n+  end subroutine bug14\n+end\n+! { dg-final { cleanup-modules \"d_mat_mod \" } }"}]}