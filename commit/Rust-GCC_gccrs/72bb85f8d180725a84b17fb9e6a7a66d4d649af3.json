{"sha": "72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiYjg1ZjhkMTgwNzI1YTg0YjE3ZmI5ZTZhN2E2NmQ0ZDY0OWFmMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-08-27T07:39:34Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-08-27T07:39:34Z"}, "message": "Fix new clang warnings.\n\n2019-08-27  Martin Liska  <mliska@suse.cz>\n\n\t* cgraph.c (cgraph_node::remove): Remove dead assignment before\n\tloop.\n\t* config/i386/i386-features.c (scalar_chain::emit_conversion_insns):\n\tEnclose in anonymous namespace.\n\t* config/i386/x86-tune-costs.h (struct processor_costs): Wrap\n\thard_register initialization in braces.\n\t* tree-vrp.h (value_range_base::supports_type_p): Return false\n\tfor function with boolean return type.\n\nFrom-SVN: r274945", "tree": {"sha": "2a94159ac2554208c571527b83c23fae1d51559a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a94159ac2554208c571527b83c23fae1d51559a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e80f40684f4f214923da3a4aea7b31063649635e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80f40684f4f214923da3a4aea7b31063649635e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80f40684f4f214923da3a4aea7b31063649635e"}], "stats": {"total": 67, "additions": 65, "deletions": 2}, "files": [{"sha": "856ce684b79d9821e6d19ded40e386586b56fd45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "patch": "@@ -1,3 +1,14 @@\n+2019-08-27  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (cgraph_node::remove): Remove dead assignment before\n+\tloop.\n+\t* config/i386/i386-features.c (scalar_chain::emit_conversion_insns):\n+\tEnclose in anonymous namespace.\n+\t* config/i386/x86-tune-costs.h (struct processor_costs): Wrap\n+\thard_register initialization in braces.\n+\t* tree-vrp.h (value_range_base::supports_type_p): Return false\n+\tfor function with boolean return type.\n+\n 2019-08-26  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (emit_i387_cw_initialization)"}, {"sha": "843891e9e566d74c35b0bb7b91c31f2ebe534913", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "patch": "@@ -1783,7 +1783,7 @@ cgraph_node::remove (void)\n      */\n   force_output = false;\n   forced_by_abi = false;\n-  cgraph_node *next = nested;\n+  cgraph_node *next;\n   for (cgraph_node *n = nested; n; n = next)\n   {\n     next = n->next_nested;"}, {"sha": "589158475021bafd1b01f9b875cf495796942179", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "patch": "@@ -274,6 +274,8 @@ xlogue_layout::get_stub_rtx (enum xlogue_stub stub)\n \n unsigned scalar_chain::max_id = 0;\n \n+namespace {\n+\n /* Initialize new chain.  */\n \n scalar_chain::scalar_chain (enum machine_mode smode_, enum machine_mode vmode_)\n@@ -622,6 +624,8 @@ scalar_chain::emit_conversion_insns (rtx insns, rtx_insn *after)\n   emit_insn_after (insns, BB_HEAD (new_bb));\n }\n \n+} // anon namespace\n+\n /* Generate the canonical SET_SRC to move GPR to a VMODE vector register,\n    zeroing the upper parts.  */\n "}, {"sha": "3381b8bf143c5175b5d3f22b9be272708725f766", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "patch": "@@ -36,6 +36,7 @@ static stringop_algs ix86_size_memset[2] = {\n \n const\n struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n@@ -59,6 +60,7 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_BYTES (2),\t\t\t/* cost of an add instruction */\n   COSTS_N_BYTES (3),\t\t\t/* cost of a lea instruction */\n@@ -138,6 +140,7 @@ static stringop_algs i386_memset[2] = {\n \n static const\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n@@ -161,6 +164,7 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -237,6 +241,7 @@ static stringop_algs i486_memset[2] = {\n \n static const\n struct processor_costs i486_cost = {\t/* 486 specific costs */\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n@@ -260,6 +265,7 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -338,6 +344,7 @@ static stringop_algs pentium_memset[2] = {\n \n static const\n struct processor_costs pentium_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n@@ -361,6 +368,7 @@ struct processor_costs pentium_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -430,6 +438,7 @@ struct processor_costs pentium_cost = {\n \n static const\n struct processor_costs lakemont_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n@@ -453,6 +462,7 @@ struct processor_costs lakemont_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n@@ -537,6 +547,7 @@ static stringop_algs pentiumpro_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs pentiumpro_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n@@ -560,6 +571,7 @@ struct processor_costs pentiumpro_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -635,6 +647,7 @@ static stringop_algs geode_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs geode_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n@@ -658,6 +671,7 @@ struct processor_costs geode_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -733,6 +747,7 @@ static stringop_algs k6_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs k6_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   3,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n@@ -756,6 +771,7 @@ struct processor_costs k6_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -837,6 +853,7 @@ static stringop_algs athlon_memset[2] = {\n   DUMMY_STRINGOP_ALGS};\n static const\n struct processor_costs athlon_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n@@ -860,6 +877,7 @@ struct processor_costs athlon_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -943,6 +961,7 @@ static stringop_algs k8_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs k8_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n@@ -966,6 +985,7 @@ struct processor_costs k8_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -1053,6 +1073,7 @@ static stringop_algs amdfam10_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n struct processor_costs amdfam10_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n@@ -1085,6 +1106,7 @@ struct processor_costs amdfam10_cost = {\n \t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n \t\t\t\t\t\t\t       1/1  1/1 */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -1173,6 +1195,7 @@ static stringop_algs bdver_memset[2] = {\n              {-1, libcall, false}}}};\n \n const struct processor_costs bdver_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   8,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n@@ -1196,6 +1219,7 @@ const struct processor_costs bdver_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -1285,6 +1309,7 @@ static stringop_algs znver1_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n \t     {-1, libcall, false}}}};\n struct processor_costs znver1_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n \n   /* reg-reg moves are done by renaming and thus they are even cheaper than\n@@ -1315,6 +1340,7 @@ struct processor_costs znver1_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n   6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves.  */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n@@ -1420,6 +1446,7 @@ static stringop_algs znver2_memset[2] = {\n \t     {-1, libcall, false}}}};\n \n struct processor_costs znver2_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n \n   /* reg-reg moves are done by renaming and thus they are even cheaper than\n@@ -1452,6 +1479,7 @@ struct processor_costs znver2_cost = {\n   6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE\n \t\t\t\t\t   moves.  */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n@@ -1560,6 +1588,7 @@ static stringop_algs skylake_memset[2] = {\n \n static const\n struct processor_costs skylake_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n@@ -1583,6 +1612,7 @@ struct processor_costs skylake_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1)+1,\t\t/* cost of a lea instruction */\n@@ -1665,6 +1695,7 @@ static stringop_algs btver1_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n const struct processor_costs btver1_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   8,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {6, 8, 6},\t\t\t\t/* cost of loading integer registers\n@@ -1688,6 +1719,7 @@ const struct processor_costs btver1_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -1766,6 +1798,7 @@ static stringop_algs btver2_memset[2] = {\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n const struct processor_costs btver2_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   8,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {8, 8, 6},\t\t\t\t/* cost of loading integer registers\n@@ -1789,6 +1822,7 @@ const struct processor_costs btver2_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n@@ -1866,6 +1900,7 @@ static stringop_algs pentium4_memset[2] = {\n \n static const\n struct processor_costs pentium4_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   5,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n@@ -1889,6 +1924,7 @@ struct processor_costs pentium4_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (3),\t\t\t/* cost of a lea instruction */\n@@ -1969,6 +2005,7 @@ static stringop_algs nocona_memset[2] = {\n \n static const\n struct processor_costs nocona_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n@@ -1992,6 +2029,7 @@ struct processor_costs nocona_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n@@ -2070,6 +2108,7 @@ static stringop_algs atom_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs atom_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n@@ -2093,6 +2132,7 @@ struct processor_costs atom_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n@@ -2171,6 +2211,7 @@ static stringop_algs slm_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs slm_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   8,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n@@ -2194,6 +2235,7 @@ struct processor_costs slm_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n@@ -2272,6 +2314,7 @@ static stringop_algs intel_memset[2] = {\n              {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}};\n static const\n struct processor_costs intel_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n@@ -2295,6 +2338,7 @@ struct processor_costs intel_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   4, 4,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n@@ -2377,6 +2421,7 @@ static stringop_algs generic_memset[2] = {\n              {-1, libcall, false}}}};\n static const\n struct processor_costs generic_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n@@ -2400,6 +2445,7 @@ struct processor_costs generic_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   /* Setting cost to 2 makes our current implementation of synth_mult result in\n@@ -2487,6 +2533,7 @@ static stringop_algs core_memset[2] = {\n \n static const\n struct processor_costs core_cost = {\n+  {\n   /* Start of register allocator costs.  integer->integer move cost is 2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n@@ -2510,6 +2557,7 @@ struct processor_costs core_cost = {\n \t\t\t\t\t   in 32,64,128,256 and 512-bit */\n   2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   /* End of register allocator costs.  */\n+  },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   /* On all chips taken into consideration lea is 2 cycles and more.  With"}, {"sha": "cf236fa6264ab5491619dea801b61884e703f9f4", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72bb85f8d180725a84b17fb9e6a7a66d4d649af3/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=72bb85f8d180725a84b17fb9e6a7a66d4d649af3", "patch": "@@ -265,7 +265,7 @@ value_range_base::supports_type_p (tree type)\n {\n   if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n     return type;\n-  return NULL;\n+  return false;\n }\n \n extern void register_edge_assert_for (tree, edge, enum tree_code,"}]}