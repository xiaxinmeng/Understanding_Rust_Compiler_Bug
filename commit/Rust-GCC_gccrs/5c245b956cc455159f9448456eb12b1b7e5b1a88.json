{"sha": "5c245b956cc455159f9448456eb12b1b7e5b1a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMyNDViOTU2Y2M0NTUxNTlmOTQ0ODQ1NmViMTJiMWI3ZTViMWE4OA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-27T15:52:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-27T15:52:44Z"}, "message": "tree-ssa-structalias.c (find_func_aliases): In IPA mode handle calls to externally visible functions like in regular mode.\n\n2009-10-27  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (find_func_aliases): In IPA mode\n\thandle calls to externally visible functions like in regular mode.\n\t(create_variable_info_for): Do not create function infos here.\n\t(have_alias_info): Remove write-only variable.\n\t(solve_constraints): New function split out from common code\n\tin compute_points_to_sets and ipa_pta_execute.\n\t(compute_points_to_sets): Adjust.\n\t(ipa_pta_execute): Likewise.  Handle clones and externally visible\n\tfunctions like in non-IPA mode.\n\n\t* gcc.dg/torture/ipa-pta-1.c: Adjust testcase.\n\nFrom-SVN: r153600", "tree": {"sha": "3729f0a69b1c096c71531c62d5e4692f6ba33de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3729f0a69b1c096c71531c62d5e4692f6ba33de8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c245b956cc455159f9448456eb12b1b7e5b1a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c245b956cc455159f9448456eb12b1b7e5b1a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c245b956cc455159f9448456eb12b1b7e5b1a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c245b956cc455159f9448456eb12b1b7e5b1a88/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "06302a02c05eeaeea9e8597dfc6ed3d0e0085357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06302a02c05eeaeea9e8597dfc6ed3d0e0085357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06302a02c05eeaeea9e8597dfc6ed3d0e0085357"}], "stats": {"total": 263, "additions": 141, "deletions": 122}, "files": [{"sha": "89051c8cfb47fe167fb5be1b884c51f06f720e61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c245b956cc455159f9448456eb12b1b7e5b1a88", "patch": "@@ -1,3 +1,15 @@\n+2009-10-27  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (find_func_aliases): In IPA mode\n+\thandle calls to externally visible functions like in regular mode.\n+\t(create_variable_info_for): Do not create function infos here.\n+\t(have_alias_info): Remove write-only variable.\n+\t(solve_constraints): New function split out from common code\n+\tin compute_points_to_sets and ipa_pta_execute.\n+\t(compute_points_to_sets): Adjust.\n+\t(ipa_pta_execute): Likewise.  Handle clones and externally visible\n+\tfunctions like in non-IPA mode.\n+\n 2009-10-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/41842"}, {"sha": "54abf12150c47c4f5e15812700fd298dbc19a795", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c245b956cc455159f9448456eb12b1b7e5b1a88", "patch": "@@ -1,3 +1,7 @@\n+2009-10-27  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/torture/ipa-pta-1.c: Adjust testcase.\n+\n 2009-10-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/41842"}, {"sha": "7df130a1f5b9dcd325747d4a53cbbda708a71b25", "filename": "gcc/testsuite/gcc.dg/torture/ipa-pta-1.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c?ref=5c245b956cc455159f9448456eb12b1b7e5b1a88", "patch": "@@ -4,37 +4,43 @@\n \n struct X { char x; char y; };\n \n-void bar (char *p);\n+char *q;\n \n-void test1 (char a, char b, char c, char d, char e, char f, char g, char h)\n+static void __attribute__((noinline))\n+bar (char *p)\n {\n-  char *p = &a;\n+  q = p;\n+}\n+\n+void test1 (char a1, char b, char c, char d, char e, char f, char g, char h)\n+{\n+  char *p = &a1;\n   p++;\n   bar (p);\n }\n \n-void test2 (struct X a, char b, char c, char d, char e, char f, char g, char h)\n+void test2 (struct X a2, char b, char c, char d, char e, char f, char g, char h)\n {\n-  char *p = &a.x;\n+  char *p = &a2.x;\n   p++;\n   bar (p);\n }\n \n-void test3 (struct X a, char b, char c, char d, char e, char f, char g, char h)\n+void test3 (struct X a3, char b, char c, char d, char e, char f, char g, char h)\n {\n-  char *p = &a.y;\n+  char *p = &a3.y;\n   bar (p);\n }\n \n-void test4 (int a, char b, char c, char d, char e, char f, char g, char h)\n+void test4 (int a4, char b, char c, char d, char e, char f, char g, char h)\n {\n-  char *p = (char *)&a;\n+  char *p = (char *)&a4;\n   p++;\n   p++;\n   p++;\n   p++;\n   bar (p);\n }\n \n-/* { dg-final { scan-ipa-dump \"bar.arg0 = { test4.arg0 test3.arg0 test2.arg0 test1.arg0 }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"bar.arg0 = { a4 a3 a2 a1 }\" \"pta\" } } */\n /* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "7b33936dfd7bb923af8cad4ad4e28ad1b3d782da", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 109, "deletions": 112, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c245b956cc455159f9448456eb12b1b7e5b1a88/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=5c245b956cc455159f9448456eb12b1b7e5b1a88", "patch": "@@ -3663,8 +3663,8 @@ find_func_aliases (gimple origt)\n      pointer passed by address.  */\n   else if (is_gimple_call (t))\n     {\n-      tree fndecl;\n-      if ((fndecl = gimple_call_fndecl (t)) != NULL_TREE\n+      tree fndecl = gimple_call_fndecl (t);\n+      if (fndecl != NULL_TREE\n \t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n \t/* ???  All builtins that are handled here need to be handled\n \t   in the alias-oracle query functions explicitly!  */\n@@ -3774,7 +3774,9 @@ find_func_aliases (gimple origt)\n \t  default:\n \t    /* Fallthru to general call handling.  */;\n \t  }\n-      if (!in_ipa_mode)\n+      if (!in_ipa_mode\n+\t  || (fndecl\n+\t      && !lookup_vi_for_tree (fndecl)))\n \t{\n \t  VEC(ce_s, heap) *rhsc = NULL;\n \t  int flags = gimple_call_flags (t);\n@@ -4425,9 +4427,6 @@ create_variable_info_for (tree decl, const char *name)\n   tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decl_type);\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL && in_ipa_mode)\n-    return create_function_info_for (decl, name);\n-\n   if (var_can_have_subvars (decl) && use_field_sensitive)\n     push_fields_onto_fieldstack (decl_type, &fieldstack, 0);\n \n@@ -4773,8 +4772,6 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n }\n \n \n-static bool have_alias_info = false;\n-\n /* Compute the points-to solution *PT for the variable VI.  */\n \n static void\n@@ -5399,44 +5396,12 @@ delete_alias_heapvars (void)\n   heapvar_for_stmt = NULL;\n }\n \n-/* Create points-to sets for the current function.  See the comments\n-   at the start of the file for an algorithmic overview.  */\n+/* Solve the constraint set.  */\n \n static void\n-compute_points_to_sets (void)\n+solve_constraints (void)\n {\n   struct scc_info *si;\n-  basic_block bb;\n-  unsigned i;\n-  varinfo_t vi;\n-\n-  timevar_push (TV_TREE_PTA);\n-\n-  init_alias_vars ();\n-  init_alias_heapvars ();\n-\n-  intra_create_variable_infos ();\n-\n-  /* Now walk all statements and derive aliases.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple phi = gsi_stmt (gsi);\n-\n-\t  if (is_gimple_reg (gimple_phi_result (phi)))\n-\t    find_func_aliases (phi);\n-\t}\n-\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\n-\t  find_func_aliases (stmt);\n-\t}\n-    }\n \n   if (dump_file)\n     {\n@@ -5493,6 +5458,48 @@ compute_points_to_sets (void)\n \n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n+}\n+\n+/* Create points-to sets for the current function.  See the comments\n+   at the start of the file for an algorithmic overview.  */\n+\n+static void\n+compute_points_to_sets (void)\n+{\n+  basic_block bb;\n+  unsigned i;\n+  varinfo_t vi;\n+\n+  timevar_push (TV_TREE_PTA);\n+\n+  init_alias_vars ();\n+  init_alias_heapvars ();\n+\n+  intra_create_variable_infos ();\n+\n+  /* Now walk all statements and derive aliases.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple phi = gsi_stmt (gsi);\n+\n+\t  if (is_gimple_reg (gimple_phi_result (phi)))\n+\t    find_func_aliases (phi);\n+\t}\n+\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\n+\t  find_func_aliases (stmt);\n+\t}\n+    }\n+\n+  /* From the constraints compute the points-to sets.  */\n+  solve_constraints ();\n \n   /* Compute the points-to sets for ESCAPED and CALLUSED used for\n      call-clobber analysis.  */\n@@ -5524,8 +5531,6 @@ compute_points_to_sets (void)\n     }\n \n   timevar_pop (TV_TREE_PTA);\n-\n-  have_alias_info = true;\n }\n \n \n@@ -5559,7 +5564,6 @@ delete_points_to_sets (void)\n   VEC_free (varinfo_t, heap, varmap);\n   free_alloc_pool (variable_info_pool);\n   free_alloc_pool (constraint_pool);\n-  have_alias_info = false;\n }\n \n \n@@ -5658,101 +5662,94 @@ static unsigned int\n ipa_pta_execute (void)\n {\n   struct cgraph_node *node;\n-  struct scc_info *si;\n \n   in_ipa_mode = 1;\n+\n   init_alias_heapvars ();\n   init_alias_vars ();\n \n+  /* Build the constraints.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       unsigned int varid;\n \n+      /* Nodes without a body are not interesting.  Especially do not\n+         visit clones at this point for now - we get duplicate decls\n+\t there for inline clones at least.  */\n+      if (!gimple_has_body_p (node->decl)\n+\t  || node->clone_of)\n+\tcontinue;\n+\n+      /* It does not make sense to have graph edges into or out of\n+         externally visible functions.  There is no extra information\n+\t we can gather from them.  */\n+      if (node->local.externally_visible)\n+\tcontinue;\n+\n       varid = create_function_info_for (node->decl,\n \t\t\t\t\tcgraph_node_name (node));\n-      if (node->local.externally_visible)\n-\t{\n-\t  varinfo_t fi = get_varinfo (varid);\n-\t  for (; fi; fi = fi->next)\n-\t    make_constraint_from (fi, anything_id);\n-\t}\n     }\n+\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      if (node->analyzed)\n-\t{\n-\t  struct function *func = DECL_STRUCT_FUNCTION (node->decl);\n-\t  basic_block bb;\n-\t  tree old_func_decl = current_function_decl;\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Generating constraints for %s\\n\",\n-\t\t     cgraph_node_name (node));\n-\t  push_cfun (func);\n-\t  current_function_decl = node->decl;\n+      struct function *func;\n+      basic_block bb;\n+      tree old_func_decl;\n \n-\t  FOR_EACH_BB_FN (bb, func)\n-\t    {\n-\t      gimple_stmt_iterator gsi;\n+      /* Nodes without a body are not interesting.  */\n+      if (!gimple_has_body_p (node->decl)\n+\t  || node->clone_of)\n+\tcontinue;\n \n-\t      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n-\t\t   gsi_next (&gsi))\n-\t\t{\n-\t\t  gimple phi = gsi_stmt (gsi);\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Generating constraints for %s\\n\",\n+\t\t cgraph_node_name (node));\n \n-\t\t  if (is_gimple_reg (gimple_phi_result (phi)))\n-\t\t    find_func_aliases (phi);\n-\t\t}\n+      func = DECL_STRUCT_FUNCTION (node->decl);\n+      old_func_decl = current_function_decl;\n+      push_cfun (func);\n+      current_function_decl = node->decl;\n \n-\t      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\tfind_func_aliases (gsi_stmt (gsi));\n-\t    }\n-\t  current_function_decl = old_func_decl;\n-\t  pop_cfun ();\n-\t}\n-      else\n-\t{\n-\t  /* Make point to anything.  */\n-\t}\n-    }\n+      /* For externally visible functions use local constraints for\n+\t their arguments.  For local functions we see all callers\n+\t and thus do not need initial constraints for parameters.  */\n+      if (node->local.externally_visible)\n+\tintra_create_variable_infos ();\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n-      dump_constraints (dump_file);\n-    }\n+      /* Build constriants for the function body.  */\n+      FOR_EACH_BB_FN (bb, func)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n \n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\nCollapsing static cycles and doing variable \"\n-\t     \"substitution:\\n\");\n+\t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n+\t    {\n+\t      gimple phi = gsi_stmt (gsi);\n \n-  init_graph (VEC_length (varinfo_t, varmap) * 2);\n-  build_pred_graph ();\n-  si = perform_var_substitution (graph);\n-  rewrite_constraints (graph, si);\n+\t      if (is_gimple_reg (gimple_phi_result (phi)))\n+\t\tfind_func_aliases (phi);\n+\t    }\n \n-  build_succ_graph ();\n-  free_var_substitution_info (si);\n-  move_complex_constraints (graph);\n-  unite_pointer_equivalences (graph);\n-  find_indirect_cycles (graph);\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n \n-  /* Implicit nodes and predecessors are no longer necessary at this\n-     point. */\n-  remove_preds_and_fake_succs (graph);\n+\t      find_func_aliases (stmt);\n+\t    }\n+\t}\n \n-  if (dump_file)\n-    fprintf (dump_file, \"\\nSolving graph\\n\");\n+      current_function_decl = old_func_decl;\n+      pop_cfun ();\n+    }\n \n-  solve_graph (graph);\n+  /* From the constraints compute the points-to sets.  */\n+  solve_constraints ();\n \n-  if (dump_file)\n-    dump_sa_points_to_info (dump_file);\n+  delete_points_to_sets ();\n \n   in_ipa_mode = 0;\n-  delete_alias_heapvars ();\n-  delete_points_to_sets ();\n+\n   return 0;\n }\n "}]}