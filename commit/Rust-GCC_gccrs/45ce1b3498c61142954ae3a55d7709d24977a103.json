{"sha": "45ce1b3498c61142954ae3a55d7709d24977a103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVjZTFiMzQ5OGM2MTE0Mjk1NGFlM2E1NWQ3NzA5ZDI0OTc3YTEwMw==", "commit": {"author": {"name": "Felix Natter", "email": "fnatter@gmx.net", "date": "2000-04-25T06:42:25Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-04-25T06:42:25Z"}, "message": "howto.html: Add bits.\n\n\n2000-04-24  Felix Natter <fnatter@gmx.net>\n\n\t* docs/17_intro/howto.html: Add bits.\n\t* docs/17_intro/porting-howto.html: New file.\n\nFrom-SVN: r33403", "tree": {"sha": "f56b1627e9d1861323a8bf72da6c15964e7f39e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f56b1627e9d1861323a8bf72da6c15964e7f39e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45ce1b3498c61142954ae3a55d7709d24977a103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ce1b3498c61142954ae3a55d7709d24977a103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ce1b3498c61142954ae3a55d7709d24977a103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ce1b3498c61142954ae3a55d7709d24977a103/comments", "author": {"login": "fnatter", "id": 1979118, "node_id": "MDQ6VXNlcjE5NzkxMTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1979118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fnatter", "html_url": "https://github.com/fnatter", "followers_url": "https://api.github.com/users/fnatter/followers", "following_url": "https://api.github.com/users/fnatter/following{/other_user}", "gists_url": "https://api.github.com/users/fnatter/gists{/gist_id}", "starred_url": "https://api.github.com/users/fnatter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fnatter/subscriptions", "organizations_url": "https://api.github.com/users/fnatter/orgs", "repos_url": "https://api.github.com/users/fnatter/repos", "events_url": "https://api.github.com/users/fnatter/events{/privacy}", "received_events_url": "https://api.github.com/users/fnatter/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d89258ae5150ce2c0f947ee2c636e3cae1275da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d89258ae5150ce2c0f947ee2c636e3cae1275da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d89258ae5150ce2c0f947ee2c636e3cae1275da"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "024aac7e7c9310ebbff6bb1916076002cda39d6f", "filename": "libstdc++-v3/docs/17_intro/porting-howto.html", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ce1b3498c61142954ae3a55d7709d24977a103/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fporting-howto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ce1b3498c61142954ae3a55d7709d24977a103/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fporting-howto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F17_intro%2Fporting-howto.html?ref=45ce1b3498c61142954ae3a55d7709d24977a103", "patch": "@@ -0,0 +1,199 @@\n+<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n+\n+<html>\n+\n+  <head>\n+    <title>Libstdc++-porting-howto</title>\n+  </head>\n+\n+  <body>\n+\n+  <h1>Porting to libstdc++-v3</h1>\n+\n+  <center>\n+  <li><a href = \"#std\">Namespaces std</a>\n+  <li><a href = \"#nocreate\">File-flags: <tt>ios::nocreate</tt> and\n+  <tt>ios::noreplace</tt></a>\n+  <li><a href = \"#headers\">The new headers</a>\n+  <li><a href = \"#about\">Comments, suggestions, corrections, questions...</a>\n+  </center>\n+\n+    <a name = \"std\">\n+\t<h2>Namespace std::</h2>\n+\t</a>\n+\t  <p>\n+The latest C++-standard (ISO-14882) requires that the standard C++-library\n+is defined in namespace std::. Thus, to use classes from the standard c++\n+library, you can do one of three things:\n+<ul>\n+  <li>wrap your code in <tt>namespace std { ... }</tt>\n+=> This is not an option because only symbols from the standard c++-library are\n+defined in namespace std::.\n+  <li>put a kind of <dfn>using-declaration</dfn> in your source\n+(either <tt>using namespace std;</tt> or i.e. <tt>using std::string;</tt>)\n+=> works well for source-files, but cannot be used in header-files\n+  <li>use a <dfn>fully qualified name</dfn> for each libstdc++-symbol\n+(i.e. <tt>std::string</tt>, <tt>std::cout</tt>)\n+=> can always be used\n+</ul>\n+</p>\n+      <p>\n+Namespace portability-issues are not a problem with g++, because versions\n+of g++ that do not have libstdc++ in std:: use <tt>-fno-honor-std</tt>\n+(ignore <tt>std::</tt>, <tt>:: = std::</tt>) by default. This probably\n+applies to some other compilers as well.\n+\n+The following sections list some possible solutions to support compilers\n+that cannot ignore std::.\n+</p> \n+      <h3>Using <dfn>namespace composition</dfn> if the project uses a separate\n+      namespace</h3>\n+\n+\t    <p>\n+<a href = \"http://gtkmm.sourcforge.net\">Gtk--</a> defines most of its\n+classes in namespace Gtk::. Thus, it was possible to adapt Gtk-- to\n+namespace std:: by using a C++-feature called <dfn>namespace\n+composition</dfn>. This is what happens if you put a\n+<dfn>using</dfn>-declaration into a namespace-definition: the imported\n+symbol(s) gets imported into the currently active namespace(s). This is\n+what it looks like in Gtk--:\n+<pre>\n+namespace Gtk {\n+\tusing std::string;\n+\tclass Window { ... }\n+}\n+</pre>\n+In this example, <tt>std::string</tt> gets imported into namespace Gtk::.\n+The result is that you don't have to use <tt>std::string</tt> in this header,\n+but still <tt>std::string</tt> does not get imported into user-space (the\n+global namespace ::) unless the user does <tt>using namespace Gtk;</tt>\n+(which is not recommended practice for Gtk--, so it is not a problem).\n+</p>\n+\n+      <h3>Defining an empty namespace std for backwards-compatibility</h3>\n+\t    <p>\n+By defining an (empty) namespace std:: before using it, you can avoid\n+getting errors on systems where no part of the library is in std:\n+<pre>\n+namespace std { }\n+using namespace std;\n+</pre>\n+</p>\n+      <h3>Avoid to use fully qualified names (i.e. std::string)</h3>\n+\t    <p>\n+If some compilers complain about <tt>using std::string;</tt>, and if the\n+hack for gtk-- mentioned above does not work, then it might be a good idea\n+to define a macro <tt>NS_STD</tt>, which is defined to either \"\" or \"std\"\n+based on an autoconf-test. Then you should be able to use\n+<tt>NS_STD::string</tt>, which will evaluate to <tt>::string</tt> (\"string\n+in the global namespace\") on systems that do not put string in std::.\n+(This is untested and might not even be necessary)\n+</p>\n+\n+      <h3>How some open-source-projects deal with this</h3>\n+\t    <p>\n+\n+<table>\n+  <tr><td><a href = \"http://www.clanlib.org\">clanlib</a></td> <td>usual</td>\n+  </tr>\n+  <tr><td><a href = \"http://pingus.seul.org\">pingus</a></td> <td>usual</td>\n+  </tr>\n+  <tr><td><a href = \"http://www.mozilla.org\">mozilla</a></td> <td>usual</td>\n+  </tr>\n+  <tr><td><a href = \"http://www.mnemonic.org\">mnemonic</a></td> <td>none</td>\n+  </tr>\n+  <tr><td><a href = \"http://libsigc.sourceforge.net\">libsigc++</a></td>\n+      <td>portable-impl</td>\n+  </tr>\n+</table>\n+\n+<table>\n+  <caption>Notations for categories</caption>\n+  <tr>\n+    <td>usual</td> <td>mostly fully qualified names and some\n+    using-declarations (but not in headers)</td>\n+  </tr>\n+  <tr>\n+    <td>none</td> <td>no namespace std at all</td>\n+  </tr>\n+  <tr>\n+    <td>portable-impl</td> <td>wrap all namespace-handling in macros to support\n+\tcompilers without namespace-support (no libstdc++ used in headers)</td>\n+  </tr>\n+</table>\n+\t\n+</p>\n+    <a name = \"nocreate\">    \n+    <h2>there is no ios::nocreate/ios::noreplace in ISO 14882</h2>\n+\t</a>\n+\t  <p>\n+I have seen <tt>ios::nocreate</tt> being used for input-streams, most\n+probably because the authors thought it would be more correct to specify\n+nocreate \"explicitly\".  So you can simply leave it out for\n+input-streams.\n+</p>\n+<p>\n+For output streams, \"nocreate\" is probably the default, unless you specify\n+<tt>std::ios::trunc</tt> ? To be safe, you can open the file for\n+reading, check if it has been opened, and then decide whether you want to\n+create/replace or not.\n+</p>\n+    <a name = \"attach\">    \n+\t<h2><tt>stream::attach(int fd)</tt> is not in the standard any more</h2>\n+\t</a>\n+\t  <p>\n+With libstdc++-v3, you can use\n+<pre>\n+basic_filebuf(int __fd, const char*__name, ios_base::openmode __mode)\n+</pre>\n+For a portable solution (if there is one), you need to implement\n+a subclass of <tt>streambuf</tt> which opens a file given a descriptor,\n+and then pass an instance of this to the stream-constructor (from the\n+Josuttis-book).\n+</p>\n+\t<a name = \"headers\">\n+\t<h2>The new headers</h2>\n+\t</a>\n+\t  <p>\n+The new headers can be seen in this\n+<a href = \"../../testsuite/17_intro/headers.cc\">source file</a>.\n+</p>\n+      <p>\n+I think it is a problem for libstdc++-v3 to add links or wrappers for the\n+old headers, because the implementation has changed, and the\n+header-name-changes indicate this. It might be preferable to use the new\n+headers and tell users of old compilers that they should create links\n+(which is what they will have to do sometime anyway).\n+</p>\n+\n+\t  <h3><tt>&lt;ctype.h&gt;</tt> introduces ambiguity when used with\n+\t  <tt>&lt;cctype&gt;</tt></h3>\n+\t  <p>\n+The best solution I came up with so far is to include <tt>cctype</tt>\n+instead of <tt>ctype.h</tt> wherever possible, and then use fully\n+qualified names to refer to the libstdc++-versions: std::islower,\n+std::isalnum etc.  (you will need to as soon as any header includes\n+<tt>&lt;ctype.h&gt;</tt>, because then there will be an ambiguity with the\n+C-versions in the global namespace defined in <tt>&lt;ctype.h&gt;</tt>)\n+</p>\n+\n+      <h3><tt>&lt;fstream&gt;</tt> does not define <tt>std::cout</tt>,\n+      <tt>std::cin</tt> etc.</h3>\n+        <p>\n+In previous versions of the standard, <tt>&lt;fstream.h&gt;</tt>,\n+<tt>&lt;ostream.h&gt;</tt> and <tt>&lt;istream.h&gt;</tt> used to define\n+<tt>cout</tt>, <tt>cin</tt> and so on. With libstdc++-v3, you need\n+to include <tt>&lt;iostream&gt;</tt> to define these.\n+</p>\n+    <a name = \"about\">\n+\t<h2>About...</h2>\n+\t</a>\n+      <p>\n+Please send any experience, additions, corrections or questions to <a href =\n+\"mailto:fnatter@gmx.net\">fnatter@gmx.net</a> or for discussion to\n+the libstdc++-v3-mailing-list.\n+</p>\n+\t\n+  </body>\n+\n+</html>"}]}