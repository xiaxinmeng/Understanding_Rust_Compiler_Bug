{"sha": "a9b31c40b3d0680eefd5c4b09e5566541394fcb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTliMzFjNDBiM2QwNjgwZWVmZDVjNGIwOWU1NTY2NTQxMzk0ZmNiOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-30T02:12:42Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-30T02:12:42Z"}, "message": "tree-outof-ssa.c (_elim_graph): Change the type of edge_list to VEC(int,heap)*.\n\n\t* tree-outof-ssa.c (_elim_graph): Change the type of edge_list\n\tto VEC(int,heap)*.\n\t(new_elim_graph, clear_elim_graph, delete_elim_graph,\n\telim_graph_add_edge, elim_graph_remove_succ_edge,\n\tFOR_EACH_ELIM_GRAPH_SUCC, FOR_EACH_ELIM_GRAPH_PRED): Use VEC\n\tinstead of VARRAY.\n\nFrom-SVN: r100349", "tree": {"sha": "4bcebefe7b1d86111d0e5d683b22c98c7db13365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bcebefe7b1d86111d0e5d683b22c98c7db13365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9b31c40b3d0680eefd5c4b09e5566541394fcb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b31c40b3d0680eefd5c4b09e5566541394fcb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9b31c40b3d0680eefd5c4b09e5566541394fcb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b31c40b3d0680eefd5c4b09e5566541394fcb8/comments", "author": null, "committer": null, "parents": [{"sha": "ad821074cbd282194b570e63a09b4690d644303e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad821074cbd282194b570e63a09b4690d644303e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad821074cbd282194b570e63a09b4690d644303e"}], "stats": {"total": 45, "additions": 29, "deletions": 16}, "files": [{"sha": "754a0277229dfc39b6c3df9237e3a66b604c6cb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b31c40b3d0680eefd5c4b09e5566541394fcb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b31c40b3d0680eefd5c4b09e5566541394fcb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9b31c40b3d0680eefd5c4b09e5566541394fcb8", "patch": "@@ -1,3 +1,12 @@\n+2005-05-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-outof-ssa.c (_elim_graph): Change the type of edge_list\n+\tto VEC(int,heap)*.\n+\t(new_elim_graph, clear_elim_graph, delete_elim_graph,\n+\telim_graph_add_edge, elim_graph_remove_succ_edge,\n+\tFOR_EACH_ELIM_GRAPH_SUCC, FOR_EACH_ELIM_GRAPH_PRED): Use VEC\n+\tinstead of VARRAY.\n+\n 2005-05-29  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cgraphunit.c, ipa-inline.c, loop-iv.c, modulo-sched.c,"}, {"sha": "52505c1aee41d968900551042b3763eec1e8344a", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b31c40b3d0680eefd5c4b09e5566541394fcb8/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b31c40b3d0680eefd5c4b09e5566541394fcb8/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=a9b31c40b3d0680eefd5c4b09e5566541394fcb8", "patch": "@@ -53,6 +53,9 @@ Boston, MA 02111-1307, USA.  */\n #define SSANORM_COMBINE_TEMPS\t\t0x2\n #define SSANORM_COALESCE_PARTITIONS\t0x4\n \n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n+\n /* Used to hold all the components required to do SSA PHI elimination.\n    The node and pred/succ list is a simple linear list of nodes and\n    edges represented as pairs of nodes.\n@@ -82,7 +85,7 @@ typedef struct _elim_graph {\n   VEC(tree,heap) *nodes;\n \n   /*  The predecessor and successor edge list.  */\n-  varray_type edge_list;\n+  VEC(int,heap) *edge_list;\n \n   /* Visited vector.  */\n   sbitmap visited;\n@@ -220,7 +223,7 @@ new_elim_graph (int size)\n \n   g->nodes = VEC_alloc (tree, heap, 30);\n   g->const_copies = VEC_alloc (tree, heap, 20);\n-  VARRAY_INT_INIT (g->edge_list, 20, \"Elimination Edge List\");\n+  g->edge_list = VEC_alloc (int, heap, 20);\n   VARRAY_INT_INIT (g->stack, 30, \" Elimination Stack\");\n   \n   g->visited = sbitmap_alloc (size);\n@@ -235,7 +238,7 @@ static inline void\n clear_elim_graph (elim_graph g)\n {\n   VEC_truncate (tree, g->nodes, 0);\n-  VARRAY_POP_ALL (g->edge_list);\n+  VEC_truncate (int, g->edge_list, 0);\n }\n \n \n@@ -245,6 +248,7 @@ static inline void\n delete_elim_graph (elim_graph g)\n {\n   sbitmap_free (g->visited);\n+  VEC_free (int, heap, g->edge_list);\n   VEC_free (tree, heap, g->const_copies);\n   VEC_free (tree, heap, g->nodes);\n   free (g);\n@@ -280,8 +284,8 @@ elim_graph_add_node (elim_graph g, tree node)\n static inline void\n elim_graph_add_edge (elim_graph g, int pred, int succ)\n {\n-  VARRAY_PUSH_INT (g->edge_list, pred);\n-  VARRAY_PUSH_INT (g->edge_list, succ);\n+  VEC_safe_push (int, heap, g->edge_list, pred);\n+  VEC_safe_push (int, heap, g->edge_list, succ);\n }\n \n \n@@ -293,12 +297,12 @@ elim_graph_remove_succ_edge (elim_graph g, int node)\n {\n   int y;\n   unsigned x;\n-  for (x = 0; x < VARRAY_ACTIVE_SIZE (g->edge_list); x += 2)\n-    if (VARRAY_INT (g->edge_list, x) == node)\n+  for (x = 0; x < VEC_length (int, g->edge_list); x += 2)\n+    if (VEC_index (int, g->edge_list, x) == node)\n       {\n-        VARRAY_INT (g->edge_list, x) = -1;\n-\ty = VARRAY_INT (g->edge_list, x + 1);\n-\tVARRAY_INT (g->edge_list, x + 1) = -1;\n+        VEC_replace (int, g->edge_list, x, -1);\n+\ty = VEC_index (int, g->edge_list, x + 1);\n+\tVEC_replace (int, g->edge_list, x + 1, -1);\n \treturn y;\n       }\n   return -1;\n@@ -313,12 +317,12 @@ elim_graph_remove_succ_edge (elim_graph g, int node)\n do {\t\t\t\t\t\t\t\t\t\\\n   unsigned x_;\t\t\t\t\t\t\t\t\\\n   int y_;\t\t\t\t\t\t\t\t\\\n-  for (x_ = 0; x_ < VARRAY_ACTIVE_SIZE ((GRAPH)->edge_list); x_ += 2)\t\\\n+  for (x_ = 0; x_ < VEC_length (int, (GRAPH)->edge_list); x_ += 2)\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      y_ = VARRAY_INT ((GRAPH)->edge_list, x_);\t\t\t\t\\\n+      y_ = VEC_index (int, (GRAPH)->edge_list, x_);\t\t\t\\\n       if (y_ != (NODE))\t\t\t\t\t\t\t\\\n         continue;\t\t\t\t\t\t\t\\\n-      (VAR) = VARRAY_INT ((GRAPH)->edge_list, x_ + 1);\t\t\t\\\n+      (VAR) = VEC_index (int, (GRAPH)->edge_list, x_ + 1);\t\t\\\n       CODE;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n@@ -332,12 +336,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   unsigned x_;\t\t\t\t\t\t\t\t\\\n   int y_;\t\t\t\t\t\t\t\t\\\n-  for (x_ = 0; x_ < VARRAY_ACTIVE_SIZE ((GRAPH)->edge_list); x_ += 2)\t\\\n+  for (x_ = 0; x_ < VEC_length (int, (GRAPH)->edge_list); x_ += 2)\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      y_ = VARRAY_INT ((GRAPH)->edge_list, x_ + 1);\t\t\t\\\n+      y_ = VEC_index (int, (GRAPH)->edge_list, x_ + 1);\t\t\t\\\n       if (y_ != (NODE))\t\t\t\t\t\t\t\\\n         continue;\t\t\t\t\t\t\t\\\n-      (VAR) = VARRAY_INT ((GRAPH)->edge_list, x_);\t\t\t\\\n+      (VAR) = VEC_index (int, (GRAPH)->edge_list, x_);\t\t\t\\\n       CODE;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)"}]}