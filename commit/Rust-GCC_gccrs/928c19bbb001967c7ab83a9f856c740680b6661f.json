{"sha": "928c19bbb001967c7ab83a9f856c740680b6661f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4YzE5YmJiMDAxOTY3YzdhYjgzYTlmODU2Yzc0MDY4MGI2NjYxZg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2009-03-29T18:13:43Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2009-03-29T18:13:43Z"}, "message": "re PR c/456 (constant expressions constraints (gcc.dg/c90-const-expr-1))\n\n\tPR c/456\n\tPR c/5675\n\tPR c/19976\n\tPR c/29116\n\tPR c/31871\n\tPR c/35198\n\nfixincludes:\n\t* inclhack.def (glibc_tgmath): New fix.\n\t* fixincl.x: Regenerate.\n\t* tests/base/tgmath.h: New.\n\ngcc:\n\t* builtins.c (fold_builtin_sincos): Build COMPOUND_EXPR in\n\tvoid_type_node.\n\t(fold_call_expr): Return a NOP_EXPR from folding rather than the\n\tcontained expression.\n\t* c-common.c (c_fully_fold, c_fully_fold_internal, c_save_expr):\n\tNew.\n\t(c_common_truthvalue_conversion): Use c_save_expr.  Do not fold\n\tconditional expressions for C.\n\t(decl_constant_value_for_optimization): Move from\n\tdecl_constant_value_for_broken_optimization in c-typeck.c.  Check\n\twhether optimizing and that the expression is a VAR_DECL not of\n\tarray type instead of doing such checks in the caller.  Do not\n\tcheck pedantic.  Call gcc_unreachable for C++.\n\t* c-common.def (C_MAYBE_CONST_EXPR): New.\n\t* c-common.h (c_fully_fold, c_save_expr,\n\tdecl_constant_value_for_optimization): New prototypes.\n\t(C_MAYBE_CONST_EXPR_PRE, C_MAYBE_CONST_EXPR_EXPR,\n\tC_MAYBE_CONST_EXPR_INT_OPERANDS, C_MAYBE_CONST_EXPR_NON_CONST,\n\tEXPR_INT_CONST_OPERANDS): Define.\n\t* c-convert.c (convert): Strip nops from expression.\n\t* c-decl.c (groktypename): Take extra parameters expr and\n\texpr_const_operands.  Update call to grokdeclarator.\n\t(start_decl): Update call to grokdeclarator.  Add statement for\n\texpressions used in type of decl.\n\t(grokparm): Update call to grokdeclarator.\n\t(push_parm_decl): Update call to grokdeclarator.\n\t(build_compound_literal): Add parameter non_const and build a\n\tC_MAYBE_COSNT_EXPR if applicable.\n\t(grokdeclarator): Take extra parameters expr and\n\texpr_const_operands.  Track expressions used in declaration\n\tspecifiers and declarators.  Fold array sizes and track whether\n\tthey are constant expressions and whether they are integer\n\tconstant expressions.\n\t(parser_xref_tag): Set expr and expr_const_operands fields in\n\treturn value.\n\t(grokfield): Update call to grokdeclarator.\n\t(start_function): Update call to grokdeclarator.\n\t(build_null_declspecs): Set expr and expr_const_operands fields in\n\treturn value.\n\t(declspecs_add_type): Handle expressions in typeof specifiers.\n\t* c-parser.c (c_parser_declspecs): Set expr and\n\texpr_const_operands fields for declaration specifiers.\n\t(c_parser_enum_specifier): Likewise.\n\t(c_parser_struct_or_union_specifier): Likewise.\n\t(c_parser_typeof_specifier): Likewise.  Update call to\n\tgroktypename.  Fold expression as needed.  Return expressions with\n\ttype instead of adding statements.\n\t(c_parser_attributes): Update calls to c_parser_expr_list.\n\t(c_parser_statement_after_labels): Fold expression before passing\n\tto objc_build_throw_stmt.\n\t(c_parser_condition): Fold expression.\n\t(c_parser_asm_operands): Fold expression.\n\t(c_parser_conditional_expression): Use c_save_expr.  Update call\n\tto build_conditional_expr.\n\t(c_parser_alignof_expression): Update call to groktypename.\n\t(c_parser_postfix_expression): Preserve C_MAYBE_CONST_EXPR as\n\toriginal_code.  Fold expression argument of va_arg.  Create\n\tC_MAYBE_CONST_EXPR to preserve side effects of expressions in type\n\targument to va_arg.  Update calls to groktypename.  Fold array\n\tindex for offsetof.  Verify that first argument to\n\t__builtin_choose_expr has integer type.\n\t(c_parser_postfix_expression_after_paren_type): Update calls to\n\tgroktypename and build_compound_literal.  Handle expressions with\n\tside effects in type name.\n\t(c_parser_postfix_expression_after_primary): Update call to\n\tc_parser_expr_list.  Set original_code for calls to\n\t__builtin_constant_p.\n\t(c_parser_expr_list): Take extra parameter fold_p.  Fold\n\texpressions if requested.\n\t(c_parser_objc_type_name): Update call to groktypename.\n\t(c_parser_objc_synchronized_statement): Fold expression.\n\t(c_parser_objc_receiver): Fold expression.\n\t(c_parser_objc_keywordexpr): Update call to c_parser_expr_list.\n\t(c_parser_omp_clause_num_threads, c_parser_omp_clause_schedule,\n\tc_parser_omp_atomic, c_parser_omp_for_loop): Fold expressions.\n\t* c-tree.h (CONSTRUCTOR_NON_CONST): Define.\n\t(struct c_typespec): Add elements expr and expr_const_operands.\n\t(struct c_declspecs): Add elements expr and expr_const_operands.\n\t(groktypename, build_conditional_expr, build_compound_literal):\n\tUpdate prototypes.\n\t(in_late_binary_op): Declare.\n\t* c-typeck.c (note_integer_operands): New function.\n\t(in_late_binary_op): New variable.\n\t(decl_constant_value_for_broken_optimization): Move to c-common.c\n\tand rename to decl_constant_value_for_optimization.\n\t(default_function_array_conversion): Do not strip nops.\n\t(default_conversion): Do not call\n\tdecl_constant_value_for_broken_optimization.\n\t(build_array_ref): Do not fold result.\n\t(c_expr_sizeof_expr): Fold operand.  Use C_MAYBE_CONST_EXPR for\n\tresult when operand is a VLA.\n\t(c_expr_sizeof_type): Update call to groktypename.  Handle\n\texpressions included in type name.  Use C_MAYBE_CONST_EXPR for\n\tresult when operand names a VLA type.\n\t(build_function_call): Update call to build_compound_literal.\n\tOnly fold result for calls to __builtin_* functions.  Strip\n\tNOP_EXPR from INTEGER_CST returned from such functions.  Fold\n\tthe function designator.\n\t(convert_arguments): Fold arguments.  Update call to\n\tconvert_for_assignment.\n\t(build_unary_op): Handle increment and decrement of\n\tC_MAYBE_CONST_EXPR.  Move lvalue checks for increment and\n\tdecrement earlier.  Fold operand of increment and decrement.\n\tHandle address of C_MAYBE_CONST_EXPR.  Only fold expression being\n\tbuilt for integer operand.  Wrap returns that are INTEGER_CSTs\n\twithout being integer constant expressions or that have integer\n\tconstant operands without being INTEGER_CSTs.\n\t(lvalue_p): Handle C_MAYBE_CONST_EXPR.\n\t(build_conditional_expr): Add operand ifexp_bcp.  Track whether\n\tresult is an integer constant expression or can be used in\n\tunevaluated parts of one and avoid folding and wrap as\n\tappropriate.  Fold operands before possibly doing -Wsign-compare\n\twarnings.\n\t(build_compound_expr): Wrap result for C99 if operands can be used\n\tin integer constant expressions.\n\t(build_c_cast): Update call to digest_init.  Do not ignore\n\toverflow from casting floating-point constants to integers.  Wrap\n\tresults that could be confused with integer constant expressions,\n\tnull pointer constants or floating-point constants.\n\t(c_cast_expr): Update call to groktypename.  Handle expressions\n\tincluded in type name.\n\t(build_modify_expr): Handle modifying a C_MAYBE_CONST_EXPR.  Fold\n\tlhs inside possible SAVE_EXPR.  Fold RHS before assignment.\n\tUpdate calls to convert_for_assignment.\n\t(convert_for_assignment): Take new parameter\n\tnull_pointer_constant.  Do not strip nops or call\n\tdecl_constant_value_for_broken_optimization.  Set\n\tin_late_binary_op for conversions to boolean.\n\t(store_init_value): Update call to digest_init.\n\t(digest_init): Take new parameter null_pointer_constant.  Do not\n\tcall decl_constant_value_for_broken_optimization.  pedwarn for\n\tinitializers not constant expressions.  Update calls to\n\tconvert_for_assignment.\n\t(constructor_nonconst): New.\n\t(struct constructor_stack): Add nonconst element.\n\t(really_start_incremental_init, push_init_level, pop_init_level):\n\tHandle constructor_nonconst and nonconst element.\n\t(set_init_index): Call constant_expression_warning for array\n\tdesignators.\n\t(output_init_element): Fold value.  Set constructor_nonconst as\n\tapplicable.  pedwarn for initializers not constant expressions.\n\tUpdate call to digest_init.  Call constant_expression_warning\n\twhere constant initializers are required.\n\t(process_init_element): Use c_save_expr.\n\t(c_finish_goto_ptr): Fold expression.\n\t(c_finish_return): Fold return value.  Update call to\n\tconvert_for_assignment.\n\t(c_start_case): Fold switch expression.\n\t(c_process_expr_stmt): Fold expression.\n\t(c_finish_stmt_expr): Create C_MAYBE_CONST_EXPR as needed to\n\tensure statement expression is not evaluated in constant\n\texpression.\n\t(build_binary_op): Track whether results are integer constant\n\texpressions or may occur in such, disable folding and wrap results\n\tas applicable.  Fold operands for -Wsign-compare warnings unless\n\tin_late_binary_op.\n\t(c_objc_common_truthvalue_conversion): Handle results folded to\n\tinteger constants that are not integer constant expressions.\n\t* doc/extend.texi: Document when typeof operands are evaluated,\n\tthat condition of __builtin_choose_expr is an integer constant\n\texpression, and more about use of __builtin_constant_p in\n\tinitializers.\n\ngcc/objc:\n\t* objc-act.c (objc_finish_try_stmt): Set in_late_binary_op.\n\ngcc/testsuite:\n\t* gcc.c-torture/compile/20081108-1.c,\n\tgcc.c-torture/compile/20081108-2.c,\n\tgcc.c-torture/compile/20081108-3.c, gcc.dg/bconstp-2.c,\n\tgcc.dg/bconstp-3.c, gcc.dg/bconstp-4.c, gcc.dg/c90-const-expr-6.c,\n\tgcc.dg/c90-const-expr-7.c, gcc.dg/c90-const-expr-8.c,\n\tgcc.dg/c90-const-expr-9.c, gcc.dg/c90-const-expr-10.c,\n\tgcc.dg/c90-const-expr-11.c, gcc.dg/c99-const-expr-6.c,\n\tgcc.dg/c99-const-expr-7.c, gcc.dg/c99-const-expr-8.c,\n\tgcc.dg/c99-const-expr-9.c, gcc.dg/c99-const-expr-10.c,\n\tgcc.dg/c99-const-expr-11.c, gcc.dg/c99-const-expr-12.c,\n\tgcc.dg/c99-const-expr-13.c, gcc.dg/compare10.c,\n\tgcc.dg/gnu89-const-expr-1.c, gcc.dg/gnu89-const-expr-2.c,\n\tgcc.dg/gnu99-const-expr-1.c, gcc.dg/gnu99-const-expr-2.c,\n\tgcc.dg/gnu99-const-expr-3.c, gcc.dg/vla-12.c, gcc.dg/vla-13.c,\n\tgcc.dg/vla-14.c, gcc.dg/vla-15.c, gcc.dg/vla-16.c: New tests.\n\t* gcc.dg/c90-const-expr-1.c, gcc.dg/c90-const-expr-2.c,\n\tgcc.dg/c90-const-expr-3.c, gcc.dg/c99-const-expr-2.c,\n\tgcc.dg/c99-const-expr-3.c, gcc.dg/c99-static-1.c: Remove XFAILs.\n\t* gcc.dg/c90-const-expr-2.c: Use ZERO in place of 0 in another\n\tcase.\n\t* gcc.dg/overflow-warn-1.c, gcc.dg/overflow-warn-2.c,\n\tgcc.dg/overflow-warn-3.c, gcc.dg/overflow-warn-4.c: Remove\n\tXFAILs.  Update expected messages.\n\t* gcc.dg/pr14649-1.c, gcc.dg/pr19984.c, gcc.dg/pr25682.c: Update\n\texpected messages.\n\t* gcc.dg/real-const-1.c: Replace with test from original PR.\n\t* gcc.dg/vect/pr32230.c: Use intermediate cast to __PTRDIFF_TYPE__\n\twhen casting from non-constant integer to pointer.\n\nFrom-SVN: r145254", "tree": {"sha": "a06c7550ad4d8d100141b10b1c0d61bf7548b888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a06c7550ad4d8d100141b10b1c0d61bf7548b888"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/928c19bbb001967c7ab83a9f856c740680b6661f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928c19bbb001967c7ab83a9f856c740680b6661f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928c19bbb001967c7ab83a9f856c740680b6661f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928c19bbb001967c7ab83a9f856c740680b6661f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5babbcc0fceb0aa66547feb61124ff548929cbfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5babbcc0fceb0aa66547feb61124ff548929cbfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5babbcc0fceb0aa66547feb61124ff548929cbfc"}], "stats": {"total": 2919, "additions": 2630, "deletions": 289}, "files": [{"sha": "e76229617e7637b2a44f2f5e95c65d0e71deafc3", "filename": "fixincludes/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2FChangeLog?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,3 +1,15 @@\n+2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/456\n+\tPR c/5675\n+\tPR c/19976\n+\tPR c/29116\n+\tPR c/31871\n+\tPR c/35198\n+\t* inclhack.def (glibc_tgmath): New fix.\n+\t* fixincl.x: Regenerate.\n+\t* tests/base/tgmath.h: New.\n+\n 2009-03-28  Joseph Myers  <joseph@codesourcery.com>\n \n \t* inclhack.def (aix_syswait, exception_structure,"}, {"sha": "fa38cb324eb85e38731e438ffcaa8a34f00b06f0", "filename": "fixincludes/fixincl.x", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ffixincl.x?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -2,11 +2,11 @@\n  * \n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  * \n- * It has been AutoGen-ed  Saturday March 28, 2009 at 12:12:55 AM UTC\n+ * It has been AutoGen-ed  Sunday March 29, 2009 at 01:30:25 AM UTC\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT SVN-MERGE THIS FILE, EITHER Sat Mar 28 00:12:55 UTC 2009\n+/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Mar 29 01:30:25 UTC 2009\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -15,7 +15,7 @@\n  * certain ANSI-incompatible system header files which are fixed to work\n  * correctly with ANSI C and placed in a directory that GNU C will search.\n  *\n- * This file contains 177 fixup descriptions.\n+ * This file contains 178 fixup descriptions.\n  *\n  * See README for more information.\n  *\n@@ -2217,6 +2217,49 @@ s/{ { 0, } }/{ { 0, 0, 0, 0, 0, 0 } }/\\n\\\n     \"-e\", \"/define[ \\t]\\\\+PTHREAD_COND_INITIALIZER/s/{ { 0, } }/{ { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }/\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Tgmath fix\n+ */\n+tSCC zGlibc_TgmathName[] =\n+     \"glibc_tgmath\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_TgmathList[] =\n+  \"tgmath.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_TgmathMachs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_TgmathSelect0[] =\n+       \"\\\\(\\\\(\\\\(type\\\\) 0.25\\\\) && \\\\(\\\\(type\\\\) 0.25 - 1\\\\)\\\\)\";\n+\n+/*\n+ *  content bypass pattern - skip fix if pattern found\n+ */\n+tSCC zGlibc_TgmathBypass0[] =\n+       \"__floating_type \\\\\\\\\\n\\\n+.*__builtin_classify_type\";\n+\n+#define    GLIBC_TGMATH_TEST_CT  2\n+static tTestDesc aGlibc_TgmathTests[] = {\n+  { TT_NEGREP,   zGlibc_TgmathBypass0, (regex_t*)NULL },\n+  { TT_EGREP,    zGlibc_TgmathSelect0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Tgmath\n+ */\n+static const char* apzGlibc_TgmathPatch[] = {\n+    \"format\",\n+    \"(__builtin_classify_type ((type) 0) == 8 || (__builtin_classify_type ((type) 0) == 9 && __builtin_classify_type (__real__ ((type) 0)) == 8))\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Gnu_Types fix\n@@ -7192,9 +7235,9 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          221\n+#define REGEX_COUNT          223\n #define MACH_LIST_SIZE_LIMIT 181\n-#define FIX_COUNT            177\n+#define FIX_COUNT            178\n \n /*\n  *  Enumerate the fixes\n@@ -7253,6 +7296,7 @@ typedef enum {\n     GLIBC_C99_INLINE_3_FIXIDX,\n     GLIBC_C99_INLINE_4_FIXIDX,\n     GLIBC_MUTEX_INIT_FIXIDX,\n+    GLIBC_TGMATH_FIXIDX,\n     GNU_TYPES_FIXIDX,\n     HP_INLINE_FIXIDX,\n     HP_SYSFILE_FIXIDX,\n@@ -7645,6 +7689,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      GLIBC_MUTEX_INIT_TEST_CT, FD_MACH_ONLY,\n      aGlibc_Mutex_InitTests,   apzGlibc_Mutex_InitPatch, 0 },\n \n+  {  zGlibc_TgmathName,    zGlibc_TgmathList,\n+     apzGlibc_TgmathMachs,\n+     GLIBC_TGMATH_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_TgmathTests,   apzGlibc_TgmathPatch, 0 },\n+\n   {  zGnu_TypesName,    zGnu_TypesList,\n      apzGnu_TypesMachs,\n      GNU_TYPES_TEST_CT, FD_MACH_IFNOT | FD_SUBROUTINE,"}, {"sha": "f6dbd21738ef03853f24bbabec859bebfb409c59", "filename": "fixincludes/inclhack.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Finclhack.def?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1265,6 +1265,19 @@ fix = {\n };\n \n \n+/* glibc's tgmath.h relies on an expression that is not an integer\n+   constant expression being treated as it was by GCC 4.4 and\n+   earlier.  */\n+fix = {\n+    hackname  = glibc_tgmath;\n+    files     = tgmath.h;\n+    select    = '\\(\\(\\(type\\) 0.25\\) && \\(\\(type\\) 0.25 - 1\\)\\)';\n+    bypass    = \"__floating_type \\\\\\\\\\n.*__builtin_classify_type\";\n+    c_fix     = format;\n+    c_fix_arg = \"(__builtin_classify_type ((type) 0) == 8 || (__builtin_classify_type ((type) 0) == 9 && __builtin_classify_type (__real__ ((type) 0)) == 8))\";\n+    test_text = \"# define __floating_type(type) (((type) 0.25) && ((type) 0.25 - 1))\";\n+};\n+\n /*\n  * Fix these files to use the types we think they should for\n  * ptrdiff_t, size_t, and wchar_t."}, {"sha": "f06dc89a2a7cf4b1aeb611d018f5d8531c93d8b3", "filename": "fixincludes/tests/base/tgmath.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2Ftests%2Fbase%2Ftgmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/fixincludes%2Ftests%2Fbase%2Ftgmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ftests%2Fbase%2Ftgmath.h?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,14 @@\n+/*  DO NOT EDIT THIS FILE.\n+\n+    It has been auto-edited by fixincludes from:\n+\n+\t\"fixinc/tests/inc/tgmath.h\"\n+\n+    This had to be done to correct non-standard usages in the\n+    original, manufacturer supplied header file.  */\n+\n+\n+\n+#if defined( GLIBC_TGMATH_CHECK )\n+# define __floating_type(type) (__builtin_classify_type ((type) 0) == 8 || (__builtin_classify_type ((type) 0) == 9 && __builtin_classify_type (__real__ ((type) 0)) == 8))\n+#endif  /* GLIBC_TGMATH_CHECK */"}, {"sha": "f31b531a7815134f3a72b8416fd005702d7177eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,3 +1,174 @@\n+2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/456\n+\tPR c/5675\n+\tPR c/19976\n+\tPR c/29116\n+\tPR c/31871\n+\tPR c/35198\n+\t* builtins.c (fold_builtin_sincos): Build COMPOUND_EXPR in\n+\tvoid_type_node.\n+\t(fold_call_expr): Return a NOP_EXPR from folding rather than the\n+\tcontained expression.\n+\t* c-common.c (c_fully_fold, c_fully_fold_internal, c_save_expr):\n+\tNew.\n+\t(c_common_truthvalue_conversion): Use c_save_expr.  Do not fold\n+\tconditional expressions for C.\n+\t(decl_constant_value_for_optimization): Move from\n+\tdecl_constant_value_for_broken_optimization in c-typeck.c.  Check\n+\twhether optimizing and that the expression is a VAR_DECL not of\n+\tarray type instead of doing such checks in the caller.  Do not\n+\tcheck pedantic.  Call gcc_unreachable for C++.\n+\t* c-common.def (C_MAYBE_CONST_EXPR): New.\n+\t* c-common.h (c_fully_fold, c_save_expr,\n+\tdecl_constant_value_for_optimization): New prototypes.\n+\t(C_MAYBE_CONST_EXPR_PRE, C_MAYBE_CONST_EXPR_EXPR,\n+\tC_MAYBE_CONST_EXPR_INT_OPERANDS, C_MAYBE_CONST_EXPR_NON_CONST,\n+\tEXPR_INT_CONST_OPERANDS): Define.\n+\t* c-convert.c (convert): Strip nops from expression.\n+\t* c-decl.c (groktypename): Take extra parameters expr and\n+\texpr_const_operands.  Update call to grokdeclarator.\n+\t(start_decl): Update call to grokdeclarator.  Add statement for\n+\texpressions used in type of decl.\n+\t(grokparm): Update call to grokdeclarator.\n+\t(push_parm_decl): Update call to grokdeclarator.\n+\t(build_compound_literal): Add parameter non_const and build a\n+\tC_MAYBE_COSNT_EXPR if applicable.\n+\t(grokdeclarator): Take extra parameters expr and\n+\texpr_const_operands.  Track expressions used in declaration\n+\tspecifiers and declarators.  Fold array sizes and track whether\n+\tthey are constant expressions and whether they are integer\n+\tconstant expressions.\n+\t(parser_xref_tag): Set expr and expr_const_operands fields in\n+\treturn value.\n+\t(grokfield): Update call to grokdeclarator.\n+\t(start_function): Update call to grokdeclarator.\n+\t(build_null_declspecs): Set expr and expr_const_operands fields in\n+\treturn value.\n+\t(declspecs_add_type): Handle expressions in typeof specifiers.\n+\t* c-parser.c (c_parser_declspecs): Set expr and\n+\texpr_const_operands fields for declaration specifiers.\n+\t(c_parser_enum_specifier): Likewise.\n+\t(c_parser_struct_or_union_specifier): Likewise.\n+\t(c_parser_typeof_specifier): Likewise.  Update call to\n+\tgroktypename.  Fold expression as needed.  Return expressions with\n+\ttype instead of adding statements.\n+\t(c_parser_attributes): Update calls to c_parser_expr_list.\n+\t(c_parser_statement_after_labels): Fold expression before passing\n+\tto objc_build_throw_stmt.\n+\t(c_parser_condition): Fold expression.\n+\t(c_parser_asm_operands): Fold expression.\n+\t(c_parser_conditional_expression): Use c_save_expr.  Update call\n+\tto build_conditional_expr.\n+\t(c_parser_alignof_expression): Update call to groktypename.\n+\t(c_parser_postfix_expression): Preserve C_MAYBE_CONST_EXPR as\n+\toriginal_code.  Fold expression argument of va_arg.  Create\n+\tC_MAYBE_CONST_EXPR to preserve side effects of expressions in type\n+\targument to va_arg.  Update calls to groktypename.  Fold array\n+\tindex for offsetof.  Verify that first argument to\n+\t__builtin_choose_expr has integer type.\n+\t(c_parser_postfix_expression_after_paren_type): Update calls to\n+\tgroktypename and build_compound_literal.  Handle expressions with\n+\tside effects in type name.\n+\t(c_parser_postfix_expression_after_primary): Update call to\n+\tc_parser_expr_list.  Set original_code for calls to\n+\t__builtin_constant_p.\n+\t(c_parser_expr_list): Take extra parameter fold_p.  Fold\n+\texpressions if requested.\n+\t(c_parser_objc_type_name): Update call to groktypename.\n+\t(c_parser_objc_synchronized_statement): Fold expression.\n+\t(c_parser_objc_receiver): Fold expression.\n+\t(c_parser_objc_keywordexpr): Update call to c_parser_expr_list.\n+\t(c_parser_omp_clause_num_threads, c_parser_omp_clause_schedule,\n+\tc_parser_omp_atomic, c_parser_omp_for_loop): Fold expressions.\n+\t* c-tree.h (CONSTRUCTOR_NON_CONST): Define.\n+\t(struct c_typespec): Add elements expr and expr_const_operands.\n+\t(struct c_declspecs): Add elements expr and expr_const_operands.\n+\t(groktypename, build_conditional_expr, build_compound_literal):\n+\tUpdate prototypes.\n+\t(in_late_binary_op): Declare.\n+\t* c-typeck.c (note_integer_operands): New function.\n+\t(in_late_binary_op): New variable.\n+\t(decl_constant_value_for_broken_optimization): Move to c-common.c\n+\tand rename to decl_constant_value_for_optimization.\n+\t(default_function_array_conversion): Do not strip nops.\n+\t(default_conversion): Do not call\n+\tdecl_constant_value_for_broken_optimization.\n+\t(build_array_ref): Do not fold result.\n+\t(c_expr_sizeof_expr): Fold operand.  Use C_MAYBE_CONST_EXPR for\n+\tresult when operand is a VLA.\n+\t(c_expr_sizeof_type): Update call to groktypename.  Handle\n+\texpressions included in type name.  Use C_MAYBE_CONST_EXPR for\n+\tresult when operand names a VLA type.\n+\t(build_function_call): Update call to build_compound_literal.\n+\tOnly fold result for calls to __builtin_* functions.  Strip\n+\tNOP_EXPR from INTEGER_CST returned from such functions.  Fold\n+\tthe function designator.\n+\t(convert_arguments): Fold arguments.  Update call to\n+\tconvert_for_assignment.\n+\t(build_unary_op): Handle increment and decrement of\n+\tC_MAYBE_CONST_EXPR.  Move lvalue checks for increment and\n+\tdecrement earlier.  Fold operand of increment and decrement.\n+\tHandle address of C_MAYBE_CONST_EXPR.  Only fold expression being\n+\tbuilt for integer operand.  Wrap returns that are INTEGER_CSTs\n+\twithout being integer constant expressions or that have integer\n+\tconstant operands without being INTEGER_CSTs.\n+\t(lvalue_p): Handle C_MAYBE_CONST_EXPR.\n+\t(build_conditional_expr): Add operand ifexp_bcp.  Track whether\n+\tresult is an integer constant expression or can be used in\n+\tunevaluated parts of one and avoid folding and wrap as\n+\tappropriate.  Fold operands before possibly doing -Wsign-compare\n+\twarnings.\n+\t(build_compound_expr): Wrap result for C99 if operands can be used\n+\tin integer constant expressions.\n+\t(build_c_cast): Update call to digest_init.  Do not ignore\n+\toverflow from casting floating-point constants to integers.  Wrap\n+\tresults that could be confused with integer constant expressions,\n+\tnull pointer constants or floating-point constants.\n+\t(c_cast_expr): Update call to groktypename.  Handle expressions\n+\tincluded in type name.\n+\t(build_modify_expr): Handle modifying a C_MAYBE_CONST_EXPR.  Fold\n+\tlhs inside possible SAVE_EXPR.  Fold RHS before assignment.\n+\tUpdate calls to convert_for_assignment.\n+\t(convert_for_assignment): Take new parameter\n+\tnull_pointer_constant.  Do not strip nops or call\n+\tdecl_constant_value_for_broken_optimization.  Set\n+\tin_late_binary_op for conversions to boolean.\n+\t(store_init_value): Update call to digest_init.\n+\t(digest_init): Take new parameter null_pointer_constant.  Do not\n+\tcall decl_constant_value_for_broken_optimization.  pedwarn for\n+\tinitializers not constant expressions.  Update calls to\n+\tconvert_for_assignment.\n+\t(constructor_nonconst): New.\n+\t(struct constructor_stack): Add nonconst element.\n+\t(really_start_incremental_init, push_init_level, pop_init_level):\n+\tHandle constructor_nonconst and nonconst element.\n+\t(set_init_index): Call constant_expression_warning for array\n+\tdesignators.\n+\t(output_init_element): Fold value.  Set constructor_nonconst as\n+\tapplicable.  pedwarn for initializers not constant expressions.\n+\tUpdate call to digest_init.  Call constant_expression_warning\n+\twhere constant initializers are required.\n+\t(process_init_element): Use c_save_expr.\n+\t(c_finish_goto_ptr): Fold expression.\n+\t(c_finish_return): Fold return value.  Update call to\n+\tconvert_for_assignment.\n+\t(c_start_case): Fold switch expression.\n+\t(c_process_expr_stmt): Fold expression.\n+\t(c_finish_stmt_expr): Create C_MAYBE_CONST_EXPR as needed to\n+\tensure statement expression is not evaluated in constant\n+\texpression.\n+\t(build_binary_op): Track whether results are integer constant\n+\texpressions or may occur in such, disable folding and wrap results\n+\tas applicable.  Fold operands for -Wsign-compare warnings unless\n+\tin_late_binary_op.\n+\t(c_objc_common_truthvalue_conversion): Handle results folded to\n+\tinteger constants that are not integer constant expressions.\n+\t* doc/extend.texi: Document when typeof operands are evaluated,\n+\tthat condition of __builtin_choose_expr is an integer constant\n+\texpression, and more about use of __builtin_constant_p in\n+\tinitializers.\n+\n 2009-03-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Properly"}, {"sha": "e22c5f58964dd20bcb8581938e4888c584330af9", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -7930,7 +7930,7 @@ fold_builtin_sincos (tree arg0, tree arg1, tree arg2)\n   call = build_call_expr (fn, 1, arg0);\n   call = builtin_save_expr (call);\n \n-  return build2 (COMPOUND_EXPR, type,\n+  return build2 (COMPOUND_EXPR, void_type_node,\n \t\t build2 (MODIFY_EXPR, void_type_node,\n \t\t\t build_fold_indirect_ref (arg1),\n \t\t\t build1 (IMAGPART_EXPR, type, call)),\n@@ -10929,7 +10929,6 @@ fold_call_expr (tree exp, bool ignore)\n \t\t  if (CAN_HAVE_LOCATION_P (realret)\n \t\t      && !EXPR_HAS_LOCATION (realret))\n \t\t    SET_EXPR_LOCATION (realret, EXPR_LOCATION (exp));\n-\t\t  return realret;\n \t\t}\n \t      return ret;\n \t    }"}, {"sha": "c066e95695908e4ff353a87e9b863d298cef66c8", "filename": "gcc/c-common.c", "status": "modified", "additions": 424, "deletions": 7, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -518,6 +518,7 @@ const struct fname_var_t fname_vars[] =\n   {NULL, 0, 0},\n };\n \n+static tree c_fully_fold_internal (tree expr, bool, bool *, bool *);\n static tree check_case_value (tree);\n static bool check_case_bounds (tree, tree, tree *, tree *);\n \n@@ -1107,6 +1108,390 @@ fix_string_type (tree value)\n   return value;\n }\n \f\n+/* Fully fold EXPR, an expression that was not folded (beyond integer\n+   constant expressions and null pointer constants) when being built\n+   up.  If IN_INIT, this is in a static initializer and certain\n+   changes are made to the folding done.  Clear *MAYBE_CONST if\n+   MAYBE_CONST is not NULL and EXPR is definitely not a constant\n+   expression because it contains an evaluated operator (in C99) or an\n+   operator outside of sizeof returning an integer constant (in C90)\n+   not permitted in constant expressions, or because it contains an\n+   evaluated arithmetic overflow.  (*MAYBE_CONST should typically be\n+   set to true by callers before calling this function.)  Return the\n+   folded expression.  Function arguments have already been folded\n+   before calling this function, as have the contents of SAVE_EXPR,\n+   TARGET_EXPR, BIND_EXPR, VA_ARG_EXPR, OBJ_TYPE_REF and\n+   C_MAYBE_CONST_EXPR.  */\n+\n+tree\n+c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n+{\n+  tree ret;\n+  bool dummy = true;\n+  bool maybe_const_itself = true;\n+\n+  /* This function is not relevant to C++ because C++ folds while\n+     parsing, and may need changes to be correct for C++ when C++\n+     stops folding while parsing.  */\n+  if (c_dialect_cxx ())\n+    gcc_unreachable ();\n+\n+  if (!maybe_const)\n+    maybe_const = &dummy;\n+  ret = c_fully_fold_internal (expr, in_init, maybe_const,\n+\t\t\t       &maybe_const_itself);\n+  *maybe_const &= maybe_const_itself;\n+  return ret;\n+}\n+\n+/* Internal helper for c_fully_fold.  EXPR and IN_INIT are as for\n+   c_fully_fold.  *MAYBE_CONST_OPERANDS is cleared because of operands\n+   not permitted, while *MAYBE_CONST_ITSELF is cleared because of\n+   arithmetic overflow (for C90, *MAYBE_CONST_OPERANDS is carried from\n+   both evaluated and unevaluated subexpressions while\n+   *MAYBE_CONST_ITSELF is carried from only evaluated\n+   subexpressions).  */\n+\n+static tree\n+c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n+\t\t       bool *maybe_const_itself)\n+{\n+  tree ret = expr;\n+  enum tree_code code = TREE_CODE (expr);\n+  enum tree_code_class kind = TREE_CODE_CLASS (code);\n+  location_t loc = EXPR_LOCATION (expr);\n+  tree op0, op1, op2, op3;\n+  tree orig_op0, orig_op1, orig_op2;\n+  bool op0_const = true, op1_const = true, op2_const = true;\n+  bool op0_const_self = true, op1_const_self = true, op2_const_self = true;\n+  bool nowarning = TREE_NO_WARNING (expr);\n+\n+  /* This function is not relevant to C++ because C++ folds while\n+     parsing, and may need changes to be correct for C++ when C++\n+     stops folding while parsing.  */\n+  if (c_dialect_cxx ())\n+    gcc_unreachable ();\n+\n+  /* Constants, declarations, statements, errors, SAVE_EXPRs and\n+     anything else not counted as an expression cannot usefully be\n+     folded further at this point.  */\n+  if (!IS_EXPR_CODE_CLASS (kind)\n+      || kind == tcc_statement\n+      || code == SAVE_EXPR)\n+    return expr;\n+\n+  /* Operands of variable-length expressions (function calls) have\n+     already been folded, as have __builtin_* function calls, and such\n+     expressions cannot occur in constant expressions.  */\n+  if (kind == tcc_vl_exp)\n+    {\n+      *maybe_const_operands = false;\n+      ret = fold (expr);\n+      goto out;\n+    }\n+\n+  if (code == C_MAYBE_CONST_EXPR)\n+    {\n+      tree pre = C_MAYBE_CONST_EXPR_PRE (expr);\n+      tree inner = C_MAYBE_CONST_EXPR_EXPR (expr);\n+      if (C_MAYBE_CONST_EXPR_NON_CONST (expr))\n+\t*maybe_const_operands = false;\n+      if (C_MAYBE_CONST_EXPR_INT_OPERANDS (expr))\n+\t*maybe_const_itself = false;\n+      if (pre && !in_init)\n+\tret = build2 (COMPOUND_EXPR, TREE_TYPE (expr), pre, inner);\n+      else\n+\tret = inner;\n+      goto out;\n+    }\n+\n+  /* Assignment, increment, decrement, function call and comma\n+     operators, and statement expressions, cannot occur in constant\n+     expressions if evaluated / outside of sizeof.  (Function calls\n+     were handled above, though VA_ARG_EXPR is treated like a function\n+     call here, and statement expressions are handled through\n+     C_MAYBE_CONST_EXPR to avoid folding inside them.)  */\n+  switch (code)\n+    {\n+    case MODIFY_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case COMPOUND_EXPR:\n+      *maybe_const_operands = false;\n+      break;\n+\n+    case VA_ARG_EXPR:\n+    case TARGET_EXPR:\n+    case BIND_EXPR:\n+    case OBJ_TYPE_REF:\n+      *maybe_const_operands = false;\n+      ret = fold (expr);\n+      goto out;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Fold individual tree codes as appropriate.  */\n+  switch (code)\n+    {\n+    case COMPOUND_LITERAL_EXPR:\n+      /* Any non-constancy will have been marked in a containing\n+\t C_MAYBE_CONST_EXPR; there is no more folding to do here.  */\n+      goto out;\n+\n+    case COMPONENT_REF:\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      op1 = TREE_OPERAND (expr, 1);\n+      op2 = TREE_OPERAND (expr, 2);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself);\n+      if (op0 != orig_op0)\n+\tret = build3 (COMPONENT_REF, TREE_TYPE (expr), op0, op1, op2);\n+      if (ret != expr)\n+\t{\n+\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n+\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n+\t}\n+      goto out;\n+\n+    case ARRAY_REF:\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      op2 = TREE_OPERAND (expr, 2);\n+      op3 = TREE_OPERAND (expr, 3);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself);\n+      op1 = c_fully_fold_internal (op1, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself);\n+      op1 = decl_constant_value_for_optimization (op1);\n+      if (op0 != orig_op0 || op1 != orig_op1)\n+\tret = build4 (ARRAY_REF, TREE_TYPE (expr), op0, op1, op2, op3);\n+      if (ret != expr)\n+\t{\n+\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n+\t  TREE_SIDE_EFFECTS (ret) = TREE_SIDE_EFFECTS (expr);\n+\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n+\t}\n+      ret = fold (ret);\n+      goto out;\n+\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case COMPLEX_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+      /* Binary operations evaluating both arguments (increment and\n+\t decrement are binary internally in GCC).  */\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself);\n+      if (code != MODIFY_EXPR\n+\t  && code != PREDECREMENT_EXPR\n+\t  && code != PREINCREMENT_EXPR\n+\t  && code != POSTDECREMENT_EXPR\n+\t  && code != POSTINCREMENT_EXPR)\n+\top0 = decl_constant_value_for_optimization (op0);\n+      /* The RHS of a MODIFY_EXPR was fully folded when building that\n+\t expression for the sake of conversion warnings.  */\n+      if (code != MODIFY_EXPR)\n+\top1 = c_fully_fold_internal (op1, in_init, maybe_const_operands,\n+\t\t\t\t     maybe_const_itself);\n+      op1 = decl_constant_value_for_optimization (op1);\n+      if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n+\tret = in_init\n+\t  ? fold_build2_initializer (code, TREE_TYPE (expr), op0, op1)\n+\t  : fold_build2 (code, TREE_TYPE (expr), op0, op1);\n+      else\n+\tret = fold (expr);\n+      goto out;\n+\n+    case INDIRECT_REF:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case CONJ_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      /* Unary operations.  */\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      op0 = c_fully_fold_internal (op0, in_init, maybe_const_operands,\n+\t\t\t\t   maybe_const_itself);\n+      if (code != ADDR_EXPR && code != REALPART_EXPR && code != IMAGPART_EXPR)\n+\top0 = decl_constant_value_for_optimization (op0);\n+      if (op0 != orig_op0 || in_init)\n+\tret = in_init\n+\t  ? fold_build1_initializer (code, TREE_TYPE (expr), op0)\n+\t  : fold_build1 (code, TREE_TYPE (expr), op0);\n+      else\n+\tret = fold (expr);\n+      if (code == INDIRECT_REF\n+\t  && ret != expr\n+\t  && TREE_CODE (ret) == INDIRECT_REF)\n+\t{\n+\t  TREE_READONLY (ret) = TREE_READONLY (expr);\n+\t  TREE_SIDE_EFFECTS (ret) = TREE_SIDE_EFFECTS (expr);\n+\t  TREE_THIS_VOLATILE (ret) = TREE_THIS_VOLATILE (expr);\n+\t}\n+      goto out;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      /* Binary operations not necessarily evaluating both\n+\t arguments.  */\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      op0 = c_fully_fold_internal (op0, in_init, &op0_const, &op0_const_self);\n+      op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self);\n+      if (op0 != orig_op0 || op1 != orig_op1 || in_init)\n+\tret = in_init\n+\t  ? fold_build2_initializer (code, TREE_TYPE (expr), op0, op1)\n+\t  : fold_build2 (code, TREE_TYPE (expr), op0, op1);\n+      else\n+\tret = fold (expr);\n+      *maybe_const_operands &= op0_const;\n+      *maybe_const_itself &= op0_const_self;\n+      if (!(flag_isoc99\n+\t    && op0_const\n+\t    && op0_const_self\n+\t    && (code == TRUTH_ANDIF_EXPR\n+\t\t? op0 == truthvalue_false_node\n+\t\t: op0 == truthvalue_true_node)))\n+\t*maybe_const_operands &= op1_const;\n+      if (!(op0_const\n+\t    && op0_const_self\n+\t    && (code == TRUTH_ANDIF_EXPR\n+\t\t? op0 == truthvalue_false_node\n+\t\t: op0 == truthvalue_true_node)))\n+\t*maybe_const_itself &= op1_const_self;\n+      goto out;\n+\n+    case COND_EXPR:\n+      orig_op0 = op0 = TREE_OPERAND (expr, 0);\n+      orig_op1 = op1 = TREE_OPERAND (expr, 1);\n+      orig_op2 = op2 = TREE_OPERAND (expr, 2);\n+      op0 = c_fully_fold_internal (op0, in_init, &op0_const, &op0_const_self);\n+      op1 = c_fully_fold_internal (op1, in_init, &op1_const, &op1_const_self);\n+      op2 = c_fully_fold_internal (op2, in_init, &op2_const, &op2_const_self);\n+      if (op0 != orig_op0 || op1 != orig_op1 || op2 != orig_op2)\n+\tret = fold_build3 (code, TREE_TYPE (expr), op0, op1, op2);\n+      else\n+\tret = fold (expr);\n+      *maybe_const_operands &= op0_const;\n+      *maybe_const_itself &= op0_const_self;\n+      if (!(flag_isoc99\n+\t    && op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_false_node))\n+\t*maybe_const_operands &= op1_const;\n+      if (!(op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_false_node))\n+\t*maybe_const_itself &= op1_const_self;\n+      if (!(flag_isoc99\n+\t    && op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_true_node))\n+\t*maybe_const_operands &= op2_const;\n+      if (!(op0_const\n+\t    && op0_const_self\n+\t    && op0 == truthvalue_true_node))\n+\t*maybe_const_itself &= op2_const_self;\n+      goto out;\n+\n+    default:\n+      /* Various codes may appear through folding built-in functions\n+\t and their arguments.  */\n+      goto out;\n+    }\n+\n+ out:\n+  /* Some folding may introduce NON_LVALUE_EXPRs; all lvalue checks\n+     have been done by this point, so remove them again.  */\n+  nowarning |= TREE_NO_WARNING (ret);\n+  STRIP_TYPE_NOPS (ret);\n+  if (nowarning && !TREE_NO_WARNING (ret))\n+    {\n+      if (!CAN_HAVE_LOCATION_P (ret))\n+\tret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n+      TREE_NO_WARNING (ret) = 1;\n+    }\n+  if (ret != expr)\n+    protected_set_expr_location (ret, loc);\n+  return ret;\n+}\n+\n+/* If not optimizing, EXP is not a VAR_DECL, or EXP has array type,\n+   return EXP.  Otherwise, return either EXP or its known constant\n+   value (if it has one), but return EXP if EXP has mode BLKmode.  ???\n+   Is the BLKmode test appropriate?  */\n+\n+tree\n+decl_constant_value_for_optimization (tree exp)\n+{\n+  tree ret;\n+\n+  /* This function is only used by C, for c_fully_fold and other\n+     optimization, and may not be correct for C++.  */\n+  if (c_dialect_cxx ())\n+    gcc_unreachable ();\n+\n+  if (!optimize\n+      || TREE_CODE (exp) != VAR_DECL\n+      || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n+      || DECL_MODE (exp) == BLKmode)\n+    return exp;\n+\n+  ret = decl_constant_value (exp);\n+  /* Avoid unwanted tree sharing between the initializer and current\n+     function's body where the tree can be modified e.g. by the\n+     gimplifier.  */\n+  if (ret != exp && TREE_STATIC (exp))\n+    ret = unshare_expr (ret);\n+  return ret;\n+}\n+\n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n    requires to be a constant expression.\n@@ -3328,6 +3713,27 @@ pointer_int_sum (location_t location, enum tree_code resultcode,\n   return ret;\n }\n \f\n+/* Wrap a SAVE_EXPR around EXPR, if appropriate.  Like save_expr, but\n+   for C folds the inside expression and wraps a C_MAYBE_CONST_EXPR\n+   around the SAVE_EXPR if needed so that c_fully_fold does not need\n+   to look inside SAVE_EXPRs.  */\n+\n+tree\n+c_save_expr (tree expr)\n+{\n+  bool maybe_const = true;\n+  if (c_dialect_cxx ())\n+    return save_expr (expr);\n+  expr = c_fully_fold (expr, false, &maybe_const);\n+  expr = save_expr (expr);\n+  if (!maybe_const)\n+    {\n+      expr = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (expr), NULL, expr);\n+      C_MAYBE_CONST_EXPR_NON_CONST (expr) = 1;\n+    }\n+  return expr;\n+}\n+\n /* Return whether EXPR is a declaration whose address can never be\n    NULL.  */\n \n@@ -3470,12 +3876,23 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold_build3 (COND_EXPR, truthvalue_type_node,\n-\t\tTREE_OPERAND (expr, 0),\n-\t\tc_common_truthvalue_conversion (location,\n-\t\t\t\t\t\tTREE_OPERAND (expr, 1)),\n-\t\tc_common_truthvalue_conversion (location,\n-\t\t\t\t\t\tTREE_OPERAND (expr, 2)));\n+      if (c_dialect_cxx ())\n+\treturn fold_build3 (COND_EXPR, truthvalue_type_node,\n+\t\t\t    TREE_OPERAND (expr, 0),\n+\t\t\t    c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t\t    TREE_OPERAND (expr,\n+\t\t\t\t\t\t\t\t\t  1)),\n+\t\t\t    c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t\t    TREE_OPERAND (expr,\n+\t\t\t\t\t\t\t\t\t  2)));\n+      else\n+\t/* Folding will happen later for C.  */\n+\treturn build3 (COND_EXPR, truthvalue_type_node,\n+\t\t       TREE_OPERAND (expr, 0),\n+\t\t       c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t       TREE_OPERAND (expr, 1)),\n+\t\t       c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t       TREE_OPERAND (expr, 2)));\n \n     CASE_CONVERT:\n       /* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE,\n@@ -3506,7 +3923,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \n   if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE)\n     {\n-      tree t = save_expr (expr);\n+      tree t = c_save_expr (expr);\n       return (build_binary_op\n \t      (EXPR_LOCATION (expr),\n \t       (TREE_SIDE_EFFECTS (expr)"}, {"sha": "3080fd3cee8b548f2549b15bb1af857169b4496d", "filename": "gcc/c-common.def", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -2,7 +2,7 @@\n    additional tree codes used in the GNU C compiler (see tree.def\n    for the standard codes).\n    Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998,\n-   1999, 2000, 2001, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n    Written by Benjamin Chelf <chelf@codesourcery.com>\n \n This file is part of GCC.\n@@ -31,6 +31,21 @@ along with GCC; see the file COPYING3.  If not see\n    the compound literal.  */\n DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", tcc_expression, 1)\n \n+/* A C_MAYBE_CONST_EXPR, currently only used for C and Objective C,\n+   tracks information about constancy of an expression and VLA type\n+   sizes or VM expressions from typeof that need to be evaluated\n+   before the main expression.  It is used during parsing and removed\n+   in c_fully_fold.  C_MAYBE_CONST_EXPR_PRE is the expression to\n+   evaluate first, if not NULL; C_MAYBE_CONST_EXPR_EXPR is the main\n+   expression.  If C_MAYBE_CONST_EXPR_INT_OPERANDS is set then the\n+   expression may be used in an unevaluated part of an integer\n+   constant expression, but not in an evaluated part.  If\n+   C_MAYBE_CONST_EXPR_NON_CONST is set then the expression contains\n+   something that cannot occur in an evaluated part of a constant\n+   expression (or outside of sizeof in C90 mode); otherwise it does\n+   not.  */\n+DEFTREECODE (C_MAYBE_CONST_EXPR, \"c_maybe_const_expr\", tcc_expression, 2)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "ce8b23826ce1ec3221fa568ce047b8a840f14683", "filename": "gcc/c-common.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for c-common.c.\n    Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -30,8 +30,10 @@ along with GCC; see the file COPYING3.  If not see\n    0: TREE_NEGATED_INT (in INTEGER_CST).\n       IDENTIFIER_MARKED (used by search routines).\n       DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n+      C_MAYBE_CONST_EXPR_INT_OPERANDS (in C_MAYBE_CONST_EXPR, for C)\n    1: C_DECLARED_LABEL_FLAG (in LABEL_DECL)\n       STATEMENT_LIST_STMT_EXPR (in STATEMENT_LIST)\n+      C_MAYBE_CONST_EXPR_NON_CONST (in C_MAYBE_CONST_EXPR, for C)\n    2: unused\n    3: STATEMENT_LIST_HAS_LABEL (in STATEMENT_LIST)\n    4: unused\n@@ -715,6 +717,9 @@ extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);\n extern tree c_build_bitfield_integer_type (unsigned HOST_WIDE_INT, int);\n extern bool decl_with_nonnull_addr_p (const_tree);\n+extern tree c_fully_fold (tree, bool, bool *);\n+extern tree decl_constant_value_for_optimization (tree);\n+extern tree c_save_expr (tree);\n extern tree c_common_truthvalue_conversion (location_t, tree);\n extern void c_apply_type_quals_to_decl (int, tree);\n extern tree c_sizeof_or_alignof_type (tree, bool, int);\n@@ -799,6 +804,21 @@ extern void finish_file\t(void);\n #define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n   DECL_EXPR_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n \n+/* C_MAYBE_CONST_EXPR accessors.  */\n+#define C_MAYBE_CONST_EXPR_PRE(NODE)\t\t\t\\\n+  TREE_OPERAND (C_MAYBE_CONST_EXPR_CHECK (NODE), 0)\n+#define C_MAYBE_CONST_EXPR_EXPR(NODE)\t\t\t\\\n+  TREE_OPERAND (C_MAYBE_CONST_EXPR_CHECK (NODE), 1)\n+#define C_MAYBE_CONST_EXPR_INT_OPERANDS(NODE)\t\t\\\n+  TREE_LANG_FLAG_0 (C_MAYBE_CONST_EXPR_CHECK (NODE))\n+#define C_MAYBE_CONST_EXPR_NON_CONST(NODE)\t\t\\\n+  TREE_LANG_FLAG_1 (C_MAYBE_CONST_EXPR_CHECK (NODE))\n+#define EXPR_INT_CONST_OPERANDS(EXPR)\t\t\t\\\n+  (INTEGRAL_TYPE_P (TREE_TYPE (EXPR))\t\t\t\\\n+   && (TREE_CODE (EXPR) == INTEGER_CST\t\t\t\\\n+       || (TREE_CODE (EXPR) == C_MAYBE_CONST_EXPR\t\\\n+\t   && C_MAYBE_CONST_EXPR_INT_OPERANDS (EXPR))))\n+\n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n #define DECL_C_BIT_FIELD(NODE) \\\n   (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)"}, {"sha": "f6bf5deb8939debacc1819d0a0dc526b9de61274", "filename": "gcc/c-convert.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,6 +1,6 @@\n /* Language-level data type conversion for GNU C.\n-   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2003, 2004, 2005, 2007, 2008\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2003, 2004, 2005, 2007, 2008,\n+   2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -86,6 +86,8 @@ convert (tree type, tree expr)\n   if (type == TREE_TYPE (expr))\n     return expr;\n \n+  STRIP_TYPE_NOPS (e);\n+\n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n     return fold_convert (type, expr);\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)"}, {"sha": "588b75c5527fee548f5e949a9e99a8e70694c959", "filename": "gcc/c-decl.c", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -410,8 +410,8 @@ static tree lookup_name_in_scope (tree, struct c_scope *);\n static tree c_make_fname_decl (tree, int);\n static tree grokdeclarator (const struct c_declarator *,\n \t\t\t    struct c_declspecs *,\n-\t\t\t    enum decl_context, bool, tree *, tree *,\n-\t\t\t    enum deprecated_states);\n+\t\t\t    enum decl_context, bool, tree *, tree *, tree *,\n+\t\t\t    bool *, enum deprecated_states);\n static tree grokparms (struct c_arg_info *, bool);\n static void layout_array_type (tree);\n \f\n@@ -3128,18 +3128,24 @@ add_flexible_array_elts_to_size (tree decl, tree init)\n     }\n }\n \f\n-/* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n+/* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.\n+   Set *EXPR, if EXPR not NULL, to any expression to be evaluated\n+   before the type name, and set *EXPR_CONST_OPERANDS, if\n+   EXPR_CONST_OPERANDS not NULL, to indicate whether the type name may\n+   appear in a constant expression.  */\n \n tree\n-groktypename (struct c_type_name *type_name)\n+groktypename (struct c_type_name *type_name, tree *expr,\n+\t      bool *expr_const_operands)\n {\n   tree type;\n   tree attrs = type_name->specs->attrs;\n \n   type_name->specs->attrs = NULL_TREE;\n \n   type = grokdeclarator (type_name->declarator, type_name->specs, TYPENAME,\n-\t\t\t false, NULL, &attrs, DEPRECATED_NORMAL);\n+\t\t\t false, NULL, &attrs, expr, expr_const_operands,\n+\t\t\t DEPRECATED_NORMAL);\n \n   /* Apply attributes.  */\n   decl_attributes (&type, attrs, 0);\n@@ -3168,6 +3174,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n {\n   tree decl;\n   tree tem;\n+  tree expr = NULL_TREE;\n   enum deprecated_states deprecated_state = DEPRECATED_NORMAL;\n \n   /* An object declared as __attribute__((deprecated)) suppresses\n@@ -3176,11 +3183,14 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n     deprecated_state = DEPRECATED_SUPPRESS;\n \n   decl = grokdeclarator (declarator, declspecs,\n-\t\t\t NORMAL, initialized, NULL, &attributes,\n+\t\t\t NORMAL, initialized, NULL, &attributes, &expr, NULL,\n \t\t\t deprecated_state);\n   if (!decl)\n     return 0;\n \n+  if (expr)\n+    add_stmt (expr);\n+\n   if (TREE_CODE (decl) != FUNCTION_DECL && MAIN_NAME_P (DECL_NAME (decl)))\n     warning (OPT_Wmain, \"%q+D is usually a function\", decl);\n \n@@ -3668,7 +3678,7 @@ grokparm (const struct c_parm *parm)\n {\n   tree attrs = parm->attrs;\n   tree decl = grokdeclarator (parm->declarator, parm->specs, PARM, false,\n-\t\t\t      NULL, &attrs, DEPRECATED_NORMAL);\n+\t\t\t      NULL, &attrs, NULL, NULL, DEPRECATED_NORMAL);\n \n   decl_attributes (&decl, attrs, 0);\n \n@@ -3685,7 +3695,7 @@ push_parm_decl (const struct c_parm *parm)\n   tree decl;\n \n   decl = grokdeclarator (parm->declarator, parm->specs, PARM, false, NULL,\n-\t\t\t &attrs, DEPRECATED_NORMAL);\n+\t\t\t &attrs, NULL, NULL, DEPRECATED_NORMAL);\n   decl_attributes (&decl, attrs, 0);\n \n   decl = pushdecl (decl);\n@@ -3716,10 +3726,11 @@ mark_forward_parm_decls (void)\n /* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound\n    literal, which may be an incomplete array type completed by the\n    initializer; INIT is a CONSTRUCTOR that initializes the compound\n-   literal.  */\n+   literal.  NON_CONST is true if the initializers contain something\n+   that cannot occur in a constant expression.  */\n \n tree\n-build_compound_literal (tree type, tree init)\n+build_compound_literal (tree type, tree init, bool non_const)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n@@ -3772,6 +3783,12 @@ build_compound_literal (tree type, tree init)\n       rest_of_decl_compilation (decl, 1, 0);\n     }\n \n+  if (non_const)\n+    {\n+      complit = build2 (C_MAYBE_CONST_EXPR, type, NULL, complit);\n+      C_MAYBE_CONST_EXPR_NON_CONST (complit) = 1;\n+    }\n+\n   return complit;\n }\n \f\n@@ -3958,6 +3975,11 @@ warn_variable_length_array (const char *name, tree size)\n    DECL_ATTRS points to the list of attributes that should be added to this\n      decl.  Any nested attributes that belong on the decl itself will be\n      added to this list.\n+   If EXPR is not NULL, any expressions that need to be evaluated as\n+     part of evaluating variably modified types will be stored in *EXPR.\n+   If EXPR_CONST_OPERANDS is not NULL, *EXPR_CONST_OPERANDS will be\n+     set to indicate whether operands in *EXPR can be used in constant\n+     expressions.\n    DEPRECATED_STATE is a deprecated_states value indicating whether\n    deprecation warnings should be suppressed.\n \n@@ -3972,7 +3994,8 @@ static tree\n grokdeclarator (const struct c_declarator *declarator,\n \t\tstruct c_declspecs *declspecs,\n \t\tenum decl_context decl_context, bool initialized, tree *width,\n-\t\ttree *decl_attrs, enum deprecated_states deprecated_state)\n+\t\ttree *decl_attrs, tree *expr, bool *expr_const_operands,\n+\t\tenum deprecated_states deprecated_state)\n {\n   tree type = declspecs->type;\n   bool threadp = declspecs->thread_p;\n@@ -3994,6 +4017,16 @@ grokdeclarator (const struct c_declarator *declarator,\n   bool bitfield = width != NULL;\n   tree element_type;\n   struct c_arg_info *arg_info = 0;\n+  tree expr_dummy;\n+  bool expr_const_operands_dummy;\n+\n+  if (expr == NULL)\n+    expr = &expr_dummy;\n+  if (expr_const_operands == NULL)\n+    expr_const_operands = &expr_const_operands_dummy;\n+\n+  *expr = declspecs->expr;\n+  *expr_const_operands = declspecs->expr_const_operands;\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = true, decl_context = NORMAL;\n@@ -4306,6 +4339,11 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t    if (size)\n \t      {\n+\t\tbool size_maybe_const = true;\n+\t\tbool size_int_const = (TREE_CODE (size) == INTEGER_CST\n+\t\t\t\t       && !TREE_OVERFLOW (size));\n+\t\tbool this_size_varies = false;\n+\n \t\t/* Strip NON_LVALUE_EXPRs since we aren't using as an\n \t\t   lvalue.  */\n \t\tSTRIP_TYPE_NOPS (size);\n@@ -4316,18 +4354,27 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    size = integer_one_node;\n \t\t  }\n \n-\t\tif (pedantic && integer_zerop (size))\n+\t\tsize = c_fully_fold (size, false, &size_maybe_const);\n+\n+\t\tif (pedantic && size_maybe_const && integer_zerop (size))\n \t\t  pedwarn (input_location, OPT_pedantic,\n \t\t\t   \"ISO C forbids zero-size array %qs\", name);\n \n-\t\tif (TREE_CODE (size) == INTEGER_CST)\n+\t\tif (TREE_CODE (size) == INTEGER_CST && size_maybe_const)\n \t\t  {\n \t\t    constant_expression_warning (size);\n \t\t    if (tree_int_cst_sgn (size) < 0)\n \t\t      {\n \t\t\terror (\"size of array %qs is negative\", name);\n \t\t\tsize = integer_one_node;\n \t\t      }\n+\t\t    /* Handle a size folded to an integer constant but\n+\t\t       not an integer constant expression.  */\n+\t\t    if (!size_int_const)\n+\t\t      {\n+\t\t\tthis_size_varies = size_varies = 1;\n+\t\t\twarn_variable_length_array (orig_name, size);\n+\t\t      }\n \t\t  }\n \t\telse if ((decl_context == NORMAL || decl_context == FIELD)\n \t\t\t && current_scope == file_scope)\n@@ -4340,11 +4387,11 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    /* Make sure the array size remains visibly\n \t\t       nonconstant even if it is (eg) a const variable\n \t\t       with known value.  */\n-\t\t    size_varies = 1;\n+\t\t    this_size_varies = size_varies = 1;\n \t\t    warn_variable_length_array (orig_name, size);\n \t\t  }\n \n-\t\tif (integer_zerop (size))\n+\t\tif (integer_zerop (size) && !this_size_varies)\n \t\t  {\n \t\t    /* A zero-length array cannot be represented with\n \t\t       an unsigned index type, which is what we'll\n@@ -4359,6 +4406,9 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       with the +1 that happens when building TYPE_SIZE.  */\n \t\t    if (size_varies)\n \t\t      size = variable_size (size);\n+\t\t    if (this_size_varies && TREE_CODE (size) == INTEGER_CST)\n+\t\t      size = build2 (COMPOUND_EXPR, TREE_TYPE (size),\n+\t\t\t\t     integer_zero_node, size);\n \n \t\t    /* Compute the maximum valid index, that is, size\n \t\t       - 1.  Do the calculation in index_type, so that\n@@ -4386,6 +4436,15 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t\t    itype = build_index_type (itype);\n \t\t  }\n+\t\tif (this_size_varies)\n+\t\t  {\n+\t\t    if (*expr)\n+\t\t      *expr = build2 (COMPOUND_EXPR, TREE_TYPE (size),\n+\t\t\t\t      *expr, size);\n+\t\t    else\n+\t\t      *expr = size;\n+\t\t    *expr_const_operands &= size_maybe_const;\n+\t\t  }\n \t      }\n \t    else if (decl_context == FIELD)\n \t      {\n@@ -5288,10 +5347,15 @@ struct c_typespec\n parser_xref_tag (enum tree_code code, tree name)\n {\n   struct c_typespec ret;\n+  tree ref;\n+\n+  ret.expr = NULL_TREE;\n+  ret.expr_const_operands = true;\n+\n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n \n-  tree ref = lookup_tag (code, name, 0);\n+  ref = lookup_tag (code, name, 0);\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n@@ -5460,7 +5524,7 @@ grokfield (location_t loc,\n     }\n \n   value = grokdeclarator (declarator, declspecs, FIELD, false,\n-\t\t\t  width ? &width : NULL, decl_attrs,\n+\t\t\t  width ? &width : NULL, decl_attrs, NULL, NULL,\n \t\t\t  DEPRECATED_NORMAL);\n \n   finish_decl (value, NULL_TREE, NULL_TREE);\n@@ -6119,7 +6183,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   c_break_label = c_cont_label = size_zero_node;\n \n   decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, true, NULL,\n-\t\t\t  &attributes, DEPRECATED_NORMAL);\n+\t\t\t  &attributes, NULL, NULL, DEPRECATED_NORMAL);\n \n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */\n@@ -7132,10 +7196,12 @@ build_null_declspecs (void)\n {\n   struct c_declspecs *ret = XOBNEW (&parser_obstack, struct c_declspecs);\n   ret->type = 0;\n+  ret->expr = 0;\n   ret->decl_attr = 0;\n   ret->attrs = 0;\n   ret->typespec_word = cts_none;\n   ret->storage_class = csc_none;\n+  ret->expr_const_operands = true;\n   ret->declspecs_seen_p = false;\n   ret->type_seen_p = false;\n   ret->non_sc_seen_p = false;\n@@ -7657,7 +7723,18 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n       if (spec.kind == ctsk_tagdef || spec.kind == ctsk_tagfirstref)\n \tspecs->tag_defined_p = true;\n       if (spec.kind == ctsk_typeof)\n-\tspecs->typedef_p = true;\n+\t{\n+\t  specs->typedef_p = true;\n+\t  if (spec.expr)\n+\t    {\n+\t      if (specs->expr)\n+\t\tspecs->expr = build2 (COMPOUND_EXPR, TREE_TYPE (spec.expr),\n+\t\t\t\t      specs->expr, spec.expr);\n+\t      else\n+\t\tspecs->expr = spec.expr;\n+\t      specs->expr_const_operands &= spec.expr_const_operands;\n+\t    }\n+\t}\n       specs->type = type;\n     }\n "}, {"sha": "4d1b4d51395bfe3ab6d323fbfd0128c32b67d45d", "filename": "gcc/c-parser.c", "status": "modified", "additions": 107, "deletions": 42, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -915,7 +915,7 @@ static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n \t\t\t\t\t\t\t\tstruct c_expr);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n-static tree c_parser_expr_list (c_parser *, bool);\n+static tree c_parser_expr_list (c_parser *, bool, bool);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -1455,6 +1455,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      /* For a typedef name, record the meaning, not the name.\n \t\t In case of 'foo foo, bar;'.  */\n \t      t.spec = lookup_name (value);\n+\t      t.expr = NULL_TREE;\n+\t      t.expr_const_operands = true;\n \t    }\n \t  else\n \t    {\n@@ -1464,6 +1466,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t      if (c_parser_next_token_is (parser, CPP_LESS))\n \t\tproto = c_parser_objc_protocol_refs (parser);\n \t      t.spec = objc_get_protocol_qualified_type (value, proto);\n+\t      t.expr = NULL_TREE;\n+\t      t.expr_const_operands = true;\n \t    }\n \t  declspecs_add_type (specs, t);\n \t  continue;\n@@ -1479,6 +1483,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  proto = c_parser_objc_protocol_refs (parser);\n \t  t.kind = ctsk_objc;\n \t  t.spec = objc_get_protocol_qualified_type (NULL_TREE, proto);\n+\t  t.expr = NULL_TREE;\n+\t  t.expr_const_operands = true;\n \t  declspecs_add_type (specs, t);\n \t  continue;\n \t}\n@@ -1526,6 +1532,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t    parser->objc_need_raw_identifier = true;\n \t  t.kind = ctsk_resword;\n \t  t.spec = c_parser_peek_token (parser)->value;\n+\t  t.expr = NULL_TREE;\n+\t  t.expr_const_operands = true;\n \t  declspecs_add_type (specs, t);\n \t  c_parser_consume_token (parser);\n \t  break;\n@@ -1687,13 +1695,17 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.spec = finish_enum (type, nreverse (values),\n \t\t\t      chainon (attrs, postfix_attrs));\n       ret.kind = ctsk_tagdef;\n+      ret.expr = NULL_TREE;\n+      ret.expr_const_operands = true;\n       return ret;\n     }\n   else if (!ident)\n     {\n       c_parser_error (parser, \"expected %<{%>\");\n       ret.spec = error_mark_node;\n       ret.kind = ctsk_tagref;\n+      ret.expr = NULL_TREE;\n+      ret.expr_const_operands = true;\n       return ret;\n     }\n   ret = parser_xref_tag (ENUMERAL_TYPE, ident);\n@@ -1870,13 +1882,17 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.spec = finish_struct (type, nreverse (contents),\n \t\t\t\tchainon (attrs, postfix_attrs));\n       ret.kind = ctsk_tagdef;\n+      ret.expr = NULL_TREE;\n+      ret.expr_const_operands = true;\n       return ret;\n     }\n   else if (!ident)\n     {\n       c_parser_error (parser, \"expected %<{%>\");\n       ret.spec = error_mark_node;\n       ret.kind = ctsk_tagref;\n+      ret.expr = NULL_TREE;\n+      ret.expr_const_operands = true;\n       return ret;\n     }\n   ret = parser_xref_tag (code, ident);\n@@ -2053,6 +2069,8 @@ c_parser_typeof_specifier (c_parser *parser)\n   struct c_typespec ret;\n   ret.kind = ctsk_typeof;\n   ret.spec = error_mark_node;\n+  ret.expr = NULL_TREE;\n+  ret.expr_const_operands = true;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_TYPEOF));\n   c_parser_consume_token (parser);\n   skip_evaluation++;\n@@ -2070,7 +2088,7 @@ c_parser_typeof_specifier (c_parser *parser)\n       in_typeof--;\n       if (type != NULL)\n \t{\n-\t  ret.spec = groktypename (type);\n+\t  ret.spec = groktypename (type, &ret.expr, &ret.expr_const_operands);\n \t  pop_maybe_used (variably_modified_type_p (ret.spec, NULL_TREE));\n \t}\n     }\n@@ -2086,22 +2104,10 @@ c_parser_typeof_specifier (c_parser *parser)\n \terror_at (here, \"%<typeof%> applied to a bit-field\");\n       ret.spec = TREE_TYPE (expr.value);\n       was_vm = variably_modified_type_p (ret.spec, NULL_TREE);\n-      /* This should be returned with the type so that when the type\n-\t is evaluated, this can be evaluated.  For now, we avoid\n-\t evaluation when the context might.  */\n-      if (!skip_evaluation && was_vm)\n-\t{\n-\t  tree e = expr.value;\n-\n-\t  /* If the expression is not of a type to which we cannot assign a line\n-\t     number, wrap the thing in a no-op NOP_EXPR.  */\n-\t  if (DECL_P (e) || CONSTANT_CLASS_P (e))\n-\t    e = build1 (NOP_EXPR, void_type_node, e);\n-\n-\t  protected_set_expr_location (e, here);\n-\n-\t  add_stmt (e);\n-\t}\n+      /* This is returned with the type so that when the type is\n+\t evaluated, this can be evaluated.  */\n+      if (was_vm)\n+\tret.expr = c_fully_fold (expr.value, false, &ret.expr_const_operands);\n       pop_maybe_used (was_vm);\n     }\n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -2858,15 +2864,16 @@ c_parser_attributes (c_parser *parser)\n \t\t{\n \t\t  c_parser_consume_token (parser);\n \t\t  attr_args = tree_cons (NULL_TREE, arg1,\n-\t\t\t\t\t c_parser_expr_list (parser, false));\n+\t\t\t\t\t c_parser_expr_list (parser, false,\n+\t\t\t\t\t\t\t     true));\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t\tattr_args = NULL_TREE;\n \t      else\n-\t\tattr_args = c_parser_expr_list (parser, false);\n+\t\tattr_args = c_parser_expr_list (parser, false, true);\n \t    }\n \t  attr = build_tree_list (attr_name, attr_args);\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -3748,8 +3755,9 @@ c_parser_statement_after_labels (c_parser *parser)\n \t    }\n \t  else\n \t    {\n-\t      stmt\n-\t\t= objc_build_throw_stmt (c_parser_expression (parser).value);\n+\t      tree expr = c_parser_expression (parser).value;\n+\t      expr = c_fully_fold (expr, false, NULL);\n+\t      stmt = objc_build_throw_stmt (expr);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -3810,8 +3818,9 @@ c_parser_condition (c_parser *parser)\n   location_t loc;\n   tree cond;\n   loc = c_parser_peek_token (parser)->location;\n-  cond = c_objc_common_truthvalue_conversion \n-    (loc, c_parser_expression_conv (parser).value);\n+  cond = c_parser_expression_conv (parser).value;\n+  cond = c_objc_common_truthvalue_conversion (loc, cond);\n+  cond = c_fully_fold (cond, false, NULL);\n   protected_set_expr_location (cond, loc);\n   if (warn_sequence_point)\n     verify_sequence_points (cond);\n@@ -4304,6 +4313,7 @@ c_parser_asm_operands (c_parser *parser, bool convert_p)\n       expr = c_parser_expression (parser);\n       if (convert_p)\n \texpr = default_function_array_conversion (expr);\n+      expr.value = c_fully_fold (expr.value, false, NULL);\n       parser->lex_untranslated_string = true;\n       if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n \t{\n@@ -4458,7 +4468,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n \t       \"ISO C forbids omitting the middle term of a ?: expression\");\n       /* Make sure first operand is calculated only once.  */\n-      exp1.value = save_expr (default_conversion (cond.value));\n+      exp1.value = c_save_expr (default_conversion (cond.value));\n       cond.value = c_objc_common_truthvalue_conversion (cond_loc, exp1.value);\n       skip_evaluation += cond.value == truthvalue_true_node;\n     }\n@@ -4482,7 +4492,9 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   exp2 = c_parser_conditional_expression (parser, NULL);\n   exp2 = default_function_array_conversion (exp2);\n   skip_evaluation -= cond.value == truthvalue_true_node;\n-  ret.value = build_conditional_expr (cond.value, exp1.value, exp2.value);\n+  ret.value = build_conditional_expr (cond.value,\n+\t\t\t\t      cond.original_code == C_MAYBE_CONST_EXPR,\n+\t\t\t\t      exp1.value, exp2.value);\n   ret.original_code = ERROR_MARK;\n   return ret;\n }\n@@ -5012,7 +5024,7 @@ c_parser_alignof_expression (c_parser *parser)\n       /* alignof ( type-name ).  */\n       skip_evaluation--;\n       in_alignof--;\n-      ret.value = c_alignof (groktypename (type_name));\n+      ret.value = c_alignof (groktypename (type_name, NULL, NULL));\n       ret.original_code = ERROR_MARK;\n       return ret;\n     }\n@@ -5200,7 +5212,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  expr = c_parser_expression (parser);\n \t  if (TREE_CODE (expr.value) == MODIFY_EXPR)\n \t    TREE_NO_WARNING (expr.value) = 1;\n-\t  expr.original_code = ERROR_MARK;\n+\t  if (expr.original_code != C_MAYBE_CONST_EXPR)\n+\t    expr.original_code = ERROR_MARK;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t}\n@@ -5226,6 +5239,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t      break;\n \t    }\n \t  e1 = c_parser_expr_no_commas (parser, NULL);\n+\t  e1.value = c_fully_fold (e1.value, false, NULL);\n \t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n \t    {\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n@@ -5243,7 +5257,17 @@ c_parser_postfix_expression (c_parser *parser)\n \t    }\n \t  else\n \t    {\n-\t      expr.value = build_va_arg (e1.value, groktypename (t1));\n+\t      tree type_expr = NULL_TREE;\n+\t      expr.value = build_va_arg (e1.value, groktypename (t1,\n+\t\t\t\t\t\t\t\t &type_expr,\n+\t\t\t\t\t\t\t\t NULL));\n+\t      if (type_expr)\n+\t\t{\n+\t\t  expr.value = build2 (C_MAYBE_CONST_EXPR,\n+\t\t\t\t       TREE_TYPE (expr.value), type_expr,\n+\t\t\t\t       expr.value);\n+\t\t  C_MAYBE_CONST_EXPR_NON_CONST (expr.value) = true;\n+\t\t}\n \t      expr.original_code = ERROR_MARK;\n \t    }\n \t  break;\n@@ -5270,7 +5294,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t      break;\n \t    }\n \t  {\n-\t    tree type = groktypename (t1);\n+\t    tree type = groktypename (t1, NULL, NULL);\n \t    tree offsetof_ref;\n \t    if (type == error_mark_node)\n \t      offsetof_ref = error_mark_node;\n@@ -5319,6 +5343,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\tloc = c_parser_peek_token (parser)->location;\n \t\t\tc_parser_consume_token (parser);\n \t\t\tidx = c_parser_expression (parser).value;\n+\t\t\tidx = c_fully_fold (idx, false, NULL);\n \t\t\tc_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t\t   \"expected %<]%>\");\n \t\t\toffsetof_ref = build_array_ref (offsetof_ref, idx, loc);\n@@ -5365,10 +5390,12 @@ c_parser_postfix_expression (c_parser *parser)\n \t    tree c;\n \n \t    c = fold (e1.value);\n-\t    if (TREE_CODE (c) != INTEGER_CST)\n+\t    if (TREE_CODE (c) != INTEGER_CST\n+\t\t|| !INTEGRAL_TYPE_P (TREE_TYPE (c)))\n \t      error_at (loc,\n \t\t\t\"first argument to %<__builtin_choose_expr%> not\"\n \t\t\t\" a constant\");\n+\t    constant_expression_warning (c);\n \t    expr = integer_zerop (c) ? e3 : e2;\n \t  }\n \t  break;\n@@ -5406,8 +5433,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  {\n \t    tree e1, e2;\n \n-\t    e1 = TYPE_MAIN_VARIANT (groktypename (t1));\n-\t    e2 = TYPE_MAIN_VARIANT (groktypename (t2));\n+\t    e1 = TYPE_MAIN_VARIANT (groktypename (t1, NULL, NULL));\n+\t    e2 = TYPE_MAIN_VARIANT (groktypename (t2, NULL, NULL));\n \n \t    expr.value = comptypes (e1, e2)\n \t      ? build_int_cst (NULL_TREE, 1)\n@@ -5479,7 +5506,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  {\n-\t    tree type = groktypename (t1);\n+\t    tree type = groktypename (t1, NULL, NULL);\n \t    expr.value = objc_build_encode_expr (type);\n \t    expr.original_code = ERROR_MARK;\n \t  }\n@@ -5529,10 +5556,13 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n {\n   tree type;\n   struct c_expr init;\n+  bool non_const;\n   struct c_expr expr;\n   location_t start_loc;\n+  tree type_expr = NULL_TREE;\n+  bool type_expr_const = true;\n   start_init (NULL_TREE, NULL, 0);\n-  type = groktypename (type_name);\n+  type = groktypename (type_name, &type_expr, &type_expr_const);\n   start_loc = c_parser_peek_token (parser)->location;\n   if (type != error_mark_node && C_TYPE_VARIABLE_SIZE (type))\n     {\n@@ -5545,8 +5575,26 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \n   if (!flag_isoc99)\n     pedwarn (start_loc, OPT_pedantic, \"ISO C90 forbids compound literals\");\n-  expr.value = build_compound_literal (type, init.value);\n+  non_const = ((init.value && TREE_CODE (init.value) == CONSTRUCTOR)\n+\t       ? CONSTRUCTOR_NON_CONST (init.value)\n+\t       : init.original_code == C_MAYBE_CONST_EXPR);\n+  non_const |= !type_expr_const;\n+  expr.value = build_compound_literal (type, init.value, non_const);\n   expr.original_code = ERROR_MARK;\n+  if (type_expr)\n+    {\n+      if (TREE_CODE (expr.value) == C_MAYBE_CONST_EXPR)\n+\t{\n+\t  gcc_assert (C_MAYBE_CONST_EXPR_PRE (expr.value) == NULL_TREE);\n+\t  C_MAYBE_CONST_EXPR_PRE (expr.value) = type_expr;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (!non_const);\n+\t  expr.value = build2 (C_MAYBE_CONST_EXPR, type,\n+\t\t\t       type_expr, expr.value);\n+\t}\n+    }\n   return c_parser_postfix_expression_after_primary (parser, expr);\n }\n \n@@ -5557,6 +5605,7 @@ static struct c_expr\n c_parser_postfix_expression_after_primary (c_parser *parser,\n \t\t\t\t\t   struct c_expr expr)\n {\n+  struct c_expr orig_expr;\n   tree ident, idx, exprlist;\n   location_t loc = c_parser_peek_token (parser)->location;\n   while (true)\n@@ -5579,11 +5628,17 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t    exprlist = NULL_TREE;\n \t  else\n-\t    exprlist = c_parser_expr_list (parser, true);\n+\t    exprlist = c_parser_expr_list (parser, true, false);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n+\t  orig_expr = expr;\n \t  expr.value = build_function_call (expr.value, exprlist);\n \t  expr.original_code = ERROR_MARK;\n+\t  if (TREE_CODE (expr.value) == INTEGER_CST\n+\t      && TREE_CODE (orig_expr.value) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN_CLASS (orig_expr.value) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (orig_expr.value) == BUILT_IN_CONSTANT_P)\n+\t    expr.original_code = C_MAYBE_CONST_EXPR;\n \t  break;\n \tcase CPP_DOT:\n \t  /* Structure element reference.  */\n@@ -5681,28 +5736,32 @@ c_parser_expression_conv (c_parser *parser)\n }\n \n /* Parse a non-empty list of expressions.  If CONVERT_P, convert\n-   functions and arrays to pointers.\n+   functions and arrays to pointers.  If FOLD_P, fold the expressions.\n \n    nonempty-expr-list:\n      assignment-expression\n      nonempty-expr-list , assignment-expression\n */\n \n static tree\n-c_parser_expr_list (c_parser *parser, bool convert_p)\n+c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p)\n {\n   struct c_expr expr;\n   tree ret, cur;\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n     expr = default_function_array_conversion (expr);\n+  if (fold_p)\n+    expr.value = c_fully_fold (expr.value, false, NULL);\n   ret = cur = build_tree_list (NULL_TREE, expr.value);\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n \texpr = default_function_array_conversion (expr);\n+      if (fold_p)\n+\texpr.value = c_fully_fold (expr.value, false, NULL);\n       cur = TREE_CHAIN (cur) = build_tree_list (NULL_TREE, expr.value);\n     }\n   return ret;\n@@ -6288,7 +6347,7 @@ c_parser_objc_type_name (c_parser *parser)\n   if (c_parser_next_token_starts_typename (parser))\n     type_name = c_parser_type_name (parser);\n   if (type_name)\n-    type = groktypename (type_name);\n+    type = groktypename (type_name, NULL, NULL);\n   return build_tree_list (quals, type);\n }\n \n@@ -6394,6 +6453,7 @@ c_parser_objc_synchronized_statement (c_parser *parser)\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       expr = c_parser_expression (parser).value;\n+      expr = c_fully_fold (expr, false, NULL);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   else\n@@ -6529,7 +6589,7 @@ c_parser_objc_receiver (c_parser *parser)\n       c_parser_consume_token (parser);\n       return objc_get_class_reference (id);\n     }\n-  return c_parser_expression (parser).value;\n+  return c_fully_fold (c_parser_expression (parser).value, false, NULL);\n }\n \n /* Parse objc-message-args.\n@@ -6577,7 +6637,7 @@ c_parser_objc_message_args (c_parser *parser)\n static tree\n c_parser_objc_keywordexpr (c_parser *parser)\n {\n-  tree list = c_parser_expr_list (parser, true);\n+  tree list = c_parser_expr_list (parser, true, true);\n   if (TREE_CHAIN (list) == NULL_TREE)\n     {\n       /* Just return the expression, remove a level of\n@@ -7053,6 +7113,7 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       tree c, t = c_parser_expression (parser).value;\n+      t = c_fully_fold (t, false, NULL);\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n \n@@ -7231,6 +7292,7 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n \n       here = c_parser_peek_token (parser)->location;\n       t = c_parser_expr_no_commas (parser, NULL).value;\n+      t = c_fully_fold (t, false, NULL);\n \n       if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n \terror_at (here, \"schedule %<runtime%> does not take \"\n@@ -7430,6 +7492,7 @@ c_parser_omp_atomic (c_parser *parser)\n   c_parser_skip_to_pragma_eol (parser);\n \n   lhs = c_parser_unary_expression (parser).value;\n+  lhs = c_fully_fold (lhs, false, NULL);\n   switch (TREE_CODE (lhs))\n     {\n     case ERROR_MARK:\n@@ -7491,6 +7554,7 @@ c_parser_omp_atomic (c_parser *parser)\n       rhs_expr = c_parser_expression (parser);\n       rhs_expr = default_function_array_conversion (rhs_expr);\n       rhs = rhs_expr.value;\n+      rhs = c_fully_fold (rhs, false, NULL);\n       break;\n     }\n   stmt = c_finish_omp_atomic (code, lhs, rhs);\n@@ -7654,6 +7718,7 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \n \t  cond = cond_expr.value;\n \t  cond = c_objc_common_truthvalue_conversion (cond_loc, cond);\n+\t  cond = c_fully_fold (cond, false, NULL);\n \t  switch (cond_expr.original_code)\n \t    {\n \t    case GT_EXPR:"}, {"sha": "f9e4b3e5d9de8adc5d69fd898fcfaf14adbc22f1", "filename": "gcc/c-tree.h", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -146,6 +146,10 @@ struct lang_type GTY(())\n    without prototypes.  */\n #define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_LANG_SLOT_1 (NODE)\n \n+/* For a CONSTRUCTOR, whether some initializer contains a\n+   subexpression meaning it is not a constant expression.  */\n+#define CONSTRUCTOR_NON_CONST(EXPR) TREE_LANG_FLAG_1 (CONSTRUCTOR_CHECK (EXPR))\n+\n /* Record parser information about an expression that is irrelevant\n    for code generation alongside a tree representing its value.  */\n struct c_expr\n@@ -154,7 +158,9 @@ struct c_expr\n   tree value;\n   /* Record the original unary/binary operator of an expression, which may\n      have been changed by fold, STRING_CST for unparenthesized string\n-     constants, or ERROR_MARK for other expressions (including\n+     constants, C_MAYBE_CONST_EXPR for __builtin_constant_p calls\n+     (even if parenthesized), for subexpressions, and for non-constant\n+     initializers, or ERROR_MARK for other expressions (including\n      parenthesized expressions).  */\n   enum tree_code original_code;\n };\n@@ -190,6 +196,18 @@ struct c_typespec {\n   enum c_typespec_kind kind;\n   /* The specifier itself.  */\n   tree spec;\n+  /* An expression to be evaluated before the type specifier, in the\n+     case of typeof specifiers, or NULL otherwise or if no such\n+     expression is required for a particular typeof specifier.  In\n+     particular, when typeof is applied to an expression of variably\n+     modified type, that expression must be evaluated in order to\n+     determine array sizes that form part of the type, but the\n+     expression itself (as opposed to the array sizes) forms no part\n+     of the type and so needs to be recorded separately.  */\n+  tree expr;\n+  /* Whether the expression has operands suitable for use in constant\n+     expressions.  */\n+  bool expr_const_operands;\n };\n \n /* A storage class specifier.  */\n@@ -227,6 +245,9 @@ struct c_declspecs {\n      whole type, or NULL_TREE if none or a keyword such as \"void\" or\n      \"char\" is used.  Does not include qualifiers.  */\n   tree type;\n+  /* Any expression to be evaluated before the type, from a typeof\n+     specifier.  */\n+  tree expr;\n   /* The attributes from a typedef decl.  */\n   tree decl_attr;\n   /* When parsing, the attributes.  Outside the parser, this will be\n@@ -238,6 +259,9 @@ struct c_declspecs {\n   enum c_typespec_keyword typespec_word;\n   /* The storage class specifier, or csc_none if none.  */\n   enum c_storage_class storage_class;\n+  /* Whether any expressions in typeof specifiers may appear in\n+     constant expressions.  */\n+  BOOL_BITFIELD expr_const_operands : 1;\n   /* Whether any declaration specifiers have been seen at all.  */\n   BOOL_BITFIELD declspecs_seen_p : 1;\n   /* Whether a type specifier has been seen.  */\n@@ -478,7 +502,7 @@ extern tree finish_struct (tree, tree, tree);\n extern struct c_arg_info *get_parm_info (bool);\n extern tree grokfield (location_t, struct c_declarator *,\n \t\t       struct c_declspecs *, tree, tree *);\n-extern tree groktypename (struct c_type_name *);\n+extern tree groktypename (struct c_type_name *, tree *, bool *);\n extern tree grokparm (const struct c_parm *);\n extern tree implicitly_declare (tree);\n extern void keep_next_level (void);\n@@ -532,6 +556,7 @@ extern bool c_vla_unspec_p (tree x, tree fn);\n \t\t\t  ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n \n /* in c-typeck.c */\n+extern bool in_late_binary_op;\n extern int in_alignof;\n extern int in_sizeof;\n extern int in_typeof;\n@@ -561,7 +586,7 @@ extern struct c_expr parser_build_unary_op (enum tree_code, struct c_expr,\n extern struct c_expr parser_build_binary_op (location_t, \n     \t\t\t\t\t     enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n-extern tree build_conditional_expr (tree, tree, tree);\n+extern tree build_conditional_expr (tree, bool, tree, tree);\n extern tree build_compound_expr (tree, tree);\n extern tree c_cast_expr (struct c_type_name *, tree);\n extern tree build_c_cast (tree, tree);\n@@ -577,7 +602,7 @@ extern struct c_expr pop_init_level (int);\n extern void set_init_index (tree, tree);\n extern void set_init_label (tree);\n extern void process_init_element (struct c_expr, bool);\n-extern tree build_compound_literal (tree, tree);\n+extern tree build_compound_literal (tree, tree, bool);\n extern tree c_start_case (tree);\n extern void c_finish_case (tree);\n extern tree build_asm_expr (tree, tree, tree, tree, bool);"}, {"sha": "674220ca3b01a98025c6ed857578867c781b37fd", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 510, "deletions": 134, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -54,6 +54,13 @@ enum impl_conv {\n   ic_return\n };\n \n+/* Whether we are building a boolean conversion inside\n+   convert_for_assignment, or some other late binary operation.  If\n+   build_binary_op is called (from code shared with C++) in this case,\n+   then the operands have already been folded and the result will not\n+   be folded again, so C_MAYBE_CONST_EXPR should not be generated.  */\n+bool in_late_binary_op;\n+\n /* The level of nesting inside \"__alignof__\".  */\n int in_alignof;\n \n@@ -79,19 +86,18 @@ static int tagged_types_tu_compatible_p (const_tree, const_tree);\n static int comp_target_types (tree, tree);\n static int function_types_compatible_p (const_tree, const_tree);\n static int type_lists_compatible_p (const_tree, const_tree);\n-static tree decl_constant_value_for_broken_optimization (tree);\n static tree lookup_field (tree, tree);\n static int convert_arguments (int, tree *, tree, tree, tree, tree);\n static tree pointer_diff (tree, tree);\n-static tree convert_for_assignment (tree, tree, enum impl_conv, tree, tree,\n-\t\t\t\t    int);\n+static tree convert_for_assignment (tree, tree, enum impl_conv, bool,\n+\t\t\t\t    tree, tree, int);\n static tree valid_compound_expr_initializer (tree, tree);\n static void push_string (const char *);\n static void push_member_name (tree);\n static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (int, const char *);\n-static tree digest_init (tree, tree, bool, int);\n+static tree digest_init (tree, tree, bool, bool, int);\n static void output_init_element (tree, bool, tree, tree, int, bool);\n static void output_pending_init_elements (int);\n static int set_designator (int);\n@@ -122,6 +128,29 @@ null_pointer_constant_p (const_tree expr)\n \t\t  && VOID_TYPE_P (TREE_TYPE (type))\n \t\t  && TYPE_QUALS (TREE_TYPE (type)) == TYPE_UNQUALIFIED)));\n }\n+\n+/* EXPR may appear in an unevaluated part of an integer constant\n+   expression, but not in an evaluated part.  Wrap it in a\n+   C_MAYBE_CONST_EXPR, or mark it with TREE_OVERFLOW if it is just an\n+   INTEGER_CST and we cannot create a C_MAYBE_CONST_EXPR.  */\n+\n+static tree\n+note_integer_operands (tree expr)\n+{\n+  tree ret;\n+  if (TREE_CODE (expr) == INTEGER_CST && in_late_binary_op)\n+    {\n+      ret = copy_node (expr);\n+      TREE_OVERFLOW (ret) = 1;\n+    }\n+  else\n+    {\n+      ret = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (expr), NULL_TREE, expr);\n+      C_MAYBE_CONST_EXPR_INT_OPERANDS (ret) = 1;\n+    }\n+  return ret;\n+}\n+\n \f/* This is a cache to hold if two types are compatible or not.  */\n \n struct tagged_tu_seen_cache {\n@@ -1568,31 +1597,6 @@ decl_constant_value (tree decl)\n   return decl;\n }\n \n-/* Return either DECL or its known constant value (if it has one), but\n-   return DECL if pedantic or DECL has mode BLKmode.  This is for\n-   bug-compatibility with the old behavior of decl_constant_value\n-   (before GCC 3.0); every use of this function is a bug and it should\n-   be removed before GCC 3.1.  It is not appropriate to use pedantic\n-   in a way that affects optimization, and BLKmode is probably not the\n-   right test for avoiding misoptimizations either.  */\n-\n-static tree\n-decl_constant_value_for_broken_optimization (tree decl)\n-{\n-  tree ret;\n-\n-  if (pedantic || DECL_MODE (decl) == BLKmode)\n-    return decl;\n-\n-  ret = decl_constant_value (decl);\n-  /* Avoid unwanted tree sharing between the initializer and current\n-     function's body where the tree can be modified e.g. by the\n-     gimplifier.  */\n-  if (ret != decl && TREE_STATIC (decl))\n-    ret = unshare_expr (ret);\n-  return ret;\n-}\n-\n /* Convert the array expression EXP to a pointer.  */\n static tree\n array_to_pointer_conversion (tree exp)\n@@ -1652,7 +1656,7 @@ function_to_pointer_conversion (tree exp)\n \n /* Perform the default conversion of arrays and functions to pointers.\n    Return the result of converting EXP.  For any other expression, just\n-   return EXP after removing NOPs.  */\n+   return EXP.  */\n \n struct c_expr\n default_function_array_conversion (struct c_expr exp)\n@@ -1697,9 +1701,6 @@ default_function_array_conversion (struct c_expr exp)\n       exp.value = function_to_pointer_conversion (exp.value);\n       break;\n     default:\n-      STRIP_TYPE_NOPS (exp.value);\n-      if (TREE_NO_WARNING (orig_exp))\n-\tTREE_NO_WARNING (exp.value) = 1;\n       break;\n     }\n \n@@ -1775,15 +1776,6 @@ default_conversion (tree exp)\n   if (TREE_CODE (exp) == CONST_DECL)\n     exp = DECL_INITIAL (exp);\n \n-  /* Replace a nonvolatile const static variable with its value unless\n-     it is an array, in which case we must be sure that taking the\n-     address of the array produces consistent results.  */\n-  else if (optimize && TREE_CODE (exp) == VAR_DECL && code != ARRAY_TYPE)\n-    {\n-      exp = decl_constant_value_for_broken_optimization (exp);\n-      type = TREE_TYPE (exp);\n-    }\n-\n   /* Strip no-op conversions.  */\n   orig_exp = exp;\n   STRIP_TYPE_NOPS (exp);\n@@ -2162,7 +2154,7 @@ build_array_ref (tree array, tree index, location_t loc)\n \t       in an inline function.\n \t       Hope it doesn't break something else.  */\n \t    | TREE_THIS_VOLATILE (array));\n-      ret = require_complete_type (fold (rval));\n+      ret = require_complete_type (rval);\n       protected_set_expr_location (ret, loc);\n       return ret;\n     }\n@@ -2332,14 +2324,19 @@ c_expr_sizeof_expr (struct c_expr expr)\n     }\n   else\n     {\n-      ret.value = c_sizeof (TREE_TYPE (expr.value));\n+      bool expr_const_operands = true;\n+      tree folded_expr = c_fully_fold (expr.value, require_constant_value,\n+\t\t\t\t       &expr_const_operands);\n+      ret.value = c_sizeof (TREE_TYPE (folded_expr));\n       ret.original_code = ERROR_MARK;\n-      if (c_vla_type_p (TREE_TYPE (expr.value)))\n+      if (c_vla_type_p (TREE_TYPE (folded_expr)))\n \t{\n \t  /* sizeof is evaluated when given a vla (C99 6.5.3.4p2).  */\n-\t  ret.value = build2 (COMPOUND_EXPR, TREE_TYPE (ret.value), expr.value, ret.value);\n+\t  ret.value = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret.value),\n+\t\t\t      folded_expr, ret.value);\n+\t  C_MAYBE_CONST_EXPR_NON_CONST (ret.value) = !expr_const_operands;\n \t}\n-      pop_maybe_used (C_TYPE_VARIABLE_SIZE (TREE_TYPE (expr.value)));\n+      pop_maybe_used (C_TYPE_VARIABLE_SIZE (TREE_TYPE (folded_expr)));\n     }\n   return ret;\n }\n@@ -2352,9 +2349,17 @@ c_expr_sizeof_type (struct c_type_name *t)\n {\n   tree type;\n   struct c_expr ret;\n-  type = groktypename (t);\n+  tree type_expr = NULL_TREE;\n+  bool type_expr_const = true;\n+  type = groktypename (t, &type_expr, &type_expr_const);\n   ret.value = c_sizeof (type);\n   ret.original_code = ERROR_MARK;\n+  if (type_expr && c_vla_type_p (type))\n+    {\n+      ret.value = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret.value),\n+\t\t\t  type_expr, ret.value);\n+      C_MAYBE_CONST_EXPR_NON_CONST (ret.value) = !type_expr_const;\n+    }\n   pop_maybe_used (type != error_mark_node\n \t\t  ? C_TYPE_VARIABLE_SIZE (type) : false);\n   return ret;\n@@ -2399,6 +2404,8 @@ build_function_call (tree function, tree params)\n      expressions, like those used for ObjC messenger dispatches.  */\n   function = objc_rewrite_function_call (function, params);\n \n+  function = c_fully_fold (function, false, NULL);\n+\n   fntype = TREE_TYPE (function);\n \n   if (TREE_CODE (fntype) == ERROR_MARK)\n@@ -2462,7 +2469,8 @@ build_function_call (tree function, tree params)\n \n \t  if (AGGREGATE_TYPE_P (return_type))\n \t    rhs = build_compound_literal (return_type,\n-\t\t\t\t\t  build_constructor (return_type, 0));\n+\t\t\t\t\t  build_constructor (return_type, 0),\n+\t\t\t\t\t  false);\n \t  else\n \t    rhs = fold_convert (return_type, integer_zero_node);\n \n@@ -2481,18 +2489,22 @@ build_function_call (tree function, tree params)\n   check_function_arguments (TYPE_ATTRIBUTES (fntype), nargs, argarray,\n \t\t\t    TYPE_ARG_TYPES (fntype));\n \n-  if (require_constant_value)\n+  if (name != NULL_TREE\n+      && !strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10))\n     {\n-      result = fold_build_call_array_initializer (TREE_TYPE (fntype),\n-\t\t\t\t\t\t  function, nargs, argarray);\n-      if (TREE_CONSTANT (result)\n-\t  && (name == NULL_TREE\n-\t      || strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10) != 0))\n-\tpedwarn_init (input_location, 0, \"initializer element is not constant\");\n+      if (require_constant_value)\n+\tresult = fold_build_call_array_initializer (TREE_TYPE (fntype),\n+\t\t\t\t\t\t    function, nargs, argarray);\n+      else\n+\tresult = fold_build_call_array (TREE_TYPE (fntype),\n+\t\t\t\t\tfunction, nargs, argarray);\n+      if (TREE_CODE (result) == NOP_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (result, 0)) == INTEGER_CST)\n+\tSTRIP_TYPE_NOPS (result);\n     }\n   else\n-    result = fold_build_call_array (TREE_TYPE (fntype),\n-\t\t\t\t    function, nargs, argarray);\n+    result = build_call_array (TREE_TYPE (fntype),\n+\t\t\t       function, nargs, argarray);\n \n   if (VOID_TYPE_P (TREE_TYPE (result)))\n     return result;\n@@ -2552,6 +2564,7 @@ convert_arguments (int nargs, tree *argarray,\n       tree rname = function;\n       int argnum = parmnum + 1;\n       const char *invalid_func_diag;\n+      bool npc;\n \n       if (type == void_type_node)\n \t{\n@@ -2565,6 +2578,8 @@ convert_arguments (int nargs, tree *argarray,\n \t  argnum -= 2;\n \t}\n \n+      npc = null_pointer_constant_p (val);\n+      val = c_fully_fold (val, false, NULL);\n       STRIP_TYPE_NOPS (val);\n \n       val = require_complete_type (val);\n@@ -2705,7 +2720,7 @@ convert_arguments (int nargs, tree *argarray,\n \t\t    }\n \t\t}\n \n-\t      parmval = convert_for_assignment (type, val, ic_argpass,\n+\t      parmval = convert_for_assignment (type, val, ic_argpass, npc,\n \t\t\t\t\t\tfundecl, function,\n \t\t\t\t\t\tparmnum + 1);\n \n@@ -2934,6 +2949,9 @@ build_unary_op (location_t location,\n   tree ret = error_mark_node;\n   int noconvert = flag;\n   const char *invalid_op_diag;\n+  bool int_operands;\n+\n+  int_operands = EXPR_INT_CONST_OPERANDS (xarg);\n \n   if (code != ADDR_EXPR)\n     arg = require_complete_type (arg);\n@@ -3063,6 +3081,29 @@ build_unary_op (location_t location,\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n \n+      if (TREE_CODE (arg) == C_MAYBE_CONST_EXPR)\n+\t{\n+\t  tree inner = build_unary_op (location, code,\n+\t\t\t\t       C_MAYBE_CONST_EXPR_EXPR (arg), flag);\n+\t  if (inner == error_mark_node)\n+\t    return error_mark_node;\n+\t  ret = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (inner),\n+\t\t\tC_MAYBE_CONST_EXPR_PRE (arg), inner);\n+\t  gcc_assert (!C_MAYBE_CONST_EXPR_INT_OPERANDS (arg));\n+\t  C_MAYBE_CONST_EXPR_NON_CONST (ret) = 1;\n+\t  goto return_build_unary_op;\n+\t}\n+\n+      /* Complain about anything that is not a true lvalue.  */\n+      if (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n+\t\t\t\t  || code == POSTINCREMENT_EXPR)\n+\t\t\t\t ? lv_increment\n+\t\t\t\t : lv_decrement)))\n+\treturn error_mark_node;\n+\n+      /* Ensure the argument is fully folded inside any SAVE_EXPR.  */\n+      arg = c_fully_fold (arg, false, NULL);\n+\n       /* Increment or decrement the real part of the value,\n \t and don't change the imaginary part.  */\n       if (typecode == COMPLEX_TYPE)\n@@ -3155,13 +3196,6 @@ build_unary_op (location_t location,\n \t    inc = convert (argtype, inc);\n \t  }\n \n-\t/* Complain about anything else that is not a true lvalue.  */\n-\tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n-\t\t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t\t   ? lv_increment\n-\t\t\t\t   : lv_decrement)))\n-\t  return error_mark_node;\n-\n \t/* Report a read-only lvalue.  */\n \tif (TREE_READONLY (arg))\n \t  {\n@@ -3215,6 +3249,20 @@ build_unary_op (location_t location,\n \t       && !lvalue_or_else (arg, lv_addressof))\n \treturn error_mark_node;\n \n+      /* Move address operations inside C_MAYBE_CONST_EXPR to simplify\n+\t folding later.  */\n+      if (TREE_CODE (arg) == C_MAYBE_CONST_EXPR)\n+\t{\n+\t  tree inner = build_unary_op (location, code,\n+\t\t\t\t       C_MAYBE_CONST_EXPR_EXPR (arg), flag);\n+\t  ret = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (inner),\n+\t\t\tC_MAYBE_CONST_EXPR_PRE (arg), inner);\n+\t  gcc_assert (!C_MAYBE_CONST_EXPR_INT_OPERANDS (arg));\n+\t  C_MAYBE_CONST_EXPR_NON_CONST (ret)\n+\t    = C_MAYBE_CONST_EXPR_NON_CONST (arg);\n+\t  goto return_build_unary_op;\n+\t}\n+\n       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n       argtype = TREE_TYPE (arg);\n \n@@ -3260,10 +3308,19 @@ build_unary_op (location_t location,\n \n   if (argtype == 0)\n     argtype = TREE_TYPE (arg);\n-  ret = require_constant_value ? fold_build1_initializer (code, argtype, arg)\n-\t\t\t       : fold_build1 (code, argtype, arg);\n+  if (TREE_CODE (arg) == INTEGER_CST)\n+    ret = (require_constant_value\n+\t   ? fold_build1_initializer (code, argtype, arg)\n+\t   : fold_build1 (code, argtype, arg));\n+  else\n+    ret = build1 (code, argtype, arg);\n  return_build_unary_op:\n   gcc_assert (ret != error_mark_node);\n+  if (TREE_CODE (ret) == INTEGER_CST && !TREE_OVERFLOW (ret)\n+      && !(TREE_CODE (xarg) == INTEGER_CST && !TREE_OVERFLOW (xarg)))\n+    ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n+  else if (TREE_CODE (ret) != INTEGER_CST && int_operands)\n+    ret = note_integer_operands (ret);\n   protected_set_expr_location (ret, location);\n   return ret;\n }\n@@ -3284,6 +3341,9 @@ lvalue_p (const_tree ref)\n     case COMPONENT_REF:\n       return lvalue_p (TREE_OPERAND (ref, 0));\n \n+    case C_MAYBE_CONST_EXPR:\n+      return lvalue_p (TREE_OPERAND (ref, 1));\n+\n     case COMPOUND_LITERAL_EXPR:\n     case STRING_CST:\n       return 1;\n@@ -3426,17 +3486,23 @@ c_mark_addressable (tree exp)\n     }\n }\n \f\n-/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */\n+/* Build and return a conditional expression IFEXP ? OP1 : OP2.  If\n+   IFEXP_BCP then the condition is a call to __builtin_constant_p, and\n+   if folded to an integer constant then the unselected half may\n+   contain arbitrary operations not normally permitted in constant\n+   expressions.  */\n \n tree\n-build_conditional_expr (tree ifexp, tree op1, tree op2)\n+build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n {\n   tree type1;\n   tree type2;\n   enum tree_code code1;\n   enum tree_code code2;\n   tree result_type = NULL;\n   tree orig_op1 = op1, orig_op2 = op2;\n+  bool int_const, op1_int_operands, op2_int_operands, int_operands;\n+  tree ret;\n   bool objc_ok;\n \n   /* Promote both alternatives.  */\n@@ -3487,7 +3553,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \t and later code won't know it used to be different.\n \t Do this check on the original types, so that explicit casts\n \t will be considered, but default promotions won't.  */\n-      if (warn_sign_compare && !skip_evaluation)\n+      if (!skip_evaluation)\n \t{\n \t  int unsigned_op1 = TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n \t  int unsigned_op2 = TYPE_UNSIGNED (TREE_TYPE (orig_op2));\n@@ -3501,16 +3567,47 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \t\t all the values of the unsigned type.  */\n \t      if (!TYPE_UNSIGNED (result_type))\n \t\t/* OK */;\n-\t      /* Do not warn if the signed quantity is an unsuffixed\n-\t\t integer literal (or some static constant expression\n-\t\t involving such literals) and it is non-negative.  */\n-\t      else if ((unsigned_op2\n-\t\t\t&& tree_expr_nonnegative_warnv_p (op1, &ovf))\n-\t\t       || (unsigned_op1\n-\t\t\t   && tree_expr_nonnegative_warnv_p (op2, &ovf)))\n-\t\t/* OK */;\n \t      else\n-\t\twarning (OPT_Wsign_compare, \"signed and unsigned type in conditional expression\");\n+\t\t{\n+\t\t  bool op1_maybe_const = true;\n+\t\t  bool op2_maybe_const = true;\n+\n+\t\t  /* Do not warn if the signed quantity is an\n+\t\t     unsuffixed integer literal (or some static\n+\t\t     constant expression involving such literals) and\n+\t\t     it is non-negative.  This warning requires the\n+\t\t     operands to be folded for best results, so do\n+\t\t     that folding in this case even without\n+\t\t     warn_sign_compare to avoid warning options\n+\t\t     possibly affecting code generation.  */\n+\t\t  op1 = c_fully_fold (op1, require_constant_value,\n+\t\t\t\t      &op1_maybe_const);\n+\t\t  op2 = c_fully_fold (op2, require_constant_value,\n+\t\t\t\t      &op2_maybe_const);\n+\n+\t\t  if (warn_sign_compare)\n+\t\t    {\n+\t\t      if ((unsigned_op2\n+\t\t\t   && tree_expr_nonnegative_warnv_p (op1, &ovf))\n+\t\t\t  || (unsigned_op1\n+\t\t\t      && tree_expr_nonnegative_warnv_p (op2, &ovf)))\n+\t\t\t/* OK */;\n+\t\t      else\n+\t\t\twarning (OPT_Wsign_compare, \"signed and unsigned type in conditional expression\");\n+\t\t    }\n+\t\t  if (!op1_maybe_const || TREE_CODE (op1) != INTEGER_CST)\n+\t\t    {\n+\t\t      op1 = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (op1),\n+\t\t\t\t    NULL, op1);\n+\t\t      C_MAYBE_CONST_EXPR_NON_CONST (op1) = !op1_maybe_const;\n+\t\t    }\n+\t\t  if (!op2_maybe_const || TREE_CODE (op2) != INTEGER_CST)\n+\t\t    {\n+\t\t      op2 = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (op2),\n+\t\t\t\t    NULL, op2);\n+\t\t      C_MAYBE_CONST_EXPR_NON_CONST (op2) = !op2_maybe_const;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n@@ -3600,7 +3697,40 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   if (result_type != TREE_TYPE (op2))\n     op2 = convert_and_check (result_type, op2);\n \n-  return fold_build3 (COND_EXPR, result_type, ifexp, op1, op2);\n+  op1_int_operands = EXPR_INT_CONST_OPERANDS (orig_op1);\n+  op2_int_operands = EXPR_INT_CONST_OPERANDS (orig_op2);\n+  if (ifexp_bcp && ifexp == truthvalue_true_node)\n+    {\n+      op2_int_operands = true;\n+      op1 = c_fully_fold (op1, require_constant_value, NULL);\n+    }\n+  if (ifexp_bcp && ifexp == truthvalue_false_node)\n+    {\n+      op1_int_operands = true;\n+      op2 = c_fully_fold (op2, require_constant_value, NULL);\n+    }\n+  int_const = int_operands = (EXPR_INT_CONST_OPERANDS (ifexp)\n+\t\t\t      && op1_int_operands\n+\t\t\t      && op2_int_operands);\n+  if (int_operands)\n+    {\n+      int_const = ((ifexp == truthvalue_true_node\n+\t\t    && TREE_CODE (orig_op1) == INTEGER_CST\n+\t\t    && !TREE_OVERFLOW (orig_op1))\n+\t\t   || (ifexp == truthvalue_false_node\n+\t\t       && TREE_CODE (orig_op2) == INTEGER_CST\n+\t\t       && !TREE_OVERFLOW (orig_op2)));\n+    }\n+  if (int_const || (ifexp_bcp && TREE_CODE (ifexp) == INTEGER_CST))\n+    ret = fold_build3 (COND_EXPR, result_type, ifexp, op1, op2);\n+  else\n+    {\n+      ret = build3 (COND_EXPR, result_type, ifexp, op1, op2);\n+      if (int_operands)\n+\tret = note_integer_operands (ret);\n+    }\n+\n+  return ret;\n }\n \f\n /* Return a compound expression that performs two expressions and\n@@ -3609,6 +3739,8 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n tree\n build_compound_expr (tree expr1, tree expr2)\n {\n+  tree ret;\n+\n   if (!TREE_SIDE_EFFECTS (expr1))\n     {\n       /* The left-hand operand of a comma expression is like an expression\n@@ -3639,7 +3771,14 @@ build_compound_expr (tree expr1, tree expr2)\n   if (expr2 == error_mark_node)\n     return error_mark_node;\n \n-  return build2 (COMPOUND_EXPR, TREE_TYPE (expr2), expr1, expr2);\n+  ret = build2 (COMPOUND_EXPR, TREE_TYPE (expr2), expr1, expr2);\n+\n+  if (flag_isoc99\n+      && EXPR_INT_CONST_OPERANDS (expr1)\n+      && EXPR_INT_CONST_OPERANDS (expr2))\n+    ret = note_integer_operands (ret);\n+\n+  return ret;\n }\n \n /* Build an expression representing a cast to type TYPE of expression EXPR.  */\n@@ -3704,7 +3843,7 @@ build_c_cast (tree type, tree expr)\n \t\t   \"ISO C forbids casts to union type\");\n \t  t = digest_init (type,\n \t\t\t   build_constructor_single (type, field, value),\n-\t\t\t   true, 0);\n+\t\t\t   false, true, 0);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n \t  return t;\n \t}\n@@ -3828,7 +3967,7 @@ build_c_cast (tree type, tree expr)\n       value = convert (type, value);\n \n       /* Ignore any integer overflow caused by the cast.  */\n-      if (TREE_CODE (value) == INTEGER_CST)\n+      if (TREE_CODE (value) == INTEGER_CST && !FLOAT_TYPE_P (otype))\n \t{\n \t  if (CONSTANT_CLASS_P (ovalue) && TREE_OVERFLOW (ovalue))\n \t    {\n@@ -3851,6 +3990,20 @@ build_c_cast (tree type, tree expr)\n   if (value == expr)\n     value = non_lvalue (value);\n \n+  /* Don't allow the results of casting to floating-point or complex\n+     types be confused with actual constants, or casts involving\n+     integer and pointer types other than direct integer-to-integer\n+     and integer-to-pointer be confused with integer constant\n+     expressions and null pointer constants.  */\n+  if (TREE_CODE (value) == REAL_CST\n+      || TREE_CODE (value) == COMPLEX_CST\n+      || (TREE_CODE (value) == INTEGER_CST\n+\t  && !((TREE_CODE (expr) == INTEGER_CST\n+\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n+\t       || TREE_CODE (expr) == REAL_CST\n+\t       || TREE_CODE (expr) == COMPLEX_CST)))\n+      value = build1 (NOP_EXPR, type, value);\n+\n   return value;\n }\n \n@@ -3859,16 +4012,25 @@ tree\n c_cast_expr (struct c_type_name *type_name, tree expr)\n {\n   tree type;\n+  tree type_expr = NULL_TREE;\n+  bool type_expr_const = true;\n+  tree ret;\n   int saved_wsp = warn_strict_prototypes;\n \n   /* This avoids warnings about unprototyped casts on\n      integers.  E.g. \"#define SIG_DFL (void(*)())0\".  */\n   if (TREE_CODE (expr) == INTEGER_CST)\n     warn_strict_prototypes = 0;\n-  type = groktypename (type_name);\n+  type = groktypename (type_name, &type_expr, &type_expr_const);\n   warn_strict_prototypes = saved_wsp;\n \n-  return build_c_cast (type, expr);\n+  ret = build_c_cast (type, expr);\n+  if (type_expr)\n+    {\n+      ret = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret), type_expr, ret);\n+      C_MAYBE_CONST_EXPR_NON_CONST (ret) = !type_expr_const;\n+    }\n+  return ret;\n }\n \f\n /* Build an assignment expression of lvalue LHS from value RHS.\n@@ -3886,6 +4048,7 @@ build_modify_expr (location_t location,\n   tree newrhs;\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n+  bool npc;\n \n   /* Types that aren't fully specified cannot be used in assignments.  */\n   lhs = require_complete_type (lhs);\n@@ -3897,15 +4060,28 @@ build_modify_expr (location_t location,\n   if (!lvalue_or_else (lhs, lv_assign))\n     return error_mark_node;\n \n-  STRIP_TYPE_NOPS (rhs);\n-\n   newrhs = rhs;\n \n+  if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n+    {\n+      tree inner = build_modify_expr (location, C_MAYBE_CONST_EXPR_EXPR (lhs),\n+\t\t\t\t      modifycode, rhs);\n+      if (inner == error_mark_node)\n+\treturn error_mark_node;\n+      result = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (inner),\n+\t\t       C_MAYBE_CONST_EXPR_PRE (lhs), inner);\n+      gcc_assert (!C_MAYBE_CONST_EXPR_INT_OPERANDS (lhs));\n+      C_MAYBE_CONST_EXPR_NON_CONST (result) = 1;\n+      protected_set_expr_location (result, location);\n+      return result;\n+    }\n+\n   /* If a binary op has been requested, combine the old LHS value with the RHS\n      producing the value we should actually store into the LHS.  */\n \n   if (modifycode != NOP_EXPR)\n     {\n+      lhs = c_fully_fold (lhs, false, NULL);\n       lhs = stabilize_reference (lhs);\n       newrhs = build_binary_op (location,\n \t\t\t\tmodifycode, lhs, rhs, 1);\n@@ -3943,9 +4119,12 @@ build_modify_expr (location_t location,\n       TREE_TYPE (lhs) = lhstype;\n     }\n \n-  /* Convert new value to destination type.  */\n+  /* Convert new value to destination type.  Fold it first for the\n+     sake of conversion warnings.  */\n \n-  newrhs = convert_for_assignment (lhstype, newrhs, ic_assign,\n+  npc = null_pointer_constant_p (newrhs);\n+  newrhs = c_fully_fold (newrhs, false, NULL);\n+  newrhs = convert_for_assignment (lhstype, newrhs, ic_assign, npc,\n \t\t\t\t   NULL_TREE, NULL_TREE, 0);\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n     return error_mark_node;\n@@ -3975,14 +4154,15 @@ build_modify_expr (location_t location,\n   if (olhstype == TREE_TYPE (result))\n     return result;\n \n-  result = convert_for_assignment (olhstype, result, ic_assign,\n+  result = convert_for_assignment (olhstype, result, ic_assign, false,\n \t\t\t\t   NULL_TREE, NULL_TREE, 0);\n   protected_set_expr_location (result, location);\n   return result;\n }\n \f\n /* Convert value RHS to type TYPE as preparation for an assignment\n-   to an lvalue of type TYPE.\n+   to an lvalue of type TYPE.  NULL_POINTER_CONSTANT says whether RHS\n+   was a null pointer constant before any folding.\n    The real work of conversion is done by `convert'.\n    The purpose of this function is to generate error messages\n    for assignments that are not allowed in C.\n@@ -3994,6 +4174,7 @@ build_modify_expr (location_t location,\n \n static tree\n convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n+\t\t\tbool null_pointer_constant,\n \t\t\ttree fundecl, tree function, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n@@ -4049,12 +4230,6 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       }                                                                  \\\n   } while (0)\n \n-  STRIP_TYPE_NOPS (rhs);\n-\n-  if (optimize && TREE_CODE (rhs) == VAR_DECL\n-\t   && TREE_CODE (TREE_TYPE (rhs)) != ARRAY_TYPE)\n-    rhs = decl_constant_value_for_broken_optimization (rhs);\n-\n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n \n@@ -4142,7 +4317,16 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t       || coder == FIXED_POINT_TYPE\n \t       || coder == ENUMERAL_TYPE || coder == COMPLEX_TYPE\n \t       || coder == BOOLEAN_TYPE))\n-    return convert_and_check (type, rhs);\n+    {\n+      tree ret;\n+      bool save = in_late_binary_op;\n+      if (codel == BOOLEAN_TYPE)\n+\tin_late_binary_op = true;\n+      ret = convert_and_check (type, rhs);\n+      if (codel == BOOLEAN_TYPE)\n+\tin_late_binary_op = save;\n+      return ret;\n+    }\n \n   /* Aggregates in different TUs might need conversion.  */\n   if ((codel == RECORD_TYPE || codel == UNION_TYPE)\n@@ -4197,7 +4381,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t    }\n \n \t  /* Can convert integer zero to any pointer type.  */\n-\t  if (null_pointer_constant_p (rhs))\n+\t  if (null_pointer_constant)\n \t    {\n \t      rhs = null_pointer_node;\n \t      break;\n@@ -4335,7 +4519,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)\n \t\t  ||\n \t\t  (VOID_TYPE_P (ttr)\n-\t\t   && !null_pointer_constant_p (rhs)\n+\t\t   && !null_pointer_constant\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n \t    WARN_FOR_ASSIGNMENT (input_location, OPT_pedantic,\n \t\t\t\t G_(\"ISO C forbids passing argument %d of \"\n@@ -4430,7 +4614,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       /* An explicit constant 0 can convert to a pointer,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n-      if (!null_pointer_constant_p (rhs))\n+      if (!null_pointer_constant)\n \tWARN_FOR_ASSIGNMENT (input_location, 0,\n \t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\"pointer from integer without a cast\"),\n@@ -4457,7 +4641,14 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       return convert (type, rhs);\n     }\n   else if (codel == BOOLEAN_TYPE && coder == POINTER_TYPE)\n-    return convert (type, rhs);\n+    {\n+      tree ret;\n+      bool save = in_late_binary_op;\n+      in_late_binary_op = true;\n+      ret = convert (type, rhs);\n+      in_late_binary_op = save;\n+      return ret;\n+    }\n \n   switch (errtype)\n     {\n@@ -4518,6 +4709,7 @@ void\n store_init_value (tree decl, tree init)\n {\n   tree value, type;\n+  bool npc = false;\n \n   /* If variable's type was invalidly declared, just ignore it.  */\n \n@@ -4527,7 +4719,9 @@ store_init_value (tree decl, tree init)\n \n   /* Digest the specified initializer into an expression.  */\n \n-  value = digest_init (type, init, true, TREE_STATIC (decl));\n+  if (init)\n+    npc = null_pointer_constant_p (init);\n+  value = digest_init (type, init, npc, true, TREE_STATIC (decl));\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -4758,6 +4952,8 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n \n+   NULL_POINTER_CONSTANT is true if INIT is a null pointer constant.\n+\n    If INIT is a string constant, STRICT_STRING is true if it is\n    unparenthesized or we should not warn here for it being parenthesized.\n    For other types of INIT, STRICT_STRING is not used.\n@@ -4766,10 +4962,12 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n    elements are seen.  */\n \n static tree\n-digest_init (tree type, tree init, bool strict_string, int require_constant)\n+digest_init (tree type, tree init, bool null_pointer_constant,\n+\t     bool strict_string, int require_constant)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree inside_init = init;\n+  bool maybe_const = true;\n \n   if (type == error_mark_node\n       || !init\n@@ -4779,7 +4977,8 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \n   STRIP_TYPE_NOPS (inside_init);\n \n-  inside_init = fold (inside_init);\n+  inside_init = c_fully_fold (inside_init, require_constant, &maybe_const);\n+  inside_init = decl_constant_value_for_optimization (inside_init);\n \n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n@@ -4949,9 +5148,6 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t  return error_mark_node;\n \t}\n \n-      if (optimize && TREE_CODE (inside_init) == VAR_DECL)\n-\tinside_init = decl_constant_value_for_broken_optimization (inside_init);\n-\n       /* Compound expressions can only occur here if -pedantic or\n \t -pedantic-errors is specified.  In the later case, we always want\n \t an error.  In the former case, we simply want a warning.  */\n@@ -4976,11 +5172,15 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t  error_init (\"initializer element is not constant\");\n \t  inside_init = error_mark_node;\n \t}\n+      else if (require_constant && !maybe_const)\n+\tpedwarn_init (input_location, 0,\n+\t\t      \"initializer element is not a constant expression\");\n \n       /* Added to enable additional -Wmissing-format-attribute warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n-\tinside_init = convert_for_assignment (type, inside_init, ic_init, NULL_TREE,\n-\t\t\t\t\t      NULL_TREE, 0);\n+\tinside_init = convert_for_assignment (type, inside_init, ic_init,\n+\t\t\t\t\t      null_pointer_constant,\n+\t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n       return inside_init;\n     }\n \n@@ -4993,9 +5193,10 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n       if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n \t  && (TREE_CODE (init) == STRING_CST\n \t      || TREE_CODE (init) == COMPOUND_LITERAL_EXPR))\n-\tinit = array_to_pointer_conversion (init);\n+\tinside_init = init = array_to_pointer_conversion (init);\n       inside_init\n-\t= convert_for_assignment (type, init, ic_init,\n+\t= convert_for_assignment (type, inside_init, ic_init,\n+\t\t\t\t  null_pointer_constant,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n \n       /* Check to see if we have already given an error message.  */\n@@ -5013,6 +5214,9 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t  error_init (\"initializer element is not computable at load time\");\n \t  inside_init = error_mark_node;\n \t}\n+      else if (require_constant && !maybe_const)\n+\tpedwarn_init (input_location, 0,\n+\t\t      \"initializer element is not a constant expression\");\n \n       return inside_init;\n     }\n@@ -5072,6 +5276,10 @@ static int constructor_constant;\n /* 1 if so far this constructor's elements are all valid address constants.  */\n static int constructor_simple;\n \n+/* 1 if this constructor has an element that cannot be part of a\n+   constant expression.  */\n+static int constructor_nonconst;\n+\n /* 1 if this constructor is erroneous so far.  */\n static int constructor_erroneous;\n \n@@ -5141,6 +5349,7 @@ struct constructor_stack\n   struct constructor_range_stack *range_stack;\n   char constant;\n   char simple;\n+  char nonconst;\n   char implicit;\n   char erroneous;\n   char outer;\n@@ -5304,6 +5513,7 @@ really_start_incremental_init (tree type)\n   p->elements = constructor_elements;\n   p->constant = constructor_constant;\n   p->simple = constructor_simple;\n+  p->nonconst = constructor_nonconst;\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n@@ -5319,6 +5529,7 @@ really_start_incremental_init (tree type)\n \n   constructor_constant = 1;\n   constructor_simple = 1;\n+  constructor_nonconst = 0;\n   constructor_depth = SPELLING_DEPTH ();\n   constructor_elements = 0;\n   constructor_pending_elts = 0;\n@@ -5445,6 +5656,7 @@ push_init_level (int implicit)\n   p->elements = constructor_elements;\n   p->constant = constructor_constant;\n   p->simple = constructor_simple;\n+  p->nonconst = constructor_nonconst;\n   p->erroneous = constructor_erroneous;\n   p->pending_elts = constructor_pending_elts;\n   p->depth = constructor_depth;\n@@ -5460,6 +5672,7 @@ push_init_level (int implicit)\n \n   constructor_constant = 1;\n   constructor_simple = 1;\n+  constructor_nonconst = 0;\n   constructor_depth = SPELLING_DEPTH ();\n   constructor_elements = 0;\n   constructor_incremental = 1;\n@@ -5509,6 +5722,7 @@ push_init_level (int implicit)\n     {\n       constructor_constant = TREE_CONSTANT (value);\n       constructor_simple = TREE_STATIC (value);\n+      constructor_nonconst = CONSTRUCTOR_NON_CONST (value);\n       constructor_elements = CONSTRUCTOR_ELTS (value);\n       if (!VEC_empty (constructor_elt, constructor_elements)\n \t  && (TREE_CODE (constructor_type) == RECORD_TYPE\n@@ -5713,9 +5927,19 @@ pop_init_level (int implicit)\n \t    TREE_CONSTANT (ret.value) = 1;\n \t  if (constructor_constant && constructor_simple)\n \t    TREE_STATIC (ret.value) = 1;\n+\t  if (constructor_nonconst)\n+\t    CONSTRUCTOR_NON_CONST (ret.value) = 1;\n \t}\n     }\n \n+  if (ret.value && TREE_CODE (ret.value) != CONSTRUCTOR)\n+    {\n+      if (constructor_nonconst)\n+\tret.original_code = C_MAYBE_CONST_EXPR;\n+      else if (ret.original_code == C_MAYBE_CONST_EXPR)\n+\tret.original_code = ERROR_MARK;\n+    }\n+\n   constructor_type = p->type;\n   constructor_fields = p->fields;\n   constructor_index = p->index;\n@@ -5726,6 +5950,7 @@ pop_init_level (int implicit)\n   constructor_elements = p->elements;\n   constructor_constant = p->constant;\n   constructor_simple = p->simple;\n+  constructor_nonconst = p->nonconst;\n   constructor_erroneous = p->erroneous;\n   constructor_incremental = p->incremental;\n   constructor_designated = p->designated;\n@@ -5860,6 +6085,9 @@ set_init_index (tree first, tree last)\n     error_init (\"array index in initializer exceeds array bounds\");\n   else\n     {\n+      constant_expression_warning (first);\n+      if (last)\n+\tconstant_expression_warning (last);\n       constructor_index = convert (bitsizetype, first);\n \n       if (last)\n@@ -6348,6 +6576,8 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t\t     int pending, bool implicit)\n {\n   constructor_elt *celt;\n+  bool maybe_const = true;\n+  bool npc;\n \n   if (type == error_mark_node || value == error_mark_node)\n     {\n@@ -6374,6 +6604,9 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n       value = DECL_INITIAL (decl);\n     }\n \n+  npc = null_pointer_constant_p (value);\n+  value = c_fully_fold (value, require_constant_value, &maybe_const);\n+\n   if (value == error_mark_node)\n     constructor_erroneous = 1;\n   else if (!TREE_CONSTANT (value))\n@@ -6384,6 +6617,8 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t       && DECL_C_BIT_FIELD (field)\n \t       && TREE_CODE (value) != INTEGER_CST))\n     constructor_simple = 0;\n+  if (!maybe_const)\n+    constructor_nonconst = 1;\n \n   if (!initializer_constant_valid_p (value, TREE_TYPE (value)))\n     {\n@@ -6396,6 +6631,10 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \tpedwarn (input_location, 0,\n \t\t \"initializer element is not computable at load time\");\n     }\n+  else if (!maybe_const\n+\t   && (require_constant_value || require_constant_elements))\n+    pedwarn_init (input_location, 0,\n+\t\t  \"initializer element is not a constant expression\");\n \n   /* If this field is empty (and not at the end of structure),\n      don't do anything other than checking the initializer.  */\n@@ -6407,12 +6646,15 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t\t  || TREE_CHAIN (field)))))\n     return;\n \n-  value = digest_init (type, value, strict_string, require_constant_value);\n+  value = digest_init (type, value, npc, strict_string,\n+\t\t       require_constant_value);\n   if (value == error_mark_node)\n     {\n       constructor_erroneous = 1;\n       return;\n     }\n+  if (require_constant_value || require_constant_elements)\n+    constant_expression_warning (value);\n \n   /* If this element doesn't come next in sequence,\n      put it on constructor_pending_elts.  */\n@@ -6718,7 +6960,7 @@ process_init_element (struct c_expr value, bool implicit)\n       if (TREE_CODE (value.value) != COMPOUND_LITERAL_EXPR\n \t  || !require_constant_value\n \t  || flag_isoc99)\n-\tvalue.value = save_expr (value.value);\n+\tvalue.value = c_save_expr (value.value);\n     }\n \n   while (1)\n@@ -7191,6 +7433,7 @@ tree\n c_finish_goto_ptr (tree expr)\n {\n   pedwarn (input_location, OPT_pedantic, \"ISO C forbids %<goto *expr;%>\");\n+  expr = c_fully_fold (expr, false, NULL);\n   expr = convert (ptr_type_node, expr);\n   return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));\n }\n@@ -7203,10 +7446,17 @@ c_finish_return (tree retval)\n {\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl)), ret_stmt;\n   bool no_warning = false;\n+  bool npc = false;\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n     warning (0, \"function declared %<noreturn%> has a %<return%> statement\");\n \n+  if (retval)\n+    {\n+      npc = null_pointer_constant_p (retval);\n+      retval = c_fully_fold (retval, false, NULL);\n+    }\n+\n   if (!retval)\n     {\n       current_function_returns_null = 1;\n@@ -7231,7 +7481,7 @@ c_finish_return (tree retval)\n     }\n   else\n     {\n-      tree t = convert_for_assignment (valtype, retval, ic_return,\n+      tree t = convert_for_assignment (valtype, retval, ic_return, npc,\n \t\t\t\t       NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;\n@@ -7375,6 +7625,7 @@ c_start_case (tree exp)\n \t    warning (OPT_Wtraditional, \"%<long%> switch expression not \"\n \t\t     \"converted to %<int%> in ISO C\");\n \n+\t  exp = c_fully_fold (exp, false, NULL);\n \t  exp = default_conversion (exp);\n \n \t  if (warn_sequence_point)\n@@ -7668,6 +7919,8 @@ c_process_expr_stmt (tree expr)\n   if (!expr)\n     return NULL_TREE;\n \n+  expr = c_fully_fold (expr, false, NULL);\n+\n   if (warn_sequence_point)\n     verify_sequence_points (expr);\n \n@@ -7823,10 +8076,13 @@ c_finish_stmt_expr (tree body)\n       || (last == BIND_EXPR_BODY (body)\n \t  && BIND_EXPR_VARS (body) == NULL))\n     {\n+      /* Even if this looks constant, do not allow it in a constant\n+\t expression.  */\n+      last = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (last), NULL_TREE, last);\n+      C_MAYBE_CONST_EXPR_NON_CONST (last) = 1;\n       /* Do not warn if the return value of a statement expression is\n \t unused.  */\n-      if (CAN_HAVE_LOCATION_P (last))\n-\tTREE_NO_WARNING (last) = 1;\n+      TREE_NO_WARNING (last) = 1;\n       return last;\n     }\n \n@@ -8018,6 +8274,7 @@ build_binary_op (location_t location, enum tree_code code,\n   tree op0, op1;\n   tree ret = error_mark_node;\n   const char *invalid_op_diag;\n+  bool int_const, int_const_or_overflow, int_operands;\n \n   /* Expression code to give to the expression when it is built.\n      Normally this is CODE, which is what the caller asked for,\n@@ -8067,6 +8324,19 @@ build_binary_op (location_t location, enum tree_code code,\n   if (location == UNKNOWN_LOCATION)\n     location = input_location;\n \n+  int_operands = (EXPR_INT_CONST_OPERANDS (orig_op0)\n+\t\t  && EXPR_INT_CONST_OPERANDS (orig_op1));\n+  if (int_operands)\n+    {\n+      int_const_or_overflow = (TREE_CODE (orig_op0) == INTEGER_CST\n+\t\t\t       && TREE_CODE (orig_op1) == INTEGER_CST);\n+      int_const = (int_const_or_overflow\n+\t\t   && !TREE_OVERFLOW (orig_op0)\n+\t\t   && !TREE_OVERFLOW (orig_op1));\n+    }\n+  else\n+    int_const = int_const_or_overflow = false;\n+\n   if (convert_p)\n     {\n       op0 = default_conversion (orig_op0);\n@@ -8233,6 +8503,28 @@ build_binary_op (location_t location, enum tree_code code,\n \t  op1 = c_common_truthvalue_conversion (location, op1);\n \t  converted = 1;\n \t}\n+      if (code == TRUTH_ANDIF_EXPR)\n+\t{\n+\t  int_const_or_overflow = (int_operands\n+\t\t\t\t   && TREE_CODE (orig_op0) == INTEGER_CST\n+\t\t\t\t   && (op0 == truthvalue_false_node\n+\t\t\t\t       || TREE_CODE (orig_op1) == INTEGER_CST));\n+\t  int_const = (int_const_or_overflow\n+\t\t       && !TREE_OVERFLOW (orig_op0)\n+\t\t       && (op0 == truthvalue_false_node\n+\t\t\t   || !TREE_OVERFLOW (orig_op1)));\n+\t}\n+      else if (code == TRUTH_ORIF_EXPR)\n+\t{\n+\t  int_const_or_overflow = (int_operands\n+\t\t\t\t   && TREE_CODE (orig_op0) == INTEGER_CST\n+\t\t\t\t   && (op0 == truthvalue_true_node\n+\t\t\t\t       || TREE_CODE (orig_op1) == INTEGER_CST));\n+\t  int_const = (int_const_or_overflow\n+\t\t       && !TREE_OVERFLOW (orig_op0)\n+\t\t       && (op0 == truthvalue_true_node\n+\t\t\t   || !TREE_OVERFLOW (orig_op1)));\n+\t}\n       break;\n \n       /* Shift operations: result has same type as first operand;\n@@ -8243,17 +8535,25 @@ build_binary_op (location_t location, enum tree_code code,\n       if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE)\n \t  && code1 == INTEGER_TYPE)\n \t{\n-\t  if (TREE_CODE (op1) == INTEGER_CST && skip_evaluation == 0)\n+\t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_sgn (op1) < 0)\n-\t\twarning (0, \"right shift count is negative\");\n+\t\t{\n+\t\t  int_const = false;\n+\t\t  if (skip_evaluation == 0)\n+\t\t    warning (0, \"right shift count is negative\");\n+\t\t}\n \t      else\n \t\t{\n \t\t  if (!integer_zerop (op1))\n \t\t    short_shift = 1;\n \n \t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n-\t\t    warning (0, \"right shift count >= width of type\");\n+\t\t    {\n+\t\t      int_const = false;\n+\t\t      if (skip_evaluation == 0)\n+\t\t\twarning (0, \"right shift count >= width of type\");\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -8272,13 +8572,21 @@ build_binary_op (location_t location, enum tree_code code,\n       if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE)\n \t  && code1 == INTEGER_TYPE)\n \t{\n-\t  if (TREE_CODE (op1) == INTEGER_CST && skip_evaluation == 0)\n+\t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_sgn (op1) < 0)\n-\t\twarning (0, \"left shift count is negative\");\n+\t\t{\n+\t\t  int_const = false;\n+\t\t  if (skip_evaluation == 0)\n+\t\t    warning (0, \"left shift count is negative\");\n+\t\t}\n \n \t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n-\t\twarning (0, \"left shift count >= width of type\");\n+\t\t{\n+\t\t  int_const = false;\n+\t\t  if (skip_evaluation == 0)\n+\t\t    warning (0, \"left shift count >= width of type\");\n+\t\t}\n \t    }\n \n \t  /* Use the type of the value to be shifted.  */\n@@ -8531,10 +8839,54 @@ build_binary_op (location_t location, enum tree_code code,\n \t  converted = 1;\n \t  resultcode = xresultcode;\n \n-\t  if (warn_sign_compare && !skip_evaluation)\n-            {\n-              warn_for_sign_compare (location, orig_op0, orig_op1, op0, op1, \n-                                     result_type, resultcode);\n+\t  if (!skip_evaluation)\n+\t    {\n+\t      bool op0_maybe_const = true;\n+\t      bool op1_maybe_const = true;\n+\t      tree orig_op0_folded, orig_op1_folded;\n+\n+\t      if (in_late_binary_op)\n+\t\t{\n+\t\t  orig_op0_folded = orig_op0;\n+\t\t  orig_op1_folded = orig_op1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Fold for the sake of possible warnings, as in\n+\t\t     build_conditional_expr.  This requires the\n+\t\t     \"original\" values to be folded, not just op0 and\n+\t\t     op1.  */\n+\t\t  op0 = c_fully_fold (op0, require_constant_value,\n+\t\t\t\t      &op0_maybe_const);\n+\t\t  op1 = c_fully_fold (op1, require_constant_value,\n+\t\t\t\t      &op1_maybe_const);\n+\t\t  orig_op0_folded = c_fully_fold (orig_op0,\n+\t\t\t\t\t\t  require_constant_value,\n+\t\t\t\t\t\t  NULL);\n+\t\t  orig_op1_folded = c_fully_fold (orig_op1,\n+\t\t\t\t\t\t  require_constant_value,\n+\t\t\t\t\t\t  NULL);\n+\t\t}\n+\n+\t      if (warn_sign_compare)\n+\t\twarn_for_sign_compare (location, orig_op0_folded,\n+\t\t\t\t       orig_op1_folded, op0, op1,\n+\t\t\t\t       result_type, resultcode);\n+\t      if (!in_late_binary_op)\n+\t\t{\n+\t\t  if (!op0_maybe_const || TREE_CODE (op0) != INTEGER_CST)\n+\t\t    {\n+\t\t      op0 = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (op0),\n+\t\t\t\t    NULL, op0);\n+\t\t      C_MAYBE_CONST_EXPR_NON_CONST (op0) = !op0_maybe_const;\n+\t\t    }\n+\t\t  if (!op1_maybe_const || TREE_CODE (op1) != INTEGER_CST)\n+\t\t    {\n+\t\t      op1 = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (op1),\n+\t\t\t\t    NULL, op1);\n+\t\t      C_MAYBE_CONST_EXPR_NON_CONST (op1) = !op1_maybe_const;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n@@ -8568,16 +8920,24 @@ build_binary_op (location_t location, enum tree_code code,\n     build_type = result_type;\n \n   /* Treat expressions in initializers specially as they can't trap.  */\n-  ret = require_constant_value ? fold_build2_initializer (resultcode,\n-\t\t\t\t\t\t\t  build_type,\n-\t\t\t\t\t\t\t  op0, op1)\n-\t\t\t       : fold_build2 (resultcode, build_type,\n-\t\t\t\t\t      op0, op1);\n+  if (int_const_or_overflow)\n+    ret = (require_constant_value\n+\t   ? fold_build2_initializer (resultcode, build_type, op0, op1)\n+\t   : fold_build2 (resultcode, build_type, op0, op1));\n+  else\n+    ret = build2 (resultcode, build_type, op0, op1);\n   if (final_type != 0)\n     ret = convert (final_type, ret);\n \n  return_build_binary_op:\n   gcc_assert (ret != error_mark_node);\n+  if (TREE_CODE (ret) == INTEGER_CST && !TREE_OVERFLOW (ret) && !int_const)\n+    ret = (int_operands\n+\t   ? note_integer_operands (ret)\n+\t   : build1 (NOP_EXPR, TREE_TYPE (ret), ret));\n+  else if (TREE_CODE (ret) != INTEGER_CST && int_operands\n+\t   && !in_late_binary_op)\n+    ret = note_integer_operands (ret);\n   protected_set_expr_location (ret, location);\n   return ret;\n }\n@@ -8589,6 +8949,8 @@ build_binary_op (location_t location, enum tree_code code,\n tree\n c_objc_common_truthvalue_conversion (location_t location, tree expr)\n {\n+  bool int_const, int_operands;\n+\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n     case ARRAY_TYPE:\n@@ -8610,9 +8972,23 @@ c_objc_common_truthvalue_conversion (location_t location, tree expr)\n       break;\n     }\n \n+  int_const = (TREE_CODE (expr) == INTEGER_CST && !TREE_OVERFLOW (expr));\n+  int_operands = EXPR_INT_CONST_OPERANDS (expr);\n+\n   /* ??? Should we also give an error for void and vectors rather than\n      leaving those to give errors later?  */\n-  return c_common_truthvalue_conversion (location, expr);\n+  expr = c_common_truthvalue_conversion (location, expr);\n+\n+  if (TREE_CODE (expr) == INTEGER_CST && int_operands && !int_const)\n+    {\n+      if (TREE_OVERFLOW (expr))\n+\treturn expr;\n+      else\n+\treturn note_integer_operands (expr);\n+    }\n+  if (TREE_CODE (expr) == INTEGER_CST && !int_const)\n+    return build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n+  return expr;\n }\n \f\n "}, {"sha": "9500feb1112c1f2b580d1460942b45c77845bbed", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -663,6 +663,10 @@ A @code{typeof}-construct can be used anywhere a typedef name could be\n used.  For example, you can use it in a declaration, in a cast, or inside\n of @code{sizeof} or @code{typeof}.\n \n+The operand of @code{typeof} is evaluated for its side effects if and\n+only if it is an expression of variably modified type or the name of\n+such a type.\n+\n @code{typeof} is often useful in conjunction with the\n statements-within-expressions feature.  Here is how the two together can\n be used to define a safe ``maximum'' macro that operates on any\n@@ -6635,9 +6639,8 @@ depending on the arguments' types.  For example:\n \n You can use the built-in function @code{__builtin_choose_expr} to\n evaluate code depending on the value of a constant expression.  This\n-built-in function returns @var{exp1} if @var{const_exp}, which is a\n-constant expression that must be able to be determined at compile time,\n-is nonzero.  Otherwise it returns 0.\n+built-in function returns @var{exp1} if @var{const_exp}, which is an\n+integer constant expression, is nonzero.  Otherwise it returns 0.\n \n This built-in function is analogous to the @samp{? :} operator in C,\n except that the expression returned has its type unaltered by promotion\n@@ -6716,7 +6719,11 @@ static const int table[] = @{\n \n @noindent\n This is an acceptable initializer even if @var{EXPRESSION} is not a\n-constant expression.  GCC must be more conservative about evaluating the\n+constant expression, including the case where\n+@code{__builtin_constant_p} returns 1 because @var{EXPRESSION} can be\n+folded to a constant but @var{EXPRESSION} contains operands that would\n+not otherwize be permitted in a static initializer (for example,\n+@code{0 && foo ()}).  GCC must be more conservative about evaluating the\n built-in in this case, because it has no opportunity to perform\n optimization.\n "}, {"sha": "4a9668fef77c82f5ccd088c6b5d35581d63de217", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,3 +1,13 @@\n+2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/456\n+\tPR c/5675\n+\tPR c/19976\n+\tPR c/29116\n+\tPR c/31871\n+\tPR c/35198\n+\t* objc-act.c (objc_finish_try_stmt): Set in_late_binary_op.\n+\n 2008-12-05  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR bootstrap/38262"}, {"sha": "df3a719ba9375b39833dc7dbdad727ec2752fabc", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,6 +1,6 @@\n /* Implement classes and message passing for Objective C.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n+   2002, 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Steve Naroff.\n \n This file is part of GCC.\n@@ -3885,12 +3885,15 @@ objc_finish_try_stmt (void)\n   /* If we're doing Darwin setjmp exceptions, build the big nasty.  */\n   if (flag_objc_sjlj_exceptions)\n     {\n+      bool save = in_late_binary_op;\n+      in_late_binary_op = true;\n       if (!cur_try_context->finally_body)\n \t{\n \t  cur_try_context->finally_locus = input_location;\n \t  cur_try_context->end_finally_locus = input_location;\n \t}\n       stmt = next_sjlj_build_try_catch_finally ();\n+      in_late_binary_op = save;\n     }\n   else\n     {"}, {"sha": "4588cab3d1edcc99bbb5d80368a8acd009dff0ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,3 +1,40 @@\n+2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/456\n+\tPR c/5675\n+\tPR c/19976\n+\tPR c/29116\n+\tPR c/31871\n+\tPR c/35198\n+\t* gcc.c-torture/compile/20081108-1.c,\n+\tgcc.c-torture/compile/20081108-2.c,\n+\tgcc.c-torture/compile/20081108-3.c, gcc.dg/bconstp-2.c,\n+\tgcc.dg/bconstp-3.c, gcc.dg/bconstp-4.c, gcc.dg/c90-const-expr-6.c,\n+\tgcc.dg/c90-const-expr-7.c, gcc.dg/c90-const-expr-8.c,\n+\tgcc.dg/c90-const-expr-9.c, gcc.dg/c90-const-expr-10.c,\n+\tgcc.dg/c90-const-expr-11.c, gcc.dg/c99-const-expr-6.c,\n+\tgcc.dg/c99-const-expr-7.c, gcc.dg/c99-const-expr-8.c,\n+\tgcc.dg/c99-const-expr-9.c, gcc.dg/c99-const-expr-10.c,\n+\tgcc.dg/c99-const-expr-11.c, gcc.dg/c99-const-expr-12.c,\n+\tgcc.dg/c99-const-expr-13.c, gcc.dg/compare10.c,\n+\tgcc.dg/gnu89-const-expr-1.c, gcc.dg/gnu89-const-expr-2.c,\n+\tgcc.dg/gnu99-const-expr-1.c, gcc.dg/gnu99-const-expr-2.c,\n+\tgcc.dg/gnu99-const-expr-3.c, gcc.dg/vla-12.c, gcc.dg/vla-13.c,\n+\tgcc.dg/vla-14.c, gcc.dg/vla-15.c, gcc.dg/vla-16.c: New tests.\n+\t* gcc.dg/c90-const-expr-1.c, gcc.dg/c90-const-expr-2.c,\n+\tgcc.dg/c90-const-expr-3.c, gcc.dg/c99-const-expr-2.c,\n+\tgcc.dg/c99-const-expr-3.c, gcc.dg/c99-static-1.c: Remove XFAILs.\n+\t* gcc.dg/c90-const-expr-2.c: Use ZERO in place of 0 in another\n+\tcase.\n+\t* gcc.dg/overflow-warn-1.c, gcc.dg/overflow-warn-2.c,\n+\tgcc.dg/overflow-warn-3.c, gcc.dg/overflow-warn-4.c: Remove\n+\tXFAILs.  Update expected messages.\n+\t* gcc.dg/pr14649-1.c, gcc.dg/pr19984.c, gcc.dg/pr25682.c: Update\n+\texpected messages.\n+\t* gcc.dg/real-const-1.c: Replace with test from original PR.\n+\t* gcc.dg/vect/pr32230.c: Use intermediate cast to __PTRDIFF_TYPE__\n+\twhen casting from non-constant integer to pointer.\n+\n 2009-03-29  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/forwprop-11.c: New testcase."}, {"sha": "3209a90c83bc8683b89705df656221e3b43657b7", "filename": "gcc/testsuite/gcc.c-torture/compile/20081108-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,11 @@\n+/* Test function call with function designator involving VLA\n+   side-effects does not lead to an ICE.  */\n+\n+void f (void);\n+void g (void);\n+\n+void\n+h (int a, void *b)\n+{\n+  ((void *)(int (*)[++a])b ? f : g) ();\n+}"}, {"sha": "2f5a7f64b352a34557f6f696c04b3ae898d2639f", "filename": "gcc/testsuite/gcc.c-torture/compile/20081108-2.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,4 @@\n+/* Test boolean conversion as part of returning unsigned value does\n+   not lead to an ICE.  */\n+\n+_Bool f(unsigned a) { return a & 1; }"}, {"sha": "12c58ba98cfc2d966a7d54caaa035e72907a1cc8", "filename": "gcc/testsuite/gcc.c-torture/compile/20081108-3.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20081108-3.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,4 @@\n+/* Test boolean conversion of an overflowing integer return value does\n+   not lead to an ICE.  */\n+\n+_Bool f(void) { return __INT_MAX__ + 1; }"}, {"sha": "5b5ff8b1cf1174a603e5d5decf45917debc862cd", "filename": "gcc/testsuite/gcc.dg/bconstp-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,27 @@\n+/* As bconstp-1.c, but with the __builtin_constant_p calls\n+   parenthesized.  */\n+/* { dg-do compile } */\n+\n+/* This test checks that builtin_constant_p can be used safely in\n+   initializers for static data.  The macro X() defined below should\n+   be an acceptable initializer expression no matter how complex its\n+   argument is.  */\n+\n+extern int a;\n+extern int b;\n+\n+extern int foo(void);\n+extern int bar(void);\n+\n+#define X(exp) ((__builtin_constant_p(exp)) ? (exp) : -1)\n+\n+const short tests[] = {\n+  X(0),\n+  X(a),\n+  X(0 && a),\n+  X(a && b),\n+  X(foo()),\n+  X(0 && foo()),\n+  X(a && foo()),\n+  X(foo() && bar())\n+};"}, {"sha": "9e3d10f3993067c6d385367e3d50ca6e2ecec2ff", "filename": "gcc/testsuite/gcc.dg/bconstp-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-3.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,27 @@\n+/* As bconstp-1.c, but with the __builtin_constant_p calls inside\n+   __builtin_choose_expr.  */\n+/* { dg-do compile } */\n+\n+/* This test checks that builtin_constant_p can be used safely in\n+   initializers for static data.  The macro X() defined below should\n+   be an acceptable initializer expression no matter how complex its\n+   argument is.  */\n+\n+extern int a;\n+extern int b;\n+\n+extern int foo(void);\n+extern int bar(void);\n+\n+#define X(exp) (__builtin_choose_expr(1, __builtin_constant_p(exp), 1) ? (exp) : -1)\n+\n+const short tests[] = {\n+  X(0),\n+  X(a),\n+  X(0 && a),\n+  X(a && b),\n+  X(foo()),\n+  X(0 && foo()),\n+  X(a && foo()),\n+  X(foo() && bar())\n+};"}, {"sha": "bb8aef19fc027e9aced7326c5ed06dd8a86009ee", "filename": "gcc/testsuite/gcc.dg/bconstp-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-4.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,10 @@\n+/* Test that a condition is not counted as a call to\n+   __builtin_constant_p if that call is itself inside a conditional\n+   expression with __builtin_constant_p condition.  */\n+/* { dg-do compile } */\n+\n+extern int foo(void);\n+\n+#define X(exp) (__builtin_choose_expr(1, __builtin_constant_p(exp), 1) ? (exp) : -1)\n+\n+const int x = ((__builtin_constant_p(1) ? __builtin_constant_p (0 && foo()) : 0) ? (0 && foo()) : -1); /* { dg-error \"initializer element is not a constant expression\" } */"}, {"sha": "e4c27ac4561be6c51e447526387cc531c3e07fb0", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -15,9 +15,9 @@ void\n foo (void)\n {\n   int i;\n-  static int j = (1 ? 0 : (i = 2)); /* { dg-error \"initial\" \"assignment\" { xfail *-*-* } } */\n-  static int k = (1 ? 0 : ++i); /* { dg-error \"initial\" \"increment\" { xfail *-*-* } } */\n-  static int l = (1 ? 0 : --i); /* { dg-error \"initial\" \"decrement\" { xfail *-*-* } } */\n-  static int m = (1 ? 0 : bar ()); /* { dg-error \"initial\" \"function call\" { xfail *-*-* } } */\n-  static int n = (1 ? 0 : (2, 3)); /* { dg-error \"initial\" \"comma\" { xfail *-*-* } } */\n+  static int j = (1 ? 0 : (i = 2)); /* { dg-error \"initial\" \"assignment\" } */\n+  static int k = (1 ? 0 : ++i); /* { dg-error \"initial\" \"increment\" } */\n+  static int l = (1 ? 0 : --i); /* { dg-error \"initial\" \"decrement\" } */\n+  static int m = (1 ? 0 : bar ()); /* { dg-error \"initial\" \"function call\" } */\n+  static int n = (1 ? 0 : (2, 3)); /* { dg-error \"initial\" \"comma\" } */\n }"}, {"sha": "6159390bb94dc6e0e16ca8099f498b2787b8991c", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-10.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-10.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,28 @@\n+/* Test for constant expressions: invalid null pointer constants in\n+   various contexts (make sure NOPs are not inappropriately\n+   stripped).  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+void *p = (__SIZE_TYPE__)(void *)0; /* { dg-error \"without a cast\" } */\n+struct s { void *a; } q = { (__SIZE_TYPE__)(void *)0 }; /* { dg-error \"without a cast\" } */\n+void *\n+f (void)\n+{\n+  void *r;\n+  r = (__SIZE_TYPE__)(void *)0; /* { dg-error \"without a cast\" } */\n+  return (__SIZE_TYPE__)(void *)0; /* { dg-error \"without a cast\" } */\n+}\n+void g (void *); /* { dg-message \"but argument is of type\" } */\n+void\n+h (void)\n+{\n+  g ((__SIZE_TYPE__)(void *)0); /* { dg-error \"without a cast\" } */\n+}\n+void g2 (int, void *); /* { dg-message \"but argument is of type\" } */\n+void\n+h2 (void)\n+{\n+  g2 (0, (__SIZE_TYPE__)(void *)0); /* { dg-error \"without a cast\" } */\n+}"}, {"sha": "cfda93e12a44f675c956474cbede8a5fe145aba6", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-11.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-11.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,27 @@\n+/* Test for constant expressions: C90 aggregate initializers requiring\n+   constant expressions.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors -O2\" } */\n+\n+#include <float.h>\n+#include <limits.h>\n+\n+double atan(double);\n+\n+struct s { double d; };\n+struct t { int i; };\n+\n+void\n+f (void)\n+{\n+  /* As in PR 14649 for static initializers.  */\n+  struct s a = { atan (1.0) }; /* { dg-error \"is not a constant expression|near initialization\" } */\n+  /* Overflow.  */\n+  struct t b = { INT_MAX + 1 }; /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  struct t c = { DBL_MAX }; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 23 } */\n+  /* Bad operator outside sizeof.  */\n+  struct s d = { 1 ? 1.0 : atan (a.d) }; /* { dg-error \"is not a constant expression|near initialization\" } */\n+}"}, {"sha": "662d8e790dcd62d1c8127ffd59b4d4e11fce0967", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -34,10 +34,10 @@ foo (void)\n {\n   ASSERT_NPC (0);\n   ASSERT_NPC ((void *)0);\n-  ASSERT_NOT_NPC ((void *)(void *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC ((void *)(char *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((void *)(void *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC ((void *)(char *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NOT_NPC ((void *)(0, ZERO)); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n-  ASSERT_NOT_NPC ((void *)(&\"Foobar\"[0] - &\"Foobar\"[0])); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((void *)(&\"Foobar\"[0] - &\"Foobar\"[0])); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   /* This last one is a null pointer constant in C99 only.  */\n-  ASSERT_NOT_NPC ((void *)(1 ? 0 : (0, 0))); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((void *)(1 ? ZERO : (0, ZERO))); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n }"}, {"sha": "46a02273445b7438d1ff948e813493abe0580280", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-3.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-3.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -28,19 +28,19 @@ foo (void)\n   ASSERT_NPC (0);\n   ASSERT_NOT_NPC (ZERO);\n   ASSERT_NPC (0 + 0);\n-  ASSERT_NOT_NPC (ZERO + 0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC (ZERO + ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC (ZERO + 0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC (ZERO + ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NPC (+0);\n-  ASSERT_NOT_NPC (+ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC (+ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NPC (-0);\n-  ASSERT_NOT_NPC (-ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC (-ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NPC ((char) 0);\n   ASSERT_NOT_NPC ((char) ZERO);\n   ASSERT_NPC ((int) 0);\n   ASSERT_NOT_NPC ((int) ZERO);\n   ASSERT_NPC ((int) 0.0);\n   ASSERT_NOT_NPC ((int) DZERO);\n-  ASSERT_NOT_NPC ((int) +0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC ((int) (0.0+0.0)); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC ((int) (double)0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((int) +0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC ((int) (0.0+0.0)); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC ((int) (double)0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n }"}, {"sha": "50de3a9525f80f0b752e8b048c5e4dfd8a0bcc77", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-6.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-6.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,53 @@\n+/* Test for constant expressions: operands and casts not permitted in\n+   integer constant expressions.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+/* PR 29116.  */\n+int n = 0, p[n * 0 + 1]; /* { dg-error \"variabl|can't be evaluated\" } */\n+\n+/* PR 31871.  */\n+extern int c[1 + ((__PTRDIFF_TYPE__) (void *) 0)]; /* { dg-error \"variab|can't be evaluated\" } */\n+\n+/* Implicit conversions from floating-point constants are not OK,\n+   although explicit ones are.  */\n+extern int c1[1.0 ? 1 : 0]; /* { dg-error \"variab|can't be evaluated\" } */\n+\n+extern int c2[(int)1.0 ? 1 : 0];\n+\n+extern int c3[1.0 && 1]; /* { dg-error \"variab|can't be evaluated\" } */\n+\n+extern int c4[(int)1.0 && 1];\n+\n+extern int c5[1.0 || 1]; /* { dg-error \"variab|can't be evaluated\" } */\n+\n+extern int c6[(int)1.0 || 1];\n+\n+/* Similar with various other cases where integer constant expressions\n+   are required.  */\n+\n+struct s {\n+  int a : (n * 0 + 1); /* { dg-error \"constant\" } */\n+};\n+\n+enum e {\n+  E = (1 + ((__PTRDIFF_TYPE__) (void *) 0)), /* { dg-error \"constant\" } */\n+  E2 = 0\n+};\n+\n+enum f {\n+  F = (1 ? 1 : n), /* { dg-error \"constant\" } */\n+  F2 = 0\n+};\n+\n+void\n+f (int a)\n+{\n+  int v[1 + ((__PTRDIFF_TYPE__) (void *) 0)]; /* { dg-error \"variab|can't be evaluated\" } */\n+  switch (a)\n+    {\n+    case (n * 0 + 1): /* { dg-error \"constant\" } */\n+      ;\n+    }\n+}"}, {"sha": "30aeba06a7c7277db3bcdee0fac71c1c983c544c", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-7.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-7.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,35 @@\n+/* Test for constant expressions: overflow and constant expressions;\n+   see also overflow-warn-*.c for some other cases.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+#include <float.h>\n+\n+int a = DBL_MAX; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 9 } */\n+int b = (int) DBL_MAX; /* { dg-error \"overflow\" \"\" } */\n+unsigned int c = -1.0; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 12 } */\n+unsigned int d = (unsigned)-1.0; /* { dg-error \"overflow\" } */\n+\n+int e = 0 << 1000; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 16 } */\n+int f = 0 << -1; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 18 } */\n+int g = 0 >> 1000; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 20 } */\n+int h = 0 >> -1; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 22 } */\n+\n+int b1 = (0 ? (int) DBL_MAX : 0);\n+unsigned int d1 = (0 ? (unsigned int)-1.0 : 0);\n+int e1 = (0 ? 0 << 1000 : 0);\n+int f1 = (0 ? 0 << -1 : 0);\n+int g1 = (0 ? 0 >> 1000 : 0);\n+int h1 = (0 ? 0 >> -1: 0);\n+\n+int i = -1 << 0;\n+\n+int j[1] = { DBL_MAX }; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 34 } */"}, {"sha": "966044c4eff143465b6e4872a77972e1fdf36583", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-8.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,27 @@\n+/* Test for constant expressions: overflow and constant expressions\n+   with -fwrapv: overflows still count as such for the purposes of\n+   constant expressions even when they have defined values at\n+   runtime.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors -fwrapv\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 12 } */\n+  E1 = 0 * (INT_MIN / -1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 14 } */\n+  E2 = 0 * (INT_MAX * INT_MAX), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 16 } */\n+  E3 = 0 * (INT_MIN - 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 18 } */\n+  E4 = 0 * (unsigned)(INT_MIN - 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 20 } */\n+  E5 = 0 * -INT_MIN, /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 22 } */\n+  E6 = 0 * !-INT_MIN, /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"not an integer constant\" \"constant\" { target *-*-* } 24 } */\n+  E7 = INT_MIN % -1 /* Not an overflow.  */\n+};"}, {"sha": "d9ab37565995b8128351c81343554c3a18ad6362", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-9.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-9.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,26 @@\n+/* Test for constant expressions: __builtin_offsetof allowed in\n+   integer constant expressions but not traditional offsetof\n+   expansion.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+struct s {\n+  int a;\n+};\n+\n+struct t {\n+  struct s a;\n+  int b[2];\n+};\n+\n+#define old_offsetof(TYPE, MEMBER) ((__SIZE_TYPE__) &((TYPE *)0)->MEMBER)\n+\n+enum e {\n+  E1 = old_offsetof (struct s, a), /* { dg-error \"constant\" } */\n+  E2 = old_offsetof (struct t, a.a), /* { dg-error \"constant\" } */\n+  E3 = old_offsetof (struct t, b[1]), /* { dg-error \"constant\" } */\n+  E4 = __builtin_offsetof (struct s, a),\n+  E5 = __builtin_offsetof (struct t, a.a),\n+  E6 = __builtin_offsetof (struct t, b[1])\n+};"}, {"sha": "8e5a1043d290a1017dde33d15f1eacf0fa8597fa", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-10.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-10.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,28 @@\n+/* Test for constant expressions: invalid null pointer constants in\n+   various contexts (make sure NOPs are not inappropriately\n+   stripped).  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+void *p = (__SIZE_TYPE__)(void *)0; /* { dg-error \"without a cast\" } */\n+struct s { void *a; } q = { (__SIZE_TYPE__)(void *)0 }; /* { dg-error \"without a cast\" } */\n+void *\n+f (void)\n+{\n+  void *r;\n+  r = (__SIZE_TYPE__)(void *)0; /* { dg-error \"without a cast\" } */\n+  return (__SIZE_TYPE__)(void *)0; /* { dg-error \"without a cast\" } */\n+}\n+void g (void *); /* { dg-message \"but argument is of type\" } */\n+void\n+h (void)\n+{\n+  g ((__SIZE_TYPE__)(void *)0); /* { dg-error \"without a cast\" } */\n+}\n+void g2 (int, void *); /* { dg-message \"but argument is of type\" } */\n+void\n+h2 (void)\n+{\n+  g2 (0, (__SIZE_TYPE__)(void *)0); /* { dg-error \"without a cast\" } */\n+}"}, {"sha": "21d9c5f46a20ba428da0f3fb5e0e9fbd470b7231", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-11.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-11.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,46 @@\n+/* Test for constant expressions: cases involving VLAs.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+/* It appears address constants may contain casts to variably modified\n+   types.  Whether they should be permitted was discussed in\n+   <http://groups.google.com/group/comp.std.c/msg/923eee5ab690fd98>\n+   <LV7g2Vy3ARF$Ew9Q@romana.davros.org>; since static pointers to VLAs\n+   are definitely permitted within functions and may be initialized\n+   and such initialization involves implicit conversion to a variably\n+   modified type, allowing explicit casts seems appropriate.  Thus,\n+   GCC allows them as long as the \"evaluated\" size expressions do not\n+   contain the various operators not permitted to be evaluated in a\n+   constant expression, and as long as the result is genuinely\n+   constant (meaning that pointer arithmetic using the size of the VLA\n+   is generally not permitted).  */\n+\n+static int sa[100];\n+\n+volatile int nv;\n+\n+int\n+f (int m, int n)\n+{\n+  static int (*a1)[n] = &sa;\n+  static int (*a2)[n] = (int (*)[n])sa;\n+  static int (*a3)[n] = (int (*)[(int){n}])sa;\n+  static int (*a4)[n] = (int (*)[(int){m++}])sa; /* { dg-error \"constant\" } */\n+  static int (*a5)[n] = (int (*)[(int){++m}])sa; /* { dg-error \"constant\" } */\n+  static int (*a6)[n] = (int (*)[(int){m--}])sa; /* { dg-error \"constant\" } */\n+  static int (*a7)[n] = (int (*)[(int){--m}])sa; /* { dg-error \"constant\" } */\n+  static int (*a8)[n] = (int (*)[(m=n)])sa; /* { dg-error \"constant\" } */\n+  static int (*a9)[n] = (int (*)[(m+=n)])sa; /* { dg-error \"constant\" } */\n+  static int (*a10)[n] = (int (*)[f(m,n)])sa; /* { dg-error \"constant\" } */\n+  static int (*a11)[n] = (int (*)[(m,n)])sa; /* { dg-error \"constant\" } */\n+  static int (*a12)[n] = (int (*)[sizeof(int[n])])sa;\n+  static int (*a13)[n] = (int (*)[sizeof(int[m++])])sa; /* { dg-error \"constant\" } */\n+  static int (*a14)[n] = (int (*)[sizeof(*a1)])sa;\n+  static int (*a15)[n] = (int (*)[sizeof(*(int (*)[n])sa)])sa;\n+  static int (*a16)[n] = (int (*)[sizeof(*(int (*)[m++])sa)])sa; /* { dg-error \"constant\" } */\n+  static int (*a17)[n] = (int (*)[nv])sa;\n+  typedef int (*vmt)[m++];\n+  static int (*a18)[n] = (vmt)sa;\n+  return n;\n+}"}, {"sha": "396cea51acc2977fe35b004cb40553fed20bd2a3", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-12.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-12.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,23 @@\n+/* Test for constant expressions: VLA size constraints.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+void\n+f (int m)\n+{\n+  /* An array size that is a constant expression, not just an integer\n+     constant expression, must be checked for being positive, but only\n+     an integer constant expression makes it not a VLA (which affects\n+     certain compatibility checks, in particular).  */\n+  int a1[0]; /* { dg-error \"zero\" } */\n+  int a2[-1]; /* { dg-error \"negative\" } */\n+  int a3[(int)(double)0.0]; /* { dg-error \"zero\" } */\n+  int a4[(int)-1.0]; /* { dg-error \"negative\" } */\n+  int a5[(int)+1.0];\n+  int a6[(int)+2.0];\n+  void *p = (m ? &a5 : &a6);\n+  int a7[(int)1.0];\n+  int a8[(int)2.0];\n+  void *q = (m ? &a7 : &a8); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+}"}, {"sha": "0ee525bec61c85656b2733899a760ca60bb1a077", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-13.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-13.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,15 @@\n+/* Test for constant expressions: VLA size constraints with\n+   -frounding-math.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors -frounding-math\" } */\n+\n+void\n+f (void)\n+{\n+  /* With -frounding-math, presume that floating-point expressions\n+     that may depend on the rounding mode do not count as arithmetic\n+     constant expressions, and so arrays involving such expressions in\n+     their sizes do not have the size checked for being negative.  */\n+  int a1[(int)(-5.0/3.0)];\n+}"}, {"sha": "8e5a600185f063bbc14e1b9fed60c67e07b3f609", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -34,10 +34,10 @@ foo (void)\n {\n   ASSERT_NPC (0);\n   ASSERT_NPC ((void *)0);\n-  ASSERT_NOT_NPC ((void *)(void *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC ((void *)(char *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((void *)(void *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC ((void *)(char *)0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NOT_NPC ((void *)(0, ZERO)); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n-  ASSERT_NOT_NPC ((void *)(&\"Foobar\"[0] - &\"Foobar\"[0])); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((void *)(&\"Foobar\"[0] - &\"Foobar\"[0])); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   /* This last one is a null pointer constant in C99 only.  */\n   ASSERT_NPC ((void *)(1 ? 0 : (0, 0)));\n }"}, {"sha": "9b036a32d162175726f2919f11e6d75a4bdcd662", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-3.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-3.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -27,19 +27,19 @@ foo (void)\n   ASSERT_NPC (0);\n   ASSERT_NOT_NPC (ZERO);\n   ASSERT_NPC (0 + 0);\n-  ASSERT_NOT_NPC (ZERO + 0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC (ZERO + ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC (ZERO + 0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC (ZERO + ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NPC (+0);\n-  ASSERT_NOT_NPC (+ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC (+ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NPC (-0);\n-  ASSERT_NOT_NPC (-ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC (-ZERO); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n   ASSERT_NPC ((char) 0);\n   ASSERT_NOT_NPC ((char) ZERO);\n   ASSERT_NPC ((int) 0);\n   ASSERT_NOT_NPC ((int) ZERO);\n   ASSERT_NPC ((int) 0.0);\n   ASSERT_NOT_NPC ((int) DZERO);\n-  ASSERT_NOT_NPC ((int) +0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC ((int) (0.0+0.0)); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n-  ASSERT_NOT_NPC ((int) (double)0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" { xfail *-*-* } } */\n+  ASSERT_NOT_NPC ((int) +0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC ((int) (0.0+0.0)); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n+  ASSERT_NOT_NPC ((int) (double)0.0); /* { dg-bogus \"incompatible\" \"bogus null pointer constant\" } */\n }"}, {"sha": "1a31ddc40c4556b61134c3d7a8834c44a64c0358", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-6.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-6.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,62 @@\n+/* Test for constant expressions: operands and casts not permitted in\n+   integer constant expressions.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+/* PR 29116.  */\n+int n = 0, p[n * 0 + 1]; /* { dg-error \"variabl\" } */\n+\n+/* PR 31871.  */\n+extern int c[1 + ((__PTRDIFF_TYPE__) (void *) 0)]; /* { dg-error \"variab\" } */\n+\n+/* Implicit conversions from floating-point constants are not OK,\n+   although explicit ones are.  */\n+extern int c1[1.0 ? 1 : 0]; /* { dg-error \"variab\" } */\n+\n+extern int c2[(int)1.0 ? 1 : 0];\n+\n+extern int c3[1.0 && 1]; /* { dg-error \"variab\" } */\n+\n+extern int c4[(int)1.0 && 1];\n+\n+extern int c5[1.0 || 1]; /* { dg-error \"variab\" } */\n+\n+extern int c6[(int)1.0 || 1];\n+\n+/* Similar with various other cases where integer constant expressions\n+   are required.  */\n+\n+struct s {\n+  int a : (n * 0 + 1); /* { dg-error \"constant\" } */\n+};\n+\n+enum e {\n+  E = (1 + ((__PTRDIFF_TYPE__) (void *) 0)), /* { dg-error \"constant\" } */\n+  E2 = 0\n+};\n+\n+enum f {\n+  F = (1 ? 1 : n), /* { dg-error \"constant\" } */\n+  F2 = 0\n+};\n+\n+/* Presume that a compound literal, being a reference to an anonymous\n+   variable, is not allowed in an integer constant expression\n+   regardless of what initializers it contains.  */\n+enum g {\n+  G = (1 ? 1 : (int){0}), /* { dg-error \"constant\" } */\n+  G2 = 0\n+};\n+\n+int v[2] = { [(n * 0 + 1)] = 1 }; /* { dg-error \"constant|near initialization\" } */\n+\n+void\n+f (int a)\n+{\n+  switch (a)\n+    {\n+    case (n * 0 + 1): /* { dg-error \"constant\" } */\n+      ;\n+    }\n+}"}, {"sha": "b872077e964ef81e8e6337be6ebd2751285711d8", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-7.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-7.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,43 @@\n+/* Test for constant expressions: overflow and constant expressions;\n+   see also overflow-warn-*.c for some other cases.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+#include <float.h>\n+#include <limits.h>\n+\n+int a = DBL_MAX; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 10 } */\n+int b = (int) DBL_MAX; /* { dg-error \"overflow\" \"\" } */\n+unsigned int c = -1.0; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 13 } */\n+unsigned int d = (unsigned)-1.0; /* { dg-error \"overflow\" } */\n+\n+int e = 0 << 1000; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 17 } */\n+int f = 0 << -1; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 19 } */\n+int g = 0 >> 1000; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 21 } */\n+int h = 0 >> -1; /* { dg-warning \"shift count\" } */\n+/* { dg-error \"constant\" \"constant\" { target *-*-* } 23 } */\n+\n+int b1 = (0 ? (int) DBL_MAX : 0);\n+unsigned int d1 = (0 ? (unsigned int)-1.0 : 0);\n+int e1 = (0 ? 0 << 1000 : 0);\n+int f1 = (0 ? 0 << -1 : 0);\n+int g1 = (0 ? 0 >> 1000 : 0);\n+int h1 = (0 ? 0 >> -1: 0);\n+\n+/* Allowed for now, but actually undefined behavior in C99.  */\n+int i = -1 << 0;\n+\n+int j[1] = { DBL_MAX }; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 36 } */\n+\n+int array[2] = { [0 * (INT_MAX + 1)] = 0 }; /* { dg-warning \"integer overflow in expression\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 39 } */\n+\n+_Bool k = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 42 } */"}, {"sha": "e84fa7b4db055653784d789e0857d1564f57c5b5", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-8.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,27 @@\n+/* Test for constant expressions: overflow and constant expressions\n+   with -fwrapv: overflows still count as such for the purposes of\n+   constant expressions even when they have defined values at\n+   runtime.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors -fwrapv\" } */\n+\n+#include <limits.h>\n+\n+enum e {\n+  E0 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 12 } */\n+  E1 = 0 * (INT_MIN / -1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 14 } */\n+  E2 = 0 * (INT_MAX * INT_MAX), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 16 } */\n+  E3 = 0 * (INT_MIN - 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 18 } */\n+  E4 = 0 * (unsigned)(INT_MIN - 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 20 } */\n+  E5 = 0 * -INT_MIN, /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 22 } */\n+  E6 = 0 * !-INT_MIN, /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"not an integer constant\" \"constant\" { target *-*-* } 24 } */\n+  E7 = INT_MIN % -1 /* Not an overflow.  */\n+};"}, {"sha": "48f43edece6a9712fba0f913a8382f992251ba01", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-9.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-9.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,26 @@\n+/* Test for constant expressions: __builtin_offsetof allowed in\n+   integer constant expressions but not traditional offsetof\n+   expansion.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+struct s {\n+  int a;\n+};\n+\n+struct t {\n+  struct s a;\n+  int b[2];\n+};\n+\n+#define old_offsetof(TYPE, MEMBER) ((__SIZE_TYPE__) &((TYPE *)0)->MEMBER)\n+\n+enum e {\n+  E1 = old_offsetof (struct s, a), /* { dg-error \"constant\" } */\n+  E2 = old_offsetof (struct t, a.a), /* { dg-error \"constant\" } */\n+  E3 = old_offsetof (struct t, b[1]), /* { dg-error \"constant\" } */\n+  E4 = __builtin_offsetof (struct s, a),\n+  E5 = __builtin_offsetof (struct t, a.a),\n+  E6 = __builtin_offsetof (struct t, b[1])\n+};"}, {"sha": "a138f878d928b60e919c215f8b51dfd20ff82ed5", "filename": "gcc/testsuite/gcc.dg/c99-static-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-static-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-static-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-static-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -27,7 +27,7 @@ static int f4(void);\n void g4(void) { sizeof(int (*)[f4()]); }\n \n /* Constraint violation (VLA).  */\n-static int f5(void); /* { dg-error \"used but never defined\" \"VLA\" { xfail *-*-* } } */\n+static int f5(void); /* { dg-error \"used but never defined\" \"VLA\" } */\n void g5(void) { sizeof(int [0 ? f5() : 1]); }\n \n /* OK (non-constant sizeof inside constant sizeof).  */"}, {"sha": "3b8af28bf188ba10390984bbe0667852210087a8", "filename": "gcc/testsuite/gcc.dg/compare10.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare10.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,16 @@\n+/* Test for bogus -Wsign-compare warnings that appeared when not\n+   folding operands before warning.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wsign-compare\" } */\n+\n+int\n+test_compare (int a, unsigned b)\n+{\n+  return (b > 8 * (a ? 4 : 8));\n+}\n+\n+unsigned int\n+test_conditional (int a, unsigned b, int c)\n+{\n+  return (c ? b : 8 * (a ? 4 : 8));\n+}"}, {"sha": "ebc68859a5e64e7a5fb064137481cbcb54071dac", "filename": "gcc/testsuite/gcc.dg/gnu89-const-expr-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu89-const-expr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu89-const-expr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu89-const-expr-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,47 @@\n+/* Test for constant expressions: GNU extensions.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu89\" } */\n+\n+int n;\n+\n+void\n+f (void)\n+{\n+  int i = 0;\n+  int a[n];\n+  enum e1 {\n+    /* Integer constant expressions may not contain statement\n+       expressions (not a permitted operand).  */\n+    E1 = (1 ? 0 : ({ 0; })), /* { dg-error \"constant\" } */\n+    /* Real and imaginary parts act like other arithmetic\n+       operators.  */\n+    E2 = __real__ (1 ? 0 : i++), /* { dg-error \"constant\" } */\n+    E3 = __real__ 0,\n+    E4 = __imag__ (1 ? 0 : i++), /* { dg-error \"constant\" } */\n+    E5 = __imag__ 0,\n+    /* __alignof__ always constant.  */\n+    E6 = __alignof__ (int[n]),\n+    E7 = __alignof__ (a),\n+    /* __extension__ ignored for constant expression purposes.  */\n+    E8 = __extension__ (1 ? 0 : i++), /* { dg-error \"constant\" } */\n+    E9 = __extension__ 0,\n+    /* Conditional expressions with omitted arguments act like the\n+       standard type.  */ \n+    E10 = (1 ? : i++), /* { dg-error \"constant\" } */\n+    E11 = (1 ? : 0)\n+  };\n+  enum e2 {\n+    /* Complex integer constants may be cast directly to integer\n+       types, but not after further arithmetic on them.  */\n+    F1 = (int) (_Complex int) 2i, /* { dg-error \"constant\" } */\n+    F2 = (int) +2i, /* { dg-error \"constant\" } */\n+    F3 = (int) (1 + 2i), /* { dg-error \"constant\" } */\n+    F4 = (int) 2i\n+  };\n+  static double dr = __real__ (1.0 + 2.0i);\n+  static double di = __imag__ (1.0 + 2.0i);\n+  /* Statement expressions allowed in unevaluated subexpressions in\n+     initializers in gnu99 but not gnu89.  */\n+  static int j = (1 ? 0 : ({ 0; })); /* { dg-warning \"constant expression\" } */\n+}"}, {"sha": "3395b55c733e0dc23599fca18f0ad9ec4ee60e7a", "filename": "gcc/testsuite/gcc.dg/gnu89-const-expr-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu89-const-expr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu89-const-expr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu89-const-expr-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,23 @@\n+/* Test for constant expressions: __builtin_choose_expr.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu89 -pedantic-errors\" } */\n+\n+#include <limits.h>\n+\n+int a, b, c;\n+\n+void\n+f (void)\n+{\n+  /* __builtin_choose_expr acts exactly like the chosen argument for\n+     all constant expression purposes.  */\n+  enum e {\n+    E1 = __builtin_choose_expr (1, 1, ++b)\n+  };\n+  /* The first argument to __builtin_choose_expr must be an integer\n+     constant expression.  */\n+  a = __builtin_choose_expr ((void *)0, b, c); /* { dg-error \"constant\" } */\n+  a = __builtin_choose_expr (0 * (INT_MAX + 1), b, c); /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+}"}, {"sha": "dcc976e558272c3b0bf16fb59d32322cad5f5e51", "filename": "gcc/testsuite/gcc.dg/gnu99-const-expr-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,47 @@\n+/* Test for constant expressions: GNU extensions.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+int n;\n+\n+void\n+f (void)\n+{\n+  int i = 0;\n+  int a[n];\n+  enum e1 {\n+    /* Integer constant expressions may not contain statement\n+       expressions (not a permitted operand).  */\n+    E1 = (1 ? 0 : ({ 0; })), /* { dg-error \"constant\" } */\n+    /* Real and imaginary parts act like other arithmetic\n+       operators.  */\n+    E2 = __real__ (1 ? 0 : i++), /* { dg-error \"constant\" } */\n+    E3 = __real__ 0,\n+    E4 = __imag__ (1 ? 0 : i++), /* { dg-error \"constant\" } */\n+    E5 = __imag__ 0,\n+    /* __alignof__ always constant.  */\n+    E6 = __alignof__ (int[n]),\n+    E7 = __alignof__ (a),\n+    /* __extension__ ignored for constant expression purposes.  */\n+    E8 = __extension__ (1 ? 0 : i++), /* { dg-error \"constant\" } */\n+    E9 = __extension__ 0,\n+    /* Conditional expressions with omitted arguments act like the\n+       standard type.  */ \n+    E10 = (1 ? : i++), /* { dg-error \"constant\" } */\n+    E11 = (1 ? : 0)\n+  };\n+  enum e2 {\n+    /* Complex integer constants may be cast directly to integer\n+       types, but not after further arithmetic on them.  */\n+    F1 = (int) (_Complex int) 2i, /* { dg-error \"constant\" } */\n+    F2 = (int) +2i, /* { dg-error \"constant\" } */\n+    F3 = (int) (1 + 2i), /* { dg-error \"constant\" } */\n+    F4 = (int) 2i\n+  };\n+  static double dr = __real__ (1.0 + 2.0i);\n+  static double di = __imag__ (1.0 + 2.0i);\n+  /* Statement expressions allowed in unevaluated subexpressions in\n+     initializers in gnu99 but not gnu89.  */\n+  static int j = (1 ? 0 : ({ 0; }));\n+}"}, {"sha": "f868c537fa26338f801863ddb60d5f1abc3373c5", "filename": "gcc/testsuite/gcc.dg/gnu99-const-expr-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,23 @@\n+/* Test for constant expressions: __builtin_choose_expr.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -pedantic-errors\" } */\n+\n+#include <limits.h>\n+\n+int a, b, c;\n+\n+void\n+f (void)\n+{\n+  /* __builtin_choose_expr acts exactly like the chosen argument for\n+     all constant expression purposes.  */\n+  enum e {\n+    E1 = __builtin_choose_expr (1, 1, ++b)\n+  };\n+  /* The first argument to __builtin_choose_expr must be an integer\n+     constant expression.  */\n+  a = __builtin_choose_expr ((void *)0, b, c); /* { dg-error \"constant\" } */\n+  a = __builtin_choose_expr (0 * (INT_MAX + 1), b, c); /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+}"}, {"sha": "aba7da542a06cbdb85ff6ff032b17788e6ec4445", "filename": "gcc/testsuite/gcc.dg/gnu99-const-expr-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu99-const-expr-3.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,32 @@\n+/* Test for constant expressions: cases involving VLAs and typeof.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -pedantic-errors\" } */\n+\n+/* It appears address constants may contain casts to variably modified\n+   types.  Whether they should be permitted was discussed in\n+   <http://groups.google.com/group/comp.std.c/msg/923eee5ab690fd98>\n+   <LV7g2Vy3ARF$Ew9Q@romana.davros.org>; since static pointers to VLAs\n+   are definitely permitted within functions and may be initialized\n+   and such initialization involves implicit conversion to a variably\n+   modified type, allowing explicit casts seems appropriate.  Thus,\n+   GCC allows them as long as the \"evaluated\" size expressions do not\n+   contain the various operators not permitted to be evaluated in a\n+   constant expression, and as long as the result is genuinely\n+   constant (meaning that pointer arithmetic using the size of the VLA\n+   is generally not permitted).  */\n+\n+static int sa[100];\n+\n+int\n+f (int m, int n)\n+{\n+  static int (*a1)[n] = &sa;\n+  static int (*a2)[n] = (__typeof__(int (*)[n]))sa;\n+  static int (*a3)[n] = (__typeof__(int (*)[(int){m++}]))sa; /* { dg-error \"constant\" } */\n+  static int (*a4)[n] = (__typeof__((int (*)[n])sa))sa;\n+  static int (*a5)[n] = (__typeof__((int (*)[m++])sa))sa; /* { dg-error \"constant\" } */\n+  static int (*a6)[n] = (__typeof__((int (*)[100])(int (*)[m++])sa))sa;\n+  static int (*a7)[n] = (__typeof__((int (*)[n])sa + m++))sa; /* { dg-error \"constant\" } */\n+  return n;\n+}"}, {"sha": "633d70b84b5435e66dbeee8ee70b2f9884292642", "filename": "gcc/testsuite/gcc.dg/overflow-warn-1.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target *-*-* } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* Again, overflow in evaluated subexpression.  */\n   E6 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n@@ -28,6 +28,7 @@ enum e {\n struct s {\n   int a;\n   int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n+  /* { dg-error \"not an integer constant\" \"integer constant\" { target *-*-* } 30 } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n };\n \n@@ -46,9 +47,10 @@ static int sc = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" }\n    constants.  The third has the overflow in an unevaluated\n    subexpression, so is a null pointer constant.  */\n void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 48 } */\n+/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 49 } */\n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 50 } */\n+/* { dg-error \"initializer element is not constant\" \"constant\" { target *-*-* } 51 } */\n+/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 51 } */\n void *r = (1 ? 0 : INT_MAX+1);\n \n void\n@@ -57,6 +59,7 @@ g (int i)\n   switch (i)\n     {\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n+      /* { dg-error \"case label does not reduce to an integer constant\" \"constant\" { target *-*-* } 61 } */\n       ;\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n       ;"}, {"sha": "e8bbd24455d56e31af97b1e1502002dc25d5139a", "filename": "gcc/testsuite/gcc.dg/overflow-warn-2.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-2.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target *-*-* } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* Again, overflow in evaluated subexpression.  */\n   E6 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n@@ -28,6 +28,7 @@ enum e {\n struct s {\n   int a;\n   int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n+  /* { dg-error \"not an integer constant\" \"integer constant\" { target *-*-* } 30 } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n };\n \n@@ -46,9 +47,10 @@ static int sc = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" }\n    constants.  The third has the overflow in an unevaluated\n    subexpression, so is a null pointer constant.  */\n void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 48 } */\n+/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 49 } */\n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 50 } */\n+/* { dg-error \"initializer element is not constant\" \"constant\" { target *-*-* } 51 } */\n+/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 51 } */\n void *r = (1 ? 0 : INT_MAX+1);\n \n void\n@@ -57,6 +59,7 @@ g (int i)\n   switch (i)\n     {\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n+      /* { dg-error \"case label does not reduce to an integer constant\" \"constant\" { target *-*-* } 61 } */\n       ;\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n       ;\n@@ -82,23 +85,23 @@ void\n h2 (void)\n {\n   fsc (SCHAR_MAX + 1);\n-  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 84 } */\n+  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 87 } */\n   fsc (SCHAR_MIN - 1); /* { dg-warning \"overflow in implicit constant conversion\" } */\n-  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 86 } */\n+  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 89 } */\n   fsc (UCHAR_MAX);\n-  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 88 } */\n+  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 91 } */\n   fsc (UCHAR_MAX + 1); /* { dg-warning \"overflow in implicit constant conversion\" } */\n-  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 90 } */\n+  /* { dg-warning \"passing argument 1 of 'fsc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 93 } */\n   fuc (-1);\n-  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 92 } */\n+  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 95 } */\n   fuc (UCHAR_MAX + 1); /* { dg-warning \"large integer implicitly truncated to unsigned type\" } */\n-  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 94 } */\n+  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 97 } */\n   fuc (SCHAR_MIN);\n-  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 96 } */\n+  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 99 } */\n   fuc (SCHAR_MIN - 1); /* { dg-warning \"large integer implicitly truncated to unsigned type\" } */\n-  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 98 } */\n+  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 101 } */\n   fuc (-UCHAR_MAX); /* { dg-warning \"large integer implicitly truncated to unsigned type\" } */\n-  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 100 } */\n+  /* { dg-warning \"passing argument 1 of 'fuc' with different width due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 103 } */\n }\n \n void fui (unsigned int);\n@@ -122,11 +125,11 @@ h2i (int x)\n   fsi (UINT_MAX); /* { dg-warning \"passing argument 1 of 'fsi' as signed due to prototype\" } */\n   si = UINT_MAX;\n   fui (-1);\n-  /* { dg-warning \"passing argument 1 of 'fui' as unsigned due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 124 } */\n+  /* { dg-warning \"passing argument 1 of 'fui' as unsigned due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 127 } */\n   ui = -1;\n   ui = x ? -1 : 1U;\n   fui (INT_MIN);\n-  /* { dg-warning \"passing argument 1 of 'fui' as unsigned due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 128 } */\n+  /* { dg-warning \"passing argument 1 of 'fui' as unsigned due to prototype\" \"-Wtraditional-conversion\" { target *-*-* } 131 } */\n   ui = INT_MIN;\n   ui = x ? INT_MIN : 1U;\n }"}, {"sha": "d9a3ae430dbc61a46588840c817d1e4565626163", "filename": "gcc/testsuite/gcc.dg/overflow-warn-3.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-3.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target *-*-* } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n   /* Again, overflow in evaluated subexpression.  */\n@@ -30,8 +30,9 @@ enum e {\n struct s {\n   int a;\n   int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n+  /* { dg-error \"not an integer constant\" \"integer constant\" { target *-*-* } 32 } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+  /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 34 } */\n };\n \n void\n@@ -45,16 +46,17 @@ f (void)\n \n /* But this expression does need to be constant.  */\n static int sc = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 47 } */\n+/* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 48 } */\n \n /* The first two of these involve overflow, so are not null pointer\n    constants.  The third has the overflow in an unevaluated\n    subexpression, so is a null pointer constant.  */\n void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 53 } */\n-/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 53 } */\n+/* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 54 } */\n+/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 54 } */\n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 56 } */\n+/* { dg-error \"initializer element is not constant\" \"constant\" { target *-*-* } 57 } */\n+/* { dg-warning \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 57 } */\n void *r = (1 ? 0 : INT_MAX+1);\n \n void\n@@ -63,9 +65,10 @@ g (int i)\n   switch (i)\n     {\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n+      /* { dg-error \"case label does not reduce to an integer constant\" \"constant\" { target *-*-* } 67 } */\n       ;\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n-      /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n+      /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 70 } */\n       ;\n     }\n }"}, {"sha": "7b7e23cef4b57e14a6ebd2c234494d96a4d5abaf", "filename": "gcc/testsuite/gcc.dg/overflow-warn-4.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-4.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target *-*-* } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n   /* Again, overflow in evaluated subexpression.  */\n@@ -30,8 +30,9 @@ enum e {\n struct s {\n   int a;\n   int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n+  /* { dg-error \"not an integer constant\" \"integer constant\" { target *-*-* } 32 } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 34 } */\n };\n \n void\n@@ -45,16 +46,17 @@ f (void)\n \n /* But this expression does need to be constant.  */\n static int sc = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 47 } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 48 } */\n \n /* The first two of these involve overflow, so are not null pointer\n    constants.  The third has the overflow in an unevaluated\n    subexpression, so is a null pointer constant.  */\n void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 53 } */\n-/* { dg-error \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 53 } */\n+/* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 54 } */\n+/* { dg-error \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 54 } */\n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-error \"initialization makes pointer from integer without a cast\" \"null\" { xfail *-*-* } 56 } */\n+/* { dg-error \"initializer element is not constant\" \"constant\" { target *-*-* } 57 } */\n+/* { dg-error \"initialization makes pointer from integer without a cast\" \"null\" { target *-*-* } 57 } */\n void *r = (1 ? 0 : INT_MAX+1);\n \n void\n@@ -63,9 +65,10 @@ g (int i)\n   switch (i)\n     {\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n+      /* { dg-error \"case label does not reduce to an integer constant\" \"constant\" { target *-*-* } 67 } */\n       ;\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n-      /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n+      /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 70 } */\n       ;\n     }\n }"}, {"sha": "34f42f08f2cadef0f5c3a6b5663d005b0ed58094", "filename": "gcc/testsuite/gcc.dg/pr14649-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr14649-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr14649-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr14649-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -4,7 +4,7 @@\n \n double atan(double);\n \n-const double pi = 4*atan(1.0);  /* { dg-warning \"(not constant)|(near initialization)\" } */\n+const double pi = 4*atan(1.0);  /* { dg-warning \"not a constant expression\" } */\n \n const double ok = 4*__builtin_atan(1.0);\n "}, {"sha": "5323c461fb0f8bb9a4ff6691eedadefdde6a028b", "filename": "gcc/testsuite/gcc.dg/pr19984.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19984.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19984.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19984.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -5,7 +5,7 @@\n \n double nan (const char *);\n \n-const double nok = nan (\"\");\t/* { dg-warning \"(not constant)|(near initialization)\" } */\n+const double nok = nan (\"\");\t/* { dg-warning \"(not a constant)|(near initialization)\" } */\n \n const double ok = __builtin_nan (\"\");\n "}, {"sha": "c99b891f8faac47c86c12826ae7b43c7b945b94c", "filename": "gcc/testsuite/gcc.dg/pr25682.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25682.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25682.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25682.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -10,10 +10,10 @@ struct S\n   int b;\n };\n \n-char c[(char *) &((struct S *) 0)->b - (char *) 0];\n-char d[(__SIZE_TYPE__) &((struct S *) 8)->b];\n-char e[sizeof (c) == __builtin_offsetof (struct S, b) ? 1 : -1];\n-char f[sizeof (d) == __builtin_offsetof (struct S, b) + 8 ? 1 : -1];\n+char c[(char *) &((struct S *) 0)->b - (char *) 0]; /* { dg-error \"variable-size\" } */\n+char d[(__SIZE_TYPE__) &((struct S *) 8)->b]; /* { dg-error \"variable-size\" } */\n+char e[sizeof (c) == __builtin_offsetof (struct S, b) ? 1 : -1]; /* { dg-error \"variably modified\" } */\n+char f[sizeof (d) == __builtin_offsetof (struct S, b) + 8 ? 1 : -1]; /* { dg-error \"variably modified\" } */\n \n extern void bar (char *, char *);\n "}, {"sha": "4c7058d17af1f384220b23df9a0340ba9fb94b20", "filename": "gcc/testsuite/gcc.dg/real-const-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Freal-const-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Freal-const-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Freal-const-1.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -1,4 +1,5 @@\n /* PR middle-end/21781.  */\n /* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n \n-int f[.0e200000000 == 0?1:-1];\n+int foo(void) { if (.0e200000000 == 0 ) return 1; }"}, {"sha": "bdb290ab4ec8f21f99a1945c82415a1603bc6438", "filename": "gcc/testsuite/gcc.dg/vect/pr32230.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr32230.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr32230.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr32230.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -16,7 +16,7 @@ const_f (filter_buffer_t *buf)\n   int i;\n \n   for (i = 0; i < 10; i++)\n-    ((float*) (&((sbuf_header_t *) ((buf) == (filter_buffer_t *)&(buf)->buf[0]))->buf[0]))[i] = val;\n+    ((float*) (&((sbuf_header_t *) (__PTRDIFF_TYPE__)((buf) == (filter_buffer_t *)&(buf)->buf[0]))->buf[0]))[i] = val;\n }\n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "604ea88dc2c72c15560cc9c34f3a6736093d8899", "filename": "gcc/testsuite/gcc.dg/vla-12.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-12.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,50 @@\n+/* Test for typeof evaluation: should be at the appropriate point in\n+   the containing expression rather than just adding a statement.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+void *p;\n+\n+void\n+f1 (void)\n+{\n+  int i = 0, j = -1, k = -1;\n+  /* typeof applied to expression with cast.  */\n+  (j = ++i), (void)(typeof ((int (*)[(k = ++i)])p))p;\n+  if (j != 1 || k != 2 || i != 2)\n+    abort ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i = 0, j = -1, k = -1;\n+  /* typeof applied to type.  */\n+  (j = ++i), (void)(typeof (int (*)[(k = ++i)]))p;\n+  if (j != 1 || k != 2 || i != 2)\n+    abort ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i = 0, j = -1, k = -1;\n+  void *q;\n+  /* typeof applied to expression with cast that is used.  */\n+  (j = ++i), (void)((typeof (1 + (int (*)[(k = ++i)])p))p);\n+  if (j != 1 || k != 2 || i != 2)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  exit (0);\n+}"}, {"sha": "70b63059d722fa43f0bee05f77cca909929d6fa6", "filename": "gcc/testsuite/gcc.dg/vla-13.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-13.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,99 @@\n+/* Test for VLA size evaluation; see PR 35198.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99\" } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+int i;\n+void *p;\n+\n+void\n+f1 (void *x, int j)\n+{\n+  p = (int (*)[++i])x;\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f1c (void *x, int j)\n+{\n+  p = (int (*)[++i]){x};\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f2 (void *x, int j)\n+{\n+  x = (void *)(int (*)[++i])p;\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f2c (void *x, int j)\n+{\n+  x = (void *)(int (*)[++i]){p};\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f3 (void *x, int j)\n+{\n+  (void)(int (*)[++i])p;\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f3c (void *x, int j)\n+{\n+  (void)(int (*)[++i]){p};\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f4 (void *x, int j)\n+{\n+  (int (*)[++i])p;\n+  (int (*)[++i])p;\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f4c (void *x, int j)\n+{\n+  (int (*)[++i]){p};\n+  (int (*)[++i]){p};\n+  if (i != j)\n+    abort ();\n+}\n+\n+void\n+f5c (void *x, int j, int k)\n+{\n+  (++i, f3c (x, j), (int (*)[++i]){p});\n+  if (i != k)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  f1 (p, 1);\n+  f2 (p, 2);\n+  f3 (p, 3);\n+  f4 (p, 5);\n+  f1c (p, 6);\n+  f2c (p, 7);\n+  f3c (p, 8);\n+  f4c (p, 10);\n+  f5c (p, 12, 13);\n+  exit (0);\n+}"}, {"sha": "3dbb11ed1a717d2b1454a3e2dfb6ea7b0789a7d0", "filename": "gcc/testsuite/gcc.dg/vla-14.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-14.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,33 @@\n+/* Test for VLA size evaluation in va_arg.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <stdarg.h>\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+int a[10];\n+int i = 9;\n+\n+void\n+f (int n, ...)\n+{\n+  va_list ap;\n+  void *p;\n+  va_start (ap, n);\n+  p = va_arg (ap, typeof (int (*)[++i]));\n+  if (p != a)\n+    abort ();\n+  if (i != n)\n+    abort ();\n+  va_end (ap);\n+}\n+\n+int\n+main (void)\n+{\n+  f (10, &a);\n+  exit (0);\n+}"}, {"sha": "800163bc1844c178f3fc6fa8b217121a258b6a5b", "filename": "gcc/testsuite/gcc.dg/vla-15.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-15.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,27 @@\n+/* Test for VLA size evaluation in sizeof typeof.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <stdarg.h>\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+char a[1];\n+\n+void\n+f1 (void)\n+{\n+  int i = 0;\n+  int j = sizeof (typeof (*(++i, (char (*)[i])a)));\n+  if (i != 1 || j != 1)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  f1 ();\n+  exit (0);\n+}"}, {"sha": "05e751af7a56ee80cca496b1bc3c7c7268ef7bc4", "filename": "gcc/testsuite/gcc.dg/vla-16.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928c19bbb001967c7ab83a9f856c740680b6661f/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-16.c?ref=928c19bbb001967c7ab83a9f856c740680b6661f", "patch": "@@ -0,0 +1,70 @@\n+/* Test for modifying and taking addresses of compound literals whose\n+   variably modified types involve typeof.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <stdarg.h>\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+int a[1];\n+\n+void\n+f1 (void)\n+{\n+  int i = 0;\n+  int (**p)[1] = &(typeof (++i, (int (*)[i])a)){&a};\n+  if (*p != &a)\n+    abort ();\n+  if (i != 1)\n+    abort ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i = 0;\n+  (typeof (++i, (int (*)[i])a)){&a} = 0;\n+  if (i != 1)\n+    abort ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i = 0;\n+  (typeof (++i, (int (*)[i])a)){&a} += 1;\n+  if (i != 1)\n+    abort ();\n+}\n+\n+void\n+f4 (void)\n+{\n+  int i = 0;\n+  --(typeof (++i, (int (*)[i])a)){&a + 1};\n+  if (i != 1)\n+    abort ();\n+}\n+\n+void\n+f5 (void)\n+{\n+  int i = 0;\n+  (typeof (++i, (int (*)[i])a)){&a}++;\n+  if (i != 1)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f4 ();\n+  f5 ();\n+  exit (0);\n+}"}]}