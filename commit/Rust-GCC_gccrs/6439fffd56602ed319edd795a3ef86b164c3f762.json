{"sha": "6439fffd56602ed319edd795a3ef86b164c3f762", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQzOWZmZmQ1NjYwMmVkMzE5ZWRkNzk1YTNlZjg2YjE2NGMzZjc2Mg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2005-03-05T15:44:22Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2005-03-05T15:44:22Z"}, "message": "re PR c++/19311 (ICE in resolve_overloaded_unification)\n\n\tPR c++/19311\n\t* init.c (build_offset_ref): Don't build non-dependent SCOPE_REF.\n\t* pt.c (build_non_dependent_expr): Don't build NON_DEPENDENT_EXPR\n\tfor OFFSET_TYPE.\n\t* typeck.c (build_x_unary_op): Don't build non-dependent SCOPE_REF.\n\tAlso set PTRMEM_OK_P for NON_DEPENDENT_EXPR.\n\t(build_unary_op): Handle building ADDR_EXPR of OFFSET_REF inside\n\ttemplate.\n\n\t* g++.dg/template/non-dependent11.C: New test.\n\nFrom-SVN: r95933", "tree": {"sha": "8e6216ca8d3e3a7f15f173ab7e56307bb21bef86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e6216ca8d3e3a7f15f173ab7e56307bb21bef86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6439fffd56602ed319edd795a3ef86b164c3f762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6439fffd56602ed319edd795a3ef86b164c3f762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6439fffd56602ed319edd795a3ef86b164c3f762", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6439fffd56602ed319edd795a3ef86b164c3f762/comments", "author": null, "committer": null, "parents": [{"sha": "d19e3ef69676036ebb9b3ad68f052a75690e3366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19e3ef69676036ebb9b3ad68f052a75690e3366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19e3ef69676036ebb9b3ad68f052a75690e3366"}], "stats": {"total": 77, "additions": 46, "deletions": 31}, "files": [{"sha": "4c40681333faf4ca55edcc55bdb549e2c0311917", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6439fffd56602ed319edd795a3ef86b164c3f762", "patch": "@@ -1,3 +1,14 @@\n+2005-03-05  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/19311\n+\t* init.c (build_offset_ref): Don't build non-dependent SCOPE_REF.\n+\t* pt.c (build_non_dependent_expr): Don't build NON_DEPENDENT_EXPR\n+\tfor OFFSET_TYPE.\n+\t* typeck.c (build_x_unary_op): Don't build non-dependent SCOPE_REF.\n+\tAlso set PTRMEM_OK_P for NON_DEPENDENT_EXPR.\n+\t(build_unary_op): Handle building ADDR_EXPR of OFFSET_REF inside\n+\ttemplate.\n+\n 2005-03-02  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* name-lookup.c (push_overloaded_decl): Don't error if the new"}, {"sha": "d572bca344e92bbedb59d7d4bfd09cec283f4dff", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6439fffd56602ed319edd795a3ef86b164c3f762", "patch": "@@ -1417,14 +1417,6 @@ build_offset_ref (tree type, tree name, bool address_p)\n       return error_mark_node;\n     }\n \n-  if (processing_template_decl)\n-    {\n-      if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n-\treturn build_min (SCOPE_REF, TREE_TYPE (member), type, orig_name);\n-      else\n-\treturn build_min (SCOPE_REF, TREE_TYPE (member), type, name);\n-    }\n-\n   if (TREE_CODE (member) == TYPE_DECL)\n     {\n       TREE_USED (member) = 1;"}, {"sha": "14940b7567110b2ae74ce1f76f808932addeb5a1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6439fffd56602ed319edd795a3ef86b164c3f762", "patch": "@@ -12376,7 +12376,8 @@ build_non_dependent_expr (tree expr)\n   if (TREE_CODE (inner_expr) == OVERLOAD \n       || TREE_CODE (inner_expr) == FUNCTION_DECL\n       || TREE_CODE (inner_expr) == TEMPLATE_DECL\n-      || TREE_CODE (inner_expr) == TEMPLATE_ID_EXPR)\n+      || TREE_CODE (inner_expr) == TEMPLATE_ID_EXPR\n+      || TREE_CODE (inner_expr) == OFFSET_REF)\n     return expr;\n   /* There is no need to return a proxy for a variable.  */\n   if (TREE_CODE (expr) == VAR_DECL)"}, {"sha": "9de7b24d0a2112dffc7564e0e56b74b04540ce29", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6439fffd56602ed319edd795a3ef86b164c3f762", "patch": "@@ -3530,23 +3530,6 @@ build_x_unary_op (enum tree_code code, tree xarg)\n       if (type_dependent_expression_p (xarg))\n \treturn build_min_nt (code, xarg, NULL_TREE);\n \n-      /* For non-dependent pointer-to-member, the SCOPE_REF will be\n-\t processed during template substitution.  Just compute the\n-\t right type here and build an ADDR_EXPR around it for\n-\t diagnostics.  */\n-      if (code == ADDR_EXPR && TREE_CODE (xarg) == SCOPE_REF)\n-\t{\n-\t  tree type;\n-\t  if (TREE_TYPE (xarg) == unknown_type_node)\n-\t    type = unknown_type_node;\n-\t  else if (TREE_CODE (TREE_TYPE (xarg)) == FUNCTION_TYPE)\n-\t    type = build_pointer_type (TREE_TYPE (xarg));\n-\t  else\n-\t    type = build_ptrmem_type (TREE_OPERAND (xarg, 0),\n-\t\t\t\t      TREE_TYPE (xarg));\n-\t  return build_min (code, type, xarg, NULL_TREE);\n-\t}\n-\n       xarg = build_non_dependent_expr (xarg);\n     }\n \n@@ -3610,13 +3593,13 @@ build_x_unary_op (enum tree_code code, tree xarg)\n       else if (TREE_CODE (xarg) == TARGET_EXPR)\n \twarning (\"taking address of temporary\");\n       exp = build_unary_op (ADDR_EXPR, xarg, 0);\n-      if (TREE_CODE (exp) == ADDR_EXPR)\n-\tPTRMEM_OK_P (exp) = ptrmem;\n     }\n \n   if (processing_template_decl && exp != error_mark_node)\n-    return build_min_non_dep (code, exp, orig_expr,\n-\t\t\t      /*For {PRE,POST}{INC,DEC}REMENT_EXPR*/NULL_TREE);\n+    exp = build_min_non_dep (code, exp, orig_expr,\n+\t\t\t     /*For {PRE,POST}{INC,DEC}REMENT_EXPR*/NULL_TREE);\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    PTRMEM_OK_P (exp) = ptrmem;\n   return exp;\n }\n \n@@ -4056,6 +4039,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t is an error.  */\n       else if (TREE_CODE (argtype) != FUNCTION_TYPE\n \t       && TREE_CODE (argtype) != METHOD_TYPE\n+\t       && TREE_CODE (arg) != OFFSET_REF\n \t       && !lvalue_or_else (arg, lv_addressof))\n \treturn error_mark_node;\n \n@@ -4070,7 +4054,11 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t       expression so we can just form an ADDR_EXPR with the\n \t       correct type.  */\n \t    || processing_template_decl)\n-\t  addr = build_address (arg);\n+\t  {\n+\t    addr = build_address (arg);\n+\t    if (TREE_CODE (arg) == OFFSET_REF)\n+\t      PTRMEM_OK_P (addr) = PTRMEM_OK_P (arg);\n+\t  }\n \telse if (TREE_CODE (TREE_OPERAND (arg, 1)) == BASELINK)\n \t  {\n \t    tree fn = BASELINK_FUNCTIONS (TREE_OPERAND (arg, 1));"}, {"sha": "fefe2397980e706eea1392972bf2b3c02565f426", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6439fffd56602ed319edd795a3ef86b164c3f762", "patch": "@@ -1,3 +1,8 @@\n+2005-03-06  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/19311\n+\t* g++.dg/template/non-dependent11.C: New test.\n+\n 2005-03-05  Uros Bizjak  <uros@kss-loka.si>\n \n \t* lib/target-supports.exp (check_iconv_available): Fix comment."}, {"sha": "dff5b909d954bc4bbe76d5a5ba15f3f1a550d46f", "filename": "gcc/testsuite/g++.dg/template/non-dependent11.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6439fffd56602ed319edd795a3ef86b164c3f762/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent11.C?ref=6439fffd56602ed319edd795a3ef86b164c3f762", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+\n+// Origin: Jakub Jelinek <jakub@gcc.gnu.org>\n+//\t   Wolfgang Bangerth <bangerth@ticam.utexas.edu>\n+\n+// PR c++/19311: Non-dependent address to member as function argument.\n+\n+template <class R, class T>          void foo (R (T::*x) ()); \n+template <class R, class T, class C> void foo (R (T::*x) (C)); \n+ \n+template<int> struct I { \n+  int o (); \n+  int o () const; \n+}; \n+ \n+template <int> void bar (void) { \n+  foo <int, I<1> > (&I<1>::o); \n+}"}]}