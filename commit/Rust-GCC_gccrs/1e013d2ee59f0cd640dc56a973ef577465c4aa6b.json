{"sha": "1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUwMTNkMmVlNTlmMGNkNjQwZGM1NmE5NzNlZjU3NzQ2NWM0YWE2Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-26T21:44:35Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-26T21:44:35Z"}, "message": "cpphash.h (struct cpp_pool): Remove locks and locked.\n\n\t* cpphash.h (struct cpp_pool): Remove locks and locked.\n\t(struct cpp_context): Add member buff.\n\t(struct cpp_reader): Remove member argument_pool.\n\t(_cpp_lock_pool, _cpp_unlock_pool): Remove.\n\t* cppinit.c (cpp_create_reader, cpp_destroy): Argument_pool is dead.\n\t* cpplex.c (chunk_suitable): Remove pool argument.\n\t(MIN_BUFF_SIZE, BUFF_SIZE_UPPER_BOUND, EXTENDED_BUFF_SIZE): New.\n\t(new_buff, _cpp_extend_buff): Update.\n\t(_cpp_get_buff): Fix silly pointer bug.  Be more selective about\n\twhich buffer is returned.\n\t(_cpp_next_chunk, _cpp_init_pool): Pool locking removed.\n\t(_cpp_lock_pool, _cpp_unlock_pool): Remove.\n\t* cppmacro.c (lock_pools, unlock_pools): Remove.\n\t(push_ptoken_context): Take a _cpp_buff.\n\t(enter_macro_context): Pool locking removed.\n\t(replace_args): Use a _cpp_buff for the replacement list with\n\targuments replaced.\n\t(push_token_context): Clear buff.\n\t(expand_arg): Use _cpp_pop_context.\n\t(_cpp_pop_context): Free a context's buffer, if any.\n\nFrom-SVN: r45833", "tree": {"sha": "03b83203b4e6f5bc73aa03834e13b0fb8efa1d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03b83203b4e6f5bc73aa03834e13b0fb8efa1d57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/comments", "author": null, "committer": null, "parents": [{"sha": "0c055e3461e70139f7277fb146e080599a0ab6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c055e3461e70139f7277fb146e080599a0ab6a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c055e3461e70139f7277fb146e080599a0ab6a2"}], "stats": {"total": 159, "additions": 77, "deletions": 82}, "files": [{"sha": "aa135529bca08cf66204fdbcfe4ab3bdacb1c6fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "patch": "@@ -1,3 +1,26 @@\n+2001-09-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_pool): Remove locks and locked.\n+\t(struct cpp_context): Add member buff.\n+\t(struct cpp_reader): Remove member argument_pool.\n+\t(_cpp_lock_pool, _cpp_unlock_pool): Remove.\n+\t* cppinit.c (cpp_create_reader, cpp_destroy): Argument_pool is dead.\n+\t* cpplex.c (chunk_suitable): Remove pool argument.\n+\t(MIN_BUFF_SIZE, BUFF_SIZE_UPPER_BOUND, EXTENDED_BUFF_SIZE): New.\n+\t(new_buff, _cpp_extend_buff): Update.\n+\t(_cpp_get_buff): Fix silly pointer bug.  Be more selective about\n+\twhich buffer is returned.\n+\t(_cpp_next_chunk, _cpp_init_pool): Pool locking removed.\n+\t(_cpp_lock_pool, _cpp_unlock_pool): Remove.\n+\t* cppmacro.c (lock_pools, unlock_pools): Remove.\n+\t(push_ptoken_context): Take a _cpp_buff.\n+\t(enter_macro_context): Pool locking removed.\n+\t(replace_args): Use a _cpp_buff for the replacement list with\n+\targuments replaced.\n+\t(push_token_context): Clear buff.\n+\t(expand_arg): Use _cpp_pop_context.\n+\t(_cpp_pop_context): Free a context's buffer, if any.\n+\n 2001-09-26  DJ Delorie  <dj@redhat.com>\n \n \t* c-typeck.c (digest_init): Check for sizeless arrays."}, {"sha": "58ae27f0e5ff2f851d7cfd082a7452aae51071fc", "filename": "gcc/cpphash.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "patch": "@@ -66,10 +66,9 @@ struct cpp_chunk\n typedef struct cpp_pool cpp_pool;\n struct cpp_pool\n {\n-  struct cpp_chunk *cur, *locked, *first;\n+  struct cpp_chunk *cur, *first;\n   unsigned char *pos;\t\t/* Current position.  */\n   unsigned int align;\n-  unsigned int locks;\n };\n \n /* A generic memory buffer.  */\n@@ -134,6 +133,10 @@ struct cpp_context\n   union utoken first;\n   union utoken last;\n \n+  /* If non-NULL, a buffer used for storage related to this context.\n+     When the context is popped, the buffer is freed.  */\n+  _cpp_buff *buff;\n+\n   /* For a macro context, these are the macro and its arguments.  */\n   cpp_macro *macro;\n \n@@ -267,7 +270,6 @@ struct cpp_reader\n   cpp_pool ident_pool;\t\t/* For all identifiers, and permanent\n \t\t\t\t   numbers and strings.  */\n   cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n-  cpp_pool argument_pool;\t/* For macro arguments.  Temporary.   */\n \n   /* Memory buffers.  */\n   _cpp_buff *free_buffs;\n@@ -436,8 +438,6 @@ extern unsigned char *_cpp_pool_reserve PARAMS ((cpp_pool *, unsigned int));\n extern unsigned char *_cpp_pool_alloc\tPARAMS ((cpp_pool *, unsigned int));\n extern unsigned char *_cpp_next_chunk\tPARAMS ((cpp_pool *, unsigned int,\n \t\t\t\t\t\t unsigned char **));\n-extern void _cpp_lock_pool\t\tPARAMS ((cpp_pool *));\n-extern void _cpp_unlock_pool\t\tPARAMS ((cpp_pool *));\n \n /* In cppinit.c.  */\n extern bool _cpp_push_next_buffer\tPARAMS ((cpp_reader *));"}, {"sha": "42decd106123b21413791a30eae2788521fd7b7f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "patch": "@@ -530,9 +530,6 @@ cpp_create_reader (table, lang)\n   /* Identifier pool initially 8K.  Unaligned, permanent pool.  */\n   _cpp_init_pool (&pfile->ident_pool, 8 * 1024, 1, 0);\n \n-  /* Argument pool initially 8K.  Aligned, temporary pool.  */\n-  _cpp_init_pool (&pfile->argument_pool, 8 * 1024, 0, 1);\n-\n   /* Macro pool initially 8K.  Aligned, permanent pool.  */\n   _cpp_init_pool (&pfile->macro_pool, 8 * 1024, 0, 0);\n \n@@ -590,7 +587,6 @@ cpp_destroy (pfile)\n \n   _cpp_free_pool (&pfile->ident_pool);\n   _cpp_free_pool (&pfile->macro_pool);\n-  _cpp_free_pool (&pfile->argument_pool);\n   _cpp_free_buff (pfile->free_buffs);\n \n   for (run = &pfile->base_run; run; run = runn)"}, {"sha": "b5e979b764a46b83973edf7ec9b319177a7f42b3", "filename": "gcc/cpplex.c", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "patch": "@@ -105,7 +105,7 @@ static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n \n static cpp_chunk *new_chunk PARAMS ((unsigned int));\n-static int chunk_suitable PARAMS ((cpp_pool *, cpp_chunk *, unsigned int));\n+static int chunk_suitable PARAMS ((cpp_chunk *, unsigned int));\n static unsigned int hex_digit_value PARAMS ((unsigned int));\n static _cpp_buff *new_buff PARAMS ((unsigned int));\n \n@@ -2115,7 +2115,16 @@ cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n   return result;\n }\n \n-/* Memory buffers.  */\n+/* Memory buffers.  Changing these three constants can have a dramatic\n+   effect on performance.  The values here are reasonable defaults,\n+   but might be tuned.  If you adjust them, be sure to test across a\n+   range of uses of cpplib, including heavy nested function-like macro\n+   expansion.  Also check the change in peak memory usage (NJAMD is a\n+   good tool for this).  */\n+#define MIN_BUFF_SIZE 8000\n+#define BUFF_SIZE_UPPER_BOUND(MIN_SIZE) (8000 + (MIN_SIZE) * 3 / 2)\n+#define EXTENDED_BUFF_SIZE(BUFF, MIN_EXTRA) \\\n+\t(MIN_EXTRA + ((BUFF)->limit - (BUFF)->cur) * 2)\n \n struct dummy\n {\n@@ -2138,8 +2147,8 @@ new_buff (len)\n   _cpp_buff *result;\n   char *base;\n \n-  if (len < 4000)\n-    len = 4000;\n+  if (len < MIN_BUFF_SIZE)\n+    len = MIN_BUFF_SIZE;\n   len = CPP_ALIGN (len, DEFAULT_ALIGNMENT);\n \n   base = xmalloc (len + sizeof (_cpp_buff));\n@@ -2175,10 +2184,15 @@ _cpp_get_buff (pfile, min_size)\n \n   for (p = &pfile->free_buffs;; p = &(*p)->next)\n     {\n-      if (*p == NULL || (*p)->next == NULL)\n+      unsigned int size;\n+\n+      if (*p == NULL)\n \treturn new_buff (min_size);\n-      result = (*p)->next;\n-      if ((unsigned int) (result->limit - result->base) > min_size)\n+      result = *p;\n+      size = result->limit - result->base;\n+      /* Return a buffer that's big enough, but don't waste one that's\n+         way too big.  */\n+      if (size >= min_size && size < BUFF_SIZE_UPPER_BOUND (min_size))\n \tbreak;\n     }\n \n@@ -2197,7 +2211,7 @@ _cpp_extend_buff (pfile, buff, min_extra)\n      _cpp_buff *buff;\n      unsigned int min_extra;\n {\n-  unsigned int size = min_extra + (buff->limit - buff->cur) * 2;\n+  unsigned int size = EXTENDED_BUFF_SIZE (buff, min_extra);\n \n   buff->next = _cpp_get_buff (pfile, size);\n   memcpy (buff->next->base, buff->cur, buff->limit - buff->cur);\n@@ -2219,16 +2233,14 @@ _cpp_free_buff (buff)\n }\n \n static int\n-chunk_suitable (pool, chunk, size)\n-     cpp_pool *pool;\n+chunk_suitable (chunk, size)\n      cpp_chunk *chunk;\n      unsigned int size;\n {\n   /* Being at least twice SIZE means we can use memcpy in\n      _cpp_next_chunk rather than memmove.  Besides, it's a good idea\n      anyway.  */\n-  return (chunk && pool->locked != chunk\n-\t  && (unsigned int) (chunk->limit - chunk->base) >= size * 2);\n+  return (chunk && (unsigned int) (chunk->limit - chunk->base) >= size * 2);\n }\n \n /* Returns the end of the new pool.  PTR points to a char in the old\n@@ -2243,7 +2255,7 @@ _cpp_next_chunk (pool, len, ptr)\n \n   /* LEN is the minimum size we want in the new pool.  */\n   len += POOL_ROOM (pool);\n-  if (! chunk_suitable (pool, chunk, len))\n+  if (! chunk_suitable (chunk, len))\n     {\n       chunk = new_chunk (POOL_SIZE (pool) * 2 + len);\n \n@@ -2294,28 +2306,10 @@ _cpp_init_pool (pool, size, align, temp)\n   pool->align = align;\n   pool->first = new_chunk (size);\n   pool->cur = pool->first;\n-  pool->locked = 0;\n-  pool->locks = 0;\n   if (temp)\n     pool->cur->next = pool->cur;\n }\n \n-void\n-_cpp_lock_pool (pool)\n-     cpp_pool *pool;\n-{\n-  if (pool->locks++ == 0)\n-    pool->locked = pool->cur;\n-}\n-\n-void\n-_cpp_unlock_pool (pool)\n-     cpp_pool *pool;\n-{\n-  if (--pool->locks == 0)\n-    pool->locked = 0;\n-}\n-\n void\n _cpp_free_pool (pool)\n      cpp_pool *pool;"}, {"sha": "ad4cfedfaa845877f35223b77404aebc5687e213", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e013d2ee59f0cd640dc56a973ef577465c4aa6b/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=1e013d2ee59f0cd640dc56a973ef577465c4aa6b", "patch": "@@ -54,14 +54,13 @@ struct macro_arg\n \n /* Macro expansion.  */\n \n-static void lock_pools PARAMS ((cpp_reader *));\n-static void unlock_pools PARAMS ((cpp_reader *));\n static int enter_macro_context PARAMS ((cpp_reader *, cpp_hashnode *));\n static const cpp_token *builtin_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n static void push_token_context\n   PARAMS ((cpp_reader *, cpp_macro *, const cpp_token *, unsigned int));\n static void push_ptoken_context\n-  PARAMS ((cpp_reader *, cpp_macro *, const cpp_token **, unsigned int));\n+  PARAMS ((cpp_reader *, cpp_macro *, _cpp_buff *,\n+\t   const cpp_token **, unsigned int));\n static _cpp_buff *collect_args PARAMS ((cpp_reader *, const cpp_hashnode *));\n static cpp_context *next_context PARAMS ((cpp_reader *));\n static const cpp_token *padding_token\n@@ -217,20 +216,6 @@ builtin_macro (pfile, node)\n     }\n }\n \n-static void\n-lock_pools (pfile)\n-     cpp_reader *pfile;\n-{\n-  _cpp_lock_pool (&pfile->argument_pool);\n-}\n-\n-static void\n-unlock_pools (pfile)\n-     cpp_reader *pfile;\n-{\n-  _cpp_unlock_pool (&pfile->argument_pool);\n-}\n-\n /* Adds backslashes before all backslashes and double quotes appearing\n    in strings.  Non-printable characters are converted to octal.  */\n static U_CHAR *\n@@ -685,15 +670,8 @@ enter_macro_context (pfile, node)\n     {\n       cpp_macro *macro = node->value.macro;\n \n-      if (!pfile->context->prev)\n-\tlock_pools (pfile);\n-\n       if (macro->fun_like && !funlike_invocation_p (pfile, node))\n-\t{\n-\t  if (!pfile->context->prev)\n-\t    unlock_pools (pfile);\n-\t  return 0;\n-\t}\n+\treturn 0;\n \n       /* Disable the macro within its expansion.  */\n       macro->disabled = 1;\n@@ -718,12 +696,12 @@ replace_args (pfile, macro, args)\n   const cpp_token *src, *limit;\n   const cpp_token **dest, **first;\n   macro_arg *arg;\n+  _cpp_buff *buff;\n \n   /* First, fully macro-expand arguments, calculating the number of\n-     tokens in the final expansion as we go.  This ensures that the\n-     possible recursive use of argument_pool is fine.  The ordering of\n-     the if statements below is subtle; we must handle stringification\n-     before pasting.  */\n+     tokens in the final expansion as we go.  The ordering of the if\n+     statements below is subtle; we must handle stringification before\n+     pasting.  */\n   total = macro->count;\n   limit = macro->expansion + macro->count;\n \n@@ -755,8 +733,8 @@ replace_args (pfile, macro, args)\n \n   /* Now allocate space for the expansion, copy the tokens and replace\n      the arguments.  */\n-  first = (const cpp_token **) _cpp_pool_alloc (&pfile->argument_pool,\n-\t\t\t\t\t\ttotal * sizeof (cpp_token *));\n+  buff = _cpp_get_buff (pfile, total * sizeof (cpp_token *));\n+  first = (const cpp_token **) buff->base;\n   dest = first;\n \n   for (src = macro->expansion; src < limit; src++)\n@@ -841,7 +819,7 @@ replace_args (pfile, macro, args)\n     if (args[i].expanded)\n       free (args[i].expanded);\n \n-  push_ptoken_context (pfile, macro, first, dest - first);\n+  push_ptoken_context (pfile, macro, buff, first, dest - first);\n }\n \n /* Return a special padding token, with padding inherited from SOURCE.  */\n@@ -879,16 +857,18 @@ next_context (pfile)\n \n /* Push a list of pointers to tokens.  */\n static void\n-push_ptoken_context (pfile, macro, first, count)\n+push_ptoken_context (pfile, macro, buff, first, count)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n+     _cpp_buff *buff;\n      const cpp_token **first;\n      unsigned int count;\n {\n   cpp_context *context = next_context (pfile);\n \n   context->direct_p = false;\n   context->macro = macro;\n+  context->buff = buff;\n   context->first.ptoken = first;\n   context->last.ptoken = first + count;\n }\n@@ -905,6 +885,7 @@ push_token_context (pfile, macro, first, count)\n \n   context->direct_p = true;\n   context->macro = macro;\n+  context->buff = NULL;\n   context->first.token = first;\n   context->last.token = first + count;\n }\n@@ -924,7 +905,7 @@ expand_arg (pfile, arg)\n   arg->expanded = (const cpp_token **)\n     xmalloc (capacity * sizeof (cpp_token *));\n \n-  push_ptoken_context (pfile, NULL, arg->first, arg->count + 1);\n+  push_ptoken_context (pfile, NULL, NULL, arg->first, arg->count + 1);\n   for (;;)\n     {\n       const cpp_token *token;\n@@ -944,22 +925,23 @@ expand_arg (pfile, arg)\n       arg->expanded[arg->expanded_count++] = token;\n     }\n \n-  /* Avoid the unlock_pools test of _cpp_pop_context.  Change this to\n-     call _cpp_pop_context once we remove pool locking.  */\n-  pfile->context = pfile->context->prev;\n+  _cpp_pop_context (pfile);\n }\n \n void\n _cpp_pop_context (pfile)\n      cpp_reader *pfile;\n {\n+  cpp_context *context = pfile->context;\n+\n   /* Re-enable a macro when leaving its expansion.  */\n-  if (pfile->context->macro)\n-    pfile->context->macro->disabled = 0;\n+  if (context->macro)\n+    context->macro->disabled = 0;\n+\n+  if (context->buff)\n+    _cpp_release_buff (pfile, context->buff);\n \n-  pfile->context = pfile->context->prev;\n-  if (!pfile->context->prev && !pfile->state.parsing_args)\n-    unlock_pools (pfile);\n+  pfile->context = context->prev;\n }\n \n /* Eternal routine to get a token.  Also used nearly everywhere"}]}