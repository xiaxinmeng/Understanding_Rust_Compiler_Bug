{"sha": "f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJiNGYyMTJhOTdhZTEzN2MyYThlY2FmZTdlZDJjYjViNTAxNmI2Yg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-04-21T19:33:41Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-04-21T19:33:41Z"}, "message": "Revert \"Use std::thread::hardware_concurrency in lto-wrapper.c.\"\n\nThis reverts commit 0a18305ee11e139838771f96c5a037a29606236e.", "tree": {"sha": "47b428172502d5b466635685a658a497f904a57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47b428172502d5b466635685a658a497f904a57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a63035ae262078cd70927b06a2bd3ee94cc6e56e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a63035ae262078cd70927b06a2bd3ee94cc6e56e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a63035ae262078cd70927b06a2bd3ee94cc6e56e"}], "stats": {"total": 113, "additions": 108, "deletions": 5}, "files": [{"sha": "0b626d7c81186d346b47bcf8b2d672d9d86ff461", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=f2b4f212a97ae137c2a8ecafe7ed2cb5b5016b6b", "patch": "@@ -49,8 +49,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-section-names.h\"\n #include \"collect-utils.h\"\n \n-#include <thread>\n-\n /* Environment variable, used for passing the names of offload targets from GCC\n    driver to lto-wrapper.  */\n #define OFFLOAD_TARGET_NAMES_ENV\t\"OFFLOAD_TARGET_NAMES\"\n@@ -1201,6 +1199,113 @@ cmp_priority (const void *a, const void *b)\n   return *((const int *)b)-*((const int *)a);\n }\n \n+/* Number of CPUs that can be used for parallel LTRANS phase.  */\n+\n+static unsigned long nthreads_var = 0;\n+\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+unsigned long cpuset_size;\n+static unsigned long get_cpuset_size;\n+cpu_set_t *cpusetp;\n+\n+unsigned long\n+static cpuset_popcount (unsigned long cpusetsize, cpu_set_t *cpusetp)\n+{\n+#ifdef CPU_COUNT_S\n+  /* glibc 2.7 and above provide a macro for this.  */\n+  return CPU_COUNT_S (cpusetsize, cpusetp);\n+#else\n+#ifdef CPU_COUNT\n+  if (cpusetsize == sizeof (cpu_set_t))\n+    /* glibc 2.6 and above provide a macro for this.  */\n+    return CPU_COUNT (cpusetp);\n+#endif\n+  size_t i;\n+  unsigned long ret = 0;\n+  STATIC_ASSERT (sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int));\n+  for (i = 0; i < cpusetsize / sizeof (cpusetp->__bits[0]); i++)\n+    {\n+      unsigned long int mask = cpusetp->__bits[i];\n+      if (mask == 0)\n+\tcontinue;\n+      ret += __builtin_popcountl (mask);\n+    }\n+  return ret;\n+#endif\n+}\n+#endif\n+\n+/* At startup, determine the default number of threads.  It would seem\n+   this should be related to the number of cpus online.  */\n+\n+static void\n+init_num_threads (void)\n+{\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+#if defined (_SC_NPROCESSORS_CONF) && defined (CPU_ALLOC_SIZE)\n+  cpuset_size = sysconf (_SC_NPROCESSORS_CONF);\n+  cpuset_size = CPU_ALLOC_SIZE (cpuset_size);\n+#else\n+  cpuset_size = sizeof (cpu_set_t);\n+#endif\n+\n+  cpusetp = (cpu_set_t *) xmalloc (gomp_cpuset_size);\n+  do\n+    {\n+      int ret = pthread_getaffinity_np (pthread_self (), gomp_cpuset_size,\n+\t\t\t\t\tcpusetp);\n+      if (ret == 0)\n+\t{\n+\t  /* Count only the CPUs this process can use.  */\n+\t  nthreads_var = cpuset_popcount (cpuset_size, cpusetp);\n+\t  if (nthreads_var == 0)\n+\t    break;\n+\t  get_cpuset_size = cpuset_size;\n+#ifdef CPU_ALLOC_SIZE\n+\t  unsigned long i;\n+\t  for (i = cpuset_size * 8; i; i--)\n+\t    if (CPU_ISSET_S (i - 1, cpuset_size, cpusetp))\n+\t      break;\n+\t  cpuset_size = CPU_ALLOC_SIZE (i);\n+#endif\n+\t  return;\n+\t}\n+      if (ret != EINVAL)\n+\tbreak;\n+#ifdef CPU_ALLOC_SIZE\n+      if (cpuset_size < sizeof (cpu_set_t))\n+\tcpuset_size = sizeof (cpu_set_t);\n+      else\n+\tcpuset_size = cpuset_size * 2;\n+      if (cpuset_size < 8 * sizeof (cpu_set_t))\n+\tcpusetp\n+\t  = (cpu_set_t *) realloc (cpusetp, cpuset_size);\n+      else\n+\t{\n+\t  /* Avoid fatal if too large memory allocation would be\n+\t     requested, e.g. kernel returning EINVAL all the time.  */\n+\t  void *p = realloc (cpusetp, cpuset_size);\n+\t  if (p == NULL)\n+\t    break;\n+\t  cpusetp = (cpu_set_t *) p;\n+\t}\n+#else\n+      break;\n+#endif\n+    }\n+  while (1);\n+  cpuset_size = 0;\n+  nthreads_var = 1;\n+  free (cpusetp);\n+  cpusetp = NULL;\n+#endif\n+#ifdef _SC_NPROCESSORS_ONLN\n+  nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n+#endif\n+}\n+\n+/* FIXME: once using -std=c++11, we can use std::thread::hardware_concurrency.  */\n+\n /* Test and return reason why a jobserver cannot be detected.  */\n \n static const char *\n@@ -1284,9 +1389,6 @@ run_gcc (unsigned argc, char *argv[])\n   const char *incoming_dumppfx = dumppfx = NULL;\n   static char current_dir[] = { '.', DIR_SEPARATOR, '\\0' };\n \n-  /* Number of CPUs that can be used for parallel LTRANS phase.  */\n-  unsigned long nthreads_var = std::thread::hardware_concurrency ();\n-\n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n   if (!collect_gcc)\n@@ -1678,6 +1780,7 @@ run_gcc (unsigned argc, char *argv[])\n       else if (auto_parallel)\n \t{\n \t  char buf[256];\n+\t  init_num_threads ();\n \t  if (nthreads_var == 0)\n \t    nthreads_var = 1;\n \t  if (verbose)"}]}