{"sha": "552725e3bd542d98dd0f4a830c602230fff7138c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUyNzI1ZTNiZDU0MmQ5OGRkMGY0YTgzMGM2MDIyMzBmZmY3MTM4Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-10-21T15:46:19Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-10-21T15:46:19Z"}, "message": "re PR ada/21937 (Member record alignment triggers an ICE)\n\n\tPR ada/21937\n\tPR ada/22328\n\tPR ada/22381\n\tPR ada/22383\n\tPR ada/22419\n\tPR ada/22420\n\t* utils2.c (build_return_expr): New helper function.\n\t* gigi.h (build_return_expr): Declare it.\n\t* trans.c (Subprogram_Body_to_gnu): Use build_return_expr instead\n\tof manually building the RETURN_EXPR tree.\n\t(call_to_gnu): Pass MODIFY_EXPR through build_binary_op.\n\t(gnat_to_gnu) <N_Return_Statement>: Pass MODIFY_EXPR through\n\tbuild_binary_op for the \"target pointer\" case. \ufffdUse build_return_expr\n\tinstead of manually building the RETURN_EXPR tree.\n\nFrom-SVN: r105741", "tree": {"sha": "6f247edb01a5d6b87e8e3c910f200eaeb6643429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f247edb01a5d6b87e8e3c910f200eaeb6643429"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/552725e3bd542d98dd0f4a830c602230fff7138c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/552725e3bd542d98dd0f4a830c602230fff7138c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/552725e3bd542d98dd0f4a830c602230fff7138c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/552725e3bd542d98dd0f4a830c602230fff7138c/comments", "author": null, "committer": null, "parents": [{"sha": "6058b2fa2cc5799e442cc8c7a02bff0b170b6025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6058b2fa2cc5799e442cc8c7a02bff0b170b6025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6058b2fa2cc5799e442cc8c7a02bff0b170b6025"}], "stats": {"total": 88, "additions": 74, "deletions": 14}, "files": [{"sha": "877d6b7dfe41400efe90648645db58de96117783", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=552725e3bd542d98dd0f4a830c602230fff7138c", "patch": "@@ -1,3 +1,20 @@\n+2005-10-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/21937\n+\tPR ada/22328\n+\tPR ada/22381\n+\tPR ada/22383\n+\tPR ada/22419\n+\tPR ada/22420\n+\t* utils2.c (build_return_expr): New helper function.\n+\t* gigi.h (build_return_expr): Declare it.\n+\t* trans.c (Subprogram_Body_to_gnu): Use build_return_expr instead\n+\tof manually building the RETURN_EXPR tree.\n+\t(call_to_gnu): Pass MODIFY_EXPR through build_binary_op.\n+\t(gnat_to_gnu) <N_Return_Statement>: Pass MODIFY_EXPR through\n+\tbuild_binary_op for the \"target pointer\" case. \ufffdUse build_return_expr\n+\tinstead of manually building the RETURN_EXPR tree.\n+\n 2005-09-16  Laurent GUERBY  <laurent@guerby.net>\n \n \tPR ada/23788"}, {"sha": "9dba805530d817fdfb076c5f1481ed0b99581976", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=552725e3bd542d98dd0f4a830c602230fff7138c", "patch": "@@ -678,6 +678,9 @@ extern tree build_unary_op (enum tree_code op_code, tree result_type,\n extern tree build_cond_expr (tree result_type, tree condition_operand,\n                              tree true_operand, tree false_operand);\n \n+/* Similar, but for RETURN_EXPR.  */\n+extern tree build_return_expr (tree result_decl, tree ret_val);\n+\n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */\n extern tree build_call_1_expr (tree fundecl, tree arg);"}, {"sha": "0e05b6d473144824fed2bf3197bfbabe572b6305", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=552725e3bd542d98dd0f4a830c602230fff7138c", "patch": "@@ -1456,9 +1456,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \tgnu_retval = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_retval);\n \n       add_stmt_with_node\n-\t(build1 (RETURN_EXPR, void_type_node,\n-\t\t build2 (MODIFY_EXPR, TREE_TYPE (gnu_retval),\n-\t\t\t DECL_RESULT (current_function_decl), gnu_retval)),\n+\t(build_return_expr (DECL_RESULT (current_function_decl), gnu_retval),\n \t gnat_node);\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n@@ -1685,8 +1683,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t}\n \n \t      /* Set up to move the copy back to the original.  */\n-\t      gnu_temp = build2 (MODIFY_EXPR, TREE_TYPE (gnu_copy),\n-\t\t\t\t gnu_copy, gnu_actual);\n+\t      gnu_temp = build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t\t  gnu_copy, gnu_actual);\n \t      annotate_with_node (gnu_temp, gnat_actual);\n \t      append_to_statement_list (gnu_temp, &gnu_after_list);\n \t    }\n@@ -3519,8 +3517,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \ttree gnu_ret_val = NULL_TREE;\n \t/* The place to put the return value.  */\n \ttree gnu_lhs;\n-\t/* Avoid passing error_mark_node to RETURN_EXPR.  */\n-\tgnu_result = NULL_TREE;\n \n \t/* If we are dealing with a \"return;\" from an Ada procedure with\n \t   parameters passed by copy in copy out, we need to return a record\n@@ -3626,18 +3622,20 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t  }\n \t      }\n \t  }\n-\n-\tif (gnu_ret_val)\n-\t  gnu_result = build2 (MODIFY_EXPR, TREE_TYPE (gnu_ret_val),\n-\t\t\t       gnu_lhs, gnu_ret_val);\n+\telse\n+\t  /* If the Ada subprogram is a regular procedure, just return.  */\n+\t  gnu_lhs = NULL_TREE;\n \n \tif (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n \t  {\n+\t    if (gnu_ret_val)\n+\t      gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t\t    gnu_lhs, gnu_ret_val);\n \t    add_stmt_with_node (gnu_result, gnat_node);\n-\t    gnu_result = NULL_TREE;\n+\t    gnu_lhs = NULL_TREE;\n \t  }\n \n-\tgnu_result = build1 (RETURN_EXPR, void_type_node, gnu_result);\n+\tgnu_result = build_return_expr (gnu_lhs, gnu_ret_val);\n       }\n       break;\n "}, {"sha": "21a3f61f7615bd08ba98176c30280edb394abd1c", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/552725e3bd542d98dd0f4a830c602230fff7138c/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=552725e3bd542d98dd0f4a830c602230fff7138c", "patch": "@@ -1378,8 +1378,50 @@ build_cond_expr (tree result_type, tree condition_operand,\n \n   return result;\n }\n-\f\n \n+/* Similar, but for RETURN_EXPR.  If RESULT_DECL is non-zero, build\n+   a RETURN_EXPR around the assignment of RET_VAL to RESULT_DECL.\n+   If RESULT_DECL is zero, build a bare RETURN_EXPR.  */\n+\n+tree\n+build_return_expr (tree result_decl, tree ret_val)\n+{\n+  tree result_expr;\n+\n+  if (result_decl)\n+    {\n+      /* The gimplifier explicitly enforces the following invariant:\n+\n+           RETURN_EXPR\n+               |\n+           MODIFY_EXPR\n+           /        \\\n+          /          \\\n+      RESULT_DECL    ...\n+\n+      As a consequence, type-homogeneity dictates that we use the type\n+      of the RESULT_DECL as the operation type.  */\n+\n+      tree operation_type = TREE_TYPE (result_decl);\n+\n+      /* Convert the right operand to the operation type.  Note that\n+         it's the same transformation as in the MODIFY_EXPR case of\n+         build_binary_op with the additional guarantee that the type\n+         cannot involve a placeholder, since otherwise the function\n+         would use the \"target pointer\" return mechanism.  */\n+       \n+      if (operation_type != TREE_TYPE (ret_val))\n+\tret_val = convert (operation_type, ret_val);\n+\n+      result_expr\n+\t= build2 (MODIFY_EXPR, operation_type, result_decl, ret_val);\n+    }\n+  else\n+    result_expr = NULL_TREE;\n+\n+  return build1 (RETURN_EXPR, void_type_node, result_expr);\n+}\n+\f\n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */\n "}]}