{"sha": "50b6d6761b1a265ced9c471a81da6b91d8b1931a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBiNmQ2NzYxYjFhMjY1Y2VkOWM0NzFhODFkYTZiOTFkOGIxOTMxYQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-03-16T23:31:01Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-03-16T23:31:01Z"}, "message": "stabilize store merging\n\nDon't let pointer randomization change the order in which we process\nstore chains.  This may cause SSA_NAMEs to be released in different\norder, and if they're reused later, they may cause differences in SSA\npartitioning, leading to differences in expand, and ultimately to\ndifferent code.\n\nbootstrap-debug-lean (-fcompare-debug) on i686-linux-gnu has failed in\nhaifa-sched.c since r245196 exposed the latent ordering problem in\nstore merging.  In this case, the IR differences (different SSA names\nselected for copies in out-of-SSA, resulting in some off-by-one\ndifferences in pseudos) were not significant enough to be visible in\nthe compiler output.\n\n\nfor  gcc/ChangeLog\n\n\t* gimple-ssa-store-merging.c (struct imm_store_chain_info):\n\tAdd linked-list forward and backlinks.  Insert on\n\tconstruction, remove on destruction.\n\t(class pass_store_merging): Add m_stores_head field.\n\t(pass_store_merging::terminate_and_process_all_chains):\n\tIterate over m_stores_head list.\n\t(pass_store_merging::terminate_all_aliasing_chains):\n\tLikewise.\n\t(pass_store_merging::execute): Check for debug stmts first.\n\tPush new chains onto the m_stores_head stack.\n\nFrom-SVN: r246213", "tree": {"sha": "7905059192c02cdbcd9b49414ebc7f6cc04d07ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7905059192c02cdbcd9b49414ebc7f6cc04d07ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50b6d6761b1a265ced9c471a81da6b91d8b1931a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b6d6761b1a265ced9c471a81da6b91d8b1931a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b6d6761b1a265ced9c471a81da6b91d8b1931a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b6d6761b1a265ced9c471a81da6b91d8b1931a/comments", "author": null, "committer": null, "parents": [{"sha": "2e92d7ada96c875356c56ebc336f9b0def0041e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e92d7ada96c875356c56ebc336f9b0def0041e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e92d7ada96c875356c56ebc336f9b0def0041e2"}], "stats": {"total": 78, "additions": 62, "deletions": 16}, "files": [{"sha": "d0ed5ce3c57b19fe6f1e70c68330ed8a510dbc62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6d6761b1a265ced9c471a81da6b91d8b1931a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6d6761b1a265ced9c471a81da6b91d8b1931a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50b6d6761b1a265ced9c471a81da6b91d8b1931a", "patch": "@@ -1,3 +1,16 @@\n+2017-03-16  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* gimple-ssa-store-merging.c (struct imm_store_chain_info):\n+\tAdd linked-list forward and backlinks.  Insert on\n+\tconstruction, remove on destruction.\n+\t(class pass_store_merging): Add m_stores_head field.\n+\t(pass_store_merging::terminate_and_process_all_chains):\n+\tIterate over m_stores_head list.\n+\t(pass_store_merging::terminate_all_aliasing_chains):\n+\tLikewise.\n+\t(pass_store_merging::execute): Check for debug stmts first.\n+\tPush new chains onto the m_stores_head stack.\n+\n 2017-03-16  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/71294"}, {"sha": "5bdb4597d615a36c811fc17eea77a90da7f5a133", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b6d6761b1a265ced9c471a81da6b91d8b1931a/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b6d6761b1a265ced9c471a81da6b91d8b1931a/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=50b6d6761b1a265ced9c471a81da6b91d8b1931a", "patch": "@@ -675,11 +675,34 @@ merged_store_group::apply_stores ()\n \n struct imm_store_chain_info\n {\n+  /* Doubly-linked list that imposes an order on chain processing.\n+     PNXP (prev's next pointer) points to the head of a list, or to\n+     the next field in the previous chain in the list.\n+     See pass_store_merging::m_stores_head for more rationale.  */\n+  imm_store_chain_info *next, **pnxp;\n   tree base_addr;\n   auto_vec<struct store_immediate_info *> m_store_info;\n   auto_vec<merged_store_group *> m_merged_store_groups;\n \n-  imm_store_chain_info (tree b_a) : base_addr (b_a) {}\n+  imm_store_chain_info (imm_store_chain_info *&inspt, tree b_a)\n+  : next (inspt), pnxp (&inspt), base_addr (b_a)\n+  {\n+    inspt = this;\n+    if (next)\n+      {\n+\tgcc_checking_assert (pnxp == next->pnxp);\n+\tnext->pnxp = &next;\n+      }\n+  }\n+  ~imm_store_chain_info ()\n+  {\n+    *pnxp = next;\n+    if (next)\n+      {\n+\tgcc_checking_assert (&next == next->pnxp);\n+\tnext->pnxp = pnxp;\n+      }\n+  }\n   bool terminate_and_process_chain ();\n   bool coalesce_immediate_stores ();\n   bool output_merged_store (merged_store_group *);\n@@ -718,6 +741,17 @@ class pass_store_merging : public gimple_opt_pass\n private:\n   hash_map<tree_operand_hash, struct imm_store_chain_info *> m_stores;\n \n+  /* Form a doubly-linked stack of the elements of m_stores, so that\n+     we can iterate over them in a predictable way.  Using this order\n+     avoids extraneous differences in the compiler output just because\n+     of tree pointer variations (e.g. different chains end up in\n+     different positions of m_stores, so they are handled in different\n+     orders, so they allocate or release SSA names in different\n+     orders, and when they get reused, subsequent passes end up\n+     getting different SSA names, which may ultimately change\n+     decisions when going out of SSA).  */\n+  imm_store_chain_info *m_stores_head;\n+\n   bool terminate_and_process_all_chains ();\n   bool terminate_all_aliasing_chains (imm_store_chain_info **,\n \t\t\t\t      bool, gimple *);\n@@ -730,11 +764,11 @@ class pass_store_merging : public gimple_opt_pass\n bool\n pass_store_merging::terminate_and_process_all_chains ()\n {\n-  hash_map<tree_operand_hash, struct imm_store_chain_info *>::iterator iter\n-    = m_stores.begin ();\n   bool ret = false;\n-  for (; iter != m_stores.end (); ++iter)\n-    ret |= terminate_and_release_chain ((*iter).second);\n+  while (m_stores_head)\n+    ret |= terminate_and_release_chain (m_stores_head);\n+  gcc_assert (m_stores.elements () == 0);\n+  gcc_assert (m_stores_head == NULL);\n \n   return ret;\n }\n@@ -799,27 +833,26 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n \t}\n     }\n \n-  hash_map<tree_operand_hash, struct imm_store_chain_info *>::iterator iter\n-    = m_stores.begin ();\n-\n   /* Check for aliasing with all other store chains.  */\n-  for (; iter != m_stores.end (); ++iter)\n+  for (imm_store_chain_info *next = m_stores_head, *cur = next; cur; cur = next)\n     {\n+      next = cur->next;\n+\n       /* We already checked all the stores in chain_info and terminated the\n \t chain if necessary.  Skip it here.  */\n-      if (chain_info && (*chain_info) == (*iter).second)\n+      if (chain_info && (*chain_info) == cur)\n \tcontinue;\n \n       /* We can't use the base object here as that does not reliably exist.\n \t Build a ao_ref from the base object address (if we know the\n \t minimum and maximum offset and the maximum size we could improve\n \t things here).  */\n       ao_ref chain_ref;\n-      ao_ref_init_from_ptr_and_size (&chain_ref, (*iter).first, NULL_TREE);\n+      ao_ref_init_from_ptr_and_size (&chain_ref, cur->base_addr, NULL_TREE);\n       if (ref_maybe_used_by_stmt_p (stmt, &chain_ref)\n \t  || stmt_may_clobber_ref_p_1 (stmt, &chain_ref))\n \t{\n-\t  terminate_and_release_chain ((*iter).second);\n+\t  terminate_and_release_chain (cur);\n \t  ret = true;\n \t}\n     }\n@@ -1336,6 +1369,9 @@ pass_store_merging::execute (function *fun)\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n \n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n \t  if (gimple_has_volatile_ops (stmt))\n \t    {\n \t      /* Terminate all chains.  */\n@@ -1346,9 +1382,6 @@ pass_store_merging::execute (function *fun)\n \t      continue;\n \t    }\n \n-\t  if (is_gimple_debug (stmt))\n-\t    continue;\n-\n \t  if (gimple_assign_single_p (stmt) && gimple_vdef (stmt)\n \t      && !stmt_can_throw_internal (stmt)\n \t      && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt)))\n@@ -1456,7 +1489,7 @@ pass_store_merging::execute (function *fun)\n \t\t  terminate_all_aliasing_chains (chain_info, false, stmt);\n \t\t  /* Start a new chain.  */\n \t\t  struct imm_store_chain_info *new_chain\n-\t\t    = new imm_store_chain_info (base_addr);\n+\t\t    = new imm_store_chain_info (m_stores_head, base_addr);\n \t\t  info = new store_immediate_info (bitsize, bitpos,\n \t\t\t\t\t\t   stmt, 0);\n \t\t  new_chain->m_store_info.safe_push (info);"}]}