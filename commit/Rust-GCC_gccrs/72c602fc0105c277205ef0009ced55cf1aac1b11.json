{"sha": "72c602fc0105c277205ef0009ced55cf1aac1b11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJjNjAyZmMwMTA1YzI3NzIwNWVmMDAwOWNlZDU1Y2YxYWFjMWIxMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-04T16:40:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-04T16:40:05Z"}, "message": "machmode.h (mode_for_size, [...]): SIZE now signed.\n\n\t* machmode.h (mode_for_size, smallest_mode_for_size): SIZE now signed.\n\t* stor-layout.c (mode_for_size, smallest_mode_for_size): Likewise.\n\t(mode_for_size_tree): New function.\n\t(layout_decl, layout_type): Call it and clean up BLKmode checks.\n\t* tree.h (mode_for_size_tree): New declaration.\n\nFrom-SVN: r32326", "tree": {"sha": "0bc00a84f047a96e621c6557559e38b55168e59e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bc00a84f047a96e621c6557559e38b55168e59e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72c602fc0105c277205ef0009ced55cf1aac1b11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c602fc0105c277205ef0009ced55cf1aac1b11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c602fc0105c277205ef0009ced55cf1aac1b11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c602fc0105c277205ef0009ced55cf1aac1b11/comments", "author": null, "committer": null, "parents": [{"sha": "32070bf2d8a85cc742b3ac8d4873cadd9c863d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32070bf2d8a85cc742b3ac8d4873cadd9c863d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32070bf2d8a85cc742b3ac8d4873cadd9c863d40"}], "stats": {"total": 87, "additions": 60, "deletions": 27}, "files": [{"sha": "e53307dca9463de355f0c7256cf4b08b9fd9b10a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72c602fc0105c277205ef0009ced55cf1aac1b11", "patch": "@@ -1,5 +1,11 @@\n Sat Mar  4 11:32:30 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* machmode.h (mode_for_size, smallest_mode_for_size): SIZE now signed.\n+\t* stor-layout.c (mode_for_size, smallest_mode_for_size): Likewise.\n+\t(mode_for_size_tree): New function.\n+\t(layout_decl, layout_type): Call it and clean up BLKmode checks.\n+\t* tree.h (mode_for_size_tree): New declaration.\n+\t\n \t* toplev.c (debug_ignore_block): Mark arg BLOCK as possibly unused.\n \n 2000-03-04  Jason Merrill  <jason@casey.cygnus.com>"}, {"sha": "fd2101bcf512e3d6cd6f66faebb7a655a4062354", "filename": "gcc/machmode.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=72c602fc0105c277205ef0009ced55cf1aac1b11", "patch": "@@ -1,5 +1,6 @@\n /* Machine mode definitions for GNU C-Compiler; included by rtl.h and tree.h.\n-   Copyright (C) 1991, 93, 94, 96, 98, 99, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -105,12 +106,12 @@ extern const unsigned char mode_wider_mode[];\n    If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n    The value is BLKmode if no other mode is found.  */\n \n-extern enum machine_mode mode_for_size PARAMS ((unsigned int, enum mode_class, int));\n+extern enum machine_mode mode_for_size PARAMS ((int, enum mode_class, int));\n \n /* Similar, but find the smallest mode for a given width.  */\n \n-extern enum machine_mode smallest_mode_for_size  PARAMS ((unsigned int,\n-                                                        enum mode_class));\n+extern enum machine_mode smallest_mode_for_size \n+\t\t\t\tPARAMS ((int, enum mode_class));\n \n \n /* Return an integer mode of the exact same size as the input mode,"}, {"sha": "3aa186cf9f78386a09483697401b710a0b6e45ce", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=72c602fc0105c277205ef0009ced55cf1aac1b11", "patch": "@@ -150,30 +150,52 @@ variable_size (size)\n \n enum machine_mode\n mode_for_size (size, class, limit)\n-     unsigned int size;\n+     int size;\n      enum mode_class class;\n      int limit;\n {\n   register enum machine_mode mode;\n \n-  if (limit && size > (unsigned int)(MAX_FIXED_MODE_SIZE))\n+  if (limit && size > MAX_FIXED_MODE_SIZE)\n     return BLKmode;\n \n   /* Get the first mode which has this size, in the specified class.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if ((unsigned int)GET_MODE_BITSIZE (mode) == size)\n+    if (GET_MODE_BITSIZE (mode) == size)\n       return mode;\n \n   return BLKmode;\n }\n \n+/* Similar, except passed a tree node.  */\n+\n+enum machine_mode\n+mode_for_size_tree (size, class, limit)\n+     tree size;\n+     enum mode_class class;\n+     int limit;\n+{\n+  if (TREE_CODE (size) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (size) != 0\n+      /* If the low-order part is so high as to appear negative, we can't\n+\t find a mode for that many bits.  */\n+      || TREE_INT_CST_LOW (size) < 0\n+      /* What we really want to say here is that the size can fit in a\n+\t host integer, but we know there's no way we'd find a mode for\n+\t this many bits, so there's no point in doing the precise test.  */\n+      || TREE_INT_CST_LOW (size) > 1000)\n+    return BLKmode;\n+  else\n+    return mode_for_size (TREE_INT_CST_LOW (size), class, limit);\n+}\n+\n /* Similar, but never return BLKmode; return the narrowest mode that\n    contains at least the requested number of bits.  */\n \n enum machine_mode\n smallest_mode_for_size (size, class)\n-     unsigned int size;\n+     int size;\n      enum mode_class class;\n {\n   register enum machine_mode mode;\n@@ -182,7 +204,7 @@ smallest_mode_for_size (size, class)\n      specified class.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if ((unsigned int)GET_MODE_BITSIZE (mode) >= size)\n+    if (GET_MODE_BITSIZE (mode) >= size)\n       return mode;\n \n   abort ();\n@@ -332,7 +354,7 @@ layout_decl (decl, known_align)\n       && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT)\n     {\n       register enum machine_mode xmode\n-\t= mode_for_size (TREE_INT_CST_LOW (DECL_SIZE (decl)), MODE_INT, 1);\n+\t= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);\n \n       if (xmode != BLKmode\n \t  && known_align % GET_MODE_ALIGNMENT (xmode) == 0)\n@@ -1058,19 +1080,17 @@ layout_type (type)\n \n \tTYPE_MODE (type) = BLKmode;\n \tif (TYPE_SIZE (type) != 0\n-\t    && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n \t    /* BLKmode elements force BLKmode aggregate;\n \t       else extract/store fields may lose.  */\n \t    && (TYPE_MODE (TREE_TYPE (type)) != BLKmode\n \t\t|| TYPE_NO_FORCE_BLK (TREE_TYPE (type))))\n \t  {\n \t    TYPE_MODE (type)\n-\t      = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n-\t\t\t       MODE_INT, 1);\n+\t      = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);\n \n-\t    if (STRICT_ALIGNMENT && TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n-\t\t&& ((int) TYPE_ALIGN (type)\n-\t\t    < TREE_INT_CST_LOW (TYPE_SIZE (type)))\n+\t    if (TYPE_MODE (type) != BLKmode\n+\t\t&& STRICT_ALIGNMENT && TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n+\t\t&& TYPE_ALIGN (type) < GET_MODE_ALIGNMENT (TYPE_MODE (type))\n \t\t&& TYPE_MODE (type) != BLKmode)\n \t      {\n \t\tTYPE_NO_FORCE_BLK (type) = 1;\n@@ -1136,21 +1156,20 @@ layout_type (type)\n \t    TYPE_MODE (type) = mode;\n \t  else\n \t    TYPE_MODE (type)\n-\t      = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n-\t\t\t       MODE_INT, 1);\n+\t      = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);\n \n \t  /* If structure's known alignment is less than\n \t     what the scalar mode would need, and it matters,\n \t     then stick with BLKmode.  */\n-\t  if (STRICT_ALIGNMENT\n+\t  if (TYPE_MODE (type) != BLKmode\n+\t      && STRICT_ALIGNMENT\n \t      && ! (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t\t    || ((int) TYPE_ALIGN (type)\n-\t\t\t>= TREE_INT_CST_LOW (TYPE_SIZE (type)))))\n+\t\t    || (TYPE_ALIGN (type) >=\n+\t\t\tGET_MODE_ALIGNMENT (TYPE_MODE (type)))))\n \t    {\n-\t      if (TYPE_MODE (type) != BLKmode)\n-\t\t/* If this is the only reason this type is BLKmode,\n-\t\t   then don't force containing types to be BLKmode.  */\n-\t\tTYPE_NO_FORCE_BLK (type) = 1;\n+\t      /* If this is the only reason this type is BLKmode,\n+\t\t then don't force containing types to be BLKmode.  */\n+\t      TYPE_NO_FORCE_BLK (type) = 1;\n \t      TYPE_MODE (type) = BLKmode;\n \t    }\n \n@@ -1195,8 +1214,7 @@ layout_type (type)\n \t    }\n \n \t  TYPE_MODE (type)\n-\t    = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n-\t\t\t     MODE_INT, 1);\n+\t    = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);\n \n \tunion_lose: ;\n \t}"}, {"sha": "1a827581c6b3d573c95250ff5b8eb60aee6a89a6", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c602fc0105c277205ef0009ced55cf1aac1b11/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=72c602fc0105c277205ef0009ced55cf1aac1b11", "patch": "@@ -1799,6 +1799,14 @@ extern tree type_hash_canon\t\tPARAMS ((int, tree));\n \n extern void layout_decl\t\t\tPARAMS ((tree, unsigned));\n \n+/* Return the mode for data of a given size SIZE and mode class CLASS.\n+   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n+   The value is BLKmode if no other mode is found.  This is like\n+   mode_for_size, but is passed a tree.  */\n+\n+extern enum machine_mode mode_for_size_tree PARAMS ((tree, enum mode_class,\n+\t\t\t\t\t\t     int));\n+\n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n extern tree non_lvalue\t\t\tPARAMS ((tree));"}]}