{"sha": "efdfd311d664c32c3a6108f920fc978bb95c5d8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZkZmQzMTFkNjY0YzMyYzNhNjEwOGY5MjBmYzk3OGJiOTVjNWQ4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-12-03T11:47:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-12-03T11:47:53Z"}, "message": "[multiple changes]\n\n2003-12-03  Thomas Quinot  <quinot@act-europe.fr>\n\n\tPR ada/11724\n\n\t* adaint.h, adaint.c, g-os_lib.ads:\n\tDo not assume that the offset argument to lseek(2) is a 32 bit integer,\n\ton some platforms (including FreeBSD), it is a 64 bit value.\n\tIntroduce a __gnat_lseek wrapper in adaint.c to allow for portability.\n\n2003-12-03  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* gnatvsn.ads (Library_Version): Now contain only the relevant\n\tversion info.\n\t(Verbose_Library_Version): New constant.\n\n\t* g-spipat.adb, g-awk.adb, g-debpoo.adb,\n\tg-memdum.adb, g-thread.adb, s-geveop.adb, s-interr.adb,\n\ts-taskin.adb, s-tassta.adb: Make code compile with -gnatwa.\n\n\t* gnatlbr.adb: Clean up: replace Library_Version by\n\tVerbose_Library_Version.\n\n\t* make.adb, lib-writ.adb, exp_attr.adb:\n\tClean up: replace Library_Version by Verbose_Library_Version.\n\n\t* 5lintman.adb: Removed.\n\n\t* Makefile.in:\n\tUpdate and simplify computation of LIBRARY_VERSION.\n\tFix computation of GSMATCH_VERSION.\n\t5lintman.adb is no longer used: replaced by 7sintman.adb.\n\n2003-12-03  Robert Dewar  <dewar@gnat.com>\n\n\t* exp_ch5.adb:\n\t(Possible_Bit_Aligned_Component): Maybe_Bit_Aligned_Large_Component new\n\tname. Modified to consider small non-bit-packed arrays as troublesome\n\tand in need of component-by-component assigment expansion.\n\n2003-12-03  Vincent Celier  <celier@gnat.com>\n\n\t* lang-specs.h: Process nostdlib as nostdinc\n\n\t* back_end.adb: Update Copyright notice\n\t(Scan_Compiler_Arguments): Process -nostdlib directly.\n\n2003-12-03  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* Makefile.in:\n\tWhen defining LIBGNAT_TARGET_PAIRS for bare board targets, remove the\n\tredundant inclusion of EXTRA_HIE_NONE_TARGET_PAIRS, which is always\n\tincluded in HIE_NONE_TARGET_PAIRS.\n\n2003-12-03  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_attr.adb:\n\t(Legal_Formal_Attribute): Attribute is legal in an inlined body, as it\n\tis legal in an instance, because legality is cheched in the template.\n\n\t* sem_prag.adb:\n\t(Analyze_Pragma, case Warnings): In an inlined body, the pragma may be\n\tappplied to an unchecked conversion of a formal parameter.\n\n\t* sem_warn.adb:\n\t(Output_Unreferenced_Messages): Suppress \"not read\" warnings on imported\n\tvariables.\n\n2003-12-03  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* tb-alvms.c (unwind_regular_code, unwind_kernel_handler): New\n\troutines. The second one is new functionality to deal with backtracing\n\tthrough signal handlers.\n\t(unwind): Split into the two separate subroutines above.\n\tUpdate the documentation, and deal properly with sizeof (REG) different\n\tfrom sizeof (void*).\n\nFrom-SVN: r74226", "tree": {"sha": "c45bb2d73cfb0458efcd0a938bc033454e67d4d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c45bb2d73cfb0458efcd0a938bc033454e67d4d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efdfd311d664c32c3a6108f920fc978bb95c5d8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdfd311d664c32c3a6108f920fc978bb95c5d8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efdfd311d664c32c3a6108f920fc978bb95c5d8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdfd311d664c32c3a6108f920fc978bb95c5d8d/comments", "author": null, "committer": null, "parents": [{"sha": "1fcc57f1958ac52239279de6d3a6b1979e32700b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fcc57f1958ac52239279de6d3a6b1979e32700b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fcc57f1958ac52239279de6d3a6b1979e32700b"}], "stats": {"total": 1032, "additions": 442, "deletions": 590}, "files": [{"sha": "56871f3d9ecc1c8ec7c24edcfce0cba2a796fe9b", "filename": "gcc/ada/5lintman.adb", "status": "removed", "additions": 0, "deletions": 401, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fcc57f1958ac52239279de6d3a6b1979e32700b/gcc%2Fada%2F5lintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fcc57f1958ac52239279de6d3a6b1979e32700b/gcc%2Fada%2F5lintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lintman.adb?ref=1fcc57f1958ac52239279de6d3a6b1979e32700b", "patch": "@@ -1,401 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the GNU/Linux version of this package\n-\n---  This file performs the system-dependent translation between machine\n---  exceptions and the Ada exceptions, if any, that should be raised when they\n---  occur. This version works for the x86 running linux.\n-\n---  This is a Sun OS (FSU THREADS) version of this package\n-\n---  PLEASE DO NOT add any dependences on other packages. ??? why not ???\n---  This package is designed to work with or without tasking support.\n-\n---  Make a careful study of all signals available under the OS, to see which\n---  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n---  the lookout for special signals that may be used by the thread library.\n-\n---  The definitions of \"reserved\" differ slightly between the ARM and POSIX.\n---  Here is the ARM definition of reserved interrupt:\n-\n---  The set of reserved interrupts is implementation defined. A reserved\n---  interrupt is either an interrupt for which user-defined handlers are not\n---  supported, or one which already has an attached handler by some other\n---  implementation-defined means. Program units can be connected to\n---  non-reserved interrupts.\n-\n---  POSIX.5b/.5c specifies further:\n-\n---  Signals which the application cannot accept, and for which the application\n---  cannot modify the signal action or masking, because the signals are\n---  reserved for use by the Ada language implementation. The reserved signals\n---  defined by this standard are Signal_Abort, Signal_Alarm,\n---  Signal_Floating_Point_Error, Signal_Illegal_Instruction,\n---  Signal_Segmentation_Violation, Signal_Bus_Error. If the implementation\n---  supports any signals besides those defined by this standard, the\n---  implementation may also reserve some of those.\n-\n---  The signals defined by POSIX.5b/.5c that are not specified as being\n---  reserved are SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM, SIGUSR1, SIGUSR2,\n---  SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGIO SIGURG, and all\n---  the real-time signals.\n-\n---  Beware of reserving signals that POSIX.5b/.5c require to be available for\n---  users. POSIX.5b/.5c say:\n-\n---  An implementation shall not impose restrictions on the ability of an\n---  application to send, accept, block, or ignore the signals defined by this\n---  standard, except as specified in this standard.\n-\n---  Here are some other relevant requirements from POSIX.5b/.5c:\n-\n---  For the environment task, the initial signal mask is that specified for\n---  the process...\n-\n---  It is anticipated that the paragraph above may be modified by a future\n---  revision of this standard, to require that the realtime signals always be\n---  initially masked for a process that is an Ada active partition.\n-\n---  For all other tasks, the initial signal mask shall include all the signals\n---  that are not reserved signals and are not bound to entries of the task.\n-\n-with Interfaces.C;\n---  used for int and other types\n-\n-with System.Error_Reporting;\n---  used for Shutdown\n-\n-with System.OS_Interface;\n---  used for various Constants, Signal and types\n-\n-with Ada.Exceptions;\n---  used for Exception_Id\n---           Raise_From_Signal_Handler\n-\n-with System.Soft_Links;\n---  used for Get_Machine_State_Addr\n-\n-with Unchecked_Conversion;\n-\n-package body System.Interrupt_Management is\n-\n-   use Interfaces.C;\n-   use System.Error_Reporting;\n-   use System.OS_Interface;\n-\n-   package TSL renames System.Soft_Links;\n-\n-   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n-   Exception_Interrupts : constant Interrupt_List :=\n-     (SIGFPE, SIGILL, SIGSEGV);\n-\n-   Unreserve_All_Interrupts : Interfaces.C.int;\n-   pragma Import\n-     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n-\n-   subtype int is Interfaces.C.int;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long is Interfaces.C.unsigned_long;\n-\n-   ----------------------\n-   -- Notify_Exception --\n-   ----------------------\n-\n-   pragma Warnings (Off);\n-   --  Because many unaccessed arguments\n-\n-   Signal_Mask : aliased sigset_t;\n-   --  The set of signals handled by Notify_Exception\n-\n-   --  This function identifies the Ada exception to be raised using\n-   --  the information when the system received a synchronous signal.\n-   --  Since this function is machine and OS dependent, different code\n-   --  has to be provided for different target.\n-\n-   procedure Notify_Exception\n-     (signo         : Signal;\n-      gs            : unsigned_short;\n-      fs            : unsigned_short;\n-      es            : unsigned_short;\n-      ds            : unsigned_short;\n-      edi           : unsigned_long;\n-      esi           : unsigned_long;\n-      ebp           : unsigned_long;\n-      esp           : unsigned_long;\n-      ebx           : unsigned_long;\n-      edx           : unsigned_long;\n-      ecx           : unsigned_long;\n-      eax           : unsigned_long;\n-      trapno        : unsigned_long;\n-      err           : unsigned_long;\n-      eip           : unsigned_long;\n-      cs            : unsigned_short;\n-      eflags        : unsigned_long;\n-      esp_at_signal : unsigned_long;\n-      ss            : unsigned_short;\n-      fpstate       : System.Address;\n-      oldmask       : unsigned_long;\n-      cr2           : unsigned_long);\n-\n-   procedure Notify_Exception\n-     (signo         : Signal;\n-      gs            : unsigned_short;\n-      fs            : unsigned_short;\n-      es            : unsigned_short;\n-      ds            : unsigned_short;\n-      edi           : unsigned_long;\n-      esi           : unsigned_long;\n-      ebp           : unsigned_long;\n-      esp           : unsigned_long;\n-      ebx           : unsigned_long;\n-      edx           : unsigned_long;\n-      ecx           : unsigned_long;\n-      eax           : unsigned_long;\n-      trapno        : unsigned_long;\n-      err           : unsigned_long;\n-      eip           : unsigned_long;\n-      cs            : unsigned_short;\n-      eflags        : unsigned_long;\n-      esp_at_signal : unsigned_long;\n-      ss            : unsigned_short;\n-      fpstate       : System.Address;\n-      oldmask       : unsigned_long;\n-      cr2           : unsigned_long)\n-   is\n-      pragma Warnings (On);\n-\n-      function To_Machine_State_Ptr is new\n-        Unchecked_Conversion (Address, Machine_State_Ptr);\n-\n-      --  These are not directly visible\n-\n-      procedure Raise_From_Signal_Handler\n-        (E : Ada.Exceptions.Exception_Id;\n-         M : System.Address);\n-      pragma Import\n-        (Ada, Raise_From_Signal_Handler,\n-         \"ada__exceptions__raise_from_signal_handler\");\n-      pragma No_Return (Raise_From_Signal_Handler);\n-\n-      mstate  : Machine_State_Ptr;\n-      message : aliased constant String := \"\" & ASCII.Nul;\n-      --  A null terminated String.\n-\n-      Result  : int;\n-\n-   begin\n-\n-      --  Raise_From_Signal_Handler makes sure that the exception is raised\n-      --  safely from this signal handler.\n-\n-      --  ??? The original signal mask (the one we had before coming into this\n-      --  signal catching function) should be restored by\n-      --  Raise_From_Signal_Handler. For now, restore it explicitely\n-\n-      Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n-      pragma Assert (Result = 0);\n-\n-      --  Check that treatment of exception propagation here\n-      --  is consistent with treatment of the abort signal in\n-      --  System.Task_Primitives.Operations.\n-\n-      mstate := To_Machine_State_Ptr (TSL.Get_Machine_State_Addr.all);\n-      mstate.eip := eip;\n-      mstate.ebx := ebx;\n-      mstate.esp := esp_at_signal;\n-      mstate.ebp := ebp;\n-      mstate.esi := esi;\n-      mstate.edi := edi;\n-\n-      case signo is\n-         when SIGFPE =>\n-            Raise_From_Signal_Handler\n-              (Constraint_Error'Identity, message'Address);\n-         when SIGILL =>\n-            Raise_From_Signal_Handler\n-              (Constraint_Error'Identity, message'Address);\n-         when SIGSEGV =>\n-            Raise_From_Signal_Handler\n-              (Storage_Error'Identity, message'Address);\n-         when others =>\n-            if Shutdown (\"Unexpected signal\") then\n-               null;\n-            end if;\n-      end case;\n-   end Notify_Exception;\n-\n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Nothing needs to be done on this platform.\n-\n-   procedure Initialize_Interrupts is\n-   begin\n-      null;\n-   end Initialize_Interrupts;\n-\n-begin\n-   declare\n-      act     : aliased struct_sigaction;\n-      old_act : aliased struct_sigaction;\n-      Result  : int;\n-\n-      function State (Int : Interrupt_ID) return Character;\n-      pragma Import (C, State, \"__gnat_get_interrupt_state\");\n-      --  Get interrupt state.  Defined in a-init.c\n-      --  The input argument is the interrupt number,\n-      --  and the result is one of the following:\n-\n-      User    : constant Character := 'u';\n-      Runtime : constant Character := 'r';\n-      Default : constant Character := 's';\n-      --    'n'   this interrupt not set by any Interrupt_State pragma\n-      --    'u'   Interrupt_State pragma set state to User\n-      --    'r'   Interrupt_State pragma set state to Runtime\n-      --    's'   Interrupt_State pragma set state to System (use \"default\"\n-      --           system handler)\n-\n-   begin\n-      --  Need to call pthread_init very early because it is doing signal\n-      --  initializations.\n-\n-      pthread_init;\n-\n-      Abort_Task_Interrupt := SIGADAABORT;\n-\n-      act.sa_handler := Notify_Exception'Address;\n-\n-      act.sa_flags := 0;\n-\n-      --  On some targets, we set sa_flags to SA_NODEFER so that during the\n-      --  handler execution we do not change the Signal_Mask to be masked for\n-      --  the Signal.\n-\n-      --  This is a temporary fix to the problem that the Signal_Mask is\n-      --  not restored after the exception (longjmp) from the handler.\n-      --  The right fix should be made in sigsetjmp so that we save\n-      --  the Signal_Set and restore it after a longjmp.\n-\n-      --  Since SA_NODEFER is obsolete, instead we reset explicitely\n-      --  the mask in the exception handler.\n-\n-      Result := sigemptyset (Signal_Mask'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Add signals that map to Ada exceptions to the mask.\n-\n-      for J in Exception_Interrupts'Range loop\n-         if State (Exception_Interrupts (J)) /= Default  then\n-            Result :=\n-            sigaddset (Signal_Mask'Access, Signal (Exception_Interrupts (J)));\n-            pragma Assert (Result = 0);\n-         end if;\n-      end loop;\n-\n-      act.sa_mask := Signal_Mask;\n-\n-      pragma Assert (Keep_Unmasked = (Interrupt_ID'Range => False));\n-      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n-\n-      --  Process state of exception signals\n-\n-      for J in Exception_Interrupts'Range loop\n-         if State (Exception_Interrupts (J)) /= User then\n-            Keep_Unmasked (Exception_Interrupts (J)) := True;\n-            Reserve (Exception_Interrupts (J)) := True;\n-\n-            if State (Exception_Interrupts (J)) /= Default then\n-               Result :=\n-                 sigaction\n-                 (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n-                  old_act'Unchecked_Access);\n-               pragma Assert (Result = 0);\n-            end if;\n-         end if;\n-      end loop;\n-\n-      if State (Abort_Task_Interrupt) /= User then\n-         Keep_Unmasked (Abort_Task_Interrupt) := True;\n-         Reserve (Abort_Task_Interrupt) := True;\n-      end if;\n-\n-      --  Set SIGINT to unmasked state as long as it's\n-      --  not in \"User\" state.  Check for Unreserve_All_Interrupts last\n-\n-      if State (SIGINT) /= User then\n-         Keep_Unmasked (SIGINT) := True;\n-         Reserve (SIGINT) := True;\n-      end if;\n-\n-      --  Check all signals for state that requires keeping them\n-      --  unmasked and reserved\n-\n-      for J in Interrupt_ID'Range loop\n-         if State (J) = Default or else State (J) = Runtime then\n-            Keep_Unmasked (J) := True;\n-            Reserve (J) := True;\n-         end if;\n-      end loop;\n-\n-      --  Add the set of signals that must always be unmasked for this target\n-\n-      for J in Unmasked'Range loop\n-         Keep_Unmasked (Interrupt_ID (Unmasked (J))) := True;\n-         Reserve (Interrupt_ID (Unmasked (J))) := True;\n-      end loop;\n-\n-      --  Add target-specific reserved signals\n-\n-      for J in Reserved'Range loop\n-         Reserve (Interrupt_ID (Reserved (J))) := True;\n-      end loop;\n-\n-      --  Process pragma Unreserve_All_Interrupts. This overrides any\n-      --  settings due to pragma Interrupt_State:\n-\n-      if Unreserve_All_Interrupts /= 0 then\n-         Keep_Unmasked (SIGINT) := False;\n-         Reserve (SIGINT) := False;\n-      end if;\n-\n-      --  We do not have Signal 0 in reality. We just use this value\n-      --  to identify non-existent signals (see s-intnam.ads). Therefore,\n-      --  Signal 0 should not be used in all signal related operations hence\n-      --  mark it as reserved.\n-\n-      Reserve (0) := True;\n-   end;\n-end System.Interrupt_Management;"}, {"sha": "e0c88573e637c654e56013a9d5a9eae4496bba81", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -1,3 +1,79 @@\n+2003-12-03  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\tPR ada/11724\n+\n+\t* adaint.h, adaint.c, g-os_lib.ads: \n+\tDo not assume that the offset argument to lseek(2) is a 32 bit integer,\n+\ton some platforms (including FreeBSD), it is a 64 bit value.\n+\tIntroduce a __gnat_lseek wrapper in adaint.c to allow for portability.\n+\n+2003-12-03  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* gnatvsn.ads (Library_Version): Now contain only the relevant\n+\tversion info.\n+\t(Verbose_Library_Version): New constant.\n+\n+\t* g-spipat.adb, g-awk.adb, g-debpoo.adb,\n+\tg-memdum.adb, g-thread.adb, s-geveop.adb, s-interr.adb,\n+\ts-taskin.adb, s-tassta.adb: Make code compile with -gnatwa.\n+\n+\t* gnatlbr.adb: Clean up: replace Library_Version by\n+\tVerbose_Library_Version.\n+\n+\t* make.adb, lib-writ.adb, exp_attr.adb: \n+\tClean up: replace Library_Version by Verbose_Library_Version.\n+\n+\t* 5lintman.adb: Removed.\n+\n+\t* Makefile.in: \n+\tUpdate and simplify computation of LIBRARY_VERSION.\n+\tFix computation of GSMATCH_VERSION.\n+\t5lintman.adb is no longer used: replaced by 7sintman.adb.\n+\n+2003-12-03  Robert Dewar  <dewar@gnat.com>\n+\n+\t* exp_ch5.adb: \n+\t(Possible_Bit_Aligned_Component): Maybe_Bit_Aligned_Large_Component new\n+\tname. Modified to consider small non-bit-packed arrays as troublesome\n+\tand in need of component-by-component assigment expansion.\n+\n+2003-12-03  Vincent Celier  <celier@gnat.com>\n+\n+\t* lang-specs.h: Process nostdlib as nostdinc\n+\n+\t* back_end.adb: Update Copyright notice\n+\t(Scan_Compiler_Arguments): Process -nostdlib directly.\n+\n+2003-12-03  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* Makefile.in: \n+\tWhen defining LIBGNAT_TARGET_PAIRS for bare board targets, remove the\n+\tredundant inclusion of EXTRA_HIE_NONE_TARGET_PAIRS, which is always\n+\tincluded in HIE_NONE_TARGET_PAIRS.\n+\n+2003-12-03  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_attr.adb: \n+\t(Legal_Formal_Attribute): Attribute is legal in an inlined body, as it\n+\tis legal in an instance, because legality is cheched in the template.\n+\n+\t* sem_prag.adb: \n+\t(Analyze_Pragma, case Warnings): In an inlined body, the pragma may be\n+\tappplied to an unchecked conversion of a formal parameter.\n+\n+\t* sem_warn.adb: \n+\t(Output_Unreferenced_Messages): Suppress \"not read\" warnings on imported\n+\tvariables.\n+\n+2003-12-03  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* tb-alvms.c (unwind_regular_code, unwind_kernel_handler): New\n+\troutines. The second one is new functionality to deal with backtracing\n+\tthrough signal handlers.\n+\t(unwind): Split into the two separate subroutines above.\n+\tUpdate the documentation, and deal properly with sizeof (REG) different\n+\tfrom sizeof (void*).\n+\n 2003-12-01  Nicolas Setton  <setton@act-europe.fr>\n \n \t* a-except.adb (Raise_Current_Excep): Add a pragma Inspection_Point,"}, {"sha": "4b7148b2947fec33d5ed840f59852d3d0e173d2d", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -375,6 +375,8 @@ PREFIX_REAL_OBJS = ../prefix.o \\\n   ../../libiberty/xstrdup.o    \\\n   ../../libiberty/xexit.o\n \n+LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n+\n # $(filter-out PATTERN...,TEXT) removes all PATTERN words from TEXT.\n # $(strip STRING) removes leading and trailing spaces from STRING.\n # If what's left is null then it's a match.\n@@ -450,7 +452,7 @@ ifeq ($(strip $(filter-out %86 sysv5uw%,$(arch) $(osys))),)\n   PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n   SO_OPTS = -Wl,-h,\n   GNATLIB_SHARED = gnatlib-shared-dual\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out alpha% dec vx%,$(targ))),)\n@@ -692,17 +694,15 @@ ifeq ($(strip $(filter-out powerpc% unknown elf,$(targ))),)\n   system.ads<59system.ads\n \n   LIBGNAT_TARGET_PAIRS = \\\n-  $(HIE_NONE_TARGET_PAIRS) \\\n-  $(EXTRA_HIE_NONE_TARGET_PAIRS)\n+  $(HIE_NONE_TARGET_PAIRS)\n endif\n \n ifeq ($(strip $(filter-out sparc% unknown elf,$(targ))),)\n   EXTRA_HIE_NONE_TARGET_PAIRS= \\\n   system.ads<5rsystem.ads\n \n   LIBGNAT_TARGET_PAIRS = \\\n-  $(HIE_NONE_TARGET_PAIRS) \\\n-  $(EXTRA_HIE_NONE_TARGET_PAIRS)\n+  $(HIE_NONE_TARGET_PAIRS)\n endif\n \n ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n@@ -819,7 +819,7 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n \n   ifeq ($(strip $(filter-out fsu FSU,$(THREAD_KIND))),)\n     LIBGNAT_TARGET_PAIRS = \\\n@@ -903,7 +903,7 @@ ifeq ($(strip $(filter-out %86 solaris2%,$(arch) $(osys))),)\n   SO_OPTS = -Wl,-h,\n   GNATLIB_SHARED = gnatlib-shared-dual\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n@@ -912,7 +912,7 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   a-numaux.adb<86numaux.adb \\\n   a-numaux.ads<86numaux.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n-  s-intman.adb<5lintman.adb \\\n+  s-intman.adb<7sintman.adb \\\n   s-mastop.adb<5omastop.adb \\\n   s-osinte.adb<5iosinte.adb \\\n   s-osinte.ads<5iosinte.ads \\\n@@ -929,15 +929,15 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n \n   ifeq ($(strip $(filter-out fsu FSU,$(THREAD_KIND))),)\n     LIBGNAT_TARGET_PAIRS = \\\n     a-intnam.ads<4lintnam.ads \\\n     a-numaux.adb<86numaux.adb \\\n     a-numaux.ads<86numaux.ads \\\n     s-inmaop.adb<7sinmaop.adb \\\n-    s-intman.adb<5lintman.adb \\\n+    s-intman.adb<7sintman.adb \\\n     s-mastop.adb<5omastop.adb \\\n     s-osinte.adb<7sosinte.adb \\\n     s-osinte.ads<5losinte.ads \\\n@@ -967,7 +967,7 @@ ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n   system.ads<56system.ads\n \n   THREADSLIB=\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out mips sgi irix%,$(targ))),)\n@@ -1021,7 +1021,7 @@ ifeq ($(strip $(filter-out mips sgi irix%,$(targ))),)\n   MISCLIB = -lexc\n   SO_OPTS = -Wl,-all,-set_version,sgi1.0,-update_registry,../so_locations,-soname,\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out hppa% hp hpux10%,$(targ))),)\n@@ -1069,7 +1069,7 @@ ifeq ($(strip $(filter-out hppa% hp hpux11%,$(targ))),)\n   SO_OPTS = -Wl,+h,\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   GNATLIB_SHARED = gnatlib-shared-dual\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n \n   ifeq ($(strip $(filter-out dce DCE,$(THREAD_KIND))),)\n     LIBGNAT_TARGET_PAIRS = \\\n@@ -1220,7 +1220,7 @@ ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n   THREADSLIB = -lpthread -lmach -lexc -lrt\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   GNATLIB_SHARED = gnatlib-shared-default\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out alpha% dec vms% openvms% alphavms%,$(host))),)\n@@ -1290,8 +1290,7 @@ endif\n      ../../gnatlbr$(exeext) \\\n      ,,/../gnatsym$(exeext)\n   # This command transforms (YYYYMMDD) into YY,MMDD\n-  GSMATCH_VERSION := $(shell grep \"^ *Gnat_Version_String\" $(fsrcpfx)gnatvsn.ads | sed -e 's/.*(\\(.*\\)).*/\\1/' -e 's/\\(..\\)\\(..\\)\\(....\\)/\\2,\\3/')\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/' -e 's/\\./_/g'))\n+  GSMATCH_VERSION := $(shell grep \"^ *Gnat_Static_Version_String\" $(fsrcpfx)gnatvsn.ads | sed -e 's/.*(\\(.*\\)).*/\\1/' -e 's/\\(..\\)\\(..\\)\\(....\\)/\\2,\\3/')\n   TOOLS_LIBS_LO := --for-linker=sys\\\\$$\\$$library:trace.exe\n endif\n \n@@ -1328,14 +1327,14 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   EXTRA_GNATRTL_NONTASKING_OBJS = g-regist.o\n   soext = .dll\n   GNATLIB_SHARED = gnatlib-shared-win32\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<4lintnam.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n-  s-intman.adb<5lintman.adb \\\n+  s-intman.adb<7sintman.adb \\\n   s-osinte.ads<5iosinte.ads \\\n   s-osinte.adb<5iosinte.adb \\\n   s-osprim.adb<7sosprim.adb \\\n@@ -1349,14 +1348,14 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n   PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<4lintnam.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n-  s-intman.adb<5lintman.adb \\\n+  s-intman.adb<7sintman.adb \\\n   s-osinte.ads<5iosinte.ads \\\n   s-osinte.adb<5iosinte.adb \\\n   s-osprim.adb<7sosprim.adb \\\n@@ -1370,7 +1369,7 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n   PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(strip $(shell grep Library_Version $(fsrcpfx)gnatvsn.ads | sed -e 's/.*GNAT Lib v\\(.*\\)[ \"].*/\\1/'))\n+  LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n # The runtime library for gnat comprises two directories.  One contains the"}, {"sha": "b7130d8fbb12a57fa81c2b011466d03d71f47939", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -2481,3 +2481,9 @@ __gnatlib_install_locks (void (*lock) (void) ATTRIBUTE_UNUSED,\n      a no-op in this case. */\n #endif\n }\n+\n+int\n+__gnat_lseek (int fd, long offset, int whence)\n+{\n+  return (int) lseek (fd, offset, whence);\n+}"}, {"sha": "33c2bdcba959ff4ad0efc8e9c63ffe29b9c569aa", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -140,6 +140,7 @@ extern int    __gnat_expect_poll\t\t   (int *, int, int, int *);\n extern void   __gnat_set_binary_mode\t\t   (int);\n extern void   __gnat_set_text_mode\t\t   (int);\n extern char  *__gnat_ttyname\t\t\t   (int);\n+extern int    __gnat_lseek\t\t\t   (int, long, int);\n \n #ifdef __MINGW32__\n extern void   __gnat_plist_init                    (void);"}, {"sha": "ede3f8b2097bc1f9639e708f7b1b0339ee1f93e6", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -270,6 +270,12 @@ package body Back_End is\n                Opt.No_Stdinc := True;\n                Scan_Back_End_Switches (Argv);\n \n+            --  We must recognize -nostdlib to suppress visibility on the\n+            --  standard GNAT RTL objects.\n+\n+            elsif Argv (Argv'First + 1 .. Argv'Last) = \"nostdlib\" then\n+               Opt.No_Stdlib := True;\n+\n             elsif Is_Front_End_Switch (Argv) then\n                Scan_Front_End_Switches (Argv);\n "}, {"sha": "f296a6f60cfb76692e053cc98298f5a98ae205e8", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -907,8 +907,9 @@ package body Exp_Attr is\n          if Pent = Standard_Standard\n            or else Pent = Standard_ASCII\n          then\n-            Name_Buffer (1 .. Library_Version'Length) := Library_Version;\n-            Name_Len := Library_Version'Length;\n+            Name_Buffer (1 .. Verbose_Library_Version'Length) :=\n+              Verbose_Library_Version;\n+            Name_Len := Verbose_Library_Version'Length;\n             Rewrite (N,\n               Make_String_Literal (Loc,\n                 Strval => String_From_Name_Buffer));"}, {"sha": "a257b274ce058e03fe189aa2bcdda9baace186b0", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -95,38 +95,48 @@ package body Exp_Ch5 is\n    --  either because the target is not byte aligned, or there is a change\n    --  of representation.\n \n-   function Maybe_Bit_Aligned_Large_Component (N : Node_Id) return Boolean;\n-   --  This function is used in processing the assignment of a record or\n-   --  indexed component. The back end can handle such assignments fine\n-   --  if the objects involved are small (64-bits) or are both aligned on\n-   --  a byte boundary (starts on a byte, and ends on a byte). However,\n-   --  problems arise for large components that are not byte aligned,\n-   --  since the assignment may clobber other components that share bit\n-   --  positions in the starting or ending bytes, and in the case of\n-   --  components not starting on a byte boundary, the back end cannot\n-   --  even manage to extract the value. This function is used to detect\n-   --  such situations, so that the assignment can be handled component-wise.\n-   --  A value of False means that either the object is known to be greater\n-   --  than 64 bits, or that it is known to be byte aligned (and occupy an\n-   --  integral number of bytes. True is returned if the object is known to\n-   --  be greater than 64 bits, and is known to be unaligned. As implied\n-   --  by the name, the result is conservative, in that if the compiler\n-   --  cannot determine these conditions at compile time, True is returned.\n-\n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and Tagged assignment,\n    --  that is to say, finalization of the target before, adjustement of\n    --  the target after and save and restore of the tag and finalization\n    --  pointers which are not 'part of the value' and must not be changed\n    --  upon assignment. N is the original Assignment node.\n \n+   function Possible_Bit_Aligned_Component (N : Node_Id) return Boolean;\n+   --  This function is used in processing the assignment of a record or\n+   --  indexed component. The back end can handle such assignments fine\n+   --  if the objects involved are small (64-bits or less) records or\n+   --  scalar items (including bit-packed arrays represented with modular\n+   --  types) or are both aligned on a byte boundary (starting on a byte\n+   --  boundary, and occupying an integral number of bytes).\n+   --\n+   --  However, problems arise for records larger than 64 bits, or for\n+   --  arrays (other than bit-packed arrays represented with a modular\n+   --  type) if the component starts on a non-byte boundary, or does\n+   --  not occupy an integral number of bytes (i.e. there are some bits\n+   --  possibly shared with fields at the start or beginning of the\n+   --  component). The back end cannot handle loading and storing such\n+   --  components in a single operation.\n+   --\n+   --  This function is used to detect the troublesome situation. it is\n+   --  conservative in the sense that it produces True unless it knows\n+   --  for sure that the component is safe (as outlined in the first\n+   --  paragraph above). The code generation for record and array\n+   --  assignment checks for trouble using this function, and if so\n+   --  the assignment is generated component-wise, which the back end\n+   --  is required to handle correctly.\n+   --\n+   --  Note that in GNAT 3, the back end will reject such components\n+   --  anyway, so the hard work in checking for this case is wasted\n+   --  in GNAT 3, but it's harmless, so it is easier to do it in\n+   --  all cases, rather than conditionalize it in GNAT 5 or beyond.\n+\n    ------------------------------\n    -- Change_Of_Representation --\n    ------------------------------\n \n    function Change_Of_Representation (N : Node_Id) return Boolean is\n       Rhs : constant Node_Id := Expression (N);\n-\n    begin\n       return\n         Nkind (Rhs) = N_Type_Conversion\n@@ -372,9 +382,9 @@ package body Exp_Ch5 is\n \n       --  We require a loop if the left side is possibly bit unaligned\n \n-      elsif Maybe_Bit_Aligned_Large_Component (Lhs)\n+      elsif Possible_Bit_Aligned_Component (Lhs)\n               or else\n-            Maybe_Bit_Aligned_Large_Component (Rhs)\n+            Possible_Bit_Aligned_Component (Rhs)\n       then\n          Loop_Required := True;\n \n@@ -1026,9 +1036,9 @@ package body Exp_Ch5 is\n       --  clobbering of other components sharing bits in the first or\n       --  last byte of the component to be assigned.\n \n-      elsif Maybe_Bit_Aligned_Large_Component (Lhs)\n+      elsif Possible_Bit_Aligned_Component (Lhs)\n               or\n-            Maybe_Bit_Aligned_Large_Component (Rhs)\n+            Possible_Bit_Aligned_Component (Rhs)\n       then\n          null;\n \n@@ -3221,11 +3231,11 @@ package body Exp_Ch5 is\n          return Empty_List;\n    end Make_Tag_Ctrl_Assignment;\n \n-   ---------------------------------------\n-   -- Maybe_Bit_Aligned_Large_Component --\n-   ---------------------------------------\n+   ------------------------------------\n+   -- Possible_Bit_Aligned_Component --\n+   ------------------------------------\n \n-   function Maybe_Bit_Aligned_Large_Component (N : Node_Id) return Boolean is\n+   function Possible_Bit_Aligned_Component (N : Node_Id) return Boolean is\n    begin\n       case Nkind (N) is\n \n@@ -3250,7 +3260,7 @@ package body Exp_Ch5 is\n                --  indexing from a possibly unaligned component.\n \n                else\n-                  return Maybe_Bit_Aligned_Large_Component (P);\n+                  return Possible_Bit_Aligned_Component (P);\n                end if;\n             end;\n \n@@ -3268,17 +3278,22 @@ package body Exp_Ch5 is\n                --  only the recursive test on the prefix.\n \n                if No (Component_Clause (Comp)) then\n-                  return Maybe_Bit_Aligned_Large_Component (P);\n+                  return Possible_Bit_Aligned_Component (P);\n \n                --  Otherwise we have a component clause, which means that\n                --  the Esize and Normalized_First_Bit fields are set and\n                --  contain static values known at compile time.\n \n                else\n-                  --  If we know the size is 64 bits or less we are fine\n-                  --  since the back end always handles small fields right.\n-\n-                  if Esize (Comp) <= 64 then\n+                  --  If we know that we have a small (64 bits or less) record\n+                  --  or bit-packed array, then everything is fine, since the\n+                  --  back end can handle these cases correctly.\n+\n+                  if Esize (Comp) <= 64\n+                    and then (Is_Record_Type (Etype (Comp))\n+                               or else\n+                              Is_Bit_Packed_Array (Etype (Comp)))\n+                  then\n                      return False;\n \n                   --  Otherwise if the component is not byte aligned, we\n@@ -3293,7 +3308,7 @@ package body Exp_Ch5 is\n                   --  but we still need to test our prefix recursively.\n \n                   else\n-                     return Maybe_Bit_Aligned_Large_Component (P);\n+                     return Possible_Bit_Aligned_Component (P);\n                   end if;\n                end if;\n             end;\n@@ -3306,6 +3321,6 @@ package body Exp_Ch5 is\n             return False;\n \n       end case;\n-   end Maybe_Bit_Aligned_Large_Component;\n+   end Possible_Bit_Aligned_Component;\n \n end Exp_Ch5;"}, {"sha": "cece7e6de480bd2eecfd7dc945078360df415c54", "filename": "gcc/ada/g-awk.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-awk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-awk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -873,8 +873,7 @@ package body GNAT.AWK is\n       Callbacks  : Callback_Mode := None;\n       Session    : Session_Type  := Current_Session)\n    is\n-      Filter_Active : Boolean;\n-      Quit          : Boolean;\n+      Quit : Boolean;\n \n    begin\n       Open (Separators, Filename, Session);\n@@ -884,7 +883,12 @@ package body GNAT.AWK is\n          Split_Line (Session);\n \n          if Callbacks in Only .. Pass_Through then\n-            Filter_Active := Apply_Filters (Session);\n+            declare\n+               Discard : Boolean;\n+               pragma Unreferenced (Discard);\n+            begin\n+               Discard := Apply_Filters (Session);\n+            end;\n          end if;\n \n          if Callbacks /= Only then"}, {"sha": "4eeae1af222e7518281f76b1537d243afccadb93", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -116,7 +116,7 @@ package body GNAT.Debug_Pools is\n       return Tracebacks_Array_Access;\n    function Hash (T : Tracebacks_Array_Access) return Header;\n    function Equal (K1, K2 : Tracebacks_Array_Access) return Boolean;\n-   pragma Inline (Set_Next, Next, Get_Key, Equal, Hash);\n+   pragma Inline (Set_Next, Next, Get_Key, Hash);\n    --  Subprograms required for instantiation of the htable. See GNAT.HTable.\n \n    package Backtrace_Htable is new GNAT.HTable.Static_HTable\n@@ -374,7 +374,6 @@ package body GNAT.Debug_Pools is\n \n    function Equal (K1, K2 : Tracebacks_Array_Access) return Boolean is\n       use Ada.Exceptions.Traceback;\n-\n    begin\n       return K1.all = K2.all;\n    end Equal;"}, {"sha": "92f08392e47a299e0e019e11dad38d7d501e81c4", "filename": "gcc/ada/g-memdum.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-memdum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-memdum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-memdum.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -66,7 +66,7 @@ package body GNAT.Memory_Dump is\n \n       Line_Buf : String (1 .. Line_Len);\n \n-      Hex : array (0 .. 15) of Character := \"0123456789ABCDEF\";\n+      Hex : constant array (0 .. 15) of Character := \"0123456789ABCDEF\";\n \n       type Char_Ptr is access all Character;\n "}, {"sha": "63ed32fc6562c4ed737aeb4d94d89ce15630df28", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -359,7 +359,7 @@ pragma Elaborate_Body (OS_Lib);\n      (FD     : File_Descriptor;\n       offset : Long_Integer;\n       origin : Integer);\n-   pragma Import (C, Lseek, \"lseek\");\n+   pragma Import (C, Lseek, \"__gnat_lseek\");\n    --  Sets the current file pointer to the indicated offset value,\n    --  relative to the current position (origin = SEEK_CUR), end of\n    --  file (origin = SEEK_END), or start of file (origin = SEEK_SET)."}, {"sha": "2f499b8d3eccf1a46e1f7df8a581fd0bae347577", "filename": "gcc/ada/g-spipat.adb", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1998-2002, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 1998-2003, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -343,30 +343,28 @@ package body GNAT.Spitbol.Patterns is\n    --  structure (i.e. it is a pattern that is guaranteed to match at least\n    --  one character on success, and not to make any entries on the stack.\n \n-   OK_For_Simple_Arbno :\n-     array (Pattern_Code) of Boolean := (\n-       PC_Any_CS     |\n-       PC_Any_CH     |\n-       PC_Any_VF     |\n-       PC_Any_VP     |\n-       PC_Char       |\n-       PC_Len_Nat    |\n-       PC_NotAny_CS  |\n-       PC_NotAny_CH  |\n-       PC_NotAny_VF  |\n-       PC_NotAny_VP  |\n-       PC_Span_CS    |\n-       PC_Span_CH    |\n-       PC_Span_VF    |\n-       PC_Span_VP    |\n-       PC_String     |\n-       PC_String_2   |\n-       PC_String_3   |\n-       PC_String_4   |\n-       PC_String_5   |\n-       PC_String_6   => True,\n-\n-       others => False);\n+   OK_For_Simple_Arbno : constant array (Pattern_Code) of Boolean :=\n+     (PC_Any_CS    |\n+      PC_Any_CH    |\n+      PC_Any_VF    |\n+      PC_Any_VP    |\n+      PC_Char      |\n+      PC_Len_Nat   |\n+      PC_NotAny_CS |\n+      PC_NotAny_CH |\n+      PC_NotAny_VF |\n+      PC_NotAny_VP |\n+      PC_Span_CS   |\n+      PC_Span_CH   |\n+      PC_Span_VF   |\n+      PC_Span_VP   |\n+      PC_String    |\n+      PC_String_2  |\n+      PC_String_3  |\n+      PC_String_4  |\n+      PC_String_5  |\n+      PC_String_6   => True,\n+      others        => False);\n \n    -------------------------------\n    -- The Pattern History Stack --"}, {"sha": "1d71f379ed448a680ebafc01d584f82cf0d142b6", "filename": "gcc/ada/g-thread.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-thread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fg-thread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-thread.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -81,8 +81,7 @@ package body GNAT.Threads is\n      (Code : Address;\n       Parm : Void_Ptr;\n       Size : Natural;\n-      Prio : Integer)\n-      return System.Address\n+      Prio : Integer) return System.Address\n    is\n       TP : Tptr;\n \n@@ -108,7 +107,6 @@ package body GNAT.Threads is\n \n    procedure Unregister_Thread is\n       Self_Id : constant Tasking.Task_ID := Task_Primitives.Operations.Self;\n-\n    begin\n       Self_Id.Common.State := Tasking.Terminated;\n       Destroy_TSD (Self_Id.Common.Compiler_Data);\n@@ -150,7 +148,6 @@ package body GNAT.Threads is\n \n    procedure Destroy_Thread (Id : Address) is\n       Tid : constant Task_Id := To_Id (Id);\n-\n    begin\n       Abort_Task (Tid);\n    end Destroy_Thread;\n@@ -161,9 +158,7 @@ package body GNAT.Threads is\n \n    procedure Get_Thread (Id : Address; Thread : Address) is\n       use System.OS_Interface;\n-\n-      Thr : Thread_Id_Ptr := To_Thread (Thread);\n-\n+      Thr : constant Thread_Id_Ptr := To_Thread (Thread);\n    begin\n       Thr.all := Task_Primitives.Operations.Get_Thread_Id (To_Id (Id));\n    end Get_Thread;\n@@ -173,8 +168,7 @@ package body GNAT.Threads is\n    ----------------\n \n    function To_Task_Id\n-     (Id   : System.Address)\n-      return Ada.Task_Identification.Task_Id\n+     (Id   : System.Address) return Ada.Task_Identification.Task_Id\n    is\n    begin\n       return To_Tid (Id);"}, {"sha": "917f06416da840d664b22a3cc916c38e15750feb", "filename": "gcc/ada/gnatlbr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fgnatlbr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fgnatlbr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlbr.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -254,7 +254,8 @@ begin\n                              & F_ADC_File (1 .. F_ADC_File_Len));\n \n                Make_Args (6) :=\n-                 new String'(\"LIBRARY_VERSION=\" & '\"' & Library_Version & '\"');\n+                 new String'(\"LIBRARY_VERSION=\" & '\"' &\n+                             Verbose_Library_Version & '\"');\n \n                Make_Args (7) :=\n                  new String'(\"-f\");"}, {"sha": "3b2c5e84285b7fe2f476f186c2c98e30d2dde1fd", "filename": "gcc/ada/gnatvsn.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fgnatvsn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fgnatvsn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatvsn.ads?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -71,14 +71,17 @@ package Gnatvsn is\n    --  value should never be decreased in the future, but it would be\n    --  OK to increase it if absolutely necessary.\n \n-   Library_Version : constant String := \"GNAT Lib v3.4\";\n+   Library_Version : constant String := \"3.4\";\n    --  Library version. This value must be updated whenever any change to the\n    --  compiler affects the library formats in such a way as to obsolete\n    --  previously compiled library modules.\n    --\n    --  Note: Makefile.in relies on the precise format of the library version\n    --  string in order to correctly construct the soname value.\n \n+   Verbose_Library_Version : constant String := \"GNAT Lib v\" & Library_Version;\n+   --  Version string stored in e.g. ALI files.\n+\n    ASIS_Version_Number : constant := 2;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees, and an ASIS application that is reading the"}, {"sha": "b68e78d098b6ded62fac471f118bc3d15d5965c8", "filename": "gcc/ada/lang-specs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-specs.h?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -35,6 +35,7 @@\n  %{!gnatc*:%{!gnatz*:%{!gnats*:%{!S:%{!c:\\\n     %eone of -c, -S, -gnatc, -gnatz, or -gnats is required for Ada}}}}}\\\n  gnat1 %{I*} %{k8:-gnatk8} %{w:-gnatws} %1 %{!Q:-quiet} %{nostdinc*}\\\n+    %{nostdlib*}\\\n     -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}}\\\n     %{g*} %{O*} %{W*} %{w} %{p} %{pg:-p} %{m*} %{a} %{f*} %{d*}\\\n     %{!S:%{o*:%w%*-gnatO}} \\"}, {"sha": "055f53a897b7b26ed2ab03e9dae1837d2d4cf3ba", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -729,7 +729,7 @@ package body Lib.Writ is\n \n       Write_Info_Initiate ('V');\n       Write_Info_Str (\" \"\"\");\n-      Write_Info_Str (Library_Version);\n+      Write_Info_Str (Verbose_Library_Version);\n       Write_Info_Char ('\"');\n \n       Write_Info_EOL;"}, {"sha": "b566c6b1c91363865bce908a032d547ea9287b32", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -1356,7 +1356,7 @@ package body Make is\n             return;\n \n          elsif ALIs.Table (ALI).Ver (1 .. ALIs.Table (ALI).Ver_Len) /=\n-                                                          Library_Version\n+                 Verbose_Library_Version\n          then\n             Verbose_Msg (Full_Lib_File, \"compiled with old GNAT version\");\n             ALI := No_ALI_Id;"}, {"sha": "1820bdf2a47221275b13ddfd840ca7ef81389486", "filename": "gcc/ada/s-geveop.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-geveop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-geveop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-geveop.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,7 +61,7 @@ package body System.Generic_Vector_Operations is\n       function VP is new Unchecked_Conversion (Address, Vector_Ptr);\n       function EP is new Unchecked_Conversion (Address, Element_Ptr);\n \n-      SA : Address := XA + ((Length + 0) / VU * VU\n+      SA : constant Address := XA + ((Length + 0) / VU * VU\n                            and (Boolean'Pos (Unaligned) - Address'(1)));\n       --  First address of argument X to start serial processing\n \n@@ -102,7 +102,7 @@ package body System.Generic_Vector_Operations is\n       function VP is new Unchecked_Conversion (Address, Vector_Ptr);\n       function EP is new Unchecked_Conversion (Address, Element_Ptr);\n \n-      SA : Address := XA + ((Length + 0) / VU * VU\n+      SA : constant Address := XA + ((Length + 0) / VU * VU\n                            and (Boolean'Pos (Unaligned) - Address'(1)));\n       --  First address of argument X to start serial processing\n "}, {"sha": "0145610dd12dcff2eb595cdba85681fae5e1c654", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -598,7 +598,7 @@ package body System.Interrupts is\n \n       Ptr := Registered_Handler_Head;\n \n-      while (Ptr /= null) loop\n+      while Ptr /= null loop\n          if Ptr.H = Fat.Handler_Addr then\n             return True;\n          end if;\n@@ -946,7 +946,7 @@ package body System.Interrupts is\n             Server_ID (Interrupt) := To_System (Access_Hold.all'Identity);\n          end if;\n \n-         if (New_Handler = null) then\n+         if New_Handler = null then\n             if Old_Handler /= null then\n                Unbind_Handler (Interrupt);\n             end if;"}, {"sha": "63d527d20aefbd61fe89d38069fa37f2ced7a590", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -122,7 +122,7 @@ package body System.Tasking is\n       All_Tasks_List := T;\n    end Initialize_ATCB;\n \n-   Main_Task_Image : String := \"main_task\";\n+   Main_Task_Image : constant String := \"main_task\";\n    --  Image of environment task.\n \n    Main_Priority : Integer;"}, {"sha": "14826330e7263cc637645b36105a60ecb03ab0bb", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -1089,7 +1089,8 @@ package body System.Tasking.Stages is\n         (Ada, Tailored_Exception_Information,\n          \"__gnat_tailored_exception_information\");\n \n-      Excep : Exception_Occurrence_Access := SSL.Get_Current_Excep.all;\n+      Excep : constant Exception_Occurrence_Access :=\n+                SSL.Get_Current_Excep.all;\n \n    begin\n       --  This procedure is called by the task outermost handler in"}, {"sha": "8629c4d735908b1c192a2790b2651db4c1c9d912", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -1364,7 +1364,8 @@ package body Sem_Attr is\n             Error_Attr (\"prefix of % attribute must be generic type\", N);\n \n          elsif Is_Generic_Actual_Type (Entity (P))\n-           or In_Instance\n+           or else In_Instance\n+           or else In_Inlined_Body\n          then\n             null;\n "}, {"sha": "c626a1bfbefe4bf4a470991fc25fc48438192a4d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -9631,6 +9631,12 @@ package body Sem_Prag is\n                   E_Id := Expression (Arg2);\n                   Analyze (E_Id);\n \n+                  if In_Instance_Body\n+                    and then Nkind (E_Id) = N_Unchecked_Type_Conversion\n+                  then\n+                     E_Id := Expression (E_Id);\n+                  end if;\n+\n                   if not Is_Entity_Name (E_Id) then\n                      Error_Pragma_Arg\n                        (\"second argument of pragma% must be entity name\","}, {"sha": "0d57ac00f6675c0c8d7f931a61b3ac0562b4c999", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -1440,14 +1440,16 @@ package body Sem_Warn is\n                when E_Variable =>\n \n                   --  Case of variable that is assigned but not read. We\n-                  --  suppress the message if the variable is volatile or\n-                  --  has an address clause.\n+                  --  suppress the message if the variable is volatile,\n+                  --  has an address clause, or is imported.\n \n                   if Referenced_As_LHS (E)\n                     and then No (Address_Clause (E))\n                     and then not Is_Volatile (E)\n                   then\n-                     if Warn_On_Modified_Unread then\n+                     if Warn_On_Modified_Unread\n+                       and then not Is_Imported (E)\n+                     then\n                         Error_Msg_N\n                           (\"variable & is assigned but never read?\", E);\n                      end if;"}, {"sha": "60effcc05047966a7da1fef40c75df00969443e1", "filename": "gcc/ada/tb-alvms.c", "status": "modified", "additions": 212, "deletions": 73, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Ftb-alvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdfd311d664c32c3a6108f920fc978bb95c5d8d/gcc%2Fada%2Ftb-alvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvms.c?ref=efdfd311d664c32c3a6108f920fc978bb95c5d8d", "patch": "@@ -40,33 +40,38 @@\n    document, sections of which we will refer to as ABI-<section_number>.  */\n \n #include <pdscdef.h>\n+#include <libicb.h>\n+#include <chfctxdef.h>\n+#include <chfdef.h>\n \n-/* We still use a number of macros similar to the ones for the generic\n-   __gnat_backtrace implementation.  */\n-#define SKIP_FRAME 1\n-#define PC_ADJUST -4\n-\n-#define STOP_FRAME (frame_state.saved_ra == RA_STOP)\n-\n-/* Mask for PDSC$V_BASE_FRAME in procedure descriptors, missing from the\n-   header file included above.  */\n+/* A couple of items missing from the header file included above.  */\n+extern void * SYS$GL_CALL_HANDL;\n #define PDSC$M_BASE_FRAME (1 << 10)\n \n-typedef unsigned long REG;\n+/* Registers are 64bit wide and addresses are 32bit wide on alpha-vms.  */\n+typedef void * ADDR;\n+typedef unsigned long long REG;\n+\n+#define REG_AT(addr) (*(REG *)(addr))\n \n-#define REG_AT(address) (*(REG *)(address))\n+#define AS_REG(addr) ((REG)(unsigned long)(addr))\n+#define AS_ADDR(reg) ((ADDR)(unsigned long)(reg))\n+#define ADDR_IN(reg) (AS_ADDR(reg))\n \n /* The following structure defines the state maintained during the\n    unwinding process.  */\n typedef struct\n {\n-  void * pc;  /* Address of the call insn involved in the chain.  */\n-  void * sp;  /* Stack Pointer at the time of this call.  */\n-  void * fp;  /* Frame Pointer at the time of this call.  */\n+  ADDR pc;  /* Address of the call insn involved in the chain.  */\n+  ADDR sp;  /* Stack Pointer at the time of this call.  */\n+  ADDR fp;  /* Frame Pointer at the time of this call.  */\n+\n+  /* The values above are fetched as saved REGisters on the stack. They are\n+     typed ADDR because this is what the values in those registers are.  */\n \n   /* Values of the registers saved by the functions in the chain,\n-     incrementally updated through consecutive calls to the \"unwind\"\n-     function below.  */\n+     incrementally updated through consecutive calls to the \"unwind\" function\n+     below.  */\n   REG saved_regs [32];\n } frame_state_t;\n \n@@ -79,91 +84,133 @@ typedef struct\n \n    This is from ABI-3.1.1 [Integer Registers].  */\n \n-#define saved_fp saved_regs[29]\n-#define saved_sp saved_regs[30]\n-#define saved_ra saved_regs[26]\n-#define saved_pv saved_regs[27]\n+#define saved_fpr saved_regs[29]\n+#define saved_spr saved_regs[30]\n+#define saved_rar saved_regs[26]\n+#define saved_pvr saved_regs[27]\n \n-/* Special values for saved_ra, used to control the overall unwinding\n+/* Special values for saved_rar, used to control the overall unwinding\n    process.  */\n #define RA_UNKNOWN ((REG)~0)\n #define RA_STOP    ((REG)0)\n \n-/* Compute Procedure Value from a live Frame Pointer value.  */\n+/* We still use a number of macros similar to the ones for the generic\n+   __gnat_backtrace implementation.  */\n+#define PC_ADJUST 4\n+#define STOP_FRAME (frame_state.saved_rar == RA_STOP)\n+\n+/* Compute Procedure Value from Frame Pointer value.  This follows the rules\n+   in ABI-3.6.1 [Current Procedure].  */\n #define PV_FOR(FP) \\\n-  ((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP);\n+  (((FP) != 0) \\\n+    ? (((REG_AT (FP) & 0x7) == 0) ? *(PDSCDEF **)(FP) : (PDSCDEF *)(FP)) : 0)\n+\n \n /**********\n  * unwind *\n  **********/\n \n-/* Helper for __gnat_backtrace. Update FS->pc/sp/fp to represent the\n-   state computed in FS->saved_regs during the previous call, and update\n-   FS->saved_regs in preparation of the next call.  */\n+/* Helper for __gnat_backtrace.\n+\n+   FS represents some call frame, identified by a pc and associated frame\n+   pointer in FS->pc and FS->fp. FS->saved_regs contains the state of the\n+   general registers upon entry in this frame. Of most interest in this set\n+   are the saved return address and frame pointer registers, which actually\n+   allow identifying the caller's frame.\n+\n+   This routine \"unwinds\" the input frame state by adjusting it to eventually\n+   represent its caller's frame. The basic principle is to shift the fp and pc\n+   saved values into the current state, and then compute the corresponding new\n+   saved registers set.\n+\n+   If the call chain goes through a signal handler, special processing is\n+   required when we process the kernel frame which has called the handler, to\n+   switch it to the interrupted context frame.  */\n+\n+#define K_HANDLER_FRAME(fs) (PV_FOR ((fs)->fp) == SYS$GL_CALL_HANDL)\n+\n+static void unwind_regular_code (frame_state_t * fs);\n+static void unwind_kernel_handler (frame_state_t * fs);\n \n void\n unwind (frame_state_t * fs)\n {\n-  REG frame_base;\n-  PDSCDEF * pv;\n-\n   /* Don't do anything if requested so.  */\n-  if (fs->saved_ra == RA_STOP)\n+  if (fs->saved_rar == RA_STOP)\n     return;\n \n   /* Retrieve the values of interest computed during the previous\n      call. PC_ADJUST gets us from the return address to the call insn\n      address.  */\n-  fs->pc = (void *) fs->saved_ra + PC_ADJUST;\n-  fs->sp = (void *) fs->saved_sp;\n-  fs->fp = (void *) fs->saved_fp;\n+  fs->pc = ADDR_IN (fs->saved_rar) - PC_ADJUST;\n+  fs->sp = ADDR_IN (fs->saved_spr);\n+  fs->fp = ADDR_IN (fs->saved_fpr);\n \n   /* Unless we are able to determine otherwise, set the frame state's\n      saved return address such that the unwinding process will stop.  */\n-  fs->saved_ra = RA_STOP;\n+  fs->saved_rar = RA_STOP;\n \n-  /* Now we want to update fs->saved_regs to reflect what the procedure\n-     described by pc/fp/sp has done.  */\n+  /* Now we want to update fs->saved_regs to reflect the state of the caller\n+     of the procedure described by pc/fp.\n \n-  /* Compute the corresponding \"procedure value\", following the rules in\n-     ABI-3.6.1 [Current Procedure]. Return immediatly if this value mandates\n-     us to stop.  */\n-  if (fs->fp == 0)\n-    return;\n+     The condition to check for a special kernel frame which has called a\n+     signal handler is stated in ABI-6.7.1 [Signaler's Registers] : \"The frame\n+     of the call to the handler can be identified by the return address of\n+     SYS$CALL_HANDL+4\". We use the equivalent procedure value identification\n+     here because SYS$CALL_HANDL appears to be undefined. */\n+\n+  if (K_HANDLER_FRAME (fs))\n+    unwind_kernel_handler (fs);\n+  else\n+    unwind_regular_code (fs);\n+}\n \n-  pv = PV_FOR (fs->fp);\n+/***********************\n+ * unwind_regular_code *\n+ ***********************/\n+\n+/* Helper for unwind, for the case of unwinding through regular code which\n+   is not a signal handler.  */\n+\n+static void\n+unwind_regular_code (frame_state_t * fs)\n+{\n+  PDSCDEF * pv = PV_FOR (fs->fp);\n+\n+  ADDR frame_base;\n+\n+  /* Use the procedure value to unwind, in a way depending on the kind of\n+     procedure at hand. See ABI-3.3 [Procedure Representation] and ABI-3.4\n+     [Procedure Types].  */\n \n   if (pv == 0\n       || pv->pdsc$w_flags & PDSC$M_BASE_FRAME)\n     return;\n \n-  /* Use the procedure value to unwind, in a way depending on the kind of\n-     procedure at hand. This is based on ABI-3.3 [Procedure Representation]\n-     and ABI-3.4 [Procedure Types].  */\n   frame_base\n-    = (REG) ((pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP) ? fs->fp : fs->sp);\n+    = (pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP) ? fs->fp : fs->sp;\n \n   switch (pv->pdsc$w_flags & 0xf)\n     {\n     case PDSC$K_KIND_FP_STACK:\n       /* Stack Frame Procedure (ABI-3.4.1). Retrieve the necessary registers\n \t from the Register Save Area in the frame.  */\n       {\n-\tREG rsa_base = frame_base + pv->pdsc$w_rsa_offset;\n+\tADDR rsa_base = frame_base + pv->pdsc$w_rsa_offset;\n \tint i, j;\n \n-\tfs->saved_ra = REG_AT (rsa_base);\n-\tfs->saved_pv = REG_AT (frame_base);\n-\t\n+\tfs->saved_rar = REG_AT (rsa_base);\n+\tfs->saved_pvr = REG_AT (frame_base);\n+\n \tfor (i = 0, j = 0; i < 32; i++)\n \t  if (pv->pdsc$l_ireg_mask & (1 << i))\n \t    fs->saved_regs[i] = REG_AT (rsa_base + 8 * ++j);\n \n-\t/* Note that the loop above is guaranteed to set fs->saved_fp, because\n-\t   \"The preserved register set must always include R29(FP) since it\n-\t   will always be used.\" (ABI-3.4.3.4 [Register Save Area for All\n-\t   Stack Frames]).\n-\t\n+\t/* Note that the loop above is guaranteed to set fs->saved_fpr,\n+\t   because \"The preserved register set must always include R29(FP)\n+\t   since it will always be used.\" (ABI-3.4.3.4 [Register Save Area for\n+\t   All Stack Frames]).\n+\n \t   Also note that we need to run through all the registers to ensure\n \t   that unwinding through register procedures (see below) gets the\n \t   right values out of the saved_regs array.  */\n@@ -174,8 +221,8 @@ unwind (frame_state_t * fs)\n       /* Register Procedure (ABI-3.4.4). Retrieve the necessary registers from\n \t the registers where they have been saved.  */\n       {\n-\tfs->saved_ra = fs->saved_regs[pv->pdsc$b_save_ra];\n-\tfs->saved_fp = fs->saved_regs[pv->pdsc$b_save_fp];\n+\tfs->saved_rar = fs->saved_regs[pv->pdsc$b_save_ra];\n+\tfs->saved_fpr = fs->saved_regs[pv->pdsc$b_save_fp];\n       }\n       break;\n \n@@ -187,31 +234,120 @@ unwind (frame_state_t * fs)\n   /* SP is actually never part of the saved registers area, so we use the\n      corresponding entry in the saved_regs array to manually keep track of\n      it's evolution.  */\n-  fs->saved_sp = frame_base + pv->pdsc$l_size;\n+  fs->saved_spr = AS_REG (frame_base) + pv->pdsc$l_size;\n+}\n+\n+/*************************\n+ * unwind_kernel_handler *\n+ *************************/\n+\n+/* Helper for unwind, for the specific case of unwinding through a signal\n+   handler.\n+\n+   The input frame state describes the kernel frame which has called a signal\n+   handler. We fill the corresponding saved_regs to have it's \"caller\" frame\n+   represented as the interrupted context.  */\n+\n+static void\n+unwind_kernel_handler (frame_state_t * fs)\n+{\n+  PDSCDEF * pv = PV_FOR (fs->fp);\n+\n+  CHFDEF1 *sigargs;\n+  CHFDEF2 *mechargs;\n+\n+  /* Retrieve the arguments passed to the handler, by way of a VMS service\n+     providing the corresponding \"Invocation Context Block\".  */\n+  {\n+    long handler_ivhandle;\n+    INVO_CONTEXT_BLK handler_ivcb;\n+\n+    CHFCTX *chfctx;\n+\n+    handler_ivcb.libicb$q_ireg [29] = AS_REG (fs->fp);\n+    handler_ivcb.libicb$q_ireg [30] = 0;\n+\n+    handler_ivhandle = LIB$GET_INVO_HANDLE (&handler_ivcb);\n+\n+    if ((LIB$GET_INVO_CONTEXT (handler_ivhandle, &handler_ivcb) & 1) != 1)\n+      return;\n+\n+    chfctx = (CHFCTX *) AS_ADDR (handler_ivcb.libicb$ph_chfctx_addr);\n+\n+    sigargs = (CHFDEF1 *) AS_ADDR (chfctx->chfctx$q_sigarglst);\n+    mechargs = (CHFDEF2 *) AS_ADDR (chfctx->chfctx$q_mcharglst);\n+  }\n+\n+  /* Compute the saved return address as the PC of the instruction causing the\n+     condition, accounting for the fact that it will be adjusted by the next\n+     call to \"unwind\" as if it was an actual call return address.  */\n+  {\n+    /* ABI-6.5.1.1 [Signal Argument Vector]: The signal occurrence address\n+       is available from the sigargs argument to the handler, designed to\n+       support both 32 and 64 bit addresses.  The initial reference we get\n+       is a pointer to the 32bit form, from which one may extract a pointer\n+       to the 64bit version if need be.  We work directly from the 32bit\n+       form here.  */\n+\n+    /* The sigargs vector structure for 32bits addresses is:\n+\n+       <......32bit......>\n+       +-----------------+\n+       |      Vsize      | :chf$is_sig_args\n+       +-----------------+ -+-\n+       | Condition Value |  : [0]\n+       +-----------------+  :\n+       |       ...       |  :\n+       +-----------------+  : vector of Vsize entries\n+       |    Signal PC    |  :\n+       +-----------------+  :\n+       |       PS        |  : [Vsize - 1]\n+       +-----------------+ -+-\n+\n+       */\n+\n+    unsigned long * sigargs_vector\n+      = ((unsigned long *) (&sigargs->chf$is_sig_args)) + 1;\n+\n+    long sigargs_vsize\n+      = sigargs->chf$is_sig_args;\n+\n+    fs->saved_rar = (REG) sigargs_vector [sigargs_vsize - 2] + PC_ADJUST;\n+  }\n+\n+  fs->saved_spr = RA_UNKNOWN;\n+  fs->saved_fpr = (REG) mechargs->chf$q_mch_frame;\n+  fs->saved_pvr = (REG) mechargs->chf$q_mch_savr27;\n+\n+  fs->saved_regs[16] = (REG) mechargs->chf$q_mch_savr16;\n+  fs->saved_regs[17] = (REG) mechargs->chf$q_mch_savr17;\n+  fs->saved_regs[18] = (REG) mechargs->chf$q_mch_savr18;\n+  fs->saved_regs[19] = (REG) mechargs->chf$q_mch_savr19;\n+  fs->saved_regs[20] = (REG) mechargs->chf$q_mch_savr20;\n }\n \n /* Structure representing a traceback entry in the tracebacks array to be\n    filled by __gnat_backtrace below.\n \n+   !! This should match what is in System.Traceback_Entries, so beware of\n+   !! the REG/ADDR difference here.\n+\n    The use of a structure is motivated by the potential necessity of having\n    several fields to fill for each entry, for instance if later calls to VMS\n    system functions need more than just a mere PC to compute info on a frame\n    (e.g. for non-symbolic->symbolic translation purposes).  */\n typedef struct {\n-  void * pc;\n-  void * pv;\n+  ADDR pc;\n+  ADDR pv;\n } tb_entry_t;\n \n /********************\n  * __gnat_backtrace *\n  ********************/\n \n int\n-__gnat_backtrace (void **array,\n-                  int size,\n-                  void *exclude_min,\n-                  void *exclude_max,\n-                  int skip_frames)\n+__gnat_backtrace (void **array, int size,\n+                  void *exclude_min, void *exclude_max, int skip_frames)\n {\n   int cnt;\n \n@@ -223,9 +359,9 @@ __gnat_backtrace (void **array,\n   register REG this_FP __asm__(\"$29\");\n   register REG this_SP __asm__(\"$30\");\n \n-  frame_state.saved_fp = this_FP;\n-  frame_state.saved_sp = this_SP;\n-  frame_state.saved_ra = RA_UNKNOWN;\n+  frame_state.saved_fpr = this_FP;\n+  frame_state.saved_spr = this_SP;\n+  frame_state.saved_rar = RA_UNKNOWN;\n \n   unwind (&frame_state);\n \n@@ -239,15 +375,18 @@ __gnat_backtrace (void **array,\n   cnt = 0;\n   while (cnt < size)\n     {\n+      PDSCDEF * pv = PV_FOR (frame_state.fp);\n+\n+      /* Stop if either the frame contents or the unwinder say so.  */\n       if (STOP_FRAME)\n         break;\n \n-      if (frame_state.pc < exclude_min\n-\t  || frame_state.pc > exclude_max)\n+      if (! K_HANDLER_FRAME (&frame_state)\n+\t  && (frame_state.pc < exclude_min || frame_state.pc > exclude_max))\n \t{\n-\t  tbe->pc = frame_state.pc;\n-\t  tbe->pv = PV_FOR (frame_state.fp);\n-\t\n+\t  tbe->pc = (ADDR) frame_state.pc;\n+\t  tbe->pv = (ADDR) PV_FOR (frame_state.fp);\n+\n \t  cnt ++;\n \t  tbe ++;\n \t}"}]}