{"sha": "ef302293136af29f6b167bb87f647fca3d423767", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzMDIyOTMxMzZhZjI5ZjZiMTY3YmI4N2Y2NDdmY2EzZDQyMzc2Nw==", "commit": {"author": {"name": "Leehod Baruch", "email": "leehod@il.ibm.com", "date": "2005-02-03T16:13:17Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-02-03T16:13:17Z"}, "message": "tree-vectorizer.c (vect_analyze_data_ref_dependence): Function declaration added.\n\n        * tree-vectorizer.c (vect_analyze_data_ref_dependence): Function\n        declaration added.\n        (vect_analyze_data_ref_dependences): Likewise.\n\n        (vect_is_simple_use): Argument changed from loop structure to\n        loop_vect_info structure.\n        (vect_can_advance_ivs_p): Likewise.\n        (vect_create_index_for_vector_ref): Likewise.\n        (vect_update_ivs_after_vectorizer): Likewise.\n        (new_stmt_vec_info): Likewise.\n\n        (new_loop_vec_info): Second argument in call to new_stmt_vec_info was\n        changed from loop to loop_vinfo.\n        (vect_create_data_ref_ptr): First argument in call to\n        vect_create_index_for_vector_ref was changed from loop to loop_vinfo.\n        (vectorizable_assignment): Second argument in call to vect_is_simple_use\n        was changed from loop to loop_vinfo.\n        (vectorizable_operation): Likewise.\n        (vectorizable_store): Likewise.\n        (vect_mark_stmts_to_be_vectorized): Likewise.\n        (vect_do_peeling_for_loop_bound): First argument in call to\n        vect_update_ivs_after_vectorizer was changed from loop to loop_vinfo.\n        (vect_analyze_operations): Argument in call to vect_can_advance_ivs_p\n        was changed from loop to loop_vinfo.\n        (vect_analyze_data_ref_dependences): Third argument in call to\n        vect_analyze_data_ref_dependence was changed from loop to loop_vinfo.\n\n        (vect_create_index_for_vector_ref): Get the loop from loop_vinfo.\n        (vect_create_data_ref_ptr): Likewise.\n        (vect_init_vector): Likewise.\n        (vect_get_vec_def_for_operand): Likewise.\n        (vectorizable_assignment): Likewise.\n        (vectorizable_operation): Likewise.\n        (vectorizable_store): Likewise.\n        (vectorizable_load): Likewise.\n        (vect_update_ivs_after_vectorizer): Likewise.\n        (vect_is_simple_use): Likewise.\n        (vect_analyze_data_ref_dependence): Likewise.\n        (vect_analyze_pointer_ref_access): Likewise.\n        (vect_can_advance_ivs_p): Likewise.\n\n        * tree-vectorizer.h: (_loop_vec_info): Definition and macros moved\n        before _stmt_vec_info.\n        (_stmt_vec_info): Loop field replaced by loop_vec_info.\n        (STMT_VINFO_LOOP): Replaced with STMT_VINFO_LOOP_VINFO.\n        (new_stmt_vec_info): Argument changed from loop structure to\n        loop_vect_info structure\n\n        (vect_analyze_data_ref_dependences): Unnecessary line was removed.\n        (vect_analyze_offset_expr): Avoid 80 columns overflow.\n        (vect_create_addr_base_for_vector_ref): Likewise.\n        (vect_analyze_pointer_ref_access): Likewise.\n\nCo-Authored-By: Dorit Naishlos <dorit@il.ibm.com>\n\nFrom-SVN: r94661", "tree": {"sha": "9f3b1a7826708c1a82d8e59891c32e838223bd48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f3b1a7826708c1a82d8e59891c32e838223bd48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef302293136af29f6b167bb87f647fca3d423767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef302293136af29f6b167bb87f647fca3d423767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef302293136af29f6b167bb87f647fca3d423767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef302293136af29f6b167bb87f647fca3d423767/comments", "author": null, "committer": null, "parents": [{"sha": "9df935d878e5d92552ba1cb2b1ceacecef69f53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9df935d878e5d92552ba1cb2b1ceacecef69f53f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9df935d878e5d92552ba1cb2b1ceacecef69f53f"}], "stats": {"total": 294, "additions": 176, "deletions": 118}, "files": [{"sha": "8419047fcb4837fe6752465ec73935b45f09528b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef302293136af29f6b167bb87f647fca3d423767/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef302293136af29f6b167bb87f647fca3d423767/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef302293136af29f6b167bb87f647fca3d423767", "patch": "@@ -1,3 +1,59 @@\n+2005-02-03  Leehod Baruch  <leehod@il.ibm.com>\n+\t    Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (vect_analyze_data_ref_dependence): Function\n+\tdeclaration added.\n+\t(vect_analyze_data_ref_dependences): Likewise.\n+\n+\t(vect_is_simple_use): Argument changed from loop structure to\n+\tloop_vect_info structure.\n+\t(vect_can_advance_ivs_p): Likewise.\n+\t(vect_create_index_for_vector_ref): Likewise.\n+\t(vect_update_ivs_after_vectorizer): Likewise.\n+\t(new_stmt_vec_info): Likewise.\n+\t\n+\t(new_loop_vec_info): Second argument in call to new_stmt_vec_info was\n+\tchanged from loop to loop_vinfo.\n+\t(vect_create_data_ref_ptr): First argument in call to\n+\tvect_create_index_for_vector_ref was changed from loop to loop_vinfo.\n+\t(vectorizable_assignment): Second argument in call to vect_is_simple_use\n+\twas changed from loop to loop_vinfo.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vect_do_peeling_for_loop_bound): First argument in call to\n+\tvect_update_ivs_after_vectorizer was changed from loop to loop_vinfo.\n+\t(vect_analyze_operations): Argument in call to vect_can_advance_ivs_p\n+\twas changed from loop to loop_vinfo.\n+\t(vect_analyze_data_ref_dependences): Third argument in call to\n+\tvect_analyze_data_ref_dependence was changed from loop to loop_vinfo.\n+\t\n+\t(vect_create_index_for_vector_ref): Get the loop from loop_vinfo.\n+\t(vect_create_data_ref_ptr): Likewise.\n+\t(vect_init_vector): Likewise.\n+\t(vect_get_vec_def_for_operand): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vect_update_ivs_after_vectorizer): Likewise.\n+\t(vect_is_simple_use): Likewise.\n+\t(vect_analyze_data_ref_dependence): Likewise.\n+\t(vect_analyze_pointer_ref_access): Likewise.\n+\t(vect_can_advance_ivs_p): Likewise.\n+\n+\t* tree-vectorizer.h: (_loop_vec_info): Definition and macros moved\n+\tbefore _stmt_vec_info.\n+\t(_stmt_vec_info): Loop field replaced by loop_vec_info.\n+\t(STMT_VINFO_LOOP): Replaced with STMT_VINFO_LOOP_VINFO.\n+\t(new_stmt_vec_info): Argument changed from loop structure to\n+\tloop_vect_info structure\n+\n+\t(vect_analyze_data_ref_dependences): Unnecessary line was removed.\n+\t(vect_analyze_offset_expr): Avoid 80 columns overflow.\n+\t(vect_create_addr_base_for_vector_ref): Likewise.\n+\t(vect_analyze_pointer_ref_access): Likewise.\n+\n 2005-02-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/19768"}, {"sha": "b200c5a0b13fb52f8b7dffac9ac4652b6f4d777a", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef302293136af29f6b167bb87f647fca3d423767/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef302293136af29f6b167bb87f647fca3d423767/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ef302293136af29f6b167bb87f647fca3d423767", "patch": "@@ -191,6 +191,9 @@ static bool vect_analyze_data_refs (loop_vec_info);\n static bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n static bool vect_analyze_scalar_cycles (loop_vec_info);\n static bool vect_analyze_data_ref_accesses (loop_vec_info);\n+static bool vect_analyze_data_ref_dependence\n+  (struct data_reference *, struct data_reference *, loop_vec_info);\n+static bool vect_analyze_data_ref_dependences (loop_vec_info);\n static bool vect_analyze_data_refs_alignment (loop_vec_info);\n static bool vect_compute_data_refs_alignment (loop_vec_info);\n static bool vect_analyze_operations (loop_vec_info);\n@@ -208,7 +211,7 @@ static void vect_align_data_ref (tree);\n static void vect_enhance_data_refs_alignment (loop_vec_info);\n \n /* Utility functions for the analyses.  */\n-static bool vect_is_simple_use (tree , struct loop *, tree *);\n+static bool vect_is_simple_use (tree , loop_vec_info, tree *);\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n static bool vect_is_simple_iv_evolution (unsigned, tree, tree *, tree *, bool);\n static void vect_mark_relevant (varray_type *, tree);\n@@ -219,7 +222,7 @@ static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n   (tree, tree, bool);\n-static bool vect_can_advance_ivs_p (struct loop *);\n+static bool vect_can_advance_ivs_p (loop_vec_info);\n static tree vect_get_base_and_offset (struct data_reference *, tree, tree, \n \t\t\t\t      loop_vec_info, tree *, tree *, tree *,\n \t\t\t\t      bool*);\n@@ -236,7 +239,7 @@ static tree vect_strip_conversion (tree);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n   (tree, block_stmt_iterator *, tree, tree *, bool); \n-static tree vect_create_index_for_vector_ref (struct loop *);\n+static tree vect_create_index_for_vector_ref (loop_vec_info);\n static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n static tree get_vectype_for_scalar_type (tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n@@ -249,7 +252,7 @@ static void vect_finish_stmt_generation\n static void vect_generate_tmps_on_preheader \n   (loop_vec_info, tree *, tree *, tree *);\n static tree vect_build_loop_niters (loop_vec_info);\n-static void vect_update_ivs_after_vectorizer (struct loop *, tree, edge); \n+static void vect_update_ivs_after_vectorizer (loop_vec_info, tree, edge); \n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n static void vect_update_inits_of_dr (struct data_reference *, tree niters);\n static void vect_update_inits_of_drs (loop_vec_info, tree);\n@@ -260,7 +263,7 @@ static void vect_do_peeling_for_loop_bound\n /* Utilities for creation and deletion of vec_info structs.  */\n loop_vec_info new_loop_vec_info (struct loop *loop);\n void destroy_loop_vec_info (loop_vec_info);\n-stmt_vec_info new_stmt_vec_info (tree stmt, struct loop *loop);\n+stmt_vec_info new_stmt_vec_info (tree, loop_vec_info);\n \n static bool vect_debug_stats (struct loop *loop);\n static bool vect_debug_details (struct loop *loop);\n@@ -665,7 +668,6 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   tree step = build_int_cst (TREE_TYPE (niters), 1);\n   tree then_label;\n   tree else_label;\n-  tree incr;\n \n   orig_cond = get_loop_exit_condition (loop);\n #ifdef ENABLE_CHECKING\n@@ -676,9 +678,6 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   standard_iv_increment_position (loop, &incr_bsi, &insert_after);\n   create_iv (init, step, NULL_TREE, loop,\n              &incr_bsi, insert_after, &indx_before_incr, &indx_after_incr);\n-  incr = bsi_stmt (incr_bsi);\n-  get_stmt_operands (incr);\n-  set_stmt_info (stmt_ann (incr), new_stmt_vec_info (incr, loop));\n \n   if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n     {\n@@ -723,19 +722,13 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n \n   at_exit = (e == loop->exit_edges[0]); \n   if (!at_exit && e != loop_preheader_edge (loop))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t  fprintf (dump_file, \"Edge is not an entry nor an exit edge.\\n\");\n-      return NULL;\n-    }\n+    return NULL;\n \n   bbs = get_loop_body (loop);\n \n   /* Check whether duplication is possible.  */\n   if (!can_copy_bbs_p (bbs, loop->num_nodes))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file, \"Cannot copy basic blocks.\\n\");\n       free (bbs);\n       return NULL;\n     }\n@@ -744,8 +737,6 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   new_loop = duplicate_loop (loops, loop, loop->outer);\n   if (!new_loop)\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file, \"duplicate_loop returns NULL.\\n\");\n       free (bbs);\n       return NULL;\n     }\n@@ -1127,14 +1118,14 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n    Create and initialize a new stmt_vec_info struct for STMT.  */\n \n stmt_vec_info\n-new_stmt_vec_info (tree stmt, struct loop *loop)\n+new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n {\n   stmt_vec_info res;\n   res = (stmt_vec_info) xcalloc (1, sizeof (struct _stmt_vec_info));\n \n   STMT_VINFO_TYPE (res) = undef_vec_info_type;\n   STMT_VINFO_STMT (res) = stmt;\n-  STMT_VINFO_LOOP (res) = loop;\n+  STMT_VINFO_LOOP_VINFO (res) = loop_vinfo;\n   STMT_VINFO_RELEVANT_P (res) = 0;\n   STMT_VINFO_VECTYPE (res) = NULL;\n   STMT_VINFO_VEC_STMT (res) = NULL;\n@@ -1178,7 +1169,7 @@ new_loop_vec_info (struct loop *loop)\n \n \t  get_stmt_operands (stmt);\n \t  ann = stmt_ann (stmt);\n-\t  set_stmt_info (ann, new_stmt_vec_info (stmt, loop));\n+\t  set_stmt_info (ann, new_stmt_vec_info (stmt, res));\n \t}\n     }\n \n@@ -1492,8 +1483,8 @@ vect_analyze_offset_expr (tree expr,\n   if (!vect_analyze_offset_expr (oprnd0, loop, vectype_alignment, &left_offset, \n \t\t\t\t&left_misalign, &left_step)\n       || !vect_analyze_offset_expr (oprnd1, loop, vectype_alignment, \n-\t\t\t\t    &right_offset, &right_misalign, &right_step))\n-      return false;\n+\t\t\t\t   &right_offset, &right_misalign, &right_step))\n+    return false;\n \n   /* The type of the operation: plus, minus or mult.  */\n   code = TREE_CODE (expr);\n@@ -1513,14 +1504,15 @@ vect_analyze_offset_expr (tree expr,\n       /* Misalignment computation.  */\n       if (SSA_VAR_P (left_offset))\n \t{\n-\t  /* If the left side contains variable that cannot be substituted with \n-\t     constant, we check if the right side is a multiple of ALIGNMENT.  */\n+\t  /* If the left side contains variables that can't be substituted with \n+\t     constants, we check if the right side is a multiple of ALIGNMENT.\n+\t   */\n \t  if (integer_zerop (size_binop (TRUNC_MOD_EXPR, right_offset, \n \t\t\t          fold_convert (ssizetype, vectype_alignment))))\n \t    *misalign = ssize_int (0);\n \t  else\n-\t    /* If the remainder is not zero or the right side isn't constant, we \n-\t       can't compute  misalignment.  */\n+\t    /* If the remainder is not zero or the right side isn't constant,\n+\t       we can't compute  misalignment.  */\n \t    *misalign = NULL_TREE;\n \t}\n       else \n@@ -1852,12 +1844,13 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n    just before the conditional expression that ends the single block loop.  */\n \n static tree\n-vect_create_index_for_vector_ref (struct loop *loop)\n+vect_create_index_for_vector_ref (loop_vec_info loop_vinfo)\n {\n   tree init, step;\n   block_stmt_iterator incr_bsi;\n   bool insert_after;\n   tree indx_before_incr, indx_after_incr;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree incr;\n \n   /* It is assumed that the base pointer used for vectorized access contains\n@@ -1872,7 +1865,7 @@ vect_create_index_for_vector_ref (struct loop *loop)\n \t&indx_before_incr, &indx_after_incr);\n   incr = bsi_stmt (incr_bsi);\n   get_stmt_operands (incr);\n-  set_stmt_info (stmt_ann (incr), new_stmt_vec_info (incr, loop));\n+  set_stmt_info (stmt_ann (incr), new_stmt_vec_info (incr, loop_vinfo));\n \n   return indx_before_incr;\n }\n@@ -1953,8 +1946,8 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n       add_referenced_tmp_var (tmp);\n       offset = fold (build2 (MULT_EXPR, TREE_TYPE (offset), offset, \n \t\t\t     STMT_VINFO_VECT_STEP (stmt_info)));\n-      base_offset = fold (build2 (PLUS_EXPR, TREE_TYPE (base_offset), base_offset, \n-\t\t\t\t  offset));\n+      base_offset = fold (build2 (PLUS_EXPR, TREE_TYPE (base_offset), \n+\t\t\t\t  base_offset, offset));\n       base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);  \n       append_to_statement_list_force (new_stmt, new_stmt_list);\n     }\n@@ -2103,7 +2096,8 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vect_ptr_type;\n   tree vect_ptr;\n@@ -2207,7 +2201,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   if (only_init) /* No update in loop is required.  */\n     return vect_ptr_init;\n \n-  idx = vect_create_index_for_vector_ref (loop);\n+  idx = vect_create_index_for_vector_ref (loop_vinfo);\n \n   /* Create: update = idx * vectype_size  */\n   tmp = create_tmp_var (integer_type_node, \"update\");\n@@ -2272,7 +2266,8 @@ static tree\n vect_init_vector (tree stmt, tree vector_var)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_vinfo);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree new_var;\n   tree init_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo); \n@@ -2324,7 +2319,8 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   int nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_vinfo);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block bb;\n   tree vec_inv;\n   tree t = NULL_TREE;\n@@ -2480,7 +2476,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vec_oprnd;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n \n   /* Is vectorizable assignment?  */\n@@ -2493,7 +2489,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     return false;\n \n   op = TREE_OPERAND (stmt, 1);\n-  if (!vect_is_simple_use (op, loop, NULL))\n+  if (!vect_is_simple_use (op, loop_vinfo, NULL))\n     {\n       if (vect_debug_details (NULL))\n         fprintf (dump_file, \"use not simple.\");\n@@ -2544,7 +2540,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vec_oprnd0, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   int i;\n   enum tree_code code;\n   enum machine_mode vec_mode;\n@@ -2576,7 +2572,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   for (i = 0; i < op_type; i++)\n     {\n       op = TREE_OPERAND (operation, i);\n-      if (!vect_is_simple_use (op, loop, NULL))\n+      if (!vect_is_simple_use (op, loop_vinfo, NULL))\n \t{\n \t  if (vect_debug_details (NULL))\n \t    fprintf (dump_file, \"use not simple.\");\n@@ -2658,7 +2654,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n@@ -2674,7 +2670,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     return false;\n \n   op = TREE_OPERAND (stmt, 1);\n-  if (!vect_is_simple_use (op, loop, NULL))\n+  if (!vect_is_simple_use (op, loop_vinfo, NULL))\n     {\n       if (vect_debug_details (NULL))\n         fprintf (dump_file, \"use not simple.\");\n@@ -2747,7 +2743,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree new_stmt;\n   tree dummy;\n   basic_block new_bb;\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   edge pe = loop_preheader_edge (loop);\n   enum dr_alignment_support alignment_support_cheme;\n \n@@ -3139,13 +3136,15 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n  */\n \n static void\n-vect_update_ivs_after_vectorizer (struct loop *loop, tree niters, edge update_e)\n+vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters, \n+\t\t\t\t  edge update_e)\n {\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block exit_bb = loop->exit_edges[0]->dest;\n   tree phi, phi1;\n   basic_block update_bb = update_e->dest;\n \n-  /* gcc_assert (vect_can_advance_ivs_p (loop)); */\n+  /* gcc_assert (vect_can_advance_ivs_p (loop_vinfo)); */\n \n   /* Make sure there exists a single-predecessor exit bb:  */\n   gcc_assert (EDGE_COUNT (exit_bb->preds) == 1);\n@@ -3267,7 +3266,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \n   /* Update IVs of original loop as if they were advanced \n      by ratio_mult_vf_name steps.  */\n-  vect_update_ivs_after_vectorizer (loop, ratio_mult_vf_name, update_e); \n+  vect_update_ivs_after_vectorizer (loop_vinfo, ratio_mult_vf_name, update_e); \n \n   /* After peeling we have to reset scalar evolution analyzer.  */\n   scev_reset ();\n@@ -3588,10 +3587,11 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n    in reduction/induction computations).  */\n \n static bool\n-vect_is_simple_use (tree operand, struct loop *loop, tree *def)\n+vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n { \n   tree def_stmt;\n   basic_block bb;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (def)\n     *def = NULL_TREE;\n@@ -3809,7 +3809,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\n         fprintf (dump_file, \"epilog loop required.\");\n-      if (!vect_can_advance_ivs_p (loop))\n+      if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n           if (vect_debug_stats (loop) || vect_debug_details (loop))\n             fprintf (dump_file, \"not vectorized: can't create epilog loop 1.\");\n@@ -4045,10 +4045,11 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n static bool\n vect_analyze_data_ref_dependence (struct data_reference *dra,\n \t\t\t\t  struct data_reference *drb, \n-\t\t\t\t  struct loop *loop)\n+\t\t\t\t  loop_vec_info loop_vinfo)\n {\n   bool differ_p; \n   struct data_dependence_relation *ddr;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   \n   if (!array_base_name_differ_p (dra, drb, &differ_p))\n     {\n@@ -4099,7 +4100,6 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n   unsigned int i, j;\n   varray_type loop_write_refs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_refs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   /* Examine store-store (output) dependences.  */\n \n@@ -4117,7 +4117,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \t    VARRAY_GENERIC_PTR (loop_write_refs, i);\n \t  struct data_reference *drb =\n \t    VARRAY_GENERIC_PTR (loop_write_refs, j);\n-\t  if (vect_analyze_data_ref_dependence (dra, drb, loop))\n+\t  if (vect_analyze_data_ref_dependence (dra, drb, loop_vinfo))\n \t    return false;\n \t}\n     }\n@@ -4134,7 +4134,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \t  struct data_reference *dra = VARRAY_GENERIC_PTR (loop_read_refs, i);\n \t  struct data_reference *drb =\n \t    VARRAY_GENERIC_PTR (loop_write_refs, j);\n-\t  if (vect_analyze_data_ref_dependence (dra, drb, loop))\n+\t  if (vect_analyze_data_ref_dependence (dra, drb, loop_vinfo))\n \t    return false;\n \t}\n     }\n@@ -4609,7 +4609,8 @@ static struct data_reference *\n vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree access_fn = analyze_scalar_evolution (loop, TREE_OPERAND (memref, 0));\n   tree init, step;\t\n   tree reftype, innertype;\n@@ -4719,9 +4720,9 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n    and SSA_NAME (this is category 3 - \"recursion stop condition\"). \n \n    When the MEMREF falls into category 1 there is still no data reference struct \n-   (DR) available. It is created by this function, and then, along the recursion, \n-   MEMREF will fall into category 2 or 3, in which case a DR will have already \n-   been created, but the analysis continues to retrieve the MEMTAG.\n+   (DR) available. It is created by this function, and then, along the \n+   recursion, MEMREF will fall into category 2 or 3, in which case a DR will \n+   have already been created, but the analysis continues to retrieve the MEMTAG.\n \n    Input:\n    MEMREF - data reference in STMT\n@@ -4887,7 +4888,6 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n }\n \n \n-\n /* Function vect_analyze_data_refs.\n \n    Find all the data references in the loop.\n@@ -5229,7 +5229,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      tree arg = PHI_ARG_DEF (stmt, j);\n \t      tree def_stmt = NULL_TREE;\n \t      basic_block bb;\n-\t      if (!vect_is_simple_use (arg, loop, &def_stmt))\n+\t      if (!vect_is_simple_use (arg, loop_vinfo, &def_stmt))\n \t\t{\n \t\t  if (vect_debug_details (NULL))\t\n \t\t    fprintf (dump_file, \"worklist: unsupported use.\");\n@@ -5265,7 +5265,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    {\n               tree def_stmt = NULL_TREE;\n               basic_block bb;\n-              if (!vect_is_simple_use (use, loop, &def_stmt))\n+              if (!vect_is_simple_use (use, loop_vinfo, &def_stmt))\n                 {\n                   if (vect_debug_details (NULL))        \n                     fprintf (dump_file, \"worklist: unsupported use.\");\n@@ -5304,8 +5304,9 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n    These restrictions will be relaxed in the future.  */\n \n static bool \n-vect_can_advance_ivs_p (struct loop *loop)\n+vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n {\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block bb = loop->header;\n   tree phi;\n "}, {"sha": "4b893e6e36cf054961e6bf7ac2ffdd77e2107da3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef302293136af29f6b167bb87f647fca3d423767/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef302293136af29f6b167bb87f647fca3d423767/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ef302293136af29f6b167bb87f647fca3d423767", "patch": "@@ -42,6 +42,62 @@ enum dr_alignment_support {\n   dr_aligned\n };\n \n+/*-----------------------------------------------------------------*/\n+/* Info on vectorized loops.                                       */\n+/*-----------------------------------------------------------------*/\n+typedef struct _loop_vec_info {\n+\n+  /* The loop to which this info struct refers to.  */\n+  struct loop *loop;\n+\n+  /* The loop basic blocks.  */\n+  basic_block *bbs;\n+\n+  /* The loop exit_condition.  */\n+  tree exit_cond;\n+\n+  /* Number of iterations.  */\n+  tree num_iters;\n+\n+  /* Is the loop vectorizable? */\n+  bool vectorizable;\n+\n+  /* Unrolling factor  */\n+  int vectorization_factor;\n+\n+  /* Unknown DRs according to which loop was peeled.  */\n+  struct data_reference *unaligned_dr;\n+\n+  /* If true, loop is peeled.\n+   unaligned_drs show in this case DRs used for peeling.  */\n+  bool do_peeling_for_alignment;\n+\n+  /* All data references in the loop that are being written to.  */\n+  varray_type data_ref_writes;\n+\n+  /* All data references in the loop that are being read from.  */\n+  varray_type data_ref_reads;\n+\n+} *loop_vec_info;\n+\n+/* Access Functions.  */\n+#define LOOP_VINFO_LOOP(L)           (L)->loop\n+#define LOOP_VINFO_BBS(L)            (L)->bbs\n+#define LOOP_VINFO_EXIT_COND(L)      (L)->exit_cond\n+#define LOOP_VINFO_NITERS(L)         (L)->num_iters\n+#define LOOP_VINFO_VECTORIZABLE_P(L) (L)->vectorizable\n+#define LOOP_VINFO_VECT_FACTOR(L)    (L)->vectorization_factor\n+#define LOOP_VINFO_DATAREF_WRITES(L) (L)->data_ref_writes\n+#define LOOP_VINFO_DATAREF_READS(L)  (L)->data_ref_reads\n+#define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))\n+#define LOOP_DO_PEELING_FOR_ALIGNMENT(L) (L)->do_peeling_for_alignment\n+#define LOOP_VINFO_UNALIGNED_DR(L) (L)->unaligned_dr\n+\n+\n+#define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\\n+(host_integerp ((L)->num_iters,0)                        \\\n+&& TREE_INT_CST_LOW ((L)->num_iters) > 0)\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized defs.                                        */\n /*-----------------------------------------------------------------*/\n@@ -60,8 +116,8 @@ typedef struct _stmt_vec_info {\n   /* The stmt to which this info struct refers to.  */\n   tree stmt;\n \n-  /* The loop with respect to which STMT is vectorized.  */\n-  struct loop *loop;\n+  /* The loop_vec_info with respect to which STMT is vectorized.  */\n+  loop_vec_info loop_vinfo;\n \n   /* Not all stmts in the loop need to be vectorized. e.g, the incrementation\n      of the loop induction variable and computation of array indexes. relevant\n@@ -114,7 +170,7 @@ typedef struct _stmt_vec_info {\n /* Access Functions.  */\n #define STMT_VINFO_TYPE(S)                (S)->type\n #define STMT_VINFO_STMT(S)                (S)->stmt\n-#define STMT_VINFO_LOOP(S)                (S)->loop\n+#define STMT_VINFO_LOOP_VINFO(S)          (S)->loop_vinfo\n #define STMT_VINFO_RELEVANT_P(S)          (S)->relevant\n #define STMT_VINFO_VECTYPE(S)             (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n@@ -166,61 +222,6 @@ unknown_alignment_for_access_p (struct data_reference *data_ref_info)\n #define VECT_SMODULO(x,y) ((x) % (y) < 0 ? ((x) % (y) + (y)) : (x) % (y))\n \n \n-/*-----------------------------------------------------------------*/\n-/* Info on vectorized loops.                                       */\n-/*-----------------------------------------------------------------*/\n-typedef struct _loop_vec_info {\n-\n-  /* The loop to which this info struct refers to.  */\n-  struct loop *loop;\n-\n-  /* The loop basic blocks.  */\n-  basic_block *bbs;\n-\n-  /* The loop exit_condition.  */\n-  tree exit_cond;\n-\n-  /* Number of iterations.  */\n-  tree num_iters;\n-\n-  /* Is the loop vectorizable? */\n-  bool vectorizable;\n-\n-  /* Unrolling factor  */\n-  int vectorization_factor;\n-\n-  /* Unknown DRs according to which loop was peeled.  */\n-  struct data_reference *unaligned_dr;\n-\n-  /* If true, loop is peeled.\n-   unaligned_drs show in this case DRs used for peeling.  */\n-  bool do_peeling_for_alignment;\n-\n-  /* All data references in the loop that are being written to.  */\n-  varray_type data_ref_writes;\n-\n-  /* All data references in the loop that are being read from.  */\n-  varray_type data_ref_reads;\n-} *loop_vec_info;\n-\n-/* Access Functions.  */\n-#define LOOP_VINFO_LOOP(L)           (L)->loop\n-#define LOOP_VINFO_BBS(L)            (L)->bbs\n-#define LOOP_VINFO_EXIT_COND(L)      (L)->exit_cond\n-#define LOOP_VINFO_NITERS(L)         (L)->num_iters\n-#define LOOP_VINFO_VECTORIZABLE_P(L) (L)->vectorizable\n-#define LOOP_VINFO_VECT_FACTOR(L)    (L)->vectorization_factor\n-#define LOOP_VINFO_DATAREF_WRITES(L) (L)->data_ref_writes\n-#define LOOP_VINFO_DATAREF_READS(L)  (L)->data_ref_reads\n-#define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))       \n-#define LOOP_DO_PEELING_FOR_ALIGNMENT(L) (L)->do_peeling_for_alignment\n-#define LOOP_VINFO_UNALIGNED_DR(L)       (L)->unaligned_dr\n-  \n-\n-#define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\\n-(host_integerp ((L)->num_iters,0)                        \\\n-&& TREE_INT_CST_LOW ((L)->num_iters) > 0)      \n-\n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */\n /*-----------------------------------------------------------------*/\n@@ -231,6 +232,6 @@ extern void vectorize_loops (struct loops *);\n /* creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n extern void destroy_loop_vec_info (loop_vec_info);\n-extern stmt_vec_info new_stmt_vec_info (tree stmt, struct loop *loop);\n+extern stmt_vec_info new_stmt_vec_info (tree stmt, loop_vec_info);\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}