{"sha": "08c796829cf14288f1916299cbd74d0381f3e890", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjNzk2ODI5Y2YxNDI4OGYxOTE2Mjk5Y2JkNzRkMDM4MWYzZTg5MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-04-17T12:40:57Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-04-17T12:40:57Z"}, "message": "alias.c (reg_base_value, [...]): Change the type to VEC(rtx,gc) *.\n\n\t* alias.c (reg_base_value, old_reg_base_value): Change the\n\ttype to VEC(rtx,gc) *.\n\t(REG_BASE_VALUE, find_base_value, record_set,\n\tinit_alias_analysis): Use VEC instead of VARRAY.\n\nFrom-SVN: r113004", "tree": {"sha": "c1fdffc97d2bf2bbb25c80ba7f2d0fb5c2ed058b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1fdffc97d2bf2bbb25c80ba7f2d0fb5c2ed058b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c796829cf14288f1916299cbd74d0381f3e890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c796829cf14288f1916299cbd74d0381f3e890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c796829cf14288f1916299cbd74d0381f3e890", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c796829cf14288f1916299cbd74d0381f3e890/comments", "author": null, "committer": null, "parents": [{"sha": "726ac11ebd7552453d39f084cf9d05d2bbc91b58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726ac11ebd7552453d39f084cf9d05d2bbc91b58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726ac11ebd7552453d39f084cf9d05d2bbc91b58"}], "stats": {"total": 65, "additions": 32, "deletions": 33}, "files": [{"sha": "275cf27c0e0a433b5db702630b554c00cceef397", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c796829cf14288f1916299cbd74d0381f3e890/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c796829cf14288f1916299cbd74d0381f3e890/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08c796829cf14288f1916299cbd74d0381f3e890", "patch": "@@ -1,3 +1,10 @@\n+2006-04-16  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* alias.c (reg_base_value, old_reg_base_value): Change the\n+\ttype to VEC(rtx,gc) *.\n+\t(REG_BASE_VALUE, find_base_value, record_set,\n+\tinit_alias_analysis): Use VEC instead of VARRAY.\n+\n 2006-04-16  Roger Sayle  <roger@eyesopen.com>\n \n \tPR target/26961"}, {"sha": "c5ea1c12986ce38dcb8d04da31c1533a3008663c", "filename": "gcc/alias.c", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c796829cf14288f1916299cbd74d0381f3e890/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c796829cf14288f1916299cbd74d0381f3e890/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=08c796829cf14288f1916299cbd74d0381f3e890", "patch": "@@ -206,21 +206,21 @@ static void record_alias_subset (HOST_WIDE_INT, HOST_WIDE_INT);\n    current function performs nonlocal memory memory references for the\n    purposes of marking the function as a constant function.  */\n \n-static GTY(()) varray_type reg_base_value;\n+static GTY(()) VEC(rtx,gc) *reg_base_value;\n static rtx *new_reg_base_value;\n \n /* We preserve the copy of old array around to avoid amount of garbage\n    produced.  About 8% of garbage produced were attributed to this\n    array.  */\n-static GTY((deletable)) varray_type old_reg_base_value;\n+static GTY((deletable)) VEC(rtx,gc) *old_reg_base_value;\n \n /* Static hunks of RTL used by the aliasing code; these are initialized\n    once per function to avoid unnecessary RTL allocations.  */\n static GTY (()) rtx static_reg_base_value[FIRST_PSEUDO_REGISTER];\n \n-#define REG_BASE_VALUE(X) \\\n-  (reg_base_value && REGNO (X) < VARRAY_SIZE (reg_base_value) \\\n-   ? VARRAY_RTX (reg_base_value, REGNO (X)) : 0)\n+#define REG_BASE_VALUE(X)\t\t\t\t\\\n+  (REGNO (X) < VEC_length (rtx, reg_base_value)\t\t\\\n+   ? VEC_index (rtx, reg_base_value, REGNO (X)) : 0)\n \n /* Vector indexed by N giving the initial (unchanging) value known for\n    pseudo-register N.  This array is initialized in init_alias_analysis,\n@@ -815,16 +815,16 @@ find_base_value (rtx src)\n \t The test above is not sufficient because the scheduler may move\n \t a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */\n       if ((regno >= FIRST_PSEUDO_REGISTER || fixed_regs[regno])\n-\t  && regno < VARRAY_SIZE (reg_base_value))\n+\t  && regno < VEC_length (rtx, reg_base_value))\n \t{\n \t  /* If we're inside init_alias_analysis, use new_reg_base_value\n \t     to reduce the number of relaxation iterations.  */\n \t  if (new_reg_base_value && new_reg_base_value[regno]\n \t      && REG_N_SETS (regno) == 1)\n \t    return new_reg_base_value[regno];\n \n-\t  if (VARRAY_RTX (reg_base_value, regno))\n-\t    return VARRAY_RTX (reg_base_value, regno);\n+\t  if (VEC_index (rtx, reg_base_value, regno))\n+\t    return VEC_index (rtx, reg_base_value, regno);\n \t}\n \n       return 0;\n@@ -968,7 +968,7 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n \n   regno = REGNO (dest);\n \n-  gcc_assert (regno < VARRAY_SIZE (reg_base_value));\n+  gcc_assert (regno < VEC_length (rtx, reg_base_value));\n \n   /* If this spans multiple hard registers, then we must indicate that every\n      register has an unusable value.  */\n@@ -2424,24 +2424,16 @@ init_alias_analysis (void)\n   reg_known_value = ggc_calloc (reg_known_value_size, sizeof (rtx));\n   reg_known_equiv_p = xcalloc (reg_known_value_size, sizeof (bool));\n \n-  /* Overallocate reg_base_value to allow some growth during loop\n-     optimization.  Loop unrolling can create a large number of\n-     registers.  */\n+  /* If we have memory allocated from the previous run, use it.  */\n   if (old_reg_base_value)\n-    {\n-      reg_base_value = old_reg_base_value;\n-      /* If varray gets large zeroing cost may get important.  */\n-      if (VARRAY_SIZE (reg_base_value) > 256\n-          && VARRAY_SIZE (reg_base_value) > 4 * maxreg)\n-\tVARRAY_GROW (reg_base_value, maxreg);\n-      VARRAY_CLEAR (reg_base_value);\n-      if (VARRAY_SIZE (reg_base_value) < maxreg)\n-\tVARRAY_GROW (reg_base_value, maxreg);\n-    }\n-  else\n-    {\n-      VARRAY_RTX_INIT (reg_base_value, maxreg, \"reg_base_value\");\n-    }\n+    reg_base_value = old_reg_base_value;\n+\n+  if (reg_base_value)\n+    VEC_truncate (rtx, reg_base_value, 0);\n+\n+  VEC_safe_grow (rtx, gc, reg_base_value, maxreg);\n+  memset (VEC_address (rtx, reg_base_value), 0,\n+\t  sizeof (rtx) * VEC_length (rtx, reg_base_value));\n \n   new_reg_base_value = XNEWVEC (rtx, maxreg);\n   reg_seen = XNEWVEC (char, maxreg);\n@@ -2576,11 +2568,11 @@ init_alias_analysis (void)\n       for (ui = 0; ui < maxreg; ui++)\n \t{\n \t  if (new_reg_base_value[ui]\n-\t      && new_reg_base_value[ui] != VARRAY_RTX (reg_base_value, ui)\n+\t      && new_reg_base_value[ui] != VEC_index (rtx, reg_base_value, ui)\n \t      && ! rtx_equal_p (new_reg_base_value[ui],\n-\t\t\t\tVARRAY_RTX (reg_base_value, ui)))\n+\t\t\t\tVEC_index (rtx, reg_base_value, ui)))\n \t    {\n-\t      VARRAY_RTX (reg_base_value, ui) = new_reg_base_value[ui];\n+\t      VEC_replace (rtx, reg_base_value, ui, new_reg_base_value[ui]);\n \t      changed = 1;\n \t    }\n \t}\n@@ -2609,15 +2601,15 @@ init_alias_analysis (void)\n       pass++;\n       for (ui = 0; ui < maxreg; ui++)\n \t{\n-\t  rtx base = VARRAY_RTX (reg_base_value, ui);\n+\t  rtx base = VEC_index (rtx, reg_base_value, ui);\n \t  if (base && REG_P (base))\n \t    {\n \t      unsigned int base_regno = REGNO (base);\n \t      if (base_regno == ui)\t\t/* register set from itself */\n-\t\tVARRAY_RTX (reg_base_value, ui) = 0;\n+\t\tVEC_replace (rtx, reg_base_value, ui, 0);\n \t      else\n-\t\tVARRAY_RTX (reg_base_value, ui)\n-\t\t  = VARRAY_RTX (reg_base_value, base_regno);\n+\t\tVEC_replace (rtx, reg_base_value, ui,\n+\t\t\t     VEC_index (rtx, reg_base_value, base_regno));\n \t      changed = 1;\n \t    }\n \t}"}]}