{"sha": "00ec6daa3ca775bae5983d6df8d3085726f6c4b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlYzZkYWEzY2E3NzViYWU1OTgzZDZkZjhkMzA4NTcyNmY2YzRiMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-09-22T01:40:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-22T01:40:28Z"}, "message": "Jan Hubicka  <hubicka@freesoft.cz>\n\n        * genrecog.c (not_both_true): Handle correctly cases when called for\n        tests with different positions in the insn.\n\nFrom-SVN: r29573", "tree": {"sha": "69498a5fa35f9d9f80f26b15296fb08ae527ef19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69498a5fa35f9d9f80f26b15296fb08ae527ef19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00ec6daa3ca775bae5983d6df8d3085726f6c4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ec6daa3ca775bae5983d6df8d3085726f6c4b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00ec6daa3ca775bae5983d6df8d3085726f6c4b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ec6daa3ca775bae5983d6df8d3085726f6c4b0/comments", "author": null, "committer": null, "parents": [{"sha": "35cc13e4b6f2ba0dd80cfbd650c643bc86b9ba48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35cc13e4b6f2ba0dd80cfbd650c643bc86b9ba48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35cc13e4b6f2ba0dd80cfbd650c643bc86b9ba48"}], "stats": {"total": 43, "additions": 43, "deletions": 0}, "files": [{"sha": "93f0ee5f70301642aaa6a60f41a7e576f0c22860", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ec6daa3ca775bae5983d6df8d3085726f6c4b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ec6daa3ca775bae5983d6df8d3085726f6c4b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00ec6daa3ca775bae5983d6df8d3085726f6c4b0", "patch": "@@ -1,3 +1,8 @@\n+Tue Sep 21 18:40:01 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* genrecog.c (not_both_true): Handle correctly cases when called for\n+\ttests with different positions in the insn.\n+\n Tue Sep 21 18:29:11 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* machmode.h (HOST_PTR_PRINTF): Move from here ..."}, {"sha": "d63c8cf8fda0f8a75fa9fdd3194bbf0a5550160e", "filename": "gcc/genrecog.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00ec6daa3ca775bae5983d6df8d3085726f6c4b0/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00ec6daa3ca775bae5983d6df8d3085726f6c4b0/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=00ec6daa3ca775bae5983d6df8d3085726f6c4b0", "patch": "@@ -685,6 +685,44 @@ not_both_true (d1, d2, toplevel)\n      int toplevel;\n {\n   struct decision *p1, *p2;\n+  int cmp;\n+\n+  /* Don't compare strings on the different positions in insn.  Doing so\n+     is incorrect and results in false matches from constructs like\n+\n+\t[(set (subreg:HI (match_operand:SI \"register_operand\" \"r\") 0)\n+\t      (subreg:HI (match_operand:SI \"register_operand\" \"r\") 0))]\n+     vs\n+\t[(set (match_operand:HI \"register_operand\" \"r\")\n+\t      (match_operand:HI \"register_operand\" \"r\"))]\n+\n+     If we are presented with such, we are recursing through the remainder\n+     of a node's success nodes (from the loop at the end of this function).\n+     Skip forward until we come to a position that matches.\n+\n+     Due to the way position strings are constructed, we know that iterating\n+     forward from the lexically lower position (e.g. \"00\") will run into\n+     the lexically higher position (e.g. \"1\") and not the other way around.\n+     This saves a bit of effort.  */\n+\n+  cmp = strcmp (d1->position, d2->position);\n+  if (cmp != 0)\n+    {\n+      if (toplevel)\n+\tabort();\n+\n+      /* If the d2->position was lexically lower, swap.  */\n+      if (cmp > 0)\n+\tp1 = d1; d1 = d2; d2 = p1;\n+\n+      if (d1->success.first == 0)\n+\treturn 0;\n+      for (p1 = d1->success.first; p1; p1 = p1->next)\n+\tif (! not_both_true (p1, d2, 0))\n+\t  return 0;\n+\n+      return 1;\n+    }\n \n   /* If they are both to test modes and the modes are different, they aren't\n      both true.  Similarly for codes, integer elements, and vector lengths.  */"}]}