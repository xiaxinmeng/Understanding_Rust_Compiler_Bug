{"sha": "73049af5fa62c7eeca27585f8f318e9bea7c47ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwNDlhZjVmYTYyYzdlZWNhMjc1ODVmOGYzMThlOWJlYTdjNDdhZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-10-17T10:54:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-10-17T10:54:54Z"}, "message": "re PR tree-optimization/63464 (compare one character to many: faster)\n\n\tPR tree-optimization/63464\n\t* gimple.h (gimple_seq_discard): New prototype.\n\t* gimple.c: Include stringpool.h and tree-ssanames.h.\n\t(gimple_seq_discard): New function.\n\t* optabs.h (lshift_cheap_p): New prototype.\n\t* optabs.c (lshift_cheap_p): New function, moved from...\n\t* tree-switch-conversion.c (lshift_cheap_p): ... here.\n\t* tree-ssa-reassoc.c: Include gimplify.h and optabs.h.\n\t(reassoc_branch_fixups): New variable.\n\t(update_range_test): Add otherrangep and seq arguments.\n\tUnshare exp.  If otherrange is NULL, use for other ranges\n\tarray of pointers pointed by otherrangep instead.\n\tEmit seq before gimplified statements for tem.\n\t(optimize_range_tests_diff): Adjust update_range_test\n\tcaller.\n\t(optimize_range_tests_xor): Likewise.  Fix up comment.\n\t(extract_bit_test_mask, optimize_range_tests_to_bit_test): New\n\tfunctions.\n\t(optimize_range_tests): Adjust update_range_test caller.\n\tCall optimize_range_tests_to_bit_test.\n\t(branch_fixup): New function.\n\t(execute_reassoc): Call branch_fixup.\n\n\t* gcc.dg/torture/pr63464.c: New test.\n\t* gcc.dg/tree-ssa/reassoc-37.c: New test.\n\t* gcc.dg/tree-ssa/reassoc-38.c: New test.\n\nFrom-SVN: r216393", "tree": {"sha": "3d9f1e754cc0f6442d99387021c379a081f76de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9f1e754cc0f6442d99387021c379a081f76de3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73049af5fa62c7eeca27585f8f318e9bea7c47ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73049af5fa62c7eeca27585f8f318e9bea7c47ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73049af5fa62c7eeca27585f8f318e9bea7c47ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73049af5fa62c7eeca27585f8f318e9bea7c47ae/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4eb4a256cd4a39555f4d834c47cabc2e136ed02a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb4a256cd4a39555f4d834c47cabc2e136ed02a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb4a256cd4a39555f4d834c47cabc2e136ed02a"}], "stats": {"total": 625, "additions": 576, "deletions": 49}, "files": [{"sha": "28ab841634be730060eef446bc630c348f0124bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -1,5 +1,28 @@\n 2014-10-17  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/63464\n+\t* gimple.h (gimple_seq_discard): New prototype.\n+\t* gimple.c: Include stringpool.h and tree-ssanames.h.\n+\t(gimple_seq_discard): New function.\n+\t* optabs.h (lshift_cheap_p): New prototype.\n+\t* optabs.c (lshift_cheap_p): New function, moved from...\n+\t* tree-switch-conversion.c (lshift_cheap_p): ... here.\n+\t* tree-ssa-reassoc.c: Include gimplify.h and optabs.h.\n+\t(reassoc_branch_fixups): New variable.\n+\t(update_range_test): Add otherrangep and seq arguments.\n+\tUnshare exp.  If otherrange is NULL, use for other ranges\n+\tarray of pointers pointed by otherrangep instead.\n+\tEmit seq before gimplified statements for tem.\n+\t(optimize_range_tests_diff): Adjust update_range_test\n+\tcaller.\n+\t(optimize_range_tests_xor): Likewise.  Fix up comment.\n+\t(extract_bit_test_mask, optimize_range_tests_to_bit_test): New\n+\tfunctions.\n+\t(optimize_range_tests): Adjust update_range_test caller.\n+\tCall optimize_range_tests_to_bit_test.\n+\t(branch_fixup): New function.\n+\t(execute_reassoc): Call branch_fixup.\n+\n \tPR tree-optimization/63302\n \t* tree-ssa-reassoc.c (optimize_range_tests_xor,\n \toptimize_range_tests_diff): Use !integer_pow2p () instead of"}, {"sha": "233b43629115256378a2ee9f40476de11ce9a462", "filename": "gcc/gimple.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -47,6 +47,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"demangle.h\"\n #include \"langhooks.h\"\n #include \"bitmap.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssanames.h\"\n \n \n /* All the tuples have their operand vector (if present) at the very bottom\n@@ -2826,3 +2828,19 @@ gimple_seq_set_location (gimple_seq seq, location_t loc)\n   for (gimple_stmt_iterator i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n     gimple_set_location (gsi_stmt (i), loc);\n }\n+\n+/* Release SSA_NAMEs in SEQ as well as the GIMPLE statements.  */\n+\n+void\n+gimple_seq_discard (gimple_seq seq)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start (seq); !gsi_end_p (gsi); )\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      gsi_remove (&gsi, true);\n+      release_defs (stmt);\n+      ggc_free (stmt);\n+    }\n+}"}, {"sha": "7f1240f753826660342b9b6b09cd3dfa5ff98459", "filename": "gcc/gimple.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -1269,9 +1269,10 @@ extern bool gimple_asm_clobbers_memory_p (const_gimple);\n extern void dump_decl_set (FILE *, bitmap);\n extern bool nonfreeing_call_p (gimple);\n extern bool infer_nonnull_range (gimple, tree, bool, bool);\n-extern void sort_case_labels (vec<tree> );\n-extern void preprocess_case_label_vec_for_gimple (vec<tree> , tree, tree *);\n-extern void gimple_seq_set_location (gimple_seq , location_t);\n+extern void sort_case_labels (vec<tree>);\n+extern void preprocess_case_label_vec_for_gimple (vec<tree>, tree, tree *);\n+extern void gimple_seq_set_location (gimple_seq, location_t);\n+extern void gimple_seq_discard (gimple_seq);\n \n /* Formal (expression) temporary table handling: multiple occurrences of\n    the same scalar expression are evaluated into the same temporary.  */"}, {"sha": "2df84d23472da07e054a4dc1241811a9db221374", "filename": "gcc/optabs.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -8630,4 +8630,31 @@ get_best_mem_extraction_insn (extraction_insn *insn,\n \t\t\t\t   struct_bits, field_mode);\n }\n \n+/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n+\n+bool\n+lshift_cheap_p (bool speed_p)\n+{\n+  /* FIXME: This should be made target dependent via this \"this_target\"\n+     mechanism, similar to e.g. can_copy_init_p in gcse.c.  */\n+  static bool init[2] = { false, false };\n+  static bool cheap[2] = { true, true };\n+\n+  /* If the targer has no lshift in word_mode, the operation will most\n+     probably not be cheap.  ??? Does GCC even work for such targets?  */\n+  if (optab_handler (ashl_optab, word_mode) == CODE_FOR_nothing)\n+    return false;\n+\n+  if (!init[speed_p])\n+    {\n+      rtx reg = gen_raw_REG (word_mode, 10000);\n+      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n+\t\t\t       speed_p);\n+      cheap[speed_p] = cost < COSTS_N_INSNS (3);\n+      init[speed_p] = true;\n+    }\n+\n+  return cheap[speed_p];\n+}\n+\n #include \"gt-optabs.h\""}, {"sha": "050d9b1f51d11d0830f00d5bfcdfcf9e2a11b3de", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -538,5 +538,6 @@ extern void gen_satfractuns_conv_libfunc (convert_optab, const char *,\n \t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t  enum machine_mode);\n extern void init_tree_optimization_optabs (tree);\n+extern bool lshift_cheap_p (bool);\n \n #endif /* GCC_OPTABS_H */"}, {"sha": "e38cfd62dd93618b9a738ff0afae2a8eb7574d3d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -1,5 +1,10 @@\n 2014-10-17  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/63464\n+\t* gcc.dg/torture/pr63464.c: New test.\n+\t* gcc.dg/tree-ssa/reassoc-37.c: New test.\n+\t* gcc.dg/tree-ssa/reassoc-38.c: New test.\n+\n \tPR tree-optimization/63302\n \t* gcc.c-torture/execute/pr63302.c: New test.\n "}, {"sha": "b6a95599cbf5648220c713a11e99130ece575eca", "filename": "gcc/testsuite/gcc.dg/torture/pr63464.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr63464.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr63464.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr63464.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -0,0 +1,92 @@\n+/* PR tree-optimization/63464 */\n+/* { dg-do run { target int32plus } } */\n+\n+int cnt;\n+\n+__attribute__((noinline, noclone)) void\n+bar (int x, int y)\n+{\n+  cnt++;\n+  switch (y)\n+    {\n+    case 1:\n+      if ((unsigned) x < 24U && ((1U << x) & 0x860c0cU) != 0)\n+        __builtin_abort ();\n+      break;\n+    case 2:\n+      if ((unsigned) x >= 24U || ((1U << x) & 0x860c0cU) == 0)\n+        __builtin_abort ();\n+      break;\n+    case 3:\n+      if ((unsigned) x - 43U < 40U && ((1ULL << (x - 43U)) & 0x8f0000004fULL) != 0)\n+        __builtin_abort ();\n+      break;\n+    case 4:\n+      if ((unsigned) x - 43U >= 40U || ((1ULL << (x - 43U)) & 0x8f0000004fULL) == 0)\n+        __builtin_abort ();\n+      break;\n+    default:\n+      __builtin_abort ();\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int x)\n+{\n+  if (x != 2 && x != 3 && x != 10 && x != 11 && x != 17 && x != 18 && x != 23)\n+    bar (x, 1);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int x)\n+{\n+  if (x == 2 || x == 3 || x == 10 || x == 11 || x == 17 || x == 18 || x == 23)\n+    bar (x, 2);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (int x)\n+{\n+  if (x != 43 && x != 76 && x != 44 && x != 78 && x != 49\n+      && x != 77 && x != 46 && x != 75 && x != 45 && x != 82)\n+    bar (x, 3);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (int x)\n+{\n+  if (x == 43 || x == 76 || x == 44 || x == 78 || x == 49\n+      || x == 77 || x == 46 || x == 75 || x == 45 || x == 82)\n+    bar (x, 4);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  f1 (-__INT_MAX__ - 1);\n+  for (i = -3; i < 92; i++)\n+    f1 (i);\n+  f1 (__INT_MAX__);\n+  if (cnt != 97 - 7)\n+    __builtin_abort ();\n+  f2 (-__INT_MAX__ - 1);\n+  for (i = -3; i < 92; i++)\n+    f2 (i);\n+  f2 (__INT_MAX__);\n+  if (cnt != 97)\n+    __builtin_abort ();\n+  f3 (-__INT_MAX__ - 1);\n+  for (i = -3; i < 92; i++)\n+    f3 (i);\n+  f3 (__INT_MAX__);\n+  if (cnt != 97 * 2 - 10)\n+    __builtin_abort ();\n+  f4 (-__INT_MAX__ - 1);\n+  for (i = -3; i < 92; i++)\n+    f4 (i);\n+  f4 (__INT_MAX__);\n+  if (cnt != 97 * 2)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "5f5d36fbb07f966bea845f118da9a02db8df80dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-37.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-37.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -0,0 +1,17 @@\n+/* PR tree-optimization/63464 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int x)\n+{\n+  if (x != 2 && x != 3 && x != 10 && x != 11 && x != 17 && x != 18 && x != 23)\n+    bar ();\n+}\n+\n+/* Check if the tests have been folded into a bit test.  */\n+/* { dg-final { scan-tree-dump \"(8784908|0x0*860c0c)\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"(<<|>>)\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b894339997b6b3a14165632780b173248fa38bee", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-38.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-38.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/63464 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int x)\n+{\n+  if (x == 43 || x == 76 || x == 44 || x == 78 || x == 49\n+      || x == 77 || x == 46 || x == 75 || x == 45 || x == 82)\n+    bar ();\n+}\n+\n+/* Check if the tests have been folded into a bit test.  */\n+/* { dg-final { scan-tree-dump \"(614180323407|0x0*8f0000004f)\" \"optimized\" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 } } } } } } */\n+/* { dg-final { scan-tree-dump \"(<<|>>)\" \"optimized\" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 } } } } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "159f217bbe410fc281da8eb3dbdec88c9b5428c1", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 371, "deletions": 17, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -61,6 +61,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"diagnostic-core.h\"\n #include \"builtins.h\"\n+#include \"gimplify.h\"\n+#include \"optabs.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less\n@@ -218,6 +220,12 @@ static long *bb_rank;\n /* Operand->rank hashtable.  */\n static hash_map<tree, long> *operand_rank;\n \n+/* Vector of SSA_NAMEs on which after reassociate_bb is done with\n+   all basic blocks the CFG should be adjusted - basic blocks\n+   split right after that SSA_NAME's definition statement and before\n+   the only use, which must be a bit ior.  */\n+static vec<tree> reassoc_branch_fixups;\n+\n /* Forward decls.  */\n static long get_rank (tree);\n static bool reassoc_stmt_dominates_stmt_p (gimple, gimple);\n@@ -2071,7 +2079,9 @@ range_entry_cmp (const void *a, const void *b)\n /* Helper routine of optimize_range_test.\n    [EXP, IN_P, LOW, HIGH, STRICT_OVERFLOW_P] is a merged range for\n    RANGE and OTHERRANGE through OTHERRANGE + COUNT - 1 ranges,\n-   OPCODE and OPS are arguments of optimize_range_tests.  Return\n+   OPCODE and OPS are arguments of optimize_range_tests.  If OTHERRANGE\n+   is NULL, OTHERRANGEP should not be and then OTHERRANGEP points to\n+   an array of COUNT pointers to other ranges.  Return\n    true if the range merge has been successful.\n    If OPCODE is ERROR_MARK, this is called from within\n    maybe_optimize_range_tests and is performing inter-bb range optimization.\n@@ -2080,19 +2090,22 @@ range_entry_cmp (const void *a, const void *b)\n \n static bool\n update_range_test (struct range_entry *range, struct range_entry *otherrange,\n+\t\t   struct range_entry **otherrangep,\n \t\t   unsigned int count, enum tree_code opcode,\n-\t\t   vec<operand_entry_t> *ops, tree exp, bool in_p,\n-\t\t   tree low, tree high, bool strict_overflow_p)\n+\t\t   vec<operand_entry_t> *ops, tree exp, gimple_seq seq,\n+\t\t   bool in_p, tree low, tree high, bool strict_overflow_p)\n {\n   operand_entry_t oe = (*ops)[range->idx];\n   tree op = oe->op;\n   gimple stmt = op ? SSA_NAME_DEF_STMT (op) :\n     last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe->id));\n   location_t loc = gimple_location (stmt);\n   tree optype = op ? TREE_TYPE (op) : boolean_type_node;\n-  tree tem = build_range_check (loc, optype, exp, in_p, low, high);\n+  tree tem = build_range_check (loc, optype, unshare_expr (exp),\n+\t\t\t\tin_p, low, high);\n   enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;\n   gimple_stmt_iterator gsi;\n+  unsigned int i;\n \n   if (tem == NULL_TREE)\n     return false;\n@@ -2112,8 +2125,12 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n       fprintf (dump_file, \", \");\n       print_generic_expr (dump_file, range->high, 0);\n       fprintf (dump_file, \"]\");\n-      for (r = otherrange; r < otherrange + count; r++)\n+      for (i = 0; i < count; i++)\n \t{\n+\t  if (otherrange)\n+\t    r = otherrange + i;\n+\t  else\n+\t    r = otherrangep[i];\n \t  fprintf (dump_file, \" and %c[\", r->in_p ? '+' : '-');\n \t  print_generic_expr (dump_file, r->low, 0);\n \t  fprintf (dump_file, \", \");\n@@ -2135,10 +2152,14 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n      In that case we have to insert after the stmt rather then before\n      it.  */\n   if (op == range->exp)\n-    tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE, false,\n-\t\t\t\t    GSI_CONTINUE_LINKING);\n+    {\n+      gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+      tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE, false,\n+\t\t\t\t      GSI_CONTINUE_LINKING);\n+    }\n   else\n     {\n+      gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n       tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE, true,\n \t\t\t\t      GSI_SAME_STMT);\n       gsi_prev (&gsi);\n@@ -2156,8 +2177,12 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n   range->in_p = in_p;\n   range->strict_overflow_p = false;\n \n-  for (range = otherrange; range < otherrange + count; range++)\n+  for (i = 0; i < count; i++)\n     {\n+      if (otherrange)\n+\trange = otherrange + i;\n+      else\n+\trange = otherrangep[i];\n       oe = (*ops)[range->idx];\n       /* Now change all the other range test immediate uses, so that\n \t those tests will be optimized away.  */\n@@ -2195,8 +2220,8 @@ optimize_range_tests_xor (enum tree_code opcode, tree type,\n \t\t\t  struct range_entry *rangej)\n {\n   tree lowxor, highxor, tem, exp;\n-  /* Check highi ^ lowi == highj ^ lowj and\n-     popcount (highi ^ lowi) == 1.  */\n+  /* Check lowi ^ lowj == highi ^ highj and\n+     popcount (lowi ^ lowj) == 1.  */\n   lowxor = fold_binary (BIT_XOR_EXPR, type, lowi, lowj);\n   if (lowxor == NULL_TREE || TREE_CODE (lowxor) != INTEGER_CST)\n     return false;\n@@ -2210,8 +2235,8 @@ optimize_range_tests_xor (enum tree_code opcode, tree type,\n   exp = fold_build2 (BIT_AND_EXPR, type, rangei->exp, tem);\n   lowj = fold_build2 (BIT_AND_EXPR, type, lowi, tem);\n   highj = fold_build2 (BIT_AND_EXPR, type, highi, tem);\n-  if (update_range_test (rangei, rangej, 1, opcode, ops, exp,\n-\t\t\t rangei->in_p, lowj, highj,\n+  if (update_range_test (rangei, rangej, NULL, 1, opcode, ops, exp,\n+\t\t\t NULL, rangei->in_p, lowj, highj,\n \t\t\t rangei->strict_overflow_p\n \t\t\t || rangej->strict_overflow_p))\n     return true;\n@@ -2259,8 +2284,8 @@ optimize_range_tests_diff (enum tree_code opcode, tree type,\n \t\t      fold_convert (type, rangei->exp), lowi);\n   tem1 = fold_build2 (BIT_AND_EXPR, type, tem1, mask);\n   lowj = build_int_cst (type, 0);\n-  if (update_range_test (rangei, rangej, 1, opcode, ops, tem1,\n-\t\t\t rangei->in_p, lowj, tem2,\n+  if (update_range_test (rangei, rangej, NULL, 1, opcode, ops, tem1,\n+\t\t\t NULL, rangei->in_p, lowj, tem2,\n \t\t\t rangei->strict_overflow_p\n \t\t\t || rangej->strict_overflow_p))\n     return true;\n@@ -2328,6 +2353,255 @@ optimize_range_tests_1 (enum tree_code opcode, int first, int length,\n   return any_changes;\n }\n \n+/* Helper function of optimize_range_tests_to_bit_test.  Handle a single\n+   range, EXP, LOW, HIGH, compute bit mask of bits to test and return\n+   EXP on success, NULL otherwise.  */\n+\n+static tree\n+extract_bit_test_mask (tree exp, int prec, tree totallow, tree low, tree high,\n+\t\t       wide_int *mask, tree *totallowp)\n+{\n+  tree tem = int_const_binop (MINUS_EXPR, high, low);\n+  if (tem == NULL_TREE\n+      || TREE_CODE (tem) != INTEGER_CST\n+      || TREE_OVERFLOW (tem)\n+      || tree_int_cst_sgn (tem) == -1\n+      || compare_tree_int (tem, prec) != -1)\n+    return NULL_TREE;\n+\n+  unsigned HOST_WIDE_INT max = tree_to_uhwi (tem) + 1;\n+  *mask = wi::shifted_mask (0, max, false, prec);\n+  if (TREE_CODE (exp) == BIT_AND_EXPR\n+      && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n+    {\n+      widest_int msk = wi::to_widest (TREE_OPERAND (exp, 1));\n+      msk = wi::zext (~msk, TYPE_PRECISION (TREE_TYPE (exp)));\n+      if (wi::popcount (msk) == 1\n+\t  && wi::ltu_p (msk, prec - max))\n+\t{\n+\t  *mask |= wi::shifted_mask (msk.to_uhwi (), max, false, prec);\n+\t  max += msk.to_uhwi ();\n+\t  exp = TREE_OPERAND (exp, 0);\n+\t  if (integer_zerop (low)\n+\t      && TREE_CODE (exp) == PLUS_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n+\t    {\n+\t      widest_int bias\n+\t        = wi::neg (wi::sext (wi::to_widest (TREE_OPERAND (exp, 1)),\n+\t\t\t\t     TYPE_PRECISION (TREE_TYPE (low))));\n+\t      tree tbias = wide_int_to_tree (TREE_TYPE (low), bias);\n+\t      if (totallowp)\n+\t\t{\n+\t\t  *totallowp = tbias;\n+\t\t  exp = TREE_OPERAND (exp, 0);\n+\t\t  STRIP_NOPS (exp);\n+\t\t  return exp;\n+\t\t}\n+\t      else if (!tree_int_cst_lt (totallow, tbias))\n+\t\treturn NULL_TREE;\n+\t      bias -= wi::to_widest (totallow);\n+\t      if (wi::ges_p (bias, 0) && wi::lts_p (bias, prec - max))\n+\t\t{\n+\t\t  *mask = wi::lshift (*mask, bias);\n+\t\t  exp = TREE_OPERAND (exp, 0);\n+\t\t  STRIP_NOPS (exp);\n+\t\t  return exp;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (totallowp)\n+    return exp;\n+  if (!tree_int_cst_lt (totallow, low))\n+    return exp;\n+  tem = int_const_binop (MINUS_EXPR, low, totallow);\n+  if (tem == NULL_TREE\n+      || TREE_CODE (tem) != INTEGER_CST\n+      || TREE_OVERFLOW (tem)\n+      || compare_tree_int (tem, prec - max) == 1)\n+    return NULL_TREE;\n+\n+  *mask = wi::lshift (*mask, wi::to_widest (tem));\n+  return exp;\n+}\n+\n+/* Attempt to optimize small range tests using bit test.\n+   E.g.\n+   X != 43 && X != 76 && X != 44 && X != 78 && X != 49\n+   && X != 77 && X != 46 && X != 75 && X != 45 && X != 82\n+   has been by earlier optimizations optimized into:\n+   ((X - 43U) & ~32U) > 3U && X != 49 && X != 82\n+   As all the 43 through 82 range is less than 64 numbers,\n+   for 64-bit word targets optimize that into:\n+   (X - 43U) > 40U && ((1 << (X - 43U)) & 0x8F0000004FULL) == 0  */\n+\n+static bool\n+optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n+\t\t\t\t  vec<operand_entry_t> *ops,\n+\t\t\t\t  struct range_entry *ranges)\n+{\n+  int i, j;\n+  bool any_changes = false;\n+  int prec = GET_MODE_BITSIZE (word_mode);\n+  auto_vec<struct range_entry *, 64> candidates;\n+\n+  for (i = first; i < length - 2; i++)\n+    {\n+      tree lowi, highi, lowj, highj, type;\n+\n+      if (ranges[i].exp == NULL_TREE || ranges[i].in_p)\n+\tcontinue;\n+      type = TREE_TYPE (ranges[i].exp);\n+      if (!INTEGRAL_TYPE_P (type))\n+\tcontinue;\n+      lowi = ranges[i].low;\n+      if (lowi == NULL_TREE)\n+\tlowi = TYPE_MIN_VALUE (type);\n+      highi = ranges[i].high;\n+      if (highi == NULL_TREE)\n+\tcontinue;\n+      wide_int mask;\n+      tree exp = extract_bit_test_mask (ranges[i].exp, prec, lowi, lowi,\n+\t\t\t\t\thighi, &mask, &lowi);\n+      if (exp == NULL_TREE)\n+\tcontinue;\n+      bool strict_overflow_p = ranges[i].strict_overflow_p;\n+      candidates.truncate (0);\n+      int end = MIN (i + 64, length);\n+      for (j = i + 1; j < end; j++)\n+\t{\n+\t  tree exp2;\n+\t  if (ranges[j].exp == NULL_TREE || ranges[j].in_p)\n+\t    continue;\n+\t  if (ranges[j].exp == exp)\n+\t    ;\n+\t  else if (TREE_CODE (ranges[j].exp) == BIT_AND_EXPR)\n+\t    {\n+\t      exp2 = TREE_OPERAND (ranges[j].exp, 0);\n+\t      if (exp2 == exp)\n+\t\t;\n+\t      else if (TREE_CODE (exp2) == PLUS_EXPR)\n+\t\t{\n+\t\t  exp2 = TREE_OPERAND (exp2, 0);\n+\t\t  STRIP_NOPS (exp2);\n+\t\t  if (exp2 != exp)\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    continue;\n+\t  lowj = ranges[j].low;\n+\t  if (lowj == NULL_TREE)\n+\t    continue;\n+\t  highj = ranges[j].high;\n+\t  if (highj == NULL_TREE)\n+\t    highj = TYPE_MAX_VALUE (type);\n+\t  wide_int mask2;\n+\t  exp2 = extract_bit_test_mask (ranges[j].exp, prec, lowi, lowj,\n+\t\t\t\t\thighj, &mask2, NULL);\n+\t  if (exp2 != exp)\n+\t    continue;\n+\t  mask |= mask2;\n+\t  strict_overflow_p |= ranges[j].strict_overflow_p;\n+\t  candidates.safe_push (&ranges[j]);\n+\t}\n+\n+      /* If we need otherwise 3 or more comparisons, use a bit test.  */\n+      if (candidates.length () >= 2)\n+\t{\n+\t  tree high = wide_int_to_tree (TREE_TYPE (lowi),\n+\t\t\t\t\twi::to_widest (lowi)\n+\t\t\t\t\t+ prec - wi::clz (mask));\n+\t  operand_entry_t oe = (*ops)[ranges[i].idx];\n+\t  tree op = oe->op;\n+\t  gimple stmt = op ? SSA_NAME_DEF_STMT (op)\n+\t\t\t   : last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe->id));\n+\t  location_t loc = gimple_location (stmt);\n+\t  tree optype = op ? TREE_TYPE (op) : boolean_type_node;\n+\n+\t  /* See if it isn't cheaper to pretend the minimum value of the\n+\t     range is 0, if maximum value is small enough.\n+\t     We can avoid then subtraction of the minimum value, but the\n+\t     mask constant could be perhaps more expensive.  */\n+\t  if (compare_tree_int (lowi, 0) > 0\n+\t      && compare_tree_int (high, prec) < 0)\n+\t    {\n+\t      int cost_diff;\n+\t      HOST_WIDE_INT m = tree_to_uhwi (lowi);\n+\t      rtx reg = gen_raw_REG (word_mode, 10000);\n+\t      bool speed_p = optimize_bb_for_speed_p (gimple_bb (stmt));\n+\t      cost_diff = set_rtx_cost (gen_rtx_PLUS (word_mode, reg,\n+\t\t\t\t\t\t      GEN_INT (-m)), speed_p);\n+\t      rtx r = immed_wide_int_const (mask, word_mode);\n+\t      cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r),\n+\t\t\t\t\t speed_p);\n+\t      r = immed_wide_int_const (wi::lshift (mask, m), word_mode);\n+\t      cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r),\n+\t\t\t\t\t speed_p);\n+\t      if (cost_diff > 0)\n+\t\t{\n+\t\t  mask = wi::lshift (mask, m);\n+\t\t  lowi = build_zero_cst (TREE_TYPE (lowi));\n+\t\t}\n+\t    }\n+\n+\t  tree tem = build_range_check (loc, optype, unshare_expr (exp),\n+\t\t\t\t\tfalse, lowi, high);\n+\t  if (tem == NULL_TREE || is_gimple_val (tem))\n+\t    continue;\n+\t  tree etype = unsigned_type_for (TREE_TYPE (exp));\n+\t  exp = fold_build2_loc (loc, MINUS_EXPR, etype,\n+\t\t\t\t fold_convert_loc (loc, etype, exp),\n+\t\t\t\t fold_convert_loc (loc, etype, lowi));\n+\t  exp = fold_convert_loc (loc, integer_type_node, exp);\n+\t  tree word_type = lang_hooks.types.type_for_mode (word_mode, 1);\n+\t  exp = fold_build2_loc (loc, LSHIFT_EXPR, word_type,\n+\t\t\t\t build_int_cst (word_type, 1), exp);\n+\t  exp = fold_build2_loc (loc, BIT_AND_EXPR, word_type, exp,\n+\t\t\t\t wide_int_to_tree (word_type, mask));\n+\t  exp = fold_build2_loc (loc, EQ_EXPR, optype, exp,\n+\t\t\t\t build_zero_cst (word_type));\n+\t  if (is_gimple_val (exp))\n+\t    continue;\n+\n+\t  /* The shift might have undefined behavior if TEM is true,\n+\t     but reassociate_bb isn't prepared to have basic blocks\n+\t     split when it is running.  So, temporarily emit a code\n+\t     with BIT_IOR_EXPR instead of &&, and fix it up in\n+\t     branch_fixup.  */\n+\t  gimple_seq seq;\n+\t  tem = force_gimple_operand (tem, &seq, true, NULL_TREE);\n+\t  gcc_assert (TREE_CODE (tem) == SSA_NAME);\n+\t  gimple_set_visited (SSA_NAME_DEF_STMT (tem), true);\n+\t  gimple_seq seq2;\n+\t  exp = force_gimple_operand (exp, &seq2, true, NULL_TREE);\n+\t  gimple_seq_add_seq_without_update (&seq, seq2);\n+\t  gcc_assert (TREE_CODE (exp) == SSA_NAME);\n+\t  gimple_set_visited (SSA_NAME_DEF_STMT (exp), true);\n+\t  gimple g\n+\t    = gimple_build_assign_with_ops (BIT_IOR_EXPR,\n+\t\t\t\t\t    make_ssa_name (optype, NULL),\n+\t\t\t\t\t    tem, exp);\n+\t  gimple_set_location (g, loc);\n+\t  gimple_seq_add_stmt_without_update (&seq, g);\n+\t  exp = gimple_assign_lhs (g);\n+\t  tree val = build_zero_cst (optype);\n+\t  if (update_range_test (&ranges[i], NULL, candidates.address (),\n+\t\t\t\t candidates.length (), opcode, ops, exp,\n+\t\t\t\t seq, false, val, val, strict_overflow_p))\n+\t    {\n+\t      any_changes = true;\n+\t      reassoc_branch_fixups.safe_push (tem);\n+\t    }\n+\t  else\n+\t    gimple_seq_discard (seq);\n+\t}\n+    }\n+  return any_changes;\n+}\n+\n /* Optimize range tests, similarly how fold_range_test optimizes\n    it on trees.  The tree code for the binary\n    operation between all the operands is OPCODE.\n@@ -2391,9 +2665,9 @@ optimize_range_tests (enum tree_code opcode,\n       if (j == i + 1)\n \tcontinue;\n \n-      if (update_range_test (ranges + i, ranges + i + 1, j - i - 1, opcode,\n-\t\t\t     ops, ranges[i].exp, in_p, low, high,\n-\t\t\t     strict_overflow_p))\n+      if (update_range_test (ranges + i, ranges + i + 1, NULL, j - i - 1,\n+\t\t\t     opcode, ops, ranges[i].exp, NULL, in_p,\n+\t\t\t     low, high, strict_overflow_p))\n \t{\n \t  i = j - 1;\n \t  any_changes = true;\n@@ -2412,6 +2686,9 @@ optimize_range_tests (enum tree_code opcode,\n   if (BRANCH_COST (optimize_function_for_speed_p (cfun), false) >= 2)\n     any_changes |= optimize_range_tests_1 (opcode, first, length, false,\n \t\t\t\t\t   ops, ranges);\n+  if (lshift_cheap_p (optimize_function_for_speed_p (cfun)))\n+    any_changes |= optimize_range_tests_to_bit_test (opcode, first, length,\n+\t\t\t\t\t\t     ops, ranges);\n \n   if (any_changes && opcode != ERROR_MARK)\n     {\n@@ -4581,6 +4858,82 @@ reassociate_bb (basic_block bb)\n     reassociate_bb (son);\n }\n \n+/* Add jumps around shifts for range tests turned into bit tests.\n+   For each SSA_NAME VAR we have code like:\n+   VAR = ...; // final stmt of range comparison\n+   // bit test here...;\n+   OTHERVAR = ...; // final stmt of the bit test sequence\n+   RES = VAR | OTHERVAR;\n+   Turn the above into:\n+   VAR = ...;\n+   if (VAR != 0)\n+     goto <l3>;\n+   else\n+     goto <l2>;\n+   <l2>:\n+   // bit test here...;\n+   OTHERVAR = ...;\n+   <l3>:\n+   # RES = PHI<1(l1), OTHERVAR(l2)>;  */\n+\n+static void\n+branch_fixup (void)\n+{\n+  tree var;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (reassoc_branch_fixups, i, var)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (var);\n+      gimple use_stmt;\n+      use_operand_p use;\n+      bool ok = single_imm_use (var, &use, &use_stmt);\n+      gcc_assert (ok\n+\t\t  && is_gimple_assign (use_stmt)\n+\t\t  && gimple_assign_rhs_code (use_stmt) == BIT_IOR_EXPR\n+\t\t  && gimple_bb (def_stmt) == gimple_bb (use_stmt));\n+\n+      basic_block cond_bb = gimple_bb (def_stmt);\n+      basic_block then_bb = split_block (cond_bb, def_stmt)->dest;\n+      basic_block merge_bb = split_block (then_bb, use_stmt)->dest;\n+\n+      gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);\n+      gimple g = gimple_build_cond (NE_EXPR, var,\n+\t\t\t\t    build_zero_cst (TREE_TYPE (var)),\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+      location_t loc = gimple_location (use_stmt);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+      edge etrue = make_edge (cond_bb, merge_bb, EDGE_TRUE_VALUE);\n+      etrue->probability = REG_BR_PROB_BASE / 2;\n+      etrue->count = cond_bb->count / 2;\n+      edge efalse = find_edge (cond_bb, then_bb);\n+      efalse->flags = EDGE_FALSE_VALUE;\n+      efalse->probability -= etrue->probability;\n+      efalse->count -= etrue->count;\n+      then_bb->count -= etrue->count;\n+\n+      tree othervar = NULL_TREE;\n+      if (gimple_assign_rhs1 (use_stmt) == var)\n+\tothervar = gimple_assign_rhs2 (use_stmt);\n+      else if (gimple_assign_rhs2 (use_stmt) == var)\n+\tothervar = gimple_assign_rhs1 (use_stmt);\n+      else\n+\tgcc_unreachable ();\n+      tree lhs = gimple_assign_lhs (use_stmt);\n+      gimple phi = create_phi_node (lhs, merge_bb);\n+      add_phi_arg (phi, build_one_cst (TREE_TYPE (lhs)), etrue, loc);\n+      add_phi_arg (phi, othervar, single_succ_edge (then_bb), loc);\n+      gsi = gsi_for_stmt (use_stmt);\n+      gsi_remove (&gsi, true);\n+\n+      set_immediate_dominator (CDI_DOMINATORS, merge_bb, cond_bb);\n+      set_immediate_dominator (CDI_POST_DOMINATORS, cond_bb, merge_bb);\n+    }\n+  reassoc_branch_fixups.release ();\n+}\n+\n void dump_ops_vector (FILE *file, vec<operand_entry_t> ops);\n void debug_ops_vector (vec<operand_entry_t> ops);\n \n@@ -4695,6 +5048,7 @@ execute_reassoc (void)\n \n   do_reassoc ();\n   repropagate_negates ();\n+  branch_fixup ();\n \n   fini_reassoc ();\n   return 0;"}, {"sha": "f205129ed1f020a541763e0e82bd8d35d55ed801", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049af5fa62c7eeca27585f8f318e9bea7c47ae/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=73049af5fa62c7eeca27585f8f318e9bea7c47ae", "patch": "@@ -125,35 +125,6 @@ hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n }\n \n \n-/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n-/* FIXME: This is the function that we need rtl.h and optabs.h for.\n-   This function (and similar RTL-related cost code in e.g. IVOPTS) should\n-   be moved to some kind of interface file for GIMPLE/RTL interactions.  */\n-static bool\n-lshift_cheap_p (bool speed_p)\n-{\n-  /* FIXME: This should be made target dependent via this \"this_target\"\n-     mechanism, similar to e.g. can_copy_init_p in gcse.c.  */\n-  static bool init[2] = {false, false};\n-  static bool cheap[2] = {true, true};\n-\n-  /* If the targer has no lshift in word_mode, the operation will most\n-     probably not be cheap.  ??? Does GCC even work for such targets?  */\n-  if (optab_handler (ashl_optab, word_mode) == CODE_FOR_nothing)\n-    return false;\n-\n-  if (!init[speed_p])\n-    {\n-      rtx reg = gen_raw_REG (word_mode, 10000);\n-      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n-\t\t\t       speed_p);\n-      cheap[speed_p] = cost < COSTS_N_INSNS (MAX_CASE_BIT_TESTS);\n-      init[speed_p] = true;\n-    }\n-\n-  return cheap[speed_p];\n-}\n-\n /* Return true if a switch should be expanded as a bit test.\n    RANGE is the difference between highest and lowest case.\n    UNIQ is number of unique case node targets, not counting the default case."}]}