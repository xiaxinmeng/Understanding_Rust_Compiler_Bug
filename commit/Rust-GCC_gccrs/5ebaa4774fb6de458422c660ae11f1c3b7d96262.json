{"sha": "5ebaa4774fb6de458422c660ae11f1c3b7d96262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWViYWE0Nzc0ZmI2ZGU0NTg0MjJjNjYwYWUxMWYxYzNiN2Q5NjI2Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-07T18:40:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-07T18:40:50Z"}, "message": "Use tree_vector_builder instead of build_vector\n\nThis patch switches most build_vector calls over to tree_vector_builder,\nusing explicit encodings where appropriate.  Later patches handle\nthe remaining uses of build_vector.\n\n2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/sparc/sparc.c: Include tree-vector-builder.h.\n\t(sparc_fold_builtin): Use tree_vector_builder instead of build_vector.\n\t* expmed.c: Include tree-vector-builder.h.\n\t(make_tree): Use tree_vector_builder instead of build_vector.\n\t* fold-const.c: Include tree-vector-builder.h.\n\t(const_binop): Use tree_vector_builder instead of build_vector.\n\t(const_unop): Likewise.\n\t(native_interpret_vector): Likewise.\n\t(fold_vec_perm): Likewise.\n\t(fold_ternary_loc): Likewise.\n\t* gimple-fold.c: Include tree-vector-builder.h.\n\t(gimple_fold_stmt_to_constant_1): Use tree_vector_builder instead\n\tof build_vector.\n\t* tree-ssa-forwprop.c: Include tree-vector-builder.h.\n\t(simplify_vector_constructor): Use tree_vector_builder instead\n\tof build_vector.\n\t* tree-vect-generic.c: Include tree-vector-builder.h.\n\t(add_rshift): Use tree_vector_builder instead of build_vector.\n\t(expand_vector_divmod): Likewise.\n\t(optimize_vector_constructor): Likewise.\n\t* tree-vect-loop.c: Include tree-vector-builder.h.\n\t(vect_create_epilog_for_reduction): Use tree_vector_builder instead\n\tof build_vector.  Explicitly use a stepped encoding for\n\t{ 1, 2, 3, ... }.\n\t* tree-vect-slp.c: Include tree-vector-builder.h.\n\t(vect_get_constant_vectors): Use tree_vector_builder instead\n\tof build_vector.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Likewise.\n\t* tree-vect-stmts.c: Include tree-vector-builder.h.\n\t(vectorizable_bswap): Use tree_vector_builder instead of build_vector.\n\t(vect_gen_perm_mask_any): Likewise.\n\t(vectorizable_call): Likewise.  Explicitly use a stepped encoding.\n\t* tree.c: (build_vector_from_ctor): Use tree_vector_builder instead\n\tof build_vector.\n\t(build_vector_from_val): Likewise.  Explicitly use a duplicate\n\tencoding.\n\nFrom-SVN: r255475", "tree": {"sha": "7f5cb9043bbc4cb3bbc2359234b0e6bd0eb216f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f5cb9043bbc4cb3bbc2359234b0e6bd0eb216f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ebaa4774fb6de458422c660ae11f1c3b7d96262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebaa4774fb6de458422c660ae11f1c3b7d96262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ebaa4774fb6de458422c660ae11f1c3b7d96262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebaa4774fb6de458422c660ae11f1c3b7d96262/comments", "author": null, "committer": null, "parents": [{"sha": "734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/734914b6e230b78eb6c34fbd5a2d93b1a919d36a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/734914b6e230b78eb6c34fbd5a2d93b1a919d36a"}], "stats": {"total": 177, "additions": 112, "deletions": 65}, "files": [{"sha": "f0fca0eba15ca48d30398ac25ff6b353c38311a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -1,3 +1,43 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/sparc/sparc.c: Include tree-vector-builder.h.\n+\t(sparc_fold_builtin): Use tree_vector_builder instead of build_vector.\n+\t* expmed.c: Include tree-vector-builder.h.\n+\t(make_tree): Use tree_vector_builder instead of build_vector.\n+\t* fold-const.c: Include tree-vector-builder.h.\n+\t(const_binop): Use tree_vector_builder instead of build_vector.\n+\t(const_unop): Likewise.\n+\t(native_interpret_vector): Likewise.\n+\t(fold_vec_perm): Likewise.\n+\t(fold_ternary_loc): Likewise.\n+\t* gimple-fold.c: Include tree-vector-builder.h.\n+\t(gimple_fold_stmt_to_constant_1): Use tree_vector_builder instead\n+\tof build_vector.\n+\t* tree-ssa-forwprop.c: Include tree-vector-builder.h.\n+\t(simplify_vector_constructor): Use tree_vector_builder instead\n+\tof build_vector.\n+\t* tree-vect-generic.c: Include tree-vector-builder.h.\n+\t(add_rshift): Use tree_vector_builder instead of build_vector.\n+\t(expand_vector_divmod): Likewise.\n+\t(optimize_vector_constructor): Likewise.\n+\t* tree-vect-loop.c: Include tree-vector-builder.h.\n+\t(vect_create_epilog_for_reduction): Use tree_vector_builder instead\n+\tof build_vector.  Explicitly use a stepped encoding for\n+\t{ 1, 2, 3, ... }.\n+\t* tree-vect-slp.c: Include tree-vector-builder.h.\n+\t(vect_get_constant_vectors): Use tree_vector_builder instead\n+\tof build_vector.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t(vect_schedule_slp_instance): Likewise.\n+\t* tree-vect-stmts.c: Include tree-vector-builder.h.\n+\t(vectorizable_bswap): Use tree_vector_builder instead of build_vector.\n+\t(vect_gen_perm_mask_any): Likewise.\n+\t(vectorizable_call): Likewise.  Explicitly use a stepped encoding.\n+\t* tree.c: (build_vector_from_ctor): Use tree_vector_builder instead\n+\tof build_vector.\n+\t(build_vector_from_val): Likewise.  Explicitly use a duplicate\n+\tencoding.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* doc/generic.texi (VECTOR_CST): Describe new representation of"}, {"sha": "a8d363ce571dc7cf5d7beb09556d8d77044d394b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"context.h\"\n #include \"builtins.h\"\n+#include \"tree-vector-builder.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -11752,14 +11753,14 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \t  tree inner_type = TREE_TYPE (rtype);\n \t  unsigned i;\n \n-\t  auto_vec<tree, 32> n_elts (VECTOR_CST_NELTS (arg0));\n+\t  tree_vector_builder n_elts (rtype, VECTOR_CST_NELTS (arg0), 1);\n \t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n \t      unsigned HOST_WIDE_INT val\n \t\t= TREE_INT_CST_LOW (VECTOR_CST_ELT (arg0, i));\n \t      n_elts.quick_push (build_int_cst (inner_type, val << 4));\n \t    }\n-\t  return build_vector (rtype, n_elts);\n+\t  return n_elts.build ();\n \t}\n       break;\n \n@@ -11774,9 +11775,9 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n       if (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n \t{\n \t  tree inner_type = TREE_TYPE (rtype);\n-\t  auto_vec<tree, 32> n_elts (VECTOR_CST_NELTS (arg0));\n+\t  tree_vector_builder n_elts (rtype, VECTOR_CST_NELTS (arg0), 1);\n \t  sparc_handle_vis_mul8x16 (&n_elts, code, inner_type, arg0, arg1);\n-\t  return build_vector (rtype, n_elts);\n+\t  return n_elts.build ();\n \t}\n       break;\n \n@@ -11788,15 +11789,15 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \n       if (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n \t{\n-\t  auto_vec<tree, 32> n_elts (2 * VECTOR_CST_NELTS (arg0));\n+\t  tree_vector_builder n_elts (rtype, 2 * VECTOR_CST_NELTS (arg0), 1);\n \t  unsigned i;\n \t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n \t      n_elts.quick_push (VECTOR_CST_ELT (arg0, i));\n \t      n_elts.quick_push (VECTOR_CST_ELT (arg1, i));\n \t    }\n \n-\t  return build_vector (rtype, n_elts);\n+\t  return n_elts.build ();\n \t}\n       break;\n "}, {"sha": "f072a9437554307407b626b16bbc8982d4c5c521", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"explow.h\"\n #include \"expr.h\"\n #include \"langhooks.h\"\n+#include \"tree-vector-builder.h\"\n \n struct target_expmed default_target_expmed;\n #if SWITCHABLE_TARGET\n@@ -5184,14 +5185,14 @@ make_tree (tree type, rtx x)\n \tint i;\n \n \t/* Build a tree with vector elements.  */\n-\tauto_vec<tree, 32> elts (units);\n+\ttree_vector_builder elts (type, units, 1);\n \tfor (i = 0; i < units; ++i)\n \t  {\n \t    rtx elt = CONST_VECTOR_ELT (x, i);\n \t    elts.quick_push (make_tree (itype, elt));\n \t  }\n \n-\treturn build_vector (type, elts);\n+\treturn elts.build ();\n       }\n \n     case PLUS:"}, {"sha": "87f07bf16c0281e6b0ec617c4697b8fb9743bab6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"tree-vector-builder.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n@@ -1507,7 +1508,7 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \tgcc_assert (in_nelts == VECTOR_CST_NELTS (arg2)\n \t\t    && out_nelts == TYPE_VECTOR_SUBPARTS (type));\n \n-\tauto_vec<tree, 32> elts (out_nelts);\n+\ttree_vector_builder elts (type, out_nelts, 1);\n \tfor (i = 0; i < out_nelts; i++)\n \t  {\n \t    tree elt = (i < in_nelts\n@@ -1521,7 +1522,7 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \t    elts.quick_push (elt);\n \t  }\n \n-\treturn build_vector (type, elts);\n+\treturn elts.build ();\n       }\n \n     case VEC_WIDEN_MULT_LO_EXPR:\n@@ -1548,7 +1549,7 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \telse /* if (code == VEC_WIDEN_MULT_ODD_EXPR) */\n \t  scale = 1, ofs = 1;\n \n-\tauto_vec<tree, 32> elts (out_nelts);\n+\ttree_vector_builder elts (type, out_nelts, 1);\n \tfor (out = 0; out < out_nelts; out++)\n \t  {\n \t    unsigned int in = (out << scale) + ofs;\n@@ -1565,7 +1566,7 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \t    elts.quick_push (elt);\n \t  }\n \n-\treturn build_vector (type, elts);\n+\treturn elts.build ();\n       }\n \n     default:;\n@@ -1704,7 +1705,7 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \telse\n \t  subcode = FLOAT_EXPR;\n \n-\tauto_vec<tree, 32> elts (out_nelts);\n+\ttree_vector_builder elts (type, out_nelts, 1);\n \tfor (i = 0; i < out_nelts; i++)\n \t  {\n \t    tree elt = fold_convert_const (subcode, TREE_TYPE (type),\n@@ -1714,7 +1715,7 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \t    elts.quick_push (elt);\n \t  }\n \n-\treturn build_vector (type, elts);\n+\treturn elts.build ();\n       }\n \n     default:\n@@ -7377,15 +7378,15 @@ native_interpret_vector (tree type, const unsigned char *ptr, int len)\n   if (size * count > len)\n     return NULL_TREE;\n \n-  auto_vec<tree, 32> elements (count);\n+  tree_vector_builder elements (type, count, 1);\n   for (i = 0; i < count; ++i)\n     {\n       elem = native_interpret_expr (etype, ptr+(i*size), size);\n       if (!elem)\n \treturn NULL_TREE;\n       elements.quick_push (elem);\n     }\n-  return build_vector (type, elements);\n+  return elements.build ();\n }\n \n \n@@ -8755,7 +8756,7 @@ fold_vec_perm (tree type, tree arg0, tree arg1, vec_perm_indices sel)\n       || !vec_cst_ctor_to_array (arg1, nelts, in_elts + nelts))\n     return NULL_TREE;\n \n-  auto_vec<tree, 32> out_elts (nelts);\n+  tree_vector_builder out_elts (type, nelts, 1);\n   for (i = 0; i < nelts; i++)\n     {\n       if (!CONSTANT_CLASS_P (in_elts[sel[i]]))\n@@ -8772,7 +8773,7 @@ fold_vec_perm (tree type, tree arg0, tree arg1, vec_perm_indices sel)\n       return build_constructor (type, v);\n     }\n   else\n-    return build_vector (type, out_elts);\n+    return out_elts.build ();\n }\n \n /* Try to fold a pointer difference of type TYPE two address expressions of\n@@ -11426,10 +11427,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t  if (n == 1)\n \t\t    return VECTOR_CST_ELT (arg0, idx);\n \n-\t\t  auto_vec<tree, 32> vals (n);\n+\t\t  tree_vector_builder vals (type, n, 1);\n \t\t  for (unsigned i = 0; i < n; ++i)\n \t\t    vals.quick_push (VECTOR_CST_ELT (arg0, idx + i));\n-\t\t  return build_vector (type, vals);\n+\t\t  return vals.build ();\n \t\t}\n \t    }\n \t}\n@@ -11565,10 +11566,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  if (need_mask_canon && arg2 == op2)\n \t    {\n \t      tree eltype = TREE_TYPE (TREE_TYPE (arg2));\n-\t      auto_vec<tree, 32> tsel (nelts);\n+\t      tree_vector_builder tsel (TREE_TYPE (arg2), nelts, 1);\n \t      for (i = 0; i < nelts; i++)\n \t\ttsel.quick_push (build_int_cst (eltype, sel[i]));\n-\t      op2 = build_vector (TREE_TYPE (arg2), tsel);\n+\t      op2 = tsel.build ();\n \t      changed = true;\n \t    }\n \n@@ -11608,11 +11609,11 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t      else\n \t\t{\n \t\t  unsigned int nelts = VECTOR_CST_NELTS (arg0);\n-\t\t  auto_vec<tree, 32> elts (nelts);\n+\t\t  tree_vector_builder elts (type, nelts, 1);\n \t\t  elts.quick_grow (nelts);\n-\t\t  for (unsigned int i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n+\t\t  for (unsigned int i = 0; i < nelts; ++i)\n \t\t    elts[i] = (i == k ? arg1 : VECTOR_CST_ELT (arg0, i));\n-\t\t  return build_vector (type, elts);\n+\t\t  return elts.build ();\n \t\t}\n \t    }\n \t}"}, {"sha": "6044092412cb0ccb761a39e7e733359e259d1b04", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"intl.h\"\n #include \"calls.h\"\n+#include \"tree-vector-builder.h\"\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -6022,7 +6023,7 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t\t  tree val;\n \n \t\t  nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs));\n-\t\t  auto_vec<tree, 32> vec (nelts);\n+\t\t  tree_vector_builder vec (TREE_TYPE (rhs), nelts, 1);\n \t\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n \t\t    {\n \t\t      val = (*valueize) (val);\n@@ -6034,7 +6035,7 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t\t\treturn NULL_TREE;\n \t\t    }\n \n-\t\t  return build_vector (TREE_TYPE (rhs), vec);\n+\t\t  return vec.build ();\n \t\t}\n \t      if (subcode == OBJ_TYPE_REF)\n \t\t{"}, {"sha": "1fabcda38a2e3df4a9388f3bca2121dd6e21a8af", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"cfganal.h\"\n #include \"optabs-tree.h\"\n+#include \"tree-vector-builder.h\"\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized\n@@ -2116,10 +2117,10 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t  || GET_MODE_SIZE (TYPE_MODE (mask_type))\n \t     != GET_MODE_SIZE (TYPE_MODE (type)))\n \treturn false;\n-      auto_vec<tree, 32> mask_elts (nelts);\n+      tree_vector_builder mask_elts (mask_type, nelts, 1);\n       for (i = 0; i < nelts; i++)\n \tmask_elts.quick_push (build_int_cst (TREE_TYPE (mask_type), sel[i]));\n-      op2 = build_vector (mask_type, mask_elts);\n+      op2 = mask_elts.build ();\n       if (conv_code == ERROR_MARK)\n \tgimple_assign_set_rhs_with_ops (gsi, VEC_PERM_EXPR, orig, orig, op2);\n       else"}, {"sha": "aa5542d5dc69b6dc5cbcb0d15dce234047ec972b", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify-me.h\"\n #include \"gimplify.h\"\n #include \"tree-cfg.h\"\n+#include \"tree-vector-builder.h\"\n \n \n static void expand_vector_operations_1 (gimple_stmt_iterator *);\n@@ -398,11 +399,10 @@ add_rshift (gimple_stmt_iterator *gsi, tree type, tree op0, int *shiftcnts)\n   if (op != unknown_optab\n       && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n     {\n-      auto_vec<tree, 32> vec (nunits);\n+      tree_vector_builder vec (type, nunits, 1);\n       for (i = 0; i < nunits; i++)\n \tvec.quick_push (build_int_cst (TREE_TYPE (type), shiftcnts[i]));\n-      return gimplify_build2 (gsi, RSHIFT_EXPR, type, op0,\n-\t\t\t      build_vector (type, vec));\n+      return gimplify_build2 (gsi, RSHIFT_EXPR, type, op0, vec.build ());\n     }\n \n   return NULL_TREE;\n@@ -635,12 +635,12 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t      mask_type = build_same_sized_truth_vector_type (type);\n \t      zero = build_zero_cst (type);\n \t      cond = build2 (LT_EXPR, mask_type, op0, zero);\n-\t      auto_vec<tree, 32> vec (nunits);\n+\t      tree_vector_builder vec (type, nunits, 1);\n \t      for (i = 0; i < nunits; i++)\n \t\tvec.quick_push (build_int_cst (TREE_TYPE (type),\n \t\t\t\t\t       (HOST_WIDE_INT_1U\n \t\t\t\t\t\t<< shifts[i]) - 1));\n-\t      cst = build_vector (type, vec);\n+\t      cst = vec.build ();\n \t      addend = make_ssa_name (type);\n \t      stmt = gimple_build_assign (addend, VEC_COND_EXPR, cond,\n \t\t\t\t\t  cst, zero);\n@@ -674,12 +674,12 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n       else\n \t{\n \t  tree mask;\n-\t  auto_vec<tree, 32> vec (nunits);\n+\t  tree_vector_builder vec (type, nunits, 1);\n \t  for (i = 0; i < nunits; i++)\n \t    vec.quick_push (build_int_cst (TREE_TYPE (type),\n \t\t\t\t\t   (HOST_WIDE_INT_1U\n \t\t\t\t\t    << shifts[i]) - 1));\n-\t  mask = build_vector (type, vec);\n+\t  mask = vec.build ();\n \t  op = optab_for_tree_code (BIT_AND_EXPR, type, optab_default);\n \t  if (op != unknown_optab\n \t      && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n@@ -753,10 +753,10 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n       return NULL_TREE;\n     }\n \n-  auto_vec<tree, 32> vec (nunits);\n+  tree_vector_builder vec (type, nunits, 1);\n   for (i = 0; i < nunits; i++)\n     vec.quick_push (build_int_cst (TREE_TYPE (type), mulc[i]));\n-  mulcst = build_vector (type, vec);\n+  mulcst = vec.build ();\n \n   cur_op = gimplify_build2 (gsi, MULT_HIGHPART_EXPR, type, cur_op, mulcst);\n \n@@ -1104,7 +1104,7 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n       }\n   if (all_same)\n     return;\n-  auto_vec<tree, 32> cst (nelts);\n+  tree_vector_builder cst (type, nelts, 1);\n   for (i = 0; i < nelts; i++)\n     {\n       tree this_base = CONSTRUCTOR_ELT (rhs, i)->value;\n@@ -1127,7 +1127,7 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n   g = gimple_build_assign (make_ssa_name (type), rhs);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n   g = gimple_build_assign (lhs, PLUS_EXPR, gimple_assign_lhs (g),\n-\t\t\t   build_vector (type, cst));\n+\t\t\t   cst.build ());\n   gsi_replace (gsi, g, false);\n }\n \f"}, {"sha": "566e2a6c3e72f7e0b54b2e31c798eaddd1edc2ed", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"tree-if-conv.h\"\n #include \"internal-fn.h\"\n+#include \"tree-vector-builder.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -4507,10 +4508,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t vector size (STEP).  */\n \n       /* Create a {1,2,3,...} vector.  */\n-      auto_vec<tree, 32> vtemp (nunits_out);\n-      for (k = 0; k < nunits_out; ++k)\n+      tree_vector_builder vtemp (cr_index_vector_type, 1, 3);\n+      for (k = 0; k < 3; ++k)\n \tvtemp.quick_push (build_int_cst (cr_index_scalar_type, k + 1));\n-      tree series_vect = build_vector (cr_index_vector_type, vtemp);\n+      tree series_vect = vtemp.build ();\n \n       /* Create a vector of the step value.  */\n       tree step = build_int_cst (cr_index_scalar_type, nunits_out);"}, {"sha": "0ca42b4d12d6643f22545d6b33f2ad4c7ef6ce86", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"gimple-walk.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-vector-builder.h\"\n \n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n@@ -3222,7 +3223,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \n   number_of_places_left_in_vector = nunits;\n   constant_p = true;\n-  auto_vec<tree, 32> elts (nunits);\n+  tree_vector_builder elts (vector_type, nunits, 1);\n   elts.quick_grow (nunits);\n   bool place_after_defs = false;\n   for (j = 0; j < number_of_copies; j++)\n@@ -3340,7 +3341,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n           if (number_of_places_left_in_vector == 0)\n             {\n \t      if (constant_p)\n-\t\tvec_cst = build_vector (vector_type, elts);\n+\t\tvec_cst = elts.build ();\n \t      else\n \t\t{\n \t\t  vec<constructor_elt, va_gc> *v;\n@@ -3371,6 +3372,8 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t      place_after_defs = false;\n               number_of_places_left_in_vector = nunits;\n \t      constant_p = true;\n+\t      elts.new_vector (vector_type, nunits, 1);\n+\t      elts.quick_grow (nunits);\n             }\n         }\n     }\n@@ -3667,11 +3670,11 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t  \n \t\t  if (! noop_p)\n \t\t    {\n-\t\t      auto_vec<tree, 32> mask_elts (nunits);\n+\t\t      tree_vector_builder mask_elts (mask_type, nunits, 1);\n \t\t      for (int l = 0; l < nunits; ++l)\n \t\t\tmask_elts.quick_push (build_int_cst (mask_element_type,\n \t\t\t\t\t\t\t     mask[l]));\n-\t\t      mask_vec = build_vector (mask_type, mask_elts);\n+\t\t      mask_vec = mask_elts.build ();\n \t\t    }\n \n \t\t  if (second_vec_index == -1)\n@@ -3823,15 +3826,15 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t  for (j = 0; j < v0.length (); ++j)\n \t    {\n \t      unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\t      auto_vec<tree, 32> melts (nunits);\n+\t      tree_vector_builder melts (mvectype, nunits, 1);\n \t      for (l = 0; l < nunits; ++l)\n \t\t{\n \t\t  if (k >= group_size)\n \t\t    k = 0;\n \t\t  tree t = build_int_cst (meltype, mask[k++] * nunits + l);\n \t\t  melts.quick_push (t);\n \t\t}\n-\t      tmask = build_vector (mvectype, melts);\n+\t      tmask = melts.build ();\n \n \t      /* ???  Not all targets support a VEC_PERM_EXPR with a\n \t         constant mask that would translate to a vec_merge RTX"}, {"sha": "ee2f1ca1ccdb279c573b2e361fb4ce2350d59e14", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"builtins.h\"\n #include \"internal-fn.h\"\n+#include \"tree-vector-builder.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -2520,10 +2521,10 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n       return true;\n     }\n \n-  auto_vec<tree, 32> telts (num_bytes);\n+  tree_vector_builder telts (char_vectype, num_bytes, 1);\n   for (unsigned i = 0; i < num_bytes; ++i)\n     telts.quick_push (build_int_cst (char_type_node, elts[i]));\n-  tree bswap_vconst = build_vector (char_vectype, telts);\n+  tree bswap_vconst = telts.build ();\n \n   /* Transform.  */\n   vec<tree> vec_oprnds = vNULL;\n@@ -2941,11 +2942,11 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  if (gimple_call_internal_p (stmt)\n \t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n \t    {\n-\t      auto_vec<tree, 32> v (nunits_out);\n-\t      for (int k = 0; k < nunits_out; ++k)\n+\t      tree_vector_builder v (vectype_out, 1, 3);\n+\t      for (int k = 0; k < 3; ++k)\n \t\tv.quick_push (build_int_cst (unsigned_type_node,\n \t\t\t\t\t     j * nunits_out + k));\n-\t      tree cst = build_vector (vectype_out, v);\n+\t      tree cst = v.build ();\n \t      tree new_var\n \t\t= vect_get_new_ssa_name (vectype_out, vect_simple_var, \"cst_\");\n \t      gimple *init_stmt = gimple_build_assign (new_var, cst);\n@@ -6507,7 +6508,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n tree\n vect_gen_perm_mask_any (tree vectype, vec_perm_indices sel)\n {\n-  tree mask_elt_type, mask_type, mask_vec;\n+  tree mask_elt_type, mask_type;\n \n   unsigned int nunits = sel.length ();\n   gcc_checking_assert (nunits == TYPE_VECTOR_SUBPARTS (vectype));\n@@ -6516,12 +6517,10 @@ vect_gen_perm_mask_any (tree vectype, vec_perm_indices sel)\n     (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_elt_type);\n \n-  auto_vec<tree, 32> mask_elts (nunits);\n+  tree_vector_builder mask_elts (mask_type, nunits, 1);\n   for (unsigned int i = 0; i < nunits; ++i)\n     mask_elts.quick_push (build_int_cst (mask_elt_type, sel[i]));\n-  mask_vec = build_vector (mask_type, mask_elts);\n-\n-  return mask_vec;\n+  return mask_elts.build ();\n }\n \n /* Checked version of vect_gen_perm_mask_any.  Asserts can_vec_perm_p,"}, {"sha": "e696d03ac06450e4ba71eae78a485e4f4fbfc9d6", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebaa4774fb6de458422c660ae11f1c3b7d96262/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5ebaa4774fb6de458422c660ae11f1c3b7d96262", "patch": "@@ -1757,7 +1757,7 @@ build_vector_from_ctor (tree type, vec<constructor_elt, va_gc> *v)\n   unsigned HOST_WIDE_INT idx;\n   tree value;\n \n-  auto_vec<tree, 32> vec (nelts);\n+  tree_vector_builder vec (type, nelts, 1);\n   FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n     {\n       if (TREE_CODE (value) == VECTOR_CST)\n@@ -1769,7 +1769,7 @@ build_vector_from_ctor (tree type, vec<constructor_elt, va_gc> *v)\n   while (vec.length () < nelts)\n     vec.quick_push (build_zero_cst (TREE_TYPE (type)));\n \n-  return build_vector (type, vec);\n+  return vec.build ();\n }\n \n /* Build a vector of type VECTYPE where all the elements are SCs.  */\n@@ -1792,10 +1792,9 @@ build_vector_from_val (tree vectype, tree sc)\n \n   if (CONSTANT_CLASS_P (sc))\n     {\n-      auto_vec<tree, 32> v (nunits);\n-      for (i = 0; i < nunits; ++i)\n-\tv.quick_push (sc);\n-      return build_vector (vectype, v);\n+      tree_vector_builder v (vectype, 1, 1);\n+      v.quick_push (sc);\n+      return v.build ();\n     }\n   else\n     {"}]}