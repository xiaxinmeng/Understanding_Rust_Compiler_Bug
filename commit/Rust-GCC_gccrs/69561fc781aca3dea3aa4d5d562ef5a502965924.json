{"sha": "69561fc781aca3dea3aa4d5d562ef5a502965924", "node_id": "C_kwDOANBUbNoAKDY5NTYxZmM3ODFhY2EzZGVhM2FhNGQ1ZDU2MmVmNWE1MDI5NjU5MjQ", "commit": {"author": {"name": "Hafiz Abid Qadeer", "email": "abidh@codesourcery.com", "date": "2021-09-24T09:04:12Z"}, "committer": {"name": "Hafiz Abid Qadeer", "email": "abidh@codesourcery.com", "date": "2022-01-13T18:57:05Z"}, "message": "Add support for allocate clause (OpenMP 5.0).\n\nThis patch adds support for OpenMP 5.0 allocate clause for fortran. It does not\nyet support the allocator-modifier as specified in OpenMP 5.1. The allocate\nclause is already supported in C/C++.\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.c (show_omp_clauses): Handle OMP_LIST_ALLOCATE.\n\t* gfortran.h (OMP_LIST_ALLOCATE): New enum value.\n\t* openmp.c (enum omp_mask1): Add OMP_CLAUSE_ALLOCATE.\n\t(gfc_match_omp_clauses): Handle OMP_CLAUSE_ALLOCATE\n\t(OMP_PARALLEL_CLAUSES, OMP_DO_CLAUSES, OMP_SECTIONS_CLAUSES)\n\t(OMP_TASK_CLAUSES, OMP_TASKLOOP_CLAUSES, OMP_TARGET_CLAUSES)\n\t(OMP_TEAMS_CLAUSES, OMP_DISTRIBUTE_CLAUSES)\n\t(OMP_SINGLE_CLAUSES): Add OMP_CLAUSE_ALLOCATE.\n\t(OMP_TASKGROUP_CLAUSES): New.\n\t(gfc_match_omp_taskgroup): Use OMP_TASKGROUP_CLAUSES instead of\n\tOMP_CLAUSE_TASK_REDUCTION.\n\t(resolve_omp_clauses): Handle OMP_LIST_ALLOCATE.\n\t(resolve_omp_do): Avoid warning when loop iteration variable is\n\tin allocate clause.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Handle translation of\n\tallocate clause.\n\t(gfc_split_omp_clauses): Update for OMP_LIST_ALLOCATE.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/allocate-1.f90: New test.\n\t* gfortran.dg/gomp/allocate-2.f90: New test.\n\t* gfortran.dg/gomp/allocate-3.f90: New test.\n\t* gfortran.dg/gomp/collapse1.f90: Update error message.\n\t* gfortran.dg/gomp/openmp-simd-4.f90: Likewise.\n\t* gfortran.dg/gomp/clauses-1.f90: Uncomment allocate clause.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/allocate-1.c: New test.\n\t* testsuite/libgomp.fortran/allocate-1.f90: New test.\n\t* libgomp.texi: Remove string that says that allocate clause\n\tsupport is for C/C++ only.", "tree": {"sha": "9b7da04bfacf5d26db78c8b30c07e297ced8d20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b7da04bfacf5d26db78c8b30c07e297ced8d20a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69561fc781aca3dea3aa4d5d562ef5a502965924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69561fc781aca3dea3aa4d5d562ef5a502965924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69561fc781aca3dea3aa4d5d562ef5a502965924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69561fc781aca3dea3aa4d5d562ef5a502965924/comments", "author": {"login": "abidh", "id": 4067533, "node_id": "MDQ6VXNlcjQwNjc1MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4067533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abidh", "html_url": "https://github.com/abidh", "followers_url": "https://api.github.com/users/abidh/followers", "following_url": "https://api.github.com/users/abidh/following{/other_user}", "gists_url": "https://api.github.com/users/abidh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abidh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abidh/subscriptions", "organizations_url": "https://api.github.com/users/abidh/orgs", "repos_url": "https://api.github.com/users/abidh/repos", "events_url": "https://api.github.com/users/abidh/events{/privacy}", "received_events_url": "https://api.github.com/users/abidh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abidh", "id": 4067533, "node_id": "MDQ6VXNlcjQwNjc1MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4067533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abidh", "html_url": "https://github.com/abidh", "followers_url": "https://api.github.com/users/abidh/followers", "following_url": "https://api.github.com/users/abidh/following{/other_user}", "gists_url": "https://api.github.com/users/abidh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abidh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abidh/subscriptions", "organizations_url": "https://api.github.com/users/abidh/orgs", "repos_url": "https://api.github.com/users/abidh/repos", "events_url": "https://api.github.com/users/abidh/events{/privacy}", "received_events_url": "https://api.github.com/users/abidh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d5fb4feee831868d80fff4d024c271911c92ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d5fb4feee831868d80fff4d024c271911c92ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d5fb4feee831868d80fff4d024c271911c92ca"}], "stats": {"total": 1054, "additions": 896, "deletions": 158}, "files": [{"sha": "a618ae20d305af548878bb491048450ba3839f7f", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -1685,6 +1685,7 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \t  case OMP_LIST_USE_DEVICE_PTR: type = \"USE_DEVICE_PTR\"; break;\n \t  case OMP_LIST_USE_DEVICE_ADDR: type = \"USE_DEVICE_ADDR\"; break;\n \t  case OMP_LIST_NONTEMPORAL: type = \"NONTEMPORAL\"; break;\n+\t  case OMP_LIST_ALLOCATE: type = \"ALLOCATE\"; break;\n \t  case OMP_LIST_SCAN_IN: type = \"INCLUSIVE\"; break;\n \t  case OMP_LIST_SCAN_EX: type = \"EXCLUSIVE\"; break;\n \t  default:"}, {"sha": "26a15b15cc659aae8557d6e4577305b0bd64c7eb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -1392,6 +1392,7 @@ enum\n   OMP_LIST_USE_DEVICE_PTR,\n   OMP_LIST_USE_DEVICE_ADDR,\n   OMP_LIST_NONTEMPORAL,\n+  OMP_LIST_ALLOCATE,\n   OMP_LIST_NUM\n };\n "}, {"sha": "a204323f8838efb93a0f28d119e490ae2a0a4430", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 130, "deletions": 17, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -912,6 +912,7 @@ enum omp_mask1\n   OMP_CLAUSE_MEMORDER,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_DETACH,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_AFFINITY,  /* OpenMP 5.0.  */\n+  OMP_CLAUSE_ALLOCATE,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_BIND,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_FILTER,  /* OpenMP 5.1.  */\n   OMP_CLAUSE_AT,  /* OpenMP 5.1.  */\n@@ -1549,6 +1550,40 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t}\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_ALLOCATE)\n+\t      && gfc_match (\"allocate ( \") == MATCH_YES)\n+\t    {\n+\t      gfc_expr *allocator = NULL;\n+\t      old_loc = gfc_current_locus;\n+\t      m = gfc_match_expr (&allocator);\n+\t      if (m == MATCH_YES && gfc_match (\" : \") != MATCH_YES)\n+\t\t{\n+\t\t  /* If no \":\" then there is no allocator, we backtrack\n+\t\t     and read the variable list.  */\n+\t\t  gfc_free_expr (allocator);\n+\t\t  allocator = NULL;\n+\t\t  gfc_current_locus = old_loc;\n+\t\t}\n+\n+\t      gfc_omp_namelist **head = NULL;\n+\t      m = gfc_match_omp_variable_list (\"\", &c->lists[OMP_LIST_ALLOCATE],\n+\t\t\t\t\t       true, NULL, &head);\n+\n+\t      if (m != MATCH_YES)\n+\t\t{\n+\t\t  gfc_free_expr (allocator);\n+\t\t  gfc_error (\"Expected variable list at %C\");\n+\t\t  goto error;\n+\t\t}\n+\n+\t      for (gfc_omp_namelist *n = *head; n; n = n->next)\n+\t\tif (allocator)\n+\t\t  n->expr = gfc_copy_expr (allocator);\n+\t\telse\n+\t\t  n->expr = NULL;\n+\t      gfc_free_expr (allocator);\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_AT)\n \t      && (m = gfc_match_dupl_check (c->at == OMP_AT_UNSET, \"at\", true))\n \t\t != MATCH_NO)\n@@ -3572,7 +3607,7 @@ gfc_match_oacc_routine (void)\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_SHARED | OMP_CLAUSE_COPYIN | OMP_CLAUSE_REDUCTION\t\\\n    | OMP_CLAUSE_IF | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT\t\\\n-   | OMP_CLAUSE_PROC_BIND)\n+   | OMP_CLAUSE_PROC_BIND | OMP_CLAUSE_ALLOCATE)\n #define OMP_DECLARE_SIMD_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_SIMDLEN) | OMP_CLAUSE_LINEAR\t\t\t\\\n    | OMP_CLAUSE_UNIFORM\t| OMP_CLAUSE_ALIGNED | OMP_CLAUSE_INBRANCH\t\\\n@@ -3581,15 +3616,16 @@ gfc_match_oacc_routine (void)\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\t\t\\\n    | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED | OMP_CLAUSE_COLLAPSE\t\\\n-   | OMP_CLAUSE_LINEAR | OMP_CLAUSE_ORDER)\n+   | OMP_CLAUSE_LINEAR | OMP_CLAUSE_ORDER | OMP_CLAUSE_ALLOCATE)\n #define OMP_LOOP_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_BIND) | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_ORDER\t\\\n    | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n+\n #define OMP_SCOPE_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_REDUCTION)\n #define OMP_SECTIONS_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n-   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n+   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_ALLOCATE)\n #define OMP_SIMD_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_LASTPRIVATE\t\t\\\n    | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_SAFELEN\t\\\n@@ -3600,20 +3636,22 @@ gfc_match_oacc_routine (void)\n    | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT\t\t\\\n    | OMP_CLAUSE_UNTIED | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE\t\\\n    | OMP_CLAUSE_DEPEND | OMP_CLAUSE_PRIORITY | OMP_CLAUSE_IN_REDUCTION\t\\\n-   | OMP_CLAUSE_DETACH | OMP_CLAUSE_AFFINITY)\n+   | OMP_CLAUSE_DETACH | OMP_CLAUSE_AFFINITY | OMP_CLAUSE_ALLOCATE)\n #define OMP_TASKLOOP_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF\t\t\\\n    | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED | OMP_CLAUSE_FINAL\t\t\\\n    | OMP_CLAUSE_MERGEABLE | OMP_CLAUSE_PRIORITY | OMP_CLAUSE_GRAINSIZE\t\\\n    | OMP_CLAUSE_NUM_TASKS | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_NOGROUP\t\\\n-   | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_IN_REDUCTION)\n+   | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_IN_REDUCTION | OMP_CLAUSE_ALLOCATE)\n+#define OMP_TASKGROUP_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_TASK_REDUCTION) | OMP_CLAUSE_ALLOCATE)\n #define OMP_TARGET_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n    | OMP_CLAUSE_DEPEND | OMP_CLAUSE_NOWAIT | OMP_CLAUSE_PRIVATE\t\t\\\n    | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_DEFAULTMAP\t\t\t\\\n    | OMP_CLAUSE_IS_DEVICE_PTR | OMP_CLAUSE_IN_REDUCTION\t\t\t\\\n-   | OMP_CLAUSE_THREAD_LIMIT)\n+   | OMP_CLAUSE_THREAD_LIMIT | OMP_CLAUSE_ALLOCATE)\n #define OMP_TARGET_DATA_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_DEVICE) | OMP_CLAUSE_MAP | OMP_CLAUSE_IF\t\\\n    | OMP_CLAUSE_USE_DEVICE_PTR | OMP_CLAUSE_USE_DEVICE_ADDR)\n@@ -3629,13 +3667,14 @@ gfc_match_oacc_routine (void)\n #define OMP_TEAMS_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_NUM_TEAMS) | OMP_CLAUSE_THREAD_LIMIT\t\t\\\n    | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\\\n-   | OMP_CLAUSE_SHARED | OMP_CLAUSE_REDUCTION)\n+   | OMP_CLAUSE_SHARED | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_ALLOCATE)\n #define OMP_DISTRIBUTE_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_DIST_SCHEDULE \\\n-   | OMP_CLAUSE_ORDER)\n+   | OMP_CLAUSE_ORDER | OMP_CLAUSE_ALLOCATE)\n #define OMP_SINGLE_CLAUSES \\\n-  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE)\n+  (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n+   | OMP_CLAUSE_ALLOCATE)\n #define OMP_ORDERED_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_THREADS) | OMP_CLAUSE_SIMD)\n #define OMP_DECLARE_TARGET_CLAUSES \\\n@@ -5905,7 +5944,7 @@ gfc_match_omp_barrier (void)\n match\n gfc_match_omp_taskgroup (void)\n {\n-  return match_omp (EXEC_OMP_TASKGROUP, OMP_CLAUSE_TASK_REDUCTION);\n+  return match_omp (EXEC_OMP_TASKGROUP, OMP_TASKGROUP_CLAUSES);\n }\n \n \n@@ -6243,7 +6282,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\"IN_REDUCTION\", \"TASK_REDUCTION\",\n \t\"DEVICE_RESIDENT\", \"LINK\", \"USE_DEVICE\",\n \t\"CACHE\", \"IS_DEVICE_PTR\", \"USE_DEVICE_PTR\", \"USE_DEVICE_ADDR\",\n-\t\"NONTEMPORAL\" };\n+\t\"NONTEMPORAL\", \"ALLOCATE\" };\n   STATIC_ASSERT (ARRAY_SIZE (clause_names) == OMP_LIST_NUM);\n \n   if (omp_clauses == NULL)\n@@ -6529,7 +6568,8 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t&& list != OMP_LIST_REDUCTION_INSCAN\n \t&& list != OMP_LIST_REDUCTION_TASK\n \t&& list != OMP_LIST_IN_REDUCTION\n-\t&& list != OMP_LIST_TASK_REDUCTION)\n+\t&& list != OMP_LIST_TASK_REDUCTION\n+\t&& list != OMP_LIST_ALLOCATE)\n       for (n = omp_clauses->lists[list]; n; n = n->next)\n \t{\n \t  bool component_ref_p = false;\n@@ -6598,6 +6638,78 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \tn->sym->mark = 1;\n     }\n \n+  if (omp_clauses->lists[OMP_LIST_ALLOCATE])\n+    {\n+      for (n = omp_clauses->lists[OMP_LIST_ALLOCATE]; n; n = n->next)\n+\tif (n->expr && (n->expr->ts.type != BT_INTEGER\n+\t    || n->expr->ts.kind != gfc_c_intptr_kind))\n+\t  {\n+\t    gfc_error (\"Expected integer expression of the \"\n+\t\t       \"'omp_allocator_handle_kind' kind at %L\",\n+\t\t       &n->expr->where);\n+\t    break;\n+\t  }\n+\n+      /* Check for 2 things here.\n+     1.  There is no duplication of variable in allocate clause.\n+     2.  Variable in allocate clause are also present in some\n+\t privatization clase (non-composite case).  */\n+      for (n = omp_clauses->lists[OMP_LIST_ALLOCATE]; n; n = n->next)\n+\tn->sym->mark = 0;\n+\n+      gfc_omp_namelist *prev = NULL;\n+      for (n = omp_clauses->lists[OMP_LIST_ALLOCATE]; n;)\n+\t{\n+\t  if (n->sym->mark == 1)\n+\t    {\n+\t      gfc_warning (0, \"%qs appears more than once in %<allocate%> \"\n+\t\t\t   \"clauses at %L\" , n->sym->name, &n->where);\n+\t      /* We have already seen this variable so it is a duplicate.\n+\t\t Remove it.  */\n+\t      if (prev != NULL && prev->next == n)\n+\t\t{\n+\t\t  prev->next = n->next;\n+\t\t  n->next = NULL;\n+\t\t  gfc_free_omp_namelist (n, 0);\n+\t\t  n = prev->next;\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  n->sym->mark = 1;\n+\t  prev = n;\n+\t  n = n->next;\n+\t}\n+\n+      /* Non-composite constructs.  */\n+      if (code && code->op < EXEC_OMP_DO_SIMD)\n+\t{\n+\t  for (list = 0; list < OMP_LIST_NUM; list++)\n+\t    switch (list)\n+\t    {\n+\t      case OMP_LIST_PRIVATE:\n+\t      case OMP_LIST_FIRSTPRIVATE:\n+\t      case OMP_LIST_LASTPRIVATE:\n+\t      case OMP_LIST_REDUCTION:\n+\t      case OMP_LIST_REDUCTION_INSCAN:\n+\t      case OMP_LIST_REDUCTION_TASK:\n+\t      case OMP_LIST_IN_REDUCTION:\n+\t      case OMP_LIST_TASK_REDUCTION:\n+\t      case OMP_LIST_LINEAR:\n+\t\tfor (n = omp_clauses->lists[list]; n; n = n->next)\n+\t\t  n->sym->mark = 0;\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t    }\n+\n+\t  for (n = omp_clauses->lists[OMP_LIST_ALLOCATE]; n; n = n->next)\n+\t    if (n->sym->mark == 1)\n+\t      gfc_error (\"%qs specified in 'allocate' clause at %L but not \"\n+\t\t\t \"in an explicit privatization clause\",\n+\t\t\t n->sym->name, &n->where);\n+\t}\n+    }\n+\n   /* OpenACC reductions.  */\n   if (openacc)\n     {\n@@ -8438,19 +8550,20 @@ resolve_omp_do (gfc_code *code)\n       if (code->ext.omp_clauses)\n \tfor (list = 0; list < OMP_LIST_NUM; list++)\n \t  if (!is_simd || code->ext.omp_clauses->collapse > 1\n-\t      ? (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE)\n+\t      ? (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE\n+\t\t  && list != OMP_LIST_ALLOCATE)\n \t      : (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE\n-\t\t && list != OMP_LIST_LINEAR))\n+\t\t && list != OMP_LIST_ALLOCATE && list != OMP_LIST_LINEAR))\n \t    for (n = code->ext.omp_clauses->lists[list]; n; n = n->next)\n \t      if (dovar == n->sym)\n \t\t{\n \t\t  if (!is_simd || code->ext.omp_clauses->collapse > 1)\n \t\t    gfc_error (\"%s iteration variable present on clause \"\n-\t\t\t       \"other than PRIVATE or LASTPRIVATE at %L\",\n-\t\t\t       name, &do_code->loc);\n+\t\t\t       \"other than PRIVATE, LASTPRIVATE or \"\n+\t\t\t       \"ALLOCATE at %L\", name, &do_code->loc);\n \t\t  else\n \t\t    gfc_error (\"%s iteration variable present on clause \"\n-\t\t\t       \"other than PRIVATE, LASTPRIVATE or \"\n+\t\t\t       \"other than PRIVATE, LASTPRIVATE, ALLOCATE or \"\n \t\t\t       \"LINEAR at %L\", name, &do_code->loc);\n \t\t  break;\n \t\t}"}, {"sha": "d363258a5b9b0ba71b98de02c473fd48a5434d15", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -2649,6 +2649,28 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  }\n \t      }\n \t  break;\n+\tcase OMP_LIST_ALLOCATE:\n+\t  for (; n != NULL; n = n->next)\n+\t    if (n->sym->attr.referenced)\n+\t      {\n+\t\ttree t = gfc_trans_omp_variable (n->sym, false);\n+\t\tif (t != error_mark_node)\n+\t\t  {\n+\t\t    tree node = build_omp_clause (input_location,\n+\t\t\t\t\t\t  OMP_CLAUSE_ALLOCATE);\n+\t\t    OMP_CLAUSE_DECL (node) = t;\n+\t\t    if (n->expr)\n+\t\t      {\n+\t\t\ttree allocator_;\n+\t\t\tgfc_init_se (&se, NULL);\n+\t\t\tgfc_conv_expr (&se, n->expr);\n+\t\t\tallocator_ = gfc_evaluate_now (se.expr, block);\n+\t\t\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (node) = allocator_;\n+\t\t      }\n+\t\t    omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n+\t\t  }\n+\t      }\n+\t  break;\n \tcase OMP_LIST_LINEAR:\n \t  {\n \t    gfc_expr *last_step_expr = NULL;\n@@ -6260,6 +6282,71 @@ gfc_split_omp_clauses (gfc_code *code,\n \t== (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n        && !is_loop)\n     clausesa[GFC_OMP_SPLIT_DO].nowait = true;\n+\n+   /* Distribute allocate clause to do, parallel, distribute, teams, target\n+      and taskloop.  The code below itereates over variables in the\n+      allocate list and checks if that available is also in any\n+      privatization clause on those construct.  If yes, then we add it\n+      to the list of 'allocate'ed variables for that construct.  If a\n+      variable is found in none of them then we issue an error.  */\n+\n+   if (code->ext.omp_clauses->lists[OMP_LIST_ALLOCATE])\n+     {\n+       gfc_omp_namelist *alloc_nl, *priv_nl;\n+       gfc_omp_namelist *tails[GFC_OMP_SPLIT_NUM];\n+       for (alloc_nl = code->ext.omp_clauses->lists[OMP_LIST_ALLOCATE];\n+\t   alloc_nl; alloc_nl = alloc_nl->next)\n+\t {\n+\t   bool found = false;\n+\t   for (int i = GFC_OMP_SPLIT_DO; i <= GFC_OMP_SPLIT_TASKLOOP; i++)\n+\t     {\n+\t       gfc_omp_namelist *p;\n+\t       int list;\n+\t       for (list = 0; list < OMP_LIST_NUM; list++)\n+\t\t {\n+\t\t   switch (list)\n+\t\t   {\n+\t\t     case OMP_LIST_PRIVATE:\n+\t\t     case OMP_LIST_FIRSTPRIVATE:\n+\t\t     case OMP_LIST_LASTPRIVATE:\n+\t\t     case OMP_LIST_REDUCTION:\n+\t\t     case OMP_LIST_REDUCTION_INSCAN:\n+\t\t     case OMP_LIST_REDUCTION_TASK:\n+\t\t     case OMP_LIST_IN_REDUCTION:\n+\t\t     case OMP_LIST_TASK_REDUCTION:\n+\t\t     case OMP_LIST_LINEAR:\n+\t\t       for (priv_nl = clausesa[i].lists[list]; priv_nl;\n+\t\t\t    priv_nl = priv_nl->next)\n+\t\t\t if (alloc_nl->sym == priv_nl->sym)\n+\t\t\t   {\n+\t\t\t     found = true;\n+\t\t\t     p = gfc_get_omp_namelist ();\n+\t\t\t     p->sym = alloc_nl->sym;\n+\t\t\t     p->expr = alloc_nl->expr;\n+\t\t\t     p->where = alloc_nl->where;\n+\t\t\t     if (clausesa[i].lists[OMP_LIST_ALLOCATE] == NULL)\n+\t\t\t       {\n+\t\t\t\t clausesa[i].lists[OMP_LIST_ALLOCATE] = p;\n+\t\t\t\t tails[i] = p;\n+\t\t\t       }\n+\t\t\t     else\n+\t\t\t       {\n+\t\t\t\t tails[i]->next = p;\n+\t\t\t\t tails[i] = tails[i]->next;\n+\t\t\t       }\n+\t\t\t   }\n+\t\t       break;\n+\t\t     default:\n+\t\t       break;\n+\t\t   }\n+\t\t }\n+\t     }\n+\t   if (!found)\n+\t     gfc_error (\"%qs specified in 'allocate' clause at %L but not \"\n+\t\t\t\"in an explicit privatization clause\",\n+\t\t\talloc_nl->sym->name, &alloc_nl->where);\n+\t }\n+     }\n }\n \n static tree"}, {"sha": "8bc6b768778a37cac26bec935cc9f661be2883ab", "filename": "gcc/testsuite/gfortran.dg/gomp/allocate-1.f90", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-1.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -0,0 +1,137 @@\n+! { dg-do compile }\n+\n+module omp_lib_kinds\n+  use iso_c_binding, only: c_int, c_intptr_t\n+  implicit none\n+  private :: c_int, c_intptr_t\n+  integer, parameter :: omp_allocator_handle_kind = c_intptr_t\n+\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_null_allocator = 0\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_default_mem_alloc = 1\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_large_cap_mem_alloc = 2\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_const_mem_alloc = 3\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_high_bw_mem_alloc = 4\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_low_lat_mem_alloc = 5\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_cgroup_mem_alloc = 6\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_pteam_mem_alloc = 7\n+  integer (kind=omp_allocator_handle_kind), &\n+     parameter :: omp_thread_mem_alloc = 8\n+end module\n+\n+subroutine bar (a, b, c)\n+  implicit none\n+  integer  :: a\n+  integer  :: b\n+  integer  :: c\n+  c = a + b\n+end\n+\n+subroutine bar2 (a, b, c)\n+  implicit none\n+  integer  :: a\n+  integer  :: b(15)\n+  integer  :: c\n+  c = a + b(1)\n+end\n+\n+subroutine foo(x, y)\n+  use omp_lib_kinds\n+  implicit none\n+  integer  :: x\n+  integer  :: z\n+\n+  integer, dimension(15) :: y\n+  integer  :: r\n+  integer  :: i\n+  integer  c1, c2, c3, c4\n+  integer (kind=omp_allocator_handle_kind) :: h\n+  common /B1/ c1, c2\n+  common /B2/ c3, c4\n+\n+  r = 0\n+  h = omp_default_mem_alloc;\n+\n+\n+  !$omp parallel private(/B1/, c3, c4) allocate(/B1/, /B2/)\n+  !$omp end parallel\n+\n+  !$omp parallel private(/B1/, /B2/) allocate(h:/B1/, /B2/)\n+  !$omp end parallel\n+  \n+  !$omp parallel private(/B1/, /B2/) allocate(omp_large_cap_mem_alloc:/B1/, c3, c4)\n+  !$omp end parallel\n+\n+  !$omp parallel allocate (x) allocate (h : y) &\n+  !$omp  allocate (omp_large_cap_mem_alloc:z) firstprivate (x, y, z)\n+  call bar2 (x, y, z);\n+  !$omp end parallel\n+\n+  !$omp task private (x) firstprivate (z) allocate (omp_low_lat_mem_alloc:x,z)\n+  call bar (0, x, z);\n+  !$omp end task\n+  \n+  !$omp target teams distribute parallel do private (x) firstprivate (y) &\n+  !$omp allocate ((omp_default_mem_alloc + 0):z) allocate &\n+  !$omp (omp_default_mem_alloc: x, y) allocate (h: r) lastprivate (z) reduction(+:r)\n+  do i = 1, 10\n+    call bar (0, x, z);\n+    call bar2 (1, y, r);\n+  end do\n+  !$omp end target teams distribute parallel do\n+\n+  !$omp single private (x) allocate (omp_low_lat_mem_alloc:x)\n+  x=1\n+  !$omp end single\n+\n+  !$omp single allocate (omp_low_lat_mem_alloc:x) private (x)\n+  !$omp end single\n+\n+  !$omp parallel\n+  !$omp do allocate (x) private (x)\n+  do i = 1, 64\n+    x = 1;\n+  end do\n+  !$omp end parallel\n+\n+  !$omp sections private (x) allocate (omp_low_lat_mem_alloc: x)\n+    x = 1;\n+    !$omp section\n+    x = 2;\n+    !$omp section\n+    x = 3;\n+  !$omp end sections\n+\n+  !$omp taskgroup task_reduction(+:r) allocate (omp_default_mem_alloc : r)\n+  call bar (r, r, r);\n+  !$omp end taskgroup\n+\n+  !$omp teams private (x) firstprivate (y) allocate (h : x, y)\n+  call bar2 (x, y, r);\n+  !$omp end teams\n+\n+  !$omp taskloop lastprivate (x) reduction (+:r) allocate (h : x, r)\n+  do i = 1, 16\n+    call bar (0, r, r);\n+    x = i;\n+  end do\n+  !$omp end taskloop\n+\n+  !$omp taskgroup task_reduction(+:r) allocate (omp_default_mem_alloc : r)\n+  !$omp taskloop firstprivate (x) in_reduction (+:r) &\n+  !$omp allocate (omp_default_mem_alloc : x, r)\n+  do i = 1, 16\n+    call bar (x, r, r);\n+  end do\n+  !$omp end taskloop\n+  !$omp end taskgroup\n+  !$omp taskwait\n+end subroutine\n+"}, {"sha": "88b2d26872da36c62e2e553defb045cf19958619", "filename": "gcc/testsuite/gfortran.dg/gomp/allocate-2.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-2.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+\n+module omp_lib_kinds\n+  use iso_c_binding, only: c_int, c_intptr_t\n+  implicit none\n+  private :: c_int, c_intptr_t\n+  integer, parameter :: omp_allocator_handle_kind = c_intptr_t\n+\n+end module\n+\n+subroutine foo(x)\n+  use omp_lib_kinds\n+  implicit none\n+  integer  :: x\n+\n+  !$omp task allocate (x) ! { dg-error \"'x' specified in 'allocate' clause at .1. but not in an explicit privatization clause\" }\n+  x=1\n+  !$omp end task\n+\n+  !$omp parallel allocate (x) ! { dg-error \"'x' specified in 'allocate' clause at .1. but not in an explicit privatization clause\" }\n+  x=2\n+  !$omp end parallel\n+\n+  !$omp parallel allocate (x) shared (x) ! { dg-error \"'x' specified in 'allocate' clause at .1. but not in an explicit privatization clause\" }\n+  x=3\n+  !$omp end parallel\n+\n+  !$omp parallel private (x) allocate (x) allocate (x) ! { dg-warning \"'x' appears more than once in 'allocate' clauses at .1.\" }\n+  x=4\n+  !$omp end parallel\n+\n+  !$omp parallel private (x) allocate (x, x) ! { dg-warning \"'x' appears more than once in 'allocate' clauses at .1.\" } \n+  x=5\n+  !$omp end parallel\n+\n+  !$omp parallel allocate (0: x) private(x) ! { dg-error \"Expected integer expression of the 'omp_allocator_handle_kind' kind at .1.\" }\n+  x=6\n+  !$omp end parallel\n+  \n+  !$omp parallel private (x) allocate (0.1 : x) ! { dg-error \"Expected integer expression of the 'omp_allocator_handle_kind' kind at .1.\" }\n+  x=7\n+  !$omp end parallel\n+\n+end subroutine\n+"}, {"sha": "7b57be980cb3005552c12daee0e9671eb3f67fe8", "filename": "gcc/testsuite/gfortran.dg/gomp/allocate-3.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocate-3.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+\n+subroutine foo(x)\n+  implicit none\n+  integer  :: x\n+  integer  :: i\n+\n+  !$omp parallel do simd private (x) allocate (x) ! { dg-error \"'x' specified in 'allocate' clause at .1. but not in an explicit privatization clause\" }\n+  do i = 1, 64\n+    x = i\n+  end do\n+  !$omp end parallel do simd\n+\n+end subroutine"}, {"sha": "92801852984d8af6dee844f7a44582093a84972e", "filename": "gcc/testsuite/gfortran.dg/gomp/clauses-1.f90", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclauses-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclauses-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclauses-1.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -36,8 +36,8 @@ subroutine foo (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp distribute parallel do &\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n-  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -46,17 +46,17 @@ subroutine foo (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) nontemporal(ntm) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) order(concurrent)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) order(concurrent) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp distribute simd &\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) &\n-  !$omp&  order(concurrent)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  order(concurrent) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -81,17 +81,17 @@ subroutine baz (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp distribute parallel do &\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n-  !$omp&  lastprivate (l) schedule(static, 4) copyin(t)\n-  ! FIXME/TODO: allocate (p)\n+  !$omp&  lastprivate (l) schedule(static, 4) copyin(t) &\n+  !$omp&  allocate (p)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp distribute parallel do &\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n-  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent)\n-  ! FIXME/TODO: allocate (p)\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n+  !$omp&  allocate (p)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -100,8 +100,8 @@ subroutine baz (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) nontemporal(ntm) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) copyin(t)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) copyin(t) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -110,17 +110,17 @@ subroutine baz (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) if(simd: i1) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) nontemporal(ntm) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp distribute simd &\n   !$omp&  private (p) firstprivate (f) collapse(1) dist_schedule(static, 16) &\n   !$omp&  safelen(8) simdlen(4) aligned(q: 32) reduction(+:r) if(i1) nontemporal(ntm) &\n-  !$omp&  order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -140,42 +140,42 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n \n   !$omp do simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) linear (ll:1) reduction(+:r) schedule(static, 4) collapse(1) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) if(i1) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n   !$omp end do simd nowait\n \n   !$omp parallel do &\n   !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n-  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp parallel do &\n   !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n-  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp parallel do simd &\n   !$omp&  private (p) firstprivate (f) if (i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n   !$omp&  proc_bind(spread) lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) nontemporal(ntm) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp parallel sections &\n   !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n-  !$omp&  proc_bind(spread) lastprivate (l)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  proc_bind(spread) lastprivate (l) &\n+  !$omp&  allocate (f)\n     !$omp section\n       block; end block\n     !$omp section\n@@ -185,16 +185,16 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp target parallel &\n   !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n-  !$omp&  depend(inout: dd(0)) in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  depend(inout: dd(0)) in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   !$omp end target parallel nowait\n \n   !$omp target parallel do &\n   !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) linear (ll:1) ordered schedule(static, 4) collapse(1) depend(inout: dd(0)) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -204,8 +204,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) depend(inout: dd(0)) order(concurrent) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -216,8 +216,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  if (parallel: i2) default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) linear (ll:1) schedule(static, 4) collapse(1) &\n   !$omp&  safelen(8) simdlen(4) aligned(q: 32) depend(inout: dd(0)) nontemporal(ntm) if (simd: i3) order(concurrent) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -226,15 +226,15 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp target teams &\n   !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte - 1:nte) thread_limit(tl) depend(inout: dd(0)) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   !$omp end target teams nowait\n \n   !$omp target teams distribute &\n   !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) order(concurrent) &\n-  !$omp&  collapse(1) dist_schedule(static, 16) depend(inout: dd(0)) in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  collapse(1) dist_schedule(static, 16) depend(inout: dd(0)) in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n   end do\n   !$omp end target teams distribute nowait\n@@ -245,8 +245,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) depend(inout: dd(0)) order(concurrent) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -259,8 +259,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n   !$omp&  safelen(8) simdlen(4) aligned(q: 32) depend(inout: dd(0)) nontemporal(ntm) if (simd: i3) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -271,8 +271,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n   !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n   !$omp&  safelen(8) simdlen(4) aligned(q: 32) depend(inout: dd(0)) nontemporal(ntm) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -282,34 +282,34 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  device(d) map (tofrom: m) if (target: i1) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  safelen(8) simdlen(4) lastprivate (l) linear(ll: 1) aligned(q: 32) reduction(+:r) &\n   !$omp&  depend(inout: dd(0)) nontemporal(ntm) if(simd:i3) order(concurrent) &\n-  !$omp&  in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc:f)\n+  !$omp&  in_reduction(+:r2) &\n+  !$omp&  allocate (omp_default_mem_alloc:f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n   !$omp end target simd nowait\n \n-  !$omp taskgroup task_reduction(+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction(+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n   !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) &\n-  !$omp&  order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction(+:r)\n-  ! FIXME/TODO: allocate (r)\n+  !$omp taskgroup task_reduction(+:r) &\n+  !$omp&  allocate (r)\n   !$omp taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(i1) &\n   !$omp&  final(fi) mergeable nogroup priority (pp) &\n   !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) in_reduction(+:r) nontemporal(ntm) &\n-  !$omp&  order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n@@ -319,17 +319,17 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) if(taskloop: i1) &\n   !$omp&  final(fi) priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(+:r) if (simd: i3) nontemporal(ntm) &\n-  !$omp&  order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp target depend(inout: dd(0)) in_reduction(+:r2)\n   !$omp teams distribute &\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n-  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do i = 1, 64\n   end do\n   !$omp end target nowait\n@@ -339,8 +339,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n   !$omp&  collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n-  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -352,8 +352,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -363,8 +363,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp teams distribute simd &\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n   !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -374,8 +374,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n   !$omp&  collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n-  !$omp&  lastprivate (l) schedule(static, 4) copyin(t)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  lastprivate (l) schedule(static, 4) copyin(t) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -384,8 +384,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n   !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n-  !$omp&  lastprivate (l) schedule(static, 4)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  lastprivate (l) schedule(static, 4) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -395,8 +395,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) copyin(t) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -406,77 +406,77 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  collapse(1) dist_schedule(static, 16) &\n   !$omp&  if (parallel: i2) num_threads (nth) proc_bind(spread) &\n   !$omp&  lastprivate (l) schedule(static, 4) order(concurrent) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if (simd: i3) nontemporal(ntm) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp teams distribute simd &\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n   !$omp&  collapse(1) dist_schedule(static, 16) order(concurrent) &\n-  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm)\n-  ! FIXME/TODO: allocate(f)\n+  !$omp&  safelen(8) simdlen(4) aligned(q: 32) if(i3) nontemporal(ntm) &\n+  !$omp&  allocate(f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp parallel master &\n   !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) &\n-  !$omp&  num_threads (nth) proc_bind(spread) copyin(t)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) &\n+  !$omp&  allocate (f)\n   !$omp end parallel master\n \n   !$omp parallel masked &\n   !$omp&  private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) &\n-  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) filter (d) &\n+  !$omp&  allocate (f)\n   !$omp end parallel masked\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp master taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) &\n-  !$omp&  reduction(default, +:r) in_reduction(+:r2)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  reduction(default, +:r) in_reduction(+:r2) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp masked taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n-  !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp master taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n   !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) &\n-  !$omp&  order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp masked taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n   !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) &\n-  !$omp&  order(concurrent) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  order(concurrent) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -485,17 +485,17 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp parallel master taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) &\n-  !$omp&  reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp parallel masked taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) final(fi) mergeable priority (pp) &\n-  !$omp&  reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -504,8 +504,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n   !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) &\n-  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -514,14 +514,14 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied &\n   !$omp&  if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) &\n   !$omp&  safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) &\n-  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp master taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) &\n   !$omp&  untied if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2)\n@@ -530,8 +530,8 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp masked taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) &\n   !$omp&  untied if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) in_reduction(+:r2) filter (d)\n@@ -540,61 +540,61 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp master taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) &\n   !$omp&  final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n-  !$omp&  in_reduction(+:r2) nontemporal(ntm) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  in_reduction(+:r2) nontemporal(ntm) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n   !$omp end taskgroup\n \n-  !$omp taskgroup task_reduction (+:r2)\n-  ! FIXME/TODO: allocate (r2)\n+  !$omp taskgroup task_reduction (+:r2) &\n+  !$omp&  allocate (r2)\n   !$omp masked taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n   !$omp&  if(i1) final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n-  !$omp&  in_reduction(+:r2) nontemporal(ntm) order(concurrent) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  in_reduction(+:r2) nontemporal(ntm) order(concurrent) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n   !$omp end taskgroup\n \n   !$omp parallel master taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n-  !$omp&  if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp parallel masked taskloop &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n   !$omp&  if(i1) final(fi) mergeable priority (pp) reduction(default, +:r) num_threads (nth) proc_bind(spread) &\n-  !$omp&  copyin(t) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  copyin(t) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp parallel master taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied &\n   !$omp&  if(i1) final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n-  !$omp&  nontemporal(ntm) num_threads (nth) proc_bind(spread)copyin(t) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  nontemporal(ntm) num_threads (nth) proc_bind(spread)copyin(t) order(concurrent) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n \n   !$omp parallel masked taskloop simd &\n   !$omp&  private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) &\n   !$omp&  final(fi) mergeable priority (pp) safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) &\n-  !$omp&  nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) filter (d)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) order(concurrent) filter (d) &\n+  !$omp&  allocate (f)\n   do i = 1, 64\n     ll = ll +1\n   end do\n@@ -607,58 +607,58 @@ subroutine bar (d, m, i1, i2, i3, p, idp, s, nte, tl, nth, g, nta, fi, pp, q, dd\n \n   !$omp parallel loop &\n   !$omp&  private (p) firstprivate (f) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n-  !$omp&  proc_bind(spread) lastprivate (l) collapse(1) bind(parallel) order(concurrent) if (parallel: i2)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  proc_bind(spread) lastprivate (l) collapse(1) bind(parallel) order(concurrent) if (parallel: i2) &\n+  !$omp&  allocate (f)\n   do l = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp parallel loop &\n   !$omp&  private (p) firstprivate (f) default(shared) shared(s) copyin(t) reduction(+:r) num_threads (nth) &\n-  !$omp&  proc_bind(spread) lastprivate (l) collapse(1) if (parallel: i2)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  proc_bind(spread) lastprivate (l) collapse(1) if (parallel: i2) &\n+  !$omp&  allocate (f)\n   do l = 1, 64\n     ll = ll + 1\n   end do\n \n   !$omp teams loop &\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) &\n-  !$omp&  collapse(1) lastprivate (l) bind(teams)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  collapse(1) lastprivate (l) bind(teams) &\n+  !$omp&  allocate (f)\n   do l = 1, 64\n   end do\n \n   !$omp teams loop &\n   !$omp&  private(p) firstprivate (f) shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) &\n-  !$omp&  collapse(1) lastprivate (l) order(concurrent)\n-  ! FIXME/TODO: allocate (f)\n+  !$omp&  collapse(1) lastprivate (l) order(concurrent) &\n+  !$omp&  allocate (f)\n   do l = 1, 64\n   end do\n \n   !$omp target parallel loop &\n   !$omp&  device(d) map (tofrom: m) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  default(shared) shared(s) reduction(+:r) num_threads (nth) proc_bind(spread) &\n   !$omp&  depend(inout: dd(0)) lastprivate (l) order(concurrent) collapse(1) in_reduction(+:r2) &\n-  !$omp&  if (target: i1) if (parallel: i2)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  if (target: i1) if (parallel: i2) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do l = 1, 64\n   end do\n   !$omp end target parallel loop nowait\n \n   !$omp target teams loop &\n   !$omp&  device(d) map (tofrom: m) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte-1:nte) thread_limit(tl) depend(inout: dd(0)) &\n-  !$omp&  lastprivate (l) bind(teams) collapse(1) in_reduction(+:r2) if (target: i1)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  lastprivate (l) bind(teams) collapse(1) in_reduction(+:r2) if (target: i1) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do l = 1, 64\n   end do\n   !$omp end target teams loop nowait\n \n   !$omp target teams loop &\n   !$omp&  device(d) map (tofrom: m) private (p) firstprivate (f) defaultmap(tofrom: scalar) is_device_ptr (idp) &\n   !$omp&  shared(s) default(shared) reduction(+:r) num_teams(nte) thread_limit(tl) depend(inout: dd(0)) &\n-  !$omp&  lastprivate (l) order(concurrent) collapse(1) in_reduction(+:r2) if (target: i1)\n-  ! FIXME/TODO: allocate (omp_default_mem_alloc: f)\n+  !$omp&  lastprivate (l) order(concurrent) collapse(1) in_reduction(+:r2) if (target: i1) &\n+  !$omp&  allocate (omp_default_mem_alloc: f)\n   do l = 1, 64\n   end do\n   !$omp end target teams loop nowait"}, {"sha": "01cfc82b760757bbd0f4ee57c495496d4d690fb5", "filename": "gcc/testsuite/gfortran.dg/gomp/collapse1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcollapse1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcollapse1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcollapse1.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -24,7 +24,7 @@ subroutine collapse1\n     end do\n   !$omp parallel do collapse(2) shared(j)\n     do i = 1, 3\n-      do j = 4, 6\t\t! { dg-error \"iteration variable present on clause other than PRIVATE or LASTPRIVATE\" }\n+      do j = 4, 6\t\t! { dg-error \"iteration variable present on clause other than PRIVATE, LASTPRIVATE or ALLOCATE\" }\n       end do\n     end do\n   !$omp parallel do collapse(2)"}, {"sha": "17375e0eff51d41d8528dc50c87e3d582668c873", "filename": "gcc/testsuite/gfortran.dg/gomp/openmp-simd-4.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-4.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -45,17 +45,17 @@\n end do\n \n !$omp parallel do firstprivate(i)\n-do i = 1, 5  ! { dg-error \"PARALLEL DO iteration variable present on clause other than PRIVATE or LASTPRIVATE\" }\n+do i = 1, 5  ! { dg-error \"PARALLEL DO iteration variable present on clause other than PRIVATE, LASTPRIVATE or ALLOCATE\" }\n   x(i) = 42\n end do\n \n !$omp parallel do simd firstprivate(i)\n-do i = 1, 5  ! { dg-error \"PARALLEL DO SIMD iteration variable present on clause other than PRIVATE, LASTPRIVATE or LINEAR\" }\n+do i = 1, 5  ! { dg-error \"PARALLEL DO SIMD iteration variable present on clause other than PRIVATE, LASTPRIVATE, ALLOCATE or LINEAR\" }\n   x(i) = 42\n end do\n \n !$omp simd linear(i) collapse(2)\n-do i = 1, 5  ! { dg-error \"SIMD iteration variable present on clause other than PRIVATE or LASTPRIVATE\" }\n+do i = 1, 5  ! { dg-error \"SIMD iteration variable present on clause other than PRIVATE, LASTPRIVATE or ALLOCATE\" }\n   do j = 1, 2\n     y(j, i) = 52\n   end do"}, {"sha": "3be9de51f118e1a08496a95c372a30a4f50cb56f", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -219,7 +219,7 @@ The OpenMP 4.5 specification is fully supported.\n       @tab Y @tab Some are only stubs\n @item Memory management routines @tab Y @tab\n @item @code{allocate} directive @tab N @tab\n-@item @code{allocate} clause @tab P @tab initial support in C/C++ only\n+@item @code{allocate} clause @tab P @tab initial support\n @item @code{use_device_addr} clause on @code{target data} @tab Y @tab\n @item @code{ancestor} modifier on @code{device} clause\n       @tab P @tab Reverse offload unsupported"}, {"sha": "d33acc6feefaae8cc9fee45b21c18b9b575db150", "filename": "libgomp/testsuite/libgomp.fortran/allocate-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-1.c?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -0,0 +1,7 @@\n+#include <stdint.h>\n+\n+int\n+is_64bit_aligned_ (uintptr_t a)\n+{\n+  return ( (a & 0x3f) == 0);\n+}"}, {"sha": "35d1750b878bfa35a36add254e5a15d3b70bf01a", "filename": "libgomp/testsuite/libgomp.fortran/allocate-1.f90", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69561fc781aca3dea3aa4d5d562ef5a502965924/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69561fc781aca3dea3aa4d5d562ef5a502965924/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-1.f90?ref=69561fc781aca3dea3aa4d5d562ef5a502965924", "patch": "@@ -0,0 +1,333 @@\n+! { dg-do run }\n+! { dg-additional-sources allocate-1.c }\n+! { dg-prune-output \"command-line option '-fintrinsic-modules-path=.*' is valid for Fortran but not for C\" }\n+\n+module m\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    integer(c_int) function is_64bit_aligned (a) bind(C)\n+      import :: c_int\n+      integer  :: a\n+    end\n+  end interface\n+end module m\n+\n+subroutine foo (x, p, q, px, h, fl)\n+  use omp_lib\n+  use iso_c_binding\n+  integer  :: x\n+  integer, dimension(4) :: p\n+  integer, dimension(4) :: q\n+  integer  :: px\n+  integer (kind=omp_allocator_handle_kind) :: h\n+  integer  :: fl\n+\n+  integer  :: y\n+  integer  :: r, i, i1, i2, i3, i4, i5\n+  integer  :: l, l3, l4, l5, l6\n+  integer  :: n, n1, n2, n3, n4\n+  integer  :: j2, j3, j4\n+  integer, dimension(4) :: l2\n+  integer, dimension(4) :: r2\n+  integer, target  :: xo\n+  integer, target  :: yo\n+  integer, dimension(x) :: v\n+  integer, dimension(x) :: w\n+\n+  type s_type\n+    integer      :: a\n+    integer      :: b\n+  end type\n+\n+  type (s_type) :: s\n+  s%a = 27\n+  s%b = 29\n+  y = 0\n+  r = 0\n+  n = 8\n+  n2 = 9\n+  n3 = 10\n+  n4 = 11\n+  xo = x\n+  yo = y\n+\n+  do i = 1, 4\n+    r2(i) = 0;\n+  end do\n+\n+  do i = 1, 4\n+    p(i) = 0;\n+  end do\n+\n+  do i = 1, 4\n+    q(i) = 0;\n+  end do\n+\n+  do i = 1, x\n+    w(i) = i\n+  end do\n+\n+  !$omp parallel private (y, v) firstprivate (x) allocate (x, y, v)\n+  if (x /= 42) then\n+    stop 1\n+  end if\n+  v(1) = 7\n+  if ( (and(fl, 2) /= 0) .and.          &\n+       ((is_64bit_aligned(x) == 0) .or. &\n+        (is_64bit_aligned(y) == 0) .or. &\n+        (is_64bit_aligned(v(1)) == 0))) then\n+      stop 2\n+  end if\n+\n+  !$omp barrier\n+  y = 1;\n+  x = x + 1\n+  v(1) = 7\n+  v(41) = 8\n+  !$omp barrier\n+  if (x /= 43 .or. y /= 1) then\n+    stop 3\n+  end if\n+  if (v(1) /= 7 .or. v(41) /= 8) then\n+    stop 4\n+  end if\n+  !$omp end parallel\n+\n+  !$omp teams\n+  !$omp parallel private (y) firstprivate (x, w) allocate (h: x, y, w)\n+\n+  if (x /= 42 .or. w(17) /= 17 .or. w(41) /= 41) then\n+    stop 5\n+  end if\n+  !$omp barrier\n+  y = 1;\n+  x = x + 1\n+  w(19) = w(19) + 1\n+  !$omp barrier\n+  if (x /= 43 .or. y /= 1 .or. w(19) /= 20) then\n+    stop 6\n+  end if\n+  if ( (and(fl, 1) /= 0) .and.          &\n+       ((is_64bit_aligned(x) == 0) .or. &\n+        (is_64bit_aligned(y) == 0) .or. &\n+        (is_64bit_aligned(w(1)) == 0))) then\n+    stop 7\n+  end if\n+  !$omp end parallel\n+  !$omp end teams\n+\n+  !$omp parallel do private (y) firstprivate (x)  reduction(+: r) allocate (h: x, y, r, l, n) lastprivate (l)  linear (n: 16)\n+  do i = 0, 63\n+    if (x /= 42) then\n+      stop 8\n+    end if\n+    y = 1;\n+    l = i;\n+    n = n + y + 15;\n+    r = r + i;\n+    if ( (and(fl, 1) /= 0) .and.          &\n+         ((is_64bit_aligned(x) == 0) .or. &\n+          (is_64bit_aligned(y) == 0) .or. &\n+          (is_64bit_aligned(r) == 0) .or. &\n+          (is_64bit_aligned(l) == 0) .or. &\n+          (is_64bit_aligned(n) == 0))) then\n+      stop 9\n+    end if\n+  end do\n+  !$omp end parallel do\n+\n+  !$omp parallel\n+    !$omp do lastprivate (l2) private (i1) allocate (h: l2, l3, i1) lastprivate (conditional: l3)\n+    do i1 = 0, 63\n+      l2(1) = i1\n+      l2(2) = i1 + 1\n+      l2(3) = i1 + 2\n+      l2(4) = i1 + 3\n+      if (i1 < 37) then\n+        l3 = i1\n+      end if\n+      if ( (and(fl, 1) /= 0) .and.          &\n+           ((is_64bit_aligned(l2(1)) == 0) .or. &\n+            (is_64bit_aligned(l3) == 0) .or. &\n+            (is_64bit_aligned(i1) == 0))) then\n+\tstop 10\n+      end if\n+    end do\n+\n+    !$omp do collapse(2) lastprivate(l4, i2, j2) linear (n2:17) allocate (h: n2, l4, i2, j2)\n+    do i2 = 3, 4\n+      do j2 = 17, 22, 2\n+\tn2 = n2 + 17\n+\tl4 = i2 * 31 + j2\n+\tif ( (and(fl, 1) /= 0) .and.          &\n+\t  ((is_64bit_aligned(l4) == 0) .or. &\n+\t  (is_64bit_aligned(n2) == 0) .or. &\n+\t  (is_64bit_aligned(i2) == 0) .or. &\n+\t  (is_64bit_aligned(j2) == 0))) then\n+\t  stop 11\n+\tend if\n+      end do\n+    end do\n+\n+    !$omp do collapse(2) lastprivate(l5, i3, j3) linear (n3:17) schedule (static, 3) allocate (n3, l5, i3, j3)\n+    do i3 = 3, 4\n+      do j3 = 17, 22, 2\n+\t  n3 = n3 + 17\n+\t  l5 = i3 * 31 + j3\n+\t  if ( (and(fl, 2) /= 0) .and.      &\n+\t  ((is_64bit_aligned(l5) == 0) .or. &\n+\t  (is_64bit_aligned(n3) == 0) .or. &\n+\t  (is_64bit_aligned(i3) == 0) .or. &\n+\t  (is_64bit_aligned(j3) == 0))) then\n+\t  stop 12\n+\tend if\n+      end do\n+    end do\n+\n+    !$omp do collapse(2) lastprivate(l6, i4, j4) linear (n4:17) schedule (dynamic) allocate (h: n4, l6, i4, j4)\n+    do i4 = 3, 4\n+      do j4 = 17, 22,2\n+\t  n4 = n4 + 17;\n+\t  l6 = i4 * 31 + j4;\n+\tif ( (and(fl, 1) /= 0) .and.          &\n+\t  ((is_64bit_aligned(l6) == 0) .or. &\n+\t  (is_64bit_aligned(n4) == 0) .or. &\n+\t  (is_64bit_aligned(i4) == 0) .or. &\n+\t  (is_64bit_aligned(j4) == 0))) then\n+\t  stop 13\n+\tend if\n+      end do\n+    end do\n+\n+    !$omp do lastprivate (i5) allocate (i5)\n+    do i5 = 1, 17, 3\n+      if ( (and(fl, 2) /= 0) .and.          &\n+\t   (is_64bit_aligned(i5) == 0)) then\n+\tstop 14\n+      end if\n+    end do\n+\n+    !$omp do reduction(+:p, q, r2) allocate(h: p, q, r2)\n+    do i = 0, 31\n+\tp(3) = p(3) +  i;\n+\tp(4) = p(4) + (2 * i)\n+\tq(1) = q(1) + (3 * i)\n+\tq(3) = q(3) + (4 * i)\n+\tr2(1) = r2(1) + (5 * i)\n+\tr2(4) = r2(4) + (6 * i)\n+\tif ( (and(fl, 1) /= 0) .and.          &\n+\t  ((is_64bit_aligned(q(1)) == 0) .or. &\n+\t  (is_64bit_aligned(p(1)) == 0) .or. &\n+\t  (is_64bit_aligned(r2(1)) == 0) )) then\n+\t  stop 15\n+\tend if\n+    end do\n+\n+    !$omp task private(y) firstprivate(x) allocate(x, y)\n+    if (x /= 42) then\n+      stop 16\n+    end if\n+\n+    if ( (and(fl, 2) /= 0) .and.          &\n+      ((is_64bit_aligned(x) == 0) .or. &\n+      (is_64bit_aligned(y) == 0) )) then\n+      stop 17\n+    end if\n+    !$omp end task\n+\n+    !$omp task private(y) firstprivate(x) allocate(h: x, y)\n+    if (x /= 42) then\n+      stop 16\n+    end if\n+\n+    if ( (and(fl, 1) /= 0) .and.          &\n+      ((is_64bit_aligned(x) == 0) .or. &\n+      (is_64bit_aligned(y) == 0) )) then\n+      stop 17\n+    end if\n+    !$omp end task\n+\n+    !$omp task private(y) firstprivate(s) allocate(s, y)\n+    if (s%a /= 27 .or. s%b /= 29) then\n+      stop 18\n+    end if\n+\n+    if ( (and(fl, 2) /= 0) .and.          &\n+      ((is_64bit_aligned(s%a) == 0) .or. &\n+      (is_64bit_aligned(y) == 0) )) then\n+      stop 19\n+    end if\n+    !$omp end task\n+\n+    !$omp task private(y) firstprivate(s) allocate(h: s, y)\n+    if (s%a /= 27 .or. s%b /= 29) then\n+      stop 18\n+    end if\n+\n+    if ( (and(fl, 1) /= 0) .and.          &\n+      ((is_64bit_aligned(s%a) == 0) .or. &\n+      (is_64bit_aligned(y) == 0) )) then\n+      stop 19\n+    end if\n+    !$omp end task\n+\n+  !$omp end parallel\n+\n+  if (r /= ((64 * 63) / 2) .or. l /= 63 .or. n /= (8 + 16 * 64)) then\n+    stop 20\n+  end if\n+\n+  if (l2(1) /= 63 .or. l2(2) /= 64 .or. l2(3) /= 65 .or. l2(4) /= 66 .or. l3 /= 36) then\n+    stop 21\n+  end if\n+\n+  if (i2 /= 5 .or. j2 /= 23 .or. n2 /= (9 + (17 * 6)) .or. l4 /= (4 * 31 + 21)) then\n+    stop 22\n+  end if\n+\n+  if (i3 /= 5 .or. j3 /= 23 .or. n3 /= (10 + (17 * 6))  .or. l5 /= (4 * 31 + 21)) then\n+    stop 23\n+  end if\n+\n+  if (i4 /= 5 .or. j4 /= 23 .or. n4 /= (11 + (17 * 6))  .or. l6 /= (4 * 31 + 21)) then\n+    stop 24\n+  end if\n+\n+  if (i5 /= 19) then\n+    stop 24\n+  end if\n+\n+  if (p(3) /= ((32 * 31) / 2) .or. p(4) /= (2 * p(3))         &\n+      .or. q(1) /= (3 * p(3)) .or. q(3) /= (4 * p(3))         &\n+      .or. r2(1) /= (5 * p(3)) .or. r2(4) /= (6 * p(3))) then\n+    stop 25\n+  end if\n+\n+end subroutine\n+\n+program main\n+  use omp_lib\n+  integer, dimension(4) :: p\n+  integer, dimension(4) :: q\n+\n+  type (omp_alloctrait) :: traits(3)\n+  integer (omp_allocator_handle_kind) :: a\n+\n+  traits = [omp_alloctrait (omp_atk_alignment, 64), &\n+            omp_alloctrait (omp_atk_fallback, omp_atv_null_fb), &\n+            omp_alloctrait (omp_atk_pool_size, 8192)]\n+  a = omp_init_allocator (omp_default_mem_space, 3, traits)\n+  if (a == omp_null_allocator) stop 1\n+\n+  call omp_set_default_allocator (omp_default_mem_alloc);\n+  call foo (42, p, q, 2, a, 0);\n+  call foo (42, p, q, 2, omp_default_mem_alloc, 0);\n+  call foo (42, p, q, 2, a, 1);\n+  call omp_set_default_allocator (a);\n+  call foo (42, p, q, 2, omp_null_allocator, 3);\n+  call foo (42, p, q, 2, omp_default_mem_alloc, 2);\n+  call omp_destroy_allocator (a);\n+end"}]}