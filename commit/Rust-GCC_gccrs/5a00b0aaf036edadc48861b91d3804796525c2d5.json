{"sha": "5a00b0aaf036edadc48861b91d3804796525c2d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEwMGIwYWFmMDM2ZWRhZGM0ODg2MWI5MWQzODA0Nzk2NTI1YzJkNQ==", "commit": {"author": {"name": "Sujoy Saraswati", "email": "sujoy.saraswati@hpe.com", "date": "2015-12-22T14:04:30Z"}, "committer": {"name": "Sujoy Saraswati", "email": "ssaraswati@gcc.gnu.org", "date": "2015-12-22T14:04:30Z"}, "message": "This series of patches fix PR61441.\n\nThis series of patches fix PR61441. This patch avoids various transformations\nwith signaling NaN operands when flag_signaling_nans is on, to avoid folding\nwhich would lose exceptions.\n\nBootstrapped & regression-tested on x86_64-linux-gnu.\n\ngcc/\n\t* fold-const.c (const_binop): Convert sNaN to qNaN when\n\tflag_signaling_nans is off.\n\t(const_unop): Avoid the operation, other than NEGATE and\n\tABS, if flag_signaling_nans is on and the operand is an sNaN.\n\t(fold_convert_const_real_from_real): Avoid the operation if\n\tflag_signaling_nans is on and the operand is an sNaN.\n\t(integer_valued_real_unary_p): Update comment stating it\n\treturns false for sNaN values.\n\t(integer_valued_real_binary_p, integer_valued_real_call_p): Same.\n\t(integer_valued_real_single_p): Same.\n\t(integer_valued_real_invalid_p, integer_valued_real_p): Same.\n\t* fold-const-call.c (fold_const_pow): Avoid the operation\n\tif flag_signaling_nans is on and the operand is an sNaN.\n\t(fold_const_builtin_load_exponent) Same.\n\t(fold_const_call_sss): Same for CASE_CFN_POWI.\n\t* gimple-fold.c (gimple_assign_integer_valued_real_p): Same.\n\t(gimple_call_integer_valued_real_p): Same.\n\t(gimple_phi_integer_valued_real_p): Same.\n\t(gimple_stmt_integer_valued_real_p): Same.\n\t* simplify-rtx.c (simplify_const_unary_operation): Avoid the\n\toperation if flag_signaling_nans is on and the operand is an sNaN.\n\t(simplify_const_binary_operation): Same.\n\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Avoid the\n\toperation if flag_signaling_nans is on and the operand is an sNaN.\n\n\t* gcc.dg/pr61441.c: New testcase.\n\nFrom-SVN: r231901", "tree": {"sha": "b911e1bd2a2f7a4a924f976f2156da6ea60dc25c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b911e1bd2a2f7a4a924f976f2156da6ea60dc25c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a00b0aaf036edadc48861b91d3804796525c2d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a00b0aaf036edadc48861b91d3804796525c2d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a00b0aaf036edadc48861b91d3804796525c2d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a00b0aaf036edadc48861b91d3804796525c2d5/comments", "author": null, "committer": null, "parents": [{"sha": "9643ce888b6634d4f6c44ad3c48bd105f38474e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9643ce888b6634d4f6c44ad3c48bd105f38474e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9643ce888b6634d4f6c44ad3c48bd105f38474e8"}], "stats": {"total": 210, "additions": 190, "deletions": 20}, "files": [{"sha": "134e4fb584d6815535018b3217c5e6f3a64f11a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -1,3 +1,30 @@\n+2015-12-22  Sujoy Saraswati  <sujoy.saraswati@hpe.com>\n+\n+\t* fold-const.c (const_binop): Convert sNaN to qNaN when\n+\tflag_signaling_nans is off.\n+\t(const_unop): Avoid the operation, other than NEGATE and\n+\tABS, if flag_signaling_nans is on and the operand is an sNaN.\n+\t(fold_convert_const_real_from_real): Avoid the operation if\n+\tflag_signaling_nans is on and the operand is an sNaN.\n+\t(integer_valued_real_unary_p): Update comment stating it\n+\treturns false for sNaN values.\n+\t(integer_valued_real_binary_p, integer_valued_real_call_p): Same.\n+\t(integer_valued_real_single_p): Same.\n+\t(integer_valued_real_invalid_p, integer_valued_real_p): Same.\n+\t* fold-const-call.c (fold_const_pow): Avoid the operation\n+\tif flag_signaling_nans is on and the operand is an sNaN.\n+\t(fold_const_builtin_load_exponent) Same.\n+\t(fold_const_call_sss): Same for CASE_CFN_POWI.\n+\t* gimple-fold.c (gimple_assign_integer_valued_real_p): Same.\n+\t(gimple_call_integer_valued_real_p): Same.\n+\t(gimple_phi_integer_valued_real_p): Same.\n+\t(gimple_stmt_integer_valued_real_p): Same.\n+\t* simplify-rtx.c (simplify_const_unary_operation): Avoid the\n+\toperation if flag_signaling_nans is on and the operand is an sNaN.\n+\t(simplify_const_binary_operation): Same.\n+\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Avoid the\n+\toperation if flag_signaling_nans is on and the operand is an sNaN.\n+\n 2015-12-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* combine.c (simplify_comparison): Convert preprocessor check of"}, {"sha": "7d1351c3691727c79de5db41aeaa6252136777c0", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -512,7 +512,11 @@ fold_const_pow (real_value *result, const real_value *arg0,\n \t  || !real_equal (arg0, &dconst0)))\n     {\n       bool inexact = real_powi (result, format, arg0, n1);\n-      if (flag_unsafe_math_optimizations || !inexact)\n+      /* Avoid the folding if flag_signaling_nans is on.  */\n+      if (flag_unsafe_math_optimizations\n+\t  || (!inexact\n+\t      && !(flag_signaling_nans\n+\t           && REAL_VALUE_ISSIGNALING_NAN (*arg0))))\n \treturn true;\n     }\n \n@@ -541,6 +545,13 @@ fold_const_builtin_load_exponent (real_value *result, const real_value *arg0,\n   if (wi::les_p (arg1, -max_exp_adj) || wi::ges_p (arg1, max_exp_adj))\n     return false;\n \n+  /* Don't perform operation if we honor signaling NaNs and\n+     operand is a signaling NaN.  */\n+  if (!flag_unsafe_math_optimizations\n+      && flag_signaling_nans\n+      && REAL_VALUE_ISSIGNALING_NAN (*arg0))\n+    return false;\n+\n   REAL_VALUE_TYPE initial_result;\n   real_ldexp (&initial_result, arg0, arg1.to_shwi ());\n \n@@ -1202,6 +1213,13 @@ fold_const_call_sss (real_value *result, combined_fn fn,\n \t\t\t\t\t\t   format));\n \n     CASE_CFN_POWI:\n+      /* Avoid the folding if flag_signaling_nans is on and\n+         operand is a signaling NaN.  */\n+      if (!flag_unsafe_math_optimizations\n+\t  && flag_signaling_nans\n+\t  && REAL_VALUE_ISSIGNALING_NAN (*arg0))\n+        return false;\n+\n       real_powi (result, format, arg0, arg1.to_shwi ());\n       return true;\n "}, {"sha": "5ad5112992226d0bac5fdd506809ca6f9d527d5b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -1166,9 +1166,21 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n       /* If either operand is a NaN, just return it.  Otherwise, set up\n \t for floating-point trap; we return an overflow.  */\n       if (REAL_VALUE_ISNAN (d1))\n-\treturn arg1;\n+      {\n+\t/* Make resulting NaN value to be qNaN when flag_signaling_nans\n+\t   is off.  */\n+\td1.signalling = 0;\n+\tt = build_real (type, d1);\n+\treturn t;\n+      }\n       else if (REAL_VALUE_ISNAN (d2))\n-\treturn arg2;\n+      {\n+\t/* Make resulting NaN value to be qNaN when flag_signaling_nans\n+\t   is off.  */\n+\td2.signalling = 0;\n+\tt = build_real (type, d2);\n+\treturn t;\n+      }\n \n       inexact = real_arithmetic (&value, code, &d1, &d2);\n       real_convert (&result, mode, &value);\n@@ -1538,6 +1550,15 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n tree\n const_unop (enum tree_code code, tree type, tree arg0)\n {\n+  /* Don't perform the operation, other than NEGATE and ABS, if\n+     flag_signaling_nans is on and the operand is a signaling NaN.  */\n+  if (TREE_CODE (arg0) == REAL_CST\n+      && HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n+      && REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (arg0))\n+      && code != NEGATE_EXPR\n+      && code != ABS_EXPR)\n+    return NULL_TREE;\n+\n   switch (code)\n     {\n     CASE_CONVERT:\n@@ -1949,6 +1970,12 @@ fold_convert_const_real_from_real (tree type, const_tree arg1)\n   REAL_VALUE_TYPE value;\n   tree t;\n \n+  /* Don't perform the operation if flag_signaling_nans is on\n+     and the operand is a signaling NaN.  */\n+  if (HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1)))\n+      && REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (arg1)))\n+    return NULL_TREE; \n+\n   real_convert (&value, TYPE_MODE (type), &TREE_REAL_CST (arg1));\n   t = build_real (type, value);\n \n@@ -13414,7 +13441,7 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \n /* Return true if the floating point result of (CODE OP0) has an\n    integer value.  We also allow +Inf, -Inf and NaN to be considered\n-   integer values.\n+   integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -13447,7 +13474,7 @@ integer_valued_real_unary_p (tree_code code, tree op0, int depth)\n \n /* Return true if the floating point result of (CODE OP0 OP1) has an\n    integer value.  We also allow +Inf, -Inf and NaN to be considered\n-   integer values.\n+   integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -13471,8 +13498,8 @@ integer_valued_real_binary_p (tree_code code, tree op0, tree op1, int depth)\n \n /* Return true if the floating point result of calling FNDECL with arguments\n    ARG0 and ARG1 has an integer value.  We also allow +Inf, -Inf and NaN to be\n-   considered integer values.  If FNDECL takes fewer than 2 arguments,\n-   the remaining ARGn are null.\n+   considered integer values. Return false for signaling NaN.  If FNDECL\n+   takes fewer than 2 arguments, the remaining ARGn are null.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -13501,7 +13528,7 @@ integer_valued_real_call_p (combined_fn fn, tree arg0, tree arg1, int depth)\n \n /* Return true if the floating point expression T (a GIMPLE_SINGLE_RHS)\n    has an integer value.  We also allow +Inf, -Inf and NaN to be\n-   considered integer values.\n+   considered integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -13535,7 +13562,7 @@ integer_valued_real_single_p (tree t, int depth)\n \n /* Return true if the floating point expression T (a GIMPLE_INVALID_RHS)\n    has an integer value.  We also allow +Inf, -Inf and NaN to be\n-   considered integer values.\n+   considered integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -13563,6 +13590,7 @@ integer_valued_real_invalid_p (tree t, int depth)\n \n /* Return true if the floating point expression T has an integer value.\n    We also allow +Inf, -Inf and NaN to be considered integer values.\n+   Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n "}, {"sha": "eddb18d4db6ea259acce47ac43ccf436a23a6522", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -6267,7 +6267,7 @@ gimple_stmt_nonnegative_warnv_p (gimple *stmt, bool *strict_overflow_p,\n \n /* Return true if the floating-point value computed by assignment STMT\n    is known to have an integer value.  We also allow +Inf, -Inf and NaN\n-   to be considered integer values.\n+   to be considered integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -6296,7 +6296,7 @@ gimple_assign_integer_valued_real_p (gimple *stmt, int depth)\n \n /* Return true if the floating-point value computed by call STMT is known\n    to have an integer value.  We also allow +Inf, -Inf and NaN to be\n-   considered integer values.\n+   considered integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -6315,7 +6315,7 @@ gimple_call_integer_valued_real_p (gimple *stmt, int depth)\n \n /* Return true if the floating-point result of phi STMT is known to have\n    an integer value.  We also allow +Inf, -Inf and NaN to be considered\n-   integer values.\n+   integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n \n@@ -6333,7 +6333,7 @@ gimple_phi_integer_valued_real_p (gimple *stmt, int depth)\n \n /* Return true if the floating-point value computed by STMT is known\n    to have an integer value.  We also allow +Inf, -Inf and NaN to be\n-   considered integer values.\n+   considered integer values. Return false for signaling NaN.\n \n    DEPTH is the current nesting depth of the query.  */\n "}, {"sha": "44de1555dc56e86b8217e9037a648329f70391a9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -1703,6 +1703,12 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t}\n \n       real_from_integer (&d, mode, std::make_pair (op, op_mode), SIGNED);\n+\n+      /* Avoid the folding if flag_signaling_nans is on and\n+         operand is a signaling NaN.  */\n+      if (HONOR_SNANS (mode) && REAL_VALUE_ISSIGNALING_NAN (d))\n+        return 0;\n+\n       d = real_value_truncate (mode, d);\n       return const_double_from_real_value (d, mode);\n     }\n@@ -1721,6 +1727,12 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t}\n \n       real_from_integer (&d, mode, std::make_pair (op, op_mode), UNSIGNED);\n+\n+      /* Avoid the folding if flag_signaling_nans is on and\n+         operand is a signaling NaN.  */\n+      if (HONOR_SNANS (mode) && REAL_VALUE_ISSIGNALING_NAN (d))\n+        return 0;\n+\n       d = real_value_truncate (mode, d);\n       return const_double_from_real_value (d, mode);\n     }\n@@ -1825,16 +1837,25 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \t  d = real_value_negate (&d);\n \t  break;\n \tcase FLOAT_TRUNCATE:\n-\t  d = real_value_truncate (mode, d);\n+\t  /* Don't perform the operation if flag_signaling_nans is on\n+\t     and the operand is a signaling NaN.  */\n+\t  if (!(HONOR_SNANS (mode) && REAL_VALUE_ISSIGNALING_NAN (d)))\n+\t    d = real_value_truncate (mode, d);\n \t  break;\n \tcase FLOAT_EXTEND:\n \t  /* All this does is change the mode, unless changing\n \t     mode class.  */\n-\t  if (GET_MODE_CLASS (mode) != GET_MODE_CLASS (GET_MODE (op)))\n+\t  /* Don't perform the operation if flag_signaling_nans is on\n+\t     and the operand is a signaling NaN.  */\n+\t  if (GET_MODE_CLASS (mode) != GET_MODE_CLASS (GET_MODE (op))\n+\t      && !(HONOR_SNANS (mode) && REAL_VALUE_ISSIGNALING_NAN (d)))\n \t    real_convert (&d, mode, &d);\n \t  break;\n \tcase FIX:\n-\t  real_arithmetic (&d, FIX_TRUNC_EXPR, &d, NULL);\n+\t  /* Don't perform the operation if flag_signaling_nans is on\n+\t     and the operand is a signaling NaN.  */\n+\t  if (!(HONOR_SNANS (mode) && REAL_VALUE_ISSIGNALING_NAN (d)))\n+\t    real_arithmetic (&d, FIX_TRUNC_EXPR, &d, NULL);\n \t  break;\n \tcase NOT:\n \t  {\n@@ -3886,16 +3907,20 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n       else\n \t{\n \t  REAL_VALUE_TYPE f0, f1, value, result;\n+\t  const REAL_VALUE_TYPE *opr0, *opr1;\n \t  bool inexact;\n \n-\t  real_convert (&f0, mode, CONST_DOUBLE_REAL_VALUE (op0));\n-\t  real_convert (&f1, mode, CONST_DOUBLE_REAL_VALUE (op1));\n+\t  opr0 = CONST_DOUBLE_REAL_VALUE (op0);\n+\t  opr1 = CONST_DOUBLE_REAL_VALUE (op1);\n \n \t  if (HONOR_SNANS (mode)\n-\t      && (REAL_VALUE_ISSIGNALING_NAN (f0)\n-\t          || REAL_VALUE_ISSIGNALING_NAN (f1)))\n+\t      && (REAL_VALUE_ISSIGNALING_NAN (*opr0)\n+\t          || REAL_VALUE_ISSIGNALING_NAN (*opr1)))\n \t    return 0;\n \n+\t  real_convert (&f0, mode, opr0);\n+\t  real_convert (&f1, mode, opr1);\n+\n \t  if (code == DIV\n \t      && real_equal (&f1, &dconst0)\n \t      && (flag_trapping_math || ! MODE_HAS_INFINITIES (mode)))"}, {"sha": "d5c679e63e2f3632edc888cc010603cf8008f350", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -1,3 +1,7 @@\n+2015-12-22  Sujoy Saraswati  <sujoy.saraswati@hpe.com>\n+\n+\t* gcc.dg/pr61441.c: New testcase.\n+\n 2015-12-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/torture/pr68264.c: Tweak for Solaris."}, {"sha": "608a763b31fca868b7c8a3d54c6a05fecafd38ff", "filename": "gcc/testsuite/gcc.dg/pr61441.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61441.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61441.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61441.c?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O1 -lm\" } */\n+\n+#define _GNU_SOURCE\n+#include <stdio.h>\n+#include <math.h>\n+\n+void conversion()\n+{\n+  float sNaN = __builtin_nansf (\"\");\n+  double x = (double) sNaN;\n+  if (issignaling(x))\n+  {\n+    __builtin_abort();\n+  }\n+}\n+\n+enum op {Add, Mult, Div, Abs};\n+\n+void operation(enum op t)\n+{\n+  float x, y;\n+  float sNaN = __builtin_nansf (\"\");\n+  switch (t)\n+  {\n+    case Abs:\n+      x = fabs(sNaN);\n+      break;\n+    case Add:\n+      x = sNaN + 2.0;\n+      break;\n+    case Mult:\n+      x = sNaN * 2.0;\n+      break;\n+    case Div:\n+    default:\n+      x = sNaN / 2.0;\n+      break;\n+  }\n+  if (t == Abs)\n+  {\n+    if (!issignaling(x))\n+    {\n+      __builtin_abort();\n+    }\n+  }\n+  else if (issignaling(x))\n+  {\n+    __builtin_abort();\n+  }\n+}\n+\n+int main (void)\n+{\n+  conversion();\n+  operation(Add);\n+  operation(Mult);\n+  operation(Div);\n+  operation(Abs);\n+  return 0;\n+}"}, {"sha": "244cf196277778ad1acef403a8cd58ec4481cd99", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a00b0aaf036edadc48861b91d3804796525c2d5/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=5a00b0aaf036edadc48861b91d3804796525c2d5", "patch": "@@ -1535,6 +1535,13 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n   if (TREE_CODE (arg1) != REAL_CST)\n     return NULL_TREE;\n \n+  /* Don't perform the operation if flag_signaling_nans is on\n+     and the operand is a signaling NaN.  */\n+  if (HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1)))\n+      && (REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (arg0))\n+\t  || REAL_VALUE_ISSIGNALING_NAN (TREE_REAL_CST (arg1))))\n+    return NULL_TREE;\n+\n   /* If the exponent is equivalent to an integer, expand to an optimal\n      multiplication sequence when profitable.  */\n   c = TREE_REAL_CST (arg1);"}]}