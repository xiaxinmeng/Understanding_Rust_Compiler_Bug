{"sha": "164709cfe671e51fcf6c687847549f01a51366c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY0NzA5Y2ZlNjcxZTUxZmNmNmM2ODc4NDc1NDlmMDFhNTEzNjZjNA==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2009-08-16T16:22:59Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2009-08-16T16:22:59Z"}, "message": "avr.h (AVR_HAVE_8BIT_SP): New macros.\n\n\t* config/avr/avr.h (AVR_HAVE_8BIT_SP): New macros.\n\t* config/avr/avr.c (avr_override_options): Initialize\n\tavr_current_arch variable.\n\t(avr_cpu_cpp_builtins): Define __AVR_HAVE_8BIT_SP__ or\n\t__AVR_HAVE_16BIT_SP__ according to the device type.\n\t(expand_prologue, output_movhi): Use AVR_HAVE_8BIT_SP instead of\n\tTARGET_TINY_STACK.\n\t(expand_epilogue): Use correct QI mode frame pointer for tiny stack.\n\tUse AVR_HAVE_8BIT_SP instead of TARGET_TINY_STACK.\n\nFrom-SVN: r150801", "tree": {"sha": "0cdb00299fb3e8a4e891564994fd9d7be7ad49c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cdb00299fb3e8a4e891564994fd9d7be7ad49c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/164709cfe671e51fcf6c687847549f01a51366c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164709cfe671e51fcf6c687847549f01a51366c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/164709cfe671e51fcf6c687847549f01a51366c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164709cfe671e51fcf6c687847549f01a51366c4/comments", "author": null, "committer": null, "parents": [{"sha": "354ebf88ee1806c4d9b279c765d2d344303ffc66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/354ebf88ee1806c4d9b279c765d2d344303ffc66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/354ebf88ee1806c4d9b279c765d2d344303ffc66"}], "stats": {"total": 36, "additions": 28, "deletions": 8}, "files": [{"sha": "f1317f0ba64a09c7991cc6d7c6e8c903825a209e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/164709cfe671e51fcf6c687847549f01a51366c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/164709cfe671e51fcf6c687847549f01a51366c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=164709cfe671e51fcf6c687847549f01a51366c4", "patch": "@@ -1,3 +1,15 @@\n+2009-08-16  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/avr/avr.h (AVR_HAVE_8BIT_SP): New macros.\n+\t* config/avr/avr.c (avr_override_options): Initialize\n+\tavr_current_arch variable.\n+\t(avr_cpu_cpp_builtins): Define __AVR_HAVE_8BIT_SP__ or\n+\t__AVR_HAVE_16BIT_SP__ according to the device type.\n+\t(expand_prologue, output_movhi): Use AVR_HAVE_8BIT_SP instead of\n+\tTARGET_TINY_STACK.\n+\t(expand_epilogue): Use correct QI mode frame pointer for tiny stack.\n+\tUse AVR_HAVE_8BIT_SP instead of TARGET_TINY_STACK.\n+\n 2009-08-16  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR debug/37801"}, {"sha": "d08d89fb697fde19efb76f174689b24d642e3cc1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/164709cfe671e51fcf6c687847549f01a51366c4/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/164709cfe671e51fcf6c687847549f01a51366c4/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=164709cfe671e51fcf6c687847549f01a51366c4", "patch": "@@ -213,8 +213,9 @@ avr_override_options (void)\n \tfprintf (stderr,\"   %s\\n\", t->name);\n     }\n \n-  avr_current_arch = &avr_arch_types[t->arch];\n-  avr_extra_arch_macro = t->macro;\n+  avr_current_device = t;\n+  avr_current_arch = &avr_arch_types[avr_current_device->arch];\n+  avr_extra_arch_macro = avr_current_device->macro;\n \n   tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);\n   zero_reg_rtx = gen_rtx_REG (QImode, ZERO_REGNO);\n@@ -265,6 +266,12 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n     {\n       cpp_define (pfile, \"__AVR_2_BYTE_PC__\");\n     }\n+\n+  if (avr_current_device->short_sp)\n+    cpp_define (pfile, \"__AVR_HAVE_8BIT_SP__\");\n+  else\n+    cpp_define (pfile, \"__AVR_HAVE_16BIT_SP__\");\n+\n   if (TARGET_NO_INTERRUPTS)\n     cpp_define (pfile, \"__NO_INTERRUPTS__\");\n }\n@@ -672,7 +679,7 @@ expand_prologue (void)\n \t      rtx fp_plus_insns; \n \t      rtx sp_plus_insns = NULL_RTX;\n \n-              if (TARGET_TINY_STACK)\n+              if (AVR_HAVE_8BIT_SP)\n                 {\n                   /* The high byte (r29) doesn't change - prefer 'subi' (1 cycle)\n                      over 'sbiw' (2 cycles, same size).  */\n@@ -698,7 +705,7 @@ expand_prologue (void)\n               RTX_FRAME_RELATED_P (insn) = 1;\n \n \t      /* Copy to stack pointer.  */\n-\t      if (TARGET_TINY_STACK)\n+\t      if (AVR_HAVE_8BIT_SP)\n \t\t{\n \t\t  insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -852,7 +859,7 @@ expand_epilogue (void)\n \t      rtx fp_plus_insns;\n \t      rtx sp_plus_insns = NULL_RTX;\n \t      \n-\t      if (TARGET_TINY_STACK)\n+\t      if (AVR_HAVE_8BIT_SP)\n                 {\n                   /* The high byte (r29) doesn't change - prefer 'subi' \n                      (1 cycle) over 'sbiw' (2 cycles, same size).  */\n@@ -868,12 +875,12 @@ expand_epilogue (void)\n \t      start_sequence ();\n \n \t      emit_move_insn (myfp,\n-\t\t\t      gen_rtx_PLUS (HImode, myfp,\n+\t\t\t      gen_rtx_PLUS (GET_MODE (myfp), myfp,\n \t\t\t\t\t    gen_int_mode (size, \n \t\t\t\t\t\t\t  GET_MODE(myfp))));\n \n \t      /* Copy to stack pointer.  */\n-\t      if (TARGET_TINY_STACK)\n+\t      if (AVR_HAVE_8BIT_SP)\n \t\t{\n \t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n \t\t}\n@@ -1686,7 +1693,7 @@ output_movhi (rtx insn, rtx operands[], int *l)\n \t{\n \t  if (test_hard_reg_class (STACK_REG, dest))\n \t    {\n-\t      if (TARGET_TINY_STACK)\n+\t      if (AVR_HAVE_8BIT_SP)\n \t\treturn *l = 1, AS2 (out,__SP_L__,%A1);\n               /* Use simple load of stack pointer if no interrupts are \n \t\t used.  */"}, {"sha": "7100ad17fe8c1ab4ff0a714fdb03581740a4a893", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/164709cfe671e51fcf6c687847549f01a51366c4/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/164709cfe671e51fcf6c687847549f01a51366c4/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=164709cfe671e51fcf6c687847549f01a51366c4", "patch": "@@ -114,6 +114,7 @@ extern GTY(()) section *progmem_section;\n #define AVR_HAVE_LPMX (avr_current_arch->have_movw_lpmx)\n #define AVR_HAVE_RAMPZ (avr_current_arch->have_elpm)\n #define AVR_HAVE_EIJMP_EICALL (avr_current_arch->have_eijmp_eicall)\n+#define AVR_HAVE_8BIT_SP (avr_current_device->short_sp || TARGET_TINY_STACK)\n \n #define AVR_2_BYTE_PC (!AVR_HAVE_EIJMP_EICALL)\n #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)"}]}