{"sha": "3d529af452fe7c618ab440f2cc1c07c445d6a72e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q1MjlhZjQ1MmZlN2M2MThhYjQ0MGYyY2MxYzA3YzQ0NWQ2YTcyZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-07-08T07:57:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T07:57:16Z"}, "message": "sem_dim.adb: Minor error message change.\n\n2013-07-08  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_dim.adb: Minor error message change.\n\t* freeze.adb (Freeze_Entity, array type case): Extend handling\n\tof Implicit_Packing to handle multi-dimensional array case.\n\t* gnat_rm.texi: Update doc on Implicit_Packing.\n\nFrom-SVN: r200762", "tree": {"sha": "4c163fa4e7bb96bd73f0c5878aad93fd59ca7d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c163fa4e7bb96bd73f0c5878aad93fd59ca7d79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d529af452fe7c618ab440f2cc1c07c445d6a72e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d529af452fe7c618ab440f2cc1c07c445d6a72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d529af452fe7c618ab440f2cc1c07c445d6a72e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d529af452fe7c618ab440f2cc1c07c445d6a72e/comments", "author": null, "committer": null, "parents": [{"sha": "08daa7828efe5443383b2553e964c21aaed17cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08daa7828efe5443383b2553e964c21aaed17cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08daa7828efe5443383b2553e964c21aaed17cdf"}], "stats": {"total": 167, "additions": 95, "deletions": 72}, "files": [{"sha": "93f4b785414488c7ab31363799e9d8a16bfa554f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3d529af452fe7c618ab440f2cc1c07c445d6a72e", "patch": "@@ -1,3 +1,10 @@\n+2013-07-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_dim.adb: Minor error message change.\n+\t* freeze.adb (Freeze_Entity, array type case): Extend handling\n+\tof Implicit_Packing to handle multi-dimensional array case.\n+\t* gnat_rm.texi: Update doc on Implicit_Packing.\n+\n 2013-07-08  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb: Minor reformatting."}, {"sha": "43720a99e4a52eec2096c2378ab5b05e872f1601", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 83, "deletions": 69, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3d529af452fe7c618ab440f2cc1c07c445d6a72e", "patch": "@@ -3413,20 +3413,31 @@ package body Freeze is\n \n             --  Before we do anything else, a specialized test for the case of\n             --  a size given for an array where the array needs to be packed,\n-            --  but was not so the size cannot be honored. This would of course\n-            --  be caught by the backend, and indeed we don't catch all cases.\n-            --  The point is that we can give a better error message in those\n-            --  cases that we do catch with the circuitry here. Also if pragma\n-            --  Implicit_Packing is set, this is where the packing occurs.\n-\n-            --  The reason we do this so early is that the processing in the\n-            --  automatic packing case affects the layout of the base type, so\n-            --  it must be done before we freeze the base type.\n+            --  but was not so the size cannot be honored. This is the case\n+            --  where implicit packing may apply. The reason we do this so\n+            --  early is that if we have implicit packing, the lagout of the\n+            --  base type is affected, so we must do this before we freeze\n+            --  the base type.\n+\n+            --  We could do this processing only if implicit packing is enabled\n+            --  since in all other cases, the error would be caught by the back\n+            --  end. However, we choose to do the check even if we do not have\n+            --  implicit packingh enabled, since this allows us to give a more\n+            --  useful error message (advising the use of pack or the pragma).\n \n             if Is_Array_Type (E) then\n                declare\n-                  Lo, Hi : Node_Id;\n-                  Ctyp   : constant Entity_Id := Component_Type (E);\n+                  Ctyp : constant Entity_Id := Component_Type (E);\n+                  Rsiz : constant Uint      := RM_Size (Ctyp);\n+                  SZ   : constant Node_Id   := Size_Clause (E);\n+                  Btyp : constant Entity_Id := Base_Type (E);\n+\n+                  Lo   : Node_Id;\n+                  Hi   : Node_Id;\n+                  Indx : Node_Id;\n+\n+                  Num_Elmts : Uint;\n+                  --  Number of elements in array\n \n                begin\n                   --  Check enabling conditions. These are straightforward\n@@ -3441,87 +3452,90 @@ package body Freeze is\n                   --  a chance to freeze the base type (and it is that freeze\n                   --  action that causes stuff to be inherited).\n \n-                  if Present (Size_Clause (E))\n+                  if Has_Size_Clause (E)\n                     and then Known_Static_RM_Size (E)\n                     and then not Is_Packed (E)\n                     and then not Has_Pragma_Pack (E)\n-                    and then Number_Dimensions (E) = 1\n                     and then not Has_Component_Size_Clause (E)\n                     and then Known_Static_RM_Size (Ctyp)\n+                    and then RM_Size (Ctyp) < 64\n                     and then not Is_Limited_Composite (E)\n                     and then not Is_Packed (Root_Type (E))\n                     and then not Has_Component_Size_Clause (Root_Type (E))\n                     and then not (CodePeer_Mode or SPARK_Mode)\n                   then\n-                     Get_Index_Bounds (First_Index (E), Lo, Hi);\n+                     --  Compute number of elements in array\n \n-                     if Compile_Time_Known_Value (Lo)\n-                       and then Compile_Time_Known_Value (Hi)\n-                       and then Known_Static_RM_Size (Ctyp)\n-                       and then RM_Size (Ctyp) < 64\n-                     then\n-                        declare\n-                           Lov  : constant Uint      := Expr_Value (Lo);\n-                           Hiv  : constant Uint      := Expr_Value (Hi);\n-                           Len  : constant Uint      := UI_Max\n-                                                         (Uint_0,\n-                                                          Hiv - Lov + 1);\n-                           Rsiz : constant Uint      := RM_Size (Ctyp);\n-                           SZ   : constant Node_Id   := Size_Clause (E);\n-                           Btyp : constant Entity_Id := Base_Type (E);\n-\n-                        --  What we are looking for here is the situation where\n-                        --  the RM_Size given would be exactly right if there\n-                        --  was a pragma Pack (resulting in the component size\n-                        --  being the same as the RM_Size). Furthermore, the\n-                        --  component type size must be an odd size (not a\n-                        --  multiple of storage unit). If the component RM size\n-                        --  is an exact number of storage units that is a power\n-                        --  of two, the array is not packed and has a standard\n-                        --  representation.\n+                     Num_Elmts := Uint_1;\n+                     Indx := First_Index (E);\n+                     while Present (Indx) loop\n+                        Get_Index_Bounds (Indx, Lo, Hi);\n \n-                        begin\n-                           if RM_Size (E) = Len * Rsiz\n-                             and then Rsiz mod System_Storage_Unit /= 0\n-                           then\n-                              --  For implicit packing mode, just set the\n-                              --  component size silently.\n+                        if not (Compile_Time_Known_Value (Lo)\n+                                  and then\n+                                Compile_Time_Known_Value (Hi))\n+                        then\n+                           goto No_Implicit_Packing;\n+                        end if;\n+\n+                        Num_Elmts :=\n+                          Num_Elmts *\n+                            UI_Max (Uint_0,\n+                                    Expr_Value (Hi) - Expr_Value (Lo) + 1);\n+                        Next_Index (Indx);\n+                     end loop;\n \n-                              if Implicit_Packing then\n-                                 Set_Component_Size       (Btyp, Rsiz);\n-                                 Set_Is_Bit_Packed_Array  (Btyp);\n-                                 Set_Is_Packed            (Btyp);\n-                                 Set_Has_Non_Standard_Rep (Btyp);\n+                     --  What we are looking for here is the situation where\n+                     --  the RM_Size given would be exactly right if there was\n+                     --  a pragma Pack (resulting in the component size being\n+                     --  the same as the RM_Size). Furthermore, the component\n+                     --  type size must be an odd size (not a multiple of\n+                     --  storage unit). If the component RM size is an exact\n+                     --  number of storage units that is a power of two, the\n+                     --  array is not packed and has a standard representation.\n+\n+                     if RM_Size (E) = Num_Elmts * Rsiz\n+                       and then Rsiz mod System_Storage_Unit /= 0\n+                     then\n+                        --  For implicit packing mode, just set the component\n+                        --  size silently.\n \n-                              --  Otherwise give an error message\n+                        if Implicit_Packing then\n+                           Set_Component_Size       (Btyp, Rsiz);\n+                           Set_Is_Bit_Packed_Array  (Btyp);\n+                           Set_Is_Packed            (Btyp);\n+                           Set_Has_Non_Standard_Rep (Btyp);\n \n-                              else\n-                                 Error_Msg_NE\n-                                   (\"size given for& too small\", SZ, E);\n-                                 Error_Msg_N -- CODEFIX\n-                                   (\"\\use explicit pragma Pack \"\n-                                    & \"or use pragma Implicit_Packing\", SZ);\n-                              end if;\n+                           --  Otherwise give an error message\n \n-                           elsif RM_Size (E) = Len * Rsiz\n-                             and then Implicit_Packing\n-                             and then\n-                               (Rsiz / System_Storage_Unit = 1\n-                                 or else Rsiz / System_Storage_Unit = 2\n-                                 or else Rsiz / System_Storage_Unit = 4)\n-                           then\n+                        else\n+                           Error_Msg_NE\n+                             (\"size given for& too small\", SZ, E);\n+                           Error_Msg_N -- CODEFIX\n+                             (\"\\use explicit pragma Pack \"\n+                              & \"or use pragma Implicit_Packing\", SZ);\n+                        end if;\n \n-                              --  Not a packed array, but indicate the desired\n-                              --  component size, for the back-end.\n+                     elsif RM_Size (E) = Num_Elmts * Rsiz\n+                       and then Implicit_Packing\n+                       and then\n+                         (Rsiz / System_Storage_Unit = 1\n+                            or else\n+                          Rsiz / System_Storage_Unit = 2\n+                            or else\n+                          Rsiz / System_Storage_Unit = 4)\n+                     then\n+                        --  Not a packed array, but indicate the desired\n+                        --  component size, for the back-end.\n \n-                              Set_Component_Size (Btyp, Rsiz);\n-                           end if;\n-                        end;\n+                        Set_Component_Size (Btyp, Rsiz);\n                      end if;\n                   end if;\n                end;\n             end if;\n \n+            <<No_Implicit_Packing>>\n+\n             --  If ancestor subtype present, freeze that first. Note that this\n             --  will also get the base type frozen. Need RM reference ???\n "}, {"sha": "11b6bb671c484a42065bf5b634063ef584f7d791", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=3d529af452fe7c618ab440f2cc1c07c445d6a72e", "patch": "@@ -3255,8 +3255,10 @@ of the configuration pragma Implicit_Packing, then the Size clause in this\n and similar examples will cause implicit packing and thus be accepted. For\n this implicit packing to occur, the type in question must be an array of small\n components whose size is known at compile time, and the Size clause must\n-specify the exact size that corresponds to the length of the array multiplied\n-by the size in bits of the component type.\n+specify the exact size that corresponds to the number of elements in the array\n+multiplied by the size in bits of the component type (both single and\n+multi-dimensioned arrays can be controlled with this pragma).\n+\n @cindex Array packing\n \n Similarly, the following example shows the use in the record case"}, {"sha": "79c1e15037aa44b013a1ef800d06143e031d5bd4", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d529af452fe7c618ab440f2cc1c07c445d6a72e/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=3d529af452fe7c618ab440f2cc1c07c445d6a72e", "patch": "@@ -1409,7 +1409,7 @@ package body Sem_Dim is\n                if L_Has_Dimensions then\n                   if not Compile_Time_Known_Value (R) then\n                      Error_Msg_N (\"exponent of dimensioned operand must be \" &\n-                                  \"known at compile-time\", N);\n+                                  \"known at compile time\", N);\n                   end if;\n \n                   declare"}]}