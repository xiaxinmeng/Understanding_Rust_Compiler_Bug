{"sha": "4efd8968f8bf48265f18022b4eda5e7a99c24445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVmZDg5NjhmOGJmNDgyNjVmMTgwMjJiNGVkYTVlN2E5OWMyNDQ0NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-17T11:21:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-17T11:21:49Z"}, "message": "re PR tree-optimization/91178 (Infinite recursion in split_constant_offset in slp after r260289)\n\n2019-07-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91178\n\t* tree-ssa.c (release_defs_bitset): Iterate from higher to\n\tlower SSA names to avoid quadratic behavior in the common case.\n\t* tree-data-ref.c (split_constant_offset): Add limit argument\n\tand pass it down.  Initialize it from PARAM_SSA_NAME_DEF_CHAIN_LIMIT.\n\t(split_constant_offset_1): Add limit argument and use it to\n\tlimit SSA def walking.  Optimize the common plus/minus case.\n\nFrom-SVN: r273550", "tree": {"sha": "bcfe295ba1532602ee14041d8026f81eea21cf11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcfe295ba1532602ee14041d8026f81eea21cf11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4efd8968f8bf48265f18022b4eda5e7a99c24445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efd8968f8bf48265f18022b4eda5e7a99c24445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4efd8968f8bf48265f18022b4eda5e7a99c24445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efd8968f8bf48265f18022b4eda5e7a99c24445/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7921a90e334117206c6bb78bad57e07fb242214c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7921a90e334117206c6bb78bad57e07fb242214c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7921a90e334117206c6bb78bad57e07fb242214c"}], "stats": {"total": 85, "additions": 58, "deletions": 27}, "files": [{"sha": "f13d8a6a9a4016a27a46f90cf843e9265f6c2ac9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efd8968f8bf48265f18022b4eda5e7a99c24445/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efd8968f8bf48265f18022b4eda5e7a99c24445/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4efd8968f8bf48265f18022b4eda5e7a99c24445", "patch": "@@ -1,3 +1,13 @@\n+2019-07-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91178\n+\t* tree-ssa.c (release_defs_bitset): Iterate from higher to\n+\tlower SSA names to avoid quadratic behavior in the common case.\n+\t* tree-data-ref.c (split_constant_offset): Add limit argument\n+\tand pass it down.  Initialize it from PARAM_SSA_NAME_DEF_CHAIN_LIMIT.\n+\t(split_constant_offset_1): Add limit argument and use it to\n+\tlimit SSA def walking.  Optimize the common plus/minus case.\n+\n 2019-07-17  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91178"}, {"sha": "7f75b7e3afeebd33fda493d942ff7f7160102d39", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efd8968f8bf48265f18022b4eda5e7a99c24445/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efd8968f8bf48265f18022b4eda5e7a99c24445/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=4efd8968f8bf48265f18022b4eda5e7a99c24445", "patch": "@@ -583,7 +583,8 @@ debug_ddrs (vec<ddr_p> ddrs)\n \n static void\n split_constant_offset (tree exp, tree *var, tree *off,\n-\t\t       hash_map<tree, std::pair<tree, tree> > &cache);\n+\t\t       hash_map<tree, std::pair<tree, tree> > &cache,\n+\t\t       unsigned *limit);\n \n /* Helper function for split_constant_offset.  Expresses OP0 CODE OP1\n    (the type of the result is TYPE) as VAR + OFF, where OFF is a nonzero\n@@ -594,7 +595,8 @@ split_constant_offset (tree exp, tree *var, tree *off,\n static bool\n split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\t\t tree *var, tree *off,\n-\t\t\t hash_map<tree, std::pair<tree, tree> > &cache)\n+\t\t\t hash_map<tree, std::pair<tree, tree> > &cache,\n+\t\t\t unsigned *limit)\n {\n   tree var0, var1;\n   tree off0, off1;\n@@ -615,8 +617,15 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n       /* FALLTHROUGH */\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      split_constant_offset (op0, &var0, &off0, cache);\n-      split_constant_offset (op1, &var1, &off1, cache);\n+      if (TREE_CODE (op1) == INTEGER_CST)\n+\t{\n+\t  split_constant_offset (op0, &var0, &off0, cache, limit);\n+\t  *var = var0;\n+\t  *off = size_binop (ocode, off0, fold_convert (ssizetype, op1));\n+\t  return true;\n+\t}\n+      split_constant_offset (op0, &var0, &off0, cache, limit);\n+      split_constant_offset (op1, &var1, &off1, cache, limit);\n       *var = fold_build2 (code, type, var0, var1);\n       *off = size_binop (ocode, off0, off1);\n       return true;\n@@ -625,7 +634,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n       if (TREE_CODE (op1) != INTEGER_CST)\n \treturn false;\n \n-      split_constant_offset (op0, &var0, &off0, cache);\n+      split_constant_offset (op0, &var0, &off0, cache, limit);\n       *var = fold_build2 (MULT_EXPR, type, var0, op1);\n       *off = size_binop (MULT_EXPR, off0, fold_convert (ssizetype, op1));\n       return true;\n@@ -649,7 +658,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \n \tif (poffset)\n \t  {\n-\t    split_constant_offset (poffset, &poffset, &off1, cache);\n+\t    split_constant_offset (poffset, &poffset, &off1, cache, limit);\n \t    off0 = size_binop (PLUS_EXPR, off0, off1);\n \t    if (POINTER_TYPE_P (TREE_TYPE (base)))\n \t      base = fold_build_pointer_plus (base, poffset);\n@@ -719,11 +728,15 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t    e = std::make_pair (op0, ssize_int (0));\n \t  }\n \n+\tif (*limit == 0)\n+\t  return false;\n+\t--*limit;\n+\n \tvar0 = gimple_assign_rhs1 (def_stmt);\n \tvar1 = gimple_assign_rhs2 (def_stmt);\n \n \tbool res = split_constant_offset_1 (type, var0, subcode, var1,\n-\t\t\t\t\t    var, off, cache);\n+\t\t\t\t\t    var, off, cache, limit);\n \tif (res && use_cache)\n \t  *cache.get (op0) = std::make_pair (*var, *off);\n \treturn res;\n@@ -746,7 +759,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\t/* Split the unconverted operand and try to prove that\n \t\t   wrapping isn't a problem.  */\n \t\ttree tmp_var, tmp_off;\n-\t\tsplit_constant_offset (op0, &tmp_var, &tmp_off, cache);\n+\t\tsplit_constant_offset (op0, &tmp_var, &tmp_off, cache, limit);\n \n \t\t/* See whether we have an SSA_NAME whose range is known\n \t\t   to be [A, B].  */\n@@ -781,7 +794,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\t*off = wide_int_to_tree (ssizetype, diff);\n \t      }\n \t    else\n-\t      split_constant_offset (op0, &var0, off, cache);\n+\t      split_constant_offset (op0, &var0, off, cache, limit);\n \t    *var = fold_convert (type, var0);\n \t    return true;\n \t  }\n@@ -798,7 +811,8 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \n static void\n split_constant_offset (tree exp, tree *var, tree *off,\n-\t\t       hash_map<tree, std::pair<tree, tree> > &cache)\n+\t\t       hash_map<tree, std::pair<tree, tree> > &cache,\n+\t\t       unsigned *limit)\n {\n   tree type = TREE_TYPE (exp), op0, op1, e, o;\n   enum tree_code code;\n@@ -812,7 +826,7 @@ split_constant_offset (tree exp, tree *var, tree *off,\n \n   code = TREE_CODE (exp);\n   extract_ops_from_tree (exp, &code, &op0, &op1);\n-  if (split_constant_offset_1 (type, op0, code, op1, &e, &o, cache))\n+  if (split_constant_offset_1 (type, op0, code, op1, &e, &o, cache, limit))\n     {\n       *var = e;\n       *off = o;\n@@ -822,10 +836,11 @@ split_constant_offset (tree exp, tree *var, tree *off,\n void\n split_constant_offset (tree exp, tree *var, tree *off)\n {\n+  unsigned limit = PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT);\n   static hash_map<tree, std::pair<tree, tree> > *cache;\n   if (!cache)\n     cache = new hash_map<tree, std::pair<tree, tree> > (37);\n-  split_constant_offset (exp, var, off, *cache);\n+  split_constant_offset (exp, var, off, *cache, &limit);\n   cache->empty ();\n }\n "}, {"sha": "b4b5c903e13b1695daeff66a680c64fa7da0829d", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4efd8968f8bf48265f18022b4eda5e7a99c24445/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4efd8968f8bf48265f18022b4eda5e7a99c24445/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=4efd8968f8bf48265f18022b4eda5e7a99c24445", "patch": "@@ -559,20 +559,25 @@ release_defs_bitset (bitmap toremove)\n \n   /* Performing a topological sort is probably overkill, this will\n      most likely run in slightly superlinear time, rather than the\n-     pathological quadratic worst case.  */\n+     pathological quadratic worst case.\n+     But iterate from max SSA name version to min one because\n+     that mimics allocation order during code generation behavior best.\n+     Use an array for this which we compact on-the-fly with a NULL\n+     marker moving towards the end of the vector.  */\n+  auto_vec<tree, 16> names;\n+  names.reserve (bitmap_count_bits (toremove) + 1);\n+  names.quick_push (NULL_TREE);\n+  EXECUTE_IF_SET_IN_BITMAP (toremove, 0, j, bi)\n+    names.quick_push (ssa_name (j));\n+\n+  bitmap_tree_view (toremove);\n   while (!bitmap_empty_p (toremove))\n     {\n-      unsigned to_remove_bit = -1U;\n-      EXECUTE_IF_SET_IN_BITMAP (toremove, 0, j, bi)\n+      j = names.length () - 1;\n+      for (unsigned i = names.length () - 1; names[i];)\n \t{\n-\t  if (to_remove_bit != -1U)\n-\t    {\n-\t      bitmap_clear_bit (toremove, to_remove_bit);\n-\t      to_remove_bit = -1U;\n-\t    }\n-\n \t  bool remove_now = true;\n-\t  tree var = ssa_name (j);\n+\t  tree var = names[i];\n \t  gimple *stmt;\n \t  imm_use_iterator uit;\n \n@@ -617,14 +622,15 @@ release_defs_bitset (bitmap toremove)\n \t\t  gsi_remove (&gsi, true);\n \t\t  release_defs (def);\n \t\t}\n-\n-\t      to_remove_bit = j;\n+\t      bitmap_clear_bit (toremove, SSA_NAME_VERSION (var));\n \t    }\n+\t  else\n+\t    --i;\n+\t  if (--j != i)\n+\t    names[i] = names[j];\n \t}\n-      if (to_remove_bit != -1U)\n-\tbitmap_clear_bit (toremove, to_remove_bit);\n     }\n-\n+  bitmap_list_view (toremove);\n }\n \n /* Disable warnings about missing quoting in GCC diagnostics for"}]}