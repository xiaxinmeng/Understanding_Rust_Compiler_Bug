{"sha": "72dd050adedc5652d58794b24f498f0ffcf485e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkZDA1MGFkZWRjNTY1MmQ1ODc5NGIyNGY0OThmMGZmY2Y0ODVlNg==", "commit": {"author": {"name": "Bruno Haible", "email": "bruno@linuix.mathematik.uni-karlsruhe.de", "date": "1998-03-01T17:09:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-01T17:09:39Z"}, "message": "frame.c (start_fde_sort, [...]): New functions for fast sorting of an FDE array.\n\n        * frame.c (start_fde_sort, fde_split, heapsort, fde_merge,\n        end_fde_sort): New functions for fast sorting of an FDE array.\n        (fde_insert): Simplified.\n        (add_fdes): Change argument list.\n        (frame_init): Use the new functions.\n\nFrom-SVN: r18345", "tree": {"sha": "4f1b4dc5c2ba1a6994addca5f6d89704630f0091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f1b4dc5c2ba1a6994addca5f6d89704630f0091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72dd050adedc5652d58794b24f498f0ffcf485e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72dd050adedc5652d58794b24f498f0ffcf485e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72dd050adedc5652d58794b24f498f0ffcf485e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72dd050adedc5652d58794b24f498f0ffcf485e6/comments", "author": null, "committer": null, "parents": [{"sha": "c7271385a38b772188c086205718602a65eea4b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7271385a38b772188c086205718602a65eea4b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7271385a38b772188c086205718602a65eea4b3"}], "stats": {"total": 205, "additions": 183, "deletions": 22}, "files": [{"sha": "de994e809bd86e1531f9950ec97e77fa60f4caf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72dd050adedc5652d58794b24f498f0ffcf485e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72dd050adedc5652d58794b24f498f0ffcf485e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72dd050adedc5652d58794b24f498f0ffcf485e6", "patch": "@@ -1,3 +1,11 @@\n+Sun Feb 22 16:23:46 1998  Bruno Haible  <bruno@linuix.mathematik.uni-karlsruhe.de>\n+\n+\t* frame.c (start_fde_sort, fde_split, heapsort, fde_merge,\n+\tend_fde_sort): New functions for fast sorting of an FDE array.\n+\t(fde_insert): Simplified.\n+\t(add_fdes): Change argument list.\n+\t(frame_init): Use the new functions.\n+\n Sun Mar  1 18:06:21 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386.c (reg_mentioned_in_mem): Fix dangling else statement."}, {"sha": "4c387210c1545598c60036194218d79d600af652", "filename": "gcc/frame.c", "status": "modified", "additions": 175, "deletions": 22, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72dd050adedc5652d58794b24f498f0ffcf485e6/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72dd050adedc5652d58794b24f498f0ffcf485e6/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=72dd050adedc5652d58794b24f498f0ffcf485e6", "patch": "@@ -191,24 +191,182 @@ next_fde (fde *p)\n   return (fde *)(((char *)p) + p->length + sizeof (p->length));\n }\n \n-/* One iteration of an insertion sort, for adding new FDEs to the array.\n-   Usually the new FDE will go in at the end, so we can expect close to\n-   O(n) performance.  If this turns out to be overly optimistic, we can have\n-   the linker sort the FDEs so we don't have to do it at run time.  */\n+/* Sorting an array of FDEs by address.\n+   (Ideally we would have the linker sort the FDEs so we don't have to do\n+   it at run time. But the linkers are not yet prepared for this.)  */\n+\n+/* This is a special mix of insertion sort and heap sort, optimized for\n+   the data sets that actually occur. They look like\n+   101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.\n+   I.e. a linearly increasing sequence (coming from functions in the text\n+   section), with additionally a few unordered elements (coming from functions\n+   in gnu_linkonce sections) whose values are higher than the values in the\n+   surrounding linear sequence (but not necessarily higher than the values\n+   at the end of the linear sequence!).\n+   The worst-case total run time is O(N) + O(n log (n)), where N is the\n+   total number of FDEs and n is the number of erratic ones.  */\n+\n+typedef struct fde_vector\n+{\n+  fde **array;\n+  size_t count;\n+} fde_vector;\n+\n+typedef struct fde_accumulator\n+{\n+  fde_vector linear;\n+  fde_vector erratic;\n+} fde_accumulator;\n+\n+static inline void\n+start_fde_sort (fde_accumulator *accu, size_t count)\n+{\n+  accu->linear.array = (fde **) malloc (sizeof (fde *) * count);\n+  accu->erratic.array = (fde **) malloc (sizeof (fde *) * count);\n+  accu->linear.count = 0;\n+  accu->erratic.count = 0;\n+}\n \n+static inline void\n+fde_insert (fde_accumulator *accu, fde *this_fde)\n+{\n+  accu->linear.array[accu->linear.count++] = this_fde;\n+}\n+\n+/* Split LINEAR into a linear sequence with low values and an erratic\n+   sequence with high values, put the linear one (of longest possible\n+   length) into LINEAR and the erratic one into ERRATIC. This is O(N).  */\n+static inline void\n+fde_split (fde_vector *linear, fde_vector *erratic)\n+{\n+  size_t count = linear->count;\n+  size_t linear_max = (size_t) -1;\n+  size_t previous_max[count];\n+  size_t i, j;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      for (j = linear_max;\n+           j != (size_t) -1\n+           && fde_compare (linear->array[i], linear->array[j]) < 0;\n+           j = previous_max[j])\n+        {\n+          erratic->array[erratic->count++] = linear->array[j];\n+          linear->array[j] = (fde *) NULL;\n+        }\n+      previous_max[i] = j;\n+      linear_max = i;\n+    }\n+\n+  for (i = 0, j = 0; i < count; i++)\n+    if (linear->array[i] != (fde *) NULL)\n+      linear->array[j++] = linear->array[i];\n+  linear->count = j;\n+}\n+\n+/* This is O(n log(n)). */\n+static inline void\n+heapsort (fde_vector *erratic)\n+{\n+  /* For a description of this algorithm, see:\n+     Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,\n+     p. 60-61. */\n+  fde ** a = erratic->array;\n+  /* A portion of the array is called a \"heap\" if for all i>=0:\n+     If i and 2i+1 are valid indices, then a[i] >= a[2i+1].\n+     If i and 2i+2 are valid indices, then a[i] >= a[2i+2]. */\n+#define SWAP(x,y) do { fde * tmp = x; x = y; y = tmp; } while (0)\n+  size_t n = erratic->count;\n+  size_t m = n;\n+  size_t i;\n+\n+  while (m > 0)\n+    {\n+      /* Invariant: a[m..n-1] is a heap. */\n+      m--;\n+      for (i = m; 2*i+1 < n; )\n+        {\n+          if (2*i+2 < n\n+              && fde_compare (a[2*i+2], a[2*i+1]) > 0\n+              && fde_compare (a[2*i+2], a[i]) > 0)\n+            {\n+              SWAP (a[i], a[2*i+2]);\n+              i = 2*i+2;\n+            }\n+          else if (fde_compare (a[2*i+1], a[i]) > 0)\n+            {\n+              SWAP (a[i], a[2*i+1]);\n+              i = 2*i+1;\n+            }\n+          else\n+            break;\n+        }\n+    }\n+  while (n > 1)\n+    {\n+      /* Invariant: a[0..n-1] is a heap. */\n+      n--;\n+      SWAP (a[0], a[n]);\n+      for (i = 0; 2*i+1 < n; )\n+        {\n+          if (2*i+2 < n\n+              && fde_compare (a[2*i+2], a[2*i+1]) > 0\n+              && fde_compare (a[2*i+2], a[i]) > 0)\n+            {\n+              SWAP (a[i], a[2*i+2]);\n+              i = 2*i+2;\n+            }\n+          else if (fde_compare (a[2*i+1], a[i]) > 0)\n+            {\n+              SWAP (a[i], a[2*i+1]);\n+              i = 2*i+1;\n+            }\n+          else\n+            break;\n+        }\n+    }\n+#undef SWAP\n+}\n+\n+/* Merge V1 and V2, both sorted, and put the result into V1. */\n static void\n-fde_insert (fde **array, size_t i, fde *this_fde)\n+fde_merge (fde_vector *v1, const fde_vector *v2)\n {\n-  array[i] = this_fde;\n+  size_t i1, i2;\n+  fde * fde2;\n \n-  for (; i > 0 && fde_compare (array[i], array[i-1]) < 0; --i)\n+  i2 = v2->count;\n+  if (i2 > 0)\n     {\n-      this_fde = array[i];\n-      array[i] = array[i-1];\n-      array[i-1] = this_fde;\n+      i1 = v1->count;\n+      do {\n+        i2--;\n+        fde2 = v2->array[i2];\n+        while (i1 > 0 && fde_compare (v1->array[i1-1], fde2) > 0)\n+          {\n+            v1->array[i1+i2] = v1->array[i1-1];\n+            i1--;\n+          }\n+        v1->array[i1+i2] = fde2;\n+      } while (i2 > 0);\n+      v1->count += v2->count;\n     }\n }\n \n+static fde **\n+end_fde_sort (fde_accumulator *accu, size_t count)\n+{\n+  if (accu->linear.count != count)\n+    abort ();\n+  fde_split (&accu->linear, &accu->erratic);\n+  if (accu->linear.count + accu->erratic.count != count)\n+    abort ();\n+  heapsort (&accu->erratic);\n+  fde_merge (&accu->linear, &accu->erratic);\n+  free (accu->erratic.array);\n+  return accu->linear.array;\n+}\n+\n static size_t\n count_fdes (fde *this_fde)\n {\n@@ -227,10 +385,8 @@ count_fdes (fde *this_fde)\n }\n \n static void\n-add_fdes (fde *this_fde, fde **array, size_t *i_ptr,\n-\t  void **beg_ptr, void **end_ptr)\n+add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n {\n-  size_t i = *i_ptr;\n   void *pc_begin = *beg_ptr;\n   void *pc_end = *end_ptr;\n \n@@ -240,15 +396,14 @@ add_fdes (fde *this_fde, fde **array, size_t *i_ptr,\n       if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n \tcontinue;\n \n-      fde_insert (array, i++, this_fde);\n+      fde_insert (accu, this_fde);\n \n       if (this_fde->pc_begin < pc_begin)\n \tpc_begin = this_fde->pc_begin;\n       if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n \tpc_end = this_fde->pc_begin + this_fde->pc_range;\n     }\n \n-  *i_ptr = i;\n   *beg_ptr = pc_begin;\n   *end_ptr = pc_end;\n }\n@@ -260,9 +415,8 @@ add_fdes (fde *this_fde, fde **array, size_t *i_ptr,\n static void\n frame_init (struct object* ob)\n {\n-  fde *this_fde;\n   size_t count;\n-  fde **array;\n+  fde_accumulator accu;\n   void *pc_begin, *pc_end;\n \n   if (ob->fde_array)\n@@ -275,22 +429,21 @@ frame_init (struct object* ob)\n     count = count_fdes (ob->fde_begin);\n \n   ob->count = count;\n-  array = (fde **) malloc (sizeof (fde *) * count);\n \n+  start_fde_sort (&accu, count);\n   pc_begin = (void*)(uaddr)-1;\n   pc_end = 0;\n-  count = 0;\n \n   if (ob->fde_array)\n     {\n       fde **p = ob->fde_array;\n       for (; *p; ++p)\n-\tadd_fdes (*p, array, &count, &pc_begin, &pc_end);\n+\tadd_fdes (*p, &accu, &pc_begin, &pc_end);\n     }\n   else\n-    add_fdes (ob->fde_begin, array, &count, &pc_begin, &pc_end);\n+    add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n \n-  ob->fde_array = array;\n+  ob->fde_array = end_fde_sort (&accu, count);\n   ob->pc_begin = pc_begin;\n   ob->pc_end = pc_end;\n }"}]}