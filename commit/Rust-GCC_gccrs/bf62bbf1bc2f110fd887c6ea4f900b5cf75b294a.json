{"sha": "bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2MmJiZjFiYzJmMTEwZmQ4ODdjNmVhNGY5MDBiNWNmNzViMjk0YQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-09-25T01:09:41Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-09-25T01:09:41Z"}, "message": "sparc.c (finalize_pic): Update call to gen_get_pc_via_call.\n\n\t* sparc/sparc.c (finalize_pic): Update call to gen_get_pc_via_call.\n\n\t* sparc/sparc.c (sparc_align_{loops,jumps,funcs}_string): New globals.\n\t(sparc_align_{loops,jumps,funcs}): New globals.\n\t(sparc_override_options): Handle -malign-loops=, -malign-jumps=,\n\t-malign-functions=.\n\t(move_operand): Use SPARC_SETHI_P.\n\t(arith_double_operand): Cast to unsigned HOST_WIDE_INT first, then\n\tperform test.\n\t(arith11_double_operand): Likewise.\n\t(arith10_double_operand): Likewise.\n\t(finalize_pic): Finish sparc64 support.\n\t(emit_move_sequence): Use SPARC_SETHI_P.  Simplify low part of\n\t64 bit constants if able.\n\t(output_fp_move_quad): Don't use fmovq unless TARGET_HARD_QUAD.\n\t(sparc_builtin_saveregs, sparc64 case): Don't save fp regs if\n\t! TARGET_FPU.\n\n\t* sparc.h (ASM_COMMENT_START): Define.\n\t* sparc.c (output_function_prologue): Use it.\n\t(sparc_flat_output_function_{epi,pro}logue): Likewise.\n\nFrom-SVN: r15706", "tree": {"sha": "329ad81f0905d56e0c54c3160eef4e96512e2be1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329ad81f0905d56e0c54c3160eef4e96512e2be1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a/comments", "author": null, "committer": null, "parents": [{"sha": "5d4f5e87677fb8ed97770699ee46e002593cb64d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4f5e87677fb8ed97770699ee46e002593cb64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d4f5e87677fb8ed97770699ee46e002593cb64d"}], "stats": {"total": 247, "additions": 146, "deletions": 101}, "files": [{"sha": "75a9eb5a181160a9007b1c534180986d6ceb8218", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 146, "deletions": 101, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bf62bbf1bc2f110fd887c6ea4f900b5cf75b294a", "patch": "@@ -116,6 +116,16 @@ static void sparc_init_modes ();\n \f\n /* Option handling.  */\n \n+/* Record options as passed by user.  */\n+char *sparc_align_loops_string;\n+char *sparc_align_jumps_string;\n+char *sparc_align_funcs_string;\n+\n+/* Parsed values, as a power of two.  */\n+int sparc_align_loops;\n+int sparc_align_jumps;\n+int sparc_align_funcs;\n+\n struct sparc_cpu_select sparc_select[] =\n {\n   /* switch\tname,\t\ttune\tarch */\n@@ -223,6 +233,47 @@ sparc_override_options ()\n   if (TARGET_V9 && TARGET_ARCH32)\n     target_flags |= MASK_DEPRECATED_V8_INSNS;\n \n+  /* Validate -malign-loops= value, or provide default.  */\n+  if (sparc_align_loops_string)\n+    {\n+      sparc_align_loops = exact_log2 (atoi (sparc_align_loops_string));\n+      if (sparc_align_loops < 2 || sparc_align_loops > 7)\n+\tfatal (\"-malign-loops=%s is not between 4 and 128 or is not a power of two\",\n+\t       sparc_align_loops_string);\n+    }\n+  else\n+    {\n+      /* ??? This relies on ASM_OUTPUT_ALIGN to not emit the alignment if\n+\t its 0.  This sounds a bit kludgey.  */\n+      sparc_align_loops = 0;\n+    }\n+\n+  /* Validate -malign-jumps= value, or provide default.  */\n+  if (sparc_align_jumps_string)\n+    {\n+      sparc_align_jumps = exact_log2 (atoi (sparc_align_jumps_string));\n+      if (sparc_align_jumps < 2 || sparc_align_loops > 7)\n+\tfatal (\"-malign-jumps=%s is not between 4 and 128 or is not a power of two\",\n+\t       sparc_align_jumps_string);\n+    }\n+  else\n+    {\n+      /* ??? This relies on ASM_OUTPUT_ALIGN to not emit the alignment if\n+\t its 0.  This sounds a bit kludgey.  */\n+      sparc_align_jumps = 0;\n+    }\n+\n+  /* Validate -malign-functions= value, or provide default. */\n+  if (sparc_align_funcs_string)\n+    {\n+      sparc_align_funcs = exact_log2 (atoi (sparc_align_funcs_string));\n+      if (sparc_align_funcs < 2 || sparc_align_loops > 7)\n+\tfatal (\"-malign-functions=%s is not between 4 and 128 or is not a power of two\",\n+\t       sparc_align_funcs_string);\n+    }\n+  else\n+    sparc_align_funcs = DEFAULT_SPARC_ALIGN_FUNCS;\n+\n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n }\n@@ -587,7 +638,7 @@ move_operand (op, mode)\n   if (register_operand (op, mode))\n     return 1;\n   if (GET_CODE (op) == CONST_INT)\n-    return (SMALL_INT (op) || (INTVAL (op) & 0x3ff) == 0);\n+    return SMALL_INT (op) || SPARC_SETHI_P (INTVAL (op));\n \n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -787,11 +838,11 @@ arith_double_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n \t  || (! TARGET_ARCH64\n \t      && GET_CODE (op) == CONST_DOUBLE\n-\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n-\t      && (unsigned) (CONST_DOUBLE_HIGH (op) + 0x1000) < 0x2000)\n+\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n+\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_HIGH (op) + 0x1000) < 0x2000)\n \t  || (TARGET_ARCH64\n \t      && GET_CODE (op) == CONST_DOUBLE\n-\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n+\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n \t      && ((CONST_DOUBLE_HIGH (op) == -1\n \t\t   && (CONST_DOUBLE_LOW (op) & 0x1000) == 0x1000)\n \t\t  || (CONST_DOUBLE_HIGH (op) == 0\n@@ -811,14 +862,14 @@ arith11_double_operand (op, mode)\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x400) < 0x800\n+\t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x400) < 0x800\n \t      && ((CONST_DOUBLE_HIGH (op) == -1\n \t\t   && (CONST_DOUBLE_LOW (op) & 0x400) == 0x400)\n \t\t  || (CONST_DOUBLE_HIGH (op) == 0\n \t\t      && (CONST_DOUBLE_LOW (op) & 0x400) == 0)))\n \t  || (GET_CODE (op) == CONST_INT\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned) (INTVAL (op) + 0x400) < 0x800));\n+\t      && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x400) < 0x800));\n }\n \n /* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n@@ -841,7 +892,7 @@ arith10_double_operand (op, mode)\n \t\t      && (CONST_DOUBLE_LOW (op) & 0x200) == 0)))\n \t  || (GET_CODE (op) == CONST_INT\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n-\t      && (unsigned) (INTVAL (op) + 0x200) < 0x400));\n+\t      && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x200) < 0x400));\n }\n \n /* Return truth value of whether OP is a integer which fits the\n@@ -1404,8 +1455,6 @@ finalize_pic ()\n \n   flag_pic = 0;\n \n-  /* ??? sparc64 pic currently under construction.  */\n-\n   start_sequence ();\n \n   l1 = gen_label_rtx ();\n@@ -1421,56 +1470,41 @@ finalize_pic ()\n \t\t\t\t\t\t   gen_rtx (LABEL_REF, VOIDmode, l1),\n \t\t\t\t\t\t   pc_rtx))));\n \n-  if (! TARGET_ARCH64)\n-    {\n-      l2 = gen_label_rtx ();\n-      emit_label (l1);\n-      /* Note that we pun calls and jumps here!  */\n-      emit_jump_insn (gen_get_pc_sp32 (l2));\n-      emit_label (l2);\n-\n-      emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t\t  gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n-\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  pic_offset_table_rtx,\n-\t\t\t  gen_rtx (LO_SUM, Pmode,\n-\t\t\t\t   pic_offset_table_rtx, pic_pc_rtx)));\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  pic_offset_table_rtx,\n-\t\t\t  gen_rtx (PLUS, Pmode,\n-\t\t\t\t   pic_offset_table_rtx,\n-\t\t\t\t   gen_rtx (REG, Pmode, 15))));\n-\n-      /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n-      LABEL_PRESERVE_P (l1) = 1;\n-      LABEL_PRESERVE_P (l2) = 1;\n-    }\n-  else\n-    {\n-      /* ??? This definately isn't right for -mfullany.  */\n-      /* ??? And it doesn't quite seem right for the others either.  */\n-      emit_label (l1);\n-      emit_insn (gen_get_pc_sp64 (gen_rtx (REG, Pmode, 1)));\n-\n-      /* Don't let the scheduler separate the previous insn from `l1'.  */\n-      emit_insn (gen_blockage ());\n-\n-      emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t\t  gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n-\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  pic_offset_table_rtx,\n-\t\t\t  gen_rtx (LO_SUM, Pmode,\n-\t\t\t\t   pic_offset_table_rtx, pic_pc_rtx)));\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  pic_offset_table_rtx,\n-\t\t\t  gen_rtx (PLUS, Pmode,\n-\t\t\t\t   pic_offset_table_rtx, gen_rtx (REG, Pmode, 1))));\n-\n-      /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n-      LABEL_PRESERVE_P (l1) = 1;\n-    }\n+  /* sparc64: the RDPC instruction doesn't pair, and puts 4 bubbles in the\n+     pipe to boot.  So don't use it here, especially when we're\n+     doing a save anyway because of %l7.  */\n+\n+  l2 = gen_label_rtx ();\n+  emit_label (l1);\n+\n+  /* Iff we are doing delay branch optimization, slot the sethi up\n+     here so that it will fill the delay slot of the call.  */\n+  if (flag_delayed_branch)\n+    emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t\tgen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+\n+  /* Note that we pun calls and jumps here!  */\n+  emit_jump_insn (gen_get_pc_via_call (l2, l1));\n+\n+  emit_label (l2);\n+\n+  if (!flag_delayed_branch)\n+    emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t\tgen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+\n+  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t      pic_offset_table_rtx,\n+\t\t      gen_rtx (LO_SUM, Pmode,\n+\t\t\t       pic_offset_table_rtx, pic_pc_rtx)));\n+  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t      pic_offset_table_rtx,\n+\t\t      gen_rtx (PLUS, Pmode,\n+\t\t\t       pic_offset_table_rtx,\n+\t\t\t       gen_rtx (REG, Pmode, 15))));\n+\n+  /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n+  LABEL_PRESERVE_P (l1) = 1;\n+  LABEL_PRESERVE_P (l2) = 1;\n \n   flag_pic = orig_flag_pic;\n \n@@ -1569,10 +1603,10 @@ emit_move_sequence (operands, mode)\n \t}\n       else if (GET_CODE (operand1) == CONST_INT\n \t       ? (! SMALL_INT (operand1)\n-\t\t  && (INTVAL (operand1) & 0x3ff) != 0)\n-\t       : (GET_CODE (operand1) == CONST_DOUBLE\n-\t\t  ? ! arith_double_operand (operand1, DImode)\n-\t\t  : 1))\n+\t\t  && ! SPARC_SETHI_P (INTVAL (operand1)))\n+\t       : GET_CODE (operand1) == CONST_DOUBLE\n+\t       ? ! arith_double_operand (operand1, DImode)\n+\t       : 1)\n \t{\n \t  /* For DImode values, temp must be operand0 because of the way\n \t     HI and LO_SUM work.  The LO_SUM operator only copies half of\n@@ -1596,6 +1630,10 @@ emit_move_sequence (operands, mode)\n \t    emit_insn (gen_rtx (SET, VOIDmode, temp,\n \t\t\t\tgen_rtx (HIGH, mode, operand1)));\n \n+\t  if (GET_CODE (operand1) == CONST_INT)\n+\t    operand1 = GEN_INT (INTVAL (operand1) & 0xffffffff);\n+\t  else if (GET_CODE (operand1) == CONST_DOUBLE)\n+\t    operand1 = GEN_INT (CONST_DOUBLE_LOW (operand1) & 0xffffffff);\n \t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n \t}\n     }\n@@ -2207,7 +2245,7 @@ output_fp_move_quad (operands)\n     {\n       if (FP_REG_P (op1))\n \t{\n-\t  if (TARGET_V9)\n+\t  if (TARGET_V9 && TARGET_HARD_QUAD)\n \t    return \"fmovq %1,%0\";\n \t  else\n \t    return \"fmovs %1,%0\\n\\tfmovs %R1,%R0\\n\\tfmovs %S1,%S0\\n\\tfmovs %T1,%T0\";\n@@ -3133,7 +3171,7 @@ output_function_prologue (file, size, leaf_function)\n     }\n \n   /* This is only for the human reader.  */\n-  fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n+  fprintf (file, \"\\t%s#PROLOGUE# 0\\n\", ASM_COMMENT_START);\n \n   if (actual_fsize == 0)\n     /* do nothing.  */ ;\n@@ -3211,7 +3249,7 @@ output_function_prologue (file, size, leaf_function)\n \n   /* If doing anything with PIC, do it now.  */\n   if (! flag_pic)\n-    fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n+    fprintf (file, \"\\t%s#PROLOGUE# 1\\n\", ASM_COMMENT_START);\n \n   /* Call saved registers are saved just above the outgoing argument area.  */\n   if (num_gfregs)\n@@ -3405,10 +3443,11 @@ sparc_builtin_saveregs (arglist)\n   /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n      Or can assign_stack_local accept a 0 SIZE argument?  */\n \n-  bufsize = (n_intregs * UNITS_PER_WORD) + (n_floatregs * (UNITS_PER_WORD / 2));\n+  bufsize = (n_intregs * UNITS_PER_WORD) + \n+  \t    (TARGET_FPU ? (n_floatregs * (UNITS_PER_WORD / 2)) : 0);\n   /* Add space in front of the int regs to ensure proper alignment of quadword\n      fp regs.  We must add the space in front because va_start assumes this.  */\n-  if (n_floatregs >= 4)\n+  if (TARGET_FPU && n_floatregs >= 4)\n     adjust = ((n_intregs + first_floatreg / 2) % 2) * UNITS_PER_WORD;\n   else\n     adjust = 0;\n@@ -3426,23 +3465,26 @@ sparc_builtin_saveregs (arglist)\n     move_block_from_reg (BASE_INCOMING_ARG_REG (SImode) + first_intreg,\n \t\t\t regbuf, n_intregs, n_intregs * UNITS_PER_WORD);\n \n-  /* Save float args.\n-     This is optimized to only save the regs that are necessary.  Explicitly\n-     named args need not be saved.\n-     We explicitly build a pointer to the buffer because it halves the insn\n-     count when not optimizing (otherwise the pointer is built for each reg\n-     saved).  */\n-\n-  fpregs = gen_reg_rtx (Pmode);\n-  emit_move_insn (fpregs, plus_constant (XEXP (regbuf, 0),\n-\t\t\t\t\t n_intregs * UNITS_PER_WORD));\n-  for (regno = first_floatreg; regno < NPARM_REGS (SFmode); regno += 2)\n-    emit_move_insn (gen_rtx (MEM, DFmode,\n-\t\t\t     plus_constant (fpregs,\n-\t\t\t\t\t    GET_MODE_SIZE (SFmode)\n-\t\t\t\t\t    * (regno - first_floatreg))),\n-\t\t    gen_rtx (REG, DFmode,\n-\t\t\t     BASE_INCOMING_ARG_REG (DFmode) + regno));\n+  if (TARGET_FPU) \n+    {\n+      /* Save float args.\n+         This is optimized to only save the regs that are necessary.\n+\t Explicitly named args need not be saved.\n+         We explicitly build a pointer to the buffer because it halves the insn\n+         count when not optimizing (otherwise the pointer is built for each reg\n+         saved).  */\n+\n+      fpregs = gen_reg_rtx (Pmode);\n+      emit_move_insn (fpregs, plus_constant (XEXP (regbuf, 0),\n+  \t\t\t\t\t     n_intregs * UNITS_PER_WORD));\n+      for (regno = first_floatreg; regno < NPARM_REGS (SFmode); regno += 2)\n+        emit_move_insn (gen_rtx (MEM, DFmode,\n+\t\t\t         plus_constant (fpregs,\n+\t\t\t\t\t        GET_MODE_SIZE (SFmode)\n+\t\t\t\t\t        * (regno - first_floatreg))),\n+\t\t        gen_rtx (REG, DFmode,\n+\t\t\t         BASE_INCOMING_ARG_REG (DFmode) + regno));\n+    }\n \n   if (flag_check_memory_usage)\n     {\n@@ -4800,8 +4842,9 @@ sparc_flat_output_function_prologue (file, size)\n   unsigned long gmask = current_frame_info.gmask;\n \n   /* This is only for the human reader.  */\n-  fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n-  fprintf (file, \"\\t!# vars= %d, regs= %d/%d, args= %d, extra= %d\\n\",\n+  fprintf (file, \"\\t%s#PROLOGUE# 0\\n\", ASM_COMMENT_START);\n+  fprintf (file, \"\\t%s# vars= %d, regs= %d/%d, args= %d, extra= %d\\n\",\n+\t   ASM_COMMENT_START,\n \t   current_frame_info.var_size,\n \t   current_frame_info.gp_reg_size / 4,\n \t   current_frame_info.fp_reg_size / 4,\n@@ -4857,8 +4900,8 @@ sparc_flat_output_function_prologue (file, size)\n \t\t{\n \t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t\t   fp_str, sp_str, reg_offset);\n-\t\t  fprintf (file, \"\\tsub %s,%d,%s\\t!# set up frame pointer\\n\",\n-\t\t\t   sp_str, -size, fp_str);\n+\t\t  fprintf (file, \"\\tsub %s,%d,%s\\t%s# set up frame pointer\\n\",\n+\t\t\t   sp_str, -size, fp_str, ASM_COMMENT_START);\n \t\t  reg_offset += 4;\n \t\t}\n \t    }\n@@ -4870,8 +4913,8 @@ sparc_flat_output_function_prologue (file, size)\n \t\t{\n \t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\",\n \t\t\t   fp_str, sp_str, reg_offset);\n-\t\t  fprintf (file, \"\\tadd %s,%s,%s\\t!# set up frame pointer\\n\",\n-\t\t\t   sp_str, t1_str, fp_str);\n+\t\t  fprintf (file, \"\\tadd %s,%s,%s\\t%s# set up frame pointer\\n\",\n+\t\t\t   sp_str, t1_str, fp_str, ASM_COMMENT_START);\n \t\t  reg_offset += 4;\n \t\t}\n \t    }\n@@ -4915,8 +4958,9 @@ sparc_flat_output_function_prologue (file, size)\n \t\t       sp_str, -size1, sp_str);\n \t      if (gmask & FRAME_POINTER_MASK)\n \t\t{\n-\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\\tsub %s,%d,%s\\t!# set up frame pointer\\n\",\n-\t\t\t   fp_str, sp_str, offset, sp_str, -size1, fp_str);\n+\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\\tsub %s,%d,%s\\t%s# set up frame pointer\\n\",\n+\t\t\t   fp_str, sp_str, offset, sp_str, -size1, fp_str,\n+\t\t\t   ASM_COMMENT_START);\n \t\t  offset += 4;\n \t\t}\n \t    }\n@@ -4926,8 +4970,9 @@ sparc_flat_output_function_prologue (file, size)\n \t\t       size1, t1_str, sp_str, t1_str, sp_str);\n \t      if (gmask & FRAME_POINTER_MASK)\n \t\t{\n-\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\\tadd %s,%s,%s\\t!# set up frame pointer\\n\",\n-\t\t\t   fp_str, sp_str, offset, sp_str, t1_str, fp_str);\n+\t\t  fprintf (file, \"\\tst %s,[%s+%d]\\n\\tadd %s,%s,%s\\t%s# set up frame pointer\\n\",\n+\t\t\t   fp_str, sp_str, offset, sp_str, t1_str, fp_str,\n+\t\t\t   ASM_COMMENT_START);\n \t\t  offset += 4;\n \t\t}\n \t    }\n@@ -4965,7 +5010,7 @@ sparc_flat_output_function_prologue (file, size)\n \t}\n     }\n \n-  fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n+  fprintf (file, \"\\t%s#PROLOGUE# 1\\n\", ASM_COMMENT_START);\n }\n \f\n /* Do any necessary cleanup after a function to restore stack, frame,\n@@ -4980,7 +5025,7 @@ sparc_flat_output_function_epilogue (file, size)\n   int noepilogue = FALSE;\n \n   /* This is only for the human reader.  */\n-  fprintf (file, \"\\t!#EPILOGUE#\\n\");\n+  fprintf (file, \"\\t%s#EPILOGUE#\\n\", ASM_COMMENT_START);\n \n   /* The epilogue does not depend on any registers, but the stack\n      registers, so we assume that if we have 1 pending nop, it can be\n@@ -5022,11 +5067,11 @@ sparc_flat_output_function_epilogue (file, size)\n       if (frame_pointer_needed)\n \t{\n \t  if (size > 4095)\n-\t    fprintf (file,\"\\tsub %s,%s,%s\\t\\t!# sp not trusted here\\n\",\n-\t\t     fp_str, t1_str, sp_str);\n+\t    fprintf (file,\"\\tsub %s,%s,%s\\t\\t%s# sp not trusted here\\n\",\n+\t\t     fp_str, t1_str, sp_str, ASM_COMMENT_START);\n \t  else\n-\t    fprintf (file,\"\\tsub %s,%d,%s\\t\\t!# sp not trusted here\\n\",\n-\t\t     fp_str, size, sp_str);\n+\t    fprintf (file,\"\\tsub %s,%d,%s\\t\\t%s# sp not trusted here\\n\",\n+\t\t     fp_str, size, sp_str, ASM_COMMENT_START);\n \t}\n \n       /* Is the entire register save area offsettable from %sp?  */"}]}