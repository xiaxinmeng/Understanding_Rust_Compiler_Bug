{"sha": "55e70146bda8fbfe3a4fa5176268a834fda6bb39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlNzAxNDZiZGE4ZmJmZTNhNGZhNTE3NjI2OGE4MzRmZGE2YmIzOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-13T12:46:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-13T12:46:37Z"}, "message": "(calll, tablejump, movsi): New variants for NT.\n\nFrom-SVN: r9371", "tree": {"sha": "dd2207d1a7859df317aae4fccd2f559ea4cea94d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd2207d1a7859df317aae4fccd2f559ea4cea94d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55e70146bda8fbfe3a4fa5176268a834fda6bb39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e70146bda8fbfe3a4fa5176268a834fda6bb39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e70146bda8fbfe3a4fa5176268a834fda6bb39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e70146bda8fbfe3a4fa5176268a834fda6bb39/comments", "author": null, "committer": null, "parents": [{"sha": "0076aa6bda29f13eade22a16783d6192d7a34498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0076aa6bda29f13eade22a16783d6192d7a34498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0076aa6bda29f13eade22a16783d6192d7a34498"}], "stats": {"total": 177, "additions": 171, "deletions": 6}, "files": [{"sha": "0af9cc226c915e0b56819f5d51da96f98ceacbec", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 171, "deletions": 6, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e70146bda8fbfe3a4fa5176268a834fda6bb39/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e70146bda8fbfe3a4fa5176268a834fda6bb39/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=55e70146bda8fbfe3a4fa5176268a834fda6bb39", "patch": "@@ -2592,9 +2592,23 @@\n \t\t\t DImode, operands[4], const0_rtx);\n }\")\n \f\n-;; Here are the CALL and unconditional branch insns.\n+;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF\n+;; work differently, so we have different patterns for each.\n \n (define_expand \"call\"\n+  [(use (match_operand:DI 0 \"\" \"\"))\n+   (use (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"\n+{ if (WINDOWS_NT)\n+    emit_call_insn (gen_call_nt (operands[0], operands[1]));\n+  else\n+    emit_call_insn (gen_call_osf (operands[0], operands[1]));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"call_osf\"\n   [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:DI 27))\n@@ -2615,7 +2629,35 @@\n     }\n }\")\n \n+(define_expand \"call_nt\"\n+  [(parallel [(call (mem:DI (match_operand:DI 0 \"\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 26))])]\n+  \"\"\n+  \"\n+{ if (GET_CODE (operands[0]) != MEM)\n+    abort ();\n+  operands[0] = XEXP (operands[0], 0);\n+\n+  if (GET_CODE (operands[0]) != SYMBOL_REF)\n+    operands[0] = force_reg (Pmode, operands[0]);\n+}\")\n+\n (define_expand \"call_value\"\n+  [(use (match_operand 0 \"\" \"\"))\n+   (use (match_operand:DI 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))]\n+  \"\"\n+  \"\n+{ if (WINDOWS_NT)\n+    emit_call_insn (gen_call_value_nt (operands[0], operands[1], operands[2]));\n+  else\n+    emit_call_insn (gen_call_value_osf (operands[0], operands[1],\n+\t\t\t\t\toperands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"call_value_osf\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n@@ -2637,31 +2679,67 @@\n     }\n }\")\n \n+(define_expand \"call_value_nt\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:DI (match_operand:DI 1 \"\" \"\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 26))])]\n+  \"\"\n+  \"\n+{ if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n+  operands[1] = XEXP (operands[1], 0);\n+  if (GET_CODE (operands[1]) != SYMBOL_REF)\n+    operands[1] = force_reg (Pmode, operands[1]);\n+}\")\n+\n (define_insn \"\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:DI 27))\n    (clobber (reg:DI 26))]\n-  \"\"\n+  \"! WINDOWS_NT\"\n   \"@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,%0..ng\n    jsr $26,%0\\;ldgp $29,0($26)\"\n   [(set_attr \"type\" \"jsr,jsr,ibr\")])\n       \n+(define_insn \"\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,i\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:DI 26))]\n+  \"WINDOWS_NT\"\n+  \"@\n+   jsr $26,(%0)\n+   bsr $26,%0\"\n+  [(set_attr \"type\" \"jsr\")])\n+      \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=rf,rf,rf\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,R,i\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:DI 27))\n    (clobber (reg:DI 26))]\n-  \"\"\n+  \"! WINDOWS_NT\"\n   \"@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,%1..ng\n    jsr $26,%1\\;ldgp $29,0($26)\"\n   [(set_attr \"type\" \"jsr,jsr,ibr\")])\n \n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf,rf\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,i\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:DI 26))]\n+  \"WINDOWS_NT\"\n+  \"@\n+   jsr $26,(%1)\n+   bsr $26,%1\"\n+  [(set_attr \"type\" \"jsr\")])\n+\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\"\n@@ -2725,6 +2803,20 @@\n   [(set_attr \"type\" \"iaddlog\")])\n \n (define_expand \"tablejump\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (match_operand:SI 1 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (WINDOWS_NT)\n+    emit_jump_insn (gen_tablejump_nt (operands[0], operands[1]));\n+  else\n+    emit_jump_insn (gen_tablejump_osf (operands[0], operands[1]));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"tablejump_osf\"\n   [(set (match_dup 3)\n \t(sign_extend:DI (match_operand:SI 0 \"register_operand\" \"\")))\n    (parallel [(set (pc)\n@@ -2735,12 +2827,22 @@\n   \"\n { operands[3] = gen_reg_rtx (DImode); }\")\n \n+(define_expand \"tablejump_nt\"\n+  [(set (match_dup 3)\n+\t(sign_extend:DI (match_operand:SI 0 \"register_operand\" \"\")))\n+   (parallel [(set (pc)\n+\t\t   (match_dup 3))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+  \"\n+{ operands[3] = gen_reg_rtx (DImode); }\")\n+\n (define_insn \"\"\n   [(set (pc)\n \t(plus:DI (match_operand:DI 0 \"register_operand\" \"r\")\n \t\t (label_ref:DI (match_operand 1 \"\" \"\"))))\n    (clobber (match_scratch:DI 2 \"=r\"))]\n-  \"next_active_insn (insn) != 0\n+  \"! WINDOWS_NT && next_active_insn (insn) != 0\n    && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n    && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n   \"*\n@@ -2779,6 +2881,49 @@\n }\"\n   [(set_attr \"type\" \"ibr\")])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(match_operand:DI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"WINDOWS_NT && next_active_insn (insn) != 0\n+   && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n+   && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n+  \"*\n+{ rtx best_label = 0;\n+  rtx jump_table_insn = next_active_insn (operands[1]);\n+\n+  if (GET_CODE (jump_table_insn) == JUMP_INSN\n+      && GET_CODE (PATTERN (jump_table_insn)) == ADDR_DIFF_VEC)\n+    {\n+      rtx jump_table = PATTERN (jump_table_insn);\n+      int n_labels = XVECLEN (jump_table, 1);\n+      int best_count = -1;\n+      int i, j;\n+\n+      for (i = 0; i < n_labels; i++)\n+\t{\n+\t  int count = 1;\n+\n+\t  for (j = i + 1; j < n_labels; j++)\n+\t    if (XEXP (XVECEXP (jump_table, 1, i), 0)\n+\t\t== XEXP (XVECEXP (jump_table, 1, j), 0))\n+\t      count++;\n+\n+\t  if (count > best_count)\n+\t    best_count = count, best_label = XVECEXP (jump_table, 1, i);\n+\t}\n+    }\n+\n+  if (best_label)\n+    {\n+      operands[2] = best_label;\n+      return \\\"jmp $31,(%0),%2\\\";\n+    }\n+  else\n+    return \\\"jmp $31,(%0),0\\\";\n+}\"\n+  [(set_attr \"type\" \"ibr\")])\n+\n ;; Cache flush.  Used by INITIALIZE_TRAMPOLINE.  0x86 is PAL_imb, but we don't\n ;; want to have to include pal.h in our .s file.\n (define_insn \"\"\n@@ -2845,8 +2990,8 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,f,f,f,m\")\n \t(match_operand:SI 1 \"input_operand\" \"r,J,I,K,L,m,rJ,f,J,m,fG\"))]\n-  \"register_operand (operands[0], SImode)\n-   || reg_or_0_operand (operands[1], SImode)\"\n+  \"! WINDOWS_NT && (register_operand (operands[0], SImode)\n+\t\t    || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n    bis %1,%1,%0\n    bis $31,$31,%0\n@@ -2861,6 +3006,26 @@\n    sts %R1,%0\"\n   [(set_attr \"type\" \"iaddlog,iaddlog,iaddlog,iaddlog,iaddlog,ld,st,fpop,fpop,ld,st\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,r,m,f,f,f,m\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,J,I,K,L,s,m,rJ,f,J,m,fG\"))]\n+  \"WINDOWS_NT && (register_operand (operands[0], SImode)\n+\t\t  || reg_or_0_operand (operands[1], SImode))\"\n+  \"@\n+   bis %1,%1,%0\n+   bis $31,$31,%0\n+   bis $31,%1,%0\n+   lda %0,%1\n+   ldah %0,%h1\n+   lda %0,%1\n+   ldl %0,%1\n+   stl %r1,%0\n+   cpys %1,%1,%0\n+   cpys $f31,$f31,%0\n+   lds %0,%1\n+   sts %R1,%0\"\n+  [(set_attr \"type\" \"iaddlog,iaddlog,iaddlog,iaddlog,iaddlog,ldsym,ld,st,fpop,fpop,ld,st\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,r,f,f\")\n \t(match_operand:HI 1 \"input_operand\" \"r,J,I,n,f,J\"))]"}]}