{"sha": "f223bb136269cc62ae94cc5d382e08be53b47acd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyM2JiMTM2MjY5Y2M2MmFlOTRjYzVkMzgyZTA4YmU1M2I0N2FjZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-04-08T13:46:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-04-08T13:46:00Z"}, "message": "re PR c++/34949 (Dead code in empty destructors.)\n\n\tPR c++/34949\n\tPR c++/50243\n\t* tree-eh.c (optimize_clobbers): Only remove clobbers if bb doesn't\n\tcontain anything but clobbers, at most one __builtin_stack_restore,\n\toptionally debug stmts and final resx, and if it has at least one\n\tincoming EH edge.  Don't check for SSA_NAME on LHS of a clobber.\n\t(sink_clobbers): Don't check for SSA_NAME on LHS of a clobber.\n\tInstead of moving clobbers with MEM_REF LHS with SSA_NAME address\n\twhich isn't defaut definition, remove them.\n\t(unsplit_eh, cleanup_empty_eh): Use single_{pred,succ}_{p,edge}\n\tinstead of EDGE_COUNT comparisons or EDGE_{PRED,SUCC}.\n\t* tree-ssa-ccp.c (execute_fold_all_builtins): Remove clobbers\n\twith MEM_REF LHS with SSA_NAME address.\n\n\t* g++.dg/opt/vt3.C: New test.\n\t* g++.dg/opt/vt4.C: New test.\n\nFrom-SVN: r197580", "tree": {"sha": "a3858d5e8ddd0ca9b466d3525480cd3308ad2bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3858d5e8ddd0ca9b466d3525480cd3308ad2bfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f223bb136269cc62ae94cc5d382e08be53b47acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f223bb136269cc62ae94cc5d382e08be53b47acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f223bb136269cc62ae94cc5d382e08be53b47acd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f223bb136269cc62ae94cc5d382e08be53b47acd/comments", "author": null, "committer": null, "parents": [{"sha": "4481581f34be81348f36276e290c80d59fbf49c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4481581f34be81348f36276e290c80d59fbf49c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4481581f34be81348f36276e290c80d59fbf49c6"}], "stats": {"total": 181, "additions": 171, "deletions": 10}, "files": [{"sha": "6ee7d9c2ef8f73635bed2f7284e15cdbf706ea16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f223bb136269cc62ae94cc5d382e08be53b47acd", "patch": "@@ -1,3 +1,19 @@\n+2013-04-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/34949\n+\tPR c++/50243\n+\t* tree-eh.c (optimize_clobbers): Only remove clobbers if bb doesn't\n+\tcontain anything but clobbers, at most one __builtin_stack_restore,\n+\toptionally debug stmts and final resx, and if it has at least one\n+\tincoming EH edge.  Don't check for SSA_NAME on LHS of a clobber.\n+\t(sink_clobbers): Don't check for SSA_NAME on LHS of a clobber.\n+\tInstead of moving clobbers with MEM_REF LHS with SSA_NAME address\n+\twhich isn't defaut definition, remove them.\n+\t(unsplit_eh, cleanup_empty_eh): Use single_{pred,succ}_{p,edge}\n+\tinstead of EDGE_COUNT comparisons or EDGE_{PRED,SUCC}.\n+\t* tree-ssa-ccp.c (execute_fold_all_builtins): Remove clobbers\n+\twith MEM_REF LHS with SSA_NAME address.\n+\n 2013-04-08  Jeff Law  <law@redhat.com>\n \n \t* gimple.c (canonicalize_cond_expr_cond): Rewrite x ^ y into x != y."}, {"sha": "5eb5f7d57430b31a3ddb0bb13cbeb7bdd04207df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f223bb136269cc62ae94cc5d382e08be53b47acd", "patch": "@@ -1,6 +1,13 @@\n+2013-04-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/34949\n+\tPR c++/50243\n+\t* g++.dg/opt/vt3.C: New test.\n+\t* g++.dg/opt/vt4.C: New test.\n+\n 2013-04-08  Jeff Law  <law@redhat.com>\n \n-\t* gcc.dg/tree-ssa/forwprop-25.c: New test\n+\t* gcc.dg/tree-ssa/forwprop-25.c: New test.\n \n 2013-04-08  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "0cef67206e012656a10f77ddc6d18e5be8f80a51", "filename": "gcc/testsuite/g++.dg/opt/vt3.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt3.C?ref=f223bb136269cc62ae94cc5d382e08be53b47acd", "patch": "@@ -0,0 +1,43 @@\n+// PR c++/34949\n+// { dg-do compile }\n+// { dg-options \"-O3\" }\n+\n+struct E {};\n+struct A\n+{\n+  virtual void a (void *) = 0;\n+};\n+struct B\n+{\n+  virtual ~B () {};\n+  unsigned int b1;\n+  E **b2;\n+  A *b3;\n+};\n+struct C : public B\n+{\n+  ~C ();\n+};\n+C::~C ()\n+{\n+  for (unsigned int i = 0; i < b1; i++)\n+    b3->a (b2);\n+}\n+struct D\n+{\n+  ~D () {}\n+  C d;\n+};\n+struct F { virtual ~F () {}; };\n+struct G { void g (); };\n+struct H : public F\n+{\n+  virtual ~H ();\n+  D *h1;\n+  G *h2;\n+};\n+H::~H ()\n+{\n+  h2->g ();\n+  delete h1;\n+}"}, {"sha": "c8d04cffc1655f9c11720ff7f0d04b0369134700", "filename": "gcc/testsuite/g++.dg/opt/vt4.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fvt4.C?ref=f223bb136269cc62ae94cc5d382e08be53b47acd", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/50243\n+// { dg-do compile }\n+// { dg-options \"-O\" }\n+// { dg-final { scan-assembler-not \"_ZTV.A\" } }\n+\n+void foo ();\n+\n+struct A\n+{\n+  ~A () { }\n+  virtual void a () = 0;\n+  virtual void b () = 0;\n+  virtual void c () = 0;\n+};\n+\n+struct B : public A\n+{\n+  ~B () { foo (); }\n+  void a () { foo (); }\n+  void b () { foo (); }\n+  void c () { delete this; }\n+};\n+\n+void\n+test ()\n+{\n+  A *y = new B ();\n+  y->a ();\n+  y->b ();\n+  y->c ();\n+}"}, {"sha": "2eb309732a6b98815164db6608810acdf04d425a", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=f223bb136269cc62ae94cc5d382e08be53b47acd", "patch": "@@ -3230,14 +3230,48 @@ static void\n optimize_clobbers (basic_block bb)\n {\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  bool any_clobbers = false;\n+  bool seen_stack_restore = false;\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* Only optimize anything if the bb contains at least one clobber,\n+     ends with resx (checked by caller), optionally contains some\n+     debug stmts or labels, or at most one __builtin_stack_restore\n+     call, and has an incoming EH edge.  */\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n       if (is_gimple_debug (stmt))\n \tcontinue;\n-      if (!gimple_clobber_p (stmt)\n-\t  || TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n-\treturn;\n+      if (gimple_clobber_p (stmt))\n+\t{\n+\t  any_clobbers = true;\n+\t  continue;\n+\t}\n+      if (!seen_stack_restore\n+\t  && gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))\n+\t{\n+\t  seen_stack_restore = true;\n+\t  continue;\n+\t}\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tbreak;\n+      return;\n+    }\n+  if (!any_clobbers)\n+    return;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_EH)\n+      break;\n+  if (e == NULL)\n+    return;\n+  gsi = gsi_last_bb (bb);\n+  for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (!gimple_clobber_p (stmt))\n+\tcontinue;\n       unlink_stmt_vdef (stmt);\n       gsi_remove (&gsi, true);\n       release_defs (stmt);\n@@ -3278,8 +3312,7 @@ sink_clobbers (basic_block bb)\n \tcontinue;\n       if (gimple_code (stmt) == GIMPLE_LABEL)\n \tbreak;\n-      if (!gimple_clobber_p (stmt)\n-\t  || TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n+      if (!gimple_clobber_p (stmt))\n \treturn 0;\n       any_clobbers = true;\n     }\n@@ -3292,11 +3325,27 @@ sink_clobbers (basic_block bb)\n   for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n+      tree lhs;\n       if (is_gimple_debug (stmt))\n \tcontinue;\n       if (gimple_code (stmt) == GIMPLE_LABEL)\n \tbreak;\n       unlink_stmt_vdef (stmt);\n+      lhs = gimple_assign_lhs (stmt);\n+      /* Unfortunately we don't have dominance info updated at this\n+\t point, so checking if\n+\t dominated_by_p (CDI_DOMINATORS, succbb,\n+\t\t\t gimple_bb (SSA_NAME_DEF_STMT (TREE_OPERAND (lhs, 0)))\n+\t would be too costly.  Thus, avoid sinking any clobbers that\n+\t refer to non-(D) SSA_NAMEs.  */\n+      if (TREE_CODE (lhs) == MEM_REF\n+\t  && TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (TREE_OPERAND (lhs, 0)))\n+\t{\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n+\t  continue;\n+\t}\n       gsi_remove (&gsi, false);\n       /* Trigger the operand scanner to cause renaming for virtual\n          operands for this statement.\n@@ -3737,10 +3786,10 @@ unsplit_eh (eh_landing_pad lp)\n   edge e_in, e_out;\n \n   /* Quickly check the edge counts on BB for singularity.  */\n-  if (EDGE_COUNT (bb->preds) != 1 || EDGE_COUNT (bb->succs) != 1)\n+  if (!single_pred_p (bb) || !single_succ_p (bb))\n     return false;\n-  e_in = EDGE_PRED (bb, 0);\n-  e_out = EDGE_SUCC (bb, 0);\n+  e_in = single_pred_edge (bb);\n+  e_out = single_succ_edge (bb);\n \n   /* Input edge must be EH and output edge must be normal.  */\n   if ((e_in->flags & EDGE_EH) == 0 || (e_out->flags & EDGE_EH) != 0)\n@@ -4142,7 +4191,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n       e_out = NULL;\n       break;\n     case 1:\n-      e_out = EDGE_SUCC (bb, 0);\n+      e_out = single_succ_edge (bb);\n       break;\n     default:\n       return false;"}, {"sha": "f298b27ad9713cfab3aadbf4068df5e4df9f83c1", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f223bb136269cc62ae94cc5d382e08be53b47acd/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f223bb136269cc62ae94cc5d382e08be53b47acd", "patch": "@@ -2396,6 +2396,21 @@ execute_fold_all_builtins (void)\n \n           if (gimple_code (stmt) != GIMPLE_CALL)\n \t    {\n+\t      /* Remove all *ssaname_N ={v} {CLOBBER}; stmts,\n+\t\t after the last GIMPLE DSE they aren't needed and might\n+\t\t unnecessarily keep the SSA_NAMEs live.  */\n+\t      if (gimple_clobber_p (stmt))\n+\t\t{\n+\t\t  tree lhs = gimple_assign_lhs (stmt);\n+\t\t  if (TREE_CODE (lhs) == MEM_REF\n+\t\t      && TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME)\n+\t\t    {\n+\t\t      unlink_stmt_vdef (stmt);\n+\t\t      gsi_remove (&i, true);\n+\t\t      release_defs (stmt);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n \t      gsi_next (&i);\n \t      continue;\n \t    }"}]}