{"sha": "7e1a450d2118aaf0a8b71d56400ebe95dec9c23a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UxYTQ1MGQyMTE4YWFmMGE4YjcxZDU2NDAwZWJlOTVkZWM5YzIzYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-16T06:08:16Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-16T06:08:16Z"}, "message": "* optabs.c: Fix formatting.\n\nFrom-SVN: r59151", "tree": {"sha": "d3298dd6f206d00163409dfb552526b506558998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3298dd6f206d00163409dfb552526b506558998"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a/comments", "author": null, "committer": null, "parents": [{"sha": "1b245ade01676835c4c38eba631e84bb3f9ec1fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b245ade01676835c4c38eba631e84bb3f9ec1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b245ade01676835c4c38eba631e84bb3f9ec1fb"}], "stats": {"total": 113, "additions": 59, "deletions": 54}, "files": [{"sha": "a44d60dbc546016f5b9a5e97a019dead80200032", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e1a450d2118aaf0a8b71d56400ebe95dec9c23a", "patch": "@@ -1,3 +1,7 @@\n+2002-11-16  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* optabs.c: Fix formatting.\n+\n Sat Nov 16 02:06:02 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* athlon.md, k6.md, pentium.md, ppro.md: Handle shift1, rotate1"}, {"sha": "3852b6fe1dbe6617a3b678f50b93236748e70826", "filename": "gcc/optabs.c", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1a450d2118aaf0a8b71d56400ebe95dec9c23a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7e1a450d2118aaf0a8b71d56400ebe95dec9c23a", "patch": "@@ -244,12 +244,12 @@ widen_operand (op, mode, oldmode, unsignedp, no_extend)\n static int\n expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n \t\t\t  unsignedp, methods, class, binoptab)\n-  rtx real0, real1, imag0, imag1, realr, imagr;\n-  enum machine_mode submode;\n-  int unsignedp;\n-  enum optab_methods methods;\n-  enum mode_class class;\n-  optab binoptab;\n+     rtx real0, real1, imag0, imag1, realr, imagr;\n+     enum machine_mode submode;\n+     int unsignedp;\n+     enum optab_methods methods;\n+     enum mode_class class;\n+     optab binoptab;\n {\n   rtx divisor;\n   rtx real_t, imag_t;\n@@ -376,12 +376,12 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n static int\n expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n \t\t      unsignedp, methods, class, binoptab)\n-  rtx real0, real1, imag0, imag1, realr, imagr;\n-  enum machine_mode submode;\n-  int unsignedp;\n-  enum optab_methods methods;\n-  enum mode_class class;\n-  optab binoptab;\n+     rtx real0, real1, imag0, imag1, realr, imagr;\n+     enum machine_mode submode;\n+     int unsignedp;\n+     enum optab_methods methods;\n+     enum mode_class class;\n+     optab binoptab;\n {\n   rtx ratio, divisor;\n   rtx real_t, imag_t;\n@@ -646,7 +646,7 @@ expand_simple_binop (mode, code, op0, op1, target, unsignedp, methods)\n      int unsignedp;\n      enum optab_methods methods;\n {\n-  optab binop = code_to_optab [(int) code];\n+  optab binop = code_to_optab[(int) code];\n   if (binop == 0)\n     abort ();\n \n@@ -680,7 +680,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n   enum machine_mode wider_mode;\n   rtx temp;\n   int commutative_op = 0;\n-  int shift_op = (binoptab->code ==  ASHIFT\n+  int shift_op = (binoptab->code == ASHIFT\n \t\t  || binoptab->code == ASHIFTRT\n \t\t  || binoptab->code == LSHIFTRT\n \t\t  || binoptab->code == ROTATE\n@@ -1138,7 +1138,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (shift_count > BITS_PER_WORD)\n \t    {\n \t      first_shift_count = GEN_INT (shift_count - BITS_PER_WORD);\n-\t      second_shift_count = GEN_INT (2*BITS_PER_WORD - shift_count);\n+\t      second_shift_count = GEN_INT (2 * BITS_PER_WORD - shift_count);\n \t    }\n \t  else\n \t    {\n@@ -1640,7 +1640,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t\t\t    NULL_RTX, unsignedp, methods);\n \n \t      if (temp1 == 0 || temp2 == 0)\n-\t\t  break;\n+\t\tbreak;\n \n \t      res = (expand_binop\n                      (submode,\n@@ -1900,7 +1900,7 @@ expand_vector_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n   class = GET_MODE_CLASS (mode);\n \n-  size =  GET_MODE_SIZE (mode);\n+  size = GET_MODE_SIZE (mode);\n   submode = GET_MODE_INNER (mode);\n \n   /* Search for the widest vector mode with the same inner mode that is\n@@ -2023,7 +2023,7 @@ expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n   int size, elts, subsize, subbitsize, i;\n   rtx t, a, res, seq;\n \n-  size =  GET_MODE_SIZE (mode);\n+  size = GET_MODE_SIZE (mode);\n   submode = GET_MODE_INNER (mode);\n \n   /* Search for the widest vector mode with the same inner mode that is\n@@ -2117,11 +2117,11 @@ expand_vector_unop (mode, unoptab, op0, target, unsignedp)\n \n rtx\n sign_expand_binop (mode, uoptab, soptab, op0, op1, target, unsignedp, methods)\n-    enum machine_mode mode;\n-    optab uoptab, soptab;\n-    rtx op0, op1, target;\n-    int unsignedp;\n-    enum optab_methods methods;\n+     enum machine_mode mode;\n+     optab uoptab, soptab;\n+     rtx op0, op1, target;\n+     int unsignedp;\n+     enum optab_methods methods;\n {\n   rtx temp;\n   optab direct_optab = unsignedp ? uoptab : soptab;\n@@ -2317,7 +2317,7 @@ expand_simple_unop (mode, code, op0, target, unsignedp)\n      rtx target;\n      int unsignedp;\n {\n-  optab unop = code_to_optab [(int) code];\n+  optab unop = code_to_optab[(int) code];\n   if (unop == 0)\n     abort ();\n \n@@ -3293,24 +3293,24 @@ can_compare_p (code, mode, purpose)\n {\n   do\n     {\n-      if (cmp_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+      if (cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t{\n \t  if (purpose == ccp_jump)\n-\t    return bcc_gen_fctn[(int)code] != NULL;\n+\t    return bcc_gen_fctn[(int) code] != NULL;\n \t  else if (purpose == ccp_store_flag)\n-\t    return setcc_gen_code[(int)code] != CODE_FOR_nothing;\n+\t    return setcc_gen_code[(int) code] != CODE_FOR_nothing;\n \t  else\n \t    /* There's only one cmov entry point, and it's allowed to fail.  */\n \t    return 1;\n \t}\n       if (purpose == ccp_jump\n-\t  && cbranch_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+\t  && cbranch_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \treturn 1;\n       if (purpose == ccp_cmov\n-\t  && cmov_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+\t  && cmov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \treturn 1;\n       if (purpose == ccp_store_flag\n-\t  && cstore_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n+\t  && cstore_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \treturn 1;\n \n       mode = GET_MODE_WIDER_MODE (mode);\n@@ -3378,7 +3378,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, purpose)\n      states that canonical comparisons are required only for targets which\n      have cc0.  */\n   if (CONSTANT_P (x) && ! CONSTANT_P (y))\n-    abort();\n+    abort ();\n #endif\n \n   /* Don't let both operands fail to indicate the mode.  */\n@@ -3545,7 +3545,7 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n \n       if (label)\n \t{\t  \n-\t  icode = cbranch_optab->handlers[(int)wider_mode].insn_code;\n+\t  icode = cbranch_optab->handlers[(int) wider_mode].insn_code;\n \t  \n \t  if (icode != CODE_FOR_nothing\n \t      && (*insn_data[icode].operand[0].predicate) (test, wider_mode))\n@@ -3586,7 +3586,8 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n \tbreak;\n \n       wider_mode = GET_MODE_WIDER_MODE (wider_mode);\n-    } while (wider_mode != VOIDmode);\n+    }\n+  while (wider_mode != VOIDmode);\n \n   abort ();\n }\n@@ -4014,7 +4015,7 @@ void\n emit_indirect_jump (loc)\n      rtx loc;\n {\n-  if (! ((*insn_data[(int)CODE_FOR_indirect_jump].operand[0].predicate)\n+  if (! ((*insn_data[(int) CODE_FOR_indirect_jump].operand[0].predicate)\n \t (loc, Pmode)))\n     loc = copy_to_mode_reg (Pmode, loc);\n \n@@ -4206,7 +4207,7 @@ gen_add3_insn (r0, r1, c)\n {\n   int icode = (int) add_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n-    if (icode == CODE_FOR_nothing\n+  if (icode == CODE_FOR_nothing\n       || ! ((*insn_data[icode].operand[0].predicate)\n \t    (r0, insn_data[icode].operand[0].mode))\n       || ! ((*insn_data[icode].operand[1].predicate)\n@@ -4270,7 +4271,7 @@ gen_sub3_insn (r0, r1, c)\n {\n   int icode = (int) sub_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n-    if (icode == CODE_FOR_nothing\n+  if (icode == CODE_FOR_nothing\n       || ! ((*insn_data[icode].operand[0].predicate)\n \t    (r0, insn_data[icode].operand[0].mode))\n       || ! ((*insn_data[icode].operand[1].predicate)\n@@ -4506,7 +4507,7 @@ expand_float (to, from, unsignedp)\n \t      convert_move (to, target, 0);\n \t    return;\n \t  }\n-    }\n+      }\n \n   /* Unsigned integer, and no way to convert directly.\n      Convert as signed, then conditionally adjust the result.  */\n@@ -4581,7 +4582,7 @@ expand_float (to, from, unsignedp)\n \n \t      /* Multiply by 2 to undo the shift above.  */\n \t      temp = expand_binop (fmode, add_optab, target, target,\n-\t\t\t\t     target, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t   target, 0, OPTAB_LIB_WIDEN);\n \t      if (temp != target)\n \t\temit_move_insn (target, temp);\n \n@@ -5009,19 +5010,19 @@ init_optabv (code)\n \n static void\n init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n-    optab optable;\n-    int first_mode;\n-    int last_mode;\n-    const char *opname;\n-    int suffix;\n+     optab optable;\n+     int first_mode;\n+     int last_mode;\n+     const char *opname;\n+     int suffix;\n {\n   int mode;\n   unsigned opname_len = strlen (opname);\n \n   for (mode = first_mode; (int) mode <= (int) last_mode;\n        mode = (enum machine_mode) ((int) mode + 1))\n     {\n-      const char *mname = GET_MODE_NAME(mode);\n+      const char *mname = GET_MODE_NAME (mode);\n       unsigned mname_len = strlen (mname);\n       char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n       char *p;\n@@ -5050,9 +5051,9 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n \n static void\n init_integral_libfuncs (optable, opname, suffix)\n-    optab optable;\n-    const char *opname;\n-    int suffix;\n+     optab optable;\n+     const char *opname;\n+     int suffix;\n {\n   init_libfuncs (optable, SImode, TImode, opname, suffix);\n }\n@@ -5064,9 +5065,9 @@ init_integral_libfuncs (optable, opname, suffix)\n \n static void\n init_floating_libfuncs (optable, opname, suffix)\n-    optab optable;\n-    const char *opname;\n-    int suffix;\n+     optab optable;\n+     const char *opname;\n+     int suffix;\n {\n   init_libfuncs (optable, SFmode, TFmode, opname, suffix);\n }\n@@ -5466,8 +5467,8 @@ init_traps ()\n \n rtx\n gen_cond_trap (code, op1, op2, tcode)\n-  enum rtx_code code ATTRIBUTE_UNUSED;\n-  rtx op1, op2 ATTRIBUTE_UNUSED, tcode ATTRIBUTE_UNUSED;\n+     enum rtx_code code ATTRIBUTE_UNUSED;\n+     rtx op1, op2 ATTRIBUTE_UNUSED, tcode ATTRIBUTE_UNUSED;\n {\n   enum machine_mode mode = GET_MODE (op1);\n \n@@ -5479,7 +5480,7 @@ gen_cond_trap (code, op1, op2, tcode)\n       && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       rtx insn;\n-      start_sequence();\n+      start_sequence ();\n       emit_insn (GEN_FCN (cmp_optab->handlers[(int) mode].insn_code) (op1, op2));\n       PUT_CODE (trap_rtx, code);\n       insn = gen_conditional_trap (trap_rtx, tcode);\n@@ -5488,7 +5489,7 @@ gen_cond_trap (code, op1, op2, tcode)\n \t  emit_insn (insn);\n \t  insn = get_insns ();\n \t}\n-      end_sequence();\n+      end_sequence ();\n       return insn;\n     }\n #endif"}]}