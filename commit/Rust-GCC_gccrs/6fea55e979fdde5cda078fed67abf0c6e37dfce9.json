{"sha": "6fea55e979fdde5cda078fed67abf0c6e37dfce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlYTU1ZTk3OWZkZGU1Y2RhMDc4ZmVkNjdhYmYwYzZlMzdkZmNlOQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-07-28T12:38:53Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-07-28T12:38:53Z"}, "message": "re PR tree-optimization/16688 (ICE in group_aliases, at tree-ssa-alias.c:1234)\n\n\n\tPR tree-optimization/16688\n\tPR tree-optimization/16689\n\t* g++.dg/tree-ssa/pr16688.C: New test.\n\nFrom-SVN: r85262", "tree": {"sha": "520bb4d333706f9b16033658d0cd9deda1bd904f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/520bb4d333706f9b16033658d0cd9deda1bd904f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fea55e979fdde5cda078fed67abf0c6e37dfce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fea55e979fdde5cda078fed67abf0c6e37dfce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fea55e979fdde5cda078fed67abf0c6e37dfce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fea55e979fdde5cda078fed67abf0c6e37dfce9/comments", "author": null, "committer": null, "parents": [{"sha": "47a43a1046eaf9445e7b699f328d45ab85e599af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a43a1046eaf9445e7b699f328d45ab85e599af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a43a1046eaf9445e7b699f328d45ab85e599af"}], "stats": {"total": 279, "additions": 279, "deletions": 0}, "files": [{"sha": "ae7cd8024da79063591f983e465564ab003693a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fea55e979fdde5cda078fed67abf0c6e37dfce9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fea55e979fdde5cda078fed67abf0c6e37dfce9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fea55e979fdde5cda078fed67abf0c6e37dfce9", "patch": "@@ -1,3 +1,9 @@\n+2004-07-28  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/16688\n+\tPR tree-optimization/16689\n+\t* g++.dg/tree-ssa/pr16688.C: New test.\n+\n 2004-07-28  Diego Novillo  <dnovillo@redhat.com>\n \n \t* gcc.dg/tree-ssa/20031022-1.c: Adjust number of expected"}, {"sha": "ce88bc2b2dc9cb1526f99b31a4d1d584330273f6", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr16688.C", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fea55e979fdde5cda078fed67abf0c6e37dfce9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr16688.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fea55e979fdde5cda078fed67abf0c6e37dfce9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr16688.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr16688.C?ref=6fea55e979fdde5cda078fed67abf0c6e37dfce9", "patch": "@@ -0,0 +1,273 @@\n+/* PR 16688.  Test provided by Wolfgang Bangerth.  The alias analyzer\n+   was aborting when trying to group aliases.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+template<typename _Tp>\n+struct iterator_traits;\n+\n+template<typename _Tp>\n+struct iterator_traits<_Tp*> {\n+    typedef _Tp& reference;\n+};\n+\n+template<typename _Iterator> struct NI {\n+    _Iterator current;\n+\n+    typedef typename iterator_traits<_Iterator>::reference reference;\n+\n+    NI() { }\n+\n+    NI(const _Iterator& __i) : current(__i) { }\n+\n+    reference operator*() const { return *current; }\n+\n+    NI& operator++() { return *this; }\n+\n+    const _Iterator& base() const { return current; }\n+};\n+\n+template<typename _IteratorL, typename _IteratorR>\n+inline int\n+operator-(const NI<_IteratorL>& __lhs,\n+          const NI<_IteratorR>& __rhs)\n+{ return __lhs.base() - __rhs.base(); }\n+\n+\n+template<typename _II, typename _OI>\n+inline _OI\n+__copy_aux(_II __first, _II __last, _OI __result)\n+{\n+  struct __copy {\n+      static _OI\n+      copy(_II __first, _II __last, _OI __result)\n+        {\n+          for (; __first != __last; ++__result, ++__first)\n+            *__result = *__first;\n+          return __result;\n+        }\n+  };\n+\n+  return __copy::copy(__first, __last, __result);\n+}\n+\n+struct __copy_normal\n+{\n+    template<typename _II, typename _OI>\n+    static _OI\n+    copy_n(_II __first, _II __last, _OI __result)\n+      {\n+        return __copy_aux(__first, __last, __result);\n+      }\n+};\n+template<typename _InputIterator, typename _OutputIterator>\n+inline _OutputIterator\n+copy(_InputIterator __first, _InputIterator __last,\n+     _OutputIterator __result)\n+{\n+  return __copy_normal::copy_n(__first, __last, __result);\n+}\n+\n+template <typename T, typename U, typename V>\n+void uninitialized_fill_n(T,U,V);\n+\n+\n+template<typename _Tp>\n+struct _Vector_base {\n+    struct _Vector_impl {\n+        _Tp* start;\n+        _Tp* finish;\n+        _Tp* end_of_storage;\n+        _Vector_impl() : start(0), finish(0), end_of_storage(0)\n+          { }\n+    } impl;\n+\n+    _Vector_base(unsigned __n) {\n+      impl.start = allocate(__n);\n+      impl.finish = impl.start;\n+      impl.end_of_storage = impl.start + __n;\n+    }\n+\n+    ~_Vector_base() {\n+      deallocate(impl.start,\n+                    impl.end_of_storage - impl.start);\n+    }\n+\n+    _Tp* allocate(unsigned __n);\n+\n+    void deallocate(_Tp* __p, unsigned __n);\n+\n+    NI<_Tp*> begin() { return NI<_Tp*> (impl.start); }\n+};\n+\n+\n+template<typename _Tp>\n+struct vector : _Vector_base<_Tp>\n+{\n+    vector(int __n)\n+                    : _Vector_base<_Tp>(__n)\n+      {\n+        uninitialized_fill_n(this->impl.start, __n, _Tp());\n+      }\n+};\n+\n+\n+\n+struct Tensor\n+{\n+    Tensor ();\n+    Tensor (const Tensor &);\n+\n+    double values[2];\n+};\n+\n+\n+inline\n+Tensor::Tensor (const Tensor &p)\n+{\n+  for (unsigned int i=0; i<2; ++i)\n+    values[i] = p.values[i];\n+}\n+\n+\n+struct TriaAccessor\n+{\n+    typedef void * AccessorData;\n+\n+    void copy_from (const TriaAccessor &);\n+    void operator = (const TriaAccessor *);\n+\n+    TriaAccessor & operator = (const TriaAccessor &);\n+\n+    bool operator == (const TriaAccessor &) const;\n+\n+    bool operator != (const TriaAccessor &) const;\n+    void operator ++ ();\n+\n+    int state () const;\n+    bool used () const;\n+\n+    int present_level;\n+    int present_index;\n+    int** levels;\n+};\n+\n+inline int TriaAccessor::state () const {\n+  if ((present_level>=0) && (present_index>=0))\n+    return 0;\n+  else\n+    if ((present_level==-1) && (present_index==-1))\n+      return 1;\n+    else\n+      return 2;\n+}\n+\n+\n+inline\n+void TriaAccessor::operator ++ () {\n+  ++this->present_index;\n+\n+  while (this->present_index >=\n+         static_cast<int>(*this->levels[this->present_level]))\n+    {\n+      ++this->present_level;\n+      this->present_index = 0;\n+\n+      if (this->present_level >= static_cast<int>(1))\n+        {\n+\n+          this->present_level = this->present_index = -1;\n+          return;\n+        }\n+    }\n+}\n+\n+struct MGDoFObjectAccessor : TriaAccessor {};\n+\n+\n+\n+struct TriaRawIterator\n+{\n+    TriaRawIterator ();\n+\n+    TriaRawIterator (const TriaRawIterator &);\n+    TriaRawIterator (const MGDoFObjectAccessor &a);\n+    const MGDoFObjectAccessor & operator * () const;\n+    \n+    MGDoFObjectAccessor & operator * ();\n+    const MGDoFObjectAccessor * operator -> () const;\n+\n+    MGDoFObjectAccessor * operator -> ();\n+\n+    TriaRawIterator & operator = (const TriaRawIterator &);\n+\n+    bool operator == (const TriaRawIterator &) const;\n+    bool operator != (const TriaRawIterator &) const;\n+    bool operator < (const TriaRawIterator &) const;\n+    MGDoFObjectAccessor accessor;\n+\n+    TriaRawIterator & operator ++ ();\n+};\n+\n+struct TriaIterator : TriaRawIterator\n+{\n+    TriaIterator ();\n+\n+    TriaIterator (const TriaIterator &i);\n+\n+    TriaIterator &\n+    operator = (const TriaIterator &);\n+\n+    TriaIterator &\n+    operator = (const TriaRawIterator &);\n+};\n+\n+\n+inline\n+TriaRawIterator::TriaRawIterator (const TriaRawIterator &i) :\n+                accessor (i.accessor) {}\n+\n+inline\n+TriaIterator::TriaIterator (const TriaIterator &i) :\n+                TriaRawIterator (static_cast<TriaRawIterator >(i)) {}\n+\n+inline\n+TriaRawIterator & TriaRawIterator::operator ++ () {\n+  while (++accessor, (this->accessor.state() == 0))\n+    if (this->accessor.used() == true)\n+      return *this;\n+  return *this;\n+}\n+\n+struct Comp {\n+    Comp (const Tensor &dir) : dir(dir) {}\n+\n+    bool operator () (const TriaIterator &c1, const TriaIterator &c2) const;\n+    const Tensor dir;\n+};\n+\n+\n+template<typename Iter>\n+void x1(Iter first, Iter last, int i, Comp comp)\n+{\n+  x1(Iter(), last, i, comp);\n+}\n+\n+template<typename Iter>\n+inline void x2(Iter first, Iter last, Comp comp)\n+{\n+  if (first.base() != last.base())\n+    x1(first, last, (last - first), comp);\n+}\n+\n+void downstream_dg (const Tensor& direction)\n+{\n+  vector<TriaIterator> ordered_cells(13);\n+  const Comp comparator(direction);\n+\n+  TriaIterator begin, end;\n+\n+  copy (begin, end, ordered_cells.begin());\n+  x2 (ordered_cells.begin(), ordered_cells.begin(), comparator);\n+}"}]}