{"sha": "6723181663a87a735bdfdf2e16a6bd41dbc30be1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyMzE4MTY2M2E4N2E3MzViZGZkZjJlMTZhNmJkNDFkYmMzMGJlMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-21T16:58:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-21T16:58:22Z"}, "message": "tree.def (FDESC_EXPR): New.\n\ngcc/\n        * tree.def (FDESC_EXPR): New.\n        * expr.c (expand_expr): Handle it.\n        * varasm.c (initializer_constant_valid_p): Likewise.\n        (output_constant): Likewise.\n        * defaults.h (TARGET_VTABLE_USES_DESCRIPTORS): New.\n        * config/ia64/ia64.h (TARGET_VTABLE_USES_DESCRIPTORS): New.\n        (ASM_OUTPUT_FDESC): New.\n        * doc/tm.texi: Document the new macros.\ngcc/cp/\n        * class.c (set_vindex): Mind TARGET_VTABLE_USES_DESCRIPTORS.\n        (build_vtbl_initializer): Likewise.\n        (build_vfn_ref): New.\n        * cp-tree.h: Declare it.\n        * call.c (build_over_call): Use it.\n        * decl2.c (mark_vtable_entries): Mark FDESC_EXPR.\n        * typeck.c (get_member_function_from_ptrfunc): Mind descriptors.\ngcc/java/\n        * class.c (get_dispatch_table): Handle function descriptors.\n        (build_dtable_decl): Likewise.\n        * expr.c (build_invokevirtual): Likewise.\ngcc/testsuite/\n        * g++.old-deja/g++.abi/ptrmem.C: Update for ia64 c++ abi.\n        * g++.old-deja/g++.abi/vtable2.C: Likewise.\n\nFrom-SVN: r45733", "tree": {"sha": "746cb9ad4b9e1b8562a39be3d23d3c85abfdac19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/746cb9ad4b9e1b8562a39be3d23d3c85abfdac19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6723181663a87a735bdfdf2e16a6bd41dbc30be1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6723181663a87a735bdfdf2e16a6bd41dbc30be1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6723181663a87a735bdfdf2e16a6bd41dbc30be1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6723181663a87a735bdfdf2e16a6bd41dbc30be1/comments", "author": null, "committer": null, "parents": [{"sha": "2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3b2d2c0791d979571fd33155b62e66ea7fe27c"}], "stats": {"total": 289, "additions": 258, "deletions": 31}, "files": [{"sha": "8aed6475695b13d675e465c2fad1b0390825e4eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1,3 +1,14 @@\n+2001-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree.def (FDESC_EXPR): New.\n+\t* expr.c (expand_expr): Handle it.\n+\t* varasm.c (initializer_constant_valid_p): Likewise.\n+\t(output_constant): Likewise.\n+\t* defaults.h (TARGET_VTABLE_USES_DESCRIPTORS): New.\n+\t* config/ia64/ia64.h (TARGET_VTABLE_USES_DESCRIPTORS): New.\n+\t(ASM_OUTPUT_FDESC): New.\n+\t* doc/tm.texi: Document the new macros.\n+\n 21-09-2001  Richard Earnshaw  (reanrsha@arm.com)\n \n \t* cfgcleanup.c (merge_blocks_move_successor_nojumps): Don't leave "}, {"sha": "ce8e7f1e1f98b30c9f9ed2234dab0de31e0463f8", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -416,6 +416,13 @@ while (0)\n /* A code distinguishing the floating point format of the target machine.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n+/* By default, the C++ compiler will use function addresses in the\n+   vtable entries.  Setting this non-zero tells the compiler to use\n+   function descriptors instead.  The value of this macro says how\n+   many words wide the descriptor is (normally 2).  It is assumed \n+   that the address of a function descriptor may be treated as a\n+   pointer to a function.  */\n+#define TARGET_VTABLE_USES_DESCRIPTORS 2\n \f\n /* Layout of Source Language Data Types */\n \n@@ -1534,6 +1541,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n } while (0)\n \n+/* Output part N of a function descriptor for DECL.  For ia64, both\n+   words are emitted with a single relocation, so ignore N > 0.  */\n+#define ASM_OUTPUT_FDESC(FILE, DECL, PART)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((PART) == 0)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\tdata16.ua @iplt(\", FILE);\t\t\t\t\\\n+      assemble_name (FILE, XSTR (XEXP (DECL_RTL (DECL), 0), 0));\t\\\n+      fputs (\")\\n\", FILE);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n \f\n /* Generating Code for Profiling.  */\n "}, {"sha": "25efd971a0c9ab795b2e218b48005c799618a38f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1,3 +1,13 @@\n+2001-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* class.c (set_vindex): Mind TARGET_VTABLE_USES_DESCRIPTORS.\n+\t(build_vtbl_initializer): Likewise.\n+\t(build_vfn_ref): New.\n+\t* cp-tree.h: Declare it.\n+\t* call.c (build_over_call): Use it.\n+\t* decl2.c (mark_vtable_entries): Mark FDESC_EXPR.\n+\t* typeck.c (get_member_function_from_ptrfunc): Mind descriptors.\n+\n Fri Sep 21 08:16:19 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* decl.c (grokdeclarator): Use C syntax for attr_flags declaration."}, {"sha": "427314878927228033085320da2b10af5e736d1f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -4321,7 +4321,7 @@ build_over_call (cand, args, flags)\n       if (DECL_CONTEXT (fn) && TYPE_JAVA_INTERFACE (DECL_CONTEXT (fn)))\n \tfn = build_java_interface_fn_ref (fn, *p);\n       else\n-\tfn = build_vtbl_ref (build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n+\tfn = build_vfn_ref (build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n   else if (DECL_INLINE (fn))"}, {"sha": "ac71fc5baa556ed34e7400dfaf25c8500a889a62", "filename": "gcc/cp/class.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -459,9 +459,9 @@ build_vtable_entry_ref (basetype, idx)\n }\n \n /* Given an object INSTANCE, return an expression which yields the\n-   virtual function vtable element corresponding to INDEX.  There are\n-   many special cases for INSTANCE which we take care of here, mainly\n-   to avoid creating extra tree nodes when we don't have to.  */\n+   vtable element corresponding to INDEX.  There are many special\n+   cases for INSTANCE which we take care of here, mainly to avoid\n+   creating extra tree nodes when we don't have to.  */\n \n tree\n build_vtbl_ref (instance, idx)\n@@ -543,6 +543,24 @@ build_vtbl_ref (instance, idx)\n   return aref;\n }\n \n+/* Given an object INSTANCE, return an expression which yields a\n+   function pointer corresponding to vtable element INDEX.  */\n+\n+tree\n+build_vfn_ref (instance, idx)\n+     tree instance, idx;\n+{\n+  tree aref = build_vtbl_ref (instance, idx);\n+\n+  /* When using function descriptors, the address of the\n+     vtable entry is treated as a function pointer.  */\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    return build1 (NOP_EXPR, TREE_TYPE (aref),\n+\t\t   build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1));\n+\n+  return aref;\n+}\n+\n /* Return the name of the virtual function table (as an IDENTIFIER_NODE)\n    for the given TYPE.  */\n \n@@ -823,7 +841,9 @@ set_vindex (decl, vfuns_p)\n {\n   int vindex;\n \n-  vindex = (*vfuns_p)++;\n+  vindex = *vfuns_p;\n+  *vfuns_p += (TARGET_VTABLE_USES_DESCRIPTORS\n+\t       ? TARGET_VTABLE_USES_DESCRIPTORS : 1);\n   DECL_VINDEX (decl) = build_shared_int_cst (vindex);\n }\n \n@@ -7587,7 +7607,25 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n \t  }\n \n       /* And add it to the chain of initializers.  */\n-      vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n+      if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\t{\n+\t  int i;\n+\t  if (init == size_zero_node)\n+\t    for (i = 0; i < TARGET_VTABLE_USES_DESCRIPTORS; ++i)\n+\t      vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n+\t  else\n+\t    for (i = 0; i < TARGET_VTABLE_USES_DESCRIPTORS; ++i)\n+\t      {\n+\t\ttree fdesc = build (FDESC_EXPR, vfunc_ptr_type_node,\n+\t\t\t\t    TREE_OPERAND (init, 0),\n+\t\t\t\t    build_int_2 (i, 0));\n+\t\tTREE_CONSTANT (fdesc) = 1;\n+\n+\t\tvfun_inits = tree_cons (NULL_TREE, fdesc, vfun_inits);\n+\t      }\n+\t}\n+      else\n+        vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n     }\n \n   /* The initializers for virtual functions were built up in reverse"}, {"sha": "525750d34dee8584c2d32202482bc9e63ac96990", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -3527,6 +3527,7 @@ extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n /* in class.c */\n extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n+extern tree build_vfn_ref\t\t\tPARAMS ((tree, tree));\n extern tree get_vtable_decl                     PARAMS ((tree, int));\n extern void add_method\t\t\t\tPARAMS ((tree, tree, int));\n extern int currently_open_class\t\t\tPARAMS ((tree));"}, {"sha": "372b8ee8139f57d7a521eceee3db28aef65a4a07", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -2168,7 +2168,8 @@ mark_vtable_entries (decl)\n       tree fnaddr = TREE_VALUE (entries);\n       tree fn;\n       \n-      if (TREE_CODE (fnaddr) != ADDR_EXPR)\n+      if (TREE_CODE (fnaddr) != ADDR_EXPR\n+\t  && TREE_CODE (fnaddr) != FDESC_EXPR)\n \t/* This entry is an offset: a virtual base class offset, a\n \t   virtual call offset, an RTTI offset, etc.  */\n \tcontinue;"}, {"sha": "54dc0ed3df586d018d9b61d8cd7ca100cf570fff", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -2910,6 +2910,12 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       vtbl = build_indirect_ref (vtbl, NULL);\n       e2 = build_array_ref (vtbl, idx);\n \n+      /* When using function descriptors, the address of the\n+\t vtable entry is treated as a function pointer.  */\n+      if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\te2 = build1 (NOP_EXPR, TREE_TYPE (e2),\n+\t\t     build_unary_op (ADDR_EXPR, e2, /*noconvert=*/1));\n+\n       TREE_TYPE (e2) = TREE_TYPE (e3);\n       e1 = build_conditional_expr (e1, e2, e3);\n       "}, {"sha": "f9fef2061f1e1d903769dec230f61af06748f172", "filename": "gcc/defaults.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -358,6 +358,16 @@ do {\t\t\t\t\t\t\t\t\\\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n #endif\n \n+/* By default, the C++ compiler will use function addresses in the\n+   vtable entries.  Setting this non-zero tells the compiler to use\n+   function descriptors instead.  The value of this macro says how\n+   many words wide the descriptor is (normally 2).  It is assumed \n+   that the address of a function descriptor may be treated as a\n+   pointer to a function.  */\n+#ifndef TARGET_VTABLE_USES_DESCRIPTORS\n+#define TARGET_VTABLE_USES_DESCRIPTORS 0\n+#endif\n+\n /* Select a format to encode pointers in exception handling data.  We\n    prefer those that result in fewer dynamic relocations.  Assume no\n    special support here and encode direct references.  */"}, {"sha": "cd4ec28aebbdbca8e06824aa97623cdb02d864a3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1597,6 +1597,18 @@ In general, you should not have to define this macro.  On architectures\n in which function addresses are always even, according to\n @code{FUNCTION_BOUNDARY}, GCC will automatically define this macro to\n @code{ptrmemfunc_vbit_in_pfn}.\n+\n+@findex TARGET_VTABLE_USES_DESCRIPTORS\n+@item TARGET_VTABLE_USES_DESCRIPTORS\n+Normally, the C++ compiler uses function pointers in vtables.  This\n+macro allows the target to change to use ``function descriptors'' \n+instead.  Function descriptors are found on targets for whom a\n+function pointer is actually a small data structure.  Normally the\n+data structure consists of the actual code address plus a data \n+pointer to which the function's data is relative.\n+\n+If vtables are used, the value of this macro should be the number\n+of words that the function descriptor occupies.\n @end table\n \n @node Escape Sequences\n@@ -6012,6 +6024,12 @@ If the assembler has a @code{.ascii} pseudo-op as found in the\n Berkeley Unix assembler, do not define the macro\n @code{ASM_OUTPUT_ASCII}.\n \n+@findex ASM_OUTPUT_FDESC\n+@item ASM_OUTPUT_FDESC (@var{stream}, @var{decl}, @var{n})\n+A C statement to output word @var{n} of a function descriptor for\n+@var{decl}.  This must be defined if @code{TARGET_VTABLE_USES_DESCRIPTORS}\n+is defined, and is otherwise unused.\n+\n @findex CONSTANT_POOL_BEFORE_FUNCTION\n @item CONSTANT_POOL_BEFORE_FUNCTION\n You may define this macro as a C expression.  You should define the"}, {"sha": "7d23c7ac82443f82fff8ae237962f95d3458f5f0", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -8757,6 +8757,11 @@ expand_expr (exp, target, tmode, modifier)\n     case EXC_PTR_EXPR:\n       return get_exception_pointer (cfun);\n \n+    case FDESC_EXPR:\n+      /* Function descriptors are not valid except for as\n+\t initialization constants, and should not be expanded.  */\n+      abort ();\n+\n     default:\n       return (*lang_expand_expr) (exp, original_target, tmode, modifier);\n     }"}, {"sha": "fcfb7eb52f00f74551141790a633061b90fb73bd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1,3 +1,9 @@\n+2001-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* class.c (get_dispatch_table): Handle function descriptors.\n+\t(build_dtable_decl): Likewise.\n+\t* expr.c (build_invokevirtual): Likewise.\n+\n 2001-09-19  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.h: (WFL_STRIP_BRACKET): Re-written using"}, {"sha": "260db757d71bf9556e7e5ff82d66139e8c2e03a3", "filename": "gcc/java/class.c", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1372,9 +1372,11 @@ get_dispatch_table (type, this_class_addr)\n {\n   int abstract_p = CLASS_ABSTRACT (TYPE_NAME (type));\n   tree vtable = get_dispatch_vector (type);\n-  int i;\n+  int i, j;\n   tree list = NULL_TREE;\n   int nvirtuals = TREE_VEC_LENGTH (vtable);\n+  int arraysize;\n+\n   for (i = nvirtuals;  --i >= 0; )\n     {\n       tree method = TREE_VEC_ELT (vtable, i);\n@@ -1383,27 +1385,52 @@ get_dispatch_table (type, this_class_addr)\n \t  if (! abstract_p)\n \t    warning_with_decl (method,\n \t\t\t       \"abstract method in non-abstract class\");\n-\t  method = null_pointer_node;\n+\n+\t  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n+\t      list = tree_cons (NULL_TREE, null_pointer_node, list);\n+\t  else\n+\t    list = tree_cons (NULL_TREE, null_pointer_node, list);\n \t}\n       else\n \t{\n \t  if (!DECL_RTL_SET_P (method))\n \t    make_decl_rtl (method, NULL);\n-\t  method = build1 (ADDR_EXPR, nativecode_ptr_type_node, method);\n+\n+\t  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n+\t      {\n+\t\ttree fdesc = build (FDESC_EXPR, nativecode_ptr_type_node, \n+\t\t\t\t    method, build_int_2 (j, 0));\n+\t\tTREE_CONSTANT (fdesc) = 1;\n+\t        list = tree_cons (NULL_TREE, fdesc, list);\n+\t      }\n+\t  else\n+\t    list = tree_cons (NULL_TREE,\n+\t\t\t      build1 (ADDR_EXPR, nativecode_ptr_type_node,\n+\t\t\t\t      method),\n+\t\t\t      list);\n \t}\n-      list = tree_cons (NULL_TREE /*DECL_VINDEX (method) + 2*/,\n-\t\t\tmethod, list);\n     }\n+\n   /* Dummy entry for compatibility with G++ -fvtable-thunks.  When\n      using the Boehm GC we sometimes stash a GC type descriptor\n      there. We set the PURPOSE to NULL_TREE not to interfere (reset)\n      the emitted byte count during the output to the assembly file. */\n-  list = tree_cons (NULL_TREE, get_boehm_type_descriptor (type),\n-\t\t    list);\n+  for (j = 1; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n+    list = tree_cons (NULL_TREE, null_pointer_node, list);\n+  list = tree_cons (NULL_TREE, get_boehm_type_descriptor (type), list);\n+\n+  for (j = 1; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n+    list = tree_cons (NULL_TREE, null_pointer_node, list);\n   list = tree_cons (integer_zero_node, this_class_addr, list);\n-  return build (CONSTRUCTOR, build_prim_array_type (nativecode_ptr_type_node,\n-\t\t\t\t\t\t    nvirtuals + 2),\n-\t\t NULL_TREE, list);\n+\n+  arraysize = nvirtuals + 2;\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    arraysize *= TARGET_VTABLE_USES_DESCRIPTORS;\n+  return build (CONSTRUCTOR,\n+\t\tbuild_prim_array_type (nativecode_ptr_type_node, arraysize),\n+\t\tNULL_TREE, list);\n }\n \n void\n@@ -1733,13 +1760,37 @@ build_dtable_decl (type)\n      TYPE. */\n   if (current_class == type)\n     {\n-      tree dummy = NULL_TREE, aomt, n;\n+      tree dummy = NULL_TREE;\n+      int n;\n \n       dtype = make_node (RECORD_TYPE);\n+\n       PUSH_FIELD (dtype, dummy, \"class\", class_ptr_type);\n-      n = build_int_2 (TREE_VEC_LENGTH (get_dispatch_vector (type)), 0);\n-      aomt = build_array_type (ptr_type_node, build_index_type (n));\n-      PUSH_FIELD (dtype, dummy, \"methods\", aomt);\n+      for (n = 1; n < TARGET_VTABLE_USES_DESCRIPTORS; ++n)\n+\t{\n+\t  tree tmp_field = build_decl (FIELD_DECL, NULL_TREE, ptr_type_node);\n+\t  TREE_CHAIN (dummy) = tmp_field;\n+\t  DECL_CONTEXT (tmp_field) = dtype;\n+\t  DECL_ARTIFICIAL (tmp_field) = 1;\n+\t  dummy = tmp_field;\n+\t}\n+\n+      PUSH_FIELD (dtype, dummy, \"gc_descr\", ptr_type_node);\n+      for (n = 1; n < TARGET_VTABLE_USES_DESCRIPTORS; ++n)\n+\t{\n+\t  tree tmp_field = build_decl (FIELD_DECL, NULL_TREE, ptr_type_node);\n+\t  TREE_CHAIN (dummy) = tmp_field;\n+\t  DECL_CONTEXT (tmp_field) = dtype;\n+\t  DECL_ARTIFICIAL (tmp_field) = 1;\n+\t  dummy = tmp_field;\n+\t}\n+\n+      n = TREE_VEC_LENGTH (get_dispatch_vector (type));\n+      if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\tn *= TARGET_VTABLE_USES_DESCRIPTORS;\n+\n+      PUSH_FIELD (dtype, dummy, \"methods\",\n+\t\t  build_prim_array_type (nativecode_ptr_type_node, n));\n       layout_type (dtype);\n     }\n   else"}, {"sha": "5481289e444aff9e57fcfa5e9d78bd5350c20216", "filename": "gcc/java/expr.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1845,9 +1845,18 @@ build_invokevirtual (dtable, method)\n   method_index = size_binop (PLUS_EXPR, method_index, size_int (2));\n   method_index = size_binop (MULT_EXPR, method_index,\n \t\t\t     TYPE_SIZE_UNIT (nativecode_ptr_ptr_type_node));\n+\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    method_index = size_binop (MULT_EXPR, method_index,\n+\t\t\t       size_int (TARGET_VTABLE_USES_DESCRIPTORS));\n+\n   func = fold (build (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n \t\t      convert (nativecode_ptr_ptr_type_node, method_index)));\n-  func = build1 (INDIRECT_REF, nativecode_ptr_type_node, func);\n+\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    func = build1 (NOP_EXPR, nativecode_ptr_type_node, func);\n+  else\n+    func = build1 (INDIRECT_REF, nativecode_ptr_type_node, func);\n \n   return func;\n }"}, {"sha": "ac98003e9cb1539aca14ac71fb6c60452d34142f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -1,3 +1,8 @@\n+2001-09-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.old-deja/g++.abi/ptrmem.C: Update for ia64 c++ abi.\n+\t* g++.old-deja/g++.abi/vtable2.C: Likewise.\n+\n 2001-09-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \tTable-driven attributes."}, {"sha": "38f8177a2a6f29fd618508b91875f2c231801a51", "filename": "gcc/testsuite/g++.old-deja/g++.abi/ptrmem.C", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -14,6 +14,16 @@\n #define ADJUST_DELTA(delta, virt) (delta)\n #endif\n \n+/* IA64 uses function descriptors instead of function pointers in its\n+   vtables, which means that we can't meaningfully compare them directly.  */\n+#if defined __ia64__\n+#define CMP_PTRFN(A, B)\t(*(void **)(A) == *(void **)(B))\n+#define VPTE_SIZE\t(16)\n+#else\n+#define CMP_PTRFN(A, B) ((A) == (B))\n+#define VPTE_SIZE\tsizeof(void *)\n+#endif\n+\n #if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n \n // Check that pointers-to-member functions are represented correctly.\n@@ -85,12 +95,12 @@ main ()\n   // There should be no adjustment for the `T' version, and an\n   // appropriate adjustment for the `S' version.\n   y = &T::f;\n-  if (yp->ptr != ADJUST_PTRFN (&_ZN1T1fEv, 0))\n+  if (! CMP_PTRFN (yp->ptr, ADJUST_PTRFN (&_ZN1T1fEv, 0)))\n     return 5;\n   if (yp->adj != ADJUST_DELTA (0, 0))\n     return 6;\n   x = (sp) y;\n-  if (xp->ptr != ADJUST_PTRFN (&_ZN1T1fEv, 0))\n+  if (! CMP_PTRFN (xp->ptr, ADJUST_PTRFN (&_ZN1T1fEv, 0)))\n     return 7;\n   if (xp->adj != ADJUST_DELTA (delta, 0))\n     return 8;\n@@ -99,12 +109,12 @@ main ()\n   // one.  `T::h' is in the second slot: the vtable pointer points to\n   // the first virtual function.\n   y = &T::h;\n-  if (yp->ptr != ADJUST_PTRFN (sizeof (void *), 1))\n+  if (yp->ptr != ADJUST_PTRFN (VPTE_SIZE, 1))\n     return 9;\n   if (yp->adj != ADJUST_DELTA (0, 1))\n     return 10;\n   x = (sp) y;\n-  if (xp->ptr != ADJUST_PTRFN (sizeof (void *), 1))\n+  if (xp->ptr != ADJUST_PTRFN (VPTE_SIZE, 1))\n     return 11;\n   if (xp->adj != ADJUST_DELTA (delta, 1))\n     return 12;"}, {"sha": "9847a15a8b83dfbbf4c4cbbe9b33abaec1c2c576", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable2.C", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -127,6 +127,15 @@ void _ZN2S32s3Ev ();\n void _ZN2S42s1Ev ();\n }\n \n+// IA-64 uses function descriptors not function pointers in its vtables.\n+#if defined __ia64__\n+#define CMP_VPTR(A, B)\t(*(void **)(A) == *(void **)(B))\n+#define INC_VPTR(A)\t((A) += 2)\n+#else\n+#define CMP_VPTR(A, B)\t(*(A) == (ptrdiff_t)(B))\n+#define INC_VPTR(A)\t((A) += 1)\n+#endif\n+\n int main ()\n {\n   S4 s4;\n@@ -148,10 +157,12 @@ int main ()\n     return 4;\n   // Skip the RTTI entry.\n   vtbl++;\n-  if (*vtbl++ != (ptrdiff_t) &_ZN2S32s3Ev)\n+  if (! CMP_VPTR (vtbl, &_ZN2S32s3Ev))\n     return 5;\n-  if (*vtbl++ != (ptrdiff_t) &_ZN2S42s1Ev)\n+  INC_VPTR (vtbl);\n+  if (! CMP_VPTR (vtbl, &_ZN2S42s1Ev))\n     return 6;\n+  INC_VPTR (vtbl);\n   // The S1 vbase offset.\n   if (*vtbl++ != 0)\n     return 7;\n@@ -169,8 +180,8 @@ int main ()\n   // Skip the RTTI entry.\n   vtbl++;\n   // Skip the remaining virtual functions -- they are thunks.\n-  vtbl++;\n-  vtbl++;\n+  INC_VPTR (vtbl);\n+  INC_VPTR (vtbl);\n }\n \n #else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}, {"sha": "4b155b0796c4e4294cdd7d406322e63e8c242a4a", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -716,9 +716,13 @@ DEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n DEFTREECODE (REFERENCE_EXPR, \"reference_expr\", 'e', 1)\n \n /* Operand is a function constant; result is a function variable value\n-   of typeEPmode.  Used only for languages that need static chains.  */\n+   of type EPmode.  Used only for languages that need static chains.  */\n DEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", 'e', 1)\n \n+/* Operand0 is a function constant; result is part N of a function \n+   descriptor of type ptr_mode.  */\n+DEFTREECODE (FDESC_EXPR, \"fdesc_expr\", 'e', 2)\n+\n /* Given two real or integer operands of the same type,\n    returns a complex value of the corresponding complex type.  */\n DEFTREECODE (COMPLEX_EXPR, \"complex_expr\", '2', 2)"}, {"sha": "72ec1a272aeeec58b56d25b8c4630a0340791e69", "filename": "gcc/varasm.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6723181663a87a735bdfdf2e16a6bd41dbc30be1/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6723181663a87a735bdfdf2e16a6bd41dbc30be1", "patch": "@@ -4277,6 +4277,7 @@ initializer_constant_valid_p (value, endtype)\n       return null_pointer_node;\n \n     case ADDR_EXPR:\n+    case FDESC_EXPR:\n       return staticp (TREE_OPERAND (value, 0)) ? TREE_OPERAND (value, 0) : 0;\n \n     case NON_LVALUE_EXPR:\n@@ -4469,6 +4470,18 @@ output_constant (exp, size, align)\n       return;\n     }\n \n+  if (TREE_CODE (exp) == FDESC_EXPR)\n+    {\n+      HOST_WIDE_INT part = tree_low_cst (TREE_OPERAND (exp, 1), 0);\n+      tree decl = TREE_OPERAND (exp, 0);\n+#ifdef ASM_OUTPUT_FDESC\n+      ASM_OUTPUT_FDESC (asm_out_file, decl, part);\n+#else\n+      abort ();\n+#endif\n+      return;\n+    }\n+\n   switch (code)\n     {\n     case CHAR_TYPE:"}]}