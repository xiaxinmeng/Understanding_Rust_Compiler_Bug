{"sha": "7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3OGExYWQxZmExMGY1MjAyZWM2NTgzOGQxZDkxYTAyNjFjZTk1Yw==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-01-26T11:33:42Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-01-26T11:33:42Z"}, "message": "[ARC] Add SJLI support.\n\ngcc/\n2018-01-26  Claudiu Zissulescu  <claziss@synopsys.com>\n\n        * config/arc/arc-protos.h: Add arc_is_secure_call_p proto.\n        * config/arc/arc.c (arc_handle_secure_attribute): New function.\n        (arc_attribute_table): Add 'secure_call' attribute.\n        (arc_print_operand): Print secure call operand.\n        (arc_function_ok_for_sibcall): Don't optimize tail calls when\n        secure.\n        (arc_is_secure_call_p): New function.\n        * config/arc/arc.md (call_i): Add support for sjli instruction.\n        (call_value_i): Likewise.\n        * config/arc/constraints.md (Csc): New constraint.\n\nFrom-SVN: r257082", "tree": {"sha": "e2e0ff73897468ae14a2bc56badea78673ba1343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e0ff73897468ae14a2bc56badea78673ba1343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b55f8c92b1ea138ac851389c456820fde8cf026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b55f8c92b1ea138ac851389c456820fde8cf026", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b55f8c92b1ea138ac851389c456820fde8cf026"}], "stats": {"total": 222, "additions": 167, "deletions": 55}, "files": [{"sha": "8782ff8b17af6c3b99ed7d24c792d34e3f8f9e19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "patch": "@@ -1,3 +1,16 @@\n+2018-01-26  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h: Add arc_is_secure_call_p proto.\n+\t* config/arc/arc.c (arc_handle_secure_attribute): New function.\n+\t(arc_attribute_table): Add 'secure_call' attribute.\n+\t(arc_print_operand): Print secure call operand.\n+\t(arc_function_ok_for_sibcall): Don't optimize tail calls when\n+\tsecure.\n+\t(arc_is_secure_call_p): New function.  * config/arc/arc.md\n+\t(call_i): Add support for sjli instruction.\n+\t(call_value_i): Likewise.\n+\t* config/arc/constraints.md (Csc): New constraint.\n+\n 2018-01-26  Claudiu Zissulescu  <claziss@synopsys.com>\n \t    John Eric Martin <John.Martin@emmicro-us.com>\n "}, {"sha": "76b82bfb517ae6900e5f577e5affcc02829b998b", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "patch": "@@ -118,3 +118,4 @@ extern bool arc_store_addr_hazard_p (rtx_insn *, rtx_insn *);\n extern rtx arc_eh_return_address_location (void);\n extern bool arc_is_jli_call_p (rtx);\n extern void arc_file_end (void);\n+extern bool arc_is_secure_call_p (rtx);"}, {"sha": "1ad0bf601f605d604e8d0e34a7760cb508a6c17a", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 123, "deletions": 40, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "patch": "@@ -226,6 +226,7 @@ static int get_arc_condition_code (rtx);\n static tree arc_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n static tree arc_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n static tree arc_handle_jli_attribute (tree *, tree, tree, int, bool *);\n+static tree arc_handle_secure_attribute (tree *, tree, tree, int, bool *);\n \n \n /* Initialized arc_attribute_table to NULL since arc doesnot have any\n@@ -257,6 +258,9 @@ const struct attribute_spec arc_attribute_table[] =\n      table is given as input parameter.  */\n   { \"jli_fixed\",    1, 1, false, true,  true,  arc_handle_jli_attribute,\n     NULL },\n+  /* Call a function using secure-mode.  */\n+  { \"secure_call\",  1, 1, false, true, true, arc_handle_secure_attribute,\n+    NULL },\n   { NULL, 0, 0, false, false, false, false, NULL, NULL }\n };\n static int arc_comp_type_attributes (const_tree, const_tree);\n@@ -3745,6 +3749,46 @@ arc_initialize_trampoline (rtx tramp, tree fndecl, rtx cxt)\n \t\t     Pmode);\n }\n \n+/* Add the given function declaration to emit code in JLI section.  */\n+\n+static void\n+arc_add_jli_section (rtx pat)\n+{\n+  const char *name;\n+  tree attrs;\n+  arc_jli_section *sec = arc_jli_sections, *new_section;\n+  tree decl = SYMBOL_REF_DECL (pat);\n+\n+  if (!pat)\n+    return;\n+\n+  if (decl)\n+    {\n+      /* For fixed locations do not generate the jli table entry.  It\n+\t should be provided by the user as an asm file.  */\n+      attrs = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+      if (lookup_attribute (\"jli_fixed\", attrs))\n+\treturn;\n+    }\n+\n+  name = XSTR (pat, 0);\n+\n+  /* Don't insert the same symbol twice.  */\n+  while (sec != NULL)\n+    {\n+      if(strcmp (name, sec->name) == 0)\n+\treturn;\n+      sec = sec->next;\n+    }\n+\n+  /* New name, insert it.  */\n+  new_section = (arc_jli_section *) xmalloc (sizeof (arc_jli_section));\n+  gcc_assert (new_section != NULL);\n+  new_section->name = name;\n+  new_section->next = arc_jli_sections;\n+  arc_jli_sections = new_section;\n+}\n+\n /* This is set briefly to 1 when we output a \".as\" address modifer, and then\n    reset when we output the scaled address.  */\n static int output_scaled = 0;\n@@ -3772,6 +3816,7 @@ static int output_scaled = 0;\n     'D'\n     'R': Second word\n     'S': JLI instruction\n+    'j': used by mov instruction to properly emit jli related labels.\n     'B': Branch comparison operand - suppress sda reference\n     'H': Most significant word\n     'L': Least significant word\n@@ -3986,6 +4031,7 @@ arc_print_operand (FILE *file, rtx x, int code)\n       else\n \toutput_operand_lossage (\"invalid operand to %%R code\");\n       return;\n+    case 'j':\n     case 'S' :\n       if (GET_CODE (x) == SYMBOL_REF\n \t  && arc_is_jli_call_p (x))\n@@ -3997,6 +4043,9 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t\t\t    : NULL_TREE);\n \t      if (lookup_attribute (\"jli_fixed\", attrs))\n \t\t{\n+\t\t  /* No special treatment for jli_fixed functions.  */\n+\t\t  if (code == 'j')\n+\t\t    break;\n \t\t  fprintf (file, \"%ld\\t; @\",\n \t\t\t   TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attrs))));\n \t\t  assemble_name (file, XSTR (x, 0));\n@@ -4005,6 +4054,22 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t    }\n \t  fprintf (file, \"@__jli.\");\n \t  assemble_name (file, XSTR (x, 0));\n+\t  if (code == 'j')\n+\t    arc_add_jli_section (x);\n+\t  return;\n+\t}\n+      if (GET_CODE (x) == SYMBOL_REF\n+\t  && arc_is_secure_call_p (x))\n+\t{\n+\t  /* No special treatment for secure functions.  */\n+\t  if (code == 'j' )\n+\t    break;\n+\t  tree attrs = (TREE_TYPE (SYMBOL_REF_DECL (x)) != error_mark_node\n+\t\t\t? TYPE_ATTRIBUTES (TREE_TYPE (SYMBOL_REF_DECL (x)))\n+\t\t\t: NULL_TREE);\n+\t  fprintf (file, \"%ld\\t; @\",\n+\t\t   TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attrs))));\n+\t  assemble_name (file, XSTR (x, 0));\n \t  return;\n \t}\n       break;\n@@ -6949,6 +7014,8 @@ arc_function_ok_for_sibcall (tree decl,\n \treturn false;\n       if (lookup_attribute (\"jli_fixed\", attrs))\n \treturn false;\n+      if (lookup_attribute (\"secure_call\", attrs))\n+\treturn false;\n     }\n \n   /* Everything else is ok.  */\n@@ -7655,46 +7722,6 @@ arc_reorg_loops (void)\n   reorg_loops (true, &arc_doloop_hooks);\n }\n \n-/* Add the given function declaration to emit code in JLI section.  */\n-\n-static void\n-arc_add_jli_section (rtx pat)\n-{\n-  const char *name;\n-  tree attrs;\n-  arc_jli_section *sec = arc_jli_sections, *new_section;\n-  tree decl = SYMBOL_REF_DECL (pat);\n-\n-  if (!pat)\n-    return;\n-\n-  if (decl)\n-    {\n-      /* For fixed locations do not generate the jli table entry.  It\n-\t should be provided by the user as an asm file.  */\n-      attrs = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n-      if (lookup_attribute (\"jli_fixed\", attrs))\n-\treturn;\n-    }\n-\n-  name = XSTR (pat, 0);\n-\n-  /* Don't insert the same symbol twice.  */\n-  while (sec != NULL)\n-    {\n-      if(strcmp (name, sec->name) == 0)\n-\treturn;\n-      sec = sec->next;\n-    }\n-\n-  /* New name, insert it.  */\n-  new_section = (arc_jli_section *) xmalloc (sizeof (arc_jli_section));\n-  gcc_assert (new_section != NULL);\n-  new_section->name = name;\n-  new_section->next = arc_jli_sections;\n-  arc_jli_sections = new_section;\n-}\n-\n /* Scan all calls and add symbols to be emitted in the jli section if\n    needed.  */\n \n@@ -11030,6 +11057,62 @@ arc_handle_jli_attribute (tree *node ATTRIBUTE_UNUSED,\n    return NULL_TREE;\n }\n \n+/* Handle and \"scure\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+\n+static tree\n+arc_handle_secure_attribute (tree *node ATTRIBUTE_UNUSED,\n+\t\t\t  tree name, tree args, int,\n+\t\t\t  bool *no_add_attrs)\n+{\n+  if (!TARGET_EM)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute only valid for ARC EM architecture\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n+  if (args == NULL_TREE)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"argument of %qE attribute is missing\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      if (TREE_CODE (TREE_VALUE (args)) == NON_LVALUE_EXPR)\n+\tTREE_VALUE (args) = TREE_OPERAND (TREE_VALUE (args), 0);\n+      tree arg = TREE_VALUE (args);\n+      if (TREE_CODE (arg) != INTEGER_CST)\n+\t{\n+\t  warning (0, \"%qE attribute allows only an integer constant argument\",\n+\t\t   name);\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+   return NULL_TREE;\n+}\n+\n+/* Return nonzero if the symbol is a secure function.  */\n+\n+bool\n+arc_is_secure_call_p (rtx pat)\n+{\n+  tree attrs;\n+  tree decl = SYMBOL_REF_DECL (pat);\n+\n+  if (!decl)\n+    return false;\n+\n+  attrs = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+  if (lookup_attribute (\"secure_call\", attrs))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Implement TARGET_USE_ANCHORS_FOR_SYMBOL_P.  We don't want to use\n    anchors for small data: the GP register acts as an anchor in that\n    case.  We also don't want to use them for PC-relative accesses,"}, {"sha": "172fd115d25bd46eb07712cadaffd89d08002d41", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "patch": "@@ -740,10 +740,10 @@\n    mov%? %0,%1\t\t;11\n    add %0,%1\t\t;12\n    add %0,pcl,%1@pcl    ;13\n-   mov%? %0,%1  \t;14\n-   mov%? %0,%1\t\t;15\n-   mov%? %0,%1\t\t;16\n-   ld%?%U1 %0,%1\t;17\n+   mov%? %0,%j1 \t;14\n+   mov%? %0,%j1\t\t;15\n+   mov%? %0,%j1\t\t;16\n+   ld%? %0,%1\t\t;17\n    st%? %1,%0%&\t\t;18\n    * return arc_short_long (insn, \\\"push%? %1%&\\\", \\\"st%U0 %1,%0%&\\\");\n    * return arc_short_long (insn, \\\"pop%? %0%&\\\",  \\\"ld%U1 %0,%1%&\\\");\n@@ -4233,7 +4233,7 @@\n ; alternative 1 (\"q\"), that means that we can't use the short form.\n (define_insn \"*call_i\"\n   [(call (mem:SI (match_operand:SI 0\n-\t\t  \"call_address_operand\" \"Rcq,q,c,Cji,Cbp,Cbr,L,I,Cal\"))\n+\t\t  \"call_address_operand\" \"Rcq,q,c,Cji,Csc,Cbp,Cbr,L,I,Cal\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))]\n   \"\"\n@@ -4242,15 +4242,16 @@\n    jl%!%* [%0]%&\n    jl%!%* [%0]\n    jli_s %S0\n+   sjli  %S0\n    bl%!%* %P0\n    bl%!%* %P0\n    jl%!%* %0\n    jl%* %0\n    jl%! %0\"\n-  [(set_attr \"type\" \"call,call,call,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n-   (set_attr \"iscompact\" \"maybe,false,*,true,*,*,*,*,*\")\n-   (set_attr \"predicable\" \"no,no,yes,no,yes,no,yes,no,yes\")\n-   (set_attr \"length\" \"*,*,4,2,4,4,4,4,8\")])\n+  [(set_attr \"type\" \"call,call,call,call_no_delay_slot,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n+   (set_attr \"iscompact\" \"maybe,false,*,true,*,*,*,*,*,*\")\n+   (set_attr \"predicable\" \"no,no,yes,no,no,yes,no,yes,no,yes\")\n+   (set_attr \"length\" \"*,*,4,2,4,4,4,4,4,8\")])\n \n (define_expand \"call_value\"\n   ;; operand 2 is stack_size_rtx\n@@ -4276,9 +4277,9 @@\n ; At instruction output time, if it doesn't match and we end up with\n ; alternative 1 (\"q\"), that means that we can't use the short form.\n (define_insn \"*call_value_i\"\n-  [(set (match_operand 0 \"dest_reg_operand\"  \"=Rcq,q,w,  w,  w,  w,w,w,  w\")\n+  [(set (match_operand 0 \"dest_reg_operand\"  \"=Rcq,q,w,  w,  w,  w,  w,w,w,  w\")\n \t(call (mem:SI (match_operand:SI 1\n-\t\t       \"call_address_operand\" \"Rcq,q,c,Cji,Cbp,Cbr,L,I,Cal\"))\n+\t\t       \"call_address_operand\" \"Rcq,q,c,Cji,Csc,Cbp,Cbr,L,I,Cal\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))]\n   \"\"\n@@ -4287,15 +4288,16 @@\n    jl%!%* [%1]%&\n    jl%!%* [%1]\n    jli_s %S1\n+   sjli  %S1\n    bl%!%* %P1;1\n    bl%!%* %P1;1\n    jl%!%* %1\n    jl%* %1\n    jl%! %1\"\n-  [(set_attr \"type\" \"call,call,call,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n-   (set_attr \"iscompact\" \"maybe,false,*,true,*,*,*,*,*\")\n-   (set_attr \"predicable\" \"no,no,yes,no,yes,no,yes,no,yes\")\n-   (set_attr \"length\" \"*,*,4,2,4,4,4,4,8\")])\n+  [(set_attr \"type\" \"call,call,call,call_no_delay_slot,call_no_delay_slot,call,call,call,call,call_no_delay_slot\")\n+   (set_attr \"iscompact\" \"maybe,false,*,true,false,*,*,*,*,*\")\n+   (set_attr \"predicable\" \"no,no,yes,no,no,yes,no,yes,no,yes\")\n+   (set_attr \"length\" \"*,*,4,2,4,4,4,4,4,8\")])\n \n ; There is a bl_s instruction (16 bit opcode branch-and-link), but we can't\n ; use it for lack of inter-procedural branch shortening."}, {"sha": "7249107d988fe705b087b28946c102a2b009013e", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "patch": "@@ -407,6 +407,13 @@\n        (match_test \"TARGET_CODE_DENSITY\")\n        (match_test \"arc_is_jli_call_p (op)\")))\n \n+(define_constraint \"Csc\"\n+  \"Secure call\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"TARGET_CODE_DENSITY\")\n+       (match_test \"TARGET_EM\")\n+       (match_test \"arc_is_secure_call_p (op)\")))\n+\n (define_constraint \"Cpc\"\n   \"pc-relative constant\"\n   (match_test \"arc_legitimate_pic_addr_p (op)\"))"}, {"sha": "a4b21e6c67a1b2a2fb98a124e833b6359765a849", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7778a1ad1fa10f5202ec65838d1d91a0261ce95c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7778a1ad1fa10f5202ec65838d1d91a0261ce95c", "patch": "@@ -3775,6 +3775,12 @@ which are addressed using this instruction.\n Identical like the above one, but the location of the function in the\n @code{jli} table is known and given as an attribute parameter.\n \n+@item secure_call\n+@cindex @code{secure_call} function attribute, ARC\n+This attribute allows one to mark secure-code functions that are\n+callable from normal mode.  The location of the secure call function\n+into the @code{sjli} table needs to be passed as argument.\n+\n @end table\n \n @node ARM Function Attributes"}]}