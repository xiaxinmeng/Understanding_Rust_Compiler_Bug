{"sha": "013e5ef956c191f9f6748615b22b78653a5e762a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzZTVlZjk1NmMxOTFmOWY2NzQ4NjE1YjIyYjc4NjUzYTVlNzYyYQ==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2013-04-26T00:30:32Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2013-04-26T00:30:32Z"}, "message": "This patch is part of a consolodation of the hash_table patches to the...\n\nThis patch is part of a consolodation of the hash_table patches to\nthe cxx-conversion branch for files not under gcc/config.\n\nUpdate various hash tables from htab_t to hash_table.\nModify types and calls to match.\n\n* var-tracking.c'emit_note_data_def.vars\n* var-tracking.c'shared_hash_def.htab\n* var-tracking.c'changed_variables\n\nFold variable_htab_hash, variable_htab_eq, variable_htab_free\n  into new struct variable_hasher.\nAdd typedef variable_table_type.\nAdd typedef variable_iterator_type.\n\nTested on x86_64.\n\n\nIndex: gcc/ChangeLog\n\n\t* var-tracking.c (shared_hash_def::htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n2013-04-25  Lawrence Crowl  <crowl@google.com>\n\nFrom-SVN: r198330", "tree": {"sha": "e7f553f5d1c71fa3170de2c64c531fcd570f5de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7f553f5d1c71fa3170de2c64c531fcd570f5de9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/013e5ef956c191f9f6748615b22b78653a5e762a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013e5ef956c191f9f6748615b22b78653a5e762a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013e5ef956c191f9f6748615b22b78653a5e762a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013e5ef956c191f9f6748615b22b78653a5e762a/comments", "author": null, "committer": null, "parents": [{"sha": "4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8fb1a1de7c34fc788ccca21f3a15980bbce093"}], "stats": {"total": 851, "additions": 426, "deletions": 425}, "files": [{"sha": "1768ae8b7ade0ee68d1044e319cc83df9488d7d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013e5ef956c191f9f6748615b22b78653a5e762a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013e5ef956c191f9f6748615b22b78653a5e762a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=013e5ef956c191f9f6748615b22b78653a5e762a", "patch": "@@ -1,3 +1,8 @@\n+2013-04-25  Lawrence Crowl  <crowl@google.com>\n+\n+\t* var-tracking.c (shared_hash_def::htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n 2013-04-25  Lawrence Crowl  <crowl@google.com>\n \n \t* Makefile.in: Update as needed below."}, {"sha": "adb7d0c0b6b642b3294bf086b5e68958c93c8100", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013e5ef956c191f9f6748615b22b78653a5e762a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013e5ef956c191f9f6748615b22b78653a5e762a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=013e5ef956c191f9f6748615b22b78653a5e762a", "patch": "@@ -3095,7 +3095,7 @@ valtrack.o : valtrack.c $(VALTRACK_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(FUNCTION_H) $(REGS_H) $(EMIT_RTL_H)\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n-   $(BASIC_BLOCK_H) bitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n+   $(BASIC_BLOCK_H) bitmap.h alloc-pool.h $(FIBHEAP_H) $(HASH_TABLE_H) \\\n    $(REGS_H) $(EXPR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n    cselib.h $(TARGET_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) $(DIAGNOSTIC_H) \\\n    pointer-set.h $(RECOG_H) $(TM_P_H) $(TREE_PRETTY_PRINT_H) $(ALIAS_H)"}, {"sha": "8108413ea72c1066a6935a8c27c569c79bd5ed53", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 420, "deletions": 424, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013e5ef956c191f9f6748615b22b78653a5e762a/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013e5ef956c191f9f6748615b22b78653a5e762a/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=013e5ef956c191f9f6748615b22b78653a5e762a", "patch": "@@ -100,7 +100,7 @@\n #include \"sbitmap.h\"\n #include \"alloc-pool.h\"\n #include \"fibheap.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"regs.h\"\n #include \"expr.h\"\n #include \"tree-pass.h\"\n@@ -196,19 +196,43 @@ typedef struct micro_operation_def\n    declaration.  */\n typedef void *decl_or_value;\n \n-/* Structure for passing some other parameters to function\n-   emit_note_insn_var_location.  */\n-typedef struct emit_note_data_def\n+/* Return true if a decl_or_value DV is a DECL or NULL.  */\n+static inline bool\n+dv_is_decl_p (decl_or_value dv)\n {\n-  /* The instruction which the note will be emitted before/after.  */\n-  rtx insn;\n+  return !dv || (int) TREE_CODE ((tree) dv) != (int) VALUE;\n+}\n \n-  /* Where the note will be emitted (before/after insn)?  */\n-  enum emit_note_where where;\n+/* Return true if a decl_or_value is a VALUE rtl.  */\n+static inline bool\n+dv_is_value_p (decl_or_value dv)\n+{\n+  return dv && !dv_is_decl_p (dv);\n+}\n+\n+/* Return the decl in the decl_or_value.  */\n+static inline tree\n+dv_as_decl (decl_or_value dv)\n+{\n+  gcc_checking_assert (dv_is_decl_p (dv));\n+  return (tree) dv;\n+}\n+\n+/* Return the value in the decl_or_value.  */\n+static inline rtx\n+dv_as_value (decl_or_value dv)\n+{\n+  gcc_checking_assert (dv_is_value_p (dv));\n+  return (rtx)dv;\n+}\n+\n+/* Return the opaque pointer in the decl_or_value.  */\n+static inline void *\n+dv_as_opaque (decl_or_value dv)\n+{\n+  return dv;\n+}\n \n-  /* The variables and values active at this point.  */\n-  htab_t vars;\n-} emit_note_data;\n \n /* Description of location of a part of a variable.  The content of a physical\n    register is described by a chain of these structures.\n@@ -229,58 +253,6 @@ typedef struct attrs_def\n   HOST_WIDE_INT offset;\n } *attrs;\n \n-/* Structure holding a refcounted hash table.  If refcount > 1,\n-   it must be first unshared before modified.  */\n-typedef struct shared_hash_def\n-{\n-  /* Reference count.  */\n-  int refcount;\n-\n-  /* Actual hash table.  */\n-  htab_t htab;\n-} *shared_hash;\n-\n-/* Structure holding the IN or OUT set for a basic block.  */\n-typedef struct dataflow_set_def\n-{\n-  /* Adjustment of stack offset.  */\n-  HOST_WIDE_INT stack_adjust;\n-\n-  /* Attributes for registers (lists of attrs).  */\n-  attrs regs[FIRST_PSEUDO_REGISTER];\n-\n-  /* Variable locations.  */\n-  shared_hash vars;\n-\n-  /* Vars that is being traversed.  */\n-  shared_hash traversed_vars;\n-} dataflow_set;\n-\n-/* The structure (one for each basic block) containing the information\n-   needed for variable tracking.  */\n-typedef struct variable_tracking_info_def\n-{\n-  /* The vector of micro operations.  */\n-  vec<micro_operation> mos;\n-\n-  /* The IN and OUT set for dataflow analysis.  */\n-  dataflow_set in;\n-  dataflow_set out;\n-\n-  /* The permanent-in dataflow set for this block.  This is used to\n-     hold values for which we had to compute entry values.  ??? This\n-     should probably be dynamically allocated, to avoid using more\n-     memory in non-debug builds.  */\n-  dataflow_set *permp;\n-\n-  /* Has the block been visited in DFS?  */\n-  bool visited;\n-\n-  /* Has the block been flooded in VTA?  */\n-  bool flooded;\n-\n-} *variable_tracking_info;\n-\n /* Structure for chaining the locations.  */\n typedef struct location_chain_def\n {\n@@ -454,6 +426,146 @@ typedef const struct variable_def *const_variable;\n \t\t\t      ? &VAR_LOC_1PAUX (var)->deps\t  \\\n \t\t\t      : NULL)\n \n+\n+\n+typedef unsigned int dvuid;\n+\n+/* Return the uid of DV.  */\n+\n+static inline dvuid\n+dv_uid (decl_or_value dv)\n+{\n+  if (dv_is_value_p (dv))\n+    return CSELIB_VAL_PTR (dv_as_value (dv))->uid;\n+  else\n+    return DECL_UID (dv_as_decl (dv));\n+}\n+\n+/* Compute the hash from the uid.  */\n+\n+static inline hashval_t\n+dv_uid2hash (dvuid uid)\n+{\n+  return uid;\n+}\n+\n+/* The hash function for a mask table in a shared_htab chain.  */\n+\n+static inline hashval_t\n+dv_htab_hash (decl_or_value dv)\n+{\n+  return dv_uid2hash (dv_uid (dv));\n+}\n+\n+static void variable_htab_free (void *);\n+\n+/* Variable hashtable helpers.  */\n+\n+struct variable_hasher\n+{\n+  typedef variable_def value_type;\n+  typedef void compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+/* The hash function for variable_htab, computes the hash value\n+   from the declaration of variable X.  */\n+\n+inline hashval_t\n+variable_hasher::hash (const value_type *v)\n+{\n+  return dv_htab_hash (v->dv);\n+}\n+\n+/* Compare the declaration of variable X with declaration Y.  */\n+\n+inline bool\n+variable_hasher::equal (const value_type *v, const compare_type *y)\n+{\n+  decl_or_value dv = CONST_CAST2 (decl_or_value, const void *, y);\n+\n+  return (dv_as_opaque (v->dv) == dv_as_opaque (dv));\n+}\n+\n+/* Free the element of VARIABLE_HTAB (its type is struct variable_def).  */\n+\n+inline void\n+variable_hasher::remove (value_type *var)\n+{\n+  variable_htab_free (var);\n+}\n+\n+typedef hash_table <variable_hasher> variable_table_type;\n+typedef variable_table_type::iterator variable_iterator_type;\n+\n+/* Structure for passing some other parameters to function\n+   emit_note_insn_var_location.  */\n+typedef struct emit_note_data_def\n+{\n+  /* The instruction which the note will be emitted before/after.  */\n+  rtx insn;\n+\n+  /* Where the note will be emitted (before/after insn)?  */\n+  enum emit_note_where where;\n+\n+  /* The variables and values active at this point.  */\n+  variable_table_type vars;\n+} emit_note_data;\n+\n+/* Structure holding a refcounted hash table.  If refcount > 1,\n+   it must be first unshared before modified.  */\n+typedef struct shared_hash_def\n+{\n+  /* Reference count.  */\n+  int refcount;\n+\n+  /* Actual hash table.  */\n+  variable_table_type htab;\n+} *shared_hash;\n+\n+/* Structure holding the IN or OUT set for a basic block.  */\n+typedef struct dataflow_set_def\n+{\n+  /* Adjustment of stack offset.  */\n+  HOST_WIDE_INT stack_adjust;\n+\n+  /* Attributes for registers (lists of attrs).  */\n+  attrs regs[FIRST_PSEUDO_REGISTER];\n+\n+  /* Variable locations.  */\n+  shared_hash vars;\n+\n+  /* Vars that is being traversed.  */\n+  shared_hash traversed_vars;\n+} dataflow_set;\n+\n+/* The structure (one for each basic block) containing the information\n+   needed for variable tracking.  */\n+typedef struct variable_tracking_info_def\n+{\n+  /* The vector of micro operations.  */\n+  vec<micro_operation> mos;\n+\n+  /* The IN and OUT set for dataflow analysis.  */\n+  dataflow_set in;\n+  dataflow_set out;\n+\n+  /* The permanent-in dataflow set for this block.  This is used to\n+     hold values for which we had to compute entry values.  ??? This\n+     should probably be dynamically allocated, to avoid using more\n+     memory in non-debug builds.  */\n+  dataflow_set *permp;\n+\n+  /* Has the block been visited in DFS?  */\n+  bool visited;\n+\n+  /* Has the block been flooded in VTA?  */\n+  bool flooded;\n+\n+} *variable_tracking_info;\n+\n /* Alloc pool for struct attrs_def.  */\n static alloc_pool attrs_pool;\n \n@@ -473,15 +585,15 @@ static alloc_pool shared_hash_pool;\n static alloc_pool loc_exp_dep_pool;\n \n /* Changed variables, notes will be emitted for them.  */\n-static htab_t changed_variables;\n+static variable_table_type changed_variables;\n \n /* Shall notes be emitted?  */\n static bool emit_notes;\n \n /* Values whose dynamic location lists have gone empty, but whose\n    cselib location lists are still usable.  Use this to hold the\n    current location, the backlinks, etc, during emit_notes.  */\n-static htab_t dropped_values;\n+static variable_table_type dropped_values;\n \n /* Empty shared hashtable.  */\n static shared_hash empty_shared_hash;\n@@ -509,9 +621,6 @@ static void stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n static void insn_stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t       HOST_WIDE_INT *);\n static bool vt_stack_adjustments (void);\n-static hashval_t variable_htab_hash (const void *);\n-static int variable_htab_eq (const void *, const void *);\n-static void variable_htab_free (void *);\n \n static void init_attrs_list_set (attrs *);\n static void attrs_list_clear (attrs *);\n@@ -520,9 +629,9 @@ static void attrs_list_insert (attrs *, decl_or_value, HOST_WIDE_INT, rtx);\n static void attrs_list_copy (attrs *, attrs);\n static void attrs_list_union (attrs *, attrs);\n \n-static void **unshare_variable (dataflow_set *set, void **slot, variable var,\n-\t\t\t\tenum var_init_status);\n-static void vars_copy (htab_t, htab_t);\n+static variable_def **unshare_variable (dataflow_set *set, variable_def **slot,\n+\t\t\t\t\tvariable var, enum var_init_status);\n+static void vars_copy (variable_table_type, variable_table_type);\n static tree var_debug_decl (tree);\n static void var_reg_set (dataflow_set *, rtx, enum var_init_status, rtx);\n static void var_reg_delete_and_set (dataflow_set *, rtx, bool,\n@@ -539,7 +648,7 @@ static void dataflow_set_clear (dataflow_set *);\n static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n static int variable_union_info_cmp_pos (const void *, const void *);\n static void dataflow_set_union (dataflow_set *, dataflow_set *);\n-static location_chain find_loc_in_1pdv (rtx, variable, htab_t);\n+static location_chain find_loc_in_1pdv (rtx, variable, variable_table_type);\n static bool canon_value_cmp (rtx, rtx);\n static int loc_cmp (rtx, rtx);\n static bool variable_part_different_p (variable_part *, variable_part *);\n@@ -558,32 +667,27 @@ static bool compute_bb_dataflow (basic_block);\n static bool vt_find_locations (void);\n \n static void dump_attrs_list (attrs);\n-static int dump_var_slot (void **, void *);\n static void dump_var (variable);\n-static void dump_vars (htab_t);\n+static void dump_vars (variable_table_type);\n static void dump_dataflow_set (dataflow_set *);\n static void dump_dataflow_sets (void);\n \n static void set_dv_changed (decl_or_value, bool);\n static void variable_was_changed (variable, dataflow_set *);\n-static void **set_slot_part (dataflow_set *, rtx, void **,\n-\t\t\t     decl_or_value, HOST_WIDE_INT,\n-\t\t\t     enum var_init_status, rtx);\n+static variable_def **set_slot_part (dataflow_set *, rtx, variable_def **,\n+\t\t\t\t     decl_or_value, HOST_WIDE_INT,\n+\t\t\t\t     enum var_init_status, rtx);\n static void set_variable_part (dataflow_set *, rtx,\n \t\t\t       decl_or_value, HOST_WIDE_INT,\n \t\t\t       enum var_init_status, rtx, enum insert_option);\n-static void **clobber_slot_part (dataflow_set *, rtx,\n-\t\t\t\t void **, HOST_WIDE_INT, rtx);\n+static variable_def **clobber_slot_part (dataflow_set *, rtx,\n+\t\t\t\t\t variable_def **, HOST_WIDE_INT, rtx);\n static void clobber_variable_part (dataflow_set *, rtx,\n \t\t\t\t   decl_or_value, HOST_WIDE_INT, rtx);\n-static void **delete_slot_part (dataflow_set *, rtx, void **, HOST_WIDE_INT);\n+static variable_def **delete_slot_part (dataflow_set *, rtx, variable_def **,\n+\t\t\t\t\tHOST_WIDE_INT);\n static void delete_variable_part (dataflow_set *, rtx,\n \t\t\t\t  decl_or_value, HOST_WIDE_INT);\n-static int emit_note_insn_var_location (void **, void *);\n-static void emit_notes_for_changes (rtx, enum emit_note_where, shared_hash);\n-static int emit_notes_for_differences_1 (void **, void *);\n-static int emit_notes_for_differences_2 (void **, void *);\n-static void emit_notes_for_differences (rtx, dataflow_set *, dataflow_set *);\n static void emit_notes_in_bb (basic_block, dataflow_set *);\n static void vt_emit_notes (void);\n \n@@ -1188,36 +1292,6 @@ adjust_insn (basic_block bb, rtx insn)\n     }\n }\n \n-/* Return true if a decl_or_value DV is a DECL or NULL.  */\n-static inline bool\n-dv_is_decl_p (decl_or_value dv)\n-{\n-  return !dv || (int) TREE_CODE ((tree) dv) != (int) VALUE;\n-}\n-\n-/* Return true if a decl_or_value is a VALUE rtl.  */\n-static inline bool\n-dv_is_value_p (decl_or_value dv)\n-{\n-  return dv && !dv_is_decl_p (dv);\n-}\n-\n-/* Return the decl in the decl_or_value.  */\n-static inline tree\n-dv_as_decl (decl_or_value dv)\n-{\n-  gcc_checking_assert (dv_is_decl_p (dv));\n-  return (tree) dv;\n-}\n-\n-/* Return the value in the decl_or_value.  */\n-static inline rtx\n-dv_as_value (decl_or_value dv)\n-{\n-  gcc_checking_assert (dv_is_value_p (dv));\n-  return (rtx)dv;\n-}\n-\n /* Return the DEBUG_EXPR of a DEBUG_EXPR_DECL or the VALUE in DV.  */\n static inline rtx\n dv_as_rtx (decl_or_value dv)\n@@ -1233,13 +1307,6 @@ dv_as_rtx (decl_or_value dv)\n   return DECL_RTL_KNOWN_SET (decl);\n }\n \n-/* Return the opaque pointer in the decl_or_value.  */\n-static inline void *\n-dv_as_opaque (decl_or_value dv)\n-{\n-  return dv;\n-}\n-\n /* Return nonzero if a decl_or_value must not have more than one\n    variable part.  The returned value discriminates among various\n    kinds of one-part DVs ccording to enum onepart_enum.  */\n@@ -1327,57 +1394,6 @@ debug_dv (decl_or_value dv)\n     debug_generic_stmt (dv_as_decl (dv));\n }\n \n-typedef unsigned int dvuid;\n-\n-/* Return the uid of DV.  */\n-\n-static inline dvuid\n-dv_uid (decl_or_value dv)\n-{\n-  if (dv_is_value_p (dv))\n-    return CSELIB_VAL_PTR (dv_as_value (dv))->uid;\n-  else\n-    return DECL_UID (dv_as_decl (dv));\n-}\n-\n-/* Compute the hash from the uid.  */\n-\n-static inline hashval_t\n-dv_uid2hash (dvuid uid)\n-{\n-  return uid;\n-}\n-\n-/* The hash function for a mask table in a shared_htab chain.  */\n-\n-static inline hashval_t\n-dv_htab_hash (decl_or_value dv)\n-{\n-  return dv_uid2hash (dv_uid (dv));\n-}\n-\n-/* The hash function for variable_htab, computes the hash value\n-   from the declaration of variable X.  */\n-\n-static hashval_t\n-variable_htab_hash (const void *x)\n-{\n-  const_variable const v = (const_variable) x;\n-\n-  return dv_htab_hash (v->dv);\n-}\n-\n-/* Compare the declaration of variable X with declaration Y.  */\n-\n-static int\n-variable_htab_eq (const void *x, const void *y)\n-{\n-  const_variable const v = (const_variable) x;\n-  decl_or_value dv = CONST_CAST2 (decl_or_value, const void *, y);\n-\n-  return (dv_as_opaque (v->dv) == dv_as_opaque (dv));\n-}\n-\n static void loc_exp_dep_clear (variable var);\n \n /* Free the element of VARIABLE_HTAB (its type is struct variable_def).  */\n@@ -1534,7 +1550,7 @@ shared_hash_shared (shared_hash vars)\n \n /* Return the hash table for VARS.  */\n \n-static inline htab_t\n+static inline variable_table_type\n shared_hash_htab (shared_hash vars)\n {\n   return vars->htab;\n@@ -1558,9 +1574,7 @@ shared_hash_unshare (shared_hash vars)\n   shared_hash new_vars = (shared_hash) pool_alloc (shared_hash_pool);\n   gcc_assert (vars->refcount > 1);\n   new_vars->refcount = 1;\n-  new_vars->htab\n-    = htab_create (htab_elements (vars->htab) + 3, variable_htab_hash,\n-\t\t   variable_htab_eq, variable_htab_free);\n+  new_vars->htab.create (vars->htab.elements () + 3);\n   vars_copy (new_vars->htab, vars->htab);\n   vars->refcount--;\n   return new_vars;\n@@ -1584,24 +1598,24 @@ shared_hash_destroy (shared_hash vars)\n   gcc_checking_assert (vars->refcount > 0);\n   if (--vars->refcount == 0)\n     {\n-      htab_delete (vars->htab);\n+      vars->htab.dispose ();\n       pool_free (shared_hash_pool, vars);\n     }\n }\n \n /* Unshare *PVARS if shared and return slot for DV.  If INS is\n    INSERT, insert it if not already present.  */\n \n-static inline void **\n+static inline variable_def **\n shared_hash_find_slot_unshare_1 (shared_hash *pvars, decl_or_value dv,\n \t\t\t\t hashval_t dvhash, enum insert_option ins)\n {\n   if (shared_hash_shared (*pvars))\n     *pvars = shared_hash_unshare (*pvars);\n-  return htab_find_slot_with_hash (shared_hash_htab (*pvars), dv, dvhash, ins);\n+  return shared_hash_htab (*pvars).find_slot_with_hash (dv, dvhash, ins);\n }\n \n-static inline void **\n+static inline variable_def **\n shared_hash_find_slot_unshare (shared_hash *pvars, decl_or_value dv,\n \t\t\t       enum insert_option ins)\n {\n@@ -1612,31 +1626,30 @@ shared_hash_find_slot_unshare (shared_hash *pvars, decl_or_value dv,\n    If it is not present, insert it only VARS is not shared, otherwise\n    return NULL.  */\n \n-static inline void **\n+static inline variable_def **\n shared_hash_find_slot_1 (shared_hash vars, decl_or_value dv, hashval_t dvhash)\n {\n-  return htab_find_slot_with_hash (shared_hash_htab (vars), dv, dvhash,\n-\t\t\t\t   shared_hash_shared (vars)\n-\t\t\t\t   ? NO_INSERT : INSERT);\n+  return shared_hash_htab (vars).find_slot_with_hash (dv, dvhash,\n+\t\t\t\t\t\t      shared_hash_shared (vars)\n+\t\t\t\t\t\t      ? NO_INSERT : INSERT);\n }\n \n-static inline void **\n+static inline variable_def **\n shared_hash_find_slot (shared_hash vars, decl_or_value dv)\n {\n   return shared_hash_find_slot_1 (vars, dv, dv_htab_hash (dv));\n }\n \n /* Return slot for DV only if it is already present in the hash table.  */\n \n-static inline void **\n+static inline variable_def **\n shared_hash_find_slot_noinsert_1 (shared_hash vars, decl_or_value dv,\n \t\t\t\t  hashval_t dvhash)\n {\n-  return htab_find_slot_with_hash (shared_hash_htab (vars), dv, dvhash,\n-\t\t\t\t   NO_INSERT);\n+  return shared_hash_htab (vars).find_slot_with_hash (dv, dvhash, NO_INSERT);\n }\n \n-static inline void **\n+static inline variable_def **\n shared_hash_find_slot_noinsert (shared_hash vars, decl_or_value dv)\n {\n   return shared_hash_find_slot_noinsert_1 (vars, dv, dv_htab_hash (dv));\n@@ -1648,7 +1661,7 @@ shared_hash_find_slot_noinsert (shared_hash vars, decl_or_value dv)\n static inline variable\n shared_hash_find_1 (shared_hash vars, decl_or_value dv, hashval_t dvhash)\n {\n-  return (variable) htab_find_with_hash (shared_hash_htab (vars), dv, dvhash);\n+  return shared_hash_htab (vars).find_with_hash (dv, dvhash);\n }\n \n static inline variable\n@@ -1677,8 +1690,8 @@ static bool dst_can_be_shared;\n \n /* Return a copy of a variable VAR and insert it to dataflow set SET.  */\n \n-static void **\n-unshare_variable (dataflow_set *set, void **slot, variable var,\n+static variable_def **\n+unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n \t\t  enum var_init_status initialized)\n {\n   variable new_var;\n@@ -1744,8 +1757,8 @@ unshare_variable (dataflow_set *set, void **slot, variable var,\n   *slot = new_var;\n   if (var->in_changed_variables)\n     {\n-      void **cslot\n-\t= htab_find_slot_with_hash (changed_variables, var->dv,\n+      variable_def **cslot\n+\t= changed_variables.find_slot_with_hash (var->dv,\n \t\t\t\t    dv_htab_hash (var->dv), NO_INSERT);\n       gcc_assert (*cslot == (void *) var);\n       var->in_changed_variables = false;\n@@ -1759,18 +1772,16 @@ unshare_variable (dataflow_set *set, void **slot, variable var,\n /* Copy all variables from hash table SRC to hash table DST.  */\n \n static void\n-vars_copy (htab_t dst, htab_t src)\n+vars_copy (variable_table_type dst, variable_table_type src)\n {\n-  htab_iterator hi;\n+  variable_iterator_type hi;\n   variable var;\n \n-  FOR_EACH_HTAB_ELEMENT (src, var, variable, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (src, var, variable, hi)\n     {\n-      void **dstp;\n+      variable_def **dstp;\n       var->refcount++;\n-      dstp = htab_find_slot_with_hash (dst, var->dv,\n-\t\t\t\t       dv_htab_hash (var->dv),\n-\t\t\t\t       INSERT);\n+      dstp = dst.find_slot_with_hash (var->dv, dv_htab_hash (var->dv), INSERT);\n       *dstp = var;\n     }\n }\n@@ -2057,8 +2068,7 @@ get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n     }\n \n   dv = dv_from_rtx (x);\n-  var = (variable) htab_find_with_hash (shared_hash_htab (set->vars),\n-\t\t\t\t\tdv, dv_htab_hash (dv));\n+  var = shared_hash_find (set->vars, dv);\n   if (!var)\n     return x;\n \n@@ -2198,13 +2208,12 @@ struct overlapping_mems\n    canonicalized form of COMS->LOC's address, and COMS->LOC must be\n    canonicalized itself.  */\n \n-static int\n-drop_overlapping_mem_locs (void **slot, void *data)\n+int\n+drop_overlapping_mem_locs (variable_def **slot, overlapping_mems *coms)\n {\n-  struct overlapping_mems *coms = (struct overlapping_mems *)data;\n   dataflow_set *set = coms->set;\n   rtx mloc = coms->loc, addr = coms->addr;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n \n   if (var->onepart == ONEPART_VALUE)\n     {\n@@ -2224,7 +2233,7 @@ drop_overlapping_mem_locs (void **slot, void *data)\n \t    return 1;\n \n \t  slot = unshare_variable (set, slot, var, VAR_INIT_STATUS_UNKNOWN);\n-\t  var = (variable)*slot;\n+\t  var = *slot;\n \t  gcc_assert (var->n_var_parts == 1);\n \t}\n \n@@ -2282,8 +2291,8 @@ clobber_overlapping_mems (dataflow_set *set, rtx loc)\n   coms.addr = vt_canonicalize_addr (set, XEXP (loc, 0));\n \n   set->traversed_vars = set->vars;\n-  htab_traverse (shared_hash_htab (set->vars),\n-\t\t drop_overlapping_mem_locs, &coms);\n+  shared_hash_htab (set->vars)\n+    .traverse <overlapping_mems*, drop_overlapping_mem_locs> (&coms);\n   set->traversed_vars = NULL;\n }\n \n@@ -2701,7 +2710,7 @@ static int\n variable_union (variable src, dataflow_set *set)\n {\n   variable dst;\n-  void **dstp;\n+  variable_def **dstp;\n   int i, j, k;\n \n   dstp = shared_hash_find_slot (set->vars, src->dv);\n@@ -2719,7 +2728,7 @@ variable_union (variable src, dataflow_set *set)\n       return 1;\n     }\n   else\n-    dst = (variable) *dstp;\n+    dst = *dstp;\n \n   gcc_assert (src->n_var_parts);\n   gcc_checking_assert (src->onepart == dst->onepart);\n@@ -2753,7 +2762,7 @@ variable_union (variable src, dataflow_set *set)\n \t\t{\n \t\t  dstp = unshare_variable (set, dstp, dst,\n \t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n-\t\t  dst = (variable)*dstp;\n+\t\t  dst = *dstp;\n \t\t  goto restart_onepart_unshared;\n \t\t}\n \n@@ -2806,7 +2815,7 @@ variable_union (variable src, dataflow_set *set)\n   if (dst->n_var_parts != k && shared_var_p (dst, set->vars))\n     {\n       dstp = unshare_variable (set, dstp, dst, VAR_INIT_STATUS_UNKNOWN);\n-      dst = (variable)*dstp;\n+      dst = *dstp;\n     }\n \n   i = src->n_var_parts - 1;\n@@ -3081,10 +3090,11 @@ dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n     }\n   else\n     {\n-      htab_iterator hi;\n+      variable_iterator_type hi;\n       variable var;\n \n-      FOR_EACH_HTAB_ELEMENT (shared_hash_htab (src->vars), var, variable, hi)\n+      FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (src->vars),\n+\t\t\t\t   var, variable, hi)\n \tvariable_union (var, dst);\n     }\n }\n@@ -3147,7 +3157,7 @@ dv_changed_p (decl_or_value dv)\n    be in star-canonical form.  */\n \n static location_chain\n-find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n+find_loc_in_1pdv (rtx loc, variable var, variable_table_type vars)\n {\n   location_chain node;\n   enum rtx_code loc_code;\n@@ -3204,7 +3214,7 @@ find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n       gcc_checking_assert (!node->next);\n \n       dv = dv_from_value (node->loc);\n-      rvar = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+      rvar = vars.find_with_hash (dv, dv_htab_hash (dv));\n       return find_loc_in_1pdv (loc, rvar, vars);\n     }\n \n@@ -3520,10 +3530,11 @@ loc_cmp (rtx x, rtx y)\n #if ENABLE_CHECKING\n /* Check the order of entries in one-part variables.   */\n \n-static int\n-canonicalize_loc_order_check (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+canonicalize_loc_order_check (variable_def **slot,\n+\t\t\t      dataflow_set *data ATTRIBUTE_UNUSED)\n {\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n   location_chain node, next;\n \n #ifdef ENABLE_RTL_CHECKING\n@@ -3555,11 +3566,10 @@ canonicalize_loc_order_check (void **slot, void *data ATTRIBUTE_UNUSED)\n    Ensure less likely values can reach more likely neighbors, making\n    the connections bidirectional.  */\n \n-static int\n-canonicalize_values_mark (void **slot, void *data)\n+int\n+canonicalize_values_mark (variable_def **slot, dataflow_set *set)\n {\n-  dataflow_set *set = (dataflow_set *)data;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n   decl_or_value dv = var->dv;\n   rtx val;\n   location_chain node;\n@@ -3579,7 +3589,8 @@ canonicalize_values_mark (void **slot, void *data)\n \telse\n \t  {\n \t    decl_or_value odv = dv_from_value (node->loc);\n-\t    void **oslot = shared_hash_find_slot_noinsert (set->vars, odv);\n+\t    variable_def **oslot;\n+\t    oslot = shared_hash_find_slot_noinsert (set->vars, odv);\n \n \t    set_slot_part (set, val, oslot, odv, 0,\n \t\t\t   node->init, NULL_RTX);\n@@ -3594,16 +3605,15 @@ canonicalize_values_mark (void **slot, void *data)\n /* Remove redundant entries from equivalence lists in onepart\n    variables, canonicalizing equivalence sets into star shapes.  */\n \n-static int\n-canonicalize_values_star (void **slot, void *data)\n+int\n+canonicalize_values_star (variable_def **slot, dataflow_set *set)\n {\n-  dataflow_set *set = (dataflow_set *)data;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n   decl_or_value dv = var->dv;\n   location_chain node;\n   decl_or_value cdv;\n   rtx val, cval;\n-  void **cslot;\n+  variable_def **cslot;\n   bool has_value;\n   bool has_marks;\n \n@@ -3669,7 +3679,7 @@ canonicalize_values_star (void **slot, void *data)\n \t\tclobber_variable_part (set, NULL, var->dv, 0, NULL);\n \t\treturn 1;\n \t      }\n-\t    var = (variable)*slot;\n+\t    var = *slot;\n \t    gcc_assert (dv_is_value_p (var->dv));\n \t    if (var->n_var_parts == 0)\n \t      return 1;\n@@ -3799,7 +3809,7 @@ canonicalize_values_star (void **slot, void *data)\n   slot = clobber_slot_part (set, cval, slot, 0, NULL);\n \n   /* Variable may have been unshared.  */\n-  var = (variable)*slot;\n+  var = *slot;\n   gcc_checking_assert (var->n_var_parts && var->var_part[0].loc_chain->loc == cval\n \t\t       && var->var_part[0].loc_chain->next == NULL);\n \n@@ -3816,16 +3826,15 @@ canonicalize_values_star (void **slot, void *data)\n    have determined or even seen the canonical value of a set when we\n    get to a variable that references another member of the set.  */\n \n-static int\n-canonicalize_vars_star (void **slot, void *data)\n+int\n+canonicalize_vars_star (variable_def **slot, dataflow_set *set)\n {\n-  dataflow_set *set = (dataflow_set *)data;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n   decl_or_value dv = var->dv;\n   location_chain node;\n   rtx cval;\n   decl_or_value cdv;\n-  void **cslot;\n+  variable_def **cslot;\n   variable cvar;\n   location_chain cnode;\n \n@@ -3847,7 +3856,7 @@ canonicalize_vars_star (void **slot, void *data)\n   cslot = shared_hash_find_slot_noinsert (set->vars, cdv);\n   if (!cslot)\n     return 1;\n-  cvar = (variable)*cslot;\n+  cvar = *cslot;\n   gcc_assert (cvar->n_var_parts == 1);\n \n   cnode = cvar->var_part[0].loc_chain;\n@@ -3879,7 +3888,7 @@ static int\n variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n {\n   dataflow_set *dst = dsm->dst;\n-  void **dstslot;\n+  variable_def **dstslot;\n   variable s2var, dvar = NULL;\n   decl_or_value dv = s1var->dv;\n   onepart_enum_t onepart = s1var->onepart;\n@@ -3919,7 +3928,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n   dstslot = shared_hash_find_slot_noinsert_1 (dst->vars, dv, dvhash);\n   if (dstslot)\n     {\n-      dvar = (variable)*dstslot;\n+      dvar = *dstslot;\n       gcc_assert (dvar->refcount == 1\n \t\t  && dvar->onepart == onepart\n \t\t  && dvar->n_var_parts == 1);\n@@ -4017,8 +4026,8 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n       nodep = nextp;\n     }\n \n-  if (dvar != (variable)*dstslot)\n-    dvar = (variable)*dstslot;\n+  if (dvar != *dstslot)\n+    dvar = *dstslot;\n   nodep = &dvar->var_part[0].loc_chain;\n \n   if (val)\n@@ -4040,7 +4049,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n       gcc_checking_assert (dstslot\n \t\t\t   == shared_hash_find_slot_noinsert_1 (dst->vars,\n \t\t\t\t\t\t\t\tdv, dvhash));\n-      dvar = (variable)*dstslot;\n+      dvar = *dstslot;\n     }\n   else\n     {\n@@ -4076,7 +4085,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t      if (GET_CODE (node->loc) == VALUE)\n \t\t{\n \t\t  decl_or_value dv = dv_from_value (node->loc);\n-\t\t  void **slot = NULL;\n+\t\t  variable_def **slot = NULL;\n \n \t\t  if (shared_hash_shared (dst->vars))\n \t\t    slot = shared_hash_find_slot_noinsert (dst->vars, dv);\n@@ -4108,7 +4117,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t  gcc_checking_assert (dstslot\n \t\t\t       == shared_hash_find_slot_noinsert_1 (dst->vars,\n \t\t\t\t\t\t\t\t    dv, dvhash));\n-\t  dvar = (variable)*dstslot;\n+\t  dvar = *dstslot;\n \t}\n     }\n \n@@ -4144,7 +4153,7 @@ variable_merge_over_src (variable s2var, struct dfset_merge *dsm)\n \n   if (!s2var->onepart)\n     {\n-      void **dstp = shared_hash_find_slot (dst->vars, dv);\n+      variable_def **dstp = shared_hash_find_slot (dst->vars, dv);\n       *dstp = s2var;\n       s2var->refcount++;\n       return 1;\n@@ -4165,19 +4174,17 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   struct dfset_merge dsm;\n   int i;\n   size_t src1_elems, src2_elems;\n-  htab_iterator hi;\n+  variable_iterator_type hi;\n   variable var;\n \n-  src1_elems = htab_elements (shared_hash_htab (src1->vars));\n-  src2_elems = htab_elements (shared_hash_htab (src2->vars));\n+  src1_elems = shared_hash_htab (src1->vars).elements ();\n+  src2_elems = shared_hash_htab (src2->vars).elements ();\n   dataflow_set_init (dst);\n   dst->stack_adjust = cur.stack_adjust;\n   shared_hash_destroy (dst->vars);\n   dst->vars = (shared_hash) pool_alloc (shared_hash_pool);\n   dst->vars->refcount = 1;\n-  dst->vars->htab\n-    = htab_create (MAX (src1_elems, src2_elems), variable_htab_hash,\n-\t\t   variable_htab_eq, variable_htab_free);\n+  dst->vars->htab.create (MAX (src1_elems, src2_elems));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     attrs_list_mpdv_union (&dst->regs[i], src1->regs[i], src2->regs[i]);\n@@ -4187,9 +4194,11 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   dsm.cur = src1;\n   dsm.src_onepart_cnt = 0;\n \n-  FOR_EACH_HTAB_ELEMENT (shared_hash_htab (dsm.src->vars), var, variable, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (dsm.src->vars),\n+\t\t\t       var, variable, hi)\n     variable_merge_over_src (var, &dsm);\n-  FOR_EACH_HTAB_ELEMENT (shared_hash_htab (dsm.cur->vars), var, variable, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (dsm.cur->vars),\n+\t\t\t       var, variable, hi)\n     variable_merge_over_cur (var, &dsm);\n \n   if (dsm.src_onepart_cnt)\n@@ -4259,7 +4268,7 @@ dataflow_set_equiv_regs (dataflow_set *set)\n \tif (list->offset == 0 && dv_onepart_p (list->dv))\n \t  {\n \t    rtx cval = canon[(int)GET_MODE (list->loc)];\n-\t    void **slot;\n+\t    variable_def **slot;\n \n \t    if (!cval)\n \t      continue;\n@@ -4330,12 +4339,11 @@ struct dfset_post_merge\n /* Create values for incoming expressions associated with one-part\n    variables that don't have value numbers for them.  */\n \n-static int\n-variable_post_merge_new_vals (void **slot, void *info)\n+int\n+variable_post_merge_new_vals (variable_def **slot, dfset_post_merge *dfpm)\n {\n-  struct dfset_post_merge *dfpm = (struct dfset_post_merge *)info;\n   dataflow_set *set = dfpm->set;\n-  variable var = (variable)*slot;\n+  variable var = *slot;\n   location_chain node;\n \n   if (!var->onepart || !var->n_var_parts)\n@@ -4360,7 +4368,7 @@ variable_post_merge_new_vals (void **slot, void *info)\n \t\t{\n \t\t  slot = unshare_variable (set, slot, var,\n \t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n-\t\t  var = (variable)*slot;\n+\t\t  var = *slot;\n \t\t  goto restart;\n \t\t}\n \n@@ -4467,12 +4475,11 @@ variable_post_merge_new_vals (void **slot, void *info)\n /* Reset values in the permanent set that are not associated with the\n    chosen expression.  */\n \n-static int\n-variable_post_merge_perm_vals (void **pslot, void *info)\n+int\n+variable_post_merge_perm_vals (variable_def **pslot, dfset_post_merge *dfpm)\n {\n-  struct dfset_post_merge *dfpm = (struct dfset_post_merge *)info;\n   dataflow_set *set = dfpm->set;\n-  variable pvar = (variable)*pslot, var;\n+  variable pvar = *pslot, var;\n   location_chain pnode;\n   decl_or_value dv;\n   attrs att;\n@@ -4536,21 +4543,23 @@ dataflow_post_merge_adjust (dataflow_set *set, dataflow_set **permp)\n   dfpm.set = set;\n   dfpm.permp = permp;\n \n-  htab_traverse (shared_hash_htab (set->vars), variable_post_merge_new_vals,\n-\t\t &dfpm);\n+  shared_hash_htab (set->vars)\n+    .traverse <dfset_post_merge*, variable_post_merge_new_vals> (&dfpm);\n   if (*permp)\n-    htab_traverse (shared_hash_htab ((*permp)->vars),\n-\t\t   variable_post_merge_perm_vals, &dfpm);\n-  htab_traverse (shared_hash_htab (set->vars), canonicalize_values_star, set);\n-  htab_traverse (shared_hash_htab (set->vars), canonicalize_vars_star, set);\n+    shared_hash_htab ((*permp)->vars)\n+      .traverse <dfset_post_merge*, variable_post_merge_perm_vals> (&dfpm);\n+  shared_hash_htab (set->vars)\n+    .traverse <dataflow_set *, canonicalize_values_star> (set);\n+  shared_hash_htab (set->vars)\n+    .traverse <dataflow_set *, canonicalize_vars_star> (set);\n }\n \n /* Return a node whose loc is a MEM that refers to EXPR in the\n    location list of a one-part variable or value VAR, or in that of\n    any values recursively mentioned in the location lists.  */\n \n static location_chain\n-find_mem_expr_in_1pdv (tree expr, rtx val, htab_t vars)\n+find_mem_expr_in_1pdv (tree expr, rtx val, variable_table_type vars)\n {\n   location_chain node;\n   decl_or_value dv;\n@@ -4564,7 +4573,7 @@ find_mem_expr_in_1pdv (tree expr, rtx val, htab_t vars)\n \t      && !VALUE_RECURSED_INTO (val));\n \n   dv = dv_from_value (val);\n-  var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+  var = vars.find_with_hash (dv, dv_htab_hash (dv));\n \n   if (!var)\n     return NULL;\n@@ -4621,11 +4630,10 @@ mem_dies_at_call (rtx mem)\n    one-part variable, except those whose MEM attributes map back to\n    the variable itself, directly or within a VALUE.  */\n \n-static int\n-dataflow_set_preserve_mem_locs (void **slot, void *data)\n+int\n+dataflow_set_preserve_mem_locs (variable_def **slot, dataflow_set *set)\n {\n-  dataflow_set *set = (dataflow_set *) data;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n \n   if (var->onepart == ONEPART_VDECL || var->onepart == ONEPART_DEXPR)\n     {\n@@ -4659,7 +4667,7 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n \t    return 1;\n \n \t  slot = unshare_variable (set, slot, var, VAR_INIT_STATUS_UNKNOWN);\n-\t  var = (variable)*slot;\n+\t  var = *slot;\n \t  gcc_assert (var->n_var_parts == 1);\n \t}\n \n@@ -4731,11 +4739,10 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n /* Remove all MEMs from the location list of a hash table entry for a\n    value.  */\n \n-static int\n-dataflow_set_remove_mem_locs (void **slot, void *data)\n+int\n+dataflow_set_remove_mem_locs (variable_def **slot, dataflow_set *set)\n {\n-  dataflow_set *set = (dataflow_set *) data;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n \n   if (var->onepart == ONEPART_VALUE)\n     {\n@@ -4756,7 +4763,7 @@ dataflow_set_remove_mem_locs (void **slot, void *data)\n \t    return 1;\n \n \t  slot = unshare_variable (set, slot, var, VAR_INIT_STATUS_UNKNOWN);\n-\t  var = (variable)*slot;\n+\t  var = *slot;\n \t  gcc_assert (var->n_var_parts == 1);\n \t}\n \n@@ -4816,11 +4823,11 @@ dataflow_set_clear_at_call (dataflow_set *set)\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       set->traversed_vars = set->vars;\n-      htab_traverse (shared_hash_htab (set->vars),\n-\t\t     dataflow_set_preserve_mem_locs, set);\n+      shared_hash_htab (set->vars)\n+\t.traverse <dataflow_set *, dataflow_set_preserve_mem_locs> (set);\n       set->traversed_vars = set->vars;\n-      htab_traverse (shared_hash_htab (set->vars), dataflow_set_remove_mem_locs,\n-\t\t     set);\n+      shared_hash_htab (set->vars)\n+\t.traverse <dataflow_set *, dataflow_set_remove_mem_locs> (set);\n       set->traversed_vars = NULL;\n     }\n }\n@@ -4919,21 +4926,21 @@ variable_different_p (variable var1, variable var2)\n static bool\n dataflow_set_different (dataflow_set *old_set, dataflow_set *new_set)\n {\n-  htab_iterator hi;\n+  variable_iterator_type hi;\n   variable var1;\n \n   if (old_set->vars == new_set->vars)\n     return false;\n \n-  if (htab_elements (shared_hash_htab (old_set->vars))\n-      != htab_elements (shared_hash_htab (new_set->vars)))\n+  if (shared_hash_htab (old_set->vars).elements ()\n+      != shared_hash_htab (new_set->vars).elements ())\n     return true;\n \n-  FOR_EACH_HTAB_ELEMENT (shared_hash_htab (old_set->vars), var1, variable, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (shared_hash_htab (old_set->vars),\n+\t\t\t       var1, variable, hi)\n     {\n-      htab_t htab = shared_hash_htab (new_set->vars);\n-      variable var2 = (variable) htab_find_with_hash (htab, var1->dv,\n-\t\t\t\t\t\t      dv_htab_hash (var1->dv));\n+      variable_table_type htab = shared_hash_htab (new_set->vars);\n+      variable var2 = htab.find_with_hash (var1->dv, dv_htab_hash (var1->dv));\n       if (!var2)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -6843,13 +6850,13 @@ compute_bb_dataflow (basic_block bb)\n       local_get_addr_cache = NULL;\n \n       dataflow_set_equiv_regs (out);\n-      htab_traverse (shared_hash_htab (out->vars), canonicalize_values_mark,\n-\t\t     out);\n-      htab_traverse (shared_hash_htab (out->vars), canonicalize_values_star,\n-\t\t     out);\n+      shared_hash_htab (out->vars)\n+\t.traverse <dataflow_set *, canonicalize_values_mark> (out);\n+      shared_hash_htab (out->vars)\n+\t.traverse <dataflow_set *, canonicalize_values_star> (out);\n #if ENABLE_CHECKING\n-      htab_traverse (shared_hash_htab (out->vars),\n-\t\t     canonicalize_loc_order_check, out);\n+      shared_hash_htab (out->vars)\n+\t.traverse <dataflow_set *, canonicalize_loc_order_check> (out);\n #endif\n     }\n   changed = dataflow_set_different (&old_out, out);\n@@ -6921,12 +6928,10 @@ vt_find_locations (void)\n \t      if (VTI (bb)->in.vars)\n \t\t{\n \t\t  htabsz\n-\t\t    -= (htab_size (shared_hash_htab (VTI (bb)->in.vars))\n-\t\t\t+ htab_size (shared_hash_htab (VTI (bb)->out.vars)));\n-\t\t  oldinsz\n-\t\t    = htab_elements (shared_hash_htab (VTI (bb)->in.vars));\n-\t\t  oldoutsz\n-\t\t    = htab_elements (shared_hash_htab (VTI (bb)->out.vars));\n+\t\t    -= shared_hash_htab (VTI (bb)->in.vars).size ()\n+\t\t\t+ shared_hash_htab (VTI (bb)->out.vars).size ();\n+\t\t  oldinsz = shared_hash_htab (VTI (bb)->in.vars).elements ();\n+\t\t  oldoutsz = shared_hash_htab (VTI (bb)->out.vars).elements ();\n \t\t}\n \t      else\n \t\toldinsz = oldoutsz = 0;\n@@ -6964,9 +6969,9 @@ vt_find_locations (void)\n #if ENABLE_CHECKING\n \t\t      /* Merge and merge_adjust should keep entries in\n \t\t\t canonical order.  */\n-\t\t      htab_traverse (shared_hash_htab (in->vars),\n-\t\t\t\t     canonicalize_loc_order_check,\n-\t\t\t\t     in);\n+\t\t      shared_hash_htab (in->vars)\n+\t\t\t.traverse <dataflow_set *,\n+\t\t\t\t   canonicalize_loc_order_check> (in);\n #endif\n \t\t      if (dst_can_be_shared)\n \t\t\t{\n@@ -6986,8 +6991,8 @@ vt_find_locations (void)\n \t\t}\n \n \t      changed = compute_bb_dataflow (bb);\n-\t      htabsz += (htab_size (shared_hash_htab (VTI (bb)->in.vars))\n-\t\t\t + htab_size (shared_hash_htab (VTI (bb)->out.vars)));\n+\t      htabsz += shared_hash_htab (VTI (bb)->in.vars).size ()\n+\t\t\t + shared_hash_htab (VTI (bb)->out.vars).size ();\n \n \t      if (htabmax && htabsz > htabmax)\n \t\t{\n@@ -7034,9 +7039,9 @@ vt_find_locations (void)\n \t\tfprintf (dump_file,\n \t\t\t \"BB %i: in %i (was %i), out %i (was %i), rem %i + %i, tsz %i\\n\",\n \t\t\t bb->index,\n-\t\t\t (int)htab_elements (shared_hash_htab (VTI (bb)->in.vars)),\n+\t\t\t (int)shared_hash_htab (VTI (bb)->in.vars).size (),\n \t\t\t oldinsz,\n-\t\t\t (int)htab_elements (shared_hash_htab (VTI (bb)->out.vars)),\n+\t\t\t (int)shared_hash_htab (VTI (bb)->out.vars).size (),\n \t\t\t oldoutsz,\n \t\t\t (int)worklist->nodes, (int)pending->nodes, htabsz);\n \n@@ -7084,10 +7089,10 @@ dump_attrs_list (attrs list)\n \n /* Print the information about variable *SLOT to dump file.  */\n \n-static int\n-dump_var_slot (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+dump_var_tracking_slot (variable_def **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n \n   dump_var (var);\n \n@@ -7143,12 +7148,12 @@ dump_var (variable var)\n /* Print the information about variables from hash table VARS to dump file.  */\n \n static void\n-dump_vars (htab_t vars)\n+dump_vars (variable_table_type vars)\n {\n-  if (htab_elements (vars) > 0)\n+  if (vars.elements () > 0)\n     {\n       fprintf (dump_file, \"Variables:\\n\");\n-      htab_traverse (vars, dump_var_slot, NULL);\n+      vars.traverse <void *, dump_var_tracking_slot> (NULL);\n     }\n }\n \n@@ -7196,18 +7201,17 @@ dump_dataflow_sets (void)\n static inline variable\n variable_from_dropped (decl_or_value dv, enum insert_option insert)\n {\n-  void **slot;\n+  variable_def **slot;\n   variable empty_var;\n   onepart_enum_t onepart;\n \n-  slot = htab_find_slot_with_hash (dropped_values, dv, dv_htab_hash (dv),\n-\t\t\t\t   insert);\n+  slot = dropped_values.find_slot_with_hash (dv, dv_htab_hash (dv), insert);\n \n   if (!slot)\n     return NULL;\n \n   if (*slot)\n-    return (variable) *slot;\n+    return *slot;\n \n   gcc_checking_assert (insert == INSERT);\n \n@@ -7267,18 +7271,16 @@ variable_was_changed (variable var, dataflow_set *set)\n \n   if (emit_notes)\n     {\n-      void **slot;\n+      variable_def **slot;\n \n       /* Remember this decl or VALUE has been added to changed_variables.  */\n       set_dv_changed (var->dv, true);\n \n-      slot = htab_find_slot_with_hash (changed_variables,\n-\t\t\t\t       var->dv,\n-\t\t\t\t       hash, INSERT);\n+      slot = changed_variables.find_slot_with_hash (var->dv, hash, INSERT);\n \n       if (*slot)\n \t{\n-\t  variable old_var = (variable) *slot;\n+\t  variable old_var = *slot;\n \t  gcc_assert (old_var->in_changed_variables);\n \t  old_var->in_changed_variables = false;\n \t  if (var != old_var && var->onepart)\n@@ -7297,14 +7299,14 @@ variable_was_changed (variable var, dataflow_set *set)\n \t{\n \t  onepart_enum_t onepart = var->onepart;\n \t  variable empty_var = NULL;\n-\t  void **dslot = NULL;\n+\t  variable_def **dslot = NULL;\n \n \t  if (onepart == ONEPART_VALUE || onepart == ONEPART_DEXPR)\n \t    {\n-\t      dslot = htab_find_slot_with_hash (dropped_values, var->dv,\n+\t      dslot = dropped_values.find_slot_with_hash (var->dv,\n \t\t\t\t\t\tdv_htab_hash (var->dv),\n \t\t\t\t\t\tINSERT);\n-\t      empty_var = (variable) *dslot;\n+\t      empty_var = *dslot;\n \n \t      if (empty_var)\n \t\t{\n@@ -7359,7 +7361,7 @@ variable_was_changed (variable var, dataflow_set *set)\n       gcc_assert (set);\n       if (var->n_var_parts == 0)\n \t{\n-\t  void **slot;\n+\t  variable_def **slot;\n \n \tdrop_var:\n \t  slot = shared_hash_find_slot_noinsert (set->vars, var->dv);\n@@ -7368,7 +7370,7 @@ variable_was_changed (variable var, dataflow_set *set)\n \t      if (shared_hash_shared (set->vars))\n \t\tslot = shared_hash_find_slot_unshare (&set->vars, var->dv,\n \t\t\t\t\t\t      NO_INSERT);\n-\t      htab_clear_slot (shared_hash_htab (set->vars), slot);\n+\t      shared_hash_htab (set->vars).clear_slot (slot);\n \t    }\n \t}\n     }\n@@ -7418,8 +7420,8 @@ find_variable_location_part (variable var, HOST_WIDE_INT offset,\n   return -1;\n }\n \n-static void **\n-set_slot_part (dataflow_set *set, rtx loc, void **slot,\n+static variable_def **\n+set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t       decl_or_value dv, HOST_WIDE_INT offset,\n \t       enum var_init_status initialized, rtx set_src)\n {\n@@ -7429,7 +7431,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n   variable var;\n   onepart_enum_t onepart;\n \n-  var = (variable) *slot;\n+  var = *slot;\n \n   if (var)\n     onepart = var->onepart;\n@@ -7552,7 +7554,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n       if (shared_var_p (var, set->vars))\n \t{\n \t  slot = unshare_variable (set, slot, var, initialized);\n-\t  var = (variable)*slot;\n+\t  var = *slot;\n \t  for (nextp = &var->var_part[0].loc_chain; c;\n \t       nextp = &(*nextp)->next)\n \t    c--;\n@@ -7591,7 +7593,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t      if (shared_var_p (var, set->vars))\n \t\t{\n \t\t  slot = unshare_variable (set, slot, var, initialized);\n-\t\t  var = (variable)*slot;\n+\t\t  var = *slot;\n \t\t}\n \t    }\n \t}\n@@ -7603,7 +7605,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t  if (shared_var_p (var, set->vars))\n \t    {\n \t      slot = unshare_variable (set, slot, var, initialized);\n-\t      var = (variable)*slot;\n+\t      var = *slot;\n \t    }\n \n \t  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n@@ -7678,7 +7680,7 @@ set_variable_part (dataflow_set *set, rtx loc,\n \t\t   enum var_init_status initialized, rtx set_src,\n \t\t   enum insert_option iopt)\n {\n-  void **slot;\n+  variable_def **slot;\n \n   if (iopt == NO_INSERT)\n     slot = shared_hash_find_slot_noinsert (set->vars, dv);\n@@ -7696,11 +7698,11 @@ set_variable_part (dataflow_set *set, rtx loc,\n    The variable part is specified by variable's declaration or value\n    DV and offset OFFSET.  */\n \n-static void **\n-clobber_slot_part (dataflow_set *set, rtx loc, void **slot,\n+static variable_def **\n+clobber_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t\t   HOST_WIDE_INT offset, rtx set_src)\n {\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n   int pos = find_variable_location_part (var, offset, NULL);\n \n   if (pos >= 0)\n@@ -7759,7 +7761,7 @@ static void\n clobber_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n \t\t       HOST_WIDE_INT offset, rtx set_src)\n {\n-  void **slot;\n+  variable_def **slot;\n \n   if (!dv_as_opaque (dv)\n       || (!dv_is_value_p (dv) && ! DECL_P (dv_as_decl (dv))))\n@@ -7776,11 +7778,11 @@ clobber_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n    variable part is specified by its SET->vars slot SLOT and offset\n    OFFSET and the part's location by LOC.  */\n \n-static void **\n-delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n+static variable_def **\n+delete_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t\t  HOST_WIDE_INT offset)\n {\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n   int pos = find_variable_location_part (var, offset, NULL);\n \n   if (pos >= 0)\n@@ -7803,7 +7805,7 @@ delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t\t{\n \t\t  slot = unshare_variable (set, slot, var,\n \t\t\t\t\t   VAR_INIT_STATUS_UNKNOWN);\n-\t\t  var = (variable)*slot;\n+\t\t  var = *slot;\n \t\t  break;\n \t\t}\n \t    }\n@@ -7867,7 +7869,7 @@ static void\n delete_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n \t\t      HOST_WIDE_INT offset)\n {\n-  void **slot = shared_hash_find_slot_noinsert (set->vars, dv);\n+  variable_def **slot = shared_hash_find_slot_noinsert (set->vars, dv);\n   if (!slot)\n     return;\n \n@@ -7880,7 +7882,7 @@ delete_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n struct expand_loc_callback_data\n {\n   /* The variables and values active at this point.  */\n-  htab_t vars;\n+  variable_table_type vars;\n \n   /* Stack of values and debug_exprs under expansion, and their\n      children.  */\n@@ -7969,7 +7971,7 @@ loc_exp_dep_clear (variable var)\n    back-links in VARS.  */\n \n static void\n-loc_exp_insert_dep (variable var, rtx x, htab_t vars)\n+loc_exp_insert_dep (variable var, rtx x, variable_table_type vars)\n {\n   decl_or_value dv;\n   variable xvar;\n@@ -7979,7 +7981,7 @@ loc_exp_insert_dep (variable var, rtx x, htab_t vars)\n \n   /* ??? Build a vector of variables parallel to EXPANDING, to avoid\n      an additional look up?  */\n-  xvar = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+  xvar = vars.find_with_hash (dv, dv_htab_hash (dv));\n \n   if (!xvar)\n     {\n@@ -8019,7 +8021,8 @@ loc_exp_insert_dep (variable var, rtx x, htab_t vars)\n    true if we found any pending-recursion results.  */\n \n static bool\n-loc_exp_dep_set (variable var, rtx result, rtx *value, int count, htab_t vars)\n+loc_exp_dep_set (variable var, rtx result, rtx *value, int count,\n+\t\t variable_table_type vars)\n {\n   bool pending_recursion = false;\n \n@@ -8048,7 +8051,7 @@ loc_exp_dep_set (variable var, rtx result, rtx *value, int count, htab_t vars)\n    attempt to compute a current location.  */\n \n static void\n-notify_dependents_of_resolved_value (variable ivar, htab_t vars)\n+notify_dependents_of_resolved_value (variable ivar, variable_table_type vars)\n {\n   loc_exp_dep *led, *next;\n \n@@ -8086,7 +8089,7 @@ notify_dependents_of_resolved_value (variable ivar, htab_t vars)\n \t    continue;\n       }\n \n-      var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+      var = vars.find_with_hash (dv, dv_htab_hash (dv));\n \n       if (!var)\n \tvar = variable_from_dropped (dv, NO_INSERT);\n@@ -8330,7 +8333,7 @@ vt_expand_loc_callback (rtx x, bitmap regs,\n       return NULL;\n     }\n \n-  var = (variable) htab_find_with_hash (elcd->vars, dv, dv_htab_hash (dv));\n+  var = elcd->vars.find_with_hash (dv, dv_htab_hash (dv));\n \n   if (!var)\n     {\n@@ -8439,7 +8442,7 @@ resolve_expansions_pending_recursion (vec<rtx, va_stack> pending)\n    equivalences in VARS, updating their CUR_LOCs in the process.  */\n \n static rtx\n-vt_expand_loc (rtx loc, htab_t vars)\n+vt_expand_loc (rtx loc, variable_table_type vars)\n {\n   struct expand_loc_callback_data data;\n   rtx result;\n@@ -8461,7 +8464,7 @@ vt_expand_loc (rtx loc, htab_t vars)\n    in VARS, updating their CUR_LOCs in the process.  */\n \n static rtx\n-vt_expand_1pvar (variable var, htab_t vars)\n+vt_expand_1pvar (variable var, variable_table_type vars)\n {\n   struct expand_loc_callback_data data;\n   rtx loc;\n@@ -8486,13 +8489,13 @@ vt_expand_1pvar (variable var, htab_t vars)\n    additional parameters: WHERE specifies whether the note shall be emitted\n    before or after instruction INSN.  */\n \n-static int\n-emit_note_insn_var_location (void **varp, void *data)\n+int\n+emit_note_insn_var_location (variable_def **varp, emit_note_data *data)\n {\n-  variable var = (variable) *varp;\n-  rtx insn = ((emit_note_data *)data)->insn;\n-  enum emit_note_where where = ((emit_note_data *)data)->where;\n-  htab_t vars = ((emit_note_data *)data)->vars;\n+  variable var = *varp;\n+  rtx insn = data->insn;\n+  enum emit_note_where where = data->where;\n+  variable_table_type vars = data->vars;\n   rtx note, note_vl;\n   int i, j, n_var_parts;\n   bool complete;\n@@ -8709,7 +8712,7 @@ emit_note_insn_var_location (void **varp, void *data)\n   set_dv_changed (var->dv, false);\n   gcc_assert (var->in_changed_variables);\n   var->in_changed_variables = false;\n-  htab_clear_slot (changed_variables, varp);\n+  changed_variables.clear_slot (varp);\n \n   /* Continue traversing the hash table.  */\n   return 1;\n@@ -8718,11 +8721,11 @@ emit_note_insn_var_location (void **varp, void *data)\n /* While traversing changed_variables, push onto DATA (a stack of RTX\n    values) entries that aren't user variables.  */\n \n-static int\n-values_to_stack (void **slot, void *data)\n+int\n+var_track_values_to_stack (variable_def **slot,\n+\t\t\t   vec<rtx, va_stack> *changed_values_stack)\n {\n-  vec<rtx, va_stack> *changed_values_stack = (vec<rtx, va_stack> *) data;\n-  variable var = (variable) *slot;\n+  variable var = *slot;\n \n   if (var->onepart == ONEPART_VALUE)\n     changed_values_stack->safe_push (dv_as_value (var->dv));\n@@ -8738,14 +8741,14 @@ static void\n remove_value_from_changed_variables (rtx val)\n {\n   decl_or_value dv = dv_from_rtx (val);\n-  void **slot;\n+  variable_def **slot;\n   variable var;\n \n-  slot = htab_find_slot_with_hash (changed_variables,\n-\t\t\t\t   dv, dv_htab_hash (dv), NO_INSERT);\n-  var = (variable) *slot;\n+  slot = changed_variables.find_slot_with_hash (dv, dv_htab_hash (dv),\n+\t\t\t\t\t\tNO_INSERT);\n+  var = *slot;\n   var->in_changed_variables = false;\n-  htab_clear_slot (changed_variables, slot);\n+  changed_variables.clear_slot (slot);\n }\n \n /* If VAL (a value or debug_expr) has backlinks to variables actively\n@@ -8754,23 +8757,22 @@ remove_value_from_changed_variables (rtx val)\n    have dependencies of their own to notify.  */\n \n static void\n-notify_dependents_of_changed_value (rtx val, htab_t htab,\n+notify_dependents_of_changed_value (rtx val, variable_table_type htab,\n \t\t\t\t    vec<rtx, va_stack> *changed_values_stack)\n {\n-  void **slot;\n+  variable_def **slot;\n   variable var;\n   loc_exp_dep *led;\n   decl_or_value dv = dv_from_rtx (val);\n \n-  slot = htab_find_slot_with_hash (changed_variables,\n-\t\t\t\t   dv, dv_htab_hash (dv), NO_INSERT);\n+  slot = changed_variables.find_slot_with_hash (dv, dv_htab_hash (dv),\n+\t\t\t\t\t\tNO_INSERT);\n   if (!slot)\n-    slot = htab_find_slot_with_hash (htab,\n-\t\t\t\t     dv, dv_htab_hash (dv), NO_INSERT);\n+    slot = htab.find_slot_with_hash (dv, dv_htab_hash (dv), NO_INSERT);\n   if (!slot)\n-    slot = htab_find_slot_with_hash (dropped_values,\n-\t\t\t\t     dv, dv_htab_hash (dv), NO_INSERT);\n-  var = (variable) *slot;\n+    slot = dropped_values.find_slot_with_hash (dv, dv_htab_hash (dv),\n+\t\t\t\t\t       NO_INSERT);\n+  var = *slot;\n \n   while ((led = VAR_LOC_DEP_LST (var)))\n     {\n@@ -8800,14 +8802,14 @@ notify_dependents_of_changed_value (rtx val, htab_t htab,\n \t  break;\n \n \tcase ONEPART_VDECL:\n-\t  ivar = (variable) htab_find_with_hash (htab, ldv, dv_htab_hash (ldv));\n+\t  ivar = htab.find_with_hash (ldv, dv_htab_hash (ldv));\n \t  gcc_checking_assert (!VAR_LOC_DEP_LST (ivar));\n \t  variable_was_changed (ivar, NULL);\n \t  break;\n \n \tcase NOT_ONEPART:\n \t  pool_free (loc_exp_dep_pool, led);\n-\t  ivar = (variable) htab_find_with_hash (htab, ldv, dv_htab_hash (ldv));\n+\t  ivar = htab.find_with_hash (ldv, dv_htab_hash (ldv));\n \t  if (ivar)\n \t    {\n \t      int i = ivar->n_var_parts;\n@@ -8837,7 +8839,7 @@ notify_dependents_of_changed_value (rtx val, htab_t htab,\n    CHANGED_VARIABLES.  */\n \n static void\n-process_changed_values (htab_t htab)\n+process_changed_values (variable_table_type htab)\n {\n   int i, n;\n   rtx val;\n@@ -8846,7 +8848,9 @@ process_changed_values (htab_t htab)\n   vec_stack_alloc (rtx, changed_values_stack, 20);\n \n   /* Move values from changed_variables to changed_values_stack.  */\n-  htab_traverse (changed_variables, values_to_stack, &changed_values_stack);\n+  changed_variables\n+    .traverse <vec<rtx, va_stack>*, var_track_values_to_stack>\n+      (&changed_values_stack);\n \n   /* Back-propagate change notifications in values while popping\n      them from the stack.  */\n@@ -8879,9 +8883,9 @@ emit_notes_for_changes (rtx insn, enum emit_note_where where,\n \t\t\tshared_hash vars)\n {\n   emit_note_data data;\n-  htab_t htab = shared_hash_htab (vars);\n+  variable_table_type htab = shared_hash_htab (vars);\n \n-  if (!htab_elements (changed_variables))\n+  if (!changed_variables.elements ())\n     return;\n \n   if (MAY_HAVE_DEBUG_INSNS)\n@@ -8891,21 +8895,20 @@ emit_notes_for_changes (rtx insn, enum emit_note_where where,\n   data.where = where;\n   data.vars = htab;\n \n-  htab_traverse (changed_variables, emit_note_insn_var_location, &data);\n+  changed_variables\n+    .traverse <emit_note_data*, emit_note_insn_var_location> (&data);\n }\n \n /* Add variable *SLOT to the chain CHANGED_VARIABLES if it differs from the\n    same variable in hash table DATA or is not there at all.  */\n \n-static int\n-emit_notes_for_differences_1 (void **slot, void *data)\n+int\n+emit_notes_for_differences_1 (variable_def **slot, variable_table_type new_vars)\n {\n-  htab_t new_vars = (htab_t) data;\n   variable old_var, new_var;\n \n-  old_var = (variable) *slot;\n-  new_var = (variable) htab_find_with_hash (new_vars, old_var->dv,\n-\t\t\t\t\t    dv_htab_hash (old_var->dv));\n+  old_var = *slot;\n+  new_var = new_vars.find_with_hash (old_var->dv, dv_htab_hash (old_var->dv));\n \n   if (!new_var)\n     {\n@@ -8971,15 +8974,13 @@ emit_notes_for_differences_1 (void **slot, void *data)\n /* Add variable *SLOT to the chain CHANGED_VARIABLES if it is not in hash\n    table DATA.  */\n \n-static int\n-emit_notes_for_differences_2 (void **slot, void *data)\n+int\n+emit_notes_for_differences_2 (variable_def **slot, variable_table_type old_vars)\n {\n-  htab_t old_vars = (htab_t) data;\n   variable old_var, new_var;\n \n-  new_var = (variable) *slot;\n-  old_var = (variable) htab_find_with_hash (old_vars, new_var->dv,\n-\t\t\t\t\t    dv_htab_hash (new_var->dv));\n+  new_var = *slot;\n+  old_var = old_vars.find_with_hash (new_var->dv, dv_htab_hash (new_var->dv));\n   if (!old_var)\n     {\n       int i;\n@@ -8999,12 +9000,12 @@ static void\n emit_notes_for_differences (rtx insn, dataflow_set *old_set,\n \t\t\t    dataflow_set *new_set)\n {\n-  htab_traverse (shared_hash_htab (old_set->vars),\n-\t\t emit_notes_for_differences_1,\n-\t\t shared_hash_htab (new_set->vars));\n-  htab_traverse (shared_hash_htab (new_set->vars),\n-\t\t emit_notes_for_differences_2,\n-\t\t shared_hash_htab (old_set->vars));\n+  shared_hash_htab (old_set->vars)\n+    .traverse <variable_table_type, emit_notes_for_differences_1>\n+      (shared_hash_htab (new_set->vars));\n+  shared_hash_htab (new_set->vars)\n+    .traverse <variable_table_type, emit_notes_for_differences_2>\n+      (shared_hash_htab (old_set->vars));\n   emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN, new_set->vars);\n }\n \n@@ -9359,7 +9360,7 @@ vt_emit_notes (void)\n   basic_block bb;\n   dataflow_set cur;\n \n-  gcc_assert (!htab_elements (changed_variables));\n+  gcc_assert (!changed_variables.elements ());\n \n   /* Free memory occupied by the out hash tables, as they aren't used\n      anymore.  */\n@@ -9372,9 +9373,7 @@ vt_emit_notes (void)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n-      dropped_values = htab_create (cselib_get_next_uid () * 2,\n-\t\t\t\t    variable_htab_hash, variable_htab_eq,\n-\t\t\t\t    variable_htab_free);\n+      dropped_values.create (cselib_get_next_uid () * 2);\n       loc_exp_dep_pool = create_alloc_pool (\"loc_exp_dep pool\",\n \t\t\t\t\t    sizeof (loc_exp_dep), 64);\n     }\n@@ -9402,14 +9401,14 @@ vt_emit_notes (void)\n       dataflow_set_clear (&VTI (bb)->in);\n     }\n #ifdef ENABLE_CHECKING\n-  htab_traverse (shared_hash_htab (cur.vars),\n-\t\t emit_notes_for_differences_1,\n-\t\t shared_hash_htab (empty_shared_hash));\n+  shared_hash_htab (cur.vars)\n+    .traverse <variable_table_type, emit_notes_for_differences_1>\n+      (shared_hash_htab (empty_shared_hash));\n #endif\n   dataflow_set_destroy (&cur);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    htab_delete (dropped_values);\n+    dropped_values.dispose ();\n \n   emit_notes = false;\n }\n@@ -9745,11 +9744,8 @@ vt_initialize (void)\n \t\t\t\t\tsizeof (struct shared_hash_def), 256);\n   empty_shared_hash = (shared_hash) pool_alloc (shared_hash_pool);\n   empty_shared_hash->refcount = 1;\n-  empty_shared_hash->htab\n-    = htab_create (1, variable_htab_hash, variable_htab_eq,\n-\t\t   variable_htab_free);\n-  changed_variables = htab_create (10, variable_htab_hash, variable_htab_eq,\n-\t\t\t\t   variable_htab_free);\n+  empty_shared_hash->htab.create (1);\n+  changed_variables.create (10);\n \n   /* Init the IN and OUT sets.  */\n   FOR_ALL_BB (bb)\n@@ -10102,8 +10098,8 @@ vt_finalize (void)\n \t}\n     }\n   free_aux_for_blocks ();\n-  htab_delete (empty_shared_hash->htab);\n-  htab_delete (changed_variables);\n+  empty_shared_hash->htab.dispose ();\n+  changed_variables.dispose ();\n   free_alloc_pool (attrs_pool);\n   free_alloc_pool (var_pool);\n   free_alloc_pool (loc_chain_pool);"}]}