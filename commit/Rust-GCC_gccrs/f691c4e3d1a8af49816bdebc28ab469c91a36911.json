{"sha": "f691c4e3d1a8af49816bdebc28ab469c91a36911", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY5MWM0ZTNkMWE4YWY0OTgxNmJkZWJjMjhhYjQ2OWM5MWEzNjkxMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-29T10:30:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-29T10:30:33Z"}, "message": "mips.c (print_operand): Remove '%Y' and '%y'.\n\n\t* config/mips/mips.c (print_operand): Remove '%Y' and '%y'.\n\t(mips_expand_4s_compare_builtin): Redefine CCV4 to be 0 if all\n\tregisters are false and -1 if all registers are true.\n\t(mips_expand_ps_compare_builtin): Likewise CCV2.  Use subregs for\n\tMIPS_CMP_UPPER and MIPS_CMP_LOWER.\n\t* config/mips/mips.md (mips_cond_move_tf_ps): Use %Q rather than %y.\n\t(bc1any4t, bc1any4f): Adjust for new CCV4 interpretation.\n\t(bc1any2t, bc1any2f): Likewise CCV2.\n\t(bc1upper2t, bc1lower2t, bc1upper2f, bc1lower2f): Delete.\n\nFrom-SVN: r86715", "tree": {"sha": "30f577b3431cf235a1d4b68306cf573eed187fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30f577b3431cf235a1d4b68306cf573eed187fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f691c4e3d1a8af49816bdebc28ab469c91a36911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f691c4e3d1a8af49816bdebc28ab469c91a36911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f691c4e3d1a8af49816bdebc28ab469c91a36911", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f691c4e3d1a8af49816bdebc28ab469c91a36911/comments", "author": null, "committer": null, "parents": [{"sha": "491357065f3fcae82b880628ad05ce253a885f21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491357065f3fcae82b880628ad05ce253a885f21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/491357065f3fcae82b880628ad05ce253a885f21"}], "stats": {"total": 148, "additions": 47, "deletions": 101}, "files": [{"sha": "a35febbaea723a6a88e4900a50dd85e9452b3ef1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691c4e3d1a8af49816bdebc28ab469c91a36911/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691c4e3d1a8af49816bdebc28ab469c91a36911/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f691c4e3d1a8af49816bdebc28ab469c91a36911", "patch": "@@ -1,3 +1,15 @@\n+2004-08-29  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (print_operand): Remove '%Y' and '%y'.\n+\t(mips_expand_4s_compare_builtin): Redefine CCV4 to be 0 if all\n+\tregisters are false and -1 if all registers are true.\n+\t(mips_expand_ps_compare_builtin): Likewise CCV2.  Use subregs for\n+\tMIPS_CMP_UPPER and MIPS_CMP_LOWER.\n+\t* config/mips/mips.md (mips_cond_move_tf_ps): Use %Q rather than %y.\n+\t(bc1any4t, bc1any4f): Adjust for new CCV4 interpretation.\n+\t(bc1any2t, bc1any2f): Likewise CCV2.\n+\t(bc1upper2t, bc1lower2t, bc1upper2f, bc1lower2f): Delete.\n+\n 2004-08-29  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (UNSPEC_MOVE_TF_PS): New."}, {"sha": "f55546c9cecf5ae10aa0e1f293ab06e166aa76ad", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691c4e3d1a8af49816bdebc28ab469c91a36911/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691c4e3d1a8af49816bdebc28ab469c91a36911/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=f691c4e3d1a8af49816bdebc28ab469c91a36911", "patch": "@@ -56,8 +56,8 @@\n \t\t     UNSPEC_MOVE_TF_PS))]\n   \"TARGET_PAIRED_SINGLE_FLOAT\"\n   \"@\n-    movt.ps\\t%0,%1,%y3\n-    movf.ps\\t%0,%2,%y3\"\n+    movt.ps\\t%0,%1,%Q3\n+    movf.ps\\t%0,%2,%Q3\"\n   [(set_attr \"type\" \"condmove\")\n    (set_attr \"mode\" \"SF\")])\n \n@@ -1374,7 +1374,7 @@\n ; Branch on Any of Four Floating Point Condition Codes True\n (define_insn \"bc1any4t\"\n   [(set (pc)\n-\t(if_then_else (eq:CCV4 (match_operand:CCV4 0 \"register_operand\" \"z\")\n+\t(if_then_else (ne:CCV4 (match_operand:CCV4 0 \"register_operand\" \"z\")\n \t\t\t       (const_int 0))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n@@ -1387,7 +1387,7 @@\n (define_insn \"bc1any4f\"\n   [(set (pc)\n \t(if_then_else (ne:CCV4 (match_operand:CCV4 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 1))\n+\t\t\t       (const_int -1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_MIPS3D\"\n@@ -1398,7 +1398,7 @@\n ; Branch on Any of Two Floating Point Condition Codes True\n (define_insn \"bc1any2t\"\n   [(set (pc)\n-\t(if_then_else (eq:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n+\t(if_then_else (ne:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n \t\t\t       (const_int 0))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n@@ -1407,67 +1407,18 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n \n-; Branch on Upper of Two Floating Point Condition Codes True\n-(define_insn \"bc1upper2t\"\n-  [(set (pc)\n-\t(if_then_else (eq:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 1))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1t\\t%Y0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n-\n-; Branch on Lower of Two Floating Point Condition Codes True\n-(define_insn \"bc1lower2t\"\n-  [(set (pc)\n-\t(if_then_else (eq:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 2))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1t\\t%y0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n-\n-\n ; Branch on Any of Two Floating Point Condition Codes False\n (define_insn \"bc1any2f\"\n   [(set (pc)\n \t(if_then_else (ne:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 3))\n+\t\t\t       (const_int -1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_MIPS3D\"\n   \"%*bc1any2f\\t%Q0,%1%/\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"mode\" \"none\")])\n \n-; Branch on Upper of Two Floating Point Condition Codes False\n-(define_insn \"bc1upper2f\"\n-  [(set (pc)\n-\t(if_then_else (ne:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 1))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1f\\t%Y0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n-\n-; Branch on Lower of Two Floating Point Condition Codes False\n-(define_insn \"bc1lower2f\"\n-  [(set (pc)\n-\t(if_then_else (ne:CCV2 (match_operand:CCV2 0 \"register_operand\" \"z\")\n-\t\t\t       (const_int 2))\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"%*bc1f\\t%y0,%1%/\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")])\n-\n ;----------------------------------------------------------------------------\n ; Floating Point Reduced Precision Reciprocal Square Root Instructions.\n ;----------------------------------------------------------------------------"}, {"sha": "4f6ddd5e81b677f6108897b5dfd8e73ba82cd0c2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 29, "deletions": 46, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f691c4e3d1a8af49816bdebc28ab469c91a36911/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f691c4e3d1a8af49816bdebc28ab469c91a36911/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f691c4e3d1a8af49816bdebc28ab469c91a36911", "patch": "@@ -4570,9 +4570,6 @@ print_fcc_operand (FILE *file, rtx op, enum rtx_code code,\n    't'  like 'T', but with the EQ/NE cases reversed\n    'Z'  print register and a comma, but print nothing for $fcc0\n    'R'  print the reloc associated with LO_SUM\n-   'Y'  Check if the fcc register number is even.  Then print the fcc register \n-        plus 1.\n-   'y'  Check if the fcc register number is even.  Then print the fcc register.\n    'V'  Check if the fcc register number divided by 4 is zero.  Then print \n         the fcc register plus 2.\n    'v'  Check if the fcc register number divided by 4 is zero.  Then print \n@@ -4812,12 +4809,6 @@ print_operand (FILE *file, rtx op, int letter)\n   else if (letter == 'Z')\n     print_fcc_operand (file, op, code, 1, 0, 1);\n \n-  else if (letter == 'Y')\n-    print_fcc_operand (file, op, code, 2, 1, 0);\n-\n-  else if (letter == 'y')\n-    print_fcc_operand (file, op, code, 2, 0, 0);\n-\n   else if (letter == 'V')\n     print_fcc_operand (file, op, code, 4, 2, 0);\n \n@@ -10690,8 +10681,6 @@ mips_expand_ps_cond_move_builtin (enum mips_cmp_choice cmp_choice,\n   rtx temp_target;\n   rtx src1;\n   rtx src2;\n-  enum rtx_code test_code;\n-  int compare_value;\n \n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n@@ -10741,8 +10730,6 @@ mips_expand_ps_cond_move_builtin (enum mips_cmp_choice cmp_choice,\n   /* Copy op2 to target */\n   emit_insn (gen_rtx_SET (tmode, target, op2)); \n \n-  test_code = EQ;\n-  compare_value = 0;\n   switch (cmp_choice)\n     {\n     case MIPS_CMP_MOVT:\n@@ -10793,7 +10780,6 @@ mips_expand_4s_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n   rtx label1;\n   rtx label2;\n   rtx if_then_else;\n-  enum rtx_code test_code;\n   int compare_value;\n \n   if (target == 0 || GET_MODE (target) != SImode)\n@@ -10832,27 +10818,26 @@ mips_expand_4s_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n   if (!pat)\n     return 0;\n \n-  /* We fake the value of CCV4 to be\n-     0, if ANY is true    <-->  NOT 0, if ALL is false\n-     1, if ALL is true    <-->  NOT 1, if ANY is false\n+  /* We fake the value of CCV4 to be:\n+     0 if all registers are false.\n+     -1 if all registers are true.\n+     an indeterminate value otherse.\n  \n      Thus, we can map \"enum mips_cmp_choice\" to RTL comparison operators:\n-     MIPS_CMP_ANY ->   (EQ 0)\n-     MIPS_CMP_ALL ->   (EQ 1)\n+     MIPS_CMP_ANY ->   (NE 0)\n+     MIPS_CMP_ALL ->   (EQ -1).\n \n      However, because MIPS doesn't have \"branch_all\" instructions, \n-     for MIPS_CMP_ALL, we will use (NE 1) and reverse the assignment of \n+     for MIPS_CMP_ALL, we will use (NE -1) and reverse the assignment of\n      the target to 1 first and then 0.  */\n   switch (cmp_choice)\n     {\n     case MIPS_CMP_ANY:\n-      test_code = EQ;\n       compare_value = 0;\n       break;\n \n     case MIPS_CMP_ALL:\n-      test_code = NE;\n-      compare_value = 1;\n+      compare_value = -1;\n       break;\n \n     default:\n@@ -10870,7 +10855,7 @@ mips_expand_4s_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n   label2 = gen_label_rtx ();\n   if_then_else \n     = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (test_code, CCV4mode, temp_target, \n+\t\t\t    gen_rtx_fmt_ee (NE, CCV4mode, temp_target,\n \t\t\t\t            GEN_INT (compare_value)),\n \t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n \n@@ -10986,7 +10971,6 @@ mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n   rtx label1;\n   rtx label2;\n   rtx if_then_else;\n-  enum rtx_code test_code;\n   int compare_value;\n \n   if (target == 0 || GET_MODE (target) != SImode)\n@@ -11013,41 +10997,39 @@ mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n   if (!pat)\n     return 0;\n \n-  /* We fake the value of CCV2 to be\n-     0, if ANY is true    <-->  NOT 0, if ALL is false\n-     1, if UPPER is true  <-->  NOT 1, if UPPER is false\n-     2, if LOWER is true  <-->  NOT 2, if LOWER is false\n-     3, if ALL is true    <-->  NOT 3, if ANY is false\n+  /* We fake the value of CCV2 to be:\n+     0 if all registers are false.\n+     -1 if all registers are true.\n+     an indeterminate value otherse.\n  \n      Thus, we can map \"enum mips_cmp_choice\" to RTL comparison operators:\n-     MIPS_CMP_ANY ->   (EQ 0)\n-     MIPS_CMP_UPPER -> (EQ 1)\n-     MIPS_CMP_LOWER -> (EQ 2)\n-     MIPS_CMP_ALL ->   (EQ 3)\n+     MIPS_CMP_ANY ->   (NE 0)\n+     MIPS_CMP_ALL ->   (EQ -1).\n \n-     However, because MIPS doesn't have \"branch_all\" instructions, \n-     for MIPS_CMP_ALL, we will use (NE 3) and reverse the assignment of \n-     the target to 1 fisrt and then 0.  */\n+     However, because MIPS doesn't have \"branch_all\" instructions,\n+     for MIPS_CMP_ALL, we will use (NE -1) and reverse the assignment of\n+     the target to 1 first and then 0.\n+\n+     We handle MIPS_CMP_LOWER and MIPS_CMP_UPPER by taking the appropriate\n+     CCmode subreg and comparing against zero in the normal way.  */\n   switch (cmp_choice)\n     {\n     case MIPS_CMP_ANY:\n-      test_code = EQ;\n       compare_value = 0;\n       break;\n \n     case MIPS_CMP_UPPER:\n-      test_code = EQ;\n-      compare_value = 1;\n+      temp_target = simplify_gen_subreg (CCmode, temp_target, CCV2mode, 4);\n+      compare_value = 0;\n       break;\n \n     case MIPS_CMP_LOWER:\n-      test_code = EQ;\n-      compare_value = 2;\n+      temp_target = simplify_gen_subreg (CCmode, temp_target, CCV2mode, 0);\n+      compare_value = 0;\n       break;\n \n     case MIPS_CMP_ALL:\n-      test_code = NE;\n-      compare_value = 3;\n+      compare_value = -1;\n       break;\n \n     default:\n@@ -11066,8 +11048,9 @@ mips_expand_ps_compare_builtin (enum mips_cmp_choice cmp_choice, rtx target,\n \n   if_then_else \n     = gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t    gen_rtx_fmt_ee (test_code, CCV2mode, temp_target, \n-\t\t\t\t            GEN_INT (compare_value)),\n+\t\t\t    gen_rtx_fmt_ee (NE, GET_MODE (temp_target),\n+\t\t\t\t\t    temp_target,\n+\t\t\t\t\t    GEN_INT (compare_value)),\n \t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n \n   emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else)); "}]}