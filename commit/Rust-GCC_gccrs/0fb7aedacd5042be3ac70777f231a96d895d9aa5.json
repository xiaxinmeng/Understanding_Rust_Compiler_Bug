{"sha": "0fb7aedacd5042be3ac70777f231a96d895d9aa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiN2FlZGFjZDUwNDJiZTNhYzcwNzc3ZjIzMWE5NmQ4OTVkOWFhNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-06-03T01:13:17Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-06-03T01:13:17Z"}, "message": "emit-rtl.c: Likewise.\n\n\t* emit-rtl.c: Likewise.\n\t* errors.h: Likewise.\n\t* except.c: Likewise.\n\t* explow.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* expr.h: Likewise.\n\nFrom-SVN: r54197", "tree": {"sha": "f3cfd74f5103be9c0bd0fb3b4c386285c78a9a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3cfd74f5103be9c0bd0fb3b4c386285c78a9a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb7aedacd5042be3ac70777f231a96d895d9aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb7aedacd5042be3ac70777f231a96d895d9aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb7aedacd5042be3ac70777f231a96d895d9aa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb7aedacd5042be3ac70777f231a96d895d9aa5/comments", "author": null, "committer": null, "parents": [{"sha": "1c8ec18b71dd89b6c61b9211095775de417bafe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8ec18b71dd89b6c61b9211095775de417bafe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c8ec18b71dd89b6c61b9211095775de417bafe8"}], "stats": {"total": 196, "additions": 103, "deletions": 93}, "files": [{"sha": "b922125fc721bfb61b90ef77da5d8532beffe165", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -1,3 +1,13 @@\n+2002-06-02  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* emit-rtl.c: Likewise.\n+\t* errors.h: Likewise.\n+\t* except.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* expr.h: Likewise.\n+\n 2002-06-02  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/elf.h: Fix formatting."}, {"sha": "4651473e2b350d13e680a7c8d2c890852e589fad", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -650,7 +650,7 @@ gen_rtx VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n \tHOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n \tHOST_WIDE_INT arg1 = va_arg (p, HOST_WIDE_INT);\n \n-        rt_val = immed_double_const (arg0, arg1, mode);\n+\trt_val = immed_double_const (arg0, arg1, mode);\n       }\n       break;\n \n@@ -3050,9 +3050,9 @@ mark_label_nuses (x)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-        mark_label_nuses (XEXP (x, i));\n+\tmark_label_nuses (XEXP (x, i));\n       else if (fmt[i] == 'E')\n-        for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t  mark_label_nuses (XVECEXP (x, i, j));\n     }\n }\n@@ -3634,7 +3634,7 @@ find_line_note (insn)\n \n   for (; insn; insn = PREV_INSN (insn))\n     if (GET_CODE (insn) == NOTE\n-        && NOTE_LINE_NUMBER (insn) >= 0)\n+\t&& NOTE_LINE_NUMBER (insn) >= 0)\n       break;\n \n   return insn;\n@@ -4162,10 +4162,10 @@ emit_insns_after (first, after)\n     {\n       bb->flags |= BB_DIRTY;\n       for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n-        if (GET_CODE (last) != BARRIER)\n+\tif (GET_CODE (last) != BARRIER)\n \t  set_block_for_insn (last, bb);\n       if (GET_CODE (last) != BARRIER)\n-        set_block_for_insn (last, bb);\n+\tset_block_for_insn (last, bb);\n       if (bb->end == after)\n \tbb->end = last;\n     }"}, {"sha": "b48f855554f37f753646f4d468b3650f4072fc2d", "filename": "gcc/errors.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Ferrors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Ferrors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ferrors.h?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -39,5 +39,5 @@ extern void fancy_abort PARAMS ((const char *, int, const char *))\n \n extern int have_error;\n extern const char *progname;\n-    \n+\n #endif /* ! GCC_ERRORS_H */"}, {"sha": "5b21d64acd620a86f60e5466c0535fc7d6327fed", "filename": "gcc/except.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -851,11 +851,11 @@ expand_start_catch (type_or_list)\n       tree type_node;\n \n       if (TREE_CODE (type_or_list) != TREE_LIST)\n-        type_list = tree_cons (NULL_TREE, type_or_list, NULL_TREE);\n+\ttype_list = tree_cons (NULL_TREE, type_or_list, NULL_TREE);\n \n       type_node = type_list;\n       for (; type_node; type_node = TREE_CHAIN (type_node))\n-        add_type_for_runtime (TREE_VALUE (type_node));\n+\tadd_type_for_runtime (TREE_VALUE (type_node));\n     }\n \n   expand_eh_region_start ();\n@@ -1165,7 +1165,7 @@ remove_fixup_regions ()\n \n       /* Allow GC to maybe free some memory.  */\n       if (fixup->type == ERT_CLEANUP)\n-        fixup->u.cleanup.exp = NULL_TREE;\n+\tfixup->u.cleanup.exp = NULL_TREE;\n \n       if (fixup->type != ERT_FIXUP)\n \tcontinue;\n@@ -1221,23 +1221,23 @@ remove_unreachable_regions (insns)\n \tcontinue;\n \n       if (r->resume)\n-        {\n+\t{\n \t  if (uid_region_num[INSN_UID (r->resume)])\n \t    abort ();\n \t  uid_region_num[INSN_UID (r->resume)] = i;\n-        }\n+\t}\n       if (r->label)\n-        {\n+\t{\n \t  if (uid_region_num[INSN_UID (r->label)])\n \t    abort ();\n \t  uid_region_num[INSN_UID (r->label)] = i;\n-        }\n+\t}\n       if (r->type == ERT_TRY && r->u.try.continue_label)\n-        {\n+\t{\n \t  if (uid_region_num[INSN_UID (r->u.try.continue_label)])\n \t    abort ();\n \t  uid_region_num[INSN_UID (r->u.try.continue_label)] = i;\n-        }\n+\t}\n     }\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n@@ -1415,7 +1415,7 @@ find_exception_handler_labels ()\n       /* ??? The expansion factor here (3/2) must be greater than the htab\n \t occupancy factor (4/3) to avoid unnecessary resizing.  */\n       exception_handler_label_map\n-        = htab_create (cfun->eh->last_region_number * 3 / 2,\n+\t= htab_create (cfun->eh->last_region_number * 3 / 2,\n \t\t       ehl_hash, ehl_eq, ehl_free);\n     }\n \n@@ -1529,9 +1529,9 @@ duplicate_eh_region_2 (o, n_array)\n \n     case ERT_CATCH:\n       if (o->u.catch.next_catch)\n-        n->u.catch.next_catch = n_array[o->u.catch.next_catch->region_number];\n+\tn->u.catch.next_catch = n_array[o->u.catch.next_catch->region_number];\n       if (o->u.catch.prev_catch)\n-        n->u.catch.prev_catch = n_array[o->u.catch.prev_catch->region_number];\n+\tn->u.catch.prev_catch = n_array[o->u.catch.prev_catch->region_number];\n       break;\n \n     default:\n@@ -2281,7 +2281,7 @@ sjlj_mark_call_sites (lp_info)\n       /* Don't separate a call from it's argument loads.  */\n       before = insn;\n       if (GET_CODE (insn) == CALL_INSN)\n-         before = find_first_parameter_load (insn, NULL_RTX);\n+\tbefore = find_first_parameter_load (insn, NULL_RTX);\n \n       start_sequence ();\n       mem = adjust_address (cfun->eh->sjlj_fc, TYPE_MODE (integer_type_node),\n@@ -2600,7 +2600,7 @@ remove_eh_handler (region)\n   if (outer)\n     {\n       if (!outer->aka)\n-        outer->aka = BITMAP_XMALLOC ();\n+\touter->aka = BITMAP_XMALLOC ();\n       if (region->aka)\n \tbitmap_a_or_b (outer->aka, outer->aka, region->aka);\n       bitmap_set_bit (outer->aka, region->region_number);\n@@ -2941,7 +2941,7 @@ reachable_next_level (region, type_thrown, info)\n       if (info && info->handlers)\n \t{\n \t  add_reachable_handler (info, region, region);\n-          return RNL_CAUGHT;\n+\t  return RNL_CAUGHT;\n \t}\n       else\n \treturn RNL_BLOCKED;\n@@ -3061,7 +3061,7 @@ can_throw_internal (insn)\n       if (how == RNL_BLOCKED)\n \treturn false;\n       if (how != RNL_NOT_CAUGHT)\n-        return true;\n+\treturn true;\n     }\n \n   return false;\n@@ -3965,7 +3965,7 @@ output_function_exception_table ()\n \tassemble_integer (value, tt_format_size,\n \t\t\t  tt_format_size * BITS_PER_UNIT, 1);\n       else\n-        dw2_asm_output_encoded_addr_rtx (tt_format, value, NULL);\n+\tdw2_asm_output_encoded_addr_rtx (tt_format, value, NULL);\n     }\n \n #ifdef HAVE_AS_LEB128"}, {"sha": "fb1c2a0388c3fb785c1973f1e8ff1424bcec8a32", "filename": "gcc/explow.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -391,7 +391,7 @@ convert_memory_address (to_mode, x)\n \n     case CONST:\n       if (POINTERS_EXTEND_UNSIGNED >= 0)\n-        return gen_rtx_CONST (to_mode,\n+\treturn gen_rtx_CONST (to_mode,\n \t\t\t      convert_memory_address (to_mode, XEXP (x, 0)));\n       break;\n \n@@ -1375,7 +1375,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n #ifdef SETJMP_VIA_SAVE_AREA\n       if (setjmpless_size != NULL_RTX)\n \t{\n- \t  rtx note_target = get_last_insn ();\n+\t  rtx note_target = get_last_insn ();\n \n \t  REG_NOTES (note_target)\n \t    = gen_rtx_EXPR_LIST (REG_SAVE_AREA, setjmpless_size,\n@@ -1620,17 +1620,17 @@ hard_function_value (valtype, func, outgoing)\n \t will match and we will abort later in this function.  */\n \n       for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-           tmpmode != VOIDmode;\n-           tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n-        {\n-          /* Have we found a large enough mode?  */\n-          if (GET_MODE_SIZE (tmpmode) >= bytes)\n-            break;\n-        }\n+\t   tmpmode != VOIDmode;\n+\t   tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n+\t{\n+\t  /* Have we found a large enough mode?  */\n+\t  if (GET_MODE_SIZE (tmpmode) >= bytes)\n+\t    break;\n+\t}\n \n       /* No suitable mode found.  */\n       if (tmpmode == VOIDmode)\n-        abort ();\n+\tabort ();\n \n       PUT_MODE (val, tmpmode);\n     }"}, {"sha": "7670f1ce7f431509d73d25c6e04fda2166c4f22e", "filename": "gcc/expmed.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -347,7 +347,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n       && (GET_CODE (op0) != MEM\n \t  ? ((GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n \t     || GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode))\n-            && byte_offset % GET_MODE_SIZE (fieldmode) == 0)\n+\t     && byte_offset % GET_MODE_SIZE (fieldmode) == 0)\n \t  : (! SLOW_UNALIGNED_ACCESS (fieldmode, MEM_ALIGN (op0))\n \t     || (offset * BITS_PER_UNIT % bitsize == 0\n \t\t && MEM_ALIGN (op0) % GET_MODE_BITSIZE (fieldmode) == 0))))\n@@ -675,7 +675,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n       if (pat)\n \temit_insn (pat);\n       else\n-        {\n+\t{\n \t  delete_insns_since (last);\n \t  store_fixed_bit_field (op0, offset, bitsize, bitpos, value);\n \t}\n@@ -737,8 +737,8 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value)\n \n       mode = GET_MODE (op0);\n       if (GET_MODE_BITSIZE (mode) == 0\n-          || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n-        mode = word_mode;\n+\t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n+\tmode = word_mode;\n       mode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n \t\t\t    MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n \n@@ -1109,8 +1109,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n                 + (offset * UNITS_PER_WORD);\n \n   mode1  = (VECTOR_MODE_P (tmode)\n-           ? mode\n-\t   : mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0));\n+\t    ? mode\n+\t    : mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0));\n \n   if (((GET_CODE (op0) != MEM\n \t&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n@@ -1928,9 +1928,9 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n   if (SHIFT_COUNT_TRUNCATED)\n     {\n       if (GET_CODE (op1) == CONST_INT\n-          && ((unsigned HOST_WIDE_INT) INTVAL (op1) >=\n+\t  && ((unsigned HOST_WIDE_INT) INTVAL (op1) >=\n \t      (unsigned HOST_WIDE_INT) GET_MODE_BITSIZE (mode)))\n-        op1 = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (op1)\n+\top1 = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (op1)\n \t\t       % GET_MODE_BITSIZE (mode));\n       else if (GET_CODE (op1) == SUBREG\n \t       && subreg_lowpart_p (op1))\n@@ -2566,8 +2566,8 @@ expand_mult (mode, op0, op1, target, unsignedp)\n      there is no difference between signed and unsigned.  */\n   op0 = expand_binop (mode,\n \t\t      ! unsignedp\n-                       && flag_trapv && (GET_MODE_CLASS(mode) == MODE_INT)\n-                       ? smulv_optab : smul_optab,\n+\t\t      && flag_trapv && (GET_MODE_CLASS(mode) == MODE_INT)\n+\t\t      ? smulv_optab : smul_optab,\n \t\t      op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);\n   if (op0 == 0)\n     abort ();\n@@ -3012,9 +3012,9 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (! unsignedp && op1 == constm1_rtx)\n     {\n       if (rem_flag)\n-        return const0_rtx;\n+\treturn const0_rtx;\n       return expand_unop (mode, flag_trapv && GET_MODE_CLASS(mode) == MODE_INT\n-                        ? negv_optab : neg_optab, op0, target, 0);\n+\t\t\t  ? negv_optab : neg_optab, op0, target, 0);\n     }\n \n   if (target"}, {"sha": "e633232c06ece690e489d40d2192581cf9c2e736", "filename": "gcc/expr.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -277,7 +277,7 @@ init_expr_once ()\n     {\n       enum machine_mode srcmode;\n       for (srcmode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); srcmode != mode;\n-           srcmode = GET_MODE_WIDER_MODE (srcmode))\n+\t   srcmode = GET_MODE_WIDER_MODE (srcmode))\n \t{\n \t  enum insn_code ic;\n \n@@ -286,7 +286,7 @@ init_expr_once ()\n \t    continue;\n \n \t  PUT_MODE (mem, srcmode);\n-\t  \n+\n \t  if ((*insn_data[ic].operand[1].predicate) (mem, srcmode))\n \t    float_extend_from_mem[mode][srcmode] = true;\n \t}\n@@ -3054,7 +3054,7 @@ emit_move_insn_1 (x, y)\n \t{\n \t  rtx temp;\n \t  enum rtx_code code;\n-\t  \n+\n \t  /* Do not use anti_adjust_stack, since we don't want to update\n \t     stack_pointer_delta.  */\n \t  temp = expand_binop (Pmode,\n@@ -3069,18 +3069,18 @@ emit_move_insn_1 (x, y)\n \t\t\t\t  (GET_MODE_SIZE (GET_MODE (x)))),\n \t\t\t       stack_pointer_rtx, 0, OPTAB_LIB_WIDEN);\n \n-          if (temp != stack_pointer_rtx)\n-            emit_move_insn (stack_pointer_rtx, temp);\n+\t  if (temp != stack_pointer_rtx)\n+\t    emit_move_insn (stack_pointer_rtx, temp);\n \n \t  code = GET_CODE (XEXP (x, 0));\n \n \t  /* Just hope that small offsets off SP are OK.  */\n \t  if (code == POST_INC)\n-\t    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, \n+\t    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t\tGEN_INT (-((HOST_WIDE_INT)\n \t\t\t\t\t   GET_MODE_SIZE (GET_MODE (x)))));\n \t  else if (code == POST_DEC)\n-\t    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, \n+\t    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t\tGEN_INT (GET_MODE_SIZE (GET_MODE (x))));\n \t  else\n \t    temp = stack_pointer_rtx;\n@@ -3357,7 +3357,7 @@ emit_single_push_insn (mode, x, type)\n void\n emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\targs_addr, args_so_far, reg_parm_stack_space,\n-                alignment_pad)\n+\t\talignment_pad)\n      rtx x;\n      enum machine_mode mode;\n      tree type;\n@@ -3384,7 +3384,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n      Default is below for small data on big-endian machines; else above.  */\n   enum direction where_pad = FUNCTION_ARG_PADDING (mode, type);\n \n-  /* Invert direction if stack is post-decrement. \n+  /* Invert direction if stack is post-decrement.\n      FIXME: why?  */\n   if (STACK_PUSH_CODE == POST_DEC)\n     if (where_pad != none)\n@@ -4174,7 +4174,7 @@ store_expr (exp, target, want_value)\n \t    {\n \t      temp = gen_lowpart_SUBREG (GET_MODE (target), temp);\n \t      SUBREG_PROMOTED_VAR_P (temp) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET (temp, \n+\t      SUBREG_PROMOTED_UNSIGNED_SET (temp,\n \t\tSUBREG_PROMOTED_UNSIGNED_P (target));\n \t    }\n \t  else\n@@ -6456,7 +6456,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  /* Get the signedness used for this variable.  Ensure we get the\n \t     same mode we got when the variable was declared.  */\n \t  if (GET_MODE (DECL_RTL (exp))\n-\t      != promote_mode (type, DECL_MODE (exp), &unsignedp, \n+\t      != promote_mode (type, DECL_MODE (exp), &unsignedp,\n \t\t\t       (TREE_CODE (exp) == RESULT_DECL ? 1 : 0)))\n \t    abort ();\n \n@@ -6773,9 +6773,9 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t&& (! MOVE_BY_PIECES_P\n \t\t\t    (tree_low_cst (TYPE_SIZE_UNIT (type), 1),\n \t\t\t     TYPE_ALIGN (type)))\n- \t\t\t&& ((TREE_CODE (type) == VECTOR_TYPE\n- \t\t\t     && !is_zeros_p (exp))\n- \t\t\t    || ! mostly_zeros_p (exp)))))\n+\t\t\t&& ((TREE_CODE (type) == VECTOR_TYPE\n+\t\t\t     && !is_zeros_p (exp))\n+\t\t\t    || ! mostly_zeros_p (exp)))))\n \t       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))\n \t{\n \t  rtx constructor = output_constant_def (exp, 1);\n@@ -6812,14 +6812,14 @@ expand_expr (exp, target, tmode, modifier)\n \ttree string = string_constant (exp1, &index);\n \n \t/* Try to optimize reads from const strings.  */\n- \tif (string\n- \t    && TREE_CODE (string) == STRING_CST\n- \t    && TREE_CODE (index) == INTEGER_CST\n+\tif (string\n+\t    && TREE_CODE (string) == STRING_CST\n+\t    && TREE_CODE (index) == INTEGER_CST\n \t    && compare_tree_int (index, TREE_STRING_LENGTH (string)) < 0\n- \t    && GET_MODE_CLASS (mode) == MODE_INT\n- \t    && GET_MODE_SIZE (mode) == 1\n+\t    && GET_MODE_CLASS (mode) == MODE_INT\n+\t    && GET_MODE_SIZE (mode) == 1\n \t    && modifier != EXPAND_WRITE)\n- \t  return gen_int_mode (TREE_STRING_POINTER (string)\n+\t  return gen_int_mode (TREE_STRING_POINTER (string)\n \t\t\t       [TREE_INT_CST_LOW (index)], mode);\n \n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n@@ -7428,7 +7428,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n \t      == FUNCTION_DECL)\n \t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n-        {\n+\t{\n \t  if (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n \t      == BUILT_IN_FRONTEND)\n \t    return (*lang_hooks.expand_expr)\n@@ -7511,7 +7511,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t  enum machine_mode inner_mode = TYPE_MODE (inner_type);\n \n-          if (modifier == EXPAND_INITIALIZER)\n+\t  if (modifier == EXPAND_INITIALIZER)\n \t    return simplify_gen_subreg (mode, op0, inner_mode,\n \t\t\t\t\tsubreg_lowpart_offset (mode,\n \t\t\t\t\t\t\t       inner_mode));\n@@ -7598,7 +7598,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t      op0 = new;\n \t    }\n-      \n+\n \t  op0 = adjust_address (op0, TYPE_MODE (type), 0);\n \t}\n \n@@ -7645,7 +7645,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t If this is an EXPAND_SUM call, always return the sum.  */\n       if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n-          || (mode == ptr_mode && (unsignedp || ! flag_trapv)))\n+\t  || (mode == ptr_mode && (unsignedp || ! flag_trapv)))\n \t{\n \t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n@@ -7994,9 +7994,9 @@ expand_expr (exp, target, tmode, modifier)\n     case NEGATE_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n       temp = expand_unop (mode,\n-                          ! unsignedp && flag_trapv\n-                          && (GET_MODE_CLASS(mode) == MODE_INT)\n-                          ? negv_optab : neg_optab, op0, target, 0);\n+\t\t\t  ! unsignedp && flag_trapv\n+\t\t\t  && (GET_MODE_CLASS(mode) == MODE_INT)\n+\t\t\t  ? negv_optab : neg_optab, op0, target, 0);\n       if (temp == 0)\n \tabort ();\n       return temp;\n@@ -8172,7 +8172,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      enum machine_mode mode1 = GET_MODE (temp);\n \t      if (mode1 == VOIDmode)\n \t\tmode1 = tmode != VOIDmode ? tmode : mode;\n-\t      \n+\n \t      temp = copy_to_mode_reg (mode1, temp);\n \t    }\n \n@@ -8352,13 +8352,13 @@ expand_expr (exp, target, tmode, modifier)\n \t  {\n \t    rtx result;\n \t    optab boptab = (TREE_CODE (binary_op) == PLUS_EXPR\n-                            ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n-                               ? addv_optab : add_optab)\n-                            : TREE_CODE (binary_op) == MINUS_EXPR\n-                              ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n-                                 ? subv_optab : sub_optab)\n-                            : TREE_CODE (binary_op) == BIT_IOR_EXPR ? ior_optab\n-                            : xor_optab);\n+\t\t\t    ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n+\t\t\t       ? addv_optab : add_optab)\n+\t\t\t    : TREE_CODE (binary_op) == MINUS_EXPR\n+\t\t\t    ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n+\t\t\t       ? subv_optab : sub_optab)\n+\t\t\t    : TREE_CODE (binary_op) == BIT_IOR_EXPR ? ior_optab\n+\t\t\t    : xor_optab);\n \n \t    /* If we had X ? A : A + 1, do this as A + (X == 0).\n \n@@ -8673,7 +8673,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \ttemp = expand_assignment (lhs, rhs, ! ignore, original_target != 0);\n-\t\n+\n \treturn temp;\n       }\n \n@@ -8762,11 +8762,11 @@ expand_expr (exp, target, tmode, modifier)\n \t\t    /* Handle calls that pass values in multiple\n \t\t       non-contiguous locations.  The Irix 6 ABI has examples\n \t\t       of this.  */\n-\t\t    emit_group_store (memloc, op0, \n+\t\t    emit_group_store (memloc, op0,\n \t\t\t\t      int_size_in_bytes (inner_type));\n \t\t  else\n \t\t    emit_move_insn (memloc, op0);\n-\t\t  \n+\n \t\t  op0 = memloc;\n \t\t}\n \t    }\n@@ -8904,9 +8904,9 @@ expand_expr (exp, target, tmode, modifier)\n \n \timag_t = gen_imagpart (partmode, target);\n \ttemp = expand_unop (partmode,\n-                            ! unsignedp && flag_trapv\n-                            && (GET_MODE_CLASS(partmode) == MODE_INT)\n-                            ? negv_optab : neg_optab,\n+\t\t\t    ! unsignedp && flag_trapv\n+\t\t\t    && (GET_MODE_CLASS(partmode) == MODE_INT)\n+\t\t\t    ? negv_optab : neg_optab,\n \t\t\t    gen_imagpart (partmode, op0), imag_t, 0);\n \tif (temp != imag_t)\n \t  emit_move_insn (imag_t, temp);\n@@ -9737,7 +9737,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t\t|| rcmp == UNORDERED))\n \t  do_rev = 1;\n \n-        if (! do_rev)\n+\tif (! do_rev)\n \t  do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label);\n \telse\n \t  do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label);\n@@ -9770,7 +9770,7 @@ do_jump (exp, if_false_label, if_true_label)\n \tgoto unordered_bcc;\n \n       unordered_bcc:\n-        mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\tmode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \tif (can_compare_p (rcode1, mode, ccp_jump))\n \t  do_compare_and_jump (exp, rcode1, rcode1, if_false_label,\n \t\t\t       if_true_label);\n@@ -9839,7 +9839,7 @@ do_jump (exp, if_false_label, if_true_label)\n       /* Do any postincrements in the expression that was tested.  */\n       emit_queue ();\n \n-      if (GET_CODE (temp) == CONST_INT \n+      if (GET_CODE (temp) == CONST_INT\n \t  || (GET_CODE (temp) == CONST_DOUBLE && GET_MODE (temp) == VOIDmode)\n \t  || GET_CODE (temp) == LABEL_REF)\n \t{"}, {"sha": "6b05218073385977b91af8e79820b8a8bd273c84", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aedacd5042be3ac70777f231a96d895d9aa5/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=0fb7aedacd5042be3ac70777f231a96d895d9aa5", "patch": "@@ -132,7 +132,7 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n /* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n    FUNCTION_ARG_PADDING, which also pads the length, handle any needed\n    alignment.  */\n-  \n+\n #ifndef FUNCTION_ARG_BOUNDARY\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n #endif\n@@ -289,7 +289,7 @@ extern rtx gen_move_insn PARAMS ((rtx, rtx));\n extern int have_add2_insn PARAMS ((rtx, rtx));\n extern int have_sub2_insn PARAMS ((rtx, rtx));\n \n-/* Emit a pair of rtl insns to compare two rtx's and to jump \n+/* Emit a pair of rtl insns to compare two rtx's and to jump\n    to a label if the comparison is true.  */\n extern void emit_cmp_and_jump_insns PARAMS ((rtx, rtx, enum rtx_code, rtx,\n \t\t\t\t\t     enum machine_mode, int, rtx));\n@@ -727,7 +727,7 @@ extern void emit_stack_restore PARAMS ((enum save_level, rtx, rtx));\n    says how many bytes.  */\n extern rtx allocate_dynamic_stack_space PARAMS ((rtx, rtx, int));\n \n-/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive. \n+/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n    FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n    current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n    subtract from the stack.  If SIZE is constant, this is done"}]}