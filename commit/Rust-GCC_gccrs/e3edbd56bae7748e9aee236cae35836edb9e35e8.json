{"sha": "e3edbd56bae7748e9aee236cae35836edb9e35e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNlZGJkNTZiYWU3NzQ4ZTlhZWUyMzZjYWUzNTgzNmVkYjllMzVlOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-04-02T08:44:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-02T08:44:43Z"}, "message": "gigi.h (get_dummy_type): Declare.\n\n\t* gcc-interface/gigi.h (get_dummy_type): Declare.\n\t(build_dummy_unc_pointer_types): Likewise.\n\t(finish_fat_pointer_type): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: If a dummy\n\tfat pointer type has been built, complete it in place.\n\t<E_Access_Type>: Call build_dummy_unc_pointer_types to build dummy fat\n\tand thin pointers.  Remove useless variable.\n\t(finish_fat_pointer_type): Make global and move to...\n\t* gcc-interface/utils.c (finish_fat_pointer_type): ...here.\n\t(get_dummy_type): New function.\n\t(build_dummy_unc_pointer_types): Likewise.\n\t(gnat_pushdecl): Propage the name to the anonymous variants only.\n\t(update_pointer_to): Only adjust the pointer types in the unconstrained\n\tarray case.\n\nFrom-SVN: r171882", "tree": {"sha": "3bd19211576bdf7f1b96652d584a9d5ccb0c08b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bd19211576bdf7f1b96652d584a9d5ccb0c08b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3edbd56bae7748e9aee236cae35836edb9e35e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3edbd56bae7748e9aee236cae35836edb9e35e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3edbd56bae7748e9aee236cae35836edb9e35e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3edbd56bae7748e9aee236cae35836edb9e35e8/comments", "author": null, "committer": null, "parents": [{"sha": "65444786bebc03fd4f639801aecc8a25047d33f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65444786bebc03fd4f639801aecc8a25047d33f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65444786bebc03fd4f639801aecc8a25047d33f8"}], "stats": {"total": 362, "additions": 188, "deletions": 174}, "files": [{"sha": "e76786dab17cf076cf4be06b10fd5b4aa76ae0d2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e3edbd56bae7748e9aee236cae35836edb9e35e8", "patch": "@@ -1,3 +1,20 @@\n+2011-04-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (get_dummy_type): Declare.\n+\t(build_dummy_unc_pointer_types): Likewise.\n+\t(finish_fat_pointer_type): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: If a dummy\n+\tfat pointer type has been built, complete it in place.\n+\t<E_Access_Type>: Call build_dummy_unc_pointer_types to build dummy fat\n+\tand thin pointers.  Remove useless variable.\n+\t(finish_fat_pointer_type): Make global and move to...\n+\t* gcc-interface/utils.c (finish_fat_pointer_type): ...here.\n+\t(get_dummy_type): New function.\n+\t(build_dummy_unc_pointer_types): Likewise.\n+\t(gnat_pushdecl): Propage the name to the anonymous variants only.\n+\t(update_pointer_to): Only adjust the pointer types in the unconstrained\n+\tarray case.\n+\n 2011-04-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (DECL_TAFT_TYPE_P): New flag."}, {"sha": "64d60b77bb1cce9f9e57038925060a9e442080b1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 69, "deletions": 101, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=e3edbd56bae7748e9aee236cae35836edb9e35e8", "patch": "@@ -182,7 +182,6 @@ static tree create_variant_part_from (tree, VEC(variant_desc,heap) *, tree,\n \t\t\t\t      tree, VEC(subst_pair,heap) *);\n static void copy_and_substitute_in_size (tree, tree, VEC(subst_pair,heap) *);\n static void rest_of_type_decl_compilation_no_defer (tree);\n-static void finish_fat_pointer_type (tree, tree);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n    to pass around calls performing profile compatibility checks.  */\n@@ -1912,22 +1911,32 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_String_Type:\n     case E_Array_Type:\n       {\n-\tEntity_Id gnat_index, gnat_name;\n \tconst bool convention_fortran_p\n \t  = (Convention (gnat_entity) == Convention_Fortran);\n \tconst int ndim = Number_Dimensions (gnat_entity);\n-\ttree gnu_template_fields = NULL_TREE;\n \ttree gnu_template_type = make_node (RECORD_TYPE);\n-\ttree gnu_template_reference;\n \ttree gnu_ptr_template = build_pointer_type (gnu_template_type);\n-\ttree gnu_fat_type = make_node (RECORD_TYPE);\n+\ttree gnu_template_reference, gnu_template_fields, gnu_fat_type;\n \ttree *gnu_index_types = XALLOCAVEC (tree, ndim);\n \ttree *gnu_temp_fields = XALLOCAVEC (tree, ndim);\n-\ttree gnu_max_size = size_one_node, gnu_max_size_unit, tem;\n+\ttree gnu_max_size = size_one_node, gnu_max_size_unit, tem, t;\n+\tEntity_Id gnat_index, gnat_name;\n \tint index;\n \n-\tTYPE_NAME (gnu_template_type)\n-\t  = create_concat_name (gnat_entity, \"XUB\");\n+\t/* We complete an existing dummy fat pointer type in place.  This both\n+\t   avoids further complex adjustments in update_pointer_to and yields\n+\t   better debugging information in DWARF by leveraging the support for\n+\t   incomplete declarations of \"tagged\" types in the DWARF back-end.  */\n+\tgnu_type = get_dummy_type (gnat_entity);\n+\tif (gnu_type && TYPE_POINTER_TO (gnu_type))\n+\t  {\n+\t    gnu_fat_type = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (gnu_type));\n+\t    TYPE_NAME (gnu_fat_type) = NULL_TREE;\n+\t    /* Save the contents of the dummy type for update_pointer_to.  */\n+\t    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);\n+\t  }\n+\telse\n+\t  gnu_fat_type = make_node (RECORD_TYPE);\n \n \t/* Make a node for the array.  If we are not defining the array\n \t   suppress expanding incomplete types.  */\n@@ -1945,10 +1954,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttem\n \t  = create_field_decl (get_identifier (\"P_ARRAY\"), ptr_void_type_node,\n \t\t\t       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n-\tTREE_CHAIN (tem)\n+\tDECL_CHAIN (tem)\n \t  = create_field_decl (get_identifier (\"P_BOUNDS\"), gnu_ptr_template,\n \t\t\t       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n-\tfinish_fat_pointer_type (gnu_fat_type, tem);\n+\n+\tif (COMPLETE_TYPE_P (gnu_fat_type))\n+\t  {\n+\t    /* We are going to lay it out again so reset the alias set.  */\n+\t    alias_set_type alias_set = TYPE_ALIAS_SET (gnu_fat_type);\n+\t    TYPE_ALIAS_SET (gnu_fat_type) = -1;\n+\t    finish_fat_pointer_type (gnu_fat_type, tem);\n+\t    TYPE_ALIAS_SET (gnu_fat_type) = alias_set;\n+\t    for (t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))\n+\t      {\n+\t\tTYPE_FIELDS (t) = tem;\n+\t\tSET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    finish_fat_pointer_type (gnu_fat_type, tem);\n+\t    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n+\t  }\n \n \t/* Build a reference to the template from a PLACEHOLDER_EXPR that\n \t   is the fat pointer.  This will be used to access the individual\n@@ -2053,19 +2080,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = create_concat_name (gnat_entity, field_name);\n \t  }\n \n+\t/* Install all the fields into the template.  */\n+\tTYPE_NAME (gnu_template_type)\n+\t  = create_concat_name (gnat_entity, \"XUB\");\n+\tgnu_template_fields = NULL_TREE;\n \tfor (index = 0; index < ndim; index++)\n \t  gnu_template_fields\n \t    = chainon (gnu_template_fields, gnu_temp_fields[index]);\n-\n-\t/* Install all the fields into the template.  */\n \tfinish_record_type (gnu_template_type, gnu_template_fields, 0,\n \t\t\t    debug_info_p);\n \tTYPE_READONLY (gnu_template_type) = 1;\n \n \t/* Now make the array of arrays and update the pointer to the array\n \t   in the fat pointer.  Note that it is the first field.  */\n-\ttem = gnat_to_gnu_component_type (gnat_entity, definition,\n-\t\t\t\t\t  debug_info_p);\n+\ttem\n+\t  = gnat_to_gnu_component_type (gnat_entity, definition, debug_info_p);\n \n \t/* If Component_Size is not already specified, annotate it with the\n \t   size of the component.  */\n@@ -2107,15 +2136,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \tTYPE_CONVENTION_FORTRAN_P (tem) = convention_fortran_p;\n+\n+\t/* Adjust the type of the pointer-to-array field of the fat pointer\n+\t   and record the aliasing relationships if necessary.  */\n \tTREE_TYPE (TYPE_FIELDS (gnu_fat_type)) = build_pointer_type (tem);\n+\tif (TYPE_ALIAS_SET_KNOWN_P (gnu_fat_type))\n+\t  record_component_aliases (gnu_fat_type);\n \n \t/* The result type is an UNCONSTRAINED_ARRAY_TYPE that indicates the\n \t   corresponding fat pointer.  */\n-\tTREE_TYPE (gnu_type) = TYPE_POINTER_TO (gnu_type)\n-\t  = TYPE_REFERENCE_TO (gnu_type) = gnu_fat_type;\n+\tTREE_TYPE (gnu_type) = gnu_fat_type;\n+\tTYPE_POINTER_TO (gnu_type) = gnu_fat_type;\n+\tTYPE_REFERENCE_TO (gnu_type) = gnu_fat_type;\n \tSET_TYPE_MODE (gnu_type, BLKmode);\n \tTYPE_ALIGN (gnu_type) = TYPE_ALIGN (tem);\n-\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n \n \t/* If the maximum size doesn't overflow, use it.  */\n \tif (gnu_max_size\n@@ -3301,8 +3335,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       _Parent field.  */\n \t\t    else if (gnat_name == Name_uController && gnu_last)\n \t\t      {\n-\t\t\tTREE_CHAIN (gnu_field) = TREE_CHAIN (gnu_last);\n-\t\t\tTREE_CHAIN (gnu_last) = gnu_field;\n+\t\t\tDECL_CHAIN (gnu_field) = DECL_CHAIN (gnu_last);\n+\t\t\tDECL_CHAIN (gnu_last) = gnu_field;\n \t\t      }\n \n \t\t    /* Otherwise, if this is a regular field, put it after\n@@ -3512,8 +3546,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     : In_Extended_Main_Code_Unit (gnat_desig_type));\n \t/* True if we make a dummy type here.  */\n \tbool made_dummy = false;\n-\t/* True if the dummy type is a fat pointer.  */\n-\tbool got_fat_p = false;\n \t/* The mode to be used for the pointer type.  */\n \tenum machine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n \t/* The GCC type used for the designated type.  */\n@@ -3547,11 +3579,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = Is_Array_Type (gnat_desig_rep) && !Is_Constrained (gnat_desig_rep);\n \n \t/* If we are pointing to an incomplete type whose completion is an\n-\t   unconstrained array, make a fat pointer type.  The two types in our\n-\t   fields will be pointers to dummy nodes and will be replaced in\n-\t   update_pointer_to.  Similarly, if the type itself is a dummy type or\n-\t   an unconstrained array.  Also make a dummy TYPE_OBJECT_RECORD_TYPE\n-\t   in case we have any thin pointers to it.  */\n+\t   unconstrained array, make dummy fat and thin pointer types to it.\n+\t   Likewise if the type itself is dummy or an unconstrained array.  */\n \tif (is_unconstrained_array\n \t    && (Present (gnat_desig_full)\n \t\t|| (present_gnu_tree (gnat_desig_equiv)\n@@ -3569,55 +3598,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    else\n \t      {\n \t\tgnu_desig_type = make_dummy_type (gnat_desig_rep);\n-\t\t/* Show the dummy we get will be a fat pointer.  */\n-\t\tgot_fat_p = made_dummy = true;\n+\t\tmade_dummy = true;\n \t      }\n \n \t    /* If the call above got something that has a pointer, the pointer\n \t       is our type.  This could have happened either because the type\n \t       was elaborated or because somebody else executed the code.  */\n+\t    if (!TYPE_POINTER_TO (gnu_desig_type))\n+\t      build_dummy_unc_pointer_types (gnat_desig_equiv, gnu_desig_type);\n \t    gnu_type = TYPE_POINTER_TO (gnu_desig_type);\n-\t    if (!gnu_type)\n-\t      {\n-\t\ttree gnu_template_type = make_node (RECORD_TYPE);\n-\t\ttree gnu_ptr_template = build_pointer_type (gnu_template_type);\n-\t\ttree gnu_array_type = make_node (ENUMERAL_TYPE);\n-\t\ttree gnu_ptr_array = build_pointer_type (gnu_array_type);\n-\t\ttree fields;\n-\n-\t\tTYPE_NAME (gnu_template_type)\n-\t\t  = create_concat_name (gnat_desig_equiv, \"XUB\");\n-\t\tTYPE_DUMMY_P (gnu_template_type) = 1;\n-\n-\t\tTYPE_NAME (gnu_array_type)\n-\t\t  = create_concat_name (gnat_desig_equiv, \"XUA\");\n-\t\tTYPE_DUMMY_P (gnu_array_type) = 1;\n-\n-\t\tgnu_type = make_node (RECORD_TYPE);\n-\t\t/* Build a stub DECL to trigger the special processing for fat\n-\t\t   pointer types in gnat_pushdecl.  */\n-\t\tTYPE_NAME (gnu_type)\n-\t\t  = create_type_stub_decl\n-\t\t    (create_concat_name (gnat_desig_equiv, \"XUP\"), gnu_type);\n-\t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_desig_type);\n-\t\tTYPE_POINTER_TO (gnu_desig_type) = gnu_type;\n-\n-\t\tfields\n-\t\t  = create_field_decl (get_identifier (\"P_ARRAY\"),\n-\t\t\t\t       gnu_ptr_array, gnu_type,\n-\t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n-\t\tDECL_CHAIN (fields)\n-\t\t  = create_field_decl (get_identifier (\"P_BOUNDS\"),\n-\t\t\t\t       gnu_ptr_template, gnu_type,\n-\t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n-\t\tfinish_fat_pointer_type (gnu_type, fields);\n-\n-\t\tTYPE_OBJECT_RECORD_TYPE (gnu_desig_type)\n-\t\t  = make_node (RECORD_TYPE);\n-\t\tTYPE_NAME (TYPE_OBJECT_RECORD_TYPE (gnu_desig_type))\n-\t\t  = create_concat_name (gnat_desig_equiv, \"XUT\");\n-\t\tTYPE_DUMMY_P (TYPE_OBJECT_RECORD_TYPE (gnu_desig_type)) = 1;\n-\t      }\n \t  }\n \n \t/* If we already know what the full type is, use it.  */\n@@ -3738,16 +3727,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   end of the current unit.  */\n \tif ((!in_main_unit || is_from_limited_with) && made_dummy)\n \t  {\n-\t    tree gnu_old_desig_type\n-\t      = TYPE_IS_FAT_POINTER_P (gnu_type)\n-\t\t? TYPE_UNCONSTRAINED_ARRAY (gnu_type) : TREE_TYPE (gnu_type);\n+\t    tree gnu_old_desig_type;\n \n-\t    if (esize == POINTER_SIZE\n-\t\t&& (got_fat_p || TYPE_IS_FAT_POINTER_P (gnu_type)))\n-\t      gnu_type\n-\t\t= build_pointer_type\n-\t\t  (TYPE_OBJECT_RECORD_TYPE\n-\t\t   (TYPE_UNCONSTRAINED_ARRAY (gnu_type)));\n+\t    if (TYPE_IS_FAT_POINTER_P (gnu_type))\n+\t      {\n+\t\tgnu_old_desig_type = TYPE_UNCONSTRAINED_ARRAY (gnu_type);\n+\t\tif (esize == POINTER_SIZE)\n+\t\t  gnu_type = build_pointer_type\n+\t\t\t     (TYPE_OBJECT_RECORD_TYPE (gnu_old_desig_type));\n+\t      }\n+\t    else\n+\t      gnu_old_desig_type = TREE_TYPE (gnu_type);\n \n \t    gnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n \t\t\t\t\t !Comes_From_Source (gnat_entity),\n@@ -3905,7 +3895,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tEntity_Id gnat_return_type = Etype (gnat_entity);\n \ttree gnu_return_type;\n \t/* The first GCC parameter declaration (a PARM_DECL node).  The\n-\t   PARM_DECL nodes are chained through the TREE_CHAIN field, so this\n+\t   PARM_DECL nodes are chained through the DECL_CHAIN field, so this\n \t   actually is the head of this parameter list.  */\n \ttree gnu_param_list = NULL_TREE;\n \t/* Likewise for the stub associated with an exported procedure.  */\n@@ -5142,28 +5132,6 @@ rest_of_type_decl_compilation_no_defer (tree decl)\n     }\n }\n \n-/* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n-   finish constructing the record type as a fat pointer type.  */\n-\n-static void\n-finish_fat_pointer_type (tree record_type, tree field_list)\n-{\n-  /* Make sure we can put it into a register.  */\n-  TYPE_ALIGN (record_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n-\n-  /* Show what it really is.  */\n-  TYPE_FAT_POINTER_P (record_type) = 1;\n-\n-  /* Do not emit debug info for it since the types of its fields may still be\n-     incomplete at this point.  */\n-  finish_record_type (record_type, field_list, 0, false);\n-\n-  /* Force type_contains_placeholder_p to return true on it.  Although the\n-     PLACEHOLDER_EXPRs are referenced only indirectly, this isn't a pointer\n-     type but the representation of the unconstrained array.  */\n-  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (record_type) = 2;\n-}\n-\n /* Finalize the processing of From_With_Type incomplete types.  */\n \n void"}, {"sha": "c5cd5770ed3e9193b3da659086b7b1390e0a5ae3", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=e3edbd56bae7748e9aee236cae35836edb9e35e8", "patch": "@@ -504,11 +504,23 @@ extern void init_dummy_type (void);\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n extern tree make_dummy_type (Entity_Id gnat_type);\n \n+/* Return the dummy type that was made for GNAT_TYPE, if any.  */\n+extern tree get_dummy_type (Entity_Id gnat_type);\n+\n+/* Build dummy fat and thin pointer types whose designated type is specified\n+   by GNAT_DESIG_TYPE/GNU_DESIG_TYPE and attach them to the latter.  */\n+extern void build_dummy_unc_pointer_types (Entity_Id gnat_desig_type,\n+\t\t\t\t\t   tree gnu_desig_type);\n+\n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.\n    ARTIFICIAL_P is true if it's a type that was generated by the compiler.  */\n extern void record_builtin_type (const char *name, tree type,\n \t\t\t\t bool artificial_p);\n \n+/* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n+   finish constructing the record type as a fat pointer type.  */\n+extern void finish_fat_pointer_type (tree record_type, tree field_list);\n+\n /* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n    finish constructing the record or union type.  If REP_LEVEL is zero, this\n    record has no representation clause and so will be entirely laid out here."}, {"sha": "6472a0cda177da002d284ddde62b0ff1a0924207", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 90, "deletions": 73, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3edbd56bae7748e9aee236cae35836edb9e35e8/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e3edbd56bae7748e9aee236cae35836edb9e35e8", "patch": "@@ -313,6 +313,57 @@ make_dummy_type (Entity_Id gnat_type)\n \n   return gnu_type;\n }\n+\n+/* Return the dummy type that was made for GNAT_TYPE, if any.  */\n+\n+tree\n+get_dummy_type (Entity_Id gnat_type)\n+{\n+  return GET_DUMMY_NODE (gnat_type);\n+}\n+\n+/* Build dummy fat and thin pointer types whose designated type is specified\n+   by GNAT_DESIG_TYPE/GNU_DESIG_TYPE and attach them to the latter.  */\n+\n+void\n+build_dummy_unc_pointer_types (Entity_Id gnat_desig_type, tree gnu_desig_type)\n+{\n+  tree gnu_template_type, gnu_ptr_template, gnu_array_type, gnu_ptr_array;\n+  tree gnu_fat_type, fields, gnu_object_type;\n+\n+  gnu_template_type = make_node (RECORD_TYPE);\n+  TYPE_NAME (gnu_template_type) = create_concat_name (gnat_desig_type, \"XUB\");\n+  TYPE_DUMMY_P (gnu_template_type) = 1;\n+  gnu_ptr_template = build_pointer_type (gnu_template_type);\n+\n+  gnu_array_type = make_node (ENUMERAL_TYPE);\n+  TYPE_NAME (gnu_array_type) = create_concat_name (gnat_desig_type, \"XUA\");\n+  TYPE_DUMMY_P (gnu_array_type) = 1;\n+  gnu_ptr_array = build_pointer_type (gnu_array_type);\n+\n+  gnu_fat_type = make_node (RECORD_TYPE);\n+  /* Build a stub DECL to trigger the special processing for fat pointer types\n+     in gnat_pushdecl.  */\n+  TYPE_NAME (gnu_fat_type)\n+    = create_type_stub_decl (create_concat_name (gnat_desig_type, \"XUP\"),\n+\t\t\t     gnu_fat_type);\n+  fields = create_field_decl (get_identifier (\"P_ARRAY\"), gnu_ptr_array,\n+\t\t\t      gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n+  DECL_CHAIN (fields)\n+    = create_field_decl (get_identifier (\"P_BOUNDS\"), gnu_ptr_template,\n+\t\t\t gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n+  finish_fat_pointer_type (gnu_fat_type, fields);\n+  SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_desig_type);\n+  /* Suppress debug info until after the type is completed.  */\n+  TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (gnu_fat_type)) = 1;\n+\n+  gnu_object_type = make_node (RECORD_TYPE);\n+  TYPE_NAME (gnu_object_type) = create_concat_name (gnat_desig_type, \"XUT\");\n+  TYPE_DUMMY_P (gnu_object_type) = 1;\n+\n+  TYPE_POINTER_TO (gnu_desig_type) = gnu_fat_type;\n+  TYPE_OBJECT_RECORD_TYPE (gnu_desig_type) = gnu_object_type;\n+}\n \f\n /* Return nonzero if we are currently in the global binding level.  */\n \n@@ -522,6 +573,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t}\n       else if (TYPE_IS_FAT_POINTER_P (t))\n \t{\n+\t  /* We need a variant for the placeholder machinery to work.  */\n \t  tree tt = build_variant_type_copy (t);\n \t  TYPE_NAME (tt) = decl;\n \t  TREE_USED (tt) = TREE_USED (t);\n@@ -530,19 +582,20 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t    DECL_ORIGINAL_TYPE (decl) = DECL_ORIGINAL_TYPE (TYPE_NAME (t));\n \t  else\n \t    DECL_ORIGINAL_TYPE (decl) = t;\n-\t  t = NULL_TREE;\n \t  DECL_ARTIFICIAL (decl) = 0;\n+\t  t = NULL_TREE;\n \t}\n       else if (DECL_ARTIFICIAL (TYPE_NAME (t)) && !DECL_ARTIFICIAL (decl))\n \t;\n       else\n \tt = NULL_TREE;\n \n-      /* Propagate the name to all the variants.  This is needed for\n-\t the type qualifiers machinery to work properly.  */\n+      /* Propagate the name to all the anonymous variants.  This is needed\n+\t for the type qualifiers machinery to work properly.  */\n       if (t)\n \tfor (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n-\t  TYPE_NAME (t) = decl;\n+\t  if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n+\t    TYPE_NAME (t) = decl;\n     }\n }\n \f\n@@ -561,6 +614,28 @@ record_builtin_type (const char *name, tree type, bool artificial_p)\n     debug_hooks->type_decl (type_decl, false);\n }\n \f\n+/* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n+   finish constructing the record type as a fat pointer type.  */\n+\n+void\n+finish_fat_pointer_type (tree record_type, tree field_list)\n+{\n+  /* Make sure we can put it into a register.  */\n+  TYPE_ALIGN (record_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n+\n+  /* Show what it really is.  */\n+  TYPE_FAT_POINTER_P (record_type) = 1;\n+\n+  /* Do not emit debug info for it since the types of its fields may still be\n+     incomplete at this point.  */\n+  finish_record_type (record_type, field_list, 0, false);\n+\n+  /* Force type_contains_placeholder_p to return true on it.  Although the\n+     PLACEHOLDER_EXPRs are referenced only indirectly, this isn't a pointer\n+     type but the representation of the unconstrained array.  */\n+  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (record_type) = 2;\n+}\n+\n /* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n    finish constructing the record or union type.  If REP_LEVEL is zero, this\n    record has no representation clause and so will be entirely laid out here.\n@@ -3502,90 +3577,32 @@ update_pointer_to (tree old_type, tree new_type)\n \n   /* Now deal with the unconstrained array case.  In this case the pointer\n      is actually a record where both fields are pointers to dummy nodes.\n-     Turn them into pointers to the correct types using update_pointer_to.  */\n+     Turn them into pointers to the correct types using update_pointer_to.\n+     Likewise for the pointer to the object record (thin pointer).  */\n   else\n     {\n-      tree new_ptr = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (new_type));\n-      tree new_obj_rec = TYPE_OBJECT_RECORD_TYPE (new_type);\n-      tree array_field, bounds_field, new_ref, last = NULL_TREE;\n+      tree new_ptr = TYPE_POINTER_TO (new_type);\n \n       gcc_assert (TYPE_IS_FAT_POINTER_P (ptr));\n \n-      /* If PTR already points to new type, nothing to do.  This can happen\n+      /* If PTR already points to NEW_TYPE, nothing to do.  This can happen\n \t since update_pointer_to can be invoked multiple times on the same\n \t couple of types because of the type variants.  */\n       if (TYPE_UNCONSTRAINED_ARRAY (ptr) == new_type)\n \treturn;\n \n-      array_field = TYPE_FIELDS (ptr);\n-      bounds_field = DECL_CHAIN (array_field);\n-\n-      /* Make pointers to the dummy template point to the real template.  */\n       update_pointer_to\n-\t(TREE_TYPE (TREE_TYPE (bounds_field)),\n-\t TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (new_ptr)))));\n-\n-      /* The references to the template bounds present in the array type use\n-\t the bounds field of NEW_PTR through a PLACEHOLDER_EXPR.  Since we\n-\t are going to merge PTR in NEW_PTR, we must rework these references\n-\t to use the bounds field of PTR instead.  */\n-      new_ref = build3 (COMPONENT_REF, TREE_TYPE (bounds_field),\n-\t\t\tbuild0 (PLACEHOLDER_EXPR, new_ptr),\n-\t\t\tbounds_field, NULL_TREE);\n+\t(TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))),\n+\t TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))));\n \n-      /* Create the new array for the new PLACEHOLDER_EXPR and make pointers\n-\t to the dummy array point to it.  */\n       update_pointer_to\n-\t(TREE_TYPE (TREE_TYPE (array_field)),\n-\t substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))),\n-\t\t\t     DECL_CHAIN (TYPE_FIELDS (new_ptr)), new_ref));\n-\n-      /* Merge PTR in NEW_PTR.  */\n-      DECL_FIELD_CONTEXT (array_field) = new_ptr;\n-      DECL_FIELD_CONTEXT (bounds_field) = new_ptr;\n-      for (t = new_ptr; t; last = t, t = TYPE_NEXT_VARIANT (t))\n-\tTYPE_FIELDS (t) = TYPE_FIELDS (ptr);\n-      TYPE_ALIAS_SET (new_ptr) = TYPE_ALIAS_SET (ptr);\n-\n-      /* Chain PTR and its variants at the end.  */\n-      TYPE_NEXT_VARIANT (last) = TYPE_MAIN_VARIANT (ptr);\n+\t(TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (ptr)))),\n+\t TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (new_ptr)))));\n \n-      /* Now adjust them.  */\n-      for (t = TYPE_MAIN_VARIANT (ptr); t; t = TYPE_NEXT_VARIANT (t))\n-\t{\n-\t  TYPE_MAIN_VARIANT (t) = new_ptr;\n-\t  SET_TYPE_UNCONSTRAINED_ARRAY (t, new_type);\n-\n-\t  /* And show the original pointer NEW_PTR to the debugger.  This is\n-\t     the counterpart of the special processing for fat pointer types\n-\t     in gnat_pushdecl, but when the unconstrained array type is only\n-\t     frozen after access types to it.  */\n-\t  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n-\t    {\n-\t      DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = new_ptr;\n-\t      DECL_ARTIFICIAL (TYPE_NAME (t)) = 0;\n-\t    }\n-\t}\n+      update_pointer_to (TYPE_OBJECT_RECORD_TYPE (old_type),\n+\t\t\t TYPE_OBJECT_RECORD_TYPE (new_type));\n \n-      /* Now handle updating the allocation record, what the thin pointer\n-\t points to.  Update all pointers from the old record into the new\n-\t one, update the type of the array field, and recompute the size.  */\n-      update_pointer_to (TYPE_OBJECT_RECORD_TYPE (old_type), new_obj_rec);\n-      TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TREE_TYPE (TREE_TYPE (array_field));\n-\n-      /* The size recomputation needs to account for alignment constraints, so\n-\t we let layout_type work it out.  This will reset the field offsets to\n-\t what they would be in a regular record, so we shift them back to what\n-\t we want them to be for a thin pointer designated type afterwards.  */\n-      DECL_SIZE (TYPE_FIELDS (new_obj_rec)) = NULL_TREE;\n-      DECL_SIZE (DECL_CHAIN (TYPE_FIELDS (new_obj_rec))) = NULL_TREE;\n-      TYPE_SIZE (new_obj_rec) = NULL_TREE;\n-      layout_type (new_obj_rec);\n-      shift_unc_components_for_thin_pointers (new_obj_rec);\n-\n-      /* We are done, at last.  */\n-      rest_of_record_type_compilation (ptr);\n+      TYPE_POINTER_TO (old_type) = NULL_TREE;\n     }\n }\n \f"}]}