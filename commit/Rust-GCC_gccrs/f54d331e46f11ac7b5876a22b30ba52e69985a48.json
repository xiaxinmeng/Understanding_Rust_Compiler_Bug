{"sha": "f54d331e46f11ac7b5876a22b30ba52e69985a48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0ZDMzMWU0NmYxMWFjN2I1ODc2YTIyYjMwYmE1MmU2OTk4NWE0OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-15T04:10:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-15T04:10:08Z"}, "message": "Use the backend interface for select statements.\n\nFrom-SVN: r172468", "tree": {"sha": "7b20c37532b2390ef74bb6aab95ec57585f0de03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b20c37532b2390ef74bb6aab95ec57585f0de03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f54d331e46f11ac7b5876a22b30ba52e69985a48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54d331e46f11ac7b5876a22b30ba52e69985a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54d331e46f11ac7b5876a22b30ba52e69985a48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54d331e46f11ac7b5876a22b30ba52e69985a48/comments", "author": null, "committer": null, "parents": [{"sha": "7427a3680f389ece268c056e8bf7b0791f411941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7427a3680f389ece268c056e8bf7b0791f411941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7427a3680f389ece268c056e8bf7b0791f411941"}], "stats": {"total": 348, "additions": 209, "deletions": 139}, "files": [{"sha": "0b4c721130fff4b600e31887d3d0e998d87161c6", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -1,3 +1,7 @@\n+2011-04-14  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Backend::error_statement): New function.\n+\n 2011-04-13  Ian Lance Taylor  <iant@google.com>\n \n \t* Make-lang.in (go/gogo-tree.o): depend on $(GO_RUNTIME_H)."}, {"sha": "acdbfd0153c463e5ebf5216280c5568045897852", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -166,6 +166,10 @@ class Gcc_backend : public Backend\n \n   // Statements.\n \n+  Bstatement*\n+  error_statement()\n+  { return this->make_statement(error_mark_node); }\n+\n   Bstatement*\n   expression_statement(Bexpression*);\n "}, {"sha": "516ace9375967aba5d2ea2e1a2d01c5f6d9ebf20", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -107,6 +107,12 @@ class Backend\n \n   // Statements.\n \n+  // Create an error statement.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bstatement*\n+  error_statement() = 0;\n+\n   // Create an expression statement.\n   virtual Bstatement*\n   expression_statement(Bexpression*) = 0;"}, {"sha": "6e1461852a93c5921f79b53d7513c693484bbac9", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -3603,10 +3603,11 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n   else if (t->channel_type() != NULL)\n     gcc_assert(et->channel_type() != NULL);\n   else if (t->points_to() != NULL && t->points_to()->channel_type() != NULL)\n-    gcc_assert(et->points_to() != NULL\n-\t       && et->points_to()->channel_type() != NULL);\n+    gcc_assert((et->points_to() != NULL\n+\t\t&& et->points_to()->channel_type() != NULL)\n+\t       || et->is_nil_type());\n   else if (t->is_unsafe_pointer_type())\n-    gcc_assert(et->points_to() != NULL);\n+    gcc_assert(et->points_to() != NULL || et->is_nil_type());\n   else if (et->is_unsafe_pointer_type())\n     gcc_assert(t->points_to() != NULL);\n   else if (t->interface_type() != NULL && !t->interface_type()->is_empty())"}, {"sha": "b10a1b63c7a092c5c7921bc3fe4bda280260bcf4", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -381,3 +381,12 @@ Runtime::map_iteration_type()\n \n   return Type::make_array_type(runtime_function_type(RFT_POINTER), iexpr);\n }\n+\n+// Return the type used to pass a list of general channels to the\n+// select runtime function.\n+\n+Type*\n+Runtime::chanptr_type()\n+{\n+  return runtime_function_type(RFT_CHANPTR);\n+}"}, {"sha": "f7c878e73b9a1c61aa2fc41f75da318e87286582", "filename": "gcc/go/gofrontend/runtime.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.h?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -30,15 +30,24 @@ class Runtime\n     NUMBER_OF_FUNCTIONS\n   };\n \n+  // Make a call to a runtime function.\n   static Call_expression*\n   make_call(Function, source_location, int, ...);\n \n+  // Convert all the types used by runtime functions to the backend\n+  // representation.\n   static void\n   convert_types(Gogo*);\n \n+  // Return the type used for iterations over maps.\n   static Type*\n   map_iteration_type();\n \n+  // Return the type used to pass a list of general channels to the\n+  // select runtime function.\n+  static Type*\n+  chanptr_type();\n+\n  private:\n   static Named_object*\n   runtime_declaration(Function);"}, {"sha": "0774b83af93e523279aaa250fcdf3369489a0561", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 164, "deletions": 129, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -3974,12 +3974,13 @@ Select_clauses::Select_clause::may_fall_through() const\n \n // Return a tree for the statements to execute.\n \n-tree\n-Select_clauses::Select_clause::get_statements_tree(Translate_context* context)\n+Bstatement*\n+Select_clauses::Select_clause::get_statements_backend(\n+    Translate_context* context)\n {\n   if (this->statements_ == NULL)\n-    return NULL_TREE;\n-  return this->statements_->get_tree(context);\n+    return NULL;\n+  return tree_to_stat(this->statements_->get_tree(context));\n }\n \n // Class Select_clauses.\n@@ -4037,7 +4038,7 @@ Select_clauses::may_fall_through() const\n   return false;\n }\n \n-// Return a tree.  We build a call to\n+// Convert to the backend representation.  We build a call to\n //   size_t __go_select(size_t count, _Bool has_default,\n //                      channel* channels, _Bool* is_send)\n //\n@@ -4051,20 +4052,24 @@ Select_clauses::may_fall_through() const\n // FIXME: This doesn't handle channels which send interface types\n // where the receiver has a static type which matches that interface.\n \n-tree\n-Select_clauses::get_tree(Translate_context* context,\n-\t\t\t Unnamed_label *break_label,\n-\t\t\t source_location location)\n+Bstatement*\n+Select_clauses::get_backend(Translate_context* context,\n+\t\t\t    Unnamed_label *break_label,\n+\t\t\t    source_location location)\n {\n   size_t count = this->clauses_.size();\n-  VEC(constructor_elt, gc)* chan_init = VEC_alloc(constructor_elt, gc, count);\n-  VEC(constructor_elt, gc)* is_send_init = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t\t     count);\n-  Select_clause* default_clause = NULL;\n-  tree final_stmt_list = NULL_TREE;\n-  tree channel_type_tree = NULL_TREE;\n \n-  size_t i = 0;\n+  Expression_list* chan_init = new Expression_list();\n+  chan_init->reserve(count);\n+\n+  Expression_list* is_send_init = new Expression_list();\n+  is_send_init->reserve(count);\n+\n+  Select_clause *default_clause = NULL;\n+\n+  Type* runtime_chanptr_type = Runtime::chanptr_type();\n+  Type* runtime_chan_type = runtime_chanptr_type->points_to();\n+\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n        ++p)\n@@ -4081,153 +4086,182 @@ Select_clauses::get_tree(Translate_context* context,\n \t  // We should have given an error in the send or receive\n \t  // statement we created via lowering.\n \t  gcc_assert(saw_errors());\n-\t  return error_mark_node;\n+\t  return context->backend()->error_statement();\n \t}\n \n-      tree channel_tree = p->channel()->get_tree(context);\n-      if (channel_tree == error_mark_node)\n-\treturn error_mark_node;\n-      channel_type_tree = TREE_TYPE(channel_tree);\n-\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, chan_init, NULL);\n-      elt->index = build_int_cstu(sizetype, i);\n-      elt->value = channel_tree;\n-\n-      elt = VEC_quick_push(constructor_elt, is_send_init, NULL);\n-      elt->index = build_int_cstu(sizetype, i);\n-      elt->value = p->is_send() ? boolean_true_node : boolean_false_node;\n+      Expression* c = p->channel();\n+      c = Expression::make_unsafe_cast(runtime_chan_type, c, p->location());\n+      chan_init->push_back(c);\n \n-      ++i;\n+      is_send_init->push_back(Expression::make_boolean(p->is_send(),\n+\t\t\t\t\t\t       p->location()));\n     }\n-  gcc_assert(i == count);\n \n-  if (i == 0 && default_clause != NULL)\n+  if (chan_init->empty())\n     {\n-      // There is only a default clause.\n-      gcc_assert(final_stmt_list == NULL_TREE);\n-      tree stmt_list = NULL_TREE;\n-      append_to_statement_list(default_clause->get_statements_tree(context),\n-\t\t\t       &stmt_list);\n+      gcc_assert(count == 0);\n+      Bstatement* s;\n       Bstatement* ldef = break_label->get_definition(context);\n-      append_to_statement_list(stat_to_tree(ldef), &stmt_list);\n-      return stmt_list;\n+      if (default_clause != NULL)\n+\t{\n+\t  // There is a default clause and no cases.  Just execute the\n+\t  // default clause.\n+\t  s = default_clause->get_statements_backend(context);\n+\t}\n+      else\n+\t{\n+\t  // There isn't even a default clause.  In this case select\n+\t  // pauses forever.  Call the runtime function with nils.\n+\t  mpz_t zval;\n+\t  mpz_init_set_ui(zval, 0);\n+\t  Expression* zero = Expression::make_integer(&zval, NULL, location);\n+\t  mpz_clear(zval);\n+\t  Expression* default_arg = Expression::make_boolean(false, location);\n+\t  Expression* nil1 = Expression::make_nil(location);\n+\t  Expression* nil2 = nil1->copy();\n+\t  Expression* call = Runtime::make_call(Runtime::SELECT, location, 4,\n+\t\t\t\t\t\tzero, default_arg, nil1, nil2);\n+\t  context->gogo()->lower_expression(context->function(), &call);\n+\t  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n+\t  s = context->backend()->expression_statement(bcall);\n+\t}\n+      if (s == NULL)\n+\treturn ldef;\n+      std::vector<Bstatement*> stats(2);\n+      stats[0] = s;\n+      stats[1] = ldef;\n+      return context->backend()->statement_list(stats);\n     }\n+  gcc_assert(count > 0);\n \n-  tree pointer_chan_type_tree = (channel_type_tree == NULL_TREE\n-\t\t\t\t ? ptr_type_node\n-\t\t\t\t : build_pointer_type(channel_type_tree));\n-  tree chans_arg;\n-  tree pointer_boolean_type_tree = build_pointer_type(boolean_type_node);\n-  tree is_sends_arg;\n+  std::vector<Bstatement*> statements;\n \n-  if (i == 0)\n-    {\n-      chans_arg = fold_convert_loc(location, pointer_chan_type_tree,\n-\t\t\t\t   null_pointer_node);\n-      is_sends_arg = fold_convert_loc(location, pointer_boolean_type_tree,\n-\t\t\t\t      null_pointer_node);\n-    }\n-  else\n-    {\n-      tree index_type_tree = build_index_type(size_int(count - 1));\n-      tree chan_array_type_tree = build_array_type(channel_type_tree,\n-\t\t\t\t\t\t   index_type_tree);\n-      tree chan_constructor = build_constructor(chan_array_type_tree,\n-\t\t\t\t\t\tchan_init);\n-      tree chan_var = create_tmp_var(chan_array_type_tree, \"CHAN\");\n-      DECL_IGNORED_P(chan_var) = 0;\n-      DECL_INITIAL(chan_var) = chan_constructor;\n-      DECL_SOURCE_LOCATION(chan_var) = location;\n-      TREE_ADDRESSABLE(chan_var) = 1;\n-      tree decl_expr = build1(DECL_EXPR, void_type_node, chan_var);\n-      SET_EXPR_LOCATION(decl_expr, location);\n-      append_to_statement_list(decl_expr, &final_stmt_list);\n-\n-      tree is_send_array_type_tree = build_array_type(boolean_type_node,\n-\t\t\t\t\t\t      index_type_tree);\n-      tree is_send_constructor = build_constructor(is_send_array_type_tree,\n-\t\t\t\t\t\t   is_send_init);\n-      tree is_send_var = create_tmp_var(is_send_array_type_tree, \"ISSEND\");\n-      DECL_IGNORED_P(is_send_var) = 0;\n-      DECL_INITIAL(is_send_var) = is_send_constructor;\n-      DECL_SOURCE_LOCATION(is_send_var) = location;\n-      TREE_ADDRESSABLE(is_send_var) = 1;\n-      decl_expr = build1(DECL_EXPR, void_type_node, is_send_var);\n-      SET_EXPR_LOCATION(decl_expr, location);\n-      append_to_statement_list(decl_expr, &final_stmt_list);\n-\n-      chans_arg = fold_convert_loc(location, pointer_chan_type_tree,\n-\t\t\t\t   build_fold_addr_expr_loc(location,\n-\t\t\t\t\t\t\t    chan_var));\n-      is_sends_arg = fold_convert_loc(location, pointer_boolean_type_tree,\n-\t\t\t\t      build_fold_addr_expr_loc(location,\n-\t\t\t\t\t\t\t       is_send_var));\n-    }\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, count);\n+  Expression* ecount = Expression::make_integer(&ival, NULL, location);\n+  mpz_clear(ival);\n \n-  static tree select_fndecl;\n-  tree call = Gogo::call_builtin(&select_fndecl,\n-\t\t\t\t location,\n-\t\t\t\t \"__go_select\",\n-\t\t\t\t 4,\n-\t\t\t\t sizetype,\n-\t\t\t\t sizetype,\n-\t\t\t\t size_int(count),\n-\t\t\t\t boolean_type_node,\n-\t\t\t\t (default_clause == NULL\n-\t\t\t\t  ? boolean_false_node\n-\t\t\t\t  : boolean_true_node),\n-\t\t\t\t pointer_chan_type_tree,\n-\t\t\t\t chans_arg,\n-\t\t\t\t pointer_boolean_type_tree,\n-\t\t\t\t is_sends_arg);\n-  if (call == error_mark_node)\n-    return error_mark_node;\n+  Type* chan_array_type = Type::make_array_type(runtime_chan_type, ecount);\n+  Expression* chans = Expression::make_composite_literal(chan_array_type, 0,\n+\t\t\t\t\t\t\t false, chan_init,\n+\t\t\t\t\t\t\t location);\n+  context->gogo()->lower_expression(context->function(), &chans);\n+  Temporary_statement* chan_temp = Statement::make_temporary(chan_array_type,\n+\t\t\t\t\t\t\t     chans,\n+\t\t\t\t\t\t\t     location);\n+  statements.push_back(tree_to_stat(chan_temp->get_tree(context)));\n+\n+  Type* is_send_array_type = Type::make_array_type(Type::lookup_bool_type(),\n+\t\t\t\t\t\t   ecount->copy());\n+  Expression* is_sends = Expression::make_composite_literal(is_send_array_type,\n+\t\t\t\t\t\t\t    0, false,\n+\t\t\t\t\t\t\t    is_send_init,\n+\t\t\t\t\t\t\t    location);\n+  context->gogo()->lower_expression(context->function(), &is_sends);\n+  Temporary_statement* is_send_temp =\n+    Statement::make_temporary(is_send_array_type, is_sends, location);\n+  statements.push_back(tree_to_stat(is_send_temp->get_tree(context)));\n+\n+  mpz_init_set_ui(ival, 0);\n+  Expression* zero = Expression::make_integer(&ival, NULL, location);\n+  mpz_clear(ival);\n+\n+  Expression* ref = Expression::make_temporary_reference(chan_temp, location);\n+  Expression* chan_arg = Expression::make_array_index(ref, zero, NULL,\n+\t\t\t\t\t\t      location);\n+  chan_arg = Expression::make_unary(OPERATOR_AND, chan_arg, location);\n+  chan_arg = Expression::make_unsafe_cast(runtime_chanptr_type, chan_arg,\n+\t\t\t\t\t  location);\n+\n+  ref = Expression::make_temporary_reference(is_send_temp, location);\n+  Expression* is_send_arg = Expression::make_array_index(ref, zero->copy(),\n+\t\t\t\t\t\t\t NULL, location);\n+  is_send_arg = Expression::make_unary(OPERATOR_AND, is_send_arg, location);\n+\n+  Expression* default_arg = Expression::make_boolean(default_clause != NULL,\n+\t\t\t\t\t\t     location);\n+  Expression* call = Runtime::make_call(Runtime::SELECT, location, 4,\n+\t\t\t\t\tecount->copy(), default_arg,\n+\t\t\t\t\tchan_arg, is_send_arg);\n+  context->gogo()->lower_expression(context->function(), &call);\n+  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n \n-  tree stmt_list = NULL_TREE;\n+  std::vector<std::vector<Bexpression*> > cases;\n+  std::vector<Bstatement*> clauses;\n+\n+  cases.resize(count + (default_clause != NULL ? 1 : 0));\n+  clauses.resize(count + (default_clause != NULL ? 1 : 0));\n+\n+  int index = 0;\n \n   if (default_clause != NULL)\n-    this->add_clause_tree(context, 0, default_clause, break_label, &stmt_list);\n+    {\n+      this->add_clause_backend(context, location, index, 0, default_clause,\n+\t\t\t       break_label, &cases, &clauses);\n+      ++index;\n+    }\n \n-  i = 1;\n+  int i = 1;\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n        ++p)\n     {\n       if (!p->is_default())\n \t{\n-\t  this->add_clause_tree(context, i, &*p, break_label, &stmt_list);\n+\t  this->add_clause_backend(context, location, index, i, &*p,\n+\t\t\t\t   break_label, &cases, &clauses);\n \t  ++i;\n+\t  ++index;\n \t}\n     }\n \n-  Bstatement* ldef = break_label->get_definition(context);\n-  append_to_statement_list(stat_to_tree(ldef), &stmt_list);\n+  Bstatement* switch_stmt = context->backend()->switch_statement(bcall,\n+\t\t\t\t\t\t\t\t cases,\n+\t\t\t\t\t\t\t\t clauses,\n+\t\t\t\t\t\t\t\t location);\n+  statements.push_back(switch_stmt);\n \n-  tree switch_stmt = build3(SWITCH_EXPR, sizetype, call, stmt_list, NULL_TREE);\n-  SET_EXPR_LOCATION(switch_stmt, location);\n-  append_to_statement_list(switch_stmt, &final_stmt_list);\n+  Bstatement* ldef = break_label->get_definition(context);\n+  statements.push_back(ldef);\n \n-  return final_stmt_list;\n+  return context->backend()->statement_list(statements);\n }\n \n // Add the tree for CLAUSE to STMT_LIST.\n \n void\n-Select_clauses::add_clause_tree(Translate_context* context, int case_index,\n-\t\t\t\tSelect_clause* clause,\n-\t\t\t\tUnnamed_label* bottom_label, tree* stmt_list)\n-{\n-  tree label = create_artificial_label(clause->location());\n-  append_to_statement_list(build3(CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t  build_int_cst(sizetype, case_index),\n-\t\t\t\t  NULL_TREE, label),\n-\t\t\t   stmt_list);\n-  append_to_statement_list(clause->get_statements_tree(context), stmt_list);\n+Select_clauses::add_clause_backend(\n+    Translate_context* context,\n+    source_location location,\n+    int index,\n+    int case_value,\n+    Select_clause* clause,\n+    Unnamed_label* bottom_label,\n+    std::vector<std::vector<Bexpression*> > *cases,\n+    std::vector<Bstatement*>* clauses)\n+{\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, case_value);\n+  Expression* e = Expression::make_integer(&ival, NULL, location);\n+  mpz_clear(ival);\n+  (*cases)[index].push_back(tree_to_expr(e->get_tree(context)));\n+\n+  Bstatement* s = clause->get_statements_backend(context);\n+\n   source_location gloc = (clause->statements() == NULL\n \t\t\t  ? clause->location()\n \t\t\t  : clause->statements()->end_location());\n   Bstatement* g = bottom_label->get_goto(context, gloc);\n-  append_to_statement_list(stat_to_tree(g), stmt_list);\n+\t\t\t\t\n+  if (s == NULL)\n+    (*clauses)[index] = g;\n+  else\n+    {\n+      std::vector<Bstatement*> stats(2);\n+      stats[0] = s;\n+      stats[1] = g;\n+      (*clauses)[index] = context->backend()->statement_list(stats);\n+    }\n }\n \n // Class Select_statement.\n@@ -4266,8 +4300,9 @@ Select_statement::do_lower(Gogo* gogo, Named_object* function,\n tree\n Select_statement::do_get_tree(Translate_context* context)\n {\n-  return this->clauses_->get_tree(context, this->break_label(),\n-\t\t\t\t  this->location());\n+  Bstatement* ret = this->clauses_->get_backend(context, this->break_label(),\n+\t\t\t\t\t\tthis->location());\n+  return stat_to_tree(ret);\n }\n \n // Make a select statement."}, {"sha": "1958bf9b947b89c1f6a13640b3cfcc9f64c05ce5", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54d331e46f11ac7b5876a22b30ba52e69985a48/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=f54d331e46f11ac7b5876a22b30ba52e69985a48", "patch": "@@ -678,9 +678,9 @@ class Select_clauses\n   bool\n   may_fall_through() const;\n \n-  // Return a tree implementing the select statement.\n-  tree\n-  get_tree(Translate_context*, Unnamed_label* break_label, source_location);\n+  // Convert to the backend representation.\n+  Bstatement*\n+  get_backend(Translate_context*, Unnamed_label* break_label, source_location);\n \n  private:\n   // A single clause.\n@@ -749,8 +749,8 @@ class Select_clauses\n     may_fall_through() const;\n \n     // Return a tree for the statements to execute.\n-    tree\n-    get_statements_tree(Translate_context*);\n+    Bstatement*\n+    get_statements_backend(Translate_context*);\n \n    private:\n     // The channel.\n@@ -778,8 +778,10 @@ class Select_clauses\n   };\n \n   void\n-  add_clause_tree(Translate_context*, int, Select_clause*, Unnamed_label*,\n-\t\t  tree*);\n+  add_clause_backend(Translate_context*, source_location, int index,\n+\t\t     int case_value, Select_clause*, Unnamed_label*,\n+\t\t     std::vector<std::vector<Bexpression*> >* cases,\n+\t\t     std::vector<Bstatement*>* clauses);\n \n   typedef std::vector<Select_clause> Clauses;\n "}]}