{"sha": "23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNhYjJlNGUxOGE4NjZlZWU2NmM0NTc2YjRhN2Y5OGMxMTI0Y2JmNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-01-20T19:20:39Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-01-20T19:20:39Z"}, "message": "re PR tree-optimization/15349 ([tree-ssa] Merge two phi nodes.)\n\n\tPR tree-optimization/15349\n\t* timevar.def (TV_TREE_MERGE_PHI): New.\n\t* tree-cfg.c (tree_forwarder_block_p): Add a new argument\n\tPHI_WANTED.\n\t(remove_forwarder_block, cleanup_forwarder_blocks): Adjust the\n\tcalls to tree_forwarder_block_p.\n\t(remove_forwarder_block_with_phi, merge_phi_nodes,\n\tgate_merge_phi, pass_merge_phi): New.\n\t* tree-optimize.c (init_tree_optimization_passes): Add\n\tpass_merge_phi.\n\t* tree-pass.h: Add an extern for pass_merge_phi;\n\n\tPR tree-optimization/15349\n\t* testsuite/gcc.dg/tree-ssa/pr15349.c: New.\n\nFrom-SVN: r93977", "tree": {"sha": "927e668d4041aad3c145ef07614cb36fd0edcd0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/927e668d4041aad3c145ef07614cb36fd0edcd0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/comments", "author": null, "committer": null, "parents": [{"sha": "db01eeba125e00d2d138e350526a44dfae4f3c13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db01eeba125e00d2d138e350526a44dfae4f3c13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db01eeba125e00d2d138e350526a44dfae4f3c13"}], "stats": {"total": 267, "additions": 259, "deletions": 8}, "files": [{"sha": "53d41dbc2f4ba8b7bc188bee3c18b74a924d6809", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -1,3 +1,17 @@\n+2005-01-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR tree-optimization/15349\n+\t* timevar.def (TV_TREE_MERGE_PHI): New.\n+\t* tree-cfg.c (tree_forwarder_block_p): Add a new argument\n+\tPHI_WANTED.\n+\t(remove_forwarder_block, cleanup_forwarder_blocks): Adjust the\n+\tcalls to tree_forwarder_block_p.\n+\t(remove_forwarder_block_with_phi, merge_phi_nodes,\n+\tgate_merge_phi, pass_merge_phi): New.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add\n+\tpass_merge_phi.\n+\t* tree-pass.h: Add an extern for pass_merge_phi;\n+\n 2005-01-20  Richard Henderson  <rth@redhat.com>\n \n \tPR target/19418"}, {"sha": "a4947d634945067d10c6bb04deed65d5e8851f03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -1,3 +1,8 @@\n+2005-01-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR tree-optimization/15349\n+\t* gcc.dg/tree-ssa/pr15349.c: New.\n+\n 2005-01-20  Steve Ellcey  <sje@cup.hp.com>\n \n \t* gcc.dg/tree-ssa/loop-1.c:  Fix target names on xfail."}, {"sha": "024b2f5b22baa124cb174cf9e874c50dec42a7b1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr15349.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr15349.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr15349.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr15349.c?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -0,0 +1,25 @@\n+/* PR 15349.  Merge two PHI nodes.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-mergephi\" } */\n+\n+int\n+foo (int a, int b)\n+{\n+  int t;\n+\n+  if (b)\n+    {\n+      if (a)\n+\tt = 3;\n+      else\n+\tt = 5;\n+\n+      a = 0;\n+    }\n+  else\n+    t = 7;\n+\n+  return t;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"PHI\" 1 \"mergephi\"} } */"}, {"sha": "d4a6df9147d30509628ede1fd1e41a0f1f161b96", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -83,6 +83,7 @@ DEFTIMEVAR (TV_TREE_FORWPROP\t     , \"tree forward propagate\")\n DEFTIMEVAR (TV_TREE_DCE\t\t     , \"tree conservative DCE\")\n DEFTIMEVAR (TV_TREE_CD_DCE\t     , \"tree aggressive DCE\")\n DEFTIMEVAR (TV_TREE_DSE\t\t     , \"tree DSE\")\n+DEFTIMEVAR (TV_TREE_MERGE_PHI\t     , \"PHI merge\")\n DEFTIMEVAR (TV_TREE_LOOP\t     , \"tree loop optimization\")\n DEFTIMEVAR (TV_TREE_LOOP_BOUNDS\t     , \"tree record loop bounds\")\n DEFTIMEVAR (TV_LIM                   , \"loop invariant motion\")"}, {"sha": "5321fa4616f1da0f0c8d51acf0f474e18dee1b9d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 212, "deletions": 8, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -119,7 +119,7 @@ static void split_critical_edges (void);\n static inline bool stmt_starts_bb_p (tree, tree);\n static int tree_verify_flow_info (void);\n static void tree_make_forwarder_block (edge);\n-static bool tree_forwarder_block_p (basic_block);\n+static bool tree_forwarder_block_p (basic_block, bool);\n static void tree_cfg2vcg (FILE *);\n \n /* Flowgraph optimization and cleanup.  */\n@@ -3889,16 +3889,15 @@ tree_make_forwarder_block (edge fallthru)\n    ENTRY_BLOCK_PTR.  */\n \n static bool\n-tree_forwarder_block_p (basic_block bb)\n+tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n {\n   block_stmt_iterator bsi;\n \n   /* BB must have a single outgoing edge.  */\n   if (EDGE_COUNT (bb->succs) != 1\n-      /* BB can not have any PHI nodes.  This could potentially be\n-\t relaxed early in compilation if we re-rewrote the variables\n-\t appearing in any PHI nodes in forwarder blocks.  */\n-      || phi_nodes (bb)\n+      /* If PHI_WANTED is false, BB must not have any PHI nodes.\n+\t Otherwise, BB must have PHI nodes.  */\n+      || (phi_nodes (bb) != NULL_TREE) != phi_wanted\n       /* BB may not be a predecessor of EXIT_BLOCK_PTR.  */\n       || EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n       /* Nor should this be an infinite loop.  */\n@@ -4040,7 +4039,7 @@ remove_forwarder_block (basic_block bb, basic_block **worklist)\n \t     that it was not a forwarder before, since it used to have\n \t     at least two outgoing edges, so we may just add it to\n \t     worklist.  */\n-\t  if (tree_forwarder_block_p (s->src))\n+\t  if (tree_forwarder_block_p (s->src, false))\n \t    *(*worklist)++ = s->src;\n \t}\n     }\n@@ -4097,7 +4096,7 @@ cleanup_forwarder_blocks (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      if (tree_forwarder_block_p (bb))\n+      if (tree_forwarder_block_p (bb, false))\n \t*current++ = bb;\n     }\n \n@@ -4111,6 +4110,211 @@ cleanup_forwarder_blocks (void)\n   return changed;\n }\n \n+/* Merge the PHI nodes at BB into those at BB's sole successor.  */\n+\n+static void\n+remove_forwarder_block_with_phi (basic_block bb)\n+{\n+  edge succ = EDGE_SUCC (bb, 0);\n+  basic_block dest = succ->dest;\n+  basic_block dombb, domdest, dom;\n+  block_stmt_iterator bsi;\n+\n+  /* We check for infinite loops already in tree_forwarder_block_p.\n+     However it may happen that the infinite loop is created\n+     afterwards due to removal of forwarders.  */\n+  if (dest == bb)\n+    return;\n+\n+  /* If the destination block consists of a nonlocal label, do not\n+     merge it.  */\n+  for (bsi = bsi_start (dest); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      if (TREE_CODE (stmt) != LABEL_EXPR)\n+\tbreak;\n+\n+      if (DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n+\treturn;\n+    }\n+\n+  /* Redirect each incoming edge to BB to DEST.  */\n+  while (EDGE_COUNT (bb->preds) > 0)\n+    {\n+      edge e = EDGE_PRED (bb, 0), s;\n+      tree phi;\n+\n+      s = find_edge (e->src, dest);\n+      if (s)\n+\t{\n+\t  /* We already have an edge S from E->src to DEST.  If S and\n+\t     E->dest's sole successor edge have the same PHI arguments\n+\t     at DEST, redirect S to DEST.  */\n+\t  if (phi_alternatives_equal (dest, s, succ))\n+\t    {\n+\t      e = redirect_edge_and_branch (e, dest);\n+\t      PENDING_STMT (e) = NULL_TREE;\n+\t      continue;\n+\t    }\n+\n+\t  /* PHI arguemnts are different.  Create a forwarder block by\n+\t     splitting E so that we can merge PHI arguments on E to\n+\t     DEST.  */\n+\t  e = EDGE_SUCC (split_edge (e), 0);\n+\t}\n+\n+      s = redirect_edge_and_branch (e, dest);\n+\n+      /* redirect_edge_and_branch must not create a new edge.  */\n+      gcc_assert (s == e);\n+\n+      /* Add to the PHI nodes at DEST each PHI argument removed at the\n+\t destination of E.  */\n+      for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  tree def = PHI_ARG_DEF (phi, succ->dest_idx);\n+\n+\t  if (TREE_CODE (def) == SSA_NAME)\n+\t    {\n+\t      tree var;\n+\n+\t      /* If DEF is one of the results of PHI nodes removed during\n+\t\t redirection, replace it with the PHI argument that used\n+\t\t to be on E.  */\n+\t      for (var = PENDING_STMT (e); var; var = TREE_CHAIN (var))\n+\t\t{\n+\t\t  tree old_arg = TREE_PURPOSE (var);\n+\t\t  tree new_arg = TREE_VALUE (var);\n+\n+\t\t  if (def == old_arg)\n+\t\t    {\n+\t\t      def = new_arg;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  add_phi_arg (phi, def, s);\n+\t}\n+\n+      PENDING_STMT (e) = NULL;\n+    }\n+\n+  /* Update the dominators.  */\n+  dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+  domdest = get_immediate_dominator (CDI_DOMINATORS, dest);\n+  if (domdest == bb)\n+    {\n+      /* Shortcut to avoid calling (relatively expensive)\n+\t nearest_common_dominator unless necessary.  */\n+      dom = dombb;\n+    }\n+  else\n+    dom = nearest_common_dominator (CDI_DOMINATORS, domdest, dombb);\n+\n+  set_immediate_dominator (CDI_DOMINATORS, dest, dom);\n+  \n+  /* Remove BB since all of BB's incoming edges have been redirected\n+     to DEST.  */\n+  delete_basic_block (bb);\n+}\n+\n+/* This pass performs merges PHI nodes if one feeds into another.  For\n+   example, suppose we have the following:\n+\n+  goto <bb 9> (<L9>);\n+\n+<L8>:;\n+  tem_17 = foo ();\n+\n+  # tem_6 = PHI <tem_17(8), tem_23(7)>;\n+<L9>:;\n+\n+  # tem_3 = PHI <tem_6(9), tem_2(5)>;\n+<L10>:;\n+\n+  Then we merge the first PHI node into the second one like so:\n+\n+  goto <bb 9> (<L10>);\n+\n+<L8>:;\n+  tem_17 = foo ();\n+\n+  # tem_3 = PHI <tem_23(7), tem_2(5), tem_17(8)>;\n+<L10>:;\n+*/\n+\n+static void\n+merge_phi_nodes (void)\n+{\n+  basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  basic_block *current = worklist;\n+  basic_block bb;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Find all PHI nodes that we may be able to merge.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      basic_block dest;\n+\n+      /* Look for a forwarder block with PHI nodes.  */\n+      if (!tree_forwarder_block_p (bb, true))\n+\tcontinue;\n+\n+      dest = EDGE_SUCC (bb, 0)->dest;\n+\n+      /* We have to feed into another basic block with PHI\n+\t nodes.  */\n+      if (!phi_nodes (dest)\n+\t  /* We don't want to deal with a basic block with\n+\t     abnormal edges.  */\n+\t  || has_abnormal_incoming_edge_p (bb))\n+\tcontinue;\n+\n+      if (!dominated_by_p (CDI_DOMINATORS, dest, bb))\n+\t{\n+\t  /* If BB does not dominate DEST, then the PHI nodes at\n+\t     DEST must be the only users of the results of the PHI\n+\t     nodes at BB.  */\n+\t  *current++ = bb;\n+\t}\n+    }\n+\n+  /* Now let's drain WORKLIST.  */\n+  while (current != worklist)\n+    {\n+      bb = *--current;\n+      remove_forwarder_block_with_phi (bb);\n+    }\n+\n+  free (worklist);\n+}\n+\n+static bool\n+gate_merge_phi (void)\n+{\n+  return 1;\n+}\n+\n+struct tree_opt_pass pass_merge_phi = {\n+  \"mergephi\",\t\t\t/* name */\n+  gate_merge_phi,\t\t/* gate */\n+  merge_phi_nodes,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_MERGE_PHI,\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n+  | TODO_verify_ssa,\n+  0\t\t\t\t/* letter */\n+};\n+\n /* Return a non-special label in the head of basic block BLOCK.\n    Create one if it doesn't exist.  */\n "}, {"sha": "a66e8fdb59df0954db151496996150b445e5d0a2", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -354,6 +354,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_dominator);\n   NEXT_PASS (pass_redundant_phi);\n   NEXT_PASS (pass_dce);\n+  NEXT_PASS (pass_merge_phi);\n   NEXT_PASS (pass_forwprop);\n   NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_may_alias);"}, {"sha": "8a800e7f707085010f8af71eeca2d80f64b4c51a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "patch": "@@ -142,6 +142,7 @@ extern struct tree_opt_pass pass_del_ssa;\n extern struct tree_opt_pass pass_dominator;\n extern struct tree_opt_pass pass_dce;\n extern struct tree_opt_pass pass_cd_dce;\n+extern struct tree_opt_pass pass_merge_phi;\n extern struct tree_opt_pass pass_may_alias;\n extern struct tree_opt_pass pass_split_crit_edges;\n extern struct tree_opt_pass pass_pre;"}]}