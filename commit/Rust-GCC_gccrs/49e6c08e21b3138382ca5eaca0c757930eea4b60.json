{"sha": "49e6c08e21b3138382ca5eaca0c757930eea4b60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDllNmMwOGUyMWIzMTM4MzgyY2E1ZWFjYTBjNzU3OTMwZWVhNGI2MA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-04T19:42:04Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-04T19:42:04Z"}, "message": "mkdeps.c, mkdeps.h: New files.\n\n\t* mkdeps.c, mkdeps.h: New files.\n\t* po/POTFILES.in: Add them.\n\t* Makefile.in (LIBCPP_OBJS): Add mkdeps.o.\n\t(cpplib.o, cppinit.o): Depend on mkdeps.h.\n\t(mkdeps.o): New target.\n\n\t* cppfiles.c: Delete deps_output.\n\t* cppinit.c: Include mkdeps.h.  Delete known_suffixes,\n\tOBJECT_SUFFIX, and base_name.\n\t(cpp_cleanup): Use deps_free.  Free ihash->name when clearing\n\tthe include hash.\n\t(initialize_dependency_output): Use deps_init,\n\tdeps_add_target, deps_calc_target, and deps_add_dep.  Remove\n\tall the unnecessary string bashing.\n\t(cpp_finish): Use deps_write.  Remove an unnecessary nesting\n\tlevel.\n\t* cpplib.c (do_include): Use deps_add_dep.\n\t* cpplib.h (struct cpp_reader): Replace deps_buffer,\n\tdeps_allocated_size, deps_size, deps_column members with\n\tsingle pointer to a struct deps.  Delete prototype of\n\tdeps_output.\n\nFrom-SVN: r32329", "tree": {"sha": "b5fe0ea6f7acb88432c113e0e8949eba769d06b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5fe0ea6f7acb88432c113e0e8949eba769d06b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49e6c08e21b3138382ca5eaca0c757930eea4b60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e6c08e21b3138382ca5eaca0c757930eea4b60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e6c08e21b3138382ca5eaca0c757930eea4b60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e6c08e21b3138382ca5eaca0c757930eea4b60/comments", "author": null, "committer": null, "parents": [{"sha": "4a7f193558e80da380ec023d225ca3eefb9a0e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7f193558e80da380ec023d225ca3eefb9a0e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a7f193558e80da380ec023d225ca3eefb9a0e8f"}], "stats": {"total": 597, "additions": 415, "deletions": 182}, "files": [{"sha": "bb3ff7d0e4e2b7266071a03955d1ea25ead3283c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -1,5 +1,27 @@\n 2000-03-04  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* mkdeps.c, mkdeps.h: New files.\n+\t* po/POTFILES.in: Add them.\n+\t* Makefile.in (LIBCPP_OBJS): Add mkdeps.o.\n+\t(cpplib.o, cppinit.o): Depend on mkdeps.h.\n+\t(mkdeps.o): New target.\n+\n+\t* cppfiles.c: Delete deps_output.\n+\t* cppinit.c: Include mkdeps.h.  Delete known_suffixes,\n+\tOBJECT_SUFFIX, and base_name.\n+\t(cpp_cleanup): Use deps_free.  Free ihash->name when clearing\n+\tthe include hash.\n+\t(initialize_dependency_output): Use deps_init,\n+\tdeps_add_target, deps_calc_target, and deps_add_dep.  Remove\n+\tall the unnecessary string bashing.\n+\t(cpp_finish): Use deps_write.  Remove an unnecessary nesting\n+\tlevel.\n+\t* cpplib.c (do_include): Use deps_add_dep.\n+\t* cpplib.h (struct cpp_reader): Replace deps_buffer,\n+\tdeps_allocated_size, deps_size, deps_column members with\n+\tsingle pointer to a struct deps.  Delete prototype of\n+\tdeps_output.\n+\n \t* cppinit.c: Fix thinko in previous patch.\n \n Sat Mar  4 11:32:30 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>"}, {"sha": "17f67b5b913b59a3de152eb47eb0c005a2dd16e4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -2021,7 +2021,8 @@ cccp.o: cccp.c $(CONFIG_H) intl.h pcp.h version.c config.status system.h \\\n \t  -c `echo $(srcdir)/cccp.c | sed 's,^\\./,,'`\n \n LIBCPP_OBJS =\tcpplib.o cpphash.o cpperror.o cppexp.o cppfiles.o \\\n-\t\tcppinit.o cppulp.o prefix.o version.o mbchar.o @extra_cpp_objs@\n+\t\tcppinit.o cppulp.o mkdeps.o \\\n+\t\tprefix.o version.o mbchar.o @extra_cpp_objs@\n \n # All the other archives built/used by this makefile are for targets.  This\n # one is strictly for the host.\n@@ -2038,18 +2039,20 @@ cppmain$(exeext): cppmain.o intl.o libcpp.a $(LIBDEPS)\n cppmain.o: cppmain.c $(CONFIG_H) cpplib.h intl.h system.h\n \n cppulp.o:  cppulp.c  $(CONFIG_H) system.h output.h\n-cpplib.o:  cpplib.c  $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n+cpplib.o:  cpplib.c  $(CONFIG_H) cpplib.h intl.h system.h cpphash.h mkdeps.h\n cpphash.o: cpphash.c $(CONFIG_H) cpplib.h intl.h system.h cpphash.h version.h\n cpperror.o: cpperror.c $(CONFIG_H) cpplib.h intl.h system.h\n cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h system.h\n cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h intl.h system.h\n \n cppinit.o:  cppinit.c $(CONFIG_H) cpplib.h intl.h system.h \\\n-\t\tcpphash.h prefix.h output.h Makefile version.h\n+\t\tcpphash.h prefix.h output.h Makefile version.h mkdeps.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  $(PREPROCESSOR_DEFINES) \\\n \t  -c `echo $(srcdir)/cppinit.c | sed 's,^\\./,,'`\n \n+mkdeps.o: mkdeps.c $(CONFIG_H) system.h mkdeps.h\n+\n # Note for the stamp targets, we run the program `true' instead of\n # having an empty command (nothing following the semicolon).\n "}, {"sha": "d8d518d062047b4bfb78d88f68825198939f7fb9", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -29,10 +29,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"intl.h\"\n \n-/* The entry points to this file are: find_include_file, finclude,\n-   include_hash, append_include_chain, deps_output, and file_cleanup.\n-   file_cleanup is only called through CPP_BUFFER(pfile)->cleanup,\n-   so it's static anyway. */\n+/* The entry points to this file are: find_include_file,\n+   cpp_read_file, finclude, include_hash, append_include_chain, and\n+   file_cleanup.  file_cleanup is only called through\n+   CPP_BUFFER(pfile)->cleanup, so it's static anyway. */\n \n static struct include_hash *redundant_include_p\n \t\t\t\t\tPARAMS ((cpp_reader *,\n@@ -1230,58 +1230,6 @@ initialize_input_buffer (pfile, fd, st)\n   pfile->input_buffer_len = pipe_buf;\n }\n \n-/* Add output to `deps_buffer' for the -M switch.\n-   STRING points to the text to be output.\n-   SPACER is ':' for targets, ' ' for dependencies, zero for text\n-   to be inserted literally.  */\n-\n-void\n-deps_output (pfile, string, spacer)\n-     cpp_reader *pfile;\n-     const char *string;\n-     int spacer;\n-{\n-  int size;\n-  int cr = 0;\n-\n-  if (!*string)\n-    return;\n-\n-  size = strlen (string);\n-\n-#ifndef MAX_OUTPUT_COLUMNS\n-#define MAX_OUTPUT_COLUMNS 72\n-#endif\n-  if (pfile->deps_column > 0\n-      && (pfile->deps_column + size) > MAX_OUTPUT_COLUMNS)\n-    {\n-      cr = 5;\n-      pfile->deps_column = 0;\n-    }\n-\n-  if (pfile->deps_size + size + cr + 8 > pfile->deps_allocated_size)\n-    {\n-      pfile->deps_allocated_size = (pfile->deps_size + size + 50) * 2;\n-      pfile->deps_buffer = (char *) xrealloc (pfile->deps_buffer,\n-\t\t\t\t\t      pfile->deps_allocated_size);\n-    }\n-\n-  if (cr)\n-    {\n-      bcopy (\" \\\\\\n  \", &pfile->deps_buffer[pfile->deps_size], 5);\n-      pfile->deps_size += 5;\n-    }\n-  \n-  if (spacer == ' ' && pfile->deps_column > 0)\n-    pfile->deps_buffer[pfile->deps_size++] = ' ';\n-  bcopy (string, &pfile->deps_buffer[pfile->deps_size], size);\n-  pfile->deps_size += size;\n-  pfile->deps_column += size + 1;  /* count spacer too */\n-  if (spacer == ':')\n-    pfile->deps_buffer[pfile->deps_size++] = ':';\n-  pfile->deps_buffer[pfile->deps_size] = 0;\n-}\n-\n /* Simplify a path name in place, deleting redundant components.  This\n    reduces OS overhead and guarantees that equivalent paths compare\n    the same (modulo symlinks)."}, {"sha": "daac637fe95f3be3ff09e49a2ba1420af0a913eb", "filename": "gcc/cppinit.c", "status": "modified", "additions": 26, "deletions": 108, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -28,6 +28,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"prefix.h\"\n #include \"intl.h\"\n #include \"version.h\"\n+#include \"mkdeps.h\"\n \n /* Predefined symbols, built-in macros, and the default include path. */\n \n@@ -75,23 +76,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define REGISTER_PREFIX \"\"\n #endif\n \n-/* Suffix for object files, and known input-file extensions. */\n-static const char * const known_suffixes[] =\n-{\n-  \".c\",  \".C\",   \".s\",   \".S\",   \".m\",\n-  \".cc\", \".cxx\", \".cpp\", \".cp\",  \".c++\",\n-  NULL\n-};\n-\n-#ifndef OBJECT_SUFFIX\n-# ifdef VMS\n-#  define OBJECT_SUFFIX \".obj\"\n-# else\n-#  define OBJECT_SUFFIX \".o\"\n-# endif\n-#endif\n-\n-\n /* This is the default list of directories to search for include files.\n    It may be overridden by the various -I and -ixxx options.\n \n@@ -296,29 +280,6 @@ path_include (pfile, pend, list, path)\n   while (1);\n }\n \n-/* Find the base name of a (partial) pathname FNAME.\n-   Returns a pointer into the string passed in.\n-   Accepts Unix (/-separated) paths on all systems,\n-   DOS and VMS paths on those systems.  */\n-static char *\n-base_name (fname)\n-     const char *fname;\n-{\n-  char *s = (char *)fname;\n-  char *p;\n-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n-  if (ISALPHA (s[0]) && s[1] == ':') s += 2;\n-  if ((p = rindex (s, '\\\\'))) s = p + 1;\n-#elif defined VMS\n-  if ((p = rindex (s, ':'))) s = p + 1; /* Skip device.  */\n-  if ((p = rindex (s, ']'))) s = p + 1; /* Skip directory.  */\n-  if ((p = rindex (s, '>'))) s = p + 1; /* Skip alternate (int'n'l) dir.  */\n-#endif\n-  if ((p = rindex (s, '/'))) s = p + 1;\n-  return s;\n-}\n-     \n-\n /* Append DIR to include path PATH.  DIR must be permanently allocated\n    and writable. */\n static void\n@@ -442,13 +403,6 @@ cpp_cleanup (pfile)\n       pfile->token_buffer = NULL;\n     }\n \n-  if (pfile->deps_buffer)\n-    {\n-      free (pfile->deps_buffer);\n-      pfile->deps_buffer = NULL;\n-      pfile->deps_allocated_size = 0;\n-    }\n-\n   if (pfile->input_buffer)\n     {\n       free (pfile->input_buffer);\n@@ -457,6 +411,9 @@ cpp_cleanup (pfile)\n       pfile->input_buffer_len = 0;\n     }\n \n+  if (pfile->deps)\n+    deps_free (pfile->deps);\n+\n   while (pfile->if_stack)\n     {\n       IF_STACK_FRAME *temp = pfile->if_stack;\n@@ -470,10 +427,8 @@ cpp_cleanup (pfile)\n       while (imp)\n \t{\n \t  struct include_hash *next = imp->next;\n-#if 0\n-\t  /* This gets freed elsewhere - I think. */\n-\t  free (imp->name);\n-#endif\n+\n+\t  free ((PTR) imp->name);\n \t  free (imp);\n \t  imp = next;\n \t}\n@@ -610,51 +565,18 @@ initialize_dependency_output (pfile)\n       opts->print_deps_append = 1;\n     }\n \n-  /* Print the expected object file name as the target of this Make-rule.  */\n-  pfile->deps_allocated_size = 200;\n-  pfile->deps_buffer = (char *) xmalloc (pfile->deps_allocated_size);\n-  pfile->deps_buffer[0] = 0;\n-  pfile->deps_size = 0;\n-  pfile->deps_column = 0;\n+  pfile->deps = deps_init ();\n \n+  /* Print the expected object file name as the target of this Make-rule.  */\n   if (opts->deps_target)\n-    deps_output (pfile, opts->deps_target, ':');\n+    deps_add_target (pfile->deps, opts->deps_target);\n   else if (*opts->in_fname == 0)\n-    deps_output (pfile, \"-\", ':');\n+    deps_add_target (pfile->deps, \"-\");\n   else\n-    {\n-      char *p, *q, *r;\n-      int len, x;\n-\n-      /* Discard all directory prefixes from filename.  */\n-      q = base_name (opts->in_fname);\n-\n-      /* Copy remainder to mungable area.  */\n-      len = strlen (q);\n-      p = (char *) alloca (len + 8);\n-      strcpy (p, q);\n-\n-      /* Output P, but remove known suffixes.  */\n-      q = p + len;\n-      /* Point to the filename suffix.  */\n-      r = strrchr (p, '.');\n-      if (r)\n-\t/* Compare against the known suffixes.  */\n-\tfor (x = 0; known_suffixes[x]; x++)\n-\t  if (strncmp (known_suffixes[x], r, q - r) == 0)\n-\t    {\n-\t      /* Make q point to the bit we're going to overwrite\n-\t\t with an object suffix.  */\n-\t      q = r;\n-\t      break;\n-\t    }\n+    deps_calc_target (pfile->deps, opts->in_fname);\n \n-      /* Supply our own suffix.  */\n-      strcpy (q, OBJECT_SUFFIX);\n-\n-      deps_output (pfile, p, ':');\n-      deps_output (pfile, opts->in_fname, ' ');\n-    }\n+  if (opts->in_fname)\n+    deps_add_dep (pfile->deps, opts->in_fname);\n }\n \n /* And another subroutine.  This one sets up the standard include path.  */\n@@ -923,29 +845,25 @@ cpp_finish (pfile)\n     cpp_ice (pfile, \"buffers still stacked in cpp_finish\");\n   cpp_pop_buffer (pfile);\n \n-  if (opts->print_deps)\n+  /* Don't write the deps file if preprocessing has failed.  */\n+  if (opts->print_deps && pfile->errors == 0)\n     {\n       /* Stream on which to print the dependency information.  */\n       FILE *deps_stream = 0;\n \n-      /* Don't actually write the deps file if compilation has failed.  */\n-      if (pfile->errors == 0)\n-\t{\n-\t  const char *deps_mode = opts->print_deps_append ? \"a\" : \"w\";\n-\t  if (opts->deps_file == 0)\n-\t    deps_stream = stdout;\n-\t  else if ((deps_stream = fopen (opts->deps_file, deps_mode)) == 0)\n-\t    cpp_notice_from_errno (pfile, opts->deps_file);\n+      const char *deps_mode = opts->print_deps_append ? \"a\" : \"w\";\n+      if (opts->deps_file == 0)\n+\tdeps_stream = stdout;\n+      else if ((deps_stream = fopen (opts->deps_file, deps_mode)) == 0)\n+\tcpp_notice_from_errno (pfile, opts->deps_file);\n \n-\t  if (deps_stream)\n+      if (deps_stream)\n+\t{\n+\t  deps_write (pfile->deps, deps_stream, 72);\n+\t  if (opts->deps_file)\n \t    {\n-\t      fputs (pfile->deps_buffer, deps_stream);\n-\t      putc ('\\n', deps_stream);\n-\t      if (opts->deps_file)\n-\t\t{\n-\t\t  if (ferror (deps_stream) || fclose (deps_stream) != 0)\n-\t\t    cpp_fatal (pfile, \"I/O error on output\");\n-\t\t}\n+\t      if (ferror (deps_stream) || fclose (deps_stream) != 0)\n+\t\tcpp_fatal (pfile, \"I/O error on output\");\n \t    }\n \t}\n     }"}, {"sha": "567f94002845a6562e321a9a56abbd0f114f0994", "filename": "gcc/cpplib.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -25,6 +25,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"intl.h\"\n+#include \"mkdeps.h\"\n \n #define SKIP_WHITE_SPACE(p) do { while (is_hspace(*p)) p++; } while (0)\n \n@@ -1212,7 +1213,7 @@ do_include (pfile, keyword)\n \t\t\t\t       (pfile->system_include_depth > 0)))\n         {\n \t  if (!angle_brackets)\n-\t    deps_output (pfile, ftok, ' ');\n+\t    deps_add_dep (pfile->deps, ftok);\n \t  else\n \t    {\n \t      char *p;\n@@ -1232,7 +1233,7 @@ do_include (pfile, keyword)\n \t\t  strcat (p, \"/\");\n \t        }\n \t      strcat (p, ftok);\n-\t      deps_output (pfile, p, ' ');\n+\t      deps_add_dep (pfile->deps, p);\n \t    }\n \t}\n       /* If -M was specified, and this header file won't be added to\n@@ -1254,7 +1255,7 @@ do_include (pfile, keyword)\n   /* For -M, add the file to the dependencies on its first inclusion. */\n   if (!before && (CPP_PRINT_DEPS (pfile)\n \t\t  > (angle_brackets || (pfile->system_include_depth > 0))))\n-    deps_output (pfile, ihash->name, ' ');\n+    deps_add_dep (pfile->deps, ihash->name);\n \n   /* Handle -H option.  */\n   if (CPP_OPTIONS(pfile)->print_include_names)"}, {"sha": "19a9c3e9a25138e32fc12411da7bf22e494e4649", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -228,16 +228,7 @@ struct cpp_reader\n   struct tm *timebuf;\n \n   /* Buffer of -M output.  */\n-  char *deps_buffer;\n-\n-  /* Number of bytes allocated in above.  */\n-  int deps_allocated_size;\n-\n-  /* Number of bytes used.  */\n-  int deps_size;\n-\n-  /* Number of bytes since the last newline.  */\n-  int deps_column;\n+  struct deps *deps;\n \n   /* A buffer and a table, used only by read_and_prescan (in cppfiles.c)\n      which are allocated once per cpp_reader object to keep them off the\n@@ -712,8 +703,6 @@ extern int find_include_file\t\tPARAMS ((cpp_reader *, const char *,\n extern int finclude\t\t\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t        struct include_hash *));\n extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n-extern void deps_output\t\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\tconst char *, int));\n extern struct include_hash *include_hash PARAMS ((cpp_reader *, const char *, int));\n \n #ifdef __cplusplus"}, {"sha": "43501ca365f838496fb8b403b7afc5335a185cbe", "filename": "gcc/mkdeps.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.c?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -0,0 +1,278 @@\n+/* Dependency generator for Makefile fragments.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Zack Weinberg, Mar 2000\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"mkdeps.h\"\n+\n+static const char *munge\tPARAMS ((const char *));\n+static const char *base_name\tPARAMS ((const char *));\n+\n+#ifndef OBJECT_SUFFIX\n+# define OBJECT_SUFFIX \".o\"\n+#endif\n+\n+/* Given a filename, quote characters in that filename which are\n+   significant to Make.  Note that it's not possible to quote all such\n+   characters - e.g. \\n, %, *, ?, [, \\ (in some contexts), and ~ are\n+   not properly handled.  It isn't possible to get this right in any\n+   current version of Make.  (??? Still true?  Old comment referred to\n+   3.76.1.)  */\n+   \n+static const char *\n+munge (filename)\n+     const char *filename;\n+{\n+  int len;\n+  const char *p, *q;\n+  char *dst, *buffer;\n+\n+  for (p = filename, len = 0; *p; p++, len++)\n+    {\n+      switch (*p)\n+\t{\n+\tcase ' ':\n+\tcase '\\t':\n+\t  /* GNU make uses a weird quoting scheme for white space.\n+\t     A space or tab preceded by 2N+1 backslashes represents\n+\t     N backslashes followed by space; a space or tab\n+\t     preceded by 2N backslashes represents N backslashes at\n+\t     the end of a file name; and backslashes in other\n+\t     contexts should not be doubled.  */\n+\t  for (q = p - 1; q < filename && q[-1] == '\\\\';  q--)\n+\t    len++;\n+\t  len++;\n+\t  break;\n+\n+\tcase '$':\n+\t  /* '$' is quoted by doubling it. This can mishandle things\n+\t     like \"$(\" but there's no easy fix.  */\n+\t  len++;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Now we know how big to make the buffer.  */\n+  buffer = malloc (len + 1);\n+\n+  for (p = filename, dst = buffer; *p; p++, dst++)\n+    {\n+      switch (*p)\n+\t{\n+\tcase ' ':\n+\tcase '\\t':\n+\t  for (q = p - 1; filename < q && q[-1] == '\\\\';  q--)\n+\t    *dst++ = '\\\\';\n+\t  *dst++ = '\\\\';\n+\t  break;\n+\n+\tcase '$':\n+\t  *dst++ = '$';\n+\t  break;\n+\n+\tdefault:\n+\t  /* nothing */;\n+\t}\n+      *dst = *p;\n+    }\n+\n+  *dst = '\\0';\n+  return buffer;\n+}\n+\n+/* Given a pathname, calculate the non-directory part.  This always\n+   knows how to handle Unix-style pathnames, and understands VMS and\n+   DOS paths on those systems.  */\n+/* Find the base name of a (partial) pathname FNAME.\n+   Returns a pointer into the string passed in.\n+   Accepts Unix (/-separated) paths on all systems,\n+   DOS and VMS paths on those systems.  */\n+static const char *\n+base_name (fname)\n+     const char *fname;\n+{\n+  const char *s = fname;\n+  const char *p;\n+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n+  if (ISALPHA (s[0]) && s[1] == ':') s += 2;\n+  if ((p = strrchr (s, '\\\\'))) s = p + 1;\n+#elif defined VMS\n+  if ((p = strrchr (s, ':'))) s = p + 1; /* Skip device.  */\n+  if ((p = strrchr (s, ']'))) s = p + 1; /* Skip directory.  */\n+  if ((p = strrchr (s, '>'))) s = p + 1; /* Skip alternate (int'n'l) dir.  */\n+#endif\n+  if ((p = strrchr (s, '/'))) s = p + 1;\n+  return s;\n+}\n+\n+/* Public routines.  */\n+\n+struct deps *\n+deps_init (void)\n+{\n+  struct deps *d = (struct deps *) xmalloc (sizeof (struct deps));\n+\n+  /* Allocate space for the vectors now.  */\n+\n+  d->targetv = xmalloc (2 * sizeof (const char *));\n+  d->depv = xmalloc (8 * sizeof (const char *));\n+\n+  d->ntargets = 0;\n+  d->targets_size = 2;\n+  d->ndeps = 0;\n+  d->deps_size = 8;\n+\n+  return d;\n+}\n+\n+void\n+deps_free (d)\n+     struct deps *d;\n+{\n+  unsigned int i;\n+  for (i = 0; i < d->ntargets; i++)\n+    free ((PTR) d->targetv[i]);\n+  for (i = 0; i < d->ndeps; i++)\n+    free ((PTR) d->depv[i]);\n+\n+  free (d->targetv);\n+  free (d->depv);\n+  free (d);\n+}\n+\n+void\n+deps_add_target (d, t)\n+     struct deps *d;\n+     const char *t;\n+{\n+  t = munge (t);  /* Also makes permanent copy.  */\n+\n+  if (d->ntargets == d->targets_size)\n+    {\n+      d->targets_size *= 2;\n+      d->targetv = xrealloc (d->targetv,\n+\t\t\t     d->targets_size * sizeof (const char *));\n+    }\n+  d->targetv[d->ntargets++] = t;\n+}\n+\n+void\n+deps_calc_target (d, t)\n+     struct deps *d;\n+     const char *t;\n+{\n+  const char *o, *suffix;\n+\n+  t = base_name (t);\n+  o = alloca (strlen (t) + 8);\n+\n+  strcpy (o, t);\n+  suffix = strrchr (o, '.');\n+  if (suffix)\n+    strcpy (suffix, OBJECT_SUFFIX);\n+  else\n+    strcat (o, OBJECT_SUFFIX);\n+\n+  deps_add_target (d, o);\n+}\n+\n+void\n+deps_add_dep (d, t)\n+     struct deps *d;\n+     const char *t;\n+{\n+  t = munge (t);  /* Also makes permanent copy.  */\n+\n+  if (d->ndeps == d->deps_size)\n+    {\n+      d->deps_size *= 2;\n+      d->depv = xrealloc (d->depv, d->deps_size * sizeof (const char *));\n+    }\n+  d->depv[d->ndeps++] = t;\n+}\n+\n+void\n+deps_write (d, fp, colmax)\n+     const struct deps *d;\n+     FILE *fp;\n+     unsigned int colmax;\n+{\n+  unsigned int size, i, column;\n+\n+  column = 0;\n+  if (colmax && colmax < 34)\n+    colmax = 34;\n+\n+  for (i = 0; i < d->ntargets; i++)\n+    {\n+      size = strlen (d->targetv[i]);\n+      column += size;\n+      if (colmax && column > colmax)\n+\t{\n+\t  fputs (\" \\\\\\n \", fp);\n+\t  column = 1 + size;\n+\t}\n+      if (i)\n+\t{\n+\t  putc (' ', fp);\n+\t  column++;\n+\t}\n+      fputs (d->targetv[i], fp);\n+    }\n+\n+  putc (':', fp);\n+  putc (' ', fp);\n+  column += 2;\n+\n+  for (i = 0; i < d->ndeps; i++)\n+    {\n+      size = strlen (d->depv[i]);\n+      column += size;\n+      if (colmax && column > colmax)\n+\t{\n+\t  fputs (\" \\\\\\n \", fp);\n+\t  column = 1 + size;\n+\t}\n+      if (i)\n+\t{\n+\t  putc (' ', fp);\n+\t  column++;\n+\t}\n+      fputs (d->depv[i], fp);\n+    }\n+  putc ('\\n', fp);\n+}\n+  \n+void\n+deps_dummy_targets (d, fp)\n+     const struct deps *d;\n+     FILE *fp;\n+{\n+  int i;\n+\n+  for (i = 1; i < d->ndeps; i++)\n+    {\n+      fputs (d->depv[i], fp);\n+      putc (':', fp);\n+      putc ('\\n', fp);\n+    }\n+}"}, {"sha": "7a2c130af8af659fcf9e7fe995159ca24454dd8e", "filename": "gcc/mkdeps.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fmkdeps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fmkdeps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.h?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -0,0 +1,72 @@\n+/* Dependency generator for Makefile fragments.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Zack Weinberg, Mar 2000\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#ifndef __GCC_MKDEPS__\n+#define __GCC_MKDEPS__\n+\n+/* This is the data structure used by all the functions in mkdeps.c.\n+   It's quite straightforward, but should be treated as opaque.  */\n+\n+struct deps\n+{\n+  const char **targetv;\n+  unsigned int ntargets;\t/* number of slots actually occupied */\n+  unsigned int targets_size;\t/* amt of allocated space - in words */\n+\n+  const char **depv;\n+  unsigned int ndeps;\n+  unsigned int deps_size;\n+};\n+\n+/* Create a deps buffer.  */\n+extern struct deps *deps_init\tPARAMS ((void));\n+\n+/* Destroy a deps buffer.  */\n+extern void deps_free\t\tPARAMS ((struct deps *));\n+\n+/* Add a target (appears on left side of the colon) to the deps list. */\n+extern void deps_add_target\tPARAMS ((struct deps *, const char *));\n+\n+/* Given the name of the primary source file, calculate and add the\n+   name of the target.  This is done by locating and stripping the\n+   file extension (if any) and adding .o (OBJECT_SUFFIX).  In addition,\n+   any directory components of the path are discarded.  */\n+extern void deps_calc_target\tPARAMS ((struct deps *, const char *));\n+\n+/* Add a dependency (appears on the right side of the colon) to the\n+   deps list.  Dependencies will be printed in the order that they\n+   were entered with this function.  By convention, the first\n+   dependency entered should be the primary source file.  */\n+extern void deps_add_dep\tPARAMS ((struct deps *, const char *));\n+\n+/* Write out a deps buffer to a specified file.  The third argument\n+   is the number of columns to word-wrap at (0 means don't wrap).  */\n+extern void deps_write\t\tPARAMS ((const struct deps *, FILE *,\n+\t\t\t\t\t unsigned int));\n+\n+/* For each dependency *except the first*, emit a dummy rule for that\n+   file, causing it to depend on nothing.  This is used to work around\n+   the intermediate-file deletion misfeature in Make, in some\n+   automatic dependency schemes.  */\n+extern void deps_dummy_targets\tPARAMS ((const struct deps *, FILE *));\n+\n+#endif"}, {"sha": "f31bb2408b7c2a9084059d7e362fb1b7dd729949", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e6c08e21b3138382ca5eaca0c757930eea4b60/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=49e6c08e21b3138382ca5eaca0c757930eea4b60", "patch": "@@ -707,6 +707,8 @@ loop.h\n machmode.h\n mbchar.c\n mbchar.h\n+mkdeps.c\n+mkdeps.h\n #mips-tdump.c is not yet internationalized\n #mips-tfile.c is not yet internationalized\n objc/objc-act.c"}]}