{"sha": "7552da58e17fb0e2c53a03bd986eee6baea79730", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU1MmRhNThlMTdmYjBlMmM1M2EwM2JkOTg2ZWVlNmJhZWE3OTczMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2002-02-20T23:05:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2002-02-20T23:05:47Z"}, "message": "re PR c++/4401 (Array subscript  evaluation sometimes wrong for 64-bit architectures)\n\n\tPR c++/4401\n\t* c-common.c (pointer_int_sum): Moved from...\n\t* c-typeck.c (pointer_int_sum): ...here.\n\t* c-common.h (pointer_int_sum): Add prototype.\n\n\t* typeck.c (cp_pointer_int_sum): Renamed from\n\tpointer_int_sum, call pointer_int_sum.\n\n\t* g++.dg/opt/ptrintsum1.C: New test.\n\nFrom-SVN: r49916", "tree": {"sha": "61e2d388e4c9e1800d174ed4d1ad82befd143f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61e2d388e4c9e1800d174ed4d1ad82befd143f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7552da58e17fb0e2c53a03bd986eee6baea79730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7552da58e17fb0e2c53a03bd986eee6baea79730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7552da58e17fb0e2c53a03bd986eee6baea79730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7552da58e17fb0e2c53a03bd986eee6baea79730/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00fae85dcb96cb20e723b37ae16dcf1cf09434da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fae85dcb96cb20e723b37ae16dcf1cf09434da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00fae85dcb96cb20e723b37ae16dcf1cf09434da"}], "stats": {"total": 329, "additions": 152, "deletions": 177}, "files": [{"sha": "59d8288a77a0da3565ed87b0cedd181462fab360", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -1,3 +1,10 @@\n+2002-02-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/4401\n+\t* c-common.c (pointer_int_sum): Moved from...\n+\t* c-typeck.c (pointer_int_sum): ...here.\n+\t* c-common.h (pointer_int_sum): Add prototype.\n+\n 2002-02-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/5713"}, {"sha": "dfdacca3c55ecf6af202a251d297ea134aff4653", "filename": "gcc/c-common.c", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -1982,6 +1982,107 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n   return 0;\n }\n \f\n+/* Return a tree for the sum or difference (RESULTCODE says which)\n+   of pointer PTROP and integer INTOP.  */\n+\n+tree\n+pointer_int_sum (resultcode, ptrop, intop)\n+     enum tree_code resultcode;\n+     tree ptrop, intop;\n+{\n+  tree size_exp;\n+\n+  tree result;\n+  tree folded;\n+\n+  /* The result is a pointer of the same type that is being added.  */\n+\n+  tree result_type = TREE_TYPE (ptrop);\n+\n+  if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n+    {\n+      if (pedantic || warn_pointer_arith)\n+\tpedwarn (\"pointer of type `void *' used in arithmetic\");\n+      size_exp = integer_one_node;\n+    }\n+  else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n+    {\n+      if (pedantic || warn_pointer_arith)\n+\tpedwarn (\"pointer to a function used in arithmetic\");\n+      size_exp = integer_one_node;\n+    }\n+  else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n+    {\n+      if (pedantic || warn_pointer_arith)\n+\tpedwarn (\"pointer to member function used in arithmetic\");\n+      size_exp = integer_one_node;\n+    }\n+  else if (TREE_CODE (TREE_TYPE (result_type)) == OFFSET_TYPE)\n+    {\n+      if (pedantic || warn_pointer_arith)\n+\tpedwarn (\"pointer to a member used in arithmetic\");\n+      size_exp = integer_one_node;\n+    }\n+  else\n+    size_exp = size_in_bytes (TREE_TYPE (result_type));\n+\n+  /* If what we are about to multiply by the size of the elements\n+     contains a constant term, apply distributive law\n+     and multiply that constant term separately.\n+     This helps produce common subexpressions.  */\n+\n+  if ((TREE_CODE (intop) == PLUS_EXPR || TREE_CODE (intop) == MINUS_EXPR)\n+      && ! TREE_CONSTANT (intop)\n+      && TREE_CONSTANT (TREE_OPERAND (intop, 1))\n+      && TREE_CONSTANT (size_exp)\n+      /* If the constant comes from pointer subtraction,\n+\t skip this optimization--it would cause an error.  */\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (intop, 0))) == INTEGER_TYPE\n+      /* If the constant is unsigned, and smaller than the pointer size,\n+\t then we must skip this optimization.  This is because it could cause\n+\t an overflow error if the constant is negative but INTOP is not.  */\n+      && (! TREE_UNSIGNED (TREE_TYPE (intop))\n+\t  || (TYPE_PRECISION (TREE_TYPE (intop))\n+\t      == TYPE_PRECISION (TREE_TYPE (ptrop)))))\n+    {\n+      enum tree_code subcode = resultcode;\n+      tree int_type = TREE_TYPE (intop);\n+      if (TREE_CODE (intop) == MINUS_EXPR)\n+\tsubcode = (subcode == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR);\n+      /* Convert both subexpression types to the type of intop,\n+\t because weird cases involving pointer arithmetic\n+\t can result in a sum or difference with different type args.  */\n+      ptrop = build_binary_op (subcode, ptrop,\n+\t\t\t       convert (int_type, TREE_OPERAND (intop, 1)), 1);\n+      intop = convert (int_type, TREE_OPERAND (intop, 0));\n+    }\n+\n+  /* Convert the integer argument to a type the same size as sizetype\n+     so the multiply won't overflow spuriously.  */\n+\n+  if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype)\n+      || TREE_UNSIGNED (TREE_TYPE (intop)) != TREE_UNSIGNED (sizetype))\n+    intop = convert (type_for_size (TYPE_PRECISION (sizetype), \n+\t\t\t\t    TREE_UNSIGNED (sizetype)), intop);\n+\n+  /* Replace the integer argument with a suitable product by the object size.\n+     Do this multiplication as signed, then convert to the appropriate\n+     pointer type (actually unsigned integral).  */\n+\n+  intop = convert (result_type,\n+\t\t   build_binary_op (MULT_EXPR, intop,\n+\t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n+\n+  /* Create the sum or difference.  */\n+\n+  result = build (resultcode, result_type, ptrop, intop);\n+\n+  folded = fold (result);\n+  if (folded == result)\n+    TREE_CONSTANT (folded) = TREE_CONSTANT (ptrop) & TREE_CONSTANT (intop);\n+  return folded;\n+}\n+\f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n    or validate its data type for an `if' or `while' statement or ?..: exp.\n "}, {"sha": "9bb2d1ac23398c218716dcc97f172c7c69197b92", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -538,6 +538,7 @@ extern char *get_directive_line\t\t\tPARAMS ((void));\n    and, if so, perhaps change them both back to their original type.  */\n extern tree shorten_compare\t\t\tPARAMS ((tree *, tree *, tree *, enum tree_code *));\n \n+extern tree pointer_int_sum\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern unsigned int min_precision\t\tPARAMS ((tree, int));\n \n /* Add qualifiers to a type, in the fashion for C.  */"}, {"sha": "4ee7cb3b69757f38e4f1f8cb1d3ac52a2e38d4f3", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -58,7 +58,6 @@ static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n static tree default_function_array_conversion\tPARAMS ((tree));\n static tree lookup_field\t\tPARAMS ((tree, tree));\n static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n-static tree pointer_int_sum\t\tPARAMS ((enum tree_code, tree, tree));\n static tree pointer_diff\t\tPARAMS ((tree, tree));\n static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree, int));\n static void pedantic_lvalue_warning\tPARAMS ((enum tree_code));\n@@ -2637,95 +2636,6 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n   }\n }\n \f\n-/* Return a tree for the sum or difference (RESULTCODE says which)\n-   of pointer PTROP and integer INTOP.  */\n-\n-static tree\n-pointer_int_sum (resultcode, ptrop, intop)\n-     enum tree_code resultcode;\n-     tree ptrop, intop;\n-{\n-  tree size_exp;\n-\n-  tree result;\n-  tree folded;\n-\n-  /* The result is a pointer of the same type that is being added.  */\n-\n-  tree result_type = TREE_TYPE (ptrop);\n-\n-  if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n-    {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"pointer of type `void *' used in arithmetic\");\n-      size_exp = integer_one_node;\n-    }\n-  else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n-    {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"pointer to a function used in arithmetic\");\n-      size_exp = integer_one_node;\n-    }\n-  else\n-    size_exp = c_size_in_bytes (TREE_TYPE (result_type));\n-\n-  /* If what we are about to multiply by the size of the elements\n-     contains a constant term, apply distributive law\n-     and multiply that constant term separately.\n-     This helps produce common subexpressions.  */\n-\n-  if ((TREE_CODE (intop) == PLUS_EXPR || TREE_CODE (intop) == MINUS_EXPR)\n-      && ! TREE_CONSTANT (intop)\n-      && TREE_CONSTANT (TREE_OPERAND (intop, 1))\n-      && TREE_CONSTANT (size_exp)\n-      /* If the constant comes from pointer subtraction,\n-\t skip this optimization--it would cause an error.  */\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (intop, 0))) == INTEGER_TYPE\n-      /* If the constant is unsigned, and smaller than the pointer size,\n-\t then we must skip this optimization.  This is because it could cause\n-\t an overflow error if the constant is negative but INTOP is not.  */\n-      && (! TREE_UNSIGNED (TREE_TYPE (intop))\n-\t  || (TYPE_PRECISION (TREE_TYPE (intop))\n-\t      == TYPE_PRECISION (TREE_TYPE (ptrop)))))\n-    {\n-      enum tree_code subcode = resultcode;\n-      tree int_type = TREE_TYPE (intop);\n-      if (TREE_CODE (intop) == MINUS_EXPR)\n-\tsubcode = (subcode == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR);\n-      /* Convert both subexpression types to the type of intop,\n-\t because weird cases involving pointer arithmetic\n-\t can result in a sum or difference with different type args.  */\n-      ptrop = build_binary_op (subcode, ptrop,\n-\t\t\t       convert (int_type, TREE_OPERAND (intop, 1)), 1);\n-      intop = convert (int_type, TREE_OPERAND (intop, 0));\n-    }\n-\n-  /* Convert the integer argument to a type the same size as sizetype\n-     so the multiply won't overflow spuriously.  */\n-\n-  if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype)\n-      || TREE_UNSIGNED (TREE_TYPE (intop)) != TREE_UNSIGNED (sizetype))\n-    intop = convert (type_for_size (TYPE_PRECISION (sizetype), \n-\t\t\t\t    TREE_UNSIGNED (sizetype)), intop);\n-\n-  /* Replace the integer argument with a suitable product by the object size.\n-     Do this multiplication as signed, then convert to the appropriate\n-     pointer type (actually unsigned integral).  */\n-\n-  intop = convert (result_type,\n-\t\t   build_binary_op (MULT_EXPR, intop,\n-\t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n-\n-  /* Create the sum or difference.  */\n-\n-  result = build (resultcode, result_type, ptrop, intop);\n-\n-  folded = fold (result);\n-  if (folded == result)\n-    TREE_CONSTANT (folded) = TREE_CONSTANT (ptrop) & TREE_CONSTANT (intop);\n-  return folded;\n-}\n-\n /* Return a tree for the difference of pointers OP0 and OP1.\n    The resulting tree has type int.  */\n "}, {"sha": "b4a5b0bcf2461eb4b6e29e482c563cf177c66e0c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -1,3 +1,8 @@\n+2002-02-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* typeck.c (cp_pointer_int_sum): Renamed from\n+\tpointer_int_sum, call pointer_int_sum.\n+\n 2002-02-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl.c (duplicate_decls): Return 0 if issued error about"}, {"sha": "6ca524233d8d6aa5b2dbd0395fb98077ede54aae", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 87, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n \n static tree convert_for_assignment PARAMS ((tree, tree, const char *, tree,\n \t\t\t\t\t  int));\n-static tree pointer_int_sum PARAMS ((enum tree_code, tree, tree));\n+static tree cp_pointer_int_sum PARAMS ((enum tree_code, tree, tree));\n static tree rationalize_conditional_expr PARAMS ((enum tree_code, tree));\n static int comp_target_parms PARAMS ((tree, tree));\n static int comp_ptr_ttypes_real PARAMS ((tree, tree, int));\n@@ -3452,9 +3452,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case PLUS_EXPR:\n       /* Handle the pointer + int case.  */\n       if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n-\treturn pointer_int_sum (PLUS_EXPR, op0, op1);\n+\treturn cp_pointer_int_sum (PLUS_EXPR, op0, op1);\n       else if (code1 == POINTER_TYPE && code0 == INTEGER_TYPE)\n-\treturn pointer_int_sum (PLUS_EXPR, op1, op0);\n+\treturn cp_pointer_int_sum (PLUS_EXPR, op1, op0);\n       else\n \tcommon = 1;\n       break;\n@@ -3467,7 +3467,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \treturn pointer_diff (op0, op1, common_type (type0, type1));\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n-\treturn pointer_int_sum (MINUS_EXPR, op0, op1);\n+\treturn cp_pointer_int_sum (MINUS_EXPR, op0, op1);\n       else\n \tcommon = 1;\n       break;\n@@ -4072,94 +4072,14 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n    of pointer PTROP and integer INTOP.  */\n \n static tree\n-pointer_int_sum (resultcode, ptrop, intop)\n+cp_pointer_int_sum (resultcode, ptrop, intop)\n      enum tree_code resultcode;\n      register tree ptrop, intop;\n {\n-  tree size_exp;\n-\n-  register tree result;\n-  register tree folded = fold (intop);\n-\n-  /* The result is a pointer of the same type that is being added.  */\n-\n-  register tree result_type = TREE_TYPE (ptrop);\n-\n-  if (!complete_type_or_else (result_type, ptrop))\n+  if (!complete_type_or_else (TREE_TYPE (ptrop), ptrop))\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n-    {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ISO C++ forbids using pointer of type `void *' in pointer arithmetic\");\n-      size_exp = integer_one_node;\n-    }\n-  else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n-    {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ISO C++ forbids using a pointer-to-function in pointer arithmetic\");\n-      size_exp = integer_one_node;\n-    }\n-  else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n-    {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ISO C++ forbids using a pointer to member function in pointer arithmetic\");\n-      size_exp = integer_one_node;\n-    }\n-  else if (TREE_CODE (TREE_TYPE (result_type)) == OFFSET_TYPE)\n-    {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"ISO C++ forbids using pointer to a member in pointer arithmetic\");\n-      size_exp = integer_one_node;\n-    }\n-  else\n-    size_exp = size_in_bytes (complete_type (TREE_TYPE (result_type)));\n-\n-  /* Needed to make OOPS V2R3 work.  */\n-  intop = folded;\n-  if (integer_zerop (intop))\n-    return ptrop;\n-\n-  /* If what we are about to multiply by the size of the elements\n-     contains a constant term, apply distributive law\n-     and multiply that constant term separately.\n-     This helps produce common subexpressions.  */\n-\n-  if ((TREE_CODE (intop) == PLUS_EXPR || TREE_CODE (intop) == MINUS_EXPR)\n-      && ! TREE_CONSTANT (intop)\n-      && TREE_CONSTANT (TREE_OPERAND (intop, 1))\n-      && TREE_CONSTANT (size_exp))\n-    {\n-      enum tree_code subcode = resultcode;\n-      if (TREE_CODE (intop) == MINUS_EXPR)\n-\tsubcode = (subcode == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR);\n-      ptrop = cp_build_binary_op (subcode, ptrop, TREE_OPERAND (intop, 1));\n-      intop = TREE_OPERAND (intop, 0);\n-    }\n-\n-  /* Convert the integer argument to a type the same size as sizetype\n-     so the multiply won't overflow spuriously.  */\n-\n-  if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype))\n-    intop = cp_convert (type_for_size (TYPE_PRECISION (sizetype), 0), intop);\n-\n-  /* Replace the integer argument with a suitable product by the object size.\n-     Do this multiplication as signed, then convert to the appropriate\n-     pointer type (actually unsigned integral).  */\n-\n-  intop = cp_convert (result_type,\n-\t\t      cp_build_binary_op (MULT_EXPR, intop,\n-\t\t\t\t\t  cp_convert (TREE_TYPE (intop),\n-\t\t\t\t\t\t      size_exp)));\n-\n-  /* Create the sum or difference.  */\n-\n-  result = build (resultcode, result_type, ptrop, intop);\n-\n-  folded = fold (result);\n-  if (folded == result)\n-    TREE_CONSTANT (folded) = TREE_CONSTANT (ptrop) & TREE_CONSTANT (intop);\n-  return folded;\n+  return pointer_int_sum (resultcode, ptrop, fold (intop));\n }\n \n /* Return a tree for the difference of pointers OP0 and OP1."}, {"sha": "ebf920fc0f8b5494b07178ddd6c00769b943eb08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -6,6 +6,8 @@\n \n \t* gcc.dg/noncompile/20020220-1.c: New test.\n \n+\t* g++.dg/opt/ptrintsum1.C: New test.\n+\n 2002-02-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/20020216-1.c: New test."}, {"sha": "a6a3c9727db059b587cf6edf8c30d82b33263af2", "filename": "gcc/testsuite/g++.dg/opt/ptrintsum1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fptrintsum1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7552da58e17fb0e2c53a03bd986eee6baea79730/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fptrintsum1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fptrintsum1.C?ref=7552da58e17fb0e2c53a03bd986eee6baea79730", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/4401\n+// This testcase was miscompiled on 64-bit platforms, resulting to\n+// operating on a[0x100000000] instead of a[0].\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+char *a;\n+char b[] = \"AAAA\";\n+\n+extern \"C\" void abort (void);\n+extern \"C\" void exit (int);\n+\n+void foo (void)\n+{\n+  unsigned int i, j;\n+\n+  i = 2;\n+  j = 3;\n+  a[i + 1 - j] += i;\n+}\n+\n+int main (void)\n+{\n+  a = b;\n+  foo ();\n+  if (b[0] != 'A' + 2)\n+    abort ();\n+  exit (0);\n+}"}]}