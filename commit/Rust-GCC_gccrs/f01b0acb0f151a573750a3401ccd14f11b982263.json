{"sha": "f01b0acb0f151a573750a3401ccd14f11b982263", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxYjBhY2IwZjE1MWE1NzM3NTBhMzQwMWNjZDE0ZjExYjk4MjI2Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-12T01:45:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-12T01:45:44Z"}, "message": "cp-tree.h (minimal_parse_mode): Remove.\n\n\t* cp-tree.h (minimal_parse_mode): Remove.\n\t(finish_label_stmt): New function.\n\t* decl.c (saved_scope): Remove minimal parse mode.\n\t(maybe_push_to_top_level): Don't save it.\n\t(pop_from_top_level): Don't restore it.\n\t(define_label): Split out template-handling code to semantics.c.\n\t(start_decl): Don't use minimal_parse_mode.\n\t(cp_finish_decl): Likewise.\n\t(start_function): Don't increment it.\n\t(store_return_init): Don't use it.\n\t(finish_function): Don't decrement it.\n\t* parse.y (label_colon): Use finish_label_stmt throughout.\n\t* parse.c: Regenerated.\n\t* pt.c (minimal_parse_mode): Don't define it.\n\t(tsubst_expr): Use finish_label_stmt.\n\t* semantics.c (finish_label_stmt): New function.\n\nFrom-SVN: r28682", "tree": {"sha": "3a494497f77567908eafc145060dd40eb99b735e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a494497f77567908eafc145060dd40eb99b735e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f01b0acb0f151a573750a3401ccd14f11b982263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01b0acb0f151a573750a3401ccd14f11b982263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f01b0acb0f151a573750a3401ccd14f11b982263", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01b0acb0f151a573750a3401ccd14f11b982263/comments", "author": null, "committer": null, "parents": [{"sha": "cf7cf3d23e8b3d6ffb7a541e5942f205c6e43a90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7cf3d23e8b3d6ffb7a541e5942f205c6e43a90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7cf3d23e8b3d6ffb7a541e5942f205c6e43a90"}], "stats": {"total": 312, "additions": 160, "deletions": 152}, "files": [{"sha": "013e425dc7ad390fc09152cfdf1ba24071df954a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -1,5 +1,22 @@\n 1999-08-11  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (minimal_parse_mode): Remove.\n+\t(finish_label_stmt): New function.\n+\t* decl.c (saved_scope): Remove minimal parse mode.\n+\t(maybe_push_to_top_level): Don't save it.\n+\t(pop_from_top_level): Don't restore it.\n+\t(define_label): Split out template-handling code to semantics.c.\n+\t(start_decl): Don't use minimal_parse_mode.\n+\t(cp_finish_decl): Likewise.\n+\t(start_function): Don't increment it.\n+\t(store_return_init): Don't use it.\n+\t(finish_function): Don't decrement it.\n+\t* parse.y (label_colon): Use finish_label_stmt throughout.\n+\t* parse.c: Regenerated.\n+\t* pt.c (minimal_parse_mode): Don't define it.\n+\t(tsubst_expr): Use finish_label_stmt.\n+\t* semantics.c (finish_label_stmt): New function.\n+\n \t* dump.c (queue): Be careful when computing bitmasks.\n \t(dequeue_and_dump): Describe binfos as binfos, not as\n \tvectors."}, {"sha": "e42122c57465cbda2c705533b75f786ce01ad249", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -2262,8 +2262,6 @@ struct tinst_level\n   struct tinst_level *next;\n };\n \n-extern int minimal_parse_mode;\n-\n extern void maybe_print_template_context\tPROTO ((void));\n \n /* in class.c */\n@@ -3305,6 +3303,7 @@ extern void finish_handler                      PROTO((tree));\n extern tree begin_compound_stmt                 PROTO((int));\n extern tree finish_compound_stmt                PROTO((int, tree));\n extern void finish_asm_stmt                     PROTO((tree, tree, tree, tree, tree));\n+extern void finish_label_stmt                   PROTO((tree));\n extern tree finish_parenthesized_expr           PROTO((tree));\n extern tree begin_stmt_expr                     PROTO((void));\n extern tree finish_stmt_expr                    PROTO((tree, tree));"}, {"sha": "f4d345a8b0fde773357d3e113c49d90a273450c7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -2390,7 +2390,6 @@ struct saved_scope {\n   struct binding_level *class_bindings;\n   tree *lang_base, *lang_stack, lang_name;\n   int lang_stacksize;\n-  int minimal_parse_mode;\n   tree last_function_parms;\n   tree template_parms;\n   HOST_WIDE_INT processing_template_decl;\n@@ -2509,7 +2508,6 @@ maybe_push_to_top_level (pseudo)\n   s->lang_base = current_lang_base;\n   s->lang_stacksize = current_lang_stacksize;\n   s->lang_name = current_lang_name;\n-  s->minimal_parse_mode = minimal_parse_mode;\n   s->last_function_parms = last_function_parms;\n   s->template_parms = current_template_parms;\n   s->processing_template_decl = processing_template_decl;\n@@ -2529,7 +2527,6 @@ maybe_push_to_top_level (pseudo)\n   strict_prototype = strict_prototypes_lang_cplusplus;\n   named_labels = NULL_TREE;\n   shadowed_labels = NULL_TREE;\n-  minimal_parse_mode = 0;\n   previous_class_type = previous_class_values = NULL_TREE;\n   class_cache_firstobj = 0;\n   processing_specialization = 0;\n@@ -2595,7 +2592,6 @@ pop_from_top_level ()\n     strict_prototype = strict_prototypes_lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n     strict_prototype = strict_prototypes_lang_c;\n-  minimal_parse_mode = s->minimal_parse_mode;\n   last_function_parms = s->last_function_parms;\n   current_template_parms = s->template_parms;\n   processing_template_decl = s->processing_template_decl;\n@@ -4825,20 +4821,7 @@ define_label (filename, line, name)\n      int line;\n      tree name;\n {\n-  tree decl;\n-\n-  if (minimal_parse_mode)\n-    {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-      decl = build_decl (LABEL_DECL, name, void_type_node);\n-      pop_obstacks ();\n-      DECL_SOURCE_LINE (decl) = line;\n-      DECL_SOURCE_FILE (decl) = filename;\n-      add_tree (decl);\n-      return decl;\n-    }\n-\n-  decl = lookup_label (name);\n+  tree decl = lookup_label (name);\n \n   /* After labels, make any new cleanups go into their\n      own new (temporary) binding contour.  */\n@@ -7027,7 +7010,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n     {\n       if (! current_function_decl)\n \ttem = push_template_decl (tem);\n-      else if (minimal_parse_mode)\n+      else\n \tDECL_VINDEX (tem)\n \t    = build_min_nt (DECL_STMT, copy_to_permanent (declarator),\n \t\t\t    copy_to_permanent (declspecs),\n@@ -7398,7 +7381,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     {\n       if (init && DECL_INITIAL (decl))\n \tDECL_INITIAL (decl) = init;\n-      if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl))\n+      if (current_function_decl && ! DECL_ARTIFICIAL (decl))\n \t{\n \t  tree stmt = DECL_VINDEX (decl);\n \t  /* If the decl is declaring a member of a local class (in a\n@@ -13172,11 +13155,8 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     temporary_allocation ();\n \n   if (processing_template_decl)\n-    {\n-      ++minimal_parse_mode;\n-      last_tree = DECL_SAVED_TREE (decl1)\n-\t= build_nt (EXPR_STMT, void_zero_node);\n-    }\n+    last_tree = DECL_SAVED_TREE (decl1)\n+      = build_nt (EXPR_STMT, void_zero_node);\n \n   ++function_depth;\n \n@@ -13420,7 +13400,7 @@ store_return_init (return_id, init)\n       DECL_INITIAL (decl) = init;\n       pushdecl (decl);\n \n-      if (minimal_parse_mode)\n+      if (processing_template_decl && current_function_decl)\n \tadd_tree (build_min_nt (RETURN_INIT, return_id,\n \t\t\t\tcopy_to_permanent (init)));\n       else\n@@ -13872,7 +13852,6 @@ finish_function (lineno, flags, nested)\n      until we do an instantiation.  */\n   if (processing_template_decl)\n     {\n-      --minimal_parse_mode;\n       DECL_SAVED_TREE (fndecl) = TREE_CHAIN (DECL_SAVED_TREE (fndecl));\n       /* We have to save this value here in case\n \t maybe_end_member_template_processing decides to pop all the"}, {"sha": "809a7eb3e74be8fd6e791472d0be3c9d11a99f7b", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 103, "deletions": 108, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -721,16 +721,16 @@ static const short yyrline[] = { 0,\n   3292,  3294,  3300,  3306,  3309,  3312,  3318,  3320,  3322,  3326,\n   3328,  3329,  3330,  3332,  3335,  3338,  3341,  3347,  3351,  3353,\n   3356,  3358,  3361,  3365,  3367,  3370,  3372,  3375,  3392,  3398,\n-  3406,  3408,  3410,  3414,  3417,  3418,  3426,  3430,  3434,  3437,\n-  3438,  3444,  3447,  3450,  3452,  3456,  3461,  3464,  3474,  3479,\n-  3480,  3487,  3490,  3493,  3495,  3498,  3500,  3510,  3524,  3528,\n-  3531,  3533,  3537,  3541,  3544,  3547,  3549,  3553,  3555,  3562,\n-  3569,  3572,  3576,  3580,  3584,  3590,  3594,  3599,  3601,  3604,\n-  3609,  3615,  3626,  3629,  3631,  3635,  3643,  3646,  3650,  3653,\n-  3655,  3657,  3663,  3668,  3671,  3673,  3675,  3677,  3679,  3681,\n-  3683,  3685,  3687,  3689,  3691,  3693,  3695,  3697,  3699,  3701,\n-  3703,  3705,  3707,  3709,  3711,  3713,  3715,  3717,  3719,  3721,\n-  3723,  3725,  3727,  3729,  3731,  3733,  3736,  3738\n+  3401,  3403,  3405,  3409,  3412,  3413,  3421,  3425,  3429,  3432,\n+  3433,  3439,  3442,  3445,  3447,  3451,  3456,  3459,  3469,  3474,\n+  3475,  3482,  3485,  3488,  3490,  3493,  3495,  3505,  3519,  3523,\n+  3526,  3528,  3532,  3536,  3539,  3542,  3544,  3548,  3550,  3557,\n+  3564,  3567,  3571,  3575,  3579,  3585,  3589,  3594,  3596,  3599,\n+  3604,  3610,  3621,  3624,  3626,  3630,  3638,  3641,  3645,  3648,\n+  3650,  3652,  3658,  3663,  3666,  3668,  3670,  3672,  3674,  3676,\n+  3678,  3680,  3682,  3684,  3686,  3688,  3690,  3692,  3694,  3696,\n+  3698,  3700,  3702,  3704,  3706,  3708,  3710,  3712,  3714,  3716,\n+  3718,  3720,  3722,  3724,  3726,  3728,  3731,  3733\n };\n #endif\n \n@@ -7716,106 +7716,101 @@ case 779:\n     break;}\n case 780:\n #line 3400 \"parse.y\"\n-{ tree label;\n-\t\tdo_label:\n-\t\t  label = define_label (input_filename, lineno, yyvsp[-1].ttype);\n-\t\t  if (label && ! minimal_parse_mode)\n-\t\t    expand_label (label);\n-\t\t;\n+{ finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 781:\n-#line 3407 \"parse.y\"\n-{ goto do_label; ;\n+#line 3402 \"parse.y\"\n+{ finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 782:\n-#line 3409 \"parse.y\"\n-{ goto do_label; ;\n+#line 3404 \"parse.y\"\n+{ finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 783:\n-#line 3411 \"parse.y\"\n-{ goto do_label; ;\n+#line 3406 \"parse.y\"\n+{ finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 784:\n-#line 3416 \"parse.y\"\n+#line 3411 \"parse.y\"\n { if (yyvsp[-1].ttype) cplus_expand_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 786:\n-#line 3419 \"parse.y\"\n+#line 3414 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 787:\n-#line 3428 \"parse.y\"\n+#line 3423 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 788:\n-#line 3431 \"parse.y\"\n+#line 3426 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 789:\n-#line 3436 \"parse.y\"\n+#line 3431 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 791:\n-#line 3439 \"parse.y\"\n+#line 3434 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 792:\n-#line 3446 \"parse.y\"\n+#line 3441 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 795:\n-#line 3453 \"parse.y\"\n+#line 3448 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 796:\n-#line 3458 \"parse.y\"\n+#line 3453 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 797:\n-#line 3463 \"parse.y\"\n+#line 3458 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 798:\n-#line 3465 \"parse.y\"\n+#line 3460 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 799:\n-#line 3476 \"parse.y\"\n+#line 3471 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 801:\n-#line 3481 \"parse.y\"\n+#line 3476 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 802:\n-#line 3489 \"parse.y\"\n+#line 3484 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 803:\n-#line 3491 \"parse.y\"\n+#line 3486 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 804:\n-#line 3494 \"parse.y\"\n+#line 3489 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 805:\n-#line 3496 \"parse.y\"\n+#line 3491 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 806:\n-#line 3499 \"parse.y\"\n+#line 3494 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 807:\n-#line 3501 \"parse.y\"\n+#line 3496 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7827,7 +7822,7 @@ case 807:\n \t\t;\n     break;}\n case 808:\n-#line 3511 \"parse.y\"\n+#line 3506 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7840,99 +7835,99 @@ case 808:\n \t\t;\n     break;}\n case 809:\n-#line 3526 \"parse.y\"\n+#line 3521 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 810:\n-#line 3528 \"parse.y\"\n+#line 3523 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 813:\n-#line 3539 \"parse.y\"\n+#line 3534 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 814:\n-#line 3542 \"parse.y\"\n+#line 3537 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 815:\n-#line 3545 \"parse.y\"\n+#line 3540 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 816:\n-#line 3548 \"parse.y\"\n+#line 3543 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 817:\n-#line 3550 \"parse.y\"\n+#line 3545 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 819:\n-#line 3556 \"parse.y\"\n+#line 3551 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 820:\n-#line 3566 \"parse.y\"\n+#line 3561 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 821:\n-#line 3570 \"parse.y\"\n+#line 3565 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 822:\n-#line 3573 \"parse.y\"\n+#line 3568 \"parse.y\"\n { yyval.ftype.t = build_tree_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 823:\n-#line 3577 \"parse.y\"\n+#line 3572 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 824:\n-#line 3581 \"parse.y\"\n+#line 3576 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 825:\n-#line 3585 \"parse.y\"\n+#line 3580 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 826:\n-#line 3592 \"parse.y\"\n+#line 3587 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 827:\n-#line 3595 \"parse.y\"\n+#line 3590 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 830:\n-#line 3606 \"parse.y\"\n+#line 3601 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 831:\n-#line 3611 \"parse.y\"\n+#line 3606 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 832:\n-#line 3616 \"parse.y\"\n+#line 3611 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7943,192 +7938,192 @@ case 832:\n \t\t;\n     break;}\n case 833:\n-#line 3628 \"parse.y\"\n+#line 3623 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 834:\n-#line 3630 \"parse.y\"\n+#line 3625 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 835:\n-#line 3632 \"parse.y\"\n+#line 3627 \"parse.y\"\n { yyval.ttype = empty_except_spec; ;\n     break;}\n case 836:\n-#line 3637 \"parse.y\"\n+#line 3632 \"parse.y\"\n {\n \t\t  check_for_new_type (\"exception specifier\", yyvsp[0].ftype);\n \t\t  yyval.ttype = groktypename (yyvsp[0].ftype.t);\n \t\t;\n     break;}\n case 837:\n-#line 3645 \"parse.y\"\n+#line 3640 \"parse.y\"\n { yyval.ttype = add_exception_specifier (NULL_TREE, yyvsp[0].ttype, 1); ;\n     break;}\n case 838:\n-#line 3647 \"parse.y\"\n+#line 3642 \"parse.y\"\n { yyval.ttype = add_exception_specifier (yyvsp[-2].ttype, yyvsp[0].ttype, 1); ;\n     break;}\n case 839:\n-#line 3652 \"parse.y\"\n+#line 3647 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 840:\n-#line 3654 \"parse.y\"\n+#line 3649 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 841:\n-#line 3656 \"parse.y\"\n+#line 3651 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 842:\n-#line 3658 \"parse.y\"\n+#line 3653 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 843:\n-#line 3665 \"parse.y\"\n+#line 3660 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 844:\n-#line 3670 \"parse.y\"\n+#line 3665 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 845:\n-#line 3672 \"parse.y\"\n+#line 3667 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 846:\n-#line 3674 \"parse.y\"\n+#line 3669 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 847:\n-#line 3676 \"parse.y\"\n+#line 3671 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 848:\n-#line 3678 \"parse.y\"\n+#line 3673 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 849:\n-#line 3680 \"parse.y\"\n+#line 3675 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 850:\n-#line 3682 \"parse.y\"\n+#line 3677 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 851:\n-#line 3684 \"parse.y\"\n+#line 3679 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 852:\n-#line 3686 \"parse.y\"\n+#line 3681 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 853:\n-#line 3688 \"parse.y\"\n+#line 3683 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 854:\n-#line 3690 \"parse.y\"\n+#line 3685 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 855:\n-#line 3692 \"parse.y\"\n+#line 3687 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 856:\n-#line 3694 \"parse.y\"\n+#line 3689 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 857:\n-#line 3696 \"parse.y\"\n+#line 3691 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 858:\n-#line 3698 \"parse.y\"\n+#line 3693 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 859:\n-#line 3700 \"parse.y\"\n+#line 3695 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 860:\n-#line 3702 \"parse.y\"\n+#line 3697 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 861:\n-#line 3704 \"parse.y\"\n+#line 3699 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 862:\n-#line 3706 \"parse.y\"\n+#line 3701 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 863:\n-#line 3708 \"parse.y\"\n+#line 3703 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 864:\n-#line 3710 \"parse.y\"\n+#line 3705 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 865:\n-#line 3712 \"parse.y\"\n+#line 3707 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 866:\n-#line 3714 \"parse.y\"\n+#line 3709 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 867:\n-#line 3716 \"parse.y\"\n+#line 3711 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 868:\n-#line 3718 \"parse.y\"\n+#line 3713 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 869:\n-#line 3720 \"parse.y\"\n+#line 3715 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 870:\n-#line 3722 \"parse.y\"\n+#line 3717 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 871:\n-#line 3724 \"parse.y\"\n+#line 3719 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 872:\n-#line 3726 \"parse.y\"\n+#line 3721 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 873:\n-#line 3728 \"parse.y\"\n+#line 3723 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 874:\n-#line 3730 \"parse.y\"\n+#line 3725 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 875:\n-#line 3732 \"parse.y\"\n+#line 3727 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 876:\n-#line 3734 \"parse.y\"\n+#line 3729 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 877:\n-#line 3737 \"parse.y\"\n+#line 3732 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 878:\n-#line 3739 \"parse.y\"\n+#line 3734 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -8329,7 +8324,7 @@ case 878:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 3742 \"parse.y\"\n+#line 3737 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "94acf0a78bb00d7196c46fe43fd93fde60111604", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -3397,18 +3397,13 @@ handler_args:\n \n label_colon:\n \t  IDENTIFIER ':'\n-\t\t{ tree label;\n-\t\tdo_label:\n-\t\t  label = define_label (input_filename, lineno, $1);\n-\t\t  if (label && ! minimal_parse_mode)\n-\t\t    expand_label (label);\n-\t\t}\n+                { finish_label_stmt ($1); }\n \t| PTYPENAME ':'\n-\t\t{ goto do_label; }\n+                { finish_label_stmt ($1); }\n \t| TYPENAME ':'\n-\t\t{ goto do_label; }\n+                { finish_label_stmt ($1); }\n \t| SELFNAME ':'\n-\t\t{ goto do_label; }\n+                { finish_label_stmt ($1); }\n \t;\n \n for.init.statement:"}, {"sha": "9dd6096eec852e8928288c1666af7b34ac85a975", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -68,8 +68,6 @@ static tree *template_tail = &pending_templates;\n static tree maybe_templates;\n static tree *maybe_template_tail = &maybe_templates;\n \n-int minimal_parse_mode;\n-\n int processing_specialization;\n int processing_explicit_instantiation;\n int processing_template_parmlist;\n@@ -7233,10 +7231,9 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case LABEL_DECL:\n-      t = define_label (DECL_SOURCE_FILE (t), DECL_SOURCE_LINE (t),\n-\t\t\tDECL_NAME (t));\n-      if (t)\n-\texpand_label (t);\n+      lineno = DECL_SOURCE_LINE (t);\n+      input_filename = DECL_SOURCE_FILE (t);\n+      finish_label_stmt (DECL_NAME (t));\n       break;\n \n     case GOTO_STMT:"}, {"sha": "f464c3342c80cafd753b6bdbbeddea64503fed1b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01b0acb0f151a573750a3401ccd14f11b982263/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f01b0acb0f151a573750a3401ccd14f11b982263", "patch": "@@ -832,6 +832,32 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n     }\n }\n \n+/* Finish a label with the indicated NAME.  */\n+\n+void\n+finish_label_stmt (name)\n+     tree name;\n+{\n+  tree decl;\n+\n+  if (processing_template_decl)\n+    {\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      decl = build_decl (LABEL_DECL, name, void_type_node);\n+      pop_obstacks ();\n+      DECL_SOURCE_LINE (decl) = lineno;\n+      DECL_SOURCE_FILE (decl) = input_filename;\n+      add_tree (decl);\n+    }\n+  else\n+    {\n+      decl = define_label (input_filename, lineno, name);\n+      if (decl)\n+\texpand_label (decl);\n+    }\n+}\n+\n /* Finish a parenthesized expression EXPR.  */\n \n tree"}]}