{"sha": "aba77695fbd92e01ba9aa142cff5bd02b328d878", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJhNzc2OTVmYmQ5MmUwMWJhOWFhMTQyY2ZmNWJkMDJiMzI4ZDg3OA==", "commit": {"author": {"name": "David Wohlferd", "email": "dw@LimeGreenSocks.com", "date": "2015-10-22T20:11:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-22T20:11:29Z"}, "message": "Proposed doc update for Explicit Reg Vars 3/3\n\n\t* doc/extend.exp (Global Register Variables): Rewrite.\n\nFrom-SVN: r229188", "tree": {"sha": "35bae51c1027186c8adc6f8b8f4af75cf7482666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35bae51c1027186c8adc6f8b8f4af75cf7482666"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aba77695fbd92e01ba9aa142cff5bd02b328d878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aba77695fbd92e01ba9aa142cff5bd02b328d878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aba77695fbd92e01ba9aa142cff5bd02b328d878", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aba77695fbd92e01ba9aa142cff5bd02b328d878/comments", "author": null, "committer": null, "parents": [{"sha": "9abe8b744358447b66d579d5592858cfb06c1f75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abe8b744358447b66d579d5592858cfb06c1f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abe8b744358447b66d579d5592858cfb06c1f75"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "bc0183b5efe7ecb5a15c633e886439161d92afc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aba77695fbd92e01ba9aa142cff5bd02b328d878/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aba77695fbd92e01ba9aa142cff5bd02b328d878/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aba77695fbd92e01ba9aa142cff5bd02b328d878", "patch": "@@ -1,3 +1,7 @@\n+2015-10-21  David Wohlferd  <dw@LimeGreenSocks.com>\n+\n+\t* doc/extend.exp (Global Register Variables): Rewrite.\n+\n 2015-10-22  Jeff Law  <law@redhat.com>\n \n \t* genattrtab.c (main): If we do not have any annul-true or annul-false"}, {"sha": "fdb1547ccc8a71612b7d46c44c44611fb8be1b21", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aba77695fbd92e01ba9aa142cff5bd02b328d878/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aba77695fbd92e01ba9aa142cff5bd02b328d878/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=aba77695fbd92e01ba9aa142cff5bd02b328d878", "patch": "@@ -8579,62 +8579,44 @@ should make other arrangements to save the values of the global register\n variables, and to restore them in a @code{longjmp}. This way, the same\n thing happens regardless of what @code{longjmp} does.\n \n+Eventually there may be a way of asking the compiler to choose a register \n+automatically, but first we need to figure out how it should choose and \n+how to enable you to guide the choice.  No solution is evident.\n+\n @node Local Register Variables\n @subsubsection Specifying Registers for Local Variables\n @anchor{Local Reg Vars}\n @cindex local variables, specifying registers\n @cindex specifying registers for local variables\n @cindex registers for local variables\n \n-You can define a local register variable with a specified register\n-like this:\n+You can define a local register variable and associate it with a specified \n+register like this:\n \n @smallexample\n-register int *foo asm (\"a5\");\n+register int *foo asm (\"r12\");\n @end smallexample\n \n @noindent\n-Here @code{a5} is the name of the register that should be used.  Note\n-that this is the same syntax used for defining global register\n-variables, but for a local variable it appears within a function.\n-\n-Naturally the register name is CPU-dependent, but this is not a\n-problem, since specific registers are most often useful with explicit\n-assembler instructions (@pxref{Extended Asm}).  Both of these things\n-generally require that you conditionalize your program according to\n-CPU type.\n-\n-In addition, operating systems on one type of CPU may differ in how they\n-name the registers; then you need additional conditionals.  For\n-example, some 68000 operating systems call this register @code{%a5}.\n-\n-Defining such a register variable does not reserve the register; it\n-remains available for other uses in places where flow control determines\n-the variable's value is not live.\n-\n-This option does not guarantee that GCC generates code that has\n-this variable in the register you specify at all times.  You may not\n-code an explicit reference to this register in the assembler\n-instruction template part of an @code{asm} statement and assume it\n-always refers to this variable.\n-However, using the variable as an input or output operand to the @code{asm}\n-guarantees that the specified register is used for that operand.  \n-@xref{Extended Asm}, for more information.\n-\n-Stores into local register variables may be deleted when they appear to be dead\n-according to dataflow analysis.  References to local register variables may\n-be deleted or moved or simplified.\n-\n-As with global register variables, it is recommended that you choose a\n-register that is normally saved and restored by function calls on\n-your machine, so that library routines will not clobber it.  \n-\n-Sometimes when writing inline @code{asm} code, you need to make an operand be a \n-specific register, but there's no matching constraint letter for that \n-register. To force the operand into that register, create a local variable \n-and specify the register in the variable's declaration. Then use the local \n-variable for the asm operand and specify any constraint letter that matches \n-the register:\n+Here @code{r12} is the name of the register that should be used.  Note\n+that this is the same syntax used for defining global register variables, \n+but for a local variable the declaration appears within a function.  The \n+@code{register} keyword is required, and cannot be combined with \n+@code{static}.  The register name must be a valid register name for the\n+target platform.\n+\n+As with global register variables, it is recommended that you choose \n+a register that is normally saved and restored by function calls on your \n+machine, so that calls to library routines will not clobber it.\n+\n+The only supported use for this feature is to specify registers\n+for input and output operands when calling Extended @code{asm} \n+(@pxref{Extended Asm}).  This may be necessary if the constraints for a \n+particular machine don't provide sufficient control to select the desired \n+register.  To force an operand into a register, create a local variable \n+and specify the register name after the variable's declaration.  Then use \n+the local variable for the @code{asm} operand and specify any constraint \n+letter that matches the register:\n \n @smallexample\n register int *p1 asm (\"r0\") = @dots{};\n@@ -8643,11 +8625,11 @@ register int *result asm (\"r0\");\n asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n @end smallexample\n \n-@emph{Warning:} In the above example, be aware that a register (for example r0) can be \n-call-clobbered by subsequent code, including function calls and library calls \n-for arithmetic operators on other variables (for example the initialization \n-of p2). In this case, use temporary variables for expressions between the \n-register assignments:\n+@emph{Warning:} In the above example, be aware that a register (for example \n+@code{r0}) can be call-clobbered by subsequent code, including function \n+calls and library calls for arithmetic operators on other variables (for \n+example the initialization of @code{p2}).  In this case, use temporary \n+variables for expressions between the register assignments:\n \n @smallexample\n int t1 = @dots{};\n@@ -8657,6 +8639,35 @@ register int *result asm (\"r0\");\n asm (\"sysint\" : \"=r\" (result) : \"0\" (p1), \"r\" (p2));\n @end smallexample\n \n+Defining a register variable does not reserve the register.  Other than\n+when invoking the Extended @code{asm}, the contents of the specified \n+register are not guaranteed.  For this reason, the following uses \n+are explicitly @emph{not} supported.  If they appear to work, it is only \n+happenstance, and may stop working as intended due to (seemingly) \n+unrelated changes in surrounding code, or even minor changes in the \n+optimization of a future version of gcc:\n+\n+@itemize @bullet\n+@item Passing parameters to or from Basic @code{asm}\n+@item Passing parameters to or from Extended @code{asm} without using input \n+or output operands.\n+@item Passing parameters to or from routines written in assembler (or\n+other languages) using non-standard calling conventions.\n+@end itemize\n+\n+Some developers use Local Register Variables in an attempt to improve \n+gcc's allocation of registers, especially in large functions.  In this \n+case the register name is essentially a hint to the register allocator.\n+While in some instances this can generate better code, improvements are\n+subject to the whims of the allocator/optimizers.  Since there are no\n+guarantees that your improvements won't be lost, this usage of Local\n+Register Variables is discouraged.\n+\n+On the MIPS platform, there is related use for local register variables \n+with slightly different characteristics (@pxref{MIPS Coprocessors,, \n+Defining coprocessor specifics for MIPS targets, gccint, \n+GNU Compiler Collection (GCC) Internals}).\n+\n @node Size of an asm\n @subsection Size of an @code{asm}\n "}]}