{"sha": "3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q5YjQ3ZGM0MzFjMGU4Yjk2N2YzOTBmMjhhNjhmZTM3MWQ0N2ViNA==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2007-06-20T18:19:10Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2007-06-20T18:19:10Z"}, "message": "re PR tree-optimization/25737 (ACATS c974001 c974013 hang with struct aliasing)\n\n\tPR tree-optimization/25737\n\t* tree.h (struct tree_struct_field_tag): Add new field alias_set.\n\t(SFT_NONADDRESSABLE_P, SFT_ALIAS_SET): New macros.\n\t* tree-flow.h (struct fieldoff): Add new field alias_set.\n\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Add new\n\targument addressable_type.  Set alias_set of fieldoff.\n\t* tree-ssa-alias.c (create_sft): Add new argument alias_set.\n\t(create_overlap_variables_for): Pass alias_set from fieldoff to\n\tcreate_sft.\n\t* alias.c (get_alias_set): Use alias_set from SFT if set.\n\nFrom-SVN: r125890", "tree": {"sha": "9e2d4808d596fbdc61945b54d0c37a41b151ec67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e2d4808d596fbdc61945b54d0c37a41b151ec67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/comments", "author": null, "committer": null, "parents": [{"sha": "034bfe7a9f51a82d1eadeb037791e5f467395eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/034bfe7a9f51a82d1eadeb037791e5f467395eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/034bfe7a9f51a82d1eadeb037791e5f467395eba"}], "stats": {"total": 65, "additions": 55, "deletions": 10}, "files": [{"sha": "95789e56955d14611381f6387841373a5ed90e72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "patch": "@@ -1,3 +1,16 @@\n+2007-06-20  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\tPR tree-optimization/25737\n+\t* tree.h (struct tree_struct_field_tag): Add new field alias_set.\n+\t(SFT_NONADDRESSABLE_P, SFT_ALIAS_SET): New macros.\n+\t* tree-flow.h (struct fieldoff): Add new field alias_set.\n+\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Add new\n+\targument addressable_type.  Set alias_set of fieldoff.\n+\t* tree-ssa-alias.c (create_sft): Add new argument alias_set.\n+\t(create_overlap_variables_for): Pass alias_set from fieldoff to\n+\tcreate_sft.\n+\t* alias.c (get_alias_set): Use alias_set from SFT if set.\n+\n 2007-06-20  Hui-May Chang  <hm.chang@apple.com>\n \n \t* config/i386/darwin.h (ASM_OUTPUT_COMMON): Print the size"}, {"sha": "8064b8e087a44a275afc35971bec4b985a176b22", "filename": "gcc/alias.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "patch": "@@ -586,6 +586,13 @@ get_alias_set (tree t)\n \t    return 0;\n \t}\n \n+      /* For non-addressable fields we return the alias set of the\n+\t outermost object that could have its address taken.  If this\n+\t is an SFT use the precomputed value.  */\n+      if (TREE_CODE (t) == STRUCT_FIELD_TAG\n+\t  && SFT_NONADDRESSABLE_P (t))\n+\treturn SFT_ALIAS_SET (t);\n+\n       /* Otherwise, pick up the outermost object that we could have a pointer\n \t to, processing conversions as above.  */\n       while (component_uses_parent_alias_set (t))"}, {"sha": "0af3bdc39559b80bc170b70d16d66c5258b104bb", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "patch": "@@ -1158,13 +1158,14 @@ struct fieldoff\n   tree size;\n   tree decl;\n   HOST_WIDE_INT offset;  \n+  HOST_WIDE_INT alias_set;\n };\n typedef struct fieldoff fieldoff_s;\n \n DEF_VEC_O(fieldoff_s);\n DEF_VEC_ALLOC_O(fieldoff_s,heap);\n int push_fields_onto_fieldstack (tree, VEC(fieldoff_s,heap) **,\n-\t\t\t\t HOST_WIDE_INT, bool *);\n+\t\t\t\t HOST_WIDE_INT, bool *, tree);\n void sort_fieldstack (VEC(fieldoff_s,heap) *);\n \n void init_alias_heapvars (void);"}, {"sha": "46c17ea68b177465106999fcbe1fde6e724d27d7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "patch": "@@ -3646,11 +3646,13 @@ get_or_create_used_part_for (size_t uid)\n \n \n /* Create and return a structure sub-variable for field type FIELD at\n-   offset OFFSET, with size SIZE, of variable VAR.  */\n+   offset OFFSET, with size SIZE, of variable VAR.  If ALIAS_SET not\n+   -1 this field is non-addressable and we should use this alias set\n+   with this field.  */\n \n static tree\n create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n-\t    unsigned HOST_WIDE_INT size)\n+\t    unsigned HOST_WIDE_INT size, HOST_WIDE_INT alias_set)\n {\n   tree subvar = create_tag_raw (STRUCT_FIELD_TAG, field, \"SFT\");\n \n@@ -3669,6 +3671,7 @@ create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n   SFT_PARENT_VAR (subvar) = var;\n   SFT_OFFSET (subvar) = offset;\n   SFT_SIZE (subvar) = size;\n+  SFT_ALIAS_SET (subvar) = alias_set;\n   return subvar;\n }\n \n@@ -3688,7 +3691,8 @@ create_overlap_variables_for (tree var)\n       || up->write_only)\n     return;\n \n-  push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0, NULL);\n+  push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0, NULL,\n+\t\t\t       TREE_TYPE (var));\n   if (VEC_length (fieldoff_s, fieldstack) != 0)\n     {\n       subvar_t *subvars;\n@@ -3780,7 +3784,8 @@ create_overlap_variables_for (tree var)\n \t    continue;\n \t  sv = GGC_NEW (struct subvar);\n \t  sv->next = *subvars;\n-\t  sv->var = create_sft (var, fo->type, fo->offset, fosize);\n+\t  sv->var =\n+\t    create_sft (var, fo->type, fo->offset, fosize, fo->alias_set);\n \n \t  if (dump_file)\n \t    {"}, {"sha": "ddd7de3eb6c06bb826f704b65d8d3a99961ca27e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "patch": "@@ -3695,11 +3695,13 @@ sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n    than just the immediately containing structure.  Returns the number\n    of fields pushed.\n    HAS_UNION is set to true if we find a union type as a field of\n-   TYPE.  */\n+   TYPE.  ADDRESSABLE_TYPE is the type of the outermost object that could have\n+   its address taken.  */\n \n int\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n-\t\t\t     HOST_WIDE_INT offset, bool *has_union)\n+\t\t\t     HOST_WIDE_INT offset, bool *has_union,\n+\t\t\t     tree addressable_type)\n {\n   tree field;\n   int count = 0;\n@@ -3712,12 +3714,14 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n       real_part->size = TYPE_SIZE (TREE_TYPE (type));\n       real_part->offset = offset;\n       real_part->decl = NULL_TREE;\n+      real_part->alias_set = -1;\n \n       img_part = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n       img_part->type = TREE_TYPE (type);\n       img_part->size = TYPE_SIZE (TREE_TYPE (type));\n       img_part->offset = offset + TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (type)));\n       img_part->decl = NULL_TREE;\n+      img_part->alias_set = -1;\n \n       return 2;\n     }\n@@ -3755,7 +3759,8 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t    push = true;\n \t  else if (!(pushed = push_fields_onto_fieldstack\n \t\t     (TREE_TYPE (type), fieldstack,\n-\t\t      offset + i * TREE_INT_CST_LOW (elsz), has_union)))\n+\t\t      offset + i * TREE_INT_CST_LOW (elsz), has_union,\n+\t\t      TREE_TYPE (type))))\n \t    /* Empty structures may have actual size, like in C++. So\n \t       see if we didn't push any subfields and the size is\n \t       nonzero, push the field onto the stack */\n@@ -3770,6 +3775,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t      pair->size = elsz;\n \t      pair->decl = NULL_TREE;\n \t      pair->offset = offset + i * TREE_INT_CST_LOW (elsz);\n+\t      pair->alias_set = -1;\n \t      count++;\n \t    }\n \t  else\n@@ -3794,7 +3800,10 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t  push = true;\n \telse if (!(pushed = push_fields_onto_fieldstack\n \t\t   (TREE_TYPE (field), fieldstack,\n-\t\t    offset + bitpos_of_field (field), has_union))\n+\t\t    offset + bitpos_of_field (field), has_union,\n+\t\t    (DECL_NONADDRESSABLE_P (field)\n+\t\t     ? addressable_type\n+\t\t     : TREE_TYPE (field))))\n \t\t && DECL_SIZE (field)\n \t\t && !integer_zerop (DECL_SIZE (field)))\n \t  /* Empty structures may have actual size, like in C++. So\n@@ -3811,6 +3820,10 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t    pair->size = DECL_SIZE (field);\n \t    pair->decl = field;\n \t    pair->offset = offset + bitpos_of_field (field);\n+\t    if (DECL_NONADDRESSABLE_P (field))\n+\t      pair->alias_set = get_alias_set (addressable_type);\n+\t    else\n+\t      pair->alias_set = -1;\n \t    count++;\n \t  }\n \telse\n@@ -4009,7 +4022,8 @@ create_variable_info_for (tree decl, const char *name)\n \t     || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n   if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n-      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion);\n+      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion,\n+\t\t\t\t   decltype);\n       if (hasunion)\n \t{\n \t  VEC_free (fieldoff_s, heap, fieldstack);"}, {"sha": "e6f1cee3c9fc7eae3da9b7dee4f9c1cb73eacf0d", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9b47dc431c0e8b967f390f28a68fe371d47eb4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3d9b47dc431c0e8b967f390f28a68fe371d47eb4", "patch": "@@ -2516,10 +2516,15 @@ struct tree_struct_field_tag GTY(())\n   /* Size of the field.  */\n   unsigned HOST_WIDE_INT size;\n \n+  /* Alias set for a DECL_NONADDRESSABLE_P field.  Otherwise -1.  */\n+  HOST_WIDE_INT alias_set;\n };\n #define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.parent_var)\n #define SFT_OFFSET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.offset)\n #define SFT_SIZE(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.size)\n+#define SFT_NONADDRESSABLE_P(NODE) \\\n+  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set != -1)\n+#define SFT_ALIAS_SET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set)\n \n /* Memory Partition Tags (MPTs) group memory symbols under one\n    common name for the purposes of placing memory PHI nodes.  */"}]}