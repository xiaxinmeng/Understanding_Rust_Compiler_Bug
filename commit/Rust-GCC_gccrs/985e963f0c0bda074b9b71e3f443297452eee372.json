{"sha": "985e963f0c0bda074b9b71e3f443297452eee372", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg1ZTk2M2YwYzBiZGEwNzRiOWI3MWUzZjQ0MzI5NzQ1MmVlZTM3Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-08T06:28:10Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-08T06:28:10Z"}, "message": "re PR middle-end/54146 (Very slow compile with attribute((flatten)))\n\n\tPR middle-end/54146\n\t* ifcvt.c: Include pointer-set.h.\n\t(cond_move_process_if_block): Change type of then_regs and\n\telse_regs from alloca'd array to pointer_sets.\n\t(check_cond_move_block): Update for this change.\n\t(cond_move_convert_if_block): Likewise.\n\t* Makefile.in: Fix dependencies for ifcvt.o.\n\nFrom-SVN: r190222", "tree": {"sha": "82e886e351ca4835a560129283dc5555881e17be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82e886e351ca4835a560129283dc5555881e17be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/985e963f0c0bda074b9b71e3f443297452eee372", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985e963f0c0bda074b9b71e3f443297452eee372", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985e963f0c0bda074b9b71e3f443297452eee372", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985e963f0c0bda074b9b71e3f443297452eee372/comments", "author": null, "committer": null, "parents": [{"sha": "88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ca9ea18f36fca948a0ca25a1762c9ec0230eac"}], "stats": {"total": 135, "additions": 71, "deletions": 64}, "files": [{"sha": "bb7d9c61b4915b73a36a266d2fac0eabaf420566", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985e963f0c0bda074b9b71e3f443297452eee372/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985e963f0c0bda074b9b71e3f443297452eee372/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=985e963f0c0bda074b9b71e3f443297452eee372", "patch": "@@ -1,3 +1,13 @@\n+2012-08-08  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/54146\n+\t* ifcvt.c: Include pointer-set.h.\n+\t(cond_move_process_if_block): Change type of then_regs and\n+\telse_regs from alloca'd array to pointer_sets.\n+\t(check_cond_move_block): Update for this change.\n+\t(cond_move_convert_if_block): Likewise.\n+\t* Makefile.in: Fix dependencies for ifcvt.o.\n+\n 2012-08-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gimple-ssa-strength-reduction.c (struct incr_info_d): New struct."}, {"sha": "bbd8cb1be97515f86c75e80b8d0ba42d06f83058", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985e963f0c0bda074b9b71e3f443297452eee372/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985e963f0c0bda074b9b71e3f443297452eee372/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=985e963f0c0bda074b9b71e3f443297452eee372", "patch": "@@ -3350,7 +3350,7 @@ regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) insn-config.h $(FUNCTION_H) $(RECOG_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h $(EXCEPT_H) $(TM_P_H) \\\n-   $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h \\\n+   $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h pointer-set.h \\\n    $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(COMMON_TARGET_H) \\\n    $(PARAMS_H) $(DIAGNOSTIC_CORE_H)"}, {"sha": "fd3e929426b7b0054ea9742771239a05cd818274", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985e963f0c0bda074b9b71e3f443297452eee372/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985e963f0c0bda074b9b71e3f443297452eee372/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=985e963f0c0bda074b9b71e3f443297452eee372", "patch": "@@ -43,6 +43,7 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"vec.h\"\n+#include \"pointer-set.h\"\n #include \"vecprim.h\"\n #include \"dbgcnt.h\"\n \n@@ -2687,12 +2688,14 @@ noce_process_if_block (struct noce_if_info *if_info)\n \n /* Check whether a block is suitable for conditional move conversion.\n    Every insn must be a simple set of a register to a constant or a\n-   register.  For each assignment, store the value in the array VALS,\n-   indexed by register number, then store the register number in\n-   REGS.  COND is the condition we will test.  */\n+   register.  For each assignment, store the value in the pointer map\n+   VALS, keyed indexed by register pointer, then store the register\n+   pointer in REGS.  COND is the condition we will test.  */\n \n static int\n-check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs,\n+check_cond_move_block (basic_block bb,\n+\t\t       struct pointer_map_t *vals,\n+\t\t       VEC (rtx, heap) **regs,\n \t\t       rtx cond)\n {\n   rtx insn;\n@@ -2706,6 +2709,7 @@ check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs,\n   FOR_BB_INSNS (bb, insn)\n     {\n       rtx set, dest, src;\n+      void **slot;\n \n       if (!NONDEBUG_INSN_P (insn) || JUMP_P (insn))\n \tcontinue;\n@@ -2732,14 +2736,14 @@ check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs,\n       /* Don't try to handle this if the source register was\n \t modified earlier in the block.  */\n       if ((REG_P (src)\n-\t   && vals[REGNO (src)] != NULL)\n+\t   && pointer_map_contains (vals, src))\n \t  || (GET_CODE (src) == SUBREG && REG_P (SUBREG_REG (src))\n-\t      && vals[REGNO (SUBREG_REG (src))] != NULL))\n+\t      && pointer_map_contains (vals, SUBREG_REG (src))))\n \treturn FALSE;\n \n       /* Don't try to handle this if the destination register was\n \t modified earlier in the block.  */\n-      if (vals[REGNO (dest)] != NULL)\n+      if (pointer_map_contains (vals, dest))\n \treturn FALSE;\n \n       /* Don't try to handle this if the condition uses the\n@@ -2753,25 +2757,27 @@ check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs,\n \t  && modified_between_p (src, insn, NEXT_INSN (BB_END (bb))))\n \treturn FALSE;\n \n-      vals[REGNO (dest)] = src;\n+      slot = pointer_map_insert (vals, (void *) dest);\n+      *slot = (void *) src;\n \n-      VEC_safe_push (int, heap, *regs, REGNO (dest));\n+      VEC_safe_push (rtx, heap, *regs, dest);\n     }\n \n   return TRUE;\n }\n \n /* Given a basic block BB suitable for conditional move conversion,\n-   a condition COND, and arrays THEN_VALS and ELSE_VALS containing the\n-   register values depending on COND, emit the insns in the block as\n+   a condition COND, and pointer maps THEN_VALS and ELSE_VALS containing\n+   the register values depending on COND, emit the insns in the block as\n    conditional moves.  If ELSE_BLOCK is true, THEN_BB was already\n    processed.  The caller has started a sequence for the conversion.\n    Return true if successful, false if something goes wrong.  */\n \n static bool\n cond_move_convert_if_block (struct noce_if_info *if_infop,\n \t\t\t    basic_block bb, rtx cond,\n-\t\t\t    rtx *then_vals, rtx *else_vals,\n+\t\t\t    struct pointer_map_t *then_vals,\n+\t\t\t    struct pointer_map_t *else_vals,\n \t\t\t    bool else_block_p)\n {\n   enum rtx_code code;\n@@ -2784,7 +2790,7 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n   FOR_BB_INSNS (bb, insn)\n     {\n       rtx set, target, dest, t, e;\n-      unsigned int regno;\n+      void **then_slot, **else_slot;\n \n       /* ??? Maybe emit conditional debug insn?  */\n       if (!NONDEBUG_INSN_P (insn) || JUMP_P (insn))\n@@ -2793,10 +2799,11 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n       gcc_assert (set && REG_P (SET_DEST (set)));\n \n       dest = SET_DEST (set);\n-      regno = REGNO (dest);\n \n-      t = then_vals[regno];\n-      e = else_vals[regno];\n+      then_slot = pointer_map_contains (then_vals, dest);\n+      else_slot = pointer_map_contains (else_vals, dest);\n+      t = then_slot ? (rtx) *then_slot : NULL_RTX;\n+      e = else_slot ? (rtx) *else_slot : NULL_RTX;\n \n       if (else_block_p)\n \t{\n@@ -2840,31 +2847,25 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   rtx jump = if_info->jump;\n   rtx cond = if_info->cond;\n   rtx seq, loc_insn;\n-  int max_reg, size, c, reg;\n-  rtx *then_vals;\n-  rtx *else_vals;\n-  VEC (int, heap) *then_regs = NULL;\n-  VEC (int, heap) *else_regs = NULL;\n+  rtx reg;\n+  int c;\n+  struct pointer_map_t *then_vals;\n+  struct pointer_map_t *else_vals;\n+  VEC (rtx, heap) *then_regs = NULL;\n+  VEC (rtx, heap) *else_regs = NULL;\n   unsigned int i;\n+  int success_p = FALSE;\n \n   /* Build a mapping for each block to the value used for each\n      register.  */\n-  max_reg = max_reg_num ();\n-  size = (max_reg + 1) * sizeof (rtx);\n-  then_vals = (rtx *) alloca (size);\n-  else_vals = (rtx *) alloca (size);\n-  memset (then_vals, 0, size);\n-  memset (else_vals, 0, size);\n+  then_vals = pointer_map_create ();\n+  else_vals = pointer_map_create ();\n \n   /* Make sure the blocks are suitable.  */\n   if (!check_cond_move_block (then_bb, then_vals, &then_regs, cond)\n       || (else_bb\n \t  && !check_cond_move_block (else_bb, else_vals, &else_regs, cond)))\n-    {\n-      VEC_free (int, heap, then_regs);\n-      VEC_free (int, heap, else_regs);\n-      return FALSE;\n-    }\n+    goto done;\n \n   /* Make sure the blocks can be used together.  If the same register\n      is set in both blocks, and is not set to a constant in both\n@@ -2873,41 +2874,38 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n      source register does not change after the assignment.  Also count\n      the number of registers set in only one of the blocks.  */\n   c = 0;\n-  FOR_EACH_VEC_ELT (int, then_regs, i, reg)\n+  FOR_EACH_VEC_ELT (rtx, then_regs, i, reg)\n     {\n-      if (!then_vals[reg] && !else_vals[reg])\n-\tcontinue;\n+      void **then_slot = pointer_map_contains (then_vals, reg);\n+      void **else_slot = pointer_map_contains (else_vals, reg);\n \n-      if (!else_vals[reg])\n+      gcc_checking_assert (then_slot);\n+      if (!else_slot)\n \t++c;\n       else\n \t{\n-\t  if (!CONSTANT_P (then_vals[reg])\n-\t      && !CONSTANT_P (else_vals[reg])\n-\t      && !rtx_equal_p (then_vals[reg], else_vals[reg]))\n-\t    {\n-\t      VEC_free (int, heap, then_regs);\n-\t      VEC_free (int, heap, else_regs);\n-\t      return FALSE;\n-\t    }\n+\t  rtx then_val = (rtx) *then_slot;\n+\t  rtx else_val = (rtx) *else_slot;\n+\t  if (!CONSTANT_P (then_val) && !CONSTANT_P (else_val)\n+\t      && !rtx_equal_p (then_val, else_val))\n+\t    goto done;\n \t}\n     }\n \n   /* Finish off c for MAX_CONDITIONAL_EXECUTE.  */\n-  FOR_EACH_VEC_ELT (int, else_regs, i, reg)\n-    if (!then_vals[reg])\n-      ++c;\n+  FOR_EACH_VEC_ELT (rtx, else_regs, i, reg)\n+    {\n+      gcc_checking_assert (pointer_map_contains (else_vals, reg));\n+      if (!pointer_map_contains (then_vals, reg))\n+\t++c;\n+    }\n \n   /* Make sure it is reasonable to convert this block.  What matters\n      is the number of assignments currently made in only one of the\n      branches, since if we convert we are going to always execute\n      them.  */\n   if (c > MAX_CONDITIONAL_EXECUTE)\n-    {\n-      VEC_free (int, heap, then_regs);\n-      VEC_free (int, heap, else_regs);\n-      return FALSE;\n-    }\n+    goto done;\n \n   /* Try to emit the conditional moves.  First do the then block,\n      then do anything left in the else blocks.  */\n@@ -2919,17 +2917,11 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n \t\t\t\t\t  then_vals, else_vals, true)))\n     {\n       end_sequence ();\n-      VEC_free (int, heap, then_regs);\n-      VEC_free (int, heap, else_regs);\n-      return FALSE;\n+      goto done;\n     }\n   seq = end_ifcvt_sequence (if_info);\n   if (!seq)\n-    {\n-      VEC_free (int, heap, then_regs);\n-      VEC_free (int, heap, else_regs);\n-      return FALSE;\n-    }\n+    goto done;\n \n   loc_insn = first_active_insn (then_bb);\n   if (!loc_insn)\n@@ -2960,9 +2952,14 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n \n   num_updated_if_blocks++;\n \n-  VEC_free (int, heap, then_regs);\n-  VEC_free (int, heap, else_regs);\n-  return TRUE;\n+  success_p = TRUE;\n+\n+done:\n+  pointer_map_destroy (then_vals);\n+  pointer_map_destroy (else_vals);\n+  VEC_free (rtx, heap, then_regs);\n+  VEC_free (rtx, heap, else_regs);\n+  return success_p;\n }\n \n \f"}]}