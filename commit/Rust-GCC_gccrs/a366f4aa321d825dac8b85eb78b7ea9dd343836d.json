{"sha": "a366f4aa321d825dac8b85eb78b7ea9dd343836d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2NmY0YWEzMjFkODI1ZGFjOGI4NWViNzhiN2VhOWRkMzQzODM2ZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-09-26T15:14:21Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-09-26T15:14:21Z"}, "message": "RoundRectangle2D.java (getPathIterator): Wrote.\n\n\t* java/awt/geom/RoundRectangle2D.java (getPathIterator): Wrote.\n\t* java/awt/geom/PathIterator.java: Documentation fixes.\n\nFrom-SVN: r71820", "tree": {"sha": "b1fb22ae9175ffe0e3adc1dffba1e131f853ac9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1fb22ae9175ffe0e3adc1dffba1e131f853ac9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a366f4aa321d825dac8b85eb78b7ea9dd343836d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a366f4aa321d825dac8b85eb78b7ea9dd343836d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a366f4aa321d825dac8b85eb78b7ea9dd343836d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a366f4aa321d825dac8b85eb78b7ea9dd343836d/comments", "author": null, "committer": null, "parents": [{"sha": "9f5e2e11084caae56b3b00feffd6a462b385afeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f5e2e11084caae56b3b00feffd6a462b385afeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f5e2e11084caae56b3b00feffd6a462b385afeb"}], "stats": {"total": 174, "additions": 167, "deletions": 7}, "files": [{"sha": "cd6508fcd087ade49d32460817ed8113a6b60f67", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a366f4aa321d825dac8b85eb78b7ea9dd343836d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a366f4aa321d825dac8b85eb78b7ea9dd343836d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a366f4aa321d825dac8b85eb78b7ea9dd343836d", "patch": "@@ -1,3 +1,8 @@\n+2003-09-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/awt/geom/RoundRectangle2D.java (getPathIterator): Wrote.\n+\t* java/awt/geom/PathIterator.java: Documentation fixes.\n+\n 2003-09-25  Jeff Sturm  <jsturm@one-point.com>\n \n \t* gnu/java/nio/SelectorImpl.java (getFDsAsArray): Use getNativeFD()."}, {"sha": "1d47431c30dd48aace1e87e39efd80d71715318b", "filename": "libjava/java/awt/geom/PathIterator.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a366f4aa321d825dac8b85eb78b7ea9dd343836d/libjava%2Fjava%2Fawt%2Fgeom%2FPathIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a366f4aa321d825dac8b85eb78b7ea9dd343836d/libjava%2Fjava%2Fawt%2Fgeom%2FPathIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FPathIterator.java?ref=a366f4aa321d825dac8b85eb78b7ea9dd343836d", "patch": "@@ -1,5 +1,5 @@\n /* PathIterator.java -- describes a shape by iterating over its vertices\n-   Copyright (C) 2000, 2002 Free Software Foundation\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -125,7 +125,7 @@\n   int getWindingRule();\n \n   /**\n-   * Tests if the iterator is exhausted. If this returns false, currentSegment\n+   * Tests if the iterator is exhausted. If this returns true, currentSegment\n    * and next may throw a NoSuchElementException (although this is not\n    * required).\n    *\n@@ -135,7 +135,7 @@\n \n   /**\n    * Advance to the next segment in the iteration. It is not specified what\n-   * this does if called when isDone() returns false.\n+   * this does if called when isDone() returns true.\n    *\n    * @throws java.util.NoSuchElementException optional when isDone() is true\n    */"}, {"sha": "3a7899d3ed5bb786085de4e4d4c331588f1ada61", "filename": "libjava/java/awt/geom/RoundRectangle2D.java", "status": "modified", "additions": 159, "deletions": 4, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a366f4aa321d825dac8b85eb78b7ea9dd343836d/libjava%2Fjava%2Fawt%2Fgeom%2FRoundRectangle2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a366f4aa321d825dac8b85eb78b7ea9dd343836d/libjava%2Fjava%2Fawt%2Fgeom%2FRoundRectangle2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FRoundRectangle2D.java?ref=a366f4aa321d825dac8b85eb78b7ea9dd343836d", "patch": "@@ -1,5 +1,5 @@\n /* RoundRectangle2D.java -- represents a rectangle with rounded corners\n-   Copyright (C) 2000, 2002 Free Software Foundation\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,8 @@\n \n package java.awt.geom;\n \n+import java.util.NoSuchElementException;\n+\n /** This class implements a rectangle with rounded corners.\n  * @author Tom Tromey <tromey@cygnus.com>\n  * @date December 3, 2000\n@@ -117,10 +119,163 @@ public boolean contains(double x, double y, double w, double h)\n   /** Return a new path iterator which iterates over this rectangle.\n    * @param at An affine transform to apply to the object\n    */\n-  public PathIterator getPathIterator(AffineTransform at)\n+  public PathIterator getPathIterator(final AffineTransform at)\n   {\n-    // FIXME.\n-    return null;\n+    final double minx = getX();\n+    final double miny = getY();\n+    final double maxx = minx + getWidth();\n+    final double maxy = miny + getHeight();\n+    final double arcwidth = getArcWidth();\n+    final double archeight = getArcHeight();\n+    return new PathIterator()\n+    {\n+      /** We iterate clockwise around the rectangle, starting in the\n+       * upper left.  This variable tracks our current point, which\n+       * can be on either side of a given corner.  */\n+      private int current = 0;\n+\n+      /** Child path iterator, used for corners.  */\n+      private PathIterator corner;\n+\n+      /** This is used when rendering the corners.  We re-use the arc\n+       * for each corner.  */\n+      private Arc2D arc = new Arc2D.Double();\n+\n+      /** Temporary array used by getPoint.  */\n+      private double[] temp = new double[2];\n+\n+      public int getWindingRule()\n+      {\n+\treturn WIND_NON_ZERO;\n+      }\n+\n+      public boolean isDone()\n+      {\n+\treturn current > 9;\n+      }\n+\n+      private void getPoint(int val)\n+      {\n+\tswitch (val)\n+\t  {\n+\t  case 0:\n+\t  case 8:\n+\t    temp[0] = minx;\n+\t    temp[1] = miny + archeight;\n+\t    break;\n+\t  case 1:\n+\t    temp[0] = minx + arcwidth;\n+\t    temp[1] = miny;\n+\t    break;\n+\t  case 2:\n+\t    temp[0] = maxx - arcwidth;\n+\t    temp[1] = maxy;\n+\t    break;\n+\t  case 3:\n+\t    temp[0] = maxx;\n+\t    temp[1] = miny + archeight;\n+\t    break;\n+\t  case 4:\n+\t    temp[0] = maxx;\n+\t    temp[1] = maxy - archeight;\n+\t    break;\n+\t  case 5:\n+\t    temp[0] = maxx - arcwidth;\n+\t    temp[1] = maxy;\n+\t    break;\n+\t  case 6:\n+\t    temp[0] = minx + arcwidth;\n+\t    temp[1] = maxy;\n+\t    break;\n+\t  case 7:\n+\t    temp[0] = minx;\n+\t    temp[1] = maxy - archeight;\n+\t    break;\n+\t  }\n+      }\n+\n+      public void next()\n+      {\n+\tif (current >= 8)\n+\t  ++current;\n+\telse if (corner != null)\n+\t  {\n+\t    // We're iterating through the corner.  Work on the child\n+\t    // iterator; if it finishes, reset and move to the next\n+\t    // point along the rectangle.\n+\t    corner.next();\n+\t    if (corner.isDone())\n+\t      {\n+\t\tcorner = null;\n+\t\t++current;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // Make an arc between this point on the rectangle and\n+\t    // the next one, and then iterate over this arc.\n+\t    getPoint(current);\n+\t    double x1 = temp[0];\n+\t    double y1 = temp[1];\n+\t    getPoint(current + 1);\n+\t    arc.setFrameFromDiagonal(x1, y1, temp[0], temp[1]);\n+\t    arc.setAngles(x1, y1, temp[0], temp[1]);\n+\t    corner = arc.getPathIterator(at);\n+\t  }\n+      }\n+\n+      public int currentSegment(float[] coords)\n+      {\n+\tif (corner != null)\n+\t  {\n+\t    int r = corner.currentSegment(coords);\n+\t    if (r == SEG_MOVETO)\n+\t      r = SEG_LINETO;\n+\t    return r;\n+\t  }\n+\n+\tif (current < 9)\n+\t  {\n+\t    getPoint(current);\n+\t    coords[0] = (float) temp[0];\n+\t    coords[1] = (float) temp[1];\n+\t  }\n+\telse if (current == 9)\n+\t  return SEG_CLOSE;\n+\telse\n+\t  throw new NoSuchElementException(\"rect iterator out of bounds\");\n+\n+\tif (at != null)\n+\t  at.transform(coords, 0, coords, 0, 1);\n+\treturn current == 0 ? SEG_MOVETO : SEG_LINETO;\n+      }\n+\n+      public int currentSegment(double[] coords)\n+      {\n+\tif (corner != null)\n+\t  {\n+\t    int r = corner.currentSegment(coords);\n+\t    if (r == SEG_MOVETO)\n+\t      r = SEG_LINETO;\n+\t    return r;\n+\t  }\n+\n+\tif (current < 9)\n+\t  {\n+\t    getPoint(current);\n+\t    coords[0] = temp[0];\n+\t    coords[1] = temp[1];\n+\t  }\n+\telse if (current == 9)\n+\t  return SEG_CLOSE;\n+\telse\n+\t  throw new NoSuchElementException(\"rect iterator out of bounds\");\n+\n+\tif (at != null)\n+\t  at.transform(coords, 0, coords, 0, 1);\n+\treturn current == 0 ? SEG_MOVETO : SEG_LINETO;\n+      }\n+    };\n   }\n \n   /** Return true if the given rectangle intersects this shape."}]}