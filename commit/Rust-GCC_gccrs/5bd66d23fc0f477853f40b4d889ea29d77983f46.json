{"sha": "5bd66d23fc0f477853f40b4d889ea29d77983f46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkNjZkMjNmYzBmNDc3ODUzZjQwYjRkODg5ZWEyOWQ3Nzk4M2Y0Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-04-12T13:45:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:45:25Z"}, "message": "makeutl.adb, [...]: Minor reformatting.\n\n2013-04-12  Robert Dewar  <dewar@adacore.com>\n\n\t* makeutl.adb, prj-nmsc.adb: Minor reformatting.\n\n2013-04-12  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb (Make_Invariant_Call): Use Check_Kind instead\n\tof Check_Enabled.\n\t* gnat_rm.texi (Check_Policy): Update documentation for new\n\tCheck_Policy syntax.\n\t* sem_prag.adb (Check_Kind): Replaces Check_Enabled\n\t(Analyze_Pragma, case Check_Policy): Rework to accomodate new\n\tsyntax (like Assertion_Policy).\n\t* sem_prag.ads (Check_Kind): Replaces Check_Enabled.\n\nFrom-SVN: r197920", "tree": {"sha": "a0eed113b219050e1865bb46cf549e245a16d5f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0eed113b219050e1865bb46cf549e245a16d5f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bd66d23fc0f477853f40b4d889ea29d77983f46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bd66d23fc0f477853f40b4d889ea29d77983f46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bd66d23fc0f477853f40b4d889ea29d77983f46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bd66d23fc0f477853f40b4d889ea29d77983f46/comments", "author": null, "committer": null, "parents": [{"sha": "e952150cf6d7b8f370603b05576dd6602b6029a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e952150cf6d7b8f370603b05576dd6602b6029a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e952150cf6d7b8f370603b05576dd6602b6029a3"}], "stats": {"total": 284, "additions": 217, "deletions": 67}, "files": [{"sha": "e3661882299383b28c0a4f30b67b9d26869fba69", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -1,3 +1,18 @@\n+2013-04-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* makeutl.adb, prj-nmsc.adb: Minor reformatting.\n+\n+2013-04-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb (Make_Invariant_Call): Use Check_Kind instead\n+\tof Check_Enabled.\n+\t* gnat_rm.texi (Check_Policy): Update documentation for new\n+\tCheck_Policy syntax.\n+\t* sem_prag.adb (Check_Kind): Replaces Check_Enabled\n+\t(Analyze_Pragma, case Check_Policy): Rework to accomodate new\n+\tsyntax (like Assertion_Policy).\n+\t* sem_prag.ads (Check_Kind): Replaces Check_Enabled.\n+\n 2013-04-12  Doug Rupp  <rupp@adacore.com>\n \n \t* init.c (SS$_CONTROLC, SS$_CONTINUE) [VMS]: New macros."}, {"sha": "79b9d372afa95f5bad1f05a3010836bf909688a9", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -5456,7 +5456,7 @@ package body Exp_Util is\n       pragma Assert\n         (Has_Invariants (Typ) and then Present (Invariant_Procedure (Typ)));\n \n-      if Check_Enabled (Name_Invariant) then\n+      if Check_Kind (Name_Invariant) = Name_Check then\n          return\n            Make_Procedure_Call_Statement (Loc,\n              Name                   =>"}, {"sha": "130ee3c0f726ef655116bf8cbfd9331bb9406575", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -1557,26 +1557,36 @@ pragma Check_Policy\n  ([Name   =>] CHECK_KIND,\n   [Policy =>] POLICY_IDENTIFIER);\n \n-CHECK_KIND ::= IDENTIFIER |\n-                   Pre'Class | Post'Class | Type_Invariant'Class\n+Pragma Check_Policy (\n+    CHECK_KIND => POLICY_IDENTIFIER\n+ @{, CHECK_KIND => POLICY_IDENTIFIER@});\n+\n+ASSERTION_KIND ::= RM_ASSERTION_KIND | ID_ASSERTION_KIND\n+\n+CHECK_KIND ::= IDENTIFIER           |\n+               Pre'Class            |\n+               Post'Class           |\n+               Type_Invariant'Class |\n+               Invariant'Class\n+\n+The identifiers Name and Policy are not allowed as CHECK_KIND values. This\n+avoids confusion between the two possible syntax forms for this pragma.\n \n POLICY_IDENTIFIER ::= ON | OFF | CHECK | DISABLE | IGNORE\n @end smallexample\n \n @noindent\n This pragma is used to set the checking policy for assertions (specified\n-by aspects of pragmas), the @code{Debug} pragma, or additional checks\n+by aspects or pragmas), the @code{Debug} pragma, or additional checks\n to be checked using the @code{Check} pragma. It may appear either as\n a configuration pragma, or within a declarative part of package. In the\n latter case, it applies from the point where it appears to the end of\n the declarative region (like pragma @code{Suppress}).\n \n The @code{Check_Policy} pragma is similar to the\n predefined @code{Assertion_Policy} pragma,\n-and if the first argument corresponds to one of the assertion kinds that\n+and if the check kind corresponds to one of the assertion kinds that\n are allowed by @code{Assertion_Policy}, then the effect is identical.\n-The identifiers @code{Precondition} and @code{Postcondition} are allowed\n-synonyms for @code{Pre} and @code{Post}.\n \n If the first argument is Debug, then the policy applies to Debug pragmas,\n disabling their effect if the policy is @code{Off}, @code{Disable}, or\n@@ -1605,9 +1615,8 @@ to turn on corresponding checks. The default for a set of checks for which no\n The check policy settings @code{CHECK} and @code{IGNORE} are recognized\n as synonyms for @code{ON} and @code{OFF}. These synonyms are provided for\n compatibility with the standard @code{Assertion_Policy} pragma. The check\n-policy setting @code{DISABLE} is also synonymous with @code{OFF} in this\n-context, but does not have any other significance for check\n-names other than assertion kinds.\n+policy setting @code{DISABLE} causes the second argument of a corresponding\n+@code{Check} pragma to be completely ignored and not analyzed.\n \n @node Pragma Comment\n @unnumberedsec Pragma Comment"}, {"sha": "aef82cba856cc3173d711afe39fe2f92d428835d", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -1258,20 +1258,19 @@ package body Makeutl is\n          while Obj_Proj /= No_Project loop\n             if Obj_Proj.Object_Directory /= No_Path_Information then\n                declare\n-                  Dir  : constant String :=\n-                    Get_Name_String\n-                      (Obj_Proj.Object_Directory.Display_Name);\n+                  Dir : constant String :=\n+                    Get_Name_String (Obj_Proj.Object_Directory.Display_Name);\n \n                   Object_Path : constant String :=\n                     Normalize_Pathname\n-                      (Name          =>\n-                           Get_Name_String (Source.Object),\n+                      (Name          => Get_Name_String (Source.Object),\n                        Resolve_Links => Opt.Follow_Links_For_Files,\n                        Directory     => Dir);\n \n                   Obj_Path : constant Path_Name_Type :=\n                     Create_Name (Object_Path);\n-                  Stamp    : Time_Stamp_Type := Empty_Time_Stamp;\n+\n+                  Stamp : Time_Stamp_Type := Empty_Time_Stamp;\n \n                begin\n                   --  For specs, we do not check object files if there is a\n@@ -1301,14 +1300,12 @@ package body Makeutl is\n       elsif Source.Language.Config.Dependency_Kind = Makefile then\n          declare\n             Object_Dir : constant String :=\n-                           Get_Name_String\n-                             (Source.Project.Object_Directory.Display_Name);\n+              Get_Name_String (Source.Project.Object_Directory.Display_Name);\n             Dep_Path   : constant String :=\n-                           Normalize_Pathname\n-                             (Name        => Get_Name_String (Source.Dep_Name),\n-                              Resolve_Links =>\n-                                Opt.Follow_Links_For_Files,\n-                              Directory     => Object_Dir);\n+              Normalize_Pathname\n+                (Name          => Get_Name_String (Source.Dep_Name),\n+                 Resolve_Links => Opt.Follow_Links_For_Files,\n+                 Directory     => Object_Dir);\n          begin\n             Source.Dep_Path := Create_Name (Dep_Path);\n             Source.Dep_TS   := Osint.Unknown_Attributes;\n@@ -1326,8 +1323,8 @@ package body Makeutl is\n      (Env  : Prj.Tree.Environment;\n       Argv : String) return Boolean\n    is\n-      Start     : Positive := 3;\n-      Finish    : Natural := Argv'Last;\n+      Start  : Positive := 3;\n+      Finish : Natural := Argv'Last;\n \n       pragma Assert (Argv'First = 1);\n       pragma Assert (Argv (1 .. 2) = \"-X\");"}, {"sha": "751dab8dd0817c95f98cf86338330a081b318340", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -3156,6 +3156,7 @@ package body Prj.Nmsc is\n \n             if not Dir_Exists then\n                if Directories_Must_Exist_In_Projects then\n+\n                   --  Get the absolute name of the library directory that does\n                   --  not exist, to report an error.\n \n@@ -3211,8 +3212,8 @@ package body Prj.Nmsc is\n                              File_Name_Type (Dir_Elem.Value);\n                            Error_Msg\n                              (Data.Flags,\n-                              \"library directory cannot be the same \" &\n-                              \"as source directory {\",\n+                              \"library directory cannot be the same \"\n+                              & \"as source directory {\",\n                               Lib_Dir.Location, Project);\n                            OK := False;\n                            exit;\n@@ -3246,8 +3247,8 @@ package body Prj.Nmsc is\n \n                                     Error_Msg\n                                       (Data.Flags,\n-                                       \"library directory cannot be the same\" &\n-                                       \" as source directory { of project %%\",\n+                                       \"library directory cannot be the same \"\n+                                       & \"as source directory { of project %%\",\n                                        Lib_Dir.Location, Project);\n                                     OK := False;\n                                     exit Project_Loop;"}, {"sha": "0636b8e272bd29d2ea3208dd1825592eedc8e582", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 156, "deletions": 26, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -2320,12 +2320,12 @@ package body Sem_Prag is\n          --  For a pragma PPC in the extended main source unit, record enabled\n          --  status in SCO.\n \n-         --  This may seem redundant with the call to Check_Enabled occurring\n-         --  later on when the pragma is rewritten into a pragma Check but\n-         --  is actually required in the case of a postcondition within a\n+         --  This may seem redundant with the call to Check_Kind test that\n+         --  occurs later on when the pragma is rewritten into a pragma Check\n+         --  but is actually required in the case of a postcondition within a\n          --  generic.\n \n-         if Check_Enabled (Pname) and then not Split_PPC (N) then\n+         if Check_Kind (Pname) = Name_Check and then not Split_PPC (N) then\n             Set_SCO_Pragma_Enabled (Loc);\n          end if;\n \n@@ -6763,7 +6763,11 @@ package body Sem_Prag is\n \n       Check_Applicable_Policy (N);\n \n+      --  If pragma is disable, rewrite as Null statement and skip analysis\n+\n       if Is_Disabled (N) then\n+         Rewrite (N, Make_Null_Statement (Loc));\n+         Analyze (N);\n          raise Pragma_Exit;\n       end if;\n \n@@ -7612,6 +7616,7 @@ package body Sem_Prag is\n                --  now inserted all the equivalent Check pragmas.\n \n                Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n             end if;\n          end Assertion_Policy;\n \n@@ -8096,7 +8101,32 @@ package body Sem_Prag is\n             Rewrite_Assertion_Kind (Get_Pragma_Arg (Arg1));\n             Check_Arg_Is_Identifier (Arg1);\n             Cname := Chars (Get_Pragma_Arg (Arg1));\n-            Check_On := Check_Enabled (Cname);\n+\n+            --  Set Check_On to indicate check status\n+\n+            case Check_Kind (Cname) is\n+               when Name_Ignore =>\n+                  Check_On := False;\n+\n+               when Name_Check =>\n+                  Check_On := True;\n+\n+               --  For disable, rewrite pragma as null statement and skip\n+               --  rest of the analysis of the pragma.\n+\n+               when Name_Disable =>\n+                  Rewrite (N, Make_Null_Statement (Loc));\n+                  Analyze (N);\n+                  raise Pragma_Exit;\n+\n+               --  No other possibilities\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+\n+            --  If check kind was not Disable, then continue pragma analysis\n+\n             Expr := Get_Pragma_Arg (Arg2);\n \n             --  Deal with SCO generation\n@@ -8233,24 +8263,36 @@ package body Sem_Prag is\n          -- Check_Policy --\n          ------------------\n \n+         --  This is the old style syntax, which is still allowed in all modes:\n+\n          --  pragma Check_Policy ([Name   =>] CHECK_KIND\n          --                       [Policy =>] POLICY_IDENTIFIER);\n \n          --  POLICY_IDENTIFIER ::= On | Off | Check | Disable | Ignore\n \n-         --  CHECK_KIND ::= IDENTIFIER |\n-         --                 Pre'Class | Post'Class | Identifier'Class\n+         --  CHECK_KIND ::= IDENTIFIER           |\n+         --                 Pre'Class            |\n+         --                 Post'Class           |\n+         --                 Type_Invariant'Class |\n+         --                 Invariant'Class\n+\n+         --  This is the new style syntax, compatible with Assertion_Policy\n+         --  and also allowed in all modes.\n+\n+         --  Pragma Check_Policy (\n+         --      CHECK_KIND => POLICY_IDENTIFIER\n+         --   {, CHECK_KIND => POLICY_IDENTIFIER});\n+\n+         --  Note: the identifiers Name and Policy are not allowed as\n+         --  Check_Kind values. This avoids ambiguities between the old and\n+         --  new form syntax.\n+\n+         when Pragma_Check_Policy => Check_Policy : declare\n+            Kind : Node_Id;\n \n-         when Pragma_Check_Policy => Check_Policy :\n          begin\n             GNAT_Pragma;\n-            Check_Arg_Count (2);\n-            Check_Optional_Identifier (Arg1, Name_Name);\n-            Rewrite_Assertion_Kind (Get_Pragma_Arg (Arg1));\n-            Check_Arg_Is_Identifier (Arg1);\n-            Check_Optional_Identifier (Arg2, Name_Policy);\n-            Check_Arg_Is_One_Of\n-              (Arg2, Name_On, Name_Off, Name_Check, Name_Disable, Name_Ignore);\n+            Check_At_Least_N_Arguments (1);\n \n             --  A Check_Policy pragma can appear either as a configuration\n             --  pragma, or in a declarative part or a package spec (see RM\n@@ -8261,8 +8303,90 @@ package body Sem_Prag is\n                Check_Is_In_Decl_Part_Or_Package_Spec;\n             end if;\n \n-            Set_Next_Pragma (N, Opt.Check_Policy_List);\n-            Opt.Check_Policy_List := N;\n+            --  Figure out if we have the old or new syntax. We have the\n+            --  old syntax if the first argument has no identifier, or the\n+            --  identifier is Name.\n+\n+            if Nkind (Arg1) /= N_Pragma_Argument_Association\n+               or else Nam_In (Chars (Arg1), No_Name, Name_Name)\n+            then\n+               --  Old syntax\n+\n+               Check_Arg_Count (2);\n+               Check_Optional_Identifier (Arg1, Name_Name);\n+               Kind := Get_Pragma_Arg (Arg1);\n+               Rewrite_Assertion_Kind (Kind);\n+               Check_Arg_Is_Identifier (Arg1);\n+\n+               --  Check forbidden check kind\n+\n+               if Nam_In (Chars (Kind), Name_Name, Name_Policy) then\n+                  Error_Msg_Name_2 := Chars (Kind);\n+                     Error_Pragma_Arg\n+                       (\"pragma% does not allow% as check name\", Arg1);\n+               end if;\n+\n+               --  Check policy\n+\n+               Check_Optional_Identifier (Arg2, Name_Policy);\n+               Check_Arg_Is_One_Of\n+                 (Arg2,\n+                  Name_On, Name_Off, Name_Check, Name_Disable, Name_Ignore);\n+\n+               --  And chain pragma on the Check_Policy_List for search\n+\n+               Set_Next_Pragma (N, Opt.Check_Policy_List);\n+               Opt.Check_Policy_List := N;\n+\n+            --  For the new syntax, what we do is to convert each argument to\n+            --  an old syntax equivalent. We do that because we want to chain\n+            --  old style Check_Pragmas for the search (we don't wnat to have\n+            --  to deal with multiple arguments in the search)\n+\n+            else\n+               declare\n+                  Arg  : Node_Id;\n+                  Argx : Node_Id;\n+                  LocP : Source_Ptr;\n+\n+               begin\n+                  Arg := Arg1;\n+                  while Present (Arg) loop\n+                     LocP := Sloc (Arg);\n+                     Argx := Get_Pragma_Arg (Arg);\n+\n+                     --  Kind must be specified\n+\n+                     if Nkind (Arg) /= N_Pragma_Argument_Association\n+                       or else Chars (Arg) = No_Name\n+                     then\n+                        Error_Pragma_Arg\n+                          (\"missing assertion kind for pragma%\", Arg);\n+                     end if;\n+\n+                     --  Construct equivalent old form syntax Check_Policy\n+                     --  pragma and insert it to get remaining checks.\n+\n+                     Insert_Action (N,\n+                       Make_Pragma (LocP,\n+                         Chars                        => Name_Check_Policy,\n+                         Pragma_Argument_Associations => New_List (\n+                           Make_Pragma_Argument_Association (LocP,\n+                             Expression =>\n+                               Make_Identifier (LocP, Chars (Arg))),\n+                           Make_Pragma_Argument_Association (Sloc (Argx),\n+                             Expression => Argx))));\n+\n+                     Arg := Next (Arg);\n+                  end loop;\n+\n+                  --  Rewrite original Check_Policy pragma to null, since we\n+                  --  have converted it into a series of old syntax pragmas.\n+\n+                  Rewrite (N, Make_Null_Statement (Loc));\n+                  Analyze (N);\n+               end;\n+            end if;\n          end Check_Policy;\n \n          ---------------------\n@@ -17734,11 +17858,11 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n-   -------------------\n-   -- Check_Enabled --\n-   -------------------\n+   ----------------\n+   -- Check_Kind --\n+   ----------------\n \n-   function Check_Enabled (Nam : Name_Id) return Boolean is\n+   function Check_Kind (Nam : Name_Id) return Name_Id is\n       PP : Node_Id;\n \n    begin\n@@ -17757,9 +17881,11 @@ package body Sem_Prag is\n             then\n                case (Chars (Get_Pragma_Arg (Last (PPA)))) is\n                   when Name_On | Name_Check =>\n-                     return True;\n-                  when Name_Off | Name_Disable | Name_Ignore =>\n-                     return False;\n+                     return Name_Check;\n+                  when Name_Off | Name_Ignore =>\n+                     return Name_Ignore;\n+                  when Name_Disable =>\n+                     return Name_Disable;\n                   when others =>\n                      raise Program_Error;\n                end case;\n@@ -17775,8 +17901,12 @@ package body Sem_Prag is\n       --  compatibility with the RM for the cases of assertion, invariant,\n       --  precondition, predicate, and postcondition.\n \n-      return Assertions_Enabled;\n-   end Check_Enabled;\n+      if Assertions_Enabled then\n+         return Name_Check;\n+      else\n+         return Name_Ignore;\n+      end if;\n+   end Check_Kind;\n \n    -----------------------------\n    -- Check_Applicable_Policy --"}, {"sha": "38e39ed2f8a2337e6c947c238f91ddfe2e3439de", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bd66d23fc0f477853f40b4d889ea29d77983f46/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=5bd66d23fc0f477853f40b4d889ea29d77983f46", "patch": "@@ -54,7 +54,7 @@ package Sem_Prag is\n    --  of the expressions in the pragma as \"spec expressions\" (see section\n    --  in Sem \"Handling of Default and Per-Object Expressions...\").\n \n-   function Check_Enabled (Nam : Name_Id) return Boolean;\n+   function Check_Kind (Nam : Name_Id) return Name_Id;\n    --  This function is used in connection with pragmas Assertion, Check,\n    --  and assertion aspects and pragmas, to determine if Check pragmas\n    --  (or corresponding assertion aspects or pragmas) are currently active\n@@ -63,17 +63,15 @@ package Sem_Prag is\n    --  Assertion_Policy as configuration pragmas either in a configuration\n    --  pragma file, or at the start of the current unit, or locally given\n    --  Check_Policy and Assertion_Policy pragmas that are currently active.\n-   --  True is returned if the specified check is enabled.\n    --\n-   --  This function knows about all relevant synonyms (e.g. Precondition or\n-   --  Pre can be used to refer to the Pre aspect or Precondition pragma, and\n-   --  Predicate refers to both static and dynamic predicates, and Assertion\n-   --  applies to all assertion aspects and pragmas).\n+   --  The value returned is one of the names Check, Ignore, Disable (On\n+   --  returns Check, and Off returns Ignore).\n    --\n-   --  Note: for assertion kinds Pre'Class, Post'Class, Type_Invariant'Class,\n-   --  the name passed is Name_uPre, Name_uPost, Name_uType_Invariant, which\n-   --  corresponds to _Pre, _Post, _Type_Invariant, which are special names\n-   --  used in identifiers to represent these attribute references.\n+   --  Note: for assertion kinds Pre'Class, Post'Class, Invariant'Class,\n+   --  and Type_Invariant'Class, the name passed is Name_uPre, Name_uPost,\n+   --  Name_uInvariant, or Name_uType_Invariant, which corresponds to _Pre,\n+   --  _Post, _Invariant, or _Type_Invariant, which are special names used\n+   --  in identifiers to represent these attribute references.\n \n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n@@ -83,9 +81,9 @@ package Sem_Prag is\n    --  we use for the purpose of this procedure is the aspect name, which may\n    --  be different from the pragma name (e.g. Precondition for Pre aspect).\n    --  In addition, 'Class aspects are recognized (and the corresponding\n-   --  special names used in the processing.\n+   --  special names used in the processing).\n    --\n-   --  If the name is valid assertion_Kind name, then the Check_Policy pragma\n+   --  If the name is valid ASSERTION_KIND name, then the Check_Policy pragma\n    --  chain is checked for a matching entry (or for an Assertion entry which\n    --  matches all possibilities). If a matching entry is found then the policy\n    --  is checked. If it is Off, Ignore, or Disable, then the Is_Ignored flag"}]}