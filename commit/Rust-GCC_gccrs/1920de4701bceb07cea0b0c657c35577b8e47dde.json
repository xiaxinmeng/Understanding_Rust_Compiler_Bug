{"sha": "1920de4701bceb07cea0b0c657c35577b8e47dde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkyMGRlNDcwMWJjZWIwN2NlYTBiMGM2NTdjMzU1NzdiOGU0N2RkZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-03T15:35:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-03T15:35:47Z"}, "message": "cpplib.h: Add accessor macros for token lists.\n\n\t* cpplib.h: Add accessor macros for token lists.\n\t* cpplib.c, cpphash.c, cpplex.c: Use them.\n\nFrom-SVN: r33630", "tree": {"sha": "b0329a13f3ba6a807cb4b7e6f276a6ec83f5d34f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0329a13f3ba6a807cb4b7e6f276a6ec83f5d34f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1920de4701bceb07cea0b0c657c35577b8e47dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1920de4701bceb07cea0b0c657c35577b8e47dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1920de4701bceb07cea0b0c657c35577b8e47dde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1920de4701bceb07cea0b0c657c35577b8e47dde/comments", "author": null, "committer": null, "parents": [{"sha": "32919a0dd2047067e8586102a3a248ad9fb270e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32919a0dd2047067e8586102a3a248ad9fb270e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32919a0dd2047067e8586102a3a248ad9fb270e9"}], "stats": {"total": 149, "additions": 78, "deletions": 71}, "files": [{"sha": "b28cacc8a6cf275c65726ba272dd74448fcbe5c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1920de4701bceb07cea0b0c657c35577b8e47dde", "patch": "@@ -1,3 +1,8 @@\n+2000-05-03  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h: Add accessor macros for token lists.\n+\t* cpplib.c, cpphash.c, cpplex.c: Use them.\n+\n Wed May  3 09:29:17 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (expand_expr, case COMPONENT_REF): Don't check for checking"}, {"sha": "ca9b4e294bae87187e063051387e98405c535c8a", "filename": "gcc/cpphash.c", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=1920de4701bceb07cea0b0c657c35577b8e47dde", "patch": "@@ -467,7 +467,7 @@ collect_objlike_expansion (pfile, list)\n \n   for (i = 1; i < list->tokens_used; i++)\n     {\n-      switch (list->tokens[i].type)\n+      switch (TOK_TYPE (list, i))\n \t{\n \tcase CPP_EOF:\n \t  cpp_ice (pfile, \"EOF in collect_expansion\");\n@@ -489,13 +489,10 @@ collect_objlike_expansion (pfile, list)\n \tdefault:;\n \t}\n \n-      if (i > 1 && !last_was_paste\n-\t  && (list->tokens[i].flags & PREV_WHITESPACE))\n+      if (i > 1 && !last_was_paste && TOK_PREV_WHITE (list, i))\n \tCPP_PUTC (pfile, ' ');\n \n-      CPP_PUTS (pfile,\n-\t\tlist->tokens[i].val.name.offset + list->namebuf,\n-\t\tlist->tokens[i].val.name.len);\n+      CPP_PUTS (pfile, TOK_NAME (list, i), TOK_LEN (list, i));\n       last_was_paste = 0;\n     }\n  done:\n@@ -554,9 +551,9 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n \n   for (i = replacement; i < list->tokens_used; i++)\n     {\n-      token = list->tokens[i].type;\n-      tok = list->tokens[i].val.name.offset + list->namebuf;\n-      len = list->tokens[i].val.name.len;\n+      token = TOK_TYPE (list, i);\n+      tok = TOK_NAME (list, i);\n+      len = TOK_LEN (list, i);\n       switch (token)\n \t{\n \tcase CPP_EOF:\n@@ -597,10 +594,10 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n \t}\n \n       if (last_token != PASTE && last_token != START\n-\t  && (list->tokens[i].flags & PREV_WHITESPACE))\n+\t  && TOK_PREV_WHITE (list, i))\n \tCPP_PUTC (pfile, ' ');\n       if (last_token == ARG && CPP_TRADITIONAL (pfile)\n-\t  && !(list->tokens[i].flags & PREV_WHITESPACE))\n+\t  && !TOK_PREV_WHITE (list, i))\n \tendpat->raw_after = 1;\n \n       switch (token)\n@@ -642,7 +639,7 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n       {\n \tint raw_before = (last_token == PASTE\n \t\t\t  || (CPP_TRADITIONAL (pfile)\n-\t\t\t      && !(list->tokens[i].flags & PREV_WHITESPACE)));\n+\t\t\t      && ! TOK_PREV_WHITE (list, j)));\n       \n \tadd_pat (&pat, &endpat,\n \t\t CPP_WRITTEN (pfile) - last /* nchars */, j /* argno */,\n@@ -711,10 +708,10 @@ collect_params (pfile, list, arglist)\n   unsigned int argc, a, i, j;\n \n   /* The formal parameters list starts at token 1.  */\n-  if (list->tokens[1].type != CPP_OPEN_PAREN)\n+  if (TOK_TYPE (list, 1) != CPP_OPEN_PAREN)\n     {\n       cpp_ice (pfile, \"first token = %d not %d in collect_formal_parameters\",\n-\t       list->tokens[1].type, CPP_OPEN_PAREN);\n+\t       TOK_TYPE (list, 1), CPP_OPEN_PAREN);\n       return 0;\n     }\n \n@@ -723,44 +720,44 @@ collect_params (pfile, list, arglist)\n   argc = 0;\n   argslen = 0;\n   for (i = 2; i < list->tokens_used; i++)\n-    switch (list->tokens[i].type)\n+    switch (TOK_TYPE (list, i))\n       {\n       case CPP_NAME:\n-\targslen += list->tokens[i].val.name.len + 1;\n+\targslen += TOK_LEN (list, i) + 1;\n \targc++;\n \tbreak;\n       case CPP_COMMA:\n \tbreak;\n       case CPP_CLOSE_PAREN:\n \tgoto scanned;\n       case CPP_VSPACE:\n-\tcpp_error_with_line (pfile, list->line, list->tokens[i].col,\n+\tcpp_error_with_line (pfile, list->line, TOK_COL (list, i),\n \t\t\t     \"missing right paren in macro argument list\");\n \treturn 0;\n \n       default:\n-\tcpp_error_with_line (pfile, list->line, list->tokens[i].col,\n-\t\t\t     \"syntax error in #define\");\n+\tcpp_error_with_line (pfile, list->line, TOK_COL (list, i),\n+\t\t\t     \"illegal token in macro argument list\");\n \treturn 0;\n \n       case CPP_ELLIPSIS:\n-\tif (list->tokens[i-1].type != CPP_NAME)\n+\tif (TOK_TYPE (list, i-1) != CPP_NAME)\n \t  {\n \t    argslen += sizeof \"__VA_ARGS__\";\n \t    argc++;\n \t  }\n \ti++;\n-\tif (list->tokens[i].type != CPP_CLOSE_PAREN)\n+\tif (TOK_TYPE (list, i) != CPP_CLOSE_PAREN)\n \t  {\n-\t    cpp_error_with_line (pfile, list->line, list->tokens[i].col,\n+\t    cpp_error_with_line (pfile, list->line, TOK_COL (list, i),\n \t\t\t\t \"another parameter follows \\\"...\\\"\");\n \t    return 0;\n \t  }\n \tgoto scanned;\n       }\n \n   cpp_ice (pfile, \"collect_params: unreachable - i=%d, ntokens=%d, type=%d\",\n-\t   i, list->tokens_used, list->tokens[i-1].type);\n+\t   i, list->tokens_used, TOK_TYPE (list, i-1));\n   return 0;\n \n  scanned:\n@@ -783,11 +780,11 @@ collect_params (pfile, list, arglist)\n   p = namebuf;\n   a = 0;\n   for (j = 2; j < i; j++)\n-    switch (list->tokens[j].type)\n+    switch (TOK_TYPE (list, j))\n       {\n       case CPP_NAME:\n-\ttok = list->tokens[j].val.name.offset + list->namebuf;\n-\tlen = list->tokens[j].val.name.len;\n+\ttok = TOK_NAME (list, j);\n+\tlen = TOK_LEN (list, j);\n \tmemcpy (p, tok, len);\n \tp[len] = '\\0';\n \tif (duplicate_arg_p (namebuf, p))\n@@ -812,7 +809,7 @@ collect_params (pfile, list, arglist)\n \tbreak;\n \n       case CPP_ELLIPSIS:\n-\tif (list->tokens[j-1].type != CPP_NAME)\n+\tif (TOK_TYPE (list, j-1) != CPP_NAME)\n \t  {\n \t    if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n \t      cpp_pedwarn (pfile, \"C89 does not permit varargs macros\");\n@@ -833,7 +830,7 @@ collect_params (pfile, list, arglist)\n \n       default:\n \tcpp_ice (pfile, \"collect_params: impossible token type %d\",\n-\t\t list->tokens[j].type);\n+\t\t TOK_TYPE (list, j));\n       }\n \n   arglist->argc = argc;\n@@ -869,17 +866,16 @@ _cpp_create_definition (pfile, list, hp)\n \n   if (list->tokens_used == 2)\n     ntype = T_EMPTY;    /* Empty definition of object-like macro.  */\n-  else if (list->tokens_used == 3 && list->tokens[1].type == CPP_NAME\n-\t   && list->tokens[0].val.name.len == list->tokens[1].val.name.len\n-\t   && !strncmp (list->tokens[0].val.name.offset + list->namebuf,\n-\t\t\tlist->tokens[1].val.name.offset + list->namebuf,\n-\t\t\tlist->tokens[0].val.name.len))\n+  else if (list->tokens_used == 3 && TOK_TYPE (list, 1) == CPP_NAME\n+\t   && TOK_LEN (list, 0) == TOK_LEN (list, 1)\n+\t   && !strncmp (TOK_NAME (list, 0), TOK_NAME (list, 1),\n+\t\t\tTOK_LEN (list, 0)))\n     ntype = T_IDENTITY;  /* Object like macro defined to itself.  */\n \n   /* The macro is function-like only if the next character,\n      with no intervening whitespace, is '('.  */\n-  else if (list->tokens[1].type == CPP_OPEN_PAREN\n-\t   && ! (list->tokens[1].flags & PREV_WHITESPACE))\n+  else if (TOK_TYPE (list, 1) == CPP_OPEN_PAREN\n+\t   && ! TOK_PREV_WHITE (list, 1))\n     {\n       struct arglist args;\n       int replacement;\n@@ -898,7 +894,7 @@ _cpp_create_definition (pfile, list, hp)\n      whitespace after the name (6.10.3 para 3).  */\n   else\n     {\n-      if (! (list->tokens[1].flags & PREV_WHITESPACE))\n+      if (! TOK_PREV_WHITE (list, 1))\n \tcpp_pedwarn (pfile,\n \t\t     \"The C standard requires whitespace after #define %s\",\n \t\t     hp->name);\n@@ -981,14 +977,14 @@ _cpp_create_definition (pfile, list, hp)\n     {\n       fdefn->file = CPP_BUFFER (pfile)->nominal_fname;\n       fdefn->line = list->line;\n-      fdefn->col  = list->tokens[0].col;\n+      fdefn->col  = TOK_COL (list, 0);\n       hp->value.fdefn = fdefn;\n     }\n   else\n     {\n       odefn->file = CPP_BUFFER (pfile)->nominal_fname;\n       odefn->line = list->line;\n-      odefn->col  = list->tokens[0].col;\n+      odefn->col  = TOK_COL (list, 0);\n       hp->value.odefn = odefn;\n     }\n   return 1;"}, {"sha": "f0110542e0359279412e184b6ccb20993e0d8d05", "filename": "gcc/cpplex.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=1920de4701bceb07cea0b0c657c35577b8e47dde", "patch": "@@ -307,23 +307,22 @@ cpp_output_list (pfile, print, list)\n   \n   for (i = 0; i < list->tokens_used; i++)\n     {\n-      if (list->tokens[i].type == CPP_VSPACE)\n+      if (TOK_TYPE (list, i) == CPP_VSPACE)\n \t{\n \t  output_line_command (pfile, print, list->tokens[i].aux);\n \t  continue;\n \t}\n \t  \n-      if (curcol < list->tokens[i].col)\n+      if (curcol < TOK_COL (list, i))\n \t{\n \t  /* Insert space to bring the column to what it should be.  */\n-\t  bump_column (print, curcol - 1, list->tokens[i].col);\n-\t  curcol = list->tokens[i].col;\n+\t  bump_column (print, curcol - 1, TOK_COL (list, i));\n+\t  curcol = TOK_COL (list, i);\n \t}\n       /* XXX We may have to insert space to prevent an accidental\n \t token paste.  */\n-      safe_fwrite (pfile, list->namebuf + list->tokens[i].val.name.offset,\n-\t\t   list->tokens[i].val.name.len, print->outf);\n-      curcol += list->tokens[i].val.name.len;\n+      safe_fwrite (pfile, TOK_NAME (list, i), TOK_LEN (list, i), print->outf);\n+      curcol += TOK_LEN (list, i);\n     }\n }\n \n@@ -534,21 +533,21 @@ _cpp_scan_line (pfile, list)\n \ttype = CPP_NAME;\n \n       list->tokens_used++;\n-      list->tokens[i].type = type;\n-      list->tokens[i].col = col;\n-      list->tokens[i].flags = space_before ? PREV_WHITESPACE : 0;\n+      TOK_TYPE  (list, i) = type;\n+      TOK_COL   (list, i) = col;\n+      TOK_FLAGS (list, i) = space_before ? PREV_WHITESPACE : 0;\n       \n       if (type == CPP_VSPACE)\n \tbreak;\n \n-      list->tokens[i].val.name.len = len;\n-      list->tokens[i].val.name.offset = list->name_used;\n-      memcpy (list->namebuf + list->name_used, CPP_PWRITTEN (pfile), len);\n+      TOK_LEN (list, i) = len;\n+      TOK_OFFSET (list, i) = list->name_used;\n+      memcpy (TOK_NAME (list, i), CPP_PWRITTEN (pfile), len);\n       list->name_used += len;\n       i++;\n       space_before = 0;\n     }\n-  list->tokens[i].aux =  CPP_BUFFER (pfile)->lineno + 1;\n+  TOK_AUX (list, i) = CPP_BUFFER (pfile)->lineno + 1;\n \n   /* XXX Temporary kluge: put back the newline.  */\n   FORWARD(-1);\n@@ -2194,7 +2193,7 @@ typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n #define INIT_NAME(list, name) \\\n   do {(name).len = 0; (name).offset = (list)->name_used;} while (0)\n \n-#define IS_DIRECTIVE(list) (list->tokens[0].type == CPP_HASH)\n+#define IS_DIRECTIVE(list) (TOK_TYPE (list, 0) == CPP_HASH)\n #define COLUMN(cur) ((cur) - buffer->line_base)\n \n /* Maybe put these in the ISTABLE eventually.  */\n@@ -2893,7 +2892,7 @@ _cpp_lex_line (pfile, list)\n \t  /* Do we have a wide string?  */\n \t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n \t      && cur_token[-1].val.name.len == 1\n-\t      && TOK_NAME (list, cur_token - 1)[0] == 'L'\n+\t      && *(list->namebuf + cur_token[-1].val.name.offset) == 'L'\n \t      && !CPP_TRADITIONAL (pfile))\n \t    {\n \t      /* No need for 'L' any more.  */\n@@ -3286,7 +3285,7 @@ spell_string (buffer, list, token)\n   *buffer++ = c;\n \n   len = token->val.name.len;\n-  memcpy (buffer, TOK_NAME (list, token), len);\n+  memcpy (buffer, list->namebuf + token->val.name.offset, len);\n   buffer += len;\n   *buffer++ = c;\n   return buffer - orig_buff;\n@@ -3318,7 +3317,7 @@ spell_comment (buffer, list, token)\n     }\n \n   len = token->val.name.len;\n-  memcpy (buffer, TOK_NAME (list, token), len);\n+  memcpy (buffer, list->namebuf + token->val.name.offset, len);\n \n   return len + 2;\n }\n@@ -3333,7 +3332,7 @@ spell_name (buffer, list, token)\n   size_t len;\n \n   len = token->val.name.len;\n-  memcpy (buffer, TOK_NAME (list, token), len);\n+  memcpy (buffer, list->namebuf + token->val.name.offset, len);\n   buffer += len;\n \n   return len;"}, {"sha": "baaeed65c86c5db88a8722ef2fa6f792d81456ae", "filename": "gcc/cpplib.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=1920de4701bceb07cea0b0c657c35577b8e47dde", "patch": "@@ -349,21 +349,21 @@ do_define (pfile)\n \n   /* First token on the line must be a NAME.  There must be at least\n      one token (the VSPACE at the end).  */\n-  if (list->tokens[0].type != CPP_NAME)\n+  if (TOK_TYPE (list, 0) != CPP_NAME)\n     {\n-      cpp_error_with_line (pfile, list->line, list->tokens[0].col,\n+      cpp_error_with_line (pfile, list->line, TOK_COL (list, 0),\n \t\t\t   \"#define must be followed by an identifier\");\n       goto out;\n     }\n \n-  sym = list->namebuf + list->tokens[0].val.name.offset;\n-  len = list->tokens[0].val.name.len;\n+  sym = TOK_NAME (list, 0);\n+  len = TOK_LEN (list, 0);\n \n   /* That NAME is not allowed to be \"defined\".  (Not clear if the\n      standard requires this.)  */\n   if (len == 7 && !strncmp (sym, \"defined\", 7))\n     {\n-      cpp_error_with_line (pfile, list->line, list->tokens[0].col,\n+      cpp_error_with_line (pfile, list->line, TOK_COL (list, 0),\n \t\t\t   \"\\\"defined\\\" is not a legal macro name\");\n       goto out;\n     }"}, {"sha": "0a9b6af3a8c677e4730663d36a6326b86fe8ecd0", "filename": "gcc/cpplib.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920de4701bceb07cea0b0c657c35577b8e47dde/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=1920de4701bceb07cea0b0c657c35577b8e47dde", "patch": "@@ -157,24 +157,31 @@ struct cpp_name\n   unsigned int offset;\t\t/* from list->namebuf */\n };\n \n-#define TOK_NAME(list, token) ((list)->namebuf + (token)->val.name.offset)\n+/* Accessor macros for token lists - all expect you have a\n+   list and an index.  */\n+\n+#define TOK_TYPE(l_, i_)   ((l_)->tokens[i_].type)\n+#define TOK_FLAGS(l_, i_)  ((l_)->tokens[i_].flags)\n+#define TOK_AUX(l_, i_)    ((l_)->tokens[i_].aux)\n+#define TOK_COL(l_, i_)    ((l_)->tokens[i_].col)\n+#define TOK_INT(l_, i_)    ((l_)->tokens[i_].val.integer)\n+#define TOK_OFFSET(l_, i_) ((l_)->tokens[i_].val.name.offset)\n+#define TOK_NAME(l_, i_)   ((l_)->tokens[i_].val.name.offset + (l_)->namebuf)\n+#define TOK_LEN(l_, i_)    ((l_)->tokens[i_].val.name.len)\n+\n+#define TOK_PREV_WHITE(l_, i_) (TOK_FLAGS(l_, i_) & PREV_WHITESPACE)\n \n /* Flags for the cpp_token structure.  */\n #define PREV_WHITESPACE     1\t/* If whitespace before this token.  */\n #define DIGRAPH             2\t/* If it was a digraph.  */\n #define UNSIGNED_INT        4   /* If int preprocessing token unsigned.  */\n \n-/* A preprocessing token.\n-   This has been carefully packed and should occupy 16 bytes on\n-   both 32- and 64-bit hosts.  */\n+/* A preprocessing token.  This has been carefully packed and should\n+   occupy 16 bytes on both 32- and 64-bit hosts.  */\n struct cpp_token\n {\n   unsigned short col;\t\t\t/* starting column of this token */\n-#ifdef ENUM_BITFIELDS_ARE_UNSIGNED\n-  enum cpp_ttype type : CHAR_BIT;\t/* node type */\n-#else\n-  unsigned char type;\n-#endif\n+  ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* node type */\n   unsigned char flags;\t\t\t/* flags - see above */\n   unsigned int aux;\t\t\t/* CPP_OTHER character.  Hash of a\n \t\t\t\t\t   NAME, or something - see uses"}]}