{"sha": "601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAxYmI2YjM1ZWE5YTE4NWMzNjBkNzNhOTBhM2ZjZDVjOWQyODZmZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-05-21T12:45:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-05-21T12:45:44Z"}, "message": "[multiple changes]\n\n2014-05-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_Allocator_Expression.Apply_Accessibility_Check):\n\tComplete previous patch.\n\n2014-05-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.adb (Read and Write for Datagram_Socket_Stream_Type):\n\tProvide a behaviour more consistent with underlying datagram\n\tsocket: do not attempt to loop over Send_Socket/Receive_Socket\n\titerating along the buffer.\n\n2014-05-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* freeze.adb (Freeze_Record_Type): Ensure that a discriminated\n\tor a tagged type is not labelled as volatile. Ensure that a\n\tnon-volatile type has no volatile components.\n\t* sem_ch3.adb (Analyze_Object_Contract): Add local constant\n\tObj_Typ. Code reformatting.  Ensure that a discriminated or\n\ttagged object is not labelled as volatile.\n\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Ensure that\n\tpragma Volatile applies to a full type declaration or an object\n\tdeclaration when SPARK mode is on.\n\n2014-05-21  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi: For ASIS tools, reword the paragraph about\n\tproviding options needed for compiling the argument source for\n\tthe situation when a project file can be used as a tool parameter.\n\n2014-05-21  Gary Dismukes  <dismukes@adacore.com>\n\n\t* gnat_rm.texi: Minor typo fix.\n\nFrom-SVN: r210697", "tree": {"sha": "01924246c65a2bf6ef0efdfdee15ae7d5b7057f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01924246c65a2bf6ef0efdfdee15ae7d5b7057f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/comments", "author": null, "committer": null, "parents": [{"sha": "da574a866b86e92f0305e68ddb7f1993365fb5dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da574a866b86e92f0305e68ddb7f1993365fb5dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da574a866b86e92f0305e68ddb7f1993365fb5dd"}], "stats": {"total": 336, "additions": 205, "deletions": 131}, "files": [{"sha": "6ac28b49966f8968fc27b0196a146a95e8e335df", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -1,3 +1,37 @@\n+2014-05-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression.Apply_Accessibility_Check):\n+\tComplete previous patch.\n+\n+2014-05-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.adb (Read and Write for Datagram_Socket_Stream_Type):\n+\tProvide a behaviour more consistent with underlying datagram\n+\tsocket: do not attempt to loop over Send_Socket/Receive_Socket\n+\titerating along the buffer.\n+\n+2014-05-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* freeze.adb (Freeze_Record_Type): Ensure that a discriminated\n+\tor a tagged type is not labelled as volatile. Ensure that a\n+\tnon-volatile type has no volatile components.\n+\t* sem_ch3.adb (Analyze_Object_Contract): Add local constant\n+\tObj_Typ. Code reformatting.  Ensure that a discriminated or\n+\ttagged object is not labelled as volatile.\n+\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Ensure that\n+\tpragma Volatile applies to a full type declaration or an object\n+\tdeclaration when SPARK mode is on.\n+\n+2014-05-21  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi: For ASIS tools, reword the paragraph about\n+\tproviding options needed for compiling the argument source for\n+\tthe situation when a project file can be used as a tool parameter.\n+\n+2014-05-21  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* gnat_rm.texi: Minor typo fix.\n+\n 2014-05-21  Robert Dewar  <dewar@adacore.com>\n \n \t* stand.adb (Tree_Read): Read missing entities."}, {"sha": "a3213aaeae56bc4a6e5eac5d3bd00e04681e2b22", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -835,7 +835,8 @@ package body Exp_Ch4 is\n             --  object Obj_Ref already references the tag of the secondary\n             --  dispatch table.\n \n-            if Present (Parent (Entity (Obj_Ref)))\n+            if Nkind (Obj_Ref) in N_Has_Entity\n+              and then Present (Entity (Obj_Ref))\n               and then Present (Renamed_Object (Entity (Obj_Ref)))\n               and then Is_Interface (DesigT)\n             then"}, {"sha": "6a382b9e7dcfd84ef1f24410d8759d4107800979", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -3314,6 +3314,45 @@ package body Freeze is\n             end if;\n          end if;\n \n+         --  The following checks are only relevant when SPARK_Mode is on as\n+         --  they are not standard Ada legality rules.\n+\n+         if SPARK_Mode = On then\n+            if Is_SPARK_Volatile_Object (Rec) then\n+\n+               --  A discriminated type cannot be volatile (SPARK RM C.6(4))\n+\n+               if Has_Discriminants (Rec) then\n+                  Error_Msg_N (\"discriminated type & cannot be volatile\", Rec);\n+\n+               --  A tagged type cannot be volatile (SPARK RM C.6(5))\n+\n+               elsif Is_Tagged_Type (Rec) then\n+                  Error_Msg_N (\"tagged type & cannot be volatile\", Rec);\n+               end if;\n+\n+            --  A non-volatile record type cannot contain volatile components\n+            --  (SPARK RM C.6(2)). The check is performed at freeze point\n+            --  because the volatility status of the record type and its\n+            --  components is clearly known.\n+\n+            else\n+               Comp := First_Component (Rec);\n+               while Present (Comp) loop\n+                  if Comes_From_Source (Comp)\n+                    and then Is_SPARK_Volatile_Object (Comp)\n+                  then\n+                     Error_Msg_Name_1 := Chars (Rec);\n+                     Error_Msg_N\n+                       (\"component & of non-volatile record type % cannot be \"\n+                        & \"volatile\", Comp);\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end if;\n+         end if;\n+\n          --  All done if not a full record definition\n \n          if Ekind (Rec) /= E_Record_Type then"}, {"sha": "ee4d52a4cca4db74058a3a7fbeee0ed03f9944dc", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2013, AdaCore                     --\n+--                     Copyright (C) 2001-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -244,13 +244,6 @@ package body GNAT.Sockets is\n      (Stream : in out Stream_Socket_Stream_Type;\n       Item   : Ada.Streams.Stream_Element_Array);\n \n-   procedure Stream_Write\n-     (Socket : Socket_Type;\n-      Item   : Ada.Streams.Stream_Element_Array;\n-      To     : access Sock_Addr_Type);\n-   --  Common implementation for the Write operation of Datagram_Socket_Stream_\n-   --  Type and Stream_Socket_Stream_Type.\n-\n    procedure Wait_On_Socket\n      (Socket   : Socket_Type;\n       For_Read : Boolean;\n@@ -1732,27 +1725,12 @@ package body GNAT.Sockets is\n       Item   : out Ada.Streams.Stream_Element_Array;\n       Last   : out Ada.Streams.Stream_Element_Offset)\n    is\n-      First : Ada.Streams.Stream_Element_Offset          := Item'First;\n-      Index : Ada.Streams.Stream_Element_Offset          := First - 1;\n-      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n-\n    begin\n-      loop\n-         Receive_Socket\n-           (Stream.Socket,\n-            Item (First .. Max),\n-            Index,\n-            Stream.From);\n-\n-         Last := Index;\n-\n-         --  Exit when all or zero data received. Zero means that the socket\n-         --  peer is closed.\n-\n-         exit when Index < First or else Index = Max;\n-\n-         First := Index + 1;\n-      end loop;\n+      Receive_Socket\n+        (Stream.Socket,\n+         Item,\n+         Last,\n+         Stream.From);\n    end Read;\n \n    ----------\n@@ -2419,43 +2397,6 @@ package body GNAT.Sockets is\n       return Stream_Access (S);\n    end Stream;\n \n-   ------------------\n-   -- Stream_Write --\n-   ------------------\n-\n-   procedure Stream_Write\n-     (Socket : Socket_Type;\n-      Item   : Ada.Streams.Stream_Element_Array;\n-      To     : access Sock_Addr_Type)\n-   is\n-      First : Ada.Streams.Stream_Element_Offset;\n-      Index : Ada.Streams.Stream_Element_Offset;\n-      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n-\n-   begin\n-      First := Item'First;\n-      Index := First - 1;\n-      while First <= Max loop\n-         Send_Socket (Socket, Item (First .. Max), Index, To);\n-\n-         --  Exit when all or zero data sent. Zero means that the socket has\n-         --  been closed by peer.\n-\n-         exit when Index < First or else Index = Max;\n-\n-         First := Index + 1;\n-      end loop;\n-\n-      --  For an empty array, we have First > Max, and hence Index >= Max (no\n-      --  error, the loop above is never executed). After a successful send,\n-      --  Index = Max. The only remaining case, Index < Max, is therefore\n-      --  always an actual send failure.\n-\n-      if Index < Max then\n-         Raise_Socket_Error (Socket_Errno);\n-      end if;\n-   end Stream_Write;\n-\n    ----------\n    -- To_C --\n    ----------\n@@ -2695,8 +2636,20 @@ package body GNAT.Sockets is\n      (Stream : in out Datagram_Socket_Stream_Type;\n       Item   : Ada.Streams.Stream_Element_Array)\n    is\n+      Last : Stream_Element_Offset;\n+\n    begin\n-      Stream_Write (Stream.Socket, Item, To => Stream.To'Unrestricted_Access);\n+      Send_Socket\n+        (Stream.Socket,\n+         Item,\n+         Last,\n+         Stream.To);\n+\n+      --  It is an error if not all of the data has been sent\n+\n+      if Last /= Item'Last then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n    end Write;\n \n    -----------\n@@ -2707,8 +2660,32 @@ package body GNAT.Sockets is\n      (Stream : in out Stream_Socket_Stream_Type;\n       Item   : Ada.Streams.Stream_Element_Array)\n    is\n+      First : Ada.Streams.Stream_Element_Offset;\n+      Index : Ada.Streams.Stream_Element_Offset;\n+      Max   : constant Ada.Streams.Stream_Element_Offset := Item'Last;\n+\n    begin\n-      Stream_Write (Stream.Socket, Item, To => null);\n+      First := Item'First;\n+      Index := First - 1;\n+      while First <= Max loop\n+         Send_Socket (Stream.Socket, Item (First .. Max), Index, null);\n+\n+         --  Exit when all or zero data sent. Zero means that the socket has\n+         --  been closed by peer.\n+\n+         exit when Index < First or else Index = Max;\n+\n+         First := Index + 1;\n+      end loop;\n+\n+      --  For an empty array, we have First > Max, and hence Index >= Max (no\n+      --  error, the loop above is never executed). After a successful send,\n+      --  Index = Max. The only remaining case, Index < Max, is therefore\n+      --  always an actual send failure.\n+\n+      if Index < Max then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n    end Write;\n \n    Sockets_Library_Controller_Object : Sockets_Library_Controller;"}, {"sha": "79e43ab90b0a014251d3c8e698336940d17504b9", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -15746,7 +15746,7 @@ end Overwrite_Array;\n @end smallexample\n \n @noindent\n-then the program compiles without the waraning and when run will generate\n+then the program compiles without the warning and when run will generate\n the output @code{X was not clobbered}.\n \n @node Effect of Convention on Representation"}, {"sha": "9a347525e919142903ec3735bab578b00adec01a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -14129,22 +14129,18 @@ Support for @option{--pp-old} will be removed in some future version.\n \n To produce a reformatted file, @command{gnatpp} invokes the Ada\n compiler and generates and uses the ASIS tree for the input source;\n-thus the input must be legal Ada code.\n+thus the input must be legal Ada code, and the tool should have all the\n+information needed to compile the input source. To provide this information,\n+you may specify as a tool parameter the project file the input source belongs to\n+(or you may call @command{gnatpp}\n+through the @command{gnat} driver (see @ref{The GNAT Driver and\n+Project Files}). Another possibility is to specify the source search\n+path and needed configuration files in @option{-cargs} section of @command{gnatpp}\n+call, see the description of the @command{gnatpp} switches below.\n \n @command{gnatpp} cannot process sources that contain\n preprocessing directives.\n \n-If the compilation unit contained in the input source depends\n-semantically upon units located outside the current directory, you\n-have to provide the source search path when invoking\n-@command{gnatpp}. If these units are contained in files with names\n-that do not follow the GNAT file naming rules, you have to provide a\n-configuration file describing the corresponding naming scheme; see the\n-description of the @command{gnatpp} switches below. Another\n-possibility is to use a project file and to call @command{gnatpp}\n-through the @command{gnat} driver (see @ref{The GNAT Driver and\n-Project Files}).\n-\n The @command{gnatpp} command has the form\n \n @smallexample\n@@ -15579,23 +15575,16 @@ metrics are computed and output.\n * Switches for gnatmetric::\n @end menu\n \n-@command{gnatmetric} generates and uses the ASIS\n-tree for the input source and thus requires the input to be syntactically and\n-semantically legal.\n-If this condition is not met, @command{gnatmetric} will generate\n-an error message; no metric information for this file will be\n-computed and reported.\n-\n-If the compilation unit contained in the input source depends semantically\n-upon units in files located outside the current directory, you have to provide\n-the source search path when invoking @command{gnatmetric}.\n-If it depends semantically upon units that are contained\n-in files with names that do not follow the GNAT file naming rules, you have to\n-provide the configuration file describing the corresponding naming scheme (see\n-the description of the @command{gnatmetric} switches below.)\n-Alternatively, you may use a project file and invoke @command{gnatmetric}\n-through the @command{gnat} driver (see @ref{The GNAT Driver and Project Files}),\n-or you can directly specify a project file as a @command{gnatmetric} parameter.\n+To compute program metrics, @command{gnatmetric} invokes the Ada\n+compiler and generates and uses the ASIS tree for the input source;\n+thus the input must be legal Ada code, and the tool should have all the\n+information needed to compile the input source. To provide this information,\n+you may specify as a tool parameter the project file the input source belongs to\n+(or you may call @command{gnatmetric}\n+through the @command{gnat} driver (see @ref{The GNAT Driver and\n+Project Files}). Another possibility is to specify the source search\n+path and needed configuration files in @option{-cargs} section of @command{gnatmetric}\n+call, see the description of the @command{gnatmetric} switches below.\n \n The @command{gnatmetric} command has the form\n \n@@ -16427,8 +16416,8 @@ dependencies between units that are arguments of the @command{gnatmetric}\n invocation. Coupling metrics are program-wide (or project-wide) metrics, so\n you should invoke @command{gnatmetric} for\n the complete set of sources comprising your program. This can be done\n-by invoking @command{gnatmetric} from the GNAT driver with the @option{-U}\n-option (see @ref{The GNAT Driver and Project Files} for details).\n+by invoking @command{gnatmetric} with the corresponding project file\n+and with the @option{-U} option.\n \n By default, all the coupling metrics are disabled. You can use the following\n switches to specify the coupling metrics to be computed and reported:\n@@ -19315,15 +19304,16 @@ For full details, refer to @cite{GNATcheck Reference Manual} document.\n @command{gnatstub} creates body stubs, that is, empty but compilable bodies\n for library unit declarations.\n \n-Note: to invoke @code{gnatstub} with a project file, use the @code{gnat}\n-driver (see @ref{The GNAT Driver and Project Files}).\n-\n-To create a body stub, @command{gnatstub} has to compile the library\n-unit declaration. Therefore, bodies can be created only for legal\n-library units. Moreover, if a library unit depends semantically upon\n-units located outside the current directory, you have to provide\n-the source search path when calling @command{gnatstub}, see the description\n-of @command{gnatstub} switches below.\n+To create a body stub, @command{gnatstub} invokes the Ada\n+compiler and generates and uses the ASIS tree for the input source;\n+thus the input must be legal Ada code, and the tool should have all the\n+information needed to compile the input source. To provide this information,\n+you may specify as a tool parameter the project file the input source belongs to\n+(or you may call @command{gnatstub}\n+through the @command{gnat} driver (see @ref{The GNAT Driver and\n+Project Files}). Another possibility is to specify the source search\n+path and needed configuration files in @option{-cargs} section of @command{gnatstub}\n+call, see the description of the @command{gnatstub} switches below.\n \n By default, all the program unit body stubs generated by @code{gnatstub}\n raise the predefined @code{Program_Error} exception, which will catch"}, {"sha": "06f314a27b735f61c5e798cb53ce852fa1827f24", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -2980,12 +2980,13 @@ package body Sem_Ch3 is\n    -----------------------------\n \n    procedure Analyze_Object_Contract (Obj_Id : Entity_Id) is\n-      AR_Val : Boolean := False;\n-      AW_Val : Boolean := False;\n-      ER_Val : Boolean := False;\n-      EW_Val : Boolean := False;\n-      Prag   : Node_Id;\n-      Seen   : Boolean := False;\n+      Obj_Typ : constant Entity_Id := Etype (Obj_Id);\n+      AR_Val  : Boolean := False;\n+      AW_Val  : Boolean := False;\n+      ER_Val  : Boolean := False;\n+      EW_Val  : Boolean := False;\n+      Prag    : Node_Id;\n+      Seen    : Boolean := False;\n \n    begin\n       if Ekind (Obj_Id) = E_Constant then\n@@ -3008,26 +3009,43 @@ package body Sem_Ch3 is\n          --  they are not standard Ada legality rules.\n \n          if SPARK_Mode = On then\n+            if Is_SPARK_Volatile_Object (Obj_Id) then\n \n-            --  A non-volatile object cannot have volatile components\n-            --  (SPARK RM 7.1.3(7)).\n+               --  The declaration of a volatile object must appear at the\n+               --  library level (SPARK RM 7.1.3(7), C.6(6)).\n \n-            if not Is_SPARK_Volatile_Object (Obj_Id)\n-              and then Has_Volatile_Component (Etype (Obj_Id))\n-            then\n-               Error_Msg_N\n-                 (\"non-volatile variable & cannot have volatile components\",\n-                  Obj_Id);\n+               if not Is_Library_Level_Entity (Obj_Id) then\n+                  Error_Msg_N\n+                    (\"volatile variable & must be declared at library level\",\n+                     Obj_Id);\n \n-            --  The declaration of a volatile object must appear at the library\n-            --  level.\n+               --  An object of a discriminated type cannot be volatile\n+               --  (SPARK RM C.6(4)).\n \n-            elsif Is_SPARK_Volatile_Object (Obj_Id)\n-              and then not Is_Library_Level_Entity (Obj_Id)\n-            then\n-               Error_Msg_N\n-                 (\"volatile variable & must be declared at library level \"\n-                  & \"(SPARK RM 7.1.3(5))\", Obj_Id);\n+               elsif Has_Discriminants (Obj_Typ) then\n+                  Error_Msg_N\n+                    (\"discriminated object & cannot be volatile\", Obj_Id);\n+\n+               --  An object of a tagged type cannot be volatile\n+               --  (SPARK RM C.6(5)).\n+\n+               elsif Is_Tagged_Type (Obj_Typ) then\n+                  Error_Msg_N (\"tagged object & cannot be volatile\", Obj_Id);\n+               end if;\n+\n+            --  The object is not volatile\n+\n+            else\n+               --  A non-volatile object cannot have volatile components\n+               --  (SPARK RM 7.1.3(7)).\n+\n+               if not Is_SPARK_Volatile_Object (Obj_Id)\n+                 and then Has_Volatile_Component (Obj_Typ)\n+               then\n+                  Error_Msg_N\n+                    (\"non-volatile object & cannot have volatile components\",\n+                     Obj_Id);\n+               end if;\n             end if;\n          end if;\n "}, {"sha": "8365ff79869faaf5faf6dc82d7a9770c0a5f89d0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601bb6b35ea9a185c360d73a90a3fcd5c9d286fd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=601bb6b35ea9a185c360d73a90a3fcd5c9d286fd", "patch": "@@ -6387,6 +6387,21 @@ package body Sem_Prag is\n             Error_Pragma_Arg\n               (\"inappropriate entity for pragma%\", Arg1);\n          end if;\n+\n+         --  The following check are only relevant when SPARK_Mode is on as\n+         --  those are not a standard Ada legality rule. Pragma Volatile can\n+         --  only apply to a full type declaration or an object declaration\n+         --  (SPARK RM C.6(1)).\n+\n+         if SPARK_Mode = On\n+           and then Prag_Id = Pragma_Volatile\n+           and then not Nkind_In (K, N_Full_Type_Declaration,\n+                                     N_Object_Declaration)\n+         then\n+            Error_Pragma_Arg\n+              (\"argument of pragma % must denote a full type or object \"\n+               & \"declaration\", Arg1);\n+         end if;\n       end Process_Atomic_Shared_Volatile;\n \n       -------------------------------------------"}]}