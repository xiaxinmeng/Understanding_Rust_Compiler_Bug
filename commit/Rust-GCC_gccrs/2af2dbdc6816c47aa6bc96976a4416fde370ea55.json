{"sha": "2af2dbdc6816c47aa6bc96976a4416fde370ea55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFmMmRiZGM2ODE2YzQ3YWE2YmM5Njk3NmE0NDE2ZmRlMzcwZWE1NQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-01-29T14:51:46Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-01-29T14:51:46Z"}, "message": "tm.texi (TARGET_IRA_COVER_CLASSES): Modify description.\n\n2008-01-29  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* doc/tm.texi (TARGET_IRA_COVER_CLASSES): Modify description.\n\t* doc/passes.texi: Remove entries about regclass, local-alloc, and\n\tglobal.  Modify entries about regmove and IRA.\n\n\t* ra-conflict.c: Remove the file.\n\n\t* reload.c (push_reload, find_dummy_reload): Remove flag_ira.\n\n\t* tree-pass.h (pass_local_alloc, pass_global_alloc): Remove.\n\t(pass_regclass_init): Rename to pass_reginfo_init.\n\n\t* cfgloopanal.c (estimate_reg_pressure_cost): Remove flag_ira.\n\n\t* toplev.h (flag_ira): Remove.\n\n\t* caller-save.c (setup_save_areas): Remove flag_ira.\n\n\t* ira-color.c (ira_reuse_stack_slot, ira_mark_new_stack_slot):\n\tDitto.\n\n\t* global.c: Remove the file.\n\n\t* opts.c: (decode_options): Remove flag_ira.\n\n\t* hard-reg-set.h (losing_caller_save_reg_set): Remove.\n\n\t* regmove.c: Modify file description.\n\t(find_use_as_address, try_auto_increment): Define them only if\n\tAUTO_INC_DEC is defined.\n\t(replacement_quality, replace_in_call_usage, fixup_match_1,\n\tstable_and_no_regs_but_for_p): Remove.\n\t(reg_set_in_bb): Make it static.\n\t(regmove_optimize): Remove flag_ira and code which worked for\n\t!flag_ira.\n\n\t* local-alloc.c: Remove the file.\n\n\t* common.opt (fira): Remove.\n\n\t* ira.c: Include except.h.\n\t(eliminable_regset): Move from global.c.\n\t(mark_elimination): Ditto.  Remove flag_ira.\n\t(reg_renumber, struct equivalence, reg_equiv, equiv_mem,\n\tequiv_mem_modified, validate_equiv_mem_from_store,\n\tvalidate_equiv_mem, equiv_init_varies_p, equiv_init_movable_p,\n\tcontains_replace_regs, memref_referenced_p, memref_used_between_p,\n\tno_equiv, recorded_label_ref): Move from local-alloc.c.\n\t(update_equiv_regs): Ditto.  Make it static.\n\t(print_insn_chain, print_insn_chains): Move it from global.c.\n\tpseudo_for_reload_consideration_p): Ditto.  Remove flag_ira.\n\t(build_insn_chain): Ditto.  Make it static.\n\t(ra_init_live_subregs): Move from ra-conflict.c.  Make it static.\n\tRename to init_live_subregs.\n\t(gate_ira): Remove flag_ira.\n\n\t* regclass.c: Rename reginfo.c.  Change file description.\n\t(FORBIDDEN_INC_DEC_CLASSES): Remove.\n\t(reg_class_superclasses, forbidden_inc_dec_class, in_inc_dec):\n\tRemove.\n\t(init_reg_sets_1): Remove code for evaluation of\n\treg_class_superclasses and losing_caller_save_reg_set.\n\t(init_regs): Remove init_reg_autoinc.\n\t(struct costs, costs, init_cost, ok_for_index_p_nonstrict,\n\tok_for_base_p_nonstrict): Remove.\n\t(regclass_init): Rename to reginfo_init.  Don't initialize\n\tinit_cost.\n\t(pass_regclass_init): Rename to pass_reginfo_init.  Modify\n\tcorresponding entries.\n\t(dump_regclass, record_operand_costs, scan_one_insn,\n\tinit_reg_autoinc, regclass, record_reg_classes, copy_cost,\n\trecord_address_regs, auto_inc_dec_reg_p): Remove.\n\t(gt-regclass.h): Rename to gt-reginfo.h.\n\n\t* rtl.h (dump_global_regs, retry_global_alloc,\n\tbuild_insn_chain, dump_local_alloc, update_equiv_regs):\n\tRemove.\n\n\t* Makefile.in (RA_H): Remove.\n\t(OBJS-common): Remove global.o, local-alloc.o, and ra-conflict.o.\n\tRename regclass.o to reginfo.o.\n\t(regclass.o): Rename to reginfo.o.  Rename gt-regclass.h to\n\tgt-reginfo.h.\n\t(global.o, local-alloc.o, ra-conflict.o): Remove entries.\n\t(GTFILES): Rename regclass.c to\treginfo.c.\n\n\t* passes.c (init_optimization_passes): Remove pass_local_alloc and\n\tpass_global_alloc.  Rename pass_regclass_init to\n\tpass_reginfo_init.\n\n\t* reload1.c (compute_use_by_pseudos, reload, count_pseudo,\n\tcount_spilled_pseudo, find_reg, alter_reg, delete_output_reload):\n\tRemove flag_ira.\n\t(finish_spills): Ditto.  Remove code for !flga_ira.\n\nFrom-SVN: r143757", "tree": {"sha": "902a133df01742f3e4254602b265d61345318fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/902a133df01742f3e4254602b265d61345318fc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2af2dbdc6816c47aa6bc96976a4416fde370ea55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2af2dbdc6816c47aa6bc96976a4416fde370ea55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2af2dbdc6816c47aa6bc96976a4416fde370ea55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2af2dbdc6816c47aa6bc96976a4416fde370ea55/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00b251a0371e71bce271656eb7d069851cbd7fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b251a0371e71bce271656eb7d069851cbd7fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b251a0371e71bce271656eb7d069851cbd7fcf"}], "stats": {"total": 9436, "additions": 1530, "deletions": 7906}, "files": [{"sha": "1a83aea6132aa403d17813f7e4c6535dbf94ad27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -1,3 +1,99 @@\n+2008-01-29  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/tm.texi (TARGET_IRA_COVER_CLASSES): Modify description.\n+\t* doc/passes.texi: Remove entries about regclass, local-alloc, and\n+\tglobal.  Modify entries about regmove and IRA.\n+\n+\t* ra-conflict.c: Remove the file.\n+\n+\t* reload.c (push_reload, find_dummy_reload): Remove flag_ira.\n+\n+\t* tree-pass.h (pass_local_alloc, pass_global_alloc): Remove.\n+\t(pass_regclass_init): Rename to pass_reginfo_init.\n+\n+\t* cfgloopanal.c (estimate_reg_pressure_cost): Remove flag_ira.\n+\n+\t* toplev.h (flag_ira): Remove.\n+\n+\t* caller-save.c (setup_save_areas): Remove flag_ira.\n+\n+\t* ira-color.c (ira_reuse_stack_slot, ira_mark_new_stack_slot):\n+\tDitto.\n+\n+\t* global.c: Remove the file.\n+\n+\t* opts.c: (decode_options): Remove flag_ira.\n+\n+\t* hard-reg-set.h (losing_caller_save_reg_set): Remove.\n+\n+\t* regmove.c: Modify file description.\n+\t(find_use_as_address, try_auto_increment): Define them only if\n+\tAUTO_INC_DEC is defined.\n+\t(replacement_quality, replace_in_call_usage, fixup_match_1,\n+\tstable_and_no_regs_but_for_p): Remove.\n+\t(reg_set_in_bb): Make it static.\n+\t(regmove_optimize): Remove flag_ira and code which worked for\n+\t!flag_ira.\n+\n+\t* local-alloc.c: Remove the file.\n+\n+\t* common.opt (fira): Remove.\n+\n+\t* ira.c: Include except.h.\n+\t(eliminable_regset): Move from global.c.\n+\t(mark_elimination): Ditto.  Remove flag_ira.\n+\t(reg_renumber, struct equivalence, reg_equiv, equiv_mem,\n+\tequiv_mem_modified, validate_equiv_mem_from_store,\n+\tvalidate_equiv_mem, equiv_init_varies_p, equiv_init_movable_p,\n+\tcontains_replace_regs, memref_referenced_p, memref_used_between_p,\n+\tno_equiv, recorded_label_ref): Move from local-alloc.c.\n+\t(update_equiv_regs): Ditto.  Make it static.\n+\t(print_insn_chain, print_insn_chains): Move it from global.c.\n+\tpseudo_for_reload_consideration_p): Ditto.  Remove flag_ira.\n+\t(build_insn_chain): Ditto.  Make it static.\n+\t(ra_init_live_subregs): Move from ra-conflict.c.  Make it static.\n+\tRename to init_live_subregs.\n+\t(gate_ira): Remove flag_ira.\n+\n+\t* regclass.c: Rename reginfo.c.  Change file description.\n+\t(FORBIDDEN_INC_DEC_CLASSES): Remove.\n+\t(reg_class_superclasses, forbidden_inc_dec_class, in_inc_dec):\n+\tRemove.\n+\t(init_reg_sets_1): Remove code for evaluation of\n+\treg_class_superclasses and losing_caller_save_reg_set.\n+\t(init_regs): Remove init_reg_autoinc.\n+\t(struct costs, costs, init_cost, ok_for_index_p_nonstrict,\n+\tok_for_base_p_nonstrict): Remove.\n+\t(regclass_init): Rename to reginfo_init.  Don't initialize\n+\tinit_cost.\n+\t(pass_regclass_init): Rename to pass_reginfo_init.  Modify\n+\tcorresponding entries.\n+\t(dump_regclass, record_operand_costs, scan_one_insn,\n+\tinit_reg_autoinc, regclass, record_reg_classes, copy_cost,\n+\trecord_address_regs, auto_inc_dec_reg_p): Remove.\n+\t(gt-regclass.h): Rename to gt-reginfo.h.\n+\n+\t* rtl.h (dump_global_regs, retry_global_alloc,\n+\tbuild_insn_chain, dump_local_alloc, update_equiv_regs):\n+\tRemove.\n+\n+\t* Makefile.in (RA_H): Remove.\n+\t(OBJS-common): Remove global.o, local-alloc.o, and ra-conflict.o.\n+\tRename regclass.o to reginfo.o.\n+\t(regclass.o): Rename to reginfo.o.  Rename gt-regclass.h to\n+\tgt-reginfo.h.\n+\t(global.o, local-alloc.o, ra-conflict.o): Remove entries.\n+\t(GTFILES): Rename regclass.c to\treginfo.c.\n+\n+\t* passes.c (init_optimization_passes): Remove pass_local_alloc and\n+\tpass_global_alloc.  Rename pass_regclass_init to\n+\tpass_reginfo_init.\n+\n+\t* reload1.c (compute_use_by_pseudos, reload, count_pseudo,\n+\tcount_spilled_pseudo, find_reg, alter_reg, delete_output_reload):\n+\tRemove flag_ira.\n+\t(finish_spills): Ditto.  Remove code for !flga_ira.\n+\t\n 2009-01-29  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \tPR middle-end/35854"}, {"sha": "3e09ccadbf8553bf109bf5fae82b291b34371f21", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -824,7 +824,6 @@ FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) varray.h\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)\n-RA_H = ra.h $(REGS_H)\n RESOURCE_H = resource.h hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) vecprim.h\n SEL_SCHED_IR_H = sel-sched-ir.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) \\\n@@ -1115,7 +1114,6 @@ OBJS-common = \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n \tgimplify.o \\\n-\tglobal.o \\\n \tgraph.o \\\n \tgraphds.o \\\n \tgraphite.o \\\n@@ -1140,7 +1138,6 @@ OBJS-common = \\\n \tlanghooks.o \\\n \tlcm.o \\\n \tlists.o \\\n-\tlocal-alloc.o \\\n \tloop-doloop.o \\\n \tloop-init.o \\\n \tloop-invariant.o \\\n@@ -1167,11 +1164,10 @@ OBJS-common = \\\n \tprint-rtl.o \\\n \tprint-tree.o \\\n \tprofile.o \\\n-\tra-conflict.o \\\n \treal.o \\\n \trecog.o \\\n \treg-stack.o \\\n-\tregclass.o \\\n+\treginfo.o \\\n \tregmove.o \\\n \tregrename.o \\\n \tregstat.o \\\n@@ -2842,25 +2838,13 @@ combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) $(REAL_H) hard-reg-set.h \\\n    $(TOPLEV_H) $(TM_P_H) $(TREE_H) $(TARGET_H) output.h $(PARAMS_H) $(OPTABS_H) \\\n    insn-codes.h $(TIMEVAR_H) tree-pass.h $(DF_H) vecprim.h $(CGRAPH_H)\n-regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) addresses.h $(REGS_H) insn-config.h \\\n    $(RECOG_H) reload.h $(REAL_H) $(TOPLEV_H) $(FUNCTION_H) output.h $(GGC_H) \\\n-   $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-regclass.h $(HASHTAB_H) \\\n+   $(TM_P_H) $(EXPR_H) $(TIMEVAR_H) gt-reginfo.h $(HASHTAB_H) \\\n    $(TARGET_H) tree-pass.h $(DF_H) ira.h\n-local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n-   output.h $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H)  except.h reload.h $(TM_P_H) \\\n-   $(GGC_H) $(INTEGRATE_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H)\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(GGC_H) gt-bitmap.h $(BITMAP_H) $(OBSTACK_H) $(HASHTAB_H)\n-global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h output.h $(TOPLEV_H) $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n-   $(TIMEVAR_H) vecprim.h $(DF_H) $(DBGCNT_H) $(RA_H) ira.h\n-ra-conflict.o : ra-conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h output.h $(TOPLEV_H) $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n-   $(TIMEVAR_H) vecprim.h $(DF_H) $(RA_H) sbitmap.h sparseset.h\n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) $(TOPLEV_H)\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \\\n@@ -3303,7 +3287,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/expr.h \\\n   $(srcdir)/function.c $(srcdir)/except.h \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n-  $(srcdir)/profile.c $(srcdir)/regclass.c $(srcdir)/mcf.c \\\n+  $(srcdir)/profile.c $(srcdir)/reginfo.c $(srcdir)/mcf.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\"}, {"sha": "303da88bb48df6ac36428a74cb708cc8d7d0a5d7", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -448,7 +448,7 @@ setup_save_areas (void)\n \t    SET_HARD_REG_BIT (hard_regs_used, r);\n       }\n \n-  if (flag_ira && optimize && flag_ira_share_save_slots)\n+  if (optimize && flag_ira_share_save_slots)\n     {\n       rtx insn, slot;\n       struct insn_chain *chain, *next;"}, {"sha": "120371368a221bbc227ebb4d653650d54ab9e5bc", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -396,8 +396,8 @@ estimate_reg_pressure_cost (unsigned n_new, unsigned n_old, bool speed)\n        one.  */\n     cost = target_spill_cost [speed] * n_new;\n \n-  if (optimize && flag_ira && (flag_ira_region == IRA_REGION_ALL\n-\t\t\t       || flag_ira_region == IRA_REGION_MIXED)\n+  if (optimize && (flag_ira_region == IRA_REGION_ALL\n+\t\t   || flag_ira_region == IRA_REGION_MIXED)\n       && number_of_loops () <= (unsigned) IRA_MAX_LOOPS_NUM)\n     /* IRA regional allocation deals with high register pressure\n        better.  So decrease the cost (to do more accurate the cost"}, {"sha": "774bef36b532a8e0fbfb2cfebdc74f75d804cdc9", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -679,10 +679,6 @@ Common Report Var(flag_ipa_struct_reorg)\n Perform structure layout optimizations based\n on profiling information.\n \n-fira\n-Common Report Var(flag_ira) Init(0)\n-Use integrated register allocator.\n-\n fira-algorithm=\n Common Joined RejectNegative\n -fira-algorithm=[CB|priority] Set the used IRA algorithm"}, {"sha": "6d32b07efe72348745695763edf6ce767d4092eb", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -826,24 +826,12 @@ them on the stack.  This is done in several subpasses:\n \n @itemize @bullet\n @item\n-Register class preferencing.  The RTL code is scanned to find out\n-which register class is best for each pseudo register.  The source\n-file is @file{regclass.c}.\n+Register move optimizations.  This pass makes some simple RTL code\n+transformations which improve the subsequent register allocation.  The\n+source file is @file{regmove.c}.\n \n @item\n-Local register allocation.  This pass allocates hard registers to\n-pseudo registers that are used only within one basic block.  Because\n-the basic block is linear, it can use fast and powerful techniques to\n-do a decent job.  The source is located in @file{local-alloc.c}.\n-\n-@item\n-Global register allocation.  This pass allocates hard registers for\n-the remaining pseudo registers (those whose life spans are not\n-contained in one basic block).  The pass is located in @file{global.c}.\n-\n-@item\n-The optional integrated register allocator (@acronym{IRA}).  It can be\n-used instead of the local and global allocator.  It is called\n+The integrated register allocator (@acronym{IRA}).  It is called\n integrated because coalescing, register live range splitting, and hard\n register preferencing are done on-the-fly during coloring.  It also\n has better integration with the reload pass.  Pseudo-registers spilled"}, {"sha": "abf070d91c27dd2cc080e248a6372300d0f48a7c", "filename": "gcc/global.c", "status": "removed", "additions": 0, "deletions": 1849, "changes": 1849, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b251a0371e71bce271656eb7d069851cbd7fcf/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b251a0371e71bce271656eb7d069851cbd7fcf/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=00b251a0371e71bce271656eb7d069851cbd7fcf", "patch": "@@ -1,1849 +0,0 @@\n-/* Allocate registers for pseudo-registers that span basic blocks.\n-   Copyright (C) 1987, 1988, 1991, 1994, 1996, 1997, 1998,\n-   1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"machmode.h\"\n-#include \"hard-reg-set.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"flags.h\"\n-#include \"regs.h\"\n-#include \"function.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"reload.h\"\n-#include \"output.h\"\n-#include \"toplev.h\"\n-#include \"tree-pass.h\"\n-#include \"timevar.h\"\n-#include \"df.h\"\n-#include \"vecprim.h\"\n-#include \"dbgcnt.h\"\n-#include \"ra.h\"\n-#include \"ira.h\"\n-\n-/* This pass of the compiler performs global register allocation.\n-   It assigns hard register numbers to all the pseudo registers\n-   that were not handled in local_alloc.  Assignments are recorded\n-   in the vector reg_renumber, not by changing the rtl code.\n-   (Such changes are made by final).  The entry point is\n-   the function global_alloc.\n-\n-   After allocation is complete, the reload pass is run as a subroutine\n-   of this pass, so that when a pseudo reg loses its hard reg due to\n-   spilling it is possible to make a second attempt to find a hard\n-   reg for it.  The reload pass is independent in other respects\n-   and it is run even when stupid register allocation is in use.\n-\n-   1. Assign allocation-numbers (allocnos) to the pseudo-registers\n-   still needing allocations and to the pseudo-registers currently\n-   allocated by local-alloc which may be spilled by reload.\n-   Set up tables reg_allocno and allocno_reg to map\n-   reg numbers to allocnos and vice versa.\n-   max_allocno gets the number of allocnos in use.\n-\n-   2. Allocate a max_allocno by max_allocno compressed triangular conflict\n-   bit matrix (a triangular bit matrix with portions removed for which we\n-   can guarantee there are no conflicts, example: two local pseudos that\n-   live in different basic blocks) and clear it.  This is called \"conflict\".\n-   Note that for triangular bit matrices, there are two possible equations\n-   for computing the bit number for two allocnos: LOW and HIGH (LOW < HIGH):\n-\n-     1) BITNUM = f(HIGH) + LOW, where\n-       f(HIGH) = (HIGH * (HIGH - 1)) / 2\n-\n-     2) BITNUM = f(LOW) + HIGH, where\n-       f(LOW) = LOW * (max_allocno - LOW) + (LOW * (LOW - 1)) / 2 - LOW - 1\n-\n-   We use the second (and less common) equation as this gives us better\n-   cache locality for local allocnos that are live within the same basic\n-   block.  Also note that f(HIGH) and f(LOW) can be precalculated for all\n-   values of HIGH and LOW, so all that is necessary to compute the bit\n-   number for two allocnos LOW and HIGH is a load followed by an addition.\n-\n-   Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix for\n-   conflicts between allocnos and explicit hard register use (which\n-   includes use of pseudo-registers allocated by local_alloc).  This\n-   is the hard_reg_conflicts inside each allocno.\n-\n-   3. For each basic block, walk backward through the block, recording\n-   which pseudo-registers and which hardware registers are live.\n-   Build the conflict matrix between the pseudo-registers and another of\n-   pseudo-registers versus hardware registers.\n-\n-   4. For each basic block, walk backward through the block, recording\n-   the preferred hardware registers for each pseudo-register.\n-\n-   5. Sort a table of the allocnos into order of desirability of the variables.\n-\n-   6. Allocate the variables in that order; each if possible into\n-   a preferred register, else into another register.  */\n-\f\n-/* A vector of the integers from 0 to max_allocno-1,\n-   sorted in the order of first-to-be-allocated first.  */\n-\n-static int *allocno_order;\n-\n-/* Set of registers that global-alloc isn't supposed to use.  */\n-\n-static HARD_REG_SET no_global_alloc_regs;\n-\n-/* Set of registers used so far.  */\n-\n-static HARD_REG_SET regs_used_so_far;\n-\n-/* Number of refs to each hard reg, as used by local alloc.\n-   It is zero for a reg that contains global pseudos or is explicitly used.  */\n-\n-static int local_reg_n_refs[FIRST_PSEUDO_REGISTER];\n-\n-/* Frequency of uses of given hard reg.  */\n-static int local_reg_freq[FIRST_PSEUDO_REGISTER];\n-\n-/* Guess at live length of each hard reg, as used by local alloc.\n-   This is actually the sum of the live lengths of the specific regs.  */\n-\n-static int local_reg_live_length[FIRST_PSEUDO_REGISTER];\n-\n-/* Set to 1 a bit in a vector TABLE of HARD_REG_SETs, for vector\n-   element I, and hard register number J.  */\n-\n-#define SET_REGBIT(TABLE, I, J)  SET_HARD_REG_BIT (allocno[I].TABLE, J)\n-\n-/* Return true if *LOC contains an asm.  */\n-\n-static int\n-insn_contains_asm_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n-{\n-  if ( !*loc)\n-    return 0;\n-  if (GET_CODE (*loc) == ASM_OPERANDS)\n-    return 1;\n-  return 0;\n-}\n-\n-\n-/* Return true if INSN contains an ASM.  */\n-\n-static int\n-insn_contains_asm (rtx insn)\n-{\n-  return for_each_rtx (&insn, insn_contains_asm_1, NULL);\n-}\n-\n-\n-static void\n-compute_regs_asm_clobbered (char *regs_asm_clobbered)\n-{\n-  basic_block bb;\n-\n-  memset (regs_asm_clobbered, 0, sizeof (char) * FIRST_PSEUDO_REGISTER);\n-  \n-  FOR_EACH_BB (bb)\n-    {\n-      rtx insn;\n-      FOR_BB_INSNS_REVERSE (bb, insn)\n-\t{\n-\t  df_ref *def_rec;\n-\t  if (insn_contains_asm (insn))\n-\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-\t      {\n-\t\tdf_ref def = *def_rec;\n-\t\tunsigned int dregno = DF_REF_REGNO (def);\n-\t\tif (dregno < FIRST_PSEUDO_REGISTER)\n-\t\t  {\n-\t\t    unsigned int i;\n-\t\t    enum machine_mode mode = GET_MODE (DF_REF_REAL_REG (def));\n-\t\t    unsigned int end = dregno \n-\t\t      + hard_regno_nregs[dregno][mode] - 1;\n-\t\t    for (i = dregno; i <= end; ++i)\n-\t\t      regs_asm_clobbered[i] = 1;\n-\t\t  }\n-\t      }\n-\t}\n-    }\n-}\n-\n-\n-/* All registers that can be eliminated.  */\n-\n-HARD_REG_SET eliminable_regset;\n-\n-static int regno_compare (const void *, const void *);\n-static int allocno_compare (const void *, const void *);\n-static void expand_preferences (void);\n-static void prune_preferences (void);\n-static void set_preferences (void);\n-static void find_reg (int, HARD_REG_SET, int, int, int);\n-static void dump_conflicts (FILE *);\n-\f\n-\n-/* Look through the list of eliminable registers.  Set ELIM_SET to the\n-   set of registers which may be eliminated.  Set NO_GLOBAL_SET to the\n-   set of registers which may not be used across blocks.\n-\n-   This will normally be called with ELIM_SET as the file static\n-   variable eliminable_regset, and NO_GLOBAL_SET as the file static\n-   variable NO_GLOBAL_ALLOC_REGS.\n-\n-   It also initializes global flag frame_pointer_needed.  */\n-\n-static void\n-compute_regsets (HARD_REG_SET *elim_set, \n-                 HARD_REG_SET *no_global_set)\n-{\n-\n-/* Like regs_ever_live, but 1 if a reg is set or clobbered from an asm.\n-   Unlike regs_ever_live, elements of this array corresponding to\n-   eliminable regs like the frame pointer are set if an asm sets them.  */\n-  char *regs_asm_clobbered = XALLOCAVEC (char, FIRST_PSEUDO_REGISTER);\n-\n-#ifdef ELIMINABLE_REGS\n-  static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n-  size_t i;\n-#endif\n-\n-  /* FIXME: If EXIT_IGNORE_STACK is set, we will not save and restore\n-     sp for alloca.  So we can't eliminate the frame pointer in that\n-     case.  At some point, we should improve this by emitting the\n-     sp-adjusting insns for this case.  */\n-  int need_fp\n-    = (! flag_omit_frame_pointer\n-       || (cfun->calls_alloca && EXIT_IGNORE_STACK)\n-       || crtl->accesses_prior_frames\n-       || crtl->stack_realign_needed\n-       || FRAME_POINTER_REQUIRED);\n-\n-  frame_pointer_needed = need_fp;\n-\n-  max_regno = max_reg_num ();\n-  compact_blocks ();\n-\n-  max_allocno = 0;\n-\n-  /* A machine may have certain hard registers that\n-     are safe to use only within a basic block.  */\n-\n-  CLEAR_HARD_REG_SET (*no_global_set);\n-  CLEAR_HARD_REG_SET (*elim_set);\n-\n-  compute_regs_asm_clobbered (regs_asm_clobbered);\n-  /* Build the regset of all eliminable registers and show we can't use those\n-     that we already know won't be eliminated.  */\n-#ifdef ELIMINABLE_REGS\n-  for (i = 0; i < ARRAY_SIZE (eliminables); i++)\n-    {\n-      bool cannot_elim\n-\t= (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n-\t   || (eliminables[i].to == STACK_POINTER_REGNUM\n-\t       && need_fp \n-\t       && (! SUPPORTS_STACK_ALIGNMENT\n-\t\t   || ! stack_realign_fp)));\n-\n-      if (!regs_asm_clobbered[eliminables[i].from])\n-\t{\n-\t  SET_HARD_REG_BIT (*elim_set, eliminables[i].from);\n-\n-\t  if (cannot_elim)\n-\t    SET_HARD_REG_BIT (*no_global_set, eliminables[i].from);\n-\t}\n-      else if (cannot_elim)\n-\terror (\"%s cannot be used in asm here\",\n-\t       reg_names[eliminables[i].from]);\n-      else\n-\tdf_set_regs_ever_live (eliminables[i].from, true);\n-    }\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-  if (!regs_asm_clobbered[HARD_FRAME_POINTER_REGNUM])\n-    {\n-      SET_HARD_REG_BIT (*elim_set, HARD_FRAME_POINTER_REGNUM);\n-      if (need_fp)\n-\tSET_HARD_REG_BIT (*no_global_set, HARD_FRAME_POINTER_REGNUM);\n-    }\n-  else if (need_fp)\n-    error (\"%s cannot be used in asm here\",\n-\t   reg_names[HARD_FRAME_POINTER_REGNUM]);\n-  else\n-    df_set_regs_ever_live (HARD_FRAME_POINTER_REGNUM, true);\n-#endif\n-\n-#else\n-  if (!regs_asm_clobbered[FRAME_POINTER_REGNUM])\n-    {\n-      SET_HARD_REG_BIT (*elim_set, FRAME_POINTER_REGNUM);\n-      if (need_fp)\n-\tSET_HARD_REG_BIT (*no_global_set, FRAME_POINTER_REGNUM);\n-    }\n-  else if (need_fp)\n-    error (\"%s cannot be used in asm here\", reg_names[FRAME_POINTER_REGNUM]);\n-  else\n-    df_set_regs_ever_live (FRAME_POINTER_REGNUM, true);\n-#endif\n-}\n-\n-/* Perform allocation of pseudo-registers not allocated by local_alloc.\n-\n-   Return value is nonzero if reload failed\n-   and we must not do any more for this function.  */\n-\n-static int\n-global_alloc (void)\n-{\n-  int retval;\n-  size_t i;\n-  int max_blk;\n-  int *num_allocnos_per_blk;\n-\n-  compute_regsets (&eliminable_regset, &no_global_alloc_regs);\n-\n-  /* Track which registers have already been used.  Start with registers\n-     explicitly in the rtl, then registers allocated by local register\n-     allocation.  */\n-\n-  CLEAR_HARD_REG_SET (regs_used_so_far);\n-#ifdef LEAF_REGISTERS\n-  /* If we are doing the leaf function optimization, and this is a leaf\n-     function, it means that the registers that take work to save are those\n-     that need a register window.  So prefer the ones that can be used in\n-     a leaf function.  */\n-  {\n-    const char *cheap_regs;\n-    const char *const leaf_regs = LEAF_REGISTERS;\n-\n-    if (only_leaf_regs_used () && leaf_function_p ())\n-      cheap_regs = leaf_regs;\n-    else\n-      cheap_regs = call_used_regs;\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (df_regs_ever_live_p (i) || cheap_regs[i])\n-\tSET_HARD_REG_BIT (regs_used_so_far, i);\n-  }\n-#else\n-  /* We consider registers that do not have to be saved over calls as if\n-     they were already used since there is no cost in using them.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (df_regs_ever_live_p (i) || call_used_regs[i])\n-      SET_HARD_REG_BIT (regs_used_so_far, i);\n-#endif\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n-    if (reg_renumber[i] >= 0)\n-      SET_HARD_REG_BIT (regs_used_so_far, reg_renumber[i]);\n-\n-  /* Establish mappings from register number to allocation number\n-     and vice versa.  In the process, count the allocnos.  */\n-\n-  reg_allocno = XNEWVEC (int, max_regno);\n-\n-  /* Initially fill the reg_allocno array with regno's...  */\n-  max_blk = 0;\n-  max_allocno = 0;\n-  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n-    /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n-       that we are supposed to refrain from putting in a hard reg.\n-       -2 means do make an allocno but don't allocate it.  */\n-    if (REG_N_REFS (i) != 0 && REG_LIVE_LENGTH (i) != -1\n-\t/* Don't allocate pseudos that cross calls,\n-\t   if this function receives a nonlocal goto.  */\n-\t&& (! cfun->has_nonlocal_label\n-\t    || REG_N_CALLS_CROSSED (i) == 0))\n-      {\n-\tint blk = regno_basic_block (i);\n-\treg_allocno[max_allocno++] = i;\n-\tif (blk > max_blk)\n-\t  max_blk = blk;\n-\tgcc_assert (REG_LIVE_LENGTH (i));\n-      }\n-\n-  allocno = XCNEWVEC (struct allocno, max_allocno);\n-  partial_bitnum = XNEWVEC (HOST_WIDE_INT, max_allocno);\n-  num_allocnos_per_blk = XCNEWVEC (int, max_blk + 1);\n-\n-  /* ...so we can sort them in the order we want them to receive\n-     their allocnos.  */\n-  qsort (reg_allocno, max_allocno, sizeof (int), regno_compare);\n-\n-  for (i = 0; i < (size_t) max_allocno; i++)\n-    {\n-      int regno = reg_allocno[i];\n-      int blk = regno_basic_block (regno);\n-      num_allocnos_per_blk[blk]++;\n-      allocno[i].reg = regno;\n-      allocno[i].size = PSEUDO_REGNO_SIZE (regno);\n-      allocno[i].calls_crossed += REG_N_CALLS_CROSSED (regno);\n-      allocno[i].freq_calls_crossed += REG_FREQ_CALLS_CROSSED (regno);\n-      allocno[i].throwing_calls_crossed\n-\t+= REG_N_THROWING_CALLS_CROSSED (regno);\n-      allocno[i].n_refs += REG_N_REFS (regno);\n-      allocno[i].freq += REG_FREQ (regno);\n-      if (allocno[i].live_length < REG_LIVE_LENGTH (regno))\n-\tallocno[i].live_length = REG_LIVE_LENGTH (regno);\n-    }\n-\n-  /* The \"global\" block must contain all allocnos.  */\n-  num_allocnos_per_blk[0] = max_allocno;\n-\n-  /* Now reinitialize the reg_allocno array in terms of the\n-     optimized regno to allocno mapping we created above.  */\n-  for (i = 0; i < (size_t) max_regno; i++)\n-    reg_allocno[i] = -1;\n-\n-  max_bitnum = 0;\n-  for (i = 0; i < (size_t) max_allocno; i++)\n-    {\n-      int regno = allocno[i].reg;\n-      int blk = regno_basic_block (regno);\n-      int row_size = --num_allocnos_per_blk[blk];\n-      reg_allocno[regno] = (int) i;\n-      partial_bitnum[i] = (row_size > 0) ? max_bitnum - ((int) i + 1) : -1;\n-      max_bitnum += row_size;\n-    }\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (max_bitnum <=\n-\t      (((HOST_WIDE_INT) max_allocno *\n-\t\t((HOST_WIDE_INT) max_allocno - 1)) / 2));\n-#endif\n-\n-  if (dump_file)\n-    {\n-      HOST_WIDE_INT num_bits, num_bytes, actual_bytes;\n-\n-      fprintf (dump_file, \"## max_blk:     %d\\n\", max_blk);\n-      fprintf (dump_file, \"## max_regno:   %d\\n\", max_regno);\n-      fprintf (dump_file, \"## max_allocno: %d\\n\", max_allocno);\n-\n-      num_bits = max_bitnum;\n-      num_bytes = CEIL (num_bits, 8);\n-      actual_bytes = num_bytes;\n-      fprintf (dump_file, \"## Compressed triangular bitmatrix size: \");\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC \" bits, \", num_bits);\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC \" bytes\\n\", num_bytes);\n-\n-      num_bits = ((HOST_WIDE_INT) max_allocno *\n-\t\t  ((HOST_WIDE_INT) max_allocno - 1)) / 2;\n-      num_bytes = CEIL (num_bits, 8);\n-      fprintf (dump_file, \"## Standard triangular bitmatrix size:   \");\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC \" bits, \", num_bits);\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC \" bytes [%.2f%%]\\n\",\n-\t       num_bytes, 100.0 * ((double) actual_bytes / (double) num_bytes));\n-\n-      num_bits = (HOST_WIDE_INT) max_allocno * (HOST_WIDE_INT) max_allocno;\n-      num_bytes = CEIL (num_bits, 8);\n-      fprintf (dump_file, \"## Square bitmatrix size:                \");\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC \" bits, \", num_bits);\n-      fprintf (dump_file, HOST_WIDE_INT_PRINT_DEC \" bytes [%.2f%%]\\n\",\n-\t       num_bytes, 100.0 * ((double) actual_bytes / (double) num_bytes));\n-    }\n-\n-  /* Calculate amount of usage of each hard reg by pseudos\n-     allocated by local-alloc.  This is to see if we want to\n-     override it.  */\n-  memset (local_reg_live_length, 0, sizeof local_reg_live_length);\n-  memset (local_reg_n_refs, 0, sizeof local_reg_n_refs);\n-  memset (local_reg_freq, 0, sizeof local_reg_freq);\n-  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n-    if (reg_renumber[i] >= 0)\n-      {\n-\tint regno = reg_renumber[i];\n-\tint endregno = end_hard_regno (PSEUDO_REGNO_MODE (i), regno);\n-\tint j;\n-\n-\tfor (j = regno; j < endregno; j++)\n-\t  {\n-\t    local_reg_n_refs[j] += REG_N_REFS (i);\n-\t    local_reg_freq[j] += REG_FREQ (i);\n-\t    local_reg_live_length[j] += REG_LIVE_LENGTH (i);\n-\t  }\n-      }\n-\n-  /* We can't override local-alloc for a reg used not just by local-alloc.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (df_regs_ever_live_p (i))\n-      local_reg_n_refs[i] = 0, local_reg_freq[i] = 0;\n-\n-  if (dump_file)\n-    {\n-      for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n-\t{\n-\t  fprintf (dump_file, \"%d REG_N_REFS=%d, REG_FREQ=%d, REG_LIVE_LENGTH=%d\\n\", \n-\t\t   (int)i, REG_N_REFS (i), REG_FREQ (i), REG_LIVE_LENGTH (i));\n-\t}\n-      fprintf (dump_file, \"regs_ever_live =\");\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (df_regs_ever_live_p (i))\n-\t  fprintf (dump_file, \" %d\", (int)i);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  conflicts = NULL;\n-  adjacency = NULL;\n-  adjacency_pool = NULL;\n-\n-  /* If there is work to be done (at least one reg to allocate),\n-     perform global conflict analysis and allocate the regs.  */\n-\n-  if (max_allocno > 0)\n-    {\n-      /* We used to use alloca here, but the size of what it would try to\n-\t allocate would occasionally cause it to exceed the stack limit and\n-\t cause unpredictable core dumps.  Some examples were > 2Mb in size.  */\n-      conflicts = XCNEWVEC (HOST_WIDEST_FAST_INT,\n-\t\t\t    CEIL(max_bitnum, HOST_BITS_PER_WIDEST_FAST_INT));\n-\n-      adjacency = XCNEWVEC (adjacency_t *, max_allocno);\n-      adjacency_pool = create_alloc_pool (\"global_alloc adjacency list pool\",\n-\t\t\t\t\t  sizeof (adjacency_t), 1024);\n-\n-      /* Scan all the insns and compute the conflicts among allocnos\n-\t and between allocnos and hard regs.  */\n-\n-      global_conflicts ();\n-\n-      /* There is just too much going on in the register allocators to\n-\t keep things up to date.  At the end we have to rescan anyway\n-\t because things change when the reload_completed flag is set.  \n-\t So we just turn off scanning and we will rescan by hand.  \n-\n-\t However, we needed to do the rescanning before this point to\n-\t get the new insns scanned inserted by local_alloc scanned for\n-\t global_conflicts.  */\n-      df_set_flags (DF_NO_INSN_RESCAN);\n-\n-      /* Eliminate conflicts between pseudos and eliminable registers.  If\n-\t the register is not eliminated, the pseudo won't really be able to\n-\t live in the eliminable register, so the conflict doesn't matter.\n-\t If we do eliminate the register, the conflict will no longer exist.\n-\t So in either case, we can ignore the conflict.  Likewise for\n-\t preferences.  */\n-\n-      set_preferences ();\n-\n-      for (i = 0; i < (size_t) max_allocno; i++)\n-\t{\n-\t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_conflicts,\n-\t\t\t\t  eliminable_regset);\n-\t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_copy_preferences,\n-\t\t\t\t  eliminable_regset);\n-\t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_preferences,\n-\t\t\t\t  eliminable_regset);\n-\t}\n-\n-      /* Try to expand the preferences by merging them between allocnos.  */\n-\n-      expand_preferences ();\n-\n-      /* Determine the order to allocate the remaining pseudo registers.  */\n-\n-      allocno_order = XNEWVEC (int, max_allocno);\n-      for (i = 0; i < (size_t) max_allocno; i++)\n-\tallocno_order[i] = i;\n-\n-      /* Default the size to 1, since allocno_compare uses it to divide by.\n-\t Also convert allocno_live_length of zero to -1.  A length of zero\n-\t can occur when all the registers for that allocno have reg_live_length\n-\t equal to -2.  In this case, we want to make an allocno, but not\n-\t allocate it.  So avoid the divide-by-zero and set it to a low\n-\t priority.  */\n-\n-      for (i = 0; i < (size_t) max_allocno; i++)\n-\t{\n-\t  if (allocno[i].size == 0)\n-\t    allocno[i].size = 1;\n-\t  if (allocno[i].live_length == 0)\n-\t    allocno[i].live_length = -1;\n-\t}\n-\n-      qsort (allocno_order, max_allocno, sizeof (int), allocno_compare);\n-\n-      prune_preferences ();\n-\n-      if (dump_file)\n-\tdump_conflicts (dump_file);\n-\n-      /* Try allocating them, one by one, in that order,\n-\t except for parameters marked with reg_live_length[regno] == -2.  */\n-\n-      for (i = 0; i < (size_t) max_allocno; i++)\n-\tif (reg_renumber[allocno[allocno_order[i]].reg] < 0\n-\t    && REG_LIVE_LENGTH (allocno[allocno_order[i]].reg) >= 0)\n-\t  {\n-            if (!dbg_cnt (global_alloc_at_reg))\n-              break;\n-\t    /* If we have more than one register class,\n-\t       first try allocating in the class that is cheapest\n-\t       for this pseudo-reg.  If that fails, try any reg.  */\n-\t    if (N_REG_CLASSES > 1)\n-\t      {\n-\t\tfind_reg (allocno_order[i], 0, 0, 0, 0);\n-\t\tif (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n-\t\t  continue;\n-\t      }\n-\t    if (reg_alternate_class (allocno[allocno_order[i]].reg) != NO_REGS)\n-\t      find_reg (allocno_order[i], 0, 1, 0, 0);\n-\t  }\n-\n-      free (allocno_order);\n-      free (conflicts);\n-    }\n-\n-  /* Do the reloads now while the allocno data still exists, so that we can\n-     try to assign new hard regs to any pseudo regs that are spilled.  */\n-\n-#if 0 /* We need to eliminate regs even if there is no rtl code,\n-\t for the sake of debugging information.  */\n-  if (n_basic_blocks > NUM_FIXED_BLOCKS)\n-#endif\n-    {\n-      build_insn_chain ();\n-      retval = reload (get_insns (), 1);\n-    }\n-\n-  /* Clean up.  */\n-  free (reg_allocno);\n-  free (num_allocnos_per_blk);\n-  free (partial_bitnum);\n-  free (allocno);\n-  if (adjacency != NULL)\n-    {\n-      free_alloc_pool (adjacency_pool);\n-      free (adjacency);\n-    }\n-\n-  return retval;\n-}\n-\n-/* Sort predicate for ordering the regnos.  We want the regno to allocno\n-   mapping to have the property that all \"global\" regnos (ie, regnos that\n-   are referenced in more than one basic block) have smaller allocno values\n-   than \"local\" regnos (ie, regnos referenced in only one basic block).\n-   In addition, for two basic blocks \"i\" and \"j\" with i < j, all regnos\n-   local to basic block i should have smaller allocno values than regnos\n-   local to basic block j.\n-   Returns -1 (1) if *v1p should be allocated before (after) *v2p.  */\n-\n-static int\n-regno_compare (const void *v1p, const void *v2p)\n-{\n-  int regno1 = *(const int *)v1p;\n-  int regno2 = *(const int *)v2p;\n-  int blk1 = REG_BASIC_BLOCK (regno1);\n-  int blk2 = REG_BASIC_BLOCK (regno2);\n-\n-  /* Prefer lower numbered basic blocks.  Note that global and unknown\n-     blocks have negative values, giving them high precedence.  */\n-  if (blk1 - blk2)\n-    return blk1 - blk2;\n-\n-  /* If both regs are referenced from the same block, sort by regno.  */\n-  return regno1 - regno2;\n-}\n-\n-/* Sort predicate for ordering the allocnos.\n-   Returns -1 (1) if *v1 should be allocated before (after) *v2.  */\n-\n-static int\n-allocno_compare (const void *v1p, const void *v2p)\n-{\n-  int v1 = *(const int *)v1p, v2 = *(const int *)v2p;\n-  /* Note that the quotient will never be bigger than\n-     the value of floor_log2 times the maximum number of\n-     times a register can occur in one insn (surely less than 100)\n-     weighted by the frequency (maximally REG_FREQ_MAX).\n-     Multiplying this by 10000/REG_FREQ_MAX can't overflow.  */\n-  int pri1\n-    = (((double) (floor_log2 (allocno[v1].n_refs) * allocno[v1].freq)\n-\t/ allocno[v1].live_length)\n-       * (10000 / REG_FREQ_MAX) * allocno[v1].size);\n-  int pri2\n-    = (((double) (floor_log2 (allocno[v2].n_refs) * allocno[v2].freq)\n-\t/ allocno[v2].live_length)\n-       * (10000 / REG_FREQ_MAX) * allocno[v2].size);\n-  if (pri2 - pri1)\n-    return pri2 - pri1;\n-\n-  /* If regs are equally good, sort by allocno,\n-     so that the results of qsort leave nothing to chance.  */\n-  return v1 - v2;\n-}\n-\f\n-/* Expand the preference information by looking for cases where one allocno\n-   dies in an insn that sets an allocno.  If those two allocnos don't conflict,\n-   merge any preferences between those allocnos.  */\n-\n-static void\n-expand_preferences (void)\n-{\n-  rtx insn;\n-  rtx link;\n-  rtx set;\n-\n-  /* We only try to handle the most common cases here.  Most of the cases\n-     where this wins are reg-reg copies.  */\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& (set = single_set (insn)) != 0\n-\t&& REG_P (SET_DEST (set))\n-\t&& reg_allocno[REGNO (SET_DEST (set))] >= 0)\n-      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t    && REG_P (XEXP (link, 0))\n-\t    && reg_allocno[REGNO (XEXP (link, 0))] >= 0\n-\t    && ! conflict_p (reg_allocno[REGNO (SET_DEST (set))],\n-\t\t\t     reg_allocno[REGNO (XEXP (link, 0))]))\n-\t  {\n-\t    int a1 = reg_allocno[REGNO (SET_DEST (set))];\n-\t    int a2 = reg_allocno[REGNO (XEXP (link, 0))];\n-\n-\t    if (XEXP (link, 0) == SET_SRC (set))\n-\t      {\n-\t\tIOR_HARD_REG_SET (allocno[a1].hard_reg_copy_preferences,\n-\t\t\t\t  allocno[a2].hard_reg_copy_preferences);\n-\t\tIOR_HARD_REG_SET (allocno[a2].hard_reg_copy_preferences,\n-\t\t\t\t  allocno[a1].hard_reg_copy_preferences);\n-\t      }\n-\n-\t    IOR_HARD_REG_SET (allocno[a1].hard_reg_preferences,\n-\t\t\t      allocno[a2].hard_reg_preferences);\n-\t    IOR_HARD_REG_SET (allocno[a2].hard_reg_preferences,\n-\t\t\t      allocno[a1].hard_reg_preferences);\n-\t    IOR_HARD_REG_SET (allocno[a1].hard_reg_full_preferences,\n-\t\t\t      allocno[a2].hard_reg_full_preferences);\n-\t    IOR_HARD_REG_SET (allocno[a2].hard_reg_full_preferences,\n-\t\t\t      allocno[a1].hard_reg_full_preferences);\n-\t  }\n-}\n-\n-\n-/* Try to set a preference for an allocno to a hard register.\n-   We are passed DEST and SRC which are the operands of a SET.  It is known\n-   that SRC is a register.  If SRC or the first operand of SRC is a register,\n-   try to set a preference.  If one of the two is a hard register and the other\n-   is a pseudo-register, mark the preference.\n-\n-   Note that we are not as aggressive as local-alloc in trying to tie a\n-   pseudo-register to a hard register.  */\n-\n-static void\n-set_preference (rtx dest, rtx src)\n-{\n-  unsigned int src_regno, dest_regno, end_regno;\n-  /* Amount to add to the hard regno for SRC, or subtract from that for DEST,\n-     to compensate for subregs in SRC or DEST.  */\n-  int offset = 0;\n-  unsigned int i;\n-  int copy = 1;\n-\n-  if (GET_RTX_FORMAT (GET_CODE (src))[0] == 'e')\n-    src = XEXP (src, 0), copy = 0;\n-\n-  /* Get the reg number for both SRC and DEST.\n-     If neither is a reg, give up.  */\n-\n-  if (REG_P (src))\n-    src_regno = REGNO (src);\n-  else if (GET_CODE (src) == SUBREG && REG_P (SUBREG_REG (src)))\n-    {\n-      src_regno = REGNO (SUBREG_REG (src));\n-\n-      if (REGNO (SUBREG_REG (src)) < FIRST_PSEUDO_REGISTER)\n-\toffset += subreg_regno_offset (REGNO (SUBREG_REG (src)),\n-\t\t\t\t       GET_MODE (SUBREG_REG (src)),\n-\t\t\t\t       SUBREG_BYTE (src),\n-\t\t\t\t       GET_MODE (src));\n-      else\n-\toffset += (SUBREG_BYTE (src)\n-\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (src)));\n-    }\n-  else\n-    return;\n-\n-  if (REG_P (dest))\n-    dest_regno = REGNO (dest);\n-  else if (GET_CODE (dest) == SUBREG && REG_P (SUBREG_REG (dest)))\n-    {\n-      dest_regno = REGNO (SUBREG_REG (dest));\n-\n-      if (REGNO (SUBREG_REG (dest)) < FIRST_PSEUDO_REGISTER)\n-\toffset -= subreg_regno_offset (REGNO (SUBREG_REG (dest)),\n-\t\t\t\t       GET_MODE (SUBREG_REG (dest)),\n-\t\t\t\t       SUBREG_BYTE (dest),\n-\t\t\t\t       GET_MODE (dest));\n-      else\n-\toffset -= (SUBREG_BYTE (dest)\n-\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (dest)));\n-    }\n-  else\n-    return;\n-\n-  /* Convert either or both to hard reg numbers.  */\n-\n-  if (reg_renumber[src_regno] >= 0)\n-    src_regno = reg_renumber[src_regno];\n-\n-  if (reg_renumber[dest_regno] >= 0)\n-    dest_regno = reg_renumber[dest_regno];\n-\n-  /* Now if one is a hard reg and the other is a global pseudo\n-     then give the other a preference.  */\n-\n-  if (dest_regno < FIRST_PSEUDO_REGISTER && src_regno >= FIRST_PSEUDO_REGISTER\n-      && reg_allocno[src_regno] >= 0)\n-    {\n-      dest_regno -= offset;\n-      if (dest_regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  if (copy)\n-\t    SET_REGBIT (hard_reg_copy_preferences,\n-\t\t\treg_allocno[src_regno], dest_regno);\n-\n-\t  SET_REGBIT (hard_reg_preferences,\n-\t\t      reg_allocno[src_regno], dest_regno);\n-\t  end_regno = end_hard_regno (GET_MODE (dest), dest_regno);\n-\t  for (i = dest_regno; i < end_regno; i++)\n-\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[src_regno], i);\n-\t}\n-    }\n-\n-  if (src_regno < FIRST_PSEUDO_REGISTER && dest_regno >= FIRST_PSEUDO_REGISTER\n-      && reg_allocno[dest_regno] >= 0)\n-    {\n-      src_regno += offset;\n-      if (src_regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  if (copy)\n-\t    SET_REGBIT (hard_reg_copy_preferences,\n-\t\t\treg_allocno[dest_regno], src_regno);\n-\n-\t  SET_REGBIT (hard_reg_preferences,\n-\t\t      reg_allocno[dest_regno], src_regno);\n-\t  end_regno = end_hard_regno (GET_MODE (src), src_regno);\n-\t  for (i = src_regno; i < end_regno; i++)\n-\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[dest_regno], i);\n-\t}\n-    }\n-}\n-\f\n-/* Helper function for set_preferences.  */\n-static void\n-set_preferences_1 (rtx reg, const_rtx setter, void *data ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (!REG_P (reg))\n-    return;\n-\n-  gcc_assert (setter);\n-  if (GET_CODE (setter) != CLOBBER)\n-    set_preference (reg, SET_SRC (setter));\n-}\n-\f\n-/* Scan all of the insns and initialize the preferences.  */\n-\n-static void \n-set_preferences (void)\n-{\n-  basic_block bb;\n-  rtx insn;\n-  FOR_EACH_BB (bb)\n-    FOR_BB_INSNS_REVERSE (bb, insn)\n-      {\n-\tif (!INSN_P (insn))\n-\t  continue;\t\n-\n-\tnote_stores (PATTERN (insn), set_preferences_1, NULL);\n-      }\n-}\n-\n-\n-\f\n-/* Prune the preferences for global registers to exclude registers that cannot\n-   be used.\n-\n-   Compute `regs_someone_prefers', which is a bitmask of the hard registers\n-   that are preferred by conflicting registers of lower priority.  If possible,\n-   we will avoid using these registers.  */\n-\n-static void\n-prune_preferences (void)\n-{\n-  int i;\n-  int num;\n-  int *allocno_to_order = XNEWVEC (int, max_allocno);\n-\n-  /* Scan least most important to most important.\n-     For each allocno, remove from preferences registers that cannot be used,\n-     either because of conflicts or register type.  Then compute all registers\n-     preferred by each lower-priority register that conflicts.  */\n-\n-  for (i = max_allocno - 1; i >= 0; i--)\n-    {\n-      HARD_REG_SET temp;\n-\n-      num = allocno_order[i];\n-      allocno_to_order[num] = i;\n-      COPY_HARD_REG_SET (temp, allocno[num].hard_reg_conflicts);\n-\n-      if (allocno[num].calls_crossed == 0)\n-\tIOR_HARD_REG_SET (temp, fixed_reg_set);\n-      else\n-\tIOR_HARD_REG_SET (temp,\tcall_used_reg_set);\n-\n-      IOR_COMPL_HARD_REG_SET\n-\t(temp,\n-\t reg_class_contents[(int) reg_preferred_class (allocno[num].reg)]);\n-\n-      AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_preferences, temp);\n-      AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_copy_preferences, temp);\n-      AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_full_preferences, temp);\n-    }\n-\n-  for (i = max_allocno - 1; i >= 0; i--)\n-    {\n-      /* Merge in the preferences of lower-priority registers (they have\n-\t already been pruned).  If we also prefer some of those registers,\n-\t don't exclude them unless we are of a smaller size (in which case\n-\t we want to give the lower-priority allocno the first chance for\n-\t these registers).  */\n-      HARD_REG_SET temp, temp2;\n-      int allocno2;\n-      adjacency_iter ai;\n-\n-      num = allocno_order[i];\n-\n-      CLEAR_HARD_REG_SET (temp);\n-      CLEAR_HARD_REG_SET (temp2);\n-\n-      FOR_EACH_CONFLICT (num, allocno2, ai)\n-\t{\n-\t  if (allocno_to_order[allocno2] > i)\n-\t    {\n-\t      if (allocno[allocno2].size <= allocno[num].size)\n-\t\tIOR_HARD_REG_SET (temp,\n-\t\t\t\t  allocno[allocno2].hard_reg_full_preferences);\n-\t      else\n-\t\tIOR_HARD_REG_SET (temp2,\n-\t\t\t\t  allocno[allocno2].hard_reg_full_preferences);\n-\t    }\n-\t}\n-\n-      AND_COMPL_HARD_REG_SET (temp, allocno[num].hard_reg_full_preferences);\n-      IOR_HARD_REG_SET (temp, temp2);\n-      COPY_HARD_REG_SET (allocno[num].regs_someone_prefers, temp);\n-    }\n-  free (allocno_to_order);\n-}\n-\f\n-/* Assign a hard register to allocno NUM; look for one that is the beginning\n-   of a long enough stretch of hard regs none of which conflicts with ALLOCNO.\n-   The registers marked in PREFREGS are tried first.\n-\n-   LOSERS, if nonzero, is a HARD_REG_SET indicating registers that cannot\n-   be used for this allocation.\n-\n-   If ALT_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.\n-   Otherwise ignore that preferred class and use the alternate class.\n-\n-   If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that\n-   will have to be saved and restored at calls.\n-\n-   RETRYING is nonzero if this is called from retry_global_alloc.\n-\n-   If we find one, record it in reg_renumber.\n-   If not, do nothing.  */\n-\n-static void\n-find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbered, int retrying)\n-{\n-  int i, best_reg, pass;\n-  HARD_REG_SET used, used1, used2;\n-\n-  enum reg_class rclass = (alt_regs_p\n-\t\t\t  ? reg_alternate_class (allocno[num].reg)\n-\t\t\t  : reg_preferred_class (allocno[num].reg));\n-  enum machine_mode mode = PSEUDO_REGNO_MODE (allocno[num].reg);\n-\n-  if (accept_call_clobbered)\n-    COPY_HARD_REG_SET (used1, call_fixed_reg_set);\n-  else if (allocno[num].calls_crossed == 0)\n-    COPY_HARD_REG_SET (used1, fixed_reg_set);\n-  else\n-    COPY_HARD_REG_SET (used1, call_used_reg_set);\n-\n-  /* Some registers should not be allocated in global-alloc.  */\n-  IOR_HARD_REG_SET (used1, no_global_alloc_regs);\n-  if (losers)\n-    IOR_HARD_REG_SET (used1, losers);\n-\n-  IOR_COMPL_HARD_REG_SET (used1, reg_class_contents[(int) rclass]);\n-\n-#ifdef EH_RETURN_DATA_REGNO\n-  if (allocno[num].no_eh_reg)\n-    {\n-      unsigned int j;\n-      for (j = 0; ; ++j)\n-\t{\n-\t  unsigned int regno = EH_RETURN_DATA_REGNO (j);\n-\t  if (regno == INVALID_REGNUM)\n-\t    break;\n-\t  SET_HARD_REG_BIT (used1, regno);\n-\t}\n-    }\n-#endif\n-\n-  COPY_HARD_REG_SET (used2, used1);\n-\n-  IOR_HARD_REG_SET (used1, allocno[num].hard_reg_conflicts);\n-\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  cannot_change_mode_set_regs (&used1, mode, allocno[num].reg);\n-#endif\n-\n-  /* Try each hard reg to see if it fits.  Do this in two passes.\n-     In the first pass, skip registers that are preferred by some other pseudo\n-     to give it a better chance of getting one of those registers.  Only if\n-     we can't get a register when excluding those do we take one of them.\n-     However, we never allocate a register for the first time in pass 0.  */\n-\n-  COPY_HARD_REG_SET (used, used1);\n-  IOR_COMPL_HARD_REG_SET (used, regs_used_so_far);\n-  IOR_HARD_REG_SET (used, allocno[num].regs_someone_prefers);\n-\n-  best_reg = -1;\n-  for (i = FIRST_PSEUDO_REGISTER, pass = 0;\n-       pass <= 1 && i >= FIRST_PSEUDO_REGISTER;\n-       pass++)\n-    {\n-      if (pass == 1)\n-\tCOPY_HARD_REG_SET (used, used1);\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t{\n-#ifdef REG_ALLOC_ORDER\n-\t  int regno = reg_alloc_order[i];\n-#else\n-\t  int regno = i;\n-#endif\n-\t  if (! TEST_HARD_REG_BIT (used, regno)\n-\t      && HARD_REGNO_MODE_OK (regno, mode)\n-\t      && (allocno[num].calls_crossed == 0\n-\t\t  || accept_call_clobbered\n-\t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n-\t    {\n-\t      int j;\n-\t      int lim = end_hard_regno (mode, regno);\n-\t      for (j = regno + 1;\n-\t\t   (j < lim\n-\t\t    && ! TEST_HARD_REG_BIT (used, j));\n-\t\t   j++);\n-\t      if (j == lim)\n-\t\t{\n-\t\t  best_reg = regno;\n-\t\t  break;\n-\t\t}\n-#ifndef REG_ALLOC_ORDER\n-\t      i = j;\t\t\t/* Skip starting points we know will lose */\n-#endif\n-\t    }\n-\t  }\n-      }\n-\n-  /* See if there is a preferred register with the same class as the register\n-     we allocated above.  Making this restriction prevents register\n-     preferencing from creating worse register allocation.\n-\n-     Remove from the preferred registers and conflicting registers.  Note that\n-     additional conflicts may have been added after `prune_preferences' was\n-     called.\n-\n-     First do this for those register with copy preferences, then all\n-     preferred registers.  */\n-\n-  AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_copy_preferences, used);\n-  if (!hard_reg_set_empty_p (allocno[num].hard_reg_copy_preferences)\n-      && best_reg >= 0)\n-    {\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (allocno[num].hard_reg_copy_preferences, i)\n-\t    && HARD_REGNO_MODE_OK (i, mode)\n-\t    && (allocno[num].calls_crossed == 0\n-\t\t|| accept_call_clobbered\n-\t\t|| ! HARD_REGNO_CALL_PART_CLOBBERED (i, mode))\n-\t    && (REGNO_REG_CLASS (i) == REGNO_REG_CLASS (best_reg)\n-\t\t|| reg_class_subset_p (REGNO_REG_CLASS (i),\n-\t\t\t\t       REGNO_REG_CLASS (best_reg))\n-\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg),\n-\t\t\t\t       REGNO_REG_CLASS (i))))\n-\t    {\n-\t      int j;\n-\t      int lim = end_hard_regno (mode, i);\n-\t      for (j = i + 1;\n-\t\t   (j < lim\n-\t\t    && ! TEST_HARD_REG_BIT (used, j)\n-\t\t    && (REGNO_REG_CLASS (j)\n-\t\t\t== REGNO_REG_CLASS (best_reg + (j - i))\n-\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (j),\n-\t\t\t\t\t       REGNO_REG_CLASS (best_reg + (j - i)))\n-\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg + (j - i)),\n-\t\t\t\t\t       REGNO_REG_CLASS (j))));\n-\t\t   j++);\n-\t      if (j == lim)\n-\t\t{\n-\t\t  best_reg = i;\n-\t\t  goto no_prefs;\n-\t\t}\n-\t    }\n-    }\n-\n-  AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_preferences, used);\n-  if (!hard_reg_set_empty_p (allocno[num].hard_reg_preferences)\n-      && best_reg >= 0)\n-    {\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (allocno[num].hard_reg_preferences, i)\n-\t    && HARD_REGNO_MODE_OK (i, mode)\n-\t    && (allocno[num].calls_crossed == 0\n-\t\t|| accept_call_clobbered\n-\t\t|| ! HARD_REGNO_CALL_PART_CLOBBERED (i, mode))\n-\t    && (REGNO_REG_CLASS (i) == REGNO_REG_CLASS (best_reg)\n-\t\t|| reg_class_subset_p (REGNO_REG_CLASS (i),\n-\t\t\t\t       REGNO_REG_CLASS (best_reg))\n-\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg),\n-\t\t\t\t       REGNO_REG_CLASS (i))))\n-\t    {\n-\t      int j;\n-\t      int lim = end_hard_regno (mode, i);\n-\t      for (j = i + 1;\n-\t\t   (j < lim\n-\t\t    && ! TEST_HARD_REG_BIT (used, j)\n-\t\t    && (REGNO_REG_CLASS (j)\n-\t\t\t== REGNO_REG_CLASS (best_reg + (j - i))\n-\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (j),\n-\t\t\t\t\t       REGNO_REG_CLASS (best_reg + (j - i)))\n-\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg + (j - i)),\n-\t\t\t\t\t       REGNO_REG_CLASS (j))));\n-\t\t   j++);\n-\t      if (j == lim)\n-\t\t{\n-\t\t  best_reg = i;\n-\t\t  break;\n-\t\t}\n-\t    }\n-    }\n- no_prefs:\n-\n-  /* If we haven't succeeded yet, try with caller-saves.\n-     We need not check to see if the current function has nonlocal\n-     labels because we don't put any pseudos that are live over calls in\n-     registers in that case.  */\n-\n-  if (flag_caller_saves && best_reg < 0)\n-    {\n-      /* Did not find a register.  If it would be profitable to\n-\t allocate a call-clobbered register and save and restore it\n-\t around calls, do that.  Don't do this if it crosses any calls\n-\t that might throw.  */\n-      if (! accept_call_clobbered\n-\t  && allocno[num].calls_crossed != 0\n-\t  && allocno[num].throwing_calls_crossed == 0\n-\t  && CALLER_SAVE_PROFITABLE (optimize_function_for_size_p (cfun) ? allocno[num].n_refs : allocno[num].freq,\n-\t\t\t\t     optimize_function_for_size_p (cfun) ? allocno[num].calls_crossed\n-\t\t\t\t     : allocno[num].freq_calls_crossed))\n-\t{\n-\t  HARD_REG_SET new_losers;\n-\t  if (! losers)\n-\t    CLEAR_HARD_REG_SET (new_losers);\n-\t  else\n-\t    COPY_HARD_REG_SET (new_losers, losers);\n-\n-\t  IOR_HARD_REG_SET(new_losers, losing_caller_save_reg_set);\n-\t  find_reg (num, new_losers, alt_regs_p, 1, retrying);\n-\t  if (reg_renumber[allocno[num].reg] >= 0)\n-\t    {\n-\t      caller_save_needed = 1;\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  /* If we haven't succeeded yet,\n-     see if some hard reg that conflicts with us\n-     was utilized poorly by local-alloc.\n-     If so, kick out the regs that were put there by local-alloc\n-     so we can use it instead.  */\n-  if (best_reg < 0 && !retrying\n-      /* Let's not bother with multi-reg allocnos.  */\n-      && allocno[num].size == 1\n-      && REG_BASIC_BLOCK (allocno[num].reg) == REG_BLOCK_GLOBAL)\n-    {\n-      /* Count from the end, to find the least-used ones first.  */\n-      for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-\t{\n-#ifdef REG_ALLOC_ORDER\n-\t  int regno = reg_alloc_order[i];\n-#else\n-\t  int regno = i;\n-#endif\n-\n-\t  if (local_reg_n_refs[regno] != 0\n-\t      /* Don't use a reg no good for this pseudo.  */\n-\t      && ! TEST_HARD_REG_BIT (used2, regno)\n-\t      && HARD_REGNO_MODE_OK (regno, mode)\n-\t      /* The code below assumes that we need only a single\n-\t\t register, but the check of allocno[num].size above\n-\t\t was not enough.  Sometimes we need more than one\n-\t\t register for a single-word value.  */\n-\t      && hard_regno_nregs[regno][mode] == 1\n-\t      && (allocno[num].calls_crossed == 0\n-\t\t  || accept_call_clobbered\n-\t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t      && ! invalid_mode_change_p (regno, REGNO_REG_CLASS (regno),\n-\t\t\t\t\t  mode)\n-#endif\n-#ifdef STACK_REGS\n-\t     && (!allocno[num].no_stack_reg\n-\t\t || regno < FIRST_STACK_REG || regno > LAST_STACK_REG)\n-#endif\n-\t      )\n-\t    {\n-\t      /* We explicitly evaluate the divide results into temporary\n-\t\t variables so as to avoid excess precision problems that occur\n-\t\t on an i386-unknown-sysv4.2 (unixware) host.  */\n-\n-\t      double tmp1 = ((double) local_reg_freq[regno] * local_reg_n_refs[regno]\n-\t\t\t    / local_reg_live_length[regno]);\n-\t      double tmp2 = ((double) allocno[num].freq * allocno[num].n_refs\n-\t\t\t     / allocno[num].live_length);\n-\n-\t      if (tmp1 < tmp2)\n-\t\t{\n-\t\t  /* Hard reg REGNO was used less in total by local regs\n-\t\t     than it would be used by this one allocno!  */\n-\t\t  int k;\n-\t\t  if (dump_file)\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Regno %d better for global %d, \",\n-\t\t      \t       regno, allocno[num].reg);\n-\t\t      fprintf (dump_file, \"fr:%d, ll:%d, nr:%d \",\n-\t\t\t       allocno[num].freq, allocno[num].live_length,\n-\t\t\t       allocno[num].n_refs);\n-\t\t      fprintf (dump_file, \"(was: fr:%d, ll:%d, nr:%d)\\n\",\n-\t\t\t       local_reg_freq[regno],\n-\t\t\t       local_reg_live_length[regno],\n-\t\t\t       local_reg_n_refs[regno]);\n-\t\t    }\n-\n-\t\t  for (k = 0; k < max_regno; k++)\n-\t\t    if (reg_renumber[k] >= 0)\n-\t\t      {\n-\t\t\tint r = reg_renumber[k];\n-\t\t\tint endregno\n-\t\t\t  = end_hard_regno (PSEUDO_REGNO_MODE (k), r);\n-\n-\t\t\tif (regno >= r && regno < endregno)\n-\t\t\t  {\n-\t\t\t    if (dump_file)\n-\t\t\t      fprintf (dump_file,\n-\t\t\t\t       \"Local Reg %d now on stack\\n\", k);\n-\t\t\t    reg_renumber[k] = -1;\n-\t\t\t  }\n-\t\t      }\n-\n-\t\t  best_reg = regno;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Did we find a register?  */\n-\n-  if (best_reg >= 0)\n-    {\n-      int lim, j;\n-      HARD_REG_SET this_reg;\n-      adjacency_iter ai;\n-\n-      /* Yes.  Record it as the hard register of this pseudo-reg.  */\n-      reg_renumber[allocno[num].reg] = best_reg;\n-\n-      /* Make a set of the hard regs being allocated.  */\n-      CLEAR_HARD_REG_SET (this_reg);\n-      lim = end_hard_regno (mode, best_reg);\n-      for (j = best_reg; j < lim; j++)\n-\t{\n-\t  SET_HARD_REG_BIT (this_reg, j);\n-\t  SET_HARD_REG_BIT (regs_used_so_far, j);\n-\t  /* This is no longer a reg used just by local regs.  */\n-\t  local_reg_n_refs[j] = 0;\n-\t  local_reg_freq[j] = 0;\n-\t}\n-      /* For each other pseudo-reg conflicting with this one,\n-\t mark it as conflicting with the hard regs this one occupies.  */\n-      FOR_EACH_CONFLICT (num, j, ai)\n-\t{\n-\t  IOR_HARD_REG_SET (allocno[j].hard_reg_conflicts, this_reg);\n-\t}\n-    }\n-}\n-\f\n-/* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.\n-   Perhaps it had previously seemed not worth a hard reg,\n-   or perhaps its old hard reg has been commandeered for reloads.\n-   FORBIDDEN_REGS indicates certain hard regs that may not be used, even if\n-   they do not appear to be allocated.\n-   If FORBIDDEN_REGS is zero, no regs are forbidden.  */\n-\n-void\n-retry_global_alloc (int regno, HARD_REG_SET forbidden_regs)\n-{\n-  int alloc_no = reg_allocno[regno];\n-  if (alloc_no >= 0)\n-    {\n-      /* If we have more than one register class,\n-\t first try allocating in the class that is cheapest\n-\t for this pseudo-reg.  If that fails, try any reg.  */\n-      if (N_REG_CLASSES > 1)\n-\tfind_reg (alloc_no, forbidden_regs, 0, 0, 1);\n-      if (reg_renumber[regno] < 0\n-\t  && reg_alternate_class (regno) != NO_REGS)\n-\tfind_reg (alloc_no, forbidden_regs, 1, 0, 1);\n-\n-      /* If we found a register, modify the RTL for the register to\n-\t show the hard register, and mark that register live.  */\n-      if (reg_renumber[regno] >= 0)\n-\t{\n-\t  SET_REGNO (regno_reg_rtx[regno], reg_renumber[regno]);\n-\t  mark_home_live (regno);\n-\t}\n-    }\n-}\n-\f\n-/* Indicate that hard register number FROM was eliminated and replaced with\n-   an offset from hard register number TO.  The status of hard registers live\n-   at the start of a basic block is updated by replacing a use of FROM with\n-   a use of TO.  */\n-\n-void\n-mark_elimination (int from, int to)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      /* We don't use LIVE info in IRA.  */\n-      regset r = (flag_ira ? DF_LR_IN (bb) : DF_LIVE_IN (bb));\n-      if (REGNO_REG_SET_P (r, from))\n-\t{\n-\t  CLEAR_REGNO_REG_SET (r, from);\n-\t  SET_REGNO_REG_SET (r, to);\n-\t}\n-    }\n-}\n-\f\n-/* Print chain C to FILE.  */\n-\n-static void\n-print_insn_chain (FILE *file, struct insn_chain *c)\n-{\n-  fprintf (file, \"insn=%d, \", INSN_UID(c->insn));\n-  bitmap_print (file, &c->live_throughout, \"live_throughout: \", \", \");\n-  bitmap_print (file, &c->dead_or_set, \"dead_or_set: \", \"\\n\");\n-}\n-\n-\n-/* Print all reload_insn_chains to FILE.  */\n-\n-static void\n-print_insn_chains (FILE *file)\n-{\n-  struct insn_chain *c;\n-  for (c = reload_insn_chain; c ; c = c->next)\n-    print_insn_chain (file, c);\n-}\n-\n-/* Return true if pseudo REGNO should be added to set live_throughout\n-   or dead_or_set of the insn chains for reload consideration.  */\n-\n-static bool\n-pseudo_for_reload_consideration_p (int regno)\n-{\n-  /* Consider spilled pseudos too for IRA because they still have a\n-     chance to get hard-registers in the reload when IRA is used.  */\n-  return (reg_renumber[regno] >= 0\n-\t  || (flag_ira && ira_conflicts_p && flag_ira_share_spill_slots));\n-}\n-\n-/* Walk the insns of the current function and build reload_insn_chain,\n-   and record register life information.  */\n-\n-void\n-build_insn_chain (void)\n-{\n-  unsigned int i;\n-  struct insn_chain **p = &reload_insn_chain;\n-  basic_block bb;\n-  struct insn_chain *c = NULL;\n-  struct insn_chain *next = NULL;\n-  bitmap live_relevant_regs = BITMAP_ALLOC (NULL);\n-  bitmap elim_regset = BITMAP_ALLOC (NULL);\n-  /* live_subregs is a vector used to keep accurate information about\n-     which hardregs are live in multiword pseudos.  live_subregs and\n-     live_subregs_used are indexed by pseudo number.  The live_subreg\n-     entry for a particular pseudo is only used if the corresponding\n-     element is non zero in live_subregs_used.  The value in\n-     live_subregs_used is number of bytes that the pseudo can\n-     occupy.  */\n-  sbitmap *live_subregs = XCNEWVEC (sbitmap, max_regno);\n-  int *live_subregs_used = XNEWVEC (int, max_regno);\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (TEST_HARD_REG_BIT (eliminable_regset, i))\n-      bitmap_set_bit (elim_regset, i);\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      bitmap_iterator bi;\n-      rtx insn;\n-      \n-      CLEAR_REG_SET (live_relevant_regs);\n-      memset (live_subregs_used, 0, max_regno * sizeof (int));\n-      \n-      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb), 0, i, bi)\n-\t{\n-\t  if (i >= FIRST_PSEUDO_REGISTER)\n-\t    break;\n-\t  bitmap_set_bit (live_relevant_regs, i);\n-\t}\n-\n-      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb), FIRST_PSEUDO_REGISTER, i, bi)\n-\t{\n-\t  if (pseudo_for_reload_consideration_p (i))\n-\t    bitmap_set_bit (live_relevant_regs, i);\n-\t}\n-\n-      FOR_BB_INSNS_REVERSE (bb, insn)\n-\t{\n-\t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n-\t    {\n-\t      unsigned int uid = INSN_UID (insn);\n-\t      df_ref *def_rec;\n-\t      df_ref *use_rec;\n-\n-\t      c = new_insn_chain ();\n-\t      c->next = next;\n-\t      next = c;\n-\t      *p = c;\n-\t      p = &c->prev;\n-\t      \n-\t      c->insn = insn;\n-\t      c->block = bb->index;\n-\n-\t      if (INSN_P (insn))\n-\t\tfor (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t\t  {\n-\t\t    df_ref def = *def_rec;\n-\t\t    unsigned int regno = DF_REF_REGNO (def);\n-\t\t    \n-\t\t    /* Ignore may clobbers because these are generated\n-\t\t       from calls. However, every other kind of def is\n-\t\t       added to dead_or_set.  */\n-\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n-\t\t      {\n-\t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n-\t\t\t  {\n-\t\t\t    if (!fixed_regs[regno])\n-\t\t\t      bitmap_set_bit (&c->dead_or_set, regno);\n-\t\t\t  }\n-\t\t\telse if (pseudo_for_reload_consideration_p (regno))\n-\t\t\t  bitmap_set_bit (&c->dead_or_set, regno);\n-\t\t      }\n-\n-\t\t    if ((regno < FIRST_PSEUDO_REGISTER\n-\t\t\t || reg_renumber[regno] >= 0\n-\t\t\t || (flag_ira && ira_conflicts_p))\n-\t\t\t&& (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL)))\n-\t\t      {\n-\t\t\trtx reg = DF_REF_REG (def);\n-\n-\t\t\t/* We can model subregs, but not if they are\n-\t\t\t   wrapped in ZERO_EXTRACTS.  */\n-\t\t\tif (GET_CODE (reg) == SUBREG\n-\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n-\t\t\t  {\n-\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n-\t\t\t    unsigned int last = start \n-\t\t\t      + GET_MODE_SIZE (GET_MODE (reg));\n-\n-\t\t\t    ra_init_live_subregs (bitmap_bit_p (live_relevant_regs, \n-\t\t\t\t\t\t\t\tregno), \n-\t\t\t\t\t\t  live_subregs, \n-\t\t\t\t\t\t  live_subregs_used,\n-\t\t\t\t\t\t  regno, reg);\n-\n-\t\t\t    if (!DF_REF_FLAGS_IS_SET\n-\t\t\t\t(def, DF_REF_STRICT_LOW_PART))\n-\t\t\t      {\n-\t\t\t\t/* Expand the range to cover entire words.\n-\t\t\t\t   Bytes added here are \"don't care\".  */\n-\t\t\t\tstart = start / UNITS_PER_WORD * UNITS_PER_WORD;\n-\t\t\t\tlast = ((last + UNITS_PER_WORD - 1)\n-\t\t\t\t\t/ UNITS_PER_WORD * UNITS_PER_WORD);\n-\t\t\t      }\n-\n-\t\t\t    /* Ignore the paradoxical bits.  */\n-\t\t\t    if ((int)last > live_subregs_used[regno])\n-\t\t\t      last = live_subregs_used[regno];\n-\n-\t\t\t    while (start < last)\n-\t\t\t      {\n-\t\t\t\tRESET_BIT (live_subregs[regno], start);\n-\t\t\t\tstart++;\n-\t\t\t      }\n-\t\t\t    \n-\t\t\t    if (sbitmap_empty_p (live_subregs[regno]))\n-\t\t\t      {\n-\t\t\t\tlive_subregs_used[regno] = 0;\n-\t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n-\t\t\t      }\n-\t\t\t    else\n-\t\t\t      /* Set live_relevant_regs here because\n-\t\t\t\t that bit has to be true to get us to\n-\t\t\t\t look at the live_subregs fields.  */\n-\t\t\t      bitmap_set_bit (live_relevant_regs, regno);\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    /* DF_REF_PARTIAL is generated for\n-\t\t\t       subregs, STRICT_LOW_PART, and\n-\t\t\t       ZERO_EXTRACT.  We handle the subreg\n-\t\t\t       case above so here we have to keep from\n-\t\t\t       modeling the def as a killing def.  */\n-\t\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL))\n-\t\t\t      {\n-\t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n-\t\t\t\tlive_subregs_used[regno] = 0;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\t  \n-\t      bitmap_and_compl_into (live_relevant_regs, elim_regset);\n-\t      bitmap_copy (&c->live_throughout, live_relevant_regs);\n-\n-\t      if (INSN_P (insn))\n-\t\tfor (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t\t  {\n-\t\t    df_ref use = *use_rec;\n-\t\t    unsigned int regno = DF_REF_REGNO (use);\n-\t\t    rtx reg = DF_REF_REG (use);\n-\t\t    \n-\t\t    /* DF_REF_READ_WRITE on a use means that this use\n-\t\t       is fabricated from a def that is a partial set\n-\t\t       to a multiword reg.  Here, we only model the\n-\t\t       subreg case that is not wrapped in ZERO_EXTRACT\n-\t\t       precisely so we do not need to look at the\n-\t\t       fabricated use. */\n-\t\t    if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n-\t\t\t&& !DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT) \n-\t\t\t&& DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n-\t\t      continue;\n-\t\t    \n-\t\t    /* Add the last use of each var to dead_or_set.  */\n-\t\t    if (!bitmap_bit_p (live_relevant_regs, regno))\n-\t\t      {\n-\t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n-\t\t\t  {\n-\t\t\t    if (!fixed_regs[regno])\n-\t\t\t      bitmap_set_bit (&c->dead_or_set, regno);\n-\t\t\t  }\n-\t\t\telse if (pseudo_for_reload_consideration_p (regno))\n-\t\t\t  bitmap_set_bit (&c->dead_or_set, regno);\n-\t\t      }\n-\t\t    \n-\t\t    if (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t|| pseudo_for_reload_consideration_p (regno))\n-\t\t      {\n-\t\t\tif (GET_CODE (reg) == SUBREG\n-\t\t\t    && !DF_REF_FLAGS_IS_SET (use,\n-\t\t\t\t\t\t     DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT)) \n-\t\t\t  {\n-\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n-\t\t\t    unsigned int last = start \n-\t\t\t      + GET_MODE_SIZE (GET_MODE (reg));\n-\t\t\t    \n-\t\t\t    ra_init_live_subregs (bitmap_bit_p (live_relevant_regs, \n-\t\t\t\t\t\t\t\tregno), \n-\t\t\t\t\t\t  live_subregs, \n-\t\t\t\t\t\t  live_subregs_used,\n-\t\t\t\t\t\t  regno, reg);\n-\t\t\t    \n-\t\t\t    /* Ignore the paradoxical bits.  */\n-\t\t\t    if ((int)last > live_subregs_used[regno])\n-\t\t\t      last = live_subregs_used[regno];\n-\n-\t\t\t    while (start < last)\n-\t\t\t      {\n-\t\t\t\tSET_BIT (live_subregs[regno], start);\n-\t\t\t\tstart++;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  /* Resetting the live_subregs_used is\n-\t\t\t     effectively saying do not use the subregs\n-\t\t\t     because we are reading the whole\n-\t\t\t     pseudo.  */\n-\t\t\t  live_subregs_used[regno] = 0;\n-\t\t\tbitmap_set_bit (live_relevant_regs, regno);\n-\t\t      }\n-\t\t  }\n-\t    }\n-\t}\n-\n-      /* FIXME!! The following code is a disaster.  Reload needs to see the\n-\t labels and jump tables that are just hanging out in between\n-\t the basic blocks.  See pr33676.  */\n-      insn = BB_HEAD (bb);\n-      \n-      /* Skip over the barriers and cruft.  */\n-      while (insn && (BARRIER_P (insn) || NOTE_P (insn) \n-\t\t      || BLOCK_FOR_INSN (insn) == bb))\n-\tinsn = PREV_INSN (insn);\n-      \n-      /* While we add anything except barriers and notes, the focus is\n-\t to get the labels and jump tables into the\n-\t reload_insn_chain.  */\n-      while (insn)\n-\t{\n-\t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n-\t    {\n-\t      if (BLOCK_FOR_INSN (insn))\n-\t\tbreak;\n-\t      \n-\t      c = new_insn_chain ();\n-\t      c->next = next;\n-\t      next = c;\n-\t      *p = c;\n-\t      p = &c->prev;\n-\t      \n-\t      /* The block makes no sense here, but it is what the old\n-\t\t code did.  */\n-\t      c->block = bb->index;\n-\t      c->insn = insn;\n-\t      bitmap_copy (&c->live_throughout, live_relevant_regs);\n-\t    }\t  \n-\t  insn = PREV_INSN (insn);\n-\t}\n-    }\n-\n-  for (i = 0; i < (unsigned int) max_regno; i++)\n-    if (live_subregs[i])\n-      free (live_subregs[i]);\n-\n-  reload_insn_chain = c;\n-  *p = NULL;\n-\n-  free (live_subregs);\n-  free (live_subregs_used);\n-  BITMAP_FREE (live_relevant_regs);\n-  BITMAP_FREE (elim_regset);\n-\n-  if (dump_file)\n-    print_insn_chains (dump_file);\n-}\n-\f\n-/* Print debugging trace information if -dg switch is given,\n-   showing the information on which the allocation decisions are based.  */\n-\n-static void\n-dump_conflicts (FILE *file)\n-{\n-  int i;\n-  int regno;\n-  int has_preferences;\n-  int nregs;\n-  nregs = 0;\n-  for (i = 0; i < max_allocno; i++)\n-    {\n-      if (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n-\tcontinue;\n-      nregs++;\n-    }\n-  fprintf (file, \";; %d regs to allocate:\", nregs);\n-  for (regno = 0; regno < max_regno; regno++)\n-    if ((i = reg_allocno[regno]) >= 0)\n-      {\n-\tint j;\n-\tif (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n-\t  continue;\n-\tfprintf (file, \" %d\", allocno[allocno_order[i]].reg);\n-\tfor (j = 0; j < max_regno; j++)\n-\t  if (reg_allocno[j] == allocno_order[i]\n-\t      && j != allocno[allocno_order[i]].reg)\n-\t    fprintf (file, \"+%d\", j);\n-\tif (allocno[allocno_order[i]].size != 1)\n-\t  fprintf (file, \" (%d)\", allocno[allocno_order[i]].size);\n-      }\n-  fprintf (file, \"\\n\");\n-\n-  for (regno = 0; regno < max_regno; regno++)\n-    if ((i = reg_allocno[regno]) >= 0)\n-      {\n-\tint j;\n-\tadjacency_iter ai;\n-\tfprintf (file, \";; %d conflicts:\", allocno[i].reg);\n-\tFOR_EACH_CONFLICT (i, j, ai)\n-\t  {\n-\t    fprintf (file, \" %d\", allocno[j].reg);\n-\t  }\n-\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t  if (TEST_HARD_REG_BIT (allocno[i].hard_reg_conflicts, j)\n-\t      && !fixed_regs[j])\n-\t    fprintf (file, \" %d\", j);\n-\tfprintf (file, \"\\n\");\n-\n-\thas_preferences = 0;\n-\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t  if (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n-\t    has_preferences = 1;\n-\n-\tif (!has_preferences)\n-\t  continue;\n-\tfprintf (file, \";; %d preferences:\", allocno[i].reg);\n-\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t  if (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n-\t    fprintf (file, \" %d\", j);\n-\tfprintf (file, \"\\n\");\n-      }\n-  fprintf (file, \"\\n\");\n-}\n-\n-void\n-dump_global_regs (FILE *file)\n-{\n-  int i, j;\n-\n-  fprintf (file, \";; Register dispositions:\\n\");\n-  for (i = FIRST_PSEUDO_REGISTER, j = 0; i < max_regno; i++)\n-    if (reg_renumber[i] >= 0)\n-      {\n-\tfprintf (file, \"%d in %d  \", i, reg_renumber[i]);\n-\tif (++j % 6 == 0)\n-\t  fprintf (file, \"\\n\");\n-      }\n-\n-  fprintf (file, \"\\n\\n;; Hard regs used: \");\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (df_regs_ever_live_p (i))\n-      fprintf (file, \" %d\", i);\n-  fprintf (file, \"\\n\\n\");\n-}\n-\n-\n-static bool\n-gate_handle_global_alloc (void)\n-{\n-  return ! flag_ira;\n-}\n-\n-/* Run old register allocator.  Return TRUE if we must exit\n-   rest_of_compilation upon return.  */\n-static unsigned int\n-rest_of_handle_global_alloc (void)\n-{\n-  bool failure;\n-\n-  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n-     pass fixing up any insns that are invalid.  */\n-  if (optimize && dbg_cnt (global_alloc_at_func))\n-    failure = global_alloc ();\n-  else\n-    {\n-      /* There is just too much going on in the register allocators to\n-\t keep things up to date.  At the end we have to rescan anyway\n-\t because things change when the reload_completed flag is set.  \n-\t So we just turn off scanning and we will rescan by hand.  */\n-      df_set_flags (DF_NO_INSN_RESCAN);\n-      compute_regsets (&eliminable_regset, &no_global_alloc_regs);\n-      build_insn_chain ();\n-      df_set_flags (DF_NO_INSN_RESCAN);\n-      failure = reload (get_insns (), 0);\n-    }\n-\n-  if (dump_enabled_p (pass_global_alloc.pass.static_pass_number))\n-    {\n-      timevar_push (TV_DUMP);\n-      dump_global_regs (dump_file);\n-      timevar_pop (TV_DUMP);\n-    }\n-\n-  /* FIXME: This appears on the surface to be wrong thing to be doing.\n-     So much of the compiler is designed to check reload_completed to\n-     see if it is running after reload that seems doomed to failure.\n-     We should be returning a value that says that we have found\n-     errors so that nothing but the cleanup passes are run\n-     afterwards.  */\n-  gcc_assert (reload_completed || failure);\n-  reload_completed = !failure;\n-\n-  /* The world has changed so much that at this point we might as well\n-     just rescan everything.  Note that df_rescan_all_insns is not\n-     going to help here because it does not touch the artificial uses\n-     and defs.  */\n-  df_finish_pass (true);\n-  if (optimize > 1)\n-    df_live_add_problem ();\n-  df_scan_alloc (NULL);\n-  df_scan_blocks ();\n-\n-  if (optimize)\n-    df_analyze ();\n-\n-  regstat_free_n_sets_and_refs ();\n-  regstat_free_ri ();\n-  return 0;\n-}\n-\n-struct rtl_opt_pass pass_global_alloc =\n-{\n- {\n-  RTL_PASS,\n-  \"greg\",                               /* name */\n-  gate_handle_global_alloc,             /* gate */\n-  rest_of_handle_global_alloc,          /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_GLOBAL_ALLOC,                      /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func | TODO_verify_rtl_sharing\n-  | TODO_ggc_collect                    /* todo_flags_finish */\n- }\n-};\n-"}, {"sha": "2b0d079006a242332d89c869ae0c62125597170e", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -601,9 +601,6 @@ extern char call_really_used_regs[];\n \n extern HARD_REG_SET call_used_reg_set;\n   \n-/* Registers that we don't want to caller save.  */\n-extern HARD_REG_SET losing_caller_save_reg_set;\n-\n /* Indexed by hard register number, contains 1 for registers that are\n    fixed use -- i.e. in fixed_regs -- or a function value return register\n    or TARGET_STRUCT_VALUE_RTX or STATIC_CHAIN_REGNUM.  These are the"}, {"sha": "fcad642ae12ea4301c44d451172ed3ad49d390b2", "filename": "gcc/ira-color.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -2962,7 +2962,7 @@ ira_reuse_stack_slot (int regno, unsigned int inherent_size,\n   bitmap_iterator bi;\n   struct ira_spilled_reg_stack_slot *slot = NULL;\n \n-  ira_assert (flag_ira && inherent_size == PSEUDO_REGNO_BYTES (regno)\n+  ira_assert (inherent_size == PSEUDO_REGNO_BYTES (regno)\n \t      && inherent_size <= total_size\n \t      && ALLOCNO_HARD_REGNO (allocno) < 0);\n   if (! flag_ira_share_spill_slots)\n@@ -3074,7 +3074,7 @@ ira_mark_new_stack_slot (rtx x, int regno, unsigned int total_size)\n   int slot_num;\n   ira_allocno_t allocno;\n \n-  ira_assert (flag_ira && PSEUDO_REGNO_BYTES (regno) <= total_size);\n+  ira_assert (PSEUDO_REGNO_BYTES (regno) <= total_size);\n   allocno = ira_regno_allocno_map[regno];\n   slot_num = -ALLOCNO_HARD_REGNO (allocno) - 2;\n   if (slot_num == -1)"}, {"sha": "8dee2298e181491b987a00156a6767b1cdf4ba58", "filename": "gcc/ira.c", "status": "modified", "additions": 1215, "deletions": 1, "changes": 1216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -316,6 +316,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"output.h\"\n+#include \"except.h\"\n #include \"reload.h\"\n #include \"errors.h\"\n #include \"integrate.h\"\n@@ -349,6 +350,10 @@ int ira_reg_cost, ira_mem_cost;\n int ira_load_cost, ira_store_cost, ira_shuffle_cost;\n int ira_move_loops_num, ira_additional_jumps_num;\n \n+/* All registers that can be eliminated.  */\n+\n+HARD_REG_SET eliminable_regset;\n+\n /* Map: hard regs X modes -> set of hard registers for storing value\n    of given mode starting with given hard register.  */\n HARD_REG_SET ira_reg_mode_hard_regset[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n@@ -1527,6 +1532,14 @@ find_reg_equiv_invariant_const (void)\n \n \f\n \n+/* Vector of substitutions of register numbers,\n+   used to map pseudo regs into hardware regs.\n+   This is set up as a result of register allocation.\n+   Element N is the hard reg assigned to pseudo reg N,\n+   or is -1 if no hard reg was assigned.\n+   If N is a hard reg number, element N is N.  */\n+short *reg_renumber;\n+\n /* Set up REG_RENUMBER and CALLER_SAVE_NEEDED (used by reload) from\n    the allocation found by IRA.  */\n static void\n@@ -1824,6 +1837,1207 @@ too_high_register_pressure_p (void)\n \n \f\n \n+/* Indicate that hard register number FROM was eliminated and replaced with\n+   an offset from hard register number TO.  The status of hard registers live\n+   at the start of a basic block is updated by replacing a use of FROM with\n+   a use of TO.  */\n+\n+void\n+mark_elimination (int from, int to)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      /* We don't use LIVE info in IRA.  */\n+      regset r = DF_LR_IN (bb);\n+\n+      if (REGNO_REG_SET_P (r, from))\n+\t{\n+\t  CLEAR_REGNO_REG_SET (r, from);\n+\t  SET_REGNO_REG_SET (r, to);\n+\t}\n+    }\n+}\n+\n+\f\n+\n+struct equivalence\n+{\n+  /* Set when an attempt should be made to replace a register\n+     with the associated src_p entry.  */\n+  char replace;\n+  /* Set when a REG_EQUIV note is found or created.  Use to\n+     keep track of what memory accesses might be created later,\n+     e.g. by reload.  */\n+  rtx replacement;\n+  rtx *src_p;\n+  /* Loop depth is used to recognize equivalences which appear\n+     to be present within the same loop (or in an inner loop).  */\n+  int loop_depth;\n+  /* The list of each instruction which initializes this register.  */\n+  rtx init_insns;\n+  /* Nonzero if this had a preexisting REG_EQUIV note.  */\n+  int is_arg_equivalence;\n+};\n+\n+/* reg_equiv[N] (where N is a pseudo reg number) is the equivalence\n+   structure for that register.  */\n+static struct equivalence *reg_equiv;\n+\n+/* Used for communication between the following two functions: contains\n+   a MEM that we wish to ensure remains unchanged.  */\n+static rtx equiv_mem;\n+\n+/* Set nonzero if EQUIV_MEM is modified.  */\n+static int equiv_mem_modified;\n+\n+/* If EQUIV_MEM is modified by modifying DEST, indicate that it is modified.\n+   Called via note_stores.  */\n+static void\n+validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n+\t\t\t       void *data ATTRIBUTE_UNUSED)\n+{\n+  if ((REG_P (dest)\n+       && reg_overlap_mentioned_p (dest, equiv_mem))\n+      || (MEM_P (dest)\n+\t  && true_dependence (dest, VOIDmode, equiv_mem, rtx_varies_p)))\n+    equiv_mem_modified = 1;\n+}\n+\n+/* Verify that no store between START and the death of REG invalidates\n+   MEMREF.  MEMREF is invalidated by modifying a register used in MEMREF,\n+   by storing into an overlapping memory location, or with a non-const\n+   CALL_INSN.\n+\n+   Return 1 if MEMREF remains valid.  */\n+static int\n+validate_equiv_mem (rtx start, rtx reg, rtx memref)\n+{\n+  rtx insn;\n+  rtx note;\n+\n+  equiv_mem = memref;\n+  equiv_mem_modified = 0;\n+\n+  /* If the memory reference has side effects or is volatile, it isn't a\n+     valid equivalence.  */\n+  if (side_effects_p (memref))\n+    return 0;\n+\n+  for (insn = start; insn && ! equiv_mem_modified; insn = NEXT_INSN (insn))\n+    {\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      if (find_reg_note (insn, REG_DEAD, reg))\n+\treturn 1;\n+\n+      if (CALL_P (insn) && ! MEM_READONLY_P (memref)\n+\t  && ! RTL_CONST_OR_PURE_CALL_P (insn))\n+\treturn 0;\n+\n+      note_stores (PATTERN (insn), validate_equiv_mem_from_store, NULL);\n+\n+      /* If a register mentioned in MEMREF is modified via an\n+\t auto-increment, we lose the equivalence.  Do the same if one\n+\t dies; although we could extend the life, it doesn't seem worth\n+\t the trouble.  */\n+\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\tif ((REG_NOTE_KIND (note) == REG_INC\n+\t     || REG_NOTE_KIND (note) == REG_DEAD)\n+\t    && REG_P (XEXP (note, 0))\n+\t    && reg_overlap_mentioned_p (XEXP (note, 0), memref))\n+\t  return 0;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Returns zero if X is known to be invariant.  */\n+static int\n+equiv_init_varies_p (rtx x)\n+{\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      return !MEM_READONLY_P (x) || equiv_init_varies_p (XEXP (x, 0));\n+\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case REG:\n+      return reg_equiv[REGNO (x)].replace == 0 && rtx_varies_p (x, 0);\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+\n+      /* Fall through.  */\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      {\n+\tif (equiv_init_varies_p (XEXP (x, i)))\n+\t  return 1;\n+      }\n+    else if (fmt[i] == 'E')\n+      {\n+\tint j;\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (equiv_init_varies_p (XVECEXP (x, i, j)))\n+\t    return 1;\n+      }\n+\n+  return 0;\n+}\n+\n+/* Returns nonzero if X (used to initialize register REGNO) is movable.\n+   X is only movable if the registers it uses have equivalent initializations\n+   which appear to be within the same loop (or in an inner loop) and movable\n+   or if they are not candidates for local_alloc and don't vary.  */\n+static int\n+equiv_init_movable_p (rtx x, int regno)\n+{\n+  int i, j;\n+  const char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case SET:\n+      return equiv_init_movable_p (SET_SRC (x), regno);\n+\n+    case CC0:\n+    case CLOBBER:\n+      return 0;\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case POST_INC:\n+    case POST_DEC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return 0;\n+\n+    case REG:\n+      return (reg_equiv[REGNO (x)].loop_depth >= reg_equiv[regno].loop_depth\n+\t      && reg_equiv[REGNO (x)].replace)\n+\t     || (REG_BASIC_BLOCK (REGNO (x)) < NUM_FIXED_BLOCKS && ! rtx_varies_p (x, 0));\n+\n+    case UNSPEC_VOLATILE:\n+      return 0;\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 0;\n+\n+      /* Fall through.  */\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'e':\n+\tif (! equiv_init_movable_p (XEXP (x, i), regno))\n+\t  return 0;\n+\tbreak;\n+      case 'E':\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (! equiv_init_movable_p (XVECEXP (x, i, j), regno))\n+\t    return 0;\n+\tbreak;\n+      }\n+\n+  return 1;\n+}\n+\n+/* TRUE if X uses any registers for which reg_equiv[REGNO].replace is true.  */\n+static int\n+contains_replace_regs (rtx x)\n+{\n+  int i, j;\n+  const char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case PC:\n+    case CC0:\n+    case HIGH:\n+      return 0;\n+\n+    case REG:\n+      return reg_equiv[REGNO (x)].replace;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'e':\n+\tif (contains_replace_regs (XEXP (x, i)))\n+\t  return 1;\n+\tbreak;\n+      case 'E':\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (contains_replace_regs (XVECEXP (x, i, j)))\n+\t    return 1;\n+\tbreak;\n+      }\n+\n+  return 0;\n+}\n+\n+/* TRUE if X references a memory location that would be affected by a store\n+   to MEMREF.  */\n+static int\n+memref_referenced_p (rtx memref, rtx x)\n+{\n+  int i, j;\n+  const char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case PC:\n+    case CC0:\n+    case HIGH:\n+    case LO_SUM:\n+      return 0;\n+\n+    case REG:\n+      return (reg_equiv[REGNO (x)].replacement\n+\t      && memref_referenced_p (memref,\n+\t\t\t\t      reg_equiv[REGNO (x)].replacement));\n+\n+    case MEM:\n+      if (true_dependence (memref, VOIDmode, x, rtx_varies_p))\n+\treturn 1;\n+      break;\n+\n+    case SET:\n+      /* If we are setting a MEM, it doesn't count (its address does), but any\n+\t other SET_DEST that has a MEM in it is referencing the MEM.  */\n+      if (MEM_P (SET_DEST (x)))\n+\t{\n+\t  if (memref_referenced_p (memref, XEXP (SET_DEST (x), 0)))\n+\t    return 1;\n+\t}\n+      else if (memref_referenced_p (memref, SET_DEST (x)))\n+\treturn 1;\n+\n+      return memref_referenced_p (memref, SET_SRC (x));\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'e':\n+\tif (memref_referenced_p (memref, XEXP (x, i)))\n+\t  return 1;\n+\tbreak;\n+      case 'E':\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (memref_referenced_p (memref, XVECEXP (x, i, j)))\n+\t    return 1;\n+\tbreak;\n+      }\n+\n+  return 0;\n+}\n+\n+/* TRUE if some insn in the range (START, END] references a memory location\n+   that would be affected by a store to MEMREF.  */\n+static int\n+memref_used_between_p (rtx memref, rtx start, rtx end)\n+{\n+  rtx insn;\n+\n+  for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (!INSN_P (insn))\n+\tcontinue;\n+      \n+      if (memref_referenced_p (memref, PATTERN (insn)))\n+\treturn 1;\n+\n+      /* Nonconst functions may access memory.  */\n+      if (CALL_P (insn) && (! RTL_CONST_CALL_P (insn)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Mark REG as having no known equivalence.\n+   Some instructions might have been processed before and furnished\n+   with REG_EQUIV notes for this register; these notes will have to be\n+   removed.\n+   STORE is the piece of RTL that does the non-constant / conflicting\n+   assignment - a SET, CLOBBER or REG_INC note.  It is currently not used,\n+   but needs to be there because this function is called from note_stores.  */\n+static void\n+no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n+{\n+  int regno;\n+  rtx list;\n+\n+  if (!REG_P (reg))\n+    return;\n+  regno = REGNO (reg);\n+  list = reg_equiv[regno].init_insns;\n+  if (list == const0_rtx)\n+    return;\n+  reg_equiv[regno].init_insns = const0_rtx;\n+  reg_equiv[regno].replacement = NULL_RTX;\n+  /* This doesn't matter for equivalences made for argument registers, we\n+     should keep their initialization insns.  */\n+  if (reg_equiv[regno].is_arg_equivalence)\n+    return;\n+  reg_equiv_init[regno] = NULL_RTX;\n+  for (; list; list =  XEXP (list, 1))\n+    {\n+      rtx insn = XEXP (list, 0);\n+      remove_note (insn, find_reg_note (insn, REG_EQUIV, NULL_RTX));\n+    }\n+}\n+\n+/* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n+static int recorded_label_ref;\n+\n+/* Find registers that are equivalent to a single value throughout the\n+   compilation (either because they can be referenced in memory or are set once\n+   from a single constant).  Lower their priority for a register.\n+\n+   If such a register is only referenced once, try substituting its value\n+   into the using insn.  If it succeeds, we can eliminate the register\n+   completely.\n+\n+   Initialize the REG_EQUIV_INIT array of initializing insns.\n+\n+   Return non-zero if jump label rebuilding should be done.  */\n+static int\n+update_equiv_regs (void)\n+{\n+  rtx insn;\n+  basic_block bb;\n+  int loop_depth;\n+  bitmap cleared_regs;\n+  \n+  /* We need to keep track of whether or not we recorded a LABEL_REF so\n+     that we know if the jump optimizer needs to be rerun.  */\n+  recorded_label_ref = 0;\n+\n+  reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n+  reg_equiv_init = GGC_CNEWVEC (rtx, max_regno);\n+  reg_equiv_init_size = max_regno;\n+\n+  init_alias_analysis ();\n+\n+  /* Scan the insns and find which registers have equivalences.  Do this\n+     in a separate scan of the insns because (due to -fcse-follow-jumps)\n+     a register can be set below its use.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      loop_depth = bb->loop_depth;\n+\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx note;\n+\t  rtx set;\n+\t  rtx dest, src;\n+\t  int regno;\n+\n+\t  if (! INSN_P (insn))\n+\t    continue;\n+\n+\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_INC)\n+\t      no_equiv (XEXP (note, 0), note, NULL);\n+\n+\t  set = single_set (insn);\n+\n+\t  /* If this insn contains more (or less) than a single SET,\n+\t     only mark all destinations as having no known equivalence.  */\n+\t  if (set == 0)\n+\t    {\n+\t      note_stores (PATTERN (insn), no_equiv, NULL);\n+\t      continue;\n+\t    }\n+\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t    {\n+\t      int i;\n+\n+\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t\t{\n+\t\t  rtx part = XVECEXP (PATTERN (insn), 0, i);\n+\t\t  if (part != set)\n+\t\t    note_stores (part, no_equiv, NULL);\n+\t\t}\n+\t    }\n+\n+\t  dest = SET_DEST (set);\n+\t  src = SET_SRC (set);\n+\n+\t  /* See if this is setting up the equivalence between an argument\n+\t     register and its stack slot.  */\n+\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+\t  if (note)\n+\t    {\n+\t      gcc_assert (REG_P (dest));\n+\t      regno = REGNO (dest);\n+\n+\t      /* Note that we don't want to clear reg_equiv_init even if there\n+\t\t are multiple sets of this register.  */\n+\t      reg_equiv[regno].is_arg_equivalence = 1;\n+\n+\t      /* Record for reload that this is an equivalencing insn.  */\n+\t      if (rtx_equal_p (src, XEXP (note, 0)))\n+\t\treg_equiv_init[regno]\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n+\n+\t      /* Continue normally in case this is a candidate for\n+\t\t replacements.  */\n+\t    }\n+\n+\t  if (!optimize)\n+\t    continue;\n+\n+\t  /* We only handle the case of a pseudo register being set\n+\t     once, or always to the same value.  */\n+\t  /* ??? The mn10200 port breaks if we add equivalences for\n+\t     values that need an ADDRESS_REGS register and set them equivalent\n+\t     to a MEM of a pseudo.  The actual problem is in the over-conservative\n+\t     handling of INPADDR_ADDRESS / INPUT_ADDRESS / INPUT triples in\n+\t     calculate_needs, but we traditionally work around this problem\n+\t     here by rejecting equivalences when the destination is in a register\n+\t     that's likely spilled.  This is fragile, of course, since the\n+\t     preferred class of a pseudo depends on all instructions that set\n+\t     or use it.  */\n+\n+\t  if (!REG_P (dest)\n+\t      || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n+\t      || reg_equiv[regno].init_insns == const0_rtx\n+\t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n+\t\t  && MEM_P (src) && ! reg_equiv[regno].is_arg_equivalence))\n+\t    {\n+\t      /* This might be setting a SUBREG of a pseudo, a pseudo that is\n+\t\t also set somewhere else to a constant.  */\n+\t      note_stores (set, no_equiv, NULL);\n+\t      continue;\n+\t    }\n+\n+\t  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\n+\t  /* cse sometimes generates function invariants, but doesn't put a\n+\t     REG_EQUAL note on the insn.  Since this note would be redundant,\n+\t     there's no point creating it earlier than here.  */\n+\t  if (! note && ! rtx_varies_p (src, 0))\n+\t    note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n+\n+\t  /* Don't bother considering a REG_EQUAL note containing an EXPR_LIST\n+\t     since it represents a function call */\n+\t  if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n+\t    note = NULL_RTX;\n+\n+\t  if (DF_REG_DEF_COUNT (regno) != 1\n+\t      && (! note\n+\t\t  || rtx_varies_p (XEXP (note, 0), 0)\n+\t\t  || (reg_equiv[regno].replacement\n+\t\t      && ! rtx_equal_p (XEXP (note, 0),\n+\t\t\t\t\treg_equiv[regno].replacement))))\n+\t    {\n+\t      no_equiv (dest, set, NULL);\n+\t      continue;\n+\t    }\n+\t  /* Record this insn as initializing this register.  */\n+\t  reg_equiv[regno].init_insns\n+\t    = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv[regno].init_insns);\n+\n+\t  /* If this register is known to be equal to a constant, record that\n+\t     it is always equivalent to the constant.  */\n+\t  if (DF_REG_DEF_COUNT (regno) == 1\n+\t      && note && ! rtx_varies_p (XEXP (note, 0), 0))\n+\t    {\n+\t      rtx note_value = XEXP (note, 0);\n+\t      remove_note (insn, note);\n+\t      set_unique_reg_note (insn, REG_EQUIV, note_value);\n+\t    }\n+\n+\t  /* If this insn introduces a \"constant\" register, decrease the priority\n+\t     of that register.  Record this insn if the register is only used once\n+\t     more and the equivalence value is the same as our source.\n+\n+\t     The latter condition is checked for two reasons:  First, it is an\n+\t     indication that it may be more efficient to actually emit the insn\n+\t     as written (if no registers are available, reload will substitute\n+\t     the equivalence).  Secondly, it avoids problems with any registers\n+\t     dying in this insn whose death notes would be missed.\n+\n+\t     If we don't have a REG_EQUIV note, see if this insn is loading\n+\t     a register used only in one basic block from a MEM.  If so, and the\n+\t     MEM remains unchanged for the life of the register, add a REG_EQUIV\n+\t     note.  */\n+\n+\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+\n+\t  if (note == 0 && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n+\t      && MEM_P (SET_SRC (set))\n+\t      && validate_equiv_mem (insn, dest, SET_SRC (set)))\n+\t    note = set_unique_reg_note (insn, REG_EQUIV, copy_rtx (SET_SRC (set)));\n+\n+\t  if (note)\n+\t    {\n+\t      int regno = REGNO (dest);\n+\t      rtx x = XEXP (note, 0);\n+\n+\t      /* If we haven't done so, record for reload that this is an\n+\t\t equivalencing insn.  */\n+\t      if (!reg_equiv[regno].is_arg_equivalence)\n+\t\treg_equiv_init[regno]\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n+\n+\t      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n+\t\t We might end up substituting the LABEL_REF for uses of the\n+\t\t pseudo here or later.  That kind of transformation may turn an\n+\t\t indirect jump into a direct jump, in which case we must rerun the\n+\t\t jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n+\t      if (GET_CODE (x) == LABEL_REF\n+\t\t  || (GET_CODE (x) == CONST\n+\t\t      && GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)))\n+\t\trecorded_label_ref = 1;\n+\n+\t      reg_equiv[regno].replacement = x;\n+\t      reg_equiv[regno].src_p = &SET_SRC (set);\n+\t      reg_equiv[regno].loop_depth = loop_depth;\n+\n+\t      /* Don't mess with things live during setjmp.  */\n+\t      if (REG_LIVE_LENGTH (regno) >= 0 && optimize)\n+\t\t{\n+\t\t  /* Note that the statement below does not affect the priority\n+\t\t     in local-alloc!  */\n+\t\t  REG_LIVE_LENGTH (regno) *= 2;\n+\n+\t\t  /* If the register is referenced exactly twice, meaning it is\n+\t\t     set once and used once, indicate that the reference may be\n+\t\t     replaced by the equivalence we computed above.  Do this\n+\t\t     even if the register is only used in one block so that\n+\t\t     dependencies can be handled where the last register is\n+\t\t     used in a different block (i.e. HIGH / LO_SUM sequences)\n+\t\t     and to reduce the number of registers alive across\n+\t\t     calls.  */\n+\n+\t\t  if (REG_N_REFS (regno) == 2\n+\t\t      && (rtx_equal_p (x, src)\n+\t\t\t  || ! equiv_init_varies_p (src))\n+\t\t      && NONJUMP_INSN_P (insn)\n+\t\t      && equiv_init_movable_p (PATTERN (insn), regno))\n+\t\t    reg_equiv[regno].replace = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (!optimize)\n+    goto out;\n+\n+  /* A second pass, to gather additional equivalences with memory.  This needs\n+     to be done after we know which registers we are going to replace.  */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx set, src, dest;\n+      unsigned regno;\n+\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      set = single_set (insn);\n+      if (! set)\n+\tcontinue;\n+\n+      dest = SET_DEST (set);\n+      src = SET_SRC (set);\n+\n+      /* If this sets a MEM to the contents of a REG that is only used\n+\t in a single basic block, see if the register is always equivalent\n+\t to that memory location and if moving the store from INSN to the\n+\t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n+\t initializing insn.\n+\n+\t Don't add a REG_EQUIV note if the insn already has one.  The existing\n+\t REG_EQUIV is likely more useful than the one we are adding.\n+\n+\t If one of the regs in the address has reg_equiv[REGNO].replace set,\n+\t then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n+\t optimization may move the set of this register immediately before\n+\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n+\t the mention in the REG_EQUIV note would be to an uninitialized\n+\t pseudo.  */\n+\n+      if (MEM_P (dest) && REG_P (src)\n+\t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n+\t  && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n+\t  && DF_REG_DEF_COUNT (regno) == 1\n+\t  && reg_equiv[regno].init_insns != 0\n+\t  && reg_equiv[regno].init_insns != const0_rtx\n+\t  && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n+\t\t\t      REG_EQUIV, NULL_RTX)\n+\t  && ! contains_replace_regs (XEXP (dest, 0)))\n+\t{\n+\t  rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n+\t  if (validate_equiv_mem (init_insn, src, dest)\n+\t      && ! memref_used_between_p (dest, init_insn, insn)\n+\t      /* Attaching a REG_EQUIV note will fail if INIT_INSN has\n+\t\t multiple sets.  */\n+\t      && set_unique_reg_note (init_insn, REG_EQUIV, copy_rtx (dest)))\n+\t    {\n+\t      /* This insn makes the equivalence, not the one initializing\n+\t\t the register.  */\n+\t      reg_equiv_init[regno]\n+\t\t= gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t      df_notes_rescan (init_insn);\n+\t    }\n+\t}\n+    }\n+\n+  cleared_regs = BITMAP_ALLOC (NULL);\n+  /* Now scan all regs killed in an insn to see if any of them are\n+     registers only used that once.  If so, see if we can replace the\n+     reference with the equivalent form.  If we can, delete the\n+     initializing reference and this register will go away.  If we\n+     can't replace the reference, and the initializing reference is\n+     within the same loop (or in an inner loop), then move the register\n+     initialization just before the use, so that they are in the same\n+     basic block.  */\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      loop_depth = bb->loop_depth;\n+      for (insn = BB_END (bb);\n+\t   insn != PREV_INSN (BB_HEAD (bb));\n+\t   insn = PREV_INSN (insn))\n+\t{\n+\t  rtx link;\n+\n+\t  if (! INSN_P (insn))\n+\t    continue;\n+\n+\t  /* Don't substitute into a non-local goto, this confuses CFG.  */\n+\t  if (JUMP_P (insn)\n+\t      && find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+\t    continue;\n+\n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t    {\n+\t      if (REG_NOTE_KIND (link) == REG_DEAD\n+\t\t  /* Make sure this insn still refers to the register.  */\n+\t\t  && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n+\t\t{\n+\t\t  int regno = REGNO (XEXP (link, 0));\n+\t\t  rtx equiv_insn;\n+\n+\t\t  if (! reg_equiv[regno].replace\n+\t\t      || reg_equiv[regno].loop_depth < loop_depth)\n+\t\t    continue;\n+\n+\t\t  /* reg_equiv[REGNO].replace gets set only when\n+\t\t     REG_N_REFS[REGNO] is 2, i.e. the register is set\n+\t\t     once and used once.  (If it were only set, but not used,\n+\t\t     flow would have deleted the setting insns.)  Hence\n+\t\t     there can only be one insn in reg_equiv[REGNO].init_insns.  */\n+\t\t  gcc_assert (reg_equiv[regno].init_insns\n+\t\t\t      && !XEXP (reg_equiv[regno].init_insns, 1));\n+\t\t  equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n+\n+\t\t  /* We may not move instructions that can throw, since\n+\t\t     that changes basic block boundaries and we are not\n+\t\t     prepared to adjust the CFG to match.  */\n+\t\t  if (can_throw_internal (equiv_insn))\n+\t\t    continue;\n+\n+\t\t  if (asm_noperands (PATTERN (equiv_insn)) < 0\n+\t\t      && validate_replace_rtx (regno_reg_rtx[regno],\n+\t\t\t\t\t       *(reg_equiv[regno].src_p), insn))\n+\t\t    {\n+\t\t      rtx equiv_link;\n+\t\t      rtx last_link;\n+\t\t      rtx note;\n+\n+\t\t      /* Find the last note.  */\n+\t\t      for (last_link = link; XEXP (last_link, 1);\n+\t\t\t   last_link = XEXP (last_link, 1))\n+\t\t\t;\n+\n+\t\t      /* Append the REG_DEAD notes from equiv_insn.  */\n+\t\t      equiv_link = REG_NOTES (equiv_insn);\n+\t\t      while (equiv_link)\n+\t\t\t{\n+\t\t\t  note = equiv_link;\n+\t\t\t  equiv_link = XEXP (equiv_link, 1);\n+\t\t\t  if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t\t\t    {\n+\t\t\t      remove_note (equiv_insn, note);\n+\t\t\t      XEXP (last_link, 1) = note;\n+\t\t\t      XEXP (note, 1) = NULL_RTX;\n+\t\t\t      last_link = note;\n+\t\t\t    }\n+\t\t\t}\n+\n+\t\t      remove_death (regno, insn);\n+\t\t      SET_REG_N_REFS (regno, 0);\n+\t\t      REG_FREQ (regno) = 0;\n+\t\t      delete_insn (equiv_insn);\n+\n+\t\t      reg_equiv[regno].init_insns\n+\t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n+\n+\t\t      reg_equiv_init[regno] = NULL_RTX;\n+\t\t      bitmap_set_bit (cleared_regs, regno);\n+\t\t    }\n+\t\t  /* Move the initialization of the register to just before\n+\t\t     INSN.  Update the flow information.  */\n+\t\t  else if (PREV_INSN (insn) != equiv_insn)\n+\t\t    {\n+\t\t      rtx new_insn;\n+\n+\t\t      new_insn = emit_insn_before (PATTERN (equiv_insn), insn);\n+\t\t      REG_NOTES (new_insn) = REG_NOTES (equiv_insn);\n+\t\t      REG_NOTES (equiv_insn) = 0;\n+\t\t      /* Rescan it to process the notes.  */\n+\t\t      df_insn_rescan (new_insn);\n+\n+\t\t      /* Make sure this insn is recognized before\n+\t\t\t reload begins, otherwise\n+\t\t\t eliminate_regs_in_insn will die.  */\n+\t\t      INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n+\n+\t\t      delete_insn (equiv_insn);\n+\n+\t\t      XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n+\n+\t\t      REG_BASIC_BLOCK (regno) = bb->index;\n+\t\t      REG_N_CALLS_CROSSED (regno) = 0;\n+\t\t      REG_FREQ_CALLS_CROSSED (regno) = 0;\n+\t\t      REG_N_THROWING_CALLS_CROSSED (regno) = 0;\n+\t\t      REG_LIVE_LENGTH (regno) = 2;\n+\n+\t\t      if (insn == BB_HEAD (bb))\n+\t\t\tBB_HEAD (bb) = PREV_INSN (insn);\n+\n+\t\t      reg_equiv_init[regno]\n+\t\t\t= gen_rtx_INSN_LIST (VOIDmode, new_insn, NULL_RTX);\n+\t\t      bitmap_set_bit (cleared_regs, regno);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (!bitmap_empty_p (cleared_regs))\n+    FOR_EACH_BB (bb)\n+      {\n+\tbitmap_and_compl_into (DF_LIVE_IN (bb), cleared_regs);\n+\tbitmap_and_compl_into (DF_LIVE_OUT (bb), cleared_regs);\n+\tbitmap_and_compl_into (DF_LR_IN (bb), cleared_regs);\n+\tbitmap_and_compl_into (DF_LR_OUT (bb), cleared_regs);\n+      }\n+\n+  BITMAP_FREE (cleared_regs);\n+\n+  out:\n+  /* Clean up.  */\n+\n+  end_alias_analysis ();\n+  free (reg_equiv);\n+  return recorded_label_ref;\n+}\n+\n+\f\n+\n+/* Print chain C to FILE.  */\n+static void\n+print_insn_chain (FILE *file, struct insn_chain *c)\n+{\n+  fprintf (file, \"insn=%d, \", INSN_UID(c->insn));\n+  bitmap_print (file, &c->live_throughout, \"live_throughout: \", \", \");\n+  bitmap_print (file, &c->dead_or_set, \"dead_or_set: \", \"\\n\");\n+}\n+\n+\n+/* Print all reload_insn_chains to FILE.  */\n+static void\n+print_insn_chains (FILE *file)\n+{\n+  struct insn_chain *c;\n+  for (c = reload_insn_chain; c ; c = c->next)\n+    print_insn_chain (file, c);\n+}\n+\n+/* Return true if pseudo REGNO should be added to set live_throughout\n+   or dead_or_set of the insn chains for reload consideration.  */\n+static bool\n+pseudo_for_reload_consideration_p (int regno)\n+{\n+  /* Consider spilled pseudos too for IRA because they still have a\n+     chance to get hard-registers in the reload when IRA is used.  */\n+  return (reg_renumber[regno] >= 0\n+\t  || (ira_conflicts_p && flag_ira_share_spill_slots));\n+}\n+\n+/* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] using\n+   REG to the number of nregs, and INIT_VALUE to get the\n+   initialization.  ALLOCNUM need not be the regno of REG.  */\n+static void\n+init_live_subregs (bool init_value, sbitmap *live_subregs,\n+\t\t   int *live_subregs_used, int allocnum, rtx reg)\n+{\n+  unsigned int regno = REGNO (SUBREG_REG (reg));\n+  int size = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n+\n+  gcc_assert (size > 0);\n+\n+  /* Been there, done that.  */\n+  if (live_subregs_used[allocnum])\n+    return;\n+\n+  /* Create a new one with zeros.  */\n+  if (live_subregs[allocnum] == NULL)\n+    live_subregs[allocnum] = sbitmap_alloc (size);\n+\n+  /* If the entire reg was live before blasting into subregs, we need\n+     to init all of the subregs to ones else init to 0.  */\n+  if (init_value)\n+    sbitmap_ones (live_subregs[allocnum]);\n+  else \n+    sbitmap_zero (live_subregs[allocnum]);\n+\n+  /* Set the number of bits that we really want.  */\n+  live_subregs_used[allocnum] = size;\n+}\n+\n+/* Walk the insns of the current function and build reload_insn_chain,\n+   and record register life information.  */\n+static void\n+build_insn_chain (void)\n+{\n+  unsigned int i;\n+  struct insn_chain **p = &reload_insn_chain;\n+  basic_block bb;\n+  struct insn_chain *c = NULL;\n+  struct insn_chain *next = NULL;\n+  bitmap live_relevant_regs = BITMAP_ALLOC (NULL);\n+  bitmap elim_regset = BITMAP_ALLOC (NULL);\n+  /* live_subregs is a vector used to keep accurate information about\n+     which hardregs are live in multiword pseudos.  live_subregs and\n+     live_subregs_used are indexed by pseudo number.  The live_subreg\n+     entry for a particular pseudo is only used if the corresponding\n+     element is non zero in live_subregs_used.  The value in\n+     live_subregs_used is number of bytes that the pseudo can\n+     occupy.  */\n+  sbitmap *live_subregs = XCNEWVEC (sbitmap, max_regno);\n+  int *live_subregs_used = XNEWVEC (int, max_regno);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (eliminable_regset, i))\n+      bitmap_set_bit (elim_regset, i);\n+  FOR_EACH_BB_REVERSE (bb)\n+    {\n+      bitmap_iterator bi;\n+      rtx insn;\n+      \n+      CLEAR_REG_SET (live_relevant_regs);\n+      memset (live_subregs_used, 0, max_regno * sizeof (int));\n+      \n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb), 0, i, bi)\n+\t{\n+\t  if (i >= FIRST_PSEUDO_REGISTER)\n+\t    break;\n+\t  bitmap_set_bit (live_relevant_regs, i);\n+\t}\n+\n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_out (bb),\n+\t\t\t\tFIRST_PSEUDO_REGISTER, i, bi)\n+\t{\n+\t  if (pseudo_for_reload_consideration_p (i))\n+\t    bitmap_set_bit (live_relevant_regs, i);\n+\t}\n+\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+\t{\n+\t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n+\t    {\n+\t      unsigned int uid = INSN_UID (insn);\n+\t      df_ref *def_rec;\n+\t      df_ref *use_rec;\n+\n+\t      c = new_insn_chain ();\n+\t      c->next = next;\n+\t      next = c;\n+\t      *p = c;\n+\t      p = &c->prev;\n+\t      \n+\t      c->insn = insn;\n+\t      c->block = bb->index;\n+\n+\t      if (INSN_P (insn))\n+\t\tfor (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+\t\t  {\n+\t\t    df_ref def = *def_rec;\n+\t\t    unsigned int regno = DF_REF_REGNO (def);\n+\t\t    \n+\t\t    /* Ignore may clobbers because these are generated\n+\t\t       from calls. However, every other kind of def is\n+\t\t       added to dead_or_set.  */\n+\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n+\t\t      {\n+\t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n+\t\t\t  {\n+\t\t\t    if (!fixed_regs[regno])\n+\t\t\t      bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t\t  }\n+\t\t\telse if (pseudo_for_reload_consideration_p (regno))\n+\t\t\t  bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t      }\n+\n+\t\t    if ((regno < FIRST_PSEUDO_REGISTER\n+\t\t\t || reg_renumber[regno] >= 0\n+\t\t\t || ira_conflicts_p)\n+\t\t\t&& (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL)))\n+\t\t      {\n+\t\t\trtx reg = DF_REF_REG (def);\n+\n+\t\t\t/* We can model subregs, but not if they are\n+\t\t\t   wrapped in ZERO_EXTRACTS.  */\n+\t\t\tif (GET_CODE (reg) == SUBREG\n+\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n+\t\t\t  {\n+\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n+\t\t\t    unsigned int last = start \n+\t\t\t      + GET_MODE_SIZE (GET_MODE (reg));\n+\n+\t\t\t    init_live_subregs\n+\t\t\t      (bitmap_bit_p (live_relevant_regs, regno), \n+\t\t\t       live_subregs, live_subregs_used, regno, reg);\n+\n+\t\t\t    if (!DF_REF_FLAGS_IS_SET\n+\t\t\t\t(def, DF_REF_STRICT_LOW_PART))\n+\t\t\t      {\n+\t\t\t\t/* Expand the range to cover entire words.\n+\t\t\t\t   Bytes added here are \"don't care\".  */\n+\t\t\t\tstart\n+\t\t\t\t  = start / UNITS_PER_WORD * UNITS_PER_WORD;\n+\t\t\t\tlast = ((last + UNITS_PER_WORD - 1)\n+\t\t\t\t\t/ UNITS_PER_WORD * UNITS_PER_WORD);\n+\t\t\t      }\n+\n+\t\t\t    /* Ignore the paradoxical bits.  */\n+\t\t\t    if ((int)last > live_subregs_used[regno])\n+\t\t\t      last = live_subregs_used[regno];\n+\n+\t\t\t    while (start < last)\n+\t\t\t      {\n+\t\t\t\tRESET_BIT (live_subregs[regno], start);\n+\t\t\t\tstart++;\n+\t\t\t      }\n+\t\t\t    \n+\t\t\t    if (sbitmap_empty_p (live_subregs[regno]))\n+\t\t\t      {\n+\t\t\t\tlive_subregs_used[regno] = 0;\n+\t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      /* Set live_relevant_regs here because\n+\t\t\t\t that bit has to be true to get us to\n+\t\t\t\t look at the live_subregs fields.  */\n+\t\t\t      bitmap_set_bit (live_relevant_regs, regno);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    /* DF_REF_PARTIAL is generated for\n+\t\t\t       subregs, STRICT_LOW_PART, and\n+\t\t\t       ZERO_EXTRACT.  We handle the subreg\n+\t\t\t       case above so here we have to keep from\n+\t\t\t       modeling the def as a killing def.  */\n+\t\t\t    if (!DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL))\n+\t\t\t      {\n+\t\t\t\tbitmap_clear_bit (live_relevant_regs, regno);\n+\t\t\t\tlive_subregs_used[regno] = 0;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\t  \n+\t      bitmap_and_compl_into (live_relevant_regs, elim_regset);\n+\t      bitmap_copy (&c->live_throughout, live_relevant_regs);\n+\n+\t      if (INSN_P (insn))\n+\t\tfor (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n+\t\t  {\n+\t\t    df_ref use = *use_rec;\n+\t\t    unsigned int regno = DF_REF_REGNO (use);\n+\t\t    rtx reg = DF_REF_REG (use);\n+\t\t    \n+\t\t    /* DF_REF_READ_WRITE on a use means that this use\n+\t\t       is fabricated from a def that is a partial set\n+\t\t       to a multiword reg.  Here, we only model the\n+\t\t       subreg case that is not wrapped in ZERO_EXTRACT\n+\t\t       precisely so we do not need to look at the\n+\t\t       fabricated use. */\n+\t\t    if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n+\t\t\t&& !DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT) \n+\t\t\t&& DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n+\t\t      continue;\n+\t\t    \n+\t\t    /* Add the last use of each var to dead_or_set.  */\n+\t\t    if (!bitmap_bit_p (live_relevant_regs, regno))\n+\t\t      {\n+\t\t\tif (regno < FIRST_PSEUDO_REGISTER)\n+\t\t\t  {\n+\t\t\t    if (!fixed_regs[regno])\n+\t\t\t      bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t\t  }\n+\t\t\telse if (pseudo_for_reload_consideration_p (regno))\n+\t\t\t  bitmap_set_bit (&c->dead_or_set, regno);\n+\t\t      }\n+\t\t    \n+\t\t    if (regno < FIRST_PSEUDO_REGISTER\n+\t\t\t|| pseudo_for_reload_consideration_p (regno))\n+\t\t      {\n+\t\t\tif (GET_CODE (reg) == SUBREG\n+\t\t\t    && !DF_REF_FLAGS_IS_SET (use,\n+\t\t\t\t\t\t     DF_REF_SIGN_EXTRACT\n+\t\t\t\t\t\t     | DF_REF_ZERO_EXTRACT)) \n+\t\t\t  {\n+\t\t\t    unsigned int start = SUBREG_BYTE (reg);\n+\t\t\t    unsigned int last = start \n+\t\t\t      + GET_MODE_SIZE (GET_MODE (reg));\n+\t\t\t    \n+\t\t\t    init_live_subregs\n+\t\t\t      (bitmap_bit_p (live_relevant_regs, regno), \n+\t\t\t       live_subregs, live_subregs_used, regno, reg);\n+\t\t\t    \n+\t\t\t    /* Ignore the paradoxical bits.  */\n+\t\t\t    if ((int)last > live_subregs_used[regno])\n+\t\t\t      last = live_subregs_used[regno];\n+\n+\t\t\t    while (start < last)\n+\t\t\t      {\n+\t\t\t\tSET_BIT (live_subregs[regno], start);\n+\t\t\t\tstart++;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  /* Resetting the live_subregs_used is\n+\t\t\t     effectively saying do not use the subregs\n+\t\t\t     because we are reading the whole\n+\t\t\t     pseudo.  */\n+\t\t\t  live_subregs_used[regno] = 0;\n+\t\t\tbitmap_set_bit (live_relevant_regs, regno);\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t}\n+\n+      /* FIXME!! The following code is a disaster.  Reload needs to see the\n+\t labels and jump tables that are just hanging out in between\n+\t the basic blocks.  See pr33676.  */\n+      insn = BB_HEAD (bb);\n+      \n+      /* Skip over the barriers and cruft.  */\n+      while (insn && (BARRIER_P (insn) || NOTE_P (insn) \n+\t\t      || BLOCK_FOR_INSN (insn) == bb))\n+\tinsn = PREV_INSN (insn);\n+      \n+      /* While we add anything except barriers and notes, the focus is\n+\t to get the labels and jump tables into the\n+\t reload_insn_chain.  */\n+      while (insn)\n+\t{\n+\t  if (!NOTE_P (insn) && !BARRIER_P (insn))\n+\t    {\n+\t      if (BLOCK_FOR_INSN (insn))\n+\t\tbreak;\n+\t      \n+\t      c = new_insn_chain ();\n+\t      c->next = next;\n+\t      next = c;\n+\t      *p = c;\n+\t      p = &c->prev;\n+\t      \n+\t      /* The block makes no sense here, but it is what the old\n+\t\t code did.  */\n+\t      c->block = bb->index;\n+\t      c->insn = insn;\n+\t      bitmap_copy (&c->live_throughout, live_relevant_regs);\n+\t    }\t  \n+\t  insn = PREV_INSN (insn);\n+\t}\n+    }\n+\n+  for (i = 0; i < (unsigned int) max_regno; i++)\n+    if (live_subregs[i])\n+      free (live_subregs[i]);\n+\n+  reload_insn_chain = c;\n+  *p = NULL;\n+\n+  free (live_subregs);\n+  free (live_subregs_used);\n+  BITMAP_FREE (live_relevant_regs);\n+  BITMAP_FREE (elim_regset);\n+\n+  if (dump_file)\n+    print_insn_chains (dump_file);\n+}\n+\n+\f\n+\n /* All natural loops.  */\n struct loops ira_loops;\n \n@@ -2085,7 +3299,7 @@ ira (FILE *f)\n static bool\n gate_ira (void)\n {\n-  return flag_ira != 0;\n+  return true;\n }\n \n /* Run the integrated register allocator.  */"}, {"sha": "648f239a65df8878ec8d5bc8e004b7d8337b373d", "filename": "gcc/local-alloc.c", "status": "removed", "additions": 0, "deletions": 2545, "changes": 2545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b251a0371e71bce271656eb7d069851cbd7fcf/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b251a0371e71bce271656eb7d069851cbd7fcf/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=00b251a0371e71bce271656eb7d069851cbd7fcf", "patch": "@@ -1,2545 +0,0 @@\n-/* Allocate registers within a basic block, for GNU compiler.\n-   Copyright (C) 1987, 1988, 1991, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Allocation of hard register numbers to pseudo registers is done in\n-   two passes.  In this pass we consider only regs that are born and\n-   die once within one basic block.  We do this one basic block at a\n-   time.  Then the next pass allocates the registers that remain.\n-   Two passes are used because this pass uses methods that work only\n-   on linear code, but that do a better job than the general methods\n-   used in global_alloc, and more quickly too.\n-\n-   The assignments made are recorded in the vector reg_renumber\n-   whose space is allocated here.  The rtl code itself is not altered.\n-\n-   We assign each instruction in the basic block a number\n-   which is its order from the beginning of the block.\n-   Then we can represent the lifetime of a pseudo register with\n-   a pair of numbers, and check for conflicts easily.\n-   We can record the availability of hard registers with a\n-   HARD_REG_SET for each instruction.  The HARD_REG_SET\n-   contains 0 or 1 for each hard reg.\n-\n-   To avoid register shuffling, we tie registers together when one\n-   dies by being copied into another, or dies in an instruction that\n-   does arithmetic to produce another.  The tied registers are\n-   allocated as one.  Registers with different reg class preferences\n-   can never be tied unless the class preferred by one is a subclass\n-   of the one preferred by the other.\n-\n-   Tying is represented with \"quantity numbers\".\n-   A non-tied register is given a new quantity number.\n-   Tied registers have the same quantity number.\n-\n-   We have provision to exempt registers, even when they are contained\n-   within the block, that can be tied to others that are not contained in it.\n-   This is so that global_alloc could process them both and tie them then.\n-   But this is currently disabled since tying in global_alloc is not\n-   yet implemented.  */\n-\n-/* Pseudos allocated here can be reallocated by global.c if the hard register\n-   is used as a spill register.  Currently we don't allocate such pseudos\n-   here if their preferred class is likely to be used by spills.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"hard-reg-set.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"flags.h\"\n-#include \"regs.h\"\n-#include \"function.h\"\n-#include \"insn-config.h\"\n-#include \"insn-attr.h\"\n-#include \"recog.h\"\n-#include \"output.h\"\n-#include \"toplev.h\"\n-#include \"except.h\"\n-#include \"integrate.h\"\n-#include \"reload.h\"\n-#include \"ggc.h\"\n-#include \"timevar.h\"\n-#include \"tree-pass.h\"\n-#include \"df.h\"\n-#include \"dbgcnt.h\"\n-\n-\f\n-/* Next quantity number available for allocation.  */\n-\n-static int next_qty;\n-\n-/* Information we maintain about each quantity.  */\n-struct qty\n-{\n-  /* The number of refs to quantity Q.  */\n-\n-  int n_refs;\n-\n-  /* The frequency of uses of quantity Q.  */\n-\n-  int freq;\n-\n-  /* Insn number (counting from head of basic block)\n-     where quantity Q was born.  -1 if birth has not been recorded.  */\n-\n-  int birth;\n-\n-  /* Insn number (counting from head of basic block)\n-     where given quantity died.  Due to the way tying is done,\n-     and the fact that we consider in this pass only regs that die but once,\n-     a quantity can die only once.  Each quantity's life span\n-     is a set of consecutive insns.  -1 if death has not been recorded.  */\n-\n-  int death;\n-\n-  /* Number of words needed to hold the data in given quantity.\n-     This depends on its machine mode.  It is used for these purposes:\n-     1. It is used in computing the relative importance of qtys,\n-\twhich determines the order in which we look for regs for them.\n-     2. It is used in rules that prevent tying several registers of\n-\tdifferent sizes in a way that is geometrically impossible\n-\t(see combine_regs).  */\n-\n-  int size;\n-\n-  /* Number of times a reg tied to given qty lives across a CALL_INSN.  */\n-\n-  int n_calls_crossed;\n-\n-  /* Number of times a reg tied to given qty lives across a CALL_INSN.  */\n-\n-  int freq_calls_crossed;\n-\n-  /* Number of times a reg tied to given qty lives across a CALL_INSN\n-     that might throw.  */\n-\n-  int n_throwing_calls_crossed;\n-\n-  /* The register number of one pseudo register whose reg_qty value is Q.\n-     This register should be the head of the chain\n-     maintained in reg_next_in_qty.  */\n-\n-  int first_reg;\n-\n-  /* Reg class contained in (smaller than) the preferred classes of all\n-     the pseudo regs that are tied in given quantity.\n-     This is the preferred class for allocating that quantity.  */\n-\n-  enum reg_class min_class;\n-\n-  /* Register class within which we allocate given qty if we can't get\n-     its preferred class.  */\n-\n-  enum reg_class alternate_class;\n-\n-  /* This holds the mode of the registers that are tied to given qty,\n-     or VOIDmode if registers with differing modes are tied together.  */\n-\n-  enum machine_mode mode;\n-\n-  /* the hard reg number chosen for given quantity,\n-     or -1 if none was found.  */\n-\n-  short phys_reg;\n-};\n-\n-static struct qty *qty;\n-\n-/* These fields are kept separately to speedup their clearing.  */\n-\n-/* We maintain two hard register sets that indicate suggested hard registers\n-   for each quantity.  The first, phys_copy_sugg, contains hard registers\n-   that are tied to the quantity by a simple copy.  The second contains all\n-   hard registers that are tied to the quantity via an arithmetic operation.\n-\n-   The former register set is given priority for allocation.  This tends to\n-   eliminate copy insns.  */\n-\n-/* Element Q is a set of hard registers that are suggested for quantity Q by\n-   copy insns.  */\n-\n-static HARD_REG_SET *qty_phys_copy_sugg;\n-\n-/* Element Q is a set of hard registers that are suggested for quantity Q by\n-   arithmetic insns.  */\n-\n-static HARD_REG_SET *qty_phys_sugg;\n-\n-/* Element Q is the number of suggested registers in qty_phys_copy_sugg.  */\n-\n-static short *qty_phys_num_copy_sugg;\n-\n-/* Element Q is the number of suggested registers in qty_phys_sugg.  */\n-\n-static short *qty_phys_num_sugg;\n-\n-/* If (REG N) has been assigned a quantity number, is a register number\n-   of another register assigned the same quantity number, or -1 for the\n-   end of the chain.  qty->first_reg point to the head of this chain.  */\n-\n-static int *reg_next_in_qty;\n-\n-/* reg_qty[N] (where N is a pseudo reg number) is the qty number of that reg\n-   if it is >= 0,\n-   of -1 if this register cannot be allocated by local-alloc,\n-   or -2 if not known yet.\n-\n-   Note that if we see a use or death of pseudo register N with\n-   reg_qty[N] == -2, register N must be local to the current block.  If\n-   it were used in more than one block, we would have reg_qty[N] == -1.\n-   This relies on the fact that if reg_basic_block[N] is >= 0, register N\n-   will not appear in any other block.  We save a considerable number of\n-   tests by exploiting this.\n-\n-   If N is < FIRST_PSEUDO_REGISTER, reg_qty[N] is undefined and should not\n-   be referenced.  */\n-\n-static int *reg_qty;\n-\n-/* The offset (in words) of register N within its quantity.\n-   This can be nonzero if register N is SImode, and has been tied\n-   to a subreg of a DImode register.  */\n-\n-static char *reg_offset;\n-\n-/* Vector of substitutions of register numbers,\n-   used to map pseudo regs into hardware regs.\n-   This is set up as a result of register allocation.\n-   Element N is the hard reg assigned to pseudo reg N,\n-   or is -1 if no hard reg was assigned.\n-   If N is a hard reg number, element N is N.  */\n-\n-short *reg_renumber;\n-\n-/* Set of hard registers live at the current point in the scan\n-   of the instructions in a basic block.  */\n-\n-static HARD_REG_SET regs_live;\n-\n-/* Each set of hard registers indicates registers live at a particular\n-   point in the basic block.  For N even, regs_live_at[N] says which\n-   hard registers are needed *after* insn N/2 (i.e., they may not\n-   conflict with the outputs of insn N/2 or the inputs of insn N/2 + 1.\n-\n-   If an object is to conflict with the inputs of insn J but not the\n-   outputs of insn J + 1, we say it is born at index J*2 - 1.  Similarly,\n-   if it is to conflict with the outputs of insn J but not the inputs of\n-   insn J + 1, it is said to die at index J*2 + 1.  */\n-\n-static HARD_REG_SET *regs_live_at;\n-\n-/* Communicate local vars `insn_number' and `insn'\n-   from `block_alloc' to `reg_is_set', `wipe_dead_reg', and `alloc_qty'.  */\n-static int this_insn_number;\n-static rtx this_insn;\n-\n-struct equivalence\n-{\n-  /* Set when an attempt should be made to replace a register\n-     with the associated src_p entry.  */\n-\n-  char replace;\n-\n-  /* Set when a REG_EQUIV note is found or created.  Use to\n-     keep track of what memory accesses might be created later,\n-     e.g. by reload.  */\n-\n-  rtx replacement;\n-\n-  rtx *src_p;\n-\n-  /* Loop depth is used to recognize equivalences which appear\n-     to be present within the same loop (or in an inner loop).  */\n-\n-  int loop_depth;\n-\n-  /* The list of each instruction which initializes this register.  */\n-\n-  rtx init_insns;\n-\n-  /* Nonzero if this had a preexisting REG_EQUIV note.  */\n-\n-  int is_arg_equivalence;\n-};\n-\n-/* reg_equiv[N] (where N is a pseudo reg number) is the equivalence\n-   structure for that register.  */\n-\n-static struct equivalence *reg_equiv;\n-\n-/* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n-static int recorded_label_ref;\n-\n-static void alloc_qty (int, enum machine_mode, int, int);\n-static void validate_equiv_mem_from_store (rtx, const_rtx, void *);\n-static int validate_equiv_mem (rtx, rtx, rtx);\n-static int equiv_init_varies_p (rtx);\n-static int equiv_init_movable_p (rtx, int);\n-static int contains_replace_regs (rtx);\n-static int memref_referenced_p (rtx, rtx);\n-static int memref_used_between_p (rtx, rtx, rtx);\n-static void no_equiv (rtx, const_rtx, void *);\n-static void block_alloc (basic_block);\n-static int qty_sugg_compare (int, int);\n-static int qty_sugg_compare_1 (const void *, const void *);\n-static int qty_compare (int, int);\n-static int qty_compare_1 (const void *, const void *);\n-static int combine_regs (rtx, rtx, int, int, rtx);\n-static int reg_meets_class_p (int, enum reg_class);\n-static void update_qty_class (int, int);\n-static void reg_is_set (rtx, const_rtx, void *);\n-static void reg_is_born (rtx, int);\n-static void wipe_dead_reg (rtx, int);\n-static int find_free_reg (enum reg_class, enum machine_mode, int, int, int,\n-\t\t\t  int, int, basic_block);\n-static void mark_life (int, enum machine_mode, int);\n-static void post_mark_life (int, enum machine_mode, int, int, int);\n-static int requires_inout (const char *);\n-\f\n-/* Allocate a new quantity (new within current basic block)\n-   for register number REGNO which is born at index BIRTH\n-   within the block.  MODE and SIZE are info on reg REGNO.  */\n-\n-static void\n-alloc_qty (int regno, enum machine_mode mode, int size, int birth)\n-{\n-  int qtyno = next_qty++;\n-\n-  reg_qty[regno] = qtyno;\n-  reg_offset[regno] = 0;\n-  reg_next_in_qty[regno] = -1;\n-\n-  qty[qtyno].first_reg = regno;\n-  qty[qtyno].size = size;\n-  qty[qtyno].mode = mode;\n-  qty[qtyno].birth = birth;\n-  qty[qtyno].n_calls_crossed = REG_N_CALLS_CROSSED (regno);\n-  qty[qtyno].freq_calls_crossed = REG_FREQ_CALLS_CROSSED (regno);\n-  qty[qtyno].n_throwing_calls_crossed = REG_N_THROWING_CALLS_CROSSED (regno);\n-  qty[qtyno].min_class = reg_preferred_class (regno);\n-  qty[qtyno].alternate_class = reg_alternate_class (regno);\n-  qty[qtyno].n_refs = REG_N_REFS (regno);\n-  qty[qtyno].freq = REG_FREQ (regno);\n-}\n-\f\n-/* Main entry point of this file.  */\n-\n-static int\n-local_alloc (void)\n-{\n-  int i;\n-  int max_qty;\n-  basic_block b;\n-\n-  /* We need to keep track of whether or not we recorded a LABEL_REF so\n-     that we know if the jump optimizer needs to be rerun.  */\n-  recorded_label_ref = 0;\n-\n-  /* Leaf functions and non-leaf functions have different needs.\n-     If defined, let the machine say what kind of ordering we\n-     should use.  */\n-#ifdef ORDER_REGS_FOR_LOCAL_ALLOC\n-  ORDER_REGS_FOR_LOCAL_ALLOC;\n-#endif\n-\n-  /* Promote REG_EQUAL notes to REG_EQUIV notes and adjust status of affected\n-     registers.  */\n-  update_equiv_regs ();\n-\n-  /* This sets the maximum number of quantities we can have.  Quantity\n-     numbers start at zero and we can have one for each pseudo.  */\n-  max_qty = (max_regno - FIRST_PSEUDO_REGISTER);\n-\n-  /* Allocate vectors of temporary data.\n-     See the declarations of these variables, above,\n-     for what they mean.  */\n-\n-  qty = XNEWVEC (struct qty, max_qty);\n-  qty_phys_copy_sugg = XNEWVEC (HARD_REG_SET, max_qty);\n-  qty_phys_num_copy_sugg = XNEWVEC (short, max_qty);\n-  qty_phys_sugg = XNEWVEC (HARD_REG_SET, max_qty);\n-  qty_phys_num_sugg = XNEWVEC (short, max_qty);\n-\n-  reg_qty = XNEWVEC (int, max_regno);\n-  reg_offset = XNEWVEC (char, max_regno);\n-  reg_next_in_qty = XNEWVEC (int, max_regno);\n-\n-  /* Determine which pseudo-registers can be allocated by local-alloc.\n-     In general, these are the registers used only in a single block and\n-     which only die once.\n-\n-     We need not be concerned with which block actually uses the register\n-     since we will never see it outside that block.  */\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    {\n-      if (REG_BASIC_BLOCK (i) >= NUM_FIXED_BLOCKS && REG_N_DEATHS (i) == 1)\n-\treg_qty[i] = -2;\n-      else\n-\treg_qty[i] = -1;\n-    }\n-\n-  /* Force loop below to initialize entire quantity array.  */\n-  next_qty = max_qty;\n-\n-  /* Allocate each block's local registers, block by block.  */\n-\n-  FOR_EACH_BB (b)\n-    {\n-      /* NEXT_QTY indicates which elements of the `qty_...'\n-\t vectors might need to be initialized because they were used\n-\t for the previous block; it is set to the entire array before\n-\t block 0.  Initialize those, with explicit loop if there are few,\n-\t else with bzero and bcopy.  Do not initialize vectors that are\n-\t explicit set by `alloc_qty'.  */\n-\n-      if (next_qty < 6)\n-\t{\n-\t  for (i = 0; i < next_qty; i++)\n-\t    {\n-\t      CLEAR_HARD_REG_SET (qty_phys_copy_sugg[i]);\n-\t      qty_phys_num_copy_sugg[i] = 0;\n-\t      CLEAR_HARD_REG_SET (qty_phys_sugg[i]);\n-\t      qty_phys_num_sugg[i] = 0;\n-\t    }\n-\t}\n-      else\n-\t{\n-#define CLEAR(vector)  \\\n-\t  memset ((vector), 0, (sizeof (*(vector))) * next_qty);\n-\n-\t  CLEAR (qty_phys_copy_sugg);\n-\t  CLEAR (qty_phys_num_copy_sugg);\n-\t  CLEAR (qty_phys_sugg);\n-\t  CLEAR (qty_phys_num_sugg);\n-\t}\n-\n-      next_qty = 0;\n-\n-      block_alloc (b);\n-    }\n-\n-  free (qty);\n-  free (qty_phys_copy_sugg);\n-  free (qty_phys_num_copy_sugg);\n-  free (qty_phys_sugg);\n-  free (qty_phys_num_sugg);\n-\n-  free (reg_qty);\n-  free (reg_offset);\n-  free (reg_next_in_qty);\n-\n-  return recorded_label_ref;\n-}\n-\f\n-/* Used for communication between the following two functions: contains\n-   a MEM that we wish to ensure remains unchanged.  */\n-static rtx equiv_mem;\n-\n-/* Set nonzero if EQUIV_MEM is modified.  */\n-static int equiv_mem_modified;\n-\n-/* If EQUIV_MEM is modified by modifying DEST, indicate that it is modified.\n-   Called via note_stores.  */\n-\n-static void\n-validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n-\t\t\t       void *data ATTRIBUTE_UNUSED)\n-{\n-  if ((REG_P (dest)\n-       && reg_overlap_mentioned_p (dest, equiv_mem))\n-      || (MEM_P (dest)\n-\t  && true_dependence (dest, VOIDmode, equiv_mem, rtx_varies_p)))\n-    equiv_mem_modified = 1;\n-}\n-\n-/* Verify that no store between START and the death of REG invalidates\n-   MEMREF.  MEMREF is invalidated by modifying a register used in MEMREF,\n-   by storing into an overlapping memory location, or with a non-const\n-   CALL_INSN.\n-\n-   Return 1 if MEMREF remains valid.  */\n-\n-static int\n-validate_equiv_mem (rtx start, rtx reg, rtx memref)\n-{\n-  rtx insn;\n-  rtx note;\n-\n-  equiv_mem = memref;\n-  equiv_mem_modified = 0;\n-\n-  /* If the memory reference has side effects or is volatile, it isn't a\n-     valid equivalence.  */\n-  if (side_effects_p (memref))\n-    return 0;\n-\n-  for (insn = start; insn && ! equiv_mem_modified; insn = NEXT_INSN (insn))\n-    {\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      if (find_reg_note (insn, REG_DEAD, reg))\n-\treturn 1;\n-\n-      if (CALL_P (insn) && ! MEM_READONLY_P (memref)\n-\t  && ! RTL_CONST_OR_PURE_CALL_P (insn))\n-\treturn 0;\n-\n-      note_stores (PATTERN (insn), validate_equiv_mem_from_store, NULL);\n-\n-      /* If a register mentioned in MEMREF is modified via an\n-\t auto-increment, we lose the equivalence.  Do the same if one\n-\t dies; although we could extend the life, it doesn't seem worth\n-\t the trouble.  */\n-\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\tif ((REG_NOTE_KIND (note) == REG_INC\n-\t     || REG_NOTE_KIND (note) == REG_DEAD)\n-\t    && REG_P (XEXP (note, 0))\n-\t    && reg_overlap_mentioned_p (XEXP (note, 0), memref))\n-\t  return 0;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Returns zero if X is known to be invariant.  */\n-\n-static int\n-equiv_init_varies_p (rtx x)\n-{\n-  RTX_CODE code = GET_CODE (x);\n-  int i;\n-  const char *fmt;\n-\n-  switch (code)\n-    {\n-    case MEM:\n-      return !MEM_READONLY_P (x) || equiv_init_varies_p (XEXP (x, 0));\n-\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 0;\n-\n-    case REG:\n-      return reg_equiv[REGNO (x)].replace == 0 && rtx_varies_p (x, 0);\n-\n-    case ASM_OPERANDS:\n-      if (MEM_VOLATILE_P (x))\n-\treturn 1;\n-\n-      /* Fall through.  */\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e')\n-      {\n-\tif (equiv_init_varies_p (XEXP (x, i)))\n-\t  return 1;\n-      }\n-    else if (fmt[i] == 'E')\n-      {\n-\tint j;\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (equiv_init_varies_p (XVECEXP (x, i, j)))\n-\t    return 1;\n-      }\n-\n-  return 0;\n-}\n-\n-/* Returns nonzero if X (used to initialize register REGNO) is movable.\n-   X is only movable if the registers it uses have equivalent initializations\n-   which appear to be within the same loop (or in an inner loop) and movable\n-   or if they are not candidates for local_alloc and don't vary.  */\n-\n-static int\n-equiv_init_movable_p (rtx x, int regno)\n-{\n-  int i, j;\n-  const char *fmt;\n-  enum rtx_code code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case SET:\n-      return equiv_init_movable_p (SET_SRC (x), regno);\n-\n-    case CC0:\n-    case CLOBBER:\n-      return 0;\n-\n-    case PRE_INC:\n-    case PRE_DEC:\n-    case POST_INC:\n-    case POST_DEC:\n-    case PRE_MODIFY:\n-    case POST_MODIFY:\n-      return 0;\n-\n-    case REG:\n-      return (reg_equiv[REGNO (x)].loop_depth >= reg_equiv[regno].loop_depth\n-\t      && reg_equiv[REGNO (x)].replace)\n-\t     || (REG_BASIC_BLOCK (REGNO (x)) < NUM_FIXED_BLOCKS && ! rtx_varies_p (x, 0));\n-\n-    case UNSPEC_VOLATILE:\n-      return 0;\n-\n-    case ASM_OPERANDS:\n-      if (MEM_VOLATILE_P (x))\n-\treturn 0;\n-\n-      /* Fall through.  */\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    switch (fmt[i])\n-      {\n-      case 'e':\n-\tif (! equiv_init_movable_p (XEXP (x, i), regno))\n-\t  return 0;\n-\tbreak;\n-      case 'E':\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (! equiv_init_movable_p (XVECEXP (x, i, j), regno))\n-\t    return 0;\n-\tbreak;\n-      }\n-\n-  return 1;\n-}\n-\n-/* TRUE if X uses any registers for which reg_equiv[REGNO].replace is true.  */\n-\n-static int\n-contains_replace_regs (rtx x)\n-{\n-  int i, j;\n-  const char *fmt;\n-  enum rtx_code code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case PC:\n-    case CC0:\n-    case HIGH:\n-      return 0;\n-\n-    case REG:\n-      return reg_equiv[REGNO (x)].replace;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    switch (fmt[i])\n-      {\n-      case 'e':\n-\tif (contains_replace_regs (XEXP (x, i)))\n-\t  return 1;\n-\tbreak;\n-      case 'E':\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (contains_replace_regs (XVECEXP (x, i, j)))\n-\t    return 1;\n-\tbreak;\n-      }\n-\n-  return 0;\n-}\n-\f\n-/* TRUE if X references a memory location that would be affected by a store\n-   to MEMREF.  */\n-\n-static int\n-memref_referenced_p (rtx memref, rtx x)\n-{\n-  int i, j;\n-  const char *fmt;\n-  enum rtx_code code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case PC:\n-    case CC0:\n-    case HIGH:\n-    case LO_SUM:\n-      return 0;\n-\n-    case REG:\n-      return (reg_equiv[REGNO (x)].replacement\n-\t      && memref_referenced_p (memref,\n-\t\t\t\t      reg_equiv[REGNO (x)].replacement));\n-\n-    case MEM:\n-      if (true_dependence (memref, VOIDmode, x, rtx_varies_p))\n-\treturn 1;\n-      break;\n-\n-    case SET:\n-      /* If we are setting a MEM, it doesn't count (its address does), but any\n-\t other SET_DEST that has a MEM in it is referencing the MEM.  */\n-      if (MEM_P (SET_DEST (x)))\n-\t{\n-\t  if (memref_referenced_p (memref, XEXP (SET_DEST (x), 0)))\n-\t    return 1;\n-\t}\n-      else if (memref_referenced_p (memref, SET_DEST (x)))\n-\treturn 1;\n-\n-      return memref_referenced_p (memref, SET_SRC (x));\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    switch (fmt[i])\n-      {\n-      case 'e':\n-\tif (memref_referenced_p (memref, XEXP (x, i)))\n-\t  return 1;\n-\tbreak;\n-      case 'E':\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (memref_referenced_p (memref, XVECEXP (x, i, j)))\n-\t    return 1;\n-\tbreak;\n-      }\n-\n-  return 0;\n-}\n-\n-/* TRUE if some insn in the range (START, END] references a memory location\n-   that would be affected by a store to MEMREF.  */\n-\n-static int\n-memref_used_between_p (rtx memref, rtx start, rtx end)\n-{\n-  rtx insn;\n-\n-  for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (!INSN_P (insn))\n-\tcontinue;\n-      \n-      if (memref_referenced_p (memref, PATTERN (insn)))\n-\treturn 1;\n-\n-      /* Nonconst functions may access memory.  */\n-      if (CALL_P (insn) && (! RTL_CONST_CALL_P (insn)))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\f\n-/* Find registers that are equivalent to a single value throughout the\n-   compilation (either because they can be referenced in memory or are set once\n-   from a single constant).  Lower their priority for a register.\n-\n-   If such a register is only referenced once, try substituting its value\n-   into the using insn.  If it succeeds, we can eliminate the register\n-   completely.\n-\n-   Initialize the REG_EQUIV_INIT array of initializing insns.\n-\n-   Return non-zero if jump label rebuilding should be done.  */\n-\n-int\n-update_equiv_regs (void)\n-{\n-  rtx insn;\n-  basic_block bb;\n-  int loop_depth;\n-  bitmap cleared_regs;\n-  \n-  reg_equiv = XCNEWVEC (struct equivalence, max_regno);\n-  reg_equiv_init = GGC_CNEWVEC (rtx, max_regno);\n-  reg_equiv_init_size = max_regno;\n-\n-  init_alias_analysis ();\n-\n-  /* Scan the insns and find which registers have equivalences.  Do this\n-     in a separate scan of the insns because (due to -fcse-follow-jumps)\n-     a register can be set below its use.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      loop_depth = bb->loop_depth;\n-\n-      for (insn = BB_HEAD (bb);\n-\t   insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  rtx note;\n-\t  rtx set;\n-\t  rtx dest, src;\n-\t  int regno;\n-\n-\t  if (! INSN_P (insn))\n-\t    continue;\n-\n-\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_INC)\n-\t      no_equiv (XEXP (note, 0), note, NULL);\n-\n-\t  set = single_set (insn);\n-\n-\t  /* If this insn contains more (or less) than a single SET,\n-\t     only mark all destinations as having no known equivalence.  */\n-\t  if (set == 0)\n-\t    {\n-\t      note_stores (PATTERN (insn), no_equiv, NULL);\n-\t      continue;\n-\t    }\n-\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t    {\n-\t      int i;\n-\n-\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t\t{\n-\t\t  rtx part = XVECEXP (PATTERN (insn), 0, i);\n-\t\t  if (part != set)\n-\t\t    note_stores (part, no_equiv, NULL);\n-\t\t}\n-\t    }\n-\n-\t  dest = SET_DEST (set);\n-\t  src = SET_SRC (set);\n-\n-\t  /* See if this is setting up the equivalence between an argument\n-\t     register and its stack slot.  */\n-\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\t  if (note)\n-\t    {\n-\t      gcc_assert (REG_P (dest));\n-\t      regno = REGNO (dest);\n-\n-\t      /* Note that we don't want to clear reg_equiv_init even if there\n-\t\t are multiple sets of this register.  */\n-\t      reg_equiv[regno].is_arg_equivalence = 1;\n-\n-\t      /* Record for reload that this is an equivalencing insn.  */\n-\t      if (rtx_equal_p (src, XEXP (note, 0)))\n-\t\treg_equiv_init[regno]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n-\n-\t      /* Continue normally in case this is a candidate for\n-\t\t replacements.  */\n-\t    }\n-\n-\t  if (!optimize)\n-\t    continue;\n-\n-\t  /* We only handle the case of a pseudo register being set\n-\t     once, or always to the same value.  */\n-\t  /* ??? The mn10200 port breaks if we add equivalences for\n-\t     values that need an ADDRESS_REGS register and set them equivalent\n-\t     to a MEM of a pseudo.  The actual problem is in the over-conservative\n-\t     handling of INPADDR_ADDRESS / INPUT_ADDRESS / INPUT triples in\n-\t     calculate_needs, but we traditionally work around this problem\n-\t     here by rejecting equivalences when the destination is in a register\n-\t     that's likely spilled.  This is fragile, of course, since the\n-\t     preferred class of a pseudo depends on all instructions that set\n-\t     or use it.  */\n-\n-\t  if (!REG_P (dest)\n-\t      || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n-\t      || reg_equiv[regno].init_insns == const0_rtx\n-\t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n-\t\t  && MEM_P (src) && ! reg_equiv[regno].is_arg_equivalence))\n-\t    {\n-\t      /* This might be setting a SUBREG of a pseudo, a pseudo that is\n-\t\t also set somewhere else to a constant.  */\n-\t      note_stores (set, no_equiv, NULL);\n-\t      continue;\n-\t    }\n-\n-\t  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\n-\t  /* cse sometimes generates function invariants, but doesn't put a\n-\t     REG_EQUAL note on the insn.  Since this note would be redundant,\n-\t     there's no point creating it earlier than here.  */\n-\t  if (! note && ! rtx_varies_p (src, 0))\n-\t    note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n-\n-\t  /* Don't bother considering a REG_EQUAL note containing an EXPR_LIST\n-\t     since it represents a function call */\n-\t  if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n-\t    note = NULL_RTX;\n-\n-\t  if (DF_REG_DEF_COUNT (regno) != 1\n-\t      && (! note\n-\t\t  || rtx_varies_p (XEXP (note, 0), 0)\n-\t\t  || (reg_equiv[regno].replacement\n-\t\t      && ! rtx_equal_p (XEXP (note, 0),\n-\t\t\t\t\treg_equiv[regno].replacement))))\n-\t    {\n-\t      no_equiv (dest, set, NULL);\n-\t      continue;\n-\t    }\n-\t  /* Record this insn as initializing this register.  */\n-\t  reg_equiv[regno].init_insns\n-\t    = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv[regno].init_insns);\n-\n-\t  /* If this register is known to be equal to a constant, record that\n-\t     it is always equivalent to the constant.  */\n-\t  if (DF_REG_DEF_COUNT (regno) == 1\n-\t      && note && ! rtx_varies_p (XEXP (note, 0), 0))\n-\t    {\n-\t      rtx note_value = XEXP (note, 0);\n-\t      remove_note (insn, note);\n-\t      set_unique_reg_note (insn, REG_EQUIV, note_value);\n-\t    }\n-\n-\t  /* If this insn introduces a \"constant\" register, decrease the priority\n-\t     of that register.  Record this insn if the register is only used once\n-\t     more and the equivalence value is the same as our source.\n-\n-\t     The latter condition is checked for two reasons:  First, it is an\n-\t     indication that it may be more efficient to actually emit the insn\n-\t     as written (if no registers are available, reload will substitute\n-\t     the equivalence).  Secondly, it avoids problems with any registers\n-\t     dying in this insn whose death notes would be missed.\n-\n-\t     If we don't have a REG_EQUIV note, see if this insn is loading\n-\t     a register used only in one basic block from a MEM.  If so, and the\n-\t     MEM remains unchanged for the life of the register, add a REG_EQUIV\n-\t     note.  */\n-\n-\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\n-\t  if (note == 0 && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n-\t      && MEM_P (SET_SRC (set))\n-\t      && validate_equiv_mem (insn, dest, SET_SRC (set)))\n-\t    note = set_unique_reg_note (insn, REG_EQUIV, copy_rtx (SET_SRC (set)));\n-\n-\t  if (note)\n-\t    {\n-\t      int regno = REGNO (dest);\n-\t      rtx x = XEXP (note, 0);\n-\n-\t      /* If we haven't done so, record for reload that this is an\n-\t\t equivalencing insn.  */\n-\t      if (!reg_equiv[regno].is_arg_equivalence)\n-\t\treg_equiv_init[regno]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[regno]);\n-\n-\t      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n-\t\t We might end up substituting the LABEL_REF for uses of the\n-\t\t pseudo here or later.  That kind of transformation may turn an\n-\t\t indirect jump into a direct jump, in which case we must rerun the\n-\t\t jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n-\t      if (GET_CODE (x) == LABEL_REF\n-\t\t  || (GET_CODE (x) == CONST\n-\t\t      && GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)))\n-\t\trecorded_label_ref = 1;\n-\n-\t      reg_equiv[regno].replacement = x;\n-\t      reg_equiv[regno].src_p = &SET_SRC (set);\n-\t      reg_equiv[regno].loop_depth = loop_depth;\n-\n-\t      /* Don't mess with things live during setjmp.  */\n-\t      if (REG_LIVE_LENGTH (regno) >= 0 && optimize)\n-\t\t{\n-\t\t  /* Note that the statement below does not affect the priority\n-\t\t     in local-alloc!  */\n-\t\t  REG_LIVE_LENGTH (regno) *= 2;\n-\n-\t\t  /* If the register is referenced exactly twice, meaning it is\n-\t\t     set once and used once, indicate that the reference may be\n-\t\t     replaced by the equivalence we computed above.  Do this\n-\t\t     even if the register is only used in one block so that\n-\t\t     dependencies can be handled where the last register is\n-\t\t     used in a different block (i.e. HIGH / LO_SUM sequences)\n-\t\t     and to reduce the number of registers alive across\n-\t\t     calls.  */\n-\n-\t\t  if (REG_N_REFS (regno) == 2\n-\t\t      && (rtx_equal_p (x, src)\n-\t\t\t  || ! equiv_init_varies_p (src))\n-\t\t      && NONJUMP_INSN_P (insn)\n-\t\t      && equiv_init_movable_p (PATTERN (insn), regno))\n-\t\t    reg_equiv[regno].replace = 1;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (!optimize)\n-    goto out;\n-\n-  /* A second pass, to gather additional equivalences with memory.  This needs\n-     to be done after we know which registers we are going to replace.  */\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx set, src, dest;\n-      unsigned regno;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      set = single_set (insn);\n-      if (! set)\n-\tcontinue;\n-\n-      dest = SET_DEST (set);\n-      src = SET_SRC (set);\n-\n-      /* If this sets a MEM to the contents of a REG that is only used\n-\t in a single basic block, see if the register is always equivalent\n-\t to that memory location and if moving the store from INSN to the\n-\t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n-\t initializing insn.\n-\n-\t Don't add a REG_EQUIV note if the insn already has one.  The existing\n-\t REG_EQUIV is likely more useful than the one we are adding.\n-\n-\t If one of the regs in the address has reg_equiv[REGNO].replace set,\n-\t then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n-\t optimization may move the set of this register immediately before\n-\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n-\t the mention in the REG_EQUIV note would be to an uninitialized\n-\t pseudo.  */\n-\n-      if (MEM_P (dest) && REG_P (src)\n-\t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n-\t  && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n-\t  && DF_REG_DEF_COUNT (regno) == 1\n-\t  && reg_equiv[regno].init_insns != 0\n-\t  && reg_equiv[regno].init_insns != const0_rtx\n-\t  && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n-\t\t\t      REG_EQUIV, NULL_RTX)\n-\t  && ! contains_replace_regs (XEXP (dest, 0)))\n-\t{\n-\t  rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n-\t  if (validate_equiv_mem (init_insn, src, dest)\n-\t      && ! memref_used_between_p (dest, init_insn, insn)\n-\t      /* Attaching a REG_EQUIV note will fail if INIT_INSN has\n-\t\t multiple sets.  */\n-\t      && set_unique_reg_note (init_insn, REG_EQUIV, copy_rtx (dest)))\n-\t    {\n-\t      /* This insn makes the equivalence, not the one initializing\n-\t\t the register.  */\n-\t      reg_equiv_init[regno]\n-\t\t= gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n-\t      df_notes_rescan (init_insn);\n-\t    }\n-\t}\n-    }\n-\n-  cleared_regs = BITMAP_ALLOC (NULL);\n-  /* Now scan all regs killed in an insn to see if any of them are\n-     registers only used that once.  If so, see if we can replace the\n-     reference with the equivalent form.  If we can, delete the\n-     initializing reference and this register will go away.  If we\n-     can't replace the reference, and the initializing reference is\n-     within the same loop (or in an inner loop), then move the register\n-     initialization just before the use, so that they are in the same\n-     basic block.  */\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      loop_depth = bb->loop_depth;\n-      for (insn = BB_END (bb);\n-\t   insn != PREV_INSN (BB_HEAD (bb));\n-\t   insn = PREV_INSN (insn))\n-\t{\n-\t  rtx link;\n-\n-\t  if (! INSN_P (insn))\n-\t    continue;\n-\n-\t  /* Don't substitute into a non-local goto, this confuses CFG.  */\n-\t  if (JUMP_P (insn)\n-\t      && find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n-\t    continue;\n-\n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    {\n-\t      if (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t  /* Make sure this insn still refers to the register.  */\n-\t\t  && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n-\t\t{\n-\t\t  int regno = REGNO (XEXP (link, 0));\n-\t\t  rtx equiv_insn;\n-\n-\t\t  if (! reg_equiv[regno].replace\n-\t\t      || reg_equiv[regno].loop_depth < loop_depth)\n-\t\t    continue;\n-\n-\t\t  /* reg_equiv[REGNO].replace gets set only when\n-\t\t     REG_N_REFS[REGNO] is 2, i.e. the register is set\n-\t\t     once and used once.  (If it were only set, but not used,\n-\t\t     flow would have deleted the setting insns.)  Hence\n-\t\t     there can only be one insn in reg_equiv[REGNO].init_insns.  */\n-\t\t  gcc_assert (reg_equiv[regno].init_insns\n-\t\t\t      && !XEXP (reg_equiv[regno].init_insns, 1));\n-\t\t  equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n-\n-\t\t  /* We may not move instructions that can throw, since\n-\t\t     that changes basic block boundaries and we are not\n-\t\t     prepared to adjust the CFG to match.  */\n-\t\t  if (can_throw_internal (equiv_insn))\n-\t\t    continue;\n-\n-\t\t  if (asm_noperands (PATTERN (equiv_insn)) < 0\n-\t\t      && validate_replace_rtx (regno_reg_rtx[regno],\n-\t\t\t\t\t       *(reg_equiv[regno].src_p), insn))\n-\t\t    {\n-\t\t      rtx equiv_link;\n-\t\t      rtx last_link;\n-\t\t      rtx note;\n-\n-\t\t      /* Find the last note.  */\n-\t\t      for (last_link = link; XEXP (last_link, 1);\n-\t\t\t   last_link = XEXP (last_link, 1))\n-\t\t\t;\n-\n-\t\t      /* Append the REG_DEAD notes from equiv_insn.  */\n-\t\t      equiv_link = REG_NOTES (equiv_insn);\n-\t\t      while (equiv_link)\n-\t\t\t{\n-\t\t\t  note = equiv_link;\n-\t\t\t  equiv_link = XEXP (equiv_link, 1);\n-\t\t\t  if (REG_NOTE_KIND (note) == REG_DEAD)\n-\t\t\t    {\n-\t\t\t      remove_note (equiv_insn, note);\n-\t\t\t      XEXP (last_link, 1) = note;\n-\t\t\t      XEXP (note, 1) = NULL_RTX;\n-\t\t\t      last_link = note;\n-\t\t\t    }\n-\t\t\t}\n-\n-\t\t      remove_death (regno, insn);\n-\t\t      SET_REG_N_REFS (regno, 0);\n-\t\t      REG_FREQ (regno) = 0;\n-\t\t      delete_insn (equiv_insn);\n-\n-\t\t      reg_equiv[regno].init_insns\n-\t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n-\n-\t\t      reg_equiv_init[regno] = NULL_RTX;\n-\t\t      bitmap_set_bit (cleared_regs, regno);\n-\t\t    }\n-\t\t  /* Move the initialization of the register to just before\n-\t\t     INSN.  Update the flow information.  */\n-\t\t  else if (PREV_INSN (insn) != equiv_insn)\n-\t\t    {\n-\t\t      rtx new_insn;\n-\n-\t\t      new_insn = emit_insn_before (PATTERN (equiv_insn), insn);\n-\t\t      REG_NOTES (new_insn) = REG_NOTES (equiv_insn);\n-\t\t      REG_NOTES (equiv_insn) = 0;\n-\t\t      /* Rescan it to process the notes.  */\n-\t\t      df_insn_rescan (new_insn);\n-\n-\t\t      /* Make sure this insn is recognized before\n-\t\t\t reload begins, otherwise\n-\t\t\t eliminate_regs_in_insn will die.  */\n-\t\t      INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n-\n-\t\t      delete_insn (equiv_insn);\n-\n-\t\t      XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n-\n-\t\t      REG_BASIC_BLOCK (regno) = bb->index;\n-\t\t      REG_N_CALLS_CROSSED (regno) = 0;\n-\t\t      REG_FREQ_CALLS_CROSSED (regno) = 0;\n-\t\t      REG_N_THROWING_CALLS_CROSSED (regno) = 0;\n-\t\t      REG_LIVE_LENGTH (regno) = 2;\n-\n-\t\t      if (insn == BB_HEAD (bb))\n-\t\t\tBB_HEAD (bb) = PREV_INSN (insn);\n-\n-\t\t      reg_equiv_init[regno]\n-\t\t\t= gen_rtx_INSN_LIST (VOIDmode, new_insn, NULL_RTX);\n-\t\t      bitmap_set_bit (cleared_regs, regno);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (!bitmap_empty_p (cleared_regs))\n-    FOR_EACH_BB (bb)\n-      {\n-\tbitmap_and_compl_into (DF_LIVE_IN (bb), cleared_regs);\n-\tbitmap_and_compl_into (DF_LIVE_OUT (bb), cleared_regs);\n-\tbitmap_and_compl_into (DF_LR_IN (bb), cleared_regs);\n-\tbitmap_and_compl_into (DF_LR_OUT (bb), cleared_regs);\n-      }\n-\n-  BITMAP_FREE (cleared_regs);\n-\n-  out:\n-  /* Clean up.  */\n-\n-  end_alias_analysis ();\n-  free (reg_equiv);\n-  return recorded_label_ref;\n-}\n-\n-/* Mark REG as having no known equivalence.\n-   Some instructions might have been processed before and furnished\n-   with REG_EQUIV notes for this register; these notes will have to be\n-   removed.\n-   STORE is the piece of RTL that does the non-constant / conflicting\n-   assignment - a SET, CLOBBER or REG_INC note.  It is currently not used,\n-   but needs to be there because this function is called from note_stores.  */\n-static void\n-no_equiv (rtx reg, const_rtx store ATTRIBUTE_UNUSED, void *data ATTRIBUTE_UNUSED)\n-{\n-  int regno;\n-  rtx list;\n-\n-  if (!REG_P (reg))\n-    return;\n-  regno = REGNO (reg);\n-  list = reg_equiv[regno].init_insns;\n-  if (list == const0_rtx)\n-    return;\n-  reg_equiv[regno].init_insns = const0_rtx;\n-  reg_equiv[regno].replacement = NULL_RTX;\n-  /* This doesn't matter for equivalences made for argument registers, we\n-     should keep their initialization insns.  */\n-  if (reg_equiv[regno].is_arg_equivalence)\n-    return;\n-  reg_equiv_init[regno] = NULL_RTX;\n-  for (; list; list =  XEXP (list, 1))\n-    {\n-      rtx insn = XEXP (list, 0);\n-      remove_note (insn, find_reg_note (insn, REG_EQUIV, NULL_RTX));\n-    }\n-}\n-\f\n-/* Allocate hard regs to the pseudo regs used only within block number B.\n-   Only the pseudos that die but once can be handled.  */\n-\n-static void\n-block_alloc (basic_block b)\n-{\n-  int i, q;\n-  rtx insn;\n-  rtx hard_reg;\n-  int insn_number = 0;\n-  int insn_count = 0;\n-  int max_uid = get_max_uid ();\n-  int *qty_order;\n-  df_ref *def_rec;\n-\n-  /* Count the instructions in the basic block.  */\n-\n-  insn = BB_END (b);\n-  while (1)\n-    {\n-      if (!NOTE_P (insn))\n-\t{\n-\t  ++insn_count;\n-\t  gcc_assert (insn_count <= max_uid);\n-\t}\n-      if (insn == BB_HEAD (b))\n-\tbreak;\n-      insn = PREV_INSN (insn);\n-    }\n-\n-  /* +2 to leave room for a post_mark_life at the last insn and for\n-     the birth of a CLOBBER in the first insn.  */\n-  regs_live_at = XCNEWVEC (HARD_REG_SET, 2 * insn_count + 2);\n-\n-  /* Initialize table of hardware registers currently live.  */\n-\n-  REG_SET_TO_HARD_REG_SET (regs_live, DF_LR_IN (b));\n-\n-  /* This is conservative, as this would include registers that are\n-     artificial-def'ed-but-not-used.  However, artificial-defs are\n-     rare, and such uninitialized use is rarer still, and the chance\n-     of this having any performance impact is even less, while the\n-     benefit is not having to compute and keep the TOP set around.  */\n-  for (def_rec = df_get_artificial_defs (b->index); *def_rec; def_rec++)\n-    {\n-      int regno = DF_REF_REGNO (*def_rec);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\tSET_HARD_REG_BIT (regs_live, regno);\n-    }\n-\n-  /* This loop scans the instructions of the basic block\n-     and assigns quantities to registers.\n-     It computes which registers to tie.  */\n-\n-  insn = BB_HEAD (b);\n-  while (1)\n-    {\n-      if (!NOTE_P (insn))\n-\tinsn_number++;\n-\n-      if (INSN_P (insn))\n-\t{\n-\t  rtx link;\n-\t  int win = 0;\n-\t  rtx r0, r1 = NULL_RTX;\n-\t  int combined_regno = -1;\n-\t  int i;\n-\n-\t  this_insn_number = insn_number;\n-\t  this_insn = insn;\n-\n-\t  extract_insn (insn);\n-\t  which_alternative = -1;\n-\n-\t  /* Is this insn suitable for tying two registers?\n-\t     If so, try doing that.\n-\t     Suitable insns are those with at least two operands and where\n-\t     operand 0 is an output that is a register that is not\n-\t     earlyclobber.\n-\n-\t     We can tie operand 0 with some operand that dies in this insn.\n-\t     First look for operands that are required to be in the same\n-\t     register as operand 0.  If we find such, only try tying that\n-\t     operand or one that can be put into that operand if the\n-\t     operation is commutative.  If we don't find an operand\n-\t     that is required to be in the same register as operand 0,\n-\t     we can tie with any operand.\n-\n-\t     Subregs in place of regs are also ok.\n-\n-\t     If tying is done, WIN is set nonzero.  */\n-\n-\t  if (optimize\n-\t      && recog_data.n_operands > 1\n-\t      && recog_data.constraints[0][0] == '='\n-\t      && recog_data.constraints[0][1] != '&')\n-\t    {\n-\t      /* If non-negative, is an operand that must match operand 0.  */\n-\t      int must_match_0 = -1;\n-\t      /* Counts number of alternatives that require a match with\n-\t\t operand 0.  */\n-\t      int n_matching_alts = 0;\n-\n-\t      for (i = 1; i < recog_data.n_operands; i++)\n-\t\t{\n-\t\t  const char *p = recog_data.constraints[i];\n-\t\t  int this_match = requires_inout (p);\n-\n-\t\t  n_matching_alts += this_match;\n-\t\t  if (this_match == recog_data.n_alternatives)\n-\t\t    must_match_0 = i;\n-\t\t}\n-\n-\t      r0 = recog_data.operand[0];\n-\t      for (i = 1; i < recog_data.n_operands; i++)\n-\t\t{\n-\t\t  /* Skip this operand if we found an operand that\n-\t\t     must match operand 0 and this operand isn't it\n-\t\t     and can't be made to be it by commutativity.  */\n-\n-\t\t  if (must_match_0 >= 0 && i != must_match_0\n-\t\t      && ! (i == must_match_0 + 1\n-\t\t\t    && recog_data.constraints[i-1][0] == '%')\n-\t\t      && ! (i == must_match_0 - 1\n-\t\t\t    && recog_data.constraints[i][0] == '%'))\n-\t\t    continue;\n-\n-\t\t  /* Likewise if each alternative has some operand that\n-\t\t     must match operand zero.  In that case, skip any\n-\t\t     operand that doesn't list operand 0 since we know that\n-\t\t     the operand always conflicts with operand 0.  We\n-\t\t     ignore commutativity in this case to keep things simple.  */\n-\t\t  if (n_matching_alts == recog_data.n_alternatives\n-\t\t      && 0 == requires_inout (recog_data.constraints[i]))\n-\t\t    continue;\n-\n-\t\t  r1 = recog_data.operand[i];\n-\n-\t\t  /* If the operand is an address, find a register in it.\n-\t\t     There may be more than one register, but we only try one\n-\t\t     of them.  */\n-\t\t  if (recog_data.constraints[i][0] == 'p'\n-\t\t      || EXTRA_ADDRESS_CONSTRAINT (recog_data.constraints[i][0],\n-\t\t\t\t\t\t   recog_data.constraints[i]))\n-\t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n-\t\t      r1 = XEXP (r1, 0);\n-\n-\t\t  /* Avoid making a call-saved register unnecessarily\n-                     clobbered.  */\n-\t\t  hard_reg = get_hard_reg_initial_reg (r1);\n-\t\t  if (hard_reg != NULL_RTX)\n-\t\t    {\n-\t\t      if (REG_P (hard_reg)\n-\t\t\t  && REGNO (hard_reg) < FIRST_PSEUDO_REGISTER\n-\t\t\t  && !call_used_regs[REGNO (hard_reg)])\n-\t\t\tcontinue;\n-\t\t    }\n-\n-\t\t  if (REG_P (r0) || GET_CODE (r0) == SUBREG)\n-\t\t    {\n-\t\t      /* We have two priorities for hard register preferences.\n-\t\t\t If we have a move insn or an insn whose first input\n-\t\t\t can only be in the same register as the output, give\n-\t\t\t priority to an equivalence found from that insn.  */\n-\t\t      int may_save_copy\n-\t\t\t= (r1 == recog_data.operand[i] && must_match_0 >= 0);\n-\n-\t\t      if (REG_P (r1) || GET_CODE (r1) == SUBREG)\n-\t\t\twin = combine_regs (r1, r0, may_save_copy,\n-\t\t\t\t\t    insn_number, insn);\n-\t\t    }\n-\t\t  if (win)\n-\t\t    break;\n-\t\t}\n-\t    }\n-\n-\t  /* If registers were just tied, set COMBINED_REGNO\n-\t     to the number of the register used in this insn\n-\t     that was tied to the register set in this insn.\n-\t     This register's qty should not be \"killed\".  */\n-\n-\t  if (win)\n-\t    {\n-\t      while (GET_CODE (r1) == SUBREG)\n-\t\tr1 = SUBREG_REG (r1);\n-\t      combined_regno = REGNO (r1);\n-\t    }\n-\n-\t  /* Mark the death of everything that dies in this instruction.  */\n-\n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    if (REG_NOTE_KIND (link) == REG_DEAD\n-\t\t&& REG_P (XEXP (link, 0))\n-\t\t&& combined_regno != (int) REGNO (XEXP (link, 0)))\n-\t      wipe_dead_reg (XEXP (link, 0), 0);\n-\n-\t  /* Allocate qty numbers for all registers local to this block\n-\t     that are born (set) in this instruction.\n-\t     A pseudo that already has a qty is not changed.  */\n-\n-\t  note_stores (PATTERN (insn), reg_is_set, NULL);\n-\n-\t  /* If anything is set in this insn and then unused, mark it as dying\n-\t     after this insn, so it will conflict with our outputs.  This\n-\t     can't match with something that combined, and it doesn't matter\n-\t     if it did.  Do this after the calls to reg_is_set since these\n-\t     die after, not during, the current insn.  */\n-\n-\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t    if (REG_NOTE_KIND (link) == REG_UNUSED\n-\t\t&& REG_P (XEXP (link, 0)))\n-\t      wipe_dead_reg (XEXP (link, 0), 1);\n-\t}\n-\n-      /* Set the registers live after INSN_NUMBER.  Note that we never\n-\t record the registers live before the block's first insn, since no\n-\t pseudos we care about are live before that insn.  */\n-\n-      IOR_HARD_REG_SET (regs_live_at[2 * insn_number], regs_live);\n-      IOR_HARD_REG_SET (regs_live_at[2 * insn_number + 1], regs_live);\n-\n-      if (insn == BB_END (b))\n-\tbreak;\n-\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  /* Now every register that is local to this basic block\n-     should have been given a quantity, or else -1 meaning ignore it.\n-     Every quantity should have a known birth and death.\n-\n-     Order the qtys so we assign them registers in order of the\n-     number of suggested registers they need so we allocate those with\n-     the most restrictive needs first.  */\n-\n-  qty_order = XNEWVEC (int, next_qty);\n-  for (i = 0; i < next_qty; i++)\n-    qty_order[i] = i;\n-\n-#define EXCHANGE(I1, I2)  \\\n-  { i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }\n-\n-  switch (next_qty)\n-    {\n-    case 3:\n-      /* Make qty_order[2] be the one to allocate last.  */\n-      if (qty_sugg_compare (0, 1) > 0)\n-\tEXCHANGE (0, 1);\n-      if (qty_sugg_compare (1, 2) > 0)\n-\tEXCHANGE (2, 1);\n-\n-      /* ... Fall through ...  */\n-    case 2:\n-      /* Put the best one to allocate in qty_order[0].  */\n-      if (qty_sugg_compare (0, 1) > 0)\n-\tEXCHANGE (0, 1);\n-\n-      /* ... Fall through ...  */\n-\n-    case 1:\n-    case 0:\n-      /* Nothing to do here.  */\n-      break;\n-\n-    default:\n-      qsort (qty_order, next_qty, sizeof (int), qty_sugg_compare_1);\n-    }\n-\n-  /* Try to put each quantity in a suggested physical register, if it has one.\n-     This may cause registers to be allocated that otherwise wouldn't be, but\n-     this seems acceptable in local allocation (unlike global allocation).  */\n-  for (i = 0; i < next_qty; i++)\n-    {\n-      q = qty_order[i];\n-      if (qty_phys_num_sugg[q] != 0 || qty_phys_num_copy_sugg[q] != 0)\n-\tqty[q].phys_reg = find_free_reg (qty[q].min_class, qty[q].mode, q,\n-\t\t\t\t\t 0, 1, qty[q].birth, qty[q].death, b);\n-      else\n-\tqty[q].phys_reg = -1;\n-    }\n-\n-  /* Order the qtys so we assign them registers in order of\n-     decreasing length of life.  Normally call qsort, but if we\n-     have only a very small number of quantities, sort them ourselves.  */\n-\n-  for (i = 0; i < next_qty; i++)\n-    qty_order[i] = i;\n-\n-#define EXCHANGE(I1, I2)  \\\n-  { i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }\n-\n-  switch (next_qty)\n-    {\n-    case 3:\n-      /* Make qty_order[2] be the one to allocate last.  */\n-      if (qty_compare (0, 1) > 0)\n-\tEXCHANGE (0, 1);\n-      if (qty_compare (1, 2) > 0)\n-\tEXCHANGE (2, 1);\n-\n-      /* ... Fall through ...  */\n-    case 2:\n-      /* Put the best one to allocate in qty_order[0].  */\n-      if (qty_compare (0, 1) > 0)\n-\tEXCHANGE (0, 1);\n-\n-      /* ... Fall through ...  */\n-\n-    case 1:\n-    case 0:\n-      /* Nothing to do here.  */\n-      break;\n-\n-    default:\n-      qsort (qty_order, next_qty, sizeof (int), qty_compare_1);\n-    }\n-\n-  /* Now for each qty that is not a hardware register,\n-     look for a hardware register to put it in.\n-     First try the register class that is cheapest for this qty,\n-     if there is more than one class.  */\n-\n-  for (i = 0; i < next_qty; i++)\n-    {\n-      q = qty_order[i];\n-      if (qty[q].phys_reg < 0)\n-\t{\n-#ifdef INSN_SCHEDULING\n-\t  /* These values represent the adjusted lifetime of a qty so\n-\t     that it conflicts with qtys which appear near the start/end\n-\t     of this qty's lifetime.\n-\n-\t     The purpose behind extending the lifetime of this qty is to\n-\t     discourage the register allocator from creating false\n-\t     dependencies.\n-\n-\t     The adjustment value is chosen to indicate that this qty\n-\t     conflicts with all the qtys in the instructions immediately\n-\t     before and after the lifetime of this qty.\n-\n-\t     Experiments have shown that higher values tend to hurt\n-\t     overall code performance.\n-\n-\t     If allocation using the extended lifetime fails we will try\n-\t     again with the qty's unadjusted lifetime.  */\n-\t  int fake_birth = MAX (0, qty[q].birth - 2 + qty[q].birth % 2);\n-\t  int fake_death = MIN (insn_number * 2 + 1,\n-\t\t\t\tqty[q].death + 2 - qty[q].death % 2);\n-#endif\n-\n-\t  if (N_REG_CLASSES > 1)\n-\t    {\n-#ifdef INSN_SCHEDULING\n-\t      /* We try to avoid using hard registers allocated to qtys which\n-\t\t are born immediately after this qty or die immediately before\n-\t\t this qty.\n-\n-\t\t This optimization is only appropriate when we will run\n-\t\t a scheduling pass after reload and we are not optimizing\n-\t\t for code size.  */\n-\t      if (flag_schedule_insns_after_reload && dbg_cnt (local_alloc_for_sched)\n-\t\t  && optimize_bb_for_speed_p (b)\n-\t\t  && !SMALL_REGISTER_CLASSES)\n-\t\t{\n-\t\t  qty[q].phys_reg = find_free_reg (qty[q].min_class,\n-\t\t\t\t\t\t   qty[q].mode, q, 0, 0,\n-\t\t\t\t\t\t   fake_birth, fake_death, b);\n-\t\t  if (qty[q].phys_reg >= 0)\n-\t\t    continue;\n-\t\t}\n-#endif\n-\t      qty[q].phys_reg = find_free_reg (qty[q].min_class,\n-\t\t\t\t\t       qty[q].mode, q, 0, 0,\n-\t\t\t\t\t       qty[q].birth, qty[q].death, b);\n-\t      if (qty[q].phys_reg >= 0)\n-\t\tcontinue;\n-\t    }\n-\n-#ifdef INSN_SCHEDULING\n-\t  /* Similarly, avoid false dependencies.  */\n-\t  if (flag_schedule_insns_after_reload && dbg_cnt (local_alloc_for_sched)\n-\t      && optimize_bb_for_speed_p (b)\n-\t      && !SMALL_REGISTER_CLASSES\n-\t      && qty[q].alternate_class != NO_REGS)\n-\t    qty[q].phys_reg = find_free_reg (qty[q].alternate_class,\n-\t\t\t\t\t     qty[q].mode, q, 0, 0,\n-\t\t\t\t\t     fake_birth, fake_death, b);\n-#endif\n-\t  if (qty[q].alternate_class != NO_REGS)\n-\t    qty[q].phys_reg = find_free_reg (qty[q].alternate_class,\n-\t\t\t\t\t     qty[q].mode, q, 0, 0,\n-\t\t\t\t\t     qty[q].birth, qty[q].death, b);\n-\t}\n-    }\n-\n-  /* Now propagate the register assignments\n-     to the pseudo regs belonging to the qtys.  */\n-\n-  for (q = 0; q < next_qty; q++)\n-    if (qty[q].phys_reg >= 0)\n-      {\n-\tfor (i = qty[q].first_reg; i >= 0; i = reg_next_in_qty[i])\n-\t  reg_renumber[i] = qty[q].phys_reg + reg_offset[i];\n-      }\n-\n-  /* Clean up.  */\n-  free (regs_live_at);\n-  free (qty_order);\n-}\n-\f\n-/* Compare two quantities' priority for getting real registers.\n-   We give shorter-lived quantities higher priority.\n-   Quantities with more references are also preferred, as are quantities that\n-   require multiple registers.  This is the identical prioritization as\n-   done by global-alloc.\n-\n-   We used to give preference to registers with *longer* lives, but using\n-   the same algorithm in both local- and global-alloc can speed up execution\n-   of some programs by as much as a factor of three!  */\n-\n-/* Note that the quotient will never be bigger than\n-   the value of floor_log2 times the maximum number of\n-   times a register can occur in one insn (surely less than 100)\n-   weighted by frequency (max REG_FREQ_MAX).\n-   Multiplying this by 10000/REG_FREQ_MAX can't overflow.\n-   QTY_CMP_PRI is also used by qty_sugg_compare.  */\n-\n-#define QTY_CMP_PRI(q)\t\t\\\n-  ((int) (((double) (floor_log2 (qty[q].n_refs) * qty[q].freq * qty[q].size) \\\n-\t  / (qty[q].death - qty[q].birth)) * (10000 / REG_FREQ_MAX)))\n-\n-static int\n-qty_compare (int q1, int q2)\n-{\n-  return QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n-}\n-\n-static int\n-qty_compare_1 (const void *q1p, const void *q2p)\n-{\n-  int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n-  int tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n-\n-  if (tem != 0)\n-    return tem;\n-\n-  /* If qtys are equally good, sort by qty number,\n-     so that the results of qsort leave nothing to chance.  */\n-  return q1 - q2;\n-}\n-\f\n-/* Compare two quantities' priority for getting real registers.  This version\n-   is called for quantities that have suggested hard registers.  First priority\n-   goes to quantities that have copy preferences, then to those that have\n-   normal preferences.  Within those groups, quantities with the lower\n-   number of preferences have the highest priority.  Of those, we use the same\n-   algorithm as above.  */\n-\n-#define QTY_CMP_SUGG(q)\t\t\\\n-  (qty_phys_num_copy_sugg[q]\t\t\\\n-    ? qty_phys_num_copy_sugg[q]\t\\\n-    : qty_phys_num_sugg[q] * FIRST_PSEUDO_REGISTER)\n-\n-static int\n-qty_sugg_compare (int q1, int q2)\n-{\n-  int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n-\n-  if (tem != 0)\n-    return tem;\n-\n-  return QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n-}\n-\n-static int\n-qty_sugg_compare_1 (const void *q1p, const void *q2p)\n-{\n-  int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n-  int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n-\n-  if (tem != 0)\n-    return tem;\n-\n-  tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n-  if (tem != 0)\n-    return tem;\n-\n-  /* If qtys are equally good, sort by qty number,\n-     so that the results of qsort leave nothing to chance.  */\n-  return q1 - q2;\n-}\n-\n-#undef QTY_CMP_SUGG\n-#undef QTY_CMP_PRI\n-\f\n-/* Attempt to combine the two registers (rtx's) USEDREG and SETREG.\n-   Returns 1 if have done so, or 0 if cannot.\n-\n-   Combining registers means marking them as having the same quantity\n-   and adjusting the offsets within the quantity if either of\n-   them is a SUBREG.\n-\n-   We don't actually combine a hard reg with a pseudo; instead\n-   we just record the hard reg as the suggestion for the pseudo's quantity.\n-   If we really combined them, we could lose if the pseudo lives\n-   across an insn that clobbers the hard reg (eg, movmem).\n-\n-   MAY_SAVE_COPY is nonzero if this insn is simply copying USEDREG to\n-   SETREG or if the input and output must share a register.\n-   In that case, we record a hard reg suggestion in QTY_PHYS_COPY_SUGG.\n-\n-   There are elaborate checks for the validity of combining.  */\n-\n-static int\n-combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n-\t      rtx insn)\n-{\n-  int ureg, sreg;\n-  int offset = 0;\n-  int usize, ssize;\n-  int sqty;\n-\n-  /* Determine the numbers and sizes of registers being used.  If a subreg\n-     is present that does not change the entire register, don't consider\n-     this a copy insn.  */\n-\n-  while (GET_CODE (usedreg) == SUBREG)\n-    {\n-      rtx subreg = SUBREG_REG (usedreg);\n-\n-      if (REG_P (subreg))\n-\t{\n-\t  if (GET_MODE_SIZE (GET_MODE (subreg)) > UNITS_PER_WORD)\n-\t    may_save_copy = 0;\n-\n-\t  if (REGNO (subreg) < FIRST_PSEUDO_REGISTER)\n-\t    offset += subreg_regno_offset (REGNO (subreg),\n-\t\t\t\t\t   GET_MODE (subreg),\n-\t\t\t\t\t   SUBREG_BYTE (usedreg),\n-\t\t\t\t\t   GET_MODE (usedreg));\n-\t  else\n-\t    offset += (SUBREG_BYTE (usedreg)\n-\t\t      / REGMODE_NATURAL_SIZE (GET_MODE (usedreg)));\n-\t}\n-\n-      usedreg = subreg;\n-    }\n-\n-  if (!REG_P (usedreg))\n-    return 0;\n-\n-  ureg = REGNO (usedreg);\n-  if (ureg < FIRST_PSEUDO_REGISTER)\n-    usize = hard_regno_nregs[ureg][GET_MODE (usedreg)];\n-  else\n-    usize = ((GET_MODE_SIZE (GET_MODE (usedreg))\n-\t      + (REGMODE_NATURAL_SIZE (GET_MODE (usedreg)) - 1))\n-\t     / REGMODE_NATURAL_SIZE (GET_MODE (usedreg)));\n-\n-  while (GET_CODE (setreg) == SUBREG)\n-    {\n-      rtx subreg = SUBREG_REG (setreg);\n-\n-      if (REG_P (subreg))\n-\t{\n-\t  if (GET_MODE_SIZE (GET_MODE (subreg)) > UNITS_PER_WORD)\n-\t    may_save_copy = 0;\n-\n-\t  if (REGNO (subreg) < FIRST_PSEUDO_REGISTER)\n-\t    offset -= subreg_regno_offset (REGNO (subreg),\n-\t\t\t\t\t   GET_MODE (subreg),\n-\t\t\t\t\t   SUBREG_BYTE (setreg),\n-\t\t\t\t\t   GET_MODE (setreg));\n-\t  else\n-\t    offset -= (SUBREG_BYTE (setreg)\n-\t\t      / REGMODE_NATURAL_SIZE (GET_MODE (setreg)));\n-\t}\n-\n-      setreg = subreg;\n-    }\n-\n-  if (!REG_P (setreg))\n-    return 0;\n-\n-  sreg = REGNO (setreg);\n-  if (sreg < FIRST_PSEUDO_REGISTER)\n-    ssize = hard_regno_nregs[sreg][GET_MODE (setreg)];\n-  else\n-    ssize = ((GET_MODE_SIZE (GET_MODE (setreg))\n-\t      + (REGMODE_NATURAL_SIZE (GET_MODE (setreg)) - 1))\n-\t     / REGMODE_NATURAL_SIZE (GET_MODE (setreg)));\n-\n-  /* If UREG is a pseudo-register that hasn't already been assigned a\n-     quantity number, it means that it is not local to this block or dies\n-     more than once.  In either event, we can't do anything with it.  */\n-  if ((ureg >= FIRST_PSEUDO_REGISTER && reg_qty[ureg] < 0)\n-      /* Do not combine registers unless one fits within the other.  */\n-      || (offset > 0 && usize + offset > ssize)\n-      || (offset < 0 && usize + offset < ssize)\n-      /* Do not combine with a smaller already-assigned object\n-\t if that smaller object is already combined with something bigger.  */\n-      || (ssize > usize && ureg >= FIRST_PSEUDO_REGISTER\n-\t  && usize < qty[reg_qty[ureg]].size)\n-      /* Can't combine if SREG is not a register we can allocate.  */\n-      || (sreg >= FIRST_PSEUDO_REGISTER && reg_qty[sreg] == -1)\n-      /* Don't tie something to itself.  In most cases it would make no\n-\t difference, but it would screw up if the reg being tied to itself\n-\t also dies in this insn.  */\n-      || ureg == sreg\n-      /* Don't try to connect two different hardware registers.  */\n-      || (ureg < FIRST_PSEUDO_REGISTER && sreg < FIRST_PSEUDO_REGISTER)\n-      /* Don't connect two different machine modes if they have different\n-\t implications as to which registers may be used.  */\n-      || !MODES_TIEABLE_P (GET_MODE (usedreg), GET_MODE (setreg)))\n-    return 0;\n-\n-  /* Now, if UREG is a hard reg and SREG is a pseudo, record the hard reg in\n-     qty_phys_sugg for the pseudo instead of tying them.\n-\n-     Return \"failure\" so that the lifespan of UREG is terminated here;\n-     that way the two lifespans will be disjoint and nothing will prevent\n-     the pseudo reg from being given this hard reg.  */\n-\n-  if (ureg < FIRST_PSEUDO_REGISTER)\n-    {\n-      /* Allocate a quantity number so we have a place to put our\n-\t suggestions.  */\n-      if (reg_qty[sreg] == -2)\n-\treg_is_born (setreg, 2 * insn_number);\n-\n-      if (reg_qty[sreg] >= 0)\n-\t{\n-\t  if (may_save_copy\n-\t      && ! TEST_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[sreg]], ureg))\n-\t    {\n-\t      SET_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[sreg]], ureg);\n-\t      qty_phys_num_copy_sugg[reg_qty[sreg]]++;\n-\t    }\n-\t  else if (! TEST_HARD_REG_BIT (qty_phys_sugg[reg_qty[sreg]], ureg))\n-\t    {\n-\t      SET_HARD_REG_BIT (qty_phys_sugg[reg_qty[sreg]], ureg);\n-\t      qty_phys_num_sugg[reg_qty[sreg]]++;\n-\t    }\n-\t}\n-      return 0;\n-    }\n-\n-  /* Similarly for SREG a hard register and UREG a pseudo register.  */\n-\n-  if (sreg < FIRST_PSEUDO_REGISTER)\n-    {\n-      if (may_save_copy\n-\t  && ! TEST_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[ureg]], sreg))\n-\t{\n-\t  SET_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[ureg]], sreg);\n-\t  qty_phys_num_copy_sugg[reg_qty[ureg]]++;\n-\t}\n-      else if (! TEST_HARD_REG_BIT (qty_phys_sugg[reg_qty[ureg]], sreg))\n-\t{\n-\t  SET_HARD_REG_BIT (qty_phys_sugg[reg_qty[ureg]], sreg);\n-\t  qty_phys_num_sugg[reg_qty[ureg]]++;\n-\t}\n-      return 0;\n-    }\n-\n-  /* At this point we know that SREG and UREG are both pseudos.\n-     Do nothing if SREG already has a quantity or is a register that we\n-     don't allocate.  */\n-  if (reg_qty[sreg] >= -1\n-      /* If we are not going to let any regs live across calls,\n-\t don't tie a call-crossing reg to a non-call-crossing reg.  */\n-      || (cfun->has_nonlocal_label\n-\t  && ((REG_N_CALLS_CROSSED (ureg) > 0)\n-\t      != (REG_N_CALLS_CROSSED (sreg) > 0))))\n-    return 0;\n-\n-  /* We don't already know about SREG, so tie it to UREG\n-     if this is the last use of UREG, provided the classes they want\n-     are compatible.  */\n-\n-  if (find_regno_note (insn, REG_DEAD, ureg)\n-      && reg_meets_class_p (sreg, qty[reg_qty[ureg]].min_class))\n-    {\n-      /* Add SREG to UREG's quantity.  */\n-      sqty = reg_qty[ureg];\n-      reg_qty[sreg] = sqty;\n-      reg_offset[sreg] = reg_offset[ureg] + offset;\n-      reg_next_in_qty[sreg] = qty[sqty].first_reg;\n-      qty[sqty].first_reg = sreg;\n-\n-      /* If SREG's reg class is smaller, set qty[SQTY].min_class.  */\n-      update_qty_class (sqty, sreg);\n-\n-      /* Update info about quantity SQTY.  */\n-      qty[sqty].n_calls_crossed += REG_N_CALLS_CROSSED (sreg);\n-      qty[sqty].freq_calls_crossed += REG_FREQ_CALLS_CROSSED (sreg);\n-      qty[sqty].n_throwing_calls_crossed\n-\t+= REG_N_THROWING_CALLS_CROSSED (sreg);\n-      qty[sqty].n_refs += REG_N_REFS (sreg);\n-      qty[sqty].freq += REG_FREQ (sreg);\n-      if (usize < ssize)\n-\t{\n-\t  int i;\n-\n-\t  for (i = qty[sqty].first_reg; i >= 0; i = reg_next_in_qty[i])\n-\t    reg_offset[i] -= offset;\n-\n-\t  qty[sqty].size = ssize;\n-\t  qty[sqty].mode = GET_MODE (setreg);\n-\t}\n-    }\n-  else\n-    return 0;\n-\n-  return 1;\n-}\n-\f\n-/* Return 1 if the preferred class of REG allows it to be tied\n-   to a quantity or register whose class is CLASS.\n-   True if REG's reg class either contains or is contained in CLASS.  */\n-\n-static int\n-reg_meets_class_p (int reg, enum reg_class rclass)\n-{\n-  enum reg_class rclass2 = reg_preferred_class (reg);\n-  return (reg_class_subset_p (rclass2, rclass)\n-\t  || reg_class_subset_p (rclass, rclass2));\n-}\n-\n-/* Update the class of QTYNO assuming that REG is being tied to it.  */\n-\n-static void\n-update_qty_class (int qtyno, int reg)\n-{\n-  enum reg_class rclass = reg_preferred_class (reg);\n-  if (reg_class_subset_p (rclass, qty[qtyno].min_class))\n-    qty[qtyno].min_class = rclass;\n-\n-  rclass = reg_alternate_class (reg);\n-  if (reg_class_subset_p (rclass, qty[qtyno].alternate_class))\n-    qty[qtyno].alternate_class = rclass;\n-}\n-\f\n-/* Handle something which alters the value of an rtx REG.\n-\n-   REG is whatever is set or clobbered.  SETTER is the rtx that\n-   is modifying the register.\n-\n-   If it is not really a register, we do nothing.\n-   The file-global variables `this_insn' and `this_insn_number'\n-   carry info from `block_alloc'.  */\n-\n-static void\n-reg_is_set (rtx reg, const_rtx setter, void *data ATTRIBUTE_UNUSED)\n-{\n-  /* Note that note_stores will only pass us a SUBREG if it is a SUBREG of\n-     a hard register.  These may actually not exist any more.  */\n-\n-  if (GET_CODE (reg) != SUBREG\n-      && !REG_P (reg))\n-    return;\n-\n-  /* Mark this register as being born.  If it is used in a CLOBBER, mark\n-     it as being born halfway between the previous insn and this insn so that\n-     it conflicts with our inputs but not the outputs of the previous insn.  */\n-\n-  reg_is_born (reg, 2 * this_insn_number - (GET_CODE (setter) == CLOBBER));\n-}\n-\f\n-/* Handle beginning of the life of register REG.\n-   BIRTH is the index at which this is happening.  */\n-\n-static void\n-reg_is_born (rtx reg, int birth)\n-{\n-  int regno;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    {\n-      regno = REGNO (SUBREG_REG (reg));\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\tregno = subreg_regno (reg);\n-    }\n-  else\n-    regno = REGNO (reg);\n-\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      mark_life (regno, GET_MODE (reg), 1);\n-\n-      /* If the register was to have been born earlier that the present\n-\t insn, mark it as live where it is actually born.  */\n-      if (birth < 2 * this_insn_number)\n-\tpost_mark_life (regno, GET_MODE (reg), 1, birth, 2 * this_insn_number);\n-    }\n-  else\n-    {\n-      if (reg_qty[regno] == -2)\n-\talloc_qty (regno, GET_MODE (reg), PSEUDO_REGNO_SIZE (regno), birth);\n-\n-      /* If this register has a quantity number, show that it isn't dead.  */\n-      if (reg_qty[regno] >= 0)\n-\tqty[reg_qty[regno]].death = -1;\n-    }\n-}\n-\n-/* Record the death of REG in the current insn.  If OUTPUT_P is nonzero,\n-   REG is an output that is dying (i.e., it is never used), otherwise it\n-   is an input (the normal case).\n-   If OUTPUT_P is 1, then we extend the life past the end of this insn.  */\n-\n-static void\n-wipe_dead_reg (rtx reg, int output_p)\n-{\n-  int regno = REGNO (reg);\n-\n-  /* If this insn has multiple results,\n-     and the dead reg is used in one of the results,\n-     extend its life to after this insn,\n-     so it won't get allocated together with any other result of this insn.\n-\n-     It is unsafe to use !single_set here since it will ignore an unused\n-     output.  Just because an output is unused does not mean the compiler\n-     can assume the side effect will not occur.   Consider if REG appears\n-     in the address of an output and we reload the output.  If we allocate\n-     REG to the same hard register as an unused output we could set the hard\n-     register before the output reload insn.  */\n-  if (GET_CODE (PATTERN (this_insn)) == PARALLEL\n-      && multiple_sets (this_insn))\n-    {\n-      int i;\n-      for (i = XVECLEN (PATTERN (this_insn), 0) - 1; i >= 0; i--)\n-\t{\n-\t  rtx set = XVECEXP (PATTERN (this_insn), 0, i);\n-\t  if (GET_CODE (set) == SET\n-\t      && !REG_P (SET_DEST (set))\n-\t      && !rtx_equal_p (reg, SET_DEST (set))\n-\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\t    output_p = 1;\n-\t}\n-    }\n-\n-  /* If this register is used in an auto-increment address, then extend its\n-     life to after this insn, so that it won't get allocated together with\n-     the result of this insn.  */\n-  if (! output_p && find_regno_note (this_insn, REG_INC, regno))\n-    output_p = 1;\n-\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      mark_life (regno, GET_MODE (reg), 0);\n-\n-      /* If a hard register is dying as an output, mark it as in use at\n-\t the beginning of this insn (the above statement would cause this\n-\t not to happen).  */\n-      if (output_p)\n-\tpost_mark_life (regno, GET_MODE (reg), 1,\n-\t\t\t2 * this_insn_number, 2 * this_insn_number + 1);\n-    }\n-\n-  else if (reg_qty[regno] >= 0)\n-    qty[reg_qty[regno]].death = 2 * this_insn_number + output_p;\n-}\n-\f\n-/* Find a block of SIZE words of hard regs in reg_class CLASS\n-   that can hold something of machine-mode MODE\n-     (but actually we test only the first of the block for holding MODE)\n-   and still free between insn BORN_INDEX and insn DEAD_INDEX,\n-   and return the number of the first of them.\n-   Return -1 if such a block cannot be found.\n-   If QTYNO crosses calls, insist on a register preserved by calls,\n-   unless ACCEPT_CALL_CLOBBERED is nonzero.\n-\n-   If JUST_TRY_SUGGESTED is nonzero, only try to see if the suggested\n-   register is available.  If not, return -1.  */\n-\n-static int\n-find_free_reg (enum reg_class rclass, enum machine_mode mode, int qtyno,\n-\t       int accept_call_clobbered, int just_try_suggested,\n-\t       int born_index, int dead_index, basic_block bb)\n-{\n-  int i, ins;\n-  HARD_REG_SET first_used, used;\n-#ifdef ELIMINABLE_REGS\n-  static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n-#endif\n-\n-  /* Validate our parameters.  */\n-  gcc_assert (born_index >= 0 && born_index <= dead_index);\n-\n-  /* Don't let a pseudo live in a reg across a function call\n-     if we might get a nonlocal goto.  */\n-  if (cfun->has_nonlocal_label\n-      && qty[qtyno].n_calls_crossed > 0)\n-    return -1;\n-\n-  if (accept_call_clobbered)\n-    COPY_HARD_REG_SET (used, call_fixed_reg_set);\n-  else if (qty[qtyno].n_calls_crossed == 0)\n-    COPY_HARD_REG_SET (used, fixed_reg_set);\n-  else\n-    COPY_HARD_REG_SET (used, call_used_reg_set);\n-\n-  if (accept_call_clobbered)\n-    IOR_HARD_REG_SET (used, losing_caller_save_reg_set);\n-\n-  for (ins = born_index; ins < dead_index; ins++)\n-    IOR_HARD_REG_SET (used, regs_live_at[ins]);\n-\n-  IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) rclass]);\n-\n-  /* Don't use the frame pointer reg in local-alloc even if\n-     we may omit the frame pointer, because if we do that and then we\n-     need a frame pointer, reload won't know how to move the pseudo\n-     to another hard reg.  It can move only regs made by global-alloc.\n-\n-     This is true of any register that can be eliminated.  */\n-#ifdef ELIMINABLE_REGS\n-  for (i = 0; i < (int) ARRAY_SIZE (eliminables); i++)\n-    SET_HARD_REG_BIT (used, eliminables[i].from);\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-  /* If FRAME_POINTER_REGNUM is not a real register, then protect the one\n-     that it might be eliminated into.  */\n-  SET_HARD_REG_BIT (used, HARD_FRAME_POINTER_REGNUM);\n-#endif\n-#else\n-  SET_HARD_REG_BIT (used, FRAME_POINTER_REGNUM);\n-#endif\n-\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  cannot_change_mode_set_regs (&used, mode, qty[qtyno].first_reg);\n-#endif\n-\n-  /* Normally, the registers that can be used for the first register in\n-     a multi-register quantity are the same as those that can be used for\n-     subsequent registers.  However, if just trying suggested registers,\n-     restrict our consideration to them.  If there are copy-suggested\n-     register, try them.  Otherwise, try the arithmetic-suggested\n-     registers.  */\n-  COPY_HARD_REG_SET (first_used, used);\n-\n-  if (just_try_suggested)\n-    {\n-      if (qty_phys_num_copy_sugg[qtyno] != 0)\n-\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_copy_sugg[qtyno]);\n-      else\n-\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_sugg[qtyno]);\n-    }\n-\n-  /* If at least one would be suitable, test each hard reg.  */\n-  if (!hard_reg_set_subset_p (reg_class_contents[(int) ALL_REGS], first_used))\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      {\n-#ifdef REG_ALLOC_ORDER\n-\tint regno = reg_alloc_order[i];\n-#else\n-\tint regno = i;\n-#endif\n-\tif (!TEST_HARD_REG_BIT (first_used, regno)\n-\t    && HARD_REGNO_MODE_OK (regno, mode)\n-\t    && (qty[qtyno].n_calls_crossed == 0\n-\t\t|| accept_call_clobbered\n-\t\t|| !HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n-\t  {\n-\t    int j;\n-\t    int size1 = hard_regno_nregs[regno][mode];\n-\t    j = 1;\n-\t    while (j < size1 && !TEST_HARD_REG_BIT (used, regno + j))\n-\t      j++;\n-\t    if (j == size1)\n-\t      {\n-\t\t/* Mark that this register is in use between its birth\n-\t\t   and death insns.  */\n-\t\tpost_mark_life (regno, mode, 1, born_index, dead_index);\n-\t\treturn regno;\n-\t      }\n-#ifndef REG_ALLOC_ORDER\n-\t    /* Skip starting points we know will lose.  */\n-\t    i += j;\n-#endif\n-\t  }\n-      }\n-\n-  /* If we are just trying suggested register, we have just tried copy-\n-     suggested registers, and there are arithmetic-suggested registers,\n-     try them.  */\n-\n-  /* If it would be profitable to allocate a call-clobbered register\n-     and save and restore it around calls, do that.  */\n-  if (just_try_suggested && qty_phys_num_copy_sugg[qtyno] != 0\n-      && qty_phys_num_sugg[qtyno] != 0)\n-    {\n-      /* Don't try the copy-suggested regs again.  */\n-      qty_phys_num_copy_sugg[qtyno] = 0;\n-      return find_free_reg (rclass, mode, qtyno, accept_call_clobbered, 1,\n-\t\t\t    born_index, dead_index, bb);\n-    }\n-\n-  /* We need not check to see if the current function has nonlocal\n-     labels because we don't put any pseudos that are live over calls in\n-     registers in that case.  Avoid putting pseudos crossing calls that\n-     might throw into call used registers.  */\n-\n-  if (! accept_call_clobbered\n-      && flag_caller_saves\n-      && ! just_try_suggested\n-      && qty[qtyno].n_calls_crossed != 0\n-      && qty[qtyno].n_throwing_calls_crossed == 0\n-      && CALLER_SAVE_PROFITABLE (optimize_bb_for_size_p (bb) ? qty[qtyno].n_refs\n-      \t\t\t\t : qty[qtyno].freq,\n-\t\t\t\t optimize_bb_for_size_p (bb) ? qty[qtyno].n_calls_crossed\n-\t\t\t\t : qty[qtyno].freq_calls_crossed))\n-    {\n-      i = find_free_reg (rclass, mode, qtyno, 1, 0, born_index, dead_index, bb);\n-      if (i >= 0)\n-\tcaller_save_needed = 1;\n-      return i;\n-    }\n-  return -1;\n-}\n-\f\n-/* Mark that REGNO with machine-mode MODE is live starting from the current\n-   insn (if LIFE is nonzero) or dead starting at the current insn (if LIFE\n-   is zero).  */\n-\n-static void\n-mark_life (int regno, enum machine_mode mode, int life)\n-{\n-  if (life)\n-    add_to_hard_reg_set (&regs_live, mode, regno);\n-  else\n-    remove_from_hard_reg_set (&regs_live, mode, regno);\n-}\n-\n-/* Mark register number REGNO (with machine-mode MODE) as live (if LIFE\n-   is nonzero) or dead (if LIFE is zero) from insn number BIRTH (inclusive)\n-   to insn number DEATH (exclusive).  */\n-\n-static void\n-post_mark_life (int regno, enum machine_mode mode, int life, int birth,\n-\t\tint death)\n-{\n-  HARD_REG_SET this_reg;\n-\n-  CLEAR_HARD_REG_SET (this_reg);\n-  add_to_hard_reg_set (&this_reg, mode, regno);\n-\n-  if (life)\n-    while (birth < death)\n-      {\n-\tIOR_HARD_REG_SET (regs_live_at[birth], this_reg);\n-\tbirth++;\n-      }\n-  else\n-    while (birth < death)\n-      {\n-\tAND_COMPL_HARD_REG_SET (regs_live_at[birth], this_reg);\n-\tbirth++;\n-      }\n-}\n-\f\n-/* Return the number of alternatives for which the constraint string P\n-   indicates that the operand must be equal to operand 0 and that no register\n-   is acceptable.  */\n-\n-static int\n-requires_inout (const char *p)\n-{\n-  char c;\n-  int found_zero = 0;\n-  int reg_allowed = 0;\n-  int num_matching_alts = 0;\n-  int len;\n-\n-  for ( ; (c = *p); p += len)\n-    {\n-      len = CONSTRAINT_LEN (c, p);\n-      switch (c)\n-\t{\n-\tcase '=':  case '+':  case '?':\n-\tcase '#':  case '&':  case '!':\n-\tcase '*':  case '%':\n-\tcase 'm':  case '<':  case '>':  case 'V':  case 'o':\n-\tcase 'E':  case 'F':  case 'G':  case 'H':\n-\tcase 's':  case 'i':  case 'n':\n-\tcase 'I':  case 'J':  case 'K':  case 'L':\n-\tcase 'M':  case 'N':  case 'O':  case 'P':\n-\tcase 'X':\n-\t  /* These don't say anything we care about.  */\n-\t  break;\n-\n-\tcase ',':\n-\t  if (found_zero && ! reg_allowed)\n-\t    num_matching_alts++;\n-\n-\t  found_zero = reg_allowed = 0;\n-\t  break;\n-\n-\tcase '0':\n-\t  found_zero = 1;\n-\t  break;\n-\n-\tcase '1':  case '2':  case '3':  case '4': case '5':\n-\tcase '6':  case '7':  case '8':  case '9':\n-\t  /* Skip the balance of the matching constraint.  */\n-\t  do\n-\t    p++;\n-\t  while (ISDIGIT (*p));\n-\t  len = 0;\n-\t  break;\n-\n-\tdefault:\n-\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS\n-\t      && !EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t    break;\n-\t  /* Fall through.  */\n-\tcase 'p':\n-\tcase 'g': case 'r':\n-\t  reg_allowed = 1;\n-\t  break;\n-\t}\n-    }\n-\n-  if (found_zero && ! reg_allowed)\n-    num_matching_alts++;\n-\n-  return num_matching_alts;\n-}\n-\f\n-void\n-dump_local_alloc (FILE *file)\n-{\n-  int i;\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] != -1)\n-      fprintf (file, \";; Register %d in %d.\\n\", i, reg_renumber[i]);\n-}\n-\n-#ifdef STACK_REGS\n-static void\n-find_stack_regs (void)\n-{\n-  bitmap stack_regs = BITMAP_ALLOC (NULL);\n-  int i;\n-  HARD_REG_SET stack_hard_regs, used;\n-  basic_block bb;\n-  \n-  /* Any register that MAY be allocated to a register stack (like the\n-     387) is treated poorly.  Each such register is marked as being\n-     live everywhere.  This keeps the register allocator and the\n-     subsequent passes from doing anything useful with these values.\n-\n-     FIXME: This seems like an incredibly poor idea.  */\n-\n-  CLEAR_HARD_REG_SET (stack_hard_regs);\n-  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-    SET_HARD_REG_BIT (stack_hard_regs, i);\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    {\n-      COPY_HARD_REG_SET (used, reg_class_contents[reg_preferred_class (i)]);\n-      IOR_HARD_REG_SET (used, reg_class_contents[reg_alternate_class (i)]);\n-      AND_HARD_REG_SET (used, stack_hard_regs);\n-      if (!hard_reg_set_empty_p (used))\n-\tbitmap_set_bit (stack_regs, i);\n-    }\n-\n-  if (dump_file)\n-    bitmap_print (dump_file, stack_regs, \"stack regs:\", \"\\n\");\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      bitmap_ior_into (DF_LIVE_IN (bb), stack_regs);\n-      bitmap_and_into (DF_LIVE_IN (bb), DF_LR_IN (bb));\n-      bitmap_ior_into (DF_LIVE_OUT (bb), stack_regs);\n-      bitmap_and_into (DF_LIVE_OUT (bb), DF_LR_OUT (bb));\n-    }\n-  BITMAP_FREE (stack_regs);\n-}\n-#endif\n-\n-static bool\n-gate_handle_local_alloc (void)\n-{\n-  return ! flag_ira;\n-}\n-\n-/* Run old register allocator.  Return TRUE if we must exit\n-   rest_of_compilation upon return.  */\n-static unsigned int\n-rest_of_handle_local_alloc (void)\n-{\n-  int rebuild_notes;\n-  int max_regno = max_reg_num ();\n-\n-  df_note_add_problem ();\n-\n-  if (optimize == 1)\n-    {\n-      df_live_add_problem ();\n-      df_live_set_all_dirty ();\n-    }\n-#ifdef ENABLE_CHECKING\n-  df->changeable_flags |= DF_VERIFY_SCHEDULED;\n-#endif\n-  df_analyze ();\n-#ifdef STACK_REGS\n-  if (optimize)\n-    find_stack_regs ();\n-#endif\n-  regstat_init_n_sets_and_refs ();\n-  regstat_compute_ri ();\n-\n-  /* If we are not optimizing, then this is the only place before\n-     register allocation where dataflow is done.  And that is needed\n-     to generate these warnings.  */\n-  if (warn_clobbered)\n-    generate_setjmp_warnings ();\n-\n-  /* Determine if the current function is a leaf before running reload\n-     since this can impact optimizations done by the prologue and\n-     epilogue thus changing register elimination offsets.  */\n-  current_function_is_leaf = leaf_function_p ();\n-\n-  /* And the reg_equiv_memory_loc array.  */\n-  VEC_safe_grow (rtx, gc, reg_equiv_memory_loc_vec, max_regno);\n-  memset (VEC_address (rtx, reg_equiv_memory_loc_vec), 0,\n-\t  sizeof (rtx) * max_regno);\n-  reg_equiv_memory_loc = VEC_address (rtx, reg_equiv_memory_loc_vec);\n-\n-  allocate_initial_values (reg_equiv_memory_loc);\n-\n-  regclass (get_insns (), max_regno);\n-  rebuild_notes = local_alloc ();\n-\n-  /* Local allocation may have turned an indirect jump into a direct\n-     jump.  If so, we must rebuild the JUMP_LABEL fields of jumping\n-     instructions.  */\n-  if (rebuild_notes)\n-    {\n-      timevar_push (TV_JUMP);\n-\n-      rebuild_jump_labels (get_insns ());\n-      purge_all_dead_edges ();\n-      timevar_pop (TV_JUMP);\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      timevar_push (TV_DUMP);\n-      dump_flow_info (dump_file, dump_flags);\n-      dump_local_alloc (dump_file);\n-      timevar_pop (TV_DUMP);\n-    }\n-  return 0;\n-}\n-\n-struct rtl_opt_pass pass_local_alloc =\n-{\n- {\n-  RTL_PASS,\n-  \"lreg\",                               /* name */\n-  gate_handle_local_alloc,              /* gate */\n-  rest_of_handle_local_alloc,           /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_LOCAL_ALLOC,                       /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func |\n-  TODO_ggc_collect                      /* todo_flags_finish */\n- }\n-};\n-"}, {"sha": "cccb80b403fed8a82732386c853c826b98f45622", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -870,7 +870,6 @@ decode_options (unsigned int argc, const char **argv)\n \t}\n     }\n   \n-  flag_ira = 1;\n   /* Use priority coloring if cover classes is not defined for the\n      target.  */\n   if (targetm.ira_cover_classes == NULL)\n@@ -1098,7 +1097,7 @@ decode_options (unsigned int argc, const char **argv)\n   if (!flag_sel_sched_pipelining)\n     flag_sel_sched_pipelining_outer_loops = 0;\n \n-  if (flag_ira && !targetm.ira_cover_classes\n+  if (!targetm.ira_cover_classes\n       && flag_ira_algorithm == IRA_ALGORITHM_CB)\n     {\n       inform (input_location,"}, {"sha": "6982c28f5ba49aeb5e8d90751217398f608ee52b", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -749,7 +749,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_cse2);\n       NEXT_PASS (pass_rtl_dse1);\n       NEXT_PASS (pass_rtl_fwprop_addr);\n-      NEXT_PASS (pass_regclass_init);\n+      NEXT_PASS (pass_reginfo_init);\n       NEXT_PASS (pass_inc_dec);\n       NEXT_PASS (pass_initialize_regs);\n       NEXT_PASS (pass_outof_cfg_layout_mode);\n@@ -768,8 +768,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_sms);\n       NEXT_PASS (pass_sched);\n       NEXT_PASS (pass_subregs_of_mode_init);\n-      NEXT_PASS (pass_local_alloc);\n-      NEXT_PASS (pass_global_alloc);\n       NEXT_PASS (pass_ira);\n       NEXT_PASS (pass_subregs_of_mode_finish);\n       NEXT_PASS (pass_postreload);"}, {"sha": "eb732861442452c4c9c18b916c2339da47e88b5f", "filename": "gcc/ra-conflict.c", "status": "removed", "additions": 0, "deletions": 1241, "changes": 1241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b251a0371e71bce271656eb7d069851cbd7fcf/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b251a0371e71bce271656eb7d069851cbd7fcf/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=00b251a0371e71bce271656eb7d069851cbd7fcf", "patch": "@@ -1,1241 +0,0 @@\n-/* Allocate registers for pseudo-registers that span basic blocks.\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n-   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"machmode.h\"\n-#include \"hard-reg-set.h\"\n-#include \"rtl.h\"\n-#include \"tm_p.h\"\n-#include \"flags.h\"\n-#include \"regs.h\"\n-#include \"function.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"reload.h\"\n-#include \"output.h\"\n-#include \"toplev.h\"\n-#include \"tree-pass.h\"\n-#include \"timevar.h\"\n-#include \"df.h\"\n-#include \"vecprim.h\"\n-#include \"ra.h\"\n-#include \"sbitmap.h\"\n-#include \"sparseset.h\"\n-\n-/* Externs defined in regs.h.  */\n-\n-int max_allocno;\n-struct allocno *allocno;\n-HOST_WIDEST_FAST_INT *conflicts;\n-int *reg_allocno;\n-HOST_WIDE_INT *partial_bitnum;\n-HOST_WIDE_INT max_bitnum;\n-alloc_pool adjacency_pool;\n-adjacency_t **adjacency;\n-\n-typedef df_ref df_ref_t;\n-DEF_VEC_P(df_ref_t);\n-DEF_VEC_ALLOC_P(df_ref_t,heap);\n-\n-/* Macros to determine the bit number within the triangular bit matrix for\n-   the two allocnos Low and HIGH, with LOW strictly less than HIGH.  */\n-\n-#define CONFLICT_BITNUM(I, J) \\\n-  (((I) < (J)) ? (partial_bitnum[I] + (J)) : (partial_bitnum[J] + (I)))\n-\n-#define CONFLICT_BITNUM_FAST(I, I_PARTIAL_BITNUM, J) \\\n-  (((I) < (J)) ? ((I_PARTIAL_BITNUM) + (J)) : (partial_bitnum[J] + (I)))\n-\n-bool\n-conflict_p (int allocno1, int allocno2)\n-{\n-  HOST_WIDE_INT bitnum;\n-  HOST_WIDEST_FAST_INT word, mask;\n-\n-#ifdef ENABLE_CHECKING\n-  int blk1, blk2;\n-\n-  gcc_assert (allocno1 >= 0 && allocno1 < max_allocno);\n-  gcc_assert (allocno2 >= 0 && allocno2 < max_allocno);\n-\n-  blk1 = regno_basic_block (allocno[allocno1].reg);\n-  blk2 = regno_basic_block (allocno[allocno2].reg);\n-  gcc_assert (blk1 == 0 || blk2 == 0 || blk1 == blk2);\n-#endif\n-\n-  if (allocno1 == allocno2)\n-    /* By definition, an allocno does not conflict with itself.  */\n-    return 0;\n-\n-  bitnum = CONFLICT_BITNUM (allocno1, allocno2);\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (bitnum >= 0 && bitnum < max_bitnum);\n-#endif\n-\n-  word = conflicts[bitnum / HOST_BITS_PER_WIDEST_FAST_INT];\n-  mask = (HOST_WIDEST_FAST_INT) 1 << (bitnum % HOST_BITS_PER_WIDEST_FAST_INT);\n-  return (word & mask) != 0;\n-}\n-\n-/* Add conflict edges between ALLOCNO1 and ALLOCNO2.  */\n-\n-static void\n-set_conflict (int allocno1, int allocno2)\n-{\n-  HOST_WIDE_INT bitnum, index;\n-  HOST_WIDEST_FAST_INT word, mask;\n-\n-#ifdef ENABLE_CHECKING\n-  int blk1, blk2;\n-\n-  gcc_assert (allocno1 >= 0 && allocno1 < max_allocno);\n-  gcc_assert (allocno2 >= 0 && allocno2 < max_allocno);\n-\n-  blk1 = regno_basic_block (allocno[allocno1].reg);\n-  blk2 = regno_basic_block (allocno[allocno2].reg);\n-  gcc_assert (blk1 == 0 || blk2 == 0 || blk1 == blk2);\n-#endif\n-\n-  /* By definition, an allocno does not conflict with itself.  */\n-  if (allocno1 == allocno2)\n-    return;\n-\n-  bitnum = CONFLICT_BITNUM (allocno1, allocno2);\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (bitnum >= 0 && bitnum < max_bitnum);\n-#endif\n-\n-  index = bitnum / HOST_BITS_PER_WIDEST_FAST_INT;\n-  word = conflicts[index];\n-  mask = (HOST_WIDEST_FAST_INT) 1 << (bitnum % HOST_BITS_PER_WIDEST_FAST_INT);\n-\n-  if ((word & mask) == 0)\n-    {\n-      conflicts[index] = word | mask;\n-      add_neighbor (allocno1, allocno2);\n-      add_neighbor (allocno2, allocno1);\n-    }\n-}\n-\n-/* Add conflict edges between ALLOCNO1 and all allocnos currently live.  */\n-\n-static void\n-set_conflicts (int allocno1, sparseset live)\n-{\n-  int i;\n-  HOST_WIDE_INT bitnum, index;\n-  HOST_WIDEST_FAST_INT word, mask;\n-  HOST_WIDE_INT partial_bitnum_allocno1;\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (allocno1 >= 0 && allocno1 < max_allocno);\n-#endif\n-\n-  partial_bitnum_allocno1 = partial_bitnum[allocno1];\n-\n-  EXECUTE_IF_SET_IN_SPARSESET (live, i)\n-  {\n-    /* By definition, an allocno does not conflict with itself.  */\n-    if (allocno1 == i)\n-      continue;\n-\n-#ifdef ENABLE_CHECKING\n-    gcc_assert (i >= 0 && i < max_allocno);\n-#endif\n-\n-    bitnum = CONFLICT_BITNUM_FAST (allocno1, partial_bitnum_allocno1, i);\n-\n-#ifdef ENABLE_CHECKING\n-    gcc_assert (bitnum >= 0 && bitnum < max_bitnum);\n-#endif\n-\n-    index = bitnum / HOST_BITS_PER_WIDEST_FAST_INT;\n-    word = conflicts[index];\n-    mask = (HOST_WIDEST_FAST_INT) 1 << (bitnum % HOST_BITS_PER_WIDEST_FAST_INT);\n-\n-    if ((word & mask) == 0)\n-      {\n-\tconflicts[index] = word | mask;\n-\tadd_neighbor (allocno1, i);\n-\tadd_neighbor (i, allocno1);\n-      }\n-  }\n-}\n-\n-\n-/* Add a conflict between R1 and R2.  */\n-\n-static void\n-record_one_conflict_between_regnos (enum machine_mode mode1, int r1, \n-\t\t\t\t    enum machine_mode mode2, int r2)\n-{\n-  int allocno1 = reg_allocno[r1];\n-  int allocno2 = reg_allocno[r2];\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"    rocbr adding %d<=>%d\\n\", r1, r2);\n-\n-  if (allocno1 >= 0 && allocno2 >= 0)\n-    set_conflict (allocno1, allocno2);\n-  else if (allocno1 >= 0)\n-    {\n-      if (r2 < FIRST_PSEUDO_REGISTER)\n-\tadd_to_hard_reg_set (&allocno[allocno1].hard_reg_conflicts, mode2, r2);\n-    }\n-  else if (allocno2 >= 0)\n-    {\n-      if (r1 < FIRST_PSEUDO_REGISTER)\n-        add_to_hard_reg_set (&allocno[allocno2].hard_reg_conflicts, mode1, r1);\n-    }\n-\n-  /* Now, recursively handle the reg_renumber cases.  */\n-  if (reg_renumber[r1] >= 0)\n-    record_one_conflict_between_regnos (mode1, reg_renumber[r1], mode2, r2);\n-\n-  if (reg_renumber[r2] >= 0)\n-    record_one_conflict_between_regnos (mode1, r1, mode2, reg_renumber[r2]);\n-}\n-\n-\n-/* Record a conflict between register REGNO and everything currently\n-   live.  REGNO must not be a pseudo reg that was allocated by\n-   local_alloc; such numbers must be translated through reg_renumber\n-   before calling here.  */\n-\n-static void\n-record_one_conflict (sparseset allocnos_live, \n-\t\t     HARD_REG_SET *hard_regs_live, int regno)\n-{\n-  int i;\n-\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    /* When a hard register becomes live, record conflicts with live\n-       pseudo regs.  */\n-    EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-      {\n-\tSET_HARD_REG_BIT (allocno[i].hard_reg_conflicts, regno);\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"  roc adding %d<=>%d\\n\", allocno[i].reg, regno);\n-      }\n-  else\n-    /* When a pseudo-register becomes live, record conflicts first\n-       with hard regs, then with other pseudo regs.  */\n-    {\n-      int ialloc = reg_allocno[regno];\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"  roc adding %d<=>(\", regno);\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (TEST_HARD_REG_BIT (*hard_regs_live, i) \n-\t\t&& !TEST_HARD_REG_BIT (allocno[ialloc].hard_reg_conflicts, i))\n-\t      fprintf (dump_file, \"%d \", i);\n-\t  \n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t    {\n-\t      if (!conflict_p (ialloc, i))\n-\t\tfprintf (dump_file, \"%d \", allocno[i].reg);\n-\t    }\n-\t  fprintf (dump_file, \")\\n\");\n-\t}\n-\n-      IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, *hard_regs_live);\n-      set_conflicts (ialloc, allocnos_live);\n-    }\n-}\n-\n-\n-/* Handle the case where REG is set by the insn being scanned, during\n-   the backward scan to accumulate conflicts.  Record a conflict with\n-   all other registers already live.\n-\n-   REG might actually be something other than a register; if so, we do\n-   nothing.  */\n-\n-static void\n-mark_reg_store (sparseset allocnos_live, \n-\t\tHARD_REG_SET *hard_regs_live, \n-\t\tdf_ref ref)\n-{\n-  rtx reg = DF_REF_REG (ref);\n-  unsigned int regno = DF_REF_REGNO (ref);\n-  enum machine_mode mode = GET_MODE (reg);\n-\n-  /* Either this is one of the max_allocno pseudo regs not allocated,\n-     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER && reg_allocno[regno] >= 0)\n-    record_one_conflict (allocnos_live, hard_regs_live, regno);\n-\n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno];\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n-    {\n-      unsigned int start = regno;\n-      unsigned int last = end_hard_regno (mode, regno);\n-      if ((GET_CODE (reg) == SUBREG) && !DF_REF_FLAGS_IS_SET (ref, DF_REF_ZERO_EXTRACT))\n-\t{\n-\t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n-\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n-\t  last = start + subreg_nregs_with_regno (regno, reg);\n-\t}\n-\n-      regno = start;\n-      while (regno < last)\n-\trecord_one_conflict (allocnos_live, hard_regs_live, regno++);\n-    }\n-}\n-\n-\n-/* Return true if REGNO with MODE can be assigned to a register in\n-   CL.  */\n-\n-static bool\n-may_overlap_class_p (enum machine_mode mode, unsigned int regno, \n-\t\t     enum reg_class rc)\n-{\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      enum reg_class pref_class = reg_preferred_class (regno);\n-      enum reg_class alt_class = reg_alternate_class (regno);\n-      return (reg_classes_intersect_p (rc, pref_class)\n-\t      || reg_classes_intersect_p (rc, alt_class));\n-    }\n-  else\n-    return in_hard_reg_set_p (reg_class_contents[rc], mode, regno);\n-}\n-\n-\n-/* SRC is an input operand to an instruction in which register DEST is\n-   an output operand.  SRC may be bound to a member of class SRC_CLASS\n-   and DEST may be bound to an earlyclobbered register that overlaps\n-   SRC_CLASS.  If SRC is a register that might be allocated a member\n-   of SRC_CLASS, add a conflict between it and DEST.  */\n-\n-static void\n-add_conflicts_for_earlyclobber (rtx dest, enum reg_class src_class, rtx src)\n-{\n-  if (GET_CODE (src) == SUBREG)\n-    src = SUBREG_REG (src);\n-  if (REG_P (src)\n-      && may_overlap_class_p (GET_MODE (src), REGNO (src), src_class))\n-    record_one_conflict_between_regnos (GET_MODE (src), REGNO (src),\n-                                        GET_MODE (dest), REGNO (dest));\n-}\n-\n-\n-/* Look at the defs in INSN and determine if any of them are marked as\n-   early clobber.  If they are marked as early clobber, add a conflict\n-   between any input operand that could be allocated to the same\n-   register.  */\n-\n-static void\n-set_conflicts_for_earlyclobber (rtx insn)\n-{\n-  int alt;\n-  int def;\n-  int use;\n-\n-  extract_insn (insn);\n-  preprocess_constraints ();\n-\n-  if (dump_file) \n-    fprintf (dump_file, \"  starting early clobber conflicts.\\n\");\n-\n-  for (alt = 0; alt < recog_data.n_alternatives; alt++)\n-    for (def = 0; def < recog_data.n_operands; def++)\n-      if ((recog_op_alt[def][alt].earlyclobber)\n-\t  && (recog_op_alt[def][alt].cl != NO_REGS))\n-\t{\n-\t  rtx dreg = recog_data.operand[def];\n-\t  enum machine_mode dmode = recog_data.operand_mode[def];\n-\t  if (GET_CODE (dreg) == SUBREG)\n-\t    dreg = SUBREG_REG (dreg);\n-\t  if (REG_P (dreg)\n-\t      &&  may_overlap_class_p (dmode, REGNO (dreg), recog_op_alt[def][alt].cl))\n-\n-\t    for (use = 0; use < recog_data.n_operands; use++)\n-\t      if (use != def\n-\t\t  && recog_data.operand_type[use] != OP_OUT\n-\t\t  && reg_classes_intersect_p (recog_op_alt[def][alt].cl,\n-\t\t\t\t\t      recog_op_alt[use][alt].cl))\n-\t\t{\n-\t\t  add_conflicts_for_earlyclobber (dreg,\n-\t\t\t\t\t\t  recog_op_alt[use][alt].cl,\n-\t\t\t\t\t\t  recog_data.operand[use]);\n-\t\t  /*  Reload may end up swapping commutative operands,\n-\t\t      so you have to take both orderings into account.\n-\t\t      The constraints for the two operands can be\n-\t\t      completely different.  (Indeed, if the\n-\t\t      constraints for the two operands are the same\n-\t\t      for all alternatives, there's no point marking\n-\t\t      them as commutative.)  */\n-\t\t  if (use < recog_data.n_operands + 1\n-\t\t      && recog_data.constraints[use][0] == '%')\n-\t\t    add_conflicts_for_earlyclobber (dreg,\n-\t\t\t\t\t\t    recog_op_alt[use][alt].cl,\n-\t\t\t\t\t\t    recog_data.operand[use + 1]);\n-\t\t}\n-\t}\n-}\n-\n-\n-/* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] using\n-   REG to the number of nregs, and INIT_VALUE to get the\n-   initialization.  ALLOCNUM need not be the regno of REG.  */\n-\n-void\n-ra_init_live_subregs (bool init_value, \n-\t\t      sbitmap *live_subregs, \n-\t\t      int *live_subregs_used,\n-\t\t      int allocnum, \n-\t\t      rtx reg)\n-{\n-  unsigned int regno = REGNO (SUBREG_REG (reg));\n-  int size = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n-\n-  gcc_assert (size > 0);\n-\n-  /* Been there, done that.  */\n-  if (live_subregs_used[allocnum])\n-    return;\n-\n-  /* Create a new one with zeros.  */\n-  if (live_subregs[allocnum] == NULL)\n-    live_subregs[allocnum] = sbitmap_alloc (size);\n-\n-  /* If the entire reg was live before blasting into subregs, we need\n-     to init all of the subregs to ones else init to 0.  */\n-  if (init_value)\n-    sbitmap_ones (live_subregs[allocnum]);\n-  else \n-    sbitmap_zero (live_subregs[allocnum]);\n-\n-  /* Set the number of bits that we really want.  */\n-  live_subregs_used[allocnum] = size;\n-}\n-\n-\n-/* Set REG to be not live in the sets ALLOCNOS_LIVE, LIVE_SUBREGS,\n-   HARD_REGS_LIVE.  DEF is the definition of the register.  */\n-\n-inline static void\n-clear_reg_in_live (sparseset allocnos_live,\n-\t\t   sbitmap *live_subregs, \n-\t\t   int *live_subregs_used,\n-\t\t   HARD_REG_SET *hard_regs_live, \n-\t\t   rtx reg, df_ref def)\n-{\n-  unsigned int regno = (GET_CODE (reg) == SUBREG) \n-    ? REGNO (SUBREG_REG (reg)): REGNO (reg);\n-  int allocnum = reg_allocno[regno];\n-\n-  if (allocnum >= 0)\n-    {\n-      if (GET_CODE (reg) == SUBREG\n-\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n-\t{\n-\t  unsigned int start = SUBREG_BYTE (reg);\n-\t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n-\n-\t  ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n-\t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n-\n-\t  if (!DF_REF_FLAGS_IS_SET (def, DF_REF_STRICT_LOW_PART))\n-\t    {\n-\t      /* Expand the range to cover entire words.\n-\t\t Bytes added here are \"don't care\".  */\n-\t      start = start / UNITS_PER_WORD * UNITS_PER_WORD;\n-\t      last = ((last + UNITS_PER_WORD - 1)\n-\t\t      / UNITS_PER_WORD * UNITS_PER_WORD);\n-\t    }\n-\n-\t  /* Ignore the paradoxical bits.  */\n-\t  if ((int)last > live_subregs_used[allocnum])\n-\t    last = live_subregs_used[allocnum];\n-\n-\t  while (start < last)\n-\t    {\n-\t      RESET_BIT (live_subregs[allocnum], start);\n-\t      start++;\n-\t    }\n-\n-\t  if (sbitmap_empty_p (live_subregs[allocnum]))\n-\t    {\n-\t      live_subregs_used[allocnum] = 0;\n-\t      sparseset_clear_bit (allocnos_live, allocnum);\n-\t    }\n-\t  else\n-\t    /* Set the allocnos live here because that bit has to be\n-\t       true to get us to look at the live_subregs fields.  */\n-\t    sparseset_set_bit (allocnos_live, allocnum);\n-\t}\n-      else\n-\t{\n-\t  /* Resetting the live_subregs_used is effectively saying do not use the \n-\t     subregs because we are writing the whole pseudo.  */\n-\t  live_subregs_used[allocnum] = 0;\n-\t  sparseset_clear_bit (allocnos_live, allocnum);\n-\t}\n-    }\n-\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (! fixed_regs[regno])\n-    {\n-      unsigned int start = regno;\n-      if (GET_CODE (reg) == SUBREG\n-\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n-\t{\n-\t  unsigned int last;\n-\t  start += SUBREG_BYTE (reg);\n-\t  last = start + subreg_nregs_with_regno (regno, reg);\n-\t  regno = start;\n-\n-\t  while (regno < last)\n-\t    {\n-\t      CLEAR_HARD_REG_BIT (*hard_regs_live, regno);\n-\t      regno++;\n-\t    }\n-\t}\n-      else\n-\tremove_from_hard_reg_set (hard_regs_live, GET_MODE (reg), regno);\n-    }\n-}\n-\n-\n-\n-/* Set REG to be live in the sets ALLOCNOS_LIVE, LIVE_SUBREGS,\n-   HARD_REGS_LIVE.  If EXTRACT is false, assume that the entire reg is\n-   set live even if REG is a subreg.  */\n-\n-inline static void\n-set_reg_in_live (sparseset allocnos_live, \n-\t\t sbitmap *live_subregs, \n-\t\t int *live_subregs_used,\n-\t\t HARD_REG_SET *hard_regs_live, \n-\t\t rtx reg,\n-\t\t bool extract)\n-{\n-  unsigned int regno = (GET_CODE (reg) == SUBREG) \n-    ? REGNO (SUBREG_REG (reg)): REGNO (reg);\n-  int allocnum = reg_allocno[regno];\n-\n-  if (allocnum >= 0)\n-    {\n-      if ((GET_CODE (reg) == SUBREG) && !extract)\n-\t{\n-\t  unsigned int start = SUBREG_BYTE (reg);\n-\t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n-\n-\t  ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n-\t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n-\t  \n-\t  /* Ignore the paradoxical bits.  */\n-\t  if ((int)last > live_subregs_used[allocnum])\n-\t    last = live_subregs_used[allocnum];\n-\n-\t  while (start < last)\n-\t    {\n-\t      SET_BIT (live_subregs[allocnum], start);\n-\t      start++;\n-\t    }\n-\t}\n-      else\n-\t/* Resetting the live_subregs_used is effectively saying do not use the \n-\t   subregs because we are writing the whole pseudo.  */\n-\t  live_subregs_used[allocnum] = 0;\n-     \n-      sparseset_set_bit (allocnos_live, allocnum);\n-    }\n-      \n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  if (! fixed_regs[regno])\n-    {\n-      if ((GET_CODE (reg) == SUBREG) && !extract)\n-\t{\n-\t  unsigned int start = regno;\n-\t  unsigned int last;\n-\n-\t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n-\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n-\t  last = start + subreg_nregs_with_regno (regno, reg);\n-\t  regno = start;\n-\n-\t  while (regno < last)\n-\t    {\n-\t      SET_HARD_REG_BIT (*hard_regs_live, regno);\n-\t      regno++;\n-\t    }\n-\t}\n-      else\n-\tadd_to_hard_reg_set (hard_regs_live, GET_MODE (reg), regno);\n-    }\n-}\n-\n-\n-/* Add hard reg conflicts to RENUMBERS_LIVE assuming that pseudo in\n-   allocno[ALLOCNUM] is allocated to a set of hard regs starting at\n-   RENUMBER.\n-\n-   We are smart about the case where only subregs of REG have been\n-   set, as indicated by LIVE_SUBREGS[ALLOCNUM] and\n-   LIVE_SUBREGS_USED[ALLOCNUM].  See global_conflicts for description\n-   of LIVE_SUBREGS and LIVE_SUBREGS_USED.  */\n-\n-inline static void\n-set_renumbers_live (HARD_REG_SET *renumbers_live,   \n-\t\t    sbitmap *live_subregs, \n-\t\t    int *live_subregs_used,\n-\t\t    int allocnum, int renumber)\n-{\n-  /* The width of the pseudo.  */\n-  int nbytes = live_subregs_used[allocnum];\n-  int regno = allocno[allocnum].reg;\n-  enum machine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"  set_renumbers_live %d->%d \", \n-\t     regno, renumber);\n-\n-  if (nbytes > 0)\n-    {\n-      int i;\n-      sbitmap live_subs = live_subregs[allocnum];\n-\n-      /* First figure out how many hard regs we are considering using.  */\n-      int target_nregs = hard_regno_nregs[renumber][mode];\n-\n-      /* Now figure out the number of bytes per hard reg.  Note that\n-\t this may be different that what would be obtained by looking\n-\t at the mode in the pseudo.  For instance, a complex number\n-\t made up of 2 32-bit parts gets mapped to 2 hard regs, even if\n-\t the hardregs are 64-bit floating point values.  */\n-      int target_width = nbytes / target_nregs;\n-      \n-      if (dump_file)\n-\tfprintf (dump_file, \"target_nregs=%d target_width=%d nbytes=%d\", \n-\t\t target_nregs, target_width, nbytes);\n-\n-      for (i = 0; i < target_nregs; i++)\n-\t{\n-\t  int j;\n-\t  bool set = false;\n-\t  for (j = 0; j < target_width; j++)\n-\t    {\n-\t      int reg_start = i * target_width;\n-\t      if (reg_start + j >= nbytes)\n-\t\tbreak;\n-\t      set |= TEST_BIT (live_subs, reg_start + j);\n-\t    }\n-\n-\t  if (set)\n-\t    SET_HARD_REG_BIT (*renumbers_live, renumber + i);\n-\t}\n-    }\n-  else\n-    add_to_hard_reg_set (renumbers_live, mode, renumber);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n\");\n-}\n-\n-/* Dump out a REF with its reg_renumber range to FILE using\n-   PREFIX.  */\n-\n-static void\n-dump_ref (FILE *file, \n-\t  const char * prefix, \n-\t  const char * suffix, \n-\t  rtx reg,\n-\t  unsigned int regno,\n-\t  sbitmap *live_subregs, \n-\t  int *live_subregs_used\n-)\n-{\n-  int allocnum = reg_allocno[regno];\n-\n-  fprintf (file, \"%s %d\", prefix, regno);\n-  if (allocnum >= 0 \n-      && live_subregs_used[allocnum] > 0)\n-    {\n-      int j;\n-      char s = '[';\n-      \n-      for (j = 0; j < live_subregs_used[allocnum]; j++)\n-\tif (TEST_BIT (live_subregs[allocnum], j))\n-\t  {\n-\t    fprintf (dump_file, \"%c%d\", s, j);\n-\t    s = ',';\n-\t  }\n-      fprintf (dump_file, \"]\");\n-    }\n-\n-  if (reg_renumber[regno] >= 0)\n-    {\n-      enum machine_mode mode = GET_MODE (reg);\n-      unsigned int start;\n-      unsigned int last;\n-\n-      regno = reg_renumber[regno];\n-\n-      start = regno;\n-      last = end_hard_regno (mode, regno);\n-      if (GET_CODE (reg) == SUBREG)\n-\t{\n-\t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n-\t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n-\t  last = start + subreg_nregs_with_regno (regno, reg);\n-\t}\n-\n-      if (start == last - 1)\n-\tfprintf (file, \"(%d)\", start);\n-      else \n-\tfprintf (file, \"(%d:%d..%d)\", regno, start, last-1);\n-    }\n-  fprintf (file, suffix);\n-}\n-\n-\n-/* Scan the rtl code and record all conflicts and register preferences in the\n-   conflict matrices and preference tables.  */\n-\n-void\n-global_conflicts (void)\n-{\n-  unsigned int i;\n-  basic_block bb;\n-  rtx insn;\n-\n-  /* Regs that have allocnos can be in either \n-     hard_regs_live (if regno < FIRST_PSEUDO_REGISTER) or \n-     allocnos_live (if regno >= FIRST_PSEUDO_REGISTER) or \n-     both if local_alloc has preallocated it and reg_renumber >= 0.  */\n-\n-  HARD_REG_SET hard_regs_live;\n-  HARD_REG_SET renumbers_live;\n-  sparseset allocnos_live;\n-  bitmap live = BITMAP_ALLOC (NULL);\n-  VEC (df_ref_t, heap) *clobbers = NULL;\n-  VEC (df_ref_t, heap) *dying_regs = NULL;\n-\n-  /* live_subregs is a vector used to keep accurate information about\n-     which hardregs are live in multiword pseudos.  live_subregs and\n-     live_subregs_used are indexed by reg_allocno.  The live_subreg\n-     entry for a particular pseudo is a bitmap with one bit per byte\n-     of the register.  It is only used if the corresponding element is\n-     non zero in live_subregs_used.  The value in live_subregs_used is\n-     number of bytes that the pseudo can occupy.  */\n-  sbitmap *live_subregs = XCNEWVEC (sbitmap, max_allocno);\n-  int *live_subregs_used = XNEWVEC (int, max_allocno);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"fixed registers : \"); \n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (fixed_regs[i])\n-\t  fprintf (dump_file, \"%d \", i);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  allocnos_live = sparseset_alloc (max_allocno);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      bitmap_iterator bi;\n-\n-      bitmap_copy (live, DF_LIVE_OUT (bb));\n-      df_simulate_initialize_backwards (bb, live);\n-\n-      sparseset_clear (allocnos_live);\n-      memset (live_subregs_used, 0, max_allocno * sizeof (int));\n-      CLEAR_HARD_REG_SET (hard_regs_live);\n-      CLEAR_HARD_REG_SET (renumbers_live);\n-\n-      /* Initialize allocnos_live and hard_regs_live for bottom of block.  */\n-      EXECUTE_IF_SET_IN_BITMAP (live, 0, i, bi)\n-\t{\n-\t  if (i >= FIRST_PSEUDO_REGISTER)\n-\t    break;\n-\t  if (! fixed_regs[i])\n-\t    SET_HARD_REG_BIT (hard_regs_live, i);\n-\t}\n-    \n-      EXECUTE_IF_SET_IN_BITMAP (live, FIRST_PSEUDO_REGISTER, i, bi)\n-\t{\n-\t  int allocnum = reg_allocno[i];\n-\n-\t  if (allocnum >= 0)\n-\t    {\n-\t      int renumber = reg_renumber[i];\n-\t      rtx reg = regno_reg_rtx[i];\n-\n-\t      set_reg_in_live (allocnos_live, live_subregs, live_subregs_used, \n-\t\t\t       &hard_regs_live, reg, false);\n-\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n-\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n-\t\t\t\t    allocnum, renumber);\n-\t    }\n-\t} \n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\nstarting basic block %d\\n\\n\", bb->index);\n-\n-      FOR_BB_INSNS_REVERSE (bb, insn)\n-\t{\n-\t  unsigned int uid = INSN_UID (insn);\n-\t  df_ref *def_rec;\n-\t  df_ref *use_rec;\n-\n-\t  if (!INSN_P (insn))\n-\t    continue;\t\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"insn = %d live = hardregs [\", uid);\n-\t      \n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\tif (TEST_HARD_REG_BIT (hard_regs_live, i))\n-\t\t  fprintf (dump_file, \"%d \", i);\n-\n-\t      fprintf (dump_file, \"] renumbered [\");\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\tif (TEST_HARD_REG_BIT (renumbers_live, i))\n-\t\t  fprintf (dump_file, \"%d \", i);\n-\n-\t      fprintf (dump_file, \"] pseudos [\");\n-\t      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t\t{\n-\t\t  dump_ref (dump_file, \" \", \"\", regno_reg_rtx[allocno[i].reg],\n-\t\t\t    allocno[i].reg, live_subregs, live_subregs_used);\n-\t\t}\n-\t      fprintf (dump_file, \"]\\n\");\n-\t    }\n-\n-\t  /* Add the defs into live.  Most of them will already be\n-\t     there, the ones that are missing are the unused ones and\n-\t     the clobbers.  We do this in order to make sure that\n-\t     interferences are added between every def and everything\n-\t     that is live across the insn.  These defs will be removed\n-\t     later.  */\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\n-\t      /* FIXME: Ignoring may clobbers is technically the wrong\n-\t\t thing to do.  However the old version of the this\n-\t\t code ignores may clobbers (and instead has many\n-\t\t places in the register allocator to handle these\n-\t\t constraints).  It is quite likely that with a new\n-\t\t allocator, the correct thing to do is to not ignore\n-\t\t the constraints and then do not put in the large\n-\t\t number of special checks.  */\n-\t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n-\t\t{\n-\t\t  rtx reg = DF_REF_REG (def);\n-\t\t  set_reg_in_live (allocnos_live, live_subregs, live_subregs_used, \n-\t\t\t\t   &hard_regs_live, reg, \n-\t\t\t\t   DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT));\n-\t\t  if (dump_file)\n-\t\t    dump_ref (dump_file, \"  adding def\", \"\\n\",\n-\t\t\t      reg, DF_REF_REGNO (def), live_subregs, live_subregs_used);\n-\t\t}\n-\t    }\n-\t  \n-\t  /* Add the hardregs into renumbers_live to build the\n-\t     interferences.  Renumbers_live will be rebuilt in the\n-\t     next step from scratch, so corrupting it here is no\n-\t     problem.  */\n-\t  IOR_HARD_REG_SET (renumbers_live, hard_regs_live);\n-\n-\t  /* Add the interferences for the defs.  */\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER))\n-\t\tmark_reg_store (allocnos_live, &renumbers_live, def);\n-\t    }\n-\t  \n-\t  /* Remove the defs from the live sets.  Leave the partial\n-\t     and conditional defs in the set because they do not\n-\t     kill.  */\n-\t  VEC_truncate (df_ref_t, clobbers, 0);\n-\t  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-\t    {\n-\t      df_ref def = *def_rec;\n-\n-\t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n-\t\t{\n-\t\t  rtx reg = DF_REF_REG (def);\n-\n-\t\t  clear_reg_in_live (allocnos_live, live_subregs, live_subregs_used,\n-\t\t\t\t     &hard_regs_live, reg, def);\n-\t\t  if (dump_file)\n-\t\t    dump_ref (dump_file, \"  clearing def\", \"\\n\", \n-\t\t\t      reg, DF_REF_REGNO (def), live_subregs, live_subregs_used);\n-\t\t}\n-\t      \n-\t      if (DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER))\n-\t\tVEC_safe_push (df_ref_t, heap, clobbers, def);\n-\t    }\n-\t  \n-\t  /* Go thru all of the live pseudos and reset renumbers_live.\n-\t     We must start from scratch here because there could have\n-\t     been several pseudos alive that have the same\n-\t     reg_renumber and if we see a clobber for one of them, we\n-\t     cannot not want to kill the renumbers from the other\n-\t     pseudos.  */\n-\t  CLEAR_HARD_REG_SET (renumbers_live);\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t    {\n-\t      unsigned int regno = allocno[i].reg;\n-\t      int renumber = reg_renumber[regno];\n-\n-\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n-\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n-\t\t\t\t    i, renumber);\n-\t    }\n-\t\t\t\t\t \n-\t  /* Add the uses to the live sets.  Keep track of the regs\n-\t     that are dying inside the insn, this set will be useful\n-\t     later.  */\n-\t  VEC_truncate (df_ref_t, dying_regs, 0);\n-\t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t    {\n-\t      df_ref use = *use_rec;\n-\t      unsigned int regno = DF_REF_REGNO (use);\n-\t      bool added = false;\n-\t      int renumber = reg_renumber[regno];\n-\t      int allocnum = reg_allocno[regno];\n-\t      bool renumbering = false;\n-\t      rtx reg = DF_REF_REG (use);\n-\n-\t      /* DF_REF_READ_WRITE on a use means that this use is\n-\t\t fabricated from a def that is a partial set to a\n-\t\t multiword reg.  Here, we only model the subreg case\n-\t\t precisely so we do not need to look at the fabricated\n-\t\t use unless that set also happens to wrapped in a\n-\t\t ZERO_EXTRACT. */\n-\t      if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n-\t\t  && (!DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT)) \n-\t\t  && DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n-\t\tcontinue;\n-\t      \n-\t      if (dump_file)\n-\t\tdump_ref (dump_file, \"  seeing use\", \"\\n\",\n-\t\t\t  reg, regno, live_subregs, live_subregs_used);\n-\n-\t      if (allocnum >= 0)\n-\t\t{\n-\t\t  if (GET_CODE (reg) == SUBREG\n-\t\t      && !DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT)) \n-\t\t    {\n-\t\t      unsigned int start = SUBREG_BYTE (reg);\n-\t\t      unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n-\n-\t\t      ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n-\t\t\t\t\t    live_subregs, live_subregs_used, allocnum, reg);\n-\t\t      \n-\t\t      /* Ignore the paradoxical bits.  */\n-\t\t      if ((int)last > live_subregs_used[allocnum])\n-\t\t\tlast = live_subregs_used[allocnum];\n-\t\t      \n-\t\t      while (start < last)\n-\t\t\t{\n-\t\t\t  if (!TEST_BIT (live_subregs[allocnum], start)) \n-\t\t\t    {\n-\t\t\t      if (dump_file)\n-\t\t\t\tfprintf (dump_file, \"    dying pseudo subreg %d[%d]\\n\", regno, start);\n-\t\t\t      SET_BIT (live_subregs[allocnum], start);\n-\t\t\t      \n-\t\t\t      added = true;\n-\t\t\t    }\n-\t\t\t  start++;\n-\t\t\t}\n-\t\t      \n-\t\t      sparseset_set_bit (allocnos_live, allocnum);\n-\t\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n-\t\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n-\t\t\t\t\t    allocnum, renumber);\n-\t\t    }\n-\t\t  else if (live_subregs_used[allocnum] > 0\n-\t\t\t   || !sparseset_bit_p (allocnos_live, allocnum))\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"    %sdying pseudo\\n\", \n-\t\t\t\t (live_subregs_used[allocnum] > 0) ? \"partially \": \"\");\n-\t\t      /* Resetting the live_subregs_used is\n-\t\t\t effectively saying do not use the subregs\n-\t\t\t because we are reading the whole pseudo.  */\n-\t\t      live_subregs_used[allocnum] = 0;\n-\t\t      sparseset_set_bit (allocnos_live, allocnum);\n-\t\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n-\t\t\tset_renumbers_live (&renumbers_live, live_subregs, live_subregs_used, \n-\t\t\t\t\t    allocnum, renumber);\n-\t\t      added = true;\n-\t\t    }\n-\t\t}\n-\n-\t      if (renumber >= 0 && renumber < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  regno = renumber;\n-\t\t  renumbering = true;\n-\t\t}\n-\t      \n-\t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  unsigned int start = regno;\n-\t\t  unsigned int last;\n-\t\t  if (GET_CODE (reg) == SUBREG)\n-\t\t    {\n-\t\t      start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n-\t\t\t\t\t\t    SUBREG_BYTE (reg), GET_MODE (reg));\n-\t\t      last = start + subreg_nregs_with_regno (regno, reg);\n-\t\t    }\n-\t\t  else\n-\t\t    last = end_hard_regno (GET_MODE (reg), regno);\n-\t\t  \n-\t\t  regno = start;\n-\t\t  while (regno < last)\n-\t\t    {\n-\t\t      if ((!TEST_HARD_REG_BIT (hard_regs_live, regno)) \n-\t\t\t  && (!TEST_HARD_REG_BIT (renumbers_live, regno)) \n-\t\t\t  && ! fixed_regs[regno])\n-\t\t\t{\n-\t\t\t  if (dump_file)\n-\t\t\t    fprintf (dump_file, \"    dying hard reg %d\\n\", regno);\n-\t\t\t  if (renumbering)\n-\t\t\t    SET_HARD_REG_BIT (renumbers_live, regno);\n-\t\t\t  else\n-\t\t\t    SET_HARD_REG_BIT (hard_regs_live, regno);\n-\t\t\t  \n-\t\t\t  added = true;\n-\t\t\t}\n-\t\t      regno++;\n-\t\t    }\n-\t\t}\n-\t      if (added)\n-\t\tVEC_safe_push (df_ref_t, heap, dying_regs, use);\n-\t    }\n-\t  \n-\t  /* These three cases are all closely related, they all deal\n-             with some set of outputs of the insn need to conflict\n-             with some of the registers that are used by the insn but\n-             die within the insn. If no registers die within the insn,\n-             the tests can be skipped. */\n-\n-\t  if (VEC_length (df_ref_t, dying_regs) > 0)\n-\t    {\n-\t      int k;\n-\t      /* There appears to be an ambiguity as to what a clobber\n-\t\t means in an insn.  In some cases, the clobber happens\n-\t\t within the processing of the insn and in some cases\n-\t\t it happens at the end of processing the insn.  There\n-\t\t is currently no way to distinguish these two cases so\n-\t\t this code causes real clobbers to interfere with\n-\t\t registers that die within an insn.\n-\n-\t\t This is consistent with the prior version of\n-\t\t interference graph builder but is was discovered\n-\t\t while developing this version of the code, that on\n-\t\t some architectures such as the x86-64, the clobbers\n-\t\t only appear to happen at the end of the insn.\n-\t\t However, the ppc-32 contains clobbers for which these\n-\t\t interferences are necessary.\n-\n-\t\t FIXME: We should consider either adding a new kind of\n-\t\t clobber, or adding a flag to the clobber distinguish\n-\t\t these two cases.  */\n-\t      if (dump_file && VEC_length (df_ref_t, clobbers))\n-\t\tfprintf (dump_file, \"  clobber conflicts\\n\");\n-\t      for (k = VEC_length (df_ref_t, clobbers) - 1; k >= 0; k--)\n-\t\t{\n-\t\t  df_ref def = VEC_index (df_ref_t, clobbers, k);\n-\t\t  int j;\n-\n-\t\t  for (j = VEC_length (df_ref_t, dying_regs) - 1; j >= 0; j--)\n-\t\t    {\n-\t\t      df_ref use = VEC_index (df_ref_t, dying_regs, j);\n-\t\t      record_one_conflict_between_regnos (GET_MODE (DF_REF_REG (def)),\n-\t\t\t\t\t\t\t  DF_REF_REGNO (def),\n-\t\t\t\t\t\t\t  GET_MODE (DF_REF_REG (use)),\n-\t\t\t\t\t\t\t  DF_REF_REGNO (use));\n-\t\t    }\n-\t\t}\n-\n-\t      /* Early clobbers, by definition, need to not only\n-\t\t clobber the registers that are live across the insn\n-\t\t but need to clobber the registers that die within the\n-\t\t insn.  The clobbering for registers live across the\n-\t\t insn is handled above.  */ \n-\t      set_conflicts_for_earlyclobber (insn);\n-\n-\t      /* If INSN is a store with multiple outputs, then any\n-\t\t reg that dies here and is used inside of the address\n-\t\t of the output must conflict with the other outputs.\n-\n-\t\t FIXME: There has been some discussion as to whether\n-\t\t this is right place to handle this issue.  This is a\n-\t\t hold over from an early version global conflicts.\n-\n-\t\t 1) There is some evidence that code only deals with a\n-\t\t bug that is only on the m68k.  The conditions of this\n-\t\t test are such that this case only triggers for a very\n-\t\t peculiar insn, one that is a parallel where one of\n-\t\t the sets is a store and the other sets a reg that is\n-\t\t used in the address of the store.  See\n-\t\t http://gcc.gnu.org/ml/gcc-patches/1998-12/msg00259.html\n-\n-\t\t 2) The situation that this is addressing is a bug in\n-\t\t the part of reload that handles stores, adding this\n-\t\t conflict only hides the problem.  (Of course no one\n-\t\t really wants to fix reload so it is understandable\n-\t\t why a bandaid was just added here.)\n-\n-\t\t Just because an output is unused does not mean the\n-\t\t compiler can assume the side effect will not occur.\n-\t\t Consider if REG appears in the address of an output\n-\t\t and we reload the output.  If we allocate REG to the\n-\t\t same hard register as an unused output we could set\n-\t\t the hard register before the output reload insn.\n-\n-\t\t 3) This could actually be handled by making the other\n-\t\t (non store) operand of the insn be an early clobber.\n-\t\t This would insert the same conflict, even if it is\n-\t\t not technically an early clobber.  */\n-\n-\t      /* It is unsafe to use !single_set here since it will ignore an\n-\t\t unused output.  */\n-\t      if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n-\t\t{ \n-\t\t  int j;\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"  multiple sets\\n\");\n-\t\t  for (j = VEC_length (df_ref_t, dying_regs) - 1; j >= 0; j--)\n-\t\t    {\n-\t\t      int used_in_output = 0;\n-\t\t      df_ref use = VEC_index (df_ref_t, dying_regs, j);\n-\t\t      rtx reg = DF_REF_REG (use);\n-\t\t      int uregno = DF_REF_REGNO (use);\n-\t\t      enum machine_mode umode = GET_MODE (DF_REF_REG (use));\n-\t\t      int k;\n-\n-\t\t      for (k = XVECLEN (PATTERN (insn), 0) - 1; k >= 0; k--)\n-\t\t\t{\n-\t\t\t  rtx set = XVECEXP (PATTERN (insn), 0, k);\n-\t\t\t  if (GET_CODE (set) == SET\n-\t\t\t      && !REG_P (SET_DEST (set))\n-\t\t\t      && !rtx_equal_p (reg, SET_DEST (set))\n-\t\t\t      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\t\t\t    used_in_output = 1;\n-\t\t\t}\n-\t\t      if (used_in_output)\n-\t\t\tfor (k = XVECLEN (PATTERN (insn), 0) - 1; k >= 0; k--)\n-\t\t\t  {\n-\t\t\t    rtx set = XVECEXP (PATTERN (insn), 0, k);\n-\t\t\t    if (GET_CODE (set) == SET\n-\t\t\t\t&& REG_P (SET_DEST (set))\n-\t\t\t\t&& !rtx_equal_p (reg, SET_DEST (set)))\n-\t\t\t      record_one_conflict_between_regnos (GET_MODE (SET_DEST (set)),\n-\t\t\t\t\t\t\t\t  REGNO (SET_DEST (set)), \n-\t\t\t\t\t\t\t\t  umode, uregno);\n-\t\t\t  }\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Add the renumbers live to the hard_regs_live for the next few\n-\t calls.  All of this gets recomputed at the top of the loop so\n-\t there is no harm.  */\n-      IOR_HARD_REG_SET (hard_regs_live, renumbers_live);\n-\t  \n-#ifdef EH_RETURN_DATA_REGNO\n-      if (bb_has_eh_pred (bb))\n-\t{\n-\t  unsigned int i;\n-    \n-\t  for (i = 0; ; ++i)\n-\t    {\n-\t      unsigned int regno = EH_RETURN_DATA_REGNO (i);\n-\t      if (regno == INVALID_REGNUM)\n-\t\tbreak;\n-\t      record_one_conflict (allocnos_live, &hard_regs_live, regno);\n-\t    }\n-\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t    {\n-\t      allocno[i].no_eh_reg = 1;\n-\t    }\n-\t}\n-#endif\n-\n-      if (bb_has_abnormal_pred (bb))\n-\t{\n-\t  unsigned int i;\n-#ifdef STACK_REGS\n-\t  /* Pseudos can't go in stack regs at the start of a basic block that\n-\t     is reached by an abnormal edge. Likewise for call clobbered regs,\n-\t     because caller-save, fixup_abnormal_edges and possibly the table\n-\t     driven EH machinery are not quite ready to handle such regs live\n-\t     across such edges.  */\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t    {\n-\t      allocno[i].no_stack_reg = 1;\n-\t    }\n-\n-\t  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-\t    record_one_conflict (allocnos_live, &hard_regs_live, i);\n-#endif\n-\t  \n-\t  /* No need to record conflicts for call clobbered regs if we have\n-\t     nonlocal labels around, as we don't ever try to allocate such\n-\t     regs in this case.  */\n-\t  if (! cfun->has_nonlocal_label)\n-\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t      if (call_used_regs [i])\n-\t\trecord_one_conflict (allocnos_live, &hard_regs_live, i);\n-\t}\n-    }\n-  \n-  for (i = 0; i < (unsigned int)max_allocno; i++)\n-    if (live_subregs[i])\n-      free (live_subregs[i]);\n-\n-  /* Clean up.  */\n-  free (allocnos_live);\n-  free (live_subregs);\n-  free (live_subregs_used);\n-  VEC_free (df_ref_t, heap, dying_regs);\n-  VEC_free (df_ref_t, heap, clobbers);\n-  BITMAP_FREE (live);\n-}"}, {"sha": "01b409c194241246dcb0b694404d05bc21d8f42d", "filename": "gcc/reginfo.c", "status": "renamed", "additions": 36, "deletions": 1401, "changes": 1437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -1,4 +1,4 @@\n-/* Compute register class preferences for pseudo-registers.\n+/* Compute different info about registers.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996\n    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n@@ -20,9 +20,12 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n \n-/* This file contains two passes of the compiler: reg_scan and reg_class.\n-   It also defines some tables of information about the hardware registers\n-   and a function init_reg_sets to initialize the tables.  */\n+/* This file contains regscan pass of the compiler and passes for\n+   dealing with info about modes of pseudo-registers inside\n+   subregisters.  It also defines some tables of information about the\n+   hardware registers, function init_reg_sets to initialize the\n+   tables, and other auxiliary functions to deal with info about\n+   registers and their classes.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -55,59 +58,38 @@ along with GCC; see the file COPYING3.  If not see\n \n int max_regno;\n \n-static void init_reg_sets_1 (void);\n-static void init_reg_autoinc (void);\n-\n-/* If we have auto-increment or auto-decrement and we can have secondary\n-   reloads, we are not allowed to use classes requiring secondary\n-   reloads for pseudos auto-incremented since reload can't handle it.  */\n-/* We leave it to target hooks to decide if we have secondary reloads, so\n-   assume that we might have them.  */\n-#if defined(AUTO_INC_DEC) /* */\n-#define FORBIDDEN_INC_DEC_CLASSES\n-#endif\n \f\n /* Register tables used by many passes.  */\n \n /* Indexed by hard register number, contains 1 for registers\n    that are fixed use (stack pointer, pc, frame pointer, etc.).\n    These are the registers that cannot be used to allocate\n    a pseudo reg for general use.  */\n-\n char fixed_regs[FIRST_PSEUDO_REGISTER];\n \n /* Same info as a HARD_REG_SET.  */\n-\n HARD_REG_SET fixed_reg_set;\n \n /* Data for initializing the above.  */\n-\n static const char initial_fixed_regs[] = FIXED_REGISTERS;\n \n /* Indexed by hard register number, contains 1 for registers\n    that are fixed use or are clobbered by function calls.\n    These are the registers that cannot be used to allocate\n    a pseudo reg whose life crosses calls unless we are able\n    to save/restore them across the calls.  */\n-\n char call_used_regs[FIRST_PSEUDO_REGISTER];\n \n /* Same info as a HARD_REG_SET.  */\n-\n HARD_REG_SET call_used_reg_set;\n \n-/* HARD_REG_SET of registers we want to avoid caller saving.  */\n-HARD_REG_SET losing_caller_save_reg_set;\n-\n /* Data for initializing the above.  */\n-\n static const char initial_call_used_regs[] = CALL_USED_REGISTERS;\n \n /* This is much like call_used_regs, except it doesn't have to\n    be a superset of FIXED_REGISTERS. This vector indicates\n    what is really call clobbered, and is used when defining\n    regs_invalidated_by_call.  */\n-\n #ifdef CALL_REALLY_USED_REGISTERS\n char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n #endif\n@@ -123,18 +105,15 @@ char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n    fixed use or call used registers that cannot hold quantities across\n    calls even if we are willing to save and restore them.  call fixed\n    registers are a subset of call used registers.  */\n-\n char call_fixed_regs[FIRST_PSEUDO_REGISTER];\n \n /* The same info as a HARD_REG_SET.  */\n-\n HARD_REG_SET call_fixed_reg_set;\n \n /* Indexed by hard register number, contains 1 for registers\n    that are being used for global register decls.\n    These must be exempt from ordinary flow analysis\n    and are also considered fixed.  */\n-\n char global_regs[FIRST_PSEUDO_REGISTER];\n \n /* Contains 1 for registers that are set or clobbered by calls.  */\n@@ -143,17 +122,14 @@ char global_regs[FIRST_PSEUDO_REGISTER];\n    fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n    that are actually preserved.  We know for sure that those associated\n    with the local stack frame are safe, but scant others.  */\n-\n HARD_REG_SET regs_invalidated_by_call;\n \n /* Same information as REGS_INVALIDATED_BY_CALL but in regset form to be used\n    in dataflow more conveniently.  */\n-\n regset regs_invalidated_by_call_regset;\n \n /* The bitmap_obstack is used to hold some static variables that\n    should not be reset after each function is compiled.  */\n-\n static bitmap_obstack persistent_obstack;\n \n /* Table of register numbers in the order in which to try to use them.  */\n@@ -165,104 +141,70 @@ int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n #endif\n \n /* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n-\n HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n \n /* The same information, but as an array of unsigned ints.  We copy from\n    these unsigned ints to the table above.  We do this so the tm.h files\n    do not have to be aware of the wordsize for machines with <= 64 regs.\n    Note that we hard-code 32 here, not HOST_BITS_PER_INT.  */\n-\n #define N_REG_INTS  \\\n   ((FIRST_PSEUDO_REGISTER + (32 - 1)) / 32)\n \n static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]\n   = REG_CLASS_CONTENTS;\n \n /* For each reg class, number of regs it contains.  */\n-\n unsigned int reg_class_size[N_REG_CLASSES];\n \n-/* For each reg class, table listing all the containing classes.  */\n-\n-static enum reg_class reg_class_superclasses[N_REG_CLASSES][N_REG_CLASSES];\n-\n /* For each reg class, table listing all the classes contained in it.  */\n-\n enum reg_class reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n \n /* For each pair of reg classes,\n    a largest reg class contained in their union.  */\n-\n enum reg_class reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n \n /* For each pair of reg classes,\n    the smallest reg class containing their union.  */\n-\n enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n /* Array containing all of the register names.  */\n-\n const char * reg_names[] = REGISTER_NAMES;\n \n /* Array containing all of the register class names.  */\n-\n const char * reg_class_names[] = REG_CLASS_NAMES;\n \n /* For each hard register, the widest mode object that it can contain.\n    This will be a MODE_INT mode if the register can hold integers.  Otherwise\n    it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n    register.  */\n-\n enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n \n /* 1 if there is a register of given mode.  */\n-\n bool have_regs_of_mode [MAX_MACHINE_MODE];\n \n /* 1 if class does contain register of given mode.  */\n-\n char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n \n /* Maximum cost of moving from a register in one class to a register in\n    another class.  Based on REGISTER_MOVE_COST.  */\n-\n move_table *move_cost[MAX_MACHINE_MODE];\n \n /* Similar, but here we don't have to move if the first index is a subset\n    of the second so in that case the cost is zero.  */\n-\n move_table *may_move_in_cost[MAX_MACHINE_MODE];\n \n /* Similar, but here we don't have to move if the first index is a superset\n    of the second so in that case the cost is zero.  */\n-\n move_table *may_move_out_cost[MAX_MACHINE_MODE];\n \n /* Keep track of the last mode we initialized move costs for.  */\n static int last_mode_for_init_move_cost;\n \n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-\n-/* These are the classes that regs which are auto-incremented or decremented\n-   cannot be put in.  */\n-\n-static int forbidden_inc_dec_class[N_REG_CLASSES];\n-\n-/* Indexed by n, is nonzero if (REG n) is used in an auto-inc or auto-dec\n-   context.  */\n-\n-static char *in_inc_dec;\n-\n-#endif /* FORBIDDEN_INC_DEC_CLASSES */\n-\n /* Sample MEM values for use by memory_move_secondary_cost.  */\n-\n static GTY(()) rtx top_of_stack[MAX_MACHINE_MODE];\n \n /* No more global register variables may be declared; true once\n-   regclass has been initialized.  */\n-\n+   reginfo has been initialized.  */\n static int no_global_reg_vars = 0;\n \n /* Specify number of hard registers given machine mode occupy.  */\n@@ -272,7 +214,6 @@ unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n    correspond to the hard registers, if any, set in that map.  This\n    could be done far more efficiently by having all sorts of special-cases\n    with moving single words, but probably isn't worth the trouble.  */\n-\n void\n reg_set_to_hard_reg_set (HARD_REG_SET *to, const_bitmap from)\n {\n@@ -287,10 +228,8 @@ reg_set_to_hard_reg_set (HARD_REG_SET *to, const_bitmap from)\n     }\n }\n \n-\n /* Function called only once to initialize the above data on reg usage.\n    Once this is done, various switches may override.  */\n-\n void\n init_reg_sets (void)\n {\n@@ -321,7 +260,6 @@ init_reg_sets (void)\n }\n \n /* Initialize may_move_cost and friends for mode M.  */\n-\n void\n init_move_cost (enum machine_mode m)\n {\n@@ -412,7 +350,6 @@ init_move_cost (enum machine_mode m)\n /* We need to save copies of some of the register information which\n    can be munged by command-line switches so we can restore it during\n    subsequent back-end reinitialization.  */\n-\n static char saved_fixed_regs[FIRST_PSEUDO_REGISTER];\n static char saved_call_used_regs[FIRST_PSEUDO_REGISTER];\n #ifdef CALL_REALLY_USED_REGISTERS\n@@ -421,7 +358,6 @@ static char saved_call_really_used_regs[FIRST_PSEUDO_REGISTER];\n static const char *saved_reg_names[FIRST_PSEUDO_REGISTER];\n \n /* Save the register information.  */\n-\n void\n save_register_info (void)\n {\n@@ -446,7 +382,6 @@ save_register_info (void)\n }\n \n /* Restore the register information.  */\n-\n static void\n restore_register_info (void)\n {\n@@ -463,7 +398,6 @@ restore_register_info (void)\n \n /* After switches have been processed, which perhaps alter\n    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */\n-\n static void\n init_reg_sets_1 (void)\n {\n@@ -543,10 +477,7 @@ init_reg_sets_1 (void)\n   for (i = 0; i < N_REG_CLASSES; i++)\n     {\n       for (j = 0; j < N_REG_CLASSES; j++)\n-\t{\n-\t  reg_class_superclasses[i][j] = LIM_REG_CLASSES;\n-\t  reg_class_subclasses[i][j] = LIM_REG_CLASSES;\n-\t}\n+\treg_class_subclasses[i][j] = LIM_REG_CLASSES;\n     }\n \n   for (i = 0; i < N_REG_CLASSES; i++)\n@@ -562,9 +493,6 @@ init_reg_sets_1 (void)\n \t       Add J to the table of superclasses of I.  */\n \t    enum reg_class *p;\n \n-\t    p = &reg_class_superclasses[i][0];\n-\t    while (*p != LIM_REG_CLASSES) p++;\n-\t    *p = (enum reg_class) j;\n \t    /* Add I to the table of superclasses of J.  */\n \t    p = &reg_class_subclasses[j][0];\n \t    while (*p != LIM_REG_CLASSES) p++;\n@@ -578,7 +506,6 @@ init_reg_sets_1 (void)\n   CLEAR_HARD_REG_SET (call_used_reg_set);\n   CLEAR_HARD_REG_SET (call_fixed_reg_set);\n   CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n-  CLEAR_HARD_REG_SET (losing_caller_save_reg_set);\n   if (!regs_invalidated_by_call_regset)\n     {\n       bitmap_obstack_initialize (&persistent_obstack);\n@@ -605,8 +532,6 @@ init_reg_sets_1 (void)\n \tSET_HARD_REG_BIT (call_used_reg_set, i);\n       if (call_fixed_regs[i])\n \tSET_HARD_REG_BIT (call_fixed_reg_set, i);\n-      if (CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (i)))\n-\tSET_HARD_REG_BIT (losing_caller_save_reg_set, i);\n \n       /* There are a couple of fixed registers that we know are safe to\n \t exclude from being clobbered by calls:\n@@ -702,7 +627,6 @@ init_reg_sets_1 (void)\n    This function might be invoked more than once, if the target has support\n    for changing register usage conventions on a per-function basis.\n */\n-\n void\n init_reg_modes_target (void)\n {\n@@ -730,56 +654,46 @@ init_reg_modes_target (void)\n    This function might be invoked more than once, if the target has support\n    for changing register usage conventions on a per-function basis.\n */\n-\n void\n init_regs (void)\n {\n   /* This finishes what was started by init_reg_sets, but couldn't be done\n      until after register usage was specified.  */\n   init_reg_sets_1 ();\n-\n-  init_reg_autoinc ();\n }\n \n-/* The same as previous function plus initializing IRA if it is\n-   necessary.  */\n+/* The same as previous function plus initializing IRA.  */\n void\n reinit_regs (void)\n {\n   init_regs ();\n-\n-  if (flag_ira)\n-    ira_init ();\n+  ira_init ();\n }\n \n /* Initialize some fake stack-frame MEM references for use in\n    memory_move_secondary_cost.  */\n-\n void\n init_fake_stack_mems (void)\n {\n-  {\n-    int i;\n-\n-    for (i = 0; i < MAX_MACHINE_MODE; i++)\n-      top_of_stack[i] = gen_rtx_MEM (i, stack_pointer_rtx);\n-  }\n+  int i;\n+  \n+  for (i = 0; i < MAX_MACHINE_MODE; i++)\n+    top_of_stack[i] = gen_rtx_MEM (i, stack_pointer_rtx);\n }\n \n \n /* Compute extra cost of moving registers to/from memory due to reloads.\n    Only needed if secondary reloads are required for memory moves.  */\n-\n int\n-memory_move_secondary_cost (enum machine_mode mode, enum reg_class rclass, int in)\n+memory_move_secondary_cost (enum machine_mode mode, enum reg_class rclass,\n+\t\t\t    int in)\n {\n   enum reg_class altclass;\n   int partial_cost = 0;\n   /* We need a memory reference to feed to SECONDARY... macros.  */\n   /* mem may be unused even if the SECONDARY_ macros are defined.  */\n   rtx mem ATTRIBUTE_UNUSED = top_of_stack[(int) mode];\n \n-\n   altclass = secondary_reload_class (in ? 1 : 0, rclass, mode, mem);\n \n   if (altclass == NO_REGS)\n@@ -808,7 +722,6 @@ memory_move_secondary_cost (enum machine_mode mode, enum reg_class rclass, int i\n /* Return a machine mode that is legitimate for hard reg REGNO and large\n    enough to save nregs.  If we can't find one, return VOIDmode.\n    If CALL_SAVED is true, only consider modes that are call saved.  */\n-\n enum machine_mode\n choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n \t\t      unsigned int nregs, bool call_saved)\n@@ -881,7 +794,6 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n /* Specify the usage characteristics of the register named NAME.\n    It should be a fixed register if FIXED and a\n    call-used register if CALL_USED.  */\n-\n void\n fix_register (const char *name, int fixed, int call_used)\n {\n@@ -925,7 +837,6 @@ fix_register (const char *name, int fixed, int call_used)\n }\n \n /* Mark register number I as global.  */\n-\n void\n globalize_reg (int i)\n {\n@@ -950,7 +861,7 @@ globalize_reg (int i)\n     {\n       SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n       SET_REGNO_REG_SET (regs_invalidated_by_call_regset, i);\n-   }\n+    }\n \n   /* If already fixed, nothing else to do.  */\n   if (fixed_regs[i])\n@@ -966,18 +877,6 @@ globalize_reg (int i)\n   SET_HARD_REG_BIT (call_fixed_reg_set, i);\n }\n \f\n-/* Now the data and code for the `regclass' pass, which happens\n-   just before local-alloc.  */\n-\n-/* The `costs' struct records the cost of using a hard register of each class\n-   and of using memory for each pseudo.  We use this data to set up\n-   register class preferences.  */\n-\n-struct costs\n-{\n-  int cost[N_REG_CLASSES];\n-  int mem_cost;\n-};\n \n /* Structure used to record preferences of given pseudo.  */\n struct reg_pref\n@@ -996,65 +895,13 @@ struct reg_pref\n   char altclass;\n };\n \n-/* Record the cost of each class for each pseudo.  */\n-\n-static struct costs *costs;\n-\n-/* Initialized once, and used to initialize cost values for each insn.  */\n-\n-static struct costs init_cost;\n-\n-/* Record preferences of each pseudo.\n-   This is available after `regclass' is run.  */\n-\n+/* Record preferences of each pseudo.  This is available after RA is\n+   run.  */\n static struct reg_pref *reg_pref;\n \n-/* Frequency of executions of current insn.  */\n-\n-static int frequency;\n-\n-static rtx scan_one_insn (rtx, int);\n-static void record_operand_costs (rtx, struct costs *, struct reg_pref *);\n-static void dump_regclass (FILE *);\n-static void record_reg_classes (int, int, rtx *, enum machine_mode *,\n-\t\t\t\tconst char **, rtx, struct costs *,\n-\t\t\t\tstruct reg_pref *);\n-static int copy_cost (rtx, enum machine_mode, enum reg_class, int,\n-\t\t      secondary_reload_info *);\n-static void record_address_regs (enum machine_mode, rtx, int, enum rtx_code,\n-\t\t\t\t enum rtx_code, int);\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-static int auto_inc_dec_reg_p (rtx, enum machine_mode);\n-#endif\n-static void reg_scan_mark_refs (rtx, rtx);\n-\n-/* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudo registers.  */\n-\n-static inline bool\n-ok_for_index_p_nonstrict (rtx reg)\n-{\n-  unsigned regno = REGNO (reg);\n-  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);\n-}\n-\n-/* A version of regno_ok_for_base_p for use during regclass, when all pseudos\n-   should count as OK.  Arguments as for regno_ok_for_base_p.  */\n-\n-static inline bool\n-ok_for_base_p_nonstrict (rtx reg, enum machine_mode mode,\n-\t\t\t enum rtx_code outer_code, enum rtx_code index_code)\n-{\n-  unsigned regno = REGNO (reg);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return true;\n-\n-  return ok_for_base_p_1 (regno, mode, outer_code, index_code);\n-}\n-\n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n    When that happens, just return GENERAL_REGS, which is innocuous.  */\n-\n enum reg_class\n reg_preferred_class (int regno)\n {\n@@ -1074,35 +921,28 @@ reg_alternate_class (int regno)\n }\n \n /* Initialize some global data for this pass.  */\n-\n static unsigned int \n-regclass_init (void)\n+reginfo_init (void)\n {\n-  int i;\n-\n   if (df)\n     df_compute_regs_ever_live (true);\n \n-  init_cost.mem_cost = 10000;\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    init_cost.cost[i] = 10000;\n-\n   /* This prevents dump_flow_info from losing if called\n-     before regclass is run.  */\n+     before reginfo is run.  */\n   reg_pref = NULL;\n \n   /* No more global register variables may be declared.  */\n   no_global_reg_vars = 1;\n   return 1;\n }\n \n-struct rtl_opt_pass pass_regclass_init =\n+struct rtl_opt_pass pass_reginfo_init =\n {\n  {\n   RTL_PASS,\n-  \"regclass\",                           /* name */\n+  \"reginfo\",                            /* name */\n   NULL,                                 /* gate */\n-  regclass_init,                        /* execute */\n+  reginfo_init,                         /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -1115,1210 +955,6 @@ struct rtl_opt_pass pass_regclass_init =\n  }\n };\n \n-\n-\f\n-/* Dump register costs.  */\n-static void\n-dump_regclass (FILE *dump)\n-{\n-  int i;\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    {\n-      int /* enum reg_class */ rclass;\n-      if (REG_N_REFS (i))\n-\t{\n-\t  fprintf (dump, \"  Register %i costs:\", i);\n-\t  for (rclass = 0; rclass < (int) N_REG_CLASSES; rclass++)\n-\t    if (contains_reg_of_mode [(enum reg_class) rclass][PSEUDO_REGNO_MODE (i)]\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t\t&& (!in_inc_dec[i]\n-\t\t    || !forbidden_inc_dec_class[(enum reg_class) rclass])\n-#endif\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t&& ! invalid_mode_change_p (i, (enum reg_class) rclass,\n-\t\t\t\t\t    PSEUDO_REGNO_MODE (i))\n-#endif\n-\t\t)\n-\t    fprintf (dump, \" %s:%i\", reg_class_names[rclass],\n-\t\t     costs[i].cost[(enum reg_class) rclass]);\n-\t  fprintf (dump, \" MEM:%i\\n\", costs[i].mem_cost);\n-\t}\n-    }\n-}\n-\f\n-\n-/* Calculate the costs of insn operands.  */\n-\n-static void\n-record_operand_costs (rtx insn, struct costs *op_costs,\n-\t\t      struct reg_pref *reg_pref)\n-{\n-  const char *constraints[MAX_RECOG_OPERANDS];\n-  enum machine_mode modes[MAX_RECOG_OPERANDS];\n-  int i;\n-\n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      constraints[i] = recog_data.constraints[i];\n-      modes[i] = recog_data.operand_mode[i];\n-    }\n-\n-  /* If we get here, we are set up to record the costs of all the\n-     operands for this insn.  Start by initializing the costs.\n-     Then handle any address registers.  Finally record the desired\n-     classes for any pseudos, doing it twice if some pair of\n-     operands are commutative.  */\n-\n-  for (i = 0; i < recog_data.n_operands; i++)\n-    {\n-      op_costs[i] = init_cost;\n-\n-      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-\trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n-\n-      if (MEM_P (recog_data.operand[i]))\n-\trecord_address_regs (GET_MODE (recog_data.operand[i]),\n-\t\t\t     XEXP (recog_data.operand[i], 0),\n-\t\t\t     0, MEM, SCRATCH, frequency * 2);\n-      else if (recog_data.alternative_enabled_p[0]\n-\t       && (constraints[i][0] == 'p'\n-\t\t   || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i])))\n-\trecord_address_regs (VOIDmode, recog_data.operand[i], 0, ADDRESS,\n-\t\t\t     SCRATCH, frequency * 2);\n-    }\n-\n-  /* Check for commutative in a separate loop so everything will\n-     have been initialized.  We must do this even if one operand\n-     is a constant--see addsi3 in m68k.md.  */\n-\n-  for (i = 0; i < (int) recog_data.n_operands - 1; i++)\n-    if (constraints[i][0] == '%')\n-      {\n-\tconst char *xconstraints[MAX_RECOG_OPERANDS];\n-\tint j;\n-\n-\t/* Handle commutative operands by swapping the constraints.\n-\t   We assume the modes are the same.  */\n-\n-\tfor (j = 0; j < recog_data.n_operands; j++)\n-\t  xconstraints[j] = constraints[j];\n-\n-\txconstraints[i] = constraints[i+1];\n-\txconstraints[i+1] = constraints[i];\n-\trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t\t    recog_data.operand, modes,\n-\t\t\t    xconstraints, insn, op_costs, reg_pref);\n-      }\n-\n-  record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t      recog_data.operand, modes,\n-\t\t      constraints, insn, op_costs, reg_pref);\n-}\n-\f\n-/* Subroutine of regclass, processes one insn INSN.  Scan it and record each\n-   time it would save code to put a certain register in a certain class.\n-   PASS, when nonzero, inhibits some optimizations which need only be done\n-   once.\n-   Return the last insn processed, so that the scan can be continued from\n-   there.  */\n-\n-static rtx\n-scan_one_insn (rtx insn, int pass ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code pat_code;\n-  rtx set, note;\n-  int i, j;\n-  struct costs op_costs[MAX_RECOG_OPERANDS];\n-\n-  if (!INSN_P (insn))\n-    return insn;\n-\n-  pat_code = GET_CODE (PATTERN (insn));\n-  if (pat_code == USE\n-      || pat_code == CLOBBER\n-      || pat_code == ASM_INPUT\n-      || pat_code == ADDR_VEC\n-      || pat_code == ADDR_DIFF_VEC)\n-    return insn;\n-\n-  set = single_set (insn);\n-  extract_insn (insn);\n-\n-  /* If this insn loads a parameter from its stack slot, then\n-     it represents a savings, rather than a cost, if the\n-     parameter is stored in memory.  Record this fact.  */\n-\n-  if (set != 0 && REG_P (SET_DEST (set))\n-      && MEM_P (SET_SRC (set))\n-      && (note = find_reg_note (insn, REG_EQUIV,\n-\t\t\t\tNULL_RTX)) != 0\n-      && MEM_P (XEXP (note, 0)))\n-    {\n-      costs[REGNO (SET_DEST (set))].mem_cost\n-\t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n-\t\t\t      GENERAL_REGS, 1)\n-\t    * frequency);\n-      record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n-\t\t\t   0, MEM, SCRATCH, frequency * 2);\n-      return insn;\n-    }\n-\n-  record_operand_costs (insn, op_costs, reg_pref);\n-\n-  /* Now add the cost for each operand to the total costs for\n-     its register.  */\n-\n-  for (i = 0; i < recog_data.n_operands; i++)\n-    if (REG_P (recog_data.operand[i])\n-\t&& REGNO (recog_data.operand[i]) >= FIRST_PSEUDO_REGISTER)\n-      {\n-\tint regno = REGNO (recog_data.operand[i]);\n-\tstruct costs *p = &costs[regno], *q = &op_costs[i];\n-\n-\tp->mem_cost += q->mem_cost * frequency;\n-\tfor (j = 0; j < N_REG_CLASSES; j++)\n-\t  p->cost[j] += q->cost[j] * frequency;\n-      }\n-\n-  return insn;\n-}\n-\n-/* Initialize information about which register classes can be used for\n-   pseudos that are auto-incremented or auto-decremented.  */\n-\n-static void\n-init_reg_autoinc (void)\n-{\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-  int i;\n-\n-  memset (forbidden_inc_dec_class, 0, sizeof forbidden_inc_dec_class);\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    {\n-      rtx r = gen_rtx_raw_REG (VOIDmode, 0);\n-      enum machine_mode m;\n-      int j;\n-\n-      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n-\t  {\n-\t    SET_REGNO (r, j);\n-\n-\t    for (m = VOIDmode; (int) m < (int) MAX_MACHINE_MODE;\n-\t\t m = (enum machine_mode) ((int) m + 1))\n-\t      if (HARD_REGNO_MODE_OK (j, m))\n-\t\t{\n-\t\t  /* ??? There are two assumptions here; that the base class does not\n-\t\t     depend on the exact outer code (POST_INC vs. PRE_INC etc.), and\n-\t\t     that it does not depend on the machine mode of the memory\n-\t\t     reference.  */\n-\t\t  enum reg_class base_class\n-\t\t    = base_reg_class (VOIDmode, POST_INC, SCRATCH);\n-\n-\t\t  PUT_MODE (r, m);\n-\n-\t\t  /* If a register is not directly suitable for an\n-\t\t     auto-increment or decrement addressing mode and\n-\t\t     requires secondary reloads, disallow its class from\n-\t\t     being used in such addresses.  */\n-\n-\t\t  if ((secondary_reload_class (0, base_class, m, r)\n-\t\t       || secondary_reload_class (1, base_class, m, r))\n-\t\t      && ! auto_inc_dec_reg_p (r, m))\n-\t\t    forbidden_inc_dec_class[i] = 1;\n-\t\t}\n-\t  }\n-    }\n-#endif /* FORBIDDEN_INC_DEC_CLASSES */\n-}\n-\n-/* This is a pass of the compiler that scans all instructions\n-   and calculates the preferred class for each pseudo-register.\n-   This information can be accessed later by calling `reg_preferred_class'.\n-   This pass comes just before local register allocation.  */\n-\n-void\n-regclass (rtx f, int nregs)\n-{\n-  rtx insn;\n-  int i;\n-  int pass;\n-  max_regno = max_reg_num ();\n-\n-  init_recog ();\n-\n-  reg_renumber = XNEWVEC (short, max_regno);\n-  reg_pref = XCNEWVEC (struct reg_pref, max_regno);\n-  memset (reg_renumber, -1, max_regno * sizeof (short));\n-\n-  costs = XNEWVEC (struct costs, nregs);\n-\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-\n-  in_inc_dec = XNEWVEC (char, nregs);\n-\n-#endif /* FORBIDDEN_INC_DEC_CLASSES */\n-\n-  /* Normally we scan the insns once and determine the best class to use for\n-     each register.  However, if -fexpensive_optimizations are on, we do so\n-     twice, the second time using the tentative best classes to guide the\n-     selection.  */\n-\n-  for (pass = 0; pass <= flag_expensive_optimizations; pass++)\n-    {\n-      basic_block bb;\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\n\\nPass %i\\n\\n\",pass);\n-      /* Zero out our accumulation of the cost of each class for each reg.  */\n-\n-      memset (costs, 0, nregs * sizeof (struct costs));\n-\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-      memset (in_inc_dec, 0, nregs);\n-#endif\n-\n-      /* Scan the instructions and record each time it would\n-\t save code to put a certain register in a certain class.  */\n-\n-      if (!optimize)\n-\t{\n-\t  frequency = REG_FREQ_MAX;\n-\t  for (insn = f; insn; insn = NEXT_INSN (insn))\n-\t    insn = scan_one_insn (insn, pass);\n-\t}\n-      else\n-\tFOR_EACH_BB (bb)\n-\t  {\n-\t    /* Show that an insn inside a loop is likely to be executed three\n-\t       times more than insns outside a loop.  This is much more\n-\t       aggressive than the assumptions made elsewhere and is being\n-\t       tried as an experiment.  */\n-\t    frequency = REG_FREQ_FROM_BB (bb);\n-\t    for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n-\t      {\n-\t\tinsn = scan_one_insn (insn, pass);\n-\t\tif (insn == BB_END (bb))\n-\t\t  break;\n-\t      }\n-\t  }\n-\n-      /* Now for each register look at how desirable each class is\n-\t and find which class is preferred.  Store that in\n-\t `prefclass'.  Record in `altclass' the largest register\n-\t class any of whose registers is better than memory.  */\n-\n-      if (dump_file)\n-\t{\n-\t  dump_regclass (dump_file);\n-\t  fprintf (dump_file,\"\\n\");\n-\t}\n-      for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n-\t{\n-\t  int best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n-\t  enum reg_class best = ALL_REGS, alt = NO_REGS;\n-\t  /* This is an enum reg_class, but we call it an int\n-\t     to save lots of casts.  */\n-\t  int rclass;\n-\t  struct costs *p = &costs[i];\n-\n-\t  if (regno_reg_rtx[i] == NULL)\n-\t    continue;\n-\n-\t  /* In non-optimizing compilation REG_N_REFS is not initialized\n-\t     yet.  */\n-\t  if (optimize && !REG_N_REFS (i) && !REG_N_SETS (i))\n-\t    continue;\n-\n-\t  for (rclass = (int) ALL_REGS - 1; rclass > 0; rclass--)\n-\t    {\n-\t      /* Ignore classes that are too small for this operand or\n-\t\t invalid for an operand that was auto-incremented.  */\n-\t      if (!contains_reg_of_mode [rclass][PSEUDO_REGNO_MODE (i)]\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[rclass])\n-#endif\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass,\n-\t\t\t\t\t    PSEUDO_REGNO_MODE (i))\n-#endif\n-\t\t  )\n-\t\t;\n-\t      else if (p->cost[rclass] < best_cost)\n-\t\t{\n-\t\t  best_cost = p->cost[rclass];\n-\t\t  best = (enum reg_class) rclass;\n-\t\t}\n-\t      else if (p->cost[rclass] == best_cost)\n-\t\tbest = reg_class_subunion[(int) best][rclass];\n-\t    }\n-\n-\t  /* If no register class is better than memory, use memory. */\n-\t  if (p->mem_cost < best_cost)\n-\t    best = NO_REGS;\n-\n-\t  /* Record the alternate register class; i.e., a class for which\n-\t     every register in it is better than using memory.  If adding a\n-\t     class would make a smaller class (i.e., no union of just those\n-\t     classes exists), skip that class.  The major unions of classes\n-\t     should be provided as a register class.  Don't do this if we\n-\t     will be doing it again later.  */\n-\n-\t  if ((pass == 1  || dump_file) || ! flag_expensive_optimizations)\n-\t    for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t      if (p->cost[rclass] < p->mem_cost\n-\t\t  && (reg_class_size[(int) reg_class_subunion[(int) alt][rclass]]\n-\t\t      > reg_class_size[(int) alt])\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t\t  && ! (in_inc_dec[i] && forbidden_inc_dec_class[rclass])\n-#endif\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t  && ! invalid_mode_change_p (i, (enum reg_class) rclass,\n-\t\t\t\t\t      PSEUDO_REGNO_MODE (i))\n-#endif\n-\t\t  )\n-\t\talt = reg_class_subunion[(int) alt][rclass];\n-\n-\t  /* If we don't add any classes, nothing to try.  */\n-\t  if (alt == best)\n-\t    alt = NO_REGS;\n-\n-\t  if (dump_file\n-\t      && (reg_pref[i].prefclass != (int) best\n-\t\t  || reg_pref[i].altclass != (int) alt))\n-\t    {\n-\t      fprintf (dump_file, \"  Register %i\", i);\n-\t      if (alt == ALL_REGS || best == ALL_REGS)\n-\t\tfprintf (dump_file, \" pref %s\\n\", reg_class_names[(int) best]);\n-\t      else if (alt == NO_REGS)\n-\t\tfprintf (dump_file, \" pref %s or none\\n\", reg_class_names[(int) best]);\n-\t      else\n-\t\tfprintf (dump_file, \" pref %s, else %s\\n\",\n-\t\t\t reg_class_names[(int) best],\n-\t\t\t reg_class_names[(int) alt]);\n-\t    }\n-\n-\t  /* We cast to (int) because (char) hits bugs in some compilers.  */\n-\t  reg_pref[i].prefclass = (int) best;\n-\t  reg_pref[i].altclass = (int) alt;\n-\t}\n-    }\n-\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-  free (in_inc_dec);\n-#endif\n-  free (costs);\n-}\n-\f\n-/* Record the cost of using memory or registers of various classes for\n-   the operands in INSN.\n-\n-   N_ALTS is the number of alternatives.\n-\n-   N_OPS is the number of operands.\n-\n-   OPS is an array of the operands.\n-\n-   MODES are the modes of the operands, in case any are VOIDmode.\n-\n-   CONSTRAINTS are the constraints to use for the operands.  This array\n-   is modified by this procedure.\n-\n-   This procedure works alternative by alternative.  For each alternative\n-   we assume that we will be able to allocate all pseudos to their ideal\n-   register class and calculate the cost of using that alternative.  Then\n-   we compute for each operand that is a pseudo-register, the cost of\n-   having the pseudo allocated to each register class and using it in that\n-   alternative.  To this cost is added the cost of the alternative.\n-\n-   The cost of each class for this insn is its lowest cost among all the\n-   alternatives.  */\n-\n-static void\n-record_reg_classes (int n_alts, int n_ops, rtx *ops,\n-\t\t    enum machine_mode *modes, const char **constraints,\n-\t\t    rtx insn, struct costs *op_costs,\n-\t\t    struct reg_pref *reg_pref)\n-{\n-  int alt;\n-  int i, j;\n-  rtx set;\n-\n-  /* Process each alternative, each time minimizing an operand's cost with\n-     the cost for each operand in that alternative.  */\n-\n-  for (alt = 0; alt < n_alts; alt++)\n-    {\n-      struct costs this_op_costs[MAX_RECOG_OPERANDS];\n-      int alt_fail = 0;\n-      int alt_cost = 0;\n-      enum reg_class classes[MAX_RECOG_OPERANDS];\n-      int allows_mem[MAX_RECOG_OPERANDS];\n-      int rclass;\n-\n-      for (i = 0; i < n_ops; i++)\n-\t{\n-\t  const char *p = constraints[i];\n-\t  rtx op = ops[i];\n-\t  enum machine_mode mode = modes[i];\n-\t  int allows_addr = 0;\n-\t  int win = 0;\n-\t  unsigned char c;\n-\n-\t  /* Initially show we know nothing about the register class.  */\n-\t  classes[i] = NO_REGS;\n-\t  allows_mem[i] = 0;\n-\n-\t  /* If this operand has no constraints at all, we can conclude\n-\t     nothing about it since anything is valid.  */\n-\n-\t  if (*p == 0)\n-\t    {\n-\t      if (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\tmemset (&this_op_costs[i], 0, sizeof this_op_costs[i]);\n-\n-\t      continue;\n-\t    }\n-\n-\t  /* If this alternative is only relevant when this operand\n-\t     matches a previous operand, we do different things depending\n-\t     on whether this operand is a pseudo-reg or not.  We must process\n-\t     any modifiers for the operand before we can make this test.  */\n-\n-\t  while (*p == '%' || *p == '=' || *p == '+' || *p == '&')\n-\t    p++;\n-\n-\t  if (p[0] >= '0' && p[0] <= '0' + i && (p[1] == ',' || p[1] == 0))\n-\t    {\n-\t      /* Copy class and whether memory is allowed from the matching\n-\t\t alternative.  Then perform any needed cost computations\n-\t\t and/or adjustments.  */\n-\t      j = p[0] - '0';\n-\t      classes[i] = classes[j];\n-\t      allows_mem[i] = allows_mem[j];\n-\n-\t      if (!REG_P (op) || REGNO (op) < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  /* If this matches the other operand, we have no added\n-\t\t     cost and we win.  */\n-\t\t  if (rtx_equal_p (ops[j], op))\n-\t\t    win = 1;\n-\n-\t\t  /* If we can put the other operand into a register, add to\n-\t\t     the cost of this alternative the cost to copy this\n-\t\t     operand to the register used for the other operand.  */\n-\n-\t\t  else if (classes[j] != NO_REGS)\n-\t\t    {\n-\t\t      alt_cost += copy_cost (op, mode, classes[j], 1, NULL);\n-\t\t      win = 1;\n-\t\t    }\n-\t\t}\n-\t      else if (!REG_P (ops[j])\n-\t\t       || REGNO (ops[j]) < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  /* This op is a pseudo but the one it matches is not.  */\n-\n-\t\t  /* If we can't put the other operand into a register, this\n-\t\t     alternative can't be used.  */\n-\n-\t\t  if (classes[j] == NO_REGS)\n-\t\t    alt_fail = 1;\n-\n-\t\t  /* Otherwise, add to the cost of this alternative the cost\n-\t\t     to copy the other operand to the register used for this\n-\t\t     operand.  */\n-\n-\t\t  else\n-\t\t    alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* The costs of this operand are not the same as the other\n-\t\t     operand since move costs are not symmetric.  Moreover,\n-\t\t     if we cannot tie them, this alternative needs to do a\n-\t\t     copy, which is one instruction.  */\n-\n-\t\t  struct costs *pp = &this_op_costs[i];\n-\t\t  move_table *intable = NULL;\n-\t\t  move_table *outtable = NULL;\n-\t\t  int op_class = (int) classes[i];\n-\n-\t\t  if (!move_cost[mode])\n-\t\t    init_move_cost (mode);\n-\t\t  intable = may_move_in_cost[mode];\n-\t\t  outtable = may_move_out_cost[mode];\n-\n-\t\t  /* The loop is performance critical, so unswitch it manually.\n-\t\t   */\n-\t\t  switch (recog_data.operand_type[i])\n-\t\t    {\n-\t\t    case OP_INOUT:\n-\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t\t\tpp->cost[rclass] = (intable[rclass][op_class]\n-\t\t\t\t\t   + outtable[op_class][rclass]);\n-\t\t      break;\n-\t\t    case OP_IN:\n-\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t\t\tpp->cost[rclass] = intable[rclass][op_class];\n-\t\t      break;\n-\t\t    case OP_OUT:\n-\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t\t\tpp->cost[rclass] = outtable[op_class][rclass];\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* If the alternative actually allows memory, make things\n-\t\t     a bit cheaper since we won't need an extra insn to\n-\t\t     load it.  */\n-\n-\t\t  pp->mem_cost\n-\t\t    = ((recog_data.operand_type[i] != OP_IN\n-\t\t        ? MEMORY_MOVE_COST (mode, classes[i], 0)\n-\t\t\t: 0)\n-\t\t       + (recog_data.operand_type[i] != OP_OUT\n-\t\t\t  ? MEMORY_MOVE_COST (mode, classes[i], 1)\n-\t\t\t  : 0) - allows_mem[i]);\n-\n-\t\t  /* If we have assigned a class to this register in our\n-\t\t     first pass, add a cost to this alternative corresponding\n-\t\t     to what we would add if this register were not in the\n-\t\t     appropriate class.  */\n-\n-\t\t  if (reg_pref && reg_pref[REGNO (op)].prefclass != NO_REGS)\n-\t\t    alt_cost\n-\t\t      += (may_move_in_cost[mode]\n-\t\t\t  [(unsigned char) reg_pref[REGNO (op)].prefclass]\n-\t\t\t  [(int) classes[i]]);\n-\n-\t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n-\t\t      && ! find_reg_note (insn, REG_DEAD, op))\n-\t\t    alt_cost += 2;\n-\n-\t\t  /* This is in place of ordinary cost computation\n-\t\t     for this operand, so skip to the end of the\n-\t\t     alternative (should be just one character).  */\n-\t\t  while (*p && *p++ != ',')\n-\t\t    ;\n-\n-\t\t  constraints[i] = p;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  /* Scan all the constraint letters.  See if the operand matches\n-\t     any of the constraints.  Collect the valid register classes\n-\t     and see if this operand accepts memory.  */\n-\n-\t  while ((c = *p))\n-\t    {\n-\t      switch (c)\n-\t\t{\n-\t\tcase ',':\n-\t\t  break;\n-\t\tcase '*':\n-\t\t  /* Ignore the next letter for this pass.  */\n-\t\t  c = *++p;\n-\t\t  break;\n-\n-\t\tcase '?':\n-\t\t  alt_cost += 2;\n-\t\tcase '!':  case '#':  case '&':\n-\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n-\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n-\t\t  break;\n-\n-\t\tcase 'p':\n-\t\t  allows_addr = 1;\n-\t\t  win = address_operand (op, GET_MODE (op));\n-\t\t  /* We know this operand is an address, so we want it to be\n-\t\t     allocated to a register that can be the base of an\n-\t\t     address, i.e. BASE_REG_CLASS.  */\n-\t\t  classes[i]\n-\t\t    = reg_class_subunion[(int) classes[i]]\n-\t\t    [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n-\t\t  break;\n-\n-\t\tcase TARGET_MEM_CONSTRAINT:  case 'o':  case 'V':\n-\t\t  /* It doesn't seem worth distinguishing between offsettable\n-\t\t     and non-offsettable addresses here.  */\n-\t\t  allows_mem[i] = 1;\n-\t\t  if (MEM_P (op))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase '<':\n-\t\t  if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase '>':\n-\t\t  if (MEM_P (op)\n-\t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'E':\n-\t\tcase 'F':\n-\t\t  if (GET_CODE (op) == CONST_DOUBLE\n-\t\t      || (GET_CODE (op) == CONST_VECTOR\n-\t\t\t  && (GET_MODE_CLASS (GET_MODE (op))\n-\t\t\t      == MODE_VECTOR_FLOAT)))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'G':\n-\t\tcase 'H':\n-\t\t  if (GET_CODE (op) == CONST_DOUBLE\n-\t\t      && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, c, p))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 's':\n-\t\t  if (GET_CODE (op) == CONST_INT\n-\t\t      || (GET_CODE (op) == CONST_DOUBLE\n-\t\t\t  && GET_MODE (op) == VOIDmode))\n-\t\t    break;\n-\t\tcase 'i':\n-\t\t  if (CONSTANT_P (op)\n-\t\t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op)))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'n':\n-\t\t  if (GET_CODE (op) == CONST_INT\n-\t\t      || (GET_CODE (op) == CONST_DOUBLE\n-\t\t\t  && GET_MODE (op) == VOIDmode))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'I':\n-\t\tcase 'J':\n-\t\tcase 'K':\n-\t\tcase 'L':\n-\t\tcase 'M':\n-\t\tcase 'N':\n-\t\tcase 'O':\n-\t\tcase 'P':\n-\t\t  if (GET_CODE (op) == CONST_INT\n-\t\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n-\t\t    win = 1;\n-\t\t  break;\n-\n-\t\tcase 'X':\n-\t\t  win = 1;\n-\t\t  break;\n-\n-\t\tcase 'g':\n-\t\t  if (MEM_P (op)\n-\t\t      || (CONSTANT_P (op)\n-\t\t\t  && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))))\n-\t\t    win = 1;\n-\t\t  allows_mem[i] = 1;\n-\t\tcase 'r':\n-\t\t  classes[i]\n-\t\t    = reg_class_subunion[(int) classes[i]][(int) GENERAL_REGS];\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) != NO_REGS)\n-\t\t    classes[i]\n-\t\t      = reg_class_subunion[(int) classes[i]]\n-\t\t\t[(int) REG_CLASS_FROM_CONSTRAINT (c, p)];\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n-\t\t    win = 1;\n-\n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t    {\n-\t\t      /* Every MEM can be reloaded to fit.  */\n-\t\t      allows_mem[i] = 1;\n-\t\t      if (MEM_P (op))\n-\t\t\twin = 1;\n-\t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t    {\n-\t\t      /* Every address can be reloaded to fit.  */\n-\t\t      allows_addr = 1;\n-\t\t      if (address_operand (op, GET_MODE (op)))\n-\t\t\twin = 1;\n-\t\t      /* We know this operand is an address, so we want it to\n-\t\t\t be allocated to a register that can be the base of an\n-\t\t\t address, i.e. BASE_REG_CLASS.  */\n-\t\t      classes[i]\n-\t\t\t= reg_class_subunion[(int) classes[i]]\n-\t\t\t[(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n-\t\t    }\n-#endif\n-\t\t  break;\n-\t\t}\n-\t      p += CONSTRAINT_LEN (c, p);\n-\t      if (c == ',')\n-\t\tbreak;\n-\t    }\n-\n-\t  constraints[i] = p;\n-\n-\t  /* How we account for this operand now depends on whether it is  a\n-\t     pseudo register or not.  If it is, we first check if any\n-\t     register classes are valid.  If not, we ignore this alternative,\n-\t     since we want to assume that all pseudos get allocated for\n-\t     register preferencing.  If some register class is valid, compute\n-\t     the costs of moving the pseudo into that class.  */\n-\n-\t  if (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      if (classes[i] == NO_REGS)\n-\t\t{\n-\t\t  /* We must always fail if the operand is a REG, but\n-\t\t     we did not find a suitable class.\n-\n-\t\t     Otherwise we may perform an uninitialized read\n-\t\t     from this_op_costs after the `continue' statement\n-\t\t     below.  */\n-\t\t  alt_fail = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  struct costs *pp = &this_op_costs[i];\n-\t\t  move_table *intable = NULL;\n-\t\t  move_table *outtable = NULL;\n-\t\t  int op_class = (int) classes[i];\n-\n-\t\t  if (!move_cost[mode])\n-\t\t    init_move_cost (mode);\n-\t\t  intable = may_move_in_cost[mode];\n-\t\t  outtable = may_move_out_cost[mode];\n-\n-\t\t  /* The loop is performance critical, so unswitch it manually.\n-\t\t   */\n-\t\t  switch (recog_data.operand_type[i])\n-\t\t    {\n-\t\t    case OP_INOUT:\n-\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t\t\tpp->cost[rclass] = (intable[rclass][op_class]\n-\t\t\t\t\t   + outtable[op_class][rclass]);\n-\t\t      break;\n-\t\t    case OP_IN:\n-\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t\t\tpp->cost[rclass] = intable[rclass][op_class];\n-\t\t      break;\n-\t\t    case OP_OUT:\n-\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t\t\tpp->cost[rclass] = outtable[op_class][rclass];\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* If the alternative actually allows memory, make things\n-\t\t     a bit cheaper since we won't need an extra insn to\n-\t\t     load it.  */\n-\n-\t\t  pp->mem_cost\n-\t\t    = ((recog_data.operand_type[i] != OP_IN\n-\t\t        ? MEMORY_MOVE_COST (mode, classes[i], 0)\n-\t\t\t: 0)\n-\t\t       + (recog_data.operand_type[i] != OP_OUT\n-\t\t\t  ? MEMORY_MOVE_COST (mode, classes[i], 1)\n-\t\t\t  : 0) - allows_mem[i]);\n-\n-\t\t  /* If we have assigned a class to this register in our\n-\t\t     first pass, add a cost to this alternative corresponding\n-\t\t     to what we would add if this register were not in the\n-\t\t     appropriate class.  */\n-\n-\t\t  if (reg_pref && reg_pref[REGNO (op)].prefclass != NO_REGS)\n-\t\t    alt_cost\n-\t\t      += (may_move_in_cost[mode]\n-\t\t\t  [(unsigned char) reg_pref[REGNO (op)].prefclass]\n-\t\t\t  [(int) classes[i]]);\n-\t\t}\n-\t    }\n-\n-\t  /* Otherwise, if this alternative wins, either because we\n-\t     have already determined that or if we have a hard register of\n-\t     the proper class, there is no cost for this alternative.  */\n-\n-\t  else if (win\n-\t\t   || (REG_P (op)\n-\t\t       && reg_fits_class_p (op, classes[i], 0, GET_MODE (op))))\n-\t    ;\n-\n-\t  /* If registers are valid, the cost of this alternative includes\n-\t     copying the object to and/or from a register.  */\n-\n-\t  else if (classes[i] != NO_REGS)\n-\t    {\n-\t      if (recog_data.operand_type[i] != OP_OUT)\n-\t\talt_cost += copy_cost (op, mode, classes[i], 1, NULL);\n-\n-\t      if (recog_data.operand_type[i] != OP_IN)\n-\t\talt_cost += copy_cost (op, mode, classes[i], 0, NULL);\n-\t    }\n-\n-\t  /* The only other way this alternative can be used is if this is a\n-\t     constant that could be placed into memory.  */\n-\n-\t  else if (CONSTANT_P (op) && (allows_addr || allows_mem[i]))\n-\t    alt_cost += MEMORY_MOVE_COST (mode, classes[i], 1);\n-\t  else\n-\t    alt_fail = 1;\n-\t}\n-\n-      if (alt_fail)\n-\tcontinue;\n-\n-      if (!recog_data.alternative_enabled_p[alt])\n-\tcontinue;\n-\n-      /* Finally, update the costs with the information we've calculated\n-\t about this alternative.  */\n-\n-      for (i = 0; i < n_ops; i++)\n-\tif (REG_P (ops[i])\n-\t    && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    struct costs *pp = &op_costs[i], *qq = &this_op_costs[i];\n-\t    int scale = 1 + (recog_data.operand_type[i] == OP_INOUT);\n-\n-\t    pp->mem_cost = MIN (pp->mem_cost,\n-\t\t\t\t(qq->mem_cost + alt_cost) * scale);\n-\n-\t    for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t      pp->cost[rclass] = MIN (pp->cost[rclass],\n-\t\t\t\t     (qq->cost[rclass] + alt_cost) * scale);\n-\t  }\n-    }\n-\n-  /* If this insn is a single set copying operand 1 to operand 0\n-     and one operand is a pseudo with the other a hard reg or a pseudo\n-     that prefers a register that is in its own register class then\n-     we may want to adjust the cost of that register class to -1.\n-\n-     Avoid the adjustment if the source does not die to avoid stressing of\n-     register allocator by preferencing two colliding registers into single\n-     class.\n-\n-     Also avoid the adjustment if a copy between registers of the class\n-     is expensive (ten times the cost of a default copy is considered\n-     arbitrarily expensive).  This avoids losing when the preferred class\n-     is very expensive as the source of a copy instruction.  */\n-\n-  if ((set = single_set (insn)) != 0\n-      && ops[0] == SET_DEST (set) && ops[1] == SET_SRC (set)\n-      && REG_P (ops[0]) && REG_P (ops[1])\n-      && find_regno_note (insn, REG_DEAD, REGNO (ops[1])))\n-    for (i = 0; i <= 1; i++)\n-      if (REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  unsigned int regno = REGNO (ops[!i]);\n-\t  enum machine_mode mode = GET_MODE (ops[!i]);\n-\t  int rclass;\n-\n-\t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0\n-\t      && reg_pref[regno].prefclass != NO_REGS)\n-\t    {\n-\t      enum reg_class pref = reg_pref[regno].prefclass;\n-\n-\t      if ((reg_class_size[(unsigned char) pref]\n-\t\t   == (unsigned) CLASS_MAX_NREGS (pref, mode))\n-\t\t  && REGISTER_MOVE_COST (mode, pref, pref) < 10 * 2)\n-\t\top_costs[i].cost[(unsigned char) pref] = -1;\n-\t    }\n-\t  else if (regno < FIRST_PSEUDO_REGISTER)\n-\t    for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno)\n-\t\t  && reg_class_size[rclass] == (unsigned) CLASS_MAX_NREGS (rclass, mode))\n-\t\t{\n-\t\t  if (reg_class_size[rclass] == 1)\n-\t\t    op_costs[i].cost[rclass] = -1;\n-\t\t  else if (in_hard_reg_set_p (reg_class_contents[rclass],\n-\t\t\t\t\t     mode, regno))\n-\t\t    op_costs[i].cost[rclass] = -1;\n-\t\t}\n-\t}\n-}\n-\f\n-/* Compute the cost of loading X into (if TO_P is nonzero) or from (if\n-   TO_P is zero) a register of class CLASS in mode MODE.\n-\n-   X must not be a pseudo.  */\n-\n-static int\n-copy_cost (rtx x, enum machine_mode mode, enum reg_class rclass, int to_p,\n-\t   secondary_reload_info *prev_sri)\n-{\n-  enum reg_class secondary_class = NO_REGS;\n-  secondary_reload_info sri;\n-\n-  /* If X is a SCRATCH, there is actually nothing to move since we are\n-     assuming optimal allocation.  */\n-\n-  if (GET_CODE (x) == SCRATCH)\n-    return 0;\n-\n-  /* Get the class we will actually use for a reload.  */\n-  rclass = PREFERRED_RELOAD_CLASS (x, rclass);\n-\n-  /* If we need a secondary reload for an intermediate, the\n-     cost is that to load the input into the intermediate register, then\n-     to copy it.  */\n-\n-  sri.prev_sri = prev_sri;\n-  sri.extra_cost = 0;\n-  secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n-\n-  if (!move_cost[mode])\n-    init_move_cost (mode);\n-\n-  if (secondary_class != NO_REGS)\n-    return (move_cost[mode][(int) secondary_class][(int) rclass]\n-\t    + sri.extra_cost\n-\t    + copy_cost (x, mode, secondary_class, to_p, &sri));\n-\n-  /* For memory, use the memory move cost, for (hard) registers, use the\n-     cost to move between the register classes, and use 2 for everything\n-     else (constants).  */\n-\n-  if (MEM_P (x) || rclass == NO_REGS)\n-    return sri.extra_cost + MEMORY_MOVE_COST (mode, rclass, to_p);\n-\n-  else if (REG_P (x))\n-    return (sri.extra_cost\n-\t    + move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) rclass]);\n-\n-  else\n-    /* If this is a constant, we may eventually want to call rtx_cost here.  */\n-    return sri.extra_cost + COSTS_N_INSNS (1);\n-}\n-\f\n-/* Record the pseudo registers we must reload into hard registers\n-   in a subexpression of a memory address, X.\n-\n-   If CONTEXT is 0, we are looking at the base part of an address, otherwise we\n-   are looking at the index part.\n-\n-   MODE is the mode of the memory reference; OUTER_CODE and INDEX_CODE\n-   give the context that the rtx appears in.  These three arguments are\n-   passed down to base_reg_class.\n-\n-   SCALE is twice the amount to multiply the cost by (it is twice so we\n-   can represent half-cost adjustments).  */\n-\n-static void\n-record_address_regs (enum machine_mode mode, rtx x, int context,\n-\t\t     enum rtx_code outer_code, enum rtx_code index_code,\n-\t\t     int scale)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  enum reg_class rclass;\n-\n-  if (context == 1)\n-    rclass = INDEX_REG_CLASS;\n-  else\n-    rclass = base_reg_class (mode, outer_code, index_code);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST:\n-    case CC0:\n-    case PC:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return;\n-\n-    case PLUS:\n-      /* When we have an address that is a sum,\n-\t we must determine whether registers are \"base\" or \"index\" regs.\n-\t If there is a sum of two registers, we must choose one to be\n-\t the \"base\".  Luckily, we can use the REG_POINTER to make a good\n-\t choice most of the time.  We only need to do this on machines\n-\t that can have two registers in an address and where the base\n-\t and index register classes are different.\n-\n-\t ??? This code used to set REGNO_POINTER_FLAG in some cases, but\n-\t that seems bogus since it should only be set when we are sure\n-\t the register is being used as a pointer.  */\n-\n-      {\n-\trtx arg0 = XEXP (x, 0);\n-\trtx arg1 = XEXP (x, 1);\n-\tenum rtx_code code0 = GET_CODE (arg0);\n-\tenum rtx_code code1 = GET_CODE (arg1);\n-\n-\t/* Look inside subregs.  */\n-\tif (code0 == SUBREG)\n-\t  arg0 = SUBREG_REG (arg0), code0 = GET_CODE (arg0);\n-\tif (code1 == SUBREG)\n-\t  arg1 = SUBREG_REG (arg1), code1 = GET_CODE (arg1);\n-\n-\t/* If this machine only allows one register per address, it must\n-\t   be in the first operand.  */\n-\n-\tif (MAX_REGS_PER_ADDRESS == 1)\n-\t  record_address_regs (mode, arg0, 0, PLUS, code1, scale);\n-\n-\t/* If index and base registers are the same on this machine, just\n-\t   record registers in any non-constant operands.  We assume here,\n-\t   as well as in the tests below, that all addresses are in\n-\t   canonical form.  */\n-\n-\telse if (INDEX_REG_CLASS == base_reg_class (VOIDmode, PLUS, SCRATCH))\n-\t  {\n-\t    record_address_regs (mode, arg0, context, PLUS, code1, scale);\n-\t    if (! CONSTANT_P (arg1))\n-\t      record_address_regs (mode, arg1, context, PLUS, code0, scale);\n-\t  }\n-\n-\t/* If the second operand is a constant integer, it doesn't change\n-\t   what class the first operand must be.  */\n-\n-\telse if (code1 == CONST_INT || code1 == CONST_DOUBLE)\n-\t  record_address_regs (mode, arg0, context, PLUS, code1, scale);\n-\n-\t/* If the second operand is a symbolic constant, the first operand\n-\t   must be an index register.  */\n-\n-\telse if (code1 == SYMBOL_REF || code1 == CONST || code1 == LABEL_REF)\n-\t  record_address_regs (mode, arg0, 1, PLUS, code1, scale);\n-\n-\t/* If both operands are registers but one is already a hard register\n-\t   of index or reg-base class, give the other the class that the\n-\t   hard register is not.  */\n-\n-\telse if (code0 == REG && code1 == REG\n-\t\t && REGNO (arg0) < FIRST_PSEUDO_REGISTER\n-\t\t && (ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)\n-\t\t     || ok_for_index_p_nonstrict (arg0)))\n-\t  record_address_regs (mode, arg1,\n-\t\t\t       ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)\n-\t\t\t       ? 1 : 0,\n-\t\t\t       PLUS, REG, scale);\n-\telse if (code0 == REG && code1 == REG\n-\t\t && REGNO (arg1) < FIRST_PSEUDO_REGISTER\n-\t\t && (ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)\n-\t\t     || ok_for_index_p_nonstrict (arg1)))\n-\t  record_address_regs (mode, arg0,\n-\t\t\t       ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)\n-\t\t\t       ? 1 : 0,\n-\t\t\t       PLUS, REG, scale);\n-\n-\t/* If one operand is known to be a pointer, it must be the base\n-\t   with the other operand the index.  Likewise if the other operand\n-\t   is a MULT.  */\n-\n-\telse if ((code0 == REG && REG_POINTER (arg0))\n-\t\t || code1 == MULT)\n-\t  {\n-\t    record_address_regs (mode, arg0, 0, PLUS, code1, scale);\n-\t    record_address_regs (mode, arg1, 1, PLUS, code0, scale);\n-\t  }\n-\telse if ((code1 == REG && REG_POINTER (arg1))\n-\t\t || code0 == MULT)\n-\t  {\n-\t    record_address_regs (mode, arg0, 1, PLUS, code1, scale);\n-\t    record_address_regs (mode, arg1, 0, PLUS, code0, scale);\n-\t  }\n-\n-\t/* Otherwise, count equal chances that each might be a base\n-\t   or index register.  This case should be rare.  */\n-\n-\telse\n-\t  {\n-\t    record_address_regs (mode, arg0, 0, PLUS, code1, scale / 2);\n-\t    record_address_regs (mode, arg0, 1, PLUS, code1, scale / 2);\n-\t    record_address_regs (mode, arg1, 0, PLUS, code0, scale / 2);\n-\t    record_address_regs (mode, arg1, 1, PLUS, code0, scale / 2);\n-\t  }\n-      }\n-      break;\n-\n-      /* Double the importance of a pseudo register that is incremented\n-\t or decremented, since it would take two extra insns\n-\t if it ends up in the wrong place.  */\n-    case POST_MODIFY:\n-    case PRE_MODIFY:\n-      record_address_regs (mode, XEXP (x, 0), 0, code,\n-\t\t\t   GET_CODE (XEXP (XEXP (x, 1), 1)), 2 * scale);\n-      if (REG_P (XEXP (XEXP (x, 1), 1)))\n-\trecord_address_regs (mode, XEXP (XEXP (x, 1), 1), 1, code, REG,\n-\t\t\t     2 * scale);\n-      break;\n-\n-    case POST_INC:\n-    case PRE_INC:\n-    case POST_DEC:\n-    case PRE_DEC:\n-      /* Double the importance of a pseudo register that is incremented\n-\t or decremented, since it would take two extra insns\n-\t if it ends up in the wrong place.  If the operand is a pseudo,\n-\t show it is being used in an INC_DEC context.  */\n-\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-      if (REG_P (XEXP (x, 0))\n-\t  && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER)\n-\tin_inc_dec[REGNO (XEXP (x, 0))] = 1;\n-#endif\n-\n-      record_address_regs (mode, XEXP (x, 0), 0, code, SCRATCH, 2 * scale);\n-      break;\n-\n-    case REG:\n-      {\n-\tstruct costs *pp = &costs[REGNO (x)];\n-\tint i;\n-\n-\tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, rclass, 1) * scale) / 2;\n-\n-\tif (!move_cost[Pmode])\n-\t  init_move_cost (Pmode);\n-\tfor (i = 0; i < N_REG_CLASSES; i++)\n-\t  pp->cost[i] += (may_move_in_cost[Pmode][i][(int) rclass] * scale) / 2;\n-      }\n-      break;\n-\n-    default:\n-      {\n-\tconst char *fmt = GET_RTX_FORMAT (code);\n-\tint i;\n-\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t  if (fmt[i] == 'e')\n-\t    record_address_regs (mode, XEXP (x, i), context, code, SCRATCH,\n-\t\t\t\t scale);\n-      }\n-    }\n-}\n-\f\n-#ifdef FORBIDDEN_INC_DEC_CLASSES\n-\n-/* Return 1 if REG is valid as an auto-increment memory reference\n-   to an object of MODE.  */\n-\n-static int\n-auto_inc_dec_reg_p (rtx reg, enum machine_mode mode)\n-{\n-  if (HAVE_POST_INCREMENT\n-      && memory_address_p (mode, gen_rtx_POST_INC (Pmode, reg)))\n-    return 1;\n-\n-  if (HAVE_POST_DECREMENT\n-      && memory_address_p (mode, gen_rtx_POST_DEC (Pmode, reg)))\n-    return 1;\n-\n-  if (HAVE_PRE_INCREMENT\n-      && memory_address_p (mode, gen_rtx_PRE_INC (Pmode, reg)))\n-    return 1;\n-\n-  if (HAVE_PRE_DECREMENT\n-      && memory_address_p (mode, gen_rtx_PRE_DEC (Pmode, reg)))\n-    return 1;\n-\n-  return 0;\n-}\n-#endif\n \f\n \n /* Allocate space for reg info.  */\n@@ -2383,6 +1019,8 @@ setup_reg_classes (int regno,\n    again just before loop.  It finds the first and last use of each\n    pseudo-register.  */\n \n+static void reg_scan_mark_refs (rtx, rtx);\n+\n void\n reg_scan (rtx f, unsigned int nregs ATTRIBUTE_UNUSED)\n {\n@@ -2406,7 +1044,6 @@ reg_scan (rtx f, unsigned int nregs ATTRIBUTE_UNUSED)\n    NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.\n    We should only record information for REGs with numbers\n    greater than or equal to MIN_REGNO.  */\n-\n static void\n reg_scan_mark_refs (rtx x, rtx insn)\n {\n@@ -2541,9 +1178,9 @@ reg_scan_mark_refs (rtx x, rtx insn)\n     }\n }\n \f\n+\n /* Return nonzero if C1 is a subset of C2, i.e., if every register in C1\n    is also in C2.  */\n-\n int\n reg_class_subset_p (enum reg_class c1, enum reg_class c2)\n {\n@@ -2554,7 +1191,6 @@ reg_class_subset_p (enum reg_class c1, enum reg_class c2)\n }\n \n /* Return nonzero if there is a register that is in both C1 and C2.  */\n-\n int\n reg_classes_intersect_p (enum reg_class c1, enum reg_class c2)\n {\n@@ -2565,6 +1201,11 @@ reg_classes_intersect_p (enum reg_class c1, enum reg_class c2)\n \t\t\t\t      reg_class_contents[(int) c2]));\n }\n \n+\f\n+\n+/* Passes for keeping and updating info about modes of registers\n+   inside subregisters.  */\n+\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \n struct subregs_of_mode_node\n@@ -2593,7 +1234,6 @@ som_eq (const void *x, const void *y)\n   return a->block == b->block;\n }\n \n-\n static void\n record_subregs_of_mode (rtx subreg)\n {\n@@ -2625,9 +1265,7 @@ record_subregs_of_mode (rtx subreg)\n   node->modes[mode] |= 1 << (regno & 7);\n }\n \n-\n /* Call record_subregs_of_mode for all the subregs in X.  */\n-\n static void \n find_subregs_of_mode (rtx x)\n {\n@@ -2671,10 +1309,9 @@ init_subregs_of_mode (void)\n   return 0;\n }\n \n-\n /* Set bits in *USED which correspond to registers which can't change\n-   their mode from FROM to any mode in which REGNO was encountered.  */\n-\n+   their mode from FROM to any mode in which REGNO was\n+   encountered.  */\n void\n cannot_change_mode_set_regs (HARD_REG_SET *used, enum machine_mode from,\n \t\t\t     unsigned int regno)\n@@ -2702,7 +1339,6 @@ cannot_change_mode_set_regs (HARD_REG_SET *used, enum machine_mode from,\n \n /* Return 1 if REGNO has had an invalid mode change in CLASS from FROM\n    mode.  */\n-\n bool\n invalid_mode_change_p (unsigned int regno,\n \t\t       enum reg_class rclass ATTRIBUTE_UNUSED,\n@@ -2798,5 +1434,4 @@ struct rtl_opt_pass pass_subregs_of_mode_finish =\n };\n \n \n-\n-#include \"gt-regclass.h\"\n+#include \"gt-reginfo.h\"", "previous_filename": "gcc/regclass.c"}, {"sha": "ce55c14596f2378049b85af4e30f9321ec56f1e9", "filename": "gcc/regmove.c", "status": "modified", "additions": 129, "deletions": 735, "changes": 864, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -20,10 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n \n-/* This module looks for cases where matching constraints would force\n-   an instruction to need a reload, and this reload would be a register\n-   to register move.  It then attempts to change the registers used by the\n-   instruction to avoid the move instruction.  */\n+/* This module makes some simple RTL code transformations which\n+   improve the subsequent register allocation.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -64,13 +62,8 @@ static rtx discover_flags_reg (void);\n static void mark_flags_life_zones (rtx);\n static void flags_set_1 (rtx, const_rtx, void *);\n \n-static int try_auto_increment (rtx, rtx, rtx, rtx, HOST_WIDE_INT, int);\n static int find_matches (rtx, struct match *);\n-static void replace_in_call_usage (rtx *, unsigned int, rtx, rtx);\n-static int fixup_match_1 (rtx, rtx, rtx, rtx, rtx, int, int, int);\n-static int stable_and_no_regs_but_for_p (rtx, rtx, rtx);\n static int regclass_compatible_p (int, int);\n-static int replacement_quality (rtx);\n static int fixup_match_2 (rtx, rtx, rtx, rtx);\n \n /* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n@@ -85,132 +78,6 @@ regclass_compatible_p (int class0, int class1)\n \t      && ! CLASS_LIKELY_SPILLED_P (class1)));\n }\n \n-/* Find the place in the rtx X where REG is used as a memory address.\n-   Return the MEM rtx that so uses it.\n-   If PLUSCONST is nonzero, search instead for a memory address equivalent to\n-   (plus REG (const_int PLUSCONST)).\n-\n-   If such an address does not appear, return 0.\n-   If REG appears more than once, or is used other than in such an address,\n-   return (rtx) 1.  */\n-\n-static rtx\n-find_use_as_address (rtx x, rtx reg, HOST_WIDE_INT plusconst)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  const char * const fmt = GET_RTX_FORMAT (code);\n-  int i;\n-  rtx value = 0;\n-  rtx tem;\n-\n-  if (code == MEM && XEXP (x, 0) == reg && plusconst == 0)\n-    return x;\n-\n-  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n-      && XEXP (XEXP (x, 0), 0) == reg\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && INTVAL (XEXP (XEXP (x, 0), 1)) == plusconst)\n-    return x;\n-\n-  if (code == SIGN_EXTRACT || code == ZERO_EXTRACT)\n-    {\n-      /* If REG occurs inside a MEM used in a bit-field reference,\n-\t that is unacceptable.  */\n-      if (find_use_as_address (XEXP (x, 0), reg, 0) != 0)\n-\treturn (rtx) (size_t) 1;\n-    }\n-\n-  if (x == reg)\n-    return (rtx) (size_t) 1;\n-\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  tem = find_use_as_address (XEXP (x, i), reg, plusconst);\n-\t  if (value == 0)\n-\t    value = tem;\n-\t  else if (tem != 0)\n-\t    return (rtx) (size_t) 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    {\n-\t      tem = find_use_as_address (XVECEXP (x, i, j), reg, plusconst);\n-\t      if (value == 0)\n-\t\tvalue = tem;\n-\t      else if (tem != 0)\n-\t\treturn (rtx) (size_t) 1;\n-\t    }\n-\t}\n-    }\n-\n-  return value;\n-}\n-\n-\n-/* INC_INSN is an instruction that adds INCREMENT to REG.\n-   Try to fold INC_INSN as a post/pre in/decrement into INSN.\n-   Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.\n-   Return nonzero for success.  */\n-static int\n-try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n-\t\t    HOST_WIDE_INT increment, int pre)\n-{\n-  enum rtx_code inc_code;\n-\n-  rtx pset = single_set (insn);\n-  if (pset)\n-    {\n-      /* Can't use the size of SET_SRC, we might have something like\n-\t (sign_extend:SI (mem:QI ...  */\n-      rtx use = find_use_as_address (pset, reg, 0);\n-      if (use != 0 && use != (rtx) (size_t) 1)\n-\t{\n-\t  int size = GET_MODE_SIZE (GET_MODE (use));\n-\t  if (0\n-\t      || (HAVE_POST_INCREMENT\n-\t\t  && pre == 0 && (inc_code = POST_INC, increment == size))\n-\t      || (HAVE_PRE_INCREMENT\n-\t\t  && pre == 1 && (inc_code = PRE_INC, increment == size))\n-\t      || (HAVE_POST_DECREMENT\n-\t\t  && pre == 0 && (inc_code = POST_DEC, increment == -size))\n-\t      || (HAVE_PRE_DECREMENT\n-\t\t  && pre == 1 && (inc_code = PRE_DEC, increment == -size))\n-\t  )\n-\t    {\n-\t      if (inc_insn_set)\n-\t\tvalidate_change\n-\t\t  (inc_insn,\n-\t\t   &SET_SRC (inc_insn_set),\n-\t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n-\t      validate_change (insn, &XEXP (use, 0),\n-\t\t\t       gen_rtx_fmt_e (inc_code, Pmode, reg), 1);\n-\t      if (apply_change_group ())\n-\t\t{\n-\t\t  /* If there is a REG_DEAD note on this insn, we must\n-\t\t     change this not to REG_UNUSED meaning that the register\n-\t\t     is set, but the value is dead.  Failure to do so will\n-\t\t     result in sched1 dying -- when it recomputes lifetime\n-\t\t     information, the number of REG_DEAD notes will have\n-\t\t     changed.  */\n-\t\t  rtx note = find_reg_note (insn, REG_DEAD, reg);\n-\t\t  if (note)\n-\t\t    PUT_MODE (note, REG_UNUSED);\n-\n-\t\t  add_reg_note (insn, REG_INC, reg);\n-\n-\t\t  if (! inc_insn_set)\n-\t\t    delete_insn (inc_insn);\n-\t\t  return 1;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n \f\n /* Determine if the pattern generated by add_optab has a clobber,\n    such as might be issued for a flags hard register.  To make the\n@@ -376,43 +243,140 @@ flags_set_1 (rtx x, const_rtx pat, void *data ATTRIBUTE_UNUSED)\n       && reg_overlap_mentioned_p (x, flags_set_1_rtx))\n     flags_set_1_set = 1;\n }\n-\f\n-static int *regno_src_regno;\n \n-/* Indicate how good a choice REG (which appears as a source) is to replace\n-   a destination register with.  The higher the returned value, the better\n-   the choice.  The main objective is to avoid using a register that is\n-   a candidate for tying to a hard register, since the output might in\n-   turn be a candidate to be tied to a different hard register.  */\n-static int\n-replacement_quality (rtx reg)\n+#ifdef AUTO_INC_DEC\n+\n+/* Find the place in the rtx X where REG is used as a memory address.\n+   Return the MEM rtx that so uses it.\n+   If PLUSCONST is nonzero, search instead for a memory address equivalent to\n+   (plus REG (const_int PLUSCONST)).\n+\n+   If such an address does not appear, return 0.\n+   If REG appears more than once, or is used other than in such an address,\n+   return (rtx) 1.  */\n+\n+static rtx\n+find_use_as_address (rtx x, rtx reg, HOST_WIDE_INT plusconst)\n {\n-  int src_regno;\n+  enum rtx_code code = GET_CODE (x);\n+  const char * const fmt = GET_RTX_FORMAT (code);\n+  int i;\n+  rtx value = 0;\n+  rtx tem;\n \n-  /* Bad if this isn't a register at all.  */\n-  if (!REG_P (reg))\n-    return 0;\n+  if (code == MEM && XEXP (x, 0) == reg && plusconst == 0)\n+    return x;\n \n-  /* If this register is not meant to get a hard register,\n-     it is a poor choice.  */\n-  if (REG_LIVE_LENGTH (REGNO (reg)) < 0)\n-    return 0;\n+  if (code == MEM && GET_CODE (XEXP (x, 0)) == PLUS\n+      && XEXP (XEXP (x, 0), 0) == reg\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && INTVAL (XEXP (XEXP (x, 0), 1)) == plusconst)\n+    return x;\n \n-  src_regno = regno_src_regno[REGNO (reg)];\n+  if (code == SIGN_EXTRACT || code == ZERO_EXTRACT)\n+    {\n+      /* If REG occurs inside a MEM used in a bit-field reference,\n+\t that is unacceptable.  */\n+      if (find_use_as_address (XEXP (x, 0), reg, 0) != 0)\n+\treturn (rtx) (size_t) 1;\n+    }\n \n-  /* If it was not copied from another register, it is fine.  */\n-  if (src_regno < 0)\n-    return 3;\n+  if (x == reg)\n+    return (rtx) (size_t) 1;\n \n-  /* Copied from a hard register?  */\n-  if (src_regno < FIRST_PSEUDO_REGISTER)\n-    return 1;\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  tem = find_use_as_address (XEXP (x, i), reg, plusconst);\n+\t  if (value == 0)\n+\t    value = tem;\n+\t  else if (tem != 0)\n+\t    return (rtx) (size_t) 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      tem = find_use_as_address (XVECEXP (x, i, j), reg, plusconst);\n+\t      if (value == 0)\n+\t\tvalue = tem;\n+\t      else if (tem != 0)\n+\t\treturn (rtx) (size_t) 1;\n+\t    }\n+\t}\n+    }\n \n-  /* Copied from a pseudo register - not as bad as from a hard register,\n-     yet still cumbersome, since the register live length will be lengthened\n-     when the registers get tied.  */\n-  return 2;\n+  return value;\n }\n+\n+\n+/* INC_INSN is an instruction that adds INCREMENT to REG.\n+   Try to fold INC_INSN as a post/pre in/decrement into INSN.\n+   Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.\n+   Return nonzero for success.  */\n+static int\n+try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n+\t\t    HOST_WIDE_INT increment, int pre)\n+{\n+  enum rtx_code inc_code;\n+\n+  rtx pset = single_set (insn);\n+  if (pset)\n+    {\n+      /* Can't use the size of SET_SRC, we might have something like\n+\t (sign_extend:SI (mem:QI ...  */\n+      rtx use = find_use_as_address (pset, reg, 0);\n+      if (use != 0 && use != (rtx) (size_t) 1)\n+\t{\n+\t  int size = GET_MODE_SIZE (GET_MODE (use));\n+\t  if (0\n+\t      || (HAVE_POST_INCREMENT\n+\t\t  && pre == 0 && (inc_code = POST_INC, increment == size))\n+\t      || (HAVE_PRE_INCREMENT\n+\t\t  && pre == 1 && (inc_code = PRE_INC, increment == size))\n+\t      || (HAVE_POST_DECREMENT\n+\t\t  && pre == 0 && (inc_code = POST_DEC, increment == -size))\n+\t      || (HAVE_PRE_DECREMENT\n+\t\t  && pre == 1 && (inc_code = PRE_DEC, increment == -size))\n+\t  )\n+\t    {\n+\t      if (inc_insn_set)\n+\t\tvalidate_change\n+\t\t  (inc_insn,\n+\t\t   &SET_SRC (inc_insn_set),\n+\t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n+\t      validate_change (insn, &XEXP (use, 0),\n+\t\t\t       gen_rtx_fmt_e (inc_code, Pmode, reg), 1);\n+\t      if (apply_change_group ())\n+\t\t{\n+\t\t  /* If there is a REG_DEAD note on this insn, we must\n+\t\t     change this not to REG_UNUSED meaning that the register\n+\t\t     is set, but the value is dead.  Failure to do so will\n+\t\t     result in sched1 dying -- when it recomputes lifetime\n+\t\t     information, the number of REG_DEAD notes will have\n+\t\t     changed.  */\n+\t\t  rtx note = find_reg_note (insn, REG_DEAD, reg);\n+\t\t  if (note)\n+\t\t    PUT_MODE (note, REG_UNUSED);\n+\n+\t\t  add_reg_note (insn, REG_INC, reg);\n+\n+\t\t  if (! inc_insn_set)\n+\t\t    delete_insn (inc_insn);\n+\t\t  return 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+#endif\n+\n+\f\n+static int *regno_src_regno;\n+\n \f\n /* Return 1 if INSN might end a basic block.  */\n \n@@ -898,7 +862,7 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest)\n /* reg_set_in_bb[REGNO] points to basic block iff the register is set\n    only once in the given block and has REG_EQUAL note.  */\n \n-basic_block *reg_set_in_bb;\n+static basic_block *reg_set_in_bb;\n \n /* Size of reg_set_in_bb array.  */\n static unsigned int max_reg_computed;\n@@ -1126,7 +1090,7 @@ regmove_optimize (rtx f, int nregs)\n   for (pass = 0; pass <= 2; pass++)\n     {\n       /* We need fewer optimizations for IRA.  */\n-      if ((! flag_regmove || flag_ira) && pass >= flag_expensive_optimizations)\n+      if (! flag_regmove && pass >= flag_expensive_optimizations)\n \tgoto done;\n \n       if (dump_file)\n@@ -1137,7 +1101,6 @@ regmove_optimize (rtx f, int nregs)\n \t   insn = pass ? PREV_INSN (insn) : NEXT_INSN (insn))\n \t{\n \t  rtx set;\n-\t  int op_no, match_no;\n \n \t  set = single_set (insn);\n \t  if (! set)\n@@ -1174,103 +1137,6 @@ regmove_optimize (rtx f, int nregs)\n \t\t    }\n \t\t}\n \t    }\n-\n-\t  /* All optimizations important for IRA have been done.  */\n-\t  if (! flag_regmove || flag_ira)\n-\t    continue;\n-\n-\t  if (! find_matches (insn, &match))\n-\t    continue;\n-\n-\t  /* Now scan through the operands looking for a source operand\n-\t     which is supposed to match the destination operand.\n-\t     Then scan forward for an instruction which uses the dest\n-\t     operand.\n-\t     If it dies there, then replace the dest in both operands with\n-\t     the source operand.  */\n-\n-\t  for (op_no = 0; op_no < recog_data.n_operands; op_no++)\n-\t    {\n-\t      rtx src, dst, src_subreg;\n-\t      enum reg_class src_class, dst_class;\n-\n-\t      match_no = match.with[op_no];\n-\n-\t      /* Nothing to do if the two operands aren't supposed to match.  */\n-\t      if (match_no < 0)\n-\t\tcontinue;\n-\n-\t      src = recog_data.operand[op_no];\n-\t      dst = recog_data.operand[match_no];\n-\n-\t      if (!REG_P (src))\n-\t\tcontinue;\n-\n-\t      src_subreg = src;\n-\t      if (GET_CODE (dst) == SUBREG\n-\t\t  && GET_MODE_SIZE (GET_MODE (dst))\n-\t\t     >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))\n-\t\t{\n-\t\t  dst = SUBREG_REG (dst);\n-\t\t  src_subreg = lowpart_subreg (GET_MODE (dst),\n-\t\t\t\t\t       src, GET_MODE (src));\n-\t\t  if (!src_subreg)\n-\t\t    continue;\n-\t\t}\n-\t      if (!REG_P (dst)\n-\t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n-\t\tcontinue;\n-\n-\t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  if (match.commutative[op_no] < op_no)\n-\t\t    regno_src_regno[REGNO (dst)] = REGNO (src);\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (REG_LIVE_LENGTH (REGNO (src)) < 0)\n-\t\tcontinue;\n-\n-\t      /* op_no/src must be a read-only operand, and\n-\t\t match_operand/dst must be a write-only operand.  */\n-\t      if (match.use[op_no] != READ\n-\t\t  || match.use[match_no] != WRITE)\n-\t\tcontinue;\n-\n-\t      if (match.early_clobber[match_no]\n-\t\t  && count_occurrences (PATTERN (insn), src, 0) > 1)\n-\t\tcontinue;\n-\n-\t      /* Make sure match_operand is the destination.  */\n-\t      if (recog_data.operand[match_no] != SET_DEST (set))\n-\t\tcontinue;\n-\n-\t      /* If the operands already match, then there is nothing to do.  */\n-\t      if (operands_match_p (src, dst))\n-\t\tcontinue;\n-\n-\t      /* But in the commutative case, we might find a better match.  */\n-\t      if (match.commutative[op_no] >= 0)\n-\t\t{\n-\t\t  rtx comm = recog_data.operand[match.commutative[op_no]];\n-\t\t  if (operands_match_p (comm, dst)\n-\t\t      && (replacement_quality (comm)\n-\t\t\t  >= replacement_quality (src)))\n-\t\t    continue;\n-\t\t}\n-\n-\t      src_class = reg_preferred_class (REGNO (src));\n-\t      dst_class = reg_preferred_class (REGNO (dst));\n-\t      if (! regclass_compatible_p (src_class, dst_class))\n-\t\tcontinue;\n-\n-\t      if (GET_MODE (src) != GET_MODE (dst))\n-\t\tcontinue;\n-\n-\t      if (fixup_match_1 (insn, set, src, src_subreg, dst, pass,\n-\t\t\t\t op_no, match_no))\n-\t\tbreak;\n-\t    }\n \t}\n     }\n \n@@ -1656,478 +1522,6 @@ find_matches (rtx insn, struct match *matchp)\n   return any_matches;\n }\n \n-/* Try to replace all occurrences of DST_REG with SRC in LOC, that is\n-   assumed to be in INSN.  */\n-\n-static void\n-replace_in_call_usage (rtx *loc, unsigned int dst_reg, rtx src, rtx insn)\n-{\n-  rtx x = *loc;\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i, j;\n-\n-  if (! x)\n-    return;\n-\n-  code = GET_CODE (x);\n-  if (code == REG)\n-    {\n-      if (REGNO (x) != dst_reg)\n-\treturn;\n-\n-      validate_change (insn, loc, src, 1);\n-\n-      return;\n-    }\n-\n-  /* Process each of our operands recursively.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n-    if (*fmt == 'e')\n-      replace_in_call_usage (&XEXP (x, i), dst_reg, src, insn);\n-    else if (*fmt == 'E')\n-      for (j = 0; j < XVECLEN (x, i); j++)\n-\treplace_in_call_usage (& XVECEXP (x, i, j), dst_reg, src, insn);\n-}\n-\n-/* Try to replace output operand DST in SET, with input operand SRC.  SET is\n-   the only set in INSN.  INSN has just been recognized and constrained.\n-   SRC is operand number OPERAND_NUMBER in INSN.\n-   DST is operand number MATCH_NUMBER in INSN.\n-   If BACKWARD is nonzero, we have been called in a backward pass.\n-   Return nonzero for success.  */\n-\n-static int\n-fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n-\t       int backward, int operand_number, int match_number)\n-{\n-  rtx p;\n-  rtx post_inc = 0, post_inc_set = 0, search_end = 0;\n-  int success = 0;\n-  int num_calls = 0, freq_calls = 0, s_num_calls = 0, s_freq_calls = 0;\n-  enum rtx_code code = NOTE;\n-  HOST_WIDE_INT insn_const = 0, newconst = 0;\n-  rtx overlap = 0; /* need to move insn ? */\n-  rtx src_note = find_reg_note (insn, REG_DEAD, src), dst_note = NULL_RTX;\n-  int length, s_length;\n-\n-  if (! src_note)\n-    {\n-      /* Look for (set (regX) (op regA constX))\n-\t\t  (set (regY) (op regA constY))\n-\t and change that to\n-\t\t  (set (regA) (op regA constX)).\n-\t\t  (set (regY) (op regA constY-constX)).\n-\t This works for add and shift operations, if\n-\t regA is dead after or set by the second insn.  */\n-\n-      code = GET_CODE (SET_SRC (set));\n-      if ((code == PLUS || code == LSHIFTRT\n-\t   || code == ASHIFT || code == ASHIFTRT)\n-\t  && XEXP (SET_SRC (set), 0) == src\n-\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n-\tinsn_const = INTVAL (XEXP (SET_SRC (set), 1));\n-      else if (! stable_and_no_regs_but_for_p (SET_SRC (set), src, dst))\n-\treturn 0;\n-      else\n-\t/* We might find a src_note while scanning.  */\n-\tcode = NOTE;\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t     operand_number, INSN_UID (insn), match_number);\n-\n-  /* If SRC is equivalent to a constant set in a different basic block,\n-     then do not use it for this optimization.  We want the equivalence\n-     so that if we have to reload this register, we can reload the\n-     constant, rather than extending the lifespan of the register.  */\n-  if (reg_is_remote_constant_p (src, insn))\n-    return 0;\n-\n-  /* Scan forward to find the next instruction that\n-     uses the output operand.  If the operand dies here,\n-     then replace it in both instructions with\n-     operand_number.  */\n-\n-  for (length = s_length = 0, p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n-    {\n-      if (CALL_P (p))\n-\treplace_in_call_usage (& CALL_INSN_FUNCTION_USAGE (p),\n-\t\t\t       REGNO (dst), src, p);\n-\n-      /* ??? We can't scan past the end of a basic block without updating\n-\t the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n-      if (perhaps_ends_bb_p (p))\n-\tbreak;\n-      else if (! INSN_P (p))\n-\tcontinue;\n-\n-      length++;\n-      if (src_note)\n-\ts_length++;\n-\n-      if (reg_set_p (src, p) || reg_set_p (dst, p)\n-\t  || (GET_CODE (PATTERN (p)) == USE\n-\t      && reg_overlap_mentioned_p (src, XEXP (PATTERN (p), 0))))\n-\tbreak;\n-\n-      /* See if all of DST dies in P.  This test is\n-\t slightly more conservative than it needs to be.  */\n-      if ((dst_note = find_regno_note (p, REG_DEAD, REGNO (dst)))\n-\t  && (GET_MODE (XEXP (dst_note, 0)) == GET_MODE (dst)))\n-\t{\n-\t  /* If we would be moving INSN, check that we won't move it\n-\t     into the shadow of a live a live flags register.  */\n-\t  /* ??? We only try to move it in front of P, although\n-\t\t we could move it anywhere between OVERLAP and P.  */\n-\t  if (overlap && GET_MODE (PREV_INSN (p)) != VOIDmode)\n-\t    break;\n-\n-\t  if (! src_note)\n-\t    {\n-\t      rtx q;\n-\t      rtx set2 = NULL_RTX;\n-\n-\t      /* If an optimization is done, the value of SRC while P\n-\t\t is executed will be changed.  Check that this is OK.  */\n-\t      if (reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t\tbreak;\n-\t      for (q = p; q; q = NEXT_INSN (q))\n-\t\t{\n-\t\t  /* ??? We can't scan past the end of a basic block without\n-\t\t     updating the register lifetime info\n-\t\t     (REG_DEAD/basic_block_live_at_start).  */\n-\t\t  if (perhaps_ends_bb_p (q))\n-\t\t    {\n-\t\t      q = 0;\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (! INSN_P (q))\n-\t\t    continue;\n-\t\t  else if (reg_overlap_mentioned_p (src, PATTERN (q))\n-\t\t\t   || reg_set_p (src, q))\n-\t\t    break;\n-\t\t}\n-\t      if (q)\n-\t\tset2 = single_set (q);\n-\t      if (! q || ! set2 || GET_CODE (SET_SRC (set2)) != code\n-\t\t  || XEXP (SET_SRC (set2), 0) != src\n-\t\t  || GET_CODE (XEXP (SET_SRC (set2), 1)) != CONST_INT\n-\t\t  || (SET_DEST (set2) != src\n-\t\t      && ! find_reg_note (q, REG_DEAD, src)))\n-\t\t{\n-\t\t  /* If this is a PLUS, we can still save a register by doing\n-\t\t     src += insn_const;\n-\t\t     P;\n-\t\t     src -= insn_const; .\n-\t\t     This also gives opportunities for subsequent\n-\t\t     optimizations in the backward pass, so do it there.  */\n-\t\t  if (code == PLUS && backward\n-\t\t      /* Don't do this if we can likely tie DST to SET_DEST\n-\t\t\t of P later; we can't do this tying here if we got a\n-\t\t\t hard register.  */\n-\t\t      && ! (dst_note && ! REG_N_CALLS_CROSSED (REGNO (dst))\n-\t\t\t    && single_set (p)\n-\t\t\t    && REG_P (SET_DEST (single_set (p)))\n-\t\t\t    && (REGNO (SET_DEST (single_set (p)))\n-\t\t\t\t< FIRST_PSEUDO_REGISTER))\n-\t\t      /* We may only emit an insn directly after P if we\n-\t\t\t are not in the shadow of a live flags register.  */\n-\t\t      && GET_MODE (p) == VOIDmode)\n-\t\t    {\n-\t\t      search_end = q;\n-\t\t      q = insn;\n-\t\t      set2 = set;\n-\t\t      newconst = -insn_const;\n-\t\t      code = MINUS;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  newconst = INTVAL (XEXP (SET_SRC (set2), 1)) - insn_const;\n-\t\t  /* Reject out of range shifts.  */\n-\t\t  if (code != PLUS\n-\t\t      && (newconst < 0\n-\t\t\t  || ((unsigned HOST_WIDE_INT) newconst\n-\t\t\t      >= (GET_MODE_BITSIZE (GET_MODE\n-\t\t\t\t\t\t    (SET_SRC (set2)))))))\n-\t\t    break;\n-\t\t  if (code == PLUS)\n-\t\t    {\n-\t\t      post_inc = q;\n-\t\t      if (SET_DEST (set2) != src)\n-\t\t\tpost_inc_set = set2;\n-\t\t    }\n-\t\t}\n-\t      /* We use 1 as last argument to validate_change so that all\n-\t\t changes are accepted or rejected together by apply_change_group\n-\t\t when it is called by validate_replace_rtx .  */\n-\t      validate_change (q, &XEXP (SET_SRC (set2), 1),\n-\t\t\t       GEN_INT (newconst), 1);\n-\t    }\n-\t  validate_change (insn, recog_data.operand_loc[match_number], src, 1);\n-\t  if (validate_replace_rtx (dst, src_subreg, p))\n-\t    success = 1;\n-\t  break;\n-\t}\n-\n-      if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n-\tbreak;\n-      if (! src_note && reg_overlap_mentioned_p (src, PATTERN (p)))\n-\t{\n-\t  /* INSN was already checked to be movable wrt. the registers that it\n-\t     sets / uses when we found no REG_DEAD note for src on it, but it\n-\t     still might clobber the flags register.  We'll have to check that\n-\t     we won't insert it into the shadow of a live flags register when\n-\t     we finally know where we are to move it.  */\n-\t  overlap = p;\n-\t  src_note = find_reg_note (p, REG_DEAD, src);\n-\t}\n-\n-      /* If we have passed a call instruction, and the pseudo-reg SRC is not\n-\t already live across a call, then don't perform the optimization.  */\n-      if (CALL_P (p))\n-\t{\n-\t  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n-\t    break;\n-\n-\t  num_calls++;\n-\t  freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (p));\n-\n-\t  if (src_note)\n-\t    {\n-\t      s_num_calls++;\n-\t      s_freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (p));\n-\t    }\n-\t}\n-    }\n-\n-  if (! success)\n-    return 0;\n-\n-  /* Remove the death note for DST from P.  */\n-  remove_note (p, dst_note);\n-  if (code == MINUS)\n-    {\n-      post_inc = emit_insn_after (copy_rtx (PATTERN (insn)), p);\n-      if ((HAVE_PRE_INCREMENT || HAVE_PRE_DECREMENT)\n-\t  && search_end\n-\t  && try_auto_increment (search_end, post_inc, 0, src, newconst, 1))\n-\tpost_inc = 0;\n-      validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (insn_const), 0);\n-      INC_REG_N_SETS (REGNO (src), 1);\n-      REG_LIVE_LENGTH (REGNO (src))++;\n-    }\n-  if (overlap)\n-    {\n-      /* The lifetime of src and dest overlap,\n-\t but we can change this by moving insn.  */\n-      rtx pat = PATTERN (insn);\n-      if (src_note)\n-\tremove_note (overlap, src_note);\n-      if ((HAVE_POST_INCREMENT || HAVE_POST_DECREMENT)\n-\t  && code == PLUS\n-\t  && try_auto_increment (overlap, insn, 0, src, insn_const, 0))\n-\tinsn = overlap;\n-      else\n-\t{\n-\t  rtx notes = REG_NOTES (insn);\n-\n-\t  p = emit_insn_after_setloc (pat, PREV_INSN (p), INSN_LOCATOR (insn));\n-\t  delete_insn (insn);\n-\t  REG_NOTES (p) = notes;\n-\t  df_notes_rescan (p);\n-\t}\n-    }\n-  /* Sometimes we'd generate src = const; src += n;\n-     if so, replace the instruction that set src\n-     in the first place.  */\n-\n-  if (! overlap && (code == PLUS || code == MINUS))\n-    {\n-      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-      rtx q, set2 = NULL_RTX;\n-      int num_calls2 = 0, s_length2 = 0, freq_calls2 = 0;\n-\n-      if (note && CONSTANT_P (XEXP (note, 0)))\n-\t{\n-\t  for (q = PREV_INSN (insn); q; q = PREV_INSN (q))\n-\t    {\n-\t      /* ??? We can't scan past the end of a basic block without\n-\t\t updating the register lifetime info\n-\t\t (REG_DEAD/basic_block_live_at_start).  */\n-\t      if (perhaps_ends_bb_p (q))\n-\t\t{\n-\t\t  q = 0;\n-\t\t  break;\n-\t\t}\n-\t      else if (! INSN_P (q))\n-\t\tcontinue;\n-\n-\t      s_length2++;\n-\t      if (reg_set_p (src, q))\n-\t\t{\n-\t\t  set2 = single_set (q);\n-\t\t  break;\n-\t\t}\n-\t      if (reg_overlap_mentioned_p (src, PATTERN (q)))\n-\t\t{\n-\t\t  q = 0;\n-\t\t  break;\n-\t\t}\n-\t      if (CALL_P (p))\n-\t\t{\n-\t\t  num_calls2++;\n-\t\t  freq_calls2 += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (p));\n-\t\t}\n-\t    }\n-\t  if (q && set2 && SET_DEST (set2) == src && CONSTANT_P (SET_SRC (set2))\n-\t      && validate_change (insn, &SET_SRC (set), XEXP (note, 0), 0))\n-\t    {\n-\t      delete_insn (q);\n-\t      INC_REG_N_SETS (REGNO (src), -1);\n-\t      REG_N_CALLS_CROSSED (REGNO (src)) -= num_calls2;\n-\t      REG_FREQ_CALLS_CROSSED (REGNO (src)) -= freq_calls2;\n-\t      REG_LIVE_LENGTH (REGNO (src)) -= s_length2;\n-\t      insn_const = 0;\n-\t    }\n-\t}\n-    }\n-\n-  if ((HAVE_PRE_INCREMENT || HAVE_PRE_DECREMENT)\n-\t   && (code == PLUS || code == MINUS) && insn_const\n-\t   && try_auto_increment (p, insn, 0, src, insn_const, 1))\n-    insn = p;\n-  else if ((HAVE_POST_INCREMENT || HAVE_POST_DECREMENT)\n-\t   && post_inc\n-\t   && try_auto_increment (p, post_inc, post_inc_set, src, newconst, 0))\n-    post_inc = 0;\n-  /* If post_inc still prevails, try to find an\n-     insn where it can be used as a pre-in/decrement.\n-     If code is MINUS, this was already tried.  */\n-  if (post_inc && code == PLUS\n-  /* Check that newconst is likely to be usable\n-     in a pre-in/decrement before starting the search.  */\n-      && ((HAVE_PRE_INCREMENT && newconst > 0 && newconst <= MOVE_MAX)\n-\t  || (HAVE_PRE_DECREMENT && newconst < 0 && newconst >= -MOVE_MAX))\n-      && exact_log2 (newconst))\n-    {\n-      rtx q, inc_dest;\n-\n-      inc_dest = post_inc_set ? SET_DEST (post_inc_set) : src;\n-      for (q = post_inc; (q = NEXT_INSN (q)); )\n-\t{\n-\t  /* ??? We can't scan past the end of a basic block without updating\n-\t     the register lifetime info\n-\t     (REG_DEAD/basic_block_live_at_start).  */\n-\t  if (perhaps_ends_bb_p (q))\n-\t    break;\n-\t  else if (! INSN_P (q))\n-\t    continue;\n-\t  else if (src != inc_dest\n-\t\t   && (reg_overlap_mentioned_p (src, PATTERN (q))\n-\t\t       || reg_set_p (src, q)))\n-\t    break;\n-\t  else if (reg_set_p (inc_dest, q))\n-\t    break;\n-\t  else if (reg_overlap_mentioned_p (inc_dest, PATTERN (q)))\n-\t    {\n-\t      try_auto_increment (q, post_inc,\n-\t\t\t\t  post_inc_set, inc_dest, newconst, 1);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* Move the death note for DST to INSN if it is used\n-     there.  */\n-  if (reg_overlap_mentioned_p (dst, PATTERN (insn)))\n-    {\n-      XEXP (dst_note, 1) = REG_NOTES (insn);\n-      REG_NOTES (insn) = dst_note;\n-    }\n-\n-  if (src_note)\n-    {\n-      /* Move the death note for SRC from INSN to P.  */\n-      if (! overlap)\n-\tremove_note (insn, src_note);\n-      XEXP (src_note, 1) = REG_NOTES (p);\n-      REG_NOTES (p) = src_note;\n-\n-      REG_N_CALLS_CROSSED (REGNO (src)) += s_num_calls;\n-      REG_FREQ_CALLS_CROSSED (REGNO (src)) += s_freq_calls;\n-    }\n-\n-  INC_REG_N_SETS (REGNO (src), 1);\n-  INC_REG_N_SETS (REGNO (dst), -1);\n-\n-  REG_N_CALLS_CROSSED (REGNO (dst)) -= num_calls;\n-  REG_FREQ_CALLS_CROSSED (REGNO (dst)) -= freq_calls;\n-\n-  REG_LIVE_LENGTH (REGNO (src)) += s_length;\n-  if (REG_LIVE_LENGTH (REGNO (dst)) >= 0)\n-    {\n-      REG_LIVE_LENGTH (REGNO (dst)) -= length;\n-      /* REG_LIVE_LENGTH is only an approximation after\n-\t combine if sched is not run, so make sure that we\n-\t still have a reasonable value.  */\n-      if (REG_LIVE_LENGTH (REGNO (dst)) < 2)\n-\tREG_LIVE_LENGTH (REGNO (dst)) = 2;\n-    }\n-  if (dump_file)\n-    fprintf (dump_file,\n-\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n-\t     operand_number, INSN_UID (insn), match_number);\n-  return 1;\n-}\n-\n-\n-/* Return nonzero if X is stable and mentions no registers but for\n-   mentioning SRC or mentioning / changing DST .  If in doubt, presume\n-   it is unstable.\n-   The rationale is that we want to check if we can move an insn easily\n-   while just paying attention to SRC and DST.  */\n-static int\n-stable_and_no_regs_but_for_p (rtx x, rtx src, rtx dst)\n-{\n-  RTX_CODE code = GET_CODE (x);\n-  switch (GET_RTX_CLASS (code))\n-    {\n-    case RTX_UNARY:\n-    case RTX_BIN_ARITH:\n-    case RTX_COMM_ARITH:\n-    case RTX_COMPARE:\n-    case RTX_COMM_COMPARE:\n-    case RTX_TERNARY:\n-    case RTX_BITFIELD_OPS:\n-      {\n-\tint i;\n-\tconst char *fmt = GET_RTX_FORMAT (code);\n-\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t  if (fmt[i] == 'e'\n-\t      && ! stable_and_no_regs_but_for_p (XEXP (x, i), src, dst))\n-\t      return 0;\n-\treturn 1;\n-      }\n-    case RTX_OBJ:\n-      if (code == REG)\n-\treturn x == src || x == dst;\n-      /* If this is a MEM, look inside - there might be a register hidden in\n-\t the address of an unchanging MEM.  */\n-      if (code == MEM\n-\t  && ! stable_and_no_regs_but_for_p (XEXP (x, 0), src, dst))\n-\treturn 0;\n-      /* Fall through.  */\n-    default:\n-      return ! rtx_unstable_p (x);\n-    }\n-}\n \f\n \n static bool"}, {"sha": "7f982c29be1afb05bc2e61c5a5e889f9fc612508", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -1549,9 +1549,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && reg_mentioned_p (XEXP (note, 0), in)\n \t    /* Check that a former pseudo is valid; see find_dummy_reload.  */\n \t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t|| (! bitmap_bit_p (flag_ira\n-\t\t\t\t    ? DF_LR_OUT (ENTRY_BLOCK_PTR)\n-\t\t\t\t    : DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n+\t\t|| (! bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n \t\t\t\t    ORIGINAL_REGNO (XEXP (note, 0)))\n \t\t    && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1))\n \t    && ! refers_to_regno_for_reload_p (regno,\n@@ -2029,9 +2027,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t     can ignore the conflict).  We must never introduce writes\n \t     to such hardregs, as they would clobber the other live\n \t     pseudo.  See PR 20973.  */\n-          || (!bitmap_bit_p (flag_ira\n-\t\t\t     ? DF_LR_OUT (ENTRY_BLOCK_PTR)\n-\t\t\t     : DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n+          || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n \t\t\t     ORIGINAL_REGNO (in))\n \t      /* Similarly, only do this if we can be sure that the death\n \t\t note is still valid.  global can assign some hardreg to"}, {"sha": "e0d0f942ff087b3e5afadb88792cb5065ea8f0c3", "filename": "gcc/reload1.c", "status": "modified", "additions": 35, "deletions": 60, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -557,7 +557,7 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n \t     which might still contain registers that have not\n \t     actually been allocated since they have an\n \t     equivalence.  */\n-\t  gcc_assert ((flag_ira && ira_conflicts_p) || reload_completed);\n+\t  gcc_assert (ira_conflicts_p || reload_completed);\n \t}\n       else\n \tadd_to_hard_reg_set (to, PSEUDO_REGNO_MODE (regno), r);\n@@ -901,7 +901,7 @@ reload (rtx first, int global)\n   for (n = 0, i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n     temp_pseudo_reg_arr[n++] = i;\n   \n-  if (flag_ira && ira_conflicts_p)\n+  if (ira_conflicts_p)\n     /* Ask IRA to order pseudo-registers for better stack slot\n        sharing.  */\n     ira_sort_regnos_for_alter_reg (temp_pseudo_reg_arr, n, reg_max_ref_width);\n@@ -1055,7 +1055,7 @@ reload (rtx first, int global)\n \n       calculate_needs_all_insns (global);\n \n-      if (! flag_ira || ! ira_conflicts_p)\n+      if (! ira_conflicts_p)\n \t/* Don't do it for IRA.  We need this info because we don't\n \t   change live_throughout and dead_or_set for chains when IRA\n \t   is used.  */\n@@ -1614,7 +1614,7 @@ calculate_needs_all_insns (int global)\n \t\t\t\t       reg_equiv_memory_loc\n \t\t\t\t       [REGNO (SET_DEST (set))]))))\n \t\t{\n-\t\t  if (flag_ira && ira_conflicts_p)\n+\t\t  if (ira_conflicts_p)\n \t\t    /* Inform IRA about the insn deletion.  */\n \t\t    ira_mark_memory_move_deletion (REGNO (SET_DEST (set)),\n \t\t\t\t\t\t   REGNO (SET_SRC (set)));\n@@ -1723,7 +1723,7 @@ count_pseudo (int reg)\n       || REGNO_REG_SET_P (&spilled_pseudos, reg)\n       /* Ignore spilled pseudo-registers which can be here only if IRA\n \t is used.  */\n-      || (flag_ira && ira_conflicts_p && r < 0))\n+      || (ira_conflicts_p && r < 0))\n     return;\n \n   SET_REGNO_REG_SET (&pseudos_counted, reg);\n@@ -1804,7 +1804,7 @@ count_spilled_pseudo (int spilled, int spilled_nregs, int reg)\n \n   /* Ignore spilled pseudo-registers which can be here only if IRA is\n      used.  */\n-  if ((flag_ira && ira_conflicts_p && r < 0)\n+  if ((ira_conflicts_p && r < 0)\n       || REGNO_REG_SET_P (&spilled_pseudos, reg)\n       || spilled + spilled_nregs <= r || r + nregs <= spilled)\n     return;\n@@ -1876,7 +1876,7 @@ find_reg (struct insn_chain *chain, int order)\n \t  if (! ok)\n \t    continue;\n \n-\t  if (flag_ira && ira_conflicts_p)\n+\t  if (ira_conflicts_p)\n \t    {\n \t      /* Ask IRA to find a better pseudo-register for\n \t\t spilling.  */\n@@ -2158,7 +2158,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       unsigned int min_align = reg_max_ref_width[i] * BITS_PER_UNIT;\n       int adjust = 0;\n \n-      if (flag_ira && ira_conflicts_p)\n+      if (ira_conflicts_p)\n \t{\n \t  /* Mark the spill for IRA.  */\n \t  SET_REGNO_REG_SET (&spilled_pseudos, i);\n@@ -2177,8 +2177,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t enough inherent space and enough total space.\n \t Otherwise, we allocate a new slot, making sure that it has no less\n \t inherent space, and no less total space, then the previous slot.  */\n-      else if (from_reg == -1\n-\t       || (!dont_share_p && flag_ira && ira_conflicts_p))\n+      else if (from_reg == -1 || (!dont_share_p && ira_conflicts_p))\n \t{\n \t  rtx stack_slot;\n \n@@ -2203,7 +2202,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t\t\t\t       adjust);\n \t    }\n \n-\t  if (! dont_share_p && flag_ira && ira_conflicts_p)\n+\t  if (! dont_share_p && ira_conflicts_p)\n \t    /* Inform IRA about allocation a new stack slot.  */\n \t    ira_mark_new_stack_slot (stack_slot, i, total_size);\n \t}\n@@ -3905,7 +3904,7 @@ finish_spills (int global)\n       spill_reg_order[i] = -1;\n \n   EXECUTE_IF_SET_IN_REG_SET (&spilled_pseudos, FIRST_PSEUDO_REGISTER, i, rsi)\n-    if (! flag_ira || ! ira_conflicts_p || reg_renumber[i] >= 0)\n+    if (! ira_conflicts_p || reg_renumber[i] >= 0)\n       {\n \t/* Record the current hard register the pseudo is allocated to\n \t   in pseudo_previous_regs so we avoid reallocating it to the\n@@ -3915,16 +3914,18 @@ finish_spills (int global)\n \tSET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n \t/* Mark it as no longer having a hard register home.  */\n \treg_renumber[i] = -1;\n-\tif (flag_ira && ira_conflicts_p)\n+\tif (ira_conflicts_p)\n \t  /* Inform IRA about the change.  */\n \t  ira_mark_allocation_change (i);\n \t/* We will need to scan everything again.  */\n \tsomething_changed = 1;\n       }\n \n   /* Retry global register allocation if possible.  */\n-  if (global)\n+  if (global && ira_conflicts_p)\n     {\n+      unsigned int n;\n+\n       memset (pseudo_forbidden_regs, 0, max_regno * sizeof (HARD_REG_SET));\n       /* For every insn that needs reloads, set the registers used as spill\n \t regs in pseudo_forbidden_regs for every pseudo live across the\n@@ -3945,49 +3946,23 @@ finish_spills (int global)\n \t    }\n \t}\n \n-      if (! flag_ira || ! ira_conflicts_p)\n-\t{\n-\t  /* Retry allocating the spilled pseudos.  For each reg,\n-\t     merge the various reg sets that indicate which hard regs\n-\t     can't be used, and call retry_global_alloc.  We change\n-\t     spill_pseudos here to only contain pseudos that did not\n-\t     get a new hard register.  */\n-\t  for (i = FIRST_PSEUDO_REGISTER; i < (unsigned)max_regno; i++)\n-\t    if (reg_old_renumber[i] != reg_renumber[i])\n-\t      {\n-\t\tHARD_REG_SET forbidden;\n-\t\t\n-\t\tCOPY_HARD_REG_SET (forbidden, bad_spill_regs_global);\n-\t\tIOR_HARD_REG_SET (forbidden, pseudo_forbidden_regs[i]);\n-\t\tIOR_HARD_REG_SET (forbidden, pseudo_previous_regs[i]);\n-\t\tretry_global_alloc (i, forbidden);\n-\t\tif (reg_renumber[i] >= 0)\n-\t\t  CLEAR_REGNO_REG_SET (&spilled_pseudos, i);\n-\t      }\n-\t}\n-      else\n-\t{\n-\t  /* Retry allocating the pseudos spilled in IRA and the\n-\t     reload.  For each reg, merge the various reg sets that\n-\t     indicate which hard regs can't be used, and call\n-\t     ira_reassign_pseudos.  */\n-\t  unsigned int n;\n-\n-\t  for (n = 0, i = FIRST_PSEUDO_REGISTER; i < (unsigned) max_regno; i++)\n-\t    if (reg_old_renumber[i] != reg_renumber[i])\n-\t      {\n-\t\tif (reg_renumber[i] < 0)\n-\t\t  temp_pseudo_reg_arr[n++] = i;\n-\t\telse\n-\t\t  CLEAR_REGNO_REG_SET (&spilled_pseudos, i);\n-\t      }\n-\t  if (ira_reassign_pseudos (temp_pseudo_reg_arr, n,\n-\t\t\t\t    bad_spill_regs_global,\n-\t\t\t\t    pseudo_forbidden_regs, pseudo_previous_regs,\n-\t\t\t\t    &spilled_pseudos))\n-\t    something_changed = 1;\n-\t  \n-\t}\n+      /* Retry allocating the pseudos spilled in IRA and the\n+\t reload.  For each reg, merge the various reg sets that\n+\t indicate which hard regs can't be used, and call\n+\t ira_reassign_pseudos.  */\n+      for (n = 0, i = FIRST_PSEUDO_REGISTER; i < (unsigned) max_regno; i++)\n+\tif (reg_old_renumber[i] != reg_renumber[i])\n+\t  {\n+\t    if (reg_renumber[i] < 0)\n+\t      temp_pseudo_reg_arr[n++] = i;\n+\t    else\n+\t      CLEAR_REGNO_REG_SET (&spilled_pseudos, i);\n+\t  }\n+      if (ira_reassign_pseudos (temp_pseudo_reg_arr, n,\n+\t\t\t\tbad_spill_regs_global,\n+\t\t\t\tpseudo_forbidden_regs, pseudo_previous_regs,\n+\t\t\t\t&spilled_pseudos))\n+\tsomething_changed = 1;\n     }\n   /* Fix up the register information in the insn chain.\n      This involves deleting those of the spilled pseudos which did not get\n@@ -3997,7 +3972,7 @@ finish_spills (int global)\n       HARD_REG_SET used_by_pseudos;\n       HARD_REG_SET used_by_pseudos2;\n \n-      if (! flag_ira || ! ira_conflicts_p)\n+      if (! ira_conflicts_p)\n \t{\n \t  /* Don't do it for IRA because IRA and the reload still can\n \t     assign hard registers to the spilled pseudos on next\n@@ -7000,7 +6975,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t  && REG_N_SETS (REGNO (old)) == 1)\n \t\t{\n \t\t  reg_renumber[REGNO (old)] = REGNO (reloadreg);\n-\t\t  if (flag_ira && ira_conflicts_p)\n+\t\t  if (ira_conflicts_p)\n \t\t    /* Inform IRA about the change.  */\n \t\t    ira_mark_allocation_change (REGNO (old));\n \t\t  alter_reg (REGNO (old), -1, false);\n@@ -8541,7 +8516,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n \n       /* For the debugging info, say the pseudo lives in this reload reg.  */\n       reg_renumber[REGNO (reg)] = REGNO (new_reload_reg);\n-      if (flag_ira && ira_conflicts_p)\n+      if (ira_conflicts_p)\n \t/* Inform IRA about the change.  */\n \tira_mark_allocation_change (REGNO (reg));\n       alter_reg (REGNO (reg), -1, false);"}, {"sha": "5c2a89edec937ce74f5f4912c3b80891705f8a54", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -2212,17 +2212,11 @@ extern void expand_dec (rtx, rtx);\n extern bool can_copy_p (enum machine_mode);\n extern rtx fis_get_condition (rtx);\n \n-/* In global.c */\n+/* In ira.c */\n #ifdef HARD_CONST\n extern HARD_REG_SET eliminable_regset;\n #endif\n extern void mark_elimination (int, int);\n-extern void dump_global_regs (FILE *);\n-#ifdef HARD_CONST\n-/* Yes, this ifdef is silly, but HARD_REG_SET is not always defined.  */\n-extern void retry_global_alloc (int, HARD_REG_SET);\n-#endif\n-extern void build_insn_chain (void);\n \n /* In regclass.c */\n extern int reg_classes_intersect_p (enum reg_class, enum reg_class);\n@@ -2247,10 +2241,6 @@ extern bool invalid_mode_change_p (unsigned int, enum reg_class,\n /* In reorg.c */\n extern void dbr_schedule (rtx);\n \n-/* In local-alloc.c */\n-extern void dump_local_alloc (FILE *);\n-extern int update_equiv_regs (void);\n-\n /* In reload1.c */\n extern int function_invariant_p (const_rtx);\n "}, {"sha": "0cd62ef22beaecde318c639f4c2005d66f05e3f5", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -140,7 +140,6 @@ extern int flag_unroll_all_loops;\n extern int flag_unswitch_loops;\n extern int flag_cprop_registers;\n extern int time_report;\n-extern int flag_ira;\n extern int flag_ira_coalesce;\n extern int flag_ira_move_spills;\n extern int flag_ira_share_save_slots;"}, {"sha": "02ee3c594cbdf82f107ad196894bb17565267a27", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2af2dbdc6816c47aa6bc96976a4416fde370ea55/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2af2dbdc6816c47aa6bc96976a4416fde370ea55", "patch": "@@ -450,7 +450,7 @@ extern struct rtl_opt_pass pass_web;\n extern struct rtl_opt_pass pass_cse2;\n extern struct rtl_opt_pass pass_df_initialize_opt;\n extern struct rtl_opt_pass pass_df_initialize_no_opt;\n-extern struct rtl_opt_pass pass_regclass_init;\n+extern struct rtl_opt_pass pass_reginfo_init;\n extern struct rtl_opt_pass pass_subregs_of_mode_init;\n extern struct rtl_opt_pass pass_subregs_of_mode_finish;\n extern struct rtl_opt_pass pass_inc_dec;\n@@ -468,8 +468,6 @@ extern struct rtl_opt_pass pass_mode_switching;\n extern struct rtl_opt_pass pass_see;\n extern struct rtl_opt_pass pass_sms;\n extern struct rtl_opt_pass pass_sched;\n-extern struct rtl_opt_pass pass_local_alloc;\n-extern struct rtl_opt_pass pass_global_alloc;\n extern struct rtl_opt_pass pass_ira;\n extern struct rtl_opt_pass pass_postreload;\n extern struct rtl_opt_pass pass_clean_state;"}]}