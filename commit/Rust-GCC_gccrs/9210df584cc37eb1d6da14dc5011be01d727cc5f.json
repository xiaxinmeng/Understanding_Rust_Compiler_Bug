{"sha": "9210df584cc37eb1d6da14dc5011be01d727cc5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIxMGRmNTg0Y2MzN2ViMWQ2ZGExNGRjNTAxMWJlMDFkNzI3Y2M1Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-12T13:49:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-12T13:49:59Z"}, "message": "(REVERSIBLE_CC_MODE): Add default definition.\n\n(reversible_comparison_p): REVERSIBLE_CC_MODE.\n\n(subst): Always simplify true and false arms if if_then_else_cond succeeds.\n(subst, case IF_THEN_ELSE): More canonicalizations; delete some redundant\ntests.\n(if_then_else_cond): Canonicalize (OP (mult COMP A) (mult REV_COMP B)).\n(gen_binary): Simplify (REL_OP (compare X Y) 0) here.\n\nFrom-SVN: r6540", "tree": {"sha": "91a7510737929a2a35275eae80a9a9cfb6903e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91a7510737929a2a35275eae80a9a9cfb6903e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9210df584cc37eb1d6da14dc5011be01d727cc5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9210df584cc37eb1d6da14dc5011be01d727cc5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9210df584cc37eb1d6da14dc5011be01d727cc5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9210df584cc37eb1d6da14dc5011be01d727cc5f/comments", "author": null, "committer": null, "parents": [{"sha": "be8fe4709597973e4a6b029aca7b3d966c05dbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8fe4709597973e4a6b029aca7b3d966c05dbd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be8fe4709597973e4a6b029aca7b3d966c05dbd1"}], "stats": {"total": 239, "additions": 178, "deletions": 61}, "files": [{"sha": "283bdf03dfa044a553f05eb3b6657f671bb0450a", "filename": "gcc/combine.c", "status": "modified", "additions": 178, "deletions": 61, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9210df584cc37eb1d6da14dc5011be01d727cc5f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9210df584cc37eb1d6da14dc5011be01d727cc5f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9210df584cc37eb1d6da14dc5011be01d727cc5f", "patch": "@@ -119,6 +119,13 @@ static int combine_successes;\n /* Totals over entire compilation.  */\n \n static int total_attempts, total_merges, total_extras, total_successes;\n+\n+/* Define a defulat value for REVERSIBLE_CC_MODE.\n+   We can never assume that a condition code mode is safe to reverse unless\n+   the md tells us so.  */\n+#ifndef REVERSIBLE_CC_MODE\n+#define REVERSIBLE_CC_MODE(MODE) 0\n+#endif\n \f\n /* Vector mapping INSN_UIDs to cuids.\n    The cuids are like uids but increase monotonically always.\n@@ -2989,6 +2996,14 @@ subst (x, from, to, in_dest, unique_copy)\n \t  rtx cop1 = const0_rtx;\n \t  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);\n \n+\t  /* Simplify the alternative arms; this may collapse the true and \n+\t     false arms to store-flag values.  */\n+\t  true = subst (true, pc_rtx, pc_rtx, 0, 0);\n+\t  false = subst (false, pc_rtx, pc_rtx, 0, 0);\n+\n+\t  /* Restarting if we generate a store-flag expression will cause\n+\t     us to loop.  Just drop through in this case.  */\n+\n \t  /* If the result values are STORE_FLAG_VALUE and zero, we can\n \t     just make the comparison operation.  */\n \t  if (true == const_true_rtx && false == const0_rtx)\n@@ -3010,12 +3025,15 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t   gen_binary (reverse_condition (cond_code), \n \t\t\t\t       mode, cond, cop1));\n \t  else\n-\t    x = gen_rtx (IF_THEN_ELSE, mode,\n-\t\t\t gen_binary (cond_code, VOIDmode, cond, cop1),\n-\t\t\t subst (true, pc_rtx, pc_rtx, 0, 0),\n-\t\t\t subst (false, pc_rtx, pc_rtx, 0, 0));\n+\t    {\n+\t      x = gen_rtx (IF_THEN_ELSE, mode,\n+\t\t\t   gen_binary (cond_code, VOIDmode, cond, cop1),\n+\t\t\t   true, false);\n+\t      goto restart;\n+\t    }\n \n-\t  goto restart;\n+\t  code = GET_CODE (x);\n+\t  op0_mode = VOIDmode;\n \t}\n     }\n \n@@ -3815,6 +3833,21 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \t  \n     case IF_THEN_ELSE:\n+      /* Simplify storing of the truth value. */\n+      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && XEXP (x, 1) == const_true_rtx\n+\t  && XEXP (x, 2) == const0_rtx)\n+\treturn gen_binary (GET_CODE (XEXP (x, 0)), mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t   XEXP (XEXP (x, 0), 1));\n+      \n+      /* Also when the truth value has to be reversed. */\n+      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && reversible_comparison_p (XEXP (x, 0))\n+\t  && XEXP (x, 1) == const0_rtx\n+\t  && XEXP (x, 2) == const_true_rtx)\n+\treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n+\t\t\t   mode, XEXP (XEXP (x, 0), 0), XEXP (XEXP (x, 0), 1));\n+\n       /* Sometimes we can simplify the arm of an IF_THEN_ELSE if a register\n \t used in it is being compared against certain values.  Get the\n \t true and false comparisons and see if that says anything about the\n@@ -3874,13 +3907,24 @@ subst (x, from, to, in_dest, unique_copy)\n       \n       /* If we have (if_then_else FOO (pc) (label_ref BAR)) and FOO can be\n \t reversed, do so to avoid needing two sets of patterns for\n-\t subtract-and-branch insns.  Similarly if we have a constant in that\n-\t position or if the third operand is the same as the first operand\n-\t of the comparison.  */\n+\t subtract-and-branch insns.  Similarly if we have a constant in the\n+\t true arm, the false arm is the same as the first operand of the\n+\t comparison, or the false arm is more complicated than the true\n+\t arm.  */\n \n       if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n \t  && reversible_comparison_p (XEXP (x, 0))\n-\t  && (XEXP (x, 1) == pc_rtx || GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (XEXP (x, 1) == pc_rtx \n+\t      || (CONSTANT_P (XEXP (x, 1))\n+\t\t  && GET_CODE (XEXP (x, 2)) != CONST_INT\n+\t\t  && XEXP (x, 2) != pc_rtx)\n+\t      || XEXP (x, 1) == const0_rtx\n+\t      || (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == 'o'\n+\t\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 2))) != 'o')\n+\t      || (GET_CODE (XEXP (x, 1)) == SUBREG\n+\t\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 1)))) == 'o'\n+\t\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 2))) != 'o')\n+\t      || reg_mentioned_p (XEXP (x, 1), XEXP (x, 2))\n \t      || rtx_equal_p (XEXP (x, 2), XEXP (XEXP (x, 0), 0))))\n \t{\n \t  SUBST (XEXP (x, 0),\n@@ -3954,7 +3998,10 @@ subst (x, from, to, in_dest, unique_copy)\n \t ZERO_EXTEND or SIGN_EXTEND as long as Z is already extended (so\n \t we don't destroy it).  We can do this kind of thing in some\n \t cases when STORE_FLAG_VALUE is neither of the above, but it isn't\n-\t worth checking for.  */\n+\t worth checking for.\n+\n+\t Similarly, (if_then_else COND Z 0) can be replaced by \n+\t (mult COND (mult Z STORE_FLAG_VALUE)).  */\n \n       if (mode != VOIDmode && ! side_effects_p (x))\n \t{\n@@ -3967,12 +4014,24 @@ subst (x, from, to, in_dest, unique_copy)\n \t  enum machine_mode m = mode;\n \t  rtx z = 0, c1, c2;\n \n+\t  if (f == const0_rtx)\n+\t    return gen_binary (MULT, mode, gen_binary (cond_op, mode, cond_op0,\n+\t\t\t\t\t\t       cond_op1),\n+\t\t\t       gen_binary (MULT, mode, t, const_true_rtx));\n+\n \t  if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n \t       || GET_CODE (t) == IOR || GET_CODE (t) == XOR\n \t       || GET_CODE (t) == ASHIFT\n \t       || GET_CODE (t) == LSHIFTRT || GET_CODE (t) == ASHIFTRT)\n \t      && rtx_equal_p (XEXP (t, 0), f))\n \t    c1 = XEXP (t, 1), op = GET_CODE (t), z = f;\n+\n+\t  /* If an identity-zero op is commutative, check whether there\n+\t     would be a match if we swapped the operands. */\n+\t  else if ((GET_CODE (t) == PLUS || GET_CODE (t) == IOR\n+\t\t    || GET_CODE (t) == XOR)\n+\t\t   && rtx_equal_p (XEXP (t, 1), f))\n+\t    c1 = XEXP (t, 0), op = GET_CODE (t), z = f;\n \t  else if (GET_CODE (t) == SIGN_EXTEND\n \t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n \t\t       || GET_CODE (XEXP (t, 0)) == MINUS\n@@ -3986,12 +4045,29 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n \t\t   && (num_sign_bit_copies (f, GET_MODE (f))\n \t\t       > (GET_MODE_BITSIZE (mode)\n-\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0), 0))))))\n+\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0),\n+\t\t\t\t\t\t\t      0))))))\n \t    {\n \t      c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n \t      extend_op = SIGN_EXTEND;\n \t      m = GET_MODE (XEXP (t, 0));\n \t    }\n+\t  else if (GET_CODE (t) == SIGN_EXTEND\n+\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (t, 0)) == XOR)\n+\t\t   && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n+\t\t   && (num_sign_bit_copies (f, GET_MODE (f))\n+\t\t       > (GET_MODE_BITSIZE (mode)\n+\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0),\n+\t\t\t\t\t\t\t      1))))))\n+\t    {\n+\t      c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n+\t      extend_op = SIGN_EXTEND;\n+\t      m = GET_MODE (XEXP (t, 0));\n+\t    }\n \t  else if (GET_CODE (t) == ZERO_EXTEND\n \t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n \t\t       || GET_CODE (XEXP (t, 0)) == MINUS\n@@ -4012,58 +4088,21 @@ subst (x, from, to, in_dest, unique_copy)\n \t      extend_op = ZERO_EXTEND;\n \t      m = GET_MODE (XEXP (t, 0));\n \t    }\n-\n-\t  else if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t\t   && reversible_comparison_p (XEXP (x, 0))\n-\t\t   && (GET_CODE (f) == PLUS || GET_CODE (f) == MINUS\n-\t\t       || GET_CODE (f) == IOR || GET_CODE (f) == XOR\n-\t\t       || GET_CODE (f) == ASHIFT\n-\t\t       || GET_CODE (f) == LSHIFTRT || GET_CODE (f) == ASHIFTRT)\n-\t\t   && rtx_equal_p (XEXP (f, 0), t))\n-\t    {\n-\t      c1 = XEXP (f, 1), op = GET_CODE (f), z = t;\n-\t      cond_op = reverse_condition (cond_op);\n-\t    }\n-\t  else if (GET_CODE (f) == SIGN_EXTEND\n-\t\t   && (GET_CODE (XEXP (f, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (f, 0)) == MINUS\n-\t\t       || GET_CODE (XEXP (f, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (f, 0)) == XOR\n-\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFT\n-\t\t       || GET_CODE (XEXP (f, 0)) == LSHIFTRT\n-\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFTRT)\n-\t\t   && GET_CODE (XEXP (XEXP (f, 0), 0)) == SUBREG\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (f, 0), 0))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (f, 0), 0)), f)\n-\t\t   && (num_sign_bit_copies (t, GET_MODE (t))\n-\t\t       > (GET_MODE_BITSIZE (mode)\n-\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (f, 0), 0))))))\n-\t    {\n-\t      c1 = XEXP (XEXP (f, 0), 1); z = t; op = GET_CODE (XEXP (f, 0));\n-\t      extend_op = SIGN_EXTEND;\n-\t      m = GET_MODE (XEXP (f, 0));\n-\t      cond_op = reverse_condition (cond_op);\n-\t    }\n-\t  else if (GET_CODE (f) == ZERO_EXTEND\n-\t\t   && (GET_CODE (XEXP (f, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (f, 0)) == MINUS\n-\t\t       || GET_CODE (XEXP (f, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (f, 0)) == XOR\n-\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFT\n-\t\t       || GET_CODE (XEXP (f, 0)) == LSHIFTRT\n-\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFTRT)\n-\t\t   && GET_CODE (XEXP (XEXP (f, 0), 0)) == SUBREG\n+\t  else if (GET_CODE (t) == ZERO_EXTEND\n+\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (t, 0)) == XOR)\n+\t\t   && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n \t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (f, 0), 0))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (f, 0), 0)), t)\n-\t\t   && ((nonzero_bits (t, GET_MODE (t))\n-\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (f, 0), 0))))\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n+\t\t   && ((nonzero_bits (f, GET_MODE (f))\n+\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 1))))\n \t\t       == 0))\n \t    {\n-\t      c1 = XEXP (XEXP (f, 0), 1); z = t; op = GET_CODE (XEXP (f, 0));\n+\t      c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n \t      extend_op = ZERO_EXTEND;\n-\t      m = GET_MODE (XEXP (f, 0));\n-\t      cond_op = reverse_condition (cond_op);\n+\t      m = GET_MODE (XEXP (t, 0));\n \t    }\n \n \t  if (z)\n@@ -4073,8 +4112,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n \n \t      temp = gen_binary (MULT, m, temp,\n-\t\t\t\t gen_binary (MULT, m, c1,\n-\t\t\t\t\t     GEN_INT (STORE_FLAG_VALUE)));\n+\t\t\t\t gen_binary (MULT, m, c1, const_true_rtx));\n \n \t      temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n \n@@ -6110,6 +6148,68 @@ if_then_else_cond (x, ptrue, pfalse)\n \t  *pfalse = gen_binary (code, mode, false0, false1);\n \t  return cond0 ? cond0 : cond1;\n \t}\n+\n+#if STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1\n+\n+      /* See if we have PLUS, IOR, XOR, MINUS or UMAX, where one of the\n+\t operands is zero when the other is non-zero, and vice-versa.  */\n+\n+      if ((code == PLUS || code == IOR || code == XOR || code == MINUS\n+\t   || code == UMAX)\n+\t  && GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == MULT)\n+\t{\n+\t  rtx op0 = XEXP (XEXP (x, 0), 1);\n+\t  rtx op1 = XEXP (XEXP (x, 1), 1);\n+\n+\t  cond0 = XEXP (XEXP (x, 0), 0);\n+\t  cond1 = XEXP (XEXP (x, 1), 0);\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (cond0)) == '<'\n+\t      && GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n+\t      && reversible_comparison_p (cond1)\n+\t      && ((GET_CODE (cond0) == reverse_condition (GET_CODE (cond1))\n+\t\t   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))\n+\t\t   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))\n+\t\t  || ((swap_condition (GET_CODE (cond0))\n+\t\t       == reverse_condition (GET_CODE (cond1)))\n+\t\t      && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 1))\n+\t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n+\t      && ! side_effects_p (x))\n+\t    {\n+\t      *ptrue = gen_binary (MULT, mode, op0, const_true_rtx);\n+\t      *pfalse = gen_binary (MULT, mode, \n+\t\t\t\t    (code == MINUS \n+\t\t\t\t     ? gen_unary (NEG, mode, op1) : op1),\n+\t\t\t\t    const_true_rtx);\n+\t      return cond0;\n+\t    }\n+\t}\n+\n+      /* Similarly for MULT, AND and UMIN, execpt that for these the result\n+\t is always zero.  */\n+      if ((code == MULT || code == AND || code == UMIN)\n+\t  && GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == MULT)\n+\t{\n+\t  cond0 = XEXP (XEXP (x, 0), 0);\n+\t  cond1 = XEXP (XEXP (x, 1), 0);\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (cond0)) == '<'\n+\t      && GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n+\t      && reversible_comparison_p (cond1)\n+\t      && ((GET_CODE (cond0) == reverse_condition (GET_CODE (cond1))\n+\t\t   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))\n+\t\t   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))\n+\t\t  || ((swap_condition (GET_CODE (cond0))\n+\t\t       == reverse_condition (GET_CODE (cond1)))\n+\t\t      && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 1))\n+\t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n+\t      && ! side_effects_p (x))\n+\t    {\n+\t      *ptrue = *pfalse = const0_rtx;\n+\t      return cond0;\n+\t    }\n+\t}\n+#endif\n     }\n \n   else if (code == IF_THEN_ELSE)\n@@ -8383,6 +8483,16 @@ gen_binary (code, mode, op0, op1)\n   if (GET_RTX_CLASS (code) == '<') \n     {\n       enum machine_mode op_mode = GET_MODE (op0);\n+\n+      /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get \n+\t just (REL_OP X Y). */\n+      if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n+\t{\n+\t  op1 = XEXP (op0, 1);\n+\t  op0 = XEXP (op0, 0);\n+\t  op_mode = GET_MODE (op0);\n+\t}\n+\n       if (op_mode == VOIDmode)\n \top_mode = GET_MODE (op1);\n       result = simplify_relational_operation (code, op_mode, op0, op1);\n@@ -9404,6 +9514,13 @@ reversible_comparison_p (x)\n       return 1;\n \n     case MODE_CC:\n+      /* If the mode of the condition codes tells us that this is safe,\n+\t we need look no further.  */\n+      if (REVERSIBLE_CC_MODE (GET_MODE (XEXP (x, 0))))\n+\treturn 1;\n+\n+      /* Otherwise try and find where the condition codes were last set and\n+\t use that.  */\n       x = get_last_value (XEXP (x, 0));\n       return (x && GET_CODE (x) == COMPARE\n \t      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0))));"}]}