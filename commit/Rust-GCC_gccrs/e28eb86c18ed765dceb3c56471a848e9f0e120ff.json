{"sha": "e28eb86c18ed765dceb3c56471a848e9f0e120ff", "node_id": "C_kwDOANBUbNoAKGUyOGViODZjMThlZDc2NWRjZWIzYzU2NDcxYTg0OGU5ZjBlMTIwZmY", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-02-16T21:24:03Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-03-04T14:47:06Z"}, "message": "Test 'libgomp.oacc-*/kernels-private-vars-*' with '--param=openacc-kernels=decompose' [PR104784]\n\nBefore recent commit 8935589b496f755e08cadf26d8ceddf0dd6e0968\n\"OMP lowering: Regimplify 'OMP_CLAUSE_MAP_DECL_MAKE_ADDRESSABLE' DECLs\n[PR100280, PR104132, PR104133]\", 'libgomp.oacc-c' testing already worked fine,\nbut 'libgomp.oacc-c++' testing ICEed.  Via the commit mentioned, the C++\ntesting ICEs are now resolved, but the underlying issue remains to be looked\ninto: PR104784 \"OpenACC 'kernels' decomposition: C vs. C++ differences\".\n\n\tPR middle-end/104784\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-1.c:\n\tTest with '--param=openacc-kernels=decompose'.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-3.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-4.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-5.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-3.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-4.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-5.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-6.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-2.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-3.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-4.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-5.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-6.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-7.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90:\n\tLikewise.", "tree": {"sha": "3361baa64ff7f126f01699e0d15f7982303c2192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3361baa64ff7f126f01699e0d15f7982303c2192"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28eb86c18ed765dceb3c56471a848e9f0e120ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28eb86c18ed765dceb3c56471a848e9f0e120ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28eb86c18ed765dceb3c56471a848e9f0e120ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28eb86c18ed765dceb3c56471a848e9f0e120ff/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c85aaf2cbe9da50e23655a8082a37166adf4c0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85aaf2cbe9da50e23655a8082a37166adf4c0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85aaf2cbe9da50e23655a8082a37166adf4c0f7"}], "stats": {"total": 460, "additions": 361, "deletions": 99}, "files": [{"sha": "43bfaf331ab709b0d284bb1103a88214a165a002", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-1.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-1.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Back-to-back worker loops.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,16 +30,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n \t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n@@ -50,7 +62,8 @@ main (int argc, char* argv[])\n \t  }\n \n \t#pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n@@ -64,8 +77,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "c40c2ab33c5a078771524f26f14669a4cf4062c7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-2.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-2.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Successive vector loops.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,16 +30,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'x' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n@@ -56,8 +68,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "bd04dcc7b02315fe083711a858c9d4f82ad671eb", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-3.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-3.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Aggregate worker variable.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -31,16 +35,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'pt' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n@@ -62,8 +74,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "4303ab848eab1f31feb56a52e6a631e73e0d8e90", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-4.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-4.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Addressable worker variable.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -31,16 +35,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'pt' declared in block is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'ptp' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n@@ -66,8 +78,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "8d0e846ce238ba0c949e4adbaf593ec58c3e62fe", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-local-worker-5.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-local-worker-5.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared in a local scope, broadcasting\n    to vector-partitioned mode.  Array worker variable.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,16 +30,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'pt' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n@@ -58,8 +70,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += pt[1] * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "470d5e65da4a94d6074dd0de31db1e532d75ebb9", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-1.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-1.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,10 +1,14 @@\n /* Test of gang-private variables declared on loop directive.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,8 +28,9 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  #pragma acc kernels copy(arr)\n   {\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n     /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n@@ -34,8 +39,8 @@ main (int argc, char* argv[])\n \tx = i * 2;\n \tarr[i] += x;\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     assert (arr[i] == i * 3);"}, {"sha": "34513e35f22e8bebbabe541235cecd8c910b2e50", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-2.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-2.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of gang-private variables declared on loop directive, with broadcasting\n    to partitioned workers.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -25,8 +29,9 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  #pragma acc kernels copy(arr)\n   {\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n     /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n@@ -40,8 +45,8 @@ main (int argc, char* argv[])\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x;\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 2);"}, {"sha": "ef445c82a93ad60bd9b7c11de6b4812c6757f86d", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-3.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-3.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of gang-private variables declared on loop directive, with broadcasting\n    to partitioned vectors.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -25,8 +29,9 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  #pragma acc kernels copy(arr)\n   {\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n     /* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n@@ -40,8 +45,8 @@ main (int argc, char* argv[])\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x;\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 2);"}, {"sha": "0658251ea2a33e88d3e23baf4bd19396f21e3078", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-4.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-4.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of gang-private addressable variable declared on loop directive, with\n    broadcasting to partitioned workers.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,7 +30,9 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  /* { dg-note {variable 'x\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n     /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n@@ -45,8 +51,8 @@ main (int argc, char* argv[])\n \n \t(*p)--;\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 2);"}, {"sha": "a5118666c63eacf0890f71fdbdc6304a9a78fb8a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-5.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-5.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of gang-private array variable declared on loop directive, with\n    broadcasting to partitioned workers.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -25,8 +29,9 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  #pragma acc kernels copy(arr)\n   {\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) private(x) /* { dg-line l_loop_i[incr c_loop_i] } */\n     /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n@@ -41,8 +46,8 @@ main (int argc, char* argv[])\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += x[j % 8];\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i % 8) * 2);"}, {"sha": "119bda3b2dcf0f64db3f69787b4ffc853e1bb831", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-gang-6.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-gang-6.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of gang-private aggregate variable declared on loop directive, with\n    broadcasting to partitioned workers.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -31,8 +35,9 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n+  #pragma acc kernels copy(arr)\n   {\n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang private(pt) /* { dg-line l_loop_i[incr c_loop_i] } */\n     /* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n@@ -49,8 +54,8 @@ main (int argc, char* argv[])\n \tfor (int j = 0; j < 32; j++)\n \t  arr[i * 32 + j] += pt.x + pt.y + pt.z + pt.attr[5];\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + (i / 32) * 13);"}, {"sha": "5a70bb880e525681ffea4a1f1bd3725e00da5285", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-1.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-1.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,10 +1,14 @@\n /* Test of vector-private variables declared on loop directive.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -25,16 +29,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -59,8 +71,8 @@ main (int argc, char* argv[])\n \t      }\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "f5bccabbe6f525eb9625c09426f362bb5e9bdbd2", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-vector-2.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-vector-2.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,10 +1,14 @@\n /* Test of vector-private variables declared on loop directive. Array type.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -25,16 +29,24 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c} l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) /* { dg-line l_loop_j[incr c_loop_j] } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -52,8 +64,8 @@ main (int argc, char* argv[])\n \t      }\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "9b2c49ac301e7a6042176c1979d75c09db7170af", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-1.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-1.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,10 +1,14 @@\n /* Test of worker-private variables declared on a loop directive.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,12 +28,13 @@ main (int argc, char* argv[])\n   for (i = 0; i < 32 * 32; i++)\n     arr[i] = i;\n \n-  #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  #pragma acc kernels copy(arr)\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n@@ -45,8 +50,8 @@ main (int argc, char* argv[])\n \t    arr[i * 32 + j] += x;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32 * 32; i++)\n     assert (arr[i] == i + ((i / 32) ^ (i % 32) * 3));"}, {"sha": "40baae345621a1fcaf54f9cb55d2be33a9b860b7", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-2.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-2.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,17 +30,25 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -49,8 +61,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "c8b089c0f59fae77ee65ffe2e1d905859b4e31e0", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-3.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-3.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Back-to-back worker loops.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,17 +30,25 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -51,7 +63,8 @@ main (int argc, char* argv[])\n \n \t#pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -64,8 +77,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "c1819d27179610ef6d6aa182e2ae7dfa9ea13f64", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-4.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-4.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Successive vector loops.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,17 +30,25 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -56,8 +68,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "90955aa8f6e2bf8eb9ac6da2bbcf0600c27238a3", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-5.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-5.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Addressable worker variable.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -26,17 +30,26 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n+  /* { dg-note {variable 'x\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) private(x) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'p' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n@@ -59,8 +72,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += x * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "f093cfe630bd0505d951aba3ced1aae8078d4a3a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-6.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-6.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared on a loop directive, broadcasting\n    to vector-partitioned mode.  Aggregate worker variable.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -32,17 +36,25 @@ main (int argc, char* argv[])\n     arr[i] = i;\n \n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         #pragma acc loop worker(num:32) private(pt) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -62,8 +74,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += pt.y * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "906119caf2453527ebf095cafc715478244c61b5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-private-vars-loop-worker-7.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-private-vars-loop-worker-7.c?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -1,11 +1,15 @@\n /* Test of worker-private variables declared on loop directive, broadcasting\n    to vector-partitioned mode.  Array worker variable.  */\n \n+/* { dg-additional-options \"--param=openacc-kernels=decompose\" } */\n+\n /* { dg-additional-options \"-fopt-info-omp-all\" }\n    { dg-additional-options \"-foffload=-fopt-info-omp-all\" } */\n \n /* { dg-additional-options \"--param=openacc-privatization=noisy\" }\n-   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" } */\n+   { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+   Prune a few: uninteresting:\n+   { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} } */\n \n /* It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n    passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -29,18 +33,26 @@ main (int argc, char* argv[])\n   /* \"pt\" is treated as \"present_or_copy\" on the kernels directive because it\n      is an array variable.  */\n   #pragma acc kernels copy(arr) /* { dg-line l_compute[incr c_compute] } */\n-  /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute } */\n+  /* [PR104784] For some reason, for C++, the OpenACC 'kernels' decomposition\n+     decides that a data region is needed for 'j', and subsequently requests it\n+     to be made addressable.\n+     { dg-note {OpenACC 'kernels' decomposition: variable 'j' declared in block requested to be made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' made addressable} {} { target c++ } l_compute$c_compute }\n+     { dg-note {variable 'j' declared in block is candidate for adjusting OpenACC privatization level} {} { target c++ } l_compute$c_compute } */\n   {\n     int j;\n \n+    /* { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 } */\n     #pragma acc loop gang(num:32) /* { dg-line l_loop_i[incr c_loop_i] } */\n+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_i$c_loop_i } */\n     /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i } */\n     for (i = 0; i < 32; i++)\n       {\n         /* But here, it is made private per-worker.  */\n         #pragma acc loop worker(num:32) private(pt) /* { dg-line l_loop_j[incr c_loop_j] } */\n \t/* { dg-note {variable 'pt' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n-\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n+\t/* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target c } l_loop_j$c_loop_j }\n+\t   { dg-note {variable 'j' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target c++ } l_loop_j$c_loop_j } */\n \t/* { dg-note {variable 'k' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_j$c_loop_j } */\n \tfor (j = 0; j < 32; j++)\n \t  {\n@@ -61,8 +73,8 @@ main (int argc, char* argv[])\n \t      arr[i * 1024 + j * 32 + k] += pt[1] * k;\n \t  }\n       }\n+    /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i } */\n   }\n-  /* { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute } */\n \n   for (i = 0; i < 32; i++)\n     for (int j = 0; j < 32; j++)"}, {"sha": "b4f44d69de15ddcc51af8802ad6b36d9370438e5", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-1.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-1.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -2,11 +2,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -23,16 +27,17 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 1, 32\n      x = i * 2;\n      arr(i) = arr(i) + x;\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 1, 32\n      if (arr(i) .ne. i * 3) stop 1"}, {"sha": "f4194c96f900e42606859d426e824ce1fa007a19", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-2.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-2.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,7 +28,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n@@ -37,8 +42,8 @@ program main\n         arr(i * 32 + j) = arr(i * 32 + j) + x;\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + (i / 32) * 2) stop 1"}, {"sha": "da85ac485adfcdfbac788a7177571295eb28b779", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-3.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-3.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,7 +28,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-note {variable 'x' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n@@ -37,8 +42,8 @@ program main\n         arr(i * 32 + j) = arr(i * 32 + j) + x;\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + (i / 32) * 2) stop 1"}, {"sha": "b2bcf11cef0c0c70794e64439b1a5b4a75dcc302", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-gang-6.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-gang-6.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -29,7 +33,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) private(pt) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   ! { dg-note {variable 'pt' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop_i$c_loop_i }\n@@ -45,8 +50,8 @@ program main\n         arr(i * 32 + j) = arr(i * 32 + j) + pt%x + pt%y + pt%z + pt%attr(5);\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + (i / 32) * 13) stop 1"}, {"sha": "eba7263ae563825b66e32bce1b2e33be44d80fe6", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-1.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-1.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -2,11 +2,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -23,7 +27,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -46,8 +51,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "7d1c6885cee669fa88f18cd0cc846a63b2b94aa6", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-vector-2.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-vector-2.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -2,11 +2,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -23,7 +27,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -41,8 +46,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "d459a6f185e59e9a246e59f47dbd5f22b77cfbba", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-1.f90", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-1.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -2,11 +2,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -25,6 +29,8 @@ program main\n   end do\n \n   !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-note {variable 'x\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) private(x) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -36,8 +42,8 @@ program main\n         arr(i * 32 + j) = arr(i * 32 + j) + x\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 * 32 - 1\n      if (arr(i) .ne. i + ieor(i / 32, mod(i, 32) * 3)) stop 1"}, {"sha": "c3a4e2a3406aa3ceb58abb136e35c07211fd0b16", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-2.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-2.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,7 +28,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -41,8 +46,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "db6097b6fd58445666d5ba8d828ddb63177a33bd", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-3.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-3.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,7 +28,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -54,8 +59,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "a0b6c29d466e2ce675772902ec57763916e530a8", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-4.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-4.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,7 +28,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -49,8 +54,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "22c0b9b1045ddc6e90b1b9755d77d7d6bca01621", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-5.f90", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-5.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -27,6 +31,8 @@ program main\n   end do\n \n   !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  ! { dg-note {variable 'x\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_compute$c_compute }\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -53,8 +59,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "1b4d50365966d66ae79db191b4f6a1ca2c047288", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-6.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-6.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -29,7 +33,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -53,8 +58,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}, {"sha": "9ee8a5afc2e8117bf58b2e701cf82d9155658592", "filename": "libgomp/testsuite/libgomp.oacc-fortran/kernels-private-vars-loop-worker-7.f90", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28eb86c18ed765dceb3c56471a848e9f0e120ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fkernels-private-vars-loop-worker-7.f90?ref=e28eb86c18ed765dceb3c56471a848e9f0e120ff", "patch": "@@ -3,11 +3,15 @@\n \n ! { dg-do run }\n \n+! { dg-additional-options \"--param=openacc-kernels=decompose\" }\n+\n ! { dg-additional-options \"-fopt-info-omp-all\" }\n ! { dg-additional-options \"-foffload=-fopt-info-omp-all\" }\n \n ! { dg-additional-options \"--param=openacc-privatization=noisy\" }\n ! { dg-additional-options \"-foffload=--param=openacc-privatization=noisy\" }\n+! Prune a few: uninteresting:\n+! { dg-prune-output {note: variable 'D\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} }\n \n ! It's only with Tcl 8.5 (released in 2007) that \"the variable 'varName'\n ! passed to 'incr' may be unset, and in that case, it will be set to [...]\",\n@@ -24,7 +28,8 @@ program main\n      arr(i) = i\n   end do\n \n-  !$acc kernels copy(arr) ! { dg-line l_compute[incr c_compute] }\n+  !$acc kernels copy(arr)\n+  ! { dg-note {forwarded loop nest in OpenACC 'kernels' region to 'parloops' for analysis} {} { target *-*-* } .+1 }\n   !$acc loop gang(num:32) ! { dg-line l_loop_i[incr c_loop_i] }\n   ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop_i$c_loop_i }\n   do i = 0, 31\n@@ -48,8 +53,8 @@ program main\n         end do\n      end do\n   end do\n+  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_loop_i$c_loop_i }\n   !$acc end kernels\n-  ! { dg-optimized {assigned OpenACC seq loop parallelism} {} { target *-*-* } l_compute$c_compute }\n \n   do i = 0, 32 - 1\n      do j = 0, 32 -1"}]}