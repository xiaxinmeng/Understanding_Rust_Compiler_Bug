{"sha": "636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2YWQ3ZDk1ZTBmMmFmYTE1NDRiYTdkZWVhZGYzZDUyZGUxOGE4Mg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-13T10:50:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-13T10:50:13Z"}, "message": "Merge #358\n\n358: Canonical Paths for Name Resolution and handle TurboFish properly r=philberty a=philberty\n\nAdd Canonical paths to name resolution\r\n    \r\nIn order to support name resolution and checks for duplicate definitions\r\nof names we need canonical paths for all DefId items such as inherent impl\r\nitems and normal items. Consider:\r\n\r\n```rust\r\n  struct Foo<T>(T);\r\n\r\n  impl Foo<f32> {\r\n    fn name()...\r\n  }\r\n\r\n  impl Foo<i32> {\r\n    fn name()...\r\n  }\r\n```\r\n\r\nEach of the impl blocks have a name function but these are separate due to\r\nthe concrete impl of the Parameter type passed in.\r\n\r\nThe caveat here is that to call this Function name the programmer must be\r\nexplicit in which implentation they wish to call such as:\r\n\r\n```rust\r\n  let a = Foo::<f32>::name();\r\n```\r\n\r\nThis lets the Path probe lookup the appropriate impl block. The problem here\r\nis that rust also allows for the compiler to infer the impl you wish such\r\nas:\r\n\r\n```rust\r\n  let a = Foo::name();\r\n```\r\n\r\nThis should fail since there are multiple candidates possible for this\r\nPath. Unless there might have only been one name function in which case\r\nit would have worked.\r\n\r\nThis patch is also responsible to implement PathInExpression by iterating\r\neach segment and applying generic arguments as we go.\r\n\r\nFixes #355 #335 #325 #353\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "fc50976ff47ed0e69ec2d483188e075f7066d2d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc50976ff47ed0e69ec2d483188e075f7066d2d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgdXdlCRBK7hj4Ov3rIwAAdHIIAChaayP6FRQ4pR4PWR7dUwMd\nZs026xtvsSa99Zrmik0g6YIM5tySBOsa1fyM5AdWd2ij5Uu2xcxcRX535X9DHTB6\nquuJILveEAgveRHjHWFx5nCC+UrvaxwiXj3VEIlfgYZXFFfesLsI46mce16TF96q\nJqS+obgjhAUpnLtvI8VBcVNRW1qCryrMsm2rpz37OH6q6XWgvpUvHaoB9fxiigJn\n6Si6JOZCkPXwbGdgGT266rRNYTVZz6JCFOFSMLL7KChSaeaYTkk4YJGlaeGHlZef\nNXBS74IKzYC36yKRk2XJYee0bO6nPUXzLcWijcw112h1mkbtE+32m30R4UmjUoQ=\n=zheZ\n-----END PGP SIGNATURE-----\n", "payload": "tree fc50976ff47ed0e69ec2d483188e075f7066d2d2\nparent ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438\nparent 4ee35b6edb549be11571536bf78f8585a0282991\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618311013 +0000\ncommitter GitHub <noreply@github.com> 1618311013 +0000\n\nMerge #358\n\n358: Canonical Paths for Name Resolution and handle TurboFish properly r=philberty a=philberty\n\nAdd Canonical paths to name resolution\r\n    \r\nIn order to support name resolution and checks for duplicate definitions\r\nof names we need canonical paths for all DefId items such as inherent impl\r\nitems and normal items. Consider:\r\n\r\n```rust\r\n  struct Foo<T>(T);\r\n\r\n  impl Foo<f32> {\r\n    fn name()...\r\n  }\r\n\r\n  impl Foo<i32> {\r\n    fn name()...\r\n  }\r\n```\r\n\r\nEach of the impl blocks have a name function but these are separate due to\r\nthe concrete impl of the Parameter type passed in.\r\n\r\nThe caveat here is that to call this Function name the programmer must be\r\nexplicit in which implentation they wish to call such as:\r\n\r\n```rust\r\n  let a = Foo::<f32>::name();\r\n```\r\n\r\nThis lets the Path probe lookup the appropriate impl block. The problem here\r\nis that rust also allows for the compiler to infer the impl you wish such\r\nas:\r\n\r\n```rust\r\n  let a = Foo::name();\r\n```\r\n\r\nThis should fail since there are multiple candidates possible for this\r\nPath. Unless there might have only been one name function in which case\r\nit would have worked.\r\n\r\nThis patch is also responsible to implement PathInExpression by iterating\r\neach segment and applying generic arguments as we go.\r\n\r\nFixes #355 #335 #325 #353\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8744db3e56bfcf0cf3f0e2a0bf76450aef9438"}, {"sha": "4ee35b6edb549be11571536bf78f8585a0282991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee35b6edb549be11571536bf78f8585a0282991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee35b6edb549be11571536bf78f8585a0282991"}], "stats": {"total": 2787, "additions": 2347, "deletions": 440}, "files": [{"sha": "f98ebc66ad4f7985d6f9edc2cf46e24318103907", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -526,7 +526,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::PathInExpression &expr) override\n   {\n-    translated = ResolvePathRef::Compile (&expr, ctx);\n+    translated = ResolvePathRef::Compile (expr, ctx);\n   }\n \n   void visit (HIR::LoopExpr &expr) override"}, {"sha": "30486d091955e0125572d96073824f9c326de55b", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -30,10 +30,10 @@ class ResolvePathRef : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  static Bexpression *Compile (HIR::PathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n-    expr->accept_vis (resolver);\n+    expr.accept_vis (resolver);\n     return resolver.resolved;\n   }\n "}, {"sha": "18ead3c788b5192d30dd3f9b4070f89c1d304bf4", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -360,12 +360,14 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n     std::vector<std::unique_ptr<HIR::InherentImplItem> > impl_items;\n+    std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n \tHIR::InherentImplItem *lowered\n \t  = ASTLowerImplItem::translate (impl_item.get (),\n \t\t\t\t\t mapping.get_hirid ());\n \timpl_items.push_back (std::unique_ptr<HIR::InherentImplItem> (lowered));\n+\timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n       }\n \n     translated\n@@ -381,6 +383,13 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t       translated);\n     mappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t       impl_block.get_locus ());\n+\n+    for (auto &impl_item_id : impl_item_ids)\n+      {\n+\tmappings->insert_impl_item_mapping (impl_item_id,\n+\t\t\t\t\t    static_cast<HIR::InherentImpl *> (\n+\t\t\t\t\t      translated));\n+      }\n   }\n \n private:"}, {"sha": "d6f9fc0c72dfbe95bedaef1463044d6abe6ab822", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -255,6 +255,12 @@ class PathPattern : public Pattern\n       }\n   }\n \n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  std::vector<PathExprSegment> &get_segments () { return segments; }\n+\n+  PathExprSegment &get_root_seg () { return segments.at (0); }\n+\n   PathExprSegment get_final_segment () const { return segments.back (); }\n };\n "}, {"sha": "fbf05f2ad7d6fd48a551e208db1a8a89580f3886", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -109,15 +109,16 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr) override\n   {\n-    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (resolver->get_name_scope ().lookup (CanonicalPath (expr.as_string ()),\n+\t\t\t\t\t    &resolved_node))\n       {\n \tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n \t\t\t\t\t Definition{expr.get_node_id (),\n \t\t\t\t\t\t    parent});\n       }\n-    else if (resolver->get_type_scope ().lookup (expr.as_string (),\n-\t\t\t\t\t\t &resolved_node))\n+    else if (resolver->get_type_scope ().lookup (\n+\t       CanonicalPath (expr.as_string ()), &resolved_node))\n       {\n \tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n@@ -255,8 +256,9 @@ class ResolveExpr : public ResolverBase\n \tauto label_name = label.get_lifetime ().get_lifetime_name ();\n \tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n \tresolver->get_label_scope ().insert (\n-\t  label_name, label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (std::string, NodeId, Location locus) -> void {\n+\t  CanonicalPath (label_name), label_lifetime_node_id,\n+\t  label.get_locus (), false,\n+\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t    rust_error_at (label.get_locus (),\n \t\t\t   \"label redefined multiple times\");\n \t    rust_error_at (locus, \"was defined here\");\n@@ -281,8 +283,8 @@ class ResolveExpr : public ResolverBase\n \t  }\n \n \tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (label.get_lifetime_name (),\n-\t\t\t\t\t\t  &resolved_node))\n+\tif (!resolver->get_label_scope ().lookup (\n+\t      CanonicalPath (label.get_lifetime_name ()), &resolved_node))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to resolve label\");\n@@ -311,8 +313,9 @@ class ResolveExpr : public ResolverBase\n \tauto label_name = label.get_lifetime ().get_lifetime_name ();\n \tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n \tresolver->get_label_scope ().insert (\n-\t  label_name, label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (std::string, NodeId, Location locus) -> void {\n+\t  CanonicalPath (label_name), label_lifetime_node_id,\n+\t  label.get_locus (), false,\n+\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t    rust_error_at (label.get_locus (),\n \t\t\t   \"label redefined multiple times\");\n \t    rust_error_at (locus, \"was defined here\");\n@@ -338,8 +341,8 @@ class ResolveExpr : public ResolverBase\n \t  }\n \n \tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (label.get_lifetime_name (),\n-\t\t\t\t\t\t  &resolved_node))\n+\tif (!resolver->get_label_scope ().lookup (\n+\t      CanonicalPath (label.get_lifetime_name ()), &resolved_node))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to resolve label\");"}, {"sha": "46343c2796eb29f55677a50a1ed95ced2cfbcf04", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -31,25 +31,19 @@ class ResolveToplevelImplItem : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::InherentImplItem *item, AST::Type *base)\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &prefix)\n   {\n-    ResolveToplevelImplItem resolver (base);\n-    if (resolver.base_path.is_empty ())\n-      {\n-\trust_error_at (base->get_locus_slow (),\n-\t\t       \"failed to resolve simple path\");\n-\treturn;\n-      }\n+    ResolveToplevelImplItem resolver (prefix);\n     item->accept_vis (resolver);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    std::string identifier\n-      = base_path.as_string () + \"::\" + constant.get_identifier ();\n+    auto path\n+      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n     resolver->get_name_scope ().insert (\n-      identifier, constant.get_node_id (), constant.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (constant.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -60,11 +54,11 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    std::string identifier\n-      = base_path.as_string () + \"::\" + function.get_function_name ();\n+    auto path\n+      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n     resolver->get_name_scope ().insert (\n-      identifier, function.get_node_id (), function.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (function.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -75,11 +69,11 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n-    std::string identifier\n-      = base_path.as_string () + \"::\" + method.get_method_name ();\n+    auto path\n+      = prefix.append (ResolveMethodItemToCanonicalPath::resolve (method));\n     resolver->get_name_scope ().insert (\n-      identifier, method.get_node_id (), method.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, method.get_node_id (), method.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (method.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -89,15 +83,13 @@ class ResolveToplevelImplItem : public ResolverBase\n   }\n \n private:\n-  ResolveToplevelImplItem (AST::Type *base)\n-    : ResolverBase (UNKNOWN_NODEID), base (base),\n-      base_path (AST::SimplePath::create_empty ())\n+  ResolveToplevelImplItem (const CanonicalPath &prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n   {\n-    ResolveTypeToSimplePath::go (base, base_path, true);\n+    rust_assert (!prefix.is_error ());\n   }\n \n-  AST::Type *base;\n-  AST::SimplePath base_path;\n+  const CanonicalPath &prefix;\n };\n \n } // namespace Resolver"}, {"sha": "9c19ce6d26f4c27e37016aea8dc20b4154a0356b", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -179,18 +179,21 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    bool canonicalize_type_with_generics = false;\n     NodeId resolved_node = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t\t\t    impl_block.get_node_id ());\n+\t\t\t\t\t    impl_block.get_node_id (),\n+\t\t\t\t\t    canonicalize_type_with_generics);\n     if (resolved_node == UNKNOWN_NODEID)\n       return;\n \n+    auto Self = CanonicalPath::get_big_self ();\n     resolver->get_type_scope ().insert (\n-      \"Self\", resolved_node, impl_block.get_type ()->get_locus_slow ());\n+      Self, resolved_node, impl_block.get_type ()->get_locus_slow ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       impl_item->accept_vis (*this);\n \n-    resolver->get_type_scope ().peek ()->clear_name (\"Self\", resolved_node);\n+    resolver->get_type_scope ().peek ()->clear_name (Self, resolved_node);\n     resolver->get_type_scope ().pop ();\n   }\n "}, {"sha": "07349081fcf246b870f393b5c0ad1a617e0fce3f", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -33,7 +33,6 @@ class ResolvePattern : public ResolverBase\n   static void go (AST::Pattern *pattern, NodeId parent)\n   {\n     ResolvePattern resolver (parent);\n-\n     pattern->accept_vis (resolver);\n     if (resolver.resolved_node == UNKNOWN_NODEID)\n       {\n@@ -42,12 +41,10 @@ class ResolvePattern : public ResolverBase\n       }\n   };\n \n-  ~ResolvePattern () {}\n-\n   void visit (AST::IdentifierPattern &pattern) override\n   {\n-    if (resolver->get_name_scope ().lookup (pattern.get_ident (),\n-\t\t\t\t\t    &resolved_node))\n+    if (resolver->get_name_scope ().lookup (\n+\t  CanonicalPath (pattern.get_ident ()), &resolved_node))\n       {\n \tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (pattern.get_node_id (),\n@@ -68,23 +65,14 @@ class PatternDeclaration : public ResolverBase\n   static void go (AST::Pattern *pattern, NodeId parent)\n   {\n     PatternDeclaration resolver (parent);\n-\n     pattern->accept_vis (resolver);\n-    if (resolver.resolved_node != UNKNOWN_NODEID)\n-      {\n-\t// print both locations?!\n-\trust_error_at (resolver.locus, \"duplicate pattern %s\",\n-\t\t       pattern->as_string ().c_str ());\n-      }\n   };\n \n-  ~PatternDeclaration () {}\n-\n   void visit (AST::IdentifierPattern &pattern) override\n   {\n     // if we have a duplicate id this then allows for shadowing correctly\n     // as new refs to this decl will match back here so it is ok to overwrite\n-    resolver->get_name_scope ().insert (pattern.get_ident (),\n+    resolver->get_name_scope ().insert (CanonicalPath (pattern.get_ident ()),\n \t\t\t\t\tpattern.get_node_id (),\n \t\t\t\t\tpattern.get_locus ());\n     resolver->insert_new_definition (pattern.get_node_id (),"}, {"sha": "2550c3953622fdab1ec0c2521de4b3968388fc68", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -32,17 +32,19 @@ class ResolveTopLevel : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Item *item)\n+  static void go (AST::Item *item,\n+\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n   {\n-    ResolveTopLevel resolver;\n+    ResolveTopLevel resolver (prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TypeAlias &alias) override\n   {\n     resolver->get_type_scope ().insert (\n-      alias.get_new_type_name (), alias.get_node_id (), alias.get_locus (),\n-      false, [&] (std::string, NodeId, Location locus) -> void {\n+      CanonicalPath (alias.get_new_type_name ()), alias.get_node_id (),\n+      alias.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (alias.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -51,9 +53,9 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::TupleStruct &struct_decl) override\n   {\n     resolver->get_type_scope ().insert (\n-      struct_decl.get_identifier (), struct_decl.get_node_id (),\n+      CanonicalPath (struct_decl.get_identifier ()), struct_decl.get_node_id (),\n       struct_decl.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (struct_decl.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -62,9 +64,9 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::StructStruct &struct_decl) override\n   {\n     resolver->get_type_scope ().insert (\n-      struct_decl.get_identifier (), struct_decl.get_node_id (),\n+      CanonicalPath (struct_decl.get_identifier ()), struct_decl.get_node_id (),\n       struct_decl.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (struct_decl.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -73,8 +75,9 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::StaticItem &var) override\n   {\n     resolver->get_name_scope ().insert (\n-      var.get_identifier (), var.get_node_id (), var.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      CanonicalPath (var.get_identifier ()), var.get_node_id (),\n+      var.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (var.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -86,10 +89,11 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n+    auto path\n+      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n     resolver->get_name_scope ().insert (\n-      constant.get_identifier (), constant.get_node_id (),\n-      constant.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (constant.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -100,10 +104,11 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n+    auto path\n+      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n     resolver->get_name_scope ().insert (\n-      function.get_function_name (), function.get_node_id (),\n-      function.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (function.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -122,13 +127,24 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+    CanonicalPath impl_type\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n-      ResolveToplevelImplItem::go (impl_item.get (),\n-\t\t\t\t   impl_block.get_type ().get ());\n+      ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n   }\n \n private:\n-  ResolveTopLevel () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveTopLevel (const CanonicalPath &prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n };\n \n } // namespace Resolver"}, {"sha": "35e04a87450a79a6adac433c2f469f652811b744", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 117, "deletions": 42, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -25,73 +25,136 @@\n namespace Rust {\n namespace Resolver {\n \n-class ResolveTypeToSimplePath : public ResolverBase\n+class ResolveConstantItemToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::ConstantItem &constant)\n+  {\n+    return CanonicalPath (constant.get_identifier ());\n+  }\n+};\n+\n+class ResolveFunctionItemToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::Function &function)\n+  {\n+    return CanonicalPath (function.get_function_name ());\n+  }\n+};\n+\n+class ResolveMethodItemToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::Method &method)\n+  {\n+    return CanonicalPath (method.get_method_name ());\n+  }\n+};\n+\n+class ResolveTypeToCanonicalPath : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static bool go (AST::Type *type, AST::SimplePath &simple_path_result,\n-\t\t  bool path_only = false)\n+  static CanonicalPath resolve (AST::Type &type,\n+\t\t\t\tbool include_generic_args = true,\n+\t\t\t\tbool type_resolve_generic_args = true)\n   {\n-    ResolveTypeToSimplePath resolver (simple_path_result, path_only);\n-    type->accept_vis (resolver);\n-    return !resolver.type_seg_failed_flag;\n+    ResolveTypeToCanonicalPath resolver (include_generic_args,\n+\t\t\t\t\t type_resolve_generic_args);\n+    type.accept_vis (resolver);\n+    return resolver.result;\n   }\n \n   void visit (AST::TypePath &path) override\n   {\n-    segs.reserve (path.get_num_segments ());\n     for (auto &seg : path.get_segments ())\n       {\n \tseg->accept_vis (*this);\n-\tif (type_seg_failed_flag)\n+\tif (failure_flag)\n \t  return;\n       }\n-\n-    if (segs.empty ())\n-      {\n-\trust_error_at (path.get_locus (), \"failed to resolve path: %s\",\n-\t\t       path.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    bool has_opening_scope_res = false;\n-    result = AST::SimplePath (std::move (segs), has_opening_scope_res,\n-\t\t\t      path.get_locus ());\n   }\n \n   void visit (AST::TypePathSegmentGeneric &seg) override;\n \n   void visit (AST::TypePathSegment &seg) override;\n \n+  static CanonicalPath canonicalize_generic_args (AST::GenericArgs &args);\n+\n+  static bool type_resolve_generic_args (AST::GenericArgs &args);\n+\n private:\n-  ResolveTypeToSimplePath (AST::SimplePath &simple_path_result, bool path_only)\n-    : ResolverBase (UNKNOWN_NODEID), type_seg_failed_flag (false),\n-      result (simple_path_result), path_only_flag (path_only)\n+  ResolveTypeToCanonicalPath (bool include_generic_args,\n+\t\t\t      bool type_resolve_generic_args)\n+    : ResolverBase (UNKNOWN_NODEID), result (CanonicalPath::create_empty ()),\n+      include_generic_args_flag (include_generic_args),\n+      type_resolve_generic_args_flag (type_resolve_generic_args),\n+      failure_flag (false)\n   {}\n \n-  bool type_seg_failed_flag;\n-  std::vector<AST::SimplePathSegment> segs;\n-  AST::SimplePath &result;\n-  bool path_only_flag;\n+  CanonicalPath result;\n+  bool include_generic_args_flag;\n+  bool type_resolve_generic_args_flag;\n+  bool failure_flag;\n+};\n+\n+class ResolvePathSegmentToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::PathExprSegment &seg)\n+  {\n+    CanonicalPath path = CanonicalPath (seg.get_ident_segment ().as_string ());\n+    if (seg.has_generic_args ())\n+      {\n+\tbool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\t  seg.get_generic_args ());\n+\tif (!ok)\n+\t  {\n+\t    rust_error_at (seg.get_locus (),\n+\t\t\t   \"failed to resolve all generic args\");\n+\t    return CanonicalPath::create_empty ();\n+\t  }\n+\n+\tpath\n+\t  = path.append (ResolveTypeToCanonicalPath::canonicalize_generic_args (\n+\t    seg.get_generic_args ()));\n+      }\n+    return path;\n+  }\n };\n \n-class ResolveTypePath\n+// FIXME: as part of imports and visibility we need to be able to keep a context\n+// for handling PathInExpressions segments as they can be local to a particular\n+// lexical scope requiring a context to be maintained for resolution\n+class ResolveRelativeTypePath\n {\n public:\n-  static NodeId go (AST::TypePath &path, NodeId parent)\n+  static NodeId go (AST::TypePath &path, NodeId parent,\n+\t\t    const CanonicalPath &prefix,\n+\t\t    bool canonicalize_type_with_generics)\n   {\n-    AST::SimplePath path_buffer = AST::SimplePath::create_empty ();\n-    if (!ResolveTypeToSimplePath::go (&path, path_buffer))\n-      return UNKNOWN_NODEID;\n+    CanonicalPath canonical_path\n+      = ResolveTypeToCanonicalPath::resolve (path,\n+\t\t\t\t\t     canonicalize_type_with_generics,\n+\t\t\t\t\t     true);\n+    if (canonical_path.is_error ())\n+      {\n+\trust_error_at (path.get_locus (), \"Failed to resolve canonical path\");\n+\treturn UNKNOWN_NODEID;\n+      }\n+\n+    CanonicalPath lookup = canonical_path;\n+    if (!prefix.is_error ())\n+      lookup = prefix.append (canonical_path);\n \n     auto resolver = Resolver::get ();\n     NodeId resolved_node = UNKNOWN_NODEID;\n-    if (!resolver->get_type_scope ().lookup (path_buffer.as_string (),\n-\t\t\t\t\t     &resolved_node))\n+    if (!resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n       {\n \trust_error_at (path.get_locus_slow (), \"failed to resolve TypePath: %s\",\n-\t\t       path_buffer.as_string ().c_str ());\n+\t\t       canonical_path.get ().c_str ());\n \treturn UNKNOWN_NODEID;\n       }\n \n@@ -104,9 +167,10 @@ class ResolveType : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::Type *type, NodeId parent)\n+  static NodeId go (AST::Type *type, NodeId parent,\n+\t\t    bool canonicalize_type_with_generics = false)\n   {\n-    ResolveType resolver (parent);\n+    ResolveType resolver (parent, canonicalize_type_with_generics);\n     type->accept_vis (resolver);\n     if (!resolver.ok)\n       rust_error_at (type->get_locus_slow (), \"unresolved type\");\n@@ -139,7 +203,10 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    resolved_node = ResolveTypePath::go (path, parent);\n+    resolved_node\n+      = ResolveRelativeTypePath::go (path, parent,\n+\t\t\t\t     CanonicalPath::create_empty (),\n+\t\t\t\t     canonicalize_type_with_generics);\n     ok = resolved_node != UNKNOWN_NODEID;\n     if (ok)\n       {\n@@ -160,12 +227,16 @@ class ResolveType : public ResolverBase\n     type.get_type_referenced ()->accept_vis (*this);\n   }\n \n-  // nothing to do for inferred types\n   void visit (AST::InferredType &type) override { ok = true; }\n \n private:\n-  ResolveType (NodeId parent) : ResolverBase (parent), ok (false) {}\n+  ResolveType (NodeId parent, bool canonicalize_type_with_generics)\n+    : ResolverBase (parent),\n+      canonicalize_type_with_generics (canonicalize_type_with_generics),\n+      ok (false)\n+  {}\n \n+  bool canonicalize_type_with_generics;\n   bool ok;\n };\n \n@@ -190,17 +261,21 @@ class ResolveGenericParam : public ResolverBase\n \n     // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n     resolver->get_type_scope ().insert (\n-      param.get_type_representation (), param.get_node_id (),\n+      CanonicalPath (param.get_type_representation ()), param.get_node_id (),\n       param.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (param.get_locus (),\n \t\t       \"generic param redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n   }\n \n private:\n-  ResolveGenericParam (NodeId parent) : ResolverBase (parent), ok (false) {}\n+  ResolveGenericParam (NodeId parent)\n+    : ResolverBase (parent),\n+\n+      ok (false)\n+  {}\n \n   bool ok;\n };"}, {"sha": "aac55e2a696947164e8b2bf9b872da4d0bdb967b", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 165, "deletions": 45, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -50,7 +50,8 @@ Resolver::Resolver ()\n   : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n     name_scope (Scope (mappings->get_current_crate ())),\n     type_scope (Scope (mappings->get_current_crate ())),\n-    label_scope (Scope (mappings->get_current_crate ()))\n+    label_scope (Scope (mappings->get_current_crate ())),\n+    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n {\n   generate_builtins ();\n }\n@@ -116,9 +117,12 @@ Resolver::insert_builtin_types (Rib *r)\n {\n   auto builtins = get_builtin_types ();\n   for (auto &builtin : builtins)\n-    r->insert_name (builtin->as_string (), builtin->get_node_id (),\n-\t\t    Linemap::predeclared_location (), false,\n-\t\t    [] (std::string, NodeId, Location) -> void {});\n+    {\n+      CanonicalPath builtin_path (builtin->as_string ());\n+      r->insert_name (builtin_path, builtin->get_node_id (),\n+\t\t      Linemap::predeclared_location (), false,\n+\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n+    }\n }\n \n std::vector<AST::Type *> &\n@@ -374,88 +378,170 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n \n // rust-ast-resolve-type.h\n \n-void\n-ResolveTypeToSimplePath::visit (AST::TypePathSegmentGeneric &seg)\n+CanonicalPath\n+ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n {\n-  if (!path_only_flag)\n+  std::string buf;\n+\n+  size_t i = 0;\n+  size_t total = args.get_type_args ().size ();\n+\n+  for (auto &ty_arg : args.get_type_args ())\n     {\n-      AST::GenericArgs &generics = seg.get_generic_args ();\n-      for (auto &gt : generics.get_type_args ())\n-\tResolveType::go (gt.get (), UNKNOWN_NODEID);\n+      buf += ty_arg->as_string ();\n+      if ((i + 1) < total)\n+\tbuf += \",\";\n+\n+      i++;\n     }\n \n+  return CanonicalPath (\"<\" + buf + \">\");\n+}\n+\n+bool\n+ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n+{\n+  for (auto &gt : args.get_type_args ())\n+    {\n+      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+      // FIXME error handling here for inference variable since they do not have\n+      // a node to resolve to\n+      // if (resolved == UNKNOWN_NODEID) return false;\n+    }\n+  return true;\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n   if (seg.is_error ())\n     {\n-      type_seg_failed_flag = true;\n-      rust_error_at (Location (), \"segment has error: %s\",\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n \t\t     seg.as_string ().c_str ());\n       return;\n     }\n \n-  segs.push_back (AST::SimplePathSegment (seg.get_ident_segment ().as_string (),\n-\t\t\t\t\t  seg.get_locus ()));\n+  // ident seg\n+  CanonicalPath ident_seg\n+    = CanonicalPath (seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_seg);\n+\n+  // generic args\n+  if (seg.has_generic_args ())\n+    {\n+      if (include_generic_args_flag)\n+\tresult\n+\t  = result.append (canonicalize_generic_args (seg.get_generic_args ()));\n+\n+      if (type_resolve_generic_args_flag)\n+\t{\n+\t  bool ok = type_resolve_generic_args (seg.get_generic_args ());\n+\t  failure_flag = !ok;\n+\t}\n+    }\n }\n \n void\n-ResolveTypeToSimplePath::visit (AST::TypePathSegment &seg)\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n {\n   if (seg.is_error ())\n     {\n-      type_seg_failed_flag = true;\n-      rust_error_at (Location (), \"segment has error: %s\",\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n \t\t     seg.as_string ().c_str ());\n       return;\n     }\n \n-  segs.push_back (AST::SimplePathSegment (seg.get_ident_segment ().as_string (),\n-\t\t\t\t\t  seg.get_locus ()));\n+  CanonicalPath ident_seg\n+    = CanonicalPath (seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_seg);\n }\n \n // rust-ast-resolve-expr.h\n \n void\n ResolvePath::resolve_path (AST::PathInExpression *expr)\n {\n-  // this needs extended similar to the TypePath to lookup each segment\n-  // in turn then look its rib for the next segment and so forth until we\n-  // resolve to a final NodeId generic args can be ignored\n-  std::string path_buf;\n-  for (auto &seg : expr->get_segments ())\n+  // resolve root segment first then apply segments in turn\n+  AST::PathExprSegment &root_segment = expr->get_segments ().at (0);\n+  AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n+\n+  bool segment_is_type = false;\n+  CanonicalPath root_seg_path (root_ident_seg.as_string ());\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n     {\n-      auto s = seg.get_ident_segment ();\n-      if (s.is_error () && !seg.has_generic_args ())\n+      segment_is_type = false;\n+      resolver->insert_resolved_name (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = true;\n+      resolver->insert_resolved_type (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (),\n+\t\t     \"unknown root segment in path %s lookup %s\",\n+\t\t     expr->as_string ().c_str (),\n+\t\t     root_ident_seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (root_segment.has_generic_args ())\n+    {\n+      bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\troot_segment.get_generic_args ());\n+      if (!ok)\n \t{\n-\t  rust_error_at (expr->get_locus (), \"malformed path\");\n+\t  rust_error_at (root_segment.get_locus (),\n+\t\t\t \"failed to resolve generic args\");\n \t  return;\n \t}\n+    }\n \n-      if (seg.has_generic_args ())\n-\t{\n-\t  AST::GenericArgs &args = seg.get_generic_args ();\n-\t  for (auto &gt : args.get_type_args ())\n-\t    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n-\t}\n+  if (expr->is_single_segment ())\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n \n-      if (!s.is_error ())\n-\t{\n-\t  bool needs_sep = !path_buf.empty ();\n-\t  if (needs_sep)\n-\t    path_buf += \"::\";\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+      return;\n+    }\n \n-\t  path_buf += s.as_string ();\n-\t}\n+  // we can attempt to resolve this path fully\n+  CanonicalPath path = root_seg_path;\n+  for (size_t i = 1; i < expr->get_segments ().size (); i++)\n+    {\n+      AST::PathExprSegment &seg = expr->get_segments ().at (i);\n+      auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n+      path = path.append (s);\n     }\n \n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (path_buf, &resolved_node))\n+  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n     {\n       resolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n       resolver->insert_new_definition (expr->get_node_id (),\n \t\t\t\t       Definition{expr->get_node_id (),\n \t\t\t\t\t\t  parent});\n     }\n   // check the type scope\n-  else if (resolver->get_type_scope ().lookup (path_buf, &resolved_node))\n+  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n     {\n       resolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n       resolver->insert_new_definition (expr->get_node_id (),\n@@ -464,8 +550,42 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n     }\n   else\n     {\n-      rust_error_at (expr->get_locus (), \"unknown path %s lookup %s\",\n-\t\t     expr->as_string ().c_str (), path_buf.c_str ());\n+      // attempt to fully resolve the path which is allowed to fail given the\n+      // following scenario\n+      //\n+      // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n+      // resolved fully here, there are limitations though imagine:\n+      //\n+      // struct Foo<A> (A);\n+      //\n+      // impl Foo<isize> {\n+      //    fn test() -> ...\n+      //\n+      // impl Foo<f32> {\n+      //    fn test() -> ...\n+      //\n+      // fn main() {\n+      //    let a:i32 = Foo::test();\n+      //\n+      // there are multiple paths that test can resolve to Foo::<?>::test here\n+      // so we cannot resolve this case\n+      //\n+      // canonical names:\n+      //\n+      // struct Foo<A>            -> Foo\n+      // impl Foo<isize>::fn test -> Foo::isize::test\n+      // impl Foo<f32>::fn test   -> Foo::f32::test\n+      //\n+      // Since there is the case we have the following paths for test:\n+      //\n+      // Foo::isize::test\n+      // Foo::f32::test\n+      // vs\n+      // Foo::test\n+      //\n+      // but the lookup was simply Foo::test we must rely on type resolution to\n+      // figure this type out in a similar fashion to method resolution with a\n+      // probe phase\n     }\n }\n "}, {"sha": "13b6c91cda6d327359c79ac65db2f3ab1f0c3436", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -57,7 +57,8 @@ class VerifyAsignee : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr) override\n   {\n-    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (!resolver->get_name_scope ().lookup (CanonicalPath (expr.as_string ()),\n+\t\t\t\t\t     &resolved_node))\n       return;\n \n     ok = true;"}, {"sha": "205c877fe2bd3ed7530a8a3b5cabfd18a445a04b", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 74, "deletions": 14, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -26,6 +26,62 @@\n namespace Rust {\n namespace Resolver {\n \n+// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n+//\n+// struct X - path X\n+// impl X { fn test - path X::test }\n+//\n+// struct X<T> - path X\n+//\n+// impl X<T>   { fn test - path X::test}\n+// impl X<i32> { fn test - path X<i32>::test }\n+// impl X<f32> { fn test - path X<f32>::test }\n+class CanonicalPath\n+{\n+public:\n+  explicit CanonicalPath (std::string path) : path (path) {}\n+\n+  CanonicalPath (const CanonicalPath &other) : path (other.path) {}\n+\n+  CanonicalPath &operator= (const CanonicalPath &other)\n+  {\n+    path = other.path;\n+    return *this;\n+  }\n+\n+  std::string get () const { return path; }\n+\n+  static CanonicalPath get_big_self () { return CanonicalPath (\"Self\"); }\n+\n+  static CanonicalPath get_wee_self () { return CanonicalPath (\"self\"); }\n+\n+  static CanonicalPath create_empty ()\n+  {\n+    return CanonicalPath (std::string ());\n+  }\n+\n+  bool is_error () const { return path.empty (); }\n+\n+  CanonicalPath append (const CanonicalPath &other) const\n+  {\n+    rust_assert (!other.is_error ());\n+    return is_error () ? CanonicalPath (other.get ())\n+\t\t       : CanonicalPath (append (other.get ()));\n+  }\n+\n+  bool operator== (const CanonicalPath &b) const\n+  {\n+    return get ().compare (b.get ()) == 0;\n+  }\n+\n+  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n+\n+private:\n+  std::string append (std::string elem) const { return path + \"::\" + elem; }\n+\n+  std::string path;\n+};\n+\n class Rib\n {\n public:\n@@ -37,31 +93,32 @@ class Rib\n \n   ~Rib () {}\n \n-  void insert_name (std::string ident, NodeId id, Location locus, bool shadow,\n-\t\t    std::function<void (std::string, NodeId, Location)> dup_cb)\n+  void insert_name (\n+    const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+    std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n   {\n-    auto it = mappings.find (ident);\n+    auto it = mappings.find (path);\n     bool already_exists = it != mappings.end ();\n     if (already_exists && !shadow)\n       {\n \tfor (auto &decl : decls_within_rib)\n \t  {\n \t    if (decl.first == it->second)\n \t      {\n-\t\tdup_cb (ident, it->second, decl.second);\n+\t\tdup_cb (path, it->second, decl.second);\n \t\treturn;\n \t      }\n \t  }\n-\tdup_cb (ident, it->second, locus);\n+\tdup_cb (path, it->second, locus);\n \treturn;\n       }\n \n-    mappings[ident] = id;\n+    mappings[path] = id;\n     decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n   }\n \n-  bool lookup_name (std::string ident, NodeId *id)\n+  bool lookup_name (const CanonicalPath &ident, NodeId *id)\n   {\n     auto it = mappings.find (ident);\n     if (it == mappings.end ())\n@@ -71,7 +128,7 @@ class Rib\n     return true;\n   }\n \n-  void clear_name (std::string ident, NodeId id)\n+  void clear_name (const CanonicalPath &ident, NodeId id)\n   {\n     mappings.erase (ident);\n     for (auto &it : decls_within_rib)\n@@ -136,7 +193,7 @@ class Rib\n private:\n   CrateNum crate_num;\n   NodeId node_id;\n-  std::map<std::string, NodeId> mappings;\n+  std::map<CanonicalPath, NodeId> mappings;\n   std::set<std::pair<NodeId, Location> > decls_within_rib;\n   std::map<NodeId, std::set<NodeId> > references;\n };\n@@ -145,21 +202,24 @@ class Scope\n {\n public:\n   Scope (CrateNum crate_num) : crate_num (crate_num) {}\n+\n   ~Scope () {}\n \n-  void insert (std::string ident, NodeId id, Location locus, bool shadow,\n-\t       std::function<void (std::string, NodeId, Location)> dup_cb)\n+  void\n+  insert (const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+\t  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n   {\n     peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n   }\n \n-  void insert (std::string ident, NodeId id, Location locus)\n+  void insert (const CanonicalPath &ident, NodeId id, Location locus)\n   {\n     peek ()->insert_name (ident, id, locus, true,\n-\t\t\t  [] (std::string, NodeId, Location) -> void {});\n+\t\t\t  [] (const CanonicalPath &, NodeId, Location) -> void {\n+\t\t\t  });\n   }\n \n-  bool lookup (std::string ident, NodeId *id)\n+  bool lookup (const CanonicalPath &ident, NodeId *id)\n   {\n     NodeId lookup = UNKNOWN_NODEID;\n     iterate ([&] (Rib *r) mutable -> bool {"}, {"sha": "b0071c3ee6f09f78376e4273b1dc92f8e4276a5c", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,220 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H\n+#define RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class InherentImplItemToName : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static bool resolve (HIR::InherentImplItem *item, std::string &name_result)\n+  {\n+    InherentImplItemToName resolver (name_result);\n+    item->accept_vis (resolver);\n+    return resolver.ok;\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    ok = true;\n+    result.assign (method.get_method_name ());\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ok = true;\n+    result.assign (function.get_function_name ());\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    ok = true;\n+    result.assign (constant.get_identifier ());\n+  }\n+\n+private:\n+  InherentImplItemToName (std::string &result)\n+    : TypeCheckBase (), ok (false), result (result)\n+  {}\n+\n+  bool ok;\n+  std::string &result;\n+};\n+\n+class GetLocusFromImplItem : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static bool Resolve (HIR::InherentImplItem *query, Location &locus)\n+  {\n+    GetLocusFromImplItem resolver (locus);\n+    query->accept_vis (resolver);\n+    return resolver.ok;\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    ok = true;\n+    locus = constant.get_locus ();\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ok = true;\n+    locus = function.get_locus ();\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    ok = true;\n+    locus = method.get_locus ();\n+  }\n+\n+private:\n+  GetLocusFromImplItem (Location &locus)\n+    : TypeCheckBase (), ok (false), locus (locus)\n+  {}\n+\n+  bool ok;\n+  Location &locus;\n+};\n+\n+class OverlappingImplItemPass : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void go ()\n+  {\n+    OverlappingImplItemPass pass;\n+\n+    // generate mappings\n+    pass.mappings->iterate_impl_items ([&] (HirId id,\n+\t\t\t\t\t    HIR::InherentImplItem *impl_item,\n+\t\t\t\t\t    HIR::InherentImpl *impl) -> bool {\n+      pass.process_impl_item (id, impl_item, impl);\n+      return true;\n+    });\n+\n+    pass.scan ();\n+  }\n+\n+  void process_impl_item (HirId id, HIR::InherentImplItem *impl_item,\n+\t\t\t  HIR::InherentImpl *impl)\n+  {\n+    // lets make a mapping of impl-item Self type to (impl-item,name):\n+    // {\n+    //   impl-type -> [ (item, name), ... ]\n+    // }\n+\n+    HirId impl_type_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_type = nullptr;\n+    bool ok = context->lookup_type (impl_type_id, &impl_type);\n+    rust_assert (ok);\n+\n+    std::string impl_item_name;\n+    ok = InherentImplItemToName::resolve (impl_item, impl_item_name);\n+    rust_assert (ok);\n+\n+    std::pair<HIR::InherentImplItem *, std::string> elem (impl_item,\n+\t\t\t\t\t\t\t  impl_item_name);\n+    impl_mappings[impl_type].insert (std::move (elem));\n+  }\n+\n+  void scan ()\n+  {\n+    // we can now brute force the map looking for can_eq on each of the\n+    // impl_items_types to look for possible colliding impl blocks;\n+    for (auto it = impl_mappings.begin (); it != impl_mappings.end (); it++)\n+      {\n+\tTyTy::BaseType *query = it->first;\n+\n+\tfor (auto iy = impl_mappings.begin (); iy != impl_mappings.end (); iy++)\n+\t  {\n+\t    TyTy::BaseType *candidate = iy->first;\n+\t    if (query == candidate)\n+\t      continue;\n+\n+\t    if (query->can_eq (candidate))\n+\t      possible_collision (it->second, iy->second);\n+\t  }\n+      }\n+  }\n+\n+  void possible_collision (\n+    std::set<std::pair<HIR::InherentImplItem *, std::string> > query,\n+    std::set<std::pair<HIR::InherentImplItem *, std::string> > candidate)\n+  {\n+    for (auto &q : query)\n+      {\n+\tHIR::InherentImplItem *query_impl_item = q.first;\n+\tstd::string query_impl_item_name = q.second;\n+\n+\tfor (auto &c : candidate)\n+\t  {\n+\t    HIR::InherentImplItem *candidate_impl_item = c.first;\n+\t    std::string candidate_impl_item_name = c.second;\n+\n+\t    if (query_impl_item_name.compare (candidate_impl_item_name) == 0)\n+\t      collision_detected (query_impl_item, candidate_impl_item,\n+\t\t\t\t  candidate_impl_item_name);\n+\t  }\n+      }\n+  }\n+\n+  void collision_detected (HIR::InherentImplItem *query,\n+\t\t\t   HIR::InherentImplItem *dup, const std::string &name)\n+  {\n+    Location qlocus;\n+    bool ok = GetLocusFromImplItem::Resolve (query, qlocus);\n+    rust_assert (ok);\n+\n+    Location dlocus;\n+    ok = GetLocusFromImplItem::Resolve (dup, dlocus);\n+    rust_assert (ok);\n+\n+    // this needs GCC Rich locations see\n+    // https://github.com/Rust-GCC/gccrs/issues/97\n+    rust_error_at (qlocus, \"duplicate definitions with name %s\", name.c_str ());\n+    rust_error_at (dlocus, \"duplicate def associated with\");\n+  }\n+\n+private:\n+  OverlappingImplItemPass () : TypeCheckBase () {}\n+\n+  std::map<TyTy::BaseType *,\n+\t   std::set<std::pair<HIR::InherentImplItem *, std::string> > >\n+    impl_mappings;\n+\n+  std::map<TyTy::BaseType *, std::set<TyTy::BaseType *> >\n+    possible_colliding_impls;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H"}, {"sha": "b2391e317f0f4a1adec1d291e14f8020c2f8688d", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "modified", "additions": 18, "deletions": 58, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n@@ -32,73 +33,32 @@ class MethodResolution : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static std::vector<HIR::Method *> Probe (TyTy::BaseType *receiver,\n-\t\t\t\t\t   HIR::PathExprSegment method_name)\n+  static std::vector<PathProbeCandidate>\n+  Probe (std::vector<PathProbeCandidate> &path_candidates)\n   {\n-    MethodResolution probe (receiver, method_name);\n+    MethodResolution probe;\n+    for (auto &c : path_candidates)\n+      probe.process_candidate (c);\n \n-    // lookup impl items for this crate and find all methods that can resolve to\n-    // this receiver\n-    probe.mappings->iterate_impl_items (\n-      [&] (HirId id, HIR::InherentImplItem *item) mutable -> bool {\n-\titem->accept_vis (probe);\n-\treturn true;\n-      });\n-\n-    return probe.probed;\n+    return probe.candidates;\n   }\n \n-  void visit (HIR::Method &method) override\n+  void process_candidate (PathProbeCandidate &candidate)\n   {\n-    TyTy::BaseType *self_lookup = nullptr;\n-    if (!context->lookup_type (\n-\t  method.get_self_param ().get_mappings ().get_hirid (), &self_lookup))\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to lookup lookup self type in MethodProbe\");\n-\treturn;\n-      }\n-\n-    // are the names the same\n-    HIR::PathIdentSegment seg = method_name.get_segment ();\n-    if (seg.as_string ().compare (method.get_method_name ()) != 0)\n-      {\n-\t// if the method name does not match then this is not a valid match\n-\treturn;\n-      }\n-\n-    if (self_lookup->get_kind () != receiver->get_kind ())\n-      return;\n-\n-    if (receiver->has_subsititions_defined ()\n-\t!= self_lookup->has_subsititions_defined ())\n-      return;\n-\n-    if (self_lookup->has_subsititions_defined ())\n-      {\n-\t// we assume the receiver should be fully substituted at this stage\n-\tself_lookup = SubstMapperFromExisting::Resolve (receiver, self_lookup);\n-      }\n-\n-    if (!receiver->is_equal (*self_lookup))\n-      {\n-\t// incompatible self argument then this is not a valid method for this\n-\t// receiver\n-\treturn;\n-      }\n-\n-    probed.push_back (&method);\n+    is_method_flag = false;\n+    candidate.impl_item->accept_vis (*this);\n+\n+    if (is_method_flag)\n+      candidates.push_back (candidate);\n   }\n \n-private:\n-  MethodResolution (TyTy::BaseType *receiver, HIR::PathExprSegment method_name)\n-    : TypeCheckBase (), receiver (receiver), method_name (method_name)\n-  {}\n+  void visit (HIR::Method &method) override { is_method_flag = true; }\n \n-  TyTy::BaseType *receiver;\n-  HIR::PathExprSegment method_name;\n+private:\n+  MethodResolution () : TypeCheckBase () {}\n \n-  std::vector<HIR::Method *> probed;\n+  bool is_method_flag;\n+  std::vector<PathProbeCandidate> candidates;\n };\n \n } // namespace Resolver"}, {"sha": "a838565161369a8ecf1780ec7d245f0e07fc7ed4", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,162 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATH_PROBE_H\n+#define RUST_HIR_PATH_PROBE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-substitution-mapper.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+struct PathProbeCandidate\n+{\n+  HIR::InherentImplItem *impl_item;\n+  TyTy::BaseType *ty;\n+};\n+\n+class PathProbeType : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static std::vector<PathProbeCandidate>\n+  Probe (TyTy::BaseType *receiver, const HIR::PathIdentSegment &segment_name)\n+  {\n+    PathProbeType probe (receiver, segment_name);\n+    probe.mappings->iterate_impl_items (\n+      [&] (HirId id, HIR::InherentImplItem *item,\n+\t   HIR::InherentImpl *impl) mutable -> bool {\n+\tprobe.process_candidate (id, item, impl);\n+\treturn true;\n+      });\n+    return probe.candidates;\n+  }\n+\n+  void process_candidate (HirId id, HIR::InherentImplItem *item,\n+\t\t\t  HIR::InherentImpl *impl)\n+  {\n+    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_block_ty = nullptr;\n+    bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+    rust_assert (ok);\n+\n+    if (!receiver->can_eq (impl_block_ty))\n+      return;\n+\n+    // lets visit the impl_item\n+    item->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    Identifier name = constant.get_identifier ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = constant.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&constant, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    Identifier name = function.get_function_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = function.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&function, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    Identifier name = method.get_method_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = method.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate candidate{&method, ty};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+private:\n+  PathProbeType (TyTy::BaseType *receiver, const HIR::PathIdentSegment &query)\n+    : TypeCheckBase (), receiver (receiver), search (query)\n+  {}\n+\n+  TyTy::BaseType *receiver;\n+  const HIR::PathIdentSegment &search;\n+  std::vector<PathProbeCandidate> candidates;\n+};\n+\n+class ReportMultipleCandidateError : private TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void Report (std::vector<PathProbeCandidate> &candidates,\n+\t\t      const HIR::PathIdentSegment &query, Location query_locus)\n+  {\n+    rust_error_at (query_locus, \"multiple applicable items in scope for: %s\",\n+\t\t   query.as_string ().c_str ());\n+\n+    ReportMultipleCandidateError visitor;\n+    for (auto &c : candidates)\n+      c.impl_item->accept_vis (visitor);\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    rust_error_at (constant.get_locus (), \"possible candidate\");\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    rust_error_at (function.get_locus (), \"possible candidate\");\n+  }\n+\n+  void visit (HIR::Method &method) override\n+  {\n+    rust_error_at (method.get_locus (), \"possible candidate\");\n+  }\n+\n+private:\n+  ReportMultipleCandidateError () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_PATH_PROBE_H"}, {"sha": "cb2f2502f03c81f9283f1615fed4d26b62d4f3cb", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 162, "deletions": 78, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-method-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n@@ -171,8 +172,6 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     TyTy::BaseType *function_tyty\n       = TypeCheckExpr::Resolve (expr.get_fnexpr (), false);\n-    if (function_tyty == nullptr)\n-      return;\n \n     bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n \t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n@@ -211,34 +210,37 @@ class TypeCheckExpr : public TypeCheckBase\n     // which is simple. There will need to be adjustments to ensure we can turn\n     // the receiver into borrowed references etc\n \n-    auto probes\n-      = MethodResolution::Probe (receiver_tyty, expr.get_method_name ());\n-    if (probes.size () == 0)\n+    auto candidates\n+      = PathProbeType::Probe (receiver_tyty,\n+\t\t\t      expr.get_method_name ().get_segment ());\n+    if (candidates.size () == 0)\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"failed to resolve the PathExprSegment to any Method\");\n \treturn;\n       }\n-    else if (probes.size () > 1)\n+\n+    // filter all methods\n+    auto possible_methods = MethodResolution::Probe (candidates);\n+    if (possible_methods.size () == 0)\n       {\n-\trust_error_at (\n-\t  expr.get_locus (),\n-\t  \"multiple candidates in MethodCallExpr have been probed is \"\n-\t  \"not currently supported\");\n+\trust_error_at (expr.get_method_name ().get_locus (),\n+\t\t       \"no method named %s found in scope\",\n+\t\t       expr.get_method_name ().as_string ().c_str ());\n \treturn;\n       }\n-\n-    auto resolved_method = probes.at (0);\n-    TyTy::BaseType *lookup_tyty;\n-    if (!context->lookup_type (resolved_method->get_mappings ().get_hirid (),\n-\t\t\t       &lookup_tyty))\n+    else if (possible_methods.size () > 1)\n       {\n-\trust_error_at (resolved_method->get_locus (),\n-\t\t       \"failed to lookup type for CallExpr: %s\",\n-\t\t       expr.as_string ().c_str ());\n+\tReportMultipleCandidateError::Report (\n+\t  possible_methods, expr.get_method_name ().get_segment (),\n+\t  expr.get_method_name ().get_locus ());\n \treturn;\n       }\n \n+    auto resolved_candidate = possible_methods.at (0);\n+    HIR::InherentImplItem *resolved_method = resolved_candidate.impl_item;\n+    TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n+\n     TyTy::BaseType *lookup = lookup_tyty;\n     if (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n       {\n@@ -271,7 +273,7 @@ class TypeCheckExpr : public TypeCheckBase\n     // set up the resolved name on the path\n     resolver->insert_resolved_name (\n       expr.get_mappings ().get_nodeid (),\n-      resolved_method->get_mappings ().get_nodeid ());\n+      resolved_method->get_impl_mappings ().get_nodeid ());\n \n     // return the result of the function back\n     infered = function_ret_tyty;\n@@ -759,80 +761,93 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::PathInExpression &expr) override\n   {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+    // resolve root_segment\n+    TyTy::BaseType *tyseg = resolve_root_path (expr);\n+    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+    else if (expr.get_num_segments () == 1)\n+      {\n+\tinfered = tyseg;\n+\treturn;\n+      }\n \n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    NodeId resolved_node_id = UNKNOWN_NODEID;\n+    for (size_t i = 1; i < expr.get_num_segments (); i++)\n       {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n+\t// probe the path\n+\tauto candidates = PathProbeType::Probe (tyseg, seg.get_segment ());\n+\tif (candidates.size () == 0)\n \t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n+\t    rust_error_at (seg.get_locus (), \"failed to resolve path segment\");\n+\t    return;\n+\t  }\n+\telse if (candidates.size () > 1)\n+\t  {\n+\t    ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\t  seg.get_segment (),\n+\t\t\t\t\t\t  seg.get_locus ());\n \t    return;\n \t  }\n-\tref_node_id = def.parent;\n-      }\n-    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n \n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n+\tauto candidate = candidates.at (0);\n+\ttyseg = candidate.ty;\n+\tresolved_node_id\n+\t  = candidate.impl_item->get_impl_mappings ().get_nodeid ();\n \n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-\treturn;\n+\tbool did_substitute = false;\n+\tif (seg.has_generic_args ())\n+\t  {\n+\t    if (!tyseg->can_substitute ())\n+\t      {\n+\t\trust_error_at (expr.get_locus (),\n+\t\t\t       \"substitutions not supported for %s\",\n+\t\t\t       tyseg->as_string ().c_str ());\n+\t\treturn;\n+\t      }\n+\n+\t    did_substitute = true;\n+\t    tyseg = SubstMapper::Resolve (tyseg, expr.get_locus (),\n+\t\t\t\t\t  &seg.get_generic_args ());\n+\n+\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+\telse\n+\t  {\n+\t    if (tyseg->needs_generic_substitutions ())\n+\t      {\n+\t\tdid_substitute = true;\n+\t\ttyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n+\t\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t  return;\n+\t      }\n+\t  }\n       }\n \n-    if (!context->lookup_type (ref, &infered))\n+    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+    // lookup if the name resolver was able to canonically resolve this or not\n+    NodeId path_resolved_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&path_resolved_id))\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to resolve PathInExpression type\");\n-\treturn;\n+\trust_assert (path_resolved_id == resolved_node_id);\n       }\n-\n-    HIR::PathExprSegment seg = expr.get_final_segment ();\n-    if (!infered->supports_substitutions () && seg.has_generic_args ())\n+    // check the type scope\n+    else if (resolver->lookup_resolved_type (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t     &path_resolved_id))\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"path does not support substitutions\");\n-\treturn;\n+\trust_assert (path_resolved_id == resolved_node_id);\n       }\n-\n-    if (expr.is_self ())\n-      return;\n-\n-    if (infered->has_subsititions_defined ())\n+    else\n       {\n-\tif (!infered->can_substitute ())\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"substitutions not supported for %s\",\n-\t\t\t   infered->as_string ().c_str ());\n-\t    return;\n-\t  }\n-\n-\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n-\t\t\t\t\tseg.has_generic_args ()\n-\t\t\t\t\t  ? &seg.get_generic_args ()\n-\t\t\t\t\t  : nullptr);\n+\tresolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\tresolved_node_id);\n       }\n+\n+    infered = tyseg;\n   }\n \n   void visit (HIR::LoopExpr &expr) override\n@@ -951,6 +966,75 @@ class TypeCheckExpr : public TypeCheckBase\n       inside_loop (inside_loop)\n   {}\n \n+  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr)\n+  {\n+    HIR::PathExprSegment &root = expr.get_root_seg ();\n+    NodeId ast_node_id = root.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+    else\n+      {\n+\tresolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (root.get_locus (),\n+\t\t       \"failed to type resolve root segment\");\n+\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+      }\n+\n+    TyTy::BaseType *lookup = nullptr;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to resolve root segment\");\n+\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+      }\n+\n+    // turbo-fish segment path::<ty>\n+    if (root.has_generic_args ())\n+      {\n+\tif (!lookup->can_substitute ())\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"substitutions not supported for %s\",\n+\t\t\t   lookup->as_string ().c_str ());\n+\t    return new TyTy::ErrorType (lookup->get_ref ());\n+\t  }\n+\tlookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t       &root.get_generic_args ());\n+      }\n+    else if (lookup->needs_generic_substitutions ())\n+      {\n+\tlookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n+      }\n+\n+    return lookup;\n+  }\n+\n   bool\n   validate_arithmetic_type (TyTy::BaseType *type,\n \t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type)"}, {"sha": "e52368a67657764bf6f5adeeeb9470e5b35d0c85", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -58,7 +58,7 @@ class TypeCheckStmt : public TypeCheckBase\n       {\n \tinit_expr_ty\n \t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), inside_loop);\n-\tif (init_expr_ty == nullptr)\n+\tif (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  return;\n \n \tinit_expr_ty = init_expr_ty->clone ();"}, {"sha": "8124f357e4b39779e9ec38a5435d1da8ef6ea6ea", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -41,8 +41,6 @@ class TypeCheckStructExpr : public TypeCheckBase\n \n   void visit (HIR::StructExprStructFields &struct_expr) override;\n \n-  void visit (HIR::PathInExpression &path) override;\n-\n   void visit (HIR::StructExprFieldIdentifierValue &field) override;\n \n   void visit (HIR::StructExprFieldIndexValue &field) override;"}, {"sha": "c8394c8dcbe5f0139a1c86abe99627e468ef2a6f", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 57, "deletions": 86, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-inherent-impl-overlap.h\"\n \n extern bool\n saw_errors (void);\n@@ -38,15 +39,21 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   if (saw_errors ())\n     return;\n \n+  OverlappingImplItemPass::go ();\n+  if (saw_errors ())\n+    return;\n+\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     TypeCheckItem::Resolve (it->get ());\n \n   if (saw_errors ())\n     return;\n \n+  auto resolver = Resolver::Resolver::get ();\n   auto mappings = Analysis::Mappings::get ();\n   auto context = TypeCheckContext::get ();\n \n+  // default inference variables if possible\n   context->iterate ([&] (HirId id, TyTy::BaseType *ty) mutable -> bool {\n     if (ty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n@@ -58,24 +65,58 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     // nothing to do\n     if (ty->get_kind () != TyTy::TypeKind::INFER)\n       return true;\n+\n     TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n-    if (!ok)\n+    if (ok)\n       {\n-\trust_error_at (mappings->lookup_location (id),\n-\t\t       \"unable to determine type: please give this a type: %u\",\n-\t\t       id);\n-\treturn true;\n+\tauto result = ty->unify (default_type);\n+\tresult->set_ref (id);\n+\tcontext->insert_type (\n+\t  Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID),\n+\t  result);\n       }\n-    auto result = ty->unify (default_type);\n-    result->set_ref (id);\n-    context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t\t 0, id, UNKNOWN_LOCAL_DEFID),\n-\t\t\t  result);\n \n     return true;\n   });\n+\n+  // scan the ribs to ensure the decls are all setup correctly\n+  resolver->iterate_name_ribs ([&] (Rib *r) -> bool {\n+    r->iterate_decls ([&] (NodeId decl_node_id, Location locus) -> bool {\n+      Definition def;\n+      if (!resolver->lookup_definition (decl_node_id, &def))\n+\t{\n+\t  rust_error_at (locus, \"failed to lookup decl def\");\n+\t  return true;\n+\t}\n+\n+      HirId hir_node = UNKNOWN_HIRID;\n+      if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n+\t\t\t\t\t def.parent, &hir_node))\n+\t{\n+\t  rust_error_at (locus, \"failed to lookup type hir node id\");\n+\t  return true;\n+\t}\n+\n+      // lookup the ty\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = context->lookup_type (hir_node, &ty);\n+      if (!ok)\n+\t{\n+\t  rust_error_at (locus, \"failed to lookup type for decl node_id: %u\",\n+\t\t\t decl_node_id);\n+\t  return true;\n+\t}\n+\n+      if (!ty->is_concrete ())\n+\trust_error_at (locus, \"unable to determine type\");\n+\n+      return true;\n+    });\n+    return true;\n+  });\n }\n \n // RUST_HIR_TYPE_CHECK_EXPR\n@@ -127,14 +168,16 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n void\n TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n {\n-  struct_expr.get_struct_name ().accept_vis (*this);\n-  if (struct_path_resolved == nullptr)\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n     {\n-      rust_fatal_error (struct_expr.get_struct_name ().get_locus (),\n-\t\t\t\"Failed to resolve type\");\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n       return;\n     }\n \n+  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n   TyTy::ADTType *struct_def = struct_path_resolved;\n   if (struct_expr.has_struct_base ())\n     {\n@@ -257,78 +300,6 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n   resolved = struct_def;\n }\n \n-void\n-TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n-{\n-  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-\n-  // then lookup the reference_node_id\n-  NodeId ref_node_id;\n-  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-    {\n-      if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-\t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"Failed to lookup reference for node: %s\",\n-\t\t\t expr.as_string ().c_str ());\n-\t  return;\n-\t}\n-    }\n-\n-  // node back to HIR\n-  HirId ref;\n-  if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t     ref_node_id, &ref))\n-    {\n-      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  // the base reference for this name _must_ have a type set\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (ref, &lookup))\n-    {\n-      rust_error_at (mappings->lookup_location (ref),\n-\t\t     \"consider giving this a type: %s\",\n-\t\t     expr.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (lookup->get_kind () != TyTy::TypeKind::ADT)\n-    {\n-      rust_fatal_error (mappings->lookup_location (ref),\n-\t\t\t\"expected an ADT type\");\n-      return;\n-    }\n-\n-  struct_path_resolved = static_cast<TyTy::ADTType *> (lookup);\n-  if (struct_path_resolved->has_substitutions ())\n-    {\n-      HIR::PathExprSegment seg = expr.get_final_segment ();\n-      if (!struct_path_resolved->needs_substitution ()\n-\t  && seg.has_generic_args ())\n-\t{\n-\t  rust_error_at (seg.get_generic_args ().get_locus (),\n-\t\t\t \"unexpected type arguments\");\n-\t}\n-      else if (struct_path_resolved->needs_substitution ())\n-\t{\n-\t  TyTy::BaseType *subst\n-\t    = SubstMapper::Resolve (struct_path_resolved, expr.get_locus (),\n-\t\t\t\t    seg.has_generic_args ()\n-\t\t\t\t      ? &seg.get_generic_args ()\n-\t\t\t\t      : nullptr);\n-\t  if (subst == nullptr || subst->get_kind () != TyTy::TypeKind::ADT)\n-\t    {\n-\t      rust_fatal_error (mappings->lookup_location (ref),\n-\t\t\t\t\"expected a substituted ADT type\");\n-\t      return;\n-\t    }\n-\t  struct_path_resolved = static_cast<TyTy::ADTType *> (subst);\n-\t}\n-    }\n-}\n-\n void\n TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n {"}, {"sha": "db43cbd3f351cd389d6e43eb182fd05289306965", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -37,6 +37,11 @@ class SubstMapper : public TyTy::TyVisitor\n     return mapper.resolved;\n   }\n \n+  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus)\n+  {\n+    return SubstMapper::Resolve (base, locus, nullptr);\n+  }\n+\n   bool have_generic_args () const { return generics != nullptr; }\n \n   void visit (TyTy::FnType &type) override"}, {"sha": "e2e0d08e9bc98f134ae51d1cd2841b4203870cc7", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "added", "additions": 812, "deletions": 0, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,812 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CMP_H\n+#define RUST_TYTY_CMP_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseCmp : public TyVisitor\n+{\n+public:\n+  virtual bool can_eq (BaseType *other)\n+  {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tParamType *p = static_cast<ParamType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+\n+    other->accept_vis (*this);\n+    return ok;\n+  }\n+\n+  virtual void visit (TupleType &) override { ok = false; }\n+\n+  virtual void visit (ADTType &) override { ok = false; }\n+\n+  virtual void visit (InferType &) override { ok = false; }\n+\n+  virtual void visit (FnType &) override { ok = false; }\n+\n+  virtual void visit (FnPtr &) override { ok = false; }\n+\n+  virtual void visit (ArrayType &) override { ok = false; }\n+\n+  virtual void visit (BoolType &) override { ok = false; }\n+\n+  virtual void visit (IntType &) override { ok = false; }\n+\n+  virtual void visit (UintType &) override { ok = false; }\n+\n+  virtual void visit (USizeType &) override { ok = false; }\n+\n+  virtual void visit (ISizeType &) override { ok = false; }\n+\n+  virtual void visit (FloatType &) override { ok = false; }\n+\n+  virtual void visit (ErrorType &) override { ok = false; }\n+\n+  virtual void visit (CharType &) override { ok = false; }\n+\n+  virtual void visit (ReferenceType &) override { ok = false; }\n+\n+  virtual void visit (ParamType &) override\n+  {\n+    // it is ok for types to can eq to a ParamType\n+    ok = true;\n+  }\n+\n+  virtual void visit (StrType &) override { ok = false; }\n+\n+protected:\n+  BaseCmp (BaseType *base)\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()), ok (false)\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n+  bool ok;\n+\n+private:\n+  /* Returns a pointer to the ty that created this rule. */\n+  virtual BaseType *get_base () = 0;\n+};\n+\n+class InferCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  InferCmp (InferType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tok = true;\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (CharType &type) override\n+  {\n+    {\n+      bool is_valid\n+\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+      if (is_valid)\n+\t{\n+\t  ok = true;\n+\t  return;\n+\t}\n+\n+      BaseCmp::visit (type);\n+    }\n+  }\n+\n+  void visit (ReferenceType &type) override\n+\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  InferType *base;\n+};\n+\n+class FnCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FnCmp (FnType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto unified_param = a->unify (b);\n+\tif (unified_param == nullptr)\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    auto unified_return\n+      = base->get_return_type ()->unify (type.get_return_type ());\n+    if (unified_return == nullptr)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnType *base;\n+};\n+\n+class FnptrCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FnptrCmp (FnPtr *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (FnPtr &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnPtr *base;\n+};\n+\n+class ArrayCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ArrayCmp (ArrayType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (ArrayType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    // need to check the base types and capacity\n+    if (type.get_capacity () != base->get_capacity ())\n+      {\n+\tLocation locus = mappings->lookup_location (type.get_ref ());\n+\trust_error_at (locus, \"mismatch in array capacity\");\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ArrayType *base;\n+};\n+\n+class BoolCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  BoolCmp (BoolType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (BoolType &type) override { ok = true; }\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  BoolType *base;\n+};\n+\n+class IntCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  IntCmp (IntType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    ok = type.get_int_kind () == base->get_int_kind ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  IntType *base;\n+};\n+\n+class UintCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  UintCmp (UintType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    ok = type.get_uint_kind () == base->get_uint_kind ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  UintType *base;\n+};\n+\n+class FloatCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FloatCmp (FloatType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::INTEGRAL;\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    ok = type.get_float_kind () == base->get_float_kind ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FloatType *base;\n+};\n+\n+class ADTCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ADTCmp (ADTType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (ADTType &type) override\n+  {\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < type.num_fields (); ++i)\n+      {\n+\tTyTy::StructFieldType *base_field = base->get_field (i);\n+\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\n+\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\tif (!this_field_ty->can_eq (other_field_ty))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ADTType *base;\n+};\n+\n+class TupleCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  TupleCmp (TupleType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (TupleType &type) override\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tBaseType *bo = base->get_field (i);\n+\tBaseType *fo = type.get_field (i);\n+\n+\tif (!bo->can_eq (fo))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  TupleType *base;\n+};\n+\n+class USizeCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  USizeCmp (USizeType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (USizeType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  USizeType *base;\n+};\n+\n+class ISizeCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ISizeCmp (ISizeType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (ISizeType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ISizeType *base;\n+};\n+\n+class CharCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  CharCmp (CharType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+  void visit (CharType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  CharType *base;\n+};\n+\n+class ReferenceCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ReferenceCmp (ReferenceType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    ok = base_type->can_eq (other_base_type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ReferenceType *base;\n+};\n+\n+class ParamCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ParamCmp (ParamType *base) : BaseCmp (base), base (base) {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  bool can_eq (BaseType *other) override final\n+  {\n+    if (base->get_ref () == base->get_ty_ref ())\n+      return BaseCmp::can_eq (other);\n+\n+    auto context = Resolver::TypeCheckContext::get ();\n+    BaseType *lookup = nullptr;\n+    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n+    rust_assert (ok);\n+\n+    return lookup->can_eq (other);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ParamType *base;\n+};\n+\n+class StrCmp : public BaseCmp\n+{\n+  // FIXME we will need a enum for the StrType like ByteBuf etc..\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  StrCmp (StrType *base) : BaseCmp (base), base (base) {}\n+\n+  void visit (StrType &type) override { ok = true; }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  StrType *base;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CMP_H"}, {"sha": "c23cbc1a749d4214101a3dc859e3069fa76969b8", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -67,8 +67,8 @@ class BaseRules : public TyVisitor\n       }\n \n     other->accept_vis (*this);\n-    if (resolved == nullptr)\n-      return nullptr;\n+    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+      return resolved;\n \n     resolved->append_reference (get_base ()->get_ref ());\n     resolved->append_reference (other->get_ref ());\n@@ -81,7 +81,7 @@ class BaseRules : public TyVisitor\n     bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n     bool results_is_non_general_infer_var\n       = (result_is_infer_var\n-\t && ((InferType *) resolved)->get_infer_kind ()\n+\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n \t      != TyTy::InferType::GENERAL);\n     if (result_resolved || results_is_non_general_infer_var)\n       {\n@@ -229,7 +229,7 @@ class BaseRules : public TyVisitor\n   virtual void visit (ParamType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    rust_error_at (ref_locus, \"expected [%s] got [ParamTy <%s>]\",\n+    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   get_base ()->as_string ().c_str (),\n \t\t   type.as_string ().c_str ());\n   }\n@@ -829,6 +829,12 @@ class ADTRules : public BaseRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->num_fields () != type.num_fields ())\n       {\n \tBaseRules::visit (type);\n@@ -844,11 +850,8 @@ class ADTRules : public BaseRules\n \tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n \n \tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty == nullptr)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n       }\n \n     resolved = type.clone ();\n@@ -882,11 +885,8 @@ class TupleRules : public BaseRules\n \tBaseType *fo = type.get_field (i);\n \n \tBaseType *unified_ty = bo->unify (fo);\n-\tif (unified_ty == nullptr)\n-\t  {\n-\t    BaseRules::visit (type);\n-\t    return;\n-\t  }\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n \n \tfields.push_back (TyVar (unified_ty->get_ref ()));\n       }\n@@ -1034,6 +1034,7 @@ class ParamRules : public BaseRules\n   {\n     if (base->get_ref () == base->get_ty_ref ())\n       return BaseRules::unify (other);\n+\n     auto context = Resolver::TypeCheckContext::get ();\n     BaseType *lookup = nullptr;\n     bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n@@ -1053,6 +1054,17 @@ class ParamRules : public BaseRules\n     resolved = type.clone ();\n   }\n \n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n "}, {"sha": "8f2faeccff67851d2d56386658137110d98f0d1d", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 122, "deletions": 2, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n+#include \"rust-tyty-cmp.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n \n@@ -91,6 +92,13 @@ InferType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+InferType::can_eq (BaseType *other)\n+{\n+  InferCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n InferType::clone ()\n {\n@@ -107,11 +115,13 @@ InferType::default_type (BaseType **type) const\n     {\n     case GENERAL:\n       return false;\n+\n       case INTEGRAL: {\n \tok = context->lookup_builtin (\"i32\", type);\n \trust_assert (ok);\n \treturn ok;\n       }\n+\n       case FLOAT: {\n \tok = context->lookup_builtin (\"f64\", type);\n \trust_assert (ok);\n@@ -139,6 +149,12 @@ ErrorType::unify (BaseType *other)\n   return this;\n }\n \n+bool\n+ErrorType::can_eq (BaseType *other)\n+{\n+  return get_kind () == other->get_kind ();\n+}\n+\n BaseType *\n ErrorType::clone ()\n {\n@@ -303,6 +319,13 @@ ADTType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ADTType::can_eq (BaseType *other)\n+{\n+  ADTCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n ADTType::is_equal (const BaseType &other) const\n {\n@@ -418,8 +441,7 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \tBaseType *concrete\n \t  = Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n \n-\tif (concrete == nullptr\n-\t    || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\tif (concrete->get_kind () == TyTy::TypeKind::ERROR)\n \t  {\n \t    rust_error_at (subst_mappings.get_locus (),\n \t\t\t   \"Failed to resolve field substitution type: %s\",\n@@ -469,6 +491,13 @@ TupleType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+TupleType::can_eq (BaseType *other)\n+{\n+  TupleCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n TupleType::is_equal (const BaseType &other) const\n {\n@@ -523,6 +552,13 @@ FnType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+FnType::can_eq (BaseType *other)\n+{\n+  FnCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n FnType::is_equal (const BaseType &other) const\n {\n@@ -712,6 +748,13 @@ FnPtr::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+FnPtr::can_eq (BaseType *other)\n+{\n+  FnptrCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n FnPtr::is_equal (const BaseType &other) const\n {\n@@ -766,6 +809,13 @@ ArrayType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ArrayType::can_eq (BaseType *other)\n+{\n+  ArrayCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n ArrayType::is_equal (const BaseType &other) const\n {\n@@ -814,6 +864,13 @@ BoolType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+BoolType::can_eq (BaseType *other)\n+{\n+  BoolCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n BoolType::clone ()\n {\n@@ -853,6 +910,13 @@ IntType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+IntType::can_eq (BaseType *other)\n+{\n+  IntCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n IntType::clone ()\n {\n@@ -903,6 +967,13 @@ UintType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+UintType::can_eq (BaseType *other)\n+{\n+  UintCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n UintType::clone ()\n {\n@@ -947,6 +1018,13 @@ FloatType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+FloatType::can_eq (BaseType *other)\n+{\n+  FloatCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n FloatType::clone ()\n {\n@@ -983,6 +1061,13 @@ USizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+USizeType::can_eq (BaseType *other)\n+{\n+  USizeCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n USizeType::clone ()\n {\n@@ -1008,6 +1093,13 @@ ISizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ISizeType::can_eq (BaseType *other)\n+{\n+  ISizeCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n ISizeType::clone ()\n {\n@@ -1033,6 +1125,13 @@ CharType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+CharType::can_eq (BaseType *other)\n+{\n+  CharCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n CharType::clone ()\n {\n@@ -1058,6 +1157,13 @@ ReferenceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ReferenceType::can_eq (BaseType *other)\n+{\n+  ReferenceCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n ReferenceType::is_equal (const BaseType &other) const\n {\n@@ -1110,6 +1216,13 @@ ParamType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+ParamType::can_eq (BaseType *other)\n+{\n+  ParamCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n BaseType *\n ParamType::clone ()\n {\n@@ -1178,6 +1291,13 @@ StrType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+bool\n+StrType::can_eq (BaseType *other)\n+{\n+  StrCmp r (this);\n+  return r.can_eq (other);\n+}\n+\n bool\n StrType::is_equal (const BaseType &other) const\n {"}, {"sha": "c428c4c6c6cd7bd252063824eeb68b446a2f2373", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -75,22 +75,29 @@ class BaseType\n \n   virtual std::string get_name () const = 0;\n \n-  /* Unify two types. Returns a pointer to the newly-created unified ty, or\n-     nullptr if the two ty cannot be unified. The caller is responsible for\n-     releasing the memory of the returned ty. */\n+  // Unify two types. Returns a pointer to the newly-created unified ty, or\n+  // nullptr if the two ty cannot be unified. The caller is responsible for\n+  // releasing the memory of the returned ty. using ignore_errors alows for a\n+  // can_eq style unification\n   virtual BaseType *unify (BaseType *other) = 0;\n \n-  /* Check value equality between two ty. Type inference rules are ignored. Two\n-     ty are considered equal if they're of the same kind, and\n-       1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n-       2. (For functions) have the same signature */\n+  // similar to unify but does not actually perform type unification but\n+  // determines whether they are compatible\n+  virtual bool can_eq (BaseType *other) = 0;\n+\n+  // Check value equality between two ty. Type inference rules are ignored. Two\n+  //   ty are considered equal if they're of the same kind, and\n+  //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n+  //     2. (For functions) have the same signature\n   virtual bool is_equal (const BaseType &other) const\n   {\n     return get_kind () == other.get_kind ();\n   }\n \n   virtual bool is_unit () const { return false; }\n \n+  virtual bool is_concrete () const { return true; }\n+\n   TypeKind get_kind () const { return kind; }\n \n   /* Returns a pointer to a clone of this. The caller is responsible for\n@@ -111,6 +118,8 @@ class BaseType\n     return supports_substitutions () && has_subsititions_defined ();\n   }\n \n+  virtual bool needs_generic_substitutions () const { return false; }\n+\n   std::string mappings_str () const\n   {\n     std::string buffer = \"Ref: \" + std::to_string (get_ref ())\n@@ -127,7 +136,11 @@ class BaseType\n     return as_string () + \":\" + mappings_str ();\n   }\n \n-  void debug () const { printf (\"%s\\n\", debug_str ().c_str ()); }\n+  void debug () const\n+  {\n+    printf (\"[%p] %s\\n\", static_cast<const void *> (this),\n+\t    debug_str ().c_str ());\n+  }\n \n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n@@ -186,6 +199,8 @@ class InferType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n+  bool can_eq (BaseType *other) override;\n+\n   BaseType *clone () final override;\n \n   InferTypeKind get_infer_kind () const { return infer_kind; }\n@@ -194,6 +209,8 @@ class InferType : public BaseType\n \n   bool default_type (BaseType **type) const;\n \n+  bool is_concrete () const final override { return false; }\n+\n private:\n   InferTypeKind infer_kind;\n };\n@@ -216,6 +233,7 @@ class ErrorType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -242,6 +260,7 @@ class ParamType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -312,6 +331,7 @@ class TupleType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -321,6 +341,16 @@ class TupleType : public BaseType\n \n   BaseType *clone () final override;\n \n+  bool is_concrete () const override final\n+  {\n+    for (size_t i = 0; i < num_fields (); i++)\n+      {\n+\tif (!get_field (i)->is_concrete ())\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n   void iterate_fields (std::function<bool (BaseType *)> cb) const\n   {\n     for (size_t i = 0; i < num_fields (); i++)\n@@ -405,6 +435,12 @@ class SubstitutionArg\n \n   static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n \n+  bool is_conrete () const\n+  {\n+    return argument != nullptr && argument->get_kind () != TyTy::TypeKind::ERROR\n+\t   && argument->get_kind () != TyTy::TypeKind::PARAM;\n+  }\n+\n   std::string as_string () const\n   {\n     return param->as_string () + \":\" + argument->as_string ();\n@@ -459,6 +495,19 @@ class SubstitutionArgumentMappings\n     return false;\n   }\n \n+  // is_concrete means if the used args is non error, ie: non empty this will\n+  // verify if actual real types have been put in place of are they still\n+  // ParamTy\n+  bool is_concrete () const\n+  {\n+    for (auto &mapping : mappings)\n+      {\n+\tif (!mapping.is_conrete ())\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n   Location get_locus () { return locus; }\n \n   size_t size () const { return mappings.size (); }\n@@ -529,7 +578,8 @@ class SubstitutionRef\n \n   bool needs_substitution () const\n   {\n-    return has_substitutions () && used_arguments.is_error ();\n+    return has_substitutions ()\n+\t   && (used_arguments.is_error () || !used_arguments.is_concrete ());\n   }\n \n   bool was_substituted () const { return !needs_substitution (); }\n@@ -608,11 +658,14 @@ class ADTType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n   size_t num_fields () const { return fields.size (); }\n \n+  std::string get_identifier () const { return identifier; }\n+\n   std::string get_name () const override final\n   {\n     return identifier + subst_as_string ();\n@@ -657,6 +710,11 @@ class ADTType : public BaseType, public SubstitutionRef\n       }\n   }\n \n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n   bool supports_substitutions () const override final { return true; }\n \n   bool has_subsititions_defined () const override final\n@@ -702,6 +760,7 @@ class FnType : public BaseType, public SubstitutionRef\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -731,6 +790,11 @@ class FnType : public BaseType, public SubstitutionRef\n \n   BaseType *clone () final override;\n \n+  bool needs_generic_substitutions () const override final\n+  {\n+    return needs_substitution ();\n+  }\n+\n   bool supports_substitutions () const override final { return true; }\n \n   bool has_subsititions_defined () const override final\n@@ -774,6 +838,7 @@ class FnPtr : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -815,6 +880,7 @@ class ArrayType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -824,6 +890,11 @@ class ArrayType : public BaseType\n \n   BaseType *clone () final override;\n \n+  bool is_concrete () const final override\n+  {\n+    return get_element_type ()->is_concrete ();\n+  }\n+\n private:\n   size_t capacity;\n   TyVar element_type;\n@@ -847,6 +918,7 @@ class BoolType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -879,6 +951,7 @@ class IntType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   IntKind get_int_kind () const { return int_kind; }\n \n@@ -918,6 +991,7 @@ class UintType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   UintKind get_uint_kind () const { return uint_kind; }\n \n@@ -955,6 +1029,7 @@ class FloatType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   FloatKind get_float_kind () const { return float_kind; }\n \n@@ -994,6 +1069,7 @@ class USizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1026,6 +1102,7 @@ class ISizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1058,6 +1135,7 @@ class CharType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1094,6 +1172,7 @@ class ReferenceType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1131,6 +1210,7 @@ class StrType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n+  bool can_eq (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n "}, {"sha": "0dcbd4f03c79aca4a8fc30f735d67e68a20b1413", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -524,5 +524,24 @@ Mappings::resolve_nodeid_to_stmt (CrateNum crate, NodeId id, HIR::Stmt **stmt)\n   return resolved_stmt != nullptr;\n }\n \n+void\n+Mappings::iterate_impl_items (\n+  std::function<bool (HirId, HIR::InherentImplItem *, HIR::InherentImpl *)> cb)\n+{\n+  for (auto it = hirImplItemMappings.begin (); it != hirImplItemMappings.end ();\n+       it++)\n+    {\n+      for (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n+\t{\n+\t  auto id = iy->first;\n+\t  auto impl_item = iy->second.second;\n+\t  auto impl = lookup_associated_impl (\n+\t    impl_item->get_impl_mappings ().get_hirid ());\n+\t  if (!cb (id, impl_item, impl))\n+\t    return;\n+\t}\n+    }\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "9777ee341bc1eac26d224efdf178fd3ebd6239dc", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -158,20 +158,24 @@ class Mappings\n     return hirNodesWithinCrate[crate];\n   }\n \n-  void\n-  iterate_impl_items (std::function<bool (HirId, HIR::InherentImplItem *)> cb)\n+  void insert_impl_item_mapping (HirId impl_item_id, HIR::InherentImpl *impl)\n   {\n-    for (auto it = hirImplItemMappings.begin ();\n-\t it != hirImplItemMappings.end (); it++)\n-      {\n-\tfor (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n-\t  {\n-\t    if (!cb (iy->first, iy->second.second))\n-\t      return;\n-\t  }\n-      }\n+    rust_assert (hirImplItemsToImplMappings.find (impl_item_id)\n+\t\t == hirImplItemsToImplMappings.end ());\n+    hirImplItemsToImplMappings[impl_item_id] = impl;\n   }\n \n+  HIR::InherentImpl *lookup_associated_impl (HirId impl_item_id)\n+  {\n+    auto lookup = hirImplItemsToImplMappings.find (impl_item_id);\n+    rust_assert (lookup != hirImplItemsToImplMappings.end ());\n+    return lookup->second;\n+  }\n+\n+  void iterate_impl_items (\n+    std::function<bool (HirId, HIR::InherentImplItem *, HIR::InherentImpl *)>\n+      cb);\n+\n private:\n   Mappings ();\n \n@@ -198,6 +202,7 @@ class Mappings\n \t   std::map<HirId, std::pair<HirId, HIR::InherentImplItem *> > >\n     hirImplItemMappings;\n   std::map<CrateNum, std::map<HirId, HIR::SelfParam *> > hirSelfParamMappings;\n+  std::map<HirId, HIR::InherentImpl *> hirImplItemsToImplMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}, {"sha": "5c8795d229c0687738744d4cbcedc148e1973164", "filename": "gcc/testsuite/rust.test/compile/generics13.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics13.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,40 @@\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+struct GenericStruct<T> {\n+    a: T,\n+    b: usize,\n+}\n+\n+impl Foo<isize> {\n+    fn test() -> i32 {\n+        123\n+    }\n+\n+    fn bar(self) -> isize {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a: i32 = Foo::test();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    let a2: GenericStruct<i8>;\n+    a2 = GenericStruct::<i8> { a: 1, b: 456 };\n+\n+    let b2: i8 = a2.a;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    let c2: usize = a2.b;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    let a4;\n+    a4 = GenericStruct { a: 1.0, b: 456 };\n+\n+    let b4: f32 = a4.a;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    let c4: usize = a4.b;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "aa8fbf21228712ce5eb3ae314e8c06123fe9597b", "filename": "gcc/testsuite/rust.test/compile/generics14.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics14.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics14.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics14.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,19 @@\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+impl Foo<isize> {\n+    fn test() -> i32 {\n+        123\n+    }\n+\n+    fn bar(self) -> isize {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a: i32 = Foo::test();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "c16a67c4dd559ba179098101e07fe53ec0ddaf0d", "filename": "gcc/testsuite/rust.test/compile/generics15.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics15.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics15.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics15.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,23 @@\n+struct Foo<T>(T, bool);\n+\n+impl Foo<i32> {\n+    fn bar(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+impl Foo<f32> {\n+    fn bar(self) -> f32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo(123, true);\n+    let aa = a.bar();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    let b = Foo(456f32, true);\n+    let bb = b.bar();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "15b9d7b55e73385c04695f0fd29353a83cc470b0", "filename": "gcc/testsuite/rust.test/compile/generics16.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics16.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics16.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics16.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,31 @@\n+struct Foo<T>(T, bool);\n+\n+impl Foo<i32> {\n+    fn new() -> Self {\n+        Foo(123, true)\n+    }\n+\n+    fn bar(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+impl Foo<f32> {\n+    fn new() -> Self {\n+        Foo(123f32, true)\n+    }\n+\n+    fn bar(self) -> f32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo::<i32>::new();\n+    let aa: i32 = a.bar();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    let b = Foo::<f32>::new();\n+    let bb: f32 = b.bar();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "256d2aae22a0bdffc7c0e52b60f36db1e2b3d028", "filename": "gcc/testsuite/rust.test/xfail_compile/generics6.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics6.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,29 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+impl Foo<isize> {\n+    fn test() -> i32 { // {dg-error \"possible candidate\" } \n+        123\n+    }\n+\n+    fn bar(self) -> isize {\n+        self.a\n+    }\n+}\n+\n+impl Foo<f32> {\n+    fn test() -> i32 { // {dg-error \"possible candidate\" }\n+        123\n+    }\n+\n+    fn bar(self) -> f32 {\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a: i32 = Foo::test(); // { dg-error \"multiple applicable items in scope for: test\" }\n+}\n+"}, {"sha": "d8a9e93e13f22aa7ab03259ca9d64114a8976c4b", "filename": "gcc/testsuite/rust.test/xfail_compile/generics7.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics7.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,27 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+impl Foo<isize> {\n+    fn bar(self) -> isize { // { dg-error \"duplicate definitions with name bar\" }\n+        self.a\n+    }\n+}\n+\n+impl Foo<char> {\n+    fn bar(self) -> char { // { dg-error \"duplicate definitions with name bar\" }\n+        self.a\n+    }\n+}\n+\n+impl<T> Foo<T> {\n+    fn bar(self) -> T {\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo { a: 123 };\n+    a.bar();\n+}"}, {"sha": "ef7e35763492a860e9e5f2ae8baa2fe360014b4c", "filename": "gcc/testsuite/rust.test/xfail_compile/redef_error6.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fredef_error6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fredef_error6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fredef_error6.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -0,0 +1,15 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<T>(T, usize);\n+\n+impl Foo<i32> {\n+    fn test() -> i32 {\n+        123\n+    }\n+\n+    fn test(self) -> i32 {\n+        // { dg-error \"redefined multiple times\" \"\" { target *-*-* } .-1 }\n+        self.0\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "67a33f41295f414f4f3297841b1ccd0bb2a42f33", "filename": "gcc/testsuite/rust.test/xfail_compile/tuple1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftuple1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftuple1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftuple1.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -1,3 +1,4 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n fn main() {\n     let a: (i32, bool) = (123, 123); // { dg-error \"expected .bool. got .<integer>.\" }\n     let b;"}, {"sha": "53b49234b6a5f6f2ce7a92cc592121f5ef1a1a8b", "filename": "gcc/testsuite/rust.test/xfail_compile/type-alias1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftype-alias1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636ad7d95e0f2afa1544ba7deeadf3d52de18a82/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftype-alias1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Ftype-alias1.rs?ref=636ad7d95e0f2afa1544ba7deeadf3d52de18a82", "patch": "@@ -1,3 +1,4 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n type TypeAlias = (i32, u32);\n \n fn main() {"}]}