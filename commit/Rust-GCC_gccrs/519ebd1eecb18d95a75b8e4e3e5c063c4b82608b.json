{"sha": "519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5ZWJkMWVlY2IxOGQ5NWE3NWI4ZTRlM2U1YzA2M2M0YjgyNjA4Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-06-23T01:49:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-23T01:49:05Z"}, "message": "call.c (joust): Fix confusing conversion warning.\n\n\t* call.c (joust): Fix confusing conversion warning.\n\t* call.c (build_op_delete_call): Add placement parm.  Check\n\tLOOKUP_SPECULATIVELY.\n\t* cp-tree.h, decl2.c, init.c: Adjust.\n\t* decl.c (finish_function): Use it.\n\t* pt.c (tsubst): Diagnose creating void fields or variables.\n\nFrom-SVN: r20668", "tree": {"sha": "9ef5d9ccc281c5e870c35df3179c526ac1ef69ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef5d9ccc281c5e870c35df3179c526ac1ef69ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/comments", "author": null, "committer": null, "parents": [{"sha": "5b8e7fa3f89041ca0e46f4cd71851c69df71a2e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8e7fa3f89041ca0e46f4cd71851c69df71a2e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b8e7fa3f89041ca0e46f4cd71851c69df71a2e4"}], "stats": {"total": 147, "additions": 82, "deletions": 65}, "files": [{"sha": "27a81786e74a3bf597589a7abff4022981ea3fb3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -1,3 +1,14 @@\n+1998-06-23  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (joust): Fix confusing conversion warning.\n+\n+\t* call.c (build_op_delete_call): Add placement parm.  Check\n+\tLOOKUP_SPECULATIVELY.\n+\t* cp-tree.h, decl2.c, init.c: Adjust.\n+\t* decl.c (finish_function): Use it.\n+\n+\t* pt.c (tsubst): Diagnose creating void fields or variables.\n+\n Mon Jun 22 08:50:26 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* call.c (build_scoped_method_call): Remove unused variable `tmp'."}, {"sha": "f6ff5f605d2b5bd3e3ed84fb4b5ab88e89c9a68d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -2913,16 +2913,16 @@ build_op_new_call (code, type, args, flags)\n    ADDR is the pointer to be deleted.  For placement delete, it is also\n      used to determine what the corresponding new looked like.\n    SIZE is the size of the memory block to be deleted.\n-   FLAGS are the usual overloading flags.  */\n+   FLAGS are the usual overloading flags.\n+   PLACEMENT is the corresponding placement new call, or 0.  */\n \n tree\n-build_op_delete_call (code, addr, size, flags)\n+build_op_delete_call (code, addr, size, flags, placement)\n      enum tree_code code;\n-     tree addr, size;\n+     tree addr, size, placement;\n      int flags;\n {\n   tree fn, fns, fnname, fntype, argtypes, args, type;\n-  int placement;\n \n   if (addr == error_mark_node)\n     return error_mark_node;\n@@ -2946,42 +2946,20 @@ build_op_delete_call (code, addr, size, flags)\n   else\n     fns = NULL_TREE;\n \n-  if (fns)\n-    {\n-#if 0\n-      /* It is unnecessary to wrap another TREE_LIST around it. (MvL) */\n-      /* Build this up like build_offset_ref does.  */\n-      fns = build_tree_list (error_mark_node, fns);\n-      TREE_TYPE (fns) = build_offset_type (type, unknown_type_node);\n-#endif\n-    }\n-  else\n+  if (fns == NULL_TREE)\n     fns = lookup_name_nonclass (fnname);\n \n-  /* We can recognize a placement delete because of LOOKUP_SPECULATIVELY;\n-     if we are doing placement delete we do nothing if we don't find a\n-     matching op delete.  */\n-  placement = !!(flags & LOOKUP_SPECULATIVELY);\n   if (placement)\n     {\n-      /* If placement, we are coming from build_new, and we know that addr\n-\t is the allocation expression, so extract the info we need from it.\n-\t Obviously, if the build_new process changes this may have to\n-\t change as well.  */\n-\n-      /* The NOP_EXPR.  */\n-      tree t = TREE_OPERAND (addr, 1);\n-      /* The CALL_EXPR.  */\n-      t = TREE_OPERAND (t, 0);\n-      /* The function.  */\n-      argtypes = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-      /* The second parm type.  */\n+      /* placement is a CALL_EXPR around an ADDR_EXPR around a function.  */\n+\n+      /* Extract the function.  */\n+      argtypes = TREE_OPERAND (TREE_OPERAND (placement, 0), 0);\n+      /* Then the second parm type.  */\n       argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (argtypes)));\n-      /* The second argument.  */\n-      args = TREE_CHAIN (TREE_OPERAND (t, 1));\n \n-      /* Pull the dummy var out of the TARGET_EXPR for use in our call.  */\n-      addr = TREE_OPERAND (addr, 0);\n+      /* Also the second argument.  */\n+      args = TREE_CHAIN (TREE_OPERAND (placement, 1));\n     }\n   else\n     {\n@@ -3012,6 +2990,8 @@ build_op_delete_call (code, addr, size, flags)\n       return build_function_call (fn, expr_tree_cons (NULL_TREE, addr, args));\n     }\n \n+  /* If we are doing placement delete we do nothing if we don't find a\n+     matching op delete.  */\n   if (placement)\n     return NULL_TREE;\n \n@@ -3023,9 +3003,20 @@ build_op_delete_call (code, addr, size, flags)\n   fn = instantiate_type (fntype, fns, 0);\n \n   if (fn != error_mark_node)\n-    return build_function_call\n-      (fn, expr_tree_cons (NULL_TREE, addr,\n-\t\t\t   build_expr_list (NULL_TREE, size)));\n+    {\n+      if (TREE_CODE (fns) == TREE_LIST)\n+\t/* Member functions.  */\n+\tenforce_access (TREE_PURPOSE (fns), fn);\n+      return build_function_call\n+\t(fn, expr_tree_cons (NULL_TREE, addr,\n+\t\t\t     build_expr_list (NULL_TREE, size)));\n+    }\n+\n+  /* finish_function passes LOOKUP_SPECULATIVELY if we're in a\n+     destructor, in which case the error should be deferred\n+     until someone actually tries to delete one of these.  */\n+  if (flags & LOOKUP_SPECULATIVELY)\n+    return NULL_TREE;\n \n   cp_error (\"no suitable operator delete for `%T'\", type);\n   return error_mark_node;\n@@ -4324,7 +4315,9 @@ joust (cand1, cand2, warn)\n     }\n \n   /* warn about confusing overload resolution */\n-  if (winner && cand1->second_conv)\n+  if (winner && cand1->second_conv\n+      && (! DECL_CONSTRUCTOR_P (cand1->fn)\n+\t  || ! DECL_CONSTRUCTOR_P (cand2->fn)))\n     {\n       int comp = compare_ics (cand1->second_conv, cand2->second_conv);\n       if (comp != winner)\n@@ -4336,10 +4329,12 @@ joust (cand1, cand2, warn)\n \t    w = cand2, l = cand1;\n \t  if (warn)\n \t    {\n+\t      tree source = source_type (TREE_VEC_ELT (w->convs, 0));\n+\t      if (! DECL_CONSTRUCTOR_P (w->fn))\n+\t\tsource = TREE_TYPE (source);\n \t      cp_warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n \t      cp_warning (\"  for conversion from `%T' to `%T'\",\n-\t\t\t  TREE_TYPE (source_type (TREE_VEC_ELT (w->convs, 0))),\n-\t\t\t  TREE_TYPE (w->second_conv));\n+\t\t\t  source, TREE_TYPE (w->second_conv));\n \t      cp_warning (\"  because conversion sequence for the argument is better\");\n \t    }\n \t  else"}, {"sha": "429f0ba8be90556fee77c999284560b9048b50ae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -2251,7 +2251,7 @@ extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n extern tree build_new_function_call\t\tPROTO((tree, tree));\n extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n extern tree build_op_new_call\t\t\tPROTO((enum tree_code, tree, tree, int));\n-extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int));\n+extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int, tree));\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n extern void enforce_access                      PROTO((tree, tree));"}, {"sha": "ab2a462fa26074ef7012c81d338c7614c783e814", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -12507,20 +12507,22 @@ finish_function (lineno, call_poplevel, nested)\n \t  virtual_size = c_sizeof (current_class_type);\n \n \t  /* At the end, call delete if that's what's requested.  */\n-\t  if (TYPE_GETS_REG_DELETE (current_class_type))\n-\t    /* This NOP_EXPR means we are in a static call context.  */\n-\t    exprstmt\n-\t      = build_method_call (build_indirect_ref (build1 (NOP_EXPR,\n-\t\t\t\t\t\t\t       build_pointer_type (current_class_type),\n-\t\t\t\t\t\t\t       error_mark_node),\n-\t\t\t\t\t\t       NULL_PTR),\n-\t\t\t\t   ansi_opname[(int) DELETE_EXPR],\n-\t\t\t\t   expr_tree_cons (NULL_TREE, current_class_ptr,\n-\t\t\t\t\t      build_expr_list (NULL_TREE, virtual_size)),\n-\t\t\t\t   NULL_TREE, LOOKUP_NORMAL);\n-\t  else if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t    exprstmt = build_x_delete (ptr_type_node, current_class_ptr, 0,\n-\t\t\t\t       virtual_size);\n+\n+\t  /* FDIS sez: At the point of definition of a virtual destructor\n+\t       (including an implicit definition), non-placement operator\n+\t       delete shall be looked up in the scope of the destructor's\n+\t       class and if found shall be accessible and unambiguous.\n+\n+\t     This is somewhat unclear, but I take it to mean that if the\n+\t     class only defines placement deletes we don't do anything here.\n+\t     So we pass LOOKUP_SPECULATIVELY; delete_sanity will complain\n+\t     for us if they ever try to delete one of these.  */\n+\n+\t  if (TYPE_GETS_REG_DELETE (current_class_type)\n+\t      || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+\t    exprstmt = build_op_delete_call\n+\t      (DELETE_EXPR, current_class_ptr, virtual_size,\n+\t       LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n \t  else\n \t    exprstmt = NULL_TREE;\n "}, {"sha": "b3e3385c8e6c38cf2cac131cf13b724ba1c333b7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -1326,8 +1326,8 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \t{\n \t  /* Only do access checking here; we'll be calling op delete\n \t     from the destructor.  */\n-\t  tree tmp = build_op_delete_call (DELETE_EXPR, t,\n-\t\t\t\t\t   size_zero_node, LOOKUP_NORMAL);\n+\t  tree tmp = build_op_delete_call (DELETE_EXPR, t, size_zero_node,\n+\t\t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n \t  if (tmp == error_mark_node)\n \t    return error_mark_node;\n \t}"}, {"sha": "93367f73867e6bfd9f47f08bd938df57dd8de995", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -2409,22 +2409,26 @@ build_new_1 (exp)\n       if (flag_exceptions && alloc_expr)\n \t{\n \t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n-\t  tree cleanup;\n+\t  tree cleanup, fn = NULL_TREE;\n \t  int flags = LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL);\n \n \t  /* All cleanups must last longer than normal.  */\n \t  int yes = suspend_momentary ();\n \n \t  if (placement)\n-\t    flags |= LOOKUP_SPECULATIVELY;\n+\t    {\n+\t      flags |= LOOKUP_SPECULATIVELY;\n+\n+\t      /* We expect alloc_expr to look like a TARGET_EXPR around\n+\t\t a NOP_EXPR around the CALL_EXPR we want.  */\n+\t      fn = TREE_OPERAND (alloc_expr, 1);\n+\t      fn = TREE_OPERAND (fn, 0);\n+\t    }\n \n \t  /* Copy size to the saveable obstack.  */\n \t  size = copy_node (size);\n \n-\t  /* If we have a new-placement, we need to pass the alloc TARGET_EXPR\n-\t     to build_op_delete_call so it can extract the args.  */\n-\t  cleanup = build_op_delete_call\n-\t    (dcode, placement ? alloc_expr : alloc_node, size, flags);\n+\t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags, fn);\n \n \t  resume_momentary (yes);\n \n@@ -2924,7 +2928,7 @@ build_x_delete (type, addr, which_delete, virtual_size)\n   enum tree_code code = use_vec_delete ? VEC_DELETE_EXPR : DELETE_EXPR;\n   int flags = LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL);\n \n-  return build_op_delete_call (code, addr, virtual_size, flags);\n+  return build_op_delete_call (code, addr, virtual_size, flags, NULL_TREE);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n@@ -3020,7 +3024,8 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       return build_op_delete_call\n \t(DELETE_EXPR, addr, c_sizeof_nowarn (type),\n-\t LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL));\n+\t LOOKUP_NORMAL | (use_global_delete * LOOKUP_GLOBAL),\n+\t NULL_TREE);\n     }\n \n   /* Below, we will reverse the order in which these calls are made."}, {"sha": "3bd901625c3efc37a374381757152e46627eff71", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "patch": "@@ -4777,6 +4777,8 @@ tsubst (t, args, in_decl)\n #endif\n \tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n+\tif (TREE_CODE (type) == VOID_TYPE)\n+\t  cp_error_at (\"instantiation of `%D' as type void\", r);\n \treturn r;\n       }\n \n@@ -4836,6 +4838,8 @@ tsubst (t, args, in_decl)\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t  }\n \tTREE_CHAIN (r) = NULL_TREE;\n+\tif (TREE_CODE (type) == VOID_TYPE)\n+\t  cp_error_at (\"instantiation of `%D' as type void\", r);\n \treturn r;\n       }\n "}]}