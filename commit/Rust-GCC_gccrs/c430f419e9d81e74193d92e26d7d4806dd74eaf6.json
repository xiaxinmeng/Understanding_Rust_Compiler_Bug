{"sha": "c430f419e9d81e74193d92e26d7d4806dd74eaf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzMGY0MTllOWQ4MWU3NDE5M2Q5MmUyNmQ3ZDQ4MDZkZDc0ZWFmNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-12-03T18:39:22Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-12-03T18:39:22Z"}, "message": "re PR target/64019 (ICE in extract_constrain_insn)\n\n[gcc]\n2014-12-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/64019\n\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Do\n\tnot create LO_SUM address for constant addresses if the type can\n\tgo in Altivec registers.\n\n[gcc/testsuite]\n2014-12-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/64019\n\t* gcc.target/powerpc/pr64019.c: New file.\n\nFrom-SVN: r218327", "tree": {"sha": "00296a7f489d1dc66feb368d4e2d8a79a9db4107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00296a7f489d1dc66feb368d4e2d8a79a9db4107"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c430f419e9d81e74193d92e26d7d4806dd74eaf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c430f419e9d81e74193d92e26d7d4806dd74eaf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c430f419e9d81e74193d92e26d7d4806dd74eaf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c430f419e9d81e74193d92e26d7d4806dd74eaf6/comments", "author": null, "committer": null, "parents": [{"sha": "48749dbcc461753861059d1fc48c40d2e0aefaa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48749dbcc461753861059d1fc48c40d2e0aefaa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48749dbcc461753861059d1fc48c40d2e0aefaa2"}], "stats": {"total": 89, "additions": 88, "deletions": 1}, "files": [{"sha": "928b6b8d08c6a2bc8871f2555c622b8ae644aeaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c430f419e9d81e74193d92e26d7d4806dd74eaf6", "patch": "@@ -1,3 +1,10 @@\n+2014-12-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/64019\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Do\n+\tnot create LO_SUM address for constant addresses if the type can\n+\tgo in Altivec registers.\n+\n 2014-12-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR fortran/44054"}, {"sha": "506233748a71602b3f8288b3aff790bee91c549d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c430f419e9d81e74193d92e26d7d4806dd74eaf6", "patch": "@@ -7575,7 +7575,11 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \t naturally aligned.  Since we say the address is good here, we\n \t can't disable offsets from LO_SUMs in mem_operand_gpr.\n \t FIXME: Allow offset from lo_sum for other modes too, when\n-\t mem is sufficiently aligned.  */\n+\t mem is sufficiently aligned.\n+\n+\t Also disallow this if the type can go in VMX/Altivec registers, since\n+\t those registers do not have d-form (reg+offset) address modes.  */\n+      && !reg_addr[mode].scalar_in_vmx_p\n       && mode != TFmode\n       && mode != TDmode\n       && (mode != TImode || !TARGET_VSX_TIMODE)"}, {"sha": "8c68f5135f44b6e04920e330d12b1f9c37d2c7a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c430f419e9d81e74193d92e26d7d4806dd74eaf6", "patch": "@@ -1,3 +1,8 @@\n+2014-12-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/64019\n+\t* gcc.target/powerpc/pr64019.c: New file.\n+\n 2014-12-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR fortran/44054"}, {"sha": "a39b21917982a3221129d05507e46a3e51100aff", "filename": "gcc/testsuite/gcc.target/powerpc/pr64019.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr64019.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c430f419e9d81e74193d92e26d7d4806dd74eaf6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr64019.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr64019.c?ref=c430f419e9d81e74193d92e26d7d4806dd74eaf6", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-O2 -ffast-math -mcpu=power7\" } */\n+\n+#include <math.h>\n+\n+typedef struct\n+{\n+  double x, y, z;\n+  double q, a, b, mass;\n+  double vx, vy, vz, vw, dx, dy, dz;\n+}\n+ATOM;\n+int\n+u_f_nonbon (lambda)\n+     double lambda;\n+{\n+  double r, r0, xt, yt, zt;\n+  double lcutoff, cutoff, get_f_variable ();\n+  double rdebye;\n+  int inbond, inangle, i;\n+  ATOM *a1, *a2, *bonded[10], *angled[10];\n+  ATOM *(*use)[];\n+  int uselist (), nuse, used;\n+  ATOM *cp, *bp;\n+  int a_number (), inbuffer;\n+  double (*buffer)[], xx, yy, zz, k;\n+  int invector, atomsused, ii, jj, imax;\n+  double (*vector)[];\n+  ATOM *(*atms)[];\n+  double dielectric;\n+  rdebye = cutoff / 2.;\n+  dielectric = get_f_variable (\"dielec\");\n+  imax = a_number ();\n+  for (jj = 1; jj < imax; jj++, a1 = bp)\n+    {\n+      if ((*use)[used] == a1)\n+\t{\n+\t  used += 1;\n+\t}\n+      while ((*use)[used] != a1)\n+\t{\n+\t  for (i = 0; i < inbuffer; i++)\n+\t    {\n+\t    }\n+\t  xx = a1->x + lambda * a1->dx;\n+\t  yy = a1->y + lambda * a1->dy;\n+\t  zz = a1->z + lambda * a1->dz;\n+\t  for (i = 0; i < inbuffer; i++)\n+\t    {\n+\t      xt = xx - (*buffer)[3 * i];\n+\t      yt = yy - (*buffer)[3 * i + 1];\n+\t      zt = zz - (*buffer)[3 * i + 2];\n+\t      r = xt * xt + yt * yt + zt * zt;\n+\t      r0 = sqrt (r);\n+\t      xt = xt / r0;\n+\t      zt = zt / r0;\n+\t      k =\n+\t\t-a1->q * (*atms)[i]->q * dielectric * exp (-r0 / rdebye) *\n+\t\t(1. / (rdebye * r0) + 1. / r);\n+\t      k += a1->a * (*atms)[i]->a / r / r0 * 6;\n+\t      k -= a1->b * (*atms)[i]->b / r / r / r0 * 12;\n+\t      (*vector)[3 * i] = xt * k;\n+\t      (*vector)[3 * i + 1] = yt * k;\n+\t      (*vector)[3 * i + 2] = zt * k;\n+\t    }\n+\t}\n+    }\n+}"}]}