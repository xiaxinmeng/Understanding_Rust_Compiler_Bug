{"sha": "0ad9c7087ef3904da89f2db6007b6d28b116087f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFkOWM3MDg3ZWYzOTA0ZGE4OWYyZGI2MDA3YjZkMjhiMTE2MDg3Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-18T12:07:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-21T13:01:52Z"}, "message": "tree-optimization/101120 - fix compile-time issue with SLP groups\n\nThis places two hacks to avoid an old compile-time issue when\nvectorizing large permuted SLP groups with gaps where we end up\nemitting loads and IV adjustments for the gap as well and those\nhave quite a high cost until they are eventually cleaned up.\n\nThe first hack is to fold the auto-inc style IV updates early\nin the vectorizer rather than in the next forwprop pass which\nshortens the SSA use-def chains of the used IV.\n\nThe second hack is to remove the unused loads after we've picked\nall that we possibly use.\n\n2021-06-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101120\n\t* tree-vect-data-refs.c (bump_vector_ptr): Fold the\n\tbuilt increment.\n\t* tree-vect-slp.c (vect_transform_slp_perm_load): Add\n\tDR chain DCE capability.\n\t* tree-vectorizer.h (vect_transform_slp_perm_load): Adjust.\n\t* tree-vect-stmts.c (vectorizable_load): Remove unused\n\tloads in the DR chain for SLP.", "tree": {"sha": "f4b7d5a5628d791a2c8ee0a3139cbfc38a046328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4b7d5a5628d791a2c8ee0a3139cbfc38a046328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ad9c7087ef3904da89f2db6007b6d28b116087f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ad9c7087ef3904da89f2db6007b6d28b116087f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ad9c7087ef3904da89f2db6007b6d28b116087f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ad9c7087ef3904da89f2db6007b6d28b116087f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21761d2b2b01f6cef4287c646845f6b3006546aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21761d2b2b01f6cef4287c646845f6b3006546aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21761d2b2b01f6cef4287c646845f6b3006546aa"}], "stats": {"total": 52, "additions": 44, "deletions": 8}, "files": [{"sha": "be067c8923bdc82649ceac5f1b650d0643c4421b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0ad9c7087ef3904da89f2db6007b6d28b116087f", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-hash-traits.h\"\n #include \"vec-perm-indices.h\"\n #include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n \n /* Return true if load- or store-lanes optab OPTAB is implemented for\n    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */\n@@ -5026,7 +5027,7 @@ bump_vector_ptr (vec_info *vinfo,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree update = TYPE_SIZE_UNIT (vectype);\n-  gassign *incr_stmt;\n+  gimple *incr_stmt;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n   tree new_dataref_ptr;\n@@ -5041,6 +5042,15 @@ bump_vector_ptr (vec_info *vinfo,\n   incr_stmt = gimple_build_assign (new_dataref_ptr, POINTER_PLUS_EXPR,\n \t\t\t\t   dataref_ptr, update);\n   vect_finish_stmt_generation (vinfo, stmt_info, incr_stmt, gsi);\n+  /* Fold the increment, avoiding excessive chains use-def chains of\n+     those, leading to compile-time issues for passes until the next\n+     forwprop pass which would do this as well.  */\n+  gimple_stmt_iterator fold_gsi = gsi_for_stmt (incr_stmt);\n+  if (fold_stmt (&fold_gsi, follow_all_ssa_edges))\n+    {\n+      incr_stmt = gsi_stmt (fold_gsi);\n+      update_stmt (incr_stmt);\n+    }\n \n   /* Copy the points-to information if it exists. */\n   if (DR_PTR_INFO (dr))"}, {"sha": "a32f86b8bc70a44d5bc0fc90b1d580dbfcf6ea9b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=0ad9c7087ef3904da89f2db6007b6d28b116087f", "patch": "@@ -6284,14 +6284,15 @@ vect_get_slp_defs (vec_info *,\n    If ANALYZE_ONLY is TRUE, only check that it is possible to create valid\n    permute statements for the SLP node NODE.  Store the number of vector\n    permute instructions in *N_PERMS and the number of vector load\n-   instructions in *N_LOADS.  */\n+   instructions in *N_LOADS.  If DCE_CHAIN is true, remove all definitions\n+   that were not needed.  */\n \n bool\n vect_transform_slp_perm_load (vec_info *vinfo,\n \t\t\t      slp_tree node, vec<tree> dr_chain,\n \t\t\t      gimple_stmt_iterator *gsi, poly_uint64 vf,\n \t\t\t      bool analyze_only, unsigned *n_perms,\n-\t\t\t      unsigned int *n_loads)\n+\t\t\t      unsigned int *n_loads, bool dce_chain)\n {\n   stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n   int vec_index = 0;\n@@ -6370,6 +6371,7 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n     }\n   auto_sbitmap used_in_lanes (in_nlanes);\n   bitmap_clear (used_in_lanes);\n+  auto_bitmap used_defs;\n \n   unsigned int count = mask.encoded_nelts ();\n   mask.quick_grow (count);\n@@ -6477,11 +6479,20 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n \t\t\t\t\t       mask_vec);\n \t\t      vect_finish_stmt_generation (vinfo, stmt_info, perm_stmt,\n \t\t\t\t\t\t   gsi);\n+\t\t      if (dce_chain)\n+\t\t\t{\n+\t\t\t  bitmap_set_bit (used_defs, first_vec_index + ri);\n+\t\t\t  bitmap_set_bit (used_defs, second_vec_index + ri);\n+\t\t\t}\n \t\t    }\n \t\t  else\n-\t\t    /* If mask was NULL_TREE generate the requested\n-\t\t       identity transform.  */\n-\t\t    perm_stmt = SSA_NAME_DEF_STMT (first_vec);\n+\t\t    {\n+\t\t      /* If mask was NULL_TREE generate the requested\n+\t\t\t identity transform.  */\n+\t\t      perm_stmt = SSA_NAME_DEF_STMT (first_vec);\n+\t\t      if (dce_chain)\n+\t\t\tbitmap_set_bit (used_defs, first_vec_index + ri);\n+\t\t    }\n \n \t\t  /* Store the vector statement in NODE.  */\n \t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++] = perm_stmt;\n@@ -6521,6 +6532,16 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n \t}\n     }\n \n+  if (dce_chain)\n+    for (unsigned i = 0; i < dr_chain.length (); ++i)\n+      if (!bitmap_bit_p (used_defs, i))\n+\t{\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (dr_chain[i]);\n+\t  gimple_stmt_iterator rgsi = gsi_for_stmt (stmt);\n+\t  gsi_remove (&rgsi, true);\n+\t  release_defs (stmt);\n+\t}\n+\n   return true;\n }\n "}, {"sha": "4ee11b2041a78e67ebcf0199fca6ea72ff815422", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0ad9c7087ef3904da89f2db6007b6d28b116087f", "patch": "@@ -9762,8 +9762,13 @@ vectorizable_load (vec_info *vinfo,\n       if (slp_perm)\n         {\n \t  unsigned n_perms;\n+\t  /* For SLP we know we've seen all possible uses of dr_chain so\n+\t     direct vect_transform_slp_perm_load to DCE the unused parts.\n+\t     ???  This is a hack to prevent compile-time issues as seen\n+\t     in PR101120 and friends.  */\n \t  bool ok = vect_transform_slp_perm_load (vinfo, slp_node, dr_chain,\n-\t\t\t\t\t\t  gsi, vf, false, &n_perms);\n+\t\t\t\t\t\t  gsi, vf, false, &n_perms,\n+\t\t\t\t\t\t  nullptr, true);\n \t  gcc_assert (ok);\n         }\n       else"}, {"sha": "5c71fbc487f76b7474e1cffc6089519e1336d7b0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ad9c7087ef3904da89f2db6007b6d28b116087f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0ad9c7087ef3904da89f2db6007b6d28b116087f", "patch": "@@ -2012,7 +2012,7 @@ extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (vec_info *, slp_tree, vec<tree>,\n \t\t\t\t\t  gimple_stmt_iterator *, poly_uint64,\n \t\t\t\t\t  bool, unsigned *,\n-\t\t\t\t\t  unsigned * = nullptr);\n+\t\t\t\t\t  unsigned * = nullptr, bool = false);\n extern bool vect_slp_analyze_operations (vec_info *);\n extern void vect_schedule_slp (vec_info *, vec<slp_instance>);\n extern opt_result vect_analyze_slp (vec_info *, unsigned);"}]}