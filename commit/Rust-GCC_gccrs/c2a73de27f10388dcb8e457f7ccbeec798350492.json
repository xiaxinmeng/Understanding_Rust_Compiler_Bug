{"sha": "c2a73de27f10388dcb8e457f7ccbeec798350492", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJhNzNkZTI3ZjEwMzg4ZGNiOGU0NTdmN2NjYmVlYzc5ODM1MDQ5Mg==", "commit": {"author": {"name": "Meador Inge", "email": "meadori@codesourcery.com", "date": "2012-11-27T16:55:47Z"}, "committer": {"name": "Meador Inge", "email": "meadori@gcc.gnu.org", "date": "2012-11-27T16:55:47Z"}, "message": "collect2.c (main): Call find_file_set_debug.\n\n2012-11-27  Meador Inge  <meadori@codesourcery.com>\n\n\t* collect2.c (main): Call find_file_set_debug.\n\t(find_a_find, add_prefix, prefix_from_env, prefix_from_string):\n\tFactor out into ...\n\t* file-find.c (New file): ... here and ...\n\t* file-find.h (New file): ... here.\n\t* gcc-ar.c (standard_exec_prefix): New variable.\n\t(standard_libexec_prefix): Ditto.\n\t(tooldir_base_prefix) Ditto.\n\t(self_exec_prefix): Ditto.\n\t(self_libexec_prefix): Ditto.\n\t(self_tooldir_prefix): Ditto.\n\t(target_version): Ditto.\n\t(path): Ditto.\n\t(target_path): Ditto.\n\t(setup_prefixes): New function.\n\t(main): Rework how wrapped programs are found.\n\t* Makefile.in (OBJS-libcommon-target): Add file-find.o.\n\t(AR_OBJS): New variable.\n\t(gcc-ar$(exeext)): Add dependency on $(AR_OBJS).\n\t(gcc-nm$(exeext)): Ditto.\n\t(gcc-ranlib(exeext)): Ditto.\n\t(COLLECT2_OBJS): Add file-find.o.\n\t(collect2.o): Add file-find.h prerequisite.\n\t(file-find.o): New rule.\n\nFrom-SVN: r193859", "tree": {"sha": "b327f0c1eba3f0941ca3e99f9c8e852a2b117082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b327f0c1eba3f0941ca3e99f9c8e852a2b117082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2a73de27f10388dcb8e457f7ccbeec798350492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a73de27f10388dcb8e457f7ccbeec798350492", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a73de27f10388dcb8e457f7ccbeec798350492", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a73de27f10388dcb8e457f7ccbeec798350492/comments", "author": {"login": "meadori", "id": 296965, "node_id": "MDQ6VXNlcjI5Njk2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/296965?v=4", "gravatar_id": "", "url": "https://api.github.com/users/meadori", "html_url": "https://github.com/meadori", "followers_url": "https://api.github.com/users/meadori/followers", "following_url": "https://api.github.com/users/meadori/following{/other_user}", "gists_url": "https://api.github.com/users/meadori/gists{/gist_id}", "starred_url": "https://api.github.com/users/meadori/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/meadori/subscriptions", "organizations_url": "https://api.github.com/users/meadori/orgs", "repos_url": "https://api.github.com/users/meadori/repos", "events_url": "https://api.github.com/users/meadori/events{/privacy}", "received_events_url": "https://api.github.com/users/meadori/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a50da342e585096bfdfc07ce8d8d49e9a6f227e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a50da342e585096bfdfc07ce8d8d49e9a6f227e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a50da342e585096bfdfc07ce8d8d49e9a6f227e"}], "stats": {"total": 619, "additions": 398, "deletions": 221}, "files": [{"sha": "e41e34d323029d3eb72439276d5be65ad640eb46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2a73de27f10388dcb8e457f7ccbeec798350492", "patch": "@@ -1,3 +1,30 @@\n+2012-11-27  Meador Inge  <meadori@codesourcery.com>\n+\n+\t* collect2.c (main): Call find_file_set_debug.\n+\t(find_a_find, add_prefix, prefix_from_env, prefix_from_string):\n+\tFactor out into ...\n+\t* file-find.c (New file): ... here and ...\n+\t* file-find.h (New file): ... here.\n+\t* gcc-ar.c (standard_exec_prefix): New variable.\n+\t(standard_libexec_prefix): Ditto.\n+\t(tooldir_base_prefix) Ditto.\n+\t(self_exec_prefix): Ditto.\n+\t(self_libexec_prefix): Ditto.\n+\t(self_tooldir_prefix): Ditto.\n+\t(target_version): Ditto.\n+\t(path): Ditto.\n+\t(target_path): Ditto.\n+\t(setup_prefixes): New function.\n+\t(main): Rework how wrapped programs are found.\n+\t* Makefile.in (OBJS-libcommon-target): Add file-find.o.\n+\t(AR_OBJS): New variable.\n+\t(gcc-ar$(exeext)): Add dependency on $(AR_OBJS).\n+\t(gcc-nm$(exeext)): Ditto.\n+\t(gcc-ranlib(exeext)): Ditto.\n+\t(COLLECT2_OBJS): Add file-find.o.\n+\t(collect2.o): Add file-find.h prerequisite.\n+\t(file-find.o): New rule.\n+\n 2010-11-27  Dehao Chen  <dehao@google.com>\n \n \t* ipa-prop.c (ipa_modify_call_arguments): Set loc correctly."}, {"sha": "8f8316fb6e7bd878352ea386716a26ee7992a77c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c2a73de27f10388dcb8e457f7ccbeec798350492", "patch": "@@ -1471,7 +1471,7 @@ OBJS-libcommon = diagnostic.o pretty-print.o intl.o input.o version.o\n # compiler and containing target-dependent code.\n OBJS-libcommon-target = $(common_out_object_file) prefix.o params.o \\\n \topts.o opts-common.o options.o vec.o hooks.o common/common-targhooks.o \\\n-\thash-table.o\n+\thash-table.o file-find.o\n \n # This lists all host objects for the front ends.\n ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))\n@@ -1852,19 +1852,20 @@ graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) $\n sbitmap.o: sbitmap.c sbitmap.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)\n \n+AR_OBJS = file-find.o\n AR_LIBS = @COLLECT2_LIBS@\n \n-gcc-ar$(exeext): gcc-ar.o $(LIBDEPS)\n+gcc-ar$(exeext): gcc-ar.o $(AR_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) gcc-ar.o -o $@ \\\n-\t\t$(LIBS) $(AR_LIBS)\n+\t\t$(AR_OBJS) $(LIBS) $(AR_LIBS)\n \n-gcc-nm$(exeext): gcc-nm.o $(LIBDEPS)\n+gcc-nm$(exeext): gcc-nm.o $(AR_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) gcc-nm.o -o $@ \\\n-\t\t$(LIBS) $(AR_LIBS)\n+\t\t$(AR_OBJS) $(LIBS) $(AR_LIBS)\n \n-gcc-ranlib$(exeext): gcc-ranlib.o $(LIBDEPS)\n+gcc-ranlib$(exeext): gcc-ranlib.o $(AR_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) gcc-ranlib.o -o $@ \\\n-\t\t$(LIBS) $(AR_LIBS)\n+\t\t$(AR_OBJS) $(LIBS) $(AR_LIBS)\n \n CFLAGS-gcc-ar.o += $(DRIVER_DEFINES) \\\n \t-DTARGET_MACHINE=\\\"$(target_noncanonical)\\\" \\\n@@ -1892,7 +1893,7 @@ gcc-ranlib.c: gcc-ar.c\n gcc-nm.c: gcc-ar.c\n \tcp $^ $@\n \n-COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o\n+COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o file-find.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n@@ -1904,7 +1905,7 @@ CFLAGS-collect2.o += -DTARGET_MACHINE=\\\"$(target_noncanonical)\\\" \\\n \t@TARGET_SYSTEM_ROOT_DEFINE@\n collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h \\\n \t$(OBSTACK_H) $(DEMANGLE_H) collect2.h collect2-aix.h version.h \\\n-\t$(DIAGNOSTIC_H)\n+\t$(DIAGNOSTIC_H) file-find.h\n \n collect2-aix.o : collect2-aix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     collect2-aix.h\n@@ -3425,6 +3426,7 @@ hw-doloop.o : hw-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H)\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n    $(DF_H) $(CFGLOOP_H) $(RECOG_H) $(TARGET_H) \\\n    $(REGS_H) hw-doloop.h\n+file-find.o: file-find.c $(CONFIG_H) $(SYSTEM_H) file-find.h\n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\\n    output.h $(INSN_ATTR_H) $(SYSTEM_H) toplev.h $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "49c40301d6ca605cd290bb47d1ac029303ea70ef", "filename": "gcc/collect2.c", "status": "modified", "additions": 2, "deletions": 182, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=c2a73de27f10388dcb8e457f7ccbeec798350492", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"filenames.h\"\n+#include \"file-find.h\"\n \n /* TARGET_64BIT may be defined to use driver specific functionality. */\n #undef TARGET_64BIT\n@@ -243,22 +244,6 @@ static const char *target_system_root = \"\";\n    would leave untouched.  */\n bool may_unlink_output_file = false;\n \n-/* Structure to hold all the directories in which to search for files to\n-   execute.  */\n-\n-struct prefix_list\n-{\n-  const char *prefix;         /* String to prepend to the path.  */\n-  struct prefix_list *next;   /* Next in linked list.  */\n-};\n-\n-struct path_prefix\n-{\n-  struct prefix_list *plist;  /* List of prefixes to try */\n-  int max_len;                /* Max length of a prefix in PLIST */\n-  const char *name;           /* Name of this list (used in config stuff) */\n-};\n-\n #ifdef COLLECT_EXPORT_LIST\n /* Lists to keep libraries to be scanned for global constructors/destructors.  */\n static struct head libs;                    /* list of libraries */\n@@ -302,10 +287,6 @@ typedef enum {\n static symkind is_ctor_dtor (const char *);\n \n static void handler (int);\n-static char *find_a_file (struct path_prefix *, const char *);\n-static void add_prefix (struct path_prefix *, const char *);\n-static void prefix_from_env (const char *, struct path_prefix *);\n-static void prefix_from_string (const char *, struct path_prefix *);\n static void do_wait (const char *, struct pex_obj *);\n static void fork_execute (const char *, char **);\n static void maybe_unlink (const char *);\n@@ -653,168 +634,6 @@ static const char *const target_machine = TARGET_MACHINE;\n \n    Return 0 if not found, otherwise return its name, allocated with malloc.  */\n \n-static char *\n-find_a_file (struct path_prefix *pprefix, const char *name)\n-{\n-  char *temp;\n-  struct prefix_list *pl;\n-  int len = pprefix->max_len + strlen (name) + 1;\n-\n-  if (debug)\n-    fprintf (stderr, \"Looking for '%s'\\n\", name);\n-\n-#ifdef HOST_EXECUTABLE_SUFFIX\n-  len += strlen (HOST_EXECUTABLE_SUFFIX);\n-#endif\n-\n-  temp = XNEWVEC (char, len);\n-\n-  /* Determine the filename to execute (special case for absolute paths).  */\n-\n-  if (IS_ABSOLUTE_PATH (name))\n-    {\n-      if (access (name, X_OK) == 0)\n-\t{\n-\t  strcpy (temp, name);\n-\n-\t  if (debug)\n-\t    fprintf (stderr, \"  - found: absolute path\\n\");\n-\n-\t  return temp;\n-\t}\n-\n-#ifdef HOST_EXECUTABLE_SUFFIX\n-\t/* Some systems have a suffix for executable files.\n-\t   So try appending that.  */\n-      strcpy (temp, name);\n-\tstrcat (temp, HOST_EXECUTABLE_SUFFIX);\n-\n-\tif (access (temp, X_OK) == 0)\n-\t  return temp;\n-#endif\n-\n-      if (debug)\n-\tfprintf (stderr, \"  - failed to locate using absolute path\\n\");\n-    }\n-  else\n-    for (pl = pprefix->plist; pl; pl = pl->next)\n-      {\n-\tstruct stat st;\n-\n-\tstrcpy (temp, pl->prefix);\n-\tstrcat (temp, name);\n-\n-\tif (stat (temp, &st) >= 0\n-\t    && ! S_ISDIR (st.st_mode)\n-\t    && access (temp, X_OK) == 0)\n-\t  return temp;\n-\n-#ifdef HOST_EXECUTABLE_SUFFIX\n-\t/* Some systems have a suffix for executable files.\n-\t   So try appending that.  */\n-\tstrcat (temp, HOST_EXECUTABLE_SUFFIX);\n-\n-\tif (stat (temp, &st) >= 0\n-\t    && ! S_ISDIR (st.st_mode)\n-\t    && access (temp, X_OK) == 0)\n-\t  return temp;\n-#endif\n-      }\n-\n-  if (debug && pprefix->plist == NULL)\n-    fprintf (stderr, \"  - failed: no entries in prefix list\\n\");\n-\n-  free (temp);\n-  return 0;\n-}\n-\n-/* Add an entry for PREFIX to prefix list PPREFIX.  */\n-\n-static void\n-add_prefix (struct path_prefix *pprefix, const char *prefix)\n-{\n-  struct prefix_list *pl, **prev;\n-  int len;\n-\n-  if (pprefix->plist)\n-    {\n-      for (pl = pprefix->plist; pl->next; pl = pl->next)\n-\t;\n-      prev = &pl->next;\n-    }\n-  else\n-    prev = &pprefix->plist;\n-\n-  /* Keep track of the longest prefix.  */\n-\n-  len = strlen (prefix);\n-  if (len > pprefix->max_len)\n-    pprefix->max_len = len;\n-\n-  pl = XNEW (struct prefix_list);\n-  pl->prefix = xstrdup (prefix);\n-\n-  if (*prev)\n-    pl->next = *prev;\n-  else\n-    pl->next = (struct prefix_list *) 0;\n-  *prev = pl;\n-}\n-\f\n-/* Take the value of the environment variable ENV, break it into a path, and\n-   add of the entries to PPREFIX.  */\n-\n-static void\n-prefix_from_env (const char *env, struct path_prefix *pprefix)\n-{\n-  const char *p;\n-  p = getenv (env);\n-\n-  if (p)\n-    prefix_from_string (p, pprefix);\n-}\n-\n-static void\n-prefix_from_string (const char *p, struct path_prefix *pprefix)\n-{\n-  const char *startp, *endp;\n-  char *nstore = XNEWVEC (char, strlen (p) + 3);\n-\n-  if (debug)\n-    fprintf (stderr, \"Convert string '%s' into prefixes, separator = '%c'\\n\", p, PATH_SEPARATOR);\n-\n-  startp = endp = p;\n-  while (1)\n-    {\n-      if (*endp == PATH_SEPARATOR || *endp == 0)\n-\t{\n-\t  strncpy (nstore, startp, endp-startp);\n-\t  if (endp == startp)\n-\t    {\n-\t      strcpy (nstore, \"./\");\n-\t    }\n-\t  else if (! IS_DIR_SEPARATOR (endp[-1]))\n-\t    {\n-\t      nstore[endp-startp] = DIR_SEPARATOR;\n-\t      nstore[endp-startp+1] = 0;\n-\t    }\n-\t  else\n-\t    nstore[endp-startp] = 0;\n-\n-\t  if (debug)\n-\t    fprintf (stderr, \"  - add prefix: %s\\n\", nstore);\n-\n-\t  add_prefix (pprefix, nstore);\n-\t  if (*endp == 0)\n-\t    break;\n-\t  endp = startp = endp + 1;\n-\t}\n-      else\n-\tendp++;\n-    }\n-  free (nstore);\n-}\n-\n #ifdef OBJECT_FORMAT_NONE\n \n /* Add an entry for the object file NAME to object file list LIST.\n@@ -1198,6 +1017,7 @@ main (int argc, char **argv)\n #endif\n       }\n     vflag = debug;\n+    find_file_set_debug (debug);\n     if (no_partition && lto_mode == LTO_MODE_WHOPR)\n       lto_mode = LTO_MODE_LTO;\n   }"}, {"sha": "fcc25612008243a733bf9a702601025da56298a1", "filename": "gcc/file-find.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Ffile-find.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Ffile-find.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffile-find.c?ref=c2a73de27f10388dcb8e457f7ccbeec798350492", "patch": "@@ -0,0 +1,194 @@\n+/* Utility functions for finding files relative to GCC binaries.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"filenames.h\"\n+#include \"file-find.h\"\n+\n+static bool debug = false;\n+\n+void\n+find_file_set_debug(bool debug_state)\n+{\n+  debug = debug_state;\n+}\n+\n+char *\n+find_a_file (struct path_prefix *pprefix, const char *name)\n+{\n+  char *temp;\n+  struct prefix_list *pl;\n+  int len = pprefix->max_len + strlen (name) + 1;\n+\n+  if (debug)\n+    fprintf (stderr, \"Looking for '%s'\\n\", name);\n+\n+#ifdef HOST_EXECUTABLE_SUFFIX\n+  len += strlen (HOST_EXECUTABLE_SUFFIX);\n+#endif\n+\n+  temp = XNEWVEC (char, len);\n+\n+  /* Determine the filename to execute (special case for absolute paths).  */\n+\n+  if (IS_ABSOLUTE_PATH (name))\n+    {\n+      if (access (name, X_OK) == 0)\n+\t{\n+\t  strcpy (temp, name);\n+\n+\t  if (debug)\n+\t    fprintf (stderr, \"  - found: absolute path\\n\");\n+\n+\t  return temp;\n+\t}\n+\n+#ifdef HOST_EXECUTABLE_SUFFIX\n+\t/* Some systems have a suffix for executable files.\n+\t   So try appending that.  */\n+      strcpy (temp, name);\n+\tstrcat (temp, HOST_EXECUTABLE_SUFFIX);\n+\n+\tif (access (temp, X_OK) == 0)\n+\t  return temp;\n+#endif\n+\n+      if (debug)\n+\tfprintf (stderr, \"  - failed to locate using absolute path\\n\");\n+    }\n+  else\n+    for (pl = pprefix->plist; pl; pl = pl->next)\n+      {\n+\tstruct stat st;\n+\n+\tstrcpy (temp, pl->prefix);\n+\tstrcat (temp, name);\n+\n+\tif (stat (temp, &st) >= 0\n+\t    && ! S_ISDIR (st.st_mode)\n+\t    && access (temp, X_OK) == 0)\n+\t  return temp;\n+\n+#ifdef HOST_EXECUTABLE_SUFFIX\n+\t/* Some systems have a suffix for executable files.\n+\t   So try appending that.  */\n+\tstrcat (temp, HOST_EXECUTABLE_SUFFIX);\n+\n+\tif (stat (temp, &st) >= 0\n+\t    && ! S_ISDIR (st.st_mode)\n+\t    && access (temp, X_OK) == 0)\n+\t  return temp;\n+#endif\n+      }\n+\n+  if (debug && pprefix->plist == NULL)\n+    fprintf (stderr, \"  - failed: no entries in prefix list\\n\");\n+\n+  free (temp);\n+  return 0;\n+}\n+\n+/* Add an entry for PREFIX to prefix list PPREFIX.  */\n+\n+void\n+add_prefix (struct path_prefix *pprefix, const char *prefix)\n+{\n+  struct prefix_list *pl, **prev;\n+  int len;\n+\n+  if (pprefix->plist)\n+    {\n+      for (pl = pprefix->plist; pl->next; pl = pl->next)\n+\t;\n+      prev = &pl->next;\n+    }\n+  else\n+    prev = &pprefix->plist;\n+\n+  /* Keep track of the longest prefix.  */\n+\n+  len = strlen (prefix);\n+  if (len > pprefix->max_len)\n+    pprefix->max_len = len;\n+\n+  pl = XNEW (struct prefix_list);\n+  pl->prefix = xstrdup (prefix);\n+\n+  if (*prev)\n+    pl->next = *prev;\n+  else\n+    pl->next = (struct prefix_list *) 0;\n+  *prev = pl;\n+}\n+\n+/* Take the value of the environment variable ENV, break it into a path, and\n+   add of the entries to PPREFIX.  */\n+\n+void\n+prefix_from_env (const char *env, struct path_prefix *pprefix)\n+{\n+  const char *p;\n+  p = getenv (env);\n+\n+  if (p)\n+    prefix_from_string (p, pprefix);\n+}\n+\n+void\n+prefix_from_string (const char *p, struct path_prefix *pprefix)\n+{\n+  const char *startp, *endp;\n+  char *nstore = XNEWVEC (char, strlen (p) + 3);\n+\n+  if (debug)\n+    fprintf (stderr, \"Convert string '%s' into prefixes, separator = '%c'\\n\", p, PATH_SEPARATOR);\n+\n+  startp = endp = p;\n+  while (1)\n+    {\n+      if (*endp == PATH_SEPARATOR || *endp == 0)\n+\t{\n+\t  strncpy (nstore, startp, endp-startp);\n+\t  if (endp == startp)\n+\t    {\n+\t      strcpy (nstore, \"./\");\n+\t    }\n+\t  else if (! IS_DIR_SEPARATOR (endp[-1]))\n+\t    {\n+\t      nstore[endp-startp] = DIR_SEPARATOR;\n+\t      nstore[endp-startp+1] = 0;\n+\t    }\n+\t  else\n+\t    nstore[endp-startp] = 0;\n+\n+\t  if (debug)\n+\t    fprintf (stderr, \"  - add prefix: %s\\n\", nstore);\n+\n+\t  add_prefix (pprefix, nstore);\n+\t  if (*endp == 0)\n+\t    break;\n+\t  endp = startp = endp + 1;\n+\t}\n+      else\n+\tendp++;\n+    }\n+  free (nstore);\n+}"}, {"sha": "4c0182a5eda13d2a3d09a7120bca626ab5a1c332", "filename": "gcc/file-find.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Ffile-find.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Ffile-find.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffile-find.h?ref=c2a73de27f10388dcb8e457f7ccbeec798350492", "patch": "@@ -0,0 +1,47 @@\n+/* Prototypes and data structures used for implementing functions for\n+   finding files relative to GCC binaries.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_FILE_FIND_H\n+#define GCC_FILE_FIND_H\n+\n+/* Structure to hold all the directories in which to search for files to\n+   execute.  */\n+\n+struct prefix_list\n+{\n+  const char *prefix;         /* String to prepend to the path.  */\n+  struct prefix_list *next;   /* Next in linked list.  */\n+};\n+\n+struct path_prefix\n+{\n+  struct prefix_list *plist;  /* List of prefixes to try */\n+  int max_len;                /* Max length of a prefix in PLIST */\n+  const char *name;           /* Name of this list (used in config stuff) */\n+};\n+\n+extern void find_file_set_debug (bool);\n+extern char *find_a_file (struct path_prefix *, const char *);\n+extern void add_prefix (struct path_prefix *, const char *);\n+extern void prefix_from_env (const char *, struct path_prefix *);\n+extern void prefix_from_string (const char *, struct path_prefix *);\n+\n+#endif /* GCC_FILE_FIND_H */"}, {"sha": "c614566bb7ce340448321e11ec63a6866e3d5c3b", "filename": "gcc/gcc-ar.c", "status": "modified", "additions": 117, "deletions": 30, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Fgcc-ar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a73de27f10388dcb8e457f7ccbeec798350492/gcc%2Fgcc-ar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-ar.c?ref=c2a73de27f10388dcb8e457f7ccbeec798350492", "patch": "@@ -21,21 +21,110 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"libiberty.h\"\n+#include \"file-find.h\"\n \n #ifndef PERSONALITY\n #error \"Please set personality\"\n #endif\n \n+/* The exec prefix as derived at compile-time from --prefix.  */\n+\n+static const char standard_exec_prefix[] = STANDARD_EXEC_PREFIX;\n+\n+/* The libexec prefix as derived at compile-time from --prefix.  */\n+\n static const char standard_libexec_prefix[] = STANDARD_LIBEXEC_PREFIX;\n+\n+/* The bindir prefix as derived at compile-time from --prefix.  */\n+\n static const char standard_bin_prefix[] = STANDARD_BINDIR_PREFIX;\n-static const char *const target_machine = TARGET_MACHINE;\n+\n+/* A relative path to be used in finding the location of tools\n+   relative to this program.  */\n+\n+static const char *const tooldir_base_prefix = TOOLDIR_BASE_PREFIX;\n+\n+/* The exec prefix as relocated from the location of this program.  */\n+\n+static const char *self_exec_prefix;\n+\n+/* The libexec prefix as relocated from the location of this program.  */\n+\n+static const char *self_libexec_prefix;\n+\n+/* The tools prefix as relocated from the location of this program.  */\n+\n+static const char *self_tooldir_prefix;\n+\n+/* The name of the machine that is being targeted.  */\n+\n+static const char *const target_machine = DEFAULT_TARGET_MACHINE;\n+\n+/* The target version.  */\n+\n+static const char *const target_version = DEFAULT_TARGET_VERSION;\n+\n+/* The collection of target specific path prefixes.  */\n+\n+static struct path_prefix target_path;\n+\n+/* The collection path prefixes.  */\n+\n+static struct path_prefix path;\n+\n+/* The directory separator.  */\n \n static const char dir_separator[] = { DIR_SEPARATOR, 0 };\n \n+static void\n+setup_prefixes (const char *exec_path)\n+{\n+  const char *self;\n+\n+  self = getenv (\"GCC_EXEC_PREFIX\");\n+  if (!self)\n+    self = exec_path;\n+  else\n+    self = concat (self, \"gcc-\" PERSONALITY, NULL);\n+\n+  /* Relocate the exec prefix.  */\n+  self_exec_prefix = make_relative_prefix (self,\n+\t\t\t\t\t   standard_bin_prefix,\n+\t\t\t\t\t   standard_exec_prefix);\n+  if (self_exec_prefix == NULL)\n+    self_exec_prefix = standard_exec_prefix;\n+\n+  /* Relocate libexec prefix.  */\n+  self_libexec_prefix = make_relative_prefix (self,\n+\t\t\t\t\t      standard_bin_prefix,\n+\t\t\t\t\t      standard_libexec_prefix);\n+  if (self_libexec_prefix == NULL)\n+    self_libexec_prefix = standard_libexec_prefix;\n+\n+\n+  /* Build the relative path to the target-specific tool directory.  */\n+  self_tooldir_prefix = concat (tooldir_base_prefix, target_machine,\n+\t\t\t\tdir_separator, NULL);\n+  self_tooldir_prefix = concat (self_exec_prefix, target_machine, \n+\t\t\t\tdir_separator, target_version, dir_separator,\n+\t\t\t\tself_tooldir_prefix, NULL);\n+\n+  /* Add the target-specific tool bin prefix.  */\n+  prefix_from_string (concat (self_tooldir_prefix, \"bin\", NULL), &target_path);\n+\n+  /* Add the target-specific libexec prefix.  */\n+  self_libexec_prefix = concat (self_libexec_prefix, target_machine, \n+\t\t\t\tdir_separator, target_version,\n+\t\t\t\tdir_separator, NULL);\n+  prefix_from_string (self_libexec_prefix, &target_path);\n+\n+  /* Add path as a last resort.  */\n+  prefix_from_env (\"PATH\", &path);\n+}\n+\n int \n main(int ac, char **av)\n {\n-  const char *nprefix;\n   const char *exe_name;\n   char *plugin;\n   int k, status, err;\n@@ -44,39 +133,37 @@ main(int ac, char **av)\n   bool is_ar = !strcmp (PERSONALITY, \"ar\");\n   int exit_code = FATAL_EXIT_CODE;\n \n-  exe_name = PERSONALITY;\n-#ifdef CROSS_DIRECTORY_STRUCTURE\n-  exe_name = concat (target_machine, \"-\", exe_name, NULL);\n-#endif\n+  setup_prefixes (av[0]);\n \n-  /* Find plugin */\n-  /* XXX implement more magic from gcc.c? */\n-  nprefix = getenv (\"GCC_EXEC_PREFIX\");\n-  if (!nprefix)\n-    nprefix = av[0];\n-  else\n-    nprefix = concat (nprefix, \"gcc-\" PERSONALITY, NULL);\n-\n-  nprefix = make_relative_prefix (nprefix,\n-\t\t\t\t  standard_bin_prefix,\n-\t\t\t\t  standard_libexec_prefix);\n-  if (nprefix == NULL)\n-    nprefix = standard_libexec_prefix;\n-\n-  plugin = concat (nprefix,\n-\t\t   dir_separator,\n-                   DEFAULT_TARGET_MACHINE, \n-\t\t   dir_separator,\n-\t\t   DEFAULT_TARGET_VERSION,\n-\t           dir_separator,\n-\t\t   LTOPLUGINSONAME,\n-\t\t   NULL);\n-  if (access (plugin, R_OK))\n+  /* Find the GCC LTO plugin */\n+  plugin = find_a_file (&target_path, LTOPLUGINSONAME);\n+  if (!plugin)\n     {\n-      fprintf (stderr, \"%s: Cannot find plugin %s\\n\", av[0], plugin);\n+      fprintf (stderr, \"%s: Cannot find plugin '%s'\\n\", av[0], LTOPLUGINSONAME);\n       exit (1);\n     }\n \n+  /* Find the wrapped binutils program.  */\n+  exe_name = find_a_file (&target_path, PERSONALITY);\n+  if (!exe_name)\n+    {\n+#ifdef CROSS_DIRECTORY_STRUCTURE\n+      const char *cross_exe_name;\n+\n+      cross_exe_name = concat (target_machine, \"-\", PERSONALITY, NULL);\n+      exe_name = find_a_file (&path, cross_exe_name);\n+      if (!exe_name)\n+\t{\n+\t  fprintf (stderr, \"%s: Cannot find binary '%s'\\n\", av[0],\n+\t\t   cross_exe_name);\n+\t  exit (1);\n+\t}\n+#else\n+      fprintf (stderr, \"%s: Cannot find binary '%s'\\n\", av[0], PERSONALITY);\n+      exit (1);\n+#endif\n+    }\n+\n   /* Create new command line with plugin */\n   nargv = XCNEWVEC (const char *, ac + 4);\n   nargv[0] = exe_name;"}]}