{"sha": "0e07cb7f7d43282f601820a149eec66ea99a541f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwN2NiN2Y3ZDQzMjgyZjYwMTgyMGExNDllZWM2NmVhOTlhNTQxZg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-31T15:06:25Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-31T15:06:25Z"}, "message": "Fix wrong-code issues of RX atomic operations.\n\ngcc/\n\t* config/rx/rx.md (FETCHOP_NO_MINUS): New code iterator.\n\t(atomic_<fetchop_name>_fetchsi): Extract minus operator into ...\n\t(atomic_sub_fetchsi): ... this new pattern.\n\t(mvtc): Add CC_REG clobber.\n\nFrom-SVN: r236926", "tree": {"sha": "317adf2d4cf5b5acdcf536be2fb79f44646379aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/317adf2d4cf5b5acdcf536be2fb79f44646379aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e07cb7f7d43282f601820a149eec66ea99a541f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e07cb7f7d43282f601820a149eec66ea99a541f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e07cb7f7d43282f601820a149eec66ea99a541f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e07cb7f7d43282f601820a149eec66ea99a541f/comments", "author": null, "committer": null, "parents": [{"sha": "d6439e085433332e60145d535e98f599d7889808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6439e085433332e60145d535e98f599d7889808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6439e085433332e60145d535e98f599d7889808"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "bdc3d172c4ed55adb19d9bf452b267ee1b1a6fcb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e07cb7f7d43282f601820a149eec66ea99a541f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e07cb7f7d43282f601820a149eec66ea99a541f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e07cb7f7d43282f601820a149eec66ea99a541f", "patch": "@@ -1,3 +1,10 @@\n+2016-05-31  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/rx/rx.md (FETCHOP_NO_MINUS): New code iterator.\n+\t(atomic_<fetchop_name>_fetchsi): Extract minus operator into ...\n+\t(atomic_sub_fetchsi): ... this new pattern.\n+\t(mvtc): Add CC_REG clobber.\n+\n 2016-05-31  Marek Polacek  <polacek@redhat.com>\n \n \t* gimplify.c (gimplify_switch_expr): Also handle GIMPLE_TRY."}, {"sha": "b63f17708cec5e786493e1f66c75a77c456b70c0", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e07cb7f7d43282f601820a149eec66ea99a541f/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e07cb7f7d43282f601820a149eec66ea99a541f/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=0e07cb7f7d43282f601820a149eec66ea99a541f", "patch": "@@ -2158,6 +2158,7 @@\n ;; Atomic operations.\n \n (define_code_iterator FETCHOP [plus minus ior xor and])\n+(define_code_iterator FETCHOP_NO_MINUS [plus ior xor and])\n \n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"or\") (xor \"xor\") (and \"and\")])\n@@ -2258,12 +2259,14 @@\n })\n \n ;; read - modify - write - return new value\n+;; Because subtraction is not commutative we need to specify a different\n+;; set of patterns for it.\n (define_expand \"atomic_<fetchop_name>_fetchsi\"\n   [(set (match_operand:SI 0 \"register_operand\")\n-\t(FETCHOP:SI (match_operand:SI 1 \"rx_restricted_mem_operand\")\n-\t\t    (match_operand:SI 2 \"register_operand\")))\n+\t(FETCHOP_NO_MINUS:SI (match_operand:SI 1 \"rx_restricted_mem_operand\")\n+\t\t\t     (match_operand:SI 2 \"register_operand\")))\n    (set (match_dup 1)\n-\t(FETCHOP:SI (match_dup 1) (match_dup 2)))\n+\t(FETCHOP_NO_MINUS:SI (match_dup 1) (match_dup 2)))\n    (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n   \"\"\n {\n@@ -2277,6 +2280,25 @@\n   DONE;\n })\n \n+(define_expand \"atomic_sub_fetchsi\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(minus:SI (match_operand:SI 1 \"rx_restricted_mem_operand\")\n+\t\t  (match_operand:SI 2 \"rx_source_operand\")))\n+   (set (match_dup 1)\n+\t(minus:SI (match_dup 1) (match_dup 2)))\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  {\n+    rx_atomic_sequence seq (current_function_decl);\n+\n+    emit_move_insn (operands[0], operands[1]);\n+    emit_insn (gen_subsi3 (operands[0], operands[0], operands[2]));\n+    emit_move_insn (operands[1], operands[0]);\n+  }\n+  DONE;\n+})\n+\n (define_expand \"atomic_nand_fetchsi\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(not:SI (and:SI (match_operand:SI 1 \"rx_restricted_mem_operand\")\n@@ -2674,18 +2696,16 @@\n )\n \n ;; Move to control register\n+;; This insn can be used in atomic sequences to restore the previous PSW\n+;; and re-enable interrupts.  Because of that it always clobbers the CC_REG.\n (define_insn \"mvtc\"\n   [(unspec_volatile:SI [(match_operand:SI 0 \"immediate_operand\" \"i,i\")\n \t       (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")]\n-\t      UNSPEC_BUILTIN_MVTC)]\n+\t      UNSPEC_BUILTIN_MVTC)\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"mvtc\\t%1, %C0\"\n   [(set_attr \"length\" \"3,7\")]\n-  ;; Ignore possible clobbering of the comparison flags in the\n-  ;; PSW register.  This is a cc0 target so any cc0 setting\n-  ;; instruction will always be paired with a cc0 user, without\n-  ;; the possibility of this instruction being placed in between\n-  ;; them.\n )\n \n ;; Move to interrupt priority level"}]}