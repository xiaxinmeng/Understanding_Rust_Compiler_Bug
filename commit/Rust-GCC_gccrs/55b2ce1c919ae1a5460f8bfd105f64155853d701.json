{"sha": "55b2ce1c919ae1a5460f8bfd105f64155853d701", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTViMmNlMWM5MTlhZTFhNTQ2MGY4YmZkMTA1ZjY0MTU1ODUzZDcwMQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2017-09-05T19:41:55Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2017-09-05T19:41:55Z"}, "message": "re PR target/81833 (PowerPC: VSX: Miscompiles ffmpeg's scalarproduct_int16_vsx at -O1)\n\n[gcc]\n\n2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR target/81833\n\t* config/rs6000/altivec.md (altivec_vsum2sws): Convert from a\n\tdefine_insn to a define_expand.\n\t(altivec_vsum2sws_direct): New define_insn.\n\t(altivec_vsumsws): Convert from a define_insn to a define_expand.\n\n[gcc/testsuite]\n\n2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR target/81833\n\t* gcc.target/powerpc/pr81833-1.c: New file.\n\t* gcc.target/powerpc/pr81833-2.c: New file.\n\nFrom-SVN: r251723", "tree": {"sha": "ad2c38fccd0db73de054ee8975fbf8d7f37788a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad2c38fccd0db73de054ee8975fbf8d7f37788a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55b2ce1c919ae1a5460f8bfd105f64155853d701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55b2ce1c919ae1a5460f8bfd105f64155853d701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55b2ce1c919ae1a5460f8bfd105f64155853d701", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55b2ce1c919ae1a5460f8bfd105f64155853d701/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5fc06a3d339c7db391f199c51354f61a033b555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5fc06a3d339c7db391f199c51354f61a033b555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5fc06a3d339c7db391f199c51354f61a033b555"}], "stats": {"total": 210, "additions": 176, "deletions": 34}, "files": [{"sha": "158b5248433806f5b8328a4b94db8ca4973acdec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55b2ce1c919ae1a5460f8bfd105f64155853d701", "patch": "@@ -1,3 +1,11 @@\n+2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR target/81833\n+\t* config/rs6000/altivec.md (altivec_vsum2sws): Convert from a\n+\tdefine_insn to a define_expand.\n+\t(altivec_vsum2sws_direct): New define_insn.\n+\t(altivec_vsumsws): Convert from a define_insn to a define_expand.\n+\n 2017-09-05  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/arm/arm.c (arm_option_params_internal): Improve setting of"}, {"sha": "0aa1e3016905f1b3d9d791dbed2e787d9935be3f", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=55b2ce1c919ae1a5460f8bfd105f64155853d701", "patch": "@@ -1804,51 +1804,61 @@\n   \"vsum4s<VI_char>s %0,%1,%2\"\n   [(set_attr \"type\" \"veccomplex\")])\n \n-;; FIXME: For the following two patterns, the scratch should only be\n-;; allocated for !VECTOR_ELT_ORDER_BIG, and the instructions should\n-;; be emitted separately.\n-(define_insn \"altivec_vsum2sws\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 2 \"register_operand\" \"v\")]\n-\t\t     UNSPEC_VSUM2SWS))\n-   (set (reg:SI VSCR_REGNO) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))\n-   (clobber (match_scratch:V4SI 3 \"=v\"))]\n+(define_expand \"altivec_vsum2sws\"\n+  [(use (match_operand:V4SI 0 \"register_operand\"))\n+   (use (match_operand:V4SI 1 \"register_operand\"))\n+   (use (match_operand:V4SI 2 \"register_operand\"))]\n   \"TARGET_ALTIVEC\"\n {\n   if (VECTOR_ELT_ORDER_BIG)\n-    return \"vsum2sws %0,%1,%2\";\n+    emit_insn (gen_altivec_vsum2sws_direct (operands[0], operands[1],\n+                                            operands[2]));\n   else\n-    return \"vsldoi %3,%2,%2,12\\n\\tvsum2sws %3,%1,%3\\n\\tvsldoi %0,%3,%3,4\";\n-}\n-  [(set_attr \"type\" \"veccomplex\")\n-   (set (attr \"length\")\n-     (if_then_else\n-       (match_test \"VECTOR_ELT_ORDER_BIG\")\n-       (const_string \"4\")\n-       (const_string \"12\")))])\n-\n-(define_insn \"altivec_vsumsws\"\n+    {\n+      rtx tmp1 = gen_reg_rtx (V4SImode);\n+      rtx tmp2 = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_altivec_vsldoi_v4si (tmp1, operands[2],\n+                                          operands[2], GEN_INT (12)));\n+      emit_insn (gen_altivec_vsum2sws_direct (tmp2, operands[1], tmp1));\n+      emit_insn (gen_altivec_vsldoi_v4si (operands[0], tmp2, tmp2,\n+                                          GEN_INT (4)));\n+    }\n+  DONE;\n+})\n+\n+; FIXME: This can probably be expressed without an UNSPEC.\n+(define_insn \"altivec_vsum2sws_direct\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n-                      (match_operand:V4SI 2 \"register_operand\" \"v\")]\n-\t\t     UNSPEC_VSUMSWS))\n-   (set (reg:SI VSCR_REGNO) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))\n-   (clobber (match_scratch:V4SI 3 \"=v\"))]\n+\t              (match_operand:V4SI 2 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VSUM2SWS))\n+   (set (reg:SI VSCR_REGNO) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))]\n+  \"TARGET_ALTIVEC\"\n+  \"vsum2sws %0,%1,%2\"\n+  [(set_attr \"type\" \"veccomplex\")])\n+\n+(define_expand \"altivec_vsumsws\"\n+  [(use (match_operand:V4SI 0 \"register_operand\"))\n+   (use (match_operand:V4SI 1 \"register_operand\"))\n+   (use (match_operand:V4SI 2 \"register_operand\"))]\n   \"TARGET_ALTIVEC\"\n {\n   if (VECTOR_ELT_ORDER_BIG)\n-    return \"vsumsws %0,%1,%2\";\n+    emit_insn (gen_altivec_vsumsws_direct (operands[0], operands[1],\n+                                           operands[2]));\n   else\n-    return \"vspltw %3,%2,0\\n\\tvsumsws %3,%1,%3\\n\\tvsldoi %0,%3,%3,12\";\n-}\n-  [(set_attr \"type\" \"veccomplex\")\n-   (set (attr \"length\")\n-     (if_then_else\n-       (match_test \"(VECTOR_ELT_ORDER_BIG)\")\n-       (const_string \"4\")\n-       (const_string \"12\")))])\n+    {\n+      rtx tmp1 = gen_reg_rtx (V4SImode);\n+      rtx tmp2 = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_altivec_vspltw_direct (tmp1, operands[2], const0_rtx));\n+      emit_insn (gen_altivec_vsumsws_direct (tmp2, operands[1], tmp1));\n+      emit_insn (gen_altivec_vsldoi_v4si (operands[0], tmp2, tmp2,\n+                                          GEN_INT (12)));\n+    }\n+  DONE;\n+})\n \n+; FIXME: This can probably be expressed without an UNSPEC.\n (define_insn \"altivec_vsumsws_direct\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n         (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")"}, {"sha": "8d945ded85155b78a682e690f1f3cbc48c0df8f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55b2ce1c919ae1a5460f8bfd105f64155853d701", "patch": "@@ -1,3 +1,9 @@\n+2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR target/81833\n+\t* gcc.target/powerpc/pr81833-1.c: New file.\n+\t* gcc.target/powerpc/pr81833-2.c: New file.\n+\n 2017-09-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/59501"}, {"sha": "ca5ce006d20aec74aef023ef897549a65076700a", "filename": "gcc/testsuite/gcc.target/powerpc/pr81833-1.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr81833-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr81833-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr81833-1.c?ref=55b2ce1c919ae1a5460f8bfd105f64155853d701", "patch": "@@ -0,0 +1,59 @@\n+/* PR81833: This used to fail due to improper implementation of vec_msum.  */\n+/* Test case relies on -mcpu=power7 or later.  Currently we don't have\n+   machinery to express that, so we have two separate tests for -mcpu=power7\n+   and -mcpu=power8 to catch 32-bit BE on P7 and 64-bit BE/LE on P8.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+#include <altivec.h>\n+\n+#define vec_u8  vector unsigned char\n+#define vec_s8  vector signed char\n+#define vec_u16 vector unsigned short\n+#define vec_s16 vector signed short\n+#define vec_u32 vector unsigned int\n+#define vec_s32 vector signed int\n+#define vec_f   vector float\n+\n+#define LOAD_ZERO const vec_u8 zerov = vec_splat_u8 (0)\n+\n+#define zero_u8v  (vec_u8)  zerov\n+#define zero_s8v  (vec_s8)  zerov\n+#define zero_u16v (vec_u16) zerov\n+#define zero_s16v (vec_s16) zerov\n+#define zero_u32v (vec_u32) zerov\n+#define zero_s32v (vec_s32) zerov\n+\n+signed int __attribute__((noinline))\n+scalarproduct_int16_vsx (const signed short *v1, const signed short *v2,\n+\t\t\t int order)\n+{\n+  int i;\n+  LOAD_ZERO;\n+  register vec_s16 vec1;\n+  register vec_s32 res = vec_splat_s32 (0), t;\n+  signed int ires;\n+\n+  for (i = 0; i < order; i += 8) {\n+    vec1 = vec_vsx_ld (0, v1);\n+    t    = vec_msum (vec1, vec_vsx_ld (0, v2), zero_s32v);\n+    res  = vec_sums (t, res);\n+    v1  += 8;\n+    v2  += 8;\n+  }\n+  res = vec_splat (res, 3);\n+  vec_ste (res, 0, &ires);\n+\n+  return ires;\n+}\n+\n+int main(void)\n+{\n+  const signed short test_vec[] = { 1, 1, 1, 1, 1, 1, 1, 1 };\n+  if (scalarproduct_int16_vsx (test_vec, test_vec, 8) != 8)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "e92868334692ac121850498e8f8528ca20be8157", "filename": "gcc/testsuite/gcc.target/powerpc/pr81833-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr81833-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b2ce1c919ae1a5460f8bfd105f64155853d701/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr81833-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr81833-2.c?ref=55b2ce1c919ae1a5460f8bfd105f64155853d701", "patch": "@@ -0,0 +1,59 @@\n+/* PR81833: This used to fail due to improper implementation of vec_msum.  */\n+/* Test case relies on -mcpu=power7 or later.  Currently we don't have\n+   machinery to express that, so we have two separate tests for -mcpu=power7\n+   and -mcpu=power8 to catch 32-bit BE on P7 and 64-bit BE/LE on P8.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+\n+#include <altivec.h>\n+\n+#define vec_u8  vector unsigned char\n+#define vec_s8  vector signed char\n+#define vec_u16 vector unsigned short\n+#define vec_s16 vector signed short\n+#define vec_u32 vector unsigned int\n+#define vec_s32 vector signed int\n+#define vec_f   vector float\n+\n+#define LOAD_ZERO const vec_u8 zerov = vec_splat_u8 (0)\n+\n+#define zero_u8v  (vec_u8)  zerov\n+#define zero_s8v  (vec_s8)  zerov\n+#define zero_u16v (vec_u16) zerov\n+#define zero_s16v (vec_s16) zerov\n+#define zero_u32v (vec_u32) zerov\n+#define zero_s32v (vec_s32) zerov\n+\n+signed int __attribute__((noinline))\n+scalarproduct_int16_vsx (const signed short *v1, const signed short *v2,\n+\t\t\t int order)\n+{\n+  int i;\n+  LOAD_ZERO;\n+  register vec_s16 vec1;\n+  register vec_s32 res = vec_splat_s32 (0), t;\n+  signed int ires;\n+\n+  for (i = 0; i < order; i += 8) {\n+    vec1 = vec_vsx_ld (0, v1);\n+    t    = vec_msum (vec1, vec_vsx_ld (0, v2), zero_s32v);\n+    res  = vec_sums (t, res);\n+    v1  += 8;\n+    v2  += 8;\n+  }\n+  res = vec_splat (res, 3);\n+  vec_ste (res, 0, &ires);\n+\n+  return ires;\n+}\n+\n+int main(void)\n+{\n+  const signed short test_vec[] = { 1, 1, 1, 1, 1, 1, 1, 1 };\n+  if (scalarproduct_int16_vsx (test_vec, test_vec, 8) != 8)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}