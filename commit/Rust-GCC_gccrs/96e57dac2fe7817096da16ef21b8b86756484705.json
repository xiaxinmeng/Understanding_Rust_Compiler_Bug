{"sha": "96e57dac2fe7817096da16ef21b8b86756484705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZlNTdkYWMyZmU3ODE3MDk2ZGExNmVmMjFiOGI4Njc1NjQ4NDcwNQ==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-03-25T23:09:01Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-03-25T23:09:01Z"}, "message": "New tests (one might fail due to complex alias problems)\n\nFrom-SVN: r25988", "tree": {"sha": "5734c0f765db071f23fb9bc89f0c141c55490337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5734c0f765db071f23fb9bc89f0c141c55490337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96e57dac2fe7817096da16ef21b8b86756484705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e57dac2fe7817096da16ef21b8b86756484705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e57dac2fe7817096da16ef21b8b86756484705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e57dac2fe7817096da16ef21b8b86756484705/comments", "author": null, "committer": null, "parents": [{"sha": "f3fc6b6c4577585d5ece8ba7f56f217020489b99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3fc6b6c4577585d5ece8ba7f56f217020489b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3fc6b6c4577585d5ece8ba7f56f217020489b99"}], "stats": {"total": 631, "additions": 631, "deletions": 0}, "files": [{"sha": "86ef152fb236e11543019846807955b77900bc1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e57dac2fe7817096da16ef21b8b86756484705/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e57dac2fe7817096da16ef21b8b86756484705/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96e57dac2fe7817096da16ef21b8b86756484705", "patch": "@@ -1,3 +1,8 @@\n+1999-03-26  Craig Burley  <craig@jcb-sc.com>\n+\n+\t* g77.f-torture/execute/19990325-0.f: New test.\n+\t* g77.f-torture/execute/19990325-1.f: New test.\n+\n Wed Mar 24 22:50:50 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* gcc.c-torture/execute/990324-1.c: New test."}, {"sha": "13f57a15f9038993987cea2b8a364444b9ed589d", "filename": "gcc/testsuite/g77.f-torture/execute/19990325-0.f", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e57dac2fe7817096da16ef21b8b86756484705/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F19990325-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e57dac2fe7817096da16ef21b8b86756484705/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F19990325-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F19990325-0.f?ref=96e57dac2fe7817096da16ef21b8b86756484705", "patch": "@@ -0,0 +1,313 @@\n+* test whether complex operators properly handle\n+* full and partial aliasing.\n+* (libf2c/libF77 routines used to assume no aliasing,\n+* then were changed to accommodate full aliasing, while\n+* the libg2c/libF77 versions were changed to accommodate\n+* both full and partial aliasing.)\n+*\n+* NOTE: this (19990325-0.f) is the single-precision version.\n+* See 19990325-1.f for the double-precision version.\n+\n+      program complexalias\n+      implicit none\n+\n+* Make sure non-aliased cases work.  (Catch roundoff/precision\n+* problems, etc., here.  Modify subroutine check if they occur.)\n+\n+      call tryfull (1, 3, 5)\n+\n+* Now check various combinations of aliasing.\n+\n+* Full aliasing.\n+      call tryfull (1, 1, 5)\n+\n+* Partial aliasing.\n+      call trypart (2, 3, 5)\n+      call trypart (2, 1, 5)\n+      call trypart (2, 5, 3)\n+      call trypart (2, 5, 1)\n+\n+      end\n+\n+      subroutine tryfull (xout, xin1, xin2)\n+      implicit none\n+      integer xout, xin1, xin2\n+\n+* out, in1, and in2 are the desired indexes into the REAL array (array).\n+\n+      complex expect\n+      integer pwr\n+      integer out, in1, in2\n+\n+      real array(6)\n+      complex carray(3)\n+      equivalence (carray(1), array(1))\n+\n+* Make sure the indexes can be accommodated by the equivalences above.\n+\n+      if (mod (xout, 2) .ne. 1) call abort\n+      if (mod (xin1, 2) .ne. 1) call abort\n+      if (mod (xin2, 2) .ne. 1) call abort\n+\n+* Convert the indexes into ones suitable for the COMPLEX array (carray).\n+\n+      out = (xout + 1) / 2\n+      in1 = (xin1 + 1) / 2\n+      in2 = (xin2 + 1) / 2\n+\n+* Check some open-coded stuff, just in case.\n+\n+      call prepare1 (carray(in1))\n+      expect = + carray(in1)\n+      carray(out) = + carray(in1)\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = - carray(in1)\n+      carray(out) = - carray(in1)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) + carray(in2)\n+      carray(out) = carray(in1) + carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) - carray(in2)\n+      carray(out) = carray(in1) - carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) * carray(in2)\n+      carray(out) = carray(in1) * carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 2\n+      carray(out) = carray(in1) ** 2\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 3\n+      carray(out) = carray(in1) ** 3\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = abs (carray(in1))\n+      array(out*2-1) = abs (carray(in1))\n+      array(out*2) = 0\n+      call check (expect, carray(out))\n+\n+* Now check the stuff implemented in libF77.\n+\n+      call prepare1 (carray(in1))\n+      expect = cos (carray(in1))\n+      carray(out) = cos (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = exp (carray(in1))\n+      carray(out) = exp (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = log (carray(in1))\n+      carray(out) = log (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sin (carray(in1))\n+      carray(out) = sin (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sqrt (carray(in1))\n+      carray(out) = sqrt (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = conjg (carray(in1))\n+      carray(out) = conjg (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1i (carray(in1), pwr)\n+      expect = carray(in1) ** pwr\n+      carray(out) = carray(in1) ** pwr\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) / carray(in2)\n+      carray(out) = carray(in1) / carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) ** carray(in2)\n+      carray(out) = carray(in1) ** carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** .2\n+      carray(out) = carray(in1) ** .2\n+      call check (expect, carray(out))\n+\n+      end\n+\n+      subroutine trypart (xout, xin1, xin2)\n+      implicit none\n+      integer xout, xin1, xin2\n+\n+* out, in1, and in2 are the desired indexes into the REAL array (array).\n+\n+      complex expect\n+      integer pwr\n+      integer out, in1, in2\n+\n+      real array(6)\n+      complex carray(3), carrayp(2)\n+      equivalence (carray(1), array(1))\n+      equivalence (carrayp(1), array(2))\n+\n+* Make sure the indexes can be accommodated by the equivalences above.\n+\n+      if (mod (xout, 2) .ne. 0) call abort\n+      if (mod (xin1, 2) .ne. 1) call abort\n+      if (mod (xin2, 2) .ne. 1) call abort\n+\n+* Convert the indexes into ones suitable for the COMPLEX array (carray).\n+\n+      out = xout / 2\n+      in1 = (xin1 + 1) / 2\n+      in2 = (xin2 + 1) / 2\n+\n+* Check some open-coded stuff, just in case.\n+\n+      call prepare1 (carray(in1))\n+      expect = + carray(in1)\n+      carrayp(out) = + carray(in1)\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = - carray(in1)\n+      carrayp(out) = - carray(in1)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) + carray(in2)\n+      carrayp(out) = carray(in1) + carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) - carray(in2)\n+      carrayp(out) = carray(in1) - carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) * carray(in2)\n+      carrayp(out) = carray(in1) * carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 2\n+      carrayp(out) = carray(in1) ** 2\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 3\n+      carrayp(out) = carray(in1) ** 3\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = abs (carray(in1))\n+      array(out*2) = abs (carray(in1))\n+      array(out*2+1) = 0\n+      call check (expect, carrayp(out))\n+\n+* Now check the stuff implemented in libF77.\n+\n+      call prepare1 (carray(in1))\n+      expect = cos (carray(in1))\n+      carrayp(out) = cos (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = exp (carray(in1))\n+      carrayp(out) = exp (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = log (carray(in1))\n+      carrayp(out) = log (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sin (carray(in1))\n+      carrayp(out) = sin (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sqrt (carray(in1))\n+      carrayp(out) = sqrt (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = conjg (carray(in1))\n+      carrayp(out) = conjg (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1i (carray(in1), pwr)\n+      expect = carray(in1) ** pwr\n+      carrayp(out) = carray(in1) ** pwr\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) / carray(in2)\n+      carrayp(out) = carray(in1) / carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) ** carray(in2)\n+      carrayp(out) = carray(in1) ** carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** .2\n+      carrayp(out) = carray(in1) ** .2\n+      call check (expect, carrayp(out))\n+\n+      end\n+\n+      subroutine prepare1 (in)\n+      implicit none\n+      complex in\n+\n+      in = (3.2, 4.2)\n+\n+      end\n+\n+      subroutine prepare1i (in, i)\n+      implicit none\n+      complex in\n+      integer i\n+\n+      in = (2.3, 2.5)\n+      i = 4\n+\n+      end\n+\n+      subroutine prepare2 (in1, in2)\n+      implicit none\n+      complex in1, in2\n+\n+      in1 = (1.3, 2.4)\n+      in2 = (3.5, 7.1)\n+\n+      end\n+\n+      subroutine check (expect, got)\n+      implicit none\n+      complex expect, got\n+\n+      if (aimag(expect) .ne. aimag(got)) call abort\n+      if (real(expect) .ne. real(expect)) call abort\n+\n+      end"}, {"sha": "a146f6efab82fdb2deaee260c98129708fca4494", "filename": "gcc/testsuite/g77.f-torture/execute/19990325-1.f", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e57dac2fe7817096da16ef21b8b86756484705/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F19990325-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e57dac2fe7817096da16ef21b8b86756484705/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F19990325-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fexecute%2F19990325-1.f?ref=96e57dac2fe7817096da16ef21b8b86756484705", "patch": "@@ -0,0 +1,313 @@\n+* test whether complex operators properly handle\n+* full and partial aliasing.\n+* (libf2c/libF77 routines used to assume no aliasing,\n+* then were changed to accommodate full aliasing, while\n+* the libg2c/libF77 versions were changed to accommodate\n+* both full and partial aliasing.)\n+*\n+* NOTE: this (19990325-1.f) is the double-precision version.\n+* See 19990325-0.f for the single-precision version.\n+\n+      program doublecomplexalias\n+      implicit none\n+\n+* Make sure non-aliased cases work.  (Catch roundoff/precision\n+* problems, etc., here.  Modify subroutine check if they occur.)\n+\n+      call tryfull (1, 3, 5)\n+\n+* Now check various combinations of aliasing.\n+\n+* Full aliasing.\n+      call tryfull (1, 1, 5)\n+\n+* Partial aliasing.\n+      call trypart (2, 3, 5)\n+      call trypart (2, 1, 5)\n+      call trypart (2, 5, 3)\n+      call trypart (2, 5, 1)\n+\n+      end\n+\n+      subroutine tryfull (xout, xin1, xin2)\n+      implicit none\n+      integer xout, xin1, xin2\n+\n+* out, in1, and in2 are the desired indexes into the REAL array (array).\n+\n+      double complex expect\n+      integer pwr\n+      integer out, in1, in2\n+\n+      double precision array(6)\n+      double complex carray(3)\n+      equivalence (carray(1), array(1))\n+\n+* Make sure the indexes can be accommodated by the equivalences above.\n+\n+      if (mod (xout, 2) .ne. 1) call abort\n+      if (mod (xin1, 2) .ne. 1) call abort\n+      if (mod (xin2, 2) .ne. 1) call abort\n+\n+* Convert the indexes into ones suitable for the COMPLEX array (carray).\n+\n+      out = (xout + 1) / 2\n+      in1 = (xin1 + 1) / 2\n+      in2 = (xin2 + 1) / 2\n+\n+* Check some open-coded stuff, just in case.\n+\n+      call prepare1 (carray(in1))\n+      expect = + carray(in1)\n+      carray(out) = + carray(in1)\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = - carray(in1)\n+      carray(out) = - carray(in1)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) + carray(in2)\n+      carray(out) = carray(in1) + carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) - carray(in2)\n+      carray(out) = carray(in1) - carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) * carray(in2)\n+      carray(out) = carray(in1) * carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 2\n+      carray(out) = carray(in1) ** 2\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 3\n+      carray(out) = carray(in1) ** 3\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = abs (carray(in1))\n+      array(out*2-1) = abs (carray(in1))\n+      array(out*2) = 0\n+      call check (expect, carray(out))\n+\n+* Now check the stuff implemented in libF77.\n+\n+      call prepare1 (carray(in1))\n+      expect = cos (carray(in1))\n+      carray(out) = cos (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = exp (carray(in1))\n+      carray(out) = exp (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = log (carray(in1))\n+      carray(out) = log (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sin (carray(in1))\n+      carray(out) = sin (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sqrt (carray(in1))\n+      carray(out) = sqrt (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = conjg (carray(in1))\n+      carray(out) = conjg (carray(in1))\n+      call check (expect, carray(out))\n+\n+      call prepare1i (carray(in1), pwr)\n+      expect = carray(in1) ** pwr\n+      carray(out) = carray(in1) ** pwr\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) / carray(in2)\n+      carray(out) = carray(in1) / carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) ** carray(in2)\n+      carray(out) = carray(in1) ** carray(in2)\n+      call check (expect, carray(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** .2\n+      carray(out) = carray(in1) ** .2\n+      call check (expect, carray(out))\n+\n+      end\n+\n+      subroutine trypart (xout, xin1, xin2)\n+      implicit none\n+      integer xout, xin1, xin2\n+\n+* out, in1, and in2 are the desired indexes into the REAL array (array).\n+\n+      double complex expect\n+      integer pwr\n+      integer out, in1, in2\n+\n+      double precision array(6)\n+      double complex carray(3), carrayp(2)\n+      equivalence (carray(1), array(1))\n+      equivalence (carrayp(1), array(2))\n+\n+* Make sure the indexes can be accommodated by the equivalences above.\n+\n+      if (mod (xout, 2) .ne. 0) call abort\n+      if (mod (xin1, 2) .ne. 1) call abort\n+      if (mod (xin2, 2) .ne. 1) call abort\n+\n+* Convert the indexes into ones suitable for the COMPLEX array (carray).\n+\n+      out = xout / 2\n+      in1 = (xin1 + 1) / 2\n+      in2 = (xin2 + 1) / 2\n+\n+* Check some open-coded stuff, just in case.\n+\n+      call prepare1 (carray(in1))\n+      expect = + carray(in1)\n+      carrayp(out) = + carray(in1)\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = - carray(in1)\n+      carrayp(out) = - carray(in1)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) + carray(in2)\n+      carrayp(out) = carray(in1) + carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) - carray(in2)\n+      carrayp(out) = carray(in1) - carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) * carray(in2)\n+      carrayp(out) = carray(in1) * carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 2\n+      carrayp(out) = carray(in1) ** 2\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** 3\n+      carrayp(out) = carray(in1) ** 3\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = abs (carray(in1))\n+      array(out*2) = abs (carray(in1))\n+      array(out*2+1) = 0\n+      call check (expect, carrayp(out))\n+\n+* Now check the stuff implemented in libF77.\n+\n+      call prepare1 (carray(in1))\n+      expect = cos (carray(in1))\n+      carrayp(out) = cos (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = exp (carray(in1))\n+      carrayp(out) = exp (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = log (carray(in1))\n+      carrayp(out) = log (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sin (carray(in1))\n+      carrayp(out) = sin (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = sqrt (carray(in1))\n+      carrayp(out) = sqrt (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = conjg (carray(in1))\n+      carrayp(out) = conjg (carray(in1))\n+      call check (expect, carrayp(out))\n+\n+      call prepare1i (carray(in1), pwr)\n+      expect = carray(in1) ** pwr\n+      carrayp(out) = carray(in1) ** pwr\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) / carray(in2)\n+      carrayp(out) = carray(in1) / carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare2 (carray(in1), carray(in2))\n+      expect = carray(in1) ** carray(in2)\n+      carrayp(out) = carray(in1) ** carray(in2)\n+      call check (expect, carrayp(out))\n+\n+      call prepare1 (carray(in1))\n+      expect = carray(in1) ** .2\n+      carrayp(out) = carray(in1) ** .2\n+      call check (expect, carrayp(out))\n+\n+      end\n+\n+      subroutine prepare1 (in)\n+      implicit none\n+      double complex in\n+\n+      in = (3.2d0, 4.2d0)\n+\n+      end\n+\n+      subroutine prepare1i (in, i)\n+      implicit none\n+      double complex in\n+      integer i\n+\n+      in = (2.3d0, 2.5d0)\n+      i = 4\n+\n+      end\n+\n+      subroutine prepare2 (in1, in2)\n+      implicit none\n+      double complex in1, in2\n+\n+      in1 = (1.3d0, 2.4d0)\n+      in2 = (3.5d0, 7.1d0)\n+\n+      end\n+\n+      subroutine check (expect, got)\n+      implicit none\n+      double complex expect, got\n+\n+      if (dimag(expect) .ne. dimag(got)) call abort\n+      if (dble(expect) .ne. dble(expect)) call abort\n+\n+      end"}]}