{"sha": "584898ee80100dcdda3f0eb3cbf151976843055d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg0ODk4ZWU4MDEwMGRjZGRhM2YwZWIzY2JmMTUxOTc2ODQzMDU1ZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2017-02-14T22:17:19Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2017-02-14T22:17:19Z"}, "message": "re PR target/79282 ([7 Regresion] FAIL: gcc.target/arm/neon-for-64bits-1.c scan-assembler-times vshr 0)\n\n2017-02-14  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/79282\n\t* lra-int.h (struct lra_operand_data, struct lra_insn_reg): Add\n\tmember early_clobber_alts.\n\t* lra-lives.c (reg_early_clobber_p): New.\n\t(process_bb_lives): Use it.\n\t* lra.c (new_insn_reg): New arg early_clobber_alts.  Use it.\n\t(debug_operand_data): Initialize early_clobber_alts.\n\t(setup_operand_alternative): Set up early_clobber_alts.\n\t(collect_non_operand_hard_regs): Ditto.  Pass early clobber\n\talternatives to new_insn_reg.\n\t(add_regs_to_insn_regno_info): Add arg early_clobber_alts.  Use\n\tit.\n\t(lra_update_insn_regno_info): Pass the new arg.\n\nFrom-SVN: r245459", "tree": {"sha": "d081ca334c52567eb71268a947e567756d1732eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d081ca334c52567eb71268a947e567756d1732eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/584898ee80100dcdda3f0eb3cbf151976843055d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/584898ee80100dcdda3f0eb3cbf151976843055d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/584898ee80100dcdda3f0eb3cbf151976843055d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/584898ee80100dcdda3f0eb3cbf151976843055d/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2932fe90d51b39404bd0b564415b6f5149f10f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2932fe90d51b39404bd0b564415b6f5149f10f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2932fe90d51b39404bd0b564415b6f5149f10f9b"}], "stats": {"total": 116, "additions": 85, "deletions": 31}, "files": [{"sha": "43f404303eece4d0762b16c1b3c3f2793ba05d62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=584898ee80100dcdda3f0eb3cbf151976843055d", "patch": "@@ -1,3 +1,19 @@\n+2017-02-14  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/79282\n+\t* lra-int.h (struct lra_operand_data, struct lra_insn_reg): Add\n+\tmember early_clobber_alts.\n+\t* lra-lives.c (reg_early_clobber_p): New.\n+\t(process_bb_lives): Use it.\n+\t* lra.c (new_insn_reg): New arg early_clobber_alts.  Use it.\n+\t(debug_operand_data): Initialize early_clobber_alts.\n+\t(setup_operand_alternative): Set up early_clobber_alts.\n+\t(collect_non_operand_hard_regs): Ditto.  Pass early clobber\n+\talternatives to new_insn_reg.\n+\t(add_regs_to_insn_regno_info): Add arg early_clobber_alts.  Use\n+\tit.\n+\t(lra_update_insn_regno_info): Pass the new arg.\n+\n 2017-02-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/79505"}, {"sha": "405071708b130795ac9eb34ed7db736d6a91fd85", "filename": "gcc/lra-int.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=584898ee80100dcdda3f0eb3cbf151976843055d", "patch": "@@ -130,6 +130,8 @@ struct lra_operand_data\n {\n   /* The machine description constraint string of the operand.\t*/\n   const char *constraint;\n+  /* Alternatives for which early_clobber can be true.  */\n+  alternative_mask early_clobber_alts;\n   /* It is taken only from machine description (which is different\n      from recog_data.operand_mode) and can be of VOIDmode.  */\n   ENUM_BITFIELD(machine_mode) mode : 16;\n@@ -150,6 +152,8 @@ struct lra_operand_data\n /* Info about register occurrence in an insn.  */\n struct lra_insn_reg\n {\n+  /* Alternatives for which early_clobber can be true.  */\n+  alternative_mask early_clobber_alts;\n   /* The biggest mode through which the insn refers to the register\n      occurrence (remember the register can be accessed through a\n      subreg in the insn).  */"}, {"sha": "5d4015b5ab9a65a33b3198507506761caeb0487c", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=584898ee80100dcdda3f0eb3cbf151976843055d", "patch": "@@ -586,6 +586,16 @@ check_pseudos_live_through_calls (int regno,\n   SET_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs);\n }\n \n+/* Return true if insn REG is an early clobber operand in alternative\n+   NALT.  Negative NALT means that we don't know the current insn\n+   alternative.  So assume the worst.  */\n+static inline bool\n+reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)\n+{\n+  return (reg->early_clobber\n+\t  && (n_alt < 0 || TEST_BIT (reg->early_clobber_alts, n_alt)));\n+}\n+\n /* Process insns of the basic block BB to update pseudo live ranges,\n    pseudo hard register conflicts, and insn notes.  We do it on\n    backward scan of BB insns.  CURR_POINT is the program point where\n@@ -638,7 +648,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   FOR_BB_INSNS_REVERSE_SAFE (bb, curr_insn, next)\n     {\n       bool call_p;\n-      int dst_regno, src_regno;\n+      int n_alt, dst_regno, src_regno;\n       rtx set;\n       struct lra_insn_reg *reg;\n \n@@ -647,9 +657,10 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       curr_id = lra_get_insn_recog_data (curr_insn);\n       curr_static_id = curr_id->insn_static_data;\n+      n_alt = curr_id->used_insn_alternative;\n       if (lra_dump_file != NULL)\n-\tfprintf (lra_dump_file, \"   Insn %u: point = %d\\n\",\n-\t\t INSN_UID (curr_insn), curr_point);\n+\tfprintf (lra_dump_file, \"   Insn %u: point = %d, n_alt = %d\\n\",\n+\t\t INSN_UID (curr_insn), curr_point, n_alt);\n \n       set = single_set (curr_insn);\n \n@@ -818,13 +829,15 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       /* See which defined values die here.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n+\tif (reg->type == OP_OUT\n+\t    && ! reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n \t  need_curr_point_incr\n \t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n \t\t\t\tcurr_point);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n+\tif (reg->type == OP_OUT\n+\t    && ! reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n \t  make_hard_regno_dead (reg->regno);\n \n       if (curr_id->arg_hard_regs != NULL)\n@@ -901,13 +914,15 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       /* Mark early clobber outputs dead.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n+\tif (reg->type == OP_OUT\n+\t    && reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n \t  need_curr_point_incr\n \t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n \t\t\t\tcurr_point);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n+\tif (reg->type == OP_OUT\n+\t    && reg_early_clobber_p (reg, n_alt) && ! reg->subreg_p)\n \t  make_hard_regno_dead (reg->regno);\n \n       if (need_curr_point_incr)"}, {"sha": "d551102c8c9e3f034302f5bb47f78a611e1142af", "filename": "gcc/lra.c", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584898ee80100dcdda3f0eb3cbf151976843055d/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=584898ee80100dcdda3f0eb3cbf151976843055d", "patch": "@@ -529,15 +529,19 @@ lra_update_dups (lra_insn_recog_data_t id, signed char *nops)\n /* Pools for insn reg info.  */\n object_allocator<lra_insn_reg> lra_insn_reg_pool (\"insn regs\");\n \n-/* Create LRA insn related info about a reference to REGNO in INSN with\n-   TYPE (in/out/inout), biggest reference mode MODE, flag that it is\n-   reference through subreg (SUBREG_P), flag that is early clobbered\n-   in the insn (EARLY_CLOBBER), and reference to the next insn reg\n-   info (NEXT).\t */\n+/* Create LRA insn related info about a reference to REGNO in INSN\n+   with TYPE (in/out/inout), biggest reference mode MODE, flag that it\n+   is reference through subreg (SUBREG_P), flag that is early\n+   clobbered in the insn (EARLY_CLOBBER), and reference to the next\n+   insn reg info (NEXT).  If REGNO can be early clobbered,\n+   alternatives in which it can be early clobbered are given by\n+   EARLY_CLOBBER_ALTS.  */\n static struct lra_insn_reg *\n new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n \t      machine_mode mode,\n-\t      bool subreg_p, bool early_clobber, struct lra_insn_reg *next)\n+\t      bool subreg_p, bool early_clobber,\n+\t      alternative_mask early_clobber_alts,\n+\t      struct lra_insn_reg *next)\n {\n   lra_insn_reg *ir = lra_insn_reg_pool.allocate ();\n   ir->type = type;\n@@ -547,6 +551,7 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n     lra_reg_info[regno].biggest_mode = mode;\n   ir->subreg_p = subreg_p;\n   ir->early_clobber = early_clobber;\n+  ir->early_clobber_alts = early_clobber_alts;\n   ir->regno = regno;\n   ir->next = next;\n   return ir;\n@@ -590,6 +595,7 @@ struct lra_static_insn_data *insn_code_data[NUM_INSN_CODES];\n static struct lra_operand_data debug_operand_data =\n   {\n     NULL, /* alternative  */\n+    0, /* early_clobber_alts */\n     VOIDmode, /* We are not interesting in the operand mode.  */\n     OP_IN,\n     0, 0, 0, 0\n@@ -771,6 +777,7 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n   static_data->operand_alternative = op_alt;\n   for (i = 0; i < nop; i++)\n     {\n+      static_data->operand[i].early_clobber_alts = 0;\n       static_data->operand[i].early_clobber = false;\n       static_data->operand[i].is_address = false;\n       if (static_data->operand[i].constraint[0] == '%')\n@@ -788,6 +795,8 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n     for (i = 0; i < nop; i++, op_alt++)\n       {\n \tstatic_data->operand[i].early_clobber |= op_alt->earlyclobber;\n+\tif (op_alt->earlyclobber)\n+\t  static_data->operand[i].early_clobber_alts |= (alternative_mask) 1 << j;\n \tstatic_data->operand[i].is_address |= op_alt->is_address;\n       }\n }\n@@ -847,8 +856,11 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n \t      {\n \t\tif (curr->type != type)\n \t\t  curr->type = OP_INOUT;\n-\t\tif (curr->early_clobber != early_clobber)\n-\t\t  curr->early_clobber = true;\n+\t\tif (early_clobber)\n+\t\t  {\n+\t\t    curr->early_clobber = true;\n+\t\t    curr->early_clobber_alts = ALL_ALTERNATIVES;\n+\t\t  }\n \t\tbreak;\n \t      }\n \t  if (curr == NULL)\n@@ -864,7 +876,8 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n \t\t\t && regno <= LAST_STACK_REG));\n #endif\n \t      list = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t   early_clobber, list);\n+\t\t\t\t   early_clobber,\n+\t\t\t\t   early_clobber ? ALL_ALTERNATIVES : 0, list);\n \t    }\n \t}\n       return list;\n@@ -1395,10 +1408,13 @@ lra_get_copy (int n)\n \n /* Process X of insn UID recursively and add info (operand type is\n    given by TYPE, flag of that it is early clobber is EARLY_CLOBBER)\n-   about registers in X to the insn DATA.  */\n+   about registers in X to the insn DATA.  If X can be early clobbered,\n+   alternatives in which it can be early clobbered are given by\n+   EARLY_CLOBBER_ALTS.  */\n static void\n add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n-\t\t\t     enum op_type type, bool early_clobber)\n+\t\t\t     enum op_type type, bool early_clobber,\n+\t\t\t     alternative_mask early_clobber_alts)\n {\n   int i, j, regno;\n   bool subreg_p;\n@@ -1430,7 +1446,8 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n       if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, uid))\n \t{\n \t  data->regs = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t     early_clobber, data->regs);\n+\t\t\t\t     early_clobber, early_clobber_alts,\n+\t\t\t\t     data->regs);\n \t  return;\n \t}\n       else\n@@ -1443,13 +1460,14 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n \t\t     structure.  */\n \t\t  data->regs = new_insn_reg (data->insn, regno, type, mode,\n \t\t\t\t\t     subreg_p, early_clobber,\n-\t\t\t\t\t     data->regs);\n+\t\t\t\t\t     early_clobber_alts, data->regs);\n \t\telse\n \t\t  {\n \t\t    if (curr->type != type)\n \t\t      curr->type = OP_INOUT;\n \t\t    if (curr->early_clobber != early_clobber)\n \t\t      curr->early_clobber = true;\n+\t\t    curr->early_clobber_alts |= early_clobber_alts;\n \t\t  }\n \t\treturn;\n \t      }\n@@ -1460,20 +1478,20 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n   switch (code)\n     {\n     case SET:\n-      add_regs_to_insn_regno_info (data, SET_DEST (x), uid, OP_OUT, false);\n-      add_regs_to_insn_regno_info (data, SET_SRC (x), uid, OP_IN, false);\n+      add_regs_to_insn_regno_info (data, SET_DEST (x), uid, OP_OUT, false, 0);\n+      add_regs_to_insn_regno_info (data, SET_SRC (x), uid, OP_IN, false, 0);\n       break;\n     case CLOBBER:\n       /* We treat clobber of non-operand hard registers as early\n \t clobber (the behavior is expected from asm).  */\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_OUT, true);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_OUT, true, ALL_ALTERNATIVES);\n       break;\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_INOUT, false);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_INOUT, false, 0);\n       break;\n     case PRE_MODIFY: case POST_MODIFY:\n-      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_INOUT, false);\n-      add_regs_to_insn_regno_info (data, XEXP (x, 1), uid, OP_IN, false);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_INOUT, false, 0);\n+      add_regs_to_insn_regno_info (data, XEXP (x, 1), uid, OP_IN, false, 0);\n       break;\n     default:\n       if ((code != PARALLEL && code != EXPR_LIST) || type != OP_OUT)\n@@ -1494,12 +1512,12 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n-\t    add_regs_to_insn_regno_info (data, XEXP (x, i), uid, type, false);\n+\t    add_regs_to_insn_regno_info (data, XEXP (x, i), uid, type, false, 0);\n \t  else if (fmt[i] == 'E')\n \t    {\n \t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t\tadd_regs_to_insn_regno_info (data, XVECEXP (x, i, j), uid,\n-\t\t\t\t\t     type, false);\n+\t\t\t\t\t     type, false, 0);\n \t    }\n \t}\n     }\n@@ -1590,10 +1608,11 @@ lra_update_insn_regno_info (rtx_insn *insn)\n   for (i = static_data->n_operands - 1; i >= 0; i--)\n     add_regs_to_insn_regno_info (data, *data->operand_loc[i], uid,\n \t\t\t\t static_data->operand[i].type,\n-\t\t\t\t static_data->operand[i].early_clobber);\n+\t\t\t\t static_data->operand[i].early_clobber,\n+\t\t\t\t static_data->operand[i].early_clobber_alts);\n   if ((code = GET_CODE (PATTERN (insn))) == CLOBBER || code == USE)\n     add_regs_to_insn_regno_info (data, XEXP (PATTERN (insn), 0), uid,\n-\t\t\t\t code == USE ? OP_IN : OP_OUT, false);\n+\t\t\t\t code == USE ? OP_IN : OP_OUT, false, 0);\n   if (CALL_P (insn))\n     /* On some targets call insns can refer to pseudos in memory in\n        CALL_INSN_FUNCTION_USAGE list.  Process them in order to\n@@ -1605,7 +1624,7 @@ lra_update_insn_regno_info (rtx_insn *insn)\n       if (((code = GET_CODE (XEXP (link, 0))) == USE || code == CLOBBER)\n \t  && MEM_P (XEXP (XEXP (link, 0), 0)))\n \tadd_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), uid,\n-\t\t\t\t     code == USE ? OP_IN : OP_OUT, false);\n+\t\t\t\t     code == USE ? OP_IN : OP_OUT, false, 0);\n   if (NONDEBUG_INSN_P (insn))\n     setup_insn_reg_info (data, freq);\n }"}]}