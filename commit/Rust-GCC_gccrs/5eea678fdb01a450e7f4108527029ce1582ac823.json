{"sha": "5eea678fdb01a450e7f4108527029ce1582ac823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVlYTY3OGZkYjAxYTQ1MGU3ZjQxMDg1MjcwMjljZTE1ODJhYzgyMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-10-03T22:53:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-10-03T22:53:37Z"}, "message": "decl2.c (merge_functions): Remove duplicates.\n\n\t* decl2.c (merge_functions): Remove duplicates.\n\t* decl2.c: Add -f{no-,}implicit-inline-templates.\n\t(lang_decode_option): Unset it if -frepo.\n\t(import_export_decl): Check it.\n\t* decl.c (lookup_name_real): Template parms also take precedence\n\tover implicit typename.  Only warn if yylex.\n\nFrom-SVN: r22800", "tree": {"sha": "b143bd244be2d78af15eeecda781f74fb79789c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b143bd244be2d78af15eeecda781f74fb79789c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5eea678fdb01a450e7f4108527029ce1582ac823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eea678fdb01a450e7f4108527029ce1582ac823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eea678fdb01a450e7f4108527029ce1582ac823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eea678fdb01a450e7f4108527029ce1582ac823/comments", "author": null, "committer": null, "parents": [{"sha": "4d77340e3de33f19a76a87bf1e6dfa58f79dc430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d77340e3de33f19a76a87bf1e6dfa58f79dc430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d77340e3de33f19a76a87bf1e6dfa58f79dc430"}], "stats": {"total": 81, "additions": 58, "deletions": 23}, "files": [{"sha": "8604334c7bf96e77f605ad9d27b0444a49c46e1e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eea678fdb01a450e7f4108527029ce1582ac823/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eea678fdb01a450e7f4108527029ce1582ac823/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5eea678fdb01a450e7f4108527029ce1582ac823", "patch": "@@ -1,5 +1,14 @@\n 1998-10-03  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* decl2.c (merge_functions): Remove duplicates.\n+\n+\t* decl2.c: Add -f{no-,}implicit-inline-templates.\n+\t(lang_decode_option): Unset it if -frepo.\n+\t(import_export_decl): Check it.\n+\n+\t* decl.c (lookup_name_real): Template parms also take precedence\n+\tover implicit typename.  Only warn if yylex.\n+\n \t* typeck.c (build_conditional_expr): Only fold if ifexp is an\n \tINTEGER_CST.\n "}, {"sha": "a4ed7b9d4ac802ac193080fcb4306479d2cf9666", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eea678fdb01a450e7f4108527029ce1582ac823/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eea678fdb01a450e7f4108527029ce1582ac823/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5eea678fdb01a450e7f4108527029ce1582ac823", "patch": "@@ -5167,25 +5167,43 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   else\n     val = unqualified_namespace_lookup (name, flags);\n \n+  /* Any other name takes precedence over an implicit typename.  Warn the\n+     user about this potentially confusing lookup.  */\n   if (classval && TREE_CODE (val) == TYPE_DECL\n       && TREE_CODE (TREE_TYPE (val)) == TYPENAME_TYPE\n       && TREE_TYPE (TREE_TYPE (val)))\n     {\n-      tree nsval = unqualified_namespace_lookup (name, flags);\n+      if (locval == NULL_TREE)\n+\tlocval = unqualified_namespace_lookup (name, flags);\n \n-      if (val && nsval && TREE_CODE (nsval) == TYPE_DECL)\n+      if (locval && val != locval)\n \t{\n-\t  static int explained;\n-\t  cp_warning (\"namespace-scope type `%#D'\", nsval);\n-\t  cp_warning\n-\t    (\"  is used instead of `%D' from dependent base class\", val);\n-\t  if (! explained)\n+\t  tree subtype;\n+\n+\t  val = locval;\n+\n+\t  /* To avoid redundant warnings, only warn when lexing, and the\n+\t     decls are significantly different.  */\n+\t  subtype = TREE_TYPE (TREE_TYPE (classval));\n+\t  if (yylex\n+\t      && ! (TREE_CODE (locval) == TEMPLATE_DECL\n+\t\t    && CLASSTYPE_TEMPLATE_INFO (subtype)\n+\t\t    && CLASSTYPE_TI_TEMPLATE (subtype) == locval)\n+\t      && ! (TREE_CODE (locval) == TYPE_DECL\n+\t\t    && comptypes (TREE_TYPE (locval), subtype, 1)))\n \t    {\n-\t      explained = 1;\n-\t      cp_warning (\"  (use `typename %D' if that's what you meant)\",\n-\t\t\t  val);\n+\t      static int explained;\n+\n+\t      cp_warning (\"lookup of `%D' finds `%#D'\", name, locval);\n+\t      cp_warning\n+\t\t(\"  instead of `%D' from dependent base class\", classval);\n+\t      if (! explained)\n+\t\t{\n+\t\t  explained = 1;\n+\t\t  cp_warning (\"  (use `typename %D' if that's what you meant)\",\n+\t\t\t      classval);\n+\t\t}\n \t    }\n-\t  val = nsval;\n \t}\n     }\n \n@@ -5507,7 +5525,7 @@ init_decl_processing ()\n   tree string_ftype_ptr_ptr, int_ftype_string_string;\n   tree sizetype_endlink;\n   tree ptr_ftype, ptr_ftype_unsigned, ptr_ftype_sizetype;\n-  tree void_ftype, void_ftype_int, void_ftype_ptr, ptr_ftype_void;\n+  tree void_ftype, void_ftype_int, void_ftype_ptr;\n \n   /* Have to make these distinct before we try using them.  */\n   lang_name_cplusplus = get_identifier (\"C++\");"}, {"sha": "50eea9f8247385fe759e6f14d19576801e09afb8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eea678fdb01a450e7f4108527029ce1582ac823/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eea678fdb01a450e7f4108527029ce1582ac823/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5eea678fdb01a450e7f4108527029ce1582ac823", "patch": "@@ -173,6 +173,12 @@ int flag_alt_external_templates;\n \n int flag_implicit_templates = 1;\n \n+/* Nonzero means that implicit instantiations of inline templates will be\n+   emitted if needed, even if instantiations of non-inline templates\n+   aren't.  */\n+\n+int flag_implicit_inline_templates = 1;\n+\n /* Nonzero means allow numerical priorities on constructors.  */\n \n #ifdef USE_INIT_PRIORITY\n@@ -474,6 +480,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n   {\"external-templates\", &flag_external_templates, 1},\n   {\"implicit-templates\", &flag_implicit_templates, 1},\n+  {\"implicit-inline-templates\", &flag_implicit_inline_templates, 1},\n   {\"init-priority\", &flag_init_priority, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n@@ -2856,7 +2863,8 @@ import_export_decl (decl)\n       DECL_NOT_REALLY_EXTERN (decl) = 1;\n       if ((DECL_IMPLICIT_INSTANTIATION (decl)\n \t   || DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl))\n-\t  && (flag_implicit_templates || DECL_THIS_INLINE (decl)))\n+\t  && (flag_implicit_templates\n+\t      || (flag_implicit_inline_templates && DECL_THIS_INLINE (decl))))\n \t{\n \t  if (!TREE_PUBLIC (decl))\n \t    /* Templates are allowed to have internal linkage.  See \n@@ -4118,22 +4126,22 @@ add_using_namespace (user, used, indirect)\n     add_using_namespace (TREE_PURPOSE (t), used, 1);\n }\n \n-/* Combines two sets of overloaded functions into an OVERLOAD chain.\n-   The first list becomes the tail of the result. */\n+/* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n+   duplicates.  The first list becomes the tail of the result.\n+\n+   The algorithm is O(n^2).  */\n \n static tree\n merge_functions (s1, s2)\n      tree s1;\n      tree s2;\n {\n-  if (TREE_CODE (s2) == OVERLOAD)\n-    while (s2)\n-      {\n-\ts1 = build_overload (OVL_FUNCTION (s2), s1);\n-\ts2 = OVL_CHAIN (s2);\n-      }\n-  else\n-    s1 = build_overload (s2, s1);\n+  for (; s2; s2 = OVL_NEXT (s2))\n+    {\n+      tree fn = OVL_CURRENT (s2);\n+      if (! ovl_member (fn, s1))\n+\ts1 = build_overload (fn, s1);\n+    }\n   return s1;\n }\n "}]}