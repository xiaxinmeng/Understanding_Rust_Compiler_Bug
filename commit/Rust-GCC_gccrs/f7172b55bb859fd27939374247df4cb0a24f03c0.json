{"sha": "f7172b55bb859fd27939374247df4cb0a24f03c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxNzJiNTViYjg1OWZkMjc5MzkzNzQyNDdkZjRjYjBhMjRmMDNjMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-02-20T12:46:43Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-02-20T12:46:43Z"}, "message": "re PR fortran/36932 (unneeded temporary (2x))\n\n2010-02-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/36932\n\tPR fortran/36933\n\tPR fortran/43072\n\tPR fortran/43111\n\t* dependency.c (gfc_check_argument_var_dependency): Use enum\n\tvalue instead of arithmetic vaue for 'elemental'.\n\t(check_data_pointer_types): New function.\n\t(gfc_check_dependency): Call check_data_pointer_types.\n\t* trans-array.h : Change fourth argument of\n\tgfc_conv_array_parameter to boolean.\n\t* trans-array.c (gfc_conv_array_parameter): A contiguous array\n\tcan be a dummy but it must not be assumed shape or deferred.\n\tChange fourth argument to boolean. Array constructor exprs will\n\talways be contiguous and do not need packing and unpacking.\n\t* trans-expr.c (gfc_conv_procedure_call): Clean up some white\n\tspace and change fourth argument of gfc_conv_array_parameter\n\tto boolean.\n\t(gfc_trans_arrayfunc_assign): Change fourth argument of\n\tgfc_conv_array_parameter to boolean.\n\t* trans-io.c (gfc_convert_array_to_string): The same.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_loc): The same.\n\n2010-02-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/36932\n\tPR fortran/36933\n\t* gfortran.dg/dependency_26.f90: New test.\n\n\tPR fortran/43072\n\t* gfortran.dg/internal_pack_7.f90: New test.\n\n\tPR fortran/43111\n\t* gfortran.dg/internal_pack_8.f90: New test.\n\nFrom-SVN: r156926", "tree": {"sha": "d1b425ccdec447a40c7a383fc38708be8c41cc3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1b425ccdec447a40c7a383fc38708be8c41cc3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7172b55bb859fd27939374247df4cb0a24f03c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7172b55bb859fd27939374247df4cb0a24f03c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7172b55bb859fd27939374247df4cb0a24f03c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7172b55bb859fd27939374247df4cb0a24f03c0/comments", "author": null, "committer": null, "parents": [{"sha": "e7a8485402327fdc5843b7ec0228c6e70ed1919f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a8485402327fdc5843b7ec0228c6e70ed1919f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a8485402327fdc5843b7ec0228c6e70ed1919f"}], "stats": {"total": 317, "additions": 289, "deletions": 28}, "files": [{"sha": "9efaf383ba2ec8e7434b2e3a823728984582f144", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -1,3 +1,27 @@\n+2010-02-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/36932\n+\tPR fortran/36933\n+\tPR fortran/43072\n+\tPR fortran/43111\n+\t* dependency.c (gfc_check_argument_var_dependency): Use enum\n+\tvalue instead of arithmetic vaue for 'elemental'.\n+\t(check_data_pointer_types): New function.\n+\t(gfc_check_dependency): Call check_data_pointer_types.\n+\t* trans-array.h : Change fourth argument of\n+\tgfc_conv_array_parameter to boolean.\n+\t* trans-array.c (gfc_conv_array_parameter): A contiguous array\n+\tcan be a dummy but it must not be assumed shape or deferred.\n+\tChange fourth argument to boolean. Array constructor exprs will\n+\talways be contiguous and do not need packing and unpacking.\n+\t* trans-expr.c (gfc_conv_procedure_call): Clean up some white\n+\tspace and change fourth argument of gfc_conv_array_parameter\n+\tto boolean.\n+\t(gfc_trans_arrayfunc_assign): Change fourth argument of\n+\tgfc_conv_array_parameter to boolean.\n+\t* trans-io.c (gfc_convert_array_to_string): The same.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_loc): The same.\n+\n 2010-02-20  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/42958"}, {"sha": "1f3d0eddd31d96d8bdddfbd1996ae4ede97ec824", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -467,7 +467,7 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n       /* In case of elemental subroutines, there is no dependency \n          between two same-range array references.  */\n       if (gfc_ref_needs_temporary_p (expr->ref)\n-\t  || gfc_check_dependency (var, expr, !elemental))\n+\t  || gfc_check_dependency (var, expr, elemental == NOT_ELEMENTAL))\n \t{\n \t  if (elemental == ELEM_DONT_CHECK_VARIABLE)\n \t    {\n@@ -677,6 +677,78 @@ gfc_are_equivalenced_arrays (gfc_expr *e1, gfc_expr *e2)\n }\n \n \n+/* Return true if there is no possibility of aliasing because of a type\n+   mismatch between all the possible pointer references and the\n+   potential target.  Note that this function is asymmetric in the\n+   arguments and so must be called twice with the arguments exchanged.  */\n+\n+static bool\n+check_data_pointer_types (gfc_expr *expr1, gfc_expr *expr2)\n+{\n+  gfc_component *cm1;\n+  gfc_symbol *sym1;\n+  gfc_symbol *sym2;\n+  gfc_ref *ref1;\n+  bool seen_component_ref;\n+\n+  if (expr1->expr_type != EXPR_VARIABLE\n+\t|| expr1->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  sym1 = expr1->symtree->n.sym;\n+  sym2 = expr2->symtree->n.sym;\n+\n+  /* Keep it simple for now.  */\n+  if (sym1->ts.type == BT_DERIVED && sym2->ts.type == BT_DERIVED)\n+    return false;\n+\n+  if (sym1->attr.pointer)\n+    {\n+      if (gfc_compare_types (&sym1->ts, &sym2->ts))\n+\treturn false;\n+    }\n+\n+  /* This is a conservative check on the components of the derived type\n+     if no component references have been seen.  Since we will not dig\n+     into the components of derived type components, we play it safe by\n+     returning false.  First we check the reference chain and then, if\n+     no component references have been seen, the components.  */\n+  seen_component_ref = false;\n+  if (sym1->ts.type == BT_DERIVED)\n+    {\n+      for (ref1 = expr1->ref; ref1; ref1 = ref1->next)\n+\t{\n+\t  if (ref1->type != REF_COMPONENT)\n+\t    continue;\n+\n+\t  if (ref1->u.c.component->ts.type == BT_DERIVED)\n+\t    return false;\n+\n+\t  if ((sym2->attr.pointer || ref1->u.c.component->attr.pointer)\n+\t\t&& gfc_compare_types (&ref1->u.c.component->ts, &sym2->ts))\n+\t    return false;\n+\n+\t  seen_component_ref = true;\n+\t}\n+    }\n+\n+  if (sym1->ts.type == BT_DERIVED && !seen_component_ref)\n+    {\n+      for (cm1 = sym1->ts.u.derived->components; cm1; cm1 = cm1->next)\n+\t{\n+\t  if (cm1->ts.type == BT_DERIVED)\n+\t    return false;\n+\n+\t  if ((sym2->attr.pointer || cm1->attr.pointer)\n+\t\t&& gfc_compare_types (&cm1->ts, &sym2->ts))\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Return true if the statement body redefines the condition.  Returns\n    true if expr2 depends on expr1.  expr1 should be a single term\n    suitable for the lhs of an assignment.  The IDENTICAL flag indicates\n@@ -726,7 +798,13 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n \t  /* If either variable is a pointer, assume the worst.  */\n \t  /* TODO: -fassume-no-pointer-aliasing */\n \t  if (gfc_is_data_pointer (expr1) || gfc_is_data_pointer (expr2))\n-\t    return 1;\n+\t    {\n+\t      if (check_data_pointer_types (expr1, expr2)\n+\t\t    && check_data_pointer_types (expr2, expr1))\n+\t\treturn 0;\n+\n+\t      return 1;\n+\t    }\n \n \t  /* Otherwise distinct symbols have no dependencies.  */\n \t  return 0;"}, {"sha": "2ea978d0ece5c5301fc025920e28403b36b14717", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -5459,7 +5459,7 @@ array_parameter_size (tree desc, gfc_expr *expr, tree *size)\n /* TODO: Optimize passing g77 arrays.  */\n \n void\n-gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n+gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t\t\t  const gfc_symbol *fsym, const char *proc_name,\n \t\t\t  tree *size)\n {\n@@ -5471,6 +5471,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n   bool full_array_var;\n   bool this_array_result;\n   bool contiguous;\n+  bool no_pack;\n   gfc_symbol *sym;\n   stmtblock_t block;\n   gfc_ref *ref;\n@@ -5519,8 +5520,10 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n \t  return;\n \t}\n \n-      if (!sym->attr.pointer && sym->as->type != AS_ASSUMED_SHAPE \n-          && !sym->attr.allocatable)\n+      if (!sym->attr.pointer\n+\t    && sym->as\n+\t    && sym->as->type != AS_ASSUMED_SHAPE \n+            && !sym->attr.allocatable)\n         {\n \t  /* Some variables are declared directly, others are declared as\n \t     pointers and allocated on the heap.  */\n@@ -5547,8 +5550,32 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n         }\n     }\n \n-  if (contiguous && g77 && !this_array_result\n-\t&& !expr->symtree->n.sym->attr.dummy)\n+  /* There is no need to pack and unpack the array, if it is an array\n+     constructor or contiguous and not deferred or assumed shape.  */\n+  no_pack = ((sym && sym->as\n+\t\t  && !sym->attr.pointer\n+\t\t  && sym->as->type != AS_DEFERRED\n+\t\t  && sym->as->type != AS_ASSUMED_SHAPE)\n+\t\t      ||\n+\t     (ref && ref->u.ar.as\n+\t\t  && ref->u.ar.as->type != AS_DEFERRED\n+\t\t  && ref->u.ar.as->type != AS_ASSUMED_SHAPE));\n+\n+  no_pack = g77 && !this_array_result\n+\t\t&& (expr->expr_type == EXPR_ARRAY || (contiguous && no_pack));\n+\n+  if (no_pack)\n+    {\n+      gfc_conv_expr_descriptor (se, expr, ss);\n+      if (expr->ts.type == BT_CHARACTER)\n+\tse->string_length = expr->ts.u.cl->backend_decl;\n+      if (size)\n+\tarray_parameter_size (se->expr, expr, size);\n+      se->expr = gfc_conv_array_data (se->expr);\n+      return;\n+    }\n+\n+  if (expr->expr_type == EXPR_ARRAY && g77)\n     {\n       gfc_conv_expr_descriptor (se, expr, ss);\n       if (expr->ts.type == BT_CHARACTER)\n@@ -5601,7 +5628,6 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n     {\n       desc = se->expr;\n       /* Repack the array.  */\n-\n       if (gfc_option.warn_array_temp)\n \t{\n \t  if (fsym)"}, {"sha": "2a6d2722c7d48fff22312a91a4de736f6e654278", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -111,7 +111,7 @@ void gfc_conv_tmp_ref (gfc_se *);\n /* Evaluate an array expression.  */\n void gfc_conv_expr_descriptor (gfc_se *, gfc_expr *, gfc_ss *);\n /* Convert an array for passing as an actual function parameter.  */\n-void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, int,\n+void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, bool,\n \t\t\t       const gfc_symbol *, const char *, tree *);\n /* Evaluate and transpose a matrix expression.  */\n void gfc_conv_array_transpose (gfc_se *, gfc_expr *);"}, {"sha": "276e6456c2bbd9b979888aec5450eafa2649dbe5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -2827,18 +2827,18 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (!sym->attr.elemental)\n \t{\n \t  gcc_assert (se->ss->type == GFC_SS_FUNCTION);\n-          if (se->ss->useflags)\n-            {\n+\t  if (se->ss->useflags)\n+\t    {\n \t      gcc_assert ((!comp && gfc_return_by_reference (sym)\n \t\t\t   && sym->result->attr.dimension)\n \t\t\t  || (comp && comp->attr.dimension));\n-              gcc_assert (se->loop != NULL);\n+\t      gcc_assert (se->loop != NULL);\n \n-              /* Access the previously obtained result.  */\n-              gfc_conv_tmp_array_ref (se);\n-              gfc_advance_se_ss_chain (se);\n-              return 0;\n-            }\n+\t      /* Access the previously obtained result.  */\n+\t      gfc_conv_tmp_array_ref (se);\n+\t      gfc_advance_se_ss_chain (se);\n+\t      return 0;\n+\t    }\n \t}\n       info = &se->ss->data.info;\n     }\n@@ -2872,9 +2872,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n+\n       if (e == NULL)\n \t{\n-\n \t  if (se->ignore_optional)\n \t    {\n \t      /* Some intrinsics have already been resolved to the correct\n@@ -2883,15 +2883,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    }\n \t  else if (arg->label)\n \t    {\n-              has_alternate_specifier = 1;\n-              continue;\n+\t      has_alternate_specifier = 1;\n+\t      continue;\n \t    }\n \t  else\n \t    {\n \t      /* Pass a NULL pointer for an absent arg.  */\n \t      gfc_init_se (&parmse, NULL);\n \t      parmse.expr = null_pointer_node;\n-              if (arg->missing_arg_type == BT_CHARACTER)\n+\t      if (arg->missing_arg_type == BT_CHARACTER)\n \t\tparmse.string_length = build_int_cst (gfc_charlen_type_node, 0);\n \t    }\n \t}\n@@ -2906,8 +2906,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       else if (se->ss && se->ss->useflags)\n \t{\n \t  /* An elemental function inside a scalarized loop.  */\n-          gfc_init_se (&parmse, se);\n-          gfc_conv_expr_reference (&parmse, e);\n+\t  gfc_init_se (&parmse, se);\n+\t  gfc_conv_expr_reference (&parmse, e);\n \t  parm_kind = ELEMENTAL;\n \t}\n       else\n@@ -2917,7 +2917,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  argss = gfc_walk_expr (e);\n \n \t  if (argss == gfc_ss_terminator)\n-            {\n+\t    {\n \t      if (e->expr_type == EXPR_VARIABLE\n \t\t    && e->symtree->n.sym->attr.cray_pointee\n \t\t    && fsym && fsym->attr.flavor == FL_PROCEDURE)\n@@ -3028,7 +3028,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n                  ALLOCATABLE or assumed shape, we do not use g77's calling\n                  convention, and pass the address of the array descriptor\n                  instead. Otherwise we use g77's calling convention.  */\n-\t      int f;\n+\t      bool f;\n \t      f = (fsym != NULL)\n \t\t  && !(fsym->attr.pointer || fsym->attr.allocatable)\n \t\t  && fsym->as->type != AS_ASSUMED_SHAPE;\n@@ -5036,7 +5036,7 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_start_block (&se.pre);\n   se.want_pointer = 1;\n \n-  gfc_conv_array_parameter (&se, expr1, ss, 0, NULL, NULL, NULL);\n+  gfc_conv_array_parameter (&se, expr1, ss, false, NULL, NULL, NULL);\n \n   if (expr1->ts.type == BT_DERIVED\n \t&& expr1->ts.u.derived->attr.alloc_comp)"}, {"sha": "ae60eb1c7700633fc89cd5640398bab42dac5817", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -4997,7 +4997,7 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n   if (ss == gfc_ss_terminator)\n     gfc_conv_expr_reference (se, arg_expr);\n   else\n-    gfc_conv_array_parameter (se, arg_expr, ss, 1, NULL, NULL, NULL);\n+    gfc_conv_array_parameter (se, arg_expr, ss, true, NULL, NULL, NULL);\n   se->expr= convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);\n    \n   /* Create a temporary variable for loc return value.  Without this, "}, {"sha": "b0d0556af6ddcfd76314b2c1a2591a2d4b6abda2", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -620,7 +620,7 @@ gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n       return;\n     }\n \n-  gfc_conv_array_parameter (se, e, gfc_walk_expr (e), 1, NULL, NULL, &size);\n+  gfc_conv_array_parameter (se, e, gfc_walk_expr (e), true, NULL, NULL, &size);\n   se->string_length = fold_convert (gfc_charlen_type_node, size);\n }\n "}, {"sha": "226c755fbb7108e222dcaec9e51100eb27413d0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -1,3 +1,15 @@\n+2010-02-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/36932\n+\tPR fortran/36933\n+\t* gfortran.dg/dependency_26.f90: New test.\n+\n+\tPR fortran/43072\n+\t* gfortran.dg/internal_pack_7.f90: New test.\n+\n+\tPR fortran/43111\n+\t* gfortran.dg/internal_pack_8.f90: New test.\n+\n 2010-02-20  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 43128"}, {"sha": "df909b48445f0f4ea0541050132ffbfe4fbc4dde", "filename": "gcc/testsuite/gfortran.dg/dependency_26.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_26.f90?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR36932 and PR36933, in which unnecessary\n+! temporaries were being generated.  The module m2 tests the\n+! additional testcase in comment #3 of PR36932.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+MODULE M2\n+  IMPLICIT NONE\n+  TYPE particle\n+   REAL :: r(3)\n+  END TYPE\n+CONTAINS\n+  SUBROUTINE S1(p)\n+     TYPE(particle), POINTER, DIMENSION(:) :: p\n+     REAL :: b(3)\n+     INTEGER :: i\n+     b=pbc(p(i)%r)\n+  END SUBROUTINE S1\n+  FUNCTION pbc(b)\n+     REAL :: b(3)\n+     REAL :: pbc(3)\n+     pbc=b\n+  END FUNCTION\n+END MODULE M2\n+\n+MODULE M1\n+  IMPLICIT NONE\n+  TYPE cell_type\n+     REAL :: h(3,3)\n+  END TYPE\n+CONTAINS\n+  SUBROUTINE S1(cell)\n+     TYPE(cell_type), POINTER :: cell\n+     REAL :: a(3)\n+     REAL :: b(3) = [1, 2, 3]\n+     a=MATMUL(cell%h,b)\n+     if (ANY (INT (a) .ne. [30, 36, 42])) call abort\n+  END SUBROUTINE S1\n+END MODULE M1\n+\n+  use M1\n+  TYPE(cell_type), POINTER :: cell\n+  allocate (cell)\n+  cell%h = reshape ([(real(i), i = 1, 9)], [3, 3])\n+  call s1 (cell)\n+end\n+! { dg-final { cleanup-modules \"M1\" } }\n+! { dg-final { scan-tree-dump-times \"&a\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pack\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "0bc30e508a05e8ce0c47ee0b16220799a8b74008", "filename": "gcc/testsuite/gfortran.dg/internal_pack_7.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_7.f90?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR43072, in which unnecessary calls to\n+! internal PACK/UNPACK were being generated.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+MODULE M1\n+  PRIVATE\n+  REAL, PARAMETER :: c(2)=(/(i,i=1,2)/)\n+CONTAINS\n+  ! WAS OK\n+  SUBROUTINE S0\n+    real :: r\n+     r=0\n+     r=S2(c)\n+     r=S2((/(real(i),i=1,2)/)) ! See comment #1 of the PR\n+  END SUBROUTINE S0\n+  ! WAS NOT OK\n+  SUBROUTINE S1\n+    real :: r\n+     r=0\n+     r=r+S2(c)\n+     r=r+S2((/(real(i),i=1,2)/)) ! See comment #1 of the PR\n+  END SUBROUTINE S1\n+\n+  FUNCTION S2(c)\n+     REAL, INTENT(IN) :: c(2)\n+     s2=0\n+  END FUNCTION S2\n+END MODULE M1\n+! { dg-final { cleanup-modules \"M1\" } }\n+! { dg-final { scan-tree-dump-times \"pack\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "91d6a664639df7170c2123c52afe727326f18f53", "filename": "gcc/testsuite/gfortran.dg/internal_pack_8.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7172b55bb859fd27939374247df4cb0a24f03c0/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_8.f90?ref=f7172b55bb859fd27939374247df4cb0a24f03c0", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR43111, in which necessary calls to\n+! internal PACK/UNPACK were not being generated because\n+! of an over agressive fix to PR41113/7.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+SUBROUTINE S2(I)\n+ INTEGER :: I(4)\n+ !write(6,*) I\n+ IF (ANY(I.NE.(/3,5,7,9/))) CALL ABORT()\n+END SUBROUTINE S2\n+\n+MODULE M1\n+ TYPE T1\n+  INTEGER, POINTER, DIMENSION(:) :: data\n+ END TYPE T1\n+CONTAINS\n+ SUBROUTINE S1()\n+   TYPE(T1) :: d\n+   INTEGER, TARGET, DIMENSION(10) :: scratch=(/(i,i=1,10)/)\n+   INTEGER :: i=2\n+   d%data=>scratch(1:9:2)\n+!   write(6,*) d%data(i:)\n+   CALL S2(d%data(i:))\n+ END SUBROUTINE S1\n+END MODULE M1\n+\n+USE M1\n+CALL S1\n+END\n+! { dg-final { cleanup-modules \"M1\" } }"}]}