{"sha": "41ff0d66b3825f5efbc5bb0135c0348b5ff01244", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmZjBkNjZiMzgyNWY1ZWZiYzViYjAxMzVjMDM0OGI1ZmYwMTI0NA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-03-16T18:35:44Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-03-16T18:35:44Z"}, "message": "[multiple changes]\n\n2008-03-16  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/17_intro/headers/c++200x/all_multiple_inclusion.cc:\n\tUpdate.\n\t* testsuite/17_intro/headers/c++200x/all.cc: Likewise.\n\t* include/precompiled/stdc++.h: Likewise.\n\n2008-03-16  Pedro Lamar\u00e3o  <pedro.lamarao@gmail.com>\n\n\t* include/std/date_time: New file.\n\t* src/date_time.cc: New file.\n \t* config/abi/pre/gnu.ver: Added <date_time> symbols in version\n \tGLIBCXX_3.4.11 and changed two patterns in version GLIBCXX_3.4\n\tthat matched new symbols.\n\t* include/Makefile.am: Add date_time in std headers.\n\t* src/Makefile.am: Add date_time.cc to source files.\n\t* include/Makefile.in: Regenerate.\n\t* src/Makefile.in: Likewise.\n\n2008-03-16  Pedro Lamar\u00e3o  <pedro.lamarao@gmail.com>\n\n      * testsuite/31_date_time/headers/date_time/types_std.cc: New.\n      * testsuite/31_date_time/headers/date_time/std_c++0x_neg.cc: Likewise.\n      * testsuite/31_date_time/headers/date_time/functions_std.cc: Likewise.\n      * testsuite/31_date_time/headers/date_time/synopsis.cc: Likewise.\n      * testsuite/31_date_time/nanoseconds/requirements/traits.cc: Likewise.\n      * testsuite/31_date_time/nanoseconds/requirements/duration.cc: Likewise.\n      * testsuite/31_date_time/system_time/requirements: Likewise.\n      * testsuite/31_date_time/system_time/requirements/traits.cc: Likewise. \t\n\n2008-03-16  Paolo Carlini  <pcarlini@suse.de>\n\n\t* config.h.in: Regenerate.\n\nFrom-SVN: r133278", "tree": {"sha": "33143f8869d24537a67629a926b29158f67bfc48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33143f8869d24537a67629a926b29158f67bfc48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41ff0d66b3825f5efbc5bb0135c0348b5ff01244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ff0d66b3825f5efbc5bb0135c0348b5ff01244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ff0d66b3825f5efbc5bb0135c0348b5ff01244", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ff0d66b3825f5efbc5bb0135c0348b5ff01244/comments", "author": null, "committer": null, "parents": [{"sha": "0c24bb1015bc3961ad468c31114cffb37cc4a06f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c24bb1015bc3961ad468c31114cffb37cc4a06f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c24bb1015bc3961ad468c31114cffb37cc4a06f"}], "stats": {"total": 242, "additions": 242, "deletions": 0}, "files": [{"sha": "792a1408a6ce4df104038414bee2821fc15bf196", "filename": "libstdc++-v3/include/std/date_time", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41ff0d66b3825f5efbc5bb0135c0348b5ff01244/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdate_time", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41ff0d66b3825f5efbc5bb0135c0348b5ff01244/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdate_time", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdate_time?ref=41ff0d66b3825f5efbc5bb0135c0348b5ff01244", "patch": "@@ -0,0 +1,242 @@\n+// <date_time> -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file include/date_time\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_DATE_TIME\n+#define _GLIBCXX_DATE_TIME 1\n+\n+#pragma GCC system_header\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#endif\n+\n+#include <ctime>\n+\n+namespace std\n+{\n+  // duration types\n+  \n+  class nanoseconds\n+  {\n+  public:\n+  \n+    // traits information\n+    typedef long long tick_type;\n+    static const tick_type ticks_per_second = 1000L * 1000 * 1000;\n+    static const tick_type seconds_per_tick = 0;\n+    static const bool is_subsecond = true;\n+  \n+    // construct/copy/destroy\n+    nanoseconds(long long __ns = 0) : _M_ns(__ns) { }\n+  \n+    // modifiers\n+    template<typename _RhsDuration>\n+      nanoseconds&\n+      operator+=(const _RhsDuration& __d);\n+  \n+    template<typename _RhsDuration>\n+      nanoseconds&\n+      operator-=(const _RhsDuration& __d);\n+  \n+    nanoseconds&\n+    operator*=(long __multiplier);\n+  \n+    nanoseconds&\n+    operator/=(long __divisor);\n+  \n+    // observers\n+    tick_type count() const { return _M_ns; }\n+  \n+    // operations\n+    nanoseconds operator-() const { return nanoseconds(-_M_ns); }\n+  \n+  private:\n+    tick_type _M_ns;\n+  };\n+  \n+  class microseconds;\n+  class milliseconds;\n+  class seconds;\n+  class minutes;\n+  class hours;\n+  \n+  // timepoint type\n+  class system_time\n+  {\n+  public:\n+  \n+    // traits information\n+    typedef nanoseconds::tick_type tick_type;\n+    static const tick_type ticks_per_second = nanoseconds::ticks_per_second;\n+    static const tick_type seconds_per_tick = 0;\n+    static const bool is_subsecond = true;\n+  \n+    // create/copy/destroy\n+  \n+    system_time() : _M_sec(0), _M_nsec(0) { }\n+  \n+    explicit system_time(time_t __s, nanoseconds __ns = 0)\n+    : _M_sec(__s), _M_nsec(__ns.count()) { }\n+  \n+    time_t\n+    seconds_since_epoch() const { return _M_sec; }\n+  \n+    nanoseconds\n+    nanoseconds_since_epoch() const\n+    {\n+      return nanoseconds(_M_nsec + _M_sec * ticks_per_second);\n+    }\n+  \n+    // comparison functions\n+  \n+    bool\n+    operator==(const system_time& __rhs) const\n+    {\n+      const tick_type __ns = _M_nsec + _M_sec * ticks_per_second;\n+      const tick_type __xns = __rhs._M_nsec + __rhs._M_sec * ticks_per_second;\n+      return __ns == __xns;\n+    }\n+  \n+    bool\n+    operator!=(const system_time& __rhs) const\n+    {\n+      return !(*this == __rhs);\n+    }\n+  \n+    bool\n+    operator<(const system_time& __rhs) const\n+    {\n+      const tick_type __ns = _M_nsec + _M_sec * ticks_per_second;\n+      const tick_type __xns = __rhs._M_nsec + __rhs._M_sec * ticks_per_second;\n+      return __ns < __xns;\n+    }\n+  \n+    bool\n+    operator<=(const system_time& __rhs) const\n+    {\n+      return !(__rhs < *this);\n+    }\n+  \n+    bool\n+    operator>(const system_time& __rhs) const\n+    {\n+      return __rhs < *this;\n+    }\n+  \n+    bool\n+    operator>=(const system_time& __rhs) const\n+    {\n+      return !(*this < __rhs);\n+    }\n+  \n+    // arithmetic functions\n+    nanoseconds\n+    operator-(const system_time& __rhs) const\n+    {\n+      const tick_type __ns = _M_nsec + _M_sec * ticks_per_second;\n+      const tick_type __xns = __rhs._M_nsec + __rhs._M_sec * ticks_per_second;\n+      return nanoseconds(__ns - __xns);\n+    }\n+  \n+    template<typename _Duration>\n+      system_time\n+      operator+(const _Duration& __td) const;\n+  \n+    template<typename _Duration>\n+      system_time&\n+      operator+=(const _Duration& __td);\n+  \n+    template<typename _Duration>\n+      system_time\n+      operator-(const _Duration& __td) const;\n+  \n+    template<typename _Duration>\n+      system_time&\n+      operator-=(const _Duration& __td);\n+  \n+  public:\n+    std::time_t _M_sec;\n+    tick_type _M_nsec;\n+  };\n+  \n+  // non-member functions\n+  system_time\n+  get_system_time();\n+  \n+  template<typename _Duration>\n+    system_time\n+    operator+(const _Duration& __td, const system_time& __rhs);\n+  \n+  template<class _LhsDuration, class _RhsDuration>\n+    bool\n+    operator==(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  template<class _LhsDuration, class _RhsDuration>\n+    bool\n+    operator!=(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  \n+  template<class _LhsDuration, class _RhsDuration>\n+     bool\n+     operator<(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  template<class _LhsDuration, class _RhsDuration>\n+    bool\n+    operator<=(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  template<class _LhsDuration, class _RhsDuration>\n+    bool\n+    operator>(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  template<class _LhsDuration, class _RhsDuration>\n+    bool\n+    operator>=(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  \n+  template<typename _LhsDuration, typename _RhsDuration>\n+    struct __finest_duration;\n+  \n+  template<class _LhsDuration, class _RhsDuration>\n+    typename __finest_duration<_LhsDuration, _RhsDuration>::type\n+    operator+(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  template<class _LhsDuration, class _RhsDuration>\n+    typename __finest_duration<_LhsDuration, _RhsDuration>::type\n+    operator-(const _LhsDuration& __lhs, const _RhsDuration& __rhs);\n+  \n+  template<class _Duration>\n+    _Duration\n+    operator*(_Duration __lhs, long __rhs);\n+  template<class _Duration>\n+    _Duration\n+    operator*(long __lhs, _Duration __rhs);\n+  \n+  template<class _Duration>\n+    _Duration\n+    operator/(_Duration __lhs, long __rhs);\n+}\n+\n+#endif /* _GLIBCXX_DATE_TIME */"}]}