{"sha": "42495ca044a8ecaf057eb4a6c82a47a562576ab8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI0OTVjYTA0NGE4ZWNhZjA1N2ViNGE2YzgyYTQ3YTU2MjU3NmFiOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-26T11:06:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-26T11:06:07Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1296", "tree": {"sha": "6b86d635f55150afa30d63508d7b707767beab90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b86d635f55150afa30d63508d7b707767beab90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42495ca044a8ecaf057eb4a6c82a47a562576ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42495ca044a8ecaf057eb4a6c82a47a562576ab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42495ca044a8ecaf057eb4a6c82a47a562576ab8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42495ca044a8ecaf057eb4a6c82a47a562576ab8/comments", "author": null, "committer": null, "parents": [{"sha": "3a6e78aded8d4afe5150ce86c036efd096f79db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6e78aded8d4afe5150ce86c036efd096f79db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6e78aded8d4afe5150ce86c036efd096f79db0"}], "stats": {"total": 257, "additions": 196, "deletions": 61}, "files": [{"sha": "eeea4bce52ebbde3f696b21189699f0cca228115", "filename": "gcc/combine.c", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=42495ca044a8ecaf057eb4a6c82a47a562576ab8", "patch": "@@ -1471,17 +1471,31 @@ try_combine (i3, i2, i1)\n       && asm_noperands (newpat) < 0)\n     {\n       rtx m_split, *split;\n+      rtx ni2dest = i2dest;\n \n       /* See if the MD file can split NEWPAT.  If it can't, see if letting it\n-\t use I2DEST as a scratch register will help.  */\n+\t use I2DEST as a scratch register will help.  In the latter case,\n+\t convert I2DEST to the mode of the source of NEWPAT if we can.  */\n \n       m_split = split_insns (newpat, i3);\n       if (m_split == 0)\n-\tm_split = split_insns (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t\t\tgen_rtvec (2, newpat,\n-\t\t\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t\t\t    i2dest))),\n-\t\t\t       i3);\n+\t{\n+\t  /* If I2DEST is a hard register or the only use of a pseudo,\n+\t     we can change its mode.  */\n+\t  if (GET_MODE (SET_DEST (newpat)) != GET_MODE (i2dest)\n+\t      && (REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n+\t\t  || (reg_n_sets[REGNO (i2dest)] == 1 && ! added_sets_2\n+\t\t      && ! REG_USERVAR_P (i2dest))))\n+\t    ni2dest = gen_rtx (REG, GET_MODE (SET_DEST (newpat)),\n+\t\t\t       REGNO (i2dest));\n+\n+\t  m_split = split_insns (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t\t  gen_rtvec (2, newpat,\n+\t\t\t\t\t\t     gen_rtx (CLOBBER,\n+\t\t\t\t\t\t\t      VOIDmode,\n+\t\t\t\t\t\t\t      ni2dest))),\n+\t\t\t\t i3);\n+\t}\n \n       if (m_split && GET_CODE (m_split) == SEQUENCE\n \t  && XVECLEN (m_split, 0) == 2\n@@ -1492,6 +1506,13 @@ try_combine (i3, i2, i1)\n \t  newi2pat = PATTERN (XVECEXP (m_split, 0, 0));\n \t  newpat = PATTERN (XVECEXP (m_split, 0, 1));\n \n+\t  /* In case we changed the mode of I2DEST, replace it in the\n+\t     pseudo-register table here.  We can't do it above in case this\n+\t     code doesn't get executed and we do a split the other way.  */\n+\n+\t  if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n+\t    SUBST (regno_reg_rtx[REGNO (i2dest)], ni2dest);\n+\n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \t  if (i2_code_number >= 0)\n \t    insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n@@ -2945,6 +2966,18 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t\t      - INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n \t  goto restart;\n \t}\n+\n+      /* If we are adding two things that have no bits in common, convert\n+\t the addition into an IOR.  This will often be further simplified,\n+\t for example in cases like ((a & 1) + (a & 2)), which can\n+\t become a & 3.  */\n+\n+      if ((significant_bits (XEXP (x, 0), mode)\n+\t   & significant_bits (XEXP (x, 1), mode)) == 0)\n+\t{\n+\t  x = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n+\t  goto restart;\n+\t}\n       break;\n \n     case MULT:\n@@ -4194,8 +4227,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n    We try, as much as possible, to re-use rtl expressions to save memory.\n \n    IN_CODE says what kind of expression we are processing.  Normally, it is\n-   SET.  In a memory address (inside a MEM or PLUS, the latter being a\n-   kludge), it is MEM.  When processing the arguments of a comparison\n+   SET.  In a memory address (inside a MEM, PLUS or minus, the latter two\n+   being kludges), it is MEM.  When processing the arguments of a comparison\n    or a COMPARE against zero, it is COMPARE.  */\n \n static rtx\n@@ -4215,7 +4248,7 @@ make_compound_operation (x, in_code)\n      address, we stay there.  If we have a comparison, set to COMPARE,\n      but once inside, go back to our default of SET.  */\n \n-  next_code = (code == MEM || code == PLUS ? MEM\n+  next_code = (code == MEM || code == PLUS || code == MINUS ? MEM\n \t       : ((code == COMPARE || GET_RTX_CLASS (code) == '<')\n \t\t  && XEXP (x, 1) == const0_rtx) ? COMPARE\n \t       : in_code == COMPARE ? SET : in_code);"}, {"sha": "c39174d89df218b711868f34863125f3e09b3281", "filename": "gcc/cse.c", "status": "modified", "additions": 124, "deletions": 41, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=42495ca044a8ecaf057eb4a6c82a47a562576ab8", "patch": "@@ -2451,8 +2451,9 @@ find_best_addr (insn, loc)\n       && validate_change (insn, loc, fold_rtx (addr, insn), 0))\n     addr = *loc;\n \t\n-  /* If this address is not in the hash table, we can't do any better.\n-     Also, ignore if volatile.  */\n+  /* If this address is not in the hash table, we can't look for equivalences\n+     of the whole address.  Also, ignore if volatile.  */\n+\n   do_not_record = 0;\n   hash_code = HASH (addr, Pmode);\n   addr_volatile = do_not_record;\n@@ -2465,56 +2466,138 @@ find_best_addr (insn, loc)\n \n   elt = lookup (addr, hash_code, Pmode);\n \n-  if (elt == 0)\n-    return;\n-\n #ifndef ADDRESS_COST\n-  our_cost = elt->cost;\n-\n-  /* Find the lowest cost below ours that works.  */\n-  for (elt = elt->first_same_value; elt; elt = elt->next_same_value)\n-    if (elt->cost < our_cost\n-\t&& (GET_CODE (elt->exp) == REG || exp_equiv_p (elt->exp, elt->exp, 1, 0))\n-\t&& validate_change (insn, loc, canon_reg (copy_rtx (elt->exp), 0), 0))\n-      return;\n+  if (elt)\n+    {\n+      our_cost = elt->cost;\n \n+      /* Find the lowest cost below ours that works.  */\n+      for (elt = elt->first_same_value; elt; elt = elt->next_same_value)\n+\tif (elt->cost < our_cost\n+\t    && (GET_CODE (elt->exp) == REG\n+\t\t|| exp_equiv_p (elt->exp, elt->exp, 1, 0))\n+\t    && validate_change (insn, loc,\n+\t\t\t\tcanon_reg (copy_rtx (elt->exp), 0), 0))\n+\t  return;\n+    }\n #else\n \n-  /* We need to find the best (under the criteria documented above) entry in\n-     the class that is valid.  We use the `flag' field to indicate choices\n-     that were invalid and iterate until we can't find a better one that\n-     hasn't already been tried.  */\n+  if (elt)\n+    {\n+      /* We need to find the best (under the criteria documented above) entry\n+\t in the class that is valid.  We use the `flag' field to indicate\n+\t choices that were invalid and iterate until we can't find a better\n+\t one that hasn't already been tried.  */\n \n-  for (p = elt->first_same_value; p; p = p->next_same_value)\n-    p->flag = 0;\n+      for (p = elt->first_same_value; p; p = p->next_same_value)\n+\tp->flag = 0;\n \n-  while (found_better)\n+      while (found_better)\n+\t{\n+\t  int best_addr_cost = ADDRESS_COST (*loc);\n+\t  int best_rtx_cost = (elt->cost + 1) >> 1;\n+\t  struct table_elt *best_elt = elt; \n+\n+\t  found_better = 0;\n+\t  for (p = elt->first_same_value; p; p = p->next_same_value)\n+\t    if (! p->flag\n+\t\t&& (GET_CODE (p->exp) == REG\n+\t\t    || exp_equiv_p (p->exp, p->exp, 1, 0))\n+\t\t&& (ADDRESS_COST (p->exp) < best_addr_cost\n+\t\t    || (ADDRESS_COST (p->exp) == best_addr_cost\n+\t\t\t&& (p->cost + 1) >> 1 > best_rtx_cost)))\n+\t      {\n+\t\tfound_better = 1;\n+\t\tbest_addr_cost = ADDRESS_COST (p->exp);\n+\t\tbest_rtx_cost = (p->cost + 1) >> 1;\n+\t\tbest_elt = p;\n+\t      }\n+\n+\t  if (found_better)\n+\t    {\n+\t      if (validate_change (insn, loc,\n+\t\t\t\t   canon_reg (copy_rtx (best_elt->exp), 0), 0))\n+\t\treturn;\n+\t      else\n+\t\tbest_elt->flag = 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* If the address is a binary operation with the first operand a register\n+     and the second a constant, do the same as above, but looking for\n+     equivalences of the register.  Then try to simplify before checking for\n+     the best address to use.  This catches a few cases:  First is when we\n+     have REG+const and the register is another REG+const.  We can often merge\n+     the constants and eliminate one insn and one register.  It may also be\n+     that a machine has a cheap REG+REG+const.  Finally, this improves the\n+     code on the Alpha for unaligned byte stores.  */\n+\n+  if (flag_expensive_optimizations\n+      && (GET_RTX_CLASS (GET_CODE (*loc)) == '2'\n+\t  || GET_RTX_CLASS (GET_CODE (*loc)) == 'c')\n+      && GET_CODE (XEXP (*loc, 0)) == REG\n+      && GET_CODE (XEXP (*loc, 1)) == CONST_INT)\n     {\n-      int best_addr_cost = ADDRESS_COST (*loc);\n-      int best_rtx_cost = (elt->cost + 1) >> 1;\n-      struct table_elt *best_elt = elt; \n+      rtx c = XEXP (*loc, 1);\n+\n+      do_not_record = 0;\n+      hash_code = HASH (XEXP (*loc, 0), Pmode);\n+      do_not_record = save_do_not_record;\n+      hash_arg_in_memory = save_hash_arg_in_memory;\n+      hash_arg_in_struct = save_hash_arg_in_struct;\n+\n+      elt = lookup (XEXP (*loc, 0), hash_code, Pmode);\n+      if (elt == 0)\n+\treturn;\n+\n+      /* We need to find the best (under the criteria documented above) entry\n+\t in the class that is valid.  We use the `flag' field to indicate\n+\t choices that were invalid and iterate until we can't find a better\n+\t one that hasn't already been tried.  */\n \n-      found_better = 0;\n       for (p = elt->first_same_value; p; p = p->next_same_value)\n-\tif (! p->flag\n-\t    && (GET_CODE (p->exp) == REG || exp_equiv_p (p->exp, p->exp, 1, 0))\n-\t    && (ADDRESS_COST (p->exp) < best_addr_cost\n-\t\t|| (ADDRESS_COST (p->exp) == best_addr_cost\n-\t\t    && (p->cost + 1) >> 1 > best_rtx_cost)))\n-\t  {\n-\t    found_better = 1;\n-\t    best_addr_cost = ADDRESS_COST (p->exp);\n-\t    best_rtx_cost = (p->cost + 1) >> 1;\n-\t    best_elt = p;\n-\t  }\n+\tp->flag = 0;\n \n-      if (found_better)\n+      while (found_better)\n \t{\n-\t  if (validate_change (insn, loc,\n-\t\t\t       canon_reg (copy_rtx (best_elt->exp), 0), 0))\n-\t    return;\n-\t  else\n-\t    best_elt->flag = 1;\n+\t  int best_addr_cost = ADDRESS_COST (*loc);\n+\t  int best_rtx_cost = (COST (*loc) + 1) >> 1;\n+\t  struct table_elt *best_elt = elt; \n+\t  rtx best_rtx = *loc;\n+\n+\t  found_better = 0;\n+\t  for (p = elt->first_same_value; p; p = p->next_same_value)\n+\t    if (! p->flag\n+\t\t&& (GET_CODE (p->exp) == REG\n+\t\t    || exp_equiv_p (p->exp, p->exp, 1, 0)))\n+\t      {\n+\t\trtx new = simplify_binary_operation (GET_CODE (*loc), Pmode,\n+\t\t\t\t\t\t     p->exp, c);\n+\n+\t\tif (new == 0)\n+\t\t  new = gen_rtx (GET_CODE (*loc), Pmode, p->exp, c);\n+\n+\t\tif ((ADDRESS_COST (new) < best_addr_cost\n+\t\t    || (ADDRESS_COST (new) == best_addr_cost\n+\t\t\t&& (COST (new) + 1) >> 1 > best_rtx_cost)))\n+\t\t  {\n+\t\t    found_better = 1;\n+\t\t    best_addr_cost = ADDRESS_COST (new);\n+\t\t    best_rtx_cost = (COST (new) + 1) >> 1;\n+\t\t    best_elt = p;\n+\t\t    best_rtx = new;\n+\t\t  }\n+\t      }\n+\n+\t  if (found_better)\n+\t    {\n+\t      if (validate_change (insn, loc,\n+\t\t\t\t   canon_reg (copy_rtx (best_rtx), 0), 0))\n+\t\treturn;\n+\t      else\n+\t\tbest_elt->flag = 1;\n+\t    }\n \t}\n     }\n #endif"}, {"sha": "99d347db63f9f27112c70f76e4672e90cb7afc6e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=42495ca044a8ecaf057eb4a6c82a47a562576ab8", "patch": "@@ -2134,7 +2134,6 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \n #if BYTES_BIG_ENDIAN\n   lbitpos = lnbitsize - lbitsize - lbitpos;\n-  rbitpos = rnbitsize - rbitsize - rbitpos;\n #endif\n \n   /* Make the mask to be used against the extracted field.  */"}, {"sha": "96cad8c4b9abe46a62757e66d7e90c5075928a04", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=42495ca044a8ecaf057eb4a6c82a47a562576ab8", "patch": "@@ -846,6 +846,7 @@ gen_split (split)\n   mybzero (d->strict_low, sizeof strict_low);\n \n   d->n_dups = 0;\n+  d->n_alternatives = 0;\n   d->template = 0;\n   d->outfun = 0;\n   d->n_alternatives = 0;"}, {"sha": "7abf935f407bf2f199c7e3d53c7b11ba4b68c936", "filename": "gcc/stmt.c", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42495ca044a8ecaf057eb4a6c82a47a562576ab8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=42495ca044a8ecaf057eb4a6c82a47a562576ab8", "patch": "@@ -2546,16 +2546,35 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n #if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n       if (fixed_regs[ARG_POINTER_REGNUM])\n \t{\n-\t  /* Now restore our arg pointer from the address at which it was saved\n-\t     in our stack frame.\n-\t     If there hasn't be space allocated for it yet, make some now.  */\n-\t  if (arg_pointer_save_area == 0)\n-\t    arg_pointer_save_area\n-\t      = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-\t  emit_move_insn (virtual_incoming_args_rtx,\n-\t\t\t  /* We need a pseudo here,\n-\t\t\t     or else instantiate_virtual_regs_1 complains.  */\n-\t\t\t  copy_to_reg (arg_pointer_save_area));\n+#ifdef ELIMINABLE_REGS\n+\t  /* If the argument pointer can be eliminated in favor of the\n+\t     frame pointer, we don't need to restore it.  We assume here\n+\t     that if such an elimination is present, it can always be used.\n+\t     This is the case on all known machines; if we don't make this\n+\t     assumption, we do unnecessary saving on many machines.  */\n+\t  static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n+\t  int i;\n+\n+\t  for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n+\t    if (elim_regs[i].from == ARG_POINTER_REGNUM\n+\t\t&& elim_regs[i].to == FRAME_POINTER_REGNUM)\n+\t      break;\n+\n+\t  if (i == sizeof elim_regs / sizeof elim_regs [0])\n+#endif\n+\t    {\n+\t      /* Now restore our arg pointer from the address at which it\n+\t\t was saved in our stack frame.\n+\t\t If there hasn't be space allocated for it yet, make\n+\t\t some now.  */\n+\t      if (arg_pointer_save_area == 0)\n+\t\targ_pointer_save_area\n+\t\t  = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+\t      emit_move_insn (virtual_incoming_args_rtx,\n+\t\t\t      /* We need a pseudo here, or else\n+\t\t\t\t instantiate_virtual_regs_1 complains.  */\n+\t\t\t      copy_to_reg (arg_pointer_save_area));\n+\t    }\n \t}\n #endif\n "}]}