{"sha": "f7191ecdbd3adad32b561db40fac6978df6409fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxOTFlY2RiZDNhZGFkMzJiNTYxZGI0MGZhYzY5NzhkZjY0MDlmZQ==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2013-10-11T03:15:33Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-11T03:15:33Z"}, "message": "compiler: Use backend interface for function declarations.\n\n\t* go-gcc.cc (Backend::error_function): New function.\n\t(Backend::function): New function.\n\t(Backend::make_function): New function.\n\t(function_to_tree): New function.\n\nFrom-SVN: r203403", "tree": {"sha": "5f41fdf78ab663a67c63db5beabf5b7175f799ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f41fdf78ab663a67c63db5beabf5b7175f799ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7191ecdbd3adad32b561db40fac6978df6409fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7191ecdbd3adad32b561db40fac6978df6409fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7191ecdbd3adad32b561db40fac6978df6409fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7191ecdbd3adad32b561db40fac6978df6409fe/comments", "author": null, "committer": null, "parents": [{"sha": "cf5e3504b55071f73420c3ab7756200b1dad7b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5e3504b55071f73420c3ab7756200b1dad7b7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5e3504b55071f73420c3ab7756200b1dad7b7a"}], "stats": {"total": 677, "additions": 368, "deletions": 309}, "files": [{"sha": "6d6217b266e7661b25f0bde46989715a4d6c6510", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -1,3 +1,10 @@\n+2013-10-10  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Backend::error_function): New function.\n+\t(Backend::function): New function.\n+\t(Backend::make_function): New function.\n+\t(function_to_tree): New function.\n+\n 2013-10-04  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Backend::convert_expression): New function."}, {"sha": "6b77d947c9c2bbad676399583646bea363ecefff", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -334,6 +334,17 @@ class Gcc_backend : public Backend\n   Bexpression*\n   label_address(Blabel*, Location);\n \n+  // Functions.\n+\n+  Bfunction*\n+  error_function()\n+  { return this->make_function(error_mark_node); }\n+\n+  Bfunction*\n+  function(Btype* fntype, const std::string& name, const std::string& asm_name,\n+           bool is_visible, bool is_declaration, bool is_inlinable,\n+           bool disable_split_stack, bool in_unique_section, Location);\n+\n  private:\n   // Make a Bexpression from a tree.\n   Bexpression*\n@@ -350,6 +361,10 @@ class Gcc_backend : public Backend\n   make_type(tree t)\n   { return new Btype(t); }\n \n+  Bfunction*\n+  make_function(tree t)\n+  { return new Bfunction(t); }\n+\n   Btype*\n   fill_in_struct(Btype*, const std::vector<Btyped_identifier>&);\n \n@@ -1724,6 +1739,56 @@ Gcc_backend::label_address(Blabel* label, Location location)\n   return this->make_expression(ret);\n }\n \n+// Declare or define a new function.\n+\n+Bfunction*\n+Gcc_backend::function(Btype* fntype, const std::string& name,\n+                      const std::string& asm_name, bool is_visible,\n+                      bool is_declaration, bool is_inlinable,\n+                      bool disable_split_stack, bool in_unique_section,\n+                      Location location)\n+{\n+  tree functype = fntype->get_tree();\n+  if (functype != error_mark_node)\n+    {\n+      gcc_assert(FUNCTION_POINTER_TYPE_P(functype));\n+      functype = TREE_TYPE(functype);\n+    }\n+  tree id = get_identifier_from_string(name);\n+  if (functype == error_mark_node || id == error_mark_node)\n+    return this->error_function();\n+\n+  tree decl = build_decl(location.gcc_location(), FUNCTION_DECL, id, functype);\n+  if (!asm_name.empty())\n+    SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+  if (is_visible)\n+    TREE_PUBLIC(decl) = 1;\n+  if (is_declaration)\n+    DECL_EXTERNAL(decl) = 1;\n+  else\n+    {\n+      tree restype = TREE_TYPE(functype);\n+      tree resdecl =\n+          build_decl(location.gcc_location(), RESULT_DECL, NULL_TREE, restype);\n+      DECL_ARTIFICIAL(resdecl) = 1;\n+      DECL_IGNORED_P(resdecl) = 1;\n+      DECL_CONTEXT(resdecl) = decl;\n+      DECL_RESULT(decl) = resdecl;\n+    }\n+  if (!is_inlinable)\n+    DECL_UNINLINABLE(decl) = 1;\n+  if (disable_split_stack)\n+    {\n+      tree attr = get_identifier(\"__no_split_stack__\");\n+      DECL_ATTRIBUTES(decl) = tree_cons(attr, NULL_TREE, NULL_TREE);\n+    }\n+  if (in_unique_section)\n+    resolve_unique_section(decl, 0, 1);\n+\n+  go_preserve_from_gc(decl);\n+  return new Bfunction(decl);\n+}\n+\n // The single backend.\n \n static Gcc_backend gcc_backend;\n@@ -1799,3 +1864,9 @@ var_to_tree(Bvariable* bv)\n {\n   return bv->get_tree();\n }\n+\n+tree\n+function_to_tree(Bfunction* bf)\n+{\n+  return bf->get_tree();\n+}"}, {"sha": "e73c98ca68a0319e631088f46954351740b5aa19", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -23,7 +23,7 @@ class Bexpression;\n // The backend representation of a statement.\n class Bstatement;\n \n-// The backend representation of a function definition.\n+// The backend representation of a function definition or declaration.\n class Bfunction;\n \n // The backend representation of a block.\n@@ -498,6 +498,32 @@ class Backend\n   // recover.\n   virtual Bexpression*\n   label_address(Blabel*, Location) = 0;\n+\n+  // Functions.\n+\n+  // Create an error function.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bfunction*\n+  error_function() = 0;\n+\n+  // Declare or define a function of FNTYPE.\n+  // NAME is the Go name of the function. ASM_NAME, if not the empty string, is\n+  // the name that should be used in the symbol table; this will be non-empty if\n+  // a magic extern comment is used.\n+  // IS_VISIBLE is true if this function should be visible outside of the\n+  // current compilation unit. IS_DECLARATION is true if this is a function\n+  // declaration rather than a definition; the function definition will be in\n+  // another compilation unit.\n+  // IS_INLINABLE is true if the function can be inlined.\n+  // DISABLE_SPLIT_STACK is true if this function may not split the stack; this\n+  // is used for the implementation of recover.\n+  // IN_UNIQUE_SECTION is true if this function should be put into a unique\n+  // location if possible; this is used for field tracking.\n+  virtual Bfunction*\n+  function(Btype* fntype, const std::string& name, const std::string& asm_name,\n+           bool is_visible, bool is_declaration, bool is_inlinable,\n+           bool disable_split_stack, bool in_unique_section, Location) = 0;\n };\n \n // The backend interface has to define this function.\n@@ -517,5 +543,6 @@ extern tree expr_to_tree(Bexpression*);\n extern tree stat_to_tree(Bstatement*);\n extern tree block_to_tree(Bblock*);\n extern tree var_to_tree(Bvariable*);\n+extern tree function_to_tree(Bfunction*);\n \n #endif // !defined(GO_BACKEND_H)"}, {"sha": "37f8822f73b8787e61ae88c43754bf5c397fd5aa", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -1240,15 +1240,11 @@ Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n       return error_mark_node;\n     }\n \n-  tree id = no->get_id(gogo);\n-  if (id == error_mark_node)\n-    return error_mark_node;\n-\n   tree fndecl;\n   if (no->is_function())\n-    fndecl = no->func_value()->get_or_make_decl(gogo, no, id);\n+    fndecl = no->func_value()->get_or_make_decl(gogo, no);\n   else if (no->is_function_declaration())\n-    fndecl = no->func_declaration_value()->get_or_make_decl(gogo, no, id);\n+    fndecl = no->func_declaration_value()->get_or_make_decl(gogo, no);\n   else\n     go_unreachable();\n \n@@ -9825,14 +9821,8 @@ Call_expression::do_get_tree(Translate_context* context)\n     }\n \n   tree fntype_tree = type_to_tree(fntype->get_backend(gogo));\n-  if (fntype_tree == error_mark_node)\n-    return error_mark_node;\n-  go_assert(POINTER_TYPE_P(fntype_tree));\n-  if (TREE_TYPE(fntype_tree) == error_mark_node)\n-    return error_mark_node;\n-  go_assert(TREE_CODE(TREE_TYPE(fntype_tree)) == RECORD_TYPE);\n-  tree fnfield_type = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(fntype_tree)));\n-  if (fnfield_type == error_mark_node)\n+  tree fnfield_type = type_to_tree(fntype->get_backend_fntype(gogo));\n+  if (fntype_tree == error_mark_node || fnfield_type == error_mark_node)\n     return error_mark_node;\n   go_assert(FUNCTION_POINTER_TYPE_P(fnfield_type));\n   tree rettype = TREE_TYPE(TREE_TYPE(fnfield_type));"}, {"sha": "78a8c6a724b25703770a2967212cd6cb50f68872", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 108, "deletions": 233, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -985,74 +985,6 @@ Gogo::write_globals()\n   delete[] vec;\n }\n \n-// Get a tree for the identifier for a named object.\n-\n-tree\n-Named_object::get_id(Gogo* gogo)\n-{\n-  go_assert(!this->is_variable() && !this->is_result_variable());\n-  std::string decl_name;\n-  if (this->is_function_declaration()\n-      && !this->func_declaration_value()->asm_name().empty())\n-    decl_name = this->func_declaration_value()->asm_name();\n-  else if (this->is_type()\n-\t   && Linemap::is_predeclared_location(this->type_value()->location()))\n-    {\n-      // We don't need the package name for builtin types.\n-      decl_name = Gogo::unpack_hidden_name(this->name_);\n-    }\n-  else\n-    {\n-      std::string package_name;\n-      if (this->package_ == NULL)\n-\tpackage_name = gogo->package_name();\n-      else\n-\tpackage_name = this->package_->package_name();\n-\n-      // Note that this will be misleading if this is an unexported\n-      // method generated for an embedded imported type.  In that case\n-      // the unexported method should have the package name of the\n-      // package from which it is imported, but we are going to give\n-      // it our package name.  Fixing this would require knowing the\n-      // package name, but we only know the package path.  It might be\n-      // better to use package paths here anyhow.  This doesn't affect\n-      // the assembler code, because we always set that name in\n-      // Function::get_or_make_decl anyhow.  FIXME.\n-\n-      decl_name = package_name + '.' + Gogo::unpack_hidden_name(this->name_);\n-\n-      Function_type* fntype;\n-      if (this->is_function())\n-\tfntype = this->func_value()->type();\n-      else if (this->is_function_declaration())\n-\tfntype = this->func_declaration_value()->type();\n-      else\n-\tfntype = NULL;\n-      if (fntype != NULL && fntype->is_method())\n-\t{\n-\t  decl_name.push_back('.');\n-\t  decl_name.append(fntype->receiver()->type()->mangled_name(gogo));\n-\t}\n-    }\n-  if (this->is_type())\n-    {\n-      unsigned int index;\n-      const Named_object* in_function = this->type_value()->in_function(&index);\n-      if (in_function != NULL)\n-\t{\n-\t  decl_name += '$' + Gogo::unpack_hidden_name(in_function->name());\n-\t  if (index > 0)\n-\t    {\n-\t      char buf[30];\n-\t      snprintf(buf, sizeof buf, \"%u\", index);\n-\t      decl_name += '$';\n-\t      decl_name += buf;\n-\t    }\n-\t}\n-    }\n-  return get_identifier_from_string(decl_name);\n-}\n-\n // Get a tree for a named object.\n \n tree\n@@ -1067,11 +999,6 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n       return error_mark_node;\n     }\n \n-  tree name;\n-  if (this->classification_ == NAMED_OBJECT_TYPE)\n-    name = NULL_TREE;\n-  else\n-    name = this->get_id(gogo);\n   tree decl;\n   switch (this->classification_)\n     {\n@@ -1099,6 +1026,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t      decl = error_mark_node;\n \t    else if (INTEGRAL_TYPE_P(TREE_TYPE(expr_tree)))\n \t      {\n+                tree name = get_identifier_from_string(this->get_id(gogo));\n \t\tdecl = build_decl(named_constant->location().gcc_location(),\n                                   CONST_DECL, name, TREE_TYPE(expr_tree));\n \t\tDECL_INITIAL(decl) = expr_tree;\n@@ -1161,7 +1089,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n     case NAMED_OBJECT_FUNC:\n       {\n \tFunction* func = this->u_.func_value;\n-\tdecl = func->get_or_make_decl(gogo, this, name);\n+\tdecl = func->get_or_make_decl(gogo, this);\n \tif (decl != error_mark_node)\n \t  {\n \t    if (func->block() != NULL)\n@@ -1289,120 +1217,83 @@ Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n // Get a tree for a function decl.\n \n tree\n-Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n+Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n {\n-  if (this->fndecl_ == NULL_TREE)\n+  if (this->fndecl_ == NULL)\n     {\n-      tree functype = type_to_tree(this->type_->get_backend(gogo));\n-\n-      if (functype != error_mark_node)\n-\t{\n-\t  // The type of a function comes back as a pointer to a\n-\t  // struct whose first field is the function, but we want the\n-\t  // real function type for a function declaration.\n-\t  go_assert(POINTER_TYPE_P(functype)\n-\t\t    && TREE_CODE(TREE_TYPE(functype)) == RECORD_TYPE);\n-\t  functype = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(functype)));\n-\t  go_assert(FUNCTION_POINTER_TYPE_P(functype));\n-\t  functype = TREE_TYPE(functype);\n-\t}\n-\n-      if (functype == error_mark_node)\n-\tthis->fndecl_ = error_mark_node;\n-      else\n-\t{\n-\t  tree decl = build_decl(this->location().gcc_location(), FUNCTION_DECL,\n-                                 id, functype);\n-\n-\t  this->fndecl_ = decl;\n-\n-\t  if (no->package() != NULL)\n-\t    ;\n-\t  else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n-\t    ;\n-\t  else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n-\t\t   && !this->type_->is_method())\n-\t    ;\n-\t  else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n-\t\t   && gogo->is_main_package())\n-\t    TREE_PUBLIC(decl) = 1;\n-\t  // Methods have to be public even if they are hidden because\n-\t  // they can be pulled into type descriptors when using\n-\t  // anonymous fields.\n-\t  else if (!Gogo::is_hidden_name(no->name())\n-\t\t   || this->type_->is_method())\n-\t    {\n-\t      TREE_PUBLIC(decl) = 1;\n-\t      std::string pkgpath = gogo->pkgpath_symbol();\n-\t      if (this->type_->is_method()\n-\t\t  && Gogo::is_hidden_name(no->name())\n-\t\t  && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n-\t\t{\n-\t\t  // This is a method we created for an unexported\n-\t\t  // method of an imported embedded type.  We need to\n-\t\t  // use the pkgpath of the imported package to avoid\n-\t\t  // a possible name collision.  See bug478 for a test\n-\t\t  // case.\n-\t\t  pkgpath = Gogo::hidden_name_pkgpath(no->name());\n-\t\t  pkgpath = Gogo::pkgpath_for_symbol(pkgpath);\n-\t\t}\n-\n-\t      std::string asm_name = pkgpath;\n-\t      asm_name.append(1, '.');\n-\t      asm_name.append(Gogo::unpack_hidden_name(no->name()));\n-\t      if (this->type_->is_method())\n-\t\t{\n-\t\t  asm_name.append(1, '.');\n-\t\t  Type* rtype = this->type_->receiver()->type();\n-\t\t  asm_name.append(rtype->mangled_name(gogo));\n-\t\t}\n-\t      SET_DECL_ASSEMBLER_NAME(decl,\n-\t\t\t\t      get_identifier_from_string(asm_name));\n-\t    }\n-\n-\t  // Why do we have to do this in the frontend?\n-\t  tree restype = TREE_TYPE(functype);\n-\t  tree resdecl =\n-            build_decl(this->location().gcc_location(), RESULT_DECL, NULL_TREE,\n-                       restype);\n-\t  DECL_ARTIFICIAL(resdecl) = 1;\n-\t  DECL_IGNORED_P(resdecl) = 1;\n-\t  DECL_CONTEXT(resdecl) = decl;\n-\t  DECL_RESULT(decl) = resdecl;\n-\n-\t  // If a function calls the predeclared recover function, we\n-\t  // can't inline it, because recover behaves differently in a\n-\t  // function passed directly to defer.  If this is a recover\n-\t  // thunk that we built to test whether a function can be\n-\t  // recovered, we can't inline it, because that will mess up\n-\t  // our return address comparison.\n-\t  if (this->calls_recover_ || this->is_recover_thunk_)\n-\t    DECL_UNINLINABLE(decl) = 1;\n-\n-\t  // If this is a thunk created to call a function which calls\n-\t  // the predeclared recover function, we need to disable\n-\t  // stack splitting for the thunk.\n-\t  if (this->is_recover_thunk_)\n-\t    {\n-\t      tree attr = get_identifier(\"__no_split_stack__\");\n-\t      DECL_ATTRIBUTES(decl) = tree_cons(attr, NULL_TREE, NULL_TREE);\n-\t    }\n-\n-\t  if (this->in_unique_section_)\n-\t    resolve_unique_section (decl, 0, 1);\n+      std::string asm_name;\n+      bool is_visible = false;\n+      if (no->package() != NULL)\n+        ;\n+      else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n+        ;\n+      else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n+               && !this->type_->is_method())\n+        ;\n+      else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n+               && gogo->is_main_package())\n+        is_visible = true;\n+      // Methods have to be public even if they are hidden because\n+      // they can be pulled into type descriptors when using\n+      // anonymous fields.\n+      else if (!Gogo::is_hidden_name(no->name())\n+               || this->type_->is_method())\n+        {\n+          is_visible = true;\n+          std::string pkgpath = gogo->pkgpath_symbol();\n+          if (this->type_->is_method()\n+              && Gogo::is_hidden_name(no->name())\n+              && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n+            {\n+              // This is a method we created for an unexported\n+              // method of an imported embedded type.  We need to\n+              // use the pkgpath of the imported package to avoid\n+              // a possible name collision.  See bug478 for a test\n+              // case.\n+              pkgpath = Gogo::hidden_name_pkgpath(no->name());\n+              pkgpath = Gogo::pkgpath_for_symbol(pkgpath);\n+            }\n+\n+          asm_name = pkgpath;\n+          asm_name.append(1, '.');\n+          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n+          if (this->type_->is_method())\n+            {\n+              asm_name.append(1, '.');\n+              Type* rtype = this->type_->receiver()->type();\n+              asm_name.append(rtype->mangled_name(gogo));\n+            }\n+        }\n \n-\t  go_preserve_from_gc(decl);\n-\t}\n+      // If a function calls the predeclared recover function, we\n+      // can't inline it, because recover behaves differently in a\n+      // function passed directly to defer.  If this is a recover\n+      // thunk that we built to test whether a function can be\n+      // recovered, we can't inline it, because that will mess up\n+      // our return address comparison.\n+      bool is_inlinable = !(this->calls_recover_ || this->is_recover_thunk_);\n+\n+      // If this is a thunk created to call a function which calls\n+      // the predeclared recover function, we need to disable\n+      // stack splitting for the thunk.\n+      bool disable_split_stack = this->is_recover_thunk_;\n+\n+      Btype* functype = this->type_->get_backend_fntype(gogo);\n+      this->fndecl_ =\n+          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n+                                    is_visible, false, is_inlinable,\n+                                    disable_split_stack,\n+                                    this->in_unique_section_, this->location());\n     }\n-  return this->fndecl_;\n+  return function_to_tree(this->fndecl_);\n }\n \n // Get a tree for a function declaration.\n \n tree\n-Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n+Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n {\n-  if (this->fndecl_ == NULL_TREE)\n+  if (this->fndecl_ == NULL)\n     {\n       // Let Go code use an asm declaration to pick up a builtin\n       // function.\n@@ -1412,56 +1303,44 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t    builtin_functions.find(this->asm_name_);\n \t  if (p != builtin_functions.end())\n \t    {\n-\t      this->fndecl_ = p->second;\n-\t      return this->fndecl_;\n+\t      this->fndecl_ = tree_to_function(p->second);\n+\t      return p->second;\n \t    }\n \t}\n \n-      tree functype = type_to_tree(this->fntype_->get_backend(gogo));\n+      std::string asm_name;\n+      if (this->asm_name_.empty())\n+        {\n+          asm_name = (no->package() == NULL\n+                                  ? gogo->pkgpath_symbol()\n+                                  : no->package()->pkgpath_symbol());\n+          asm_name.append(1, '.');\n+          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n+          if (this->fntype_->is_method())\n+            {\n+              asm_name.append(1, '.');\n+              Type* rtype = this->fntype_->receiver()->type();\n+              asm_name.append(rtype->mangled_name(gogo));\n+            }\n+        }\n \n-      if (functype != error_mark_node)\n-\t{\n-\t  // The type of a function comes back as a pointer to a\n-\t  // struct whose first field is the function, but we want the\n-\t  // real function type for a function declaration.\n-\t  go_assert(POINTER_TYPE_P(functype)\n-\t\t    && TREE_CODE(TREE_TYPE(functype)) == RECORD_TYPE);\n-\t  functype = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(functype)));\n-\t  go_assert(FUNCTION_POINTER_TYPE_P(functype));\n-\t  functype = TREE_TYPE(functype);\n-\t}\n+      Btype* functype = this->fntype_->get_backend_fntype(gogo);\n+      this->fndecl_ =\n+          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n+                                    true, true, true, false, false,\n+                                    this->location());\n+    }\n \n-      tree decl;\n-      if (functype == error_mark_node)\n-\tdecl = error_mark_node;\n-      else\n-\t{\n-\t  decl = build_decl(this->location().gcc_location(), FUNCTION_DECL, id,\n-                            functype);\n-\t  TREE_PUBLIC(decl) = 1;\n-\t  DECL_EXTERNAL(decl) = 1;\n+  return function_to_tree(this->fndecl_);\n+}\n \n-\t  if (this->asm_name_.empty())\n-\t    {\n-\t      std::string asm_name = (no->package() == NULL\n-\t\t\t\t      ? gogo->pkgpath_symbol()\n-\t\t\t\t      : no->package()->pkgpath_symbol());\n-\t      asm_name.append(1, '.');\n-\t      asm_name.append(Gogo::unpack_hidden_name(no->name()));\n-\t      if (this->fntype_->is_method())\n-\t\t{\n-\t\t  asm_name.append(1, '.');\n-\t\t  Type* rtype = this->fntype_->receiver()->type();\n-\t\t  asm_name.append(rtype->mangled_name(gogo));\n-\t\t}\n-\t      SET_DECL_ASSEMBLER_NAME(decl,\n-\t\t\t\t      get_identifier_from_string(asm_name));\n-\t    }\n-\t}\n-      this->fndecl_ = decl;\n-      go_preserve_from_gc(decl);\n-    }\n-  return this->fndecl_;\n+// Return the function's decl after it has been built.\n+\n+tree\n+Function::get_decl() const\n+{\n+  go_assert(this->fndecl_ != NULL);\n+  return function_to_tree(this->fndecl_);\n }\n \n // We always pass the receiver to a method as a pointer.  If the\n@@ -1558,7 +1437,7 @@ Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n void\n Function::build_tree(Gogo* gogo, Named_object* named_function)\n {\n-  tree fndecl = this->fndecl_;\n+  tree fndecl = this->get_decl();\n   go_assert(fndecl != NULL_TREE);\n \n   tree params = NULL_TREE;\n@@ -1796,7 +1675,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n     set = NULL_TREE;\n   else\n     set = fold_build2_loc(end_loc.gcc_location(), MODIFY_EXPR, void_type_node,\n-\t\t\t  DECL_RESULT(this->fndecl_), retval);\n+\t\t\t  DECL_RESULT(this->get_decl()), retval);\n   tree ret_stmt = fold_build1_loc(end_loc.gcc_location(), RETURN_EXPR,\n                                   void_type_node, set);\n   append_to_statement_list(ret_stmt, &stmt_list);\n@@ -1851,7 +1730,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n       retval = this->return_value(gogo, named_function, end_loc,\n \t\t\t\t  &stmt_list);\n       set = fold_build2_loc(end_loc.gcc_location(), MODIFY_EXPR, void_type_node,\n-\t\t\t    DECL_RESULT(this->fndecl_), retval);\n+\t\t\t    DECL_RESULT(this->get_decl()), retval);\n       ret_stmt = fold_build1_loc(end_loc.gcc_location(), RETURN_EXPR,\n                                  void_type_node, set);\n \n@@ -1869,7 +1748,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   *fini = stmt_list;\n }\n \n-// Return the value to assign to DECL_RESULT(this->fndecl_).  This may\n+// Return the value to assign to DECL_RESULT(this->get_decl()).  This may\n // also add statements to STMT_LIST, which need to be executed before\n // the assignment.  This is used for a return statement with no\n // explicit values.\n@@ -1902,7 +1781,7 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n     }\n   else\n     {\n-      tree rettype = TREE_TYPE(DECL_RESULT(this->fndecl_));\n+      tree rettype = TREE_TYPE(DECL_RESULT(this->get_decl()));\n       retval = create_tmp_var(rettype, \"RESULT\");\n       tree field = TYPE_FIELDS(rettype);\n       int index = 0;\n@@ -2323,15 +2202,11 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n       go_assert(m != NULL);\n \n       Named_object* no = m->named_object();\n-\n-      tree fnid = no->get_id(this);\n-\n       tree fndecl;\n       if (no->is_function())\n-\tfndecl = no->func_value()->get_or_make_decl(this, no, fnid);\n+\tfndecl = no->func_value()->get_or_make_decl(this, no);\n       else if (no->is_function_declaration())\n-\tfndecl = no->func_declaration_value()->get_or_make_decl(this, no,\n-\t\t\t\t\t\t\t\tfnid);\n+\tfndecl = no->func_declaration_value()->get_or_make_decl(this, no);\n       else\n \tgo_unreachable();\n       fndecl = build_fold_addr_expr(fndecl);"}, {"sha": "a8f77549e8aa06ae9fb3016d931ee4c58f5e65a0", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -5110,6 +5110,75 @@ Named_object::get_backend_variable(Gogo* gogo, Named_object* function)\n     go_unreachable();\n }\n \n+\n+// Return the external identifier for this object.\n+\n+std::string\n+Named_object::get_id(Gogo* gogo)\n+{\n+  go_assert(!this->is_variable() && !this->is_result_variable());\n+  std::string decl_name;\n+  if (this->is_function_declaration()\n+      && !this->func_declaration_value()->asm_name().empty())\n+    decl_name = this->func_declaration_value()->asm_name();\n+  else if (this->is_type()\n+\t   && Linemap::is_predeclared_location(this->type_value()->location()))\n+    {\n+      // We don't need the package name for builtin types.\n+      decl_name = Gogo::unpack_hidden_name(this->name_);\n+    }\n+  else\n+    {\n+      std::string package_name;\n+      if (this->package_ == NULL)\n+\tpackage_name = gogo->package_name();\n+      else\n+\tpackage_name = this->package_->package_name();\n+\n+      // Note that this will be misleading if this is an unexported\n+      // method generated for an embedded imported type.  In that case\n+      // the unexported method should have the package name of the\n+      // package from which it is imported, but we are going to give\n+      // it our package name.  Fixing this would require knowing the\n+      // package name, but we only know the package path.  It might be\n+      // better to use package paths here anyhow.  This doesn't affect\n+      // the assembler code, because we always set that name in\n+      // Function::get_or_make_decl anyhow.  FIXME.\n+\n+      decl_name = package_name + '.' + Gogo::unpack_hidden_name(this->name_);\n+\n+      Function_type* fntype;\n+      if (this->is_function())\n+\tfntype = this->func_value()->type();\n+      else if (this->is_function_declaration())\n+\tfntype = this->func_declaration_value()->type();\n+      else\n+\tfntype = NULL;\n+      if (fntype != NULL && fntype->is_method())\n+\t{\n+\t  decl_name.push_back('.');\n+\t  decl_name.append(fntype->receiver()->type()->mangled_name(gogo));\n+\t}\n+    }\n+  if (this->is_type())\n+    {\n+      unsigned int index;\n+      const Named_object* in_function = this->type_value()->in_function(&index);\n+      if (in_function != NULL)\n+\t{\n+\t  decl_name += '$' + Gogo::unpack_hidden_name(in_function->name());\n+\t  if (index > 0)\n+\t    {\n+\t      char buf[30];\n+\t      snprintf(buf, sizeof buf, \"%u\", index);\n+\t      decl_name += '$';\n+\t      decl_name += buf;\n+\t    }\n+\t}\n+    }\n+  return decl_name;\n+}\n+\n // Class Bindings.\n \n Bindings::Bindings(Bindings* enclosing)"}, {"sha": "5b416b0c0588a644fd6053e765aeb0bcc499e458", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -48,6 +48,7 @@ class Bstatement;\n class Bblock;\n class Bvariable;\n class Blabel;\n+class Bfunction;\n \n // This file declares the basic classes used to hold the internal\n // representation of Go which is built by the parser.\n@@ -1091,15 +1092,11 @@ class Function\n \n   // Return the function's decl given an identifier.\n   tree\n-  get_or_make_decl(Gogo*, Named_object*, tree id);\n+  get_or_make_decl(Gogo*, Named_object*);\n \n   // Return the function's decl after it has been built.\n   tree\n-  get_decl() const\n-  {\n-    go_assert(this->fndecl_ != NULL);\n-    return this->fndecl_;\n-  }\n+  get_decl() const;\n \n   // Set the function decl to hold a tree of the function code.\n   void\n@@ -1170,7 +1167,7 @@ class Function\n   // The function descriptor, if any.\n   Expression* descriptor_;\n   // The function decl.\n-  tree fndecl_;\n+  Bfunction* fndecl_;\n   // The defer stack variable.  A pointer to this variable is used to\n   // distinguish the defer stack for one function from another.  This\n   // is NULL unless we actually need a defer stack.\n@@ -1267,7 +1264,7 @@ class Function_declaration\n \n   // Return a decl for the function given an identifier.\n   tree\n-  get_or_make_decl(Gogo*, Named_object*, tree id);\n+  get_or_make_decl(Gogo*, Named_object*);\n \n   // If there is a descriptor, build it into the backend\n   // representation.\n@@ -1290,7 +1287,7 @@ class Function_declaration\n   // The function descriptor, if any.\n   Expression* descriptor_;\n   // The function decl if needed.\n-  tree fndecl_;\n+  Bfunction* fndecl_;\n };\n \n // A variable.\n@@ -2181,8 +2178,8 @@ class Named_object\n   Bvariable*\n   get_backend_variable(Gogo*, Named_object* function);\n \n-  // Return a tree for the external identifier for this object.\n-  tree\n+  // Return the external identifier for this object.\n+  std::string\n   get_id(Gogo*);\n \n   // Return a tree representing this object."}, {"sha": "f73ca7ae6f6c98777a98ae5fe37298b42902062b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -3382,6 +3382,68 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n \n // Get the backend representation for a function type.\n \n+Btype*\n+Function_type::get_backend_fntype(Gogo* gogo)\n+{\n+  if (this->fnbtype_ == NULL)\n+    {\n+      Backend::Btyped_identifier breceiver;\n+      if (this->receiver_ != NULL)\n+        {\n+          breceiver.name = Gogo::unpack_hidden_name(this->receiver_->name());\n+\n+          // We always pass the address of the receiver parameter, in\n+          // order to make interface calls work with unknown types.\n+          Type* rtype = this->receiver_->type();\n+          if (rtype->points_to() == NULL)\n+            rtype = Type::make_pointer_type(rtype);\n+          breceiver.btype = rtype->get_backend(gogo);\n+          breceiver.location = this->receiver_->location();\n+        }\n+\n+      std::vector<Backend::Btyped_identifier> bparameters;\n+      if (this->parameters_ != NULL)\n+        {\n+          bparameters.resize(this->parameters_->size());\n+          size_t i = 0;\n+          for (Typed_identifier_list::const_iterator p =\n+                   this->parameters_->begin(); p != this->parameters_->end();\n+               ++p, ++i)\n+\t    {\n+              bparameters[i].name = Gogo::unpack_hidden_name(p->name());\n+              bparameters[i].btype = p->type()->get_backend(gogo);\n+              bparameters[i].location = p->location();\n+            }\n+          go_assert(i == bparameters.size());\n+        }\n+\n+      std::vector<Backend::Btyped_identifier> bresults;\n+      if (this->results_ != NULL)\n+        {\n+          bresults.resize(this->results_->size());\n+          size_t i = 0;\n+          for (Typed_identifier_list::const_iterator p =\n+                   this->results_->begin(); p != this->results_->end();\n+               ++p, ++i)\n+\t    {\n+              bresults[i].name = Gogo::unpack_hidden_name(p->name());\n+              bresults[i].btype = p->type()->get_backend(gogo);\n+              bresults[i].location = p->location();\n+            }\n+          go_assert(i == bresults.size());\n+        }\n+\n+      this->fnbtype_ = gogo->backend()->function_type(breceiver, bparameters,\n+                                                      bresults,\n+                                                      this->location());\n+\n+    }\n+\n+  return this->fnbtype_;\n+}\n+\n+// Get the backend representation for a Go function type.\n+\n Btype*\n Function_type::do_get_backend(Gogo* gogo)\n {\n@@ -3395,57 +3457,9 @@ Function_type::do_get_backend(Gogo* gogo)\n     gogo->backend()->placeholder_struct_type(\"__go_descriptor\", loc);\n   Btype* ptr_struct_type = gogo->backend()->pointer_type(struct_type);\n \n-  Backend::Btyped_identifier breceiver;\n-  if (this->receiver_ != NULL)\n-    {\n-      breceiver.name = Gogo::unpack_hidden_name(this->receiver_->name());\n-\n-      // We always pass the address of the receiver parameter, in\n-      // order to make interface calls work with unknown types.\n-      Type* rtype = this->receiver_->type();\n-      if (rtype->points_to() == NULL)\n-\trtype = Type::make_pointer_type(rtype);\n-      breceiver.btype = rtype->get_backend(gogo);\n-      breceiver.location = this->receiver_->location();\n-    }\n-\n-  std::vector<Backend::Btyped_identifier> bparameters;\n-  if (this->parameters_ != NULL)\n-    {\n-      bparameters.resize(this->parameters_->size());\n-      size_t i = 0;\n-      for (Typed_identifier_list::const_iterator p = this->parameters_->begin();\n-\t   p != this->parameters_->end();\n-\t   ++p, ++i)\n-\t{\n-\t  bparameters[i].name = Gogo::unpack_hidden_name(p->name());\n-\t  bparameters[i].btype = p->type()->get_backend(gogo);\n-\t  bparameters[i].location = p->location();\n-\t}\n-      go_assert(i == bparameters.size());\n-    }\n-\n-  std::vector<Backend::Btyped_identifier> bresults;\n-  if (this->results_ != NULL)\n-    {\n-      bresults.resize(this->results_->size());\n-      size_t i = 0;\n-      for (Typed_identifier_list::const_iterator p = this->results_->begin();\n-\t   p != this->results_->end();\n-\t   ++p, ++i)\n-\t{\n-\t  bresults[i].name = Gogo::unpack_hidden_name(p->name());\n-\t  bresults[i].btype = p->type()->get_backend(gogo);\n-\t  bresults[i].location = p->location();\n-\t}\n-      go_assert(i == bresults.size());\n-    }\n-\n-  Btype* fntype = gogo->backend()->function_type(breceiver, bparameters,\n-\t\t\t\t\t\t bresults, loc);\n   std::vector<Backend::Btyped_identifier> fields(1);\n   fields[0].name = \"code\";\n-  fields[0].btype = fntype;\n+  fields[0].btype = this->get_backend_fntype(gogo);\n   fields[0].location = loc;\n   if (!gogo->backend()->set_placeholder_struct_type(struct_type, fields))\n     return gogo->backend()->error_type();"}, {"sha": "928c593a919022b2231c6f91117bbd5b3fc3393c", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7191ecdbd3adad32b561db40fac6978df6409fe/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=f7191ecdbd3adad32b561db40fac6978df6409fe", "patch": "@@ -1717,7 +1717,8 @@ class Function_type : public Type\n \t\tTyped_identifier_list* results, Location location)\n     : Type(TYPE_FUNCTION),\n       receiver_(receiver), parameters_(parameters), results_(results),\n-      location_(location), is_varargs_(false), is_builtin_(false)\n+      location_(location), is_varargs_(false), is_builtin_(false),\n+      fnbtype_(NULL)\n   { }\n \n   // Get the receiver.\n@@ -1798,6 +1799,11 @@ class Function_type : public Type\n   static Type*\n   make_function_type_descriptor_type();\n \n+  // Return the backend representation of this function type. This is used\n+  // as the real type of a backend function declaration or defintion.\n+  Btype*\n+  get_backend_fntype(Gogo*);\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -1851,6 +1857,9 @@ class Function_type : public Type\n   // Whether this is a special builtin function which can not simply\n   // be called.  This is used for len, cap, etc.\n   bool is_builtin_;\n+  // The backend representation of this type for backend function\n+  // declarations and definitions.\n+  Btype* fnbtype_;\n };\n \n // The type of a pointer."}]}