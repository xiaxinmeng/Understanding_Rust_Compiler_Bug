{"sha": "a4da349f823e4fdf41d50787623571a61d40c791", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkYTM0OWY4MjNlNGZkZjQxZDUwNzg3NjIzNTcxYTYxZDQwYzc5MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-20T23:31:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-20T23:31:03Z"}, "message": "Replaced file, for as1750.\n\nFrom-SVN: r8108", "tree": {"sha": "1644173d063e0ccd51de7c72d27353dda305e08b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1644173d063e0ccd51de7c72d27353dda305e08b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4da349f823e4fdf41d50787623571a61d40c791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4da349f823e4fdf41d50787623571a61d40c791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4da349f823e4fdf41d50787623571a61d40c791", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4da349f823e4fdf41d50787623571a61d40c791/comments", "author": null, "committer": null, "parents": [{"sha": "39ffdc1e3f2e513719464a6a09f5c8be4cd3c1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ffdc1e3f2e513719464a6a09f5c8be4cd3c1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ffdc1e3f2e513719464a6a09f5c8be4cd3c1dc"}], "stats": {"total": 202, "additions": 108, "deletions": 94}, "files": [{"sha": "b628dbf489a19497d786fc6feeffb6868721109d", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4da349f823e4fdf41d50787623571a61d40c791/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4da349f823e4fdf41d50787623571a61d40c791/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=a4da349f823e4fdf41d50787623571a61d40c791", "patch": "@@ -1,6 +1,6 @@\n-/* Definitions of target machine for GNU compiler, MIL-STD-1750A version.\n+/* Definitions of target machine for GNU compiler.\n    Copyright (C) 1994 Free Software Foundation, Inc.\n-   Contributed by O.M.Kellogg, Deutsche Aerospace (okellogg@salyko.cube.net).\n+   Contributed by O.M.Kellogg, DASA (okellogg@salyko.cube.net).\n \n This file is part of GNU CC.\n \n@@ -48,15 +48,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* SPECIAL ADDITION FOR MIL-STD-1750A     by O.M.Kellogg, 15-Apr-1993 */\n /* See file aux-output.c for the actual data instances. */\n struct datalabel_array {\n-    char name[14];\n+    char *name;\n     char value[14];\n     int size;\n };\n struct jumplabel_array {\n     int pc;\n     int num;\n };\n-enum section { NREL, IREL, KREL, SREL };\n+enum section { Init, Normal, Konst, Static };\n #define DATALBL_ARRSIZ 256\n #define JMPLBL_ARRSIZ  256\n #ifndef __datalbl\n@@ -65,6 +65,7 @@ extern struct jumplabel_array jmplbl[];\n extern int datalbl_ndx, jmplbl_ndx, label_pending, program_counter;\n extern enum section current_section;\n extern char *sectname[4];\n+extern char *strdup(), *float_label();\n #endif\n /*--------------------------------------------------------------------*/\n \n@@ -179,12 +180,11 @@ extern char *sectname[4];\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n-   R15 is the 1750A stack pointer. R14 would be the frame \n-   pointer, but we'd like to try avoid using it if possible. */\n+   R15 is the 1750A stack pointer. R14 is the frame pointer. */\n \n #define FIXED_REGISTERS  \\\n  { 0, 0, 0, 0, 0, 0, 0, 0, \\\n-   0, 0, 0, 0, 0, 0, 0, 1 }\n+   0, 0, 0, 0, 0, 0, 1, 1 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -232,7 +232,7 @@ extern char *sectname[4];\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n    This is computed in `reload', in reload1.c. */\n-#define FRAME_POINTER_REQUIRED 0\n+#define FRAME_POINTER_REQUIRED 1\n \n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 14\n@@ -348,11 +348,8 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    (C) == 'O' ? (VALUE) == 0 :\t\t\t\t0)\n \n /* Similar, but for floating constants, and defining letter 'G'.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-   1750 longfloat constant 0.0 is worth recognizing 'cause it's got \n-   all bits zero. */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' && (VALUE) == CONST0_RTX(HFmode))\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n@@ -452,7 +449,7 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* 1 if the tree TYPE should be returned in memory instead of in regs. \n    #define RETURN_IN_MEMORY(TYPE) \\\n-   (int_size_in_bytes(TYPE) > 13)\n+   (int_size_in_bytes(TYPE) > 12)\n */\n \n /* Define this if PCC uses the nonreentrant convention for returning\n@@ -471,7 +468,7 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   For 1750A, this is a single integer, which is a number of bytes\n+   For 1750A, this is a single integer, which is a number of words\n    of arguments scanned so far.  */\n \n #define CUMULATIVE_ARGS int\n@@ -548,10 +545,10 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n     fprintf(FILE,\" (none)\");\t\t\t\t \t\\\n   fprintf(FILE,\"\\n\");\t\t\t\t\t \t\\\n   if (SIZE > 0)\t\t\t\t\t\t\t\\\n-    fprintf(FILE,\"\\t%s   R15,%d  ; reserve local-variable space\\n\",\\\n-\t\t\t (SIZE <= 16 ? \"SISP\" : \"SIM \"),SIZE);\t\\\n-  fprintf(FILE,\"\\tPSHM   R14,R14 ; push old frame\\n\");\t\t\\\n-  fprintf(FILE,\"\\tLR     R14,R15 ; set new frame\\n\");\t\t\\\n+    fprintf(FILE,\"\\t%s\\tr15,%d  ; reserve local-variable space\\n\",\\\n+\t\t\t (SIZE <= 16 ? \"sisp\" : \"sim\"),SIZE);\t\\\n+  fprintf(FILE,\"\\tpshm\\tr14,r14 ; push old frame\\n\");\t\t\\\n+  fprintf(FILE,\"\\tlr\\tr14,r15 ; set new frame\\n\");\t\t\\\n   program_counter = 0; jmplbl_ndx = -1;\t\t\t\t\\\n }\n \n@@ -591,18 +588,19 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) {\t\t\t\\\n   if (SIZE > 0)\t\t\t\t\t\t\t\\\n-    fprintf(FILE,\"\\t%s   R14,%d ; free up local-var space\\n\",\t\\\n-\t\t\t (SIZE <= 16 ? \"AISP\" : \"AIM \"),SIZE);\t\\\n-  fprintf(FILE,\"\\tLR     R15,R14 ; set stack to return addr\\n\");\\\n-  fprintf(FILE,\"\\tURS    R15\\n\"); }\n+    fprintf(FILE,\"\\t%s\\tr14,%d ; free up local-var space\\n\",\t\\\n+\t\t\t (SIZE <= 16 ? \"aisp\" : \"aim\"),SIZE);\t\\\n+  fprintf(FILE,\"\\tlr\\tr15,r14 ; set stack to return addr\\n\");\t\\\n+  fprintf(FILE,\"\\tpopm\\tr14,r14 ; restore prev. frame ptr\\n\");\t\\\n+  fprintf(FILE,\"\\turs\\tr15\\n\"); }\n \n /* If the memory address ADDR is relative to the frame pointer,\n    correct it to be relative to the stack pointer instead.\n    This is for when we don't use a frame pointer.\n    ADDR should be a variable name. */\n \n #define FIX_FRAME_POINTER_ADDRESS(ADDR,DEPTH)  \\\n-   fprintf(asm_out_file,\"FIX_FRAME_POINTER_ADDRESS called, DEPTH=%d\\n\"), \\\n+   fprintf(stderr,\"FIX_FRAME_POINTER_ADDRESS called, DEPTH=%d\\n\"), \\\n            DEPTH), abort()\n \n /* Store in the variable DEPTH the initial difference between the\n@@ -795,7 +793,7 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n /* (was: \"1750: not counting the MOV instruction\") */\n-#define MOVE_MAX 256\n+#define MOVE_MAX 16\n \n /* Define this if zero-extension is slow (more than one real instruction).  */\n /* #define SLOW_ZERO_EXTEND */\n@@ -883,73 +881,76 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    strcpy(name,p);\t\t\t\t\t\t\t\\\n    if (p = (char *)strchr(name,'.'))\t\t\t\t\t\\\n \t*p = '\\0';\t\t\t\t\t\t\t\\\n-   if (strlen(name) > 12)\t\t\t\t\t\t\\\n-\tname[12] = '\\0';   /* TekAs can handle only up to 12 char. */\t\\\n-   fprintf(FILE,\"\\tNAME %s\\n\",name); \t\t\t\t\t\\\n-   fprintf(FILE,\"\\tNOLIST\\n\\tINCLUDE \\\"M1750.INC\\\"\\n\\tLIST\\n\");\t\t\\\n-   fprintf(FILE,\"\\n\\tSECTION SREL\\n\\tSECTION KREL\\n\\tSECTION IREL\\n\");\t\\\n-   fprintf(FILE,\"\\tSECTION NREL\\n\"); }\n+   fprintf(FILE,\"\\tname %s\\n\",name); \t\t\t\t\t\\\n+   fprintf(FILE,\"\\tnolist\\n\\tinclude \\\"ms1750.inc\\\"\\n\\tlist\\n\\n\");\t\\\n+   fprintf(FILE,\"\\tglobal\\t__main\\n\\n\");  }\n \n /* Output at end of assembler file.  \n    For 1750, we copy the data labels accrued in datalbl[] from the Constants \n-   section (KREL) to the Writable-Data section (SREL).     */\n+   section (Konst) to the Writable-Data section (Static).     */\n \n #define ASM_FILE_END(FILE)\t\\\n    do {\t\t\t\t\t\t\t\t\t\\\n       if (datalbl_ndx >= 0) {\t\t\t\t\t\t\\\n          int i, cum_size=0;\t\t\t\t\t\t\\\n-         fprintf(FILE,\"\\n\\tRESUME SREL\\nINIT_SREL\\n\");\t\t\t\\\n+         fprintf(FILE,\"\\n\\tstatic\\ninit_srel\\n\");\t\t\t\\\n          for (i = 0; i <= datalbl_ndx; i++) {\t\t\t\t\\\n-            fprintf(FILE,\"%s\\t BLOCK %d\\n\",\t\t\t\t\\\n+\t    if (datalbl[i].name == NULL)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t       fprintf(stderr, \"asm_file_end internal datalbl err\\n\");\t\\\n+\t       exit (0);\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+            fprintf(FILE,\"%s \\tblock %d\\n\",\t\t\t\t\\\n                  datalbl[i].name,datalbl[i].size);\t\t\t\\\n             cum_size += datalbl[i].size;\t\t\t\t\\\n \t }\t\t\t\t\t\t\t\t\\\n-         fprintf(FILE,\"\\n\\tRESUME IREL\\n\");\t\t\t\t\\\n-         fprintf(FILE,\"\\tLIM  R0,INIT_SREL\\n\");           /* destin. */\t\\\n-         fprintf(FILE,\"\\tLIM  R1,%d\\n\",cum_size);         /* count */\t\\\n-         fprintf(FILE,\"\\tLIM  R2,K%s\\n\",datalbl[0].name); /* source */\t\\\n-         fprintf(FILE,\"\\tMOV  R0,R2\\n\");\t\t\t\t\\\n-         fprintf(FILE,\"\\n\\tRESUME NREL\\n\");\t\t\t\t\\\n+         fprintf(FILE,\"\\n\\tinit\\n\");\t\t\t\t\t\\\n+         fprintf(FILE,\"\\tlim\\tr0,init_srel\\n\");           /* destin. */\t\\\n+         fprintf(FILE,\"\\tlim\\tr1,%d\\n\",cum_size);         /* count */\t\\\n+         fprintf(FILE,\"\\tlim\\tr2,K%s\\n\",datalbl[0].name); /* source */\t\\\n+         fprintf(FILE,\"\\tmov\\tr0,r2\\n\");\t\t\t\t\\\n+         fprintf(FILE,\"\\n\\tnormal\\n\");\t\t\t\t\t\\\n          datalbl_ndx = -1;\t\t\t/* reset stuff */\t\\\n          for (i = 0; i < DATALBL_ARRSIZ; i++)\t\t\t\t\\\n             datalbl[i].size = 0;\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-      fprintf(FILE,\"\\n\\tEND\\n\");\t\t\t\t\t\\\n+      fprintf(FILE,\"\\n\\tend\\n\");\t\t\t\t\t\\\n    } while (0)\n \n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n \n-#define ASM_APP_ON \"\\n\\tIF 0\\n; by ASM_APP_ON\\n\"\n+#define ASM_APP_ON \"\\n\\tif 0\\n; by ASM_APP_ON\\n\"\n \n /* Output to assembler file text saying following lines\n    no longer contain unusual constructs.  */\n \n-#define ASM_APP_OFF \"\\n\\tENDIF\\n\"\n+#define ASM_APP_OFF \"\\n\\tendif\\n\"\n \n \n #define EXTRA_SECTIONS  in_readonly_data\n \n #define EXTRA_SECTION_FUNCTIONS\t\t\\\n     void const_section()\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-\tfprintf(asm_out_file,\"\\tRESUME KREL\\n\");\t\\\n-\tcurrent_section = KREL;\t\t\t\t\\\n+\tfprintf(asm_out_file,\"\\tkonst\\n\");\t\t\\\n+\tcurrent_section = Konst;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n     check_section(enum section sect)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n         if (current_section != sect) {\t\t\t\\\n-\t    fprintf(asm_out_file,\"\\tRESUME %s\\n\",sectname[(int)sect]); \\\n+\t    fprintf(asm_out_file,\"\\t%s\\n\",sectname[(int)sect]); \\\n \t    current_section = sect;\t\t\t\\\n \t}\t\t\t\t\t\t\\\n \tswitch (sect) {\t\t\t\t\t\\\n-\t  case NREL:\t\t\t\t\t\\\n+\t  case Init:\t\t\t\t\t\\\n+\t  case Normal:\t\t\t\t\t\\\n \t    in_section = in_text;\t\t\t\\\n \t    break;\t\t\t\t\t\\\n-\t  case SREL:\t\t\t\t\t\\\n+\t  case Static:\t\t\t\t\t\\\n \t    in_section = in_data;\t\t\t\\\n \t    break;\t\t\t\t\t\\\n-\t  case KREL:\t\t\t\t\t\\\n+\t  case Konst:\t\t\t\t\t\\\n \t    in_section = in_readonly_data;\t\t\\\n \t    break;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n@@ -959,11 +960,14 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Function that switches to the read-only data section (optional) */\n #define READONLY_DATA_SECTION\tconst_section\n \n+/* Output before program init section */\n+#define INIT_SECTION_ASM_OP \"\\n\\tinit     ; init_section\\n\"\n+\n /* Output before program text section */\n-#define TEXT_SECTION_ASM_OP \"\\n\\tRESUME NREL   ; text_section\\n\"\n+#define TEXT_SECTION_ASM_OP \"\\n\\tnormal   ; text_section\\n\"\n \n /* Output before writable data.  */\n-#define DATA_SECTION_ASM_OP \"\\n\\tRESUME SREL   ; data_section\\n\"\n+#define DATA_SECTION_ASM_OP \"\\n\\tstatic   ; data_section\\n\"\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n@@ -978,14 +982,21 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /******************  Assembler output formatting  **********************/\n \n-#define ASM_IDENTIFY_GCC(FILE)\n+#define ASM_IDENTIFY_GCC(FILE)  fputs (\"; gcc2_compiled:\\n\", FILE)\n \n #define ASM_COMMENT_START  \";\"\n \n #define ASM_OUTPUT_FUNNAM(FILE,NAME)\t\\\n \tfprintf(FILE,\"%s\\n\",NAME)\n \n #define ASM_OUTPUT_OPCODE(FILE,PTR)  do {\t\t\\\n+\twhile (*(PTR) != '\\0' && *(PTR) != ' ') {\t\\\n+\t    putc (*(PTR), FILE);\t\t\t\\\n+\t    (PTR)++;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+\twhile (*(PTR) == ' ')\t\t\t\t\\\n+\t    (PTR)++;\t\t\t\t\t\\\n+\tputc ('\\t', FILE);\t\t\t\t\\\n \tprogram_counter += 2;\t\t\t\t\\\n      } while (0)\n \n@@ -996,31 +1007,31 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    such as the label on a static function or variable NAME.  */\n /* 1750 note: Labels are prefixed with a 'K'. This is because handling\n    has been changed for labels to be output in the \"Constants\" section\n-   (named \"KREL\"), and special initialization code takes care of copying\n-   the Const-section data into the writable data section (named \"SREL\").\n-   In the SREL section we therefore have the true label names (i.e.\n+   (named \"Konst\"), and special initialization code takes care of copying\n+   the Const-section data into the writable data section (named \"Static\").\n+   In the Static section we therefore have the true label names (i.e.\n    not prefixed with 'K').  */\n \n #define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do {  if (NAME[0] == '.')\t\t\t\t\\\n-\t   fprintf(FILE,\"%s\\n\",NAME);\t\t\t\\\n-\telse {\t\t\t\t\t\t\\\n-\t   if (strlen(NAME) > 11) NAME[11] = '\\0';\t\\\n-\t   check_section(KREL);\t\t\t\t\\\n-\t   fprintf(FILE,\"K%s\\n\",NAME);\t\t\t\\\n-\t   strcpy(datalbl[++datalbl_ndx].name,NAME);\t\\\n-\t   label_pending = 1;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n+  do {  if (NAME[0] == '.') {\t\t\t\t\t\\\n+\t   fprintf(stderr,\"Oops! label %s can't begin with '.'\\n\",NAME); \\\n+\t   abort();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\telse {\t\t\t\t\t\t\t\\\n+\t   check_section(Konst);\t\t\t\t\\\n+\t   fprintf(FILE,\"K%s\\n\",NAME);\t\t\t\t\\\n+\t   datalbl[++datalbl_ndx].name = (char *)strdup (NAME);\t\\\n+\t   label_pending = 1;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n   } while (0)\n \n \n /* This is how to output a command to make the user-level label named NAME\n    defined for reference from other files.  */\n \n #define ASM_GLOBALIZE_LABEL(FILE,NAME) do {\t\t\\\n-\t   check_section(NREL);\t\t\t\t\\\n-\t   fputs (\"\\tGLOBAL \", FILE); assemble_name (FILE, NAME); \\\n-\t   fputs (\"   ; export\\n\", FILE); } while (0)\n+\t   fprintf (FILE, \"\\tglobal  %s\\t; export\\n\", NAME);\t\\\n+  } while (0)\n \n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.  */\n@@ -1035,8 +1046,9 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \tdo {\t\t\t\t\t\t\t\\\n \t  if (strcmp(PREFIX,\"LC\") == 0) {\t\t\t\\\n \t     label_pending = 1;\t\t\t\t\t\\\n-\t     sprintf(datalbl[++datalbl_ndx].name,\"LC%d\",NUM);\t\\\n-\t     check_section(KREL);\t\t\t\t\\\n+\t     datalbl[++datalbl_ndx].name = (char *) malloc (9); \\\n+\t     sprintf(datalbl[datalbl_ndx].name,\"LC%d\",NUM);\t\\\n+\t     check_section(Konst);\t\t\t\t\\\n \t     fprintf(FILE,\"K%s%d\\n\",PREFIX,NUM);\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n \t  else if (find_jmplbl(NUM) < 0) {\t\t\t\\\n@@ -1058,33 +1070,29 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* This is how to output an assembler line defining a 1750A `float'\n    constant.  */\n \n-#define ASM_OUTPUT_FLOAT(FILE,VALUE) \t\t\t\\\n+#define ASM_OUTPUT_SHORT_FLOAT(FILE,VALUE) \t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n-      char *tekfltstr = (char *)tekasm_float('E',VALUE);\t\\\n       if (label_pending)\t\t\t\t\t\\\n \t label_pending = 0;\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-         strcpy(datalbl[++datalbl_ndx].name,\t\t\t\\\n-\t\t(char *)float_label('E',tekfltstr));\t\t\\\n-      strcpy(datalbl[datalbl_ndx].value,tekfltstr);\t\t\\\n+         datalbl[++datalbl_ndx].name = float_label('D',VALUE);\t\\\n+      sprintf (datalbl[datalbl_ndx].value, \"%lf\", (double) VALUE); \\\n       datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n-      fprintf (FILE, \"\\tDATAF %s\\n\",tekfltstr);\t\t\t\\\n+      fprintf (FILE, \"\\tdataf\\t%lf\\n\",VALUE);\t\t\t\\\n   } while(0)\n \n /* This is how to output an assembler line defining a 1750A `double'\n     constant. */\n \n #define ASM_OUTPUT_THREE_QUARTER_FLOAT(FILE,VALUE)\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n-      char *tekfltstr = (char *)tekasm_float('D',VALUE);\t\\\n       if (label_pending)\t\t\t\t\t\\\n \t label_pending = 0;\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-         strcpy(datalbl[++datalbl_ndx].name,\t\t\t\\\n-\t\t(char *)float_label('D',tekfltstr));\t\t\\\n-      strcpy(datalbl[datalbl_ndx].value,tekfltstr);\t\t\\\n+         datalbl[++datalbl_ndx].name = float_label('E',VALUE);\t\\\n+      sprintf (datalbl[datalbl_ndx].value, \"%lf\", VALUE);\t\\\n       datalbl[datalbl_ndx].size = 3;\t\t\t\t\\\n-      fprintf(FILE,\"\\tDATAF %s\\n\",tekfltstr);\t\t\t\\\n+      fprintf(FILE,\"\\tdataef\\t%lf\\n\",VALUE);\t\t\t\\\n   } while (0)\n \n /* This is how to output an assembler line defining a string constant.  */\n@@ -1099,9 +1107,9 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \t}\t\t\t\t\t\t\t\t\\\n \tfor (i = 0; i < LEN; i++)\t\t\t\t\t\\\n \t  if (PTR[i] >= 32 && PTR[i] < 127)\t\t\t\t\\\n-\t    fprintf(FILE,\"\\tDATA   %d\\t; '%c'\\n\",PTR[i],PTR[i]);\t\\\n+\t    fprintf(FILE,\"\\tdata\\t%d\\t; '%c'\\n\",PTR[i],PTR[i]);\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf(FILE,\"\\tDATA   %d\\t; (ascii)\\n\",PTR[i]);\t\t\\\n+\t    fprintf(FILE,\"\\tdata\\t%d\\t; (ascii)\\n\",PTR[i]);\t\t\\\n   } while (0)\n \n /* This is how to output an assembler line defining an `int' constant.  */\n@@ -1113,7 +1121,7 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \t   label_pending = 0;\t\t\t\t\t\t\\\n \t   datalbl[datalbl_ndx].size = 1;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tDATA \"); output_addr_const(FILE,VALUE);\t\\\n+\tfprintf(FILE, \"\\tdata\\t\"); output_addr_const(FILE,VALUE);\t\\\n \tfprintf(FILE, \"\\n\"); } while (0)\n \n /* This is how to output an assembler line defining a `long int' constant. */\n@@ -1125,7 +1133,7 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \t   label_pending = 0;\t\t\t\t\t\t\\\n \t   datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tDATAL \"); output_addr_const(FILE,VALUE);\t\\\n+\tfprintf(FILE, \"\\tdatal\\t\"); output_addr_const(FILE,VALUE);\t\\\n \tfprintf(FILE, \"\\n\"); } while (0)\n \n /* Likewise for `short' and `char' constants.  */\n@@ -1156,12 +1164,12 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* This is how to output an element of a case-vector that is absolute. */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)   \\\n-\tfprintf (FILE, \"\\tDATA   L%d ;addr_vec_elt\\n\", VALUE)\n+\tfprintf (FILE, \"\\tdata\\tL%d ;addr_vec_elt\\n\", VALUE)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n-\tfprintf (FILE, \"\\tDATA   L%d-L%d ;addr_diff_elt\\n\", VALUE,REL)\n+\tfprintf (FILE, \"\\tdata\\tL%d-L%d ;addr_diff_elt\\n\", VALUE,REL)\n \n /* This is how to output an assembler line\n    that says to advance the location counter\n@@ -1177,21 +1185,19 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n    to define a global common symbol.  */\n \n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  do {\t\\\n-\tcheck_section(NREL);\t\t\t\t\t\\\n-\tfprintf(FILE,\"\\tGLOBAL \"); assemble_name(FILE,NAME);\t\\\n-\tfprintf(FILE,\"   ; common\\n\"); } while (0)\n+\tfprintf (FILE, \"\\tcommon  %s,%d\\n\", NAME, SIZE);\t\\\n+     } while (0)\n \n #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)  do {\t\t\\\n-\tcheck_section(NREL);\t\t\t\t\t\\\n-\tfprintf(FILE,\"\\tGLOBAL \"); assemble_name(FILE,NAME);\t\\\n-\tfprintf(FILE,\"\\t; external\\n\"); } while (0)\n+\tfprintf (FILE, \"\\tglobal  %s\\t; import\\n\", NAME);\t\\\n+     }  while (0)\n \n /* This says how to output an assembler line\n    to define a local common symbol.  */\n \n #define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  do {  \\\n-\tcheck_section(SREL);\t\t\t\t\t\\\n-\tfprintf(FILE,\"%s \\tBLOCK %d  ; local\\n\",NAME,SIZE);\t\\\n+\tcheck_section (Static);\t\t\t\t\t\\\n+\tfprintf(FILE,\"%s \\tblock   %d\\t; local common\\n\",NAME,SIZE);\t\\\n      } while (0)\n \n /* Store in OUTPUT a string (made with alloca) containing\n@@ -1202,6 +1208,14 @@ enum reg_class { NO_REGS, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n+#define ASM_OUTPUT_CONSTRUCTOR(FILE, NAME)  do {\t\\\n+\tfprintf(FILE, \"\\tinit\\n\\t\"); assemble_name(NAME); \\\n+        fprintf(FILE,\"  ;constructor\"); } while (0)\n+\n+#define ASM_OUTPUT_DESTRUCTOR(FILE, NAME)  do {\t\\\n+\tfprintf(FILE, \"\\tinit\\n\\t\"); assemble_name(NAME); \\\n+        fprintf(FILE,\"  ;destructor\"); } while (0)\n+\n /* Define the parentheses used to group arithmetic operations\n    in assembler code.  */\n "}]}