{"sha": "b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f", "node_id": "C_kwDOANBUbNoAKGI2NjRjOGJmZDA5MTdlZDM0ZWQ5ZDNmMTVmM2YxODIzMjAwZTNlNGY", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-24T11:20:41Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-25T12:32:28Z"}, "message": "constexpr: Add `rust_sorry_at` in places relying on init values\n\nThis also comments out a now unused function", "tree": {"sha": "4e66d9e2f5a22e840e197c11c9553962f71d8fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e66d9e2f5a22e840e197c11c9553962f71d8fd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a32ef7aa18c45e7047f539b11cd572f0f9502b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32ef7aa18c45e7047f539b11cd572f0f9502b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32ef7aa18c45e7047f539b11cd572f0f9502b6d"}], "stats": {"total": 96, "additions": 49, "deletions": 47}, "files": [{"sha": "21e8bed99b0017c69cdb5275b7b35f3edbe7e7e8", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=b664c8bfd0917ed34ed9d3f15f3f1823200e3e4f", "patch": "@@ -3658,49 +3658,48 @@ eval_call_expression (const constexpr_ctx *ctx, tree t, bool lval,\n    whose constructor we are processing.  Add the initializer to the vector\n    and return true to indicate success.  */\n \n-static bool\n-build_anon_member_initialization (tree member, tree init,\n-\t\t\t\t  vec<constructor_elt, va_gc> **vec_outer)\n-{\n-  /* MEMBER presents the relevant fields from the inside out, but we need\n-     to build up the initializer from the outside in so that we can reuse\n-     previously built CONSTRUCTORs if this is, say, the second field in an\n-     anonymous struct.  So we use a vec as a stack.  */\n-  auto_vec<tree, 2> fields;\n-  do\n-    {\n-      fields.safe_push (TREE_OPERAND (member, 1));\n-      member = TREE_OPERAND (member, 0);\n-    }\n-  while (ANON_AGGR_TYPE_P (TREE_TYPE (member))\n-\t && TREE_CODE (member) == COMPONENT_REF);\n-\n-  /* VEC has the constructor elements vector for the context of FIELD.\n-     If FIELD is an anonymous aggregate, we will push inside it.  */\n-  vec<constructor_elt, va_gc> **vec = vec_outer;\n-  tree field;\n-  while (field = fields.pop (), ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-    {\n-      tree ctor;\n-      /* If there is already an outer constructor entry for the anonymous\n-\t aggregate FIELD, use it; otherwise, insert one.  */\n-      if (vec_safe_is_empty (*vec) || (*vec)->last ().index != field)\n-\t{\n-\t  ctor = build_constructor (TREE_TYPE (field), NULL);\n-\t  CONSTRUCTOR_APPEND_ELT (*vec, field, ctor);\n-\t}\n-      else\n-\tctor = (*vec)->last ().value;\n-      vec = &CONSTRUCTOR_ELTS (ctor);\n-    }\n-\n-  /* Now we're at the innermost field, the one that isn't an anonymous\n-     aggregate.  Add its initializer to the CONSTRUCTOR and we're done.  */\n-  gcc_assert (fields.is_empty ());\n-  CONSTRUCTOR_APPEND_ELT (*vec, field, init);\n-\n-  return true;\n-}\n+// static bool\n+// build_anon_member_initialization (tree member, tree init,\n+// \t\t\t\t  vec<constructor_elt, va_gc> **vec_outer)\n+// {\n+//   /* MEMBER presents the relevant fields from the inside out, but we need\n+//      to build up the initializer from the outside in so that we can reuse\n+//      previously built CONSTRUCTORs if this is, say, the second field in an\n+//      anonymous struct.  So we use a vec as a stack.  */\n+//   auto_vec<tree, 2> fields;\n+//   do\n+//     {\n+//       fields.safe_push (TREE_OPERAND (member, 1));\n+//       member = TREE_OPERAND (member, 0);\n+//   } while (ANON_AGGR_TYPE_P (TREE_TYPE (member))\n+// \t   && TREE_CODE (member) == COMPONENT_REF);\n+//\n+//   /* VEC has the constructor elements vector for the context of FIELD.\n+//      If FIELD is an anonymous aggregate, we will push inside it.  */\n+//   vec<constructor_elt, va_gc> **vec = vec_outer;\n+//   tree field;\n+//   while (field = fields.pop (), ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+//     {\n+//       tree ctor;\n+//       /* If there is already an outer constructor entry for the anonymous\n+// \t aggregate FIELD, use it; otherwise, insert one.  */\n+//       if (vec_safe_is_empty (*vec) || (*vec)->last ().index != field)\n+// \t{\n+// \t  ctor = build_constructor (TREE_TYPE (field), NULL);\n+// \t  CONSTRUCTOR_APPEND_ELT (*vec, field, ctor);\n+// \t}\n+//       else\n+// \tctor = (*vec)->last ().value;\n+//       vec = &CONSTRUCTOR_ELTS (ctor);\n+//     }\n+//\n+//   /* Now we're at the innermost field, the one that isn't an anonymous\n+//      aggregate.  Add its initializer to the CONSTRUCTOR and we're done.  */\n+//   gcc_assert (fields.is_empty ());\n+//   CONSTRUCTOR_APPEND_ELT (*vec, field, init);\n+//\n+//   return true;\n+// }\n \n ///* V is a vector of constructor elements built up for the base and member\n //   initializers of a constructor for TYPE.  They need to be in increasing\n@@ -3750,7 +3749,7 @@ build_anon_member_initialization (tree member, tree init,\n static bool\n build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n {\n-  tree member, init;\n+  tree member;\n   if (TREE_CODE (t) == CLEANUP_POINT_EXPR)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == EXPR_STMT)\n@@ -3835,7 +3834,8 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n \tmember = TREE_OPERAND (member, 1);\n       else if (ANON_AGGR_TYPE_P (TREE_TYPE (aggr)))\n \t/* Initializing a member of an anonymous union.  */\n-\treturn build_anon_member_initialization (member, init, vec);\n+\trust_sorry_at (Location (), \"cannot handle value initialization yet\");\n+      // return build_anon_member_initialization (member, init, vec);\n       else\n \t/* We're initializing a vtable pointer in a base.  Leave it as\n \t   COMPONENT_REF so we remember the path to get to the vfield.  */\n@@ -3845,9 +3845,11 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n   /* Value-initialization can produce multiple initializers for the\n      same field; use the last one.  */\n   if (!vec_safe_is_empty (*vec) && (*vec)->last ().index == member)\n-    (*vec)->last ().value = init;\n+    rust_sorry_at (Location (), \"cannot handle value initialization yet\");\n+  // (*vec)->last ().value = init;\n   else\n-    CONSTRUCTOR_APPEND_ELT (*vec, member, init);\n+    rust_sorry_at (Location (), \"cannot handle value initialization yet\");\n+  // CONSTRUCTOR_APPEND_ELT (*vec, member, init);\n   return true;\n }\n "}]}