{"sha": "455f58ec50465aed9d92dc31d68708a05e499388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1ZjU4ZWM1MDQ2NWFlZDlkOTJkYzMxZDY4NzA4YTA1ZTQ5OTM4OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-01-31T14:20:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-01-31T19:26:44Z"}, "message": "analyzer: fix ICE with pointers between stack frames (PR 93438)\n\nPR analyzer/93438 reports an ICE when merging two region_models\nin which an older stack frame has a local pointing to a local in\na more recent stack frame.\n\n  stack\n    older frame\n      int *: \"ow\" --+\n                    |\n    newer frame     |\n      int: \"pk\" <---+\n\nThe root cause is that the state-merging code assumes that all frame\nregions in the merged model have already been created.\nstack_region::can_merge_p iterates through the frames, creating\nand populating each merged frame in turn, so when it attempts to\npopulate the older frame, it attempts to reference the newer frame in\nthe merged model, which doesn't exist yet.\n\nThis patch reworks stack_region::can_merge_p to use a two-pass approach\nin which all frames in the merged model are created first, and then\nare all populated, fixing the bug.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/93438\n\t* region-model.cc (stack_region::can_merge_p): Split into a two\n\tpass approach, creating all stack regions first, then populating\n\tthem.\n\t(selftest::test_state_merging): Add test coverage for (a) the case\n\tof self-merging a model in which a local in an older stack frame\n\tpoints to a local in a more recent stack frame (which previously\n\twould ICE), and (b) the case of self-merging a model in which a\n\tlocal points to a global (which previously worked OK).\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/93438\n\t* gcc.dg/analyzer/torture/pr93438.c: New test.\n\t* gcc.dg/analyzer/torture/pr93438-2.c: New test.", "tree": {"sha": "ded6d41104c29eb1d934c7ef0e90f6856aeb3860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ded6d41104c29eb1d934c7ef0e90f6856aeb3860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455f58ec50465aed9d92dc31d68708a05e499388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455f58ec50465aed9d92dc31d68708a05e499388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455f58ec50465aed9d92dc31d68708a05e499388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455f58ec50465aed9d92dc31d68708a05e499388/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5910b14503dd82772dfeca5336a0176f9b1d260a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5910b14503dd82772dfeca5336a0176f9b1d260a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5910b14503dd82772dfeca5336a0176f9b1d260a"}], "stats": {"total": 172, "additions": 153, "deletions": 19}, "files": [{"sha": "8806a775acb14356667e9150e3eacc098486f756", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=455f58ec50465aed9d92dc31d68708a05e499388", "patch": "@@ -1,3 +1,15 @@\n+2020-01-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93438\n+\t* region-model.cc (stack_region::can_merge_p): Split into a two\n+\tpass approach, creating all stack regions first, then populating\n+\tthem.\n+\t(selftest::test_state_merging): Add test coverage for (a) the case\n+\tof self-merging a model in which a local in an older stack frame\n+\tpoints to a local in a more recent stack frame (which previously\n+\twould ICE), and (b) the case of self-merging a model in which a\n+\tlocal points to a global (which previously worked OK).\n+\n 2020-01-31  David Malcolm  <dmalcolm@redhat.com>\n \n \t* analyzer.cc (is_named_call_p): Replace tests for fndecl being"}, {"sha": "f116c0ae7a28788217e0d4863d2f692284708bc3", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=455f58ec50465aed9d92dc31d68708a05e499388", "patch": "@@ -2624,27 +2624,45 @@ stack_region::can_merge_p (const stack_region *stack_region_a,\n   stack_region *merged_stack\n     = merged_model->get_region <stack_region> (rid_merged_stack);\n \n-  for (unsigned i = 0; i < stack_region_a->get_num_frames (); i++)\n-    {\n-      region_id rid_a = stack_region_a->get_frame_rid (i);\n-      frame_region *frame_a = merger->get_region_a <frame_region> (rid_a);\n+  /* First, create all frames in the merged model, without populating them.\n+     The merging code assumes that all frames in the merged model already exist,\n+     so we have to do this first to handle the case in which a local in an\n+     older frame points at a local in a more recent frame.  */\n+    for (unsigned i = 0; i < stack_region_a->get_num_frames (); i++)\n+      {\n+\tregion_id rid_a = stack_region_a->get_frame_rid (i);\n+\tframe_region *frame_a = merger->get_region_a <frame_region> (rid_a);\n \n-      region_id rid_b = stack_region_b->get_frame_rid (i);\n-      frame_region *frame_b = merger->get_region_b <frame_region> (rid_b);\n+\tregion_id rid_b = stack_region_b->get_frame_rid (i);\n+\tframe_region *frame_b = merger->get_region_b <frame_region> (rid_b);\n \n-      if (frame_a->get_function () != frame_b->get_function ())\n-\treturn false;\n-      frame_region *merged_frame = new frame_region (rid_merged_stack,\n-\t\t\t\t\t\t     frame_a->get_function (),\n-\t\t\t\t\t\t     frame_a->get_depth ());\n-      region_id rid_merged_frame = merged_model->add_region (merged_frame);\n-      merged_stack->push_frame (rid_merged_frame);\n-\n-      if (!map_region::can_merge_p (frame_a, frame_b,\n-\t\t\t\t    merged_frame, rid_merged_frame,\n-\t\t\t\t    merger))\n-\treturn false;\n-    }\n+\tif (frame_a->get_function () != frame_b->get_function ())\n+\t  return false;\n+\n+\tframe_region *merged_frame = new frame_region (rid_merged_stack,\n+\t\t\t\t\t\t       frame_a->get_function (),\n+\t\t\t\t\t\t       frame_a->get_depth ());\n+\tregion_id rid_merged_frame = merged_model->add_region (merged_frame);\n+\tmerged_stack->push_frame (rid_merged_frame);\n+      }\n+\n+    /* Now populate the frames we created.  */\n+    for (unsigned i = 0; i < stack_region_a->get_num_frames (); i++)\n+      {\n+\tregion_id rid_a = stack_region_a->get_frame_rid (i);\n+\tframe_region *frame_a = merger->get_region_a <frame_region> (rid_a);\n+\n+\tregion_id rid_b = stack_region_b->get_frame_rid (i);\n+\tframe_region *frame_b = merger->get_region_b <frame_region> (rid_b);\n+\n+\tregion_id rid_merged_frame = merged_stack->get_frame_rid (i);\n+\tframe_region *merged_frame\n+\t  = merged_model->get_region <frame_region> (rid_merged_frame);\n+\tif (!map_region::can_merge_p (frame_a, frame_b,\n+\t\t\t\t      merged_frame, rid_merged_frame,\n+\t\t\t\t      merger))\n+\t  return false;\n+      }\n \n   return true;\n }\n@@ -7721,6 +7739,11 @@ test_state_merging ()\n \t\t       integer_type_node);\n   tree addr_of_a = build1 (ADDR_EXPR, ptr_type_node, a);\n \n+  /* Param \"q\", a pointer.  */\n+  tree q = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t       get_identifier (\"q\"),\n+\t\t       ptr_type_node);\n+\n   {\n     region_model model0;\n     region_model model1;\n@@ -7991,6 +8014,60 @@ test_state_merging ()\n     region_model merged;\n     ASSERT_TRUE (model0.can_merge_with_p (model1, &merged));\n   }\n+\n+  /* Verify that we can merge a model in which a local in an older stack\n+     frame points to a local in a more recent stack frame.  */\n+  {\n+    region_model model0;\n+    model0.push_frame (DECL_STRUCT_FUNCTION (test_fndecl), NULL, NULL);\n+    region_id q_in_first_frame = model0.get_lvalue (q, NULL);\n+\n+    /* Push a second frame.  */\n+    region_id rid_2nd_frame\n+      = model0.push_frame (DECL_STRUCT_FUNCTION (test_fndecl), NULL, NULL);\n+\n+    /* Have a pointer in the older frame point to a local in the\n+       more recent frame.  */\n+    svalue_id sid_ptr = model0.get_rvalue (addr_of_a, NULL);\n+    model0.set_value (q_in_first_frame, sid_ptr, NULL);\n+\n+    /* Verify that it's pointing at the newer frame.  */\n+    region_id rid_pointee\n+      = model0.get_svalue (sid_ptr)->dyn_cast_region_svalue ()->get_pointee ();\n+    ASSERT_EQ (model0.get_region (rid_pointee)->get_parent (), rid_2nd_frame);\n+\n+    model0.canonicalize (NULL);\n+\n+    region_model model1 (model0);\n+    ASSERT_EQ (model0, model1);\n+\n+    /* They should be mergeable, and the result should be the same\n+       (after canonicalization, at least).  */\n+    region_model merged;\n+    ASSERT_TRUE (model0.can_merge_with_p (model1, &merged));\n+    merged.canonicalize (NULL);\n+    ASSERT_EQ (model0, merged);\n+  }\n+\n+  /* Verify that we can merge a model in which a local points to a global.  */\n+  {\n+    region_model model0;\n+    model0.push_frame (DECL_STRUCT_FUNCTION (test_fndecl), NULL, NULL);\n+    model0.set_value (model0.get_lvalue (q, NULL),\n+\t\t      model0.get_rvalue (addr_of_y, NULL), NULL);\n+\n+    model0.canonicalize (NULL);\n+\n+    region_model model1 (model0);\n+    ASSERT_EQ (model0, model1);\n+\n+    /* They should be mergeable, and the result should be the same\n+       (after canonicalization, at least).  */\n+    region_model merged;\n+    ASSERT_TRUE (model0.can_merge_with_p (model1, &merged));\n+    merged.canonicalize (NULL);\n+    ASSERT_EQ (model0, merged);\n+  }\n }\n \n /* Verify that constraints are correctly merged when merging region_model"}, {"sha": "f8051b44085035af09beb2cfdb3258b02f03bca8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=455f58ec50465aed9d92dc31d68708a05e499388", "patch": "@@ -1,3 +1,9 @@\n+2020-01-31  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93438\n+\t* gcc.dg/analyzer/torture/pr93438.c: New test.\n+\t* gcc.dg/analyzer/torture/pr93438-2.c: New test.\n+\n 2020-01-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/91838"}, {"sha": "218dc78138b0c04bf8da15bac6cb0fc9d91fc63e", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/pr93438-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93438-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93438-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93438-2.c?ref=455f58ec50465aed9d92dc31d68708a05e499388", "patch": "@@ -0,0 +1,26 @@\n+/* A non-recursive example of state-merger of a pointer\n+   from an old stack frame to a local in a newer stack frame.  */\n+\n+int newer (int **ptr_to_ow, int flag);\n+\n+int\n+older (int flag)\n+{\n+  int *ow;\n+  return newer (&ow, flag);\n+}\n+\n+int\n+newer (int **ptr_to_ow, int flag)\n+{\n+  int pk;\n+  *ptr_to_ow = &pk;\n+  \n+  if (flag)\n+    pk = 3;\n+  else\n+    pk = 4;\n+  /* State merger.  */\n+\n+  return pk;\n+}"}, {"sha": "3a23770a02c2a934909661c123e505efea398ff5", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/pr93438.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93438.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f58ec50465aed9d92dc31d68708a05e499388/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93438.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93438.c?ref=455f58ec50465aed9d92dc31d68708a05e499388", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+void\n+tw (int **la, int pk)\n+{\n+  int *ow = *la;\n+  int jo = !!pk;\n+\n+  if (jo == 0)\n+    *la = &pk;\n+\n+  tw (&ow, pk);\n+}"}]}