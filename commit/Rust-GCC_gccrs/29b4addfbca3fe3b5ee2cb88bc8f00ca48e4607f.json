{"sha": "29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjliNGFkZGZiY2EzZmUzYjVlZTJjYjg4YmM4ZjAwY2E0OGU0NjA3Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-10-31T21:13:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-10-31T21:13:35Z"}, "message": "mips.c (mips_cannot_change_mode_class): Use a stricter mode check.\n\n\t* config/mips/mips.c (mips_cannot_change_mode_class): Use a stricter\n\tmode check.\n\nFrom-SVN: r89917", "tree": {"sha": "1f3ae1c3d3d5de48967c70edb75b39570ae8de6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f3ae1c3d3d5de48967c70edb75b39570ae8de6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f/comments", "author": null, "committer": null, "parents": [{"sha": "3292fb426e5f41ca8d3e134e28a5f9ba04538e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3292fb426e5f41ca8d3e134e28a5f9ba04538e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3292fb426e5f41ca8d3e134e28a5f9ba04538e88"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "b94a3bf1349494c2bf1a665b05baca83bf5205d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f", "patch": "@@ -1,3 +1,8 @@\n+2004-10-31  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_cannot_change_mode_class): Use a stricter\n+\tmode check.\n+\n 2004-10-31  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-common.c: Fix a comment typo."}, {"sha": "4aa3b082a160bf8ac12d09467bd87b95c0a0c723", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=29b4addfbca3fe3b5ee2cb88bc8f00ca48e4607f", "patch": "@@ -6837,35 +6837,44 @@ mips_callee_copies (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n   return mips_abi == ABI_EABI && named;\n }\n \n-/* Return the class of registers for which a mode change from FROM to TO\n-   is invalid.\n-\n-   In little-endian mode, the hi-lo registers are numbered backwards,\n-   so (subreg:SI (reg:DI hi) 0) gets the high word instead of the low\n-   word as intended.\n-\n-   Similarly, when using paired floating-point registers, the first\n-   register holds the low word, regardless of endianness.  So in big\n-   endian mode, (subreg:SI (reg:DF $f0) 0) does not get the high word\n-   as intended.\n-\n-   Also, loading a 32-bit value into a 64-bit floating-point register\n-   will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n-   We can't allow 64-bit float registers to change from a 32-bit\n-   mode to a 64-bit mode.  */\n+/* Return true if registers of class CLASS cannot change from mode FROM\n+   to mode TO.  */\n \n bool\n mips_cannot_change_mode_class (enum machine_mode from,\n \t\t\t       enum machine_mode to, enum reg_class class)\n {\n-  if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n+  if (MIN (GET_MODE_SIZE (from), GET_MODE_SIZE (to)) <= UNITS_PER_WORD\n+      && MAX (GET_MODE_SIZE (from), GET_MODE_SIZE (to)) > UNITS_PER_WORD)\n     {\n       if (TARGET_BIG_ENDIAN)\n-\treturn reg_classes_intersect_p (FP_REGS, class);\n-      if (TARGET_FLOAT64)\n-\treturn reg_classes_intersect_p (HI_AND_FP_REGS, class);\n-      return reg_classes_intersect_p (HI_REG, class);\n+\t{\n+\t  /* When a multi-word value is stored in paired floating-point\n+\t     registers, the first register always holds the low word.\n+\t     We therefore can't allow FPRs to change between single-word\n+\t     and multi-word modes.  */\n+\t  if (FP_INC > 1 && reg_classes_intersect_p (FP_REGS, class))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  /* LO_REGNO == HI_REGNO + 1, so if a multi-word value is stored\n+\t     in LO and HI, the high word always comes first.  We therefore\n+\t     can't allow values stored in HI to change between single-word\n+\t     and multi-word modes.  */\n+\t  if (reg_classes_intersect_p (HI_REG, class))\n+\t    return true;\n+\t}\n     }\n+  /* Loading a 32-bit value into a 64-bit floating-point register\n+     will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n+     We can't allow 64-bit float registers to change from SImode to\n+     to a wider mode.  */\n+  if (TARGET_FLOAT64\n+      && from == SImode\n+      && GET_MODE_SIZE (to) >= UNITS_PER_WORD\n+      && reg_classes_intersect_p (FP_REGS, class))\n+    return true;\n   return false;\n }\n "}]}