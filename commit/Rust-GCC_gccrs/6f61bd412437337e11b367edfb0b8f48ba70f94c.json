{"sha": "6f61bd412437337e11b367edfb0b8f48ba70f94c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY2MWJkNDEyNDM3MzM3ZTExYjM2N2VkZmIwYjhmNDhiYTcwZjk0Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-24T07:09:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-24T07:09:22Z"}, "message": "gigi.h (build_call_alloc_dealloc): Update comment.\n\n\t* gcc-interface/gigi.h (build_call_alloc_dealloc): Update comment.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Pass correct\n\targuments to build_allocator.\n\t* gcc-interface/utils2.c (build_call_alloc_dealloc): Update comment.\n\tRemove code handling special allocator and assert its uselessness.\n\nFrom-SVN: r146671", "tree": {"sha": "0ab8f62695943723e2cff3e7a6ef5922b0016e03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ab8f62695943723e2cff3e7a6ef5922b0016e03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f61bd412437337e11b367edfb0b8f48ba70f94c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f61bd412437337e11b367edfb0b8f48ba70f94c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f61bd412437337e11b367edfb0b8f48ba70f94c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f61bd412437337e11b367edfb0b8f48ba70f94c/comments", "author": null, "committer": null, "parents": [{"sha": "0d858698b6741132801b03c09901c56cd78e5083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d858698b6741132801b03c09901c56cd78e5083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d858698b6741132801b03c09901c56cd78e5083"}], "stats": {"total": 104, "additions": 47, "deletions": 57}, "files": [{"sha": "4760b152face593f0cffb4a2ba1ca309d8ca4702", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6f61bd412437337e11b367edfb0b8f48ba70f94c", "patch": "@@ -1,3 +1,11 @@\n+2009-04-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (build_call_alloc_dealloc): Update comment.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Pass correct\n+\targuments to build_allocator.\n+\t* gcc-interface/utils2.c (build_call_alloc_dealloc): Update comment.\n+\tRemove code handling special allocator and assert its uselessness.\n+\n 2009-04-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: If an"}, {"sha": "c25fb91ef8ebb2062288f5ebd974796efe206440", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=6f61bd412437337e11b367edfb0b8f48ba70f94c", "patch": "@@ -1199,8 +1199,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  post_error (\"?Storage_Error will be raised at run-time!\",\n \t\t\t      gnat_entity);\n \n-\t\tgnu_expr = build_allocator (gnu_alloc_type, gnu_expr, gnu_type,\n-\t\t\t\t\t    0, 0, gnat_entity, mutable_p);\n+\t\tgnu_expr\n+\t\t  = build_allocator (gnu_alloc_type, gnu_expr, gnu_type,\n+\t\t\t\t     Empty, Empty, gnat_entity, mutable_p);\n \t      }\n \t    else\n \t      {"}, {"sha": "fb183bf09d5e76d1cc77c7491d002f189a262648", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=6f61bd412437337e11b367edfb0b8f48ba70f94c", "patch": "@@ -815,19 +815,22 @@ extern tree build_component_ref (tree record_variable, tree component,\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n    generate an allocator.\n \n-   GNU_SIZE is the size of the object and ALIGN is the alignment.\n-   GNAT_PROC, if present is a procedure to call and GNAT_POOL is the\n-   storage pool to use.  If not preset, malloc and free will be used.  */\n+   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment\n+   in bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL\n+   is the storage pool to use.  If not present, malloc and free are used.\n+   GNAT_NODE is used to provide an error location for restriction violation\n+   messages.  */\n extern tree build_call_alloc_dealloc (tree gnu_obj, tree gnu_size,\n                                       unsigned align, Entity_Id gnat_proc,\n \t\t\t\t      Entity_Id gnat_pool, Node_Id gnat_node);\n \n /* Build a GCC tree to correspond to allocating an object of TYPE whose\n    initial value if INIT, if INIT is nonzero.  Convert the expression to\n    RESULT_TYPE, which must be some type of pointer.  Return the tree.\n+\n    GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n    the storage pool to use.  GNAT_NODE is used to provide an error\n-   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n+   location for restriction violation messages.  If IGNORE_INIT_TYPE is\n    true, ignore the type of INIT for the purpose of determining the size;\n    this will cause the maximum size to be allocated if TYPE is of\n    self-referential size.  */"}, {"sha": "a4534b192d27620aacdcf7ce50ca2ce592b4679d", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f61bd412437337e11b367edfb0b8f48ba70f94c/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=6f61bd412437337e11b367edfb0b8f48ba70f94c", "patch": "@@ -1837,11 +1837,11 @@ build_component_ref (tree record_variable, tree component,\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n    generate an allocator.\n \n-   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment in\n-   bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL is the\n-   storage pool to use.  If not preset, malloc and free will be used except\n-   if GNAT_PROC is the \"fake\" value of -1, in which case we allocate the\n-   object dynamically on the stack frame.  */\n+   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment\n+   in bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL\n+   is the storage pool to use.  If not present, malloc and free are used.\n+   GNAT_NODE is used to provide an error location for restriction violation\n+   messages.  */\n \n tree\n build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n@@ -1855,7 +1855,7 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n   if (Present (gnat_proc))\n     {\n       /* The storage pools are obviously always tagged types, but the\n-\t secondary stack uses the same mechanism and is not tagged */\n+\t secondary stack uses the same mechanism and is not tagged.  */\n       if (Is_Tagged_Type (Etype (gnat_pool)))\n \t{\n \t  /* The size is the third parameter; the alignment is the\n@@ -1890,7 +1890,7 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n       /* Secondary stack case.  */\n       else\n \t{\n-\t  /* The size is the second parameter */\n+\t  /* The size is the second parameter.  */\n \t  Entity_Id gnat_size_type\n \t    = Etype (Next_Formal (First_Formal (gnat_proc)));\n \t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n@@ -1900,8 +1900,8 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \n \t  gnu_size = convert (gnu_size_type, gnu_size);\n \n-\t  /* The first arg is the address of the object, for a\n-\t     deallocator, then the size */\n+\t  /* The first arg is the address of the object, for a deallocator,\n+\t     then the size.  */\n \t  if (gnu_obj)\n \t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n \t\t\t\t\tgnu_proc_addr, 2, gnu_obj, gnu_size);\n@@ -1913,57 +1913,35 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t}\n     }\n \n-  else if (gnu_obj)\n+  if (gnu_obj)\n     return build_call_1_expr (free_decl, gnu_obj);\n \n-  /* ??? For now, disable variable-sized allocators in the stack since\n-     we can't yet gimplify an ALLOCATE_EXPR.  */\n-  else if (gnat_pool == -1\n-\t   && TREE_CODE (gnu_size) == INTEGER_CST\n-\t   && flag_stack_check != GENERIC_STACK_CHECK)\n-    {\n-      /* If the size is a constant, we can put it in the fixed portion of\n-\t the stack frame to avoid the need to adjust the stack pointer.  */\n-\t{\n-\t  tree gnu_index = build_index_2_type (size_one_node, gnu_size);\n-\t  tree gnu_array_type = build_array_type (char_type_node, gnu_index);\n-\t  tree gnu_decl\n-\t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n-\t\t\t       gnu_array_type, NULL_TREE, false, false, false,\n-\t\t\t       false, NULL, gnat_node);\n-\t  return convert (ptr_void_type_node,\n-\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n-\t}\n-#if 0\n-      else\n-\treturn build2 (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n-#endif\n-    }\n-  else\n-    {\n-      if (Nkind (gnat_node) != N_Allocator || !Comes_From_Source (gnat_node))\n-        Check_No_Implicit_Heap_Alloc (gnat_node);\n-\n-      /* If the allocator size is 32bits but the pointer size is 64bits then\n-\t allocate 32bit memory (sometimes necessary on 64bit VMS). Otherwise\n-\t default to standard malloc. */\n-      if (TARGET_ABI_OPEN_VMS &&\n-          (!TARGET_MALLOC64 ||\n-           (POINTER_SIZE == 64\n-\t    && (UI_To_Int (Esize (Etype (gnat_node))) == 32\n-\t        || Convention (Etype (gnat_node)) == Convention_C))))\n-        return build_call_1_expr (malloc32_decl, gnu_size);\n-      else\n-        return build_call_1_expr (malloc_decl, gnu_size);\n-    }\n+  /* Assert that we no longer can be called with this special pool.  */\n+  gcc_assert (gnat_pool != -1);\n+\n+  /* Check that we aren't violating the associated restriction.  */\n+  if (!(Nkind (gnat_node) == N_Allocator && Comes_From_Source (gnat_node)))\n+    Check_No_Implicit_Heap_Alloc (gnat_node);\n+\n+  /* On VMS, if 64-bit memory is disabled or pointers are 64-bit and the\n+     allocator size is 32-bit or Convention C, allocate 32-bit memory.  */\n+  if (TARGET_ABI_OPEN_VMS\n+      && (!TARGET_MALLOC64\n+\t  || (POINTER_SIZE == 64\n+\t      && (UI_To_Int (Esize (Etype (gnat_node))) == 32\n+\t\t  || Convention (Etype (gnat_node)) == Convention_C))))\n+    return build_call_1_expr (malloc32_decl, gnu_size);\n+\n+  return build_call_1_expr (malloc_decl, gnu_size);\n }\n \f\n /* Build a GCC tree to correspond to allocating an object of TYPE whose\n    initial value is INIT, if INIT is nonzero.  Convert the expression to\n    RESULT_TYPE, which must be some type of pointer.  Return the tree.\n+\n    GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n    the storage pool to use.  GNAT_NODE is used to provide an error\n-   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n+   location for restriction violation messages.  If IGNORE_INIT_TYPE is\n    true, ignore the type of INIT for the purpose of determining the size;\n    this will cause the maximum size to be allocated if TYPE is of\n    self-referential size.  */"}]}