{"sha": "b399f3c6425f6c33b64e813899cbd589288ef716", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM5OWYzYzY0MjVmNmMzM2I2NGU4MTM4OTljYmQ1ODkyODhlZjcxNg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-07-17T12:10:28Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-07-17T12:10:28Z"}, "message": "AArch64: Fix bugs in -mcpu=native detection.\n\nThis patch fixes a couple of issues in AArch64's -mcpu=native processing:\n\nThe buffer used to read the lines from /proc/cpuinfo is 128 bytes long.  While\nthis was enough in the past with the increase in architecture extensions it is\nno longer enough.   It results in two bugs:\n\n1) No option string longer than 127 characters is correctly parsed.  Features\n   that are supported are silently ignored.\n\n2) It incorrectly enables features that are not present on the machine:\n  a) It checks for substring matching instead of full word matching.  This makes\n     it incorrectly detect sb support when ssbs is provided instead.\n  b) Due to the truncation at the 127 char border it also incorrectly enables\n     features due to the full feature being cut off and the part that is left\n     accidentally enables something else.\n\nThis breaks -mcpu=native detection on some of our newer system.\n\nThe patch fixes these issues by reading full lines up to the \\n in a string.\nThis gives us the full feature line.  Secondly it creates a set from this string\nto:\n\n 1) Reduce matching complexity from O(n*m) to O(n*logm).\n 2) Perform whole word matching instead of substring matching.\n\nTo make this code somewhat cleaner I also changed from using char* to using\nstd::string and std::set.\n\nNote that I have intentionally avoided the use of ifstream and stringstream\nto make it easier to backport.  I have also not change the substring matching\nfor the initial line classification as I cannot find a documented cpuinfo format\nwhich leads me to believe there may be kernels out there that require this which\nmay be why the original code does this.\n\nI also do not want this to break if the kernel adds a new line that is long and\nindents the file by two tabs to keep everything aligned.  In short I think an\nimprecise match is the right thing here.\n\nTest for this is added as the last thing in this series as it requires some\nchanges to be made to be able to test this.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/driver-aarch64.c (INCLUDE_SET): New.\n\t(parse_field): Use std::string.\n\t(split_words, readline, find_field): New.\n\t(host_detect_local_cpu): Fix truncation issues.", "tree": {"sha": "e080c1808c5f228c5edd367d2cd339ce4948915c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e080c1808c5f228c5edd367d2cd339ce4948915c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b399f3c6425f6c33b64e813899cbd589288ef716", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b399f3c6425f6c33b64e813899cbd589288ef716", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b399f3c6425f6c33b64e813899cbd589288ef716", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b399f3c6425f6c33b64e813899cbd589288ef716/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42b47dae498aa7b849b9c9a165b22146de1934a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b47dae498aa7b849b9c9a165b22146de1934a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42b47dae498aa7b849b9c9a165b22146de1934a1"}], "stats": {"total": 133, "additions": 103, "deletions": 30}, "files": [{"sha": "23657162c22368285abd98983a4e32ec15964d10", "filename": "gcc/config/aarch64/driver-aarch64.c", "status": "modified", "additions": 103, "deletions": 30, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b399f3c6425f6c33b64e813899cbd589288ef716/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b399f3c6425f6c33b64e813899cbd589288ef716/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c?ref=b399f3c6425f6c33b64e813899cbd589288ef716", "patch": "@@ -21,6 +21,7 @@\n \n #include \"config.h\"\n #define INCLUDE_STRING\n+#define INCLUDE_SET\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n@@ -116,16 +117,92 @@ valid_bL_core_p (unsigned int *core, unsigned int bL_core)\n /* Returns the hex integer that is after ':' for the FIELD.\n    Returns -1 is returned if there was problem parsing the integer. */\n static unsigned\n-parse_field (const char *field)\n+parse_field (const std::string &field)\n {\n-  const char *rest = strchr (field, ':');\n+  const char *rest = strchr (field.c_str (), ':');\n+\n+  /* The line must be in the format of <name>:<value>, if it's not\n+     then we have a weird format.  */\n+  if (rest == NULL)\n+    return -1;\n+\n   char *after;\n   unsigned fint = strtol (rest + 1, &after, 16);\n   if (after == rest + 1)\n     return -1;\n   return fint;\n }\n \n+/* Returns the index of the ':' inside the FIELD which must be found\n+   after the value of KEY.  Returns string::npos if line does not contain\n+   a field.  */\n+\n+static size_t\n+find_field (const std::string &field, const std::string &key)\n+{\n+  size_t key_pos, sep_pos;\n+  key_pos = field.find (key);\n+  if (key_pos == std::string::npos)\n+    return std::string::npos;\n+\n+  sep_pos = field.find (\":\", key_pos + 1);\n+  if (sep_pos == std::string::npos)\n+    return std::string::npos;\n+\n+  return sep_pos;\n+}\n+\n+/* Splits and returns a string based on whitespace and return it as\n+   part of a set. Empty strings are ignored.  */\n+\n+static void\n+split_words (const std::string &val, std::set<std::string> &result)\n+{\n+  size_t cur, prev = 0;\n+  std::string word;\n+  while ((cur = val.find_first_of (\" \\n\", prev)) != std::string::npos)\n+    {\n+      word = val.substr (prev, cur - prev);\n+      /* Skip adding empty words.  */\n+      if (!word.empty ())\n+\tresult.insert (word);\n+      prev = cur + 1;\n+    }\n+\n+  if (prev != cur)\n+    result.insert (val.substr (prev));\n+}\n+\n+/* Read an entire line from F until '\\n' or EOF.  */\n+\n+static std::string\n+readline (FILE *f)\n+{\n+  char *buf = NULL;\n+  int size = 0;\n+  int last = 0;\n+  const int buf_size = 128;\n+\n+  if (feof (f))\n+    return std::string ();\n+\n+  do\n+    {\n+      size += buf_size;\n+      buf = (char*) xrealloc (buf, size);\n+      gcc_assert (buf);\n+      fgets (buf + last, buf_size, f);\n+      /* If we're not at the end of the line then override the\n+\t \\0 added by fgets.  */\n+      last = strlen (buf) - 1;\n+    }\n+  while (!feof (f) && buf[last] != '\\n');\n+\n+  std::string result (buf);\n+  free (buf);\n+  return result;\n+}\n+\n /*  Return true iff ARR contains CORE, in either of the two elements. */\n \n static bool\n@@ -164,7 +241,6 @@ host_detect_local_cpu (int argc, const char **argv)\n {\n   const char *res = NULL;\n   static const int num_exts = ARRAY_SIZE (aarch64_extensions);\n-  char buf[128];\n   FILE *f = NULL;\n   bool arch = false;\n   bool tune = false;\n@@ -178,6 +254,8 @@ host_detect_local_cpu (int argc, const char **argv)\n   bool processed_exts = false;\n   uint64_t extension_flags = 0;\n   uint64_t default_flags = 0;\n+  std::string buf;\n+  size_t sep_pos = -1;\n \n   gcc_assert (argc);\n \n@@ -202,9 +280,9 @@ host_detect_local_cpu (int argc, const char **argv)\n \n   /* Look through /proc/cpuinfo to determine the implementer\n      and then the part number that identifies a particular core.  */\n-  while (fgets (buf, sizeof (buf), f) != NULL)\n+  while (!(buf = readline (f)).empty ())\n     {\n-      if (strstr (buf, \"implementer\") != NULL)\n+      if (find_field (buf, \"implementer\") != std::string::npos)\n \t{\n \t  unsigned cimp = parse_field (buf);\n \t  if (cimp == INVALID_IMP)\n@@ -216,8 +294,7 @@ host_detect_local_cpu (int argc, const char **argv)\n \t  else if (imp != cimp)\n \t    goto not_found;\n \t}\n-\n-      if (strstr (buf, \"variant\") != NULL)\n+      else if (find_field (buf, \"variant\") != std::string::npos)\n \t{\n \t  unsigned cvariant = parse_field (buf);\n \t  if (!contains_core_p (variants, cvariant))\n@@ -229,8 +306,7 @@ host_detect_local_cpu (int argc, const char **argv)\n \t    }\n           continue;\n         }\n-\n-      if (strstr (buf, \"part\") != NULL)\n+      else if (find_field (buf, \"part\") != std::string::npos)\n \t{\n \t  unsigned ccore = parse_field (buf);\n \t  if (!contains_core_p (cores, ccore))\n@@ -242,39 +318,36 @@ host_detect_local_cpu (int argc, const char **argv)\n \t    }\n \t  continue;\n \t}\n-      if (!tune && !processed_exts && strstr (buf, \"Features\") != NULL)\n+      else if (!tune && !processed_exts\n+\t       && (sep_pos = find_field (buf, \"Features\")) != std::string::npos)\n \t{\n+\t  /* First create the list of features in the buffer.  */\n+\t  std::set<std::string> features;\n+\t  /* Drop everything till the :.  */\n+\t  buf = buf.substr (sep_pos + 1);\n+\t  split_words (buf, features);\n+\n \t  for (i = 0; i < num_exts; i++)\n \t    {\n-\t      const char *p = aarch64_extensions[i].feat_string;\n+\t      const std::string val (aarch64_extensions[i].feat_string);\n \n \t      /* If the feature contains no HWCAPS string then ignore it for the\n \t\t auto detection.  */\n-\t      if (*p == '\\0')\n+\t      if (val.empty ())\n \t\tcontinue;\n \n \t      bool enabled = true;\n \n \t      /* This may be a multi-token feature string.  We need\n \t\t to match all parts, which could be in any order.  */\n-\t      size_t len = strlen (buf);\n-\t      do\n-\t\t{\n-\t\t  const char *end = strchr (p, ' ');\n-\t\t  if (end == NULL)\n-\t\t    end = strchr (p, '\\0');\n-\t\t  if (memmem (buf, len, p, end - p) == NULL)\n-\t\t    {\n-\t\t      /* Failed to match this token.  Turn off the\n-\t\t\t features we'd otherwise enable.  */\n-\t\t      enabled = false;\n-\t\t      break;\n-\t\t    }\n-\t\t  if (*end == '\\0')\n-\t\t    break;\n-\t\t  p = end + 1;\n-\t\t}\n-\t      while (1);\n+\t      std::set<std::string> tokens;\n+\t      split_words (val, tokens);\n+\t      std::set<std::string>::iterator it;\n+\n+\t      /* Iterate till the first feature isn't found or all of them\n+\t\t are found.  */\n+\t      for (it = tokens.begin (); enabled && it != tokens.end (); ++it)\n+\t\tenabled = enabled && features.count (*it);\n \n \t      if (enabled)\n \t\textension_flags |= aarch64_extensions[i].flag;"}]}