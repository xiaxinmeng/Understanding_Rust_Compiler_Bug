{"sha": "9e04287b861dc1cc8f19dce11b9c3147213c34b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUwNDI4N2I4NjFkYzFjYzhmMTlkY2UxMWI5YzMxNDcyMTNjMzRiNw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-01-05T09:11:19Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-01-05T09:11:19Z"}, "message": "class.c (finalize_component): Used passed offset expr.\n\n2013-01-05  Tobias Burnus  <burnus@net-b.de>\n\n        * class.c (finalize_component): Used passed offset expr.\n        (finalization_get_offset): New static function.\n        (finalizer_insert_packed_call, generate_finalization_wrapper):\n        Use it to handle noncontiguous arrays.\n\nFrom-SVN: r194927", "tree": {"sha": "60ded7699c29b5f8c61ac8a2d1152d2b9fa77575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60ded7699c29b5f8c61ac8a2d1152d2b9fa77575"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e04287b861dc1cc8f19dce11b9c3147213c34b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e04287b861dc1cc8f19dce11b9c3147213c34b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e04287b861dc1cc8f19dce11b9c3147213c34b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e04287b861dc1cc8f19dce11b9c3147213c34b7/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87f397d7a3a54e5c42e92129b0808092ee2ef97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f397d7a3a54e5c42e92129b0808092ee2ef97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f397d7a3a54e5c42e92129b0808092ee2ef97d"}], "stats": {"total": 760, "additions": 594, "deletions": 166}, "files": [{"sha": "bab3db4cd1304468be85442a6ce873eaf9682959", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e04287b861dc1cc8f19dce11b9c3147213c34b7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e04287b861dc1cc8f19dce11b9c3147213c34b7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9e04287b861dc1cc8f19dce11b9c3147213c34b7", "patch": "@@ -1,3 +1,10 @@\n+2013-01-05  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* class.c (finalize_component): Used passed offset expr.\n+\t(finalization_get_offset): New static function.\n+\t(finalizer_insert_packed_call, generate_finalization_wrapper): Use it\n+\tto handle noncontiguous arrays.\n+\n 2013-01-04  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans.c (gfc_build_final_call): New function."}, {"sha": "1b1e85d07c05a995cdaf53a799dad06c73501c4f", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 587, "deletions": 166, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e04287b861dc1cc8f19dce11b9c3147213c34b7/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e04287b861dc1cc8f19dce11b9c3147213c34b7/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=9e04287b861dc1cc8f19dce11b9c3147213c34b7", "patch": "@@ -924,14 +924,14 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n \n /* Generate code equivalent to\n    CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n-\t\t     + idx * stride, c_ptr), ptr).  */\n+\t\t     + offset, c_ptr), ptr).  */\n \n static gfc_code *\n-finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n-\t\t\t gfc_expr *stride, gfc_namespace *sub_ns)\n+finalization_scalarizer (gfc_symbol *array, gfc_symbol *ptr,\n+\t\t\t gfc_expr *offset, gfc_namespace *sub_ns)\n {\n   gfc_code *block;\n-  gfc_expr *expr, *expr2, *expr3;\n+  gfc_expr *expr, *expr2;\n \n   /* C_F_POINTER().  */\n   block = XCNEW (gfc_code);\n@@ -961,6 +961,7 @@ finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n \t    = gfc_intrinsic_function_by_id (GFC_ISYM_TRANSFER);\n   /* Set symtree for -fdump-parse-tree.  */\n   gfc_get_sym_tree (\"transfer\", sub_ns, &expr2->symtree, false);\n+  expr2->symtree->n.sym->intmod_sym_id = GFC_ISYM_TRANSFER;\n   expr2->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n   expr2->symtree->n.sym->attr.intrinsic = 1;\n   gfc_commit_symbol (expr2->symtree->n.sym);\n@@ -995,21 +996,12 @@ finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n   expr->ts.kind = gfc_index_integer_kind;\n   expr2->value.function.actual->expr = expr;\n \n-  /* Offset calculation: idx * stride (in bytes).  */\n-  block->ext.actual->expr = gfc_get_expr ();\n-  expr3 = block->ext.actual->expr;\n-  expr3->expr_type = EXPR_OP;\n-  expr3->value.op.op = INTRINSIC_TIMES;\n-  expr3->value.op.op1 = gfc_lval_expr_from_sym (idx);\n-  expr3->value.op.op2 = stride;\n-  expr3->ts = expr->ts;\n-\n   /* <array addr> + <offset>.  */\n   block->ext.actual->expr = gfc_get_expr ();\n   block->ext.actual->expr->expr_type = EXPR_OP;\n   block->ext.actual->expr->value.op.op = INTRINSIC_PLUS;\n   block->ext.actual->expr->value.op.op1 = expr2;\n-  block->ext.actual->expr->value.op.op2 = expr3;\n+  block->ext.actual->expr->value.op.op2 = offset;\n   block->ext.actual->expr->ts = expr->ts;\n \n   /* C_F_POINTER's 2nd arg: ptr -- and its absent shape=.  */\n@@ -1021,39 +1013,183 @@ finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n }\n \n \n+/* Calculates the offset to the (idx+1)th element of an array, taking the\n+   stride into account. It generates the code:\n+     offset = 0\n+     do idx2 = 1, rank\n+       offset = offset + mod (idx, sizes(idx2)) / sizes(idx2-1) * strides(idx2)\n+     end do\n+     offset = offset * byte_stride.  */\n+\n+static gfc_code*\n+finalization_get_offset (gfc_symbol *idx, gfc_symbol *idx2, gfc_symbol *offset,\n+\t\t\t gfc_symbol *strides, gfc_symbol *sizes,\n+\t\t\t gfc_symbol *byte_stride, gfc_expr *rank,\n+\t\t\t gfc_code *block, gfc_namespace *sub_ns)\n+{\n+  gfc_iterator *iter;\n+  gfc_expr *expr, *expr2;\n+\n+  /* offset = 0.  */\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_ASSIGN;\n+  block->loc = gfc_current_locus;\n+  block->expr1 = gfc_lval_expr_from_sym (offset);\n+  block->expr2 = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+\n+  /* Create loop.  */\n+  iter = gfc_get_iterator ();\n+  iter->var = gfc_lval_expr_from_sym (idx2);\n+  iter->start = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  iter->end = gfc_copy_expr (rank);\n+  iter->step = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_DO;\n+  block->loc = gfc_current_locus;\n+  block->ext.iterator = iter;\n+  block->block = gfc_get_code ();\n+  block->block->op = EXEC_DO;\n+\n+  /* Loop body: offset = offset + mod (idx, sizes(idx2)) / sizes(idx2-1)\n+\t\t\t\t  * strides(idx2).  */\n+\n+  /* mod (idx, sizes(idx2)).  */\n+  expr = gfc_get_expr ();\n+  expr->expr_type = EXPR_FUNCTION;\n+  expr->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_MOD);\n+  gfc_get_sym_tree (\"mod\", sub_ns, &expr->symtree, false);\n+  expr->symtree->n.sym->intmod_sym_id = GFC_ISYM_MOD;\n+  expr->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  expr->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (expr->symtree->n.sym);\n+  expr->value.function.actual = gfc_get_actual_arglist ();\n+  expr->value.function.actual->expr = gfc_lval_expr_from_sym (idx);\n+  expr->value.function.actual->next = gfc_get_actual_arglist ();\n+  expr->value.function.actual->next->expr = gfc_lval_expr_from_sym (sizes);\n+  expr->value.function.actual->next->expr->ref = gfc_get_ref ();\n+  expr->value.function.actual->next->expr->ref->type = REF_ARRAY;\n+  expr->value.function.actual->next->expr->ref->u.ar.as = sizes->as;\n+  expr->value.function.actual->next->expr->ref->u.ar.type = AR_ELEMENT;\n+  expr->value.function.actual->next->expr->ref->u.ar.dimen = 1;\n+  expr->value.function.actual->next->expr->ref->u.ar.dimen_type[0]\n+\t= DIMEN_ELEMENT;\n+  expr->value.function.actual->next->expr->ref->u.ar.start[0]\n+\t= gfc_lval_expr_from_sym (idx2);\n+  expr->ts = idx->ts;\n+\n+  /* (...) / sizes(idx2-1).  */\n+  expr2 = gfc_get_expr ();\n+  expr2->expr_type = EXPR_OP;\n+  expr2->value.op.op = INTRINSIC_DIVIDE;\n+  expr2->value.op.op1 = expr;\n+  expr2->value.op.op2 = gfc_lval_expr_from_sym (sizes);\n+  expr2->value.op.op2->ref = gfc_get_ref ();\n+  expr2->value.op.op2->ref->type = REF_ARRAY;\n+  expr2->value.op.op2->ref->u.ar.as = sizes->as;\n+  expr2->value.op.op2->ref->u.ar.type = AR_ELEMENT;\n+  expr2->value.op.op2->ref->u.ar.dimen = 1;\n+  expr2->value.op.op2->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  expr2->value.op.op2->ref->u.ar.start[0] = gfc_get_expr ();\n+  expr2->value.op.op2->ref->u.ar.start[0]->expr_type = EXPR_OP;\n+  expr2->value.op.op2->ref->u.ar.start[0]->value.op.op = INTRINSIC_MINUS;\n+  expr2->value.op.op2->ref->u.ar.start[0]->value.op.op1\n+\t= gfc_lval_expr_from_sym (idx2);\n+  expr2->value.op.op2->ref->u.ar.start[0]->value.op.op2\n+\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  expr2->value.op.op2->ref->u.ar.start[0]->ts\n+\t= expr2->value.op.op2->ref->u.ar.start[0]->value.op.op1->ts;\n+  expr2->ts = idx->ts;\n+\n+  /* ... * strides(idx2).  */\n+  expr = gfc_get_expr ();\n+  expr->expr_type = EXPR_OP;\n+  expr->value.op.op = INTRINSIC_TIMES;\n+  expr->value.op.op1 = expr2;\n+  expr->value.op.op2 = gfc_lval_expr_from_sym (strides);\n+  expr->value.op.op2->ref = gfc_get_ref ();\n+  expr->value.op.op2->ref->type = REF_ARRAY;\n+  expr->value.op.op2->ref->u.ar.type = AR_ELEMENT;\n+  expr->value.op.op2->ref->u.ar.dimen = 1;\n+  expr->value.op.op2->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  expr->value.op.op2->ref->u.ar.start[0] = gfc_lval_expr_from_sym (idx2);\n+  expr->value.op.op2->ref->u.ar.as = strides->as;\n+  expr->ts = idx->ts;\n+\n+  /* offset = offset + ...  */\n+  block->block->next = XCNEW (gfc_code);\n+  block->block->next->op = EXEC_ASSIGN;\n+  block->block->next->loc = gfc_current_locus;\n+  block->block->next->expr1 = gfc_lval_expr_from_sym (offset);\n+  block->block->next->expr2 = gfc_get_expr ();\n+  block->block->next->expr2->expr_type = EXPR_OP;\n+  block->block->next->expr2->value.op.op = INTRINSIC_PLUS;\n+  block->block->next->expr2->value.op.op1 = gfc_lval_expr_from_sym (offset);\n+  block->block->next->expr2->value.op.op2 = expr;\n+  block->block->next->expr2->ts = idx->ts;\n+\n+  /* After the loop:  offset = offset * byte_stride.  */\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_ASSIGN;\n+  block->loc = gfc_current_locus;\n+  block->expr1 = gfc_lval_expr_from_sym (offset);\n+  block->expr2 = gfc_get_expr ();\n+  block->expr2->expr_type = EXPR_OP;\n+  block->expr2->value.op.op = INTRINSIC_TIMES;\n+  block->expr2->value.op.op1 = gfc_lval_expr_from_sym (offset);\n+  block->expr2->value.op.op2 = gfc_lval_expr_from_sym (byte_stride);\n+  block->expr2->ts = block->expr2->value.op.op1->ts;\n+  return block;\n+}\n+\n+\n /* Insert code of the following form:\n \n-   if (stride == STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE\n-       || 0 == STORAGE_SIZE (array)) then\n-     call final_rank3 (array)\n-   else\n-     block\n-       type(t) :: tmp(shape (array))\n-\n-       do i = 0, size (array)-1\n-\t addr = transfer (c_loc (array), addr) + i * stride\n-\t call c_f_pointer (transfer (addr, cptr), ptr)\n-\n-\t addr = transfer (c_loc (tmp), addr)\n-\t\t\t  + i * STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE\n-\t call c_f_pointer (transfer (addr, cptr), ptr2)\n-\t ptr2 = ptr\n-       end do\n-       call final_rank3 (tmp)\n-     end block\n-   end if  */\n+   block\n+     integer(c_intptr_t) :: i\n+\n+     if ((byte_stride == STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE\n+\t  && (is_contiguous || !final_rank3->attr.contiguous\n+\t      || final_rank3->as->type != AS_ASSUMED_SHAPE))\n+         || 0 == STORAGE_SIZE (array)) then\n+       call final_rank3 (array)\n+     else\n+       block\n+         integer(c_intptr_t) :: offset, j\n+         type(t) :: tmp(shape (array))\n+\n+         do i = 0, size (array)-1\n+\t   offset = obtain_offset(i, strides, sizes, byte_stride)\n+\t   addr = transfer (c_loc (array), addr) + offset\n+\t   call c_f_pointer (transfer (addr, cptr), ptr)\n+\n+\t   addr = transfer (c_loc (tmp), addr)\n+\t\t\t    + i * STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE\n+\t   call c_f_pointer (transfer (addr, cptr), ptr2)\n+\t   ptr2 = ptr\n+         end do\n+         call final_rank3 (tmp)\n+       end block\n+     end if\n+   block  */\n \n static void\n finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n-\t\t\t      gfc_symbol *array, gfc_symbol *stride,\n+\t\t\t      gfc_symbol *array, gfc_symbol *byte_stride,\n \t\t\t      gfc_symbol *idx, gfc_symbol *ptr,\n \t\t\t      gfc_symbol *nelem, gfc_symtree *size_intr,\n+\t\t\t      gfc_symbol *strides, gfc_symbol *sizes,\n+\t\t\t      gfc_symbol *idx2, gfc_symbol *offset,\n+\t\t\t      gfc_symbol *is_contiguous, gfc_expr *rank,\n \t\t\t      gfc_namespace *sub_ns)\n {\n   gfc_symbol *tmp_array, *ptr2;\n-  gfc_expr *size_expr;\n+  gfc_expr *size_expr, *offset2, *expr;\n   gfc_namespace *ns;\n   gfc_iterator *iter;\n+  gfc_code *block2;\n   int i;\n \n   block->next = XCNEW (gfc_code);\n@@ -1080,6 +1216,8 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n                = gfc_intrinsic_function_by_id (GFC_ISYM_STORAGE_SIZE);\n   gfc_get_sym_tree (\"storage_size\", sub_ns, &size_expr->value.op.op1->symtree,\n \t\t    false);\n+  size_expr->value.op.op1->symtree->n.sym->intmod_sym_id\n+\t= GFC_ISYM_STORAGE_SIZE;\n   size_expr->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n   size_expr->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n   gfc_commit_symbol (size_expr->value.op.op1->symtree->n.sym);\n@@ -1096,32 +1234,53 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   size_expr->value.op.op1->ts = size_expr->value.op.op2->ts;\n   size_expr->ts = size_expr->value.op.op1->ts;\n \n-  /* IF condition: stride == size_expr || 0 == size_expr.  */\n+  /* IF condition: (stride == size_expr\n+\t\t    && ((fini's as->ASSUMED_SIZE && !fini's attr.contiguous)\n+\t\t\t|| is_contiguous)\n+\t\t   || 0 == size_expr.  */\n   block->expr1 = gfc_get_expr ();\n   block->expr1->expr_type = EXPR_FUNCTION;\n   block->expr1->ts.type = BT_LOGICAL;\n-  block->expr1->ts.kind = 4;\n+  block->expr1->ts.kind = gfc_default_logical_kind;\n   block->expr1->expr_type = EXPR_OP;\n   block->expr1->where = gfc_current_locus;\n \n   block->expr1->value.op.op = INTRINSIC_OR;\n \n-  /* stride == size_expr */\n-  block->expr1->value.op.op1 = gfc_get_expr ();\n-  block->expr1->value.op.op1->expr_type = EXPR_FUNCTION;\n-  block->expr1->value.op.op1->ts.type = BT_LOGICAL;\n-  block->expr1->value.op.op1->ts.kind = 4;\n-  block->expr1->value.op.op1->expr_type = EXPR_OP;\n-  block->expr1->value.op.op1->where = gfc_current_locus;\n-  block->expr1->value.op.op1->value.op.op = INTRINSIC_EQ;\n-  block->expr1->value.op.op1->value.op.op1 = gfc_lval_expr_from_sym (stride);\n-  block->expr1->value.op.op1->value.op.op2 = size_expr;\n+  /* byte_stride == size_expr */\n+  expr = gfc_get_expr ();\n+  expr->ts.type = BT_LOGICAL;\n+  expr->ts.kind = gfc_default_logical_kind;\n+  expr->expr_type = EXPR_OP;\n+  expr->where = gfc_current_locus;\n+  expr->value.op.op = INTRINSIC_EQ;\n+  expr->value.op.op1\n+\t= gfc_lval_expr_from_sym (byte_stride);\n+  expr->value.op.op2 = size_expr;\n+\n+  /* If strides aren't allowd (not assumed shape or CONTIGUOUS),\n+     add is_contiguous check.  */\n+  if (fini->proc_tree->n.sym->formal->sym->as->type != AS_ASSUMED_SHAPE\n+      || fini->proc_tree->n.sym->formal->sym->attr.contiguous)\n+    {\n+      gfc_expr *expr2;\n+      expr2 = gfc_get_expr ();\n+      expr2->ts.type = BT_LOGICAL;\n+      expr2->ts.kind = gfc_default_logical_kind;\n+      expr2->expr_type = EXPR_OP;\n+      expr2->where = gfc_current_locus;\n+      expr2->value.op.op = INTRINSIC_AND;\n+      expr2->value.op.op1 = expr;\n+      expr2->value.op.op2 = gfc_lval_expr_from_sym (is_contiguous);\n+      expr = expr2;\n+    }\n+\n+  block->expr1->value.op.op1 = expr;\n \n   /* 0 == size_expr */\n   block->expr1->value.op.op2 = gfc_get_expr ();\n-  block->expr1->value.op.op2->expr_type = EXPR_FUNCTION;\n   block->expr1->value.op.op2->ts.type = BT_LOGICAL;\n-  block->expr1->value.op.op2->ts.kind = 4;\n+  block->expr1->value.op.op2->ts.kind = gfc_default_logical_kind;\n   block->expr1->value.op.op2->expr_type = EXPR_OP;\n   block->expr1->value.op.op2->where = gfc_current_locus;\n   block->expr1->value.op.op2->value.op.op = INTRINSIC_EQ;\n@@ -1168,7 +1327,6 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   tmp_array->ts.type = BT_DERIVED;\n   tmp_array->ts.u.derived = array->ts.u.derived;\n   tmp_array->attr.flavor = FL_VARIABLE;\n-  tmp_array->attr.contiguous = 1;\n   tmp_array->attr.dimension = 1;\n   tmp_array->attr.artificial = 1;\n   tmp_array->as = gfc_get_array_spec();\n@@ -1217,22 +1375,36 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   block->block = gfc_get_code ();\n   block->block->op = EXEC_DO;\n \n+  /* Offset calculation for the new array: idx * size of type (in bytes).  */\n+  offset2 = gfc_get_expr ();\n+  offset2 = block->ext.actual->expr;\n+  offset2->expr_type = EXPR_OP;\n+  offset2->value.op.op = INTRINSIC_TIMES;\n+  offset2->value.op.op1 = gfc_lval_expr_from_sym (idx);\n+  offset2->value.op.op2 = gfc_copy_expr (size_expr);\n+  offset2->ts = byte_stride->ts;\n+\n+  /* Offset calculation of \"array\".  */\n+  block2 = finalization_get_offset (idx, idx2, offset, strides, sizes,\n+\t\t\t\t    byte_stride, rank, block->block, sub_ns);\n+\n   /* Create code for\n      CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n \t\t       + idx * stride, c_ptr), ptr).  */\n-  block->block->next = finalization_scalarizer (idx, array, ptr,\n-\t\t\t\t\t\tgfc_lval_expr_from_sym (stride),\n-\t\t\t\t\t\tsub_ns);\n-  block->block->next->next = finalization_scalarizer (idx, tmp_array, ptr2,\n-\t\t\t\t\t\t      gfc_copy_expr (size_expr),\n-\t\t\t\t\t\t      sub_ns);\n+  block2->next = finalization_scalarizer (array, ptr,\n+\t\t\t\t\t  gfc_lval_expr_from_sym (offset),\n+\t\t\t\t\t  sub_ns);\n+  block2 = block2->next;\n+  block2->next = finalization_scalarizer (tmp_array, ptr2, offset2, sub_ns);\n+\n   /* ptr2 = ptr.  */\n-  block->block->next->next->next = XCNEW (gfc_code);\n-  block->block->next->next->next->op = EXEC_ASSIGN;\n-  block->block->next->next->next->loc = gfc_current_locus;\n-  block->block->next->next->next->expr1 = gfc_lval_expr_from_sym (ptr2);\n-  block->block->next->next->next->expr2 = gfc_lval_expr_from_sym (ptr);\n+  block2->next = XCNEW (gfc_code);\n+  block2->next->op = EXEC_ASSIGN;\n+  block2->next->loc = gfc_current_locus;\n+  block2->next->expr1 = gfc_lval_expr_from_sym (ptr2);\n+  block2->next->expr2 = gfc_lval_expr_from_sym (ptr);\n \n+  /* Call now the user's final subroutine. */\n   block->next  = XCNEW (gfc_code);\n   block = block->next;\n   block->op = EXEC_CALL;\n@@ -1262,21 +1434,26 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   block->block = gfc_get_code ();\n   block->block->op = EXEC_DO;\n \n+  /* Offset calculation of \"array\".  */\n+  block2 = finalization_get_offset (idx, idx2, offset, strides, sizes,\n+\t\t\t\t    byte_stride, rank, block->block, sub_ns);\n+\n   /* Create code for\n      CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n-\t\t       + idx * stride, c_ptr), ptr).  */\n-  block->block->next = finalization_scalarizer (idx, array, ptr,\n-\t\t\t\t\t\tgfc_lval_expr_from_sym (stride),\n-\t\t\t\t\t\tsub_ns);\n-  block->block->next->next = finalization_scalarizer (idx, tmp_array, ptr2,\n-\t\t\t\t\t\t      gfc_copy_expr (size_expr),\n-\t\t\t\t\t\t      sub_ns);\n+\t\t       + offset, c_ptr), ptr).  */\n+  block2->next = finalization_scalarizer (array, ptr,\n+\t\t\t\t\t  gfc_lval_expr_from_sym (offset),\n+\t\t\t\t\t  sub_ns);\n+  block2 = block2->next;\n+  block2->next = finalization_scalarizer (tmp_array, ptr2, offset2, sub_ns);\n+  block2 = block2->next;\n+\n   /* ptr = ptr2.  */\n-  block->block->next->next->next = XCNEW (gfc_code);\n-  block->block->next->next->next->op = EXEC_ASSIGN;\n-  block->block->next->next->next->loc = gfc_current_locus;\n-  block->block->next->next->next->expr1 = gfc_lval_expr_from_sym (ptr);\n-  block->block->next->next->next->expr2 = gfc_lval_expr_from_sym (ptr2);\n+  block2->next = XCNEW (gfc_code);\n+  block2->next->op = EXEC_ASSIGN;\n+  block2->next->loc = gfc_current_locus;\n+  block2->next->expr1 = gfc_lval_expr_from_sym (ptr);\n+  block2->next->expr2 = gfc_lval_expr_from_sym (ptr2);\n }\n \n \n@@ -1300,16 +1477,17 @@ static void\n generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t\t\t       const char *tname, gfc_component *vtab_final)\n {\n-  gfc_symbol *final, *array, *nelem, *fini_coarray, *stride;\n-  gfc_symbol *ptr = NULL, *idx = NULL;\n+  gfc_symbol *final, *array, *fini_coarray, *byte_stride, *sizes, *strides;\n+  gfc_symbol *ptr = NULL, *idx, *idx2, *is_contiguous, *offset, *nelem;\n   gfc_symtree *size_intr;\n   gfc_component *comp;\n   gfc_namespace *sub_ns;\n-  gfc_code *last_code;\n+  gfc_code *last_code, *block;\n   char name[GFC_MAX_SYMBOL_LEN+1];\n   bool finalizable_comp = false;\n   bool expr_null_wrapper = false;\n-  gfc_expr *ancestor_wrapper = NULL;\n+  gfc_expr *ancestor_wrapper = NULL, *rank;\n+  gfc_iterator *iter;\n \n   /* Search for the ancestor's finalizers. */\n   if (derived->attr.extension && derived->components\n@@ -1423,22 +1601,22 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   gfc_commit_symbol (array);\n \n   /* Set up formal argument.  */\n-  gfc_get_symbol (\"stride\", sub_ns, &stride);\n-  stride->ts.type = BT_INTEGER;\n-  stride->ts.kind = gfc_index_integer_kind;\n-  stride->attr.flavor = FL_VARIABLE;\n-  stride->attr.dummy = 1;\n-  stride->attr.value = 1;\n-  stride->attr.artificial = 1;\n-  gfc_set_sym_referenced (stride);\n+  gfc_get_symbol (\"byte_stride\", sub_ns, &byte_stride);\n+  byte_stride->ts.type = BT_INTEGER;\n+  byte_stride->ts.kind = gfc_index_integer_kind;\n+  byte_stride->attr.flavor = FL_VARIABLE;\n+  byte_stride->attr.dummy = 1;\n+  byte_stride->attr.value = 1;\n+  byte_stride->attr.artificial = 1;\n+  gfc_set_sym_referenced (byte_stride);\n   final->formal->next = gfc_get_formal_arglist ();\n-  final->formal->next->sym = stride;\n-  gfc_commit_symbol (stride);\n+  final->formal->next->sym = byte_stride;\n+  gfc_commit_symbol (byte_stride);\n \n   /* Set up formal argument.  */\n   gfc_get_symbol (\"fini_coarray\", sub_ns, &fini_coarray);\n   fini_coarray->ts.type = BT_LOGICAL;\n-  fini_coarray->ts.kind = 4;\n+  fini_coarray->ts.kind = 1;\n   fini_coarray->attr.flavor = FL_VARIABLE;\n   fini_coarray->attr.dummy = 1;\n   fini_coarray->attr.value = 1;\n@@ -1457,6 +1635,90 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       return;\n     }\n \n+  /* Local variables.  */\n+\n+  gfc_get_symbol (\"idx\", sub_ns, &idx);\n+  idx->ts.type = BT_INTEGER;\n+  idx->ts.kind = gfc_index_integer_kind;\n+  idx->attr.flavor = FL_VARIABLE;\n+  idx->attr.artificial = 1;\n+  gfc_set_sym_referenced (idx);\n+  gfc_commit_symbol (idx);\n+\n+  gfc_get_symbol (\"idx2\", sub_ns, &idx2);\n+  idx2->ts.type = BT_INTEGER;\n+  idx2->ts.kind = gfc_index_integer_kind;\n+  idx2->attr.flavor = FL_VARIABLE;\n+  idx2->attr.artificial = 1;\n+  gfc_set_sym_referenced (idx2);\n+  gfc_commit_symbol (idx2);\n+\n+  gfc_get_symbol (\"offset\", sub_ns, &offset);\n+  offset->ts.type = BT_INTEGER;\n+  offset->ts.kind = gfc_index_integer_kind;\n+  offset->attr.flavor = FL_VARIABLE;\n+  offset->attr.artificial = 1;\n+  gfc_set_sym_referenced (offset);\n+  gfc_commit_symbol (offset);\n+\n+  /* Create RANK expression.  */\n+  rank = gfc_get_expr ();\n+  rank->expr_type = EXPR_FUNCTION;\n+  rank->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_RANK);\n+  gfc_get_sym_tree (\"rank\", sub_ns, &rank->symtree, false);\n+  rank->symtree->n.sym->intmod_sym_id = GFC_ISYM_RANK;\n+  rank->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  rank->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (rank->symtree->n.sym);\n+  rank->value.function.actual = gfc_get_actual_arglist ();\n+  rank->value.function.actual->expr = gfc_lval_expr_from_sym (array);\n+  rank->ts = rank->value.function.isym->ts;\n+  gfc_convert_type (rank, &idx->ts, 2);\n+\n+  /* Create is_contiguous variable.  */\n+  gfc_get_symbol (\"is_contiguous\", sub_ns, &is_contiguous);\n+  is_contiguous->ts.type = BT_LOGICAL;\n+  is_contiguous->ts.kind = gfc_default_logical_kind;\n+  is_contiguous->attr.flavor = FL_VARIABLE;\n+  is_contiguous->attr.artificial = 1;\n+  gfc_set_sym_referenced (is_contiguous);\n+  gfc_commit_symbol (is_contiguous);\n+\n+  /* Create \"sizes(0..rank)\" variable, which contains the multiplied\n+     up extent of the dimensions, i.e. sizes(0) = 1, sizes(1) = extent(dim=1),\n+     sizes(2) = sizes(1) * extent(dim=2) etc.  */\n+  gfc_get_symbol (\"sizes\", sub_ns, &sizes);\n+  sizes->ts.type = BT_INTEGER;\n+  sizes->ts.kind = gfc_index_integer_kind;\n+  sizes->attr.flavor = FL_VARIABLE;\n+  sizes->attr.dimension = 1;\n+  sizes->attr.artificial = 1;\n+  sizes->as = gfc_get_array_spec();\n+  sizes->attr.intent = INTENT_INOUT;\n+  sizes->as->type = AS_EXPLICIT;\n+  sizes->as->rank = 1;\n+  sizes->as->lower[0] = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  sizes->as->upper[0] = gfc_copy_expr (rank);\n+  gfc_set_sym_referenced (sizes);\n+  gfc_commit_symbol (sizes);\n+\n+  /* Create \"strides(1..rank)\" variable, which contains the strides per\n+     dimension.  */\n+  gfc_get_symbol (\"strides\", sub_ns, &strides);\n+  strides->ts.type = BT_INTEGER;\n+  strides->ts.kind = gfc_index_integer_kind;\n+  strides->attr.flavor = FL_VARIABLE;\n+  strides->attr.dimension = 1;\n+  strides->attr.artificial = 1;\n+  strides->as = gfc_get_array_spec();\n+  strides->attr.intent = INTENT_INOUT;\n+  strides->as->type = AS_EXPLICIT;\n+  strides->as->rank = 1;\n+  strides->as->lower[0] = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  strides->as->upper[0] = gfc_copy_expr (rank);\n+  gfc_set_sym_referenced (strides);\n+  gfc_commit_symbol (strides);\n+\n \n   /* Set return value to 0.  */\n   last_code = XCNEW (gfc_code);\n@@ -1466,6 +1728,206 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   last_code->expr2 = gfc_get_int_expr (4, NULL, 0);\n   sub_ns->code = last_code;\n \n+  /* Set:  is_contiguous = .true.  */\n+  last_code->next = XCNEW (gfc_code);\n+  last_code = last_code->next;\n+  last_code->op = EXEC_ASSIGN;\n+  last_code->loc = gfc_current_locus;\n+  last_code->expr1 = gfc_lval_expr_from_sym (is_contiguous);\n+  last_code->expr2 = gfc_get_logical_expr (gfc_default_logical_kind,\n+\t\t\t\t\t   &gfc_current_locus, true);\n+\n+  /* Set:  sizes(0) = 1.  */\n+  last_code->next = XCNEW (gfc_code);\n+  last_code = last_code->next;\n+  last_code->op = EXEC_ASSIGN;\n+  last_code->loc = gfc_current_locus;\n+  last_code->expr1 = gfc_lval_expr_from_sym (sizes);\n+  last_code->expr1->ref = gfc_get_ref ();\n+  last_code->expr1->ref->type = REF_ARRAY;\n+  last_code->expr1->ref->u.ar.type = AR_ELEMENT;\n+  last_code->expr1->ref->u.ar.dimen = 1;\n+  last_code->expr1->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  last_code->expr1->ref->u.ar.start[0]\n+\t\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  last_code->expr1->ref->u.ar.as = sizes->as;\n+  last_code->expr2 = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+\n+  /* Create:\n+     DO idx = 1, rank\n+       strides(idx) = _F._stride (array, dim=idx)\n+       sizes(idx) = sizes(i-1) * size(array, dim=idx, kind=index_kind)\n+       if (strides(idx) /= sizes(i-1)) is_contiguous = .false.\n+     END DO.  */\n+\n+  /* Create loop.  */\n+  iter = gfc_get_iterator ();\n+  iter->var = gfc_lval_expr_from_sym (idx);\n+  iter->start = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  iter->end = gfc_copy_expr (rank);\n+  iter->step = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  last_code->next = XCNEW (gfc_code);\n+  last_code = last_code->next;\n+  last_code->op = EXEC_DO;\n+  last_code->loc = gfc_current_locus;\n+  last_code->ext.iterator = iter;\n+  last_code->block = gfc_get_code ();\n+  last_code->block->op = EXEC_DO;\n+\n+  /* strides(idx) = _F._stride(array,dim=idx). */\n+  last_code->block->next = XCNEW (gfc_code);\n+  block = last_code->block->next;\n+  block->op = EXEC_ASSIGN;\n+  block->loc = gfc_current_locus;\n+\n+  block->expr1 = gfc_lval_expr_from_sym (strides);\n+  block->expr1->ref = gfc_get_ref ();\n+  block->expr1->ref->type = REF_ARRAY;\n+  block->expr1->ref->u.ar.type = AR_ELEMENT;\n+  block->expr1->ref->u.ar.dimen = 1;\n+  block->expr1->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  block->expr1->ref->u.ar.start[0] = gfc_lval_expr_from_sym (idx);\n+  block->expr1->ref->u.ar.as = strides->as;\n+\n+  block->expr2 = gfc_get_expr ();\n+  block->expr2->expr_type = EXPR_FUNCTION;\n+  block->expr2->value.function.isym\n+\t= gfc_intrinsic_function_by_id (GFC_ISYM_STRIDE);\n+  gfc_get_sym_tree (GFC_PREFIX (\"stride\"), sub_ns,\n+\t\t    &block->expr2->symtree, false);\n+  block->expr2->symtree->n.sym->intmod_sym_id = GFC_ISYM_STRIDE;\n+  block->expr2->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  block->expr2->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (block->expr2->symtree->n.sym);\n+  block->expr2->value.function.actual = gfc_get_actual_arglist ();\n+  block->expr2->value.function.actual->expr = gfc_lval_expr_from_sym (array);\n+  /* dim=idx. */\n+  block->expr2->value.function.actual->next = gfc_get_actual_arglist ();\n+  block->expr2->value.function.actual->next->expr\n+\t= gfc_lval_expr_from_sym (idx);\n+  block->expr2->ts = block->expr2->value.function.isym->ts;\n+\n+  /* sizes(idx) = sizes(idx-1) * size(array,dim=idx, kind=index_kind). */\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_ASSIGN;\n+  block->loc = gfc_current_locus;\n+\n+  /* sizes(idx) = ... */\n+  block->expr1 = gfc_lval_expr_from_sym (sizes);\n+  block->expr1->ref = gfc_get_ref ();\n+  block->expr1->ref->type = REF_ARRAY;\n+  block->expr1->ref->u.ar.type = AR_ELEMENT;\n+  block->expr1->ref->u.ar.dimen = 1;\n+  block->expr1->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  block->expr1->ref->u.ar.start[0] = gfc_lval_expr_from_sym (idx);\n+  block->expr1->ref->u.ar.as = sizes->as;\n+\n+  block->expr2 = gfc_get_expr ();\n+  block->expr2->expr_type = EXPR_OP;\n+  block->expr2->value.op.op = INTRINSIC_TIMES;\n+\n+  /* sizes(idx-1). */\n+  block->expr2->value.op.op1 = gfc_lval_expr_from_sym (sizes);\n+  block->expr2->value.op.op1->ref = gfc_get_ref ();\n+  block->expr2->value.op.op1->ref->type = REF_ARRAY;\n+  block->expr2->value.op.op1->ref->u.ar.as = sizes->as;\n+  block->expr2->value.op.op1->ref->u.ar.type = AR_ELEMENT;\n+  block->expr2->value.op.op1->ref->u.ar.dimen = 1;\n+  block->expr2->value.op.op1->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  block->expr2->value.op.op1->ref->u.ar.start[0] = gfc_get_expr ();\n+  block->expr2->value.op.op1->ref->u.ar.start[0]->expr_type = EXPR_OP;\n+  block->expr2->value.op.op1->ref->u.ar.start[0]->value.op.op = INTRINSIC_MINUS;\n+  block->expr2->value.op.op1->ref->u.ar.start[0]->value.op.op1\n+\t= gfc_lval_expr_from_sym (idx);\n+  block->expr2->value.op.op1->ref->u.ar.start[0]->value.op.op2\n+\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  block->expr2->value.op.op1->ref->u.ar.start[0]->ts\n+\t= block->expr2->value.op.op1->ref->u.ar.start[0]->value.op.op1->ts;\n+\n+  /* size(array, dim=idx, kind=index_kind).  */\n+  block->expr2->value.op.op2 = gfc_get_expr ();\n+  block->expr2->value.op.op2->expr_type = EXPR_FUNCTION;\n+  block->expr2->value.op.op2->value.function.isym\n+\t= gfc_intrinsic_function_by_id (GFC_ISYM_SIZE);\n+  gfc_get_sym_tree (\"size\", sub_ns, &block->expr2->value.op.op2->symtree,\n+\t\t    false);\n+  size_intr = block->expr2->value.op.op2->symtree;\n+  block->expr2->value.op.op2->symtree->n.sym->intmod_sym_id = GFC_ISYM_SIZE;\n+  block->expr2->value.op.op2->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  block->expr2->value.op.op2->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (block->expr2->value.op.op2->symtree->n.sym);\n+  block->expr2->value.op.op2->value.function.actual\n+\t= gfc_get_actual_arglist ();\n+  block->expr2->value.op.op2->value.function.actual->expr\n+\t= gfc_lval_expr_from_sym (array);\n+  /* dim=idx. */\n+  block->expr2->value.op.op2->value.function.actual->next\n+\t= gfc_get_actual_arglist ();\n+  block->expr2->value.op.op2->value.function.actual->next->expr\n+\t= gfc_lval_expr_from_sym (idx);\n+  /* kind=c_intptr_t. */\n+  block->expr2->value.op.op2->value.function.actual->next->next\n+\t= gfc_get_actual_arglist ();\n+  block->expr2->value.op.op2->value.function.actual->next->next->expr\n+\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  block->expr2->value.op.op2->ts = idx->ts;\n+  block->expr2->ts = idx->ts;\n+\n+  /* if (strides(idx) /= sizes(idx-1)) is_contiguous = .false.  */\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->loc = gfc_current_locus;\n+  block->op = EXEC_IF;\n+\n+  block->block = XCNEW (gfc_code);\n+  block = block->block;\n+  block->loc = gfc_current_locus;\n+  block->op = EXEC_IF;\n+\n+  /* if condition: strides(idx) /= sizes(idx-1).  */\n+  block->expr1 = gfc_get_expr ();\n+  block->expr1->ts.type = BT_LOGICAL;\n+  block->expr1->ts.kind = gfc_default_logical_kind;\n+  block->expr1->expr_type = EXPR_OP;\n+  block->expr1->where = gfc_current_locus;\n+  block->expr1->value.op.op = INTRINSIC_NE;\n+\n+  block->expr1->value.op.op1 = gfc_lval_expr_from_sym (strides);\n+  block->expr1->value.op.op1->ref = gfc_get_ref ();\n+  block->expr1->value.op.op1->ref->type = REF_ARRAY;\n+  block->expr1->value.op.op1->ref->u.ar.type = AR_ELEMENT;\n+  block->expr1->value.op.op1->ref->u.ar.dimen = 1;\n+  block->expr1->value.op.op1->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  block->expr1->value.op.op1->ref->u.ar.start[0] = gfc_lval_expr_from_sym (idx);\n+  block->expr1->value.op.op1->ref->u.ar.as = strides->as;\n+\n+  block->expr1->value.op.op2 = gfc_lval_expr_from_sym (sizes);\n+  block->expr1->value.op.op2->ref = gfc_get_ref ();\n+  block->expr1->value.op.op2->ref->type = REF_ARRAY;\n+  block->expr1->value.op.op2->ref->u.ar.as = sizes->as;\n+  block->expr1->value.op.op2->ref->u.ar.type = AR_ELEMENT;\n+  block->expr1->value.op.op2->ref->u.ar.dimen = 1;\n+  block->expr1->value.op.op2->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  block->expr1->value.op.op2->ref->u.ar.start[0] = gfc_get_expr ();\n+  block->expr1->value.op.op2->ref->u.ar.start[0]->expr_type = EXPR_OP;\n+  block->expr1->value.op.op2->ref->u.ar.start[0]->value.op.op = INTRINSIC_MINUS;\n+  block->expr1->value.op.op2->ref->u.ar.start[0]->value.op.op1\n+\t= gfc_lval_expr_from_sym (idx);\n+  block->expr1->value.op.op2->ref->u.ar.start[0]->value.op.op2\n+\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  block->expr1->value.op.op2->ref->u.ar.start[0]->ts\n+\t= block->expr1->value.op.op2->ref->u.ar.start[0]->value.op.op1->ts;\n+\n+  /* if body: is_contiguous = .false.  */\n+  block->next = XCNEW (gfc_code);\n+  block = block->next;\n+  block->op = EXEC_ASSIGN;\n+  block->loc = gfc_current_locus;\n+  block->expr1 = gfc_lval_expr_from_sym (is_contiguous);\n+  block->expr2 = gfc_get_logical_expr (gfc_default_logical_kind,\n+\t\t\t\t       &gfc_current_locus, false);\n+\n   /* Obtain the size (number of elements) of \"array\" MINUS ONE,\n      which is used in the scalarization.  */\n   gfc_get_symbol (\"nelem\", sub_ns, &nelem);\n@@ -1476,7 +1938,7 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   gfc_set_sym_referenced (nelem);\n   gfc_commit_symbol (nelem);\n \n-  /* Generate: nelem = SIZE (array) - 1.  */\n+  /* nelem = sizes (rank) - 1.  */\n   last_code->next = XCNEW (gfc_code);\n   last_code = last_code->next;\n   last_code->op = EXEC_ASSIGN;\n@@ -1491,32 +1953,14 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n   last_code->expr2->ts = last_code->expr2->value.op.op2->ts;\n \n-  last_code->expr2->value.op.op1 = gfc_get_expr ();\n-  last_code->expr2->value.op.op1->expr_type = EXPR_FUNCTION;\n-  last_code->expr2->value.op.op1->value.function.isym\n-\t= gfc_intrinsic_function_by_id (GFC_ISYM_SIZE);\n-  gfc_get_sym_tree (\"size\", sub_ns, &last_code->expr2->value.op.op1->symtree,\n-\t\t    false);\n-  size_intr = last_code->expr2->value.op.op1->symtree;\n-  last_code->expr2->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n-  last_code->expr2->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n-  gfc_commit_symbol (last_code->expr2->value.op.op1->symtree->n.sym);\n-  last_code->expr2->value.op.op1->value.function.actual\n-\t= gfc_get_actual_arglist ();\n-  last_code->expr2->value.op.op1->value.function.actual->expr\n-\t= gfc_lval_expr_from_sym (array);\n-  /* dim=NULL. */\n-  last_code->expr2->value.op.op1->value.function.actual->next\n-\t= gfc_get_actual_arglist ();\n-  /* kind=c_intptr_t. */\n-  last_code->expr2->value.op.op1->value.function.actual->next->next\n-\t= gfc_get_actual_arglist ();\n-  last_code->expr2->value.op.op1->value.function.actual->next->next->expr\n-\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n-  last_code->expr2->value.op.op1->ts\n-\t= last_code->expr2->value.op.op1->value.function.isym->ts;\n-\n-  sub_ns->code = last_code;\n+  last_code->expr2->value.op.op1 = gfc_lval_expr_from_sym (sizes);\n+  last_code->expr2->value.op.op1->ref = gfc_get_ref ();\n+  last_code->expr2->value.op.op1->ref->type = REF_ARRAY;\n+  last_code->expr2->value.op.op1->ref->u.ar.type = AR_ELEMENT;\n+  last_code->expr2->value.op.op1->ref->u.ar.dimen = 1;\n+  last_code->expr2->value.op.op1->ref->u.ar.dimen_type[0] = DIMEN_ELEMENT;\n+  last_code->expr2->value.op.op1->ref->u.ar.start[0] = gfc_copy_expr (rank);\n+  last_code->expr2->value.op.op1->ref->u.ar.as = sizes->as;\n \n   /* Call final subroutines. We now generate code like:\n      use iso_c_binding\n@@ -1539,15 +1983,6 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n   if (derived->f2k_derived && derived->f2k_derived->finalizers)\n     {\n       gfc_finalizer *fini, *fini_elem = NULL;\n-      gfc_code *block = NULL;\n-\n-      gfc_get_symbol (\"idx\", sub_ns, &idx);\n-      idx->ts.type = BT_INTEGER;\n-      idx->ts.kind = gfc_index_integer_kind;\n-      idx->attr.flavor = FL_VARIABLE;\n-      idx->attr.artificial = 1;\n-      gfc_set_sym_referenced (idx);\n-      gfc_commit_symbol (idx);\n \n       gfc_get_symbol (\"ptr\", sub_ns, &ptr);\n       ptr->ts.type = BT_DERIVED;\n@@ -1563,20 +1998,8 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       last_code = last_code->next;\n       last_code->op = EXEC_SELECT;\n       last_code->loc = gfc_current_locus;\n-\n-      last_code->expr1 = gfc_get_expr ();\n-      last_code->expr1->expr_type = EXPR_FUNCTION;\n-      last_code->expr1->value.function.isym\n-\t    = gfc_intrinsic_function_by_id (GFC_ISYM_RANK);\n-      gfc_get_sym_tree (\"rank\", sub_ns, &last_code->expr1->symtree,\n-\t\t\tfalse);\n-      last_code->expr1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n-      last_code->expr1->symtree->n.sym->attr.intrinsic = 1;\n-      gfc_commit_symbol (last_code->expr1->symtree->n.sym);\n-      last_code->expr1->value.function.actual = gfc_get_actual_arglist ();\n-      last_code->expr1->value.function.actual->expr\n-\t    = gfc_lval_expr_from_sym (array);\n-      last_code->expr1->ts = last_code->expr1->value.function.isym->ts;\n+      last_code->expr1 = gfc_copy_expr (rank);\n+      block = NULL;\n \n       for (fini = derived->f2k_derived->finalizers; fini; fini = fini->next)\n \t{\n@@ -1613,8 +2036,10 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \n \t  /* CALL fini_rank (array) - possibly with packing.  */\n           if (fini->proc_tree->n.sym->formal->sym->attr.dimension)\n-\t    finalizer_insert_packed_call (block, fini, array, stride, idx, ptr,\n-\t\t\t\t\t  nelem, size_intr, sub_ns);\n+\t    finalizer_insert_packed_call (block, fini, array, byte_stride,\n+\t\t\t\t\t  idx, ptr, nelem, size_intr, strides,\n+\t\t\t\t\t  sizes, idx2, offset, is_contiguous,\n+\t\t\t\t\t  rank, sub_ns);\n \t  else\n \t    {\n \t      block->next = XCNEW (gfc_code);\n@@ -1630,8 +2055,6 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       /* Elemental call - scalarized.  */\n       if (fini_elem)\n \t{\n-\t  gfc_iterator *iter;\n-\n \t  /* CASE DEFAULT.  */\n \t  if (block)\n \t    {\n@@ -1661,14 +2084,19 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n \t  block->block = gfc_get_code ();\n \t  block->block->op = EXEC_DO;\n \n+\t  /* Offset calculation.  */\n+\t  block = finalization_get_offset (idx, idx2, offset, strides, sizes,\n+\t\t\t\t\t   byte_stride, rank, block->block,\n+\t\t\t\t\t   sub_ns);\n+\n \t  /* Create code for\n \t     CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n-\t\t\t       + idx * stride, c_ptr), ptr).  */\n-\t  block->block->next\n-\t\t\t= finalization_scalarizer (idx, array, ptr,\n-\t\t\t\t\t\t   gfc_lval_expr_from_sym (stride),\n-\t\t\t\t\t\t   sub_ns);\n-\t  block = block->block->next;\n+\t\t\t       + offset, c_ptr), ptr).  */\n+\t  block->next\n+\t\t= finalization_scalarizer (array, ptr,\n+\t\t\t\t\t   gfc_lval_expr_from_sym (offset),\n+\t\t\t\t\t   sub_ns);\n+\t  block = block->next;\n \n \t  /* CALL final_elemental (array).  */\n \t  block->next = XCNEW (gfc_code);\n@@ -1689,18 +2117,6 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n     {\n       gfc_symbol *stat;\n       gfc_code *block = NULL;\n-      gfc_iterator *iter;\n-\n-      if (!idx)\n-\t{\n-\t  gfc_get_symbol (\"idx\", sub_ns, &idx);\n-\t  idx->ts.type = BT_INTEGER;\n-\t  idx->ts.kind = gfc_index_integer_kind;\n-\t  idx->attr.flavor = FL_VARIABLE;\n-\t  idx->attr.artificial = 1;\n-\t  gfc_set_sym_referenced (idx);\n-\t  gfc_commit_symbol (idx);\n-\t}\n \n       if (!ptr)\n \t{\n@@ -1736,14 +2152,18 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       last_code->block = gfc_get_code ();\n       last_code->block->op = EXEC_DO;\n \n+      /* Offset calculation.  */\n+      block = finalization_get_offset (idx, idx2, offset, strides, sizes,\n+\t\t\t\t       byte_stride, rank, last_code->block,\n+\t\t\t\t       sub_ns);\n+\n       /* Create code for\n \t CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n \t\t\t   + idx * stride, c_ptr), ptr).  */\n-      last_code->block->next\n-\t\t= finalization_scalarizer (idx, array, ptr,\n-\t\t\t\t\t   gfc_lval_expr_from_sym (stride),\n-\t\t\t\t\t   sub_ns);\n-      block = last_code->block->next;\n+      block->next = finalization_scalarizer (array, ptr,\n+\t\t\t\t\t     gfc_lval_expr_from_sym(offset),\n+\t\t\t\t\t     sub_ns);\n+      block = block->next;\n \n       for (comp = derived->components; comp; comp = comp->next)\n \t{\n@@ -1772,12 +2192,13 @@ generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n       last_code->ext.actual = gfc_get_actual_arglist ();\n       last_code->ext.actual->expr = gfc_lval_expr_from_sym (array);\n       last_code->ext.actual->next = gfc_get_actual_arglist ();\n-      last_code->ext.actual->next->expr = gfc_lval_expr_from_sym (stride);\n+      last_code->ext.actual->next->expr = gfc_lval_expr_from_sym (byte_stride);\n       last_code->ext.actual->next->next = gfc_get_actual_arglist ();\n       last_code->ext.actual->next->next->expr\n \t\t\t= gfc_lval_expr_from_sym (fini_coarray);\n     }\n \n+  gfc_free_expr (rank);\n   vtab_final->initializer = gfc_lval_expr_from_sym (final);\n   vtab_final->ts.interface = final;\n }"}]}