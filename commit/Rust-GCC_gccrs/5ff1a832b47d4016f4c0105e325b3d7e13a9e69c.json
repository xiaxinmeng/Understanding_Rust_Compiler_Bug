{"sha": "5ff1a832b47d4016f4c0105e325b3d7e13a9e69c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZmMWE4MzJiNDdkNDAxNmY0YzAxMDVlMzI1YjNkN2UxM2E5ZTY5Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-09T19:37:06Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-09T19:37:06Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r948", "tree": {"sha": "b9c970025605100f7ac2a01194018a7144eb8116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9c970025605100f7ac2a01194018a7144eb8116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ff1a832b47d4016f4c0105e325b3d7e13a9e69c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ff1a832b47d4016f4c0105e325b3d7e13a9e69c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ff1a832b47d4016f4c0105e325b3d7e13a9e69c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ff1a832b47d4016f4c0105e325b3d7e13a9e69c/comments", "author": null, "committer": null, "parents": [{"sha": "830a38eec6e9b38b58adb8a7aa785300ead47688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830a38eec6e9b38b58adb8a7aa785300ead47688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830a38eec6e9b38b58adb8a7aa785300ead47688"}], "stats": {"total": 98, "additions": 82, "deletions": 16}, "files": [{"sha": "885412bd4bfc46d63075843595769bf15dd5808a", "filename": "gcc/cccp.c", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ff1a832b47d4016f4c0105e325b3d7e13a9e69c/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ff1a832b47d4016f4c0105e325b3d7e13a9e69c/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=5ff1a832b47d4016f4c0105e325b3d7e13a9e69c", "patch": "@@ -576,12 +576,14 @@ struct definition {\n   U_CHAR *expansion;\n   int line;\t\t\t/* Line number of definition */\n   char *file;\t\t\t/* File of definition */\n+  char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n   struct reflist {\n     struct reflist *next;\n     char stringify;\t\t/* nonzero if this arg was preceded by a\n \t\t\t\t   # operator. */\n     char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n     char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n+    char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n     int nchars;\t\t\t/* Number of literal chars to copy before\n \t\t\t\t   this arg occurrence.  */\n     int argno;\t\t\t/* Number of arg to substitute (origin-0) */\n@@ -604,6 +606,20 @@ union hashval {\n   KEYDEF *keydef;\n };\n \n+/*\n+ * special extension string that can be added to the last macro argument to \n+ * allow it to absorb the \"rest\" of the arguments when expanded.  Ex:\n+ * \t\t#define wow(a, b...)\t\tprocess(b, a, b)\n+ *\t\t{ wow(1, 2, 3); }\t->\t{ process( 2, 3, 1,  2, 3); }\n+ *\t\t{ wow(one, two); }\t->\t{ process( two, one,  two); }\n+ * if this \"rest_arg\" is used with the concat token '##' and if it is not\n+ * supplied then the token attached to with ## will not be outputed.  Ex:\n+ * \t\t#define wow(a, b...)\t\tprocess(b ## , a, ## b)\n+ *\t\t{ wow(1, 2); }\t\t->\t{ process( 2, 1,2); }\n+ *\t\t{ wow(one); }\t\t->\t{ process( one); {\n+ */\n+static char rest_extension[] = \"...\";\n+#define REST_EXTENSION_LENGTH\t(sizeof (rest_extension) - 1)\n \n /* The structure of a node in the hash table.  The hash table\n    has entries for all tokens defined by #define commands (type T_MACRO),\n@@ -4527,6 +4543,7 @@ struct arglist {\n   U_CHAR *name;\n   int length;\n   int argno;\n+  char rest_args;\n };\n \n /* Create a DEFINITION node from a #define directive.  Arguments are \n@@ -4541,6 +4558,7 @@ create_definition (buf, limit, op)\n   int sym_length;\t\t/* and how long it is */\n   int line = instack[indepth].lineno;\n   char *file = instack[indepth].nominal_fname;\n+  int rest_args = 0;\n \n   DEFINITION *defn;\n   int arglengths = 0;\t\t/* Accumulate lengths of arg names\n@@ -4575,16 +4593,30 @@ create_definition (buf, limit, op)\n       temp->name = bp;\n       temp->next = arg_ptrs;\n       temp->argno = argno++;\n+      temp->rest_args = 0;\n       arg_ptrs = temp;\n \n-      if (!is_idstart[*bp])\n-\tpedwarn (\"parameter name starts with a digit in `#define'\");\n+      if (rest_args)\n+\tpedwarn (\"another parameter follows `%s'\",\n+\t\t rest_extension);\n \n+      if (!is_idstart[*bp])\n+\tpedwarn (\"invalid character in macro parameter name\");\n+      \n       /* Find the end of the arg name.  */\n       while (is_idchar[*bp]) {\n \tbp++;\n+\t/* do we have a \"special\" rest-args extension here? */\n+\tif (limit - bp > REST_EXTENSION_LENGTH &&\n+\t    strncmp (rest_extension, bp, REST_EXTENSION_LENGTH) == 0) {\n+\t  rest_args = 1;\n+\t  temp->rest_args = 1;\n+\t  break;\n+\t}\n       }\n       temp->length = bp - temp->name;\n+      if (rest_args == 1)\n+\tbp += REST_EXTENSION_LENGTH;\n       arglengths += temp->length + 2;\n       SKIP_WHITE_SPACE (bp);\n       if (temp->length == 0 || (*bp != ',' && *bp != ')')) {\n@@ -4621,6 +4653,7 @@ create_definition (buf, limit, op)\n     if (bp < limit && (*bp == ' ' || *bp == '\\t')) ++bp;\n     /* now everything from bp before limit is the definition. */\n     defn = collect_expansion (bp, limit, argno, arg_ptrs);\n+    defn->rest_args = rest_args;\n \n     /* Now set defn->args.argnames to the result of concatenating\n        the argument names in reverse order\n@@ -5063,6 +5096,7 @@ collect_expansion (buf, end, nargs, arglist)\n \t    tpat->next = NULL;\n \t    tpat->raw_before = concat == id_beg;\n \t    tpat->raw_after = 0;\n+\t    tpat->rest_args = arg->rest_args;\n \t    tpat->stringify = (traditional ? expected_delimiter != '\\0'\n \t\t\t       : stringify == id_beg);\n \n@@ -6737,6 +6771,7 @@ macroexpand (hp, op)\n   register U_CHAR *xbuf;\n   int xbuf_len;\n   int start_line = instack[indepth].lineno;\n+  int rest_args, rest_zero;\n \n   CHECK_DEPTH (return;);\n \n@@ -6770,13 +6805,24 @@ macroexpand (hp, op)\n \n     /* Parse all the macro args that are supplied.  I counts them.\n        The first NARGS args are stored in ARGS.\n-       The rest are discarded.  */\n+       The rest are discarded.\n+       If rest_args is set then we assume macarg absorbed the rest of the args.\n+       */\n     i = 0;\n+    rest_args = 0;\n     do {\n       /* Discard the open-parenthesis or comma before the next arg.  */\n       ++instack[indepth].bufp;\n-      parse_error\n-\t= macarg ((i < nargs || (nargs == 0 && i == 0)) ? &args[i] : 0);\n+      if (rest_args)\n+\tcontinue;\n+      if (i < nargs || (nargs == 0 && i == 0)) {\n+\t/* if we are working on last arg which absorbes rest of args... */\n+\tif (i == nargs - 1 && defn->rest_args)\n+\t  rest_args = 1;\n+\tparse_error = macarg (&args[i], rest_args);\n+      }\n+      else\n+\tparse_error = macarg (0, 0);\n       if (parse_error) {\n \terror_with_line (line_for_error (start_line), parse_error);\n \tbreak;\n@@ -6793,12 +6839,16 @@ macroexpand (hp, op)\n \ti = 0;\n     }\n \n+    rest_zero = 0;\n     if (nargs == 0 && i > 0)\n       error (\"arguments given to macro `%s'\", hp->name);\n     else if (i < nargs) {\n       /* traditional C allows foo() if foo wants one argument.  */\n       if (nargs == 1 && i == 0 && traditional)\n \t;\n+      /* the rest args token is allowed to absorb 0 tokens */\n+      else if (i == nargs - 1 && defn->rest_args)\n+\trest_zero = 1;\n       else if (i == 0)\n \terror (\"macro `%s' used without args\", hp->name);\n       else if (i == 1)\n@@ -6822,7 +6872,7 @@ macroexpand (hp, op)\n \t\t\t\t   copied a piece at a time */\n       register int totlen;\t/* total amount of exp buffer filled so far */\n \n-      register struct reflist *ap;\n+      register struct reflist *ap, *last_ap;\n \n       /* Macro really takes args.  Compute the expansion of this call.  */\n \n@@ -6849,11 +6899,16 @@ macroexpand (hp, op)\n \t OFFSET is the index in the definition\n \t of where we are copying from.  */\n       offset = totlen = 0;\n-      for (ap = defn->pattern; ap != NULL; ap = ap->next) {\n+      for (last_ap = NULL, ap = defn->pattern; ap != NULL;\n+\t   last_ap = ap, ap = ap->next) {\n \tregister struct argdata *arg = &args[ap->argno];\n \n-\tfor (i = 0; i < ap->nchars; i++)\n-\t  xbuf[totlen++] = exp[offset++];\n+\t/* add chars to XBUF unless rest_args was zero with concatenation */\n+\tfor (i = 0; i < ap->nchars; i++, offset++)\n+\t  if (! (rest_zero && ((ap->rest_args && ap->raw_before)\n+\t\t\t       || (last_ap != NULL && last_ap->rest_args\n+\t\t\t\t   && last_ap->raw_after))))\n+\t    xbuf[totlen++] = exp[offset];\n \n \tif (ap->stringify != 0) {\n \t  int arglen = arg->raw_length;\n@@ -6977,8 +7032,14 @@ macroexpand (hp, op)\n       /* if there is anything left of the definition\n \t after handling the arg list, copy that in too. */\n \n-      for (i = offset; i < defn->length; i++)\n-\txbuf[totlen++] = exp[i];\n+      for (i = offset; i < defn->length; i++) {\n+\t/* if we've reached the end of the macro */\n+\tif (exp[i] == ')')\n+\t  rest_zero = 0;\n+\tif (! (rest_zero && last_ap != NULL && last_ap->rest_args\n+\t       && last_ap->raw_after))\n+\t  xbuf[totlen++] = exp[i];\n+      }\n \n       xbuf[totlen] = 0;\n       xbuf_len = totlen;\n@@ -7024,12 +7085,14 @@ macroexpand (hp, op)\n \f\n /*\n  * Parse a macro argument and store the info on it into *ARGPTR.\n+ * REST_ARGS is passed to macarg1 to make it absorb the rest of the args.\n  * Return nonzero to indicate a syntax error.\n  */\n \n static char *\n-macarg (argptr)\n+macarg (argptr, rest_args)\n      register struct argdata *argptr;\n+     int rest_args;\n {\n   FILE_BUF *ip = &instack[indepth];\n   int paren = 0;\n@@ -7039,7 +7102,7 @@ macarg (argptr)\n   /* Try to parse as much of the argument as exists at this\n      input stack level.  */\n   U_CHAR *bp = macarg1 (ip->bufp, ip->buf + ip->length,\n-\t\t\t&paren, &newlines, &comments);\n+\t\t\t&paren, &newlines, &comments, rest_args);\n \n   /* If we find the end of the argument at this level,\n      set up *ARGPTR to point at it in the input stack.  */\n@@ -7077,7 +7140,7 @@ macarg (argptr)\n       newlines = 0;\n       comments = 0;\n       bp = macarg1 (ip->bufp, ip->buf + ip->length, &paren,\n-\t\t    &newlines, &comments);\n+\t\t    &newlines, &comments, rest_args);\n       final_start = bufsize;\n       bufsize += bp - ip->bufp;\n       extra += newlines;\n@@ -7166,13 +7229,15 @@ macarg (argptr)\n    Value returned is pointer to stopping place.\n \n    Increment *NEWLINES each time a newline is passed.\n+   REST_ARGS notifies macarg1 that it should absorb the rest of the args.\n    Set *COMMENTS to 1 if a comment is seen.  */\n \n static U_CHAR *\n-macarg1 (start, limit, depthptr, newlines, comments)\n+macarg1 (start, limit, depthptr, newlines, comments, rest_args)\n      U_CHAR *start;\n      register U_CHAR *limit;\n      int *depthptr, *newlines, *comments;\n+     int rest_args;\n {\n   register U_CHAR *bp = start;\n \n@@ -7243,7 +7308,8 @@ macarg1 (start, limit, depthptr, newlines, comments)\n       }\n       break;\n     case ',':\n-      if ((*depthptr) == 0)\n+      /* if we've returned to lowest level and we aren't absorbing all args */\n+      if ((*depthptr) == 0 && rest_args == 0)\n \treturn bp;\n       break;\n     }"}]}