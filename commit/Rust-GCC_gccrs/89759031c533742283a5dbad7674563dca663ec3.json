{"sha": "89759031c533742283a5dbad7674563dca663ec3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk3NTkwMzFjNTMzNzQyMjgzYTVkYmFkNzY3NDU2M2RjYTY2M2VjMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-09T23:26:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-09T23:26:08Z"}, "message": "vr-values.h: New file with vr_values class.\n\n\t* vr-values.h: New file with vr_values class.\n\t* tree-vrp.c: Include vr-values.h\n\t(vrp_value_range_pool, vrp_equiv_obstack, num_vr_values): Move static\n\tdata objects into the vr_values class.\n\t(vr_value, values_propagated, vr_phi_edge_counts): Likewise.\n\t(get_value_range): Make it a member function within vr_values class.\n\t(set_defs_to_varying, update_value_range, add_equivalence): Likewise.\n\t(vrp_stmt_computes_nonzero_p, op_with_boolean_value_range_p): Likewise.\n\t(op_with_constant_singleton_value_range): Likewise.\n\t(extract_range_for_var_from_comparison_expr): Likewise.\n\t(extract_range_from_assert, extract_range_from_ssa_name): Likewise.\n\t(extract_range_from_binary_expr): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t(extract_range_from_cond_expr, extrat_range_from_comparison): Likewise.\n\t(check_for_binary_op_overflow, extract_range_basic): Likewise.\n\t(extract_range_from_assignment, adjust_range_with_scev): Likewise.\n\t(dump_all_value_ranges, get_vr_for_comparison): Likewise.\n\t(compare_name_with_value, compare_names): Likewise.\n\t(vrp_evaluate_conditional_warnv_with_ops_using_ranges): Likewise.\n\t(vrp_evaluate_conditional_warnv_with_ops): Likewise.  Remove prototype.\n\t(vrp_evaluate_conditional, vrp_visit_cond_stmt): Likewise.\n\t(vrp_visit_switch_stmt, extract_range_from_stmt): Likewise.\n\t(extract_range_from_phi_node): Likewise.\n\t(simplify_truth_ops_using_ranges): Likewise.\n\t(simplify_div_or_mod_using_ranges): Likewise.\n\t(simplify_min_or_max_using_ranges, simplify_abs_using_ranges): Likewise.\n\t(simplify_bit_ops_using_ranges, simplify_cond_using_ranges_1): Likewise.\n\t(simplify_cond_using_ranges_2, simplify_switch_using_ranges): Likewise.\n\t(simplify_float_conversion_using_ranges): Likewise.\n\t(simplify_internal_call_using_ranges): Likewise.\n\t(two_valued_val_range_p, simplify_stmt_using_ranges): Likewise.\n\t(vrp_visit_assignment_or_call): Likewise.  Smuggle class instance\n\tpoitner via x_vr_values for calls into gimple folder.\n\t(vrp_initialize_lattice): Make this the vr_values ctor.\n\t(vrp_free_lattice): Make this the vr_values dtor.\n\t(set_vr_value): New function.\n\t(class vrp_prop): Add vr_values data member.  Add various member\n\tfunctions as well as member functions that delegate to vr_values.\n\t(check_array_ref): Make a member function within vrp_prop class.\n\t(search_for_addr_array, vrp_initialize): Likewise.\n\t(vrp_finalize): Likewise.  Revamp to avoid direct access to\n\tvr_value, values_propagated, etc.\n\t(check_array_bounds): Extract vrp_prop class instance pointer from\n\twalk info structure.  Use it to call member functions.\n\t(check_all_array_refs): Make a member function within vrp_prop class.\n\tSmuggle class instance pointer via walk info structure.\n\t(x_vr_values): New local static.\n\t(vrp_valueize): Use x_vr_values to get class instance.\n\t(vr_valueize_1): Likewise.\n\t(class vrp_folder): Add vr_values data member.  Add various member\n\tfunctions as well as member functions that delegate to vr_values.\n\t(fold_predicate_in): Make a mber fucntion within vrp_folder class.\n\t(simplify_stmt_for_jump_threading): Extract smuggled vr_values\n\tclass instance from vr_values.  Use it to call member functions.\n\t(vrp_dom_walker): Add vr_values data member.\n\t(vrp_dom_walker::after_dom_children): Smuggle vr_values class\n\tinstance via x_vr_values.\n\t(identify_jump_threads): Accept vr_values as argument.  Store\n\tit into the walker structure.\n\t(evrp_dom_walker): Add vr_values class data member.  Add various\n\tdelegators.\n\t(evrp_dom_walker::try_find_new_range): Use vr_values data\n\tmember to access the memory allocator.\n\t(evrp_dom_walker::before_dom_children): Store vr_values class\n\tinstance into the vrp_folder class.\n\t(evrp_dom_walker::push_value_range): Rework to avoid direct\n\taccess to num_vr_values and vr_value.\n\t(evrp_dom_walker::pop_value_range): Likewise.\n\t(execute_early_vrp): Remove call to vrp_initialize_lattice.\n\tUse vr_values to get to dump_all_value_ranges member function.\n\tRemove call to vrp_free_lattice.  Call vrp_initialize, vrp_finalize,\n\tand simplify_cond_using_ranges_2 via vrp_prop class instance.\n\tPass vr_values class instance down to identify_jump_threads.\n\tRemove call to vrp_free_lattice.\n\t(debug_all_value_ranges): Remove.\n\nFrom-SVN: r254613", "tree": {"sha": "bd35d4c649a5d299292d220e9ec2ae8a67e2933c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd35d4c649a5d299292d220e9ec2ae8a67e2933c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89759031c533742283a5dbad7674563dca663ec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89759031c533742283a5dbad7674563dca663ec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89759031c533742283a5dbad7674563dca663ec3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89759031c533742283a5dbad7674563dca663ec3/comments", "author": null, "committer": null, "parents": [{"sha": "f2a7f77b2da15227e2f97a75a16cd8fdd3612d85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a7f77b2da15227e2f97a75a16cd8fdd3612d85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2a7f77b2da15227e2f97a75a16cd8fdd3612d85"}], "stats": {"total": 647, "additions": 453, "deletions": 194}, "files": [{"sha": "0c6f9489389783c267d64c303c24bd9d418bc3db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89759031c533742283a5dbad7674563dca663ec3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89759031c533742283a5dbad7674563dca663ec3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89759031c533742283a5dbad7674563dca663ec3", "patch": "@@ -1,5 +1,81 @@\n 2017-11-09  Jeff Law  <law@redhat.com>\n \n+\t* vr-values.h: New file with vr_values class.\n+\t* tree-vrp.c: Include vr-values.h\n+\t(vrp_value_range_pool, vrp_equiv_obstack, num_vr_values): Move static\n+\tdata objects into the vr_values class.\n+\t(vr_value, values_propagated, vr_phi_edge_counts): Likewise.\n+\t(get_value_range): Make it a member function within vr_values class.\n+\t(set_defs_to_varying, update_value_range, add_equivalence): Likewise.\n+\t(vrp_stmt_computes_nonzero_p, op_with_boolean_value_range_p): Likewise.\n+\t(op_with_constant_singleton_value_range): Likewise.\n+\t(extract_range_for_var_from_comparison_expr): Likewise.\n+\t(extract_range_from_assert, extract_range_from_ssa_name): Likewise.\n+\t(extract_range_from_binary_expr): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t(extract_range_from_cond_expr, extrat_range_from_comparison): Likewise.\n+\t(check_for_binary_op_overflow, extract_range_basic): Likewise.\n+\t(extract_range_from_assignment, adjust_range_with_scev): Likewise.\n+\t(dump_all_value_ranges, get_vr_for_comparison): Likewise.\n+\t(compare_name_with_value, compare_names): Likewise.\n+\t(vrp_evaluate_conditional_warnv_with_ops_using_ranges): Likewise.\n+\t(vrp_evaluate_conditional_warnv_with_ops): Likewise.  Remove prototype.\n+\t(vrp_evaluate_conditional, vrp_visit_cond_stmt): Likewise.\n+\t(vrp_visit_switch_stmt, extract_range_from_stmt): Likewise.\n+\t(extract_range_from_phi_node): Likewise.\n+\t(simplify_truth_ops_using_ranges): Likewise.\n+\t(simplify_div_or_mod_using_ranges): Likewise.\n+\t(simplify_min_or_max_using_ranges, simplify_abs_using_ranges): Likewise.\n+\t(simplify_bit_ops_using_ranges, simplify_cond_using_ranges_1): Likewise.\n+\t(simplify_cond_using_ranges_2, simplify_switch_using_ranges): Likewise.\n+\t(simplify_float_conversion_using_ranges): Likewise.\n+\t(simplify_internal_call_using_ranges): Likewise.\n+\t(two_valued_val_range_p, simplify_stmt_using_ranges): Likewise.\n+\t(vrp_visit_assignment_or_call): Likewise.  Smuggle class instance\n+\tpoitner via x_vr_values for calls into gimple folder.\n+\t(vrp_initialize_lattice): Make this the vr_values ctor.\n+\t(vrp_free_lattice): Make this the vr_values dtor.\n+\t(set_vr_value): New function.\n+\t(class vrp_prop): Add vr_values data member.  Add various member\n+\tfunctions as well as member functions that delegate to vr_values.\n+\t(check_array_ref): Make a member function within vrp_prop class.\n+\t(search_for_addr_array, vrp_initialize): Likewise.\n+\t(vrp_finalize): Likewise.  Revamp to avoid direct access to\n+\tvr_value, values_propagated, etc.\n+\t(check_array_bounds): Extract vrp_prop class instance pointer from\n+\twalk info structure.  Use it to call member functions.\n+\t(check_all_array_refs): Make a member function within vrp_prop class.\n+\tSmuggle class instance pointer via walk info structure.\n+\t(x_vr_values): New local static.\n+\t(vrp_valueize): Use x_vr_values to get class instance.\n+\t(vr_valueize_1): Likewise.\n+\t(class vrp_folder): Add vr_values data member.  Add various member\n+\tfunctions as well as member functions that delegate to vr_values.\n+\t(fold_predicate_in): Make a mber fucntion within vrp_folder class.\n+\t(simplify_stmt_for_jump_threading): Extract smuggled vr_values\n+\tclass instance from vr_values.  Use it to call member functions.\n+\t(vrp_dom_walker): Add vr_values data member.\n+\t(vrp_dom_walker::after_dom_children): Smuggle vr_values class\n+\tinstance via x_vr_values.\n+\t(identify_jump_threads): Accept vr_values as argument.  Store\n+\tit into the walker structure.\n+\t(evrp_dom_walker): Add vr_values class data member.  Add various\n+\tdelegators.\n+\t(evrp_dom_walker::try_find_new_range): Use vr_values data\n+\tmember to access the memory allocator.\n+\t(evrp_dom_walker::before_dom_children): Store vr_values class\n+\tinstance into the vrp_folder class.\n+\t(evrp_dom_walker::push_value_range): Rework to avoid direct\n+\taccess to num_vr_values and vr_value.\n+\t(evrp_dom_walker::pop_value_range): Likewise.\n+\t(execute_early_vrp): Remove call to vrp_initialize_lattice.\n+\tUse vr_values to get to dump_all_value_ranges member function.\n+\tRemove call to vrp_free_lattice.  Call vrp_initialize, vrp_finalize,\n+\tand simplify_cond_using_ranges_2 via vrp_prop class instance.\n+\tPass vr_values class instance down to identify_jump_threads.  \n+\tRemove call to vrp_free_lattice.\n+\t(debug_all_value_ranges): Remove.\n+\n \t* tree-vrp.c (vrp_prop): Move class to earlier point in the file.\n \t(vrp_folder): Likewise.\n "}, {"sha": "7173ab22478cd3512fd031f5534e2dfb2760fb5a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 258, "deletions": 194, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89759031c533742283a5dbad7674563dca663ec3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89759031c533742283a5dbad7674563dca663ec3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=89759031c533742283a5dbad7674563dca663ec3", "patch": "@@ -64,13 +64,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"vr-values.h\"\n \n #define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }\n \n-/* Allocation pools for tree-vrp allocations.  */\n-static object_allocator<value_range> vrp_value_range_pool (\"Tree VRP value ranges\");\n-static bitmap_obstack vrp_equiv_obstack;\n-\n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n@@ -87,9 +84,6 @@ live_on_edge (edge e, tree name)\n /* Local functions.  */\n static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n-static tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n-\t\t\t\t\t\t     tree, tree, bool, bool *,\n-\t\t\t\t\t\t     bool *);\n \n struct assert_info\n {\n@@ -145,17 +139,6 @@ static bitmap need_assert_for;\n    ASSERT_EXPRs for SSA name N_I should be inserted.  */\n static assert_locus **asserts_for;\n \n-/* Value range array.  After propagation, VR_VALUE[I] holds the range\n-   of values that SSA name N_I may take.  */\n-static unsigned num_vr_values;\n-static value_range **vr_value;\n-static bool values_propagated;\n-\n-/* For a PHI node which sets SSA name N_I, VR_COUNTS[I] holds the\n-   number of executable edges we saw the last time we visited the\n-   node.  */\n-static int *vr_phi_edge_counts;\n-\n struct switch_update {\n   gswitch *stmt;\n   tree vec;\n@@ -509,8 +492,8 @@ abs_extent_range (value_range *vr, tree min, tree max)\n    If we have no values ranges recorded (ie, VRP is not running), then\n    return NULL.  Otherwise create an empty range if none existed for VAR.  */\n \n-static value_range *\n-get_value_range (const_tree var)\n+value_range *\n+vr_values::get_value_range (const_tree var)\n {\n   static const value_range vr_const_varying\n     = { VR_VARYING, NULL_TREE, NULL_TREE, NULL };\n@@ -582,8 +565,8 @@ get_value_range (const_tree var)\n \n /* Set value-ranges of all SSA names defined by STMT to varying.  */\n \n-static void\n-set_defs_to_varying (gimple *stmt)\n+void\n+vr_values::set_defs_to_varying (gimple *stmt)\n {\n   ssa_op_iter i;\n   tree def;\n@@ -631,8 +614,8 @@ vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n    this function.  Do not call update_value_range when NEW_VR\n    is the range object associated with another SSA name.  */\n \n-static inline bool\n-update_value_range (const_tree var, value_range *new_vr)\n+bool\n+vr_values::update_value_range (const_tree var, value_range *new_vr)\n {\n   value_range *old_vr;\n   bool is_new;\n@@ -690,8 +673,8 @@ update_value_range (const_tree var, value_range *new_vr)\n /* Add VAR and VAR's equivalence set to EQUIV.  This is the central\n    point where equivalence processing can be turned on/off.  */\n \n-static void\n-add_equivalence (bitmap *equiv, const_tree var)\n+void\n+vr_values::add_equivalence (bitmap *equiv, const_tree var)\n {\n   unsigned ver = SSA_NAME_VERSION (var);\n   value_range *vr = get_value_range (var);\n@@ -933,8 +916,8 @@ gimple_stmt_nonzero_p (gimple *stmt)\n /* Like tree_expr_nonzero_p, but this function uses value ranges\n    obtained so far.  */\n \n-static bool\n-vrp_stmt_computes_nonzero (gimple *stmt)\n+bool\n+vr_values::vrp_stmt_computes_nonzero (gimple *stmt)\n {\n   if (gimple_stmt_nonzero_p (stmt))\n     return true;\n@@ -1260,8 +1243,8 @@ value_range_constant_singleton (value_range *vr)\n    otherwise return NULL_TREE.  This returns OP itself if OP is a\n    constant.  */\n \n-static tree\n-op_with_constant_singleton_value_range (tree op)\n+tree\n+vr_values::op_with_constant_singleton_value_range (tree op)\n {\n   if (is_gimple_min_invariant (op))\n     return op;\n@@ -1274,8 +1257,8 @@ op_with_constant_singleton_value_range (tree op)\n \n /* Return true if op is in a boolean [0, 1] value-range.  */\n \n-static bool\n-op_with_boolean_value_range_p (tree op)\n+bool\n+vr_values::op_with_boolean_value_range_p (tree op)\n {\n   value_range *vr;\n \n@@ -1298,10 +1281,11 @@ op_with_boolean_value_range_p (tree op)\n /* Extract value range information for VAR when (OP COND_CODE LIMIT) is\n    true and store it in *VR_P.  */\n \n-static void\n-extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n-\t\t\t\t\t    tree op, tree limit,\n-\t\t\t\t\t    value_range *vr_p)\n+void\n+vr_values::extract_range_for_var_from_comparison_expr (tree var,\n+\t\t\t\t\t\t       enum tree_code cond_code,\n+\t\t\t\t\t\t       tree op, tree limit,\n+\t\t\t\t\t\t       value_range *vr_p)\n {\n   tree  min, max, type;\n   value_range *limit_vr;\n@@ -1545,8 +1529,8 @@ extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n /* Extract value range information from an ASSERT_EXPR EXPR and store\n    it in *VR_P.  */\n \n-static void\n-extract_range_from_assert (value_range *vr_p, tree expr)\n+void\n+vr_values::extract_range_from_assert (value_range *vr_p, tree expr)\n {\n   tree var = ASSERT_EXPR_VAR (expr);\n   tree cond = ASSERT_EXPR_COND (expr);\n@@ -1591,8 +1575,8 @@ extract_range_from_assert (value_range *vr_p, tree expr)\n     Even if y_5 is deemed VARYING, we can determine that x_3 > y_5 is\n     always false.  */\n \n-static void\n-extract_range_from_ssa_name (value_range *vr, tree var)\n+void\n+vr_values::extract_range_from_ssa_name (value_range *vr, tree var)\n {\n   value_range *var_vr = get_value_range (var);\n \n@@ -3027,10 +3011,10 @@ extract_range_from_binary_expr_1 (value_range *vr,\n    the ranges of each of its operands with resulting type EXPR_TYPE.\n    The resulting range is stored in *VR.  */\n \n-static void\n-extract_range_from_binary_expr (value_range *vr,\n-\t\t\t\tenum tree_code code,\n-\t\t\t\ttree expr_type, tree op0, tree op1)\n+void\n+vr_values::extract_range_from_binary_expr (value_range *vr,\n+\t\t\t\t\t   enum tree_code code,\n+\t\t\t\t\t   tree expr_type, tree op0, tree op1)\n {\n   value_range vr0 = VR_INITIALIZER;\n   value_range vr1 = VR_INITIALIZER;\n@@ -3374,9 +3358,9 @@ extract_range_from_unary_expr (value_range *vr,\n    the range of its operand with resulting type TYPE.\n    The resulting range is stored in *VR.  */\n \n-static void\n-extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n-\t\t\t       tree type, tree op0)\n+void\n+vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n+\t\t\t\t\t  tree type, tree op0)\n {\n   value_range vr0 = VR_INITIALIZER;\n \n@@ -3389,15 +3373,15 @@ extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n   else\n     set_value_range_to_varying (&vr0);\n \n-  extract_range_from_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n+  ::extract_range_from_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n }\n \n \n /* Extract range information from a conditional expression STMT based on\n    the ranges of each of its operands and the expression code.  */\n \n-static void\n-extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n+void\n+vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n {\n   tree op0, op1;\n   value_range vr0 = VR_INITIALIZER;\n@@ -3430,9 +3414,9 @@ extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n /* Extract range information from a comparison expression EXPR based\n    on the range of its operand and the expression code.  */\n \n-static void\n-extract_range_from_comparison (value_range *vr, enum tree_code code,\n-\t\t\t       tree type, tree op0, tree op1)\n+void\n+vr_values::extract_range_from_comparison (value_range *vr, enum tree_code code,\n+\t\t\t\t\t  tree type, tree op0, tree op1)\n {\n   bool sop;\n   tree val;\n@@ -3461,9 +3445,9 @@ extract_range_from_comparison (value_range *vr, enum tree_code code,\n    always overflow.  Set *OVF to true if it is known to always\n    overflow.  */\n \n-static bool\n-check_for_binary_op_overflow (enum tree_code subcode, tree type,\n-\t\t\t      tree op0, tree op1, bool *ovf)\n+bool\n+vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n+\t\t\t\t\t tree op0, tree op1, bool *ovf)\n {\n   value_range vr0 = VR_INITIALIZER;\n   value_range vr1 = VR_INITIALIZER;\n@@ -3566,8 +3550,8 @@ check_for_binary_op_overflow (enum tree_code subcode, tree type,\n    primarily on generic routines in fold in conjunction with range data.\n    Store the result in *VR */\n \n-static void\n-extract_range_basic (value_range *vr, gimple *stmt)\n+void\n+vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n {\n   bool sop;\n   tree type = gimple_expr_type (stmt);\n@@ -3917,8 +3901,8 @@ extract_range_basic (value_range *vr, gimple *stmt)\n /* Try to compute a useful range out of assignment STMT and store it\n    in *VR.  */\n \n-static void\n-extract_range_from_assignment (value_range *vr, gassign *stmt)\n+void\n+vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n {\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n \n@@ -3956,9 +3940,9 @@ extract_range_from_assignment (value_range *vr, gassign *stmt)\n    would be profitable to adjust VR using scalar evolution information\n    for VAR.  If so, update VR with the new limits.  */\n \n-static void\n-adjust_range_with_scev (value_range *vr, struct loop *loop,\n-\t\t\tgimple *stmt, tree var)\n+void\n+vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n+\t\t\t\t   gimple *stmt, tree var)\n {\n   tree init, step, chrec, tmin, tmax, min, max, type, tem;\n   enum ev_direction dir;\n@@ -4402,7 +4386,6 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n void dump_value_range (FILE *, const value_range *);\n void debug_value_range (value_range *);\n void dump_all_value_ranges (FILE *);\n-void debug_all_value_ranges (void);\n void dump_vr_equiv (FILE *, bitmap);\n void debug_vr_equiv (bitmap);\n \n@@ -4476,7 +4459,7 @@ debug_value_range (value_range *vr)\n /* Dump value ranges of all SSA_NAMEs to FILE.  */\n \n void\n-dump_all_value_ranges (FILE *file)\n+vr_values::dump_all_value_ranges (FILE *file)\n {\n   size_t i;\n \n@@ -4494,16 +4477,6 @@ dump_all_value_ranges (FILE *file)\n   fprintf (file, \"\\n\");\n }\n \n-\n-/* Dump all value ranges to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_all_value_ranges (void)\n-{\n-  dump_all_value_ranges (stderr);\n-}\n-\n-\n /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n    create a new SSA name N and return the assertion assignment\n    'N = ASSERT_EXPR <V, V OP W>'.  */\n@@ -6640,6 +6613,28 @@ class vrp_prop : public ssa_propagation_engine\n  public:\n   enum ssa_prop_result visit_stmt (gimple *, edge *, tree *) FINAL OVERRIDE;\n   enum ssa_prop_result visit_phi (gphi *) FINAL OVERRIDE;\n+\n+  void vrp_initialize (void);\n+  void vrp_finalize (bool);\n+  void check_all_array_refs (void);\n+  void check_array_ref (location_t, tree, bool);\n+  void search_for_addr_array (tree, location_t);\n+\n+  class vr_values vr_values;\n+  /* Temporary delegator to minimize code churn.  */\n+  value_range *get_value_range (const_tree op)\n+    { return vr_values.get_value_range (op); }\n+  void set_defs_to_varying (gimple *stmt)\n+    { return vr_values.set_defs_to_varying (stmt); }\n+  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+\t\t\t\ttree *output_p, value_range *vr)\n+    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n+  bool update_value_range (const_tree op, value_range *vr)\n+    { return vr_values.update_value_range (op, vr); }\n+  void extract_range_basic (value_range *vr, gimple *stmt)\n+    { vr_values.extract_range_basic (vr, stmt); }\n+  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n+    { vr_values.extract_range_from_phi_node (phi, vr); }\n };\n \n /* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible arrays\n@@ -6649,8 +6644,9 @@ class vrp_prop : public ssa_propagation_engine\n    non-overlapping with valid range.\n    IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n \n-static void\n-check_array_ref (location_t location, tree ref, bool ignore_off_by_one)\n+void\n+vrp_prop::check_array_ref (location_t location, tree ref,\n+\t\t\t   bool ignore_off_by_one)\n {\n   value_range *vr = NULL;\n   tree low_sub, up_sub;\n@@ -6742,8 +6738,8 @@ check_array_ref (location_t location, tree ref, bool ignore_off_by_one)\n /* Searches if the expr T, located at LOCATION computes\n    address of an ARRAY_REF, and call check_array_ref on it.  */\n \n-static void\n-search_for_addr_array (tree t, location_t location)\n+void\n+vrp_prop::search_for_addr_array (tree t, location_t location)\n {\n   /* Check each ARRAY_REFs in the reference chain. */\n   do\n@@ -6828,12 +6824,13 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n \n   *walk_subtree = TRUE;\n \n+  vrp_prop *vrp_prop = (class vrp_prop *)wi->info;\n   if (TREE_CODE (t) == ARRAY_REF)\n-    check_array_ref (location, t, false /*ignore_off_by_one*/);\n+    vrp_prop->check_array_ref (location, t, false /*ignore_off_by_one*/);\n \n   else if (TREE_CODE (t) == ADDR_EXPR)\n     {\n-      search_for_addr_array (t, location);\n+      vrp_prop->search_for_addr_array (t, location);\n       *walk_subtree = FALSE;\n     }\n \n@@ -6843,8 +6840,8 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n /* Walk over all statements of all reachable BBs and call check_array_bounds\n    on them.  */\n \n-static void\n-check_all_array_refs (void)\n+void\n+vrp_prop::check_all_array_refs ()\n {\n   basic_block bb;\n   gimple_stmt_iterator si;\n@@ -6871,6 +6868,8 @@ check_all_array_refs (void)\n \n \t  memset (&wi, 0, sizeof (wi));\n \n+\t  wi.info = this;\n+\n \t  walk_gimple_op (gsi_stmt (si),\n \t\t\t  check_array_bounds,\n \t\t\t  &wi);\n@@ -7121,8 +7120,7 @@ stmt_interesting_for_vrp (gimple *stmt)\n \n /* Initialize VRP lattice.  */\n \n-static void\n-vrp_initialize_lattice ()\n+vr_values::vr_values () : vrp_value_range_pool (\"Tree VRP value ranges\")\n {\n   values_propagated = false;\n   num_vr_values = num_ssa_names;\n@@ -7133,8 +7131,8 @@ vrp_initialize_lattice ()\n \n /* Initialization required by ssa_propagate engine.  */\n \n-static void\n-vrp_initialize ()\n+void\n+vrp_prop::vrp_initialize ()\n {\n   basic_block bb;\n \n@@ -7175,14 +7173,17 @@ vrp_initialize ()\n     }\n }\n \n+/* A hack.  */\n+static class vr_values *x_vr_values;\n+\n /* Return the singleton value-range for NAME or NAME.  */\n \n static inline tree\n vrp_valueize (tree name)\n {\n   if (TREE_CODE (name) == SSA_NAME)\n     {\n-      value_range *vr = get_value_range (name);\n+      value_range *vr = x_vr_values->get_value_range (name);\n       if (vr->type == VR_RANGE\n \t  && (TREE_CODE (vr->min) == SSA_NAME\n \t      || is_gimple_min_invariant (vr->min))\n@@ -7207,7 +7208,7 @@ vrp_valueize_1 (tree name)\n       if (!gimple_nop_p (def_stmt)\n \t  && prop_simulate_again_p (def_stmt))\n \treturn NULL_TREE;\n-      value_range *vr = get_value_range (name);\n+      value_range *vr = x_vr_values->get_value_range (name);\n       if (range_int_cst_singleton_p (vr))\n \treturn vr->min;\n     }\n@@ -7217,8 +7218,9 @@ vrp_valueize_1 (tree name)\n /* Visit assignment STMT.  If it produces an interesting range, record\n    the range in VR and set LHS to OUTPUT_P.  */\n \n-static void\n-vrp_visit_assignment_or_call (gimple *stmt, tree *output_p, value_range *vr)\n+void\n+vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n+\t\t\t\t\t value_range *vr)\n {\n   tree lhs;\n   enum gimple_code code = gimple_code (stmt);\n@@ -7237,8 +7239,10 @@ vrp_visit_assignment_or_call (gimple *stmt, tree *output_p, value_range *vr)\n       *output_p = lhs;\n \n       /* Try folding the statement to a constant first.  */\n+      x_vr_values = this;\n       tree tem = gimple_fold_stmt_to_constant_1 (stmt, vrp_valueize,\n \t\t\t\t\t\t vrp_valueize_1);\n+      x_vr_values = NULL;\n       if (tem)\n \t{\n \t  if (TREE_CODE (tem) == SSA_NAME\n@@ -7266,8 +7270,8 @@ vrp_visit_assignment_or_call (gimple *stmt, tree *output_p, value_range *vr)\n    or a symbolic range containing the SSA_NAME only if the value range\n    is varying or undefined.  */\n \n-static inline value_range\n-get_vr_for_comparison (int i)\n+value_range\n+vr_values::get_vr_for_comparison (int i)\n {\n   value_range vr = *get_value_range (ssa_name (i));\n \n@@ -7289,9 +7293,9 @@ get_vr_for_comparison (int i)\n    compare_range_with_value, including the setting of\n    *STRICT_OVERFLOW_P.  */\n \n-static tree\n-compare_name_with_value (enum tree_code comp, tree var, tree val,\n-\t\t\t bool *strict_overflow_p, bool use_equiv_p)\n+tree\n+vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n+\t\t\t\t    bool *strict_overflow_p, bool use_equiv_p)\n {\n   bitmap_iterator bi;\n   unsigned i;\n@@ -7374,9 +7378,9 @@ compare_name_with_value (enum tree_code comp, tree var, tree val,\n    whether we relied on undefined signed overflow in the comparison.  */\n \n \n-static tree\n-compare_names (enum tree_code comp, tree n1, tree n2,\n-\t       bool *strict_overflow_p)\n+tree\n+vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n+\t\t\t  bool *strict_overflow_p)\n {\n   tree t, retval;\n   bitmap e1, e2;\n@@ -7489,10 +7493,9 @@ compare_names (enum tree_code comp, tree n1, tree n2,\n /* Helper function for vrp_evaluate_conditional_warnv & other\n    optimizers.  */\n \n-static tree\n-vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code code,\n-\t\t\t\t\t\t      tree op0, tree op1,\n-\t\t\t\t\t\t      bool * strict_overflow_p)\n+tree\n+vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n+    (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p)\n {\n   value_range *vr0, *vr1;\n \n@@ -7512,10 +7515,12 @@ vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code code,\n \n /* Helper function for vrp_evaluate_conditional_warnv. */\n \n-static tree\n-vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n-\t\t\t\t\t tree op1, bool use_equiv_p,\n-\t\t\t\t\t bool *strict_overflow_p, bool *only_ranges)\n+tree\n+vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n+\t\t\t\t\t\t    tree op0, tree op1,\n+\t\t\t\t\t\t    bool use_equiv_p,\n+\t\t\t\t\t\t    bool *strict_overflow_p,\n+\t\t\t\t\t\t    bool *only_ranges)\n {\n   tree ret;\n   if (only_ranges)\n@@ -7584,8 +7589,9 @@ vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n    based on undefined signed overflow, issue a warning if\n    appropriate.  */\n \n-static tree\n-vrp_evaluate_conditional (tree_code code, tree op0, tree op1, gimple *stmt)\n+tree\n+vr_values::vrp_evaluate_conditional (tree_code code, tree op0,\n+\t\t\t\t     tree op1, gimple *stmt)\n {\n   bool sop;\n   tree ret;\n@@ -7676,8 +7682,8 @@ vrp_evaluate_conditional (tree_code code, tree op0, tree op1, gimple *stmt)\n    will be taken out of STMT's basic block, record it in\n    *TAKEN_EDGE_P.  Otherwise, set *TAKEN_EDGE_P to NULL.  */\n \n-static void\n-vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n+void\n+vr_values::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n {\n   tree val;\n \n@@ -7960,8 +7966,8 @@ find_case_label_ranges (gswitch *stmt, value_range *vr, size_t *min_idx1,\n    will be taken out of STMT's basic block, record it in\n    *TAKEN_EDGE_P.  Otherwise, *TAKEN_EDGE_P set to NULL.  */\n \n-static void\n-vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n+void\n+vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n {\n   tree op, val;\n   value_range *vr;\n@@ -8052,9 +8058,9 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n    If STMT is a conditional branch and we can determine its truth\n    value, the taken edge is recorded in *TAKEN_EDGE_P.  */\n \n-static void\n-extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t tree *output_p, value_range *vr)\n+void\n+vr_values::extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+\t\t\t\t    tree *output_p, value_range *vr)\n {\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -8960,8 +8966,8 @@ vrp_meet (value_range *vr0, const value_range *vr1)\n    edges.  If a valid value range can be derived from all the incoming\n    value ranges, set a new range in VR_RESULT.  */\n \n-static void\n-extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n+void\n+vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n {\n   size_t i;\n   tree lhs = PHI_RESULT (phi);\n@@ -9205,8 +9211,9 @@ vrp_prop::visit_phi (gphi *phi)\n \n /* Simplify boolean operations if the source is known\n    to be already a boolean.  */\n-static bool\n-simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+bool\n+vr_values::simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t    gimple *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs, op0, op1;\n@@ -9281,8 +9288,9 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n    [-op1min + 1, op1min - 1] for signed and [0, op1min - 1] for unsigned\n    modulo.  */\n \n-static bool\n-simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+bool\n+vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t     gimple *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree val = NULL;\n@@ -9405,8 +9413,9 @@ simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n /* Simplify a min or max if the ranges of the two operands are\n    disjoint.   Return true if we do simplify.  */\n \n-static bool\n-simplify_min_or_max_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+bool\n+vr_values::simplify_min_or_max_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t     gimple *stmt)\n {\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n@@ -9452,8 +9461,8 @@ simplify_min_or_max_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n    ABS_EXPR.  If the operand is <= 0, then simplify the\n    ABS_EXPR into a NEGATE_EXPR.  */\n \n-static bool\n-simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+bool\n+vr_values::simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n {\n   tree op = gimple_assign_rhs1 (stmt);\n   value_range *vr = get_value_range (op);\n@@ -9508,8 +9517,9 @@ simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n    set by | are already known to be one from VR, the bit\n    operation is redundant.  */\n \n-static bool\n-simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+bool\n+vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t  gimple *stmt)\n {\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n@@ -9705,8 +9715,8 @@ range_fits_type_p (value_range *vr, unsigned dest_precision, signop dest_sgn)\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n \n-static bool\n-simplify_cond_using_ranges_1 (gcond *stmt)\n+bool\n+vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -9790,8 +9800,8 @@ simplify_cond_using_ranges_1 (gcond *stmt)\n    of the type conversion.  Doing so makes the conversion dead which helps\n    subsequent passes.  */\n \n-static void\n-simplify_cond_using_ranges_2 (gcond *stmt)\n+void\n+vr_values::simplify_cond_using_ranges_2 (gcond *stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -9847,8 +9857,8 @@ simplify_cond_using_ranges_2 (gcond *stmt)\n /* Simplify a switch statement using the value range of the switch\n    argument.  */\n \n-static bool\n-simplify_switch_using_ranges (gswitch *stmt)\n+bool\n+vr_values::simplify_switch_using_ranges (gswitch *stmt)\n {\n   tree op = gimple_switch_index (stmt);\n   value_range *vr = NULL;\n@@ -10105,9 +10115,9 @@ simplify_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n \n /* Simplify a conversion from integral SSA name to float in STMT.  */\n \n-static bool\n-simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\tgimple *stmt)\n+bool\n+vr_values::simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t\t   gimple *stmt)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n   value_range *vr = get_value_range (rhs1);\n@@ -10169,8 +10179,9 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n \n /* Simplify an internal fn call using ranges if possible.  */\n \n-static bool\n-simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+bool\n+vr_values::simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t\tgimple *stmt)\n {\n   enum tree_code subcode;\n   bool is_ubsan = false;\n@@ -10271,8 +10282,8 @@ simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n /* Return true if VAR is a two-valued variable.  Set a and b with the\n    two-values when it is true.  Return false otherwise.  */\n \n-static bool\n-two_valued_val_range_p (tree var, tree *a, tree *b)\n+bool\n+vr_values::two_valued_val_range_p (tree var, tree *a, tree *b)\n {\n   value_range *vr = get_value_range (var);\n   if ((vr->type != VR_RANGE\n@@ -10306,8 +10317,8 @@ two_valued_val_range_p (tree var, tree *a, tree *b)\n \n /* Simplify STMT using ranges if possible.  */\n \n-static bool\n-simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n+bool\n+vr_values::simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   if (is_gimple_assign (stmt))\n@@ -10455,14 +10466,26 @@ class vrp_folder : public substitute_and_fold_engine\n  public:\n   tree get_value (tree) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n+  bool fold_predicate_in (gimple_stmt_iterator *);\n+\n+  class vr_values *vr_values;\n+\n+  /* Delegators.  */\n+  tree vrp_evaluate_conditional (tree_code code, tree op0,\n+\t\t\t\t tree op1, gimple *stmt)\n+    { return vr_values->vrp_evaluate_conditional (code, op0, op1, stmt); }\n+  bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n+    { return vr_values->simplify_stmt_using_ranges (gsi); }\n+ tree op_with_constant_singleton_value_range (tree op)\n+    { return vr_values->op_with_constant_singleton_value_range (op); }\n };\n \n /* If the statement pointed by SI has a predicate whose value can be\n    computed using the value range information computed by VRP, compute\n    its value and return true.  Otherwise, return false.  */\n \n-static bool\n-fold_predicate_in (gimple_stmt_iterator *si)\n+bool\n+vrp_folder::fold_predicate_in (gimple_stmt_iterator *si)\n {\n   bool assignment_p = false;\n   tree val;\n@@ -10584,6 +10607,7 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n   if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n     return cached_lhs;\n \n+  vr_values *vr_values = x_vr_values;\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n       tree op0 = gimple_cond_lhs (cond_stmt);\n@@ -10592,8 +10616,8 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n       tree op1 = gimple_cond_rhs (cond_stmt);\n       op1 = lhs_of_dominating_assert (op1, bb, stmt);\n \n-      return vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t       op0, op1, within_stmt);\n+      return vr_values->vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t  op0, op1, within_stmt);\n     }\n \n   /* We simplify a switch statement by trying to determine which case label\n@@ -10607,7 +10631,7 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \n       op = lhs_of_dominating_assert (op, bb, stmt);\n \n-      value_range *vr = get_value_range (op);\n+      value_range *vr = vr_values->get_value_range (op);\n       if ((vr->type != VR_RANGE && vr->type != VR_ANTI_RANGE)\n \t  || symbolic_range_p (vr))\n \treturn NULL_TREE;\n@@ -10668,7 +10692,7 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t      || POINTER_TYPE_P (TREE_TYPE (lhs))))\n \t{\n-\t  extract_range_from_assignment (&new_vr, assign_stmt);\n+\t  vr_values->extract_range_from_assignment (&new_vr, assign_stmt);\n \t  if (range_int_cst_singleton_p (&new_vr))\n \t    return new_vr.min;\n \t}\n@@ -10691,11 +10715,14 @@ class vrp_dom_walker : public dom_walker\n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n+  class vr_values *vr_values;\n+\n private:\n   class const_and_copies *m_const_and_copies;\n   class avail_exprs_stack *m_avail_exprs_stack;\n \n   gcond *m_dummy_cond;\n+\n };\n \n /* Called before processing dominator children of BB.  We want to look\n@@ -10748,9 +10775,11 @@ vrp_dom_walker::after_dom_children (basic_block bb)\n \t\t\t\t      integer_zero_node, integer_zero_node,\n \t\t\t\t      NULL, NULL);\n \n+  x_vr_values = vr_values;\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack,\n \t\t\t simplify_stmt_for_jump_threading);\n+  x_vr_values = NULL;\n \n   m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n@@ -10777,7 +10806,7 @@ vrp_dom_walker::after_dom_children (basic_block bb)\n    for later realization.  */\n \n static void\n-identify_jump_threads (void)\n+identify_jump_threads (class vr_values *vr_values)\n {\n   int i;\n   edge e;\n@@ -10809,6 +10838,7 @@ identify_jump_threads (void)\n     = new class avail_exprs_stack (avail_exprs);\n \n   vrp_dom_walker walker (CDI_DOMINATORS, equiv_stack, avail_exprs_stack);\n+  walker.vr_values = vr_values;\n   walker.walk (cfun->cfg->x_entry_block_ptr);\n \n   /* Clear EDGE_IGNORE.  */\n@@ -10825,8 +10855,7 @@ identify_jump_threads (void)\n \n /* Free VRP lattice.  */\n \n-static void\n-vrp_free_lattice ()\n+vr_values::~vr_values ()\n {\n   /* Free allocated memory.  */\n   free (vr_value);\n@@ -10842,48 +10871,49 @@ vrp_free_lattice ()\n \n /* Traverse all the blocks folding conditionals with known ranges.  */\n \n-static void\n-vrp_finalize (bool warn_array_bounds_p)\n+void\n+vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n {\n   size_t i;\n \n-  values_propagated = true;\n+  vr_values.values_propagated = true;\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nValue ranges after VRP:\\n\\n\");\n-      dump_all_value_ranges (dump_file);\n+      vr_values.dump_all_value_ranges (dump_file);\n       fprintf (dump_file, \"\\n\");\n     }\n \n   /* Set value range to non pointer SSA_NAMEs.  */\n-  for (i  = 0; i < num_vr_values; i++)\n-    if (vr_value[i])\n-      {\n-\ttree name = ssa_name (i);\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (!name)\n+\tcontinue;\n \n-\tif (!name\n-\t    || (vr_value[i]->type == VR_VARYING)\n-\t    || (vr_value[i]->type == VR_UNDEFINED)\n-\t    || (TREE_CODE (vr_value[i]->min) != INTEGER_CST)\n-\t    || (TREE_CODE (vr_value[i]->max) != INTEGER_CST))\n-\t  continue;\n+      value_range *vr = get_value_range (name);\n+      if (!name\n+\t  || (vr->type == VR_VARYING)\n+\t  || (vr->type == VR_UNDEFINED)\n+\t  || (TREE_CODE (vr->min) != INTEGER_CST)\n+\t  || (TREE_CODE (vr->max) != INTEGER_CST))\n+\tcontinue;\n \n-\tif (POINTER_TYPE_P (TREE_TYPE (name))\n-\t    && ((vr_value[i]->type == VR_RANGE\n-\t\t && range_includes_zero_p (vr_value[i]->min,\n-\t\t\t\t\t   vr_value[i]->max) == 0)\n-\t\t|| (vr_value[i]->type == VR_ANTI_RANGE\n-\t\t    && range_includes_zero_p (vr_value[i]->min,\n-\t\t\t\t\t      vr_value[i]->max) == 1)))\n-\t  set_ptr_nonnull (name);\n-\telse if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-\t  set_range_info (name, vr_value[i]->type,\n-\t\t\t  wi::to_wide (vr_value[i]->min),\n-\t\t\t  wi::to_wide (vr_value[i]->max));\n-      }\n+      if (POINTER_TYPE_P (TREE_TYPE (name))\n+\t  && ((vr->type == VR_RANGE\n+\t       && range_includes_zero_p (vr->min, vr->max) == 0)\n+\t      || (vr->type == VR_ANTI_RANGE\n+\t\t  && range_includes_zero_p (vr->min, vr->max) == 1)))\n+\tset_ptr_nonnull (name);\n+      else if (!POINTER_TYPE_P (TREE_TYPE (name)))\n+\tset_range_info (name, vr->type,\n+\t\t\twi::to_wide (vr->min),\n+\t\t\twi::to_wide (vr->max));\n+    }\n \n   class vrp_folder vrp_folder;\n+  vrp_folder.vr_values = &vr_values;\n   vrp_folder.substitute_and_fold ();\n \n   if (warn_array_bounds && warn_array_bounds_p)\n@@ -10917,6 +10947,38 @@ class evrp_dom_walker : public dom_walker\n   bitmap need_eh_cleanup;\n   auto_vec<gimple *> stmts_to_fixup;\n   auto_vec<gimple *> stmts_to_remove;\n+\n+  class vr_values vr_values;\n+\n+  /* Temporary delegators.  */\n+  value_range *get_value_range (const_tree op)\n+    { return vr_values.get_value_range (op); }\n+  bool update_value_range (const_tree op, value_range *vr)\n+    { return vr_values.update_value_range (op, vr); }\n+  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n+    { vr_values.extract_range_from_phi_node (phi, vr); }\n+  void extract_range_for_var_from_comparison_expr (tree var,\n+\t\t\t\t\t\t   enum tree_code cond_code,\n+\t\t\t\t\t\t   tree op, tree limit,\n+\t\t\t\t\t\t   value_range *vr_p)\n+    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n+\t\t\t\t\t\t\t    op, limit, vr_p); }\n+  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n+\t\t\t       gimple *stmt, tree var)\n+    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n+  tree op_with_constant_singleton_value_range (tree op)\n+    { return vr_values.op_with_constant_singleton_value_range (op); }\n+  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+\t\t\t\ttree *output_p, value_range *vr)\n+    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n+  void set_defs_to_varying (gimple *stmt)\n+    { return vr_values.set_defs_to_varying (stmt); }\n+  void set_vr_value (tree name, value_range *vr)\n+    { vr_values.set_vr_value (name, vr); }\n+  void simplify_cond_using_ranges_2 (gcond *stmt)\n+    { vr_values.simplify_cond_using_ranges_2 (stmt); }\n+  void vrp_visit_cond_stmt (gcond *cond, edge *e)\n+    { vr_values.vrp_visit_cond_stmt (cond, e); }\n };\n \n /*  Find new range for NAME such that (OP CODE LIMIT) is true.  */\n@@ -10939,7 +11001,7 @@ evrp_dom_walker::try_find_new_range (tree name,\n \t  && vrp_operand_equal_p (old_vr->min, vr.min)\n \t  && vrp_operand_equal_p (old_vr->max, vr.max))\n \treturn NULL;\n-      value_range *new_vr = vrp_value_range_pool.allocate ();\n+      value_range *new_vr = vr_values.vrp_value_range_pool.allocate ();\n       *new_vr = vr;\n       return new_vr;\n     }\n@@ -11208,6 +11270,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \n       /* Try folding stmts with the VR discovered.  */\n       class vrp_folder vrp_folder;\n+      vrp_folder.vr_values = &vr_values;\n       bool did_replace = vrp_folder.replace_uses_in (stmt);\n       if (fold_stmt (&gsi, follow_single_use_edges)\n \t  || did_replace)\n@@ -11274,13 +11337,19 @@ evrp_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n   stack.pop ();\n }\n \n+void\n+vr_values::set_vr_value (tree var, value_range *vr)\n+{\n+  if (SSA_NAME_VERSION (var) >= num_vr_values)\n+    return;\n+  vr_value[SSA_NAME_VERSION (var)] = vr;\n+}\n+\n /* Push the Value Range of VAR to the stack and update it with new VR.  */\n \n void\n evrp_dom_walker::push_value_range (tree var, value_range *vr)\n {\n-  if (SSA_NAME_VERSION (var) >= num_vr_values)\n-    return;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"pushing new range for \");\n@@ -11290,7 +11359,7 @@ evrp_dom_walker::push_value_range (tree var, value_range *vr)\n       fprintf (dump_file, \"\\n\");\n     }\n   stack.safe_push (std::make_pair (var, get_value_range (var)));\n-  vr_value[SSA_NAME_VERSION (var)] = vr;\n+  set_vr_value (var, vr);\n }\n \n /* Pop the Value Range from the vrp_stack and update VAR with it.  */\n@@ -11308,7 +11377,7 @@ evrp_dom_walker::pop_value_range (tree var)\n       dump_value_range (dump_file, vr);\n       fprintf (dump_file, \"\\n\");\n     }\n-  vr_value[SSA_NAME_VERSION (var)] = vr;\n+  set_vr_value (var, vr);\n   stack.pop ();\n   return vr;\n }\n@@ -11335,7 +11404,6 @@ execute_early_vrp ()\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \te->flags |= EDGE_EXECUTABLE;\n     }\n-  vrp_initialize_lattice ();\n \n   /* Walk stmts in dominance order and propagate VRP.  */\n   evrp_dom_walker walker;\n@@ -11344,7 +11412,7 @@ execute_early_vrp ()\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-      dump_all_value_ranges (dump_file);\n+      walker.vr_values.dump_all_value_ranges (dump_file);\n       fprintf (dump_file, \"\\n\");\n     }\n \n@@ -11382,7 +11450,6 @@ execute_early_vrp ()\n       fixup_noreturn_call (stmt);\n     }\n \n-  vrp_free_lattice ();\n   scev_finalize ();\n   loop_optimizer_finalize ();\n   return 0;\n@@ -11456,15 +11523,14 @@ execute_vrp (bool warn_array_bounds_p)\n   /* For visiting PHI nodes we need EDGE_DFS_BACK computed.  */\n   mark_dfs_back_edges ();\n \n-  vrp_initialize_lattice ();\n-  vrp_initialize ();\n   class vrp_prop vrp_prop;\n+  vrp_prop.vrp_initialize ();\n   vrp_prop.ssa_propagate ();\n-  vrp_finalize (warn_array_bounds_p);\n+  vrp_prop.vrp_finalize (warn_array_bounds_p);\n \n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */\n-  identify_jump_threads ();\n+  identify_jump_threads (&vrp_prop.vr_values);\n \n   /* A comparison of an SSA_NAME against a constant where the SSA_NAME\n      was set by a type conversion can often be rewritten to use the\n@@ -11478,11 +11544,9 @@ execute_vrp (bool warn_array_bounds_p)\n     {\n       gimple *last = last_stmt (bb);\n       if (last && gimple_code (last) == GIMPLE_COND)\n-\tsimplify_cond_using_ranges_2 (as_a <gcond *> (last));\n+\tvrp_prop.vr_values.simplify_cond_using_ranges_2 (as_a <gcond *> (last));\n     }\n \n-  vrp_free_lattice ();\n-\n   free_numbers_of_iterations_estimates (cfun);\n \n   /* ASSERT_EXPRs must be removed before finalizing jump threads"}, {"sha": "3b38ab6e941d888e116cc6804dc7e54e676f42b5", "filename": "gcc/vr-values.h", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89759031c533742283a5dbad7674563dca663ec3/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89759031c533742283a5dbad7674563dca663ec3/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=89759031c533742283a5dbad7674563dca663ec3", "patch": "@@ -0,0 +1,119 @@\n+/* Support routines for Value Range Propagation (VRP).\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VR_VALUES_H\n+#define GCC_VR_VALUES_H\n+\n+/* The VR_VALUES class holds the current view of range information\n+   for all the SSA_NAMEs in the IL.\n+\n+   It can be used to hold context sensitive range information during\n+   a dominator walk or it may be used to hold range information in the\n+   standard VRP pass as ranges are propagated through the lattice to a\n+   steady state.\n+\n+   This information is independent of the range information that gets\n+   attached to SSA_NAMEs.  A pass such as VRP may choose to transfer\n+   the global information it produces into global range information that\n+   gets attached to an SSA_NAME.  It's unclear how useful that global\n+   information will be in a world where we can compute context sensitive\n+   range information fast or perform on-demand queries.  */\n+class vr_values\n+{\n+ public:\n+  vr_values (void);\n+  ~vr_values (void);\n+\n+  /* Value range array.  After propagation, VR_VALUE[I] holds the range\n+     of values that SSA name N_I may take.  */\n+  unsigned int num_vr_values;\n+  value_range **vr_value;\n+  bool values_propagated;\n+\n+  /* For a PHI node which sets SSA name N_I, VR_COUNTS[I] holds the\n+     number of executable edges we saw the last time we visited the\n+     node.  */\n+  int *vr_phi_edge_counts;\n+\n+  /* Allocation pools for tree-vrp allocations.  */\n+  object_allocator<value_range> vrp_value_range_pool;\n+  bitmap_obstack vrp_equiv_obstack;\n+\n+  value_range *get_value_range (const_tree);\n+  void set_vr_value (tree, value_range *);\n+\n+  void set_defs_to_varying (gimple *);\n+  bool update_value_range (const_tree, value_range *);\n+  void add_equivalence (bitmap *, const_tree);\n+  bool vrp_stmt_computes_nonzero (gimple *);\n+  tree op_with_constant_singleton_value_range (tree);\n+  bool op_with_boolean_value_range_p (tree);\n+  bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n+  void adjust_range_with_scev (value_range *, struct loop *, gimple *, tree);\n+  value_range get_vr_for_comparison (int);\n+  tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n+  tree compare_names (enum tree_code, tree, tree, bool *);\n+  bool two_valued_val_range_p (tree, tree *, tree *);\n+\n+  tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n+\t\t\t\t\t\t\t     tree, tree,\n+\t\t\t\t\t\t\t     bool *);\n+  tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n+\t\t\t\t\t\ttree, tree, bool,\n+\t\t\t\t\t\tbool *, bool *);\n+  tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n+\n+\n+  void dump_all_value_ranges (FILE *);\n+\n+  void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n+\t\t\t\t\t\t   tree, tree, value_range *);\n+  void extract_range_from_assert (value_range *, tree);\n+  void extract_range_from_ssa_name (value_range *, tree);\n+  void extract_range_from_binary_expr (value_range *, enum tree_code,\n+\t\t\t\t       tree, tree, tree);\n+  void extract_range_from_unary_expr (value_range *, enum tree_code,\n+\t\t\t\t      tree, tree);\n+  void extract_range_from_phi_node (gphi *, value_range *);\n+  void extract_range_from_cond_expr (value_range *, gassign *);\n+  void extract_range_basic (value_range *, gimple *);\n+  void extract_range_from_assignment (value_range *, gassign *);\n+  void extract_range_from_stmt (gimple *, edge *, tree *, value_range *);\n+  void extract_range_from_comparison (value_range *, enum tree_code,\n+\t\t\t\t      tree, tree, tree);\n+\n+  void vrp_visit_assignment_or_call (gimple*, tree *, value_range *);\n+  void vrp_visit_switch_stmt (gswitch *, edge *);\n+  void vrp_visit_cond_stmt (gcond *, edge *);\n+\n+  bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_bit_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_min_or_max_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_cond_using_ranges_1 (gcond *);\n+  void simplify_cond_using_ranges_2 (gcond *);\n+  bool simplify_switch_using_ranges (gswitch *);\n+  bool simplify_float_conversion_using_ranges (gimple_stmt_iterator *,\n+\t\t\t\t\t       gimple *);\n+  bool simplify_internal_call_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n+};\n+\n+#endif /* GCC_VR_VALUES_H */"}]}