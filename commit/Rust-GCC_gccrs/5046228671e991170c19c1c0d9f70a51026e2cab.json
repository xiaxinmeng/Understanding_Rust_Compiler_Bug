{"sha": "5046228671e991170c19c1c0d9f70a51026e2cab", "node_id": "C_kwDOANBUbNoAKDUwNDYyMjg2NzFlOTkxMTcwYzE5YzFjMGQ5ZjcwYTUxMDI2ZTJjYWI", "commit": {"author": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2021-12-17T13:34:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-10T08:19:21Z"}, "message": "[Ada] Fix incorrect range computation\n\nWhen the type range [Lo, Hi] and the computed expression range [Lor,\nHir] are disjoint, the range-constraining logic breaks and returns an\nincorrect range. For example, when Lo<Hi<Lor<Hir, it currently returns\n[Lor, Hi]. Instead, return the computed range.\n\nThe current constraining logic would require returning the base type's\nbounds. However, this would miss an opportunity to warn about out of\nrange values for some cases (e.g. when type's upper bound is equal to\nbase type upper bound).\n\nThe alternative of always returning the computed values, even when\nranges are intersecting, has unwanted effects (mainly useless\nconstraint checks are inserted) in the Enable_Overflow_Check and\nApply_Scalar_Range_Check as these bounds have a special interpretation.\n\ngcc/ada/\n\n\t* checks.adb (Determine_Range): Fix range refining.", "tree": {"sha": "18ccb6aa301e56f7a3f3856c98c04049e79671b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18ccb6aa301e56f7a3f3856c98c04049e79671b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5046228671e991170c19c1c0d9f70a51026e2cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5046228671e991170c19c1c0d9f70a51026e2cab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5046228671e991170c19c1c0d9f70a51026e2cab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5046228671e991170c19c1c0d9f70a51026e2cab/comments", "author": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a445a8692c43d14c494e1edf505ee4f33cb98bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a445a8692c43d14c494e1edf505ee4f33cb98bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a445a8692c43d14c494e1edf505ee4f33cb98bb6"}], "stats": {"total": 53, "additions": 40, "deletions": 13}, "files": [{"sha": "9950c18347ce6d22cad1ff17054cce4c52b7e932", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5046228671e991170c19c1c0d9f70a51026e2cab/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5046228671e991170c19c1c0d9f70a51026e2cab/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=5046228671e991170c19c1c0d9f70a51026e2cab", "patch": "@@ -5469,22 +5469,49 @@ package body Checks is\n          --  we do NOT do this for the case of a modular type where the\n          --  possible upper bound on the value is above the base type high\n          --  bound, because that means the result could wrap.\n+         --  Same applies for the lower bound if it is negative.\n \n-         if Lor > Lo\n-           and then not (Is_Modular_Integer_Type (Typ) and then Hir > Hbound)\n-         then\n-            Lo := Lor;\n-         end if;\n+         if Is_Modular_Integer_Type (Typ) then\n+            if Lor > Lo and then Hir <= Hbound then\n+               Lo := Lor;\n+            end if;\n \n-         --  Similarly, if the refined value of the high bound is less than the\n-         --  value so far, then reset it to the more restrictive value. Again,\n-         --  we do not do this if the refined low bound is negative for a\n-         --  modular type, since this would wrap.\n+            if Hir < Hi and then Lor >= Uint_0 then\n+               Hi := Hir;\n+            end if;\n \n-         if Hir < Hi\n-           and then not (Is_Modular_Integer_Type (Typ) and then Lor < Uint_0)\n-         then\n-            Hi := Hir;\n+         else\n+            if Lor > Hi or else Hir < Lo then\n+\n+               --  If the ranges are disjoint, return the computed range.\n+\n+               --  The current range-constraining logic would require returning\n+               --  the base type's bounds. However, this would miss an\n+               --  opportunity to warn about out-of-range values for some cases\n+               --  (e.g. when type's upper bound is equal to base type upper\n+               --  bound).\n+\n+               --  The alternative of always returning the computed values,\n+               --  even when ranges are intersecting, has unwanted effects\n+               --  (mainly useless constraint checks are inserted) in the\n+               --  Enable_Overflow_Check and Apply_Scalar_Range_Check as these\n+               --  bounds have a special interpretation.\n+\n+               Lo := Lor;\n+               Hi := Hir;\n+            else\n+\n+               --  If the ranges Lor .. Hir and Lo .. Hi intersect, try to\n+               --  refine the returned range.\n+\n+               if Lor > Lo then\n+                  Lo := Lor;\n+               end if;\n+\n+               if Hir < Hi then\n+                  Hi := Hir;\n+               end if;\n+            end if;\n          end if;\n       end if;\n "}]}