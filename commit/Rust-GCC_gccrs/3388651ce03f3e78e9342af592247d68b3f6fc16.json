{"sha": "3388651ce03f3e78e9342af592247d68b3f6fc16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM4ODY1MWNlMDNmM2U3OGU5MzQyYWY1OTIyNDdkNjhiM2Y2ZmMxNg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@redhat.com", "date": "2000-08-12T00:55:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-08-12T00:55:05Z"}, "message": "cplus-dem.c (demangle_signature): Change if (GNU_DEMANGLING) to if (AUTO_DEMANGLING || GNU_DEMANGLING)\n\n        * cplus-dem.c (demangle_signature): Change if (GNU_DEMANGLING) to\n        if (AUTO_DEMANGLING || GNU_DEMANGLING)\n\nFrom-SVN: r35652", "tree": {"sha": "1115df05fbdb43acaa9be84ab9314883d4f4e0a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1115df05fbdb43acaa9be84ab9314883d4f4e0a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3388651ce03f3e78e9342af592247d68b3f6fc16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3388651ce03f3e78e9342af592247d68b3f6fc16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3388651ce03f3e78e9342af592247d68b3f6fc16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3388651ce03f3e78e9342af592247d68b3f6fc16/comments", "author": null, "committer": null, "parents": [{"sha": "1fc8c51cd45748fc060df27304d262a3fe2a27d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc8c51cd45748fc060df27304d262a3fe2a27d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc8c51cd45748fc060df27304d262a3fe2a27d4"}], "stats": {"total": 279, "additions": 248, "deletions": 31}, "files": [{"sha": "a8a496dae8fa56f6cc9e99640cb013d309e50c64", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3388651ce03f3e78e9342af592247d68b3f6fc16/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3388651ce03f3e78e9342af592247d68b3f6fc16/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=3388651ce03f3e78e9342af592247d68b3f6fc16", "patch": "@@ -24,6 +24,11 @@\n \t* rename.c: Include config.h, unistd.h\n \t* waitpid.c: Include config.h, sys/wait.h\n \n+2000-07-24  Daniel Berlin <dberlin@redhat.com>\n+\n+\t* cplus-dem.c (demangle_signature): Change if (GNU_DEMANGLING) to \n+\tif (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\n 2000-07-21  Alex Samuel  <samuel@codesourcery.com>\n \n \t* cp-demangle.c (demangle_ctor_dtor_name): Remove not-in-charge"}, {"sha": "0611d76d0f99dc8a48f4684819eea2204bf8e1a5", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 243, "deletions": 31, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3388651ce03f3e78e9342af592247d68b3f6fc16/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3388651ce03f3e78e9342af592247d68b3f6fc16/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=3388651ce03f3e78e9342af592247d68b3f6fc16", "patch": "@@ -317,12 +317,21 @@ struct demangler_engine libiberty_demanglers[] =\n \n /* Prototypes for local functions */\n \n+static void\n+delete_work_stuff PARAMS ((struct work_stuff *));\n+\n+static void\n+delete_non_B_K_work_stuff PARAMS ((struct work_stuff *));\n+\n static char *\n mop_up PARAMS ((struct work_stuff *, string *, int));\n \n static void\n squangle_mop_up PARAMS ((struct work_stuff *));\n \n+static void\n+work_stuff_copy_to_from PARAMS ((struct work_stuff *, struct work_stuff *));\n+\n #if 0\n static int\n demangle_method_args PARAMS ((struct work_stuff *, const char **, string *));\n@@ -428,6 +437,10 @@ static void\n demangle_function_name PARAMS ((struct work_stuff *, const char **, string *,\n \t\t\t\tconst char *));\n \n+static int\n+iterate_demangle_function PARAMS ((struct work_stuff *,\n+\t\t\t\t   const char **, string *, const char *));\n+\n static void\n remember_type PARAMS ((struct work_stuff *, const char *, int));\n \n@@ -981,16 +994,85 @@ squangle_mop_up (work)\n     }\n }\n \n-/* Clear out any mangled storage */\n \n-static char *\n-mop_up (work, declp, success)\n-     struct work_stuff *work;\n-     string *declp;\n-     int success;\n+/* Copy the work state and storage.  */\n+\n+static void\n+work_stuff_copy_to_from (to, from)\n+     struct work_stuff *to;\n+     struct work_stuff *from;\n {\n-  char *demangled = NULL;\n+  int i;\n+\n+  delete_work_stuff (to);\n+\n+  /* Shallow-copy scalars.  */\n+  memcpy (to, from, sizeof (*to));\n+\n+  /* Deep-copy dynamic storage.  */\n+  if (from->typevec_size)\n+    to->typevec\n+      = (char **) xmalloc (from->typevec_size * sizeof (to->typevec[0]));\n+\n+  for (i = 0; i < from->ntypes; i++)\n+    {\n+      int len = strlen (from->typevec[i]) + 1;\n+\n+      to->typevec[i] = xmalloc (len);\n+      memcpy (to->typevec[i], from->typevec[i], len);\n+    }\n+\n+  if (from->ksize)\n+    to->ktypevec\n+      = (char **) xmalloc (from->ksize * sizeof (to->ktypevec[0]));\n+\n+  for (i = 0; i < from->numk; i++)\n+    {\n+      int len = strlen (from->ktypevec[i]) + 1;\n+\n+      to->ktypevec[i] = xmalloc (len);\n+      memcpy (to->ktypevec[i], from->ktypevec[i], len);\n+    }\n \n+  if (from->bsize)\n+    to->btypevec\n+      = (char **) xmalloc (from->bsize * sizeof (to->btypevec[0]));\n+\n+  for (i = 0; i < from->numb; i++)\n+    {\n+      int len = strlen (from->btypevec[i]) + 1;\n+\n+      to->btypevec[i] = xmalloc (len);\n+      memcpy (to->btypevec[i], from->btypevec[i], len);\n+    }\n+\n+  if (from->ntmpl_args)\n+    to->tmpl_argvec\n+      = xmalloc (from->ntmpl_args * sizeof (to->tmpl_argvec[0]));\n+\n+  for (i = 0; i < from->ntmpl_args; i++)\n+    {\n+      int len = strlen (from->tmpl_argvec[i]) + 1;\n+\n+      to->tmpl_argvec[i] = xmalloc (len);\n+      memcpy (to->tmpl_argvec[i], from->tmpl_argvec[i], len);\n+    }\n+\n+  if (from->previous_argument)\n+    {\n+      to->previous_argument = (string*) xmalloc (sizeof (string));\n+      string_init (to->previous_argument);\n+      string_appends (to->previous_argument, from->previous_argument);\n+    }\n+}\n+\n+\n+/* Delete dynamic stuff in work_stuff that is not to be re-used.  */\n+\n+static void\n+delete_non_B_K_work_stuff (work)\n+     struct work_stuff *work;\n+{\n   /* Discard the remembered types, if any.  */\n \n   forget_types (work);\n@@ -1017,6 +1099,30 @@ mop_up (work, declp, success)\n       free ((char*) work->previous_argument);\n       work->previous_argument = NULL;\n     }\n+}\n+\n+\n+/* Delete all dynamic storage in work_stuff.  */\n+static void\n+delete_work_stuff (work)\n+     struct work_stuff *work;\n+{\n+  delete_non_B_K_work_stuff (work);\n+  squangle_mop_up (work);\n+}\n+\n+\n+/* Clear out any mangled storage */\n+\n+static char *\n+mop_up (work, declp, success)\n+     struct work_stuff *work;\n+     string *declp;\n+     int success;\n+{\n+  char *demangled = NULL;\n+\n+  delete_non_B_K_work_stuff (work);\n \n   /* If demangling was successful, ensure that the demangled string is null\n      terminated and return it.  Otherwise, free the demangling decl.  */\n@@ -1242,7 +1348,7 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase '_':\n-\t  if (GNU_DEMANGLING && expect_return_type)\n+\t  if ((AUTO_DEMANGLING || GNU_DEMANGLING) && expect_return_type)\n \t    {\n \t      /* Read the return type. */\n \t      string return_type;\n@@ -1276,7 +1382,7 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase 'H':\n-\t  if (GNU_DEMANGLING)\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n \t    {\n \t      /* A G++ template function.  Read the template arguments. */\n \t      success = demangle_template (work, mangled, declp, 0, 0,\n@@ -1521,6 +1627,11 @@ demangle_integral_value (work, mangled, s)\n     {\n       int value;\n \n+      /* By default, we let the number decide whether we shall consume an\n+\t underscore.  */\n+      int consume_following_underscore = 0;\n+      int leave_following_underscore = 0;\n+\n       success = 0;\n \n       /* Negative numbers are indicated with a leading `m'.  */\n@@ -1529,17 +1640,49 @@ demangle_integral_value (work, mangled, s)\n \t  string_appendn (s, \"-\", 1);\n \t  (*mangled)++;\n \t}\n+      else if (mangled[0][0] == '_' && mangled[0][1] == 'm')\n+\t{\n+\t  /* Since consume_count_with_underscores does not handle the\n+\t     `m'-prefix we must do it here, using consume_count and\n+\t     adjusting underscores: we have to consume the underscore\n+\t     matching the prepended one.  */\n+\t  consume_following_underscore = 1;\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled) += 2;\n+\t}\n+      else if (**mangled == '_')\n+\t{\n+\t  /* Do not consume a following underscore;\n+\t     consume_following_underscore will consume what should be\n+\t     consumed.  */\n+\t  leave_following_underscore = 1;\n+\t}\n+\n+      /* We must call consume_count if we expect to remove a trailing\n+\t underscore, since consume_count_with_underscores expects\n+\t the leading underscore (that we consumed) if it is to handle\n+\t multi-digit numbers.  */\n+      if (consume_following_underscore)\n+\tvalue = consume_count (mangled);\n+      else\n+\tvalue = consume_count_with_underscores (mangled);\n \n-      /* Read the rest of the number.  */\n-      value = consume_count_with_underscores (mangled);\n       if (value != -1)\n \t{\n \t  char buf[INTBUF_SIZE];\n \t  sprintf (buf, \"%d\", value);\n \t  string_append (s, buf);\n \n-\t  /* If the next character is an underscore, skip it.  */\n-\t  if (**mangled == '_')\n+\t  /* Numbers not otherwise delimited, might have an underscore\n+\t     appended as a delimeter, which we should skip.\n+\n+\t     ??? This used to always remove a following underscore, which\n+\t     is wrong.  If other (arbitrary) cases are followed by an\n+\t     underscore, we need to do something more radical.  */\n+\n+\t  if ((value > 9 || consume_following_underscore)\n+\t      && ! leave_following_underscore\n+\t      && **mangled == '_')\n \t    (*mangled)++;\n \n \t  /* All is well.  */\n@@ -1704,7 +1847,7 @@ demangle_template_value_parm (work, mangled, s, tk)\n    template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is\n    non-NULL.  If IS_TYPE is nonzero, this template is a type template,\n    not a function template.  If both IS_TYPE and REMEMBER are nonzero,\n-   the tmeplate is remembered in the list of back-referenceable\n+   the template is remembered in the list of back-referenceable\n    types.  */\n \n static int\n@@ -2236,6 +2379,86 @@ demangle_class (work, mangled, declp)\n   return (success);\n }\n \n+\n+/* Called when there's a \"__\" in the mangled name, with `scan' pointing to\n+   the rightmost guess.\n+\n+   Find the correct \"__\"-sequence where the function name ends and the\n+   signature starts, which is ambiguous with GNU mangling.\n+   Call demangle_signature here, so we can make sure we found the right\n+   one; *mangled will be consumed so caller will not make further calls to\n+   demangle_signature.  */\n+\n+static int\n+iterate_demangle_function (work, mangled, declp, scan)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+     const char *scan;\n+{\n+  const char *mangle_init = *mangled;\n+  int success = 0;\n+  string decl_init;\n+  struct work_stuff work_init;\n+\n+  if (*(scan + 2) == '\\0')\n+    return 0;\n+\n+  /* Do not iterate for some demangling modes, or if there's only one\n+     \"__\"-sequence.  This is the normal case.  */\n+  if (ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING\n+      || mystrstr (scan + 2, \"__\") == NULL)\n+    {\n+      demangle_function_name (work, mangled, declp, scan);\n+      return 1;\n+    }\n+\n+  /* Save state so we can restart if the guess at the correct \"__\" was\n+     wrong.  */\n+  string_init (&decl_init);\n+  string_appends (&decl_init, declp);\n+  memset (&work_init, 0, sizeof work_init);\n+  work_stuff_copy_to_from (&work_init, work);\n+\n+  /* Iterate over occurrences of __, allowing names and types to have a\n+     \"__\" sequence in them.  We must start with the first (not the last)\n+     occurrence, since \"__\" most often occur between independent mangled\n+     parts, hence starting at the last occurence inside a signature\n+     might get us a \"successful\" demangling of the signature.  */\n+\n+  while (scan[2])\n+    {\n+      demangle_function_name (work, mangled, declp, scan);\n+      success = demangle_signature (work, mangled, declp);\n+      if (success)\n+\tbreak;\n+\n+      /* Reset demangle state for the next round.  */\n+      *mangled = mangle_init;\n+      string_clear (declp);\n+      string_appends (declp, &decl_init);\n+      work_stuff_copy_to_from (work, &work_init);\n+\n+      /* Leave this underscore-sequence.  */\n+      scan += 2;\n+\n+      /* Scan for the next \"__\" sequence.  */\n+      while (*scan && (scan[0] != '_' || scan[1] != '_'))\n+\tscan++;\n+\n+      /* Move to last \"__\" in this sequence.  */\n+      while (*scan && *scan == '_')\n+\tscan++;\n+      scan -= 2;\n+    }\n+\n+  /* Delete saved state.  */\n+  delete_work_stuff (&work_init);\n+  string_delete (&decl_init);\n+\n+  return success;\n+}\n+\n /*\n \n LOCAL FUNCTION\n@@ -2251,6 +2474,8 @@ SYNOPSIS\n DESCRIPTION\n \n \tConsume and demangle the prefix of the mangled name.\n+\tWhile processing the function name root, arrange to call\n+\tdemangle_signature if the root is ambiguous.\n \n \tDECLP points to the string buffer into which demangled output is\n \tplaced.  On entry, the buffer is empty.  On exit it contains\n@@ -2424,29 +2649,16 @@ demangle_prefix (work, mangled, declp)\n \t      success = 0;\n \t    }\n \t  else\n-\t    {\n-\t      const char *tmp;\n-\n-              /* Look for the LAST occurrence of __, allowing names to\n-                 have the '__' sequence embedded in them. */\n-\t      if (!(ARM_DEMANGLING || HP_DEMANGLING))\n-\t\t{\n-\t\t  while ((tmp = mystrstr (scan + 2, \"__\")) != NULL)\n-\t\t    scan = tmp;\n-\t\t}\n-\t      if (*(scan + 2) == '\\0')\n-\t\tsuccess = 0;\n-              else\n-                demangle_function_name (work, mangled, declp, scan);\n-\t    }\n+\t    return iterate_demangle_function (work, mangled, declp, scan);\n \t}\n     }\n   else if (*(scan + 2) != '\\0')\n     {\n       /* Mangled name does not start with \"__\" but does have one somewhere\n \t in there with non empty stuff after it.  Looks like a global\n-\t function name.  */\n-      demangle_function_name (work, mangled, declp, scan);\n+\t function name.  Iterate over all \"__\":s until the right\n+\t one is found.  */\n+      return iterate_demangle_function (work, mangled, declp, scan);\n     }\n   else\n     {"}]}