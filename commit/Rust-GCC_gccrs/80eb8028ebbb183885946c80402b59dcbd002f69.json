{"sha": "80eb8028ebbb183885946c80402b59dcbd002f69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBlYjgwMjhlYmJiMTgzODg1OTQ2YzgwNDAyYjU5ZGNiZDAwMmY2OQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-03-22T16:37:00Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-03-22T16:37:00Z"}, "message": "df.h (df_insn_delete): Adjust prototype.\n\n\n\t* df.h (df_insn_delete): Adjust prototype.\n\t* emit-rtl.c (remove_insn): Pass a basic block to df_insn_delete\n\tand let it decide whether mark the basic block dirty.\n\t(set_insn_deleted): Only pass INSN_P insns to df_insn_delete.\n\t* df-scan.c (df_insn_info_delete): New helper function, split\n\toff from df_insn_delete.\n\t(df_scan_free_bb_info): Use it.\n\t(df_insn_rescan, df_insn_rescan_all, df_process_deferred_rescans):\n\tLikewise.\n\t(df_insn_delete): Likewise.  Take insn rtx as argument.  Verify\n\tthat the insn is actually an insn and it has a non-NULL basic block.\n\tDo not mark basic block dirty if only deleting a DEBUG_INSN.\n\nFrom-SVN: r196977", "tree": {"sha": "763d9ae5800f6d6a19f7446337ea0119f8095e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/763d9ae5800f6d6a19f7446337ea0119f8095e00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80eb8028ebbb183885946c80402b59dcbd002f69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80eb8028ebbb183885946c80402b59dcbd002f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80eb8028ebbb183885946c80402b59dcbd002f69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80eb8028ebbb183885946c80402b59dcbd002f69/comments", "author": null, "committer": null, "parents": [{"sha": "f13a8728c143fe1aacc103c38463f19d829c9857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13a8728c143fe1aacc103c38463f19d829c9857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13a8728c143fe1aacc103c38463f19d829c9857"}], "stats": {"total": 133, "additions": 84, "deletions": 49}, "files": [{"sha": "fdfa93190ce0c77f1a858fab83725f81b4cddb59", "filename": "gcc/df-scan.c", "status": "modified", "additions": 75, "deletions": 42, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80eb8028ebbb183885946c80402b59dcbd002f69/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80eb8028ebbb183885946c80402b59dcbd002f69/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=80eb8028ebbb183885946c80402b59dcbd002f69", "patch": "@@ -142,6 +142,8 @@ static void df_install_ref (df_ref, struct df_reg_info *,\n static int df_ref_compare (const void *, const void *);\n static int df_mw_compare (const void *, const void *);\n \n+static void df_insn_info_delete (unsigned int);\n+\n /* Indexed by hardware reg number, is true if that register is ever\n    used in the current function.\n \n@@ -277,8 +279,7 @@ df_scan_free_bb_info (basic_block bb, void *vbb_info)\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (INSN_P (insn))\n-\t    /* Record defs within INSN.  */\n-\t    df_insn_delete (bb, INSN_UID (insn));\n+\t    df_insn_info_delete (INSN_UID (insn));\n \t}\n \n       if (bb_index < df_scan->block_info_size)\n@@ -1087,44 +1088,15 @@ df_mw_hardreg_chain_delete (struct df_mw_hardreg **hardregs)\n }\n \n \n-/* Delete all of the refs information from INSN.  BB must be passed in\n-   except when called from df_process_deferred_rescans to mark the block\n-   as dirty.  */\n+/* Delete all of the refs information from the insn with UID.\n+   Internal helper for df_insn_delete, df_insn_rescan, and other\n+   df-scan routines that don't have to work in deferred mode\n+   and do not have to mark basic blocks for re-processing.  */\n \n-void\n-df_insn_delete (basic_block bb, unsigned int uid)\n+static void\n+df_insn_info_delete (unsigned int uid)\n {\n-  struct df_insn_info *insn_info = NULL;\n-  if (!df)\n-    return;\n-\n-  df_grow_bb_info (df_scan);\n-  df_grow_reg_info ();\n-\n-  /* The block must be marked as dirty now, rather than later as in\n-     df_insn_rescan and df_notes_rescan because it may not be there at\n-     rescanning time and the mark would blow up.  */\n-  if (bb)\n-    df_set_bb_dirty (bb);\n-\n-  insn_info = DF_INSN_UID_SAFE_GET (uid);\n-\n-  /* The client has deferred rescanning.  */\n-  if (df->changeable_flags & DF_DEFER_INSN_RESCAN)\n-    {\n-      if (insn_info)\n-\t{\n-\t  bitmap_clear_bit (&df->insns_to_rescan, uid);\n-\t  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n-\t  bitmap_set_bit (&df->insns_to_delete, uid);\n-\t}\n-      if (dump_file)\n-\tfprintf (dump_file, \"deferring deletion of insn with uid = %d.\\n\", uid);\n-      return;\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"deleting insn with uid = %d.\\n\", uid);\n+  struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n \n   bitmap_clear_bit (&df->insns_to_delete, uid);\n   bitmap_clear_bit (&df->insns_to_rescan, uid);\n@@ -1160,6 +1132,67 @@ df_insn_delete (basic_block bb, unsigned int uid)\n     }\n }\n \n+/* Delete all of the refs information from INSN, either right now\n+   or marked for later in deferred mode.  */\n+\n+void\n+df_insn_delete (rtx insn)\n+{\n+  unsigned int uid;\n+  basic_block bb;\n+\n+  gcc_checking_assert (INSN_P (insn));\n+\n+  if (!df)\n+    return;\n+\n+  uid = INSN_UID (insn);\n+  bb = BLOCK_FOR_INSN (insn);\n+\n+  /* ??? bb can be NULL after pass_free_cfg.  At that point, DF should\n+     not exist anymore (as mentioned in df-core.c: \"The only requirement\n+     [for DF] is that there be a correct control flow graph.\"  Clearly\n+     that isn't the case after pass_free_cfg.  But DF is freed much later\n+     because some back-ends want to use DF info even though the CFG is\n+     already gone.  It's not clear to me whether that is safe, actually.\n+     In any case, we expect BB to be non-NULL at least up to register\n+     allocation, so disallow a non-NULL BB up to there.  Not perfect\n+     but better than nothing...  */\n+\n+  gcc_checking_assert (bb != NULL || reload_completed);\n+\n+  df_grow_bb_info (df_scan);\n+  df_grow_reg_info ();\n+\n+  /* The block must be marked as dirty now, rather than later as in\n+     df_insn_rescan and df_notes_rescan because it may not be there at\n+     rescanning time and the mark would blow up.\n+     DEBUG_INSNs do not make a block's data flow solution dirty (at\n+     worst the LUIDs are no longer contiguous).  */\n+  if (bb != NULL && NONDEBUG_INSN_P (insn))\n+    df_set_bb_dirty (bb);\n+\n+  /* The client has deferred rescanning.  */\n+  if (df->changeable_flags & DF_DEFER_INSN_RESCAN)\n+    {\n+      struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n+      if (insn_info)\n+\t{\n+\t  bitmap_clear_bit (&df->insns_to_rescan, uid);\n+\t  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n+\t  bitmap_set_bit (&df->insns_to_delete, uid);\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \"deferring deletion of insn with uid = %d.\\n\", uid);\n+      return;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"deleting insn with uid = %d.\\n\", uid);\n+\n+  df_insn_info_delete (uid);\n+}\n+\n \n /* Free all of the refs and the mw_hardregs in COLLECTION_REC.  */\n \n@@ -1262,7 +1295,7 @@ df_insn_rescan (rtx insn)\n       /* There's change - we need to delete the existing info.\n \t Since the insn isn't moved, we can salvage its LUID.  */\n       luid = DF_INSN_LUID (insn);\n-      df_insn_delete (NULL, uid);\n+      df_insn_info_delete (uid);\n       df_insn_create_insn_record (insn);\n       DF_INSN_LUID (insn) = luid;\n     }\n@@ -1345,7 +1378,7 @@ df_insn_rescan_debug_internal (rtx insn)\n \n \n /* Rescan all of the insns in the function.  Note that the artificial\n-   uses and defs are not touched.  This function will destroy def-se\n+   uses and defs are not touched.  This function will destroy def-use\n    or use-def chains.  */\n \n void\n@@ -1377,7 +1410,7 @@ df_insn_rescan_all (void)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n-\tdf_insn_delete (NULL, uid);\n+\tdf_insn_info_delete (uid);\n     }\n \n   bitmap_clear (&tmp);\n@@ -1434,7 +1467,7 @@ df_process_deferred_rescans (void)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n-\tdf_insn_delete (NULL, uid);\n+\tdf_insn_info_delete (uid);\n     }\n \n   bitmap_copy (&tmp, &df->insns_to_rescan);"}, {"sha": "716ce0c8d72eec7504b9e690237e94e2ae659b4f", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80eb8028ebbb183885946c80402b59dcbd002f69/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80eb8028ebbb183885946c80402b59dcbd002f69/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=80eb8028ebbb183885946c80402b59dcbd002f69", "patch": "@@ -996,7 +996,7 @@ extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block,\n extern void df_uses_create (rtx *, rtx, int);\n extern void df_ref_remove (df_ref);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);\n-extern void df_insn_delete (basic_block, unsigned int);\n+extern void df_insn_delete (rtx);\n extern void df_bb_refs_record (int, bool);\n extern bool df_insn_rescan (rtx);\n extern bool df_insn_rescan_debug_internal (rtx);"}, {"sha": "31c1e638d7c503cf965d188c587a1d1df4f7ac0f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80eb8028ebbb183885946c80402b59dcbd002f69/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80eb8028ebbb183885946c80402b59dcbd002f69/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=80eb8028ebbb183885946c80402b59dcbd002f69", "patch": "@@ -3964,7 +3964,8 @@ add_insn_before (rtx insn, rtx before, basic_block bb)\n void\n set_insn_deleted (rtx insn)\n {\n-  df_insn_delete (BLOCK_FOR_INSN (insn), INSN_UID (insn));\n+  if (INSN_P (insn) && !JUMP_TABLE_DATA_P (insn))\n+    df_insn_delete (insn);\n   PUT_CODE (insn, NOTE);\n   NOTE_KIND (insn) = NOTE_INSN_DELETED;\n }\n@@ -3979,9 +3980,6 @@ remove_insn (rtx insn)\n   rtx prev = PREV_INSN (insn);\n   basic_block bb;\n \n-  /* Later in the code, the block will be marked dirty.  */\n-  df_insn_delete (NULL, INSN_UID (insn));\n-\n   if (prev)\n     {\n       NEXT_INSN (prev) = next;\n@@ -4032,11 +4030,15 @@ remove_insn (rtx insn)\n \n       gcc_assert (stack);\n     }\n+\n+  /* Invalidate data flow information associated with INSN.  */\n+  if (INSN_P (insn) && !JUMP_TABLE_DATA_P (insn))\n+    df_insn_delete (insn);\n+\n+  /* Fix up basic block boundaries, if necessary.  */\n   if (!BARRIER_P (insn)\n       && (bb = BLOCK_FOR_INSN (insn)))\n     {\n-      if (NONDEBUG_INSN_P (insn))\n-\tdf_set_bb_dirty (bb);\n       if (BB_HEAD (bb) == insn)\n \t{\n \t  /* Never ever delete the basic block note without deleting whole"}]}