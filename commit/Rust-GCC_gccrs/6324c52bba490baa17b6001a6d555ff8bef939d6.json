{"sha": "6324c52bba490baa17b6001a6d555ff8bef939d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyNGM1MmJiYTQ5MGJhYTE3YjYwMDFhNmQ1NTVmZjhiZWY5MzlkNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-07-04T09:45:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-07-10T12:36:50Z"}, "message": "c++: Support non-type template parms of union type.\n\nAnother thing newly allowed by P1907R1.  The ABI group has discussed\nrepresenting unions with designated initializers, and has separately\nspecified how to represent designators; this patch implements both.\n\ngcc/cp/ChangeLog:\n\n\t* tree.c (structural_type_p): Allow unions.\n\t* mangle.c (write_expression): Express unions with a designator.\n\nlibiberty/ChangeLog:\n\n\t* cp-demangle.c (cplus_demangle_operators): Add di, dx, dX.\n\t(d_expression_1): Handle di and dX.\n\t(is_designated_init, d_maybe_print_designated_init): New.\n\t(d_print_comp_inner): Use d_maybe_print_designated_init.\n\t* testsuite/demangle-expected: Add designator tests.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/nontype-class-union1.C: New test.", "tree": {"sha": "9ecdc93a57d1647235f79b7ae07f94e49f455aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ecdc93a57d1647235f79b7ae07f94e49f455aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6324c52bba490baa17b6001a6d555ff8bef939d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6324c52bba490baa17b6001a6d555ff8bef939d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6324c52bba490baa17b6001a6d555ff8bef939d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6324c52bba490baa17b6001a6d555ff8bef939d6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f071d999374b6dd13149a31f505d4457c9de6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50f071d999374b6dd13149a31f505d4457c9de6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50f071d999374b6dd13149a31f505d4457c9de6d"}], "stats": {"total": 129, "additions": 119, "deletions": 10}, "files": [{"sha": "ab2d8ecf2f27727c5fd820dac041c677a0ea2e14", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6324c52bba490baa17b6001a6d555ff8bef939d6/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6324c52bba490baa17b6001a6d555ff8bef939d6/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=6324c52bba490baa17b6001a6d555ff8bef939d6", "patch": "@@ -3189,6 +3189,7 @@ write_expression (tree expr)\n \t    {\n \t      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);\n \t      unsigned last_nonzero = UINT_MAX, i;\n+\t      constructor_elt *ce;\n \t      tree val;\n \n \t      if (!nontriv)\n@@ -3197,12 +3198,18 @@ write_expression (tree expr)\n \t\t    last_nonzero = i;\n \n \t      if (nontriv || last_nonzero != UINT_MAX)\n-\t\tFOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n+\t\tfor (HOST_WIDE_INT i = 0; vec_safe_iterate (elts, i, &ce); ++i)\n \t\t  {\n \t\t    if (i > last_nonzero)\n \t\t      break;\n \t\t    /* FIXME handle RANGE_EXPR */\n-\t\t    write_expression (val);\n+\t\t    if (TREE_CODE (etype) == UNION_TYPE)\n+\t\t      {\n+\t\t\t/* Express the active member as a designator.  */\n+\t\t\twrite_string (\"di\");\n+\t\t\twrite_unqualified_name (ce->index);\n+\t\t      }\n+\t\t    write_expression (ce->value);\n \t\t  }\n \t    }\n \t  else"}, {"sha": "1fcba55313a7a1a08e3c0ad35b2ac4bf2b137b65", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6324c52bba490baa17b6001a6d555ff8bef939d6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6324c52bba490baa17b6001a6d555ff8bef939d6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6324c52bba490baa17b6001a6d555ff8bef939d6", "patch": "@@ -4534,13 +4534,6 @@ structural_type_p (tree t, bool explain)\n        structural types or (possibly multi-dimensional) array thereof.  */\n   if (!CLASS_TYPE_P (t))\n     return false;\n-  if (TREE_CODE (t) == UNION_TYPE)\n-    {\n-      /* FIXME allow (and mangle) unions.  */\n-      if (explain)\n-\tinform (location_of (t), \"%qT is a union\", t);\n-      return false;\n-    }\n   if (!literal_type_p (t))\n     {\n       if (explain)"}, {"sha": "038d46fdac877dbbbba8bf471c730a505222b389", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class-union1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6324c52bba490baa17b6001a6d555ff8bef939d6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-union1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6324c52bba490baa17b6001a6d555ff8bef939d6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-union1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-union1.C?ref=6324c52bba490baa17b6001a6d555ff8bef939d6", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++20 } }\n+\n+template <auto N> struct A {};\n+template <class,class> struct assert_same;\n+template <class T> struct assert_same<T,T> {};\n+\n+#define TEQ(X,Y) static_assert(__is_same(A<(X)>,A<(Y)>))\n+#define TNEQ(X,Y) static_assert(!__is_same(A<(X)>,A<(Y)>))\n+\n+union U {\n+  int i; int j;\n+  constexpr U(int i): i(i) {}\n+  constexpr U(unsigned u): j(u) {}\n+};\n+\n+TEQ(U(0),U(0));\n+\n+// Calling the other constructor initializes a different member with the same\n+// value.  We need to distinguish these.\n+TNEQ(U(0),U(0u));\n+\n+// { dg-final { scan-assembler \"_Z1f1AIXtl1Udi1iLi0EEEE\" } }\n+void f(A<U(0)>) { }\n+// { dg-final { scan-assembler \"_Z1g1AIXtl1Udi1jLi0EEEE\" } }\n+void g(A<U(0u)>) { }"}, {"sha": "b413ba2be5fe6e142e86978ba1391003bdc6bf1c", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6324c52bba490baa17b6001a6d555ff8bef939d6/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6324c52bba490baa17b6001a6d555ff8bef939d6/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=6324c52bba490baa17b6001a6d555ff8bef939d6", "patch": "@@ -1809,13 +1809,16 @@ const struct demangle_operator_info cplus_demangle_operators[] =\n   { \"cm\", NL (\",\"),         2 },\n   { \"co\", NL (\"~\"),         1 },\n   { \"dV\", NL (\"/=\"),        2 },\n+  { \"dX\", NL (\"[...]=\"),     3 }, /* [expr...expr] = expr */\n   { \"da\", NL (\"delete[] \"), 1 },\n   { \"dc\", NL (\"dynamic_cast\"), 2 },\n   { \"de\", NL (\"*\"),         1 },\n+  { \"di\", NL (\"=\"),         2 }, /* .name = expr */\n   { \"dl\", NL (\"delete \"),   1 },\n   { \"ds\", NL (\".*\"),        2 },\n   { \"dt\", NL (\".\"),         2 },\n   { \"dv\", NL (\"/\"),         2 },\n+  { \"dx\", NL (\"]=\"),        2 }, /* [expr] = expr */\n   { \"eO\", NL (\"^=\"),        2 },\n   { \"eo\", NL (\"^\"),         2 },\n   { \"eq\", NL (\"==\"),        2 },\n@@ -3291,6 +3294,12 @@ op_is_new_cast (struct demangle_component *op)\n                 ::= sr <type> <unqualified-name>\n                 ::= sr <type> <unqualified-name> <template-args>\n                 ::= <expr-primary>\n+\n+  <braced-expression> ::= <expression>\n+\t\t      ::= di <field source-name> <braced-expression>\t# .name = expr\n+\t\t      ::= dx <index expression> <braced-expression>\t# [expr] = expr\n+\t\t      ::= dX <range begin expression> <range end expression> <braced-expression>\n+\t\t\t\t\t\t\t\t\t# [expr ... expr] = expr\n */\n \n static inline struct demangle_component *\n@@ -3453,6 +3462,8 @@ d_expression_1 (struct d_info *di)\n \t    else if (code[0] == 'f')\n \t      /* fold-expression.  */\n \t      left = d_operator_name (di);\n+\t    else if (!strcmp (code, \"di\"))\n+\t      left = d_unqualified_name (di);\n \t    else\n \t      left = d_expression_1 (di);\n \t    if (!strcmp (code, \"cl\"))\n@@ -3480,7 +3491,8 @@ d_expression_1 (struct d_info *di)\n \n \t    if (code == NULL)\n \t      return NULL;\n-\t    else if (!strcmp (code, \"qu\"))\n+\t    else if (!strcmp (code, \"qu\")\n+\t\t     || !strcmp (code, \"dX\"))\n \t      {\n \t\t/* ?: expression.  */\n \t\tfirst = d_expression_1 (di);\n@@ -4675,6 +4687,64 @@ d_maybe_print_fold_expression (struct d_print_info *dpi, int options,\n   return 1;\n }\n \n+/* True iff DC represents a C99-style designated initializer.  */\n+\n+static int\n+is_designated_init (struct demangle_component *dc)\n+{\n+  if (dc->type != DEMANGLE_COMPONENT_BINARY\n+      && dc->type != DEMANGLE_COMPONENT_TRINARY)\n+    return 0;\n+\n+  struct demangle_component *op = d_left (dc);\n+  const char *code = op->u.s_operator.op->code;\n+  return (code[0] == 'd'\n+\t  && (code[1] == 'i' || code[1] == 'x' || code[1] == 'X'));\n+}\n+\n+/* If DC represents a C99-style designated initializer, print it and return\n+   true; otherwise, return false.  */\n+\n+static int\n+d_maybe_print_designated_init (struct d_print_info *dpi, int options,\n+\t\t\t       struct demangle_component *dc)\n+{\n+  if (!is_designated_init (dc))\n+    return 0;\n+\n+  const char *code = d_left (dc)->u.s_operator.op->code;\n+\n+  struct demangle_component *operands = d_right (dc);\n+  struct demangle_component *op1 = d_left (operands);\n+  struct demangle_component *op2 = d_right (operands);\n+\n+  if (code[1] == 'i')\n+    d_append_char (dpi, '.');\n+  else\n+    d_append_char (dpi, '[');\n+\n+  d_print_comp (dpi, options, op1);\n+  if (code[1] == 'X')\n+    {\n+      d_append_string (dpi, \" ... \");\n+      d_print_comp (dpi, options, d_left (op2));\n+      op2 = d_right (op2);\n+    }\n+  if (code[1] != 'i')\n+    d_append_char (dpi, ']');\n+  if (is_designated_init (op2))\n+    {\n+      /* Don't put '=' or '(' between chained designators.  */\n+      d_print_comp (dpi, options, op2);\n+    }\n+  else\n+    {\n+      d_append_char (dpi, '=');\n+      d_print_subexpr (dpi, options, op2);\n+    }\n+  return 1;\n+}\n+\n /* Subroutine to handle components.  */\n \n static void\n@@ -5491,6 +5561,9 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       if (d_maybe_print_fold_expression (dpi, options, dc))\n \treturn;\n \n+      if (d_maybe_print_designated_init (dpi, options, dc))\n+\treturn;\n+\n       /* We wrap an expression which uses the greater-than operator in\n \t an extra layer of parens so that it does not get confused\n \t with the '>' which ends the template parameters.  */\n@@ -5548,6 +5621,8 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t}\n       if (d_maybe_print_fold_expression (dpi, options, dc))\n \treturn;\n+      if (d_maybe_print_designated_init (dpi, options, dc))\n+\treturn;\n       {\n \tstruct demangle_component *op = d_left (dc);\n \tstruct demangle_component *first = d_left (d_right (dc));"}, {"sha": "2da27849835b3aead85c7d6739ac88f0735d4eb2", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6324c52bba490baa17b6001a6d555ff8bef939d6/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6324c52bba490baa17b6001a6d555ff8bef939d6/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=6324c52bba490baa17b6001a6d555ff8bef939d6", "patch": "@@ -1456,3 +1456,12 @@ coro1::empty::operator co_await() const\n \n _ZNK3FoossERKS_\n Foo::operator<=>(Foo const&) const\n+\n+_Z1f1AIXtl1Udi1iLi0EEEE\n+f(A<U{.i=(0)}>)\n+\n+_Z1f1AIXtl1Xdi1adi1bdxLi3ELi1EEEE\n+f(A<X{.a.b[3]=(1)}>)\n+\n+_Z1f1AIXtl1Xdi1adi1bdXLi3ELi4ELi1EEEE\n+f(A<X{.a.b[3 ... 4]=(1)}>)"}]}