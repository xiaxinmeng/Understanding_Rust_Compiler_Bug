{"sha": "5cd0e800195ce0f5cb88cde3f2e98b102174847a", "node_id": "C_kwDOANBUbNoAKDVjZDBlODAwMTk1Y2UwZjVjYjg4Y2RlM2YyZTk4YjEwMjE3NDg0N2E", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-05-13T19:46:59Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-06-24T20:22:14Z"}, "message": "testsuite: Handle default_packed for gcc.dg/builtin-object-size-20.c\n\nThe gcc.dg/builtin-object-size-20.c test case assumes that the target\ninserts padding between structure members.  Obviously it fails for\ntargets which pack structures by default.\n\nSplit the cases into two tests, so that the ones requiring structure\npadding can be skipped for default_packed targets.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/builtin-object-size-20.c: Remove cases which\n\twork on default_packed targets.\n\t* gcc.dg/builtin-object-size-22.c: New test with the cases\n\tremoved above.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "d09da3732e5b40168d461f849e348a7f377ffd00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d09da3732e5b40168d461f849e348a7f377ffd00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cd0e800195ce0f5cb88cde3f2e98b102174847a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd0e800195ce0f5cb88cde3f2e98b102174847a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cd0e800195ce0f5cb88cde3f2e98b102174847a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd0e800195ce0f5cb88cde3f2e98b102174847a/comments", "author": null, "committer": null, "parents": [{"sha": "2e2371b5daad74b581842bbc846f8f10c78d4520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2371b5daad74b581842bbc846f8f10c78d4520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2371b5daad74b581842bbc846f8f10c78d4520"}], "stats": {"total": 143, "additions": 81, "deletions": 62}, "files": [{"sha": "f40e3dcc1a90cdaf1b73e9aca8bed25ae9a04ab4", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-20.c", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd0e800195ce0f5cb88cde3f2e98b102174847a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd0e800195ce0f5cb88cde3f2e98b102174847a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-20.c?ref=5cd0e800195ce0f5cb88cde3f2e98b102174847a", "patch": "@@ -1,7 +1,8 @@\n /* PR middle-end/92815 - spurious -Wstringop-overflow writing into\n    a flexible array of an extern struct\n    { dg-do compile }\n-   { dg-options \"-O -Wall -fdump-tree-optimized\" } */\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" }\n+   { dg-skip-if \"test assumes that structs have padding\" { default_packed } } */\n \n #define ASSERT(expr) ((expr) ? (void)0 : fail (__LINE__))\n #define bos0(expr) __builtin_object_size (expr, 1)\n@@ -18,44 +19,6 @@ typedef __SIZE_TYPE__  size_t;\n extern void fail (int);\n \n \n-/* Verify sizes of a struct with a flexible array member and no padding.  */\n-\n-struct ACX { char n, a[]; };\n-\n-struct ACX ac0 = { };\n-struct ACX ac1 = { 1, { 1 } };\n-struct ACX ac2 = { 2, { 1, 2 } };\n-struct ACX ac3 = { 3, { 1, 2, 3 } };\n-\n-extern struct ACX eacx;\n-\n-void facx (void)\n-{\n-  ASSERT (bos0 (&ac0) == sizeof ac0);\n-  ASSERT (bos0 (&ac1) == 2);\n-  ASSERT (bos0 (&ac2) == 3);\n-  ASSERT (bos0 (&ac3) == 4);\n-  ASSERT (bos0 (&eacx) == (size_t)-1);\n-\n-  ASSERT (bos1 (&ac0) == sizeof ac0);\n-  ASSERT (bos1 (&ac1) == 2);\n-  ASSERT (bos1 (&ac2) == 3);\n-  ASSERT (bos1 (&ac3) == 4);\n-  ASSERT (bos1 (&eacx) == (size_t)-1);\n-\n-  ASSERT (bos2 (&ac0) == sizeof ac0);\n-  ASSERT (bos2 (&ac1) == 2);\n-  ASSERT (bos2 (&ac2) == 3);\n-  ASSERT (bos2 (&ac3) == 4);\n-  ASSERT (bos2 (&eacx) == sizeof eacx);\n-\n-  ASSERT (bos3 (&ac0) == sizeof ac0);\n-  ASSERT (bos3 (&ac1) == 2);\n-  ASSERT (bos3 (&ac2) == 3);\n-  ASSERT (bos3 (&ac3) == 4);\n-  ASSERT (bos3 (&eacx) == sizeof eacx);\n-}\n-\n \n \n /* Verify sizes of a struct with a flexible array member and 1 byte\n@@ -289,27 +252,4 @@ void fai64cx (void)\n   ASSERT (bos3 (&eai64cx) == sizeof eai64cx);\n }\n \n-\n-/* Also verify sizes of a struct with a zero length array member.  */\n-\n-struct A0C0 { char n, a[0]; };\n-\n-struct A0C0 a0c0 = { };\n-extern struct A0C0 ea0c0;\n-\n-void fa0c0 (void)\n-{\n-  ASSERT (bos0 (&a0c0) == sizeof a0c0);\n-  ASSERT (bos0 (&ea0c0) == sizeof ea0c0);\n-\n-  ASSERT (bos1 (&a0c0) == sizeof a0c0);\n-  ASSERT (bos1 (&a0c0) == sizeof ea0c0);\n-\n-  ASSERT (bos2 (&a0c0) == sizeof a0c0);\n-  ASSERT (bos2 (&a0c0) == sizeof ea0c0);\n-\n-  ASSERT (bos3 (&a0c0) == sizeof a0c0);\n-  ASSERT (bos3 (&a0c0) == sizeof ea0c0);\n-}\n-\n /* { dg-final { scan-tree-dump-not \"fail\" \"optimized\" } } */"}, {"sha": "1e55229c94951b7ba849bd75c91af0dc2467e295", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-22.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd0e800195ce0f5cb88cde3f2e98b102174847a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd0e800195ce0f5cb88cde3f2e98b102174847a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-22.c?ref=5cd0e800195ce0f5cb88cde3f2e98b102174847a", "patch": "@@ -0,0 +1,79 @@\n+/* PR middle-end/92815 - a variant of gcc.dg/builtin-object-size-20.c\n+   prepared for all targets, irregardless if they pack or not\n+   the structs by default.\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" } */\n+\n+#define ASSERT(expr) ((expr) ? (void)0 : fail (__LINE__))\n+#define bos0(expr) __builtin_object_size (expr, 1)\n+#define bos1(expr) __builtin_object_size (expr, 1)\n+#define bos2(expr) __builtin_object_size (expr, 2)\n+#define bos3(expr) __builtin_object_size (expr, 3)\n+\n+typedef __SIZE_TYPE__  size_t;\n+\n+\n+extern void fail (int);\n+\n+\n+/* Verify sizes of a struct with a flexible array member and no padding.  */\n+\n+struct ACX { char n, a[]; };\n+\n+struct ACX ac0 = { };\n+struct ACX ac1 = { 1, { 1 } };\n+struct ACX ac2 = { 2, { 1, 2 } };\n+struct ACX ac3 = { 3, { 1, 2, 3 } };\n+\n+extern struct ACX eacx;\n+\n+void facx (void)\n+{\n+  ASSERT (bos0 (&ac0) == sizeof ac0);\n+  ASSERT (bos0 (&ac1) == 2);\n+  ASSERT (bos0 (&ac2) == 3);\n+  ASSERT (bos0 (&ac3) == 4);\n+  ASSERT (bos0 (&eacx) == (size_t)-1);\n+\n+  ASSERT (bos1 (&ac0) == sizeof ac0);\n+  ASSERT (bos1 (&ac1) == 2);\n+  ASSERT (bos1 (&ac2) == 3);\n+  ASSERT (bos1 (&ac3) == 4);\n+  ASSERT (bos1 (&eacx) == (size_t)-1);\n+\n+  ASSERT (bos2 (&ac0) == sizeof ac0);\n+  ASSERT (bos2 (&ac1) == 2);\n+  ASSERT (bos2 (&ac2) == 3);\n+  ASSERT (bos2 (&ac3) == 4);\n+  ASSERT (bos2 (&eacx) == sizeof eacx);\n+\n+  ASSERT (bos3 (&ac0) == sizeof ac0);\n+  ASSERT (bos3 (&ac1) == 2);\n+  ASSERT (bos3 (&ac2) == 3);\n+  ASSERT (bos3 (&ac3) == 4);\n+  ASSERT (bos3 (&eacx) == sizeof eacx);\n+}\n+\n+/* Also verify sizes of a struct with a zero length array member.  */\n+\n+struct A0C0 { char n, a[0]; };\n+\n+struct A0C0 a0c0 = { };\n+extern struct A0C0 ea0c0;\n+\n+void fa0c0 (void)\n+{\n+  ASSERT (bos0 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos0 (&ea0c0) == sizeof ea0c0);\n+\n+  ASSERT (bos1 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos1 (&a0c0) == sizeof ea0c0);\n+\n+  ASSERT (bos2 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos2 (&a0c0) == sizeof ea0c0);\n+\n+  ASSERT (bos3 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos3 (&a0c0) == sizeof ea0c0);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"fail\" \"optimized\" } } */"}]}