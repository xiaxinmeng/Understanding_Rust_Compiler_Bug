{"sha": "bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ0YjZiMGQ3OGUyYWIzZmZiZDRlNTNmNTM0ZWIxZjg1YzFiMjAzYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-01-12T22:38:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-01-12T22:38:06Z"}, "message": "* tree-ssa-threadupdate.c: Various whitespace and typo fixes.\n\nFrom-SVN: r232297", "tree": {"sha": "b3937fba90af1b5c6204bad369472f714f13305d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3937fba90af1b5c6204bad369472f714f13305d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c/comments", "author": null, "committer": null, "parents": [{"sha": "26b5ace7ea8aff21431d0070377f24031b60aa24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b5ace7ea8aff21431d0070377f24031b60aa24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b5ace7ea8aff21431d0070377f24031b60aa24"}], "stats": {"total": 82, "additions": 43, "deletions": 39}, "files": [{"sha": "3c2cf3f9e8cd6bdaac26aa87a160d8e849e37768", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c", "patch": "@@ -1,3 +1,7 @@\n+2016-01-12  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c: Various whitespace and typo fixes.\n+\n 2016-01-12  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc.c (spec_undefvar_allowed): New global."}, {"sha": "1bf9ae667721ba8197610f25dc516b8c0bdf0a7f", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=bd4b6b0d78e2ab3ffbd4e53f534eb1f85c1b203c", "patch": "@@ -353,7 +353,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n   struct redirection_data *elt;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n \n- /* Build a hash table element so we can see if E is already\n+  /* Build a hash table element so we can see if E is already\n      in the table.  */\n   elt = XNEW (struct redirection_data);\n   elt->path = path;\n@@ -635,21 +635,21 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n    are not part of any jump threading path, but add profile counts along\n    the path.\n \n-   In the aboe example, after all jump threading is complete, we will\n+   In the above example, after all jump threading is complete, we will\n    end up with the following control flow:\n \n-\t\tA\t  B\t    C\n-\t\t|\t  |\t    |\n-\t      Ea|\t  |Eb\t  |Ec\n-\t\t|\t  |\t    |\n-\t\tv\t  v\t    v\n-\t       Ja\t  J\t   Jc\n-\t       / \\\t/ \\Eon'     / \\\n+\t\tA\t   B\t       C\n+\t\t|\t   |\t       |\n+\t      Ea|\t   |Eb\t       |Ec\n+\t\t|\t   |\t       |\n+\t\tv\t   v\t       v\n+\t       Ja\t   J\t      Jc\n+\t       / \\\t  / \\Eon'     / \\\n \t  Eona/   \\   ---/---\\--------   \\Eonc\n-\t     /     \\ /  /     \\\t   \\\n+\t     /     \\ /  /     \\\t\t  \\\n \t    v       v  v       v\t  v\n \t   Sona     Soff      Son\tSonc\n-\t     \\\t\t /\\\t /\n+\t     \\\t\t       /\\\t  /\n \t      \\___________    /  \\  _____/\n \t\t\t  \\  /    \\/\n \t\t\t   vv      v\n@@ -793,19 +793,19 @@ compute_path_counts (struct redirection_data *rd,\n \t coming into the path that will contribute to the count flowing\n \t into the path successor.  */\n       if (has_joiner && epath != elast)\n-      {\n-\t/* Look for other incoming edges after joiner.  */\n-\tFOR_EACH_EDGE (ein, ei, epath->dest->preds)\n-\t  {\n-\t    if (ein != epath\n-\t\t/* Ignore in edges from blocks we have duplicated for a\n-\t\t   threading path, which have duplicated edge counts until\n-\t\t   they are redirected by an invocation of this routine.  */\n-\t\t&& !bitmap_bit_p (local_info->duplicate_blocks,\n-\t\t\t\t  ein->src->index))\n-\t      nonpath_count += ein->count;\n-\t  }\n-      }\n+\t{\n+\t  /* Look for other incoming edges after joiner.  */\n+\t  FOR_EACH_EDGE (ein, ei, epath->dest->preds)\n+\t    {\n+\t      if (ein != epath\n+\t\t  /* Ignore in edges from blocks we have duplicated for a\n+\t\t     threading path, which have duplicated edge counts until\n+\t\t     they are redirected by an invocation of this routine.  */\n+\t\t  && !bitmap_bit_p (local_info->duplicate_blocks,\n+\t\t\t\t    ein->src->index))\n+\t\tnonpath_count += ein->count;\n+\t    }\n+\t}\n       if (cur_count < path_out_count)\n \tpath_out_count = cur_count;\n       if (epath->count < min_path_count)\n@@ -827,14 +827,14 @@ compute_path_counts (struct redirection_data *rd,\n      difference between elast->count and nonpath_count.  Otherwise the edge\n      counts after threading will not be sane.  */\n   if (has_joiner && path_out_count < elast->count - nonpath_count)\n-  {\n-    path_out_count = elast->count - nonpath_count;\n-    /* But neither can we go above the minimum count along the path\n-       we are duplicating.  This can be an issue due to profile\n-       insanities coming in to this pass.  */\n-    if (path_out_count > min_path_count)\n-      path_out_count = min_path_count;\n-  }\n+    {\n+      path_out_count = elast->count - nonpath_count;\n+      /* But neither can we go above the minimum count along the path\n+\t we are duplicating.  This can be an issue due to profile\n+\t insanities coming in to this pass.  */\n+      if (path_out_count > min_path_count)\n+\tpath_out_count = min_path_count;\n+    }\n \n   *path_in_count_ptr = path_in_count;\n   *path_out_count_ptr = path_out_count;\n@@ -1268,17 +1268,17 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t     thread path (path_in_freq).  If we had a joiner, it would have\n \t     been updated at the end of that handling to the edge frequency\n \t     along the duplicated joiner path edge.  */\n-\t     update_profile (epath, NULL, path_out_count, path_out_count,\n-\t\t\t     cur_path_freq);\n+\t   update_profile (epath, NULL, path_out_count, path_out_count,\n+\t\t\t   cur_path_freq);\n \t}\n \n       /* Increment the index into the duplicated path when we processed\n \t a duplicated block.  */\n       if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK\n \t  || (*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n-      {\n+\t{\n \t  count++;\n-      }\n+\t}\n     }\n \n   /* Now walk orig blocks and update their probabilities, since the\n@@ -2383,7 +2383,7 @@ valid_jump_thread_path (vec<jump_thread_edge *> *path)\n       struct loop *loop = e->dest->loop_father;\n \n       if (e->dest != (*path)[j+1]->e->src)\n-        return false;\n+\treturn false;\n \n       /* If we're threading through the loop latch back into the\n \t same loop and the destination does not dominate the loop\n@@ -2705,7 +2705,7 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n   for (unsigned int i = 0; i < path->length (); i++)\n     {\n       if ((*path)[i]->e == NULL)\n-        {\n+\t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file,\n@@ -2715,7 +2715,7 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n \n \t  delete_jump_thread_path (path);\n \t  return;\n-        }\n+\t}\n \n       /* Only the FSM threader is allowed to thread across\n \t backedges in the CFG.  */"}]}