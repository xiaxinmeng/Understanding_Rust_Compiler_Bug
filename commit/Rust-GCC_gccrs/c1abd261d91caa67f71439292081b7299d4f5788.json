{"sha": "c1abd261d91caa67f71439292081b7299d4f5788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFhYmQyNjFkOTFjYWE2N2Y3MTQzOTI5MjA4MWI3Mjk5ZDRmNTc4OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-23T11:06:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-23T11:06:47Z"}, "message": "gigi.h (create_index_type): Adjust head comment.\n\n\t* gcc-interface/gigi.h (create_index_type): Adjust head comment.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tUse front-end predicates to compute signedness and precision.\n\t<E_String_Literal_Subtype>: Fold range type.\n\tMake sure to set longest_float_type_node to a scalar type.\n\t(elaborate_entity): Use consistent Constraint_Error spelling.\n\t(substitute_in_type) <INTEGER_TYPE>: Always copy the type.\n\t* gcc-interface/misc.c (gnat_print_type) <INTEGER_TYPE>: Use brief\n\toutput for the modulus, if any.\n\t<ENUMERAL_TYPE>: Likewise for the RM size.\n\t* gcc-interface/trans.c (gnat_to_gnu): Use consistent Constraint_Error\n\tspelling.\n\t* gcc-interface/utils.c (finish_record_type): Really test the alignment\n\tof BLKmode bit-fields to compute their addressability.\n\t(create_index_type): Adjust comments.\n\t(create_param_decl): Create the biased subtype manually.\n\t* gcc-interface/utils2.c (build_component_ref): Use consistent\n\tConstraint_Error spelling.\n\nFrom-SVN: r146644", "tree": {"sha": "c0d0a561438c71036620f0c5eb0f8ebf5a404485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d0a561438c71036620f0c5eb0f8ebf5a404485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1abd261d91caa67f71439292081b7299d4f5788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1abd261d91caa67f71439292081b7299d4f5788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1abd261d91caa67f71439292081b7299d4f5788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1abd261d91caa67f71439292081b7299d4f5788/comments", "author": null, "committer": null, "parents": [{"sha": "8713b7e4f5f8cb2bf3c046dda4000c448500b746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8713b7e4f5f8cb2bf3c046dda4000c448500b746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8713b7e4f5f8cb2bf3c046dda4000c448500b746"}], "stats": {"total": 144, "additions": 83, "deletions": 61}, "files": [{"sha": "c93bce0e38520b394e8fdac0c914bb2cbfb57b44", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -1,3 +1,24 @@\n+2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (create_index_type): Adjust head comment.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tUse front-end predicates to compute signedness and precision.\n+\t<E_String_Literal_Subtype>: Fold range type.\n+\tMake sure to set longest_float_type_node to a scalar type.\n+\t(elaborate_entity): Use consistent Constraint_Error spelling.\n+\t(substitute_in_type) <INTEGER_TYPE>: Always copy the type.\n+\t* gcc-interface/misc.c (gnat_print_type) <INTEGER_TYPE>: Use brief\n+\toutput for the modulus, if any.\n+\t<ENUMERAL_TYPE>: Likewise for the RM size.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Use consistent Constraint_Error\n+\tspelling.\n+\t* gcc-interface/utils.c (finish_record_type): Really test the alignment\n+\tof BLKmode bit-fields to compute their addressability.\n+\t(create_index_type): Adjust comments.\n+\t(create_param_decl): Create the biased subtype manually.\n+\t* gcc-interface/utils2.c (build_component_ref): Use consistent\n+\tConstraint_Error spelling.\n+\n 2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/cuintp.c: Clean up include directives."}, {"sha": "78df1f8ca5b61271c6c21b34bbbc0c51f3af2014", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -1521,7 +1521,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* For integral subtypes, we make a new INTEGER_TYPE.  Note that we do\n \t not want to call build_range_type since we would like each subtype\n \t node to be distinct.  ??? Historically this was in preparation for\n-\t when memory aliasing is implemented.  But that's obsolete now given\n+\t when memory aliasing is implemented, but that's obsolete now given\n \t the call to relate_alias_sets below.\n \n \t The TREE_TYPE field of the INTEGER_TYPE points to the base type;\n@@ -1542,12 +1542,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       gnu_type = make_node (INTEGER_TYPE);\n       TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n \n+      /* This should be an unsigned type if the base type is unsigned or\n+\t if the lower bound is constant and non-negative or if the type\n+\t is biased.  */\n+      TYPE_UNSIGNED (gnu_type) = (Is_Unsigned_Type (Etype (gnat_entity))\n+\t\t\t\t  || Is_Unsigned_Type (gnat_entity)\n+\t\t\t\t  || Has_Biased_Representation (gnat_entity));\n+\n       /* Set the precision to the Esize except for bit-packed arrays and\n \t subtypes of Standard.Boolean.  */\n       if (Is_Packed_Array_Type (gnat_entity)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \tesize = UI_To_Int (RM_Size (gnat_entity));\n-      else if (TREE_CODE (TREE_TYPE (gnu_type)) == BOOLEAN_TYPE)\n+      else if (Is_Boolean_Type (gnat_entity))\n \tesize = 1;\n \n       TYPE_PRECISION (gnu_type) = esize;\n@@ -1577,13 +1584,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n \t= Has_Biased_Representation (gnat_entity);\n \n-      /* This should be an unsigned type if the base type is unsigned or\n-\t if the lower bound is constant and non-negative (as computed by\n-\t layout_type) or if the type is biased.  */\n-      TYPE_UNSIGNED (gnu_type) = (TYPE_UNSIGNED (TREE_TYPE (gnu_type))\n-\t\t\t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_type)\n-\t\t\t\t  || Is_Unsigned_Type (gnat_entity));\n-\n       layout_type (gnu_type);\n \n       /* Inherit our alias set from what we're a subtype of.  Subtypes\n@@ -2592,15 +2592,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = build_binary_op (PLUS_EXPR, gnu_string_index_type,\n \t\t\t     gnu_lower_bound,\n \t\t\t     convert (gnu_string_index_type, gnu_length));\n-\ttree gnu_range_type\n-\t  = build_range_type (gnu_string_index_type,\n-\t\t\t      gnu_lower_bound, gnu_upper_bound);\n \ttree gnu_index_type\n-\t  = create_index_type (convert (sizetype,\n-\t\t\t\t\tTYPE_MIN_VALUE (gnu_range_type)),\n-\t\t\t       convert (sizetype,\n-\t\t\t\t\tTYPE_MAX_VALUE (gnu_range_type)),\n-\t\t\t       gnu_range_type, gnat_entity);\n+\t  = create_index_type (convert (sizetype, gnu_lower_bound),\n+\t\t\t       convert (sizetype, gnu_upper_bound),\n+\t\t\t       build_range_type (gnu_string_index_type,\n+\t\t\t\t\t\t gnu_lower_bound,\n+\t\t\t\t\t\t gnu_upper_bound),\n+\t\t\t       gnat_entity);\n \n \tgnu_type\n \t  = build_array_type (gnat_to_gnu_type (Component_Type (gnat_entity)),\n@@ -4653,10 +4651,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   if (!saved)\n     save_gnu_tree (gnat_entity, gnu_decl, false);\n \n-  /* If this is an enumeral or floating-point type, we were not able to set\n-     the bounds since they refer to the type.  These bounds are always static.\n-     For enumeration types, also write debugging information and declare the\n-     enumeration literal table, if needed.  */\n+  /* If this is an enumeration or floating-point type, we were not able to set\n+     the bounds since they refer to the type.  These are always static.  */\n   if ((kind == E_Enumeration_Type && Present (First_Literal (gnat_entity)))\n       || (kind == E_Floating_Point_Type && !Vax_Float (gnat_entity)))\n     {\n@@ -4670,14 +4666,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* If this is a floating point type and we haven't set a floating\n \t point type yet, use this in the evaluation of the bounds.  */\n       if (!longest_float_type_node && kind == E_Floating_Point_Type)\n-\tlongest_float_type_node = gnu_type;\n+\tlongest_float_type_node = gnu_scalar_type;\n \n       TYPE_MIN_VALUE (gnu_scalar_type)\n \t= gnat_to_gnu (Type_Low_Bound (gnat_entity));\n       TYPE_MAX_VALUE (gnu_scalar_type)\n \t= gnat_to_gnu (Type_High_Bound (gnat_entity));\n \n-      if (TREE_CODE (gnu_scalar_type) == ENUMERAL_TYPE)\n+      /* For enumeration types, write full debugging information.  */\n+      if (kind == E_Enumeration_Type)\n \t{\n \t  /* Since this has both a typedef and a tag, avoid outputting\n \t     the name twice.  */\n@@ -5171,10 +5168,9 @@ elaborate_entity (Entity_Id gnat_entity)\n \tNode_Id gnat_lb = Type_Low_Bound (gnat_entity);\n \tNode_Id gnat_hb = Type_High_Bound (gnat_entity);\n \n-\t/* ??? Tests for avoiding static constraint error expression\n-\t   is needed until the front stops generating bogus conversions\n-\t   on bounds of real types.  */\n-\n+\t/* ??? Tests to avoid Constraint_Error in static expressions\n+\t   are needed until after the front stops generating bogus\n+\t   conversions on bounds of real types.  */\n \tif (!Raises_Constraint_Error (gnat_lb))\n \t  elaborate_expression (gnat_lb, gnat_entity, get_identifier (\"L\"),\n \t\t\t\t1, 0, Needs_Debug_Info (gnat_entity));\n@@ -7597,7 +7593,9 @@ substitute_in_type (tree t, tree f, tree r)\n \t  if (low == TYPE_MIN_VALUE (t) && high == TYPE_MAX_VALUE (t))\n \t    return t;\n \n-\t  new = build_range_type (TREE_TYPE (t), low, high);\n+\t  new = copy_type (t);\n+\t  TYPE_MIN_VALUE (new) = low;\n+\t  TYPE_MAX_VALUE (new) = high;\n \t  if (TYPE_INDEX_TYPE (t))\n \t    SET_TYPE_INDEX_TYPE\n \t      (new, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));"}, {"sha": "1dca8c94de772c4b672523ebe937612aff99c7e4", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -141,7 +141,7 @@ extern tree choices_to_gnu (tree operand, Node_Id choices);\n    nothing has changed.  */\n extern tree substitute_in_type (tree t, tree f, tree r);\n \n-/* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n+/* Return the RM size of GNU_TYPE.  This is the actual number of bits\n    needed to represent the object.  */\n extern tree rm_size (tree gnu_type);\n \n@@ -542,9 +542,9 @@ extern tree create_subprog_type (tree return_type, tree param_decl_list,\n /* Return a copy of TYPE, but safe to modify in any way.  */\n extern tree copy_type (tree type);\n \n-/* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n-   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position of\n-   the decl.  */\n+/* Return a subtype of sizetype with range MIN to MAX and whose\n+   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position\n+   of the associated TYPE_DECL.  */\n extern tree create_index_type (tree min, tree max, tree index,\n \t\t\t       Node_Id gnat_node);\n "}, {"sha": "b67b8455de28f2b10f08a24bc8370ce5a7954755", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -497,7 +497,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n \n     case INTEGER_TYPE:\n       if (TYPE_MODULAR_P (node))\n-\tprint_node (file, \"modulus\", TYPE_MODULUS (node), indent + 4);\n+\tprint_node_brief (file, \"modulus\", TYPE_MODULUS (node), indent + 4);\n       else if (TYPE_HAS_ACTUAL_BOUNDS_P (node))\n \tprint_node (file, \"actual bounds\", TYPE_ACTUAL_BOUNDS (node),\n \t\t    indent + 4);\n@@ -510,7 +510,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n \n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n-      print_node (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n+      print_node_brief (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n       break;\n \n     case ARRAY_TYPE:"}, {"sha": "275017c0cfb70d30c9080ced92e00190acbc6ed4", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -5299,12 +5299,10 @@ gnat_to_gnu (Node_Id gnat_node)\n   if (TREE_CODE (gnu_result_type) == VOID_TYPE)\n     return gnu_result;\n \n-  /* If the result is a constant that overflows, raise constraint error.  */\n-  else if (TREE_CODE (gnu_result) == INTEGER_CST\n-      && TREE_OVERFLOW (gnu_result))\n+  /* If the result is a constant that overflowed, raise Constraint_Error.  */\n+  if (TREE_CODE (gnu_result) == INTEGER_CST && TREE_OVERFLOW (gnu_result))\n     {\n       post_error (\"Constraint_Error will be raised at run-time?\", gnat_node);\n-\n       gnu_result\n \t= build1 (NULL_EXPR, gnu_result_type,\n \t\t  build_call_raise (CE_Overflow_Check_Failed, gnat_node,"}, {"sha": "ad3909fa859efa1823617158ee0e3c1c9b520fb8", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -664,12 +664,13 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n \t    DECL_BIT_FIELD (field) = 0;\n \t}\n \n-      /* If we still have DECL_BIT_FIELD set at this point, we know the field\n-\t is technically not addressable.  Except that it can actually be\n-\t addressed if the field is BLKmode and happens to be properly\n-\t aligned.  */\n-      DECL_NONADDRESSABLE_P (field)\n-\t|= DECL_BIT_FIELD (field) && DECL_MODE (field) != BLKmode;\n+      /* If we still have DECL_BIT_FIELD set at this point, we know that the\n+\t field is technically not addressable.  Except that it can actually\n+\t be addressed if it is BLKmode and happens to be properly aligned.  */\n+      if (DECL_BIT_FIELD (field)\n+\t  && !(DECL_MODE (field) == BLKmode\n+\t       && value_factor_p (pos, BITS_PER_UNIT)))\n+\tDECL_NONADDRESSABLE_P (field) = 1;\n \n       /* A type must be as aligned as its most aligned field that is not\n \t a bit-field.  But this is already enforced by layout_type.  */\n@@ -1160,28 +1161,28 @@ copy_type (tree type)\n   return new;\n }\n \f\n-/* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n-   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position of\n-   the decl.  */\n+/* Return a subtype of sizetype with range MIN to MAX and whose\n+   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position\n+   of the associated TYPE_DECL.  */\n \n tree\n create_index_type (tree min, tree max, tree index, Node_Id gnat_node)\n {\n   /* First build a type for the desired range.  */\n   tree type = build_index_2_type (min, max);\n \n-  /* If this type has the TYPE_INDEX_TYPE we want, return it.  Otherwise, if it\n-     doesn't have TYPE_INDEX_TYPE set, set it to INDEX.  If TYPE_INDEX_TYPE\n-     is set, but not to INDEX, make a copy of this type with the requested\n-     index type.  Note that we have no way of sharing these types, but that's\n-     only a small hole.  */\n+  /* If this type has the TYPE_INDEX_TYPE we want, return it.  */\n   if (TYPE_INDEX_TYPE (type) == index)\n     return type;\n-  else if (TYPE_INDEX_TYPE (type))\n+\n+  /* Otherwise, if TYPE_INDEX_TYPE is set, make a copy.  Note that we have\n+     no way of sharing these types, but that's only a small hole.  */\n+  if (TYPE_INDEX_TYPE (type))\n     type = copy_type (type);\n \n   SET_TYPE_INDEX_TYPE (type, index);\n   create_type_decl (NULL_TREE, type, NULL, true, false, gnat_node);\n+\n   return type;\n }\n \f\n@@ -1570,12 +1571,17 @@ create_param_decl (tree param_name, tree param_type, bool readonly)\n       if (TREE_CODE (param_type) == INTEGER_TYPE\n \t  && TYPE_BIASED_REPRESENTATION_P (param_type))\n \t{\n-\t  param_type\n-\t    = copy_type (build_range_type (integer_type_node,\n-\t\t\t\t\t   TYPE_MIN_VALUE (param_type),\n-\t\t\t\t\t   TYPE_MAX_VALUE (param_type)));\n+\t  tree subtype = make_node (INTEGER_TYPE);\n+\t  TREE_TYPE (subtype) = integer_type_node;\n+\t  TYPE_BIASED_REPRESENTATION_P (subtype) = 1;\n+\n+\t  TYPE_UNSIGNED (subtype) = 1;\n+\t  TYPE_PRECISION (subtype) = TYPE_PRECISION (integer_type_node);\n+\t  TYPE_MIN_VALUE (subtype) = TYPE_MIN_VALUE (param_type);\n+\t  TYPE_MAX_VALUE (subtype) = TYPE_MAX_VALUE (param_type);\n+\t  layout_type (subtype);\n \n-\t  TYPE_BIASED_REPRESENTATION_P (param_type) = 1;\n+\t  param_type = subtype;\n \t}\n       else\n \tparam_type = integer_type_node;"}, {"sha": "895628b5e462e4e7601f8906a0dedaa784d97aaa", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1abd261d91caa67f71439292081b7299d4f5788/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=c1abd261d91caa67f71439292081b7299d4f5788", "patch": "@@ -1825,9 +1825,8 @@ build_component_ref (tree record_variable, tree component,\n   if (ref)\n     return ref;\n \n-  /* If FIELD was specified, assume this is an invalid user field so\n-     raise constraint error.  Otherwise, we can't find the type to return, so\n-     abort.  */\n+  /* If FIELD was specified, assume this is an invalid user field so raise\n+     Constraint_Error.  Otherwise, we have no type to return so abort.  */\n   gcc_assert (field);\n   return build1 (NULL_EXPR, TREE_TYPE (field),\n \t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,"}]}