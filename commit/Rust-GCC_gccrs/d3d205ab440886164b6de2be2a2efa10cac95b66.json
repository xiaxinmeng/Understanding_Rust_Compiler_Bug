{"sha": "d3d205ab440886164b6de2be2a2efa10cac95b66", "node_id": "C_kwDOANBUbNoAKGQzZDIwNWFiNDQwODg2MTY0YjZkZTJiZTJhMmVmYTEwY2FjOTViNjY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-28T20:05:30Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-28T20:05:30Z"}, "message": "c++: non-dependent variable template-id [PR108848]\n\nHere we're treating deeming the non-dependent variable template-id\ntag<int> as dependent ever since r226642 gave variable TEMPLATE_ID_EXPR\nan empty type, which causes the call to finish_template_variable from\nfinish_id_expression_1 to be unreachable at template parse time.  Thus\nwe're led into thinking tag<int>.var<void> refers to a dependent name.\n\nThis patch fixes this by making finish_id_expression_1 instantiate a\nvariable template-id as long as it's not dependent according to the\ndependence test in lookup_and_finish_template_variable rather than\naccording to type_dependent_expression_p.\n\n\tPR c++/108848\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (finish_template_variable): Move dependence check\n\tto here from ...\n\t(lookup_and_finish_template_variable): ... here.\n\t* semantics.cc (finish_id_expression_1): Call\n\tfinish_template_variable sooner, before (and regardless of) the\n\ttype_dependent_expression_p test.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1y/noexcept1.C: Don't expect a bogus \"different\n\texception specifier\" error.  Expect a separate \"not usable\n\tin a constant expression\" error.\n\t* g++.dg/cpp1y/var-templ75.C: New test.\n\t* g++.dg/cpp1y/var-templ76.C: New test.", "tree": {"sha": "5ed37246db4303d50f761537d738fc751b2c5e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ed37246db4303d50f761537d738fc751b2c5e6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3d205ab440886164b6de2be2a2efa10cac95b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d205ab440886164b6de2be2a2efa10cac95b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d205ab440886164b6de2be2a2efa10cac95b66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d205ab440886164b6de2be2a2efa10cac95b66/comments", "author": null, "committer": null, "parents": [{"sha": "afe6cea4489846aa8585f3c045d16cdaa08cc6cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe6cea4489846aa8585f3c045d16cdaa08cc6cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe6cea4489846aa8585f3c045d16cdaa08cc6cd"}], "stats": {"total": 86, "additions": 61, "deletions": 25}, "files": [{"sha": "03958da1fead083553e2f42a8591e5aca1b1526b", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=d3d205ab440886164b6de2be2a2efa10cac95b66", "patch": "@@ -10317,14 +10317,21 @@ lookup_template_variable (tree templ, tree arglist)\n   return build2 (TEMPLATE_ID_EXPR, NULL_TREE, templ, arglist);\n }\n \n-/* Instantiate a variable declaration from a TEMPLATE_ID_EXPR for use. */\n+/* Instantiate a variable declaration from a TEMPLATE_ID_EXPR if it's\n+   not dependent.  */\n \n tree\n finish_template_variable (tree var, tsubst_flags_t complain)\n {\n   tree templ = TREE_OPERAND (var, 0);\n   tree arglist = TREE_OPERAND (var, 1);\n \n+  /* If the template or arguments are dependent, then we\n+     can't resolve the TEMPLATE_ID_EXPR yet.  */\n+  if (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (templ)) != 1\n+      || any_dependent_template_arguments_p (arglist))\n+    return var;\n+\n   tree parms = DECL_TEMPLATE_PARMS (templ);\n   arglist = coerce_template_parms (parms, arglist, templ, complain);\n   if (arglist == error_mark_node)\n@@ -10352,19 +10359,14 @@ lookup_and_finish_template_variable (tree templ, tree targs,\n \t\t\t\t     tsubst_flags_t complain)\n {\n   tree var = lookup_template_variable (templ, targs);\n-  if (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (templ)) == 1\n-      && !any_dependent_template_arguments_p (targs))\n-    {\n-      /* We may be called while doing a partial substitution, but the\n-\t type of the variable template may be auto, in which case we\n-\t will call do_auto_deduction in mark_used (which clears tf_partial)\n-\t and the auto must be properly reduced at that time for the\n-\t deduction to work.  */\n-      complain &= ~tf_partial;\n-      var = finish_template_variable (var, complain);\n-      mark_used (var);\n-    }\n-\n+  /* We may be called while doing a partial substitution, but the\n+     type of the variable template may be auto, in which case we\n+     will call do_auto_deduction in mark_used (which clears tf_partial)\n+     and the auto must be properly reduced at that time for the\n+     deduction to work.  */\n+  complain &= ~tf_partial;\n+  var = finish_template_variable (var, complain);\n+  mark_used (var);\n   return convert_from_reference (var);\n }\n "}, {"sha": "db982d594e6d495cbdc93bcba8c2eba69882ec4e", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=d3d205ab440886164b6de2be2a2efa10cac95b66", "patch": "@@ -4208,6 +4208,16 @@ finish_id_expression_1 (tree id_expression,\n     }\n   else\n     {\n+      if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n+\t  && variable_template_p (TREE_OPERAND (decl, 0))\n+\t  && !concept_check_p (decl))\n+\t/* Try resolving this variable TEMPLATE_ID_EXPR (which is always\n+\t   considered type-dependent) now, so that the dependence test that\n+\t   follows gives us the right answer: if it represents a non-dependent\n+\t   variable template-id then finish_template_variable will yield the\n+\t   corresponding non-dependent VAR_DECL.  */\n+\tdecl = finish_template_variable (decl);\n+\n       bool dependent_p = type_dependent_expression_p (decl);\n \n       /* If the declaration was explicitly qualified indicate\n@@ -4275,15 +4285,6 @@ finish_id_expression_1 (tree id_expression,\n \t/* Replace an evaluated use of the thread_local variable with\n \t   a call to its wrapper.  */\n \tdecl = wrap;\n-      else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n-\t       && !dependent_p\n-\t       && variable_template_p (TREE_OPERAND (decl, 0))\n-\t       && !concept_check_p (decl))\n-\t{\n-\t  decl = finish_template_variable (decl);\n-\t  mark_used (decl);\n-\t  decl = convert_from_reference (decl);\n-\t}\n       else if (concept_check_p (decl))\n \t{\n \t  /* Nothing more to do. All of the analysis for concept checks"}, {"sha": "caa4a056a2ed104818fbcc32557bf664646d76d3", "filename": "gcc/testsuite/g++.dg/cpp1y/noexcept1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnoexcept1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnoexcept1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnoexcept1.C?ref=d3d205ab440886164b6de2be2a2efa10cac95b66", "patch": "@@ -5,9 +5,9 @@ template <int> bool b;\n \n template <typename> \n struct C {\n-  template <typename> friend int foo() noexcept(b<1>); // { dg-error \"not usable in a constant expression|different exception specifier\" }\n+  template <typename> friend int foo() noexcept(b<1>); // { dg-error \"not usable in a constant expression\" }\n };\n \n-template <typename> int foo() noexcept(b<1>);\n+template <typename> int foo() noexcept(b<1>); // { dg-error \"not usable in a constant expression\" }\n \n auto a = C<int>();"}, {"sha": "d2ab807ab9a53677725d50c438be57b916e784ed", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ75.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ75.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ75.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ75.C?ref=d3d205ab440886164b6de2be2a2efa10cac95b66", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/108848\n+// { dg-do compile { target c++14 } }\n+\n+template<class T>\n+struct tag_t {\n+  template<class Sig>\n+  static constexpr const Sig* var = nullptr;\n+\n+  template<class Sig>\n+  static const Sig* fun();\n+};\n+\n+template<class T>\n+constexpr tag_t<T> tag;\n+\n+template<class T>\n+void f() {\n+  tag<int>.var<void>;   // { dg-bogus \"expected 'template' keyword\" }\n+  tag<int>.fun<void>(); // { dg-bogus \"expected 'template' keyword\" }\n+};"}, {"sha": "2acb815095378b94ad40babfa5480803a002a0cd", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ76.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ76.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d205ab440886164b6de2be2a2efa10cac95b66/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ76.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ76.C?ref=d3d205ab440886164b6de2be2a2efa10cac95b66", "patch": "@@ -0,0 +1,13 @@\n+// Verify we can evaluate a non-dependent variable template-id ahead of time.\n+// { dg-do compile { target c++14 } }\n+\n+template<int N>\n+constexpr int var = N;\n+\n+template<int N> void f(int) = delete;\n+template<int N> void f(...);\n+\n+template<class T>\n+void g() {\n+  f<var<42>>(0); // { dg-error \"deleted\" }\n+}"}]}