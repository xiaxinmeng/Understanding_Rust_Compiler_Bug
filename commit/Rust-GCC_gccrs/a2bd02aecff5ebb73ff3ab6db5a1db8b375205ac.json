{"sha": "a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiZDAyYWVjZmY1ZWJiNzNmZjNhYjZkYjVhMWRiOGIzNzUyMDVhYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-14T01:50:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-14T01:50:31Z"}, "message": "compiler: implement type aliases\n    \n    This is a start of implementing type aliases (`type T1 = T2`) in the\n    Go frontend.  This is incomplete, in that the reflection information\n    is not updated for an embedded type alias.  It is also not well\n    tested.  Finally, the change to the language has not been approved.\n    This should be regarded as preliminary work for experimental use.\n    \n    Update golang/go#18130.\n    \n    Reviewed-on: https://go-review.googlesource.com/35120\n\nFrom-SVN: r244460", "tree": {"sha": "e0c6fe09604b8c1e8df1d97b108f37710551c3ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0c6fe09604b8c1e8df1d97b108f37710551c3ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/comments", "author": null, "committer": null, "parents": [{"sha": "3220ce78c95b6d2cf04851ea37c0f587f52e5fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3220ce78c95b6d2cf04851ea37c0f587f52e5fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3220ce78c95b6d2cf04851ea37c0f587f52e5fad"}], "stats": {"total": 460, "additions": 406, "deletions": 54}, "files": [{"sha": "61359d33d484e1e73910dda297cfbb24ec3fcd8a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -1,4 +1,4 @@\n-0ba4563a4b0dec4c01b90d7b3c9e2ce2cd58a96f\n+ea73a80a6047f477d92fccc7de143a3ee1021c65\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "6e085991a23ad76bb3796c1f66450b9f40bda5a4", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -608,6 +608,9 @@ Export::write_type(const Type* type)\n       // definition of the type may refer to the named type via a\n       // pointer.\n       this->type_refs_[type] = index;\n+\n+      if (named_type != NULL && named_type->is_alias())\n+\tthis->write_c_string(\"= \");\n     }\n \n   type->export_type(this);"}, {"sha": "ad2541c6eee9ae3c6384b788b04b1591fd852636", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -108,12 +108,14 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   uint8_type->integer_type()->set_is_byte();\n   Named_object* byte_type = Named_object::make_type(\"byte\", NULL, uint8_type,\n \t\t\t\t\t\t    loc);\n+  byte_type->type_value()->set_is_alias();\n   this->add_named_type(byte_type->type_value());\n \n   // \"rune\" is an alias for \"int32\".\n   int32_type->integer_type()->set_is_rune();\n   Named_object* rune_type = Named_object::make_type(\"rune\", NULL, int32_type,\n \t\t\t\t\t\t    loc);\n+  rune_type->type_value()->set_is_alias();\n   this->add_named_type(rune_type->type_value());\n \n   this->add_named_type(Type::make_named_bool_type());\n@@ -1775,6 +1777,10 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \t  if (rtype->classification() == Type::TYPE_POINTER)\n \t    rtype = rtype->points_to();\n \n+\t  while (rtype->named_type() != NULL\n+\t\t && rtype->named_type()->is_alias())\n+\t    rtype = rtype->named_type()->real_type();\n+\n \t  if (rtype->is_error_type())\n \t    ret = Named_object::make_function(name, NULL, function);\n \t  else if (rtype->named_type() != NULL)\n@@ -6865,7 +6871,7 @@ Type_declaration::add_method_declaration(const std::string&  name,\n   return ret;\n }\n \n-// Return whether any methods ere defined.\n+// Return whether any methods are defined.\n \n bool\n Type_declaration::has_methods() const\n@@ -6878,6 +6884,36 @@ Type_declaration::has_methods() const\n void\n Type_declaration::define_methods(Named_type* nt)\n {\n+  if (this->methods_.empty())\n+    return;\n+\n+  while (nt->is_alias())\n+    {\n+      Type *t = nt->real_type()->forwarded();\n+      if (t->named_type() != NULL)\n+\tnt = t->named_type();\n+      else if (t->forward_declaration_type() != NULL)\n+\t{\n+\t  Named_object* no = t->forward_declaration_type()->named_object();\n+\t  Type_declaration* td = no->type_declaration_value();\n+\t  td->methods_.insert(td->methods_.end(), this->methods_.begin(),\n+\t\t\t      this->methods_.end());\n+\t  this->methods_.clear();\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  for (std::vector<Named_object*>::const_iterator p =\n+\t\t this->methods_.begin();\n+\t       p != this->methods_.end();\n+\t       ++p)\n+\t    go_error_at((*p)->location(),\n+\t\t\t(\"invalid receiver type \"\n+\t\t\t \"(receiver must be a named type\"));\n+\t  return;\n+\t}\n+    }\n+\n   for (std::vector<Named_object*>::const_iterator p = this->methods_.begin();\n        p != this->methods_.end();\n        ++p)"}, {"sha": "f6b4e0c0566a346552662ec707334d5617628dd3", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -737,6 +737,13 @@ Import::read_type()\n \n   this->require_c_string(\" \");\n \n+  bool is_alias = false;\n+  if (this->match_c_string(\"= \"))\n+    {\n+      stream->advance(2);\n+      is_alias = true;\n+    }\n+\n   // The package name may follow.  This is the name of the package in\n   // the package clause of that package.  The type name will include\n   // the pkgpath, which may be different.\n@@ -810,6 +817,9 @@ Import::read_type()\n \t  // This type has not yet been imported.\n \t  ntype->clear_is_visible();\n \n+\t  if (is_alias)\n+\t    ntype->set_is_alias();\n+\n \t  if (!type->is_undefined() && type->interface_type() != NULL)\n \t    this->gogo_->record_interface_type(type->interface_type());\n "}, {"sha": "84840fb79c17cf986d2d0583797bf8df86f19279", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -1515,7 +1515,7 @@ Parse::type_decl()\n   this->decl(&Parse::type_spec, NULL);\n }\n \n-// TypeSpec = identifier Type .\n+// TypeSpec = identifier [\"=\"] Type .\n \n void\n Parse::type_spec(void*)\n@@ -1531,6 +1531,13 @@ Parse::type_spec(void*)\n   Location location = token->location();\n   token = this->advance_token();\n \n+  bool is_alias = false;\n+  if (token->is_op(OPERATOR_EQ))\n+    {\n+      is_alias = true;\n+      token = this->advance_token();\n+    }\n+\n   // The scope of the type name starts at the point where the\n   // identifier appears in the source code.  We implement this by\n   // declaring the type before we read the type definition.\n@@ -1542,13 +1549,13 @@ Parse::type_spec(void*)\n     }\n \n   Type* type;\n-  if (name == \"_\" && this->peek_token()->is_keyword(KEYWORD_INTERFACE))\n+  if (name == \"_\" && token->is_keyword(KEYWORD_INTERFACE))\n     {\n       // We call Parse::interface_type explicity here because we do not want\n       // to record an interface with a blank type name.\n       type = this->interface_type(false);\n     }\n-  else if (!this->peek_token()->is_op(OPERATOR_SEMICOLON))\n+  else if (!token->is_op(OPERATOR_SEMICOLON))\n     type = this->type();\n   else\n     {\n@@ -1579,9 +1586,11 @@ Parse::type_spec(void*)\n \t      type = Type::make_error_type();\n \t    }\n \n-\t  this->gogo_->define_type(named_type,\n-\t\t\t\t   Type::make_named_type(named_type, type,\n-\t\t\t\t\t\t\t location));\n+\t  Named_type* nt = Type::make_named_type(named_type, type, location);\n+\t  if (is_alias)\n+\t    nt->set_is_alias();\n+\n+\t  this->gogo_->define_type(named_type, nt);\n \t  go_assert(named_type->package() == NULL);\n \t}\n       else"}, {"sha": "296e8e51ee0f9c6cadec6ec037c6eefc153f72e4", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 308, "deletions": 31, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -328,10 +328,10 @@ Type::are_identical(const Type* t1, const Type* t2, bool errors_are_identical,\n   t2 = t2->forwarded();\n \n   // Ignore aliases for purposes of type identity.\n-  if (t1->named_type() != NULL && t1->named_type()->is_alias())\n-    t1 = t1->named_type()->real_type();\n-  if (t2->named_type() != NULL && t2->named_type()->is_alias())\n-    t2 = t2->named_type()->real_type();\n+  while (t1->named_type() != NULL && t1->named_type()->is_alias())\n+    t1 = t1->named_type()->real_type()->forwarded();\n+  while (t2->named_type() != NULL && t2->named_type()->is_alias())\n+    t2 = t2->named_type()->real_type()->forwarded();\n \n   if (t1 == t2)\n     return true;\n@@ -822,6 +822,8 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n unsigned int\n Type::hash_for_method(Gogo* gogo) const\n {\n+  if (this->named_type() != NULL && this->named_type()->is_alias())\n+    return this->named_type()->real_type()->hash_for_method(gogo);\n   unsigned int ret = 0;\n   if (this->classification_ != TYPE_FORWARD)\n     ret += this->classification_;\n@@ -1165,8 +1167,8 @@ Bexpression*\n Type::type_descriptor_pointer(Gogo* gogo, Location location)\n {\n   Type* t = this->forwarded();\n-  if (t->named_type() != NULL && t->named_type()->is_alias())\n-    t = t->named_type()->real_type();\n+  while (t->named_type() != NULL && t->named_type()->is_alias())\n+    t = t->named_type()->real_type()->forwarded();\n   if (t->type_descriptor_var_ == NULL)\n     {\n       t->make_type_descriptor_var(gogo);\n@@ -1585,6 +1587,9 @@ Type::make_type_descriptor_ptr_type()\n bool\n Type::needs_specific_type_functions(Gogo* gogo)\n {\n+  Named_type* nt = this->named_type();\n+  if (nt != NULL && nt->is_alias())\n+    return false;\n   if (!this->is_comparable())\n     return false;\n   if (!this->compare_is_identity(gogo))\n@@ -1593,7 +1598,6 @@ Type::needs_specific_type_functions(Gogo* gogo)\n   // We create a few predeclared types for type descriptors; they are\n   // really just for the backend and don't need hash or equality\n   // functions.\n-  Named_type* nt = this->named_type();\n   if (nt != NULL && Linemap::is_predeclared_location(nt->location()))\n     return false;\n \n@@ -1634,6 +1638,11 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t\t     Function_type* equal_fntype, Named_object** hash_fn,\n \t\t     Named_object** equal_fn)\n {\n+  // If this loop leaves NAME as NULL, then the type does not have a\n+  // name after all.\n+  while (name != NULL && name->is_alias())\n+    name = name->real_type()->named_type();\n+\n   if (!this->is_comparable())\n     {\n       *hash_fn = NULL;\n@@ -2164,6 +2173,11 @@ Type::write_named_hash(Gogo* gogo, Named_type* name,\n   Location bloc = Linemap::predeclared_location();\n \n   Named_type* base_type = name->real_type()->named_type();\n+  while (base_type->is_alias())\n+    {\n+      base_type = base_type->real_type()->named_type();\n+      go_assert(base_type != NULL);\n+    }\n   go_assert(base_type != NULL);\n \n   // The pointer to the type we are going to hash.  This is an\n@@ -2371,8 +2385,8 @@ Bexpression*\n Type::gc_symbol_pointer(Gogo* gogo)\n {\n   Type* t = this->forwarded();\n-  if (t->named_type() != NULL && t->named_type()->is_alias())\n-    t = t->named_type()->real_type();\n+  while (t->named_type() != NULL && t->named_type()->is_alias())\n+    t = t->named_type()->real_type()->forwarded();\n   if (t->gc_symbol_var_ == NULL)\n     {\n       t->make_gc_symbol_var(gogo);\n@@ -4857,7 +4871,10 @@ Struct_field::field_name() const\n       if (dt->forward_declaration_type() != NULL)\n \treturn dt->forward_declaration_type()->name();\n       else if (dt->named_type() != NULL)\n-\treturn dt->named_type()->name();\n+\t{\n+\t  // Note that this can be an alias name.\n+\t  return dt->named_type()->name();\n+\t}\n       else if (t->is_error_type() || dt->is_error_type())\n \t{\n \t  static const std::string error_string = \"*error*\";\n@@ -5786,7 +5803,12 @@ Struct_type::do_reflection(Gogo* gogo, std::string* ret) const\n       else\n \tret->append(Gogo::unpack_hidden_name(p->field_name()));\n       ret->push_back(' ');\n-      this->append_reflection(p->type(), gogo, ret);\n+      if (p->is_anonymous()\n+\t  && p->type()->named_type() != NULL\n+\t  && p->type()->named_type()->is_alias())\n+\tp->type()->named_type()->append_reflection_type_name(gogo, true, ret);\n+      else\n+\tthis->append_reflection(p->type(), gogo, ret);\n \n       if (p->has_tag())\n \t{\n@@ -5866,7 +5888,15 @@ Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \t      ret->append(buf);\n \t      ret->append(n);\n \t    }\n-\t  this->append_mangled_name(p->type(), gogo, ret);\n+\n+\t  // For an anonymous field with an alias type, the field name\n+\t  // is the alias name.\n+\t  if (p->is_anonymous()\n+\t      && p->type()->named_type() != NULL\n+\t      && p->type()->named_type()->is_alias())\n+\t    p->type()->named_type()->append_mangled_type_name(gogo, true, ret);\n+\t  else\n+\t    this->append_mangled_name(p->type(), gogo, ret);\n \t  if (p->has_tag())\n \t    {\n \t      const std::string& tag(p->tag());\n@@ -9313,18 +9343,6 @@ Named_type::message_name() const\n   return this->named_object_->message_name();\n }\n \n-// Whether this is an alias.  There are currently only two aliases so\n-// we just recognize them by name.\n-\n-bool\n-Named_type::is_alias() const\n-{\n-  if (!this->is_builtin())\n-    return false;\n-  const std::string& name(this->name());\n-  return name == \"byte\" || name == \"rune\";\n-}\n-\n // Return the base type for this type.  We have to be careful about\n // circular type definitions, which are invalid but may be seen here.\n \n@@ -9384,6 +9402,7 @@ Named_type::named_type_is_comparable(std::string* reason) const\n Named_object*\n Named_type::add_method(const std::string& name, Function* function)\n {\n+  go_assert(!this->is_alias_);\n   if (this->local_methods_ == NULL)\n     this->local_methods_ = new Bindings(NULL);\n   return this->local_methods_->add_function(name, NULL, function);\n@@ -9396,6 +9415,7 @@ Named_type::add_method_declaration(const std::string& name, Package* package,\n \t\t\t\t   Function_type* type,\n \t\t\t\t   Location location)\n {\n+  go_assert(!this->is_alias_);\n   if (this->local_methods_ == NULL)\n     this->local_methods_ = new Bindings(NULL);\n   return this->local_methods_->add_function_declaration(name, package, type,\n@@ -9407,6 +9427,7 @@ Named_type::add_method_declaration(const std::string& name, Package* package,\n void\n Named_type::add_existing_method(Named_object* no)\n {\n+  go_assert(!this->is_alias_);\n   if (this->local_methods_ == NULL)\n     this->local_methods_ = new Bindings(NULL);\n   this->local_methods_->add_named_object(no);\n@@ -9418,18 +9439,74 @@ Named_type::add_existing_method(Named_object* no)\n Named_object*\n Named_type::find_local_method(const std::string& name) const\n {\n+  if (this->is_error_)\n+    return NULL;\n+  if (this->is_alias_)\n+    {\n+      Named_type* nt = this->type_->named_type();\n+      if (nt != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return NULL;\n+\t  this->seen_alias_ = true;\n+\t  Named_object* ret = nt->find_local_method(name);\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      return NULL;\n+    }\n   if (this->local_methods_ == NULL)\n     return NULL;\n   return this->local_methods_->lookup(name);\n }\n \n+// Return the list of local methods.\n+\n+const Bindings*\n+Named_type::local_methods() const\n+{\n+  if (this->is_error_)\n+    return NULL;\n+  if (this->is_alias_)\n+    {\n+      Named_type* nt = this->type_->named_type();\n+      if (nt != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return NULL;\n+\t  this->seen_alias_ = true;\n+\t  const Bindings* ret = nt->local_methods();\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      return NULL;\n+    }\n+  return this->local_methods_;\n+}\n+\n // Return whether NAME is an unexported field or method, for better\n // error reporting.\n \n bool\n Named_type::is_unexported_local_method(Gogo* gogo,\n \t\t\t\t       const std::string& name) const\n {\n+  if (this->is_error_)\n+    return false;\n+  if (this->is_alias_)\n+    {\n+      Named_type* nt = this->type_->named_type();\n+      if (nt != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return false;\n+\t  this->seen_alias_ = true;\n+\t  bool ret = nt->is_unexported_local_method(gogo, name);\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      return false;\n+    }\n   Bindings* methods = this->local_methods_;\n   if (methods != NULL)\n     {\n@@ -9454,6 +9531,8 @@ Named_type::is_unexported_local_method(Gogo* gogo,\n void\n Named_type::finalize_methods(Gogo* gogo)\n {\n+  if (this->is_alias_)\n+    return;\n   if (this->all_methods_ != NULL)\n     return;\n \n@@ -9474,13 +9553,83 @@ Named_type::finalize_methods(Gogo* gogo)\n   Type::finalize_methods(gogo, this, this->location_, &this->all_methods_);\n }\n \n+// Return whether this type has any methods.\n+\n+bool\n+Named_type::has_any_methods() const\n+{\n+  if (this->is_error_)\n+    return false;\n+  if (this->is_alias_)\n+    {\n+      if (this->type_->named_type() != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return false;\n+\t  this->seen_alias_ = true;\n+\t  bool ret = this->type_->named_type()->has_any_methods();\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      if (this->type_->struct_type() != NULL)\n+\treturn this->type_->struct_type()->has_any_methods();\n+      return false;\n+    }\n+  return this->all_methods_ != NULL;\n+}\n+\n+// Return the methods for this type.\n+\n+const Methods*\n+Named_type::methods() const\n+{\n+  if (this->is_error_)\n+    return NULL;\n+  if (this->is_alias_)\n+    {\n+      if (this->type_->named_type() != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return NULL;\n+\t  this->seen_alias_ = true;\n+\t  const Methods* ret = this->type_->named_type()->methods();\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      if (this->type_->struct_type() != NULL)\n+\treturn this->type_->struct_type()->methods();\n+      return NULL;\n+    }\n+  return this->all_methods_;\n+}\n+\n // Return the method NAME, or NULL if there isn't one or if it is\n // ambiguous.  Set *IS_AMBIGUOUS if the method exists but is\n // ambiguous.\n \n Method*\n Named_type::method_function(const std::string& name, bool* is_ambiguous) const\n {\n+  if (this->is_error_)\n+    return NULL;\n+  if (this->is_alias_)\n+    {\n+      if (is_ambiguous != NULL)\n+\t*is_ambiguous = false;\n+      if (this->type_->named_type() != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return NULL;\n+\t  this->seen_alias_ = true;\n+\t  Named_type* nt = this->type_->named_type();\n+\t  Method* ret = nt->method_function(name, is_ambiguous);\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      if (this->type_->struct_type() != NULL)\n+\treturn this->type_->struct_type()->method_function(name, is_ambiguous);\n+      return NULL;\n+    }\n   return Type::method_function(this->all_methods_, name, is_ambiguous);\n }\n \n@@ -9491,6 +9640,25 @@ Named_type::method_function(const std::string& name, bool* is_ambiguous) const\n Expression*\n Named_type::interface_method_table(Interface_type* interface, bool is_pointer)\n {\n+  if (this->is_error_)\n+    return Expression::make_error(this->location_);\n+  if (this->is_alias_)\n+    {\n+      if (this->type_->named_type() != NULL)\n+\t{\n+\t  if (this->seen_alias_)\n+\t    return Expression::make_error(this->location_);\n+\t  this->seen_alias_ = true;\n+\t  Named_type* nt = this->type_->named_type();\n+\t  Expression* ret = nt->interface_method_table(interface, is_pointer);\n+\t  this->seen_alias_ = false;\n+\t  return ret;\n+\t}\n+      if (this->type_->struct_type() != NULL)\n+\treturn this->type_->struct_type()->interface_method_table(interface,\n+\t\t\t\t\t\t\t\t  is_pointer);\n+      go_unreachable();\n+    }\n   return Type::interface_method_table(this, interface, is_pointer,\n                                       &this->interface_method_tables_,\n                                       &this->pointer_interface_method_tables_);\n@@ -9609,6 +9777,55 @@ Find_type_use::type(Type* type)\n   return TRAVERSE_CONTINUE;\n }\n \n+// Look for a circular reference of an alias.\n+\n+class Find_alias : public Traverse\n+{\n+ public:\n+  Find_alias(Named_type* find_type)\n+    : Traverse(traverse_types),\n+      find_type_(find_type), found_(false)\n+  { }\n+\n+  // Whether we found the type.\n+  bool\n+  found() const\n+  { return this->found_; }\n+\n+ protected:\n+  int\n+  type(Type*);\n+\n+ private:\n+  // The type we are looking for.\n+  Named_type* find_type_;\n+  // Whether we found the type.\n+  bool found_;\n+};\n+\n+int\n+Find_alias::type(Type* type)\n+{\n+  Named_type* nt = type->named_type();\n+  if (nt != NULL)\n+    {\n+      if (nt == this->find_type_)\n+\t{\n+\t  this->found_ = true;\n+\t  return TRAVERSE_EXIT;\n+\t}\n+\n+      // We started from `type T1 = T2`, where T1 is find_type_ and T2\n+      // is, perhaps indirectly, the parameter TYPE.  If TYPE is not\n+      // an alias itself, it's OK if whatever T2 is defined as refers\n+      // to T1.\n+      if (!nt->is_alias())\n+\treturn TRAVERSE_SKIP_COMPONENTS;\n+    }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Verify that a named type does not refer to itself.\n \n bool\n@@ -9618,6 +9835,22 @@ Named_type::do_verify()\n     return true;\n   this->is_verified_ = true;\n \n+  if (this->is_error_)\n+    return false;\n+\n+  if (this->is_alias_)\n+    {\n+      Find_alias find(this);\n+      Type::traverse(this->type_, &find);\n+      if (find.found())\n+\t{\n+\t  go_error_at(this->location_, \"invalid recursive alias %qs\",\n+\t\t      this->message_name().c_str());\n+\t  this->is_error_ = true;\n+\t  return false;\n+\t}\n+    }\n+\n   Find_type_use find(this);\n   Type::traverse(this->type_, &find);\n   if (find.found())\n@@ -9718,8 +9951,11 @@ Named_type::do_needs_key_update()\n unsigned int\n Named_type::do_hash_for_method(Gogo* gogo) const\n {\n-  if (this->is_alias())\n-    return this->type_->named_type()->do_hash_for_method(gogo);\n+  if (this->is_error_)\n+    return 0;\n+\n+  // Aliases are handled in Type::hash_for_method.\n+  go_assert(!this->is_alias_);\n \n   const std::string& name(this->named_object()->name());\n   unsigned int ret = Type::hash_string(name, 0);\n@@ -10089,8 +10325,17 @@ Named_type::do_get_backend(Gogo* gogo)\n Expression*\n Named_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  if (name == NULL && this->is_alias())\n-    return this->type_->type_descriptor(gogo, this->type_);\n+  if (this->is_error_)\n+    return Expression::make_error(this->location_);\n+  if (name == NULL && this->is_alias_)\n+    {\n+      if (this->seen_alias_)\n+\treturn Expression::make_error(this->location_);\n+      this->seen_alias_ = true;\n+      Expression* ret = this->type_->type_descriptor(gogo, NULL);\n+      this->seen_alias_ = false;\n+      return ret;\n+    }\n \n   // If NAME is not NULL, then we don't really want the type\n   // descriptor for this type; we want the descriptor for the\n@@ -10106,9 +10351,25 @@ Named_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n void\n Named_type::do_reflection(Gogo* gogo, std::string* ret) const\n {\n-  if (this->is_alias())\n+  this->append_reflection_type_name(gogo, false, ret);\n+}\n+\n+// Add to the reflection string.  For an alias we normally use the\n+// real name, but if USE_ALIAS is true we use the alias name itself.\n+\n+void\n+Named_type::append_reflection_type_name(Gogo* gogo, bool use_alias,\n+\t\t\t\t\tstd::string* ret) const\n+{\n+  if (this->is_error_)\n+    return;\n+  if (this->is_alias_ && !use_alias)\n     {\n+      if (this->seen_alias_)\n+\treturn;\n+      this->seen_alias_ = true;\n       this->append_reflection(this->type_, gogo, ret);\n+      this->seen_alias_ = false;\n       return;\n     }\n   if (!this->is_builtin())\n@@ -10173,9 +10434,25 @@ Named_type::do_gc_symbol(Gogo* gogo, Expression_list** vals,\n void\n Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  if (this->is_alias())\n+  this->append_mangled_type_name(gogo, false, ret);\n+}\n+\n+// Get the mangled name.  For an alias we normally get the real name,\n+// but if USE_ALIAS is true we use the alias name itself.\n+\n+void\n+Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n+\t\t\t\t     std::string* ret) const\n+{\n+  if (this->is_error_)\n+    return;\n+  if (this->is_alias_ && !use_alias)\n     {\n+      if (this->seen_alias_)\n+\treturn;\n+      this->seen_alias_ = true;\n       this->append_mangled_name(this->type_, gogo, ret);\n+      this->seen_alias_ = false;\n       return;\n     }\n   Named_object* no = this->named_object_;\n@@ -11392,7 +11669,7 @@ Forward_declaration_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n       if (name != NULL)\n \treturn this->named_type_descriptor(gogo, t, name);\n       else\n-\treturn Expression::make_type_descriptor(t, ploc);\n+\treturn Expression::make_error(this->named_object_->location());\n     }\n }\n "}, {"sha": "a2a6e611cc8df5060688a18fde4fd7e797b90c20", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=a2bd02aecff5ebb73ff3ab6db5a1db8b375205ac", "patch": "@@ -3061,10 +3061,10 @@ class Named_type : public Type\n       type_(type), local_methods_(NULL), all_methods_(NULL),\n       interface_method_tables_(NULL), pointer_interface_method_tables_(NULL),\n       location_(location), named_btype_(NULL), dependencies_(),\n-      is_visible_(true), is_error_(false), is_placeholder_(false),\n-      is_converted_(false), is_circular_(false), is_verified_(false),\n-      seen_(false), seen_in_compare_is_identity_(false),\n-      seen_in_get_backend_(false)\n+      is_alias_(false), is_visible_(true), is_error_(false),\n+      is_placeholder_(false), is_converted_(false), is_circular_(false),\n+      is_verified_(false), seen_(false), seen_in_compare_is_identity_(false),\n+      seen_in_get_backend_(false), seen_alias_(false)\n   { }\n \n   // Return the associated Named_object.  This holds the actual name.\n@@ -3082,6 +3082,17 @@ class Named_type : public Type\n   set_named_object(Named_object* no)\n   { this->named_object_ = no; }\n \n+  // Whether this is an alias (type T1 = T2) rather than an ordinary\n+  // named type (type T1 T2).\n+  bool\n+  is_alias() const\n+  { return this->is_alias_; }\n+\n+  // Record that this type is an alias.\n+  void\n+  set_is_alias()\n+  { this->is_alias_ = true; }\n+\n   // Return the function in which this type is defined.  This will\n   // return NULL for a type defined in global scope.\n   const Named_object*\n@@ -3143,11 +3154,6 @@ class Named_type : public Type\n   is_builtin() const\n   { return Linemap::is_predeclared_location(this->location_); }\n \n-  // Whether this is an alias.  There are currently two aliases: byte\n-  // and rune.\n-  bool\n-  is_alias() const;\n-\n   // Whether this named type is valid.  A recursive named type is invalid.\n   bool\n   is_valid() const\n@@ -3195,8 +3201,7 @@ class Named_type : public Type\n \n   // Return the list of local methods.\n   const Bindings*\n-  local_methods() const\n-  { return this->local_methods_; }\n+  local_methods() const;\n \n   // Build the complete list of methods, including those from\n   // anonymous fields, and build method stubs if needed.\n@@ -3206,14 +3211,12 @@ class Named_type : public Type\n   // Return whether this type has any methods.  This should only be\n   // called after the finalize_methods pass.\n   bool\n-  has_any_methods() const\n-  { return this->all_methods_ != NULL; }\n+  has_any_methods() const;\n \n   // Return the methods for this type.  This should only be called\n   // after the finalized_methods pass.\n   const Methods*\n-  methods() const\n-  { return this->all_methods_; }\n+  methods() const;\n \n   // Return the method to use for NAME.  This returns NULL if there is\n   // no such method or if the method is ambiguous.  When it returns\n@@ -3246,6 +3249,16 @@ class Named_type : public Type\n   is_named_backend_type_size_known() const\n   { return this->named_btype_ != NULL && !this->is_placeholder_; }\n \n+  // Add to the reflection string as for Type::append_reflection, but\n+  // if USE_ALIAS use the alias name rather than the alias target.\n+  void\n+  append_reflection_type_name(Gogo*, bool use_alias, std::string*) const;\n+\n+  // Append the mangled type name as for Type::append_mangled_name,\n+  // but if USE_ALIAS use the alias name rather than the alias target.\n+  void\n+  append_mangled_type_name(Gogo*, bool use_alias, std::string*) const;\n+\n   // Export the type.\n   void\n   export_named_type(Export*, const std::string& name) const;\n@@ -3340,6 +3353,8 @@ class Named_type : public Type\n   // where we can't convert S2 to the backend representation unless we\n   // have converted S1.\n   std::vector<Named_type*> dependencies_;\n+  // Whether this is an alias type.\n+  bool is_alias_;\n   // Whether this type is visible.  This is false if this type was\n   // created because it was referenced by an imported object, but the\n   // type itself was not exported.  This will always be true for types\n@@ -3367,6 +3382,8 @@ class Named_type : public Type\n   bool seen_in_compare_is_identity_;\n   // Like seen_, but used only by do_get_backend.\n   bool seen_in_get_backend_;\n+  // Like seen_, but used when resolving aliases.\n+  mutable bool seen_alias_;\n };\n \n // A forward declaration.  This handles a type which has been declared"}]}