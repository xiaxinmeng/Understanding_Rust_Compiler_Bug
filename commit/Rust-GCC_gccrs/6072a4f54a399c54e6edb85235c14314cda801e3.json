{"sha": "6072a4f54a399c54e6edb85235c14314cda801e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA3MmE0ZjU0YTM5OWM1NGU2ZWRiODUyMzVjMTQzMTRjZGE4MDFlMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-02T02:04:32Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-02T02:04:32Z"}, "message": "Changed some decls.\n\nFrom-SVN: r2020", "tree": {"sha": "f4505514b1b15202650314b802c5c0dce8385527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4505514b1b15202650314b802c5c0dce8385527"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6072a4f54a399c54e6edb85235c14314cda801e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6072a4f54a399c54e6edb85235c14314cda801e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6072a4f54a399c54e6edb85235c14314cda801e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6072a4f54a399c54e6edb85235c14314cda801e3/comments", "author": null, "committer": null, "parents": [{"sha": "f847fb392d7d54f620414fea1ef2accfb04d2863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f847fb392d7d54f620414fea1ef2accfb04d2863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f847fb392d7d54f620414fea1ef2accfb04d2863"}], "stats": {"total": 193, "additions": 95, "deletions": 98}, "files": [{"sha": "469800b5bcf5054447f7dc34cb4315d4f0ecff6a", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 95, "deletions": 98, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6072a4f54a399c54e6edb85235c14314cda801e3/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6072a4f54a399c54e6edb85235c14314cda801e3/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=6072a4f54a399c54e6edb85235c14314cda801e3", "patch": "@@ -1,5 +1,3 @@\n-/* -*-c-*- */\n-\n /* Copyright (C) 1989, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -25,10 +23,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the executable file might be covered by the GNU General Public License.  */\n \n /* \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/dispatch/RCS/hash.c,v 0.13 1992/08/18 04:46:58 dglattin Exp $\n+  $Header: /home/fsf/rms/c-runtime/dispatch/RCS/hash.c,v 0.14 1992/08/31 21:09:15 dglattin Exp rms $\n   $Author: dglattin $\n-  $Date: 1992/08/18 04:46:58 $\n+  $Date: 1992/08/31 21:09:15 $\n   $Log: hash.c,v $\n+ * Revision 0.14  1992/08/31  21:09:15  dglattin\n+ * minor documentation changes.\n+ *\n  * Revision 0.13  1992/08/18  04:46:58  dglattin\n  * Saving a working version before release.\n  *\n@@ -52,22 +53,22 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n  * the efficiency gained didn't out weight the grossness of the code.\n  *\n  * Revision 0.7  1991/11/23  22:18:29  dennisg\n- * deleted hashIndex() and moved it to hash-inline.h\n- * converted hash_value_for_key () to a inline and moved it to hash-inline.h.\n+ * deleted hashIndex and moved it to hash-inline.h\n+ * converted hash_value_for_key to a inline and moved it to hash-inline.h.\n  *\n  * Revision 0.6  1991/11/21  22:27:06  dennisg\n  * changed hash value calculation.\n- * func name changed from hashValue () to hashIndex().  the\n+ * func name changed from hashValue to hashIndex.  the\n  * func really calculated a index anyway.\n  * changed hash func impl.  essentially it was calculating a hash value\n  * from a hash value.  this is a implementation thing.\n  *\n  * Revision 0.5  1991/11/20  23:29:20  dennisg\n- * converted hashIndex() to a inline.\n+ * converted hashIndex to a inline.\n  *\n  * Revision 0.4  1991/11/19  12:34:41  dennisg\n- * bug in hash_delete ().  It was using void* to obtain nodes to\n- * pass to hash_remove ().  The value passed to hash_removed () is a\n+ * bug in hash_delete.  It was using void* to obtain nodes to\n+ * pass to hash_remove.  The value passed to hash_removed is a\n  * entry from the node structure rather than the node itself.  Using\n  * void* removed compiler checking.\n  * Modified to implement cache expansion.\n@@ -84,124 +85,120 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n */\n  \n \n-#include  <hash.h>\n-#include  <objc.h>\n-#include  <objcP.h>\n-#include  <objc-protoP.h>\n+#include \"config.h\"\n+#include \"hash.h\"\n+#include \"objc.h\"\n+#include \"objcP.h\"\n+#include \"objc-protoP.h\"\n \n-#include  <assert.h>\n-#include  <math.h>\n-#include  <stdio.h>\n-#include  <stdlib.h>\n+#include \"assert.h\"\n \n \n-                                                /* These two macros determine\n-                                                  when a hash table is full and\n-                                                  by how much it should be \n-                                                  expanded respectively.\n+/* These two macros determine when a hash table is full and\n+   by how much it should be expanded respectively.\n                                                   \n-                                                  These equations are \n-                                                  percentages. */\n+   These equations are percentages.  */\n #define FULLNESS(cache) \\\n-   ((((cache)->sizeOfHash * 75  ) / 100) <= (cache)->entriesInHash)\n+   ((((cache)->sizeOfHash * 75) / 100) <= (cache)->entriesInHash)\n #define EXPANSION(cache) \\\n-  ((cache)->sizeOfHash * 2 )\n+  ((cache)->sizeOfHash * 2)\n \n Cache_t \n-hash_new (u_int sizeOfHash, HashFunc aHashFunc, CompareFunc aCompareFunc) {\n-\n+hash_new (u_int sizeOfHash, HashFunc aHashFunc, CompareFunc aCompareFunc)\n+{\n   Cache_t retCache;\n-  \n \n-  /* Pass me a value greater than 0 and a power of 2. */\n-  assert(sizeOfHash);\n-  assert( !(sizeOfHash & (sizeOfHash - 1)));\n+\n+  /* Pass me a value greater than 0 and a power of 2.  */\n+  assert (sizeOfHash);\n+  assert (!(sizeOfHash & (sizeOfHash - 1)));\n   \n-  /* Allocate the cache structure.  calloc () insures\n-     its initialization for default values. */\n-  retCache = calloc (1, sizeof (Cache));\n-  assert(retCache);\n+  /* Allocate the cache structure.  calloc insures\n+     its initialization for default values.  */\n+  retCache = (Cache_t) calloc (1, sizeof (Cache));\n+  assert (retCache);\n   \n   /* Allocate the array of buckets for the cache.  \n-     calloc() initializes all of the pointers to NULL. */\n-  retCache->theNodeTable = calloc (sizeOfHash, sizeof (CacheNode_t));\n-  assert(retCache->theNodeTable);\n+     calloc initializes all of the pointers to NULL.  */\n+  retCache->theNodeTable\n+    = (CacheNode_t *) calloc (sizeOfHash, sizeof (CacheNode_t));\n+  assert (retCache->theNodeTable);\n   \n   retCache->sizeOfHash  = sizeOfHash;\n \n   /* This should work for all processor architectures? */\n-  retCache->mask = ( sizeOfHash - 1 );\n+  retCache->mask = (sizeOfHash - 1);\n \t\n-  /* Store the hashing function so that codes can be computed. */\n+  /* Store the hashing function so that codes can be computed.  */\n   retCache->hashFunc = aHashFunc;\n \n   /* Store the function that compares hash keys to \n-     determine if they are equal. */\n+     determine if they are equal.  */\n   retCache->compareFunc = aCompareFunc;\n \n   return retCache;\n }\n \n \n void \n-hash_delete (Cache_t theCache) {\n-\n+hash_delete (Cache_t theCache)\n+{\n   CacheNode_t aNode;\n-  \n \n-  /* Purge all key/value pairs from the table. */\n+\n+  /* Purge all key/value pairs from the table.  */\n   while (aNode = hash_next (theCache, NULL))\n     hash_remove (theCache, aNode->theKey);\n \n-  /* Release the array of nodes and the cache itself. */\n+  /* Release the array of nodes and the cache itself.  */\n   free (theCache->theNodeTable);\n   free (theCache);\n }\n \n \n void \n-hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n-\n-  u_int       indx = (* (*theCache)->hashFunc)(*theCache, aKey);\n-  CacheNode_t aCacheNode = calloc (1, sizeof (CacheNode));\n+hash_add (Cache_t *theCache, void *aKey, void *aValue)\n+{\n+  u_int       indx = (*(*theCache)->hashFunc)(*theCache, aKey);\n+  CacheNode_t aCacheNode = (CacheNode_t) calloc (1, sizeof (CacheNode));\n \n \n-  assert(aCacheNode);\n+  assert (aCacheNode);\n   \n-  /* Initialize the new node. */\n+  /* Initialize the new node.  */\n   aCacheNode->theKey    = aKey;\n   aCacheNode->theValue  = aValue;\n-  aCacheNode->nextNode  = (* (*theCache)->theNodeTable)[ indx ];\n+  aCacheNode->nextNode  = (*(*theCache)->theNodeTable) [indx];\n   \n   /* Debugging.\n-     Check the list for another key. */\n+     Check the list for another key.  */\n #ifdef DEBUG\n-    { CacheNode_t checkHashNode = (* (*theCache)->theNodeTable)[ indx ];\n+  { CacheNode_t checkHashNode = (*(*theCache)->theNodeTable) [indx];\n     \n-      while (checkHashNode) {\n+    while (checkHashNode) {\n     \n-        assert(checkHashNode->theKey != aKey);\n-        checkHashNode = checkHashNode->nextNode;\n-      }\n+      assert (checkHashNode->theKey != aKey);\n+      checkHashNode = checkHashNode->nextNode;\n     }\n+  }\n #endif\n \n-  /* Install the node as the first element on the list. */\n-  (* (*theCache)->theNodeTable)[ indx ] = aCacheNode;\n+  /* Install the node as the first element on the list.  */\n+  (*(*theCache)->theNodeTable) [indx] = aCacheNode;\n \n-  /* Bump the number of entries in the cache. */\n-  ++ (*theCache)->entriesInHash;\n+  /* Bump the number of entries in the cache.  */\n+  ++(*theCache)->entriesInHash;\n   \n   /* Check the hash table's fullness.   We're going\n-     to expand if it is above the fullness level. */\n+     to expand if it is above the fullness level.  */\n   if (FULLNESS (*theCache)) {\n     \n     /* The hash table has reached its fullness level.  Time to\n        expand it. \n-                                                  \n+       \n        I'm using a slow method here but is built on other\n        primitive functions thereby increasing its \n-       correctness. */\n+       correctness.  */\n     CacheNode_t aNode = NULL;\n     Cache_t     newCache = hash_new (EXPANSION (*theCache), \n \t\t\t\t     (*theCache)->hashFunc, \n@@ -210,36 +207,36 @@ hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n     DEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n \t\t  *theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n       \n-    /* Copy the nodes from the first hash table to the new one. */\n+    /* Copy the nodes from the first hash table to the new one.  */\n     while (aNode = hash_next (*theCache, aNode))\n       hash_add (&newCache, aNode->theKey, aNode->theValue);\n \n-    /* Trash the old cache. */\n+    /* Trash the old cache.  */\n     hash_delete (*theCache);\n     \n-    /* Return a pointer to the new hash table. */\n+    /* Return a pointer to the new hash table.  */\n     *theCache = newCache;\n   }\n }\n \n \n void \n-hash_remove (Cache_t theCache, void* aKey) {\n-\n+hash_remove (Cache_t theCache, void *aKey)\n+{\n   u_int       indx = (*theCache->hashFunc)(theCache, aKey);\n-  CacheNode_t aCacheNode = (*theCache->theNodeTable)[ indx ];\n+  CacheNode_t aCacheNode = (*theCache->theNodeTable) [indx];\n   \n   \n-  /* We assume there is an entry in the table.  Error if it is not. */\n-  assert(aCacheNode);\n+  /* We assume there is an entry in the table.  Error if it is not.  */\n+  assert (aCacheNode);\n   \n-  /* Special case.  First element is the key/value pair to be removed. */\n+  /* Special case.  First element is the key/value pair to be removed.  */\n   if ((*theCache->compareFunc)(aCacheNode->theKey, aKey)) {\n-    (*theCache->theNodeTable)[ indx ] = aCacheNode->nextNode;\n+    (*theCache->theNodeTable) [indx] = aCacheNode->nextNode;\n     free (aCacheNode);\n   } else {\n \n-    /* Otherwise, find the hash entry. */\n+    /* Otherwise, find the hash entry.  */\n     CacheNode_t prevHashNode = aCacheNode;\n     BOOL        removed = NO;\n     \n@@ -251,47 +248,47 @@ hash_remove (Cache_t theCache, void* aKey) {\n       } else\n         prevHashNode = aCacheNode, aCacheNode = aCacheNode->nextNode;\n     } while (!removed && aCacheNode);\n-    assert(removed);\n+    assert (removed);\n   }\n   \n-  /* Decrement the number of entries in the hash table. */\n+  /* Decrement the number of entries in the hash table.  */\n   --theCache->entriesInHash;\n }\n \n \n CacheNode_t \n-hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n-\n+hash_next (Cache_t theCache, CacheNode_t aCacheNode)\n+{\n   CacheNode_t theCacheNode = aCacheNode;\n-  \n-  \n+\n+\n   /* If the scan is being started then reset the last node \n-     visitied pointer and bucket index. */\n+     visitied pointer and bucket index.  */\n   if (!theCacheNode)\n     theCache->lastBucket  = 0;\n   \n   /* If there is a node visited last then check for another \n-     entry in the same bucket;  Otherwise step to the next bucket. */\n+     entry in the same bucket;  Otherwise step to the next bucket.  */\n   if (theCacheNode)\n     if (theCacheNode->nextNode)\n       /* There is a node which follows the last node \n-\t returned.  Step to that node and retun it. */\n+\t returned.  Step to that node and retun it.  */\n       return theCacheNode->nextNode;\n     else\n       ++theCache->lastBucket;\n \n   /* If the list isn't exhausted then search the buckets for \n-     other nodes. */\n+     other nodes.  */\n   if (theCache->lastBucket < theCache->sizeOfHash) {\n     /*  Scan the remainder of the buckets looking for an entry\n-\tat the head of the list.  Return the first item found. */\n+\tat the head of the list.  Return the first item found.  */\n     while (theCache->lastBucket < theCache->sizeOfHash)\n-      if ((*theCache->theNodeTable)[ theCache->lastBucket ])\n-        return (*theCache->theNodeTable)[ theCache->lastBucket ];\n+      if ((*theCache->theNodeTable) [theCache->lastBucket])\n+        return (*theCache->theNodeTable) [theCache->lastBucket];\n       else\n         ++theCache->lastBucket;\n   \n-    /* No further nodes were found in the hash table. */\n+    /* No further nodes were found in the hash table.  */\n     return NULL;\n   } else\n     return NULL;\n@@ -302,12 +299,12 @@ hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n  * Given key, return its value.  Return NULL if the\n  * key/value pair isn't in the hash. \n  */\n-void* \n-hash_value_for_key (Cache_t theCache, void* aKey) {\n-\n-  CacheNode_t aCacheNode = \n-    (*theCache->theNodeTable)[(*theCache->hashFunc)(theCache, aKey)];\n-  void*       retVal = NULL;\n+void *\n+hash_value_for_key (Cache_t theCache, void *aKey)\n+{\n+  CacheNode_t aCacheNode\n+    =  (*theCache->theNodeTable) [(*theCache->hashFunc)(theCache, aKey)];\n+  void        *retVal = NULL;\n   \n \n   if (aCacheNode)"}]}