{"sha": "10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmMDQ5MTdhYmJjNDJlMzcxN2QzM2Q5YjUwNzlhYTRmOWViOWFjNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-17T16:07:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-17T16:07:19Z"}, "message": "[PATCH] Macro body is trailing array\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg01037.html\n\t* include/cpplib.h (enum cpp_macro_kind): New.\n\t(struct cpp_macro): Make body trailing array.  Add kind field,\n\tdelete traditional flag.\n\t* internal.h (_cpp_new_macro): Declare.\n\t(_cpp_reserve_room): New inline.\n\t(_cpp_commit_buf): Declare.\n\t(_cpp_create_trad_definition): Return new macro.\n\t* lex.c (_cpp_commit_buff): New.\n\t* macro.c (macro_real_token_count): Count backwards.\n\t(replace_args): Pointer equality not orderedness.\n\t(_cpp_save_parameter): Use _cpp_reserve_room.\n\t(alloc_expansion_token): Delete.\n\t(lex_expansion_token): Return macro pointer.  Use _cpp_reserve_room.\n\t(create_iso_definition): Allocate macro itself.  Adjust for\n\tdifferent allocation ordering.\n\t(_cpp_new_macro): New.\n\t(_cpp_create_definition): Adjust for API changes.\n\t* traditional.c (push_replacement_text): Don't set traditional\n\tflag.\n\t(save_replacement_text): Likewise.\n\t(_cpp_create_trad_definition): Allocate macro itself, Adjust for\n\tdifferent allocation ordering.\n\nFrom-SVN: r263622", "tree": {"sha": "d1b399c099142510b8abea59d95c27a5dd4ecf58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1b399c099142510b8abea59d95c27a5dd4ecf58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5d725c0a8da3b2227d119871e881d8a6e1bf600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d725c0a8da3b2227d119871e881d8a6e1bf600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d725c0a8da3b2227d119871e881d8a6e1bf600"}], "stats": {"total": 388, "additions": 225, "deletions": 163}, "files": [{"sha": "6ad2fe0122d3a125e059156e68b69d2a385de183", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -1,5 +1,7 @@\n 2018-08-17  Nathan Sidwell  <nathan@acm.org>\n \n+\t* c-ada-spec.c (macro_length, dump_ada_macros): Constify.\n+\n \t* c-ada-spec.c: Don't #include \"cpp-id-data.h\"\n \t* c-cppbuiltin.c: Likewise.\n "}, {"sha": "4b21d71345af1f21d303fd447804cca91fae913b", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -88,7 +88,7 @@ macro_length (const cpp_macro *macro, int *supported, int *buffer_len,\n \n   for (j = 0; j < macro->count; j++)\n     {\n-      cpp_token *token = &macro->exp.tokens[j];\n+      const cpp_token *token = &macro->exp.tokens[j];\n \n       if (token->flags & PREV_WHITE)\n \t(*buffer_len)++;\n@@ -274,7 +274,7 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \n \t  for (i = 0; supported && i < macro->count; i++)\n \t    {\n-\t      cpp_token *token = &macro->exp.tokens[i];\n+\t      const cpp_token *token = &macro->exp.tokens[i];\n \t      int is_one = 0;\n \n \t      if (token->flags & PREV_WHITE)"}, {"sha": "c79866f502a0dbbe029c763fd520dc81a2ef342d", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -1,5 +1,28 @@\n 2018-08-17  Nathan Sidwell  <nathan@acm.org>\n \n+\t* include/cpplib.h (enum cpp_macro_kind): New.\n+\t(struct cpp_macro): Make body trailing array.  Add kind field,\n+\tdelete traditional flag.\n+\t* internal.h (_cpp_new_macro): Declare.\n+\t(_cpp_reserve_room): New inline.\n+\t(_cpp_commit_buf): Declare.\n+\t(_cpp_create_trad_definition): Return new macro.\n+\t* lex.c (_cpp_commit_buff): New.\n+\t* macro.c (macro_real_token_count): Count backwards.\n+\t(replace_args): Pointer equality not orderedness.\n+\t(_cpp_save_parameter): Use _cpp_reserve_room.\n+\t(alloc_expansion_token): Delete.\n+\t(lex_expansion_token): Return macro pointer.  Use _cpp_reserve_room.\n+\t(create_iso_definition): Allocate macro itself.  Adjust for\n+\tdifferent allocation ordering.\n+\t(_cpp_new_macro): New.\n+\t(_cpp_create_definition): Adjust for API changes.\n+\t* traditional.c (push_replacement_text): Don't set traditional\n+\tflag.\n+\t(save_replacement_text): Likewise.\n+\t(_cpp_create_trad_definition): Allocate macro itself, Adjust for\n+\tdifferent allocation ordering.\n+\n \t* cpp-id-data.h (uchar, UC): Move to internal.h\n \t(struct cpp_macro): Move to cpplib.h.\n \t* internal.h (uchar, UC): From cpp-id-data.h."}, {"sha": "a0d0c53c0902a1dc3cb3afa224900a3c6592af1e", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -671,6 +671,12 @@ struct cpp_dir\n   dev_t dev;\n };\n \n+/* The kind of the cpp_macro.  */\n+enum cpp_macro_kind {\n+  cmk_macro,\t/* An ISO macro (token expansion).  */\n+  cmk_traditional,\t/* A traditional macro (text expansion).  */\n+};\n+\n /* Each macro definition is recorded in a cpp_macro structure.\n    Variadic macros cannot occur with traditional cpp.  */\n struct GTY(()) cpp_macro {\n@@ -683,15 +689,6 @@ struct GTY(()) cpp_macro {\n \t\t\tlength (\"%h.paramc\")))\n     params;\n \n-  /* Replacement tokens (ISO) or replacement text (traditional).  See\n-     comment at top of cpptrad.c for how traditional function-like\n-     macros are encoded.  */\n-  union cpp_macro_u\n-  {\n-    cpp_token * GTY ((tag (\"0\"), length (\"%0.count\"))) tokens;\n-    const unsigned char * GTY ((tag (\"1\"))) text;\n-  } GTY ((desc (\"%1.traditional\"))) exp;\n-\n   /* Definition line number.  */\n   source_location line;\n \n@@ -701,6 +698,9 @@ struct GTY(()) cpp_macro {\n   /* Number of parameters.  */\n   unsigned short paramc;\n \n+  /* The kind of this macro (ISO, trad or assert) */\n+  unsigned kind : 2;\n+\n   /* If a function-like macro.  */\n   unsigned int fun_like : 1;\n \n@@ -713,13 +713,23 @@ struct GTY(()) cpp_macro {\n   /* Nonzero if it has been expanded or had its existence tested.  */\n   unsigned int used     : 1;\n \n-  /* Indicate which field of 'exp' is in use.  */\n-  unsigned int traditional : 1;\n-\n   /* Indicate whether the tokens include extra CPP_PASTE tokens at the\n      end to track invalid redefinitions with consecutive CPP_PASTE\n      tokens.  */\n   unsigned int extra_tokens : 1;\n+\n+  /* 1 bits spare (32-bit). 33 on 64-bit target.  */\n+\n+  union cpp_exp_u\n+  {\n+    /* Trailing array of replacement tokens (ISO), or assertion body value.  */\n+    cpp_token GTY ((tag (\"false\"), length (\"%1.count\"))) tokens[1];\n+\n+    /* Pointer to replacement text (traditional).  See comment at top\n+       of cpptrad.c for how traditional function-like macros are\n+       encoded.  */\n+    const unsigned char *GTY ((tag (\"true\"))) text;\n+  } GTY ((desc (\"%1.kind == cmk_traditional\"))) exp;\n };\n \n /* The structure of a node in the hash table.  The hash table has"}, {"sha": "e40b20f267ce74944844205aa4d633dfc3ebec37", "filename": "libcpp/internal.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -633,6 +633,7 @@ inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n   if (!(node->flags & NODE_USED))\n     _cpp_notify_macro_use (pfile, node);\n }\n+extern cpp_macro *_cpp_new_macro (cpp_reader *, cpp_macro_kind, void *);\n extern void _cpp_free_definition (cpp_hashnode *);\n extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);\n extern void _cpp_pop_context (cpp_reader *);\n@@ -697,6 +698,14 @@ extern void _cpp_init_tokenrun (tokenrun *, unsigned int);\n extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);\n extern int _cpp_remaining_tokens_num_in_context (cpp_context *);\n extern void _cpp_init_lexer (void);\n+static inline void *_cpp_reserve_room (cpp_reader *pfile, size_t have,\n+\t\t\t\t       size_t extra)\n+{\n+  if (BUFF_ROOM (pfile->a_buff) < (have + extra))\n+    _cpp_extend_buff (pfile, &pfile->a_buff, extra);\n+  return BUFF_FRONT (pfile->a_buff);\n+}\n+extern void *_cpp_commit_buff (cpp_reader *pfile, size_t size);\n \n /* In init.c.  */\n extern void _cpp_maybe_push_include_file (cpp_reader *);\n@@ -733,7 +742,7 @@ extern bool _cpp_read_logical_line_trad (cpp_reader *);\n extern void _cpp_overlay_buffer (cpp_reader *pfile, const unsigned char *,\n \t\t\t\t size_t);\n extern void _cpp_remove_overlay (cpp_reader *);\n-extern bool _cpp_create_trad_definition (cpp_reader *, cpp_macro *);\n+extern cpp_macro *_cpp_create_trad_definition (cpp_reader *);\n extern bool _cpp_expansions_different_trad (const cpp_macro *,\n \t\t\t\t\t    const cpp_macro *);\n extern unsigned char *_cpp_copy_replacement_text (const cpp_macro *,"}, {"sha": "892cfc4494de592df4e1ade5d0cf4c02ee345b01", "filename": "libcpp/lex.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -3725,6 +3725,25 @@ _cpp_aligned_alloc (cpp_reader *pfile, size_t len)\n   return result;\n }\n \n+/* Commit or allocate storage from a buffer.  */\n+\n+void *\n+_cpp_commit_buff (cpp_reader *pfile, size_t size)\n+{\n+  void *ptr = BUFF_FRONT (pfile->a_buff);\n+\n+  if (pfile->hash_table->alloc_subobject)\n+    {\n+      void *copy = pfile->hash_table->alloc_subobject (size);\n+      memcpy (copy, ptr, size);\n+      ptr = copy;\n+    }\n+  else\n+    BUFF_FRONT (pfile->a_buff) += size;\n+\n+  return ptr;\n+}\n+\n /* Say which field of TOK is in use.  */\n \n enum cpp_token_fld_kind"}, {"sha": "25f4a361189d13b55f0bd2e31b48758b973dc2c7", "filename": "libcpp/macro.c", "status": "modified", "additions": 117, "deletions": 119, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -308,12 +308,11 @@ static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,\n \t\t\t  macro_arg *, source_location);\n static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,\n \t\t\t\t\t_cpp_buff **, unsigned *);\n-static bool create_iso_definition (cpp_reader *, cpp_macro *);\n+static cpp_macro *create_iso_definition (cpp_reader *);\n \n /* #define directive parsing and handling.  */\n \n-static cpp_token *alloc_expansion_token (cpp_reader *, cpp_macro *);\n-static cpp_token *lex_expansion_token (cpp_reader *, cpp_macro *);\n+static cpp_macro *lex_expansion_token (cpp_reader *, cpp_macro *);\n static bool warn_of_redefinition (cpp_reader *, cpp_hashnode *,\n \t\t\t\t  const cpp_macro *);\n static bool parse_params (cpp_reader *, unsigned *, bool *);\n@@ -1235,13 +1234,14 @@ funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,\n static inline unsigned int\n macro_real_token_count (const cpp_macro *macro)\n {\n-  unsigned int i;\n   if (__builtin_expect (!macro->extra_tokens, true))\n     return macro->count;\n-  for (i = 0; i < macro->count; i++)\n-    if (macro->exp.tokens[i].type == CPP_PASTE)\n-      return i;\n-  abort ();\n+\n+  for (unsigned i = macro->count; i--;)\n+    if (macro->exp.tokens[i].type != CPP_PASTE)\n+      return i + 1;\n+\n+  return 0;\n }\n \n /* Push the context of a macro with hash entry NODE onto the context\n@@ -1773,7 +1773,7 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro,\n \t      arg->stringified = stringify_arg (pfile, arg);\n \t  }\n \telse if ((src->flags & PASTE_LEFT)\n-\t\t || (src > macro->exp.tokens && (src[-1].flags & PASTE_LEFT)))\n+\t\t || (src != macro->exp.tokens && (src[-1].flags & PASTE_LEFT)))\n \t  total += arg->count - 1;\n \telse\n \t  {\n@@ -3078,10 +3078,9 @@ _cpp_save_parameter (cpp_reader *pfile, unsigned n, cpp_hashnode *node,\n   saved[n].canonical_node = node;\n   saved[n].value = node->value;\n \n-  if (BUFF_ROOM (pfile->a_buff) < (n + 1) * sizeof (cpp_hashnode *))\n-    _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_hashnode *));\n-\n-  ((cpp_hashnode **) BUFF_FRONT (pfile->a_buff))[n] = spelling;\n+  void *base = _cpp_reserve_room (pfile, n * sizeof (cpp_hashnode *),\n+\t\t\t\t  sizeof (cpp_hashnode *));\n+  ((cpp_hashnode **)base)[n] = spelling;\n \n   /* Morph into a macro arg.  */\n   node->flags |= NODE_MACRO_ARG;\n@@ -3226,26 +3225,18 @@ parse_params (cpp_reader *pfile, unsigned *n_ptr, bool *varadic_ptr)\n   return ok;\n }\n \n-/* Allocate room for a token from a macro's replacement list.  */\n-static cpp_token *\n-alloc_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n-{\n-  if (BUFF_ROOM (pfile->a_buff) < (macro->count + 1) * sizeof (cpp_token))\n-    _cpp_extend_buff (pfile, &pfile->a_buff, sizeof (cpp_token));\n-\n-  return &((cpp_token *) BUFF_FRONT (pfile->a_buff))[macro->count++];\n-}\n-\n /* Lex a token from the expansion of MACRO, but mark parameters as we\n    find them and warn of traditional stringification.  */\n-static cpp_token *\n+static cpp_macro *\n lex_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n {\n-  cpp_token *token, *saved_cur_token;\n-\n-  saved_cur_token = pfile->cur_token;\n-  pfile->cur_token = alloc_expansion_token (pfile, macro);\n-  token = _cpp_lex_direct (pfile);\n+  macro = (cpp_macro *)_cpp_reserve_room (pfile,\n+\t\t\t\t\t  sizeof (cpp_macro) - sizeof (cpp_token)\n+\t\t\t\t\t  + macro->count * sizeof (cpp_token),\n+\t\t\t\t\t  sizeof (cpp_token));\n+  cpp_token *saved_cur_token = pfile->cur_token;\n+  pfile->cur_token = &macro->exp.tokens[macro->count];\n+  cpp_token *token = _cpp_lex_direct (pfile);\n   pfile->cur_token = saved_cur_token;\n \n   /* Is this a parameter?  */\n@@ -3261,52 +3252,45 @@ lex_expansion_token (cpp_reader *pfile, cpp_macro *macro)\n \t   && (token->type == CPP_STRING || token->type == CPP_CHAR))\n     check_trad_stringification (pfile, macro, &token->val.str);\n \n-  return token;\n+  return macro;\n }\n \n-static bool\n-create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n+static cpp_macro *\n+create_iso_definition (cpp_reader *pfile)\n {\n-  cpp_token *token;\n-  const cpp_token *ctoken;\n   bool following_paste_op = false;\n   const char *paste_op_error_msg =\n     N_(\"'##' cannot appear at either end of a macro expansion\");\n   unsigned int num_extra_tokens = 0;\n   unsigned nparms = 0;\n+  cpp_hashnode **params = NULL;\n   bool varadic = false;\n   bool ok = false;\n+  cpp_macro *macro = NULL;\n \n-  /* Get the first token of the expansion (or the '(' of a\n-     function-like macro).  */\n-  ctoken = _cpp_lex_token (pfile);\n+  /* Look at the first token, to see if this is a function-like\n+     macro.   */\n+  cpp_token first;\n+  cpp_token *saved_cur_token = pfile->cur_token;\n+  pfile->cur_token = &first;\n+  cpp_token *token = _cpp_lex_direct (pfile);\n+  pfile->cur_token = saved_cur_token;\n \n-  if (ctoken->flags & PREV_WHITE)\n+  if (token->flags & PREV_WHITE)\n     /* Preceeded by space, must be part of expansion.  */;\n-  else if (ctoken->type == CPP_OPEN_PAREN)\n+  else if (token->type == CPP_OPEN_PAREN)\n     {\n       /* An open-paren, get a parameter list.  */\n       if (!parse_params (pfile, &nparms, &varadic))\n \tgoto out;\n-      macro->variadic = varadic;\n-      macro->paramc = nparms;\n-      macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n \n-      /* Success.  Commit or allocate the parameter array.  */\n-      if (pfile->hash_table->alloc_subobject)\n-\t{\n-\t  cpp_hashnode **params =\n-            (cpp_hashnode **) pfile->hash_table->alloc_subobject\n-            (sizeof (cpp_hashnode *) * macro->paramc);\n-\t  memcpy (params, macro->params,\n-\t\t  sizeof (cpp_hashnode *) * macro->paramc);\n-\t  macro->params = params;\n-\t}\n-      else\n-\tBUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n-      macro->fun_like = 1;\n+      params = (cpp_hashnode **)_cpp_commit_buff\n+\t(pfile, sizeof (cpp_hashnode *) * nparms);\n+      token = NULL;\n     }\n-  else if (ctoken->type != CPP_EOF && !(ctoken->flags & PREV_WHITE))\n+  else if (token->type != CPP_EOF\n+\t   && !(token->type == CPP_COMMENT\n+\t\t&& ! CPP_OPTION (pfile, discard_comments_in_macro_exp)))\n     {\n       /* While ISO C99 requires whitespace before replacement text\n \t in a macro definition, ISO C90 with TC1 allows characters\n@@ -3319,7 +3303,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n       else\n \t{\n \t  int warntype = CPP_DL_WARNING;\n-\t  switch (ctoken->type)\n+\t  switch (token->type)\n \t    {\n \t    case CPP_ATSIGN:\n \t    case CPP_AT_NAME:\n@@ -3330,7 +3314,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t    case CPP_OTHER:\n \t      /* Basic character set sans letters, digits and _.  */\n \t      if (strchr (\"!\\\"#%&'()*+,-./:;<=>?[\\\\]^{|}~\",\n-\t\t\t  ctoken->val.str.text[0]) == NULL)\n+\t\t\t  token->val.str.text[0]) == NULL)\n \t\twarntype = CPP_DL_PEDWARN;\n \t      break;\n \t    default:\n@@ -3343,16 +3327,32 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t}\n     }\n \n-  if (macro->fun_like)\n-    token = lex_expansion_token (pfile, macro);\n+  macro = _cpp_new_macro (pfile, cmk_macro,\n+\t\t\t  _cpp_reserve_room (pfile, 0, sizeof (cpp_macro)));\n+\n+  if (!token)\n+    {\n+      macro->variadic = varadic;\n+      macro->paramc = nparms;\n+      macro->params = params;\n+      macro->fun_like = true;\n+    }\n   else\n     {\n-      token = alloc_expansion_token (pfile, macro);\n-      *token = *ctoken;\n+      /* Preserve the token we peeked, there is already a single slot for it.  */\n+      macro->exp.tokens[0] = *token;\n+      token = &macro->exp.tokens[0];\n+      macro->count = 1;\n     }\n \n-  for (  vaopt_state vaopt_tracker (pfile, macro->variadic, true);;)\n+  for (vaopt_state vaopt_tracker (pfile, macro->variadic, true);; token = NULL)\n     {\n+      if (!token)\n+\t{\n+\t  macro = lex_expansion_token (pfile, macro);\n+\t  token = &macro->exp.tokens[macro->count++];\n+\t}\n+\n       /* Check the stringifying # constraint 6.10.3.2.1 of\n \t function-like macros when lexing the subsequent token.  */\n       if (macro->count > 1 && token[-1].type == CPP_HASH && macro->fun_like)\n@@ -3404,94 +3404,81 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n \t      goto out;\n \t    }\n \n-\t  if (token[-1].flags & PASTE_LEFT)\n+\t  if (following_paste_op)\n \t    {\n-\t      macro->extra_tokens = 1;\n+\t      /* Consecutive paste operators.  This one will be moved\n+\t\t to the end.  */\n \t      num_extra_tokens++;\n \t      token->val.token_no = macro->count - 1;\n \t    }\n \t  else\n \t    {\n+\t      /* Drop the paste operator.  */\n \t      --macro->count;\n \t      token[-1].flags |= PASTE_LEFT;\n \t      if (token->flags & DIGRAPH)\n \t\ttoken[-1].flags |= SP_DIGRAPH;\n \t      if (token->flags & PREV_WHITE)\n \t\ttoken[-1].flags |= SP_PREV_WHITE;\n \t    }\n+\t  following_paste_op = true;\n \t}\n+      else\n+\tfollowing_paste_op = false;\n \n       if (vaopt_tracker.update (token) == vaopt_state::ERROR)\n \tgoto out;\n-\n-      following_paste_op = (token->type == CPP_PASTE);\n-      token = lex_expansion_token (pfile, macro);\n     }\n \n   /* We're committed to winning now.  */\n   ok = true;\n \n-  macro->exp.tokens = (cpp_token *) BUFF_FRONT (pfile->a_buff);\n-  macro->traditional = 0;\n-\n   /* Don't count the CPP_EOF.  */\n   macro->count--;\n \n+  macro = (cpp_macro *)_cpp_commit_buff\n+    (pfile, sizeof (cpp_macro) - sizeof (cpp_token)\n+     + sizeof (cpp_token) * macro->count);\n+\n   /* Clear whitespace on first token for warn_of_redefinition().  */\n   if (macro->count)\n     macro->exp.tokens[0].flags &= ~PREV_WHITE;\n \n-  /* Commit or allocate the memory.  */\n-  if (pfile->hash_table->alloc_subobject)\n+  if (num_extra_tokens)\n     {\n-      cpp_token *tokns =\n-        (cpp_token *) pfile->hash_table->alloc_subobject (sizeof (cpp_token)\n-                                                          * macro->count);\n-      if (num_extra_tokens)\n-\t{\n-\t  /* Place second and subsequent ## or %:%: tokens in\n-\t     sequences of consecutive such tokens at the end of the\n-\t     list to preserve information about where they appear, how\n-\t     they are spelt and whether they are preceded by\n-\t     whitespace without otherwise interfering with macro\n-\t     expansion.  */\n-\t  cpp_token *normal_dest = tokns;\n-\t  cpp_token *extra_dest = tokns + macro->count - num_extra_tokens;\n-\t  unsigned int i;\n-\t  for (i = 0; i < macro->count; i++)\n-\t    {\n-\t      if (macro->exp.tokens[i].type == CPP_PASTE)\n-\t\t*extra_dest++ = macro->exp.tokens[i];\n-\t      else\n-\t\t*normal_dest++ = macro->exp.tokens[i];\n-\t    }\n-\t}\n-      else\n-\tmemcpy (tokns, macro->exp.tokens, sizeof (cpp_token) * macro->count);\n-      macro->exp.tokens = tokns;\n+      /* Place second and subsequent ## or %:%: tokens in sequences of\n+\t consecutive such tokens at the end of the list to preserve\n+\t information about where they appear, how they are spelt and\n+\t whether they are preceded by whitespace without otherwise\n+\t interfering with macro expansion.   Remember, this is\n+\t extremely rare, so efficiency is not a priority.  */\n+      cpp_token *temp = (cpp_token *)_cpp_reserve_room\n+\t(pfile, 0, num_extra_tokens * sizeof (cpp_token));\n+      unsigned extra_ix = 0, norm_ix = 0;\n+      cpp_token *exp = macro->exp.tokens;\n+      for (unsigned ix = 0; ix != macro->count; ix++)\n+\tif (exp[ix].type == CPP_PASTE)\n+\t  temp[extra_ix++] = exp[ix];\n+\telse\n+\t  exp[norm_ix++] = exp[ix];\n+      memcpy (&exp[norm_ix], temp, num_extra_tokens * sizeof (cpp_token));\n+\n+      /* Record there are extra tokens.  */\n+      macro->extra_tokens = 1;\n     }\n-  else\n-    BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->exp.tokens[macro->count];\n \n  out:\n   pfile->state.va_args_ok = 0;\n   _cpp_unsave_parameters (pfile, nparms);\n \n-  return ok;\n+  return ok ? macro : NULL;\n }\n \n-/* Parse a macro and save its expansion.  Returns nonzero on success.  */\n-bool\n-_cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n+cpp_macro *\n+_cpp_new_macro (cpp_reader *pfile, cpp_macro_kind kind, void *placement)\n {\n-  cpp_macro *macro;\n-  bool ok;\n+  cpp_macro *macro = (cpp_macro *) placement;\n \n-  if (pfile->hash_table->alloc_subobject)\n-    macro = (cpp_macro *) pfile->hash_table->alloc_subobject\n-      (sizeof (cpp_macro));\n-  else\n-    macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n   macro->line = pfile->directive_line;\n   macro->params = 0;\n   macro->paramc = 0;\n@@ -3503,15 +3490,26 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   /* To suppress some diagnostics.  */\n   macro->syshdr = pfile->buffer && pfile->buffer->sysp != 0;\n \n+  macro->kind = kind;\n+\n+  return macro;\n+}\n+\n+/* Parse a macro and save its expansion.  Returns nonzero on success.  */\n+bool\n+_cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n+{\n+  cpp_macro *macro;\n+\n   if (CPP_OPTION (pfile, traditional))\n-    ok = _cpp_create_trad_definition (pfile, macro);\n+    macro = _cpp_create_trad_definition (pfile);\n   else\n-    ok = create_iso_definition (pfile, macro);\n+    macro = create_iso_definition (pfile);\n \n-  if (!ok)\n-    return ok;\n+  if (!macro)\n+    return false;\n \n-  if (node->type == NT_MACRO)\n+  if (cpp_macro_p (node))\n     {\n       if (CPP_OPTION (pfile, warn_unused_macros))\n \t_cpp_warn_if_unused_macro (pfile, node, NULL);\n@@ -3552,7 +3550,7 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n      conditional flag */\n   node->flags &= ~NODE_CONDITIONAL;\n \n-  return ok;\n+  return true;\n }\n \n /* Notify the use of NODE in a macro-aware context (i.e. expanding it,\n@@ -3678,7 +3676,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n       unsigned int count = macro_real_token_count (macro);\n       for (i = 0; i < count; i++)\n \t{\n-\t  cpp_token *token = &macro->exp.tokens[i];\n+\t  const cpp_token *token = &macro->exp.tokens[i];\n \n \t  if (token->type == CPP_MACRO_ARG)\n \t    len += NODE_LEN (token->val.macro_arg.spelling);\n@@ -3742,7 +3740,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n       unsigned int count = macro_real_token_count (macro);\n       for (i = 0; i < count; i++)\n \t{\n-\t  cpp_token *token = &macro->exp.tokens[i];\n+\t  const cpp_token *token = &macro->exp.tokens[i];\n \n \t  if (token->flags & PREV_WHITE)\n \t    *buffer++ = ' ';"}, {"sha": "3c3b8ac3f1a7a665c58c7a722b0d988c2aff44e6", "filename": "libcpp/traditional.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f04917abbc42e3717d33d9b5079aa4f9eb9ac5/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=10f04917abbc42e3717d33d9b5079aa4f9eb9ac5", "patch": "@@ -853,7 +853,6 @@ push_replacement_text (cpp_reader *pfile, cpp_hashnode *node)\n       cpp_macro *macro = node->value.macro;\n       macro->used = 1;\n       text = macro->exp.text;\n-      macro->traditional = 1;\n       len = macro->count;\n     }\n \n@@ -1143,7 +1142,6 @@ save_replacement_text (cpp_reader *pfile, cpp_macro *macro,\n       memcpy (exp, pfile->out.base, len);\n       exp[len] = '\\n';\n       macro->exp.text = exp;\n-      macro->traditional = 1;\n       macro->count = len;\n     }\n   else\n@@ -1159,7 +1157,6 @@ save_replacement_text (cpp_reader *pfile, cpp_macro *macro,\n       exp = BUFF_FRONT (pfile->a_buff);\n       block = (struct block *) (exp + macro->count);\n       macro->exp.text = exp;\n-      macro->traditional = 1;\n \n       /* Write out the block information.  */\n       block->text_len = len;\n@@ -1179,13 +1176,15 @@ save_replacement_text (cpp_reader *pfile, cpp_macro *macro,\n \n /* Analyze and save the replacement text of a macro.  Returns true on\n    success.  */\n-bool\n-_cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n+cpp_macro *\n+_cpp_create_trad_definition (cpp_reader *pfile)\n {\n   const uchar *cur;\n   uchar *limit;\n   cpp_context *context = pfile->context;\n   unsigned nparms = 0;\n+  int fun_like = 0;\n+  cpp_hashnode **params = NULL;\n \n   /* The context has not been set up for command line defines, and CUR\n      has not been updated for the macro name for in-file defines.  */\n@@ -1197,21 +1196,23 @@ _cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n   /* Is this a function-like macro?  */\n   if (* CUR (context) == '(')\n     {\n-      bool ok = scan_parameters (pfile, &nparms);\n-      macro->paramc = nparms;\n+      fun_like = +1;\n+      if (scan_parameters (pfile, &nparms))\n+\tparams = (cpp_hashnode **)_cpp_commit_buff\n+\t  (pfile, sizeof (cpp_hashnode *) * nparms);\n+      else\n+\tfun_like = -1;\n+    }\n \n-      /* Remember the params so we can clear NODE_MACRO_ARG flags.  */\n-      macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n+  cpp_macro *macro = NULL;\n \n-      /* Setting macro to NULL indicates an error occurred, and\n-\t prevents unnecessary work in _cpp_scan_out_logical_line.  */\n-      if (!ok)\n-\tmacro = NULL;\n-      else\n-\t{\n-\t  BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n-\t  macro->fun_like = 1;\n-\t}\n+  if (fun_like >= 0)\n+    {\n+      macro = _cpp_new_macro (pfile, cmk_traditional,\n+\t\t\t      _cpp_aligned_alloc (pfile, sizeof (cpp_macro)));\n+      macro->params = params;\n+      macro->paramc = nparms;\n+      macro->fun_like = fun_like != 0;\n     }\n \n   /* Skip leading whitespace in the replacement text.  */\n@@ -1225,18 +1226,18 @@ _cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n \n   _cpp_unsave_parameters (pfile, nparms);\n \n-  if (!macro)\n-    return false;\n-\n-  /* Skip trailing white space.  */\n-  cur = pfile->out.base;\n-  limit = pfile->out.cur;\n-  while (limit > cur && is_space (limit[-1]))\n-    limit--;\n-  pfile->out.cur = limit;\n-  save_replacement_text (pfile, macro, 0);\n+  if (macro)\n+    {\n+      /* Skip trailing white space.  */\n+      cur = pfile->out.base;\n+      limit = pfile->out.cur;\n+      while (limit > cur && is_space (limit[-1]))\n+\tlimit--;\n+      pfile->out.cur = limit;\n+      save_replacement_text (pfile, macro, 0);\n+    }\n \n-  return true;\n+  return macro;\n }\n \n /* Copy SRC of length LEN to DEST, but convert all contiguous"}]}