{"sha": "028299c6bf8e117d33b3e4e085c703b191e46327", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4Mjk5YzZiZjhlMTE3ZDMzYjNlNGUwODVjNzAzYjE5MWU0NjMyNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-01T09:01:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-01T09:01:10Z"}, "message": "Initial revision\n\nFrom-SVN: r2293", "tree": {"sha": "040a66fc22de97a3a04088c12c8d323f8da64e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/040a66fc22de97a3a04088c12c8d323f8da64e11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/028299c6bf8e117d33b3e4e085c703b191e46327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028299c6bf8e117d33b3e4e085c703b191e46327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028299c6bf8e117d33b3e4e085c703b191e46327", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028299c6bf8e117d33b3e4e085c703b191e46327/comments", "author": null, "committer": null, "parents": [{"sha": "1d9d04f8cedd05e5c2a645995cb49849cdc996b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d9d04f8cedd05e5c2a645995cb49849cdc996b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d9d04f8cedd05e5c2a645995cb49849cdc996b0"}], "stats": {"total": 2523, "additions": 2523, "deletions": 0}, "files": [{"sha": "b56c83099340be036a346c233906140f8809dce1", "filename": "gcc/c-parse.in", "status": "added", "additions": 2523, "deletions": 0, "changes": 2523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028299c6bf8e117d33b3e4e085c703b191e46327/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028299c6bf8e117d33b3e4e085c703b191e46327/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=028299c6bf8e117d33b3e4e085c703b191e46327", "patch": "@@ -0,0 +1,2523 @@\n+/* YACC parser for C syntax and for Objective C.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This file defines the grammar of C and that of Objective C.\n+   ifobjc ... end ifobjc  conditionals contain code for Objective C only.\n+   ifc ... end ifc  conditionals contain code for C only.\n+   The awk script cond.awk is used to convert this file into\n+   c-parse.y and into objc-parse.y.  */\n+\n+/* To whomever it may concern: I have heard that such a thing was once\n+written by AT&T, but I have never seen it.  */\n+\n+ifobjc\n+%expect 36\n+end ifobjc\n+ifc\n+%expect 8\n+\n+/* These are the 8 conflicts you should get in parse.output;\n+   the state numbers may vary if minor changes in the grammar are made.\n+\n+State 41 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 92 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 99 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 103 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 119 contains 1 shift/reduce conflict.  (See comment at component_decl.)\n+State 183 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 193 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+State 199 contains 1 shift/reduce conflict.  (Two ways to recover from error.)\n+*/\n+end ifc\n+\n+%{\n+#include <stdio.h>\n+#include <errno.h>\n+#include <setjmp.h>\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"input.h\"\n+#include \"c-lex.h\"\n+#include \"c-tree.h\"\n+#include \"flags.h\"\n+\n+#ifdef MULTIBYTE_CHARS\n+#include <stdlib.h>\n+#include <locale.h>\n+#endif\n+\n+ifobjc\n+#include \"objc-actions.h\"\n+end ifobjc\n+\n+#ifndef errno\n+extern int errno;\n+#endif\n+\n+void yyerror ();\n+\n+/* Like YYERROR but do call yyerror.  */\n+#define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n+\n+/* Cause the `yydebug' variable to be defined.  */\n+#define YYDEBUG 1\n+%}\n+\n+%start program\n+\n+%union {long itype; tree ttype; enum tree_code code;\n+\tchar *filename; int lineno; }\n+\n+/* All identifiers that are not reserved words\n+   and are not declared typedefs in the current block */\n+%token IDENTIFIER\n+\n+/* All identifiers that are declared typedefs in the current block.\n+   In some contexts, they are treated just like IDENTIFIER,\n+   but they can also serve as typespecs in declarations.  */\n+%token TYPENAME\n+\n+/* Reserved words that specify storage class.\n+   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n+%token SCSPEC\n+\n+/* Reserved words that specify type.\n+   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n+%token TYPESPEC\n+\n+/* Reserved words that qualify type: \"const\" or \"volatile\".\n+   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n+%token TYPE_QUAL\n+\n+/* Character or numeric constants.\n+   yylval is the node for the constant.  */\n+%token CONSTANT\n+\n+/* String constants in raw form.\n+   yylval is a STRING_CST node.  */\n+%token STRING\n+\n+/* \"...\", used for functions with variable arglists.  */\n+%token ELLIPSIS\n+\n+/* the reserved words */\n+/* SCO include files test \"ASM\", so use something else. */\n+%token SIZEOF ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n+%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF ALIGN\n+%token ATTRIBUTE EXTENSION LABEL\n+\n+/* Add precedence rules to solve dangling else s/r conflict */\n+%nonassoc IF\n+%nonassoc ELSE\n+\n+/* Define the operator tokens and their precedences.\n+   The value is an integer because, if used, it is the tree code\n+   to use in the expression made from the operator.  */\n+\n+%right <code> ASSIGN '='\n+%right <code> '?' ':'\n+%left <code> OROR\n+%left <code> ANDAND\n+%left <code> '|'\n+%left <code> '^'\n+%left <code> '&'\n+%left <code> EQCOMPARE\n+%left <code> ARITHCOMPARE\n+%left <code> LSHIFT RSHIFT\n+%left <code> '+' '-'\n+%left <code> '*' '/' '%'\n+%right <code> UNARY PLUSPLUS MINUSMINUS\n+%left HYPERUNARY\n+%left <code> POINTSAT '.' '(' '['\n+\n+/* The Objective-C keywords.  These are included in C and in\n+   Objective C, so that the token codes are the same in both.  */\n+%token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n+%token CLASSNAME PUBLIC\n+\n+\n+%type <code> unop\n+\n+%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n+%type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n+%type <ttype> typed_declspecs reserved_declspecs\n+%type <ttype> typed_typespecs reserved_typespecquals\n+%type <ttype> declmods typespec typespecqual_reserved\n+%type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n+%type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n+%type <ttype> init initlist maybeasm\n+%type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n+%type <ttype> maybe_attribute attribute_list attrib\n+\n+%type <ttype> compstmt\n+\n+%type <ttype> declarator\n+%type <ttype> notype_declarator after_type_declarator\n+%type <ttype> parm_declarator\n+\n+%type <ttype> structsp component_decl_list component_decl_list2\n+%type <ttype> component_decl components component_declarator\n+%type <ttype> enumlist enumerator\n+%type <ttype> typename absdcl absdcl1 type_quals\n+%type <ttype> xexpr parms parm identifiers\n+\n+%type <ttype> parmlist parmlist_1 parmlist_2\n+%type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n+%type <ttype> identifiers_or_typenames\n+\n+%type <itype> setspecs\n+\n+%type <filename> save_filename\n+%type <lineno> save_lineno\n+\f\n+ifobjc\n+/* the Objective-C nonterminals */\n+\n+%type <ttype> ivar_decl_list ivar_decls ivar_decl ivars ivar_declarator\n+%type <ttype> methoddecl unaryselector keywordselector selector\n+%type <ttype> keyworddecl receiver objcmessageexpr messageargs\n+%type <ttype> keywordexpr keywordarglist keywordarg\n+%type <ttype> myparms myparm optparmlist reservedwords objcselectorexpr\n+%type <ttype> selectorarg keywordnamelist keywordname objcencodeexpr\n+%type <ttype> CLASSNAME\n+end ifobjc\n+\f\n+%{\n+/* Number of statements (loosely speaking) seen so far.  */\n+static int stmt_count;\n+\n+/* Input file and line number of the end of the body of last simple_if;\n+   used by the stmt-rule immediately after simple_if returns.  */\n+static char *if_stmt_file;\n+static int if_stmt_line;\n+\n+/* List of types and structure classes of the current declaration.  */\n+static tree current_declspecs;\n+\n+/* Stack of saved values of current_declspecs.  */\n+static tree declspec_stack;\n+\n+/* 1 if we explained undeclared var errors.  */\n+static int undeclared_variable_notice;\n+\n+ifobjc\n+/* Objective-C specific information */\n+\n+tree objc_interface_context;\n+tree objc_implementation_context;\n+tree objc_method_context;\n+tree objc_ivar_chain;\n+tree objc_ivar_context;\n+enum tree_code objc_inherit_code;\n+int objc_receiver_context;\n+int objc_public_flag;\n+\n+end ifobjc\n+\n+/* Tell yyparse how to print a token's value, if yydebug is set.  */\n+\n+#define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n+extern void yyprint ();\n+%}\n+\f\n+%%\n+program: /* empty */\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids an empty source file\");\n+ifobjc\n+\t\t  objc_finish ();\n+end ifobjc\n+\t\t}\n+\t| extdefs\n+\t\t{\n+ifobjc\n+\t\t  objc_finish ();\n+end ifobjc\n+\t\t}\n+\t;\n+\n+/* the reason for the strange actions in this rule\n+ is so that notype_initdecls when reached via datadef\n+ can find a valid list of type and sc specs in $0. */\n+\n+extdefs:\n+\t{$<ttype>$ = NULL_TREE; } extdef\n+\t| extdefs {$<ttype>$ = NULL_TREE; } extdef\n+\t;\n+\n+extdef:\n+\tfndef\n+\t| datadef\n+ifobjc\n+\t| objcdef\n+end ifobjc\n+\t| ASM_KEYWORD '(' expr ')' ';'\n+\t\t{ STRIP_NOPS ($3);\n+\t\t  if ((TREE_CODE ($3) == ADDR_EXPR\n+\t\t       && TREE_CODE (TREE_OPERAND ($3, 0)) == STRING_CST)\n+\t\t      || TREE_CODE ($3) == STRING_CST)\n+\t\t    assemble_asm ($3);\n+\t\t  else\n+\t\t    error (\"argument of `asm' is not a constant string\"); }\n+\t;\n+\n+datadef:\n+\t  setspecs notype_initdecls ';'\n+\t\t{ if (pedantic)\n+\t\t    error (\"ANSI C forbids data definition with no type or storage class\");\n+\t\t  else if (!flag_traditional)\n+\t\t    warning (\"data definition has no type or storage class\"); }\n+        | declmods setspecs notype_initdecls ';'\n+\t  {}\n+\t| typed_declspecs setspecs initdecls ';'\n+\t  {}\n+        | declmods ';'\n+\t  { pedwarn (\"empty declaration\"); }\n+\t| typed_declspecs ';'\n+\t  { shadow_tag ($1); }\n+\t| error ';'\n+\t| error '}'\n+\t| ';'\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C does not allow extra `;' outside of a function\"); }\n+\t;\n+\f\n+fndef:\n+\t  typed_declspecs setspecs declarator\n+\t\t{ if (! start_function ($1, $3, 0))\n+\t\t    YYERROR1;\n+\t\t  reinit_parse_for_function (); }\n+\t  xdecls\n+\t\t{ store_parm_decls (); }\n+\t  compstmt_or_error\n+\t\t{ finish_function (0); }\n+\t| typed_declspecs setspecs declarator error\n+\t\t{ }\n+\t| declmods setspecs notype_declarator\n+\t\t{ if (! start_function ($1, $3, 0))\n+\t\t    YYERROR1;\n+\t\t  reinit_parse_for_function (); }\n+\t  xdecls\n+\t\t{ store_parm_decls (); }\n+\t  compstmt_or_error\n+\t\t{ finish_function (0); }\n+\t| declmods setspecs notype_declarator error\n+\t\t{ }\n+\t| setspecs notype_declarator\n+\t\t{ if (! start_function (NULL_TREE, $2, 0))\n+\t\t    YYERROR1;\n+\t\t  reinit_parse_for_function (); }\n+\t  xdecls\n+\t\t{ store_parm_decls (); }\n+\t  compstmt_or_error\n+\t\t{ finish_function (0); }\n+\t| setspecs notype_declarator error\n+\t\t{ }\n+\t;\n+\n+identifier:\n+\tIDENTIFIER\n+\t| TYPENAME\n+ifobjc\n+        | CLASSNAME\n+\t\t{ $$ = CLASS_NAME ($1); }\n+end ifobjc\n+\t;\n+\n+unop:     '&'\n+\t\t{ $$ = ADDR_EXPR; }\n+\t| '-'\n+\t\t{ $$ = NEGATE_EXPR; }\n+\t| '+'\n+\t\t{ $$ = CONVERT_EXPR; }\n+\t| PLUSPLUS\n+\t\t{ $$ = PREINCREMENT_EXPR; }\n+\t| MINUSMINUS\n+\t\t{ $$ = PREDECREMENT_EXPR; }\n+\t| '~'\n+\t\t{ $$ = BIT_NOT_EXPR; }\n+\t| '!'\n+\t\t{ $$ = TRUTH_NOT_EXPR; }\n+\t;\n+\n+expr:\tnonnull_exprlist\n+\t\t{ $$ = build_compound_expr ($1); }\n+\t;\n+\n+exprlist:\n+\t  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| nonnull_exprlist\n+\t;\n+\n+nonnull_exprlist:\n+\texpr_no_commas\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| nonnull_exprlist ',' expr_no_commas\n+\t\t{ chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t;\n+\n+unary_expr:\n+\tprimary\n+\t| '*' cast_expr   %prec UNARY\n+\t\t{ $$ = build_indirect_ref ($2, \"unary *\"); }\n+\t/* __extension__ turns off -pedantic for following primary.  */\n+\t| EXTENSION\n+\t\t{ $<itype>1 = pedantic;\n+\t\t  pedantic = 0; }\n+\t  cast_expr\t  %prec UNARY\n+\t\t{ $$ = $3;\n+\t\t  pedantic = $<itype>1; }\n+\t| unop cast_expr  %prec UNARY\n+\t\t{ $$ = build_unary_op ($1, $2, 0); }\n+\t/* Refer to the address of a label as a pointer.  */\n+\t| ANDAND identifier\n+\t\t{ tree label = lookup_label ($2);\n+\t\t  TREE_USED (label) = 1;\n+\t\t  $$ = build1 (ADDR_EXPR, ptr_type_node, label);\n+\t\t  TREE_CONSTANT ($$) = 1; }\n+/* This seems to be impossible on some machines, so let's turn it off.\n+   You can use __builtin_next_arg to find the anonymous stack args.\n+\t| '&' ELLIPSIS\n+\t\t{ tree types = TYPE_ARG_TYPES (TREE_TYPE (current_function_decl));\n+\t\t  $$ = error_mark_node;\n+\t\t  if (TREE_VALUE (tree_last (types)) == void_type_node)\n+\t\t    error (\"`&...' used in function with fixed number of arguments\");\n+\t\t  else\n+\t\t    {\n+\t\t      if (pedantic)\n+\t\t\tpedwarn (\"ANSI C forbids `&...'\");\n+\t\t      $$ = tree_last (DECL_ARGUMENTS (current_function_decl));\n+\t\t      $$ = build_unary_op (ADDR_EXPR, $$, 0);\n+\t\t    } }\n+*/\n+\t| SIZEOF unary_expr  %prec UNARY\n+\t\t{ if (TREE_CODE ($2) == COMPONENT_REF\n+\t\t      && DECL_BIT_FIELD (TREE_OPERAND ($2, 1)))\n+\t\t    error (\"`sizeof' applied to a bit-field\");\n+\t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n+\t| SIZEOF '(' typename ')'  %prec HYPERUNARY\n+\t\t{ $$ = c_sizeof (groktypename ($3)); }\n+\t| ALIGNOF unary_expr  %prec UNARY\n+\t\t{ $$ = c_alignof_expr ($2); }\n+\t| ALIGNOF '(' typename ')'  %prec HYPERUNARY\n+\t\t{ $$ = c_alignof (groktypename ($3)); }\n+\t;\n+\n+cast_expr:\n+\tunary_expr\n+\t| '(' typename ')' cast_expr  %prec UNARY\n+\t\t{ tree type = groktypename ($2);\n+\t\t  $$ = build_c_cast (type, $4); }\n+\t| '(' typename ')' '{' initlist maybecomma '}'  %prec UNARY\n+\t\t{ tree type = groktypename ($2);\n+\t\t  char *name;\n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids constructor expressions\");\n+\t\t  if (TYPE_NAME (type) != 0)\n+\t\t    {\n+\t\t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n+\t\t\tname = IDENTIFIER_POINTER (TYPE_NAME (type));\n+\t\t      else\n+\t\t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+\t\t    }\n+\t\t  else\n+\t\t    name = \"\";\n+\t\t  $$ = digest_init (type, build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($5)),\n+\t\t\t\t    NULL_PTR, 0, 0, name);\n+\t\t  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n+\t\t    {\n+\t\t      int failure = complete_array_type (type, $$, 1);\n+\t\t      if (failure)\n+\t\t\tabort ();\n+\t\t    }\n+\t\t}\n+\t;\n+\n+expr_no_commas:\n+\t  cast_expr\n+\t| expr_no_commas '+' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '-' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '*' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '/' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '%' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas LSHIFT expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas RSHIFT expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas ARITHCOMPARE expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas EQCOMPARE expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '&' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '|' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas '^' expr_no_commas\n+\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n+\t| expr_no_commas ANDAND expr_no_commas\n+\t\t{ $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $3); }\n+\t| expr_no_commas OROR expr_no_commas\n+\t\t{ $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $3); }\n+\t| expr_no_commas '?' xexpr ':' expr_no_commas\n+\t\t{ $$ = build_conditional_expr ($1, $3, $5); }\n+\t| expr_no_commas '=' expr_no_commas\n+\t\t{ $$ = build_modify_expr ($1, NOP_EXPR, $3);\n+\t\t  C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }\n+\t| expr_no_commas ASSIGN expr_no_commas\n+\t\t{ $$ = build_modify_expr ($1, $2, $3);\n+\t\t  C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }\n+\t;\n+\n+primary:\n+\tIDENTIFIER\n+\t\t{\n+\t\t  tree context;\n+\n+\t\t  $$ = lastiddecl;\n+\t\t  if (!$$ || $$ == error_mark_node)\n+\t\t    {\n+\t\t      if (yychar == YYEMPTY)\n+\t\t\tyychar = YYLEX;\n+\t\t      if (yychar == '(')\n+\t\t\t{\n+ifobjc\n+\t\t\t  if (objc_receiver_context\n+\t\t\t      && ! (objc_receiver_context\n+\t\t\t\t    && strcmp (IDENTIFIER_POINTER ($1), \"super\")))\n+\t\t\t    /* we have a message to super */\n+\t\t\t    $$ = get_super_receiver ();\n+\t\t\t  else if (objc_method_context\n+\t\t\t\t   && is_ivar (objc_ivar_chain, $1))\n+\t\t\t    $$ = build_ivar_reference ($1);\n+\t\t\t  else\n+end ifobjc\n+\t\t\t    {\n+\t\t\t      /* Ordinary implicit function declaration.  */\n+\t\t\t      $$ = implicitly_declare ($1);\n+\t\t\t      assemble_external ($$);\n+\t\t\t      TREE_USED ($$) = 1;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else if (current_function_decl == 0)\n+\t\t\t{\n+\t\t\t  error (\"`%s' undeclared, outside of functions\",\n+\t\t\t\t IDENTIFIER_POINTER ($1));\n+\t\t\t  $$ = error_mark_node;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+ifobjc\n+\t\t          if (objc_receiver_context\n+\t\t\t      && ! strcmp (IDENTIFIER_POINTER ($1), \"super\"))\n+\t\t\t    /* we have a message to super */\n+\t\t\t    $$ = get_super_receiver ();\n+\t\t\t  else if (objc_method_context\n+\t\t\t\t   && is_ivar (objc_ivar_chain, $1))\n+\t\t\t    $$ = build_ivar_reference ($1);\n+\t\t\t  else\n+end ifobjc\n+\t\t\t    {\n+\t\t\t      if (IDENTIFIER_GLOBAL_VALUE ($1) != error_mark_node\n+\t\t\t\t  || IDENTIFIER_ERROR_LOCUS ($1) != current_function_decl)\n+\t\t\t\t{\n+\t\t\t\t  error (\"`%s' undeclared (first use this function)\",\n+\t\t\t\t\t IDENTIFIER_POINTER ($1));\n+\n+\t\t\t\t  if (! undeclared_variable_notice)\n+\t\t\t\t    {\n+\t\t\t\t      error (\"(Each undeclared identifier is reported only once\");\n+\t\t\t\t      error (\"for each function it appears in.)\");\n+\t\t\t\t      undeclared_variable_notice = 1;\n+\t\t\t\t    }\n+\t\t\t\t}\n+\t\t\t      $$ = error_mark_node;\n+\t\t\t      /* Prevent repeated error messages.  */\n+\t\t\t      IDENTIFIER_GLOBAL_VALUE ($1) = error_mark_node;\n+\t\t\t      IDENTIFIER_ERROR_LOCUS ($1) = current_function_decl;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (TREE_TYPE ($$) == error_mark_node)\n+\t\t    $$ = error_mark_node;\n+\t\t  else if (C_DECL_ANTICIPATED ($$))\n+\t\t    {\n+\t\t      /* The first time we see a build-in function used,\n+\t\t\t if it has not been declared.  */\n+\t\t      C_DECL_ANTICIPATED ($$) = 0;\n+\t\t      if (yychar == YYEMPTY)\n+\t\t\tyychar = YYLEX;\n+\t\t      if (yychar == '(')\n+\t\t\t{\n+\t\t\t  /* Omit the implicit declaration we\n+\t\t\t     would ordinarily do, so we don't lose\n+\t\t\t     the actual built in type.\n+\t\t\t     But print a diagnostic for the mismatch.  */\n+ifobjc\n+\t\t\t  if (objc_method_context\n+\t\t\t      && is_ivar (objc_ivar_chain, $1))\n+\t\t\t    error (\"Instance variable `%s' implicitly declared as function\",\n+\t\t\t\t   IDENTIFIER_POINTER (DECL_NAME ($$)));\n+\t\t\t  else\n+end ifobjc\n+\t\t\t    if (TREE_CODE ($$) != FUNCTION_DECL)\n+\t\t\t      error (\"`%s' implicitly declared as function\",\n+\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME ($$)));\n+\t\t\t  else if ((TYPE_MODE (TREE_TYPE (TREE_TYPE ($$)))\n+\t\t\t\t    != TYPE_MODE (integer_type_node))\n+\t\t\t\t   && (TREE_TYPE (TREE_TYPE ($$))\n+\t\t\t\t       != void_type_node))\n+\t\t\t    pedwarn (\"type mismatch in implicit declaration for built-in function `%s'\",\n+\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME ($$)));\n+\t\t\t  /* If it really returns void, change that to int.  */\n+\t\t\t  if (TREE_TYPE (TREE_TYPE ($$)) == void_type_node)\n+\t\t\t    TREE_TYPE ($$)\n+\t\t\t      = build_function_type (integer_type_node,\n+\t\t\t\t\t\t     TYPE_ARG_TYPES (TREE_TYPE ($$)));\n+\t\t\t}\n+\t\t      else\n+\t\t\tpedwarn (\"built-in function `%s' used without declaration\",\n+\t\t\t\t IDENTIFIER_POINTER (DECL_NAME ($$)));\n+\n+\t\t      /* Do what we would ordinarily do when a fn is used.  */\n+\t\t      assemble_external ($$);\n+\t\t      TREE_USED ($$) = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      assemble_external ($$);\n+\t\t      TREE_USED ($$) = 1;\n+ifobjc\n+\t\t      /* we have a definition - still check if iVariable */\n+\n+\t\t      if (!objc_receiver_context\n+\t\t\t  || (objc_receiver_context\n+\t\t\t      && strcmp (IDENTIFIER_POINTER ($1), \"super\")))\n+                        {\n+\t\t\t  if (objc_method_context\n+\t\t\t      && is_ivar (objc_ivar_chain, $1))\n+                            {\n+                              if (IDENTIFIER_LOCAL_VALUE ($1))\n+                                warning (\"local declaration of `%s' hides instance variable\",\n+\t                                 IDENTIFIER_POINTER ($1));\n+                              else\n+                                $$ = build_ivar_reference ($1);\n+                            }\n+\t\t\t}\n+                      else /* we have a message to super */\n+\t\t        $$ = get_super_receiver ();\n+end ifobjc\n+\t\t    }\n+\n+\t\t  if (TREE_CODE ($$) == CONST_DECL)\n+\t\t    {\n+\t\t      $$ = DECL_INITIAL ($$);\n+\t\t      /* This is to prevent an enum whose value is 0\n+\t\t\t from being considered a null pointer constant.  */\n+\t\t      $$ = build1 (NOP_EXPR, TREE_TYPE ($$), $$);\n+\t\t      TREE_CONSTANT ($$) = 1;\n+\t\t    }\n+\t\t}\n+\t| CONSTANT\n+\t| string\n+\t\t{ $$ = combine_strings ($1); }\n+\t| '(' expr ')'\n+\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n+\t\t  if (class == 'e' || class == '1'\n+\t\t      || class == '2' || class == '<')\n+\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n+\t\t  $$ = $2; }\n+\t| '(' error ')'\n+\t\t{ $$ = error_mark_node; }\n+\t| '('\n+\t\t{ if (current_function_decl == 0)\n+\t\t    {\n+\t\t      error (\"braced-group within expression allowed only inside a function\");\n+\t\t      YYERROR;\n+\t\t    }\n+\t\t  /* We must force a BLOCK for this level\n+\t\t     so that, if it is not expanded later,\n+\t\t     there is a way to turn off the entire subtree of blocks\n+\t\t     that are contained in it.  */\n+\t\t  keep_next_level ();\n+\t\t  push_label_level ();\n+\t\t  $<ttype>$ = expand_start_stmt_expr (); }\n+\t  compstmt ')'\n+\t\t{ tree rtl_exp;\n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids braced-groups within expressions\");\n+\t\t  pop_label_level ();\n+\t\t  rtl_exp = expand_end_stmt_expr ($<ttype>2);\n+\t\t  /* The statements have side effects, so the group does.  */\n+\t\t  TREE_SIDE_EFFECTS (rtl_exp) = 1;\n+\n+\t\t  /* Make a BIND_EXPR for the BLOCK already made.  */\n+\t\t  $$ = build (BIND_EXPR, TREE_TYPE (rtl_exp),\n+\t\t\t      NULL_TREE, rtl_exp, $3);\n+\t\t  /* Remove the block from the tree at this point.\n+\t\t     It gets put back at the proper place\n+\t\t     when the BIND_EXPR is expanded.  */\n+\t\t  delete_block ($3);\n+\t\t}\n+\t| primary '(' exprlist ')'   %prec '.'\n+\t\t{ $$ = build_function_call ($1, $3); }\n+\t| primary '[' expr ']'   %prec '.'\n+\t\t{ $$ = build_array_ref ($1, $3); }\n+\t| primary '.' identifier\n+\t\t{\n+ifobjc\n+                  if (doing_objc_thang)\n+                    {\n+\t\t      if (is_public ($1, $3))\n+\t\t\t$$ = build_component_ref ($1, $3);\n+\t\t      else\n+\t\t\t$$ = error_mark_node;\n+\t\t    }\n+                  else\n+end ifobjc\n+\t\t    $$ = build_component_ref ($1, $3);\n+\t\t}\n+\t| primary POINTSAT identifier\n+\t\t{\n+                  tree expr = build_indirect_ref ($1, \"->\");\n+\n+ifobjc\n+                  if (doing_objc_thang)\n+                    {\n+\t\t      if (is_public (expr, $3))\n+\t\t\t$$ = build_component_ref (expr, $3);\n+\t\t      else\n+\t\t\t$$ = error_mark_node;\n+\t\t    }\n+                  else\n+end ifobjc\n+                    $$ = build_component_ref (expr, $3);\n+\t\t}\n+\t| primary PLUSPLUS\n+\t\t{ $$ = build_unary_op (POSTINCREMENT_EXPR, $1, 0); }\n+\t| primary MINUSMINUS\n+\t\t{ $$ = build_unary_op (POSTDECREMENT_EXPR, $1, 0); }\n+ifobjc\n+\t| objcmessageexpr\n+\t\t{ $$ = build_message_expr ($1); }\n+\t| objcselectorexpr\n+\t\t{ $$ = build_selector_expr ($1); }\n+\t| objcencodeexpr\n+\t\t{ $$ = build_encode_expr ($1); }\n+end ifobjc\n+\t;\n+\n+/* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n+string:\n+\t  STRING\n+\t| string STRING\n+\t\t{ $$ = chainon ($1, $2); }\n+\t;\n+\n+xdecls:\n+\t/* empty */\n+\t| datadecls\n+\t| datadecls ELLIPSIS\n+\t\t/* ... is used here to indicate a varargs function.  */\n+\t\t{ c_mark_varargs ();\n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C does not permit use of `varargs.h'\"); }\n+\t;\n+\n+/* The following are analogous to lineno_decl, decls and decl\n+   except that they do not allow nested functions.\n+   They are used for old-style parm decls.  */\n+lineno_datadecl:\n+\t  save_filename save_lineno datadecl\n+\t\t{ }\n+\t;\n+\n+datadecls:\n+\tlineno_datadecl\n+\t| errstmt\n+\t| datadecls lineno_datadecl\n+\t| lineno_datadecl errstmt\n+\t;\n+\n+datadecl:\n+\ttyped_declspecs setspecs initdecls ';'\n+\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| declmods setspecs notype_initdecls ';'\n+\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| typed_declspecs ';'\n+\t\t{ shadow_tag_warned ($1, 1);\n+\t\t  pedwarn (\"empty declaration\"); }\n+\t| declmods ';'\n+\t\t{ pedwarn (\"empty declaration\"); }\n+\t;\n+\n+/* This combination which saves a lineno before a decl\n+   is the normal thing to use, rather than decl itself.\n+   This is to avoid shift/reduce conflicts in contexts\n+   where statement labels are allowed.  */\n+lineno_decl:\n+\t  save_filename save_lineno decl\n+\t\t{ }\n+\t;\n+\n+decls:\n+\tlineno_decl\n+\t| errstmt\n+\t| decls lineno_decl\n+\t| lineno_decl errstmt\n+\t;\n+\n+/* records the type and storage class specs to use for processing\n+   the declarators that follow.\n+   Maintains a stack of outer-level values of current_declspecs,\n+   for the sake of parm declarations nested in function declarators.  */\n+setspecs: /* empty */\n+\t\t{ $$ = suspend_momentary ();\n+\t\t  pending_xref_error ();\n+\t\t  declspec_stack = tree_cons (NULL_TREE, current_declspecs,\n+\t\t\t\t\t      declspec_stack);\n+\t\t  current_declspecs = $<ttype>0; }\n+\t;\n+\n+decl:\n+\ttyped_declspecs setspecs initdecls ';'\n+\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| declmods setspecs notype_initdecls ';'\n+\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| typed_declspecs setspecs nested_function\n+\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| declmods setspecs notype_nested_function\n+\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| typed_declspecs ';'\n+\t\t{ shadow_tag ($1); }\n+\t| declmods ';'\n+\t\t{ pedwarn (\"empty declaration\"); }\n+\t;\n+\n+/* Declspecs which contain at least one type specifier or typedef name.\n+   (Just `const' or `volatile' is not enough.)\n+   A typedef'd name following these is taken as a name to be declared.  */\n+\n+typed_declspecs:\n+\t  typespec reserved_declspecs\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n+\t| declmods typespec reserved_declspecs\n+\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n+\t;\n+\n+reserved_declspecs:  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| reserved_declspecs typespecqual_reserved\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t| reserved_declspecs SCSPEC\n+\t\t{ if (extra_warnings)\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t;\n+\n+/* List of just storage classes and type modifiers.\n+   A declaration can start with just this, but then it cannot be used\n+   to redeclare a typedef-name.  */\n+\n+declmods:\n+\t  TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| SCSPEC\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n+\t| declmods TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = 1; }\n+\t| declmods SCSPEC\n+\t\t{ if (extra_warnings && TREE_STATIC ($1))\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n+\t\t\t     IDENTIFIER_POINTER ($2));\n+\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n+\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n+\t;\n+\n+\n+/* Used instead of declspecs where storage classes are not allowed\n+   (that is, for typenames and structure components).\n+   Don't accept a typedef-name if anything but a modifier precedes it.  */\n+\n+typed_typespecs:\n+\t  typespec reserved_typespecquals\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n+\t| nonempty_type_quals typespec reserved_typespecquals\n+\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n+\t;\n+\n+reserved_typespecquals:  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| reserved_typespecquals typespecqual_reserved\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t;\n+\n+/* A typespec (but not a type qualifier).\n+   Once we have seen one of these in a declaration,\n+   if a typedef name appears then it is being redeclared.  */\n+\n+typespec: TYPESPEC\n+\t| structsp\n+\t| TYPENAME\n+\t\t{ /* For a typedef name, record the meaning, not the name.\n+\t\t     In case of `foo foo, bar;'.  */\n+\t\t  $$ = lookup_name ($1); }\n+ifobjc\n+        | CLASSNAME\n+\t\t{ $$ = get_static_reference ($1); }\n+end ifobjc\n+\t| TYPEOF '(' expr ')'\n+\t\t{ $$ = TREE_TYPE ($3); }\n+\t| TYPEOF '(' typename ')'\n+\t\t{ $$ = groktypename ($3); }\n+\t;\n+\n+/* A typespec that is a reserved word, or a type qualifier.  */\n+\n+typespecqual_reserved: TYPESPEC\n+\t| TYPE_QUAL\n+\t| structsp\n+\t;\n+\n+initdecls:\n+\tinitdcl\n+\t| initdecls ',' initdcl\n+\t;\n+\n+notype_initdecls:\n+\tnotype_initdcl\n+\t| notype_initdecls ',' initdcl\n+\t;\n+\n+maybeasm:\n+\t  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| ASM_KEYWORD '(' string ')'\n+\t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n+\t\t  $$ = $3;\n+\t\t}\n+\t;\n+\n+initdcl:\n+\t  declarator maybeasm maybe_attribute '='\n+\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1); }\n+\t  init\n+/* Note how the declaration of the variable is in effect while its init is parsed! */\n+\t\t{ decl_attributes ($<ttype>5, $3);\n+\t\t  finish_decl ($<ttype>5, $6, $2); }\n+\t| declarator maybeasm maybe_attribute\n+\t\t{ tree d = start_decl ($1, current_declspecs, 0);\n+\t\t  decl_attributes (d, $3);\n+\t\t  finish_decl (d, NULL_TREE, $2); }\n+\t;\n+\n+notype_initdcl:\n+\t  notype_declarator maybeasm maybe_attribute '='\n+\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1); }\n+\t  init\n+/* Note how the declaration of the variable is in effect while its init is parsed! */\n+\t\t{ decl_attributes ($<ttype>5, $3);\n+\t\t  finish_decl ($<ttype>5, $6, $2); }\n+\t| notype_declarator maybeasm maybe_attribute\n+\t\t{ tree d = start_decl ($1, current_declspecs, 0);\n+\t\t  decl_attributes (d, $3);\n+\t\t  finish_decl (d, NULL_TREE, $2); }\n+\t;\n+/* the * rules are dummies to accept the Apollo extended syntax\n+   so that the header files compile. */\n+maybe_attribute:\n+    /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+    | ATTRIBUTE '(' '(' attribute_list ')' ')'\n+\t\t{ $$ = $4; }\n+    ;\n+\n+attribute_list\n+    : attrib\n+\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n+    | attribute_list ',' attrib\n+\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n+    ;\n+\n+attrib\n+    : IDENTIFIER\n+\t{ if (strcmp (IDENTIFIER_POINTER ($1), \"packed\"))\n+\t    warning (\"`%s' attribute directive ignored\",\n+\t\t     IDENTIFIER_POINTER ($1));\n+\t  $$ = $1; }\n+    | IDENTIFIER '(' IDENTIFIER ')'\n+\t{ /* If not \"mode (m)\", then issue warning.  */\n+\t  if (strcmp (IDENTIFIER_POINTER ($1), \"mode\") != 0)\n+\t    {\n+\t      warning (\"`%s' attribute directive ignored\",\n+\t\t       IDENTIFIER_POINTER ($1));\n+\t      $$ = $1;\n+\t    }\n+\t  else\n+\t    $$ = tree_cons ($1, $3, NULL_TREE); }\n+    | IDENTIFIER '(' CONSTANT ')'\n+\t{ /* if not \"aligned(n)\", then issue warning */\n+\t  if (strcmp (IDENTIFIER_POINTER ($1), \"aligned\") != 0\n+\t      || TREE_CODE ($3) != INTEGER_CST)\n+\t    {\n+\t      warning (\"`%s' attribute directive ignored\",\n+\t\t       IDENTIFIER_POINTER ($1));\n+\t      $$ = $1;\n+\t    }\n+\t  else\n+\t    $$ = tree_cons ($1, $3, NULL_TREE); }\n+    | IDENTIFIER '(' IDENTIFIER ',' CONSTANT ',' CONSTANT ')'\n+\t{ /* if not \"format(...)\", then issue warning */\n+\t  if (strcmp (IDENTIFIER_POINTER ($1), \"format\") != 0\n+\t      || TREE_CODE ($5) != INTEGER_CST\n+\t      || TREE_CODE ($7) != INTEGER_CST)\n+\t    {\n+\t      warning (\"`%s' attribute directive ignored\",\n+\t\t       IDENTIFIER_POINTER ($1));\n+\t      $$ = $1;\n+\t    }\n+\t  else\n+\t    $$ = tree_cons ($1,\n+\t\t\t    tree_cons ($3,\n+\t\t\t\t       tree_cons ($5, $7, NULL_TREE),\n+\t\t\t\t       NULL_TREE),\n+\t\t\t    NULL_TREE); }\n+    ;\n+\n+init:\n+\texpr_no_commas\n+\t| '{' '}'\n+\t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);\n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids empty initializer braces\"); }\n+\t| '{' initlist '}'\n+\t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($2)); }\n+\t| '{' initlist ',' '}'\n+\t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($2)); }\n+\t| error\n+\t\t{ $$ = NULL_TREE; }\n+\t;\n+\n+/* This chain is built in reverse order,\n+   and put in forward order where initlist is used.  */\n+initlist:\n+\t  init\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| initlist ',' init\n+\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n+\t/* These are for labeled elements.  */\n+\t| '[' expr_no_commas ELLIPSIS expr_no_commas ']' init\n+\t\t{ $$ = build_tree_list (tree_cons ($2, NULL_TREE,\n+\t\t\t\t\t\t   build_tree_list ($4, NULL_TREE)),\n+\t\t\t\t\t$6); }\n+\t| initlist ',' '[' expr_no_commas ELLIPSIS expr_no_commas ']' init\n+\t\t{ $$ = tree_cons (tree_cons ($4, NULL_TREE,\n+\t\t\t\t\t     build_tree_list ($6, NULL_TREE)),\n+\t\t\t\t  $8,\n+\t\t\t\t  $1); }\n+\t| '[' expr_no_commas ']' init\n+\t\t{ $$ = build_tree_list ($2, $4); }\n+\t| initlist ',' '[' expr_no_commas ']' init\n+\t\t{ $$ = tree_cons ($4, $6, $1); }\n+\t| identifier ':' init\n+\t\t{ $$ = build_tree_list ($1, $3); }\n+\t| initlist ',' identifier ':' init\n+\t\t{ $$ = tree_cons ($3, $5, $1); }\n+\t;\n+\n+nested_function:\n+\t  declarator\n+\t\t{ push_c_function_context ();\n+\t\t  if (! start_function (current_declspecs, $1, 1))\n+\t\t    {\n+\t\t      pop_c_function_context ();\n+\t\t      YYERROR1;\n+\t\t    }\n+\t\t  reinit_parse_for_function ();\n+\t\t  store_parm_decls (); }\n+/* This used to use compstmt_or_error.\n+   That caused a bug with input `f(g) int g {}',\n+   where the use of YYERROR1 above caused an error\n+   which then was handled by compstmt_or_error.\n+   There followed a repeated execution of that same rule,\n+   which called YYERROR1 again, and so on.  */\n+\t  compstmt\n+\t\t{ finish_function (1);\n+\t\t  pop_c_function_context (); }\n+\t;\n+\n+notype_nested_function:\n+\t  notype_declarator\n+\t\t{ push_c_function_context ();\n+\t\t  if (! start_function (current_declspecs, $1, 1))\n+\t\t    {\n+\t\t      pop_c_function_context ();\n+\t\t      YYERROR1;\n+\t\t    }\n+\t\t  reinit_parse_for_function ();\n+\t\t  store_parm_decls (); }\n+/* This used to use compstmt_or_error.\n+   That caused a bug with input `f(g) int g {}',\n+   where the use of YYERROR1 above caused an error\n+   which then was handled by compstmt_or_error.\n+   There followed a repeated execution of that same rule,\n+   which called YYERROR1 again, and so on.  */\n+\t  compstmt\n+\t\t{ finish_function (1);\n+\t\t  pop_c_function_context (); }\n+\t;\n+\n+/* Any kind of declarator (thus, all declarators allowed\n+   after an explicit typespec).  */\n+\n+declarator:\n+\t  after_type_declarator\n+\t| notype_declarator\n+\t;\n+\n+/* A declarator that is allowed only after an explicit typespec.  */\n+\n+after_type_declarator:\n+\t  '(' after_type_declarator ')'\n+\t\t{ $$ = $2; }\n+\t| after_type_declarator '(' parmlist_or_identifiers  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n+/*\t| after_type_declarator '(' error ')'  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n+\t\t  poplevel (0, 0, 0); }  */\n+\t| after_type_declarator '[' expr ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n+\t| after_type_declarator '[' ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| '*' type_quals after_type_declarator  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| TYPENAME\n+\t;\n+\n+/* Kinds of declarator that can appear in a parameter list\n+   in addition to notype_declarator.  This is like after_type_declarator\n+   but does not allow a typedef name in parentheses as an identifier\n+   (because it would conflict with a function with that typedef as arg).  */\n+\n+parm_declarator:\n+\t  parm_declarator '(' parmlist_or_identifiers  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n+/*\t| parm_declarator '(' error ')'  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n+\t\t  poplevel (0, 0, 0); }  */\n+\t| parm_declarator '[' expr ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n+\t| parm_declarator '[' ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| '*' type_quals parm_declarator  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| TYPENAME\n+\t;\n+\n+/* A declarator allowed whether or not there has been\n+   an explicit typespec.  These cannot redeclare a typedef-name.  */\n+\n+notype_declarator:\n+\t  notype_declarator '(' parmlist_or_identifiers  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n+/*\t| notype_declarator '(' error ')'  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n+\t\t  poplevel (0, 0, 0); }  */\n+\t| '(' notype_declarator ')'\n+\t\t{ $$ = $2; }\n+\t| '*' type_quals notype_declarator  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| notype_declarator '[' expr ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n+\t| notype_declarator '[' ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| IDENTIFIER\n+\t;\n+\n+structsp:\n+\t  STRUCT identifier '{'\n+\t\t{ $$ = start_struct (RECORD_TYPE, $2);\n+\t\t  /* Start scope of tag before parsing components.  */\n+\t\t}\n+\t  component_decl_list '}'\n+\t\t{ $$ = finish_struct ($<ttype>4, $5);\n+\t\t  /* Really define the structure.  */\n+\t\t}\n+\t| STRUCT '{' component_decl_list '}'\n+\t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n+\t\t\t\t      $3); }\n+\t| STRUCT identifier\n+\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n+\t| UNION identifier '{'\n+\t\t{ $$ = start_struct (UNION_TYPE, $2); }\n+\t  component_decl_list '}'\n+\t\t{ $$ = finish_struct ($<ttype>4, $5); }\n+\t| UNION '{' component_decl_list '}'\n+\t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n+\t\t\t\t      $3); }\n+\t| UNION identifier\n+\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n+\t| ENUM identifier '{'\n+\t\t{ $<itype>3 = suspend_momentary ();\n+\t\t  $$ = start_enum ($2); }\n+\t  enumlist maybecomma_warn '}'\n+\t\t{ $$ = finish_enum ($<ttype>4, nreverse ($5));\n+\t\t  resume_momentary ($<itype>3); }\n+\t| ENUM '{'\n+\t\t{ $<itype>2 = suspend_momentary ();\n+\t\t  $$ = start_enum (NULL_TREE); }\n+\t  enumlist maybecomma_warn '}'\n+\t\t{ $$ = finish_enum ($<ttype>3, nreverse ($4));\n+\t\t  resume_momentary ($<itype>2); }\n+\t| ENUM identifier\n+\t\t{ $$ = xref_tag (ENUMERAL_TYPE, $2); }\n+\t;\n+\n+maybecomma:\n+\t  /* empty */\n+\t| ','\n+\t;\n+\n+maybecomma_warn:\n+\t  /* empty */\n+\t| ','\n+\t\t{ if (pedantic) pedwarn (\"comma at end of enumerator list\"); }\n+\t;\n+\n+component_decl_list:\n+\t  component_decl_list2\n+\t\t{ $$ = $1; }\n+\t| component_decl_list2 component_decl\n+\t\t{ $$ = chainon ($1, $2);\n+\t\t  warning (\"no semicolon at end of struct or union\"); }\n+\t;\n+\n+component_decl_list2:\t/* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| component_decl_list2 component_decl ';'\n+\t\t{ $$ = chainon ($1, $2); }\n+\t| component_decl_list2 ';'\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"extra semicolon in struct or union specified\"); }\n+ifobjc\n+\t/* foo(sizeof(struct{ @defs(ClassName)})); */\n+\t| DEFS '(' CLASSNAME ')'\n+\t\t{ $$ = get_class_ivars ($3); }\n+end ifobjc\n+\t;\n+\n+/* There is a shift-reduce conflict here, because `components' may\n+   start with a `typename'.  It happens that shifting (the default resolution)\n+   does the right thing, because it treats the `typename' as part of\n+   a `typed_typespecs'.\n+\n+   It is possible that this same technique would allow the distinction\n+   between `notype_initdecls' and `initdecls' to be eliminated.\n+   But I am being cautious and not trying it.  */\n+\n+component_decl:\n+\t  typed_typespecs setspecs components\n+\t\t{ $$ = $3;\n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| typed_typespecs\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids member declarations with no members\");\n+\t\t  shadow_tag($1);\n+\t\t  $$ = NULL_TREE; }\n+\t| nonempty_type_quals setspecs components\n+\t\t{ $$ = $3;\n+\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n+\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n+\t\t  resume_momentary ($2); }\n+\t| nonempty_type_quals\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids member declarations with no members\");\n+\t\t  shadow_tag($1);\n+\t\t  $$ = NULL_TREE; }\n+\t| error\n+\t\t{ $$ = NULL_TREE; }\n+\t;\n+\n+components:\n+\t  component_declarator\n+\t| components ',' component_declarator\n+\t\t{ $$ = chainon ($1, $3); }\n+\t;\n+\n+component_declarator:\n+\t  save_filename save_lineno declarator maybe_attribute\n+\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n+\t\t  decl_attributes ($$, $4); }\n+\t| save_filename save_lineno\n+\t  declarator ':' expr_no_commas maybe_attribute\n+\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n+\t\t  decl_attributes ($$, $6); }\n+\t| save_filename save_lineno ':' expr_no_commas\n+\t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4); }\n+\t;\n+\n+/* We chain the enumerators in reverse order.\n+   They are put in forward order where enumlist is used.\n+   (The order used to be significant, but no longer is so.\n+   However, we still maintain the order, just to be clean.)  */\n+\n+enumlist:\n+\t  enumerator\n+\t| enumlist ',' enumerator\n+\t\t{ $$ = chainon ($3, $1); }\n+\t;\n+\n+\n+enumerator:\n+\t  identifier\n+\t\t{ $$ = build_enumerator ($1, NULL_TREE); }\n+\t| identifier '=' expr_no_commas\n+\t\t{ $$ = build_enumerator ($1, $3); }\n+\t;\n+\n+typename:\n+\ttyped_typespecs absdcl\n+\t\t{ $$ = build_tree_list ($1, $2); }\n+\t| nonempty_type_quals absdcl\n+\t\t{ $$ = build_tree_list ($1, $2); }\n+\t;\n+\n+absdcl:   /* an absolute declarator */\n+\t/* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| absdcl1\n+\t;\n+\n+nonempty_type_quals:\n+\t  TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n+\t| nonempty_type_quals TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t;\n+\n+type_quals:\n+\t  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| type_quals TYPE_QUAL\n+\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n+\t;\n+\n+absdcl1:  /* a nonempty absolute declarator */\n+\t  '(' absdcl1 ')'\n+\t\t{ $$ = $2; }\n+\t  /* `(typedef)1' is `int'.  */\n+\t| '*' type_quals absdcl1  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| '*' type_quals  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n+\t| absdcl1 '(' parmlist  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n+\t| absdcl1 '[' expr ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n+\t| absdcl1 '[' ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| '(' parmlist  %prec '.'\n+\t\t{ $$ = build_nt (CALL_EXPR, NULL_TREE, $2, NULL_TREE); }\n+\t| '[' expr ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n+\t| '[' ']'  %prec '.'\n+\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n+\t;\n+\n+/* at least one statement, the first of which parses without error.  */\n+/* stmts is used only after decls, so an invalid first statement\n+   is actually regarded as an invalid decl and part of the decls.  */\n+\n+stmts:\n+\t  lineno_stmt_or_label\n+\t| stmts lineno_stmt_or_label\n+\t| stmts errstmt\n+\t;\n+\n+xstmts:\n+\t/* empty */\n+\t| stmts\n+\t;\n+\n+errstmt:  error ';'\n+\t;\n+\n+pushlevel:  /* empty */\n+\t\t{ emit_line_note (input_filename, lineno);\n+\t\t  pushlevel (0);\n+\t\t  clear_last_expr ();\n+\t\t  push_momentary ();\n+\t\t  expand_start_bindings (0);\n+ifobjc\n+\t\t  if (objc_method_context)\n+\t\t    add_objc_decls ();\n+end ifobjc\n+\t\t}\n+\t;\n+\n+/* Read zero or more forward-declarations for labels\n+   that nested functions can jump to.  */\n+maybe_label_decls:\n+\t  /* empty */\n+\t| label_decls\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids label declarations\"); }\n+\t;\n+\n+label_decls:\n+\t  label_decl\n+\t| label_decls label_decl\n+\t;\n+\n+label_decl:\n+\t  LABEL identifiers_or_typenames ';'\n+\t\t{ tree link;\n+\t\t  for (link = $2; link; link = TREE_CHAIN (link))\n+\t\t    {\n+\t\t      tree label = shadow_label (TREE_VALUE (link));\n+\t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n+\t\t      declare_nonlocal_label (label);\n+\t\t    }\n+\t\t}\n+\t;\n+\n+/* This is the body of a function definition.\n+   It causes syntax errors to ignore to the next openbrace.  */\n+compstmt_or_error:\n+\t  compstmt\n+\t\t{}\n+\t| error compstmt\n+\t;\n+\n+compstmt: '{' '}'\n+\t\t{ $$ = convert (void_type_node, integer_zero_node); }\n+\t| '{' pushlevel maybe_label_decls decls xstmts '}'\n+\t\t{ emit_line_note (input_filename, lineno);\n+\t\t  expand_end_bindings (getdecls (), 1, 0);\n+\t\t  $$ = poplevel (1, 1, 0);\n+\t\t  pop_momentary (); }\n+\t| '{' pushlevel maybe_label_decls error '}'\n+\t\t{ emit_line_note (input_filename, lineno);\n+\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+\t\t  $$ = poplevel (kept_level_p (), 0, 0);\n+\t\t  pop_momentary (); }\n+\t| '{' pushlevel maybe_label_decls stmts '}'\n+\t\t{ emit_line_note (input_filename, lineno);\n+\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+\t\t  $$ = poplevel (kept_level_p (), 0, 0);\n+\t\t  pop_momentary (); }\n+\t;\n+\n+/* Value is number of statements counted as of the closeparen.  */\n+simple_if:\n+\t  if_prefix lineno_labeled_stmt\n+/* Make sure expand_end_cond is run once\n+   for each call to expand_start_cond.\n+   Otherwise a crash is likely.  */\n+\t| if_prefix error\n+\t;\n+\n+if_prefix:\n+\t  IF '(' expr ')'\n+\t\t{ emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  expand_start_cond (truthvalue_conversion ($3), 0);\n+\t\t  $<itype>1 = stmt_count;\n+\t\t  if_stmt_file = $<filename>-1;\n+\t\t  if_stmt_line = $<lineno>0;\n+\t\t  position_after_white_space (); }\n+\t;\n+\n+/* This is a subroutine of stmt.\n+   It is used twice, once for valid DO statements\n+   and once for catching errors in parsing the end test.  */\n+do_stmt_start:\n+\t  DO\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  /* See comment in `while' alternative, above.  */\n+\t\t  emit_nop ();\n+\t\t  expand_start_loop_continue_elsewhere (1);\n+\t\t  position_after_white_space (); }\n+\t  lineno_labeled_stmt WHILE\n+\t\t{ expand_loop_continue_here (); }\n+\t;\n+\n+save_filename:\n+\t\t{ $$ = input_filename; }\n+\t;\n+\n+save_lineno:\n+\t\t{ $$ = lineno; }\n+\t;\n+\n+lineno_labeled_stmt:\n+\t  save_filename save_lineno stmt\n+\t\t{ }\n+/*\t| save_filename save_lineno error\n+\t\t{ }\n+*/\n+\t| save_filename save_lineno label lineno_labeled_stmt\n+\t\t{ }\n+\t;\n+\n+lineno_stmt_or_label:\n+\t  save_filename save_lineno stmt_or_label\n+\t\t{ }\n+\t;\n+\n+stmt_or_label:\n+\t  stmt\n+\t| label\n+\t\t{ int next;\n+\t\t  position_after_white_space ();\n+\t\t  next = getc (finput);\n+\t\t  ungetc (next, finput);\n+\t\t  if (pedantic && next == '}')\n+\t\t    pedwarn (\"ANSI C forbids label at end of compound statement\");\n+\t\t}\n+\t;\n+\n+/* Parse a single real statement, not including any labels.  */\n+stmt:\n+\t  compstmt\n+\t\t{ stmt_count++; }\n+\t| expr ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_expr_stmt ($1);\n+\t\t  clear_momentary (); }\n+\t| simple_if ELSE\n+\t\t{ expand_start_else ();\n+\t\t  $<itype>1 = stmt_count;\n+\t\t  position_after_white_space (); }\n+\t  lineno_labeled_stmt\n+\t\t{ expand_end_cond ();\n+\t\t  if (extra_warnings && stmt_count == $<itype>1)\n+\t\t    warning (\"empty body in an else-statement\"); }\n+\t| simple_if %prec IF\n+\t\t{ expand_end_cond ();\n+\t\t  if (extra_warnings && stmt_count == $<itype>1)\n+\t\t    warning_with_file_and_line (if_stmt_file, if_stmt_line,\n+\t\t\t\t\t\t\"empty body in an if-statement\"); }\n+/* Make sure expand_end_cond is run once\n+   for each call to expand_start_cond.\n+   Otherwise a crash is likely.  */\n+\t| simple_if ELSE error\n+\t\t{ expand_end_cond (); }\n+\t| WHILE\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  /* The emit_nop used to come before emit_line_note,\n+\t\t     but that made the nop seem like part of the preceding line.\n+\t\t     And that was confusing when the preceding line was\n+\t\t     inside of an if statement and was not really executed.\n+\t\t     I think it ought to work to put the nop after the line number.\n+\t\t     We will see.  --rms, July 15, 1991.  */\n+\t\t  emit_nop (); }\n+\t  '(' expr ')'\n+\t\t{ /* Don't start the loop till we have succeeded\n+\t\t     in parsing the end test.  This is to make sure\n+\t\t     that we end every loop we start.  */\n+\t\t  expand_start_loop (1);\n+\t\t  emit_line_note (input_filename, lineno);\n+\t\t  expand_exit_loop_if_false (NULL_PTR,\n+\t\t\t\t\t     truthvalue_conversion ($4));\n+\t\t  position_after_white_space (); }\n+\t  lineno_labeled_stmt\n+\t\t{ expand_end_loop (); }\n+\t| do_stmt_start\n+\t  '(' expr ')' ';'\n+\t\t{ emit_line_note (input_filename, lineno);\n+\t\t  expand_exit_loop_if_false (NULL_PTR,\n+\t\t\t\t\t     truthvalue_conversion ($3));\n+\t\t  expand_end_loop ();\n+\t\t  clear_momentary (); }\n+/* This rule is needed to make sure we end every loop we start.  */\n+\t| do_stmt_start error\n+\t\t{ expand_end_loop ();\n+\t\t  clear_momentary (); }\n+\t| FOR\n+\t  '(' xexpr ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  /* See comment in `while' alternative, above.  */\n+\t\t  emit_nop ();\n+\t\t  if ($3) c_expand_expr_stmt ($3);\n+\t\t  /* Next step is to call expand_start_loop_continue_elsewhere,\n+\t\t     but wait till after we parse the entire for (...).\n+\t\t     Otherwise, invalid input might cause us to call that\n+\t\t     fn without calling expand_end_loop.  */\n+\t\t}\n+\t  xexpr ';'\n+\t\t/* Can't emit now; wait till after expand_start_loop...  */\n+\t\t{ $<lineno>7 = lineno;\n+\t\t  $<filename>$ = input_filename; }\n+\t  xexpr ')'\n+\t\t{ \n+\t\t  /* Start the loop.  Doing this after parsing\n+\t\t     all the expressions ensures we will end the loop.  */\n+\t\t  expand_start_loop_continue_elsewhere (1);\n+\t\t  /* Emit the end-test, with a line number.  */\n+\t\t  emit_line_note ($<filename>8, $<lineno>7);\n+\t\t  if ($6)\n+\t\t    expand_exit_loop_if_false (NULL_PTR,\n+\t\t\t\t\t       truthvalue_conversion ($6));\n+\t\t  /* Don't let the tree nodes for $9 be discarded by\n+\t\t     clear_momentary during the parsing of the next stmt.  */\n+\t\t  push_momentary ();\n+\t\t  $<lineno>7 = lineno;\n+\t\t  $<filename>8 = input_filename; }\n+\t  lineno_labeled_stmt\n+\t\t{ /* Emit the increment expression, with a line number.  */\n+\t\t  emit_line_note ($<filename>8, $<lineno>7);\n+\t\t  expand_loop_continue_here ();\n+\t\t  if ($9)\n+\t\t    c_expand_expr_stmt ($9);\n+\t\t  pop_momentary ();\n+\t\t  expand_end_loop (); }\n+\t| SWITCH '(' expr ')'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_start_case ($3);\n+\t\t  /* Don't let the tree nodes for $3 be discarded by\n+\t\t     clear_momentary during the parsing of the next stmt.  */\n+\t\t  push_momentary ();\n+\t\t  position_after_white_space (); }\n+\t  lineno_labeled_stmt\n+\t\t{ expand_end_case ($3);\n+\t\t  pop_momentary (); }\n+\t| BREAK ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  if ( ! expand_exit_something ())\n+\t\t    error (\"break statement not within loop or switch\"); }\n+\t| CONTINUE ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  if (! expand_continue_loop (NULL_PTR))\n+\t\t    error (\"continue statement not within a loop\"); }\n+\t| RETURN ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_return (NULL_TREE); }\n+\t| RETURN expr ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_return ($2); }\n+\t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  STRIP_NOPS ($4);\n+\t\t  if ((TREE_CODE ($4) == ADDR_EXPR\n+\t\t       && TREE_CODE (TREE_OPERAND ($4, 0)) == STRING_CST)\n+\t\t      || TREE_CODE ($4) == STRING_CST)\n+\t\t    expand_asm ($4);\n+\t\t  else\n+\t\t    error (\"argument of `asm' is not a constant string\"); }\n+\t/* This is the case with just output operands.  */\n+\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n+\t\t\t\t\t input_filename, lineno); }\n+\t/* This is the case with input operands as well.  */\n+\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':' asm_operands ')' ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n+\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n+\t\t\t\t\t input_filename, lineno); }\n+\t/* This is the case with clobbered registers as well.  */\n+\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n+  \t  asm_operands ':' asm_clobbers ')' ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  c_expand_asm_operands ($4, $6, $8, $10,\n+\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n+\t\t\t\t\t input_filename, lineno); }\n+\t| GOTO identifier ';'\n+\t\t{ tree decl;\n+\t\t  stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  decl = lookup_label ($2);\n+\t\t  if (decl != 0)\n+\t\t    {\n+\t\t      TREE_USED (decl) = 1;\n+\t\t      expand_goto (decl);\n+\t\t    }\n+\t\t}\n+\t| GOTO '*' expr ';'\n+\t\t{ stmt_count++;\n+\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n+\t\t  expand_computed_goto (convert (ptr_type_node, $3)); }\n+\t| ';'\n+\t;\n+\n+/* Any kind of label, including jump labels and case labels.\n+   ANSI C accepts labels only before statements, but we allow them\n+   also at the end of a compound statement.  */\n+\n+label:\t  CASE expr ':'\n+\t\t{ register tree value = check_case_value ($2);\n+\t\t  register tree label\n+\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+\t\t  stmt_count++;\n+\n+\t\t  if (value != error_mark_node)\n+\t\t    {\n+\t\t      tree duplicate;\n+\t\t      int success = pushcase (value, label, &duplicate);\n+\t\t      if (success == 1)\n+\t\t\terror (\"case label not within a switch statement\");\n+\t\t      else if (success == 2)\n+\t\t\t{\n+\t\t\t  error (\"duplicate case value\");\n+\t\t\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n+\t\t\t}\n+\t\t      else if (success == 3)\n+\t\t\twarning (\"case value out of range\");\n+\t\t      else if (success == 5)\n+\t\t\terror (\"case label within scope of cleanup or variable array\");\n+\t\t    }\n+\t\t  position_after_white_space (); }\n+\t| CASE expr ELLIPSIS expr ':'\n+\t\t{ register tree value1 = check_case_value ($2);\n+\t\t  register tree value2 = check_case_value ($4);\n+\t\t  register tree label\n+\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+\t\t  stmt_count++;\n+\n+\t\t  if (value1 != error_mark_node && value2 != error_mark_node)\n+\t\t    {\n+\t\t      tree duplicate;\n+\t\t      int success = pushcase_range (value1, value2, label,\n+\t\t\t\t\t\t    &duplicate);\n+\t\t      if (success == 1)\n+\t\t\terror (\"case label not within a switch statement\");\n+\t\t      else if (success == 2)\n+\t\t\t{\n+\t\t\t  error (\"duplicate case value\");\n+\t\t\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n+\t\t\t}\n+\t\t      else if (success == 3)\n+\t\t\twarning (\"case value out of range\");\n+\t\t      else if (success == 4)\n+\t\t\twarning (\"empty case range\");\n+\t\t      else if (success == 5)\n+\t\t\terror (\"case label within scope of cleanup or variable array\");\n+\t\t    }\n+\t\t  position_after_white_space (); }\n+\t| DEFAULT ':'\n+\t\t{\n+\t\t  tree duplicate;\n+\t\t  register tree label\n+\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\t\t  int success = pushcase (NULL_TREE, label, &duplicate);\n+\t\t  stmt_count++;\n+\t\t  if (success == 1)\n+\t\t    error (\"default label not within a switch statement\");\n+\t\t  else if (success == 2)\n+\t\t    {\n+\t\t      error (\"multiple default labels in one switch\");\n+\t\t      error_with_decl (duplicate, \"this is the first default label\");\n+\t\t    }\n+\t\t  position_after_white_space (); }\n+\t| identifier ':'\n+\t\t{ tree label = define_label (input_filename, lineno, $1);\n+\t\t  stmt_count++;\n+\t\t  emit_nop ();\n+\t\t  if (label)\n+\t\t    expand_label (label);\n+\t\t  position_after_white_space (); }\n+\t;\n+\n+/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */\n+\n+maybe_type_qual:\n+\t/* empty */\n+\t\t{ emit_line_note (input_filename, lineno); }\n+\t| TYPE_QUAL\n+\t\t{ emit_line_note (input_filename, lineno); }\n+\t;\n+\n+xexpr:\n+\t/* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| expr\n+\t;\n+\n+/* These are the operands other than the first string and colon\n+   in  asm (\"addextend %2,%1\": \"=dm\" (x), \"0\" (y), \"g\" (*x))  */\n+asm_operands: /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| nonnull_asm_operands\n+\t;\n+\n+nonnull_asm_operands:\n+\t  asm_operand\n+\t| nonnull_asm_operands ',' asm_operand\n+\t\t{ $$ = chainon ($1, $3); }\n+\t;\n+\n+asm_operand:\n+\t  STRING '(' expr ')'\n+\t\t{ $$ = build_tree_list ($1, $3); }\n+\t;\n+\n+asm_clobbers:\n+\t  string\n+\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($1), NULL_TREE); }\n+\t| asm_clobbers ',' string\n+\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($3), $1); }\n+\t;\n+\f\n+/* This is what appears inside the parens in a function declarator.\n+   Its value is a list of ..._TYPE nodes.  */\n+parmlist:\n+\t\t{ pushlevel (0);\n+\t\t  clear_parm_order ();\n+\t\t  declare_parm_level (0); }\n+\t  parmlist_1\n+\t\t{ $$ = $2;\n+\t\t  parmlist_tags_warning ();\n+\t\t  poplevel (0, 0, 0); }\n+\t;\n+\n+parmlist_1:\n+\t  parmlist_2 ')'\n+\t| parms ';'\n+\t\t{ tree parm;\n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C forbids forward parameter declarations\");\n+\t\t  /* Mark the forward decls as such.  */\n+\t\t  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))\n+\t\t    TREE_ASM_WRITTEN (parm) = 1;\n+\t\t  clear_parm_order (); }\n+\t  parmlist_1\n+\t\t{ $$ = $4; }\n+\t| error ')'\n+\t\t{ $$ = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); }\n+\t;\n+\n+/* This is what appears inside the parens in a function declarator.\n+   Is value is represented in the format that grokdeclarator expects.  */\n+parmlist_2:  /* empty */\n+\t\t{ $$ = get_parm_info (0); }\n+\t| ELLIPSIS\n+\t\t{ $$ = get_parm_info (0);\n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C requires a named argument before `...'\");\n+\t\t}\n+\t| parms\n+\t\t{ $$ = get_parm_info (1); }\n+\t| parms ',' ELLIPSIS\n+\t\t{ $$ = get_parm_info (0); }\n+\t;\n+\n+parms:\n+\tparm\n+\t\t{ push_parm_decl ($1); }\n+\t| parms ',' parm\n+\t\t{ push_parm_decl ($3); }\n+\t;\n+\n+/* A single parameter declaration or parameter type name,\n+   as found in a parmlist.  */\n+parm:\n+\t  typed_declspecs parm_declarator\n+\t\t{ $$ = build_tree_list ($1, $2)\t; }\n+\t| typed_declspecs notype_declarator\n+\t\t{ $$ = build_tree_list ($1, $2)\t; }\n+\t| typed_declspecs absdcl\n+\t\t{ $$ = build_tree_list ($1, $2); }\n+\t| declmods notype_declarator\n+\t\t{ $$ = build_tree_list ($1, $2)\t; }\n+\t| declmods absdcl\n+\t\t{ $$ = build_tree_list ($1, $2); }\n+\t;\n+\n+/* This is used in a function definition\n+   where either a parmlist or an identifier list is ok.\n+   Its value is a list of ..._TYPE nodes or a list of identifiers.  */\n+parmlist_or_identifiers:\n+\t\t{ pushlevel (0);\n+\t\t  clear_parm_order ();\n+\t\t  declare_parm_level (1); }\n+\t  parmlist_or_identifiers_1\n+\t\t{ $$ = $2;\n+\t\t  parmlist_tags_warning ();\n+\t\t  poplevel (0, 0, 0); }\n+\t;\n+\n+parmlist_or_identifiers_1:\n+\t  parmlist_1\n+\t| identifiers ')'\n+\t\t{ tree t;\n+\t\t  for (t = $1; t; t = TREE_CHAIN (t))\n+\t\t    if (TREE_VALUE (t) == NULL_TREE)\n+\t\t      error (\"`...' in old-style identifier list\");\n+\t\t  $$ = tree_cons (NULL_TREE, NULL_TREE, $1); }\n+\t;\n+\n+/* A nonempty list of identifiers.  */\n+identifiers:\n+\tIDENTIFIER\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| identifiers ',' IDENTIFIER\n+\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t;\n+\n+/* A nonempty list of identifiers, including typenames.  */\n+identifiers_or_typenames:\n+\tidentifier\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| identifiers_or_typenames ',' identifier\n+\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t;\n+\f\n+ifobjc\n+/* Objective-C productions.  */\n+\n+objcdef:\n+\t  classdef\n+\t| methoddef\n+\t| END\n+\t\t{\n+\t\t  if (objc_implementation_context)\n+                    {\n+\t\t      finish_class (objc_implementation_context);\n+\t\t      objc_ivar_chain = NULL_TREE;\n+\t\t      objc_implementation_context = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    warning (\"`@end' must appear in an implementation context\");\n+\t\t}\n+\t;\n+\n+classdef:\n+\t  INTERFACE identifier '{'\n+\t\t{\n+\t\t  objc_interface_context = objc_ivar_context\n+\t\t    = start_class (INTERFACE_TYPE, $2, NULL_TREE);\n+                  objc_public_flag = 0;\n+\t\t}\n+\t  ivar_decl_list '}'\n+\t\t{\n+                  continue_class (objc_interface_context);\n+\t\t}\n+\t  methodprotolist\n+\t  END\n+\t\t{\n+\t\t  finish_class (objc_interface_context);\n+\t\t  objc_interface_context = NULL_TREE;\n+\t\t}\n+\n+\t| INTERFACE identifier\n+\t\t{\n+\t\t  objc_interface_context\n+\t\t    = start_class (INTERFACE_TYPE, $2, NULL_TREE);\n+                  continue_class (objc_interface_context);\n+\t\t}\n+\t  methodprotolist\n+\t  END\n+\t\t{\n+\t\t  finish_class (objc_interface_context);\n+\t\t  objc_interface_context = NULL_TREE;\n+\t\t}\n+\n+\t| INTERFACE identifier ':' identifier '{'\n+\t\t{\n+\t\t  objc_interface_context = objc_ivar_context\n+\t\t    = start_class (INTERFACE_TYPE, $2, $4);\n+                  objc_public_flag = 0;\n+\t\t}\n+\t  ivar_decl_list '}'\n+\t\t{\n+                  continue_class (objc_interface_context);\n+\t\t}\n+\t  methodprotolist\n+\t  END\n+\t\t{\n+\t\t  finish_class (objc_interface_context);\n+\t\t  objc_interface_context = NULL_TREE;\n+\t\t}\n+\n+\t| INTERFACE identifier ':' identifier\n+\t\t{\n+\t\t  objc_interface_context\n+\t\t    = start_class (INTERFACE_TYPE, $2, $4);\n+                  continue_class (objc_interface_context);\n+\t\t}\n+\t  methodprotolist\n+\t  END\n+\t\t{\n+\t\t  finish_class (objc_interface_context);\n+\t\t  objc_interface_context = NULL_TREE;\n+\t\t}\n+\n+\t| IMPLEMENTATION identifier '{'\n+\t\t{\n+\t\t  objc_implementation_context = objc_ivar_context\n+\t\t    = start_class (IMPLEMENTATION_TYPE, $2, NULL_TREE);\n+                  objc_public_flag = 0;\n+\t\t}\n+\t  ivar_decl_list '}'\n+\t\t{\n+                  objc_ivar_chain\n+\t\t    = continue_class (objc_implementation_context);\n+\t\t}\n+\n+\t| IMPLEMENTATION identifier\n+\t\t{\n+\t\t  objc_implementation_context\n+\t\t    = start_class (IMPLEMENTATION_TYPE, $2, NULL_TREE);\n+                  objc_ivar_chain\n+\t\t    = continue_class (objc_implementation_context);\n+\t\t}\n+\n+\t| IMPLEMENTATION identifier ':' identifier '{'\n+\t\t{\n+\t\t  objc_implementation_context = objc_ivar_context\n+\t\t    = start_class (IMPLEMENTATION_TYPE, $2, $4);\n+                  objc_public_flag = 0;\n+\t\t}\n+\t  ivar_decl_list '}'\n+\t\t{\n+                  objc_ivar_chain\n+\t\t    = continue_class (objc_implementation_context);\n+\t\t}\n+\n+\t| IMPLEMENTATION identifier ':' identifier\n+\t\t{\n+\t\t  objc_implementation_context\n+\t\t    = start_class (IMPLEMENTATION_TYPE, $2, $4);\n+                  objc_ivar_chain\n+\t\t    = continue_class (objc_implementation_context);\n+\t\t}\n+\n+\t| INTERFACE identifier '(' identifier ')'\n+\t\t{\n+\t\t  objc_interface_context\n+\t\t    = start_class (PROTOCOL_TYPE, $2, $4);\n+                  continue_class (objc_interface_context);\n+\t\t}\n+\t  methodprotolist\n+\t  END\n+\t\t{\n+\t\t  finish_class (objc_interface_context);\n+\t\t  objc_interface_context = NULL_TREE;\n+\t\t}\n+\n+\t| IMPLEMENTATION identifier '(' identifier ')'\n+\t\t{\n+\t\t  objc_implementation_context\n+\t\t    = start_class (CATEGORY_TYPE, $2, $4);\n+                  objc_ivar_chain\n+\t\t    = continue_class (objc_implementation_context);\n+\t\t}\n+\t;\n+\n+ivar_decl_list:\n+          ivar_decls PUBLIC { objc_public_flag = 1; } ivar_decls\n+        | ivar_decls\n+        ;\n+\n+ivar_decls:\n+          /* empty */\n+\t\t{\n+                  $$ = NULL_TREE;\n+                }\n+\t| ivar_decls ivar_decl ';'\n+\t| ivar_decls ';'\n+\t\t{\n+                  if (pedantic)\n+\t\t    warning (\"extra semicolon in struct or union specified\");\n+                }\n+\t;\n+\n+\n+/* There is a shift-reduce conflict here, because `components' may\n+   start with a `typename'.  It happens that shifting (the default resolution)\n+   does the right thing, because it treats the `typename' as part of\n+   a `typed_typespecs'.\n+\n+   It is possible that this same technique would allow the distinction\n+   between `notype_initdecls' and `initdecls' to be eliminated.\n+   But I am being cautious and not trying it.  */\n+\n+ivar_decl:\n+\ttyped_typespecs setspecs ivars\n+\t        {\n+                  $$ = $3;\n+\t\t  resume_momentary ($2);\n+                }\n+\t| nonempty_type_quals setspecs ivars\n+\t\t{\n+                  $$ = $3;\n+\t\t  resume_momentary ($2);\n+                }\n+\t| error\n+\t\t{ $$ = NULL_TREE; }\n+\t;\n+\n+ivars:\n+\t  /* empty */\n+\t\t{ $$ = NULL_TREE; }\n+\t| ivar_declarator\n+\t| ivars ',' ivar_declarator\n+\t;\n+\n+ivar_declarator:\n+\t  declarator\n+\t\t{\n+\t\t  $$ = add_instance_variable (objc_ivar_context,\n+\t\t\t\t\t      objc_public_flag,\n+\t\t\t\t\t      $1, current_declspecs,\n+\t\t\t\t\t      NULL_TREE);\n+                }\n+\t| declarator ':' expr_no_commas\n+\t\t{\n+\t\t  $$ = add_instance_variable (objc_ivar_context,\n+\t\t\t\t\t      objc_public_flag,\n+\t\t\t\t\t      $1, current_declspecs, $3);\n+                }\n+\t| ':' expr_no_commas\n+\t\t{\n+\t\t  $$ = add_instance_variable (objc_ivar_context,\n+\t\t\t\t\t      objc_public_flag,\n+\t\t\t\t\t      NULL_TREE,\n+\t\t\t\t\t      current_declspecs, $2);\n+                }\n+\t;\n+\n+methoddef:\n+\t  '+'\n+\t\t{\n+\t\t  if (objc_implementation_context)\n+\t\t    objc_inherit_code = CLASS_METHOD_DECL;\n+                  else\n+\t\t    fatal (\"method definition not in class context\");\n+\t\t}\n+\t  methoddecl\n+\t\t{\n+\t\t  add_class_method (objc_implementation_context, $3);\n+\t\t  start_method_def ($3);\n+\t\t  objc_method_context = $3;\n+\t\t}\n+\t  optarglist\n+\t\t{\n+\t\t  continue_method_def ();\n+\t\t}\n+\t  compstmt_or_error\n+\t\t{\n+\t\t  finish_method_def ();\n+\t\t  objc_method_context = NULL_TREE;\n+\t\t}\n+\n+\t| '-'\n+\t\t{\n+\t\t  if (objc_implementation_context)\n+\t\t    objc_inherit_code = INSTANCE_METHOD_DECL;\n+                  else\n+\t\t    fatal (\"method definition not in class context\");\n+\t\t}\n+\t  methoddecl\n+\t\t{\n+\t\t  add_instance_method (objc_implementation_context, $3);\n+\t\t  start_method_def ($3);\n+\t\t  objc_method_context = $3;\n+\t\t}\n+\t  optarglist\n+\t\t{\n+\t\t  continue_method_def ();\n+\t\t}\n+\t  compstmt_or_error\n+\t\t{\n+\t\t  finish_method_def ();\n+\t\t  objc_method_context = NULL_TREE;\n+\t\t}\n+\t;\n+\n+/* the reason for the strange actions in this rule\n+ is so that notype_initdecls when reached via datadef\n+ can find a valid list of type and sc specs in $0. */\n+\n+methodprotolist:\n+\t  /* empty  */\n+\t| {$<ttype>$ = NULL_TREE; } methodprotolist2\n+\t;\n+\n+methodprotolist2:\t\t /* eliminates a shift/reduce conflict */\n+\t   methodproto\n+\t|  datadef\n+\t| methodprotolist2 methodproto\n+\t| methodprotolist2 {$<ttype>$ = NULL_TREE; } datadef\n+\t;\n+\n+semi_or_error:\n+\t  ';'\n+\t| error\n+\t;\n+\n+methodproto:\n+\t  '+'\n+\t\t{\n+\t\t  objc_inherit_code = CLASS_METHOD_DECL;\n+\t\t}\n+\t  methoddecl\n+\t\t{\n+\t\t  add_class_method (objc_interface_context, $3);\n+\t\t}\n+\t  semi_or_error\n+\n+\t| '-'\n+\t\t{\n+\t\t  objc_inherit_code = INSTANCE_METHOD_DECL;\n+\t\t}\n+\t  methoddecl\n+\t\t{\n+\t\t  add_instance_method (objc_interface_context, $3);\n+\t\t}\n+\t  semi_or_error\n+\t;\n+\n+methoddecl:\n+\t  '(' typename ')' unaryselector\n+\t\t{\n+\t\t  $$ = build_method_decl (objc_inherit_code, $2, $4, NULL_TREE);\n+\t\t}\n+\n+\t| unaryselector\n+\t\t{\n+\t\t  $$ = build_method_decl (objc_inherit_code, NULL_TREE, $1, NULL_TREE);\n+\t\t}\n+\n+\t| '(' typename ')' keywordselector optparmlist\n+\t\t{\n+\t\t  $$ = build_method_decl (objc_inherit_code, $2, $4, $5);\n+\t\t}\n+\n+\t| keywordselector optparmlist\n+\t\t{\n+\t\t  $$ = build_method_decl (objc_inherit_code, NULL_TREE, $1, $2);\n+\t\t}\n+\t;\n+\n+/* \"optarglist\" assumes that start_method_def has already been called...\n+   if it is not, the \"xdecls\" will not be placed in the proper scope */\n+\n+optarglist:\n+\t  /* empty */\n+\t| ';' myxdecls\n+\t;\n+\n+/* to get around the following situation: \"int foo (int a) int b; {}\" that\n+   is synthesized when parsing \"- a:a b:b; id c; id d; { ... }\" */\n+\n+myxdecls:\n+\t  /* empty */\n+\t| mydecls\n+\t;\n+\n+mydecls:\n+\tmydecl\n+\t| errstmt\n+\t| mydecls mydecl\n+\t| mydecl errstmt\n+\t;\n+\n+mydecl:\n+\ttyped_declspecs setspecs myparms ';'\n+\t\t{ resume_momentary ($2); }\n+\t| typed_declspecs ';'\n+\t\t{ shadow_tag ($1); }\n+\t| declmods ';'\n+\t\t{ pedwarn (\"empty declaration\"); }\n+\t;\n+\n+myparms:\n+\tmyparm\n+\t\t{ push_parm_decl ($1); }\n+\t| myparms ',' myparm\n+\t\t{ push_parm_decl ($3); }\n+\t;\n+\n+/* A single parameter declaration or parameter type name,\n+   as found in a parmlist. DOES NOT ALLOW AN INITIALIZER OR ASMSPEC */\n+\n+myparm:\n+\t  parm_declarator\n+\t\t{ $$ = build_tree_list (current_declspecs, $1)\t; }\n+\t| notype_declarator\n+\t\t{ $$ = build_tree_list (current_declspecs, $1)\t; }\n+\t| absdcl\n+\t\t{ $$ = build_tree_list (current_declspecs, $1)\t; }\n+\t;\n+\n+optparmlist:\n+\t  /* empty */\n+\t\t{\n+\t    \t  $$ = NULL_TREE;\n+\t\t}\n+\t| ',' ELLIPSIS\n+\t\t{\n+\t\t  /* oh what a kludge! */\n+\t\t  $$ = (tree)1;\n+\t\t}\n+\t| ','\n+\t\t{\n+\t\t  pushlevel (0);\n+\t\t}\n+\t  parmlist_2\n+\t\t{\n+\t  \t  /* returns a tree list node generated by get_parm_info */\n+\t\t  $$ = $3;\n+\t\t  poplevel (0, 0, 0);\n+\t\t}\n+\t;\n+\n+unaryselector:\n+\t  selector\n+\t;\n+\n+keywordselector:\n+\t  keyworddecl\n+\n+\t| keywordselector keyworddecl\n+\t\t{\n+\t\t  $$ = chainon ($1, $2);\n+\t\t}\n+\t;\n+\n+selector:\n+\t  IDENTIFIER\n+        | TYPENAME\n+\t| reservedwords\n+\t;\n+\n+reservedwords:\n+\t  ENUM { $$ = get_identifier (token_buffer); }\n+\t| STRUCT { $$ = get_identifier (token_buffer); }\n+\t| UNION { $$ = get_identifier (token_buffer); }\n+\t| IF { $$ = get_identifier (token_buffer); }\n+\t| ELSE { $$ = get_identifier (token_buffer); }\n+\t| WHILE { $$ = get_identifier (token_buffer); }\n+\t| DO { $$ = get_identifier (token_buffer); }\n+\t| FOR { $$ = get_identifier (token_buffer); }\n+\t| SWITCH { $$ = get_identifier (token_buffer); }\n+\t| CASE { $$ = get_identifier (token_buffer); }\n+\t| DEFAULT { $$ = get_identifier (token_buffer); }\n+\t| BREAK { $$ = get_identifier (token_buffer); }\n+\t| CONTINUE { $$ = get_identifier (token_buffer); }\n+\t| RETURN  { $$ = get_identifier (token_buffer); }\n+\t| GOTO { $$ = get_identifier (token_buffer); }\n+\t| ASM_KEYWORD { $$ = get_identifier (token_buffer); }\n+        | SIZEOF { $$ = get_identifier (token_buffer); }\n+\t| TYPEOF { $$ = get_identifier (token_buffer); }\n+\t| ALIGNOF { $$ = get_identifier (token_buffer); }\n+\t| TYPESPEC | TYPE_QUAL\n+\t;\n+\n+keyworddecl:\n+\t  selector ':' '(' typename ')' identifier\n+\t\t{\n+\t\t  $$ = build_keyword_decl ($1, $4, $6);\n+\t\t}\n+\n+\t| selector ':' identifier\n+\t\t{\n+\t\t  $$ = build_keyword_decl ($1, NULL_TREE, $3);\n+\t\t}\n+\n+\t| ':' '(' typename ')' identifier\n+\t\t{\n+\t\t  $$ = build_keyword_decl (NULL_TREE, $3, $5);\n+\t\t}\n+\n+\t| ':' identifier\n+\t\t{\n+\t\t  $$ = build_keyword_decl (NULL_TREE, NULL_TREE, $2);\n+\t\t}\n+\t;\n+\n+messageargs:\n+\t  selector\n+        | keywordarglist\n+\t;\n+\n+keywordarglist:\n+\t  keywordarg\n+\t| keywordarglist keywordarg\n+\t\t{\n+\t\t  $$ = chainon ($1, $2);\n+\t\t}\n+\t;\n+\n+\n+keywordexpr:\n+\t  nonnull_exprlist\n+\t\t{\n+\t\t  if (TREE_CHAIN ($1) == NULL_TREE)\n+\t\t    /* just return the expr., remove a level of indirection */\n+\t\t    $$ = TREE_VALUE ($1);\n+                  else\n+\t\t    /* we have a comma expr., we will collapse later */\n+\t\t    $$ = $1;\n+\t\t}\n+\t;\n+\n+keywordarg:\n+\t  selector ':' keywordexpr\n+\t\t{\n+\t\t  $$ = build_tree_list ($1, $3);\n+\t\t}\n+\t| ':' keywordexpr\n+\t\t{\n+\t\t  $$ = build_tree_list (NULL_TREE, $2);\n+\t\t}\n+\t;\n+\n+receiver:\n+\t  expr\n+\t| CLASSNAME\n+\t\t{\n+\t\t  $$ = get_class_reference ($1);\n+\t\t}\n+\t;\n+\n+objcmessageexpr:\n+\t  '['\n+\t\t{ objc_receiver_context = 1; }\n+\t  receiver\n+\t\t{ objc_receiver_context = 0; }\n+\t  messageargs ']'\n+\t\t{\n+\t\t  $$ = build_tree_list ($3, $5);\n+\t\t}\n+\t;\n+\n+selectorarg:\n+\t  selector\n+        | keywordnamelist\n+\t;\n+\n+keywordnamelist:\n+\t  keywordname\n+\t| keywordnamelist keywordname\n+\t\t{\n+\t\t  $$ = chainon ($1, $2);\n+\t\t}\n+\t;\n+\n+keywordname:\n+\t  selector ':'\n+\t\t{\n+\t\t  $$ = build_tree_list ($1, NULL_TREE);\n+\t\t}\n+\t| ':'\n+\t\t{\n+\t\t  $$ = build_tree_list (NULL_TREE, NULL_TREE);\n+\t\t}\n+\t;\n+\n+objcselectorexpr:\n+\t  SELECTOR '(' selectorarg ')'\n+\t\t{\n+\t\t  $$ = $3;\n+\t\t}\n+\t;\n+\n+/* extension to support C-structures in the archiver */\n+\n+objcencodeexpr:\n+\t  ENCODE '(' typename ')'\n+\t\t{\n+\t\t  $$ = groktypename ($3);\n+\t\t}\n+\t;\n+\n+end ifobjc\n+%%\n+ifobjc\n+\n+/* If STRING is the name of an Objective C @-keyword\n+   (not including the @), return the token type for that keyword.\n+   Otherwise return 0.  */\n+\n+int\n+recognize_objc_keyword (string)\n+     char *string;\n+{\n+  switch (string[0])\n+    {\n+    case 'd':\n+      if (!strcmp (string, \"defs\"))\n+\treturn DEFS;\n+      break;\n+    case 'e':\n+      if (!strcmp (string, \"end\"))\n+\treturn END;\n+      if (!strcmp (string, \"encode\"))\n+\treturn ENCODE;\n+      break;\n+    case 'i':\n+      if (!strcmp (string, \"interface\"))\n+\treturn INTERFACE;\n+      if (!strcmp (string, \"implementation\"))\n+\treturn IMPLEMENTATION;\n+      break;\n+    case 'p':\n+      if (!strcmp (string, \"public\"))\n+\treturn PUBLIC;\n+      break;\n+    case 's':\n+      if (!strcmp (string, \"selector\"))\n+\treturn SELECTOR;\n+      break;\n+    }\n+  return 0;\n+}\n+\n+end ifobjc"}]}