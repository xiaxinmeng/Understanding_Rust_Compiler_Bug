{"sha": "68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhiYjdlM2I5ZGMzYmU2YzljZWVjYzJjODdiOWM2NzhlMWEwNDVkYw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-02-12T15:10:38Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-02-12T22:27:26Z"}, "message": "coroutines: Update to n4849 allocation/deallocation.\n\nThis updates the coroutine frame allocation and deallocation usage to\nmatch n4849.\n\n[dcl.fct.def.coroutine] /9, /10, /12.\n\n9 An implementation may need to allocate additional storage for a coroutine.\nThis storage is known as the coroutine state and is obtained by calling a\nnon-array allocation function. The allocation function\u2019s name is looked up\nin the scope of the promise type. If this lookup fails, the allocation\nfunction\u2019s name is looked up in the global scope. If the lookup finds an\nallocation function in the scope of the promise type, overload resolution\nis performed on a function call created by assembling an argument list.\nThe first argument is the amount of space requested, and has type\nstd::size_t. The lvalues p1 . . . pn are the succeeding [user's function]\narguments. If no viable function is found, overload resolution is performed\nagain on a function call created by passing just the amount of space required\nas an argument of type std::size_t.\n\n10 The unqualified-id get_return_object_on_allocation_failure is looked up in\nthe scope of the promise type by class member access lookup. If any\ndeclarations are found, then the result of a call to an allocation function\nused to obtain storage for the coroutine state is assumed to return nullptr\nif it fails to obtain storage, and if a global allocation function is\nselected, the ::operator new(size_t, nothrow_t) form is used. The allocation\nfunction used in this case shall have a non-throwing noexcept-specification.\nIf the allocation function returns nullptr, the coroutine returns control to\nthe caller of the coroutine and the return value is obtained by a call to\nT::get_return_object_on_allocation_failure(), where T is the promise type.\n\n12 The deallocation function\u2019s name is looked up in the scope of the promise\ntype. If this lookup fails, the deallocation function\u2019s name is looked up in\nthe global scope. If deallocation function lookup finds both a usual\ndeallocation function with only a pointer parameter and a usual deallocation\nfunction with both a pointer parameter and a size parameter, then the\nselected deallocation function shall be the one with two parameters.\nOtherwise, the selected deallocation function shall be the function with one\nparameter. If no usual deallocation function is found, the program is ill-\nformed. The selected deallocation function shall be called with the address\nof the block of storage to be reclaimed as its first argument. If a\ndeallocation function with a parameter of type std::size_t is used, the size\nof the block is passed as the corresponding argument.\n\ngcc/cp/ChangeLog:\n\n2020-02-12 Iain Sandoe <iain@sandoe.co.uk>\n\n\t* coroutines.cc (build_actor_fn): Implement deallocation function\n\tselection per n4849, dcl.fct.def.coroutine bullet 12.\n\t(morph_fn_to_coro): Implement allocation function selection per\n\tn4849, dcl.fct.def.coroutine bullets 9 and 10.\n\n2020-02-12 Iain Sandoe <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/coro1-allocators.h: New.\n\t* g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C: New test.\n\t* g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C: New test.\n\t* g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C: New test.\n\t* g++.dg/coroutines/torture/alloc-00-gro-on-alloc-fail.C: Use new\n\tcoro1-allocators.h header.\n\t* g++.dg/coroutines/torture/alloc-01-overload-newdel.C: Likewise.\n\t* g++.dg/coroutines/torture/alloc-02-fail-new-grooaf-check.C: New.\n\t* g++.dg/coroutines/torture/alloc-03-overload-new-1.C: New test.\n\t* g++.dg/coroutines/torture/alloc-04-overload-del-use-two-args.C:New.", "tree": {"sha": "3f4ee92a525857621540fe82a3d90b5be16b2e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f4ee92a525857621540fe82a3d90b5be16b2e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cd9bef89ef25b3fd506cedbc82e8bc00ff56fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cd9bef89ef25b3fd506cedbc82e8bc00ff56fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cd9bef89ef25b3fd506cedbc82e8bc00ff56fa8"}], "stats": {"total": 827, "additions": 587, "deletions": 240}, "files": [{"sha": "6d1eaa4bf90d108df441eb26f78043535f171f24", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -1,3 +1,10 @@\n+2020-02-12 Iain Sandoe <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc (build_actor_fn): Implement deallocation function\n+\tselection per n4849, dcl.fct.def.coroutine bullet 12.\n+\t(morph_fn_to_coro): Implement allocation function selection per\n+\tn4849, dcl.fct.def.coroutine bullets 9 and 10.\n+\n 2020-02-12  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93684 - ICE-on-invalid with broken attribute."}, {"sha": "524d48728048d814ee12d5166be412aa65a13cb2", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 173, "deletions": 75, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -1879,7 +1879,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t\ttree orig, hash_map<tree, param_info> *param_uses,\n \t\thash_map<tree, local_var_info> *local_var_uses,\n \t\tvec<tree, va_gc> *param_dtor_list, tree initial_await,\n-\t\ttree final_await, unsigned body_count)\n+\t\ttree final_await, unsigned body_count, tree frame_size)\n {\n   verify_stmt_tree (fnbody);\n   /* Some things we inherit from the original function.  */\n@@ -2198,33 +2198,64 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t}\n     }\n \n-  tree delname = ovl_op_identifier (false, DELETE_EXPR);\n-  tree arg = build1 (CONVERT_EXPR, ptr_type_node, actor_fp);\n-  vec<tree, va_gc> *arglist = make_tree_vector_single (arg);\n+  /* n4849 [dcl.fct.def.coroutine] / 12\n+     The deallocation function\u2019s name is looked up in the scope of the promise\n+     type.  If this lookup fails, the deallocation function\u2019s name is looked up\n+     in the global scope.  If deallocation function lookup finds both a usual\n+     deallocation function with only a pointer parameter and a usual\n+     deallocation function with both a pointer parameter and a size parameter,\n+     then the selected deallocation function shall be the one with two\n+     parameters.  Otherwise, the selected deallocation function shall be the\n+     function with one parameter.  If no usual deallocation function is found\n+     the program is ill-formed.  The selected deallocation function shall be\n+     called with the address of the block of storage to be reclaimed as its\n+     first argument.  If a deallocation function with a parameter of type\n+     std::size_t is used, the size of the block is passed as the corresponding\n+     argument.  */\n \n-  /* The user can (optionally) provide a delete function in the promise\n-      type, it's not a failure for it to be absent.  */\n-  tree fns = lookup_promise_method (orig, delname, loc, false);\n   tree del_coro_fr = NULL_TREE;\n-  if (fns && fns != error_mark_node)\n+  tree frame_arg = build1 (CONVERT_EXPR, ptr_type_node, actor_fp);\n+\n+  tree delname = ovl_op_identifier (false, DELETE_EXPR);\n+  tree fns = lookup_promise_method (orig, delname, loc, /*musthave=*/false);\n+  if (fns && BASELINK_P (fns))\n     {\n-      del_coro_fr = lookup_arg_dependent (delname, fns, arglist);\n-      if (OVL_P (del_coro_fr))\n-\tdel_coro_fr = OVL_FIRST (del_coro_fr);\n-      else\n-\tdel_coro_fr = BASELINK_FUNCTIONS (del_coro_fr);\n+      /* Look for sized version first, since this takes precedence.  */\n+      vec<tree, va_gc> *args = make_tree_vector ();\n+      vec_safe_push (args, frame_arg);\n+      vec_safe_push (args, frame_size);\n+      tree dummy_promise = build_dummy_object (promise_type);\n \n-      gcc_checking_assert (DECL_STATIC_FUNCTION_P (del_coro_fr));\n-      TREE_USED (del_coro_fr) = 1;\n-      del_coro_fr = build_call_expr_loc_vec (loc, del_coro_fr, arglist);\n-    }\n+      /* It's OK to fail for this one... */\n+      del_coro_fr = build_new_method_call (dummy_promise, fns, &args,\n+\t\t\t\t\t   NULL_TREE, LOOKUP_NORMAL, NULL,\n+\t\t\t\t\t   tf_none);\n \n-  /* If that fails, then fall back to the global delete operator.  */\n-  if (del_coro_fr == NULL_TREE || del_coro_fr == error_mark_node)\n+      if (!del_coro_fr || del_coro_fr == error_mark_node)\n+\t{\n+\t  release_tree_vector (args);\n+\t  args = make_tree_vector_single (frame_arg);\n+\t  del_coro_fr = build_new_method_call (dummy_promise, fns, &args,\n+\t\t\t\t\t       NULL_TREE, LOOKUP_NORMAL, NULL,\n+\t\t\t\t\t       tf_none);\n+\t}\n+\n+      /* But one of them must succeed, or the program is ill-formed.  */\n+      if (!del_coro_fr || del_coro_fr == error_mark_node)\n+\t{\n+\t  error_at (loc, \"%qE is provided by %qT but is not usable with\"\n+\t\t  \" the function signature %qD\", delname, promise_type, orig);\n+\t  del_coro_fr = error_mark_node;\n+\t}\n+    }\n+  else\n     {\n-      fns =lookup_name_real (delname, 0, 1, /*block_p=*/true, 0, 0);\n-      del_coro_fr = lookup_arg_dependent (del_coro_fr, fns, arglist);\n-      del_coro_fr = build_new_function_call (del_coro_fr, &arglist, true);\n+      del_coro_fr = build_op_delete_call (DELETE_EXPR, frame_arg, frame_size,\n+\t\t\t\t\t  /*global_p=*/true, /*placement=*/NULL,\n+\t\t\t\t\t  /*alloc_fn=*/NULL,\n+\t\t\t\t\t  tf_warning_or_error);\n+      if (!del_coro_fr || del_coro_fr == error_mark_node)\n+\tdel_coro_fr = error_mark_node;\n     }\n \n   del_coro_fr = coro_build_cvt_void_expr_stmt (del_coro_fr, loc);\n@@ -3236,74 +3267,136 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   r = coro_build_cvt_void_expr_stmt (r, fn_start);\n   add_stmt (r);\n \n-  /* We are going to copy the behavior of clang w.r.t to failed allocation\n-     of the coroutine frame.\n-     1. If the promise has a 'get_return_object_on_allocation_failure()'\n-\tmethod, then we use a nothrow new and check the return value, calling\n-\tthe method on failure to initialize an early return.\n-     2. Otherwise, we call new and the ramp is expected to terminate with an\n-\tunhandled exception in the case of failure to allocate.\n-\n-     The get_return_object_on_allocation_failure() must be a static method.  */\n-\n-  tree grooaf_meth\n-    = lookup_promise_method (orig, coro_gro_on_allocation_fail_identifier,\n-\t\t\t     fn_start, /*musthave=*/false);\n-\n   /* The CO_FRAME internal function is a mechanism to allow the middle end\n      to adjust the allocation in response to optimisations.  We provide the\n      current conservative estimate of the frame size (as per the current)\n      computed layout.  */\n+  tree frame_size = TYPE_SIZE_UNIT (coro_frame_type);\n   tree resizeable\n     = build_call_expr_internal_loc (fn_start, IFN_CO_FRAME, size_type_node, 2,\n-\t\t\t\t    TYPE_SIZE_UNIT (coro_frame_type), coro_fp);\n+\t\t\t\t    frame_size, coro_fp);\n+\n+  /* n4849 [dcl.fct.def.coroutine] / 10 (part1)\n+    The unqualified-id get_return_object_on_allocation_failure is looked up\n+    in the scope of the promise type by class member access lookup.  */\n+\n+  tree grooaf_meth\n+    = lookup_promise_method (orig, coro_gro_on_allocation_fail_identifier,\n+\t\t\t     fn_start, /*musthave=*/false);\n \n-  /* We need to adjust the operator new call as per the description above when\n-     there is a return on allocation fail function provided in the promise.  */\n   tree grooaf = NULL_TREE;\n-  vec<tree, va_gc> *arglist;\n-  vec_alloc (arglist, 2);\n-  arglist->quick_push (resizeable);\n+  tree dummy_promise = build_dummy_object (get_coroutine_promise_type (orig));\n+\n+  /* We don't require this, so lookup_promise_method can return NULL...  */\n   if (grooaf_meth && BASELINK_P (grooaf_meth))\n     {\n-      tree fn = BASELINK_FUNCTIONS (grooaf_meth);\n-      if (TREE_CODE (fn) == FUNCTION_DECL && DECL_STATIC_FUNCTION_P (fn))\n-\t{\n-\t  grooaf = build_call_expr_loc (fn_start, fn, 0);\n-\t  TREE_USED (fn) = 1;\n-\t}\n-      tree nth_ns = lookup_qualified_name (std_node, get_identifier (\"nothrow\"),\n-\t\t\t\t\t   0, /*complain=*/true, false);\n-      arglist->quick_push (nth_ns);\n+      /* ... but, if the lookup succeeds, then the function must be\n+\t usable.\n+\t build_new_method_call () wants a valid pointer to (an empty)  args\n+\t list in this case.  */\n+      vec<tree, va_gc> *args = make_tree_vector ();\n+      grooaf = build_new_method_call (dummy_promise, grooaf_meth, &args,\n+\t\t\t\t      NULL_TREE, LOOKUP_NORMAL, NULL,\n+\t\t\t\t      tf_warning_or_error);\n+      release_tree_vector (args);\n     }\n \n-  /* Allocate the frame.  */\n-\n+  /* Allocate the frame, this has several possibilities:\n+     n4849 [dcl.fct.def.coroutine] / 9 (part 1)\n+     The allocation function\u2019s name is looked up in the scope of the promise\n+     type.  It's not a failure for it to be absent see part 4, below.  */\n   tree nwname = ovl_op_identifier (false, NEW_EXPR);\n-  /* The user can (optionally) provide an allocation function in the promise\n-      type, it's not a failure for it to be absent.  */\n   tree fns = lookup_promise_method (orig, nwname, fn_start,\n \t\t\t\t    /*musthave=*/false);\n   tree new_fn = NULL_TREE;\n-  if (fns && fns != error_mark_node)\n-    {\n-      new_fn = lookup_arg_dependent (nwname, fns, arglist);\n-      if (OVL_P (new_fn))\n-\tnew_fn = OVL_FIRST (new_fn);\n-      else\n-\tnew_fn = BASELINK_FUNCTIONS (new_fn);\n+  if (fns && BASELINK_P (fns))\n+    {\n+      /* n4849 [dcl.fct.def.coroutine] / 9 (part 2)\n+\tIf the lookup finds an allocation function in the scope of the promise\n+\ttype, overload resolution is performed on a function call created by\n+\tassembling an argument list.  The first argument is the amount of space\n+\trequested, and has type std::size_t.  The succeeding arguments are\n+\tthose of the original function.  */\n+      vec<tree, va_gc> *args = make_tree_vector ();\n+      vec_safe_push (args, resizeable); /* Space needed.  */\n+      for (tree arg = DECL_ARGUMENTS (orig); arg != NULL;\n+\t   arg = DECL_CHAIN (arg))\n+\tvec_safe_push (args, arg);\n \n-\tgcc_checking_assert (DECL_STATIC_FUNCTION_P (new_fn));\n-\tTREE_USED (new_fn) = 1;\n-\tnew_fn = build_call_expr_loc_vec (fn_start, new_fn, arglist);\n-    }\n+      /* We might need to check that the provided function is nothrow.  */\n+      tree func;\n+      /* Failure is OK for the first attempt.  */\n+      new_fn = build_new_method_call (dummy_promise, fns, &args, NULL,\n+\t\t\t\t      LOOKUP_NORMAL, &func, tf_none);\n+      release_tree_vector (args);\n+\n+      if (!new_fn || new_fn == error_mark_node)\n+\t{\n+\t  /* n4849 [dcl.fct.def.coroutine] / 9 (part 3)\n+\t    If no viable function is found, overload resolution is performed\n+\t    again on a function call created by passing just the amount of\n+\t    space required as an argument of type std::size_t.  */\n+\t  args = make_tree_vector ();\n+\t  vec_safe_push (args, resizeable); /* Space needed.  */\n+\t  new_fn = build_new_method_call (dummy_promise, fns, &args,\n+\t\t\t\t\t  NULL_TREE, LOOKUP_NORMAL, &func,\n+\t\t\t\t\t  tf_none);\n+\t  release_tree_vector (args);\n+\t}\n \n-  /* If that fails, then fall back to the global operator new.  */\n-  if (new_fn == NULL_TREE || new_fn == error_mark_node)\n+     /* However, if the initial lookup succeeded, then one of these two\n+\toptions must be available.  */\n+    if (!new_fn || new_fn == error_mark_node)\n+      {\n+\terror_at (fn_start, \"%qE is provided by %qT but is not usable with\"\n+\t\t  \" the function signature %qD\", nwname, promise_type, orig);\n+\tnew_fn = error_mark_node;\n+      }\n+    else if (grooaf && !TYPE_NOTHROW_P (TREE_TYPE (func)))\n+      error_at (fn_start, \"%qE is provided by %qT but %qE is not marked\"\n+\t\t\" %<throw()%> or %<noexcept%>\", grooaf, promise_type, nwname);\n+    }\n+  else\n     {\n-      fns =lookup_name_real (nwname, 0, 1, /*block_p=*/true, 0, 0);\n-      new_fn = lookup_arg_dependent (nwname, fns, arglist);\n-      new_fn = build_new_function_call (new_fn, &arglist, /*complain=*/true);\n+      /* n4849 [dcl.fct.def.coroutine] / 9 (part 4)\n+\t If this lookup fails, the allocation function\u2019s name is looked up in\n+\t the global scope.  */\n+\n+      vec<tree, va_gc> *args;\n+      /* build_operator_new_call () will insert size needed as element 0 of\n+\t this, and we might need to append the std::nothrow constant.  */\n+      vec_alloc (args, 2);\n+\n+      if (grooaf)\n+\t{\n+\t  /* n4849 [dcl.fct.def.coroutine] / 10 (part 2)\n+\t   If any declarations (of the get return on allocation fail) are\n+\t   found, then the result of a call to an allocation function used\n+\t   to obtain storage for the coroutine state is assumed to return\n+\t   nullptr if it fails to obtain storage and, if a global allocation\n+\t   function is selected, the ::operator new(size_t, nothrow_t) form\n+\t   is used.  The allocation function used in this case shall have a\n+\t   non-throwing noexcept-specification.  So we need std::nothrow.  */\n+\t  tree std_nt = lookup_qualified_name (std_node,\n+\t\t\t\t\t       get_identifier (\"nothrow\"),\n+\t\t\t\t\t       0, /*complain=*/true, false);\n+\t  vec_safe_push (args, std_nt);\n+\t}\n+\n+      /* If we get to this point, we must succeed in looking up the global\n+\t operator new for the params provided.  Extract a simplified version\n+\t of the machinery from build_operator_new_call.  This can update the\n+\t frame size.  */\n+      tree cookie = NULL;\n+      new_fn = build_operator_new_call (nwname, &args, &frame_size, &cookie,\n+\t\t\t\t\t/*align_arg=*/NULL,\n+\t\t\t\t\t/*size_check=*/NULL, /*fn=*/NULL,\n+\t\t\t\t\ttf_warning_or_error);\n+      resizeable = build_call_expr_internal_loc\n+\t(fn_start, IFN_CO_FRAME, size_type_node, 2, frame_size, coro_fp);\n+      CALL_EXPR_ARG (new_fn, 0) = resizeable;\n+\n+      release_tree_vector (args);\n     }\n \n   tree allocated = build1 (CONVERT_EXPR, coro_frame_ptr, new_fn);\n@@ -3317,7 +3410,12 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   if (grooaf)\n     {\n-      tree cfra_label\n+      /* n4849 [dcl.fct.def.coroutine] / 10 (part 3)\n+\t If the allocation function returns nullptr,the coroutine returns\n+\t control to the caller of the coroutine and the return value is\n+\t obtained by a call to T::get_return_object_on_allocation_failure(),\n+\t where T is the promise type.  */\n+       tree cfra_label\n \t= create_named_label_with_ctx (fn_start, \"coro.frame.active\",\n \t\t\t\t       current_scope ());\n       tree early_ret_list = NULL;\n@@ -3349,8 +3447,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* deref the frame pointer, to use in member access code.  */\n   tree deref_fp = build_x_arrow (fn_start, coro_fp, tf_warning_or_error);\n \n-  /* For now, we always assume that this needs destruction, there's no impl.\n-     for frame allocation elision.  */\n+  /* For now, once allocation has succeeded we always assume that this needs\n+     destruction, there's no impl. for frame allocation elision.  */\n   tree fnf_m\n     = lookup_member (coro_frame_type, fnf_name, 1, 0, tf_warning_or_error);\n   tree fnf_x = build_class_member_access_expr (deref_fp, fnf_m, NULL_TREE,\n@@ -3724,7 +3822,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* Actor ...  */\n   build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n \t\t  &local_var_uses, param_dtor_list, initial_await, final_await,\n-\t\t  body_aw_points.count);\n+\t\t  body_aw_points.count, frame_size);\n \n   /* Destroyer ... */\n   build_destroy_fn (fn_start, coro_frame_type, destroy, actor);"}, {"sha": "46344a6334452725e7c97c60a95c5af0308d5716", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -1,3 +1,16 @@\n+2020-02-12 Iain Sandoe <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/coro1-allocators.h: New.\n+\t* g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C: New test.\n+\t* g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C: New test.\n+\t* g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C: New test.\n+\t* g++.dg/coroutines/torture/alloc-00-gro-on-alloc-fail.C: Use new\n+\tcoro1-allocators.h header.\n+\t* g++.dg/coroutines/torture/alloc-01-overload-newdel.C: Likewise.\n+\t* g++.dg/coroutines/torture/alloc-02-fail-new-grooaf-check.C: New.\n+\t* g++.dg/coroutines/torture/alloc-03-overload-new-1.C: New test.\n+\t* g++.dg/coroutines/torture/alloc-04-overload-del-use-two-args.C:New.\n+\n 2020-02-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/powerpc/pr93122.c: Use -mprefixed instead of"}, {"sha": "1fdce1dad1dbcd48f60ab513d7e7c5f18a0d903e", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-alloc-00-bad-op-new.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-00-bad-op-new.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-00-bad-op-new.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-00-bad-op-new.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// check error for a bad overload of operator new.\n+\n+#define BOGUS_OPNEW_CASE1\n+#include \"coro1-allocators.h\"\n+\n+struct coro1\n+f ()  /* { dg-error {'operator new' is provided by 'std::__n4835::coroutine_traits<coro1>::promise_type' \\{aka 'coro1::promise_type'\\} but is not usable with the function signature 'coro1 f\\(\\)'} } */\n+{\n+  co_return;\n+}"}, {"sha": "be804796835048ccd5d28a30767350c0a6584b2c", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-alloc-01-bad-op-del.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-01-bad-op-del.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-01-bad-op-del.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-01-bad-op-del.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,13 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// check error for a bad overload of operator delete.\n+\n+#define BOGUS_OPDEL_CASE1\n+#include \"coro1-allocators.h\"\n+\n+struct coro1\n+f ()  /* { dg-error {'operator delete' is provided by 'std::__n4835::coroutine_traits<coro1>::promise_type' \\{aka 'coro1::promise_type'\\} but is not usable with the function signature 'coro1 f\\(\\)'} } */\n+{\n+  co_return;\n+}\n+"}, {"sha": "eae2dada911bf8797c2837f8b1ef7b2e662bee1f", "filename": "gcc/testsuite/g++.dg/coroutines/coro-bad-alloc-02-no-op-new-nt.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-02-no-op-new-nt.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-02-no-op-new-nt.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro-bad-alloc-02-no-op-new-nt.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,15 @@\n+//  { dg-additional-options \"-fsyntax-only -w\" }\n+\n+// check error for missing new (size, nothrow).\n+\n+#define PROVIDE_NEW_SZT\n+#define PROVIDE_DEL_VP\n+#define PROVIDE_GROOAF\n+\n+#include \"coro1-allocators.h\"\n+\n+struct coro1\n+f () /* { dg-error {'coro1::promise_type::get_return_object_on_allocation_failure\\(\\)\\(\\)' is provided by 'std::__n4835::coroutine_traits<coro1>::promise_type' \\{aka 'coro1::promise_type'\\} but 'operator new' is not marked 'throw\\(\\)' or 'noexcept'} } */\n+{\n+  co_return;\n+}"}, {"sha": "3d86910600608cc3612acc9de07723ca9cd3bc5f", "filename": "gcc/testsuite/g++.dg/coroutines/coro1-allocators.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-allocators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-allocators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fcoro1-allocators.h?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,184 @@\n+/* Include <coroutine> or the equivalent.  */\n+#include \"coro.h\"\n+\n+/* Allow for stand-alone testing with no headers installed.  */\n+#if __has_include(<new>)\n+#  include <new>\n+#else\n+\n+/* Required when get_return_object_on_allocation_failure() is defined by\n+  the promise.  We need a no-throw new, and new etc.  build the relevant\n+  pieces here to avoid needing the headers in the test.  */\n+\n+namespace std {\n+  struct nothrow_t {};\n+  constexpr nothrow_t nothrow = {};\n+  typedef __SIZE_TYPE__ size_t;\n+} // end namespace std\n+\n+void* operator new(std::size_t, const std::nothrow_t&) noexcept;\n+void  operator delete(void* __p, const std::nothrow_t&) noexcept;\n+\n+#endif\n+\n+/* Flags and counters so that we can test that the methods we expected\n+   to be called, were called (and the correct number of times).  */\n+\n+#ifdef USE_FAILING_OP_NEW\n+extern int used_failing_new;\n+#endif\n+\n+#if defined (PROVIDE_NEW_SZT) || defined (PROVIDE_NEW_SZT_INT)\n+extern int used_ovl_new;\n+#endif\n+\n+#ifdef PROVIDE_NEW_SZT_NT\n+extern void *malloc (size_t);\n+extern int used_ovl_new_nt;\n+#endif\n+\n+#ifdef PROVIDE_DEL_VP\n+extern int used_ovl_del;\n+#endif\n+\n+#ifdef PROVIDE_DEL_VP_SZT\n+extern int used_ovl_del_2arg;\n+#endif\n+\n+#ifdef PROVIDE_GROOAF\n+extern int used_grooaf;\n+#endif\n+\n+struct coro1 {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n+  handle_type handle;\n+  coro1 () noexcept : handle(0) {}\n+  coro1 (handle_type _handle) noexcept\n+    : handle(_handle)  {\n+        PRINT(\"Created coro1 object from handle\");\n+  }\n+  coro1 (const coro1 &) = delete; // no copying\n+  coro1 (coro1 &&s) noexcept : handle(s.handle)  {\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 mv ctor \");\n+  }\n+  coro1 &operator = (coro1 &&s) noexcept {\n+\thandle = s.handle;\n+\ts.handle = nullptr;\n+\tPRINT(\"coro1 op=  \");\n+\treturn *this;\n+  }\n+  ~coro1() noexcept {\n+        PRINT(\"Destroyed coro1\");\n+        if ( handle )\n+          handle.destroy();\n+  }\n+\n+  struct suspend_never_prt {\n+  bool await_ready() const noexcept { return true; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n+  ~suspend_never_prt() {};\n+  };\n+\n+  struct  suspend_always_prt {\n+  bool await_ready() const noexcept { return false; }\n+  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n+  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n+  };\n+\n+  struct promise_type {\n+  promise_type() {  PRINT (\"Created Promise\"); }\n+  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+\n+  auto get_return_object () {\n+    PRINT (\"get_return_object: handle from promise\");\n+    return handle_type::from_promise (*this);\n+  }\n+  auto initial_suspend () {\n+    PRINT (\"get initial_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  auto final_suspend () {\n+    PRINT (\"get final_suspend (always)\");\n+    return suspend_always_prt{};\n+  }\n+  void return_void () {\n+    PRINT (\"return_void ()\");\n+  }\n+  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n+\n+#ifdef USE_FAILING_OP_NEW\n+  /* Provide an operator, that always fails.  */\n+  void *operator new (std::size_t sz) noexcept {\n+    PRINT (\"promise_type: used failing op new\");\n+    used_failing_new++;\n+    return nullptr;\n+  }\n+#endif\n+\n+#ifdef PROVIDE_NEW_SZT\n+  void *operator new (std::size_t sz) {\n+    PRINT (\"promise_type: used overloaded operator new\");\n+    used_ovl_new++;\n+    return ::operator new(sz);\n+  }\n+#endif\n+\n+#ifdef PROVIDE_NEW_SZT_NT\n+  void *operator new (std::size_t sz, const std::nothrow_t&) noexcept {\n+    PRINT (\"promise_type: used overloaded operator new NT\");\n+    return malloc (sz);\n+  }\n+#endif\n+\n+#ifdef PROVIDE_NEW_SZT_INT\n+  void *operator new (std::size_t sz, int x) {\n+    PRINT (\"promise_type: used overloaded operator new with int arg\");\n+    used_ovl_new += x;\n+    return ::operator new(sz);\n+  }\n+#endif\n+\n+#ifdef PROVIDE_DEL_VP\n+  void operator delete (void *p) {\n+    PRINT (\"promise_type: used overloaded operator delete 1 arg\");\n+    used_ovl_del++;\n+    return ::operator delete(p);\n+  }\n+#endif\n+\n+#ifdef PROVIDE_DEL_VP_SZT\n+  void operator delete (void *p, std::size_t sz) {\n+    PRINT (\"promise_type: used overloaded operator delete 2 args\");\n+    used_ovl_del_2arg++;\n+    return ::operator delete(p);\n+  }\n+#endif\n+\n+#ifdef BOGUS_OPNEW_CASE1\n+  /* Provide an operator, but it doesn't match on overload.  */\n+  void *operator new (std::size_t sz, char *f) noexcept {\n+    PRINT (\"promise_type: used bogus op new\");\n+    return nullptr;\n+  }\n+#endif\n+\n+#ifdef BOGUS_OPDEL_CASE1\n+  /* Provide an operator, but it doesn't match on overload.  */\n+  void operator delete (void *p, char *f) {\n+    PRINT (\"promise_type: used bogus overloaded operator delete\");\n+  }\n+#endif\n+\n+#ifdef PROVIDE_GROOAF\n+  static coro1 get_return_object_on_allocation_failure () noexcept {\n+    PRINT (\"alloc fail return\");\n+    used_grooaf++;\n+    return coro1 (nullptr);\n+  }\n+#endif\n+\n+  }; // promise\n+}; // coro1"}, {"sha": "ca07a3a03d00b810eb67ce12598a1fd4a6596bb9", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-00-gro-on-alloc-fail.C", "status": "modified", "additions": 9, "deletions": 89, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-00-gro-on-alloc-fail.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-00-gro-on-alloc-fail.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-00-gro-on-alloc-fail.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -1,96 +1,13 @@\n //  { dg-do run }\n \n-// check the code-gen for the failed alloc return.\n+/* check the code-gen for the failed alloc return.\n+   Here we use an allocator that doesn't fail so that the code\n+   is generated, but the regular path is run.  */\n \n-#include \"../coro.h\"\n+#define PROVIDE_GROOAF\n+#include \"../coro1-allocators.h\"\n \n-#if __has_include(<new>)\n-#  include <new>\n-#else\n-\n-// Required when get_return_object_on_allocation_failure() is defined by\n-// the promise.\n-// we need a no-throw new, and new etc.  build the relevant pieces here to\n-// avoid needing the headers in the test.\n-\n-namespace std {\n-  struct nothrow_t {};\n-  constexpr nothrow_t nothrow = {};\n-  typedef __SIZE_TYPE__ size_t;\n-} // end namespace std\n-\n-void* operator new(std::size_t, const std::nothrow_t&) noexcept;\n-void  operator delete(void* __p, const std::nothrow_t&) noexcept;\n-#endif\n-\n-struct coro1 {\n-  struct promise_type;\n-  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n-  handle_type handle;\n-  coro1 () noexcept : handle(0) {}\n-  coro1 (handle_type _handle) noexcept\n-    : handle(_handle)  {\n-        PRINT(\"Created coro1 object from handle\");\n-  }\n-  coro1 (const coro1 &) = delete; // no copying\n-  coro1 (coro1 &&s) noexcept : handle(s.handle)  {\n-\ts.handle = nullptr;\n-\tPRINT(\"coro1 mv ctor \");\n-  }\n-  coro1 &operator = (coro1 &&s) noexcept {\n-\thandle = s.handle;\n-\ts.handle = nullptr;\n-\tPRINT(\"coro1 op=  \");\n-\treturn *this;\n-  }\n-  ~coro1() noexcept {\n-        PRINT(\"Destroyed coro1\");\n-        if ( handle )\n-          handle.destroy();\n-  }\n-\n-  struct suspend_never_prt {\n-  bool await_ready() const noexcept { return true; }\n-  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n-  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n-  ~suspend_never_prt() {};\n-  };\n-\n-  struct  suspend_always_prt {\n-  bool await_ready() const noexcept { return false; }\n-  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n-  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n-  };\n-\n-  struct promise_type {\n-  promise_type() {  PRINT (\"Created Promise\"); }\n-  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n-\n-  auto get_return_object () {\n-    PRINT (\"get_return_object: handle from promise\");\n-    return handle_type::from_promise (*this);\n-  }\n-  auto initial_suspend () {\n-    PRINT (\"get initial_suspend (always)\");\n-    return suspend_always_prt{};\n-  }\n-  auto final_suspend () {\n-    PRINT (\"get final_suspend (always)\");\n-    return suspend_always_prt{};\n-  }\n-  void return_void () {\n-    PRINT (\"return_void ()\");\n-  }\n-  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n-  static coro1 get_return_object_on_allocation_failure () noexcept;\n-  }; // promise\n-}; // coro1\n-\n-coro1 coro1::promise_type::\n-get_return_object_on_allocation_failure () noexcept {\n-  PRINT (\"alloc fail return\");\n-  return coro1 (nullptr);\n-}\n+int used_grooaf = 0;\n \n struct coro1\n f () noexcept\n@@ -103,6 +20,9 @@ int main ()\n {\n   PRINT (\"main: create coro1\");\n   struct coro1 x = f ();\n+  if (used_grooaf)\n+    abort ();\n+\n   PRINT (\"main: got coro1 - resuming\");\n   if (x.handle.done())\n     abort();"}, {"sha": "98babcaf4f4b8c4ab915395d46f0966b99fdf7dd", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-01-overload-newdel.C", "status": "modified", "additions": 5, "deletions": 76, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-01-overload-newdel.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-01-overload-newdel.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-01-overload-newdel.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -1,86 +1,15 @@\n //  { dg-do run }\n \n-// check codegen for overloaded operator new/delete.\n+// check codegen for overloaded simple operator new/delete.\n \n-#include \"../coro.h\"\n+#define PROVIDE_NEW_SZT\n+#define PROVIDE_DEL_VP\n+\n+#include \"../coro1-allocators.h\"\n \n int used_ovl_new = 0;\n int used_ovl_del = 0;\n \n-struct coro1 {\n-  struct promise_type;\n-  using handle_type = coro::coroutine_handle<coro1::promise_type>;\n-  handle_type handle;\n-  coro1 () noexcept : handle(0) {}\n-  coro1 (handle_type _handle) noexcept\n-    : handle(_handle)  {\n-        PRINT(\"Created coro1 object from handle\");\n-  }\n-  coro1 (const coro1 &) = delete; // no copying\n-  coro1 (coro1 &&s) noexcept : handle(s.handle)  {\n-\ts.handle = nullptr;\n-\tPRINT(\"coro1 mv ctor \");\n-  }\n-  coro1 &operator = (coro1 &&s) noexcept {\n-\thandle = s.handle;\n-\ts.handle = nullptr;\n-\tPRINT(\"coro1 op=  \");\n-\treturn *this;\n-  }\n-  ~coro1() noexcept {\n-        PRINT(\"Destroyed coro1\");\n-        if ( handle )\n-          handle.destroy();\n-  }\n-\n-  struct suspend_never_prt {\n-  bool await_ready() const noexcept { return true; }\n-  void await_suspend(handle_type) const noexcept { PRINT (\"susp-never-susp\");}\n-  void await_resume() const noexcept { PRINT (\"susp-never-resume\");}\n-  ~suspend_never_prt() {};\n-  };\n-\n-  struct  suspend_always_prt {\n-  bool await_ready() const noexcept { return false; }\n-  void await_suspend(handle_type) const noexcept { PRINT (\"susp-always-susp\");}\n-  void await_resume() const noexcept { PRINT (\"susp-always-resume\");}\n-  };\n-\n-  struct promise_type {\n-  promise_type() {  PRINT (\"Created Promise\"); }\n-  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n-\n-  void *operator new (std::size_t sz) {\n-    PRINT (\"promise_type: used overloaded operator new\");\n-    used_ovl_new++;\n-    return ::operator new(sz);\n-  }\n-\n-  void operator delete (void *p)  {\n-    PRINT (\"promise_type: used overloaded operator delete\");\n-    used_ovl_del++;\n-    return ::operator delete(p);\n-  }\n-\n-  auto get_return_object () {\n-    PRINT (\"get_return_object: handle from promise\");\n-    return handle_type::from_promise (*this);\n-  }\n-  auto initial_suspend () {\n-    PRINT (\"get initial_suspend (always)\");\n-    return suspend_always_prt{};\n-  }\n-  auto final_suspend () {\n-    PRINT (\"get final_suspend (always)\");\n-    return suspend_always_prt{};\n-  }\n-  void return_void () {\n-    PRINT (\"return_void ()\");\n-  }\n-  void unhandled_exception() { PRINT (\"** unhandled exception\"); }\n-  }; // promise\n-}; // coro1\n-\n struct coro1\n f () noexcept\n {"}, {"sha": "7911cc8c43dfdba174a9dfeb6f81fcd8233dad40", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-02-fail-new-grooaf-check.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-02-fail-new-grooaf-check.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-02-fail-new-grooaf-check.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-02-fail-new-grooaf-check.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,41 @@\n+//  { dg-do run }\n+\n+/* check the code-gen for the failed alloc return.\n+   In this case, we use an operator new that always fails.\n+   So the g-r-o-o-a-f should fire.  */\n+\n+#define PROVIDE_GROOAF\n+#define USE_FAILING_OP_NEW\n+#include \"../coro1-allocators.h\"\n+\n+int used_grooaf = 0;\n+int used_failing_new = 0;\n+\n+struct coro1\n+f () noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  /* nest a scope so that we can check the counts.  */\n+  {\n+    PRINT (\"main: create coro1\");\n+    struct coro1 x = f ();\n+    /* we don't expect to be able to do anything.  */\n+    if (used_failing_new != 1)\n+      {\n+\tPRINT (\"main: we should have used the failing op new\");\n+        abort ();\n+      }\n+    if (used_grooaf != 1)\n+      {\n+\tPRINT (\"main: we should have used the GROOAF\");\n+        abort ();\n+      }\n+  }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "b1d6743fd912457c950ddac72e6947e0e850d712", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-03-overload-new-1.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-03-overload-new-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-03-overload-new-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-03-overload-new-1.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,55 @@\n+//  { dg-do run }\n+\n+/* check codegen for overloaded simple operator new/delete.\n+   here check that we prefer the overload that accounts the function\n+   args.  */\n+\n+#define PROVIDE_NEW_SZT\n+#define PROVIDE_NEW_SZT_INT\n+#define PROVIDE_DEL_VP\n+\n+#include \"../coro1-allocators.h\"\n+\n+int used_ovl_new = 0;\n+int used_ovl_del = 0;\n+\n+struct coro1\n+f (int v) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  // Nest a scope so that we can inspect the flags after the DTORs run.\n+  {\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (5);\n+\n+  if (used_ovl_new != 5)\n+    {\n+      PRINT (\"main: apparently used the wrong op new...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  }\n+\n+  if (used_ovl_del != 1)\n+    {\n+      PRINT (\"main: failed to call overloaded operator delete\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "2987c6ef116f7f83162824ca9f213912b3ce09d4", "filename": "gcc/testsuite/g++.dg/coroutines/torture/alloc-04-overload-del-use-two-args.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-04-overload-del-use-two-args.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-04-overload-del-use-two-args.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Falloc-04-overload-del-use-two-args.C?ref=68bb7e3b9dc3be6c9ceecc2c87b9c678e1a045dc", "patch": "@@ -0,0 +1,60 @@\n+//  { dg-do run }\n+\n+/* check that we use the deallocation function with two args when both\n+   are available.  */\n+\n+#define PROVIDE_NEW_SZT\n+#define PROVIDE_DEL_VP\n+#define PROVIDE_DEL_VP_SZT\n+\n+#include \"../coro1-allocators.h\"\n+\n+int used_ovl_new = 0;\n+int used_ovl_del = 0;\n+int used_ovl_del_2arg = 0;\n+\n+struct coro1\n+f (int v) noexcept\n+{\n+  PRINT (\"coro1: about to return\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  // Nest a scope so that we can inspect the flags after the DTORs run.\n+  {\n+  PRINT (\"main: create coro1\");\n+  struct coro1 x = f (5);\n+\n+  if (used_ovl_new != 1)\n+    {\n+      PRINT (\"main: apparently used the wrong op new...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"main: got coro1 - resuming\");\n+  if (x.handle.done())\n+    abort();\n+  x.handle.resume();\n+  PRINT (\"main: after resume\");\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"main: apparently not done...\");\n+      abort ();\n+    }\n+  }\n+  if (used_ovl_del != 0)\n+    {\n+      PRINT (\"main: wrong call to overloaded operator delete 1 arg\");\n+      abort ();\n+    }\n+\n+  if (used_ovl_del_2arg != 1)\n+    {\n+      PRINT (\"main: failed to call overloaded operator delete 2 args\");\n+      abort ();\n+    }\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}]}