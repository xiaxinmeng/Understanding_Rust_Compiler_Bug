{"sha": "9e9fb0ce6784ad84623738a559b5f67d78c84125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5ZmIwY2U2Nzg0YWQ4NDYyMzczOGE1NTliNWY2N2Q3OGM4NDEyNQ==", "commit": {"author": {"name": "Jan Beulich", "email": "jbeulich@novell.com", "date": "2004-07-09T22:35:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-09T22:35:35Z"}, "message": "i386.c (classify_argument): Treat V1xx modes the same as their base modes.\n\n        * config/i386/i386.c (classify_argument): Treat V1xx modes the same as\n        their base modes. CTImode, TCmode, and XCmode must be passed in memory.\n        TFmode (__float128) must be is an SSE/SSEUP pair. V2SImode, V4HImode,\n        and V8QI are class SSE. All sufficiently small remaining vector modes\n        must be passed in one or two integer registers.\n        (ix86_libcall_value): TFmode must be returned in xmm0, XCmode must be\n        returned in memory.\n        (bdesc_2arg, ix86_init_mmx_sse_builtins): __builtin_ia32_pmuludq and\n        __builtin_ia32_pmuludq128 have non-uniform argument and return types\n        and must thus be handled explicitly.\n        * config/i386/i386.md (*movdi_1_rex64): Add cases for moving between\n        MMX and XMM regs.\n        (movv8qi_internal, movv4hi_internal, movv2si_internal,\n        movv2sf_internal): Permit moving between MMX and XMM registers (since\n        MMX areguments and return values are passed in XMM registers).\n        (sse2_umulsidi3): Correct type and mode.\n\nFrom-SVN: r84410", "tree": {"sha": "3c1f045cf03960d8636bd8748ec94c9179a80ac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c1f045cf03960d8636bd8748ec94c9179a80ac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9fb0ce6784ad84623738a559b5f67d78c84125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9fb0ce6784ad84623738a559b5f67d78c84125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9fb0ce6784ad84623738a559b5f67d78c84125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9fb0ce6784ad84623738a559b5f67d78c84125/comments", "author": null, "committer": null, "parents": [{"sha": "f7fda74995eba965f74b55587caaa33b86d550eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fda74995eba965f74b55587caaa33b86d550eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7fda74995eba965f74b55587caaa33b86d550eb"}], "stats": {"total": 151, "additions": 110, "deletions": 41}, "files": [{"sha": "2486648f955008d0869fe1e04a928fb0d61dc453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9fb0ce6784ad84623738a559b5f67d78c84125/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9fb0ce6784ad84623738a559b5f67d78c84125/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e9fb0ce6784ad84623738a559b5f67d78c84125", "patch": "@@ -1,3 +1,22 @@\n+2004-04-09  Jan Beulich  <jbeulich@novell.com>\n+\n+\t* config/i386/i386.c (classify_argument): Treat V1xx modes the same as\n+\ttheir base modes. CTImode, TCmode, and XCmode must be passed in memory.\n+\tTFmode (__float128) must be is an SSE/SSEUP pair. V2SImode, V4HImode,\n+\tand V8QI are class SSE. All sufficiently small remaining vector modes\n+\tmust be passed in one or two integer registers.\n+\t(ix86_libcall_value): TFmode must be returned in xmm0, XCmode must be\n+\treturned in memory.\n+\t(bdesc_2arg, ix86_init_mmx_sse_builtins): __builtin_ia32_pmuludq and\n+\t__builtin_ia32_pmuludq128 have non-uniform argument and return types\n+\tand must thus be handled explicitly.\n+\t* config/i386/i386.md (*movdi_1_rex64): Add cases for moving between\n+\tMMX and XMM regs.\n+\t(movv8qi_internal, movv4hi_internal, movv2si_internal,\n+\tmovv2sf_internal): Permit moving between MMX and XMM registers (since\n+\tMMX areguments and return values are passed in XMM registers).\n+\t(sse2_umulsidi3): Correct type and mode.\n+\n 2004-04-09  Richard Henderson  <rth@redhat.com>\n \n \t* tree-cfg.c (dump_cfg_stats): Fix 64-bit format mismatch errors."}, {"sha": "a9ebf210910dea866fc9feb281988432d888acb1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9fb0ce6784ad84623738a559b5f67d78c84125/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9fb0ce6784ad84623738a559b5f67d78c84125/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9e9fb0ce6784ad84623738a559b5f67d78c84125", "patch": "@@ -2265,6 +2265,11 @@ classify_argument (enum machine_mode mode, tree type,\n \treturn 0;\n     }\n \n+  /* for V1xx modes, just use the base mode */\n+  if (VECTOR_MODE_P (mode)\n+      && GET_MODE_SIZE (GET_MODE_INNER (mode)) == bytes)\n+    mode = GET_MODE_INNER (mode);\n+\n   /* Classification of atomic types.  */\n   switch (mode)\n     {\n@@ -2285,9 +2290,7 @@ classify_argument (enum machine_mode mode, tree type,\n       classes[0] = classes[1] = X86_64_INTEGER_CLASS;\n       return 2;\n     case CTImode:\n-      classes[0] = classes[1] = X86_64_INTEGER_CLASS;\n-      classes[2] = classes[3] = X86_64_INTEGER_CLASS;\n-      return 4;\n+      return 0;\n     case SFmode:\n       if (!(bit_offset % 64))\n \tclasses[0] = X86_64_SSESF_CLASS;\n@@ -2302,21 +2305,20 @@ classify_argument (enum machine_mode mode, tree type,\n       classes[1] = X86_64_X87UP_CLASS;\n       return 2;\n     case TFmode:\n-    case TCmode:\n-      return 0;\n-    case XCmode:\n-      classes[0] = X86_64_X87_CLASS;\n-      classes[1] = X86_64_X87UP_CLASS;\n-      classes[2] = X86_64_X87_CLASS;\n-      classes[3] = X86_64_X87UP_CLASS;\n-      return 4;\n-    case DCmode:\n-      classes[0] = X86_64_SSEDF_CLASS;\n-      classes[1] = X86_64_SSEDF_CLASS;\n+      classes[0] = X86_64_SSE_CLASS;\n+      classes[1] = X86_64_SSEUP_CLASS;\n       return 2;\n     case SCmode:\n       classes[0] = X86_64_SSE_CLASS;\n       return 1;\n+    case DCmode:\n+      classes[0] = X86_64_SSEDF_CLASS;\n+      classes[1] = X86_64_SSEDF_CLASS;\n+      return 2;\n+    case XCmode:\n+    case TCmode:\n+      /* These modes are larger than 16 bytes.  */\n+      return 0;\n     case V4SFmode:\n     case V4SImode:\n     case V16QImode:\n@@ -2330,11 +2332,26 @@ classify_argument (enum machine_mode mode, tree type,\n     case V2SImode:\n     case V4HImode:\n     case V8QImode:\n-      return 0;\n+      classes[0] = X86_64_SSE_CLASS;\n+      return 1;\n     case BLKmode:\n     case VOIDmode:\n       return 0;\n     default:\n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  if (bytes > 16)\n+\t    return 0;\n+\t  if (GET_MODE_CLASS (GET_MODE_INNER (mode)) == MODE_INT)\n+\t    {\n+\t      if (bit_offset + GET_MODE_BITSIZE (mode) <= 32)\n+\t\tclasses[0] = X86_64_INTEGERSI_CLASS;\n+\t      else\n+\t\tclasses[0] = X86_64_INTEGER_CLASS;\n+\t      classes[1] = X86_64_INTEGER_CLASS;\n+\t      return 1 + (bytes > 8);\n+\t    }\n+\t}\n       abort ();\n     }\n }\n@@ -2963,11 +2980,11 @@ ix86_libcall_value (enum machine_mode mode)\n \tcase SCmode:\n \tcase DFmode:\n \tcase DCmode:\n+\tcase TFmode:\n \t  return gen_rtx_REG (mode, FIRST_SSE_REG);\n \tcase XFmode:\n-\tcase XCmode:\n \t  return gen_rtx_REG (mode, FIRST_FLOAT_REG);\n-\tcase TFmode:\n+\tcase XCmode:\n \tcase TCmode:\n \t  return NULL;\n \tdefault:\n@@ -12856,8 +12873,6 @@ static const struct builtin_description bdesc_2arg[] =\n \n   { MASK_SSE2, CODE_FOR_mulv8hi3, \"__builtin_ia32_pmullw128\", IX86_BUILTIN_PMULLW128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_smulv8hi3_highpart, \"__builtin_ia32_pmulhw128\", IX86_BUILTIN_PMULHW128, 0, 0 },\n-  { MASK_SSE2, CODE_FOR_sse2_umulsidi3, \"__builtin_ia32_pmuludq\", IX86_BUILTIN_PMULUDQ, 0, 0 },\n-  { MASK_SSE2, CODE_FOR_sse2_umulv2siv2di3, \"__builtin_ia32_pmuludq128\", IX86_BUILTIN_PMULUDQ128, 0, 0 },\n \n   { MASK_SSE2, CODE_FOR_sse2_andv2di3, \"__builtin_ia32_pand128\", IX86_BUILTIN_PAND128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_sse2_nandv2di3, \"__builtin_ia32_pandn128\", IX86_BUILTIN_PANDN128, 0, 0 },\n@@ -12895,6 +12910,9 @@ static const struct builtin_description bdesc_2arg[] =\n   { MASK_SSE2, CODE_FOR_umulv8hi3_highpart, \"__builtin_ia32_pmulhuw128\", IX86_BUILTIN_PMULHUW128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_sse2_psadbw, 0, IX86_BUILTIN_PSADBW128, 0, 0 },\n \n+  { MASK_SSE2, CODE_FOR_sse2_umulsidi3, 0, IX86_BUILTIN_PMULUDQ, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_sse2_umulv2siv2di3, 0, IX86_BUILTIN_PMULUDQ128, 0, 0 },\n+\n   { MASK_SSE2, CODE_FOR_ashlv8hi3_ti, 0, IX86_BUILTIN_PSLLW128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_ashlv8hi3, 0, IX86_BUILTIN_PSLLWI128, 0, 0 },\n   { MASK_SSE2, CODE_FOR_ashlv4si3_ti, 0, IX86_BUILTIN_PSLLD128, 0, 0 },\n@@ -13290,9 +13308,15 @@ ix86_init_mmx_sse_builtins (void)\n   tree di_ftype_v8qi_v8qi\n     = build_function_type_list (long_long_unsigned_type_node,\n \t\t\t\tV8QI_type_node, V8QI_type_node, NULL_TREE);\n+  tree di_ftype_v2si_v2si\n+    = build_function_type_list (long_long_unsigned_type_node,\n+\t\t\t\tV2SI_type_node, V2SI_type_node, NULL_TREE);\n   tree v2di_ftype_v16qi_v16qi\n     = build_function_type_list (V2DI_type_node,\n \t\t\t\tV16QI_type_node, V16QI_type_node, NULL_TREE);\n+  tree v2di_ftype_v4si_v4si\n+    = build_function_type_list (V2DI_type_node,\n+\t\t\t\tV4SI_type_node, V4SI_type_node, NULL_TREE);\n   tree int_ftype_v16qi\n     = build_function_type_list (integer_type_node, V16QI_type_node, NULL_TREE);\n   tree v16qi_ftype_pcchar\n@@ -13588,6 +13612,9 @@ ix86_init_mmx_sse_builtins (void)\n \n   def_builtin (MASK_SSE, \"__builtin_ia32_setzero128\", v2di_ftype_void, IX86_BUILTIN_CLRTI);\n \n+  def_builtin (MASK_SSE2, \"__builtin_ia32_pmuludq\", di_ftype_v2si_v2si, IX86_BUILTIN_PMULUDQ);\n+  def_builtin (MASK_SSE2, \"__builtin_ia32_pmuludq128\", v2di_ftype_v4si_v4si, IX86_BUILTIN_PMULUDQ128);\n+\n   def_builtin (MASK_SSE2, \"__builtin_ia32_psllw128\", v8hi_ftype_v8hi_v2di, IX86_BUILTIN_PSLLW128);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_pslld128\", v4si_ftype_v4si_v2di, IX86_BUILTIN_PSLLD128);\n   def_builtin (MASK_SSE2, \"__builtin_ia32_psllq128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_PSLLQ128);"}, {"sha": "c3b335e5c3ea07775bd3adf10b7958339cfbf930", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9fb0ce6784ad84623738a559b5f67d78c84125/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9fb0ce6784ad84623738a559b5f67d78c84125/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9e9fb0ce6784ad84623738a559b5f67d78c84125", "patch": "@@ -1963,14 +1963,19 @@\n   \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*movdi_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!*y,!rm,!*y,!*Y,!rm,!*Y\")\n-\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,*y,rm,*Y,*Y,rm\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!*y,!rm,!*y,!*Y,!rm,!*Y,!*Y,!*y\")\n+\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,*y,rm,*Y,*Y,rm,*y,*Y\"))]\n   \"TARGET_64BIT\n    && (TARGET_INTER_UNIT_MOVES || optimize_size)\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n   switch (get_attr_type (insn))\n     {\n+    case TYPE_SSECVT:\n+      if (which_alternative == 11)\n+\treturn \"movq2dq\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movdq2q\\t{%1, %0|%0, %1}\";\n     case TYPE_SSEMOV:\n       if (get_attr_mode (insn) == MODE_TI)\n \t  return \"movdqa\\t{%1, %0|%0, %1}\";\n@@ -2001,16 +2006,18 @@\n \t      (const_string \"mmxmov\")\n \t    (eq_attr \"alternative\" \"8,9,10\")\n \t      (const_string \"ssemov\")\n+\t    (eq_attr \"alternative\" \"11,12\")\n+\t      (const_string \"ssecvt\")\n \t    (eq_attr \"alternative\" \"4\")\n \t      (const_string \"multi\")\n  \t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n \t\t (match_operand:DI 1 \"symbolic_operand\" \"\"))\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*\")\n-   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI,DI\")])\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI,DI,DI,DI\")])\n \n (define_insn \"*movdi_1_rex64_nointerunit\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!*y,!m,!*y,!*Y,!m,!*Y\")\n@@ -19705,52 +19712,68 @@\n })\n \n (define_insn \"movv8qi_internal\"\n-  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,y,m\")\n-\t(match_operand:V8QI 1 \"vector_move_operand\" \"C,ym,y\"))]\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,y,m,!y,!*Y,?*Y,?m\")\n+\t(match_operand:V8QI 1 \"vector_move_operand\" \"C,ym,y,*Y,y,*Ym,*Y\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n     pxor\\t%0, %0\n     movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\n+    movdq2q\\t{%1, %0|%0, %1}\n+    movq2dq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\n     movq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mmxmov\")\n+  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"movv4hi_internal\"\n-  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,y,m\")\n-\t(match_operand:V4HI 1 \"vector_move_operand\" \"C,ym,y\"))]\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,y,m,!y,!*Y,?*Y,?m\")\n+\t(match_operand:V4HI 1 \"vector_move_operand\" \"C,ym,y,*Y,y,*Ym,*Y\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n     pxor\\t%0, %0\n     movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\n+    movdq2q\\t{%1, %0|%0, %1}\n+    movq2dq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\n     movq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mmxmov\")\n+  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov\")\n    (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"movv2si_internal\"\n-  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,y,m\")\n-\t(match_operand:V2SI 1 \"vector_move_operand\" \"C,ym,y\"))]\n+(define_insn \"*movv2si_internal\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,y,m,!y,!*Y,?*Y,?m\")\n+\t(match_operand:V2SI 1 \"vector_move_operand\" \"C,ym,y,*Y,y,*Ym,*Y\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n     pxor\\t%0, %0\n     movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\n+    movdq2q\\t{%1, %0|%0, %1}\n+    movq2dq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\n     movq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mmxcvt\")\n+  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"movv2sf_internal\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=y,y,m\")\n-        (match_operand:V2SF 1 \"vector_move_operand\" \"C,ym,y\"))]\n+  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=y,y,m,!y,!*Y,?*x,?m\")\n+        (match_operand:V2SF 1 \"vector_move_operand\" \"C,ym,y,*Y,y,*xm,*x\"))]\n   \"TARGET_3DNOW\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n     pxor\\t%0, %0\n     movq\\t{%1, %0|%0, %1}\n-    movq\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"mmxcvt\")\n-   (set_attr \"mode\" \"DI\")])\n+    movq\\t{%1, %0|%0, %1}\n+    movdq2q\\t{%1, %0|%0, %1}\n+    movq2dq\\t{%1, %0|%0, %1}\n+    movlps\\t{%1, %0|%0, %1}\n+    movlps\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"mmxmov,mmxmov,mmxmov,ssecvt,ssecvt,ssemov,ssemov\")\n+   (set_attr \"mode\" \"DI,DI,DI,DI,DI,V2SF,V2SF\")])\n \n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n@@ -23069,8 +23092,8 @@\n \t\t\t\t  (parallel [(const_int 0)])))))]\n   \"TARGET_SSE2\"\n   \"pmuludq\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseimul\")\n-   (set_attr \"mode\" \"TI\")])\n+  [(set_attr \"type\" \"mmxmul\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_insn \"sse2_umulv2siv2di3\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")"}]}