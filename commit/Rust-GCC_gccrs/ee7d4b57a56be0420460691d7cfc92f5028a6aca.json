{"sha": "ee7d4b57a56be0420460691d7cfc92f5028a6aca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3ZDRiNTdhNTZiZTA0MjA0NjA2OTFkN2NmYzkyZjUwMjhhNmFjYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-07-06T18:38:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-06T18:38:15Z"}, "message": "tree-ssa-structalias.c (struct variable_info): Remove has_union.\n\n2008-07-06  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (struct variable_info): Remove has_union.\n\t(new_var_info): Deal with it.\n\t(solution_set_add): Likewise.\n\t(bitpos_of_field): Make signed, fix.\n\t(struct fieldoff): Remove type and decl fields.  Make size field\n\tunsigned HOST_WIDE_INT.  Add has_unknown_size and may_have_pointers\n\tflags.\n\t(fieldoff_compare): Deal with it.\n\t(push_fields_onto_fieldstack): Remove has_union argument, glob\n\tadjacent non-pointer fields together.\n\t(create_function_info_for): Do not set has_union.\n\t(create_variable_info_for): Simplify.\n\n\t* gcc.dg/tree-ssa/pta-callused.c: Adjust testcase.\n\nFrom-SVN: r137530", "tree": {"sha": "7d9c3e25895221d22c35c7113f4770ce918e5d15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9c3e25895221d22c35c7113f4770ce918e5d15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee7d4b57a56be0420460691d7cfc92f5028a6aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7d4b57a56be0420460691d7cfc92f5028a6aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee7d4b57a56be0420460691d7cfc92f5028a6aca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7d4b57a56be0420460691d7cfc92f5028a6aca/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9faf4654f49b100b597bb3efbc9cd161c92e94f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9faf4654f49b100b597bb3efbc9cd161c92e94f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9faf4654f49b100b597bb3efbc9cd161c92e94f"}], "stats": {"total": 160, "additions": 84, "deletions": 76}, "files": [{"sha": "3dd4618a0b9c994ce32a7f934944f1dd4e5e3547", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee7d4b57a56be0420460691d7cfc92f5028a6aca", "patch": "@@ -1,3 +1,18 @@\n+2008-07-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Remove has_union.\n+\t(new_var_info): Deal with it.\n+\t(solution_set_add): Likewise.\n+\t(bitpos_of_field): Make signed, fix.\n+\t(struct fieldoff): Remove type and decl fields.  Make size field\n+\tunsigned HOST_WIDE_INT.  Add has_unknown_size and may_have_pointers\n+\tflags.\n+\t(fieldoff_compare): Deal with it.\n+\t(push_fields_onto_fieldstack): Remove has_union argument, glob\n+\tadjacent non-pointer fields together.\n+\t(create_function_info_for): Do not set has_union.\n+\t(create_variable_info_for): Simplify.\n+\n 2008-07-06  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config.gcc (extra_headers): Add cross-stdarg.h for target"}, {"sha": "25c118edec252529f0efa67ff055b4f8c9034827", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee7d4b57a56be0420460691d7cfc92f5028a6aca", "patch": "@@ -1,3 +1,7 @@\n+2008-07-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/pta-callused.c: Adjust testcase.\n+\n 2008-07-06  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* gcc.dg/callabi/callabi.h: New."}, {"sha": "c2b512a12e96bcd928474ac2ed8a3e9a84e22027", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c?ref=ee7d4b57a56be0420460691d7cfc92f5028a6aca", "patch": "@@ -22,6 +22,6 @@ int bar (int b)\n   return foo (&q);\n }\n \n-/* { dg-final { scan-tree-dump \"CALLUSED = { f f.q i q }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"CALLUSED = { f.* i q }\" \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */\n "}, {"sha": "266538c8b601ecbb03e81030c6f3cc230818c0f0", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 64, "deletions": 75, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7d4b57a56be0420460691d7cfc92f5028a6aca/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ee7d4b57a56be0420460691d7cfc92f5028a6aca", "patch": "@@ -220,9 +220,6 @@ struct variable_info\n   /* True for variables whose size is not known or variable.  */\n   unsigned int is_unknown_size_var:1;\n \n-  /* True for variables that have unions somewhere in them.  */\n-  unsigned int has_union:1;\n-\n   /* True if this is a heap variable.  */\n   unsigned int is_heap_var:1;\n \n@@ -376,7 +373,6 @@ new_var_info (tree t, unsigned int id, const char *name)\n   ret->is_heap_var = false;\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n-  ret->has_union = false;\n   var = t;\n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n@@ -769,7 +765,6 @@ solution_set_add (bitmap set, unsigned HOST_WIDE_INT offset)\n \t  bitmap_set_bit (result, v->id);\n \t}\n       else if (get_varinfo (i)->is_artificial_var\n-\t       || get_varinfo (i)->has_union\n \t       || get_varinfo (i)->is_unknown_size_var)\n \t{\n \t  bitmap_set_bit (result, i);\n@@ -2670,16 +2665,16 @@ could_have_pointers (tree t)\n /* Return the position, in bits, of FIELD_DECL from the beginning of its\n    structure.  */\n \n-static unsigned HOST_WIDE_INT\n+static HOST_WIDE_INT\n bitpos_of_field (const tree fdecl)\n {\n \n-  if (TREE_CODE (DECL_FIELD_OFFSET (fdecl)) != INTEGER_CST\n-      || TREE_CODE (DECL_FIELD_BIT_OFFSET (fdecl)) != INTEGER_CST)\n+  if (!host_integerp (DECL_FIELD_OFFSET (fdecl), 0)\n+      || !host_integerp (DECL_FIELD_BIT_OFFSET (fdecl), 0))\n     return -1;\n \n-  return (tree_low_cst (DECL_FIELD_OFFSET (fdecl), 1) * 8)\n-\t + tree_low_cst (DECL_FIELD_BIT_OFFSET (fdecl), 1);\n+  return (TREE_INT_CST_LOW (DECL_FIELD_OFFSET (fdecl)) * 8\n+\t  + TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (fdecl)));\n }\n \n \n@@ -4005,17 +4000,15 @@ insert_into_field_list_sorted (varinfo_t base, varinfo_t field)\n \n struct fieldoff\n {\n-  /* Type of the field.  */\n-  tree type;\n+  /* Offset from the base of the base containing object to this field.  */\n+  HOST_WIDE_INT offset;\n \n   /* Size, in bits, of the field.  */\n-  tree size;\n+  unsigned HOST_WIDE_INT size;\n \n-  /* Field.  */\n-  tree decl;\n+  unsigned has_unknown_size : 1;\n \n-  /* Offset from the base of the base containing object to this field.  */\n-  HOST_WIDE_INT offset;  \n+  unsigned may_have_pointers : 1;\n };\n typedef struct fieldoff fieldoff_s;\n \n@@ -4036,10 +4029,10 @@ fieldoff_compare (const void *pa, const void *pb)\n   else if (foa->offset > fob->offset)\n     return 1;\n \n-  foasize = TREE_INT_CST_LOW (foa->size);\n-  fobsize = TREE_INT_CST_LOW (fob->size);\n+  foasize = foa->size;\n+  fobsize = fob->size;\n   if (foasize < fobsize)\n-    return - 1;\n+    return -1;\n   else if (foasize > fobsize)\n     return 1;\n   return 0;\n@@ -4083,14 +4076,11 @@ var_can_have_subvars (const_tree v)\n \n    OFFSET is used to keep track of the offset in this entire\n    structure, rather than just the immediately containing structure.\n-   Returns the number of fields pushed.\n-\n-   HAS_UNION is set to true if we find a union type as a field of\n-   TYPE.  */\n+   Returns the number of fields pushed.  */\n \n static int\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n-\t\t\t     HOST_WIDE_INT offset, bool *has_union)\n+\t\t\t     HOST_WIDE_INT offset)\n {\n   tree field;\n   int count = 0;\n@@ -4109,19 +4099,14 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n       {\n \tbool push = false;\n \tint pushed = 0;\n+\tHOST_WIDE_INT foff = bitpos_of_field (field);\n \n-\tif (has_union\n-\t    && (TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n-\t\t|| TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n-\t  *has_union = true;\n-\n-\tif (!var_can_have_subvars (field))\n+\tif (!var_can_have_subvars (field)\n+\t    || TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n+\t    || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t  push = true;\n \telse if (!(pushed = push_fields_onto_fieldstack\n-\t\t   (TREE_TYPE (field),\n-\t\t    fieldstack,\n-\t\t    offset + bitpos_of_field (field),\n-\t\t    has_union))\n+\t\t   (TREE_TYPE (field), fieldstack, offset + foff))\n \t\t && (DECL_SIZE (field)\n \t\t     && !integer_zerop (DECL_SIZE (field))))\n \t  /* Empty structures may have actual size, like in C++.  So\n@@ -4131,14 +4116,39 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \n \tif (push)\n \t  {\n-\t    fieldoff_s *pair;\n-\n-\t    pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-\t    pair->type = TREE_TYPE (field);\n-\t    pair->size = DECL_SIZE (field);\n-\t    pair->decl = field;\n-\t    pair->offset = offset + bitpos_of_field (field);\n-\t    count++;\n+\t    fieldoff_s *pair = NULL;\n+\t    bool has_unknown_size = false;\n+\n+\t    if (!VEC_empty (fieldoff_s, *fieldstack))\n+\t      pair = VEC_last (fieldoff_s, *fieldstack);\n+\n+\t    if (!DECL_SIZE (field)\n+\t\t|| !host_integerp (DECL_SIZE (field), 1))\n+\t      has_unknown_size = true;\n+\n+\t    /* If adjacent fields do not contain pointers merge them.  */\n+\t    if (pair\n+\t\t&& !pair->may_have_pointers\n+\t\t&& !could_have_pointers (field)\n+\t\t&& !pair->has_unknown_size\n+\t\t&& !has_unknown_size\n+\t\t&& pair->offset + (HOST_WIDE_INT)pair->size == offset + foff)\n+\t      {\n+\t\tpair = VEC_last (fieldoff_s, *fieldstack);\n+\t\tpair->size += TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t      }\n+\t    else\n+\t      {\n+\t\tpair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n+\t\tpair->offset = offset + foff;\n+\t\tpair->has_unknown_size = has_unknown_size;\n+\t\tif (!has_unknown_size)\n+\t\t  pair->size = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t\telse\n+\t\t  pair->size = -1;\n+\t\tpair->may_have_pointers = could_have_pointers (field);\n+\t\tcount++;\n+\t      }\n \t  }\n \telse\n \t  count += pushed;\n@@ -4204,7 +4214,6 @@ create_function_info_for (tree decl, const char *name)\n   vi = new_var_info (decl, index, name);\n   vi->decl = decl;\n   vi->offset = 0;\n-  vi->has_union = 0;\n   vi->size = 1;\n   vi->fullsize = count_num_arguments (decl, &is_varargs) + 1;\n   insert_vi_for_tree (vi->decl, vi);\n@@ -4249,7 +4258,6 @@ create_function_info_for (tree decl, const char *name)\n       argvi->offset = i;\n       argvi->size = 1;\n       argvi->fullsize = vi->fullsize;\n-      argvi->has_union = false;\n       insert_into_field_list_sorted (vi, argvi);\n       stats.total_vars ++;\n       if (arg)\n@@ -4285,7 +4293,6 @@ create_function_info_for (tree decl, const char *name)\n       resultvi->offset = i;\n       resultvi->size = 1;\n       resultvi->fullsize = vi->fullsize;\n-      resultvi->has_union = false;\n       insert_into_field_list_sorted (vi, resultvi);\n       stats.total_vars ++;\n       if (DECL_RESULT (decl))\n@@ -4325,37 +4332,23 @@ create_variable_info_for (tree decl, const char *name)\n   varinfo_t vi;\n   tree decltype = TREE_TYPE (decl);\n   tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decltype);\n-  bool notokay = false;\n-  bool hasunion;\n   bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && in_ipa_mode)\n     return create_function_info_for (decl, name);\n \n-  hasunion = TREE_CODE (decltype) == UNION_TYPE\n-\t     || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n-  if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n-    {\n-      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion);\n-      if (hasunion)\n-\t{\n-\t  VEC_free (fieldoff_s, heap, fieldstack);\n-\t  notokay = true;\n-\t}\n-    }\n+  if (var_can_have_subvars (decl) && use_field_sensitive)\n+    push_fields_onto_fieldstack (decltype, &fieldstack, 0);\n \n   /* If the variable doesn't have subvars, we may end up needing to\n      sort the field list and create fake variables for all the\n      fields.  */\n   vi = new_var_info (decl, index, name);\n   vi->decl = decl;\n   vi->offset = 0;\n-  vi->has_union = hasunion;\n   if (!declsize\n-      || TREE_CODE (declsize) != INTEGER_CST\n-      || TREE_CODE (decltype) == UNION_TYPE\n-      || TREE_CODE (decltype) == QUAL_UNION_TYPE)\n+      || !host_integerp (declsize, 1))\n     {\n       vi->is_unknown_size_var = true;\n       vi->fullsize = ~0;\n@@ -4375,20 +4368,19 @@ create_variable_info_for (tree decl, const char *name)\n \n   stats.total_vars++;\n   if (use_field_sensitive\n-      && !notokay\n       && !vi->is_unknown_size_var\n       && var_can_have_subvars (decl)\n       && VEC_length (fieldoff_s, fieldstack) > 1\n       && VEC_length (fieldoff_s, fieldstack) <= MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     {\n       unsigned int newindex = VEC_length (varinfo_t, varmap);\n       fieldoff_s *fo = NULL;\n+      bool notokay = false;\n       unsigned int i;\n \n       for (i = 0; !notokay && VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n \t{\n-\t  if (! fo->size\n-\t      || TREE_CODE (fo->size) != INTEGER_CST\n+\t  if (fo->has_unknown_size\n \t      || fo->offset < 0)\n \t    {\n \t      notokay = true;\n@@ -4423,7 +4415,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  return index;\n \t}\n \n-      vi->size = TREE_INT_CST_LOW (fo->size);\n+      vi->size = fo->size;\n       vi->offset = fo->offset;\n       for (i = VEC_length (fieldoff_s, fieldstack) - 1;\n \t   i >= 1 && VEC_iterate (fieldoff_s, fieldstack, i, fo);\n@@ -4436,23 +4428,20 @@ create_variable_info_for (tree decl, const char *name)\n \t  newindex = VEC_length (varinfo_t, varmap);\n \t  if (dump_file)\n \t    {\n-\t      if (fo->decl)\n-\t\tasprintf (&tempname, \"%s.%s\",\n-\t\t\t  vi->name, alias_get_name (fo->decl));\n-\t      else\n-\t\tasprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t  vi->name, fo->offset);\n+\t      asprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t\"+\" HOST_WIDE_INT_PRINT_DEC,\n+\t\t\tvi->name, fo->offset, fo->size);\n \t      newname = ggc_strdup (tempname);\n \t      free (tempname);\n \t    }\n \t  newvi = new_var_info (decl, newindex, newname);\n \t  newvi->offset = fo->offset;\n-\t  newvi->size = TREE_INT_CST_LOW (fo->size);\n+\t  newvi->size = fo->size;\n \t  newvi->fullsize = vi->fullsize;\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode)\n-\t      && (!fo->decl || could_have_pointers (fo->decl)))\n+\t      && fo->may_have_pointers)\n \t    make_constraint_from (newvi, escaped_id);\n \n \t  stats.total_vars++;"}]}