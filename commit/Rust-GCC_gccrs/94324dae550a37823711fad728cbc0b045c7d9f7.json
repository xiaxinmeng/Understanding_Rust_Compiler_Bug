{"sha": "94324dae550a37823711fad728cbc0b045c7d9f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQzMjRkYWU1NTBhMzc4MjM3MTFmYWQ3MjhjYmMwYjA0NWM3ZDlmNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-05-23T17:54:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-05-23T17:54:11Z"}, "message": "passes.texi: Standardize spelling of RTL, Tree and Tree SSA.\n\n\t* doc/passes.texi: Standardize spelling of RTL, Tree and Tree SSA.\n\tRemove outdated reference to flow.c and fix nits.\n\t* doc/gccint.texi: Tweak RTL description.\n\t* doc/rtl.texi: Likewise.\n\nFrom-SVN: r147821", "tree": {"sha": "2e0fba325947b9a5acd42ddcd79a907d5f9bec36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e0fba325947b9a5acd42ddcd79a907d5f9bec36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94324dae550a37823711fad728cbc0b045c7d9f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94324dae550a37823711fad728cbc0b045c7d9f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94324dae550a37823711fad728cbc0b045c7d9f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94324dae550a37823711fad728cbc0b045c7d9f7/comments", "author": null, "committer": null, "parents": [{"sha": "22702f93614e482a1e17970afdf58f5aa8a72369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22702f93614e482a1e17970afdf58f5aa8a72369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22702f93614e482a1e17970afdf58f5aa8a72369"}], "stats": {"total": 97, "additions": 48, "deletions": 49}, "files": [{"sha": "e64c72eb69da0f0c3fff8c43482a7de348429003", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94324dae550a37823711fad728cbc0b045c7d9f7", "patch": "@@ -1,3 +1,10 @@\n+2009-05-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/passes.texi: Standardize spelling of RTL, Tree and Tree SSA.\n+\tRemove outdated reference to flow.c and fix nits.\n+\t* doc/gccint.texi: Tweak RTL description.\n+\t* doc/rtl.texi: Likewise.\n+\n 2009-05-23  Denis Chertykov  <chertykov@gmail.com>\n \n \t* config/avr/avr.c: Change my email address."}, {"sha": "4014d370da9669300490279d6894c3661686a7cf", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=94324dae550a37823711fad728cbc0b045c7d9f7", "patch": "@@ -109,10 +109,10 @@ Additional tutorial information is linked to from\n * Options::         Option specification files.\n * Passes::          Order of passes, what they do, and what each file is for.\n * Trees::           The source representation used by the C and C++ front ends.\n-* RTL::             The intermediate representation that most passes work on.\n * GENERIC::         Language-independent representation generated by Front Ends\n * GIMPLE::          Tuple representation used by Tree SSA optimizers\n * Tree SSA::        Analysis and optimization of GIMPLE\n+* RTL::             Machine-dependent low-level intermediate representation.\n * Control Flow::    Maintaining and manipulating the control flow graph.\n * Loop Analysis and Representation:: Analysis and representation of loops\n * Machine Desc::    How to write machine description instruction patterns."}, {"sha": "0798ac3447fcda5e12e3d01713e7696278160769", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=94324dae550a37823711fad728cbc0b045c7d9f7", "patch": "@@ -21,7 +21,7 @@ where near complete.\n * Parsing pass::         The language front end turns text into bits.\n * Gimplification pass::  The bits are turned into something we can optimize.\n * Pass manager::         Sequencing the optimization passes.\n-* Tree-SSA passes::      Optimizations on a high-level representation.\n+* Tree SSA passes::      Optimizations on a high-level representation.\n * RTL passes::           Optimizations on a low-level representation.\n @end menu\n \n@@ -94,8 +94,8 @@ be passed to @code{rest_of_type_compilation}.  Each function definition\n should be passed to @code{cgraph_finalize_function}.\n \n TODO: I know rest_of_compilation currently has all sorts of\n-rtl-generation semantics.  I plan to move all code generation\n-bits (both tree and rtl) to compile_function.  Should we hide\n+RTL generation semantics.  I plan to move all code generation\n+bits (both Tree and RTL) to compile_function.  Should we hide\n cgraph from the front ends and move back to rest_of_compilation\n as the official interface?  Possibly we should rename all three\n interfaces such that the names match in some meaningful way and\n@@ -172,12 +172,12 @@ dump anything.\n \n TODO: describe the global variables set up by the pass manager,\n and a brief description of how a new pass should use it.\n-I need to look at what info rtl passes use first@enddots{}\n+I need to look at what info RTL passes use first@enddots{}\n \n-@node Tree-SSA passes\n-@section Tree-SSA passes\n+@node Tree SSA passes\n+@section Tree SSA passes\n \n-The following briefly describes the tree optimization passes that are\n+The following briefly describes the Tree optimization passes that are\n run after gimplification and what source files they are located in.\n \n @itemize @bullet\n@@ -401,7 +401,7 @@ and described by @code{pass_loop}.\n The optimizations performed by this pass are:\n \n Loop invariant motion.  This pass moves only invariants that\n-would be hard to handle on rtl level (function calls, operations that expand to\n+would be hard to handle on RTL level (function calls, operations that expand to\n nontrivial sequences of insns).  With @option{-funswitch-loops} it also moves\n operands of conditions that are invariant out of the loop, so that we can use\n just trivial invariantness analysis in loop unswitching.  The pass also includes\n@@ -422,8 +422,8 @@ Loop unswitching.  This pass moves the conditional jumps that are invariant\n out of the loops.  To achieve this, a duplicate of the loop is created for\n each possible outcome of conditional jump(s).  The pass is implemented in\n @file{tree-ssa-loop-unswitch.c}.  This pass should eventually replace the\n-rtl-level loop unswitching in @file{loop-unswitch.c}, but currently\n-the rtl-level pass is not completely redundant yet due to deficiencies\n+RTL level loop unswitching in @file{loop-unswitch.c}, but currently\n+the RTL level pass is not completely redundant yet due to deficiencies\n in tree level alias analysis.\n \n The optimizations also use various utility functions contained in\n@@ -651,8 +651,8 @@ registers don't need to be saved.  This pass is located in\n @node RTL passes\n @section RTL passes\n \n-The following briefly describes the rtl generation and optimization\n-passes that are run after tree optimization.\n+The following briefly describes the RTL generation and optimization\n+passes that are run after the Tree optimization passes.\n \n @itemize @bullet\n @item RTL generation\n@@ -679,15 +679,15 @@ generated from the machine description by the programs @code{genflags}\n and @code{gencodes}, tell this pass which standard names are available\n for use and which patterns correspond to them.\n \n-@item Generate exception handling landing pads\n+@item Generation of exception landing pads\n \n This pass generates the glue that handles communication between the\n exception handling library routines and the exception handlers within\n the function.  Entry points in the function that are invoked by the\n exception handling library are called @dfn{landing pads}.  The code\n-for this pass is located within @file{except.c}.\n+for this pass is located in @file{except.c}.\n \n-@item Cleanup control flow graph\n+@item Control flow graph cleanup\n \n This pass removes unreachable code, simplifies jumps to next, jumps to\n jump, jumps across jumps, etc.  The pass is run multiple times.\n@@ -702,16 +702,16 @@ This pass attempts to remove redundant computation by substituting\n variables that come from a single definition, and\n seeing if the result can be simplified.  It performs copy propagation\n and addressing mode selection.  The pass is run twice, with values\n-being propagated into loops only on the second run.  It is located in\n-@file{fwprop.c}.\n+being propagated into loops only on the second run.  The code is\n+located in @file{fwprop.c}.\n \n @item Common subexpression elimination\n \n This pass removes redundant computation within basic blocks, and\n optimizes addressing modes based on cost.  The pass is run twice.\n-The source is located in @file{cse.c}.\n+The code for this pass is located in @file{cse.c}.\n \n-@item Global common subexpression elimination.\n+@item Global common subexpression elimination\n \n This pass performs two\n different types of GCSE  depending on whether you are optimizing for\n@@ -755,55 +755,46 @@ This pass attempts to replace conditional branches and surrounding\n assignments with arithmetic, boolean value producing comparison\n instructions, and conditional move instructions.  In the very last\n invocation after reload, it will generate predicated instructions\n-when supported by the target.  The pass is located in @file{ifcvt.c}.\n+when supported by the target.  The code is located in @file{ifcvt.c}.\n \n @item Web construction\n \n This pass splits independent uses of each pseudo-register.  This can\n improve effect of the other transformation, such as CSE or register\n-allocation.  Its source files are @file{web.c}.\n-\n-@item Life analysis\n-\n-This pass computes which pseudo-registers are live at each point in\n-the program, and makes the first instruction that uses a value point\n-at the instruction that computed the value.  It then deletes\n-computations whose results are never used, and combines memory\n-references with add or subtract instructions to make autoincrement or\n-autodecrement addressing.  The pass is located in @file{flow.c}.\n+allocation.  The code for this pass is located in @file{web.c}.\n \n @item Instruction combination\n \n This pass attempts to combine groups of two or three instructions that\n are related by data flow into single instructions.  It combines the\n RTL expressions for the instructions by substitution, simplifies the\n result using algebra, and then attempts to match the result against\n-the machine description.  The pass is located in @file{combine.c}.\n+the machine description.  The code is located in @file{combine.c}.\n \n @item Register movement\n \n This pass looks for cases where matching constraints would force an\n instruction to need a reload, and this reload would be a\n register-to-register move.  It then attempts to change the registers\n-used by the instruction to avoid the move instruction.\n-The pass is located in @file{regmove.c}.\n+used by the instruction to avoid the move instruction.  The code is\n+located in @file{regmove.c}.\n \n-@item Optimize mode switching\n+@item Mode switching optimization\n \n This pass looks for instructions that require the processor to be in a\n specific ``mode'' and minimizes the number of mode changes required to\n satisfy all users.  What these modes are, and what they apply to are\n-completely target-specific.\n-The source is located in @file{mode-switching.c}.\n+completely target-specific.  The code for this pass is located in\n+@file{mode-switching.c}.\n \n @cindex modulo scheduling\n @cindex sms, swing, software pipelining\n @item Modulo scheduling\n \n This pass looks at innermost loops and reorders their instructions\n by overlapping different iterations.  Modulo scheduling is performed\n-immediately before instruction scheduling.\n-The pass is located in (@file{modulo-sched.c}).\n+immediately before instruction scheduling.  The code for this pass is\n+located in @file{modulo-sched.c}.\n \n @item Instruction scheduling\n \n@@ -813,7 +804,7 @@ floating point instructions often have this behavior on RISC machines.\n It re-orders instructions within a basic block to try to separate the\n definition and use of items that otherwise would cause pipeline\n stalls.  This pass is performed twice, before and after register\n-allocation.  The pass is located in @file{haifa-sched.c},\n+allocation.  The code for this pass is located in @file{haifa-sched.c},\n @file{sched-deps.c}, @file{sched-ebb.c}, @file{sched-rgn.c} and\n @file{sched-vis.c}.\n \n@@ -884,13 +875,13 @@ This pass computes where the variables are stored at each\n position in code and generates notes describing the variable locations\n to RTL code.  The location lists are then generated according to these\n notes to debug information if the debugging information format supports\n-location lists.\n+location lists.  The code is located in @file{var-tracking.c}.\n \n @item Delayed branch scheduling\n \n This optional pass attempts to find instructions that can go into the\n-delay slots of other instructions, usually jumps and calls.  The\n-source file name is @file{reorg.c}.\n+delay slots of other instructions, usually jumps and calls.  The code\n+for this pass is located in @file{reorg.c}.\n \n @item Branch shortening\n \n@@ -899,13 +890,14 @@ Thus, longer sequences of instructions must be used for long branches.\n In this pass, the compiler figures out what how far each instruction\n will be from each other instruction, and therefore whether the usual\n instructions, or the longer sequences, must be used for each branch.\n+The code for this pass is located in @file{final.c}.\n \n @item Register-to-stack conversion\n \n Conversion from usage of some hard registers to usage of a register\n stack may be done at this point.  Currently, this is supported only\n-for the floating-point registers of the Intel 80387 coprocessor.   The\n-source file name is @file{reg-stack.c}.\n+for the floating-point registers of the Intel 80387 coprocessor.  The\n+code for this pass is located in @file{reg-stack.c}.\n \n @item Final\n "}, {"sha": "79baa10e25d73f85e34f6b9e0c92442487d346ff", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94324dae550a37823711fad728cbc0b045c7d9f7/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=94324dae550a37823711fad728cbc0b045c7d9f7", "patch": "@@ -10,10 +10,10 @@\n @cindex representation of RTL\n @cindex Register Transfer Language (RTL)\n \n-Most of the work of the compiler is done on an intermediate representation\n-called register transfer language.  In this language, the instructions to be\n-output are described, pretty much one by one, in an algebraic form that\n-describes what the instruction does.\n+The last part of the compiler work is done on a low-level intermediate\n+representation called Register Transfer Language.  In this language, the\n+instructions to be output are described, pretty much one by one, in an\n+algebraic form that describes what the instruction does.\n \n RTL is inspired by Lisp lists.  It has both an internal form, made up of\n structures that point at other structures, and a textual form that is used"}]}