{"sha": "a4f49061b6d921f72b2faf4843144f3c75f828f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRmNDkwNjFiNmQ5MjFmNzJiMmZhZjQ4NDMxNDRmM2M3NWY4MjhmNw==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-07-09T21:48:39Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-07-16T15:05:45Z"}, "message": "amdgcn: Handle early debug info in mkoffload\n\nForward the early debug information from the input LTO file to the output\nHSACO file, in the same way lto-wrapper does.  This is a little more\ncomplicated, however, because the ELF file containing the debug needs to be\nconverted from x86_64 to amdgcn, and because the offloaded code will have less\ncontent than the host program the debug info describes.\n\ngcc/ChangeLog:\n\n\t* config/gcn/mkoffload.c: Include simple-object.h and elf.h.\n\t(EM_AMDGPU): New macro.\n\t(ELFOSABI_AMDGPU_HSA): New macro.\n\t(ELFABIVERSION_AMDGPU_HSA): New macro.\n\t(EF_AMDGPU_MACH_AMDGCN_GFX803): New macro.\n\t(EF_AMDGPU_MACH_AMDGCN_GFX900): New macro.\n\t(EF_AMDGPU_MACH_AMDGCN_GFX906): New macro.\n\t(R_AMDGPU_NONE): New macro.\n\t(R_AMDGPU_ABS32_LO): New macro.\n\t(R_AMDGPU_ABS32_HI): New macro.\n\t(R_AMDGPU_ABS64): New macro.\n\t(R_AMDGPU_REL32): New macro.\n\t(R_AMDGPU_REL64): New macro.\n\t(R_AMDGPU_ABS32): New macro.\n\t(R_AMDGPU_GOTPCREL): New macro.\n\t(R_AMDGPU_GOTPCREL32_LO): New macro.\n\t(R_AMDGPU_GOTPCREL32_HI): New macro.\n\t(R_AMDGPU_REL32_LO): New macro.\n\t(R_AMDGPU_REL32_HI): New macro.\n\t(reserved): New macro.\n\t(R_AMDGPU_RELATIVE64): New macro.\n\t(gcn_s1_name): Delete global variable.\n\t(gcn_s2_name): Delete global variable.\n\t(gcn_o_name): Delete global variable.\n\t(gcn_cfile_name): Delete global variable.\n\t(files_to_cleanup): New global variable.\n\t(offload_abi): New global variable.\n\t(tool_cleanup): Use files_to_cleanup, not explicit list.\n\t(copy_early_debug_info): New function.\n\t(main): New local variables gcn_s1_name, gcn_s2_name, gcn_o_name,\n\tgcn_cfile_name.\n\tCreate files_to_cleanup obstack.\n\tRecognize -march options.\n\tCopy early debug info from input .o files.", "tree": {"sha": "6c14957f473a8ffcf78254b4775dc14b8d079da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c14957f473a8ffcf78254b4775dc14b8d079da7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4f49061b6d921f72b2faf4843144f3c75f828f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f49061b6d921f72b2faf4843144f3c75f828f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f49061b6d921f72b2faf4843144f3c75f828f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f49061b6d921f72b2faf4843144f3c75f828f7/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "866c5bfd9c3ebc00913f3a84eb5383b51f2aee16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866c5bfd9c3ebc00913f3a84eb5383b51f2aee16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866c5bfd9c3ebc00913f3a84eb5383b51f2aee16"}], "stats": {"total": 272, "additions": 259, "deletions": 13}, "files": [{"sha": "553f25e70df0b75e117339a7c1d362b8b6b7065a", "filename": "gcc/config/gcn/mkoffload.c", "status": "modified", "additions": 259, "deletions": 13, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f49061b6d921f72b2faf4843144f3c75f828f7/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f49061b6d921f72b2faf4843144f3c75f828f7/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.c?ref=a4f49061b6d921f72b2faf4843144f3c75f828f7", "patch": "@@ -33,31 +33,53 @@\n #include <libgen.h>\n #include \"collect-utils.h\"\n #include \"gomp-constants.h\"\n+#include \"simple-object.h\"\n+#include \"elf.h\"\n+\n+/* These probably won't be in elf.h for a while.  */\n+#ifndef EM_AMDGPU\n+#define EM_AMDGPU\t\t0xe0;\n+\n+#define ELFOSABI_AMDGPU_HSA\t 64\n+#define ELFABIVERSION_AMDGPU_HSA 1\n+\n+#define EF_AMDGPU_MACH_AMDGCN_GFX803 0x2a\n+#define EF_AMDGPU_MACH_AMDGCN_GFX900 0x2c\n+#define EF_AMDGPU_MACH_AMDGCN_GFX906 0x2f\n+\n+#define R_AMDGPU_NONE\t\t0\n+#define R_AMDGPU_ABS32_LO\t1\t/* (S + A) & 0xFFFFFFFF  */\n+#define R_AMDGPU_ABS32_HI\t2\t/* (S + A) >> 32  */\n+#define R_AMDGPU_ABS64\t\t3\t/* S + A  */\n+#define R_AMDGPU_REL32\t\t4\t/* S + A - P  */\n+#define R_AMDGPU_REL64\t\t5\t/* S + A - P  */\n+#define R_AMDGPU_ABS32\t\t6\t/* S + A  */\n+#define R_AMDGPU_GOTPCREL\t7\t/* G + GOT + A - P  */\n+#define R_AMDGPU_GOTPCREL32_LO\t8\t/* (G + GOT + A - P) & 0xFFFFFFFF  */\n+#define R_AMDGPU_GOTPCREL32_HI\t9\t/* (G + GOT + A - P) >> 32  */\n+#define R_AMDGPU_REL32_LO\t10\t/* (S + A - P) & 0xFFFFFFFF  */\n+#define R_AMDGPU_REL32_HI\t11\t/* (S + A - P) >> 32  */\n+#define reserved\t\t12\n+#define R_AMDGPU_RELATIVE64\t13\t/* B + A  */\n+#endif\n \n const char tool_name[] = \"gcn mkoffload\";\n \n-/* Files to unlink.  */\n-static const char *gcn_s1_name;\n-static const char *gcn_s2_name;\n-static const char *gcn_o_name;\n-static const char *gcn_cfile_name;\n static const char *gcn_dumpbase;\n+static struct obstack files_to_cleanup;\n \n enum offload_abi offload_abi = OFFLOAD_ABI_UNSET;\n+uint32_t elf_arch = EF_AMDGPU_MACH_AMDGCN_GFX803;  // Default GPU architecture.\n \n /* Delete tempfiles.  */\n \n void\n tool_cleanup (bool from_signal ATTRIBUTE_UNUSED)\n {\n-  if (gcn_cfile_name)\n-    maybe_unlink (gcn_cfile_name);\n-  if (gcn_s1_name)\n-    maybe_unlink (gcn_s1_name);\n-  if (gcn_s2_name)\n-    maybe_unlink (gcn_s2_name);\n-  if (gcn_o_name)\n-    maybe_unlink (gcn_o_name);\n+  obstack_ptr_grow (&files_to_cleanup, NULL);\n+  const char **files = XOBFINISH (&files_to_cleanup, const char **);\n+  for (int i = 0; files[i]; i++)\n+    maybe_unlink (files[i]);\n }\n \n static void\n@@ -204,6 +226,180 @@ access_check (const char *name, int mode)\n   return access (name, mode);\n }\n \n+/* Copy the early-debug-info from the incoming LTO object to a new object\n+   that will be linked into the output HSACO file.  The host relocations\n+   must be translated into GCN relocations, and any global undefined symbols\n+   must be weakened (so as not to have the debug info try to pull in host\n+   junk).\n+\n+   Returns true if the file was created, false otherwise.  */\n+\n+static bool\n+copy_early_debug_info (const char *infile, const char *outfile)\n+{\n+  const char *errmsg;\n+  int err;\n+\n+  /* The simple_object code can handle extracting the debug sections.\n+     This code is based on that in lto-wrapper.c.  */\n+  int infd = open (infile, O_RDONLY | O_BINARY);\n+  if (infd == -1)\n+    return false;\n+  simple_object_read *inobj = simple_object_start_read (infd, 0,\n+\t\t\t\t\t\t\t\"__GNU_LTO\",\n+\t\t\t\t\t\t\t&errmsg, &err);\n+  if (!inobj)\n+    return false;\n+\n+  off_t off, len;\n+  if (simple_object_find_section (inobj, \".gnu.debuglto_.debug_info\",\n+\t\t\t\t  &off, &len, &errmsg, &err) != 1)\n+    {\n+      simple_object_release_read (inobj);\n+      close (infd);\n+      return false;\n+    }\n+\n+  errmsg = simple_object_copy_lto_debug_sections (inobj, outfile, &err, true);\n+  if (errmsg)\n+    {\n+      unlink_if_ordinary (outfile);\n+      return false;\n+    }\n+\n+  simple_object_release_read (inobj);\n+  close (infd);\n+\n+  /* Open the file we just created for some adjustments.\n+     The simple_object code can't do this, so we do it manually.  */\n+  FILE *outfd = fopen (outfile, \"r+b\");\n+  if (!outfd)\n+    return false;\n+\n+  Elf64_Ehdr ehdr;\n+  if (fread (&ehdr, sizeof (ehdr), 1, outfd) != 1)\n+    {\n+      fclose (outfd);\n+      return true;\n+    }\n+\n+  /* We only support host relocations of x86_64, for now.  */\n+  gcc_assert (ehdr.e_machine == EM_X86_64);\n+\n+  /* Patch the correct elf architecture flag into the file.  */\n+  ehdr.e_ident[7] = ELFOSABI_AMDGPU_HSA;\n+  ehdr.e_ident[8] = ELFABIVERSION_AMDGPU_HSA;\n+  ehdr.e_type = ET_REL;\n+  ehdr.e_machine = EM_AMDGPU;\n+  ehdr.e_flags = elf_arch;\n+\n+  /* Load the section headers so we can walk them later.  */\n+  Elf64_Shdr *sections = (Elf64_Shdr *)xmalloc (sizeof (Elf64_Shdr)\n+\t\t\t\t\t\t* ehdr.e_shnum);\n+  if (fseek (outfd, ehdr.e_shoff, SEEK_SET) == -1\n+      || fread (sections, sizeof (Elf64_Shdr), ehdr.e_shnum,\n+\t\toutfd) != ehdr.e_shnum)\n+    {\n+      free (sections);\n+      fclose (outfd);\n+      return true;\n+    }\n+\n+  /* Convert the host relocations to target relocations.  */\n+  for (int i = 0; i < ehdr.e_shnum; i++)\n+    {\n+      if (sections[i].sh_type != SHT_RELA)\n+\tcontinue;\n+\n+      char *data = (char *)xmalloc (sections[i].sh_size);\n+      if (fseek (outfd, sections[i].sh_offset, SEEK_SET) == -1\n+\t  || fread (data, sections[i].sh_size, 1, outfd) != 1)\n+\t{\n+\t  free (data);\n+\t  continue;\n+\t}\n+\n+      for (size_t offset = 0;\n+\t   offset < sections[i].sh_size;\n+\t   offset += sections[i].sh_entsize)\n+\t{\n+\t  Elf64_Rela *reloc = (Elf64_Rela *) (data + offset);\n+\n+\t  /* Map the host relocations to GCN relocations.\n+\t     Only relocations that can appear in DWARF need be handled.  */\n+\t  switch (ELF64_R_TYPE (reloc->r_info))\n+\t    {\n+\t    case R_X86_64_32:\n+\t    case R_X86_64_32S:\n+\t      reloc->r_info = R_AMDGPU_ABS32;\n+\t      break;\n+\t    case R_X86_64_PC32:\n+\t      reloc->r_info = R_AMDGPU_REL32;\n+\t      break;\n+\t    case R_X86_64_PC64:\n+\t      reloc->r_info = R_AMDGPU_REL64;\n+\t      break;\n+\t    case R_X86_64_64:\n+\t      reloc->r_info = R_AMDGPU_ABS64;\n+\t      break;\n+\t    case R_X86_64_RELATIVE:\n+\t      reloc->r_info = R_AMDGPU_RELATIVE64;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      /* Write back our relocation changes.  */\n+      if (fseek (outfd, sections[i].sh_offset, SEEK_SET) != -1)\n+\tfwrite (data, sections[i].sh_size, 1, outfd);\n+\n+      free (data);\n+    }\n+\n+  /* Weaken any global undefined symbols that would pull in unwanted\n+     objects.  */\n+  for (int i = 0; i < ehdr.e_shnum; i++)\n+    {\n+      if (sections[i].sh_type != SHT_SYMTAB)\n+\tcontinue;\n+\n+      char *data = (char *)xmalloc (sections[i].sh_size);\n+      if (fseek (outfd, sections[i].sh_offset, SEEK_SET) == -1\n+\t  || fread (data, sections[i].sh_size, 1, outfd) != 1)\n+\t{\n+\t  free (data);\n+\t  continue;\n+\t}\n+\n+      for (size_t offset = 0;\n+\t   offset < sections[i].sh_size;\n+\t   offset += sections[i].sh_entsize)\n+\t{\n+\t  Elf64_Sym *sym = (Elf64_Sym *) (data + offset);\n+\t  int type = ELF64_ST_TYPE (sym->st_info);\n+\t  int bind = ELF64_ST_BIND (sym->st_info);\n+\n+\t  if (bind == STB_GLOBAL && sym->st_shndx == 0)\n+\t    sym->st_info = ELF64_ST_INFO (STB_WEAK, type);\n+\t}\n+\n+      /* Write back our symbol changes.  */\n+      if (fseek (outfd, sections[i].sh_offset, SEEK_SET) != -1)\n+\tfwrite (data, sections[i].sh_size, 1, outfd);\n+\n+      free (data);\n+    }\n+  free (sections);\n+\n+  /* Write back our header changes.  */\n+  rewind (outfd);\n+  fwrite (&ehdr, sizeof (ehdr), 1, outfd);\n+\n+  fclose (outfd);\n+  return true;\n+}\n+\n /* Parse an input assembler file, extract the offload tables etc.,\n    and output (1) the assembler code, minus the tables (which can contain\n    problematic relocations), and (2) a C file with the offload tables\n@@ -538,9 +734,15 @@ main (int argc, char **argv)\n   FILE *cfile = stdout;\n   const char *outname = 0;\n \n+  const char *gcn_s1_name;\n+  const char *gcn_s2_name;\n+  const char *gcn_o_name;\n+  const char *gcn_cfile_name;\n+\n   progname = \"mkoffload\";\n   diagnostic_initialize (global_dc, 0);\n \n+  obstack_init (&files_to_cleanup);\n   if (atexit (mkoffload_cleanup) != 0)\n     fatal_error (input_location, \"atexit failed\");\n \n@@ -632,7 +834,14 @@ main (int argc, char **argv)\n       else if (strcmp (argv[i], \"-dumpbase\") == 0\n \t       && i + 1 < argc)\n \tdumppfx = argv[++i];\n+      else if (strcmp (argv[i], \"-march=fiji\") == 0)\n+\telf_arch = EF_AMDGPU_MACH_AMDGCN_GFX803;\n+      else if (strcmp (argv[i], \"-march=gfx900\") == 0)\n+\telf_arch = EF_AMDGPU_MACH_AMDGCN_GFX900;\n+      else if (strcmp (argv[i], \"-march=gfx906\") == 0)\n+\telf_arch = EF_AMDGPU_MACH_AMDGCN_GFX906;\n     }\n+\n   if (!(fopenacc ^ fopenmp))\n     fatal_error (input_location, \"either -fopenacc or -fopenmp must be set\");\n \n@@ -693,6 +902,10 @@ main (int argc, char **argv)\n       gcn_o_name = make_temp_file (\".mkoffload.hsaco\");\n       gcn_cfile_name = make_temp_file (\".c\");\n     }\n+  obstack_ptr_grow (&files_to_cleanup, gcn_s1_name);\n+  obstack_ptr_grow (&files_to_cleanup, gcn_s2_name);\n+  obstack_ptr_grow (&files_to_cleanup, gcn_o_name);\n+  obstack_ptr_grow (&files_to_cleanup, gcn_cfile_name);\n \n   obstack_ptr_grow (&cc_argv_obstack, \"-dumpdir\");\n   obstack_ptr_grow (&cc_argv_obstack, \"\");\n@@ -710,6 +923,39 @@ main (int argc, char **argv)\n   struct obstack ld_argv_obstack;\n   obstack_init (&ld_argv_obstack);\n   obstack_ptr_grow (&ld_argv_obstack, driver);\n+\n+  /* Extract early-debug information from the input objects.\n+     This loop finds all the inputs that end \".o\" and aren't the output.  */\n+  int dbgcount = 0;\n+  for (int ix = 1; ix != argc; ix++)\n+    {\n+      if (!strcmp (argv[ix], \"-o\") && ix + 1 != argc)\n+\t++ix;\n+      else\n+\t{\n+\t  if (strcmp (argv[ix] + strlen(argv[ix]) - 2, \".o\") == 0)\n+\t    {\n+\t      char *dbgobj;\n+\t      if (save_temps)\n+\t\t{\n+\t\t  char buf[10];\n+\t\t  sprintf (buf, \"%d\", dbgcount++);\n+\t\t  dbgobj = concat (dumppfx, \".mkoffload.dbg\", buf, \".o\", NULL);\n+\t\t}\n+\t      else\n+\t\tdbgobj = make_temp_file (\".mkoffload.dbg.o\");\n+\n+\t      /* If the copy fails then just ignore it.  */\n+\t      if (copy_early_debug_info (argv[ix], dbgobj))\n+\t\t{\n+\t\t  obstack_ptr_grow (&ld_argv_obstack, dbgobj);\n+\t\t  obstack_ptr_grow (&files_to_cleanup, dbgobj);\n+\t\t}\n+\t      else\n+\t\tfree (dbgobj);\n+\t    }\n+\t}\n+    }\n   obstack_ptr_grow (&ld_argv_obstack, gcn_s2_name);\n   obstack_ptr_grow (&ld_argv_obstack, \"-lgomp\");\n "}]}