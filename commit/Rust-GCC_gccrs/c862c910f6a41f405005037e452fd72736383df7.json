{"sha": "c862c910f6a41f405005037e452fd72736383df7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg2MmM5MTBmNmE0MWY0MDUwMDUwMzdlNDUyZmQ3MjczNjM4M2RmNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-19T08:55:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-19T08:55:02Z"}, "message": "mips.c (mips_hard_regno_nregs): Put the UNITS_PER_WORD case last.\n\ngcc/\n\t* config/mips/mips.c (mips_hard_regno_nregs): Put the UNITS_PER_WORD\n\tcase last.\n\t(mips_class_max_nregs): Calculate the smallest consituent register\n\tsize and use that to determine an upper bound on the number of\n\tregisters.\n\nFrom-SVN: r129478", "tree": {"sha": "4582c7f788b6c946ad8d2368a65298c416fad322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4582c7f788b6c946ad8d2368a65298c416fad322"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c862c910f6a41f405005037e452fd72736383df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c862c910f6a41f405005037e452fd72736383df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c862c910f6a41f405005037e452fd72736383df7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c862c910f6a41f405005037e452fd72736383df7/comments", "author": null, "committer": null, "parents": [{"sha": "5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f5fe6d9f7e5680bbf6ebeca21172bc8e3b3454f"}], "stats": {"total": 67, "additions": 38, "deletions": 29}, "files": [{"sha": "41e12373090b09a5ad76b2505d585e79458e9dd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c862c910f6a41f405005037e452fd72736383df7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c862c910f6a41f405005037e452fd72736383df7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c862c910f6a41f405005037e452fd72736383df7", "patch": "@@ -1,3 +1,11 @@\n+2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (mips_hard_regno_nregs): Put the UNITS_PER_WORD\n+\tcase last.\n+\t(mips_class_max_nregs): Calculate the smallest consituent register\n+\tsize and use that to determine an upper bound on the number of\n+\tregisters.\n+\n 2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (mips16_copy_fpr_return_value): New function,"}, {"sha": "1abee68e82b140f15b80cd664f70eda3122b8f79", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c862c910f6a41f405005037e452fd72736383df7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c862c910f6a41f405005037e452fd72736383df7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c862c910f6a41f405005037e452fd72736383df7", "patch": "@@ -8805,46 +8805,47 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n   return false;\n }\n \n-/* Implement HARD_REGNO_NREGS.  The size of FP registers is controlled\n-   by UNITS_PER_FPREG.  The size of FP status registers is always 4, because\n-   they only hold condition code modes, and CCmode is always considered to\n-   be 4 bytes wide.  All other registers are word sized.  */\n+/* Implement HARD_REGNO_NREGS.  */\n \n unsigned int\n mips_hard_regno_nregs (int regno, enum machine_mode mode)\n {\n   if (ST_REG_P (regno))\n-    return ((GET_MODE_SIZE (mode) + 3) / 4);\n-  else if (! FP_REG_P (regno))\n-    return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n-  else\n-    return ((GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG);\n-}\n-\n-/* Implement CLASS_MAX_NREGS.\n+    /* The size of FP status registers is always 4, because they only hold\n+       CCmode values, and CCmode is always considered to be 4 bytes wide.  */\n+    return (GET_MODE_SIZE (mode) + 3) / 4;\n \n-   - UNITS_PER_FPREG controls the number of registers needed by FP_REGS.\n+  if (FP_REG_P (regno))\n+    return (GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG;\n \n-   - ST_REGS are always hold CCmode values, and CCmode values are\n-     considered to be 4 bytes wide.\n+  /* All other registers are word-sized.  */\n+  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n \n-   All other register classes are covered by UNITS_PER_WORD.  Note that\n-   this is true even for unions of integer and float registers when the\n-   latter are smaller than the former.  The only supported combination\n-   in which case this occurs is -mgp64 -msingle-float, which has 64-bit\n-   words but 32-bit float registers.  A word-based calculation is correct\n-   in that case since -msingle-float disallows multi-FPR values.  */\n+/* Implement CLASS_MAX_NREGS, taking the maximum of the cases\n+   in mips_hard_regno_nregs.  */\n \n int\n-mips_class_max_nregs (enum reg_class class ATTRIBUTE_UNUSED,\n-\t\t      enum machine_mode mode)\n+mips_class_max_nregs (enum reg_class class, enum machine_mode mode)\n {\n-  if (class == ST_REGS)\n-    return (GET_MODE_SIZE (mode) + 3) / 4;\n-  else if (class == FP_REGS)\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG;\n-  else\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  int size;\n+  HARD_REG_SET left;\n+\n+  size = 0x8000;\n+  COPY_HARD_REG_SET (left, reg_class_contents[(int) class]);\n+  if (hard_reg_set_intersect_p (left, reg_class_contents[(int) ST_REGS]))\n+    {\n+      size = MIN (size, 4);\n+      AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) ST_REGS]);\n+    }\n+  if (hard_reg_set_intersect_p (left, reg_class_contents[(int) FP_REGS]))\n+    {\n+      size = MIN (size, UNITS_PER_FPREG);\n+      AND_COMPL_HARD_REG_SET (left, reg_class_contents[(int) FP_REGS]);\n+    }\n+  if (!hard_reg_set_empty_p (left))\n+    size = MIN (size, UNITS_PER_WORD);\n+  return (GET_MODE_SIZE (mode) + size - 1) / size;\n }\n \n /* Return true if registers of class CLASS cannot change from mode FROM"}]}