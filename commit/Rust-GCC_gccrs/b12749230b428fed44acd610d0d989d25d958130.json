{"sha": "b12749230b428fed44acd610d0d989d25d958130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyNzQ5MjMwYjQyOGZlZDQ0YWNkNjEwZDBkOTg5ZDI1ZDk1ODEzMA==", "commit": {"author": {"name": "Roman Gareev", "email": "gareevroman@gmail.com", "date": "2014-11-10T20:32:31Z"}, "committer": {"name": "Roman Gareev", "email": "romangareev@gcc.gnu.org", "date": "2014-11-10T20:32:31Z"}, "message": "Makefile.in: Remove the compilation of graphite-clast-to-gimple.o.\n\n[gcc/]\n\n\t* Makefile.in: Remove the compilation of graphite-clast-to-gimple.o.\n\t* common.opt: Remove using of fgraphite-code-generator flag.\n\t* flag-types.h: Likewise.\n\t* graphite.c: Remove using of CLooG.\n\t* graphite-blocking.c: Likewise.\n\t* graphite-dependences.c: Likewise.\n\t* graphite-poly.c: Likewise.\n\t* graphite-poly.h: Likewise.\n\t* graphite-scop-detection.c: Likewise.\n\t* graphite-sese-to-poly.c: Likewise.\n\t* graphite-clast-to-gimple.c: Removed.\n\t* graphite-clast-to-gimple.h: Likewise.\n\t* graphite-htab.h: Likewise.\n\n[gcc/testsuite]\n\n\t* gcc.dg/graphite/isl-ast-gen-blocks-1.c: Remove using of\n\tfgraphite-code-generator flag.\n\t* gcc.dg/graphite/isl-ast-gen-blocks-2.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-blocks-3.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-blocks-4.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-user-1.c: Likewise.\n\t* gcc.dg/graphite/isl-codegen-loop-dumping.c: Likewise.\n\t* gcc.dg/graphite/pr35356-2.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-single-loop-1.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-single-loop-2.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-single-loop-3.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-if-1.c: Likewise.\n\t* gcc.dg/graphite/isl-ast-gen-if-2.c: Likewise.\n\nFrom-SVN: r217315", "tree": {"sha": "880faee88045c7eb6c71b0cf2b6e6e0bbee2e86e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/880faee88045c7eb6c71b0cf2b6e6e0bbee2e86e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b12749230b428fed44acd610d0d989d25d958130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12749230b428fed44acd610d0d989d25d958130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b12749230b428fed44acd610d0d989d25d958130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12749230b428fed44acd610d0d989d25d958130/comments", "author": {"login": "gareevroman", "id": 6114710, "node_id": "MDQ6VXNlcjYxMTQ3MTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6114710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gareevroman", "html_url": "https://github.com/gareevroman", "followers_url": "https://api.github.com/users/gareevroman/followers", "following_url": "https://api.github.com/users/gareevroman/following{/other_user}", "gists_url": "https://api.github.com/users/gareevroman/gists{/gist_id}", "starred_url": "https://api.github.com/users/gareevroman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gareevroman/subscriptions", "organizations_url": "https://api.github.com/users/gareevroman/orgs", "repos_url": "https://api.github.com/users/gareevroman/repos", "events_url": "https://api.github.com/users/gareevroman/events{/privacy}", "received_events_url": "https://api.github.com/users/gareevroman/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "642fe4a92d723046114cefb837c326b24829ec73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/642fe4a92d723046114cefb837c326b24829ec73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/642fe4a92d723046114cefb837c326b24829ec73"}], "stats": {"total": 2129, "additions": 44, "deletions": 2085}, "files": [{"sha": "6ad43420446be26a0e5981b730c758ee1d1e2971", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,3 +1,19 @@\n+2014-11-10 Roman Gareev  <gareevroman@gmail.com>\n+\n+\t* Makefile.in: Remove the compilation of graphite-clast-to-gimple.o.\n+\t* common.opt: Remove using of fgraphite-code-generator flag.\n+\t* flag-types.h: Likewise.\n+\t* graphite.c: Remove using of CLooG.\n+\t* graphite-blocking.c: Likewise.\n+\t* graphite-dependences.c: Likewise.\n+\t* graphite-poly.c: Likewise.\n+\t* graphite-poly.h: Likewise.\n+\t* graphite-scop-detection.c: Likewise.\n+\t* graphite-sese-to-poly.c: Likewise.\n+\t* graphite-clast-to-gimple.c: Removed.\n+\t* graphite-clast-to-gimple.h: Likewise.\n+\t* graphite-htab.h: Likewise.\n+\n 2014-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* doc/invoke.texi ([-Wshift-count-negative, -Wshift-count-overflow]):"}, {"sha": "4e856b16064105de7e09ef3f2a4e3285bcf2b7da", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1244,7 +1244,6 @@ OBJS = \\\n \tgraphds.o \\\n \tgraphite.o \\\n \tgraphite-blocking.o \\\n-\tgraphite-clast-to-gimple.o \\\n \tgraphite-isl-ast-to-gimple.o \\\n \tgraphite-dependences.o \\\n \tgraphite-interchange.o \\"}, {"sha": "784a4b0a05303d72a7b5e76dbf1a7d1044a7b578", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1293,19 +1293,6 @@ Enable in and out of Graphite representation\n fgraphite-identity\n Common Report Var(flag_graphite_identity) Optimization\n Enable Graphite Identity transformation\n- \n-fgraphite-code-generator=\n-Common Report RejectNegative Joined Optimization Enum(fgraphite_generator) Var(flag_graphite_code_gen) Init(FGRAPHITE_CODE_GEN_ISL)\n-Choose code generator of Graphite\n-\n-Enum\n-Name(fgraphite_generator) Type(enum fgraphite_generator) UnknownError(unknown code generator of graphite %qs)\n-\n-EnumValue\n-Enum(fgraphite_generator) String(isl) Value(FGRAPHITE_CODE_GEN_ISL)\n-\n-EnumValue\n-Enum(fgraphite_generator) String(cloog) Value(FGRAPHITE_CODE_GEN_CLOOG)\n \n fhoist-adjacent-loads\n Common Report Var(flag_hoist_adjacent_loads) Optimization"}, {"sha": "52ff7eec257ea779ca5536c70f86164fc6c51373", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -263,10 +263,4 @@ enum lto_partition_model {\n   LTO_PARTITION_MAX = 4\n };\n \n-/* The code generator used by graphite */\n-enum fgraphite_generator {\n-  FGRAPHITE_CODE_GEN_ISL = 0,\n-  FGRAPHITE_CODE_GEN_CLOOG = 1\n-};\n-\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "a8152774b34ac0c02814410247af3f02cff664e9", "filename": "gcc/graphite-blocking.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -28,10 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/map.h>\n #include <isl/union_map.h>\n #include <isl/constraint.h>\n-#ifdef HAVE_cloog\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#endif\n #endif\n \n #include \"system.h\""}, {"sha": "41a893eb996a487ccf43fa48539a8e3225445a78", "filename": "gcc/graphite-clast-to-gimple.c", "status": "removed", "additions": 0, "deletions": 1736, "changes": 1736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fe4a92d723046114cefb837c326b24829ec73/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fe4a92d723046114cefb837c326b24829ec73/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=642fe4a92d723046114cefb837c326b24829ec73", "patch": "@@ -1,1736 +0,0 @@\n-/* Translation of CLAST (CLooG AST) to Gimple.\n-   Copyright (C) 2009-2014 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-#ifdef HAVE_cloog\n-#include <isl/set.h>\n-#include <isl/map.h>\n-#include <isl/union_map.h>\n-#include <isl/list.h>\n-#include <isl/constraint.h>\n-#include <isl/ilp.h>\n-#include <isl/aff.h>\n-#include <isl/val.h>\n-#if defined(__cplusplus)\n-extern \"C\" {\n-#endif\n-#include <isl/val_gmp.h>\n-#if defined(__cplusplus)\n-}\n-#endif\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#endif\n-\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n-#include \"tree.h\"\n-#include \"predict.h\"\n-#include \"vec.h\"\n-#include \"hashtab.h\"\n-#include \"hash-set.h\"\n-#include \"machmode.h\"\n-#include \"tm.h\"\n-#include \"hard-reg-set.h\"\n-#include \"input.h\"\n-#include \"function.h\"\n-#include \"dominance.h\"\n-#include \"cfg.h\"\n-#include \"basic-block.h\"\n-#include \"tree-ssa-alias.h\"\n-#include \"internal-fn.h\"\n-#include \"gimple-expr.h\"\n-#include \"is-a.h\"\n-#include \"gimple.h\"\n-#include \"gimple-iterator.h\"\n-#include \"gimplify-me.h\"\n-#include \"gimple-ssa.h\"\n-#include \"tree-ssa-loop-manip.h\"\n-#include \"tree-ssa-loop.h\"\n-#include \"tree-into-ssa.h\"\n-#include \"tree-pass.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-chrec.h\"\n-#include \"tree-data-ref.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"sese.h\"\n-\n-#ifdef HAVE_cloog\n-#include \"cloog/cloog.h\"\n-#include \"graphite-poly.h\"\n-#include \"graphite-clast-to-gimple.h\"\n-#include \"graphite-htab.h\"\n-\n-typedef const struct clast_expr *clast_name_p;\n-\n-#ifndef CLOOG_LANGUAGE_C\n-#define CLOOG_LANGUAGE_C LANGUAGE_C\n-#endif\n-\n-\n-/* Converts a GMP constant VAL to a tree and returns it.  */\n-\n-static tree\n-gmp_cst_to_tree (tree type, mpz_t val)\n-{\n-  tree t = type ? type : integer_type_node;\n-  mpz_t tmp;\n-\n-  mpz_init (tmp);\n-  mpz_set (tmp, val);\n-  wide_int wi = wi::from_mpz (t, tmp, true);\n-  mpz_clear (tmp);\n-\n-  return wide_int_to_tree (t, wi);\n-}\n-\n-/* Sets RES to the min of V1 and V2.  */\n-\n-static void\n-value_min (mpz_t res, mpz_t v1, mpz_t v2)\n-{\n-  if (mpz_cmp (v1, v2) < 0)\n-    mpz_set (res, v1);\n-  else\n-    mpz_set (res, v2);\n-}\n-\n-/* Sets RES to the max of V1 and V2.  */\n-\n-static void\n-value_max (mpz_t res, mpz_t v1, mpz_t v2)\n-{\n-  if (mpz_cmp (v1, v2) < 0)\n-    mpz_set (res, v2);\n-  else\n-    mpz_set (res, v1);\n-}\n-\n-\n-/* This flag is set when an error occurred during the translation of\n-   CLAST to Gimple.  */\n-static bool graphite_regenerate_error;\n-\n-/* Verifies properties that GRAPHITE should maintain during translation.  */\n-\n-static inline void\n-graphite_verify (void)\n-{\n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-  verify_loop_closed_ssa (true);\n-#endif\n-}\n-\n-/* Stores the INDEX in a vector and the loop nesting LEVEL for a given\n-   clast NAME.  BOUND_ONE and BOUND_TWO represent the exact lower and\n-   upper bounds that can be inferred from the polyhedral representation.  */\n-\n-typedef struct clast_name_index {\n-  int index;\n-  int level;\n-  mpz_t bound_one, bound_two;\n-  const char *name;\n-  /* If free_name is set, the content of name was allocated by us and needs\n-     to be freed.  */\n-  char *free_name;\n-} *clast_name_index_p;\n-\n-/* Helper for hashing clast_name_index.  */\n-\n-struct clast_index_hasher\n-{\n-  typedef clast_name_index value_type;\n-  typedef clast_name_index compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n-};\n-\n-/* Computes a hash function for database element E.  */\n-\n-inline hashval_t\n-clast_index_hasher::hash (const value_type *e)\n-{\n-  hashval_t hash = 0;\n-\n-  int length = strlen (e->name);\n-  int i;\n-\n-  for (i = 0; i < length; ++i)\n-    hash = hash | (e->name[i] << (i % 4));\n-\n-  return hash;\n-}\n-\n-/* Compares database elements ELT1 and ELT2.  */\n-\n-inline bool\n-clast_index_hasher::equal (const value_type *elt1, const compare_type *elt2)\n-{\n-  return strcmp (elt1->name, elt2->name) == 0;\n-}\n-\n-/* Free the memory taken by a clast_name_index struct.  */\n-\n-inline void\n-clast_index_hasher::remove (value_type *c)\n-{\n-  if (c->free_name)\n-    free (c->free_name);\n-  mpz_clear (c->bound_one);\n-  mpz_clear (c->bound_two);\n-  free (c);\n-}\n-\n-typedef hash_table<clast_index_hasher> clast_index_htab_type;\n-\n-/* Returns a pointer to a new element of type clast_name_index_p built\n-   from NAME, INDEX, LEVEL, BOUND_ONE, and BOUND_TWO.  */\n-\n-static inline clast_name_index_p\n-new_clast_name_index (const char *name, int index, int level,\n-\t\t      mpz_t bound_one, mpz_t bound_two)\n-{\n-  clast_name_index_p res = XNEW (struct clast_name_index);\n-  char *new_name = XNEWVEC (char, strlen (name) + 1);\n-  strcpy (new_name, name);\n-\n-  res->name = new_name;\n-  res->free_name = new_name;\n-  res->level = level;\n-  res->index = index;\n-  mpz_init (res->bound_one);\n-  mpz_init (res->bound_two);\n-  mpz_set (res->bound_one, bound_one);\n-  mpz_set (res->bound_two, bound_two);\n-  return res;\n-}\n-\n-/* For a given clast NAME, returns -1 if NAME is not in the\n-   INDEX_TABLE, otherwise returns the loop level for the induction\n-   variable NAME, or if it is a parameter, the parameter number in the\n-   vector of parameters.  */\n-\n-static inline int\n-clast_name_to_level (clast_name_p name, clast_index_htab_type *index_table)\n-{\n-  struct clast_name_index tmp;\n-  clast_name_index **slot;\n-\n-  gcc_assert (name->type == clast_expr_name);\n-  tmp.name = ((const struct clast_name *) name)->name;\n-  tmp.free_name = NULL;\n-\n-  slot = index_table->find_slot (&tmp, NO_INSERT);\n-\n-  if (slot && *slot)\n-    return ((struct clast_name_index *) *slot)->level;\n-\n-  return -1;\n-}\n-\n-/* For a given clast NAME, returns -1 if it does not correspond to any\n-   parameter, or otherwise, returns the index in the PARAMS or\n-   SCATTERING_DIMENSIONS vector.  */\n-\n-static inline int\n-clast_name_to_index (struct clast_name *name, clast_index_htab_type *index_table)\n-{\n-  struct clast_name_index tmp;\n-  clast_name_index **slot;\n-\n-  tmp.name = ((const struct clast_name *) name)->name;\n-  tmp.free_name = NULL;\n-\n-  slot = index_table->find_slot (&tmp, NO_INSERT);\n-\n-  if (slot && *slot)\n-    return (*slot)->index;\n-\n-  return -1;\n-}\n-\n-/* For a given clast NAME, initializes the lower and upper bounds BOUND_ONE\n-   and BOUND_TWO stored in the INDEX_TABLE.  Returns true when NAME has been\n-   found in the INDEX_TABLE, false otherwise.  */\n-\n-static inline bool\n-clast_name_to_lb_ub (struct clast_name *name,\n-\t\t     clast_index_htab_type *index_table, mpz_t bound_one,\n-\t\t     mpz_t bound_two)\n-{\n-  struct clast_name_index tmp;\n-  clast_name_index **slot;\n-\n-  tmp.name = name->name;\n-  tmp.free_name = NULL;\n-\n-  slot = index_table->find_slot (&tmp, NO_INSERT);\n-\n-  if (slot && *slot)\n-    {\n-      mpz_set (bound_one, ((struct clast_name_index *) *slot)->bound_one);\n-      mpz_set (bound_two, ((struct clast_name_index *) *slot)->bound_two);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Records in INDEX_TABLE the INDEX and LEVEL for NAME.  */\n-\n-static inline void\n-save_clast_name_index (clast_index_htab_type *index_table, const char *name,\n-\t\t       int index, int level, mpz_t bound_one, mpz_t bound_two)\n-{\n-  struct clast_name_index tmp;\n-  clast_name_index **slot;\n-\n-  tmp.name = name;\n-  tmp.free_name = NULL;\n-  slot = index_table->find_slot (&tmp, INSERT);\n-\n-  if (slot)\n-    {\n-      free (*slot);\n-\n-      *slot = new_clast_name_index (name, index, level, bound_one, bound_two);\n-    }\n-}\n-\f\n-\n-/* NEWIVS_INDEX binds CLooG's scattering name to the index of the tree\n-   induction variable in NEWIVS.\n-\n-   PARAMS_INDEX binds CLooG's parameter name to the index of the tree\n-   parameter in PARAMS.  */\n-\n-typedef struct ivs_params {\n-  vec<tree> params, *newivs;\n-  clast_index_htab_type *newivs_index, *params_index;\n-  sese region;\n-} *ivs_params_p;\n-\n-/* Returns the tree variable from the name NAME that was given in\n-   Cloog representation.  */\n-\n-static tree\n-clast_name_to_gcc (struct clast_name *name, ivs_params_p ip)\n-{\n-  int index;\n-\n-  if (ip->params.exists () && ip->params_index)\n-    {\n-      index = clast_name_to_index (name, ip->params_index);\n-\n-      if (index >= 0)\n-\treturn ip->params[index];\n-    }\n-\n-  gcc_assert (ip->newivs && ip->newivs_index);\n-  index = clast_name_to_index (name, ip->newivs_index);\n-  gcc_assert (index >= 0);\n-\n-  return (*ip->newivs)[index];\n-}\n-\n-/* Returns the maximal precision type for expressions TYPE1 and TYPE2.  */\n-\n-static tree\n-max_precision_type (tree type1, tree type2)\n-{\n-  machine_mode mode;\n-  int p1, p2, precision;\n-  tree type;\n-\n-  if (POINTER_TYPE_P (type1))\n-    return type1;\n-\n-  if (POINTER_TYPE_P (type2))\n-    return type2;\n-\n-  if (TYPE_UNSIGNED (type1)\n-      && TYPE_UNSIGNED (type2))\n-    return TYPE_PRECISION (type1) > TYPE_PRECISION (type2) ? type1 : type2;\n-\n-  p1 = TYPE_PRECISION (type1);\n-  p2 = TYPE_PRECISION (type2);\n-\n-  if (p1 > p2)\n-    precision = TYPE_UNSIGNED (type1) ? p1 * 2 : p1;\n-  else\n-    precision = TYPE_UNSIGNED (type2) ? p2 * 2 : p2;\n-\n-  if (precision > BITS_PER_WORD)\n-    {\n-      graphite_regenerate_error = true;\n-      return integer_type_node;\n-    }\n-\n-  mode = smallest_mode_for_size (precision, MODE_INT);\n-  precision = GET_MODE_PRECISION (mode);\n-  type = build_nonstandard_integer_type (precision, false);\n-\n-  if (!type)\n-    {\n-      graphite_regenerate_error = true;\n-      return integer_type_node;\n-    }\n-\n-  return type;\n-}\n-\n-static tree\n-clast_to_gcc_expression (tree, struct clast_expr *, ivs_params_p);\n-\n-/* Converts a Cloog reduction expression R with reduction operation OP\n-   to a GCC expression tree of type TYPE.  */\n-\n-static tree\n-clast_to_gcc_expression_red (tree type, enum tree_code op,\n-\t\t\t     struct clast_reduction *r, ivs_params_p ip)\n-{\n-  int i;\n-  tree res = clast_to_gcc_expression (type, r->elts[0], ip);\n-  tree operand_type = (op == POINTER_PLUS_EXPR) ? sizetype : type;\n-\n-  for (i = 1; i < r->n; i++)\n-    {\n-      tree t = clast_to_gcc_expression (operand_type, r->elts[i], ip);\n-      res = fold_build2 (op, type, res, t);\n-    }\n-\n-  return res;\n-}\n-\n-/* Converts a Cloog AST expression E back to a GCC expression tree of\n-   type TYPE.  */\n-\n-static tree\n-clast_to_gcc_expression (tree type, struct clast_expr *e, ivs_params_p ip)\n-{\n-  switch (e->type)\n-    {\n-    case clast_expr_name:\n-      {\n-\treturn clast_name_to_gcc ((struct clast_name *) e, ip);\n-      }\n-    case clast_expr_term:\n-      {\n-\tstruct clast_term *t = (struct clast_term *) e;\n-\n-\tif (t->var)\n-\t  {\n-\t    if (mpz_cmp_si (t->val, 1) == 0)\n-\t      {\n-\t\ttree name = clast_to_gcc_expression (type, t->var, ip);\n-\n-\t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n-\t\t  name = convert_to_ptrofftype (name);\n-\n-\t\tname = fold_convert (type, name);\n-\t\treturn name;\n-\t      }\n-\n-\t    else if (mpz_cmp_si (t->val, -1) == 0)\n-\t      {\n-\t\ttree name = clast_to_gcc_expression (type, t->var, ip);\n-\n-\t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n-\t\t  name = convert_to_ptrofftype (name);\n-\n-\t\tname = fold_convert (type, name);\n-\n-\t\treturn fold_build1 (NEGATE_EXPR, type, name);\n-\t      }\n-\t    else\n-\t      {\n-\t\ttree name = clast_to_gcc_expression (type, t->var, ip);\n-\t\ttree cst = gmp_cst_to_tree (type, t->val);\n-\n-\t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n-\t\t  name = convert_to_ptrofftype (name);\n-\n-\t\tname = fold_convert (type, name);\n-\n-\t\tif (!POINTER_TYPE_P (type))\n-\t\t  return fold_build2 (MULT_EXPR, type, cst, name);\n-\n-\t\tgraphite_regenerate_error = true;\n-\t\treturn cst;\n-\t      }\n-\t  }\n-\telse\n-\t  return gmp_cst_to_tree (type, t->val);\n-      }\n-\n-    case clast_expr_red:\n-      {\n-        struct clast_reduction *r = (struct clast_reduction *) e;\n-\n-        switch (r->type)\n-          {\n-\t  case clast_red_sum:\n-\t    return clast_to_gcc_expression_red\n-\t      (type, POINTER_TYPE_P (type) ? POINTER_PLUS_EXPR : PLUS_EXPR,\n-\t       r, ip);\n-\n-\t  case clast_red_min:\n-\t    return clast_to_gcc_expression_red (type, MIN_EXPR, r, ip);\n-\n-\t  case clast_red_max:\n-\t    return clast_to_gcc_expression_red (type, MAX_EXPR, r, ip);\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-          }\n-        break;\n-      }\n-\n-    case clast_expr_bin:\n-      {\n-\tstruct clast_binary *b = (struct clast_binary *) e;\n-\tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n-\ttree tl = clast_to_gcc_expression (type, lhs, ip);\n-\ttree tr = gmp_cst_to_tree (type, b->RHS);\n-\n-\tswitch (b->type)\n-\t  {\n-\t  case clast_bin_fdiv:\n-\t    return fold_build2 (FLOOR_DIV_EXPR, type, tl, tr);\n-\n-\t  case clast_bin_cdiv:\n-\t    return fold_build2 (CEIL_DIV_EXPR, type, tl, tr);\n-\n-\t  case clast_bin_div:\n-\t    return fold_build2 (EXACT_DIV_EXPR, type, tl, tr);\n-\n-\t  case clast_bin_mod:\n-\t    return fold_build2 (TRUNC_MOD_EXPR, type, tl, tr);\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Return a type that could represent the values between BOUND_ONE and\n-   BOUND_TWO.  */\n-\n-static tree\n-type_for_interval (mpz_t bound_one, mpz_t bound_two)\n-{\n-  bool unsigned_p;\n-  tree type;\n-  machine_mode mode;\n-  int wider_precision;\n-  int precision = MAX (mpz_sizeinbase (bound_one, 2),\n-\t\t       mpz_sizeinbase (bound_two, 2));\n-\n-  if (precision > BITS_PER_WORD)\n-    {\n-      graphite_regenerate_error = true;\n-      return integer_type_node;\n-    }\n-\n-  if (mpz_cmp (bound_one, bound_two) <= 0)\n-    unsigned_p = (mpz_sgn (bound_one) >= 0);\n-  else\n-    unsigned_p = (mpz_sgn (bound_two) >= 0);\n-\n-  mode = smallest_mode_for_size (precision, MODE_INT);\n-  wider_precision = GET_MODE_PRECISION (mode);\n-\n-  /* As we want to generate signed types as much as possible, try to\n-     fit the interval [bound_one, bound_two] in a signed type.  For example,\n-     supposing that we have the interval [0, 100], instead of\n-     generating unsigned char, we want to generate a signed char.  */\n-  if (unsigned_p && precision < wider_precision)\n-    unsigned_p = false;\n-\n-  type = build_nonstandard_integer_type (wider_precision, unsigned_p);\n-\n-  if (!type)\n-    {\n-      graphite_regenerate_error = true;\n-      return integer_type_node;\n-    }\n-\n-  return type;\n-}\n-\n-/* Return a type that could represent the integer value VAL, or\n-   otherwise return NULL_TREE.  */\n-\n-static tree\n-type_for_value (mpz_t val)\n-{\n-  return type_for_interval (val, val);\n-}\n-\n-static tree\n-type_for_clast_expr (struct clast_expr *, ivs_params_p, mpz_t, mpz_t);\n-\n-/* Return the type for the clast_term T.  Initializes BOUND_ONE and\n-   BOUND_TWO to the bounds of the term.  */\n-\n-static tree\n-type_for_clast_term (struct clast_term *t, ivs_params_p ip, mpz_t bound_one,\n-\t\t     mpz_t bound_two)\n-{\n-  tree type;\n-  gcc_assert (t->expr.type == clast_expr_term);\n-\n-  if (!t->var)\n-    {\n-      mpz_set (bound_one, t->val);\n-      mpz_set (bound_two, t->val);\n-      return type_for_value (t->val);\n-    }\n-\n-  type = type_for_clast_expr (t->var, ip, bound_one, bound_two);\n-\n-  mpz_mul (bound_one, bound_one, t->val);\n-  mpz_mul (bound_two, bound_two, t->val);\n-\n-  return max_precision_type (type, type_for_interval (bound_one, bound_two));\n-}\n-\n-/* Return the type for the clast_reduction R.  Initializes BOUND_ONE\n-   and BOUND_TWO to the bounds of the reduction expression.  */\n-\n-static tree\n-type_for_clast_red (struct clast_reduction *r, ivs_params_p ip,\n-\t\t    mpz_t bound_one, mpz_t bound_two)\n-{\n-  int i;\n-  tree type = type_for_clast_expr (r->elts[0], ip, bound_one, bound_two);\n-  mpz_t b1, b2, m1, m2;\n-\n-  if (r->n == 1)\n-    return type;\n-\n-  mpz_init (b1);\n-  mpz_init (b2);\n-  mpz_init (m1);\n-  mpz_init (m2);\n-\n-  for (i = 1; i < r->n; i++)\n-    {\n-      tree t = type_for_clast_expr (r->elts[i], ip, b1, b2);\n-      type = max_precision_type (type, t);\n-\n-      switch (r->type)\n-\t{\n-\tcase clast_red_sum:\n-\t  value_min (m1, bound_one, bound_two);\n-\t  value_min (m2, b1, b2);\n-\t  mpz_add (bound_one, m1, m2);\n-\n-\t  value_max (m1, bound_one, bound_two);\n-\t  value_max (m2, b1, b2);\n-\t  mpz_add (bound_two, m1, m2);\n-\t  break;\n-\n-\tcase clast_red_min:\n-\t  value_min (bound_one, bound_one, bound_two);\n-\t  value_min (bound_two, b1, b2);\n-\t  break;\n-\n-\tcase clast_red_max:\n-\t  value_max (bound_one, bound_one, bound_two);\n-\t  value_max (bound_two, b1, b2);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  break;\n-\t}\n-    }\n-\n-  mpz_clear (b1);\n-  mpz_clear (b2);\n-  mpz_clear (m1);\n-  mpz_clear (m2);\n-\n-  /* Return a type that can represent the result of the reduction.  */\n-  return max_precision_type (type, type_for_interval (bound_one, bound_two));\n-}\n-\n-/* Return the type for the clast_binary B used in STMT.  */\n-\n-static tree\n-type_for_clast_bin (struct clast_binary *b, ivs_params_p ip, mpz_t bound_one,\n-\t\t    mpz_t bound_two)\n-{\n-  mpz_t one;\n-  tree l = type_for_clast_expr ((struct clast_expr *) b->LHS, ip,\n-\t\t\t\tbound_one, bound_two);\n-  tree r = type_for_value (b->RHS);\n-  tree type = max_precision_type (l, r);\n-\n-  switch (b->type)\n-    {\n-    case clast_bin_fdiv:\n-      mpz_mdiv (bound_one, bound_one, b->RHS);\n-      mpz_mdiv (bound_two, bound_two, b->RHS);\n-      break;\n-\n-    case clast_bin_cdiv:\n-      mpz_mdiv (bound_one, bound_one, b->RHS);\n-      mpz_mdiv (bound_two, bound_two, b->RHS);\n-      mpz_init (one);\n-      mpz_add (bound_one, bound_one, one);\n-      mpz_add (bound_two, bound_two, one);\n-      mpz_clear (one);\n-      break;\n-\n-    case clast_bin_div:\n-      mpz_div (bound_one, bound_one, b->RHS);\n-      mpz_div (bound_two, bound_two, b->RHS);\n-      break;\n-\n-    case clast_bin_mod:\n-      mpz_mod (bound_one, bound_one, b->RHS);\n-      mpz_mod (bound_two, bound_two, b->RHS);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Return a type that can represent the result of the reduction.  */\n-  return max_precision_type (type, type_for_interval (bound_one, bound_two));\n-}\n-\n-/* Return the type for the clast_name NAME.  Initializes BOUND_ONE and\n-   BOUND_TWO to the bounds of the term.  */\n-\n-static tree\n-type_for_clast_name (struct clast_name *name, ivs_params_p ip, mpz_t bound_one,\n-\t\t     mpz_t bound_two)\n-{\n-  bool found = false;\n-\n-  if (ip->params.exists () && ip->params_index)\n-    found = clast_name_to_lb_ub (name, ip->params_index, bound_one, bound_two);\n-\n-  if (!found)\n-    {\n-      gcc_assert (ip->newivs && ip->newivs_index);\n-      found = clast_name_to_lb_ub (name, ip->newivs_index, bound_one,\n-\t\t\t\t   bound_two);\n-      gcc_assert (found);\n-    }\n-\n-    return TREE_TYPE (clast_name_to_gcc (name, ip));\n-}\n-\n-/* Returns the type for the CLAST expression E when used in statement\n-   STMT.  */\n-\n-static tree\n-type_for_clast_expr (struct clast_expr *e, ivs_params_p ip, mpz_t bound_one,\n-\t\t     mpz_t bound_two)\n-{\n-  switch (e->type)\n-    {\n-    case clast_expr_term:\n-      return type_for_clast_term ((struct clast_term *) e, ip,\n-\t\t\t\t  bound_one, bound_two);\n-\n-    case clast_expr_red:\n-      return type_for_clast_red ((struct clast_reduction *) e, ip,\n-\t\t\t\t bound_one, bound_two);\n-\n-    case clast_expr_bin:\n-      return type_for_clast_bin ((struct clast_binary *) e, ip,\n-\t\t\t\t bound_one, bound_two);\n-\n-    case clast_expr_name:\n-      return type_for_clast_name ((struct clast_name *) e, ip,\n-\t\t\t\t bound_one, bound_two);\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Returns true if the clast expression E is a constant with VALUE.  */\n-\n-static bool\n-clast_expr_const_value_p (struct clast_expr *e, int value)\n-{\n-  struct clast_term *t;\n-  if (e->type != clast_expr_term)\n-    return false;\n-  t = (struct clast_term *)e;\n-  if (t->var)\n-    return false;\n-  return 0 == mpz_cmp_si (t->val, value);\n-}\n-\n-/* Translates a clast equation CLEQ to a tree.  */\n-\n-static tree\n-graphite_translate_clast_equation (struct clast_equation *cleq,\n-\t\t\t\t   ivs_params_p ip)\n-{\n-  enum tree_code comp;\n-  tree type, lhs, rhs, ltype, rtype;\n-  mpz_t bound_one, bound_two;\n-  struct clast_expr *clhs, *crhs;\n-\n-  clhs = cleq->LHS;\n-  crhs = cleq->RHS;\n-  if (cleq->sign == 0)\n-    comp = EQ_EXPR;\n-  else if (cleq->sign > 0)\n-    comp = GE_EXPR;\n-  else\n-    comp = LE_EXPR;\n-\n-  /* Special cases to reduce range of arguments to hopefully\n-     don't need types with larger precision than the input.  */\n-  if (crhs->type == clast_expr_red\n-      && comp != EQ_EXPR)\n-    {\n-      struct clast_reduction *r = (struct clast_reduction *) crhs;\n-      /* X >= A+1 --> X > A and\n-         X <= A-1 --> X < A  */\n-      if (r->n == 2\n-\t  && r->type == clast_red_sum\n-\t  && clast_expr_const_value_p (r->elts[1], comp == GE_EXPR ? 1 : -1))\n-\t{\n-\t  crhs = r->elts[0];\n-\t  comp = comp == GE_EXPR ? GT_EXPR : LT_EXPR;\n-\t}\n-    }\n-\n-  mpz_init (bound_one);\n-  mpz_init (bound_two);\n-\n-  ltype = type_for_clast_expr (clhs, ip, bound_one, bound_two);\n-  rtype = type_for_clast_expr (crhs, ip, bound_one, bound_two);\n-\n-  mpz_clear (bound_one);\n-  mpz_clear (bound_two);\n-  type = max_precision_type (ltype, rtype);\n-\n-  lhs = clast_to_gcc_expression (type, clhs, ip);\n-  rhs = clast_to_gcc_expression (type, crhs, ip);\n-\n-  return fold_build2 (comp, boolean_type_node, lhs, rhs);\n-}\n-\n-/* Creates the test for the condition in STMT.  */\n-\n-static tree\n-graphite_create_guard_cond_expr (struct clast_guard *stmt,\n-\t\t\t\t ivs_params_p ip)\n-{\n-  tree cond = NULL;\n-  int i;\n-\n-  for (i = 0; i < stmt->n; i++)\n-    {\n-      tree eq = graphite_translate_clast_equation (&stmt->eq[i], ip);\n-\n-      if (cond)\n-\tcond = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (eq), cond, eq);\n-      else\n-\tcond = eq;\n-    }\n-\n-  return cond;\n-}\n-\n-/* Creates a new if region corresponding to Cloog's guard.  */\n-\n-static edge\n-graphite_create_new_guard (edge entry_edge, struct clast_guard *stmt,\n-\t\t\t   ivs_params_p ip)\n-{\n-  tree cond_expr = graphite_create_guard_cond_expr (stmt, ip);\n-  edge exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n-  return exit_edge;\n-}\n-\n-/* Compute the lower bound LOW and upper bound UP for the parameter\n-   PARAM in scop SCOP based on the constraints in the context.  */\n-\n-static void\n-compute_bounds_for_param (scop_p scop, int param, mpz_t low, mpz_t up)\n-{\n-  isl_val *v;\n-  isl_aff *aff = isl_aff_zero_on_domain\n-    (isl_local_space_from_space (isl_set_get_space (scop->context)));\n-\n-  aff = isl_aff_add_coefficient_si (aff, isl_dim_param, param, 1);\n-\n-  v = isl_set_min_val (scop->context, aff);\n-  isl_val_get_num_gmp (v, low);\n-  isl_val_free (v);\n-  v = isl_set_max_val (scop->context, aff);\n-  isl_val_get_num_gmp (v, up);\n-  isl_val_free (v);\n-  isl_aff_free (aff);\n-}\n-\n-/* Compute the lower bound LOW and upper bound UP for the induction\n-   variable of loop LOOP.\n-\n-   FIXME: This one is not entirely correct, as min/max expressions in the\n-\t  calculation can yield to incorrect results. To be completely\n-\t  correct, we need to evaluate each subexpression generated by\n-          CLooG. CLooG does not yet support this, so this is as good as\n-\t  it can be. */\n-\n-static void\n-compute_bounds_for_loop (struct clast_for *loop, mpz_t low, mpz_t up)\n-{\n-  isl_set *domain;\n-  isl_aff *dimension;\n-  isl_local_space *local_space;\n-  isl_val *isl_value;\n-\n-  domain = isl_set_copy (isl_set_from_cloog_domain (loop->domain));\n-  local_space = isl_local_space_from_space (isl_set_get_space (domain));\n-  dimension = isl_aff_zero_on_domain (local_space);\n-  dimension = isl_aff_add_coefficient_si (dimension, isl_dim_in,\n-\t\t\t\t\t  isl_set_dim (domain, isl_dim_set) - 1,\n-\t\t\t\t\t  1);\n-\n-  isl_value = isl_set_min_val (domain, dimension);\n-  isl_val_get_num_gmp (isl_value, low);\n-  isl_val_free (isl_value);\n-  isl_value = isl_set_max_val (domain, dimension);\n-  isl_val_get_num_gmp (isl_value, up);\n-  isl_val_free (isl_value);\n-  isl_set_free (domain);\n-  isl_aff_free (dimension);\n-}\n-\n-/* Returns the type for the induction variable for the loop translated\n-   from STMT_FOR.  */\n-\n-static tree\n-type_for_clast_for (struct clast_for *stmt_for, ivs_params_p ip)\n-{\n-  mpz_t bound_one, bound_two;\n-  tree lb_type, ub_type;\n-\n-  mpz_init (bound_one);\n-  mpz_init (bound_two);\n-\n-  lb_type = type_for_clast_expr (stmt_for->LB, ip, bound_one, bound_two);\n-  ub_type = type_for_clast_expr (stmt_for->UB, ip, bound_one, bound_two);\n-\n-  mpz_clear (bound_one);\n-  mpz_clear (bound_two);\n-\n-  return max_precision_type (lb_type, ub_type);\n-}\n-\n-/* Creates a new LOOP corresponding to Cloog's STMT.  Inserts an\n-   induction variable for the new LOOP.  New LOOP is attached to CFG\n-   starting at ENTRY_EDGE.  LOOP is inserted into the loop tree and\n-   becomes the child loop of the OUTER_LOOP.  NEWIVS_INDEX binds\n-   CLooG's scattering name to the induction variable created for the\n-   loop of STMT.  The new induction variable is inserted in the NEWIVS\n-   vector and is of type TYPE.  */\n-\n-static struct loop *\n-graphite_create_new_loop (edge entry_edge, struct clast_for *stmt,\n-\t\t\t  loop_p outer, tree type, tree lb, tree ub,\n-\t\t\t  int level, ivs_params_p ip)\n-{\n-  mpz_t low, up;\n-\n-  tree stride = gmp_cst_to_tree (type, stmt->stride);\n-  tree ivvar = create_tmp_var (type, \"graphite_IV\");\n-  tree iv, iv_after_increment;\n-  loop_p loop = create_empty_loop_on_edge\n-    (entry_edge, lb, stride, ub, ivvar, &iv, &iv_after_increment,\n-     outer ? outer : entry_edge->src->loop_father);\n-\n-  mpz_init (low);\n-  mpz_init (up);\n-  compute_bounds_for_loop (stmt, low, up);\n-  save_clast_name_index (ip->newivs_index, stmt->iterator,\n-\t\t\t (*ip->newivs).length (), level, low, up);\n-  mpz_clear (low);\n-  mpz_clear (up);\n-  (*ip->newivs).safe_push (iv);\n-  return loop;\n-}\n-\n-/* Inserts in iv_map a tuple (OLD_LOOP->num, NEW_NAME) for the\n-   induction variables of the loops around GBB in SESE.  */\n-\n-static void\n-build_iv_mapping (vec<tree> iv_map, struct clast_user_stmt *user_stmt,\n-\t\t  ivs_params_p ip)\n-{\n-  struct clast_stmt *t;\n-  int depth = 0;\n-  CloogStatement *cs = user_stmt->statement;\n-  poly_bb_p pbb = (poly_bb_p) cs->usr;\n-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  mpz_t bound_one, bound_two;\n-\n-  mpz_init (bound_one);\n-  mpz_init (bound_two);\n-\n-  for (t = user_stmt->substitutions; t; t = t->next, depth++)\n-    {\n-      struct clast_expr *expr = (struct clast_expr *)\n-       ((struct clast_assignment *)t)->RHS;\n-      tree type = type_for_clast_expr (expr, ip, bound_one, bound_two);\n-      tree new_name = clast_to_gcc_expression (type, expr, ip);\n-      loop_p old_loop = gbb_loop_at_index (gbb, ip->region, depth);\n-\n-      iv_map[old_loop->num] = new_name;\n-    }\n-\n-  mpz_clear (bound_one);\n-  mpz_clear (bound_two);\n-}\n-\n-/* Mark BB with it's relevant PBB via hashing table BB_PBB_MAPPING.  */\n-\n-static void\n-mark_bb_with_pbb (poly_bb_p pbb, basic_block bb,\n-\t\t  bb_pbb_htab_type *bb_pbb_mapping)\n-{\n-  bool existed;\n-  poly_bb_p &e = bb_pbb_mapping->get_or_insert (bb, &existed);\n-  if (!existed)\n-    e = pbb;\n-}\n-\n-/* Find BB's related poly_bb_p in hash table BB_PBB_MAPPING.  */\n-\n-poly_bb_p\n-find_pbb_via_hash (bb_pbb_htab_type *bb_pbb_mapping, basic_block bb)\n-{\n-  poly_bb_p *pbb = bb_pbb_mapping->get (bb);\n-  if (pbb)\n-    return *pbb;\n-\n-  return NULL;\n-}\n-\n-/* Return the scop of the loop and initialize PBBS the set of\n-   poly_bb_p that belong to the LOOP.  BB_PBB_MAPPING is a map created\n-   by the CLAST code generator between a generated basic_block and its\n-   related poly_bb_p.  */\n-\n-scop_p\n-get_loop_body_pbbs (loop_p loop, bb_pbb_htab_type *bb_pbb_mapping,\n-\t\t    vec<poly_bb_p> *pbbs)\n-{\n-  unsigned i;\n-  basic_block *bbs = get_loop_body_in_dom_order (loop);\n-  scop_p scop = NULL;\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      poly_bb_p pbb = find_pbb_via_hash (bb_pbb_mapping, bbs[i]);\n-\n-      if (pbb == NULL)\n-\tcontinue;\n-\n-      scop = PBB_SCOP (pbb);\n-      (*pbbs).safe_push (pbb);\n-    }\n-\n-  free (bbs);\n-  return scop;\n-}\n-\n-/* Translates a clast user statement STMT to gimple.\n-\n-   - NEXT_E is the edge where new generated code should be attached.\n-   - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n-\n-static edge\n-translate_clast_user (struct clast_user_stmt *stmt, edge next_e,\n-\t\t      bb_pbb_htab_type *bb_pbb_mapping, ivs_params_p ip)\n-{\n-  int i, nb_loops;\n-  basic_block new_bb;\n-  poly_bb_p pbb = (poly_bb_p) stmt->statement->usr;\n-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  vec<tree> iv_map;\n-\n-  if (GBB_BB (gbb) == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-    return next_e;\n-\n-  nb_loops = number_of_loops (cfun);\n-  iv_map.create (nb_loops);\n-  for (i = 0; i < nb_loops; i++)\n-    iv_map.quick_push (NULL_TREE);\n-\n-  build_iv_mapping (iv_map, stmt, ip);\n-  next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), ip->region,\n-\t\t\t\t\t   next_e, iv_map,\n-\t\t\t\t\t   &graphite_regenerate_error);\n-  iv_map.release ();\n-\n-  new_bb = next_e->src;\n-  mark_bb_with_pbb (pbb, new_bb, bb_pbb_mapping);\n-  mark_virtual_operands_for_renaming (cfun);\n-  update_ssa (TODO_update_ssa);\n-\n-  return next_e;\n-}\n-\n-/* Creates a new if region protecting the loop to be executed, if the execution\n-   count is zero (lb > ub).  */\n-\n-static edge\n-graphite_create_new_loop_guard (edge entry_edge, struct clast_for *stmt,\n-\t\t\t\ttree *type, tree *lb, tree *ub,\n-\t\t\t\tivs_params_p ip)\n-{\n-  tree cond_expr;\n-  edge exit_edge;\n-\n-  *type = type_for_clast_for (stmt, ip);\n-  *lb = clast_to_gcc_expression (*type, stmt->LB, ip);\n-  *ub = clast_to_gcc_expression (*type, stmt->UB, ip);\n-\n-  /* When ub is simply a constant or a parameter, use lb <= ub.  */\n-  if (TREE_CODE (*ub) == INTEGER_CST || TREE_CODE (*ub) == SSA_NAME)\n-    cond_expr = fold_build2 (LE_EXPR, boolean_type_node, *lb, *ub);\n-  else\n-    {\n-      tree one = (POINTER_TYPE_P (*type)\n-\t\t  ? convert_to_ptrofftype (integer_one_node)\n-\t\t  : fold_convert (*type, integer_one_node));\n-      /* Adding +1 and using LT_EXPR helps with loop latches that have a\n-\t loop iteration count of \"PARAMETER - 1\".  For PARAMETER == 0 this becomes\n-\t 2^k-1 due to integer overflow, and the condition lb <= ub is true,\n-\t even if we do not want this.  However lb < ub + 1 is false, as\n-\t expected.  */\n-      tree ub_one = fold_build2 (POINTER_TYPE_P (*type) ? POINTER_PLUS_EXPR\n-\t\t\t\t : PLUS_EXPR, *type, *ub, one);\n-\n-      cond_expr = fold_build2 (LT_EXPR, boolean_type_node, *lb, ub_one);\n-    }\n-\n-  exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n-\n-  return exit_edge;\n-}\n-\n-static edge\n-translate_clast (loop_p, struct clast_stmt *, edge, bb_pbb_htab_type *,\n-\t\t int, ivs_params_p);\n-\n-/* Create the loop for a clast for statement.\n-\n-   - NEXT_E is the edge where new generated code should be attached.\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n-\n-static edge\n-translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n-\t\t\t  edge next_e, bb_pbb_htab_type *bb_pbb_mapping,\n-\t\t\t  int level, tree type, tree lb, tree ub,\n-\t\t\t  ivs_params_p ip)\n-{\n-  struct loop *loop = graphite_create_new_loop (next_e, stmt, context_loop,\n-\t\t\t\t\t\ttype, lb, ub, level, ip);\n-  edge last_e = single_exit (loop);\n-  edge to_body = single_succ_edge (loop->header);\n-  basic_block after = to_body->dest;\n-\n-  /* Create a basic block for loop close phi nodes.  */\n-  last_e = single_succ_edge (split_edge (last_e));\n-\n-  /* Translate the body of the loop.  */\n-  next_e = translate_clast (loop, stmt->body, to_body, bb_pbb_mapping,\n-\t\t\t    level + 1, ip);\n-  redirect_edge_succ_nodup (next_e, after);\n-  set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n-\n-  isl_set *domain = isl_set_from_cloog_domain (stmt->domain);\n-  int scheduling_dim = isl_set_n_dim (domain);\n-\n-  if (flag_loop_parallelize_all\n-      && loop_is_parallel_p (loop, bb_pbb_mapping, scheduling_dim))\n-    loop->can_be_parallel = true;\n-\n-  return last_e;\n-}\n-\n-/* Translates a clast for statement STMT to gimple.  First a guard is created\n-   protecting the loop, if it is executed zero times.  In this guard we create\n-   the real loop structure.\n-\n-   - NEXT_E is the edge where new generated code should be attached.\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n-\n-static edge\n-translate_clast_for (loop_p context_loop, struct clast_for *stmt, edge next_e,\n-\t\t     bb_pbb_htab_type *bb_pbb_mapping, int level,\n-\t\t     ivs_params_p ip)\n-{\n-  tree type, lb, ub;\n-  edge last_e = graphite_create_new_loop_guard (next_e, stmt, &type,\n-\t\t\t\t\t\t&lb, &ub, ip);\n-  edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n-\n-  translate_clast_for_loop (context_loop, stmt, true_e, bb_pbb_mapping, level,\n-\t\t\t    type, lb, ub, ip);\n-  return last_e;\n-}\n-\n-/* Translates a clast assignment STMT to gimple.\n-\n-   - NEXT_E is the edge where new generated code should be attached.\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n-\n-static edge\n-translate_clast_assignment (struct clast_assignment *stmt, edge next_e,\n-\t\t\t    int level, ivs_params_p ip)\n-{\n-  gimple_seq stmts;\n-  mpz_t bound_one, bound_two;\n-  tree type, new_name, var;\n-  edge res = single_succ_edge (split_edge (next_e));\n-  struct clast_expr *expr = (struct clast_expr *) stmt->RHS;\n-\n-  mpz_init (bound_one);\n-  mpz_init (bound_two);\n-  type = type_for_clast_expr (expr, ip, bound_one, bound_two);\n-  var = create_tmp_var (type, \"graphite_var\");\n-  new_name = force_gimple_operand (clast_to_gcc_expression (type, expr, ip),\n-\t\t\t\t   &stmts, true, var);\n-  if (stmts)\n-    {\n-      gsi_insert_seq_on_edge (next_e, stmts);\n-      gsi_commit_edge_inserts ();\n-    }\n-\n-  save_clast_name_index (ip->newivs_index, stmt->LHS,\n-\t\t\t (*ip->newivs).length (), level,\n-\t\t\t bound_one, bound_two);\n-  (*ip->newivs).safe_push (new_name);\n-\n-  mpz_clear (bound_one);\n-  mpz_clear (bound_two);\n-\n-  return res;\n-}\n-\n-/* Translates a clast guard statement STMT to gimple.\n-\n-   - NEXT_E is the edge where new generated code should be attached.\n-   - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n-\n-static edge\n-translate_clast_guard (loop_p context_loop, struct clast_guard *stmt,\n-\t\t       edge next_e, bb_pbb_htab_type *bb_pbb_mapping, int level,\n-\t\t       ivs_params_p ip)\n-{\n-  edge last_e = graphite_create_new_guard (next_e, stmt, ip);\n-  edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n-\n-  translate_clast (context_loop, stmt->then, true_e, bb_pbb_mapping, level, ip);\n-  return last_e;\n-}\n-\n-/* Translates a CLAST statement STMT to GCC representation in the\n-   context of a SESE.\n-\n-   - NEXT_E is the edge where new generated code should be attached.\n-   - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n-\n-static edge\n-translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n-\t\t bb_pbb_htab_type *bb_pbb_mapping, int level, ivs_params_p ip)\n-{\n-  if (!stmt)\n-    return next_e;\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_root))\n-    ; /* Do nothing.  */\n-\n-  else if (CLAST_STMT_IS_A (stmt, stmt_user))\n-    next_e = translate_clast_user ((struct clast_user_stmt *) stmt,\n-\t\t\t\t   next_e, bb_pbb_mapping, ip);\n-\n-  else if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    next_e = translate_clast_for (context_loop, (struct clast_for *) stmt,\n-\t\t\t\t  next_e, bb_pbb_mapping, level, ip);\n-\n-  else if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    next_e = translate_clast_guard (context_loop, (struct clast_guard *) stmt,\n-\t\t\t\t    next_e, bb_pbb_mapping, level, ip);\n-\n-  else if (CLAST_STMT_IS_A (stmt, stmt_block))\n-    next_e = translate_clast (context_loop, ((struct clast_block *) stmt)->body,\n-\t\t\t      next_e, bb_pbb_mapping, level, ip);\n-\n-  else if (CLAST_STMT_IS_A (stmt, stmt_ass))\n-    next_e = translate_clast_assignment ((struct clast_assignment *) stmt,\n-\t\t\t\t\t next_e, level, ip);\n-  else\n-    gcc_unreachable ();\n-\n-  recompute_all_dominators ();\n-  graphite_verify ();\n-\n-  return translate_clast (context_loop, stmt->next, next_e, bb_pbb_mapping,\n-\t\t\t  level, ip);\n-}\n-\n-/* Add parameter and iterator names to the CloogUnionDomain.  */\n-\n-static CloogUnionDomain *\n-add_names_to_union_domain (scop_p scop, CloogUnionDomain *union_domain,\n-\t\t\t   int nb_scattering_dims,\n-\t\t\t   clast_index_htab_type *params_index)\n-{\n-  sese region = SCOP_REGION (scop);\n-  int i;\n-  int nb_iterators = scop_max_loop_depth (scop);\n-  int nb_parameters = SESE_PARAMS (region).length ();\n-  mpz_t bound_one, bound_two;\n-\n-  mpz_init (bound_one);\n-  mpz_init (bound_two);\n-\n-  for (i = 0; i < nb_parameters; i++)\n-    {\n-      tree param = SESE_PARAMS (region)[i];\n-      const char *name = get_name (param);\n-      int len;\n-      char *parameter;\n-\n-      if (!name)\n-\tname = \"T\";\n-\n-      len = strlen (name);\n-      len += 17;\n-      parameter = XNEWVEC (char, len + 1);\n-      snprintf (parameter, len, \"%s_%d\", name, SSA_NAME_VERSION (param));\n-      save_clast_name_index (params_index, parameter, i, i, bound_one,\n-\t\t\t     bound_two);\n-      union_domain = cloog_union_domain_set_name (union_domain, CLOOG_PARAM, i,\n-\t\t\t\t\t\t  parameter);\n-      compute_bounds_for_param (scop, i, bound_one, bound_two);\n-      free (parameter);\n-    }\n-\n-  mpz_clear (bound_one);\n-  mpz_clear (bound_two);\n-\n-  for (i = 0; i < nb_iterators; i++)\n-    {\n-      int len = 4 + 16;\n-      char *iterator;\n-      iterator = XNEWVEC (char, len);\n-      snprintf (iterator, len, \"git_%d\", i);\n-      union_domain = cloog_union_domain_set_name (union_domain, CLOOG_ITER, i,\n-\t\t\t\t\t\t  iterator);\n-      free (iterator);\n-    }\n-\n-  for (i = 0; i < nb_scattering_dims; i++)\n-    {\n-      int len = 5 + 16;\n-      char *scattering;\n-      scattering = XNEWVEC (char, len);\n-      snprintf (scattering, len, \"scat_%d\", i);\n-      union_domain = cloog_union_domain_set_name (union_domain, CLOOG_SCAT, i,\n-\t\t\t\t\t\t  scattering);\n-      free (scattering);\n-    }\n-\n-  return union_domain;\n-}\n-\n-/* Initialize a CLooG input file.  */\n-\n-static FILE *\n-init_cloog_input_file (int scop_number)\n-{\n-  FILE *graphite_out_file;\n-  int len = strlen (dump_base_name);\n-  char *dumpname = XNEWVEC (char, len + 25);\n-  char *s_scop_number = XNEWVEC (char, 15);\n-\n-  memcpy (dumpname, dump_base_name, len + 1);\n-  strip_off_ending (dumpname, len);\n-  sprintf (s_scop_number, \".%d\", scop_number);\n-  strcat (dumpname, s_scop_number);\n-  strcat (dumpname, \".cloog\");\n-  graphite_out_file = fopen (dumpname, \"w+b\");\n-\n-  if (graphite_out_file == 0)\n-    fatal_error (\"can%'t open %s for writing: %m\", dumpname);\n-\n-  free (dumpname);\n-\n-  return graphite_out_file;\n-}\n-\n-/* Extend the scattering to NEW_DIMS scattering dimensions.  */\n-\n-static\n-isl_map *extend_scattering (isl_map *scattering, int new_dims)\n-{\n-  int old_dims, i;\n-  isl_space *space;\n-  isl_basic_map *change_scattering;\n-  isl_map *change_scattering_map;\n-\n-  old_dims = isl_map_dim (scattering, isl_dim_out);\n-\n-  space = isl_space_alloc (isl_map_get_ctx (scattering), 0, old_dims, new_dims);\n-  change_scattering = isl_basic_map_universe (isl_space_copy (space));\n-\n-  for (i = 0; i < old_dims; i++)\n-    {\n-      isl_constraint *c;\n-      c = isl_equality_alloc\n-\t(isl_local_space_from_space (isl_space_copy (space)));\n-      isl_constraint_set_coefficient_si (c, isl_dim_in, i, 1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, i, -1);\n-      change_scattering = isl_basic_map_add_constraint (change_scattering, c);\n-    }\n-\n-  for (i = old_dims; i < new_dims; i++)\n-    {\n-      isl_constraint *c;\n-      c = isl_equality_alloc\n-\t(isl_local_space_from_space (isl_space_copy (space)));\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n-      change_scattering = isl_basic_map_add_constraint (change_scattering, c);\n-    }\n-\n-  change_scattering_map = isl_map_from_basic_map (change_scattering);\n-  change_scattering_map = isl_map_align_params (change_scattering_map, space);\n-  return isl_map_apply_range (scattering, change_scattering_map);\n-}\n-\n-/* Build cloog union domain for SCoP.  */\n-\n-static CloogUnionDomain *\n-build_cloog_union_domain (scop_p scop, int nb_scattering_dims)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  CloogUnionDomain *union_domain =\n-    cloog_union_domain_alloc (scop_nb_params (scop));\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    {\n-      CloogDomain *domain;\n-      CloogScattering *scattering;\n-\n-      /* Dead code elimination: when the domain of a PBB is empty,\n-\t don't generate code for the PBB.  */\n-      if (isl_set_is_empty (pbb->domain))\n-\tcontinue;\n-\n-      domain = cloog_domain_from_isl_set (isl_set_copy (pbb->domain));\n-      scattering = cloog_scattering_from_isl_map\n-\t(extend_scattering (isl_map_copy (pbb->transformed),\n-\t\t\t    nb_scattering_dims));\n-\n-      union_domain = cloog_union_domain_add_domain (union_domain, \"\", domain,\n-\t\t\t\t\t\t    scattering, pbb);\n-    }\n-\n-  return union_domain;\n-}\n-\n-/* Return the options that will be used in graphite_regenerate_ast_cloog.  */\n-\n-static CloogOptions *\n-set_cloog_options (void)\n-{\n-  CloogOptions *options = cloog_options_malloc (cloog_state);\n-\n-  /* Change cloog output language to C.  If we do use FORTRAN instead, cloog\n-     will stop e.g. with \"ERROR: unbounded loops not allowed in FORTRAN.\", if\n-     we pass an incomplete program to cloog.  */\n-  options->language = CLOOG_LANGUAGE_C;\n-\n-  /* Enable complex equality spreading: removes dummy statements\n-     (assignments) in the generated code which repeats the\n-     substitution equations for statements.  This is useless for\n-     graphite_regenerate_ast_cloog.  */\n-  options->esp = 1;\n-\n-  /* Silence CLooG to avoid failing tests due to debug output to stderr.  */\n-  options->quiet = 1;\n-\n-  /* Allow cloog to build strides with a stride width different to one.\n-     This example has stride = 4:\n-\n-     for (i = 0; i < 20; i += 4)\n-       A  */\n-  options->strides = 1;\n-\n-  /* We want the clast to provide the iteration domains of the executed loops.\n-     This allows us to derive minimal/maximal values for the induction\n-     variables.  */\n-  options->save_domains = 1;\n-\n-  /* Do not remove scalar dimensions.  CLooG by default removes scalar \n-     dimensions very early from the input schedule.  However, they are \n-     necessary to correctly derive from the saved domains \n-     (options->save_domains) the relationship between the generated loops \n-     and the schedule dimensions they are generated from.  */ \n-  options->noscalars = 1;\n-\n-  /* Disable optimizations and make cloog generate source code closer to the\n-     input.  This is useful for debugging,  but later we want the optimized\n-     code.\n-\n-     XXX: We can not disable optimizations, as loop blocking is not working\n-     without them.  */\n-  if (0)\n-    {\n-      options->f = -1;\n-      options->l = INT_MAX;\n-    }\n-\n-  return options;\n-}\n-\n-/* Prints STMT to STDERR.  */\n-\n-void\n-print_clast_stmt (FILE *file, struct clast_stmt *stmt)\n-{\n-  CloogOptions *options = set_cloog_options ();\n-\n-  clast_pprint (file, stmt, 0, options);\n-  cloog_options_free (options);\n-}\n-\n-/* Prints STMT to STDERR.  */\n-\n-DEBUG_FUNCTION void\n-debug_clast_stmt (struct clast_stmt *stmt)\n-{\n-  print_clast_stmt (stderr, stmt);\n-}\n-\n-/* Get the maximal number of scattering dimensions in the scop SCOP.  */\n-\n-static\n-int get_max_scattering_dimensions (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  int scattering_dims = 0;\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    {\n-      int pbb_scatt_dims = isl_map_dim (pbb->transformed, isl_dim_out);\n-      if (pbb_scatt_dims > scattering_dims)\n-\tscattering_dims = pbb_scatt_dims;\n-    }\n-\n-  return scattering_dims;\n-}\n-\n-static CloogInput *\n-generate_cloog_input (scop_p scop, clast_index_htab_type *params_index)\n-{\n-  CloogUnionDomain *union_domain;\n-  CloogInput *cloog_input;\n-  CloogDomain *context;\n-  int nb_scattering_dims = get_max_scattering_dimensions (scop);\n-\n-  union_domain = build_cloog_union_domain (scop, nb_scattering_dims);\n-  union_domain = add_names_to_union_domain (scop, union_domain,\n-\t\t\t\t\t    nb_scattering_dims,\n-\t\t\t\t\t    params_index);\n-  context = cloog_domain_from_isl_set (isl_set_copy (scop->context));\n-\n-  cloog_input = cloog_input_alloc (context, union_domain);\n-\n-  return cloog_input;\n-}\n-\n-/* Translate SCOP to a CLooG program and clast.  These two\n-   representations should be freed together: a clast cannot be used\n-   without a program.  */\n-\n-static struct clast_stmt *\n-scop_to_clast (scop_p scop, clast_index_htab_type *params_index)\n-{\n-  CloogInput *cloog_input;\n-  struct clast_stmt *clast;\n-  CloogOptions *options = set_cloog_options ();\n-\n-  cloog_input = generate_cloog_input (scop, params_index);\n-\n-  /* Dump a .cloog input file, if requested.  This feature is only\n-     enabled in the Graphite branch.  */\n-  if (0)\n-  {\n-    static size_t file_scop_number = 0;\n-    FILE *cloog_file = init_cloog_input_file (file_scop_number);\n-    cloog_input_dump_cloog (cloog_file, cloog_input, options);\n-  }\n-\n-  clast = cloog_clast_create_from_input (cloog_input, options);\n-\n-  cloog_options_free (options);\n-  return clast;\n-}\n-\n-/* Prints to FILE the code generated by CLooG for SCOP.  */\n-\n-void\n-print_generated_program (FILE *file, scop_p scop)\n-{\n-  CloogOptions *options = set_cloog_options ();\n-  clast_index_htab_type *params_index = new clast_index_htab_type (10);\n-  struct clast_stmt *clast;\n-\n-  clast = scop_to_clast (scop, params_index);\n-\n-  fprintf (file, \"       (clast: \\n\");\n-  clast_pprint (file, clast, 0, options);\n-  fprintf (file, \"       )\\n\");\n-\n-  cloog_options_free (options);\n-  cloog_clast_free (clast);\n-}\n-\n-/* Prints to STDERR the code generated by CLooG for SCOP.  */\n-\n-DEBUG_FUNCTION void\n-debug_generated_program (scop_p scop)\n-{\n-  print_generated_program (stderr, scop);\n-}\n-\n-/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n-   the given SCOP.  Return true if code generation succeeded.\n-   BB_PBB_MAPPING is a basic_block and it's related poly_bb_p mapping.\n-*/\n-\n-bool\n-graphite_regenerate_ast_cloog (scop_p scop, bb_pbb_htab_type *bb_pbb_mapping)\n-{\n-  auto_vec<tree, 10> newivs;\n-  loop_p context_loop;\n-  sese region = SCOP_REGION (scop);\n-  ifsese if_region = NULL;\n-  clast_index_htab_type *newivs_index, *params_index;\n-  struct clast_stmt *clast;\n-  struct ivs_params ip;\n-\n-  timevar_push (TV_GRAPHITE_CODE_GEN);\n-  graphite_regenerate_error = false;\n-\n-  params_index = new clast_index_htab_type (10);\n-\n-  clast = scop_to_clast (scop, params_index);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nCLAST generated by CLooG: \\n\");\n-      print_clast_stmt (dump_file, clast);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  recompute_all_dominators ();\n-  graphite_verify ();\n-\n-  if_region = move_sese_in_condition (region);\n-  sese_insert_phis_for_liveouts (region,\n-\t\t\t\t if_region->region->exit->src,\n-\t\t\t\t if_region->false_region->exit,\n-\t\t\t\t if_region->true_region->exit);\n-  recompute_all_dominators ();\n-  graphite_verify ();\n-\n-  context_loop = SESE_ENTRY (region)->src->loop_father;\n-  newivs_index= new clast_index_htab_type (10);\n-\n-  ip.newivs = &newivs;\n-  ip.newivs_index = newivs_index;\n-  ip.params = SESE_PARAMS (region);\n-  ip.params_index = params_index;\n-  ip.region = region;\n-\n-  translate_clast (context_loop, clast, if_region->true_region->entry,\n-\t\t   bb_pbb_mapping, 0, &ip);\n-  graphite_verify ();\n-  scev_reset ();\n-  recompute_all_dominators ();\n-  graphite_verify ();\n-\n-  if (graphite_regenerate_error)\n-    set_ifsese_condition (if_region, integer_zero_node);\n-\n-  free (if_region->true_region);\n-  free (if_region->region);\n-  free (if_region);\n-\n-  delete newivs_index;\n-  newivs_index = NULL;\n-  delete params_index;\n-  params_index = NULL;\n-  cloog_clast_free (clast);\n-  timevar_pop (TV_GRAPHITE_CODE_GEN);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      loop_p loop;\n-      int num_no_dependency = 0;\n-\n-      FOR_EACH_LOOP (loop, 0)\n-\tif (loop->can_be_parallel)\n-\t  num_no_dependency++;\n-\n-      fprintf (dump_file, \"\\n%d loops carried no dependency.\\n\",\n-\t       num_no_dependency);\n-    }\n-\n-  return !graphite_regenerate_error;\n-}\n-#endif"}, {"sha": "ff6909923feed1c5f328a89676605d101babc342", "filename": "gcc/graphite-clast-to-gimple.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fe4a92d723046114cefb837c326b24829ec73/gcc%2Fgraphite-clast-to-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fe4a92d723046114cefb837c326b24829ec73/gcc%2Fgraphite-clast-to-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.h?ref=642fe4a92d723046114cefb837c326b24829ec73", "patch": "@@ -1,39 +0,0 @@\n-/* Translation of CLAST (CLooG AST) to Gimple.\n-   Copyright (C) 2009-2014 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_GRAPHITE_CLAST_TO_GIMPLE_H\n-#define GCC_GRAPHITE_CLAST_TO_GIMPLE_H\n-\n-#include \"graphite-htab.h\"\n-\n-extern CloogState *cloog_state;\n-\n-/* Data structure for CLooG program representation.  */\n-\n-struct cloog_prog_clast {\n-  CloogProgram *prog;\n-  struct clast_stmt *stmt;\n-};\n-\n-extern bool graphite_regenerate_ast_cloog (scop_p, bb_pbb_htab_type *);\n-extern void debug_clast_stmt (struct clast_stmt *);\n-extern void print_clast_stmt (FILE *, struct clast_stmt *);\n-\n-#endif"}, {"sha": "b79c69216121ac96ae658309d6e431711515a184", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -27,10 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/union_map.h>\n #include <isl/flow.h>\n #include <isl/constraint.h>\n-#ifdef HAVE_cloog\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#endif\n #endif\n \n #include \"system.h\"\n@@ -64,7 +60,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef HAVE_isl\n #include \"graphite-poly.h\"\n-#include \"graphite-htab.h\"\n \n isl_union_map *\n scop_get_dependences (scop_p scop)\n@@ -643,61 +638,4 @@ graphite_legal_transform (scop_p scop)\n   return res;\n }\n \n-#ifdef HAVE_cloog\n-\n-/* Return true when the loop at DEPTH carries dependences.  BODY is\n-   the body of the loop.  */\n-\n-static bool\n-loop_level_carries_dependences (scop_p scop, vec<poly_bb_p> body,\n-\t\t\t\tint depth)\n-{\n-  isl_union_map *transform = scop_get_transformed_schedule (scop, body);\n-  isl_union_map *must_raw, *may_raw;\n-  isl_union_map *must_war, *may_war;\n-  isl_union_map *must_waw, *may_waw;\n-  int res;\n-\n-  compute_deps (scop, body,\n-\t\t&must_raw, &may_raw, NULL, NULL,\n-\t\t&must_war, &may_war, NULL, NULL,\n-\t\t&must_waw, &may_waw, NULL, NULL);\n-\n-  res = (carries_deps (transform, must_raw, depth)\n-\t || carries_deps (transform, may_raw, depth)\n-\t || carries_deps (transform, must_war, depth)\n-\t || carries_deps (transform, may_war, depth)\n-\t || carries_deps (transform, must_waw, depth)\n-\t || carries_deps (transform, may_waw, depth));\n-\n-  isl_union_map_free (transform);\n-  isl_union_map_free (must_raw);\n-  isl_union_map_free (may_raw);\n-  isl_union_map_free (must_war);\n-  isl_union_map_free (may_war);\n-  isl_union_map_free (must_waw);\n-  isl_union_map_free (may_waw);\n-  return res;\n-}\n-\n-/* Returns true when the loop L at level DEPTH is parallel.\n-   BB_PBB_MAPPING is a map between a basic_block and its related\n-   poly_bb_p.  */\n-\n-bool\n-loop_is_parallel_p (loop_p loop, bb_pbb_htab_type *bb_pbb_mapping, int depth)\n-{\n-  bool dependences;\n-  scop_p scop;\n-\n-  timevar_push (TV_GRAPHITE_DATA_DEPS);\n-  auto_vec<poly_bb_p, 3> body;\n-  scop = get_loop_body_pbbs (loop, bb_pbb_mapping, &body);\n-  dependences = loop_level_carries_dependences (scop, body, depth);\n-  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n-\n-  return !dependences;\n-}\n-\n-#endif\n #endif"}, {"sha": "b1fd81e301308641e718d82d75b5d60bc88a0a16", "filename": "gcc/graphite-htab.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/642fe4a92d723046114cefb837c326b24829ec73/gcc%2Fgraphite-htab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/642fe4a92d723046114cefb837c326b24829ec73/gcc%2Fgraphite-htab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-htab.h?ref=642fe4a92d723046114cefb837c326b24829ec73", "patch": "@@ -1,56 +0,0 @@\n-/* Translation of CLAST (CLooG AST) to Gimple.\n-   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_GRAPHITE_HTAB_H\n-#define GCC_GRAPHITE_HTAB_H\n-\n-#include \"hash-map.h\"\n-\n-/* Hashtable helpers.  */\n-\n-struct bb_pbb_hasher : default_hashmap_traits\n-{\n-  static inline hashval_t hash (const basic_block);\n-  static inline bool equal_keys (const basic_block, const basic_block);\n-};\n-\n-/* Hash function.  */\n-\n-inline hashval_t\n-bb_pbb_hasher::hash (const basic_block bb)\n-{\n-  return (hashval_t)(bb->index);\n-}\n-\n-/* Compare data base element PB1 and PB2.  */\n-\n-inline bool\n-bb_pbb_hasher::equal_keys (const basic_block a, const basic_block b)\n-{\n-  return (a->index == b->index);\n-}\n-\n-typedef hash_map<basic_block, poly_bb_p, bb_pbb_hasher> bb_pbb_htab_type;\n-\n-poly_bb_p find_pbb_via_hash (bb_pbb_htab_type *, basic_block);\n-bool loop_is_parallel_p (loop_p, bb_pbb_htab_type *, int);\n-scop_p get_loop_body_pbbs (loop_p, bb_pbb_htab_type *, vec<poly_bb_p> *);\n-\n-#endif"}, {"sha": "8ab0cb57c03f8455f6d536ace54b2185dce20f95", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -36,10 +36,6 @@ extern \"C\" {\n #if defined(__cplusplus)\n }\n #endif\n-#ifdef HAVE_cloog\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#endif\n #endif\n \n #include \"system.h\"\n@@ -858,79 +854,6 @@ print_scop (FILE *file, scop_p scop, int verbosity)\n   fprintf (file, \"#)\\n\");\n }\n \n-/* Print to FILE the input file that CLooG would expect as input, at\n-   some VERBOSITY level.  */\n-\n-void\n-print_cloog (FILE *file, scop_p scop, int verbosity)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  fprintf (file, \"# SCoP (generated by GCC/Graphite\\n\");\n-  if (verbosity > 0)\n-    fprintf (file, \"# CLooG output language\\n\");\n-  fprintf (file, \"c\\n\");\n-\n-  print_scop_context (file, scop, verbosity);\n-  print_scop_params (file, scop, verbosity);\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"# Number of statements\\n\");\n-\n-  fprintf (file, \"%d\\n\", SCOP_BBS (scop).length ());\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    {\n-      if (verbosity > 1)\n-\tfprintf (file, \"# pbb_%d (\\n\", pbb_index (pbb));\n-\n-      print_pbb_domain (file, pbb, verbosity);\n-      fprintf (file, \"0 0 0\");\n-\n-      if (verbosity > 0)\n-\tfprintf (file, \"# For future CLooG options.\\n\");\n-      else\n-\tfprintf (file, \"\\n\");\n-\n-      if (verbosity > 1)\n-\tfprintf (file, \"#)\\n\");\n-    }\n-\n-  fprintf (file, \"0\");\n-  if (verbosity > 0)\n-    fprintf (file, \"# Don't set the iterator names.\\n\");\n-  else\n-    fprintf (file, \"\\n\");\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"# Number of scattering functions\\n\");\n-\n-  fprintf (file, \"%d\\n\", SCOP_BBS (scop).length ());\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    {\n-      if (!(pbb->transformed || pbb->schedule))\n-\tcontinue;\n-\n-      if (verbosity > 1)\n-\tfprintf (file, \"# pbb_%d (\\n\", pbb_index (pbb));\n-\n-      print_scattering_function_1 (file, pbb, verbosity);\n-\n-      if (verbosity > 1)\n-\tfprintf (file, \"#)\\n\");\n-    }\n-\n-  fprintf (file, \"0\");\n-  if (verbosity > 0)\n-    fprintf (file, \"# Don't set the scattering dimension names.\\n\");\n-  else\n-    fprintf (file, \"\\n\");\n-\n-  fprintf (file, \"#)\\n\");\n-}\n-\n /* Print to STDERR the domain of PBB, at some VERBOSITY level.  */\n \n DEBUG_FUNCTION void\n@@ -964,15 +887,6 @@ debug_scop (scop_p scop, int verbosity)\n   print_scop (stderr, scop, verbosity);\n }\n \n-/* Print to STDERR the SCOP under CLooG format, at some VERBOSITY\n-   level.  */\n-\n-DEBUG_FUNCTION void\n-debug_cloog (scop_p scop, int verbosity)\n-{\n-  print_cloog (stderr, scop, verbosity);\n-}\n-\n /* Print to STDERR the parameters of SCOP, at some VERBOSITY\n    level.  */\n \n@@ -1255,24 +1169,6 @@ dot_lst (lst_p lst)\n #endif\n }\n \n-/* Computes a checksum for the code generated by CLooG for SCOP.  */\n-\n-DEBUG_FUNCTION void\n-cloog_checksum (scop_p scop ATTRIBUTE_UNUSED)\n-{\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers because it calls \"system\".  */\n-#if 0\n-  FILE *stream = fopen (\"/tmp/scop.cloog\", \"w\");\n-  gcc_assert (stream);\n-  print_cloog (stream, scop, 0);\n-  fclose (stream);\n-\n-  fputs (\"\\n\", stdout);\n-  system (\"cloog -compilable 1 /tmp/scop.cloog > /tmp/scop.c ; gcc -O0 -g /tmp/scop.c -lm -o /tmp/scop; /tmp/scop | md5sum \");\n-#endif\n-}\n-\n /* Reverse the loop around PBB at level DEPTH.  */\n \n isl_map *"}, {"sha": "9c7639a901db63089afdb51f667c56b140b129a4", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -377,14 +377,12 @@ extern void print_pbb_domain (FILE *, poly_bb_p, int);\n extern void print_pbb (FILE *, poly_bb_p, int);\n extern void print_scop_context (FILE *, scop_p, int);\n extern void print_scop (FILE *, scop_p, int);\n-extern void print_cloog (FILE *, scop_p, int);\n extern void debug_pbb_domain (poly_bb_p, int);\n extern void debug_pbb (poly_bb_p, int);\n extern void print_pdrs (FILE *, poly_bb_p, int);\n extern void debug_pdrs (poly_bb_p, int);\n extern void debug_scop_context (scop_p, int);\n extern void debug_scop (scop_p, int);\n-extern void debug_cloog (scop_p, int);\n extern void print_scop_params (FILE *, scop_p, int);\n extern void debug_scop_params (scop_p, int);\n extern void print_iteration_domain (FILE *, poly_bb_p, int);\n@@ -1402,7 +1400,6 @@ extern int scop_max_loop_depth (scop_p);\n extern int unify_scattering_dimensions (scop_p);\n extern bool apply_poly_transforms (scop_p);\n extern bool graphite_legal_transform (scop_p);\n-extern void cloog_checksum (scop_p);\n \n /* Set the region of SCOP to REGION.  */\n "}, {"sha": "a22837a6027dae33a9470ec483b302c05716004d", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -25,10 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/set.h>\n #include <isl/map.h>\n #include <isl/union_map.h>\n-#ifdef HAVE_cloog\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#endif\n #endif\n \n #include \"system.h\""}, {"sha": "755b0433c8eb72a9b8e21c9dfb4b77f8e05d4c0c", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -38,11 +38,6 @@ extern \"C\" {\n #if defined(__cplusplus)\n }\n #endif\n-#ifdef HAVE_cloog\n-#include <cloog/cloog.h>\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#endif\n #endif\n \n #include \"system.h\""}, {"sha": "a8c5a5bec11a462002e0399e80e355a3c058d6d9", "filename": "gcc/graphite.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -39,11 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/map.h>\n #include <isl/options.h>\n #include <isl/union_map.h>\n-#ifdef HAVE_cloog\n-#include <cloog/cloog.h>\n-#include <cloog/isl/domain.h>\n-#include <cloog/isl/cloog.h>\n-#endif\n #endif\n \n #include \"system.h\"\n@@ -87,13 +82,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-scop-detection.h\"\n #include \"graphite-isl-ast-to-gimple.h\"\n #include \"graphite-sese-to-poly.h\"\n-#include \"graphite-htab.h\"\n-\n-#ifdef HAVE_cloog\n-#include \"graphite-clast-to-gimple.h\"\n-\n-CloogState *cloog_state;\n-#endif\n \n /* Print global statistics to FILE.  */\n \n@@ -244,10 +232,6 @@ graphite_initialize (isl_ctx *ctx)\n   recompute_all_dominators ();\n   initialize_original_copy_tables ();\n \n-#ifdef HAVE_cloog\n-  cloog_state = cloog_isl_state_malloc (ctx);\n-#endif\n-\n   if (dump_file && dump_flags)\n     dump_function_to_file (current_function_decl, dump_file, dump_flags);\n \n@@ -269,9 +253,6 @@ graphite_finalize (bool need_cfg_cleanup_p)\n       tree_estimate_probability ();\n     }\n \n-#ifdef HAVE_cloog\n-  cloog_state_free (cloog_state);\n-#endif\n   free_original_copy_tables ();\n \n   if (dump_file && dump_flags)\n@@ -311,37 +292,16 @@ graphite_transform_loops (void)\n       print_global_statistics (dump_file);\n     }\n \n-  bb_pbb_htab_type bb_pbb_mapping (10);\n-\n-#ifndef HAVE_cloog\n-  if(flag_graphite_code_gen == FGRAPHITE_CODE_GEN_CLOOG)\n-    {\n-      flag_graphite_code_gen = FGRAPHITE_CODE_GEN_ISL;\n-      printf (\"The CLooG code generator cannot be used (CLooG is not \"\n-\t      \"available). The ISL code generator was chosen.\\n\");\n-    }\n-#endif\n-\n   FOR_EACH_VEC_ELT (scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       {\n \tscop->ctx = ctx;\n \tbuild_poly_scop (scop);\n \n-#ifdef HAVE_cloog\n-\tif (POLY_SCOP_P (scop)\n-\t    && apply_poly_transforms (scop)\n-\t    && (((flag_graphite_code_gen == FGRAPHITE_CODE_GEN_ISL)\n-\t    && graphite_regenerate_ast_isl (scop))\n-\t    || ((flag_graphite_code_gen == FGRAPHITE_CODE_GEN_CLOOG)\n-\t    && graphite_regenerate_ast_cloog (scop, &bb_pbb_mapping))))\n-\t  need_cfg_cleanup_p = true;\n-#else\n \tif (POLY_SCOP_P (scop)\n \t    && apply_poly_transforms (scop)\n \t    && graphite_regenerate_ast_isl (scop))\n \t  need_cfg_cleanup_p = true;\n-#endif\n \n       }\n "}, {"sha": "feb5b60b532e43279d2daf78503cdd09ec45deb2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,3 +1,19 @@\n+2014-11-10 Roman Gareev  <gareevroman@gmail.com>\n+\n+\t* gcc.dg/graphite/isl-ast-gen-blocks-1.c: Remove using of\n+\tfgraphite-code-generator flag.\n+\t* gcc.dg/graphite/isl-ast-gen-blocks-2.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-blocks-3.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-blocks-4.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-user-1.c: Likewise.\n+\t* gcc.dg/graphite/isl-codegen-loop-dumping.c: Likewise.\n+\t* gcc.dg/graphite/pr35356-2.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-single-loop-1.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-single-loop-2.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-single-loop-3.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-if-1.c: Likewise.\n+\t* gcc.dg/graphite/isl-ast-gen-if-2.c: Likewise.\n+\n 2014-11-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.c-torture/compile/pr35468.c: Revert the last change."}, {"sha": "6146b18fc03841c5cfd1fd40eda77a346ec8cfe7", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-blocks-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-1.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n int n = 50;\n static int __attribute__((noinline))"}, {"sha": "42ff30a5c58f527b7657db8f10715d080d6ee58a", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-blocks-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-2.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n int k = 50;\n static int __attribute__((noinline))"}, {"sha": "771d337bdde350559bd34f55051dffadd92d05cf", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-blocks-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-3.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n /* We use a global variable 'k' to avoid ipa-cp. */\n int k = 50;"}, {"sha": "803eea732bfd0e2fd65545e61511238eab7226a5", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-blocks-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-blocks-4.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n static int __attribute__((noinline))\n foo (int k, int n1, int n2, int n3)"}, {"sha": "07285a92078914db5d5f5b73799992310938975d", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-if-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-if-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-if-1.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n int st = 1;\n static void __attribute__((noinline))"}, {"sha": "90111e70a1a3251f0c5f81b75cce00b6951991aa", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-if-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-if-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-if-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-if-2.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n /* This test case tests reduction, where the pbbs are duplicated.  */\n "}, {"sha": "754452be00cafd44074be86ee76045dab172ffab", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-single-loop-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-1.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n int\n foo ()"}, {"sha": "04c7dbaf01765a8ea5261325643a1f7bb176c220", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-single-loop-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-2.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n int n = 50;\n \n void"}, {"sha": "204acd3955b47cc645c4e3cc82e3e66672126030", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-single-loop-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-single-loop-3.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n int n = 50;\n \n void"}, {"sha": "760c1a2f2838391f94682f2c4e9731d119b7b106", "filename": "gcc/testsuite/gcc.dg/graphite/isl-ast-gen-user-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-user-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-user-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-ast-gen-user-1.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n \n #include <stdio.h>\n #include <stdlib.h>"}, {"sha": "6e3499e892ece569a9db954ba7e26a4941e419cb", "filename": "gcc/testsuite/gcc.dg/graphite/isl-codegen-loop-dumping.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-codegen-loop-dumping.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-codegen-loop-dumping.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fisl-codegen-loop-dumping.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-graphite-all -fgraphite-identity -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fdump-tree-graphite-all\" } */\n \n int\n main (int n, int *a)"}, {"sha": "1ac0dc1fc88a710f44a7df360234a897247e021b", "filename": "gcc/testsuite/gcc.dg/graphite/pr35356-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12749230b428fed44acd610d0d989d25d958130/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-2.c?ref=b12749230b428fed44acd610d0d989d25d958130", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fgraphite-identity -fdump-tree-graphite-all  -fgraphite-code-generator=isl\" } */\n+/* { dg-options \"-O2 -fgraphite-identity -fdump-tree-graphite-all\" } */\n \n int a[100];\n "}]}