{"sha": "486e432615e3a3e526044f3002db03a0ddbc04b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg2ZTQzMjYxNWUzYTNlNTI2MDQ0ZjMwMDJkYjAzYTBkZGJjMDRiNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-30T02:13:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-30T02:13:46Z"}, "message": "re PR middle-end/19687 (ICE with union initializer)\n\n        PR middle-end/19687\n        * expr.c (categorize_ctor_elements_1): Check for CONSTRUCTOR of a\n        union being empty.\n\nFrom-SVN: r94421", "tree": {"sha": "a84e86167986519b9fa3f1c7c5850749cdf43169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a84e86167986519b9fa3f1c7c5850749cdf43169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/486e432615e3a3e526044f3002db03a0ddbc04b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486e432615e3a3e526044f3002db03a0ddbc04b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/486e432615e3a3e526044f3002db03a0ddbc04b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486e432615e3a3e526044f3002db03a0ddbc04b5/comments", "author": null, "committer": null, "parents": [{"sha": "eb2ab5113844abdf4d1de1f3cbee4ce3a7690efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb2ab5113844abdf4d1de1f3cbee4ce3a7690efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb2ab5113844abdf4d1de1f3cbee4ce3a7690efb"}], "stats": {"total": 66, "additions": 47, "deletions": 19}, "files": [{"sha": "f3bcde399f8ad23f1d75056ea67a03cd80371c5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486e432615e3a3e526044f3002db03a0ddbc04b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486e432615e3a3e526044f3002db03a0ddbc04b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=486e432615e3a3e526044f3002db03a0ddbc04b5", "patch": "@@ -1,3 +1,9 @@\n+2005-01-29  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/19687\n+\t* expr.c (categorize_ctor_elements_1): Check for CONSTRUCTOR of a\n+\tunion being empty.\n+\n 2005-01-29  Richard Henderson  <rth@redhat.com>\n \n \t* combine.c (make_field_assignment): Fix argument order"}, {"sha": "29acbba5c5bb3bcf6f3e3ea2b70b068fb5f015e2", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486e432615e3a3e526044f3002db03a0ddbc04b5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486e432615e3a3e526044f3002db03a0ddbc04b5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=486e432615e3a3e526044f3002db03a0ddbc04b5", "patch": "@@ -4364,29 +4364,33 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t  || TREE_CODE (TREE_TYPE (ctor)) == QUAL_UNION_TYPE))\n     {\n       tree init_sub_type;\n+      bool clear_this = true;\n \n-      /* We don't expect more than one element of the union to be\n-\t initialized.  Not sure what we should do otherwise... */\n       list = CONSTRUCTOR_ELTS (ctor);\n-      gcc_assert (TREE_CHAIN (list) == NULL);\n-\n-      init_sub_type = TREE_TYPE (TREE_VALUE (list));\n-\n-      /* ??? We could look at each element of the union, and find the\n-\t largest element.  Which would avoid comparing the size of the\n-\t initialized element against any tail padding in the union.\n-\t Doesn't seem worth the effort...  */\n-      if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (ctor)), \n-\t\t\t    TYPE_SIZE (init_sub_type)) == 1)\n+      if (list)\n \t{\n-\t  /* And now we have to find out if the element itself is fully\n-\t     constructed.  E.g. for union { struct { int a, b; } s; } u\n-\t     = { .s = { .a = 1 } }.  */\n-\t  if (elt_count != count_type_elements (init_sub_type))\n-\t    *p_must_clear = true;\n+\t  /* We don't expect more than one element of the union to be\n+\t     initialized.  Not sure what we should do otherwise... */\n+          gcc_assert (TREE_CHAIN (list) == NULL);\n+\n+          init_sub_type = TREE_TYPE (TREE_VALUE (list));\n+\n+\t  /* ??? We could look at each element of the union, and find the\n+\t     largest element.  Which would avoid comparing the size of the\n+\t     initialized element against any tail padding in the union.\n+\t     Doesn't seem worth the effort...  */\n+\t  if (simple_cst_equal (TYPE_SIZE (TREE_TYPE (ctor)), \n+\t\t\t\tTYPE_SIZE (init_sub_type)) == 1)\n+\t    {\n+\t      /* And now we have to find out if the element itself is fully\n+\t\t constructed.  E.g. for union { struct { int a, b; } s; } u\n+\t\t = { .s = { .a = 1 } }.  */\n+\t      if (elt_count == count_type_elements (init_sub_type))\n+\t\tclear_this = false;\n+\t    }\n \t}\n-      else\n-\t*p_must_clear = true;\n+\n+      *p_must_clear = clear_this;\n     }\n \n   *p_nz_elts += nz_elts;"}, {"sha": "c300ab48cf0571167d353952bb2a88845ce3fd65", "filename": "gcc/testsuite/gcc.c-torture/execute/pr19687.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/486e432615e3a3e526044f3002db03a0ddbc04b5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19687.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/486e432615e3a3e526044f3002db03a0ddbc04b5/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19687.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19687.c?ref=486e432615e3a3e526044f3002db03a0ddbc04b5", "patch": "@@ -0,0 +1,18 @@\n+extern void abort (void);\n+\n+union U\n+{\n+  int i, j[4];\n+};\n+\n+int main ()\n+{\n+  union U t = {};\n+  int i;\n+\n+  for (i = 0; i < 4; ++i)\n+    if (t.j[i] != 0)\n+      abort ();\n+\n+  return 0;\n+}"}]}