{"sha": "1f83528e3e0c750c5c62f7148e4bfc3169084208", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY4MzUyOGUzZTBjNzUwYzVjNjJmNzE0OGU0YmZjMzE2OTA4NDIwOA==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2015-01-28T17:03:44Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2015-01-28T17:03:44Z"}, "message": "nvptx mkoffload.\n\n\tgcc/\n\t* config/nvptx/mkoffload.c: New file.\n\t* config/nvptx/t-nvptx: Add build rules for it.\n\t* config.gcc <nvptx-*> [$enable_as_accelerator = yes]\n\t(extra_programs): Add mkoffload.\n\t* config/nvptx/nvptx.c (nvptx_record_offload_symbol): New\n\tfunction.\n\t(TARGET_RECORD_OFFLOAD_SYMBOL): Define macro to use it.\n\nCo-Authored-By: Bernd Schmidt <bernds@codesourcery.com>\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\n\nFrom-SVN: r220209", "tree": {"sha": "6ad10e63b88402af4391efa1c162aef1fc8ebf4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ad10e63b88402af4391efa1c162aef1fc8ebf4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f83528e3e0c750c5c62f7148e4bfc3169084208", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f83528e3e0c750c5c62f7148e4bfc3169084208", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f83528e3e0c750c5c62f7148e4bfc3169084208", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f83528e3e0c750c5c62f7148e4bfc3169084208/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26586d771d2e0c7329c656c8f9a39c8151b53d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26586d771d2e0c7329c656c8f9a39c8151b53d44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26586d771d2e0c7329c656c8f9a39c8151b53d44"}], "stats": {"total": 946, "additions": 944, "deletions": 2}, "files": [{"sha": "6b957bf608680b107f2cdec63c48e630c8cdb549", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f83528e3e0c750c5c62f7148e4bfc3169084208", "patch": "@@ -1,3 +1,15 @@\n+2015-01-28  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/nvptx/mkoffload.c: New file.\n+\t* config/nvptx/t-nvptx: Add build rules for it.\n+\t* config.gcc <nvptx-*> [$enable_as_accelerator = yes]\n+\t(extra_programs): Add mkoffload.\n+\t* config/nvptx/nvptx.c (nvptx_record_offload_symbol): New\n+\tfunction.\n+\t(TARGET_RECORD_OFFLOAD_SYMBOL): Define macro to use it.\n+\n 2015-01-28  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \tPR middle-end/64809"}, {"sha": "abd915e715914330181e60feb7d89915f35b17a4", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=1f83528e3e0c750c5c62f7148e4bfc3169084208", "patch": "@@ -2233,7 +2233,10 @@ nios2-*-*)\n nvptx-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\"\n \ttmake_file=\"nvptx/t-nvptx\"\n-\ttm_file=\"${tm_file} nvptx/offload.h\"\n+\tif test x$enable_as_accelerator = xyes; then\n+\t\textra_programs=\"${extra_programs} mkoffload\\$(exeext)\"\n+\t\ttm_file=\"${tm_file} nvptx/offload.h\"\n+\tfi\n \t;;\n pdp11-*-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\""}, {"sha": "9138bdd8dd893dcdd979464221165da6755a579e", "filename": "gcc/config/nvptx/mkoffload.c", "status": "added", "additions": 907, "deletions": 0, "changes": 907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c?ref=1f83528e3e0c750c5c62f7148e4bfc3169084208", "patch": "@@ -0,0 +1,907 @@\n+/* Offload image generation tool for PTX.\n+\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+   Contributed by Nathan Sidwell <nathan@codesourcery.com> and\n+   Bernd Schmidt <bernds@codesourcery.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Munges PTX assembly into a C source file defining the PTX code as a\n+   string.\n+\n+   This is not a complete assembler.  We presume the source is well\n+   formed from the compiler and can die horribly if it is not.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"intl.h\"\n+#include <libgen.h>\n+#include \"obstack.h\"\n+#include \"diagnostic-core.h\"\n+#include \"collect-utils.h\"\n+\n+const char tool_name[] = \"nvptx mkoffload\";\n+\n+#define COMMENT_PREFIX \"#\"\n+\n+typedef enum Kind\n+{\n+  /* 0-ff used for single char tokens */\n+  K_symbol = 0x100, /* a symbol */\n+  K_label,  /* a label defn (i.e. symbol:) */\n+  K_ident,  /* other ident */\n+  K_dotted, /* dotted identifier */\n+  K_number,\n+  K_string,\n+  K_comment\n+} Kind;\n+\n+typedef struct Token\n+{\n+  unsigned short kind : 12;\n+  unsigned short space : 1; /* preceded by space */\n+  unsigned short end : 1;   /* succeeded by end of line */\n+  /* Length of token */\n+  unsigned short len;\n+\n+  /* Token itself */\n+  char const *ptr;\n+} Token;\n+\n+/* statement info */\n+typedef enum Vis\n+{\n+  V_dot = 0,  /* random pseudo */\n+  V_var = 1,  /* var decl/defn */\n+  V_func = 2, /* func decl/defn */\n+  V_insn = 3, /* random insn */\n+  V_label = 4, /* label defn */\n+  V_comment = 5,\n+  V_pred = 6,  /* predicate */\n+  V_mask = 0x7,\n+  V_global = 0x08, /* globalize */\n+  V_weak = 0x10,   /* weakly globalize */\n+  V_no_eol = 0x20, /* no end of line */\n+  V_prefix_comment = 0x40 /* prefixed comment */\n+} Vis;\n+\n+typedef struct Stmt\n+{\n+  struct Stmt *next;\n+  Token *tokens;\n+  unsigned char vis;\n+  unsigned len : 12;\n+  unsigned sym : 12;\n+} Stmt;\n+\n+struct id_map\n+{\n+  id_map *next;\n+  char *ptx_name;\n+};\n+\n+static const char *read_file (FILE *);\n+static Token *tokenize (const char *);\n+\n+static void write_token (FILE *, const Token *);\n+static void write_tokens (FILE *, const Token *, unsigned, int);\n+\n+static Stmt *alloc_stmt (unsigned, Token *, Token *, const Token *);\n+#define alloc_comment(S,E) alloc_stmt (V_comment, S, E, 0)\n+#define append_stmt(V, S) ((S)->next = *(V), *(V) = (S))\n+static Stmt *rev_stmts (Stmt *);\n+static void write_stmt (FILE *, const Stmt *);\n+static void write_stmts (FILE *, const Stmt *);\n+\n+static Token *parse_insn (Token *);\n+static Token *parse_list_nosemi (Token *);\n+static Token *parse_init (Token *);\n+static Token *parse_file (Token *);\n+\n+static Stmt *decls;\n+static Stmt *vars;\n+static Stmt *fns;\n+\n+static id_map *func_ids, **funcs_tail = &func_ids;\n+static id_map *var_ids, **vars_tail = &var_ids;\n+\n+/* Files to unlink.  */\n+static const char *ptx_name;\n+static const char *ptx_cfile_name;\n+\n+/* Delete tempfiles.  */\n+\n+/* Unlink a temporary file unless requested otherwise.  */\n+\n+void\n+maybe_unlink (const char *file)\n+{\n+  if (! debug)\n+    {\n+      if (unlink_if_ordinary (file)\n+\t  && errno != ENOENT)\n+\tfatal_error (\"deleting file %s: %m\", file);\n+    }\n+  else\n+    fprintf (stderr, \"[Leaving %s]\\n\", file);\n+}\n+\n+void\n+tool_cleanup (bool)\n+{\n+}\n+\n+/* Add or change the value of an environment variable, outputting the\n+   change to standard error if in verbose mode.  */\n+static void\n+xputenv (const char *string)\n+{\n+  if (verbose)\n+    fprintf (stderr, \"%s\\n\", string);\n+  putenv (CONST_CAST (char *, string));\n+}\n+\n+\n+static void\n+record_id (const char *p1, id_map ***where)\n+{\n+  const char *end = strchr (p1, '\\n');\n+  if (!end)\n+    fatal_error (\"malformed ptx file\");\n+\n+  id_map *v = XNEW (id_map);\n+  size_t len = end - p1;\n+  v->ptx_name = XNEWVEC (char, len + 1);\n+  memcpy (v->ptx_name, p1, len);\n+  v->ptx_name[len] = '\\0';\n+  v->next = NULL;\n+  id_map **tail = *where;\n+  *tail = v;\n+  *where = &v->next;\n+}\n+\n+/* Read the whole input file.  It will be NUL terminated (but\n+   remember, there could be a NUL in the file itself.  */\n+\n+static const char *\n+read_file (FILE *stream)\n+{\n+  size_t alloc = 16384;\n+  size_t base = 0;\n+  char *buffer;\n+\n+  if (!fseek (stream, 0, SEEK_END))\n+    {\n+      /* Get the file size.  */\n+      long s = ftell (stream);\n+      if (s >= 0)\n+\talloc = s + 100;\n+      fseek (stream, 0, SEEK_SET);\n+    }\n+  buffer = XNEWVEC (char, alloc);\n+\n+  for (;;)\n+    {\n+      size_t n = fread (buffer + base, 1, alloc - base - 1, stream);\n+\n+      if (!n)\n+\tbreak;\n+      base += n;\n+      if (base + 1 == alloc)\n+\t{\n+\t  alloc *= 2;\n+\t  buffer = XRESIZEVEC (char, buffer, alloc);\n+\t}\n+    }\n+  buffer[base] = 0;\n+  return buffer;\n+}\n+\n+/* Read a token, advancing ptr.\n+   If we read a comment, append it to the comments block. */\n+\n+static Token *\n+tokenize (const char *ptr)\n+{\n+  unsigned alloc = 1000;\n+  unsigned num = 0;\n+  Token *toks = XNEWVEC (Token, alloc);\n+  int in_comment = 0;\n+  int not_comment = 0;\n+\n+  for (;; num++)\n+    {\n+      const char *base;\n+      unsigned kind;\n+      int ws = 0;\n+      int eol = 0;\n+\n+    again:\n+      base = ptr;\n+      if (in_comment)\n+\tgoto block_comment;\n+      switch (kind = *ptr++)\n+\t{\n+\tdefault:\n+\t  break;\n+\n+\tcase '\\n':\n+\t  eol = 1;\n+\t  /* Fall through */\n+\tcase ' ':\n+\tcase '\\t':\n+\tcase '\\r':\n+\tcase '\\v':\n+\t  /* White space */\n+\t  ws = not_comment;\n+\t  goto again;\n+\n+\tcase '/':\n+\t  {\n+\t    if (*ptr == '/')\n+\t      {\n+\t\t/* line comment.  Do not include trailing \\n */\n+\t\tbase += 2;\n+\t\tfor (; *ptr; ptr++)\n+\t\t  if (*ptr == '\\n')\n+\t\t    break;\n+\t\tkind = K_comment;\n+\t      }\n+\t    else if (*ptr == '*')\n+\t      {\n+\t\t/* block comment */\n+\t\tbase += 2;\n+\t\tptr++;\n+\n+\t      block_comment:\n+\t\teol = in_comment;\n+\t\tin_comment = 1;\n+\t\tfor (; *ptr; ptr++)\n+\t\t  {\n+\t\t    if (*ptr == '\\n')\n+\t\t      {\n+\t\t\tptr++;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    if (ptr[0] == '*' && ptr[1] == '/')\n+\t\t      {\n+\t\t\tin_comment = 2;\n+\t\t\tptr += 2;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\tkind = K_comment;\n+\t      }\n+\t    else\n+\t      break;\n+\t  }\n+\t  break;\n+\n+\tcase '\"':\n+\t  /* quoted string */\n+\t  kind = K_string;\n+\t  while (*ptr)\n+\t    if (*ptr == '\"')\n+\t      {\n+\t\tptr++;\n+\t\tbreak;\n+\t      }\n+\t    else if (*ptr++ == '\\\\')\n+\t      ptr++;\n+\t  break;\n+\n+\tcase '.':\n+\t  if (*ptr < '0' || *ptr > '9')\n+\t    {\n+\t      kind = K_dotted;\n+\t      ws = not_comment;\n+\t      goto ident;\n+\t    }\n+\t  /* FALLTHROUGH */\n+\tcase '0'...'9':\n+\t  kind = K_number;\n+\t  goto ident;\n+\t  break;\n+\n+\tcase '$':  /* local labels.  */\n+\tcase '%':  /* register names, pseudoes etc */\n+\t  kind = K_ident;\n+\t  goto ident;\n+\n+\tcase 'a'...'z':\n+\tcase 'A'...'Z':\n+\tcase '_':\n+\t  kind = K_symbol; /* possible symbol name */\n+\tident:\n+\t  for (; *ptr; ptr++)\n+\t    {\n+\t      if (*ptr >= 'A' && *ptr <= 'Z')\n+\t\tcontinue;\n+\t      if (*ptr >= 'a' && *ptr <= 'z')\n+\t\tcontinue;\n+\t      if (*ptr >= '0' && *ptr <= '9')\n+\t\tcontinue;\n+\t      if (*ptr == '_' || *ptr == '$')\n+\t\tcontinue;\n+\t      if (*ptr == '.' && kind != K_dotted)\n+\t\t/* Idents starting with a dot, cannot have internal dots. */\n+\t\tcontinue;\n+\t      if ((*ptr == '+' || *ptr == '-')\n+\t\t  && kind == K_number\n+\t\t  && (ptr[-1] == 'e' || ptr[-1] == 'E'\n+\t\t      || ptr[-1] == 'p' || ptr[-1] == 'P'))\n+\t\t/* exponent */\n+\t\tcontinue;\n+\t      break;\n+\t    }\n+\t  if (*ptr == ':')\n+\t    {\n+\t      ptr++;\n+\t      kind = K_label;\n+\t    }\n+\t  break;\n+\t}\n+\n+      if (alloc == num)\n+\t{\n+\t  alloc *= 2;\n+\t  toks = XRESIZEVEC (Token, toks, alloc);\n+\t}\n+      Token *tok = toks + num;\n+\n+      tok->kind = kind;\n+      tok->space = ws;\n+      tok->end = 0;\n+      tok->ptr = base;\n+      tok->len = ptr - base - in_comment;\n+      in_comment &= 1;\n+      not_comment = kind != K_comment;\n+      if (eol && num)\n+\ttok[-1].end = 1;\n+      if (!kind)\n+\tbreak;\n+    }\n+\n+  return toks;\n+}\n+\n+/* Write an encoded token. */\n+\n+static void\n+write_token (FILE *out, Token const *tok)\n+{\n+  if (tok->space)\n+    fputc (' ', out);\n+\n+  switch (tok->kind)\n+    {\n+    case K_string:\n+      {\n+\tconst char *c = tok->ptr + 1;\n+\tsize_t len = tok->len - 2;\n+\n+\tfputs (\"\\\\\\\"\", out);\n+\twhile (len)\n+\t  {\n+\t    const char *bs = (const char *)memchr (c, '\\\\', len);\n+\t    size_t l = bs ? bs - c : len;\n+\n+\t    fprintf (out, \"%.*s\", (int)l, c);\n+\t    len -= l;\n+\t    c += l;\n+\t    if (bs)\n+\t      {\n+\t\tfputs (\"\\\\\\\\\", out);\n+\t\tlen--, c++;\n+\t      }\n+\t  }\n+\tfputs (\"\\\\\\\"\", out);\n+      }\n+      break;\n+\n+    default:\n+      /* All other tokens shouldn't have anything magic in them */\n+      fprintf (out, \"%.*s\", tok->len, tok->ptr);\n+      break;\n+    }\n+  if (tok->end)\n+    fputs (\"\\\\n\", out);\n+}\n+\n+static void\n+write_tokens (FILE *out, Token const *toks, unsigned len, int spc)\n+{\n+  fputs (\"\\t\\\"\", out);\n+  for (; len--; toks++)\n+    write_token (out, toks);\n+  if (spc)\n+    fputs (\" \", out);\n+  fputs (\"\\\"\", out);\n+}\n+\n+static Stmt *\n+alloc_stmt (unsigned vis, Token *tokens, Token *end, Token const *sym)\n+{\n+  static unsigned alloc = 0;\n+  static Stmt *heap = 0;\n+\n+  if (!alloc)\n+    {\n+      alloc = 1000;\n+      heap = XNEWVEC (Stmt, alloc);\n+    }\n+\n+  Stmt *stmt = heap++;\n+  alloc--;\n+\n+  tokens->space = 0;\n+  stmt->next = 0;\n+  stmt->vis = vis;\n+  stmt->tokens = tokens;\n+  stmt->len = end - tokens;\n+  stmt->sym = sym ? sym - tokens : ~0;\n+\n+  return stmt;\n+}\n+\n+static Stmt *\n+rev_stmts (Stmt *stmt)\n+{\n+  Stmt *prev = 0;\n+  Stmt *next;\n+\n+  while (stmt)\n+    {\n+      next = stmt->next;\n+      stmt->next = prev;\n+      prev = stmt;\n+      stmt = next;\n+    }\n+\n+  return prev;\n+}\n+\n+static void\n+write_stmt (FILE *out, const Stmt *stmt)\n+{\n+  if ((stmt->vis & V_mask) != V_comment)\n+    {\n+      write_tokens (out, stmt->tokens, stmt->len,\n+\t\t    (stmt->vis & V_mask) == V_pred);\n+      fputs (stmt->vis & V_no_eol ? \"\\t\" : \"\\n\", out);\n+    }\n+}\n+\n+static void\n+write_stmts (FILE *out, const Stmt *stmts)\n+{\n+  for (; stmts; stmts = stmts->next)\n+    write_stmt (out, stmts);\n+}\n+\n+static Token *\n+parse_insn (Token *tok)\n+{\n+  unsigned depth = 0;\n+\n+  do\n+    {\n+      Stmt *stmt;\n+      Token *sym = 0;\n+      unsigned s = V_insn;\n+      Token *start = tok;\n+\n+      switch (tok++->kind)\n+\t{\n+\tcase K_comment:\n+\t  while (tok->kind == K_comment)\n+\t    tok++;\n+\t  stmt = alloc_comment (start, tok);\n+\t  append_stmt (&fns, stmt);\n+\t  continue;\n+\n+\tcase '{':\n+\t  depth++;\n+\t  break;\n+\n+\tcase '}':\n+\t  depth--;\n+\t  break;\n+\n+\tcase K_label:\n+\t  if (tok[-1].ptr[0] != '$')\n+\t    sym = tok - 1;\n+\t  tok[-1].end = 1;\n+\t  s = V_label;\n+\t  break;\n+\n+\tcase '@':\n+\t  tok->space = 0;\n+\t  if (tok->kind == '!')\n+\t    tok++;\n+\t  if (tok->kind == K_symbol)\n+\t    sym = tok;\n+\t  tok++;\n+\t  s = V_pred;\n+\t  break;\n+\n+\tdefault:\n+\t  for (; tok->kind != ';'; tok++)\n+\t    {\n+\t      if (tok->kind == ',')\n+\t\ttok[1].space = 0;\n+\t      else if (tok->kind == K_symbol)\n+\t\tsym = tok;\n+\t    }\n+\t  tok++->end = 1;\n+\t  break;\n+\t}\n+\n+      stmt = alloc_stmt (s, start, tok, sym);\n+      append_stmt (&fns, stmt);\n+\n+      if (!tok[-1].end && tok[0].kind == K_comment)\n+\t{\n+\t  stmt->vis |= V_no_eol;\n+\t  stmt = alloc_comment (tok, tok + 1);\n+\t  append_stmt (&fns, stmt);\n+\t  tok++;\n+\t}\n+    }\n+  while (depth);\n+\n+  return tok;\n+}\n+\n+/* comma separated list of tokens */\n+\n+static Token *\n+parse_list_nosemi (Token *tok)\n+{\n+  Token *start = tok;\n+\n+  do\n+    if (!(++tok)->kind)\n+      break;\n+  while ((++tok)->kind == ',');\n+\n+  tok[-1].end = 1;\n+  Stmt *stmt = alloc_stmt (V_dot, start, tok, 0);\n+  append_stmt (&decls, stmt);\n+\n+  return tok;\n+}\n+\n+#define is_keyword(T,S) \\\n+  (sizeof (S) == (T)->len && !memcmp ((T)->ptr + 1, (S), (T)->len - 1))\n+\n+static Token *\n+parse_init (Token *tok)\n+{\n+  for (;;)\n+    {\n+      Token *start = tok;\n+      Token const *sym = 0;\n+      Stmt *stmt;\n+\n+      if (tok->kind == K_comment)\n+\t{\n+\t  while (tok->kind == K_comment)\n+\t    tok++;\n+\t  stmt = alloc_comment (start, tok);\n+\t  append_stmt (&vars, stmt);\n+\t  start = tok;\n+\t}\n+\n+      if (tok->kind == '{')\n+\ttok[1].space = 0;\n+      for (; tok->kind != ',' && tok->kind != ';'; tok++)\n+\tif (tok->kind == K_symbol)\n+\t  sym = tok;\n+      tok[1].space = 0;\n+      int end = tok++->kind == ';';\n+      stmt = alloc_stmt (V_insn, start, tok, sym);\n+      append_stmt (&vars, stmt);\n+      if (!tok[-1].end && tok->kind == K_comment)\n+\t{\n+\t  stmt->vis |= V_no_eol;\n+\t  stmt = alloc_comment (tok, tok + 1);\n+\t  append_stmt (&vars, stmt);\n+\t  tok++;\n+\t}\n+      if (end)\n+\tbreak;\n+    }\n+  return tok;\n+}\n+\n+static Token *\n+parse_file (Token *tok)\n+{\n+  Stmt *comment = 0;\n+\n+  if (tok->kind == K_comment)\n+    {\n+      Token *start = tok;\n+\n+      while (tok->kind == K_comment)\n+\t{\n+\t  if (strncmp (tok->ptr, \":VAR_MAP \", 9) == 0)\n+\t    record_id (tok->ptr + 9, &vars_tail);\n+\t  if (strncmp (tok->ptr, \":FUNC_MAP \", 10) == 0)\n+\t    record_id (tok->ptr + 10, &funcs_tail);\n+\t  tok++;\n+\t}\n+      comment = alloc_comment (start, tok);\n+      comment->vis |= V_prefix_comment;\n+    }\n+\n+  if (tok->kind == K_dotted)\n+    {\n+      if (is_keyword (tok, \"version\")\n+\t  || is_keyword (tok, \"target\")\n+\t  || is_keyword (tok, \"address_size\"))\n+\t{\n+\t  if (comment)\n+\t    append_stmt (&decls, comment);\n+\t  tok = parse_list_nosemi (tok);\n+\t}\n+      else\n+\t{\n+\t  unsigned vis = 0;\n+\t  const Token *def = 0;\n+\t  unsigned is_decl = 0;\n+\t  Token *start;\n+\n+\t  for (start = tok;\n+\t       tok->kind && tok->kind != '=' && tok->kind != K_comment\n+\t\t && tok->kind != '{' && tok->kind != ';'; tok++)\n+\t    {\n+\t      if (is_keyword (tok, \"global\")\n+\t\t  || is_keyword (tok, \"const\"))\n+\t\tvis |= V_var;\n+\t      else if (is_keyword (tok, \"func\")\n+\t\t       || is_keyword (tok, \"entry\"))\n+\t\tvis |= V_func;\n+\t      else if (is_keyword (tok, \"visible\"))\n+\t\tvis |= V_global;\n+\t      else if (is_keyword (tok, \"extern\"))\n+\t\tis_decl = 1;\n+\t      else if (is_keyword (tok, \"weak\"))\n+\t\tvis |= V_weak;\n+\t      if (tok->kind == '(')\n+\t\t{\n+\t\t  tok[1].space = 0;\n+\t\t  tok[0].space = 1;\n+\t\t}\n+\t      else if (tok->kind == ')' && tok[1].kind != ';')\n+\t\ttok[1].space = 1;\n+\n+\t      if (tok->kind == K_symbol)\n+\t\tdef = tok;\n+\t    }\n+\n+\t  if (!tok->kind)\n+\t    {\n+\t      /* end of file */\n+\t      if (comment)\n+\t\tappend_stmt (&fns, comment);\n+\t    }\n+\t  else if (tok->kind == '{'\n+\t\t   || tok->kind == K_comment)\n+\t    {\n+\t      /* function defn */\n+\t      Stmt *stmt = alloc_stmt (vis, start, tok, def);\n+\t      if (comment)\n+\t\t{\n+\t\t  append_stmt (&fns, comment);\n+\t\t  stmt->vis |= V_prefix_comment;\n+\t\t}\n+\t      append_stmt (&fns, stmt);\n+\t      tok = parse_insn (tok);\n+\t    }\n+\t  else\n+\t    {\n+\t      int assign = tok->kind == '=';\n+\n+\t      tok++->end = 1;\n+\t      if ((vis & V_mask) == V_var && !is_decl)\n+\t\t{\n+\t\t  /* variable */\n+\t\t  Stmt *stmt = alloc_stmt (vis, start, tok, def);\n+\t\t  if (comment)\n+\t\t    {\n+\t\t      append_stmt (&vars, comment);\n+\t\t      stmt->vis |= V_prefix_comment;\n+\t\t    }\n+\t\t  append_stmt (&vars, stmt);\n+\t\t  if (assign)\n+\t\t    tok = parse_init (tok);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* declaration */\n+\t\t  Stmt *stmt = alloc_stmt (vis, start, tok, 0);\n+\t\t  if (comment)\n+\t\t    {\n+\t\t      append_stmt (&decls, comment);\n+\t\t      stmt->vis |= V_prefix_comment;\n+\t\t    }\n+\t\t  append_stmt (&decls, stmt);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Something strange.  Ignore it.  */\n+      if (comment)\n+\tappend_stmt (&fns, comment);\n+\n+      while (tok->kind && !tok->end)\n+\ttok++;\n+    }\n+  return tok;\n+}\n+\n+static void\n+process (FILE *in, FILE *out)\n+{\n+  const char *input = read_file (in);\n+  Token *tok = tokenize (input);\n+\n+  do\n+    tok = parse_file (tok);\n+  while (tok->kind);\n+\n+  fprintf (out, \"static const char ptx_code[] = \\n\");\n+  write_stmts (out, rev_stmts (decls));\n+  write_stmts (out, rev_stmts (vars));\n+  write_stmts (out, rev_stmts (fns));\n+  fprintf (out, \";\\n\\n\");\n+  fprintf (out, \"static const char *var_mappings[] = {\\n\");\n+  for (id_map *id = var_ids; id; id = id->next)\n+    fprintf (out, \"\\t\\\"%s\\\"%s\\n\", id->ptx_name, id->next ? \",\" : \"\");\n+  fprintf (out, \"};\\n\\n\");\n+  fprintf (out, \"static const char *func_mappings[] = {\\n\");\n+  for (id_map *id = func_ids; id; id = id->next)\n+    fprintf (out, \"\\t\\\"%s\\\"%s\\n\", id->ptx_name, id->next ? \",\" : \"\");\n+  fprintf (out, \"};\\n\\n\");\n+\n+  fprintf (out, \"static const void *target_data[] = {\\n\");\n+  fprintf (out, \"  ptx_code, var_mappings, func_mappings\\n\");\n+  fprintf (out, \"};\\n\\n\");\n+\n+  fprintf (out, \"extern void GOMP_offload_register (const void *, int, void *);\\n\");\n+\n+  fprintf (out, \"extern void *__OPENMP_TARGET__[];\\n\\n\");\n+  fprintf (out, \"#define PTX_ID 1\\n\");\n+  fprintf (out, \"static __attribute__((constructor)) void init (void)\\n{\\n\");\n+  fprintf (out, \"  GOMP_offload_register (__OPENMP_TARGET__, PTX_ID,\\n\");\n+  fprintf (out, \"                         &target_data);\\n\");\n+  fprintf (out, \"};\\n\");\n+}\n+\n+static void\n+compile_native (const char *infile, const char *outfile, const char *compiler)\n+{\n+  const char *collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (!collect_gcc_options)\n+    fatal_error (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n+\n+  struct obstack argv_obstack;\n+  obstack_init (&argv_obstack);\n+  obstack_ptr_grow (&argv_obstack, compiler);\n+  obstack_ptr_grow (&argv_obstack, infile);\n+  obstack_ptr_grow (&argv_obstack, \"-c\");\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, outfile);\n+  obstack_ptr_grow (&argv_obstack, NULL);\n+\n+  const char **new_argv = XOBFINISH (&argv_obstack, const char **);\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), true);\n+  obstack_free (&argv_obstack, NULL);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  FILE *in = stdin;\n+  FILE *out = stdout;\n+  const char *outname = 0;\n+\n+  char *collect_gcc = getenv (\"COLLECT_GCC\");\n+  if (collect_gcc == NULL)\n+    fatal_error (\"COLLECT_GCC must be set.\");\n+  const char *gcc_path = dirname (ASTRDUP (collect_gcc));\n+  const char *gcc_exec = basename (ASTRDUP (collect_gcc));\n+\n+  size_t len = (strlen (gcc_path) + 1\n+\t\t+ strlen (GCC_INSTALL_NAME)\n+\t\t+ 1);\n+  char *driver = XALLOCAVEC (char, len);\n+\n+  if (strcmp (gcc_exec, collect_gcc) == 0)\n+    /* collect_gcc has no path, so it was found in PATH.  Make sure we also\n+       find accel-gcc in PATH.  */\n+    gcc_path = NULL;\n+\n+  int driver_used = 0;\n+  if (gcc_path != NULL)\n+    driver_used = sprintf (driver, \"%s/\", gcc_path);\n+  sprintf (driver + driver_used, \"%s\", GCC_INSTALL_NAME);\n+\n+  /* We may be called with all the arguments stored in some file and\n+     passed with @file.  Expand them into argv before processing.  */\n+  expandargv (&argc, &argv);\n+\n+  struct obstack argv_obstack;\n+  obstack_init (&argv_obstack);\n+  obstack_ptr_grow (&argv_obstack, driver);\n+  obstack_ptr_grow (&argv_obstack, \"-xlto\");\n+  obstack_ptr_grow (&argv_obstack, \"-m64\");\n+  obstack_ptr_grow (&argv_obstack, \"-S\");\n+\n+  for (int ix = 1; ix != argc; ix++)\n+    {\n+      if (!strcmp (argv[ix], \"-o\") && ix + 1 != argc)\n+\toutname = argv[++ix];\n+      else\n+\tobstack_ptr_grow (&argv_obstack, argv[ix]);\n+    }\n+\n+  ptx_name = make_temp_file (\".mkoffload\");\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, ptx_name);\n+  obstack_ptr_grow (&argv_obstack, NULL);\n+  const char **new_argv = XOBFINISH (&argv_obstack, const char **);\n+\n+  char *execpath = getenv (\"GCC_EXEC_PREFIX\");\n+  char *cpath = getenv (\"COMPILER_PATH\");\n+  char *lpath = getenv (\"LIBRARY_PATH\");\n+  unsetenv (\"GCC_EXEC_PREFIX\");\n+  unsetenv (\"COMPILER_PATH\");\n+  unsetenv (\"LIBRARY_PATH\");\n+\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), true);\n+  obstack_free (&argv_obstack, NULL);\n+\n+  xputenv (concat (\"GCC_EXEC_PREFIX=\", execpath, NULL));\n+  xputenv (concat (\"COMPILER_PATH=\", cpath, NULL));\n+  xputenv (concat (\"LIBRARY_PATH=\", lpath, NULL));\n+\n+  in = fopen (ptx_name, \"r\");\n+  if (!in)\n+    fatal_error (\"cannot open intermediate ptx file\");\n+\n+  ptx_cfile_name = make_temp_file (\".c\");\n+\n+  out = fopen (ptx_cfile_name, \"w\");\n+  if (!out)\n+    fatal_error (\"cannot open '%s'\", ptx_cfile_name);\n+\n+  process (in, out);\n+  fclose (out);\n+\n+  compile_native (ptx_cfile_name, outname, collect_gcc);\n+\n+  utils_cleanup (false);\n+\n+  return 0;\n+}"}, {"sha": "53922bc8e85ce61fc2c8e589c76728f394fb86b7", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=1f83528e3e0c750c5c62f7148e4bfc3169084208", "patch": "@@ -2030,6 +2030,16 @@ nvptx_vector_alignment (const_tree type)\n   return MIN (align, BIGGEST_ALIGNMENT);\n }\n \f\n+/* Record a symbol for mkoffload to enter into the mapping table.  */\n+\n+static void\n+nvptx_record_offload_symbol (tree decl)\n+{\n+  fprintf (asm_out_file, \"//:%s_MAP %s\\n\",\n+\t   TREE_CODE (decl) == VAR_DECL ? \"VAR\" : \"FUNC\",\n+\t   IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+}\n+\n /* Implement TARGET_ASM_FILE_START.  Write the kinds of things ptxas expects\n    at the start of a file.  */\n \n@@ -2133,6 +2143,9 @@ nvptx_file_end (void)\n #undef TARGET_NO_REGISTER_ALLOCATION\n #define TARGET_NO_REGISTER_ALLOCATION true\n \n+#undef TARGET_RECORD_OFFLOAD_SYMBOL\n+#define TARGET_RECORD_OFFLOAD_SYMBOL nvptx_record_offload_symbol\n+\n #undef TARGET_VECTOR_ALIGNMENT\n #define TARGET_VECTOR_ALIGNMENT nvptx_vector_alignment\n "}, {"sha": "d53471f955108ab3882fb5f79d52e3a5924062aa", "filename": "gcc/config/nvptx/t-nvptx", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f83528e3e0c750c5c62f7148e4bfc3169084208/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=1f83528e3e0c750c5c62f7148e4bfc3169084208", "patch": "@@ -1,2 +1,9 @@\n-#\n+CFLAGS-mkoffload.o += $(DRIVER_DEFINES) \\\n+\t-DGCC_INSTALL_NAME=\\\"$(GCC_INSTALL_NAME)\\\"\n+mkoffload.o: $(srcdir)/config/nvptx/mkoffload.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n \n+mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBDEPS)\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t  mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)"}]}