{"sha": "5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "node_id": "C_kwDOANBUbNoAKDViM2E4ODY0MGY5NjJkNGZmY2EzMWFlNjUxYmVkMmQ4NjcyZjFhOGM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-01-14T09:17:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-01-14T09:17:14Z"}, "message": "c++: Avoid incorrect shortening of divisions [PR108365]\n\nThe following testcase is miscompiled, because we shorten the division\nin a case where it should not be shortened.\nDivisions (and modulos) can be shortened if it is unsigned division/modulo,\nor if it is signed division/modulo where we can prove the dividend will\nnot be the minimum signed value or divisor will not be -1, because e.g.\non sizeof(long long)==sizeof(int)*2 && __INT_MAX__ == 0x7fffffff targets\n(-2147483647 - 1) / -1 is UB\nbut\n(int) (-2147483648LL / -1LL) is not, it is -2147483648.\nThe primary aim of both the C and C++ FE division/modulo shortening I assume\nwas for the implicit integral promotions of {,signed,unsigned} {char,short}\nand because at this point we have no VRP information etc., the shortening\nis done if the integral promotion is from unsigned type for the divisor\nor if the dividend is an integer constant other than -1.\nThis works fine for char/short -> int promotions when char/short have\nsmaller precision than int - unsigned char -> int or unsigned short -> int\nwill always be a positive int, so never the most negative.\n\nNow, the C FE checks whether orig_op0 is TYPE_UNSIGNED where op0 is either\nthe same as orig_op0 or that promoted to int, I think that works fine,\nif it isn't promoted, either the division/modulo common type will have the\nsame precision as op0 but then the division/modulo is unsigned and so\nwithout UB, or it will be done in wider precision (e.g. because op1 has\nwider precision), but then op0 can't be minimum signed value.  Or it has\nbeen promoted to int, but in that case it was again from narrower type and\nso never minimum signed int.\n\nBut the C++ FE was checking if op0 is a NOP_EXPR from TYPE_UNSIGNED.\nFirst of all, not sure if the operand of NOP_EXPR couldn't be non-integral\ntype where TYPE_UNSIGNED wouldn't be meaningful, but more importantly,\neven if it is a cast from unsigned integral type, we only know it can't be\nminimum signed value if it is a widening cast, if it is same precision or\nnarrowing cast, we know nothing.\n\nSo, the following patch for the NOP_EXPR cases checks just in case that\nit is from integral type and more importantly checks it is a widening\nconversion, and then next to it also allows op0 to be just unsigned,\npromoted or not, as that is what the C FE will do for those cases too\nand I believe it must work - either the division/modulo common type\nwill be that unsigned type, then we can shorten and don't need to worry\nabout UB, or it will be some wider signed type but then it can't be most\nnegative value of the wider type.\nAnd changes both the C and C++ FEs to do the same thing, using a helper\nfunction in c-family.\n\n2023-01-14  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/108365\n\t* c-common.h (may_shorten_divmod): New static inline function.\n\n\t* c-typeck.cc (build_binary_op): Use may_shorten_divmod for integral\n\tdivision or modulo.\n\n\t* typeck.cc (cp_build_binary_op): Use may_shorten_divmod for integral\n\tdivision or modulo.\n\n\t* c-c++-common/pr108365.c: New test.\n\t* g++.dg/opt/pr108365.C: New test.\n\t* g++.dg/warn/pr108365.C: New test.", "tree": {"sha": "f86a797c3cbefb88352a83a784d0eb51e0ede4af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f86a797c3cbefb88352a83a784d0eb51e0ede4af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88679960c2665d87c8354ce35a48aaadbe3f0793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88679960c2665d87c8354ce35a48aaadbe3f0793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88679960c2665d87c8354ce35a48aaadbe3f0793"}], "stats": {"total": 76, "additions": 62, "deletions": 14}, "files": [{"sha": "3f4129fbf3c9fecae4fcedd8b3a723e42113aa23", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "patch": "@@ -918,6 +918,30 @@ extern tree convert_init (tree, tree);\n /* Subroutine of build_binary_op, used for certain operations.  */\n extern tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise);\n \n+/* Return true if division or modulo op0 / op1 or op0 % op1 may be shortened.\n+   We can shorten only if we can guarantee that op0 is not signed integral\n+   minimum or op1 is not -1, because e.g. (long long) INT_MIN / -1 is\n+   well defined INT_MAX + 1LL if long long is wider than int, but INT_MIN / -1\n+   is UB.  */\n+static inline bool\n+may_shorten_divmod (tree op0, tree op1)\n+{\n+  tree type0 = TREE_TYPE (op0);\n+  if (TYPE_UNSIGNED (type0))\n+    return true;\n+  /* A cast from narrower unsigned won't be signed integral minimum,\n+     but cast from same or wider precision unsigned could be.  */\n+  if (TREE_CODE (op0) == NOP_EXPR\n+      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+      && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t  < TYPE_PRECISION (type0)))\n+    return true;\n+  if (TREE_CODE (op1) == INTEGER_CST && !integer_all_onesp (op1))\n+    return true;\n+  return false;\n+}\n+\n /* Subroutine of build_binary_op, used for comparison operations.\n    See if the operands have both been converted from subword integer types\n    and, if so, perhaps change them both back to their original type.  */"}, {"sha": "418efdaff3ff8f029d27e2129f04b03ca1be57f6", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "patch": "@@ -12431,9 +12431,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t       undefined if the quotient can't be represented in the\n \t       computation mode.  We shorten only if unsigned or if\n \t       dividing by something we know != -1.  */\n-\t    shorten = (TYPE_UNSIGNED (TREE_TYPE (orig_op0))\n-\t\t       || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t   && !integer_all_onesp (op1)));\n+\t    shorten = may_shorten_divmod (op0, op1);\n \t  common = 1;\n \t}\n       break;\n@@ -12467,9 +12465,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t     on some targets, since the modulo instruction is undefined if the\n \t     quotient can't be represented in the computation mode.  We shorten\n \t     only if unsigned or if dividing by something we know != -1.  */\n-\t  shorten = (TYPE_UNSIGNED (TREE_TYPE (orig_op0))\n-\t\t     || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t && !integer_all_onesp (op1)));\n+\t  shorten = may_shorten_divmod (op0, op1);\n \t  common = 1;\n \t}\n       break;"}, {"sha": "8392dc5b199c7c1c4116b2292e0afaa837ef1c22", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "patch": "@@ -5455,10 +5455,7 @@ cp_build_binary_op (const op_location_t &location,\n \t\t point, so we have to dig out the original type to find out if\n \t\t it was unsigned.  */\n \t      tree stripped_op1 = tree_strip_any_location_wrapper (op1);\n-\t      shorten = ((TREE_CODE (op0) == NOP_EXPR\n-\t\t\t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n-\t\t\t || (TREE_CODE (stripped_op1) == INTEGER_CST\n-\t\t\t     && ! integer_all_onesp (stripped_op1)));\n+\t      shorten = may_shorten_divmod (op0, stripped_op1);\n \t    }\n \n \t  common = 1;\n@@ -5491,10 +5488,7 @@ cp_build_binary_op (const op_location_t &location,\n \t     quotient can't be represented in the computation mode.  We shorten\n \t     only if unsigned or if dividing by something we know != -1.  */\n \t  tree stripped_op1 = tree_strip_any_location_wrapper (op1);\n-\t  shorten = ((TREE_CODE (op0) == NOP_EXPR\n-\t\t      && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n-\t\t     || (TREE_CODE (stripped_op1) == INTEGER_CST\n-\t\t\t && ! integer_all_onesp (stripped_op1)));\n+\t  shorten = may_shorten_divmod (op0, stripped_op1);\n \t  common = 1;\n \t}\n       break;"}, {"sha": "684a8e9a8cca9cd9617fafbf7fed3dca0b89491f", "filename": "gcc/testsuite/c-c++-common/pr108365.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr108365.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr108365.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr108365.c?ref=5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "patch": "@@ -0,0 +1,16 @@\n+/* PR c++/108365 */\n+/* { dg-do compile { target { { ilp32 || lp64 } || llp64 } } } */\n+/* { dg-options \"-O2 -fdump-tree-gimple\" } */\n+/* { dg-final { scan-tree-dump-not \" \\\\\\((int|unsigned short int|long long int|unsigned int)\\\\\\) \" \"gimple\" } } */\n+\n+unsigned short\n+foo (unsigned short x, unsigned short y)\n+{\n+  return (unsigned) x / y;\n+}\n+\n+unsigned int\n+bar (unsigned int x, unsigned int y)\n+{\n+  return (long long) x / y;\n+}"}, {"sha": "47eefa2b29aeb6f5906c4a321f9c62b10c482c1f", "filename": "gcc/testsuite/g++.dg/opt/pr108365.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr108365.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr108365.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr108365.C?ref=5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/108365\n+// { dg-do run }\n+\n+char b = 1;\n+\n+int\n+main ()\n+{\n+#if __CHAR_BIT__ == 8 && __SIZEOF_SHORT__ == 2 && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+  while ((short) ((long long) (unsigned long long) (-__INT_MAX__ - 1) / (long long) (b ? -1 : 0)))\n+    ;\n+#endif\n+}"}, {"sha": "6d40957c9b3379a559bfa72f5de5fcc99b20109a", "filename": "gcc/testsuite/g++.dg/warn/pr108365.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr108365.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3a88640f962d4ffca31ae651bed2d8672f1a8c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr108365.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr108365.C?ref=5b3a88640f962d4ffca31ae651bed2d8672f1a8c", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/108365\n+// { dg-do compile { target { { { ilp32 || lp64 } || llp64 } && c++11 } } }\n+\n+constexpr char b = 1;\n+long t = (short) ((long long) (unsigned long long) (-__INT_MAX__ - 1) / (long long) (b ? -1 : 0)); // { dg-bogus \"integer overflow in expression of type\" }"}]}