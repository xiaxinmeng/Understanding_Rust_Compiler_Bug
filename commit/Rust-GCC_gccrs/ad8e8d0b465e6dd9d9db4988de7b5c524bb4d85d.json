{"sha": "ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ4ZThkMGI0NjVlNmRkOWQ5ZGI0OTg4ZGU3YjVjNTI0YmI0ZDg1ZA==", "commit": {"author": {"name": "Seongbae Park", "email": "seongbae.park@gmail.com", "date": "2007-02-06T19:43:41Z"}, "committer": {"name": "Seongbae Park", "email": "spark@gcc.gnu.org", "date": "2007-02-06T19:43:41Z"}, "message": "re PR inline-asm/28686 (ebp from clobber list used as operand)\n\n2007-02-06  Seongbae Park <seongbae.park@gmail.com>\n\n\tPR inline-asm/28686\n\t* global.c (compute_regsets): New function.\n\t(global_alloc): Refactored ELIMINABLE_REGSET\n\tand NO_GLOBAL_ALLOC_REGS computation out.\n\t(rest_of_handle_global_alloc): Call compute_regsets()\n\tfor non-optimizing case.\n\nFrom-SVN: r121663", "tree": {"sha": "d18dafd48a46a4ba5713391feecc118b46f7533f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d18dafd48a46a4ba5713391feecc118b46f7533f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d/comments", "author": null, "committer": null, "parents": [{"sha": "5096114103d8760599ed4377fde637b22a9e5e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5096114103d8760599ed4377fde637b22a9e5e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5096114103d8760599ed4377fde637b22a9e5e91"}], "stats": {"total": 87, "additions": 60, "deletions": 27}, "files": [{"sha": "ed39761449291e8e6c0727adab56c125417b1a57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d", "patch": "@@ -1,3 +1,12 @@\n+2007-02-06  Seongbae Park <seongbae.park@gmail.com>\n+\n+\tPR inline-asm/28686\n+\t* global.c (compute_regsets): New function.\n+\t(global_alloc): Refactored ELIMINABLE_REGSET\n+\tand NO_GLOBAL_ALLOC_REGS computation out.\n+\t(rest_of_handle_global_alloc): Call compute_regsets()\n+\tfor non-optimizing case.\n+\n 2007-02-06  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/constraints.md (Y2): Rename from Y."}, {"sha": "2271f3aa21b1500a7fc93770c1a1d8ec09716a96", "filename": "gcc/global.c", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=ad8e8d0b465e6dd9d9db4988de7b5c524bb4d85d", "patch": "@@ -326,35 +326,38 @@ static void make_accurate_live_analysis (void);\n \n \f\n \n-/* Perform allocation of pseudo-registers not allocated by local_alloc.\n+/* Look through the list of eliminable registers.  Add registers\n+   clobbered by asm statements to LIVE_REGS.  Set ELIM_SET to the set of\n+   registers which may be eliminated.  Set NO_GLOBAL_SET to the set of\n+   registers which may not be used across blocks.\n \n-   Return value is nonzero if reload failed\n-   and we must not do any more for this function.  */\n+   ASM_CLOBBERED is the set of registers clobbered by some asm statement.\n \n-static int\n-global_alloc (void)\n+   This will normally be called with LIVE_REGS as the global variable\n+   regs_ever_live, ELIM_SET as the file static variable\n+   eliminable_regset, and NO_GLOBAL_SET as the file static variable\n+   NO_GLOBAL_ALLOC_REGS.  */\n+\n+static void\n+compute_regsets (char asm_clobbered[FIRST_PSEUDO_REGISTER],\n+                 char live_regs[FIRST_PSEUDO_REGISTER],\n+                 HARD_REG_SET *elim_set, \n+                 HARD_REG_SET *no_global_set)\n {\n-  int retval;\n #ifdef ELIMINABLE_REGS\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n+  size_t i;\n   int need_fp\n     = (! flag_omit_frame_pointer\n        || (current_function_calls_alloca && EXIT_IGNORE_STACK)\n        || FRAME_POINTER_REQUIRED);\n \n-  size_t i;\n-  rtx x;\n-\n-  make_accurate_live_analysis ();\n-\n-  max_allocno = 0;\n-\n   /* A machine may have certain hard registers that\n      are safe to use only within a basic block.  */\n \n-  CLEAR_HARD_REG_SET (no_global_alloc_regs);\n-  CLEAR_HARD_REG_SET (eliminable_regset);\n+  CLEAR_HARD_REG_SET (*no_global_set);\n+  CLEAR_HARD_REG_SET (*elim_set);\n \n   /* Build the regset of all eliminable registers and show we can't use those\n      that we already know won't be eliminated.  */\n@@ -365,45 +368,63 @@ global_alloc (void)\n \t= (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n \t   || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp));\n \n-      if (!regs_asm_clobbered[eliminables[i].from])\n+      if (!asm_clobbered[eliminables[i].from])\n \t{\n-\t  SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);\n+\t  SET_HARD_REG_BIT (*elim_set, eliminables[i].from);\n \n \t  if (cannot_elim)\n-\t    SET_HARD_REG_BIT (no_global_alloc_regs, eliminables[i].from);\n+\t    SET_HARD_REG_BIT (*no_global_set, eliminables[i].from);\n \t}\n       else if (cannot_elim)\n \terror (\"%s cannot be used in asm here\",\n \t       reg_names[eliminables[i].from]);\n       else\n-\tregs_ever_live[eliminables[i].from] = 1;\n+\tlive_regs[eliminables[i].from] = 1;\n     }\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-  if (!regs_asm_clobbered[HARD_FRAME_POINTER_REGNUM])\n+  if (!asm_clobbered[HARD_FRAME_POINTER_REGNUM])\n     {\n-      SET_HARD_REG_BIT (eliminable_regset, HARD_FRAME_POINTER_REGNUM);\n+      SET_HARD_REG_BIT (*elim_set, HARD_FRAME_POINTER_REGNUM);\n       if (need_fp)\n-\tSET_HARD_REG_BIT (no_global_alloc_regs, HARD_FRAME_POINTER_REGNUM);\n+\tSET_HARD_REG_BIT (*no_global_set, HARD_FRAME_POINTER_REGNUM);\n     }\n   else if (need_fp)\n     error (\"%s cannot be used in asm here\",\n \t   reg_names[HARD_FRAME_POINTER_REGNUM]);\n   else\n-    regs_ever_live[HARD_FRAME_POINTER_REGNUM] = 1;\n+    live_regs[HARD_FRAME_POINTER_REGNUM] = 1;\n #endif\n \n #else\n-  if (!regs_asm_clobbered[FRAME_POINTER_REGNUM])\n+  if (!asm_clobbered[FRAME_POINTER_REGNUM])\n     {\n-      SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);\n+      SET_HARD_REG_BIT (*elim_set, FRAME_POINTER_REGNUM);\n       if (need_fp)\n-\tSET_HARD_REG_BIT (no_global_alloc_regs, FRAME_POINTER_REGNUM);\n+\tSET_HARD_REG_BIT (*no_global_set, FRAME_POINTER_REGNUM);\n     }\n   else if (need_fp)\n     error (\"%s cannot be used in asm here\", reg_names[FRAME_POINTER_REGNUM]);\n   else\n-    regs_ever_live[FRAME_POINTER_REGNUM] = 1;\n+    live_regs[FRAME_POINTER_REGNUM] = 1;\n #endif\n+}\n+\n+/* Perform allocation of pseudo-registers not allocated by local_alloc.\n+\n+   Return value is nonzero if reload failed\n+   and we must not do any more for this function.  */\n+\n+static int\n+global_alloc (void)\n+{\n+  int retval;\n+  size_t i;\n+  rtx x;\n+\n+  make_accurate_live_analysis ();\n+\n+  compute_regsets (regs_asm_clobbered, regs_ever_live,\n+                   &eliminable_regset, &no_global_alloc_regs);\n \n   /* Track which registers have already been used.  Start with registers\n      explicitly in the rtl, then registers allocated by local register\n@@ -460,6 +481,7 @@ global_alloc (void)\n \treg_may_share[r2] = r1;\n     }\n \n+  max_allocno = 0;\n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n        that we are supposed to refrain from putting in a hard reg.\n@@ -2516,6 +2538,8 @@ rest_of_handle_global_alloc (void)\n     failure = global_alloc ();\n   else\n     {\n+      compute_regsets (regs_asm_clobbered, regs_ever_live,\n+                       &eliminable_regset, &no_global_alloc_regs);\n       build_insn_chain (get_insns ());\n       failure = reload (get_insns (), 0);\n     }"}]}