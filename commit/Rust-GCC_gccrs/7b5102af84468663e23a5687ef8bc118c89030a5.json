{"sha": "7b5102af84468663e23a5687ef8bc118c89030a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I1MTAyYWY4NDQ2ODY2M2UyM2E1Njg3ZWY4YmMxMThjODkwMzBhNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-01-14T05:15:21Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-01-14T05:15:21Z"}, "message": "[multiple changes]\n\n2003-01-13 Andreas Tobler <a.tobler@schweiz.ch>\n\n\t* libffi/src/ffitest.c\n         add closure testcases\n\n2003-01-13 Kevin B. Hendricks <khendricks@ivey.uwo.ca>\n\n\t* libffi/src/powerpc/ffi.c\n         fix alignment bug for float (4 byte aligned iso 8 byte)\n\nFrom-SVN: r61263", "tree": {"sha": "6c12361dc1451562742db27e0893369d9bb045b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c12361dc1451562742db27e0893369d9bb045b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b5102af84468663e23a5687ef8bc118c89030a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5102af84468663e23a5687ef8bc118c89030a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b5102af84468663e23a5687ef8bc118c89030a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5102af84468663e23a5687ef8bc118c89030a5/comments", "author": null, "committer": null, "parents": [{"sha": "8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d59b2301899ee7cc32bce79d766ce0618ffa2f4"}], "stats": {"total": 305, "additions": 275, "deletions": 30}, "files": [{"sha": "944206fe1cbec1933709d55ab87bdd6b0b0ab0aa", "filename": "libffi/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5102af84468663e23a5687ef8bc118c89030a5/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5102af84468663e23a5687ef8bc118c89030a5/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=7b5102af84468663e23a5687ef8bc118c89030a5", "patch": "@@ -1,3 +1,13 @@\n+2003-01-13 Andreas Tobler <a.tobler@schweiz.ch>\n+\n+\t* libffi/src/ffitest.c\n+         add closure testcases\n+\n+2003-01-13 Kevin B. Hendricks <khendricks@ivey.uwo.ca>\n+\n+\t* libffi/src/powerpc/ffi.c\n+         fix alignment bug for float (4 byte aligned iso 8 byte)\n+\n 2003-01-09  Geoffrey Keating  <geoffk@apple.com>\n \n \t* src/powerpc/ffi_darwin.c: Remove RCS version string."}, {"sha": "94643d9ec71503fe74139e11d205184989585e18", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 244, "deletions": 14, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5102af84468663e23a5687ef8bc118c89030a5/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5102af84468663e23a5687ef8bc118c89030a5/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=7b5102af84468663e23a5687ef8bc118c89030a5", "patch": "@@ -288,10 +288,121 @@ static test_structure_9 struct9 (test_structure_9 ts)\n static void\n closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)\n {\n-  *(ffi_arg*)resp = *(int*)args[0] + (int)(*(float*)args[1]) + (int)(long)userdata;\n+  *(ffi_arg*)resp =\n+    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +\n+    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +\n+    (int)(*(signed short *)args[4]) +\n+    (int)(*(unsigned long long *)args[5]) +\n+    (int)*(int *)args[6] + (int)(*(int *)args[7]) +\n+    (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +\n+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +\n+    (int)(*(int *)args[14]) +  *(int *)args[15] + (int)(long)userdata;\n+\n+    \tprintf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t       (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]), \n+\t       (int)(*(unsigned long long *)args[2]),\n+\t       (int)*(int *)args[3], (int)(*(signed short *)args[4]), \n+\t       (int)(*(unsigned long long *)args[5]),\n+\t       (int)*(int *)args[6], (int)(*(int *)args[7]), \n+\t       (int)(*(double *)args[8]), (int)*(int *)args[9],\n+\t       (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+\t       (int)*(int *)args[12], (int)(*(int *)args[13]), \n+\t       (int)(*(int *)args[14]),*(int *)args[15],\n+\t       (int)(long)userdata, *(int*)resp);\n }\n \n-typedef int (*closure_test_type)(int, float);\n+typedef int (*closure_test_type)(unsigned long long, int, unsigned long long, \n+\t\t\t\t int, signed short, unsigned long long, int, \n+\t\t\t\t int, double, int, int, float, int, int, \n+\t\t\t\t int, int);\n+\n+static void closure_test_fn1(ffi_cif* cif,void* resp,void** args, \n+\t\t\t     void* userdata)\n+ {\n+    *(ffi_arg*)resp =\n+      (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n+      (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n+      (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +\n+      (int)*(float *)args[6] + (int)(*(int *)args[7]) + \n+      (int)(*(double*)args[8]) + (int)*(int *)args[9] + \n+      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n+      (int)*(int *)args[12] + (int)(*(int *)args[13]) + \n+      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n+\n+    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t   (int)*(float *)args[0], (int)(*(float *)args[1]), \n+\t   (int)(*(float *)args[2]), (int)*(float *)args[3], \n+\t   (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),\n+\t   (int)*(float *)args[6], (int)(*(int *)args[7]),\n+\t   (int)(*(double *)args[8]), (int)*(int *)args[9],\n+\t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+\t   (int)*(int *)args[12], (int)(*(int *)args[13]),\n+\t   (int)(*(int *)args[14]), *(int *)args[15],\n+\t   (int)(long)userdata, *(int*)resp);\n+}\n+\n+typedef int (*closure_test_type1)(float, float, float, float, signed short, \n+\t\t\t\t  float, float, int, double, int, int, float,\n+\t\t\t\t  int, int, int, int);\n+\n+static void closure_test_fn2(ffi_cif* cif,void* resp,void** args, \n+\t\t\t     void* userdata)\n+ {\n+    *(ffi_arg*)resp =\n+      (int)*(double *)args[0] +(int)(*(double *)args[1]) + \n+      (int)(*(double *)args[2]) + (int)*(double *)args[3] +\n+      (int)(*(signed short *)args[4]) + (int)(*(double *)args[5]) +\n+      (int)*(double *)args[6] + (int)(*(int *)args[7]) + \n+      (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n+      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n+      (int)*(int *)args[12] + (int)(*(float *)args[13]) +\n+      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n+\n+    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t   (int)*(double *)args[0], (int)(*(double *)args[1]), \n+\t   (int)(*(double *)args[2]), (int)*(double *)args[3], \n+\t   (int)(*(signed short *)args[4]), (int)(*(double *)args[5]),\n+\t   (int)*(double *)args[6], (int)(*(int *)args[7]), \n+\t   (int)(*(double*)args[8]), (int)*(int *)args[9], \n+\t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+\t   (int)*(int *)args[12], (int)(*(float *)args[13]), \n+\t   (int)(*(int *)args[14]), *(int *)args[15], (int)(long)userdata, \n+\t   *(int*)resp);\n+ }\n+\n+typedef int (*closure_test_type2)(double, double, double, double, signed short,\n+\t\t\t\t  double, double, int, double, int, int, float,\n+\t\t\t\t  int, float, int, int);\n+\n+static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+    *(ffi_arg*)resp =\n+      (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n+      (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n+      (int)(*(float *)args[4]) + (int)(*(float *)args[5]) +\n+      (int)*(float *)args[6] + (int)(*(float *)args[7]) + \n+      (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n+      (int)(*(float *)args[10]) + (int)(*(float *)args[11]) + \n+      (int)*(int *)args[12] + (int)(*(float *)args[13]) +\n+      (int)(*(float *)args[14]) +  *(int *)args[15] + (int)(long)userdata;\n+\n+    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t   (int)*(float *)args[0], (int)(*(float *)args[1]), \n+\t   (int)(*(float *)args[2]), (int)*(float *)args[3], \n+\t   (int)(*(float *)args[4]), (int)(*(float *)args[5]),\n+\t   (int)*(float *)args[6], (int)(*(float *)args[7]), \n+\t   (int)(*(double *)args[8]), (int)*(int *)args[9], \n+\t   (int)(*(float *)args[10]), (int)(*(float *)args[11]),\n+\t   (int)*(int *)args[12], (int)(*(float *)args[13]), \n+\t   (int)(*(float *)args[14]), *(int *)args[15], (int)(long)userdata,\n+\t   *(int*)resp);\n+ }\n+\n+typedef int (*closure_test_type3)(float, float, float, float, float, float,\n+\t\t\t\t  float, float, double, int, float, float, int,\n+\t\t\t\t  float, float, int);\n #endif\n \n int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n@@ -315,6 +426,12 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   ffi_arg rint;\n   long long rlonglong;\n \n+  /* The closure must not be an automatic variable on\n+     platforms (Solaris) that forbid stack execution by default. */\n+  static ffi_closure cl;\n+  \n+  ffi_type * cl_arg_types[17];\n+\n   ffi_type ts1_type;\n   ffi_type ts2_type;\n   ffi_type ts3_type;\n@@ -1044,24 +1161,137 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n # if FFI_CLOSURES\n   /* A simple closure test */\n     {\n-      /* The closure must not be an automatic variable on\n-\t platforms (Solaris) that forbid stack execution by default. */\n-      static ffi_closure cl;\n-      ffi_type * cl_arg_types[3];\n+      (void) puts(\"\\nEnter FFI_CLOSURES\\n\");\n+\n+      cl_arg_types[0] = &ffi_type_uint64;\n+      cl_arg_types[1] = &ffi_type_uint;\n+      cl_arg_types[2] = &ffi_type_uint64;\n+      cl_arg_types[3] = &ffi_type_uint;\n+      cl_arg_types[4] = &ffi_type_sshort;\n+      cl_arg_types[5] = &ffi_type_uint64;\n+      cl_arg_types[6] = &ffi_type_uint;\n+      cl_arg_types[7] = &ffi_type_uint;\n+      cl_arg_types[8] = &ffi_type_double;\n+      cl_arg_types[9] = &ffi_type_uint;\n+      cl_arg_types[10] = &ffi_type_uint;\n+      cl_arg_types[11] = &ffi_type_float;\n+      cl_arg_types[12] = &ffi_type_uint;\n+      cl_arg_types[13] = &ffi_type_uint;\n+      cl_arg_types[14] = &ffi_type_uint;\n+      cl_arg_types[15] = &ffi_type_uint;\n+      cl_arg_types[16] = NULL;   \n \n-      cl_arg_types[0] = &ffi_type_sint;\n+      /* Initialize the cif */\n+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n+\n+      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,\n+\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n+      \n+      CHECK((*((closure_test_type)(&cl)))\n+\t    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, \n+\t     19, 21, 1) == 680);\n+    }\n+\n+    {\n+\n+      cl_arg_types[0] = &ffi_type_float;\n       cl_arg_types[1] = &ffi_type_float;\n-      cl_arg_types[2] = NULL;\n+      cl_arg_types[2] = &ffi_type_float;\n+      cl_arg_types[3] = &ffi_type_float;\n+      cl_arg_types[4] = &ffi_type_sshort;\n+      cl_arg_types[5] = &ffi_type_float;\n+      cl_arg_types[6] = &ffi_type_float;\n+      cl_arg_types[7] = &ffi_type_uint;\n+      cl_arg_types[8] = &ffi_type_double;\n+      cl_arg_types[9] = &ffi_type_uint;\n+      cl_arg_types[10] = &ffi_type_uint;\n+      cl_arg_types[11] = &ffi_type_float;\n+      cl_arg_types[12] = &ffi_type_uint;\n+      cl_arg_types[13] = &ffi_type_uint;\n+      cl_arg_types[14] = &ffi_type_uint;\n+      cl_arg_types[15] = &ffi_type_uint;\n+      cl_arg_types[16] = NULL;\n       \n       /* Initialize the cif */\n-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, \n-\t    \t         &ffi_type_sint, cl_arg_types) == FFI_OK);\n+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n+\n+      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,\n+\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n+      \n+      CHECK((*((closure_test_type1)(&cl)))\n+\t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n+\t     19, 21, 1) == 255);\n+    }\n+\n+    {\n+\n+      cl_arg_types[0] = &ffi_type_double;\n+      cl_arg_types[1] = &ffi_type_double;\n+      cl_arg_types[2] = &ffi_type_double;\n+      cl_arg_types[3] = &ffi_type_double;\n+      cl_arg_types[4] = &ffi_type_sshort;\n+      cl_arg_types[5] = &ffi_type_double;\n+      cl_arg_types[6] = &ffi_type_double;\n+      cl_arg_types[7] = &ffi_type_uint;\n+      cl_arg_types[8] = &ffi_type_double;\n+      cl_arg_types[9] = &ffi_type_uint;\n+      cl_arg_types[10] = &ffi_type_uint;\n+      cl_arg_types[11] = &ffi_type_float;\n+      cl_arg_types[12] = &ffi_type_uint;\n+      cl_arg_types[13] = &ffi_type_float;\n+      cl_arg_types[14] = &ffi_type_uint;\n+      cl_arg_types[15] = &ffi_type_uint;\n+      cl_arg_types[16] = NULL;\n+      \n+      /* Initialize the cif */\n+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n+\n+      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn2,\n+\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n+\n+      CHECK((*((closure_test_type2)(&cl)))\n+\t    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n+\t     19.0, 21, 1) == 255);\n \n-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,\n-\t\t\t     (void *) 3 /* userdata */)\n-\t    == FFI_OK);\n-      CHECK((*((closure_test_type)(&cl)))(1, 2.0) == 6);\n     }\n+\n+    {\n+\n+      cl_arg_types[0] = &ffi_type_float;\n+      cl_arg_types[1] = &ffi_type_float;\n+      cl_arg_types[2] = &ffi_type_float;\n+      cl_arg_types[3] = &ffi_type_float;\n+      cl_arg_types[4] = &ffi_type_float;\n+      cl_arg_types[5] = &ffi_type_float;\n+      cl_arg_types[6] = &ffi_type_float;\n+      cl_arg_types[7] = &ffi_type_float;\n+      cl_arg_types[8] = &ffi_type_double;\n+      cl_arg_types[9] = &ffi_type_uint;\n+      cl_arg_types[10] = &ffi_type_float;\n+      cl_arg_types[11] = &ffi_type_float;\n+      cl_arg_types[12] = &ffi_type_uint;\n+      cl_arg_types[13] = &ffi_type_float;\n+      cl_arg_types[14] = &ffi_type_float;\n+      cl_arg_types[15] = &ffi_type_uint;\n+      cl_arg_types[16] = NULL;\n+      \n+      /* Initialize the cif */\n+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n+\n+      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn3,\n+\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n+      \n+      CHECK((*((closure_test_type3)(&cl)))\n+\t    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n+\t     19.19, 21.21, 1) == 135);\n+    }\n+\n+    (void) puts(\"\\nFinished FFI_CLOSURES\\n\");\n+\n # endif\n \n   /* If we arrived here, all is good */"}, {"sha": "ea1a14e8f65dc1a32c2146b5f54181c23114940f", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5102af84468663e23a5687ef8bc118c89030a5/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5102af84468663e23a5687ef8bc118c89030a5/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=7b5102af84468663e23a5687ef8bc118c89030a5", "patch": "@@ -137,11 +137,20 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n-\tcase FFI_TYPE_DOUBLE:\n-\t  if ((*ptr)->type == FFI_TYPE_FLOAT)\n-\t    double_tmp = *(float *)*p_argv;\n+\t  double_tmp = *(float *)*p_argv;\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      *(float *)next_arg = (float)double_tmp;\n+\t      next_arg += 1;\n+\t    }\n \t  else\n-\t    double_tmp = *(double *)*p_argv;\n+\t    *fpr_base++ = double_tmp;\n+\t  fparg_count++;\n+\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  double_tmp = *(double *)*p_argv;\n \n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n \t    {\n@@ -320,6 +329,10 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n+\t  fparg_count++;\n+\t  /* floating singles are not 8-aligned on stack */\n+\t  break;\n+\n \tcase FFI_TYPE_DOUBLE:\n \t  fparg_count++;\n \t  /* If this FP arg is going on the stack, it must be\n@@ -612,20 +625,15 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \tcase FFI_TYPE_FLOAT:\n \t    /* unfortunately float values are stored as doubles\n              * in the ffi_closure_SYSV code (since we don't check\n-             * the type in that routine).  This is also true\n-             * of floats passed on the outgoing parameter stack.\n-             * Also, on the outgoing stack all values are aligned\n-             * to 8\n-             *\n-             * Don't you just love the simplicity of this ABI!\n+             * the type in that routine).\n              */\n \n           /* there are 8 64bit floating point registers */\n \n           if (nf < 8) {\n-\t     temp = *(double*)pfr;\n+             temp = *(double*)pfr;\n              *(float*)pfr = (float)temp;\n-\t     avalue[i] = pfr;\n+             avalue[i] = pfr;\n              nf++;\n              pfr+=2;\n           } else {\n@@ -634,12 +642,9 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n              * parameter stack.  This is probably a really\n              * naughty thing to do but...\n              */\n-\t     if (((long)pst) & 4) pst++;\n-\t     temp = *(double*)pst;\n-             *(float*)pst = (float)temp;\n \t     avalue[i] = pst;\n              nf++;\n-             pst+=2;\n+             pst+=1;\n           }\n \t  break;\n "}]}