{"sha": "3b9fa2df5782f5f28247f705dce8393279bf6cbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I5ZmEyZGY1NzgyZjVmMjgyNDdmNzA1ZGNlODM5MzI3OWJmNmNiZg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-12-13T10:24:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:24:30Z"}, "message": "exp_aggr.adb (Build_Record_Aggr_Code): If there is an aggregate for a limited ancestor part...\n\n2007-12-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Build_Record_Aggr_Code): If there is an aggregate for a\n\tlimited ancestor part, initialize controllers of enclosing record\n\tbefore expanding ancestor aggregate.\n\t(Gen_Assign): If a component of the aggregate is box-initialized, add\n\tcode to call Initialize if the component is controlled, and explicit\n\tassignment of null if the component is an access type.\n\n\tHandle properly aggregates for limited types that appear in object\n\tdeclarations when the aggregate contains controlled values such as\n\tprotected types.\n\tWhen expanding limited aggregates into individual components, do not\n\tcall Adjust on controlled components that are limited.\n\nFrom-SVN: r130828", "tree": {"sha": "f380a4b9454ef01b389a5e50b4c9428061c5fa4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f380a4b9454ef01b389a5e50b4c9428061c5fa4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b9fa2df5782f5f28247f705dce8393279bf6cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b9fa2df5782f5f28247f705dce8393279bf6cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b9fa2df5782f5f28247f705dce8393279bf6cbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b9fa2df5782f5f28247f705dce8393279bf6cbf/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0"}], "stats": {"total": 447, "additions": 252, "deletions": 195}, "files": [{"sha": "2dd0f0c9dd6322d73dd666ca244793058eb22cf4", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 252, "deletions": 195, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b9fa2df5782f5f28247f705dce8393279bf6cbf/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b9fa2df5782f5f28247f705dce8393279bf6cbf/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=3b9fa2df5782f5f28247f705dce8393279bf6cbf", "patch": "@@ -1063,25 +1063,48 @@ package body Exp_Aggr is\n \n          --  Ada 2005 (AI-287): In case of default initialized component, call\n          --  the initialization subprogram associated with the component type.\n+         --  If the component type is an access type, add an explicit null\n+         --  assignment, because for the back-end there is an initialization\n+         --  present for the whole aggregate, and no default initialization\n+         --  will take place.\n+\n+         --  In addition, if the component type is controlled, we must call\n+         --  its Initialize procedure explicitly, because there is no explicit\n+         --  object creation that will invoke it otherwise.\n \n          if No (Expr) then\n-            if Present (Base_Init_Proc (Etype (Ctype)))\n+            if Present (Base_Init_Proc (Base_Type (Ctype)))\n               or else Has_Task (Base_Type (Ctype))\n             then\n                Append_List_To (L,\n                  Build_Initialization_Call (Loc,\n                    Id_Ref            => Indexed_Comp,\n                    Typ               => Ctype,\n                    With_Default_Init => True));\n+\n+            elsif Is_Access_Type (Ctype) then\n+               Append_To (L,\n+                  Make_Assignment_Statement (Loc,\n+                     Name => Indexed_Comp,\n+                     Expression => Make_Null (Loc)));\n+            end if;\n+\n+            if Controlled_Type (Ctype) then\n+               Append_List_To (L,\n+                 Make_Init_Call (\n+                   Ref         => New_Copy_Tree (Indexed_Comp),\n+                   Typ         => Ctype,\n+                   Flist_Ref   => Find_Final_List (Current_Scope),\n+                   With_Attach => Make_Integer_Literal (Loc, 1)));\n             end if;\n \n          else\n             --  Now generate the assignment with no associated controlled\n-            --  actions since the target of the assignment may not have\n-            --  been initialized, it is not possible to Finalize it as\n-            --  expected by normal controlled assignment. The rest of the\n-            --  controlled actions are done manually with the proper\n-            --  finalization list coming from the context.\n+            --  actions since the target of the assignment may not have been\n+            --  initialized, it is not possible to Finalize it as expected by\n+            --  normal controlled assignment. The rest of the controlled\n+            --  actions are done manually with the proper finalization list\n+            --  coming from the context.\n \n             A :=\n               Make_OK_Assignment_Statement (Loc,\n@@ -1092,7 +1115,7 @@ package body Exp_Aggr is\n                Set_No_Ctrl_Actions (A);\n \n                --  If this is an aggregate for an array of arrays, each\n-               --  subaggregate will be expanded as well, and even with\n+               --  sub-aggregate will be expanded as well, and even with\n                --  No_Ctrl_Actions the assignments of inner components will\n                --  require attachment in their assignments to temporaries.\n                --  These temporaries must be finalized for each subaggregate,\n@@ -1115,8 +1138,8 @@ package body Exp_Aggr is\n             Append_To (L, A);\n \n             --  Adjust the tag if tagged (because of possible view\n-            --  conversions), unless compiling for the Java VM\n-            --  where tags are implicit.\n+            --  conversions), unless compiling for the Java VM where\n+            --  tags are implicit.\n \n             if Present (Comp_Type)\n               and then Is_Tagged_Type (Comp_Type)\n@@ -1153,6 +1176,7 @@ package body Exp_Aggr is\n \n             if Present (Comp_Type)\n               and then Controlled_Type (Comp_Type)\n+              and then not Is_Limited_Type (Comp_Type)\n               and then\n                 (not Is_Array_Type (Comp_Type)\n                    or else not Is_Controlled (Component_Type (Comp_Type))\n@@ -1230,9 +1254,9 @@ package body Exp_Aggr is\n          elsif Equal (L, H) then\n             return Gen_Assign (New_Copy_Tree (L), Expr);\n \n-         --  If H - L <= 2 then generate a sequence of assignments\n-         --  when we are processing the bottom most aggregate and it contains\n-         --  scalar components.\n+         --  If H - L <= 2 then generate a sequence of assignments when we are\n+         --  processing the bottom most aggregate and it contains scalar\n+         --  components.\n \n          elsif No (Next_Index (Index))\n            and then Scalar_Comp\n@@ -1292,9 +1316,9 @@ package body Exp_Aggr is\n                           Iteration_Scheme => L_Iteration_Scheme,\n                           Statements       => L_Body));\n \n-         --  A small optimization: if the aggregate is initialized with a\n-         --  box and the component type has no initialization procedure,\n-         --  remove the useless empty loop.\n+         --  A small optimization: if the aggregate is initialized with a box\n+         --  and the component type has no initialization procedure, remove the\n+         --  useless empty loop.\n \n          if Nkind (First (S)) = N_Loop_Statement\n            and then Is_Empty_List (Statements (First (S)))\n@@ -1490,11 +1514,13 @@ package body Exp_Aggr is\n                  Make_Integer_Literal (Loc, Uint_0))));\n       end if;\n \n-      --  We can skip this\n       --  STEP 1: Process component associations\n+\n       --  For those associations that may generate a loop, initialize\n       --  Loop_Actions to collect inserted actions that may be crated.\n \n+      --  Skip this if no component associations\n+\n       if No (Expressions (N)) then\n \n          --  STEP 1 (a): Sort the discrete choices\n@@ -1651,6 +1677,10 @@ package body Exp_Aggr is\n    -- Build_Record_Aggr_Code --\n    ----------------------------\n \n+   ----------------------------\n+   -- Build_Record_Aggr_Code --\n+   ----------------------------\n+\n    function Build_Record_Aggr_Code\n      (N                             : Node_Id;\n       Typ                           : Entity_Id;\n@@ -1673,10 +1703,11 @@ package body Exp_Aggr is\n       Comp_Expr : Node_Id;\n       Expr_Q    : Node_Id;\n \n-      Internal_Final_List : Node_Id;\n+      Internal_Final_List : Node_Id := Empty;\n \n       --  If this is an internal aggregate, the External_Final_List is an\n       --  expression for the controller record of the enclosing type.\n+\n       --  If the current aggregate has several controlled components, this\n       --  expression will appear in several calls to attach to the finali-\n       --  zation list, and it must not be shared.\n@@ -1693,15 +1724,15 @@ package body Exp_Aggr is\n       --  after the first do nothing.\n \n       function Ancestor_Discriminant_Value (Disc : Entity_Id) return Node_Id;\n-      --  Returns the value that the given discriminant of an ancestor\n-      --  type should receive (in the absence of a conflict with the\n-      --  value provided by an ancestor part of an extension aggregate).\n+      --  Returns the value that the given discriminant of an ancestor type\n+      --  should receive (in the absence of a conflict with the value provided\n+      --  by an ancestor part of an extension aggregate).\n \n       procedure Check_Ancestor_Discriminants (Anc_Typ : Entity_Id);\n-      --  Check that each of the discriminant values defined by the\n-      --  ancestor part of an extension aggregate match the corresponding\n-      --  values provided by either an association of the aggregate or\n-      --  by the constraint imposed by a parent type (RM95-4.3.2(8)).\n+      --  Check that each of the discriminant values defined by the ancestor\n+      --  part of an extension aggregate match the corresponding values\n+      --  provided by either an association of the aggregate or by the\n+      --  constraint imposed by a parent type (RM95-4.3.2(8)).\n \n       function Compatible_Int_Bounds\n         (Agg_Bounds : Node_Id;\n@@ -1747,8 +1778,8 @@ package body Exp_Aggr is\n          Save_Assoc   : Node_Id := Empty;\n \n       begin\n-         --  First check any discriminant associations to see if\n-         --  any of them provide a value for the discriminant.\n+         --  First check any discriminant associations to see if any of them\n+         --  provide a value for the discriminant.\n \n          if Present (Discriminant_Specifications (Parent (Current_Typ))) then\n             Assoc := First (Component_Associations (N));\n@@ -1760,9 +1791,10 @@ package body Exp_Aggr is\n \n                   Corresp_Disc := Corresponding_Discriminant (Aggr_Comp);\n                   while Present (Corresp_Disc) loop\n-                     --  If found a corresponding discriminant then return\n-                     --  the value given in the aggregate. (Note: this is\n-                     --  not correct in the presence of side effects. ???)\n+\n+                     --  If found a corresponding discriminant then return the\n+                     --  value given in the aggregate. (Note: this is not\n+                     --  correct in the presence of side effects. ???)\n \n                      if Disc = Corresp_Disc then\n                         return Duplicate_Subexpr (Expression (Assoc));\n@@ -1818,13 +1850,13 @@ package body Exp_Aggr is\n                         Assoc := Expression (Assoc);\n                      end if;\n \n-                     --  If the located association directly denotes\n-                     --  a discriminant, then use the value of a saved\n-                     --  association of the aggregate. This is a kludge\n-                     --  to handle certain cases involving multiple\n-                     --  discriminants mapped to a single discriminant\n-                     --  of a descendant. It's not clear how to locate the\n-                     --  appropriate discriminant value for such cases. ???\n+                     --  If the located association directly denotes a\n+                     --  discriminant, then use the value of a saved\n+                     --  association of the aggregate. This is a kludge to\n+                     --  handle certain cases involving multiple discriminants\n+                     --  mapped to a single discriminant of a descendant. It's\n+                     --  not clear how to locate the appropriate discriminant\n+                     --  value for such cases. ???\n \n                      if Is_Entity_Name (Assoc)\n                        and then Ekind (Entity (Assoc)) = E_Discriminant\n@@ -2141,7 +2173,7 @@ package body Exp_Aggr is\n          end if;\n \n          --  In the Has_Controlled component case, all the intermediate\n-         --  controllers must be initialized\n+         --  controllers must be initialized.\n \n          if Has_Controlled_Component (Typ)\n            and not Is_Limited_Ancestor_Expansion\n@@ -2328,8 +2360,8 @@ package body Exp_Aggr is\n          Target := Lhs;\n       end if;\n \n-      --  Deal with the ancestor part of extension aggregates\n-      --  or with the discriminants of the root type\n+      --  Deal with the ancestor part of extension aggregates or with the\n+      --  discriminants of the root type.\n \n       if Nkind (N) = N_Extension_Aggregate then\n          declare\n@@ -2349,12 +2381,12 @@ package body Exp_Aggr is\n                if Is_Constrained (Entity (A)) then\n                   Init_Typ := Entity (A);\n \n-               --  For an ancestor part given by an unconstrained type\n-               --  mark, create a subtype constrained by appropriate\n-               --  corresponding discriminant values coming from either\n-               --  associations of the aggregate or a constraint on\n-               --  a parent type. The subtype will be used to generate\n-               --  the correct default value for the ancestor part.\n+               --  For an ancestor part given by an unconstrained type mark,\n+               --  create a subtype constrained by appropriate corresponding\n+               --  discriminant values coming from either associations of the\n+               --  aggregate or a constraint on a parent type. The subtype will\n+               --  be used to generate the correct default value for the\n+               --  ancestor part.\n \n                elsif Has_Discriminants (Entity (A)) then\n                   declare\n@@ -2387,9 +2419,9 @@ package body Exp_Aggr is\n                          Defining_Identifier => Init_Typ,\n                          Subtype_Indication  => New_Indic);\n \n-                     --  Itypes must be analyzed with checks off\n-                     --  Declaration must have a parent for proper\n-                     --  handling of subsidiary actions.\n+                     --  Itypes must be analyzed with checks off Declaration\n+                     --  must have a parent for proper handling of subsidiary\n+                     --  actions.\n \n                      Set_Parent (Subt_Decl, N);\n                      Analyze (Subt_Decl, Suppress => All_Checks);\n@@ -2437,6 +2469,12 @@ package body Exp_Aggr is\n             then\n                Ancestor_Is_Expression := True;\n \n+               --  Set up  finalization data for enclosing record, because\n+               --  controlled subcomponents of the ancestor part will be\n+               --  attached to it.\n+\n+               Gen_Ctrl_Actions_For_Aggr;\n+\n                Append_List_To (L,\n                   Build_Record_Aggr_Code (\n                     N                             => Unqualify (A),\n@@ -2447,10 +2485,12 @@ package body Exp_Aggr is\n                     Is_Limited_Ancestor_Expansion => True));\n \n             --  If the ancestor part is an expression \"E\", we generate\n+\n             --     T(tmp) := E;\n+\n             --  In Ada 2005, this includes the case of a (possibly qualified)\n             --  limited function call. The assignment will turn into a\n-            --  build-in-place function call (see\n+            --  build-in-place function call (for further details, see\n             --  Make_Build_In_Place_Call_In_Assignment).\n \n             else\n@@ -2521,7 +2561,9 @@ package body Exp_Aggr is\n \n                --  Call Adjust manually\n \n-               if Controlled_Type (Etype (A)) then\n+               if Controlled_Type (Etype (A))\n+                 and then not Is_Limited_Type (Etype (A))\n+               then\n                   Append_List_To (Assign,\n                     Make_Adjust_Call (\n                       Ref         => New_Copy_Tree (Ref),\n@@ -2649,7 +2691,7 @@ package body Exp_Aggr is\n       while Present (Comp) loop\n          Selector := Entity (First (Choices (Comp)));\n \n-         --  Ada 2005 (AI-287): For each default-initialized component genarate\n+         --  Ada 2005 (AI-287): For each default-initialized component generate\n          --  a call to the corresponding IP subprogram if available.\n \n          if Box_Present (Comp)\n@@ -2705,6 +2747,7 @@ package body Exp_Aggr is\n            or else Nkind (N) = N_Extension_Aggregate\n          then\n             --  All the discriminants have now been assigned\n+\n             --  This is now a good moment to initialize and attach all the\n             --  controllers. Their position may depend on the discriminants.\n \n@@ -2724,8 +2767,8 @@ package body Exp_Aggr is\n                Expr_Q := Expression (Comp);\n             end if;\n \n-            --  The controller is the one of the parent type defining\n-            --  the component (in case of inherited components).\n+            --  The controller is the one of the parent type defining the\n+            --  component (in case of inherited components).\n \n             if Controlled_Type (Comp_Type) then\n                Internal_Final_List :=\n@@ -2758,11 +2801,11 @@ package body Exp_Aggr is\n                --  an object declaration:\n \n                --    type Arr_Typ is array (Integer range <>) of ...;\n-               --\n+\n                --    type Rec_Typ (...) is record\n                --       Obj_Arr_Typ : Arr_Typ (A .. B);\n                --    end record;\n-               --\n+\n                --    Obj_Rec_Typ : Rec_Typ := (...,\n                --      Obj_Arr_Typ => (X => (...), Y => (...)));\n \n@@ -2895,11 +2938,14 @@ package body Exp_Aggr is\n                end if;\n \n                --  Adjust and Attach the component to the proper controller\n+\n                --     Adjust (tmp.comp);\n                --     Attach_To_Final_List (tmp.comp,\n                --       comp_typ (tmp)._record_controller.f)\n \n-               if Controlled_Type (Comp_Type) then\n+               if Controlled_Type (Comp_Type)\n+                 and then not Is_Limited_Type (Comp_Type)\n+               then\n                   Append_List_To (L,\n                     Make_Adjust_Call (\n                       Ref         => New_Copy_Tree (Comp_Expr),\n@@ -2952,8 +2998,8 @@ package body Exp_Aggr is\n                       Reason => CE_Discriminant_Check_Failed));\n \n                else\n-                  --  Find self-reference in previous discriminant\n-                  --  assignment, and replace with proper expression.\n+                  --  Find self-reference in previous discriminant assignment,\n+                  --  and replace with proper expression.\n \n                   declare\n                      Ass : Node_Id;\n@@ -3092,8 +3138,8 @@ package body Exp_Aggr is\n                  Flist,\n                  Associated_Final_Chain (Base_Type (Access_Type)));\n \n-            --  ??? Dubious actual for Obj: expect 'the original object\n-            --  being initialized'\n+            --  ??? Dubious actual for Obj: expect 'the original object being\n+            --  initialized'\n \n             if Has_Task (Typ) then\n                Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n@@ -3109,8 +3155,8 @@ package body Exp_Aggr is\n              (Aggr, Typ, Occ, Flist,\n               Associated_Final_Chain (Base_Type (Access_Type))));\n \n-         --  ??? Dubious actual for Obj: expect 'the original object\n-         --  being initialized'\n+         --  ??? Dubious actual for Obj: expect 'the original object being\n+         --  initialized'\n \n       end if;\n    end Convert_Aggr_In_Allocator;\n@@ -3120,9 +3166,9 @@ package body Exp_Aggr is\n    --------------------------------\n \n    procedure Convert_Aggr_In_Assignment (N : Node_Id) is\n-      Aggr : Node_Id             := Expression (N);\n-      Typ  : constant Entity_Id  := Etype (Aggr);\n-      Occ  : constant Node_Id    := New_Copy_Tree (Name (N));\n+      Aggr : Node_Id            := Expression (N);\n+      Typ  : constant Entity_Id := Etype (Aggr);\n+      Occ  : constant Node_Id   := New_Copy_Tree (Name (N));\n \n    begin\n       if Nkind (Aggr) = N_Qualified_Expression then\n@@ -3237,8 +3283,13 @@ package body Exp_Aggr is\n       --  the finalization list of the return must be moved to the caller's\n       --  finalization list to complete the return.\n \n+      --  However, if the aggregate is limited, it is built in place, and the\n+      --  controlled components are not assigned to intermediate temporaries\n+      --  so there is no need for a transient scope in this case either.\n+\n       if Requires_Transient_Scope (Typ)\n         and then Ekind (Current_Scope) /= E_Return_Statement\n+        and then not Is_Limited_Type (Typ)\n       then\n          Establish_Transient_Scope (Aggr, Sec_Stack =>\n            Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n@@ -3250,7 +3301,7 @@ package body Exp_Aggr is\n    end Convert_Aggr_In_Object_Decl;\n \n    -------------------------------------\n-   -- Convert_array_Aggr_In_Allocator --\n+   -- Convert_Array_Aggr_In_Allocator --\n    -------------------------------------\n \n    procedure Convert_Array_Aggr_In_Allocator\n@@ -3319,8 +3370,8 @@ package body Exp_Aggr is\n          end;\n       end if;\n \n-      --  Just set the Delay flag in the cases where the transformation\n-      --  will be done top down from above.\n+      --  Just set the Delay flag in the cases where the transformation will be\n+      --  done top down from above.\n \n       if False\n \n@@ -3356,37 +3407,50 @@ package body Exp_Aggr is\n          --  in place within the caller's scope).\n \n          or else\n-          (Is_Inherently_Limited_Type (Typ)\n-            and then\n-              (Nkind (Parent (Parent_Node)) = N_Extended_Return_Statement\n-                or else Nkind (Parent_Node) = N_Simple_Return_Statement))\n+           (Is_Inherently_Limited_Type (Typ)\n+             and then\n+               (Nkind (Parent (Parent_Node)) = N_Extended_Return_Statement\n+                  or else Nkind (Parent_Node) = N_Simple_Return_Statement))\n       then\n          Set_Expansion_Delayed (N);\n          return;\n       end if;\n \n       if Requires_Transient_Scope (Typ) then\n-         Establish_Transient_Scope (N, Sec_Stack =>\n-              Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n+         Establish_Transient_Scope\n+           (N, Sec_Stack =>\n+                 Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n       end if;\n \n-      --  Create the temporary\n-\n-      Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+      --  If the aggregate is non-limited, create a temporary. If it is\n+      --  limited and the context is an assignment, this is a subaggregate\n+      --  for an enclosing aggregate being expanded. It must be built in place,\n+      --  so use the target of the current assignment.\n \n-      Instr :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Temp,\n-          Object_Definition => New_Occurrence_Of (Typ, Loc));\n+      if Is_Limited_Type (Typ)\n+        and then Nkind (Parent (N)) = N_Assignment_Statement\n+      then\n+         Target_Expr := New_Copy_Tree (Name (Parent (N)));\n+         Insert_Actions\n+           (Parent (N), Build_Record_Aggr_Code (N, Typ, Target_Expr));\n+         Rewrite (Parent (N), Make_Null_Statement (Loc));\n \n-      Set_No_Initialization (Instr);\n-      Insert_Action (N, Instr);\n-      Initialize_Discriminants (Instr, Typ);\n-      Target_Expr := New_Occurrence_Of (Temp, Loc);\n+      else\n+         Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n \n-      Insert_Actions (N, Build_Record_Aggr_Code (N, Typ, Target_Expr));\n-      Rewrite (N, New_Occurrence_Of (Temp, Loc));\n-      Analyze_And_Resolve (N, Typ);\n+         Instr :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+         Set_No_Initialization (Instr);\n+         Insert_Action (N, Instr);\n+         Initialize_Discriminants (Instr, Typ);\n+         Target_Expr := New_Occurrence_Of (Temp, Loc);\n+         Insert_Actions (N, Build_Record_Aggr_Code (N, Typ, Target_Expr));\n+         Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+         Analyze_And_Resolve (N, Typ);\n+      end if;\n    end Convert_To_Assignments;\n \n    ---------------------------\n@@ -3403,21 +3467,21 @@ package body Exp_Aggr is\n       Static_Components : Boolean := True;\n \n       procedure Check_Static_Components;\n-      --  Check whether all components of the aggregate are compile-time\n-      --  known values, and can be passed as is to the back-end without\n-      --  further expansion.\n+      --  Check whether all components of the aggregate are compile-time known\n+      --  values, and can be passed as is to the back-end without further\n+      --  expansion.\n \n       function Flatten\n         (N   : Node_Id;\n          Ix  : Node_Id;\n          Ixb : Node_Id) return Boolean;\n-      --  Convert the aggregate into a purely positional form if possible.\n-      --  On entry the bounds of all dimensions are known to be static,\n-      --  and the total number of components is safe enough to expand.\n+      --  Convert the aggregate into a purely positional form if possible. On\n+      --  entry the bounds of all dimensions are known to be static, and the\n+      --  total number of components is safe enough to expand.\n \n       function Is_Flat (N : Node_Id; Dims : Int) return Boolean;\n-      --  Return True iff the array N is flat (which is not rivial\n-      --  in the case of multidimensionsl aggregates).\n+      --  Return True iff the array N is flat (which is not rivial in the case\n+      --  of multidimensionsl aggregates).\n \n       -----------------------------\n       -- Check_Static_Components --\n@@ -3505,8 +3569,8 @@ package body Exp_Aggr is\n             return False;\n          end if;\n \n-         --  Determine if set of alternatives is suitable for conversion\n-         --  and build an array containing the values in sequence.\n+         --  Determine if set of alternatives is suitable for conversion and\n+         --  build an array containing the values in sequence.\n \n          declare\n             Vals : array (UI_To_Int (Lov) .. UI_To_Int (Hiv))\n@@ -3723,8 +3787,8 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      --  Do not convert to positional if controlled components are\n-      --  involved since these require special processing\n+      --  Do not convert to positional if controlled components are involved\n+      --  since these require special processing\n \n       if Has_Controlled_Component (Typ) then\n          return;\n@@ -3900,10 +3964,10 @@ package body Exp_Aggr is\n             end loop;\n \n          else\n-            --  We know the aggregate type is unconstrained and the\n-            --  aggregate is not processable by the back end, therefore\n-            --  not necessarily positional. Retrieve the bounds of each\n-            --  dimension as computed earlier.\n+            --  We know the aggregate type is unconstrained and the aggregate\n+            --  is not processable by the back end, therefore not necessarily\n+            --  positional. Retrieve each dimension bounds (computed earlier).\n+            --  earlier.\n \n             for D in 1 .. Number_Dimensions (Typ) loop\n                Append (\n@@ -3955,7 +4019,7 @@ package body Exp_Aggr is\n          --    [constraint_error when\n          --      Aggr_Lo <= Aggr_Hi and then\n          --        (Aggr_Lo < Ind_Lo or else Aggr_Hi > Ind_Hi)]\n-         --\n+\n          --  As an optimization try to see if some tests are trivially vacuos\n          --  because we are comparing an expression against itself.\n \n@@ -4024,16 +4088,15 @@ package body Exp_Aggr is\n          --  The index type for this dimension.xxx\n \n          Cond  : Node_Id := Empty;\n-\n          Assoc : Node_Id;\n          Expr  : Node_Id;\n \n       begin\n          --  If index checks are on generate the test\n-         --\n+\n          --    [constraint_error when\n          --      Aggr_Lo /= Sub_Lo or else Aggr_Hi /= Sub_Hi]\n-         --\n+\n          --  As an optimization try to see if some tests are trivially vacuos\n          --  because we are comparing an expression against itself. Also for\n          --  the first dimension the test is trivially vacuous because there\n@@ -4193,7 +4256,7 @@ package body Exp_Aggr is\n          Obj_Hi  : Node_Id;\n \n          function Is_Others_Aggregate (Aggr : Node_Id) return Boolean;\n-         --   Aggregates that consist of a single Others choice are safe\n+         --  Aggregates that consist of a single Others choice are safe\n          --  if the single expression is.\n \n          function Safe_Aggregate (Aggr : Node_Id) return Boolean;\n@@ -4446,8 +4509,8 @@ package body Exp_Aggr is\n                Need_To_Check := False;\n \n             else\n-               --  Count the number of discrete choices. Start with -1\n-               --  because the others choice does not count.\n+               --  Count the number of discrete choices. Start with -1 because\n+               --  the others choice does not count.\n \n                Nb_Choices := -1;\n                Assoc := First (Component_Associations (Sub_Aggr));\n@@ -4470,8 +4533,8 @@ package body Exp_Aggr is\n             Need_To_Check := False;\n          end if;\n \n-         --  If we are dealing with a positional sub-aggregate with an\n-         --  others choice then compute the number or positional elements.\n+         --  If we are dealing with a positional sub-aggregate with an others\n+         --  choice then compute the number or positional elements.\n \n          if Need_To_Check and then Present (Expressions (Sub_Aggr)) then\n             Expr := First (Expressions (Sub_Aggr));\n@@ -4529,9 +4592,9 @@ package body Exp_Aggr is\n          if not Need_To_Check then\n             Cond := Empty;\n \n-         --  If we are dealing with an aggregate containing an others\n-         --  choice and positional components, we generate the following test:\n-         --\n+         --  If we are dealing with an aggregate containing an others choice\n+         --  and positional components, we generate the following test:\n+\n          --    if Ind_Typ'Pos (Aggr_Lo) + (Nb_Elements - 1) >\n          --            Ind_Typ'Pos (Aggr_Hi)\n          --    then\n@@ -4559,9 +4622,9 @@ package body Exp_Aggr is\n                     Expressions    => New_List (\n                       Duplicate_Subexpr_Move_Checks (Aggr_Hi))));\n \n-         --  If we are dealing with an aggregate containing an others\n-         --  choice and discrete choices we generate the following test:\n-         --\n+         --  If we are dealing with an aggregate containing an others choice\n+         --  and discrete choices we generate the following test:\n+\n          --    [constraint_error when\n          --      Choices_Lo < Aggr_Lo or else Choices_Hi > Aggr_Hi];\n \n@@ -4674,16 +4737,16 @@ package body Exp_Aggr is\n             if not Range_Checks_Suppressed (Etype (Index_Constraint))\n               and then not Others_Present (J)\n             then\n-               --  We don't use Checks.Apply_Range_Check here because it\n-               --  emits a spurious check. Namely it checks that the range\n-               --  defined by the aggregate bounds is non empty. But we know\n-               --  this already if we get here.\n+               --  We don't use Checks.Apply_Range_Check here because it emits\n+               --  a spurious check. Namely it checks that the range defined by\n+               --  the aggregate bounds is non empty. But we know this already\n+               --  if we get here.\n \n                Check_Bounds (Aggr_Index_Range, Index_Constraint);\n             end if;\n \n-            --  Save the low and high bounds of the aggregate index as well\n-            --  as the index type for later use in checks (b) and (c) below.\n+            --  Save the low and high bounds of the aggregate index as well as\n+            --  the index type for later use in checks (b) and (c) below.\n \n             Aggr_Low  (J) := Low_Bound (Aggr_Index_Range);\n             Aggr_High (J) := High_Bound (Aggr_Index_Range);\n@@ -4697,8 +4760,8 @@ package body Exp_Aggr is\n \n       --  STEP 1b\n \n-      --  If an others choice is present check that no aggregate\n-      --  index is outside the bounds of the index constraint.\n+      --  If an others choice is present check that no aggregate index is\n+      --  outside the bounds of the index constraint.\n \n       Others_Check (N, 1);\n \n@@ -4713,10 +4776,10 @@ package body Exp_Aggr is\n \n       --  STEP 2\n \n-      --  Here we test for is packed array aggregate that we can handle\n-      --  at compile time. If so, return with transformation done. Note\n-      --  that we do this even if the aggregate is nested, because once\n-      --  we have done this processing, there is no more nested aggregate!\n+      --  Here we test for is packed array aggregate that we can handle at\n+      --  compile time. If so, return with transformation done. Note that we do\n+      --  this even if the aggregate is nested, because once we have done this\n+      --  processing, there is no more nested aggregate!\n \n       if Packed_Array_Aggregate_Handled (N) then\n          return;\n@@ -5142,19 +5205,19 @@ package body Exp_Aggr is\n                Expr_Q := Expression (C);\n             end if;\n \n-            --  Return true if the aggregate has any associations for\n-            --  tagged components that may require tag adjustment.\n-            --  These are cases where the source expression may have\n-            --  a tag that could differ from the component tag (e.g.,\n-            --  can occur for type conversions and formal parameters).\n-            --  (Tag adjustment is not needed if VM_Target because object\n-            --  tags are implicit in the JVM.)\n+            --  Return true if the aggregate has any associations for tagged\n+            --  components that may require tag adjustment.\n+\n+            --  These are cases where the source expression may have a tag that\n+            --  could differ from the component tag (e.g., can occur for type\n+            --  conversions and formal parameters). (Tag adjustment not needed\n+            --  if VM_Target because object tags are implicit in the machine.)\n \n             if Is_Tagged_Type (Etype (Expr_Q))\n               and then (Nkind (Expr_Q) = N_Type_Conversion\n                          or else (Is_Entity_Name (Expr_Q)\n-                                   and then\n-                                    Ekind (Entity (Expr_Q)) in Formal_Kind))\n+                                    and then\n+                                      Ekind (Entity (Expr_Q)) in Formal_Kind))\n               and then VM_Target = No_VM\n             then\n                Static_Components := False;\n@@ -5264,8 +5327,7 @@ package body Exp_Aggr is\n          Convert_To_Assignments (N, Typ);\n \n       --  If the tagged types covers interface types we need to initialize all\n-      --  the hidden components containing the pointers to secondary dispatch\n-      --  tables.\n+      --  hidden components containing pointers to secondary dispatch tables.\n \n       elsif Is_Tagged_Type (Typ) and then Has_Abstract_Interfaces (Typ) then\n          Convert_To_Assignments (N, Typ);\n@@ -5278,20 +5340,19 @@ package body Exp_Aggr is\n       elsif Has_Mutable_Components (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n-      --  If the type involved has any non-bit aligned components, then\n-      --  we are not sure that the back end can handle this case correctly.\n+      --  If the type involved has any non-bit aligned components, then we are\n+      --  not sure that the back end can handle this case correctly.\n \n       elsif Type_May_Have_Bit_Aligned_Components (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n-      --  In all other cases we generate a proper aggregate that\n-      --  can be handled by gigi.\n+      --  In all other cases, build a proper aggregate handlable by gigi\n \n       else\n          if Nkind (N) = N_Aggregate then\n \n-            --  If the aggregate is static and can be handled by the\n-            --  back-end, nothing left to do.\n+            --  If the aggregate is static and can be handled by the back-end,\n+            --  nothing left to do.\n \n             if Static_Components then\n                Set_Compile_Time_Known_Aggregate (N);\n@@ -5321,8 +5382,8 @@ package body Exp_Aggr is\n                Num_Gird     : Int := 0;\n \n                procedure Prepend_Stored_Values (T : Entity_Id);\n-               --  Scan the list of stored discriminants of the type, and\n-               --  add their values to the aggregate being built.\n+               --  Scan the list of stored discriminants of the type, and add\n+               --  their values to the aggregate being built.\n \n                ---------------------------\n                -- Prepend_Stored_Values --\n@@ -5358,8 +5419,7 @@ package body Exp_Aggr is\n             --  Start of processing for Generate_Aggregate_For_Derived_Type\n \n             begin\n-               --  Remove the associations for the  discriminant of\n-               --  the derived type.\n+               --  Remove the associations for the discriminant of derived type\n \n                First_Comp := First (Component_Associations (N));\n                while Present (First_Comp) loop\n@@ -5376,10 +5436,10 @@ package body Exp_Aggr is\n \n                --  Insert stored discriminant associations in the correct\n                --  order. If there are more stored discriminants than new\n-               --  discriminants, there is at least one new discriminant\n-               --  that constrains more than one of the stored discriminants.\n-               --  In this case we need to construct a proper subtype of\n-               --  the parent type, in order to supply values to all the\n+               --  discriminants, there is at least one new discriminant that\n+               --  constrains more than one of the stored discriminants. In\n+               --  this case we need to construct a proper subtype of the\n+               --  parent type, in order to supply values to all the\n                --  components. Otherwise there is one-one correspondence\n                --  between the constraints and the stored discriminants.\n \n@@ -5395,9 +5455,9 @@ package body Exp_Aggr is\n \n                if Num_Gird > Num_Disc then\n \n-                  --  Create a proper subtype of the parent type, which is\n-                  --  the proper implementation type for the aggregate, and\n-                  --  convert it to the intended target type.\n+                  --  Create a proper subtype of the parent type, which is the\n+                  --  proper implementation type for the aggregate, and convert\n+                  --  it to the intended target type.\n \n                   Discriminant := First_Stored_Discriminant (Base_Type (Typ));\n                   while Present (Discriminant) loop\n@@ -5434,8 +5494,8 @@ package body Exp_Aggr is\n                   Analyze (N);\n \n                --  Case where we do not have fewer new discriminants than\n-               --  stored discriminants, so in this case we can simply\n-               --  use the stored discriminants of the subtype.\n+               --  stored discriminants, so in this case we can simply use the\n+               --  stored discriminants of the subtype.\n \n                else\n                   Prepend_Stored_Values (Typ);\n@@ -5812,10 +5872,10 @@ package body Exp_Aggr is\n          --  Values of bounds if compile time known\n \n          function Get_Component_Val (N : Node_Id) return Uint;\n-         --  Given a expression value N of the component type Ctyp, returns\n-         --  A value of Csiz (component size) bits representing this value.\n-         --  If the value is non-static or any other reason exists why the\n-         --  value cannot be returned, then Not_Handled is raised.\n+         --  Given a expression value N of the component type Ctyp, returns a\n+         --  value of Csiz (component size) bits representing this value. If\n+         --  the value is non-static or any other reason exists why the value\n+         --  cannot be returned, then Not_Handled is raised.\n \n          -----------------------\n          -- Get_Component_Val --\n@@ -5831,9 +5891,9 @@ package body Exp_Aggr is\n \n             Analyze_And_Resolve (N, Ctyp);\n \n-            --  Must have a compile time value. String literals have to\n-            --  be converted into temporaries as well, because they cannot\n-            --  easily be converted into their bit representation.\n+            --  Must have a compile time value. String literals have to be\n+            --  converted into temporaries as well, because they cannot easily\n+            --  be converted into their bit representation.\n \n             if not Compile_Time_Known_Value (N)\n               or else Nkind (N) = N_String_Literal\n@@ -5878,18 +5938,17 @@ package body Exp_Aggr is\n             return False;\n          end if;\n \n-         --  At this stage we have a suitable aggregate for handling\n-         --  at compile time (the only remaining checks, are that the\n-         --  values of expressions in the aggregate are compile time\n-         --  known (check performed by Get_Component_Val), and that\n-         --  any subtypes or ranges are statically known.\n+         --  At this stage we have a suitable aggregate for handling at compile\n+         --  time (the only remaining checks are that the values of expressions\n+         --  in the aggregate are compile time known (check is performed by\n+         --  Get_Component_Val), and that any subtypes or ranges are statically\n+         --  known.\n \n-         --  If the aggregate is not fully positional at this stage,\n-         --  then convert it to positional form. Either this will fail,\n-         --  in which case we can do nothing, or it will succeed, in\n-         --  which case we have succeeded in handling the aggregate,\n-         --  or it will stay an aggregate, in which case we have failed\n-         --  to handle this case.\n+         --  If the aggregate is not fully positional at this stage, then\n+         --  convert it to positional form. Either this will fail, in which\n+         --  case we can do nothing, or it will succeed, in which case we have\n+         --  succeeded in handling the aggregate, or it will stay an aggregate,\n+         --  in which case we have failed to handle this case.\n \n          if Present (Component_Associations (N)) then\n             Convert_To_Positional\n@@ -5907,13 +5966,12 @@ package body Exp_Aggr is\n             --  The length of the array (number of elements)\n \n             Aggregate_Val : Uint;\n-            --  Value of aggregate. The value is set in the low order\n-            --  bits of this value. For the little-endian case, the\n-            --  values are stored from low-order to high-order and\n-            --  for the big-endian case the values are stored from\n-            --  high-order to low-order. Note that gigi will take care\n-            --  of the conversions to left justify the value in the big\n-            --  endian case (because of left justified modular type\n+            --  Value of aggregate. The value is set in the low order bits of\n+            --  this value. For the little-endian case, the values are stored\n+            --  from low-order to high-order and for the big-endian case the\n+            --  values are stored from high-order to low-order. Note that gigi\n+            --  will take care of the conversions to left justify the value in\n+            --  the big endian case (because of left justified modular type\n             --  processing), so we do not have to worry about that here.\n \n             Lit : Node_Id;\n@@ -5929,10 +5987,9 @@ package body Exp_Aggr is\n             --  Next expression from positional parameters of aggregate\n \n          begin\n-            --  For little endian, we fill up the low order bits of the\n-            --  target value. For big endian we fill up the high order\n-            --  bits of the target value (which is a left justified\n-            --  modular value).\n+            --  For little endian, we fill up the low order bits of the target\n+            --  value. For big endian we fill up the high order bits of the\n+            --  target value (which is a left justified modular value).\n \n             if Bytes_Big_Endian xor Debug_Flag_8 then\n                Shift := Csiz * (Len - 1);\n@@ -6054,9 +6111,9 @@ package body Exp_Aggr is\n    is\n       L1, L2, H1, H2 : Node_Id;\n    begin\n-      --  No sliding if the type of the object is not established yet, if\n-      --  it is an unconstrained type whose actual subtype comes from the\n-      --  aggregate, or if the two types are identical.\n+      --  No sliding if the type of the object is not established yet, if it is\n+      --  an unconstrained type whose actual subtype comes from the aggregate,\n+      --  or if the two types are identical.\n \n       if not Is_Array_Type (Obj_Type) then\n          return False;\n@@ -6242,8 +6299,8 @@ package body Exp_Aggr is\n                return False;\n \n             else\n-               --  The aggregate is static if all components are literals,\n-               --  or else all its components are static aggregates for the\n+               --  The aggregate is static if all components are literals, or\n+               --  else all its components are static aggregates for the\n                --  component type.\n \n                if Is_Array_Type (Comp_Type)"}]}