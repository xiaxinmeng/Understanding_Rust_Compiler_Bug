{"sha": "440eb8de8906dd789306f3497ade607adc410898", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQwZWI4ZGU4OTA2ZGQ3ODkzMDZmMzQ5N2FkZTYwN2FkYzQxMDg5OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-24T16:59:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-24T16:59:15Z"}, "message": "rx: Uncomplicate fp comparisons.\n\nIt turns out that the middle-end will happily take care of\ndoing the swapping and splitting of compound fp comparisons.\nNo need for us to replicate that here.\n\nFrom-SVN: r169169", "tree": {"sha": "6e029f556f05d3720f8de25266b46432c5c916c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e029f556f05d3720f8de25266b46432c5c916c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/440eb8de8906dd789306f3497ade607adc410898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/440eb8de8906dd789306f3497ade607adc410898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/440eb8de8906dd789306f3497ade607adc410898", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/440eb8de8906dd789306f3497ade607adc410898/comments", "author": null, "committer": null, "parents": [{"sha": "3ff79f9970dc8e5728403e800664573c49adb6da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff79f9970dc8e5728403e800664573c49adb6da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff79f9970dc8e5728403e800664573c49adb6da"}], "stats": {"total": 249, "additions": 28, "deletions": 221}, "files": [{"sha": "26edfae1db0d189f5056d5482b6e3ab7c06a7369", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440eb8de8906dd789306f3497ade607adc410898/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440eb8de8906dd789306f3497ade607adc410898/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=440eb8de8906dd789306f3497ade607adc410898", "patch": "@@ -1,3 +1,16 @@\n+2011-01-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/rx/predicates.md (rx_fp_comparison_operator): Don't accept\n+\tcompound unordered comparisons.\n+\t* config/rx/rx.c (rx_split_fp_compare): Remove.\n+\t* config/rx/rx-protos.h: Update.\n+\t* config/rx/rx.md (gcc_conds, rx_conds): Remove.\n+\t(cbranchsf4): Don't call rx_split_fp_compare.\n+\t(*cbranchsf4): Use rx_split_cbranch.\n+\t(*cmpsf): Don't accept \"i\" constraint.\n+\t(*conditional_branch): Only valid after reload.\n+\t(cstoresf4): Merge expander with insn.  Don't call rx_split_fp_compare.\n+\n 2011-01-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/47385"}, {"sha": "77b3353ac3e338ced850c4d53b7e06986a364b51", "filename": "gcc/config/rx/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fpredicates.md?ref=440eb8de8906dd789306f3497ade607adc410898", "patch": "@@ -287,9 +287,9 @@\n   (match_code \"eq,ne,lt,ge\")\n )\n \n-;; GT, LE, UNLE, UNGT omitted due to operand swap required.\n+;; GT and LE omitted due to operand swap required.\n (define_predicate \"rx_fp_comparison_operator\"\n-  (match_code \"eq,ne,lt,ge,ordered,unordered,uneq,unlt,unge,ltgt\")\n+  (match_code \"eq,ne,lt,ge,ordered,unordered\")\n )\n \n (define_predicate \"rshift_operator\""}, {"sha": "ad97c597675cd01e57a4527429fa743116e31289", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=440eb8de8906dd789306f3497ade607adc410898", "patch": "@@ -39,7 +39,6 @@ extern bool \t\trx_is_mode_dependent_addr (rtx);\n extern bool\t\trx_is_restricted_memory_address (rtx, Mmode);\n extern void\t\trx_notice_update_cc (rtx body, rtx insn);\n extern void\t\trx_split_cbranch (Mmode, Rcode, rtx, rtx, rtx);\n-extern bool\t\trx_split_fp_compare (Rcode, Rcode *, Rcode *);\n extern Mmode\t\trx_select_cc_mode (Rcode, rtx, rtx);\n extern bool\t\trx_match_ccmode (rtx, Mmode);\n #endif"}, {"sha": "f2429b74d280d9ba4d9943df002f328d0f396fc5", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=440eb8de8906dd789306f3497ade607adc410898", "patch": "@@ -2665,68 +2665,6 @@ rx_select_cc_mode (enum rtx_code cmp_code, rtx x, rtx y ATTRIBUTE_UNUSED)\n   return mode_from_flags (flags_from_code (cmp_code));\n }\n \n-/* Split the floating-point comparison IN into individual comparisons\n-   O1 and O2.  O2 may be UNKNOWN if there is no second comparison.\n-   Return true iff the comparison operands must be swapped.  */\n-\n-bool\n-rx_split_fp_compare (enum rtx_code in, enum rtx_code *o1, enum rtx_code *o2)\n-{\n-  enum rtx_code cmp1 = in, cmp2 = UNKNOWN;\n-  bool swap = false;\n-\n-  switch (in)\n-    {\n-    case ORDERED:\n-    case UNORDERED:\n-    case LT:\n-    case GE:\n-    case EQ:\n-    case NE:\n-      break;\n-\n-    case GT:\n-    case LE:\n-      cmp1 = swap_condition (cmp1);\n-      swap = true;\n-      break;\n-\n-    case UNEQ:\n-      cmp1 = UNORDERED;\n-      cmp2 = EQ;\n-      break;\n-    case UNLT:\n-      cmp1 = UNORDERED;\n-      cmp2 = LT;\n-      break;\n-    case UNGE:\n-      cmp1 = UNORDERED;\n-      cmp2 = GE;\n-      break;\n-    case UNLE:\n-      cmp1 = UNORDERED;\n-      cmp2 = GT;\n-      swap = true;\n-      break;\n-    case UNGT:\n-      cmp1 = UNORDERED;\n-      cmp2 = LE;\n-      swap = true;\n-      break;\n-    case LTGT:\n-      cmp1 = ORDERED;\n-      cmp2 = NE;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  *o1 = cmp1;\n-  *o2 = cmp2;\n-  return swap;\n-}\n-\n /* Split the conditional branch.  Emit (COMPARE C1 C2) into CC_REG with\n    CC_MODE, and use that in branches based on that compare.  */\n "}, {"sha": "9ab5f173bda8744b3fb8f25b8624f044f4c8c24e", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 13, "deletions": 156, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440eb8de8906dd789306f3497ade607adc410898/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=440eb8de8906dd789306f3497ade607adc410898", "patch": "@@ -29,16 +29,6 @@\n (define_mode_iterator register_modes\n   [(SF \"ALLOW_RX_FPU_INSNS\") (SI \"\") (HI \"\") (QI \"\")])\n \n-\n-;; Used to map RX condition names to GCC\n-;; condition names for builtin instructions.\n-(define_code_iterator gcc_conds [eq ne gt ge lt le gtu geu ltu leu\n-\t\t\t\tunge unlt uneq ltgt])\n-(define_code_attr rx_conds [(eq \"eq\") (ne \"ne\") (gt \"gt\") (ge \"ge\") (lt \"lt\")\n-\t\t\t    (le \"le\") (gtu \"gtu\") (geu \"geu\") (ltu \"ltu\")\n-\t\t\t    (leu \"leu\") (unge \"pz\") (unlt \"n\") (uneq \"o\")\n-\t\t\t    (ltgt \"no\")])\n-\n (define_constants\n   [\n    (SP_REG 0)\n@@ -259,101 +249,37 @@\n (define_expand \"cbranchsf4\"\n   [(set (pc)\n \t(if_then_else\n-\t  (match_operator 0 \"comparison_operator\"\n+\t  (match_operator 0 \"rx_fp_comparison_operator\"\n \t    [(match_operand:SF 1 \"register_operand\")\n-\t     (match_operand:SF 2 \"register_operand\")])\n-          (label_ref (match_operand 3 \"\"))\n+\t     (match_operand:SF 2 \"rx_source_operand\")])\n+\t  (label_ref (match_operand 3 \"\"))\n \t  (pc)))]\n   \"ALLOW_RX_FPU_INSNS\"\n-{\n-  enum rtx_code cmp1, cmp2;\n-\n-  /* If the comparison needs swapping of operands, do that now.\n-     Do not split the comparison in two yet.  */\n-  if (rx_split_fp_compare (GET_CODE (operands[0]), &cmp1, &cmp2))\n-    {\n-      rtx op1, op2;\n-\n-      if (cmp2 != UNKNOWN)\n-\t{\n-\t  gcc_assert (cmp1 == UNORDERED);\n-\t  if (cmp2 == GT)\n-\t    cmp1 = UNGT;\n-\t  else if (cmp2 == LE)\n-\t    cmp1 = UNLE;\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      op1 = operands[2];\n-      op2 = operands[1];\n-      operands[0] = gen_rtx_fmt_ee (cmp1, VOIDmode, op1, op2);\n-      operands[1] = op1;\n-      operands[2] = op2;\n-    }\n-})\n+)\n \n (define_insn_and_split \"*cbranchsf4\"\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 3 \"rx_fp_comparison_operator\"\n \t    [(match_operand:SF  0 \"register_operand\"  \"r\")\n-\t     (match_operand:SF  1 \"rx_source_operand\" \"rFiQ\")])\n+\t     (match_operand:SF  1 \"rx_source_operand\" \"rFQ\")])\n \t  (match_operand        2 \"label_ref_operand\" \"\")\n \t  (pc)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  enum rtx_code cmp0, cmp1, cmp2;\n-  rtx flags, lab1, lab2, over, x;\n-  bool swap;\n-\n-  cmp0 = GET_CODE (operands[3]);\n-  swap = rx_split_fp_compare (cmp0, &cmp1, &cmp2);\n-  gcc_assert (!swap);\n-\n-  flags = gen_rtx_REG (CC_Fmode, CC_REG);\n-  x = gen_rtx_COMPARE (CC_Fmode, operands[0], operands[1]);\n-  x = gen_rtx_SET (VOIDmode, flags, x);\n-  emit_insn (x);\n-\n-  over = NULL;\n-  lab1 = lab2 = operands[2];\n-\n-  /* The one case of LTGT needs to be split into cmp1 && cmp2.  */\n-  if (cmp0 == LTGT)\n-    {\n-      over = gen_label_rtx ();\n-      lab1 = gen_rtx_LABEL_REF (VOIDmode, over);\n-      cmp1 = reverse_condition_maybe_unordered (cmp1);\n-    }\n-\n-  /* Otherwise we split into cmp1 || cmp2.  */\n-  x = gen_rtx_fmt_ee (cmp1, VOIDmode, flags, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, lab1, pc_rtx);\n-  x = gen_rtx_SET (VOIDmode, pc_rtx, x);\n-  emit_jump_insn (x);\n-\n-  if (cmp2 != UNKNOWN)\n-    {\n-      x = gen_rtx_fmt_ee (cmp2, VOIDmode, flags, const0_rtx);\n-      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, lab2, pc_rtx);\n-      x = gen_rtx_SET (VOIDmode, pc_rtx, x);\n-      emit_jump_insn (x);\n-    }\n-\n-  if (over)\n-    emit_label (over);\n+  rx_split_cbranch (CC_Fmode, GET_CODE (operands[3]),\n+\t\t    operands[0], operands[1], operands[2]);\n   DONE;\n })\n \n (define_insn \"*cmpsf\"\n   [(set (reg:CC_F CC_REG)\n \t(compare:CC_F\n \t  (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n-\t  (match_operand:SF 1 \"rx_source_operand\" \"r,iF,Q\")))]\n+\t  (match_operand:SF 1 \"rx_source_operand\" \"r,F,Q\")))]\n   \"ALLOW_RX_FPU_INSNS && reload_completed\"\n   \"fcmp\\t%1, %0\"\n   [(set_attr \"timings\" \"11,11,33\")\n@@ -369,7 +295,7 @@\n \t    [(reg CC_REG) (const_int 0)])\n \t  (label_ref (match_operand 0 \"\" \"\"))\n \t  (pc)))]\n-  \"\"\n+  \"reload_completed\"\n   \"b%B1\\t%0\"\n   [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n                               ;; too hard to compute statically.\n@@ -750,95 +676,26 @@\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_expand \"cstoresf4\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (match_operator:SI 1 \"comparison_operator\"\n-\t\t    [(match_operand:SF 2 \"register_operand\" \"\")\n-\t\t     (match_operand:SF 3 \"register_operand\" \"\")]))\n-\t     (clobber (match_scratch:SI 4))])]\n-  \"ALLOW_RX_FPU_INSNS\"\n-{\n-  enum rtx_code cmp1, cmp2;\n-\n-  /* If the comparison needs swapping of operands, do that now.\n-     Do not split the comparison in two yet.  */\n-  if (rx_split_fp_compare (GET_CODE (operands[1]), &cmp1, &cmp2))\n-    {\n-      rtx op2, op3;\n-\n-      if (cmp2 != UNKNOWN)\n-\t{\n-\t  gcc_assert (cmp1 == UNORDERED);\n-\t  if (cmp2 == GT)\n-\t    cmp1 = UNGT;\n-\t  else if (cmp2 == LE)\n-\t    cmp1 = UNLE;\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      op2 = operands[3];\n-      op3 = operands[2];\n-      operands[0] = gen_rtx_fmt_ee (cmp1, VOIDmode, op2, op3);\n-      operands[2] = op2;\n-      operands[3] = op3;\n-    }\n-})\n-\n-(define_insn_and_split \"*cstoresf4\"\n+(define_insn_and_split \"cstoresf4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 4 \"rx_fp_comparison_operator\"\n+\t(match_operator:SI 1 \"rx_fp_comparison_operator\"\n \t [(match_operand:SF 2 \"register_operand\" \"r\")\n-\t  (match_operand:SF 3 \"rx_source_operand\" \"rFiQ\")]))\n-   (clobber (match_scratch:SI 1 \"=r\"))]\n+\t  (match_operand:SF 3 \"rx_source_operand\" \"rFQ\")]))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  enum rtx_code cmp0, cmp1, cmp2;\n   rtx flags, x;\n-  bool swap;\n-\n-  cmp0 = GET_CODE (operands[4]);\n-  swap = rx_split_fp_compare (cmp0, &cmp1, &cmp2);\n-  gcc_assert (!swap);\n \n   flags = gen_rtx_REG (CC_Fmode, CC_REG);\n   x = gen_rtx_COMPARE (CC_Fmode, operands[2], operands[3]);\n   x = gen_rtx_SET (VOIDmode, flags, x);\n   emit_insn (x);\n \n-  x = gen_rtx_fmt_ee (cmp1, SImode, flags, const0_rtx);\n+  x = gen_rtx_fmt_ee (GET_CODE (operands[1]), SImode, flags, const0_rtx);\n   x = gen_rtx_SET (VOIDmode, operands[0], x);\n   emit_insn (x);\n-\n-  if (cmp0 == LTGT)\n-    {\n-      /* The one case of LTGT needs to be split into ORDERED && NE.  */\n-      x = gen_rtx_fmt_ee (EQ, VOIDmode, flags, const0_rtx);\n-      x = gen_rtx_IF_THEN_ELSE (SImode, x, const0_rtx, operands[0]);\n-      x = gen_rtx_SET (VOIDmode, operands[0], x);\n-      emit_insn (x);\n-    }\n-  else if (cmp2 == EQ || cmp2 == NE)\n-    {\n-      /* Oring the two flags can be performed with a movcc operation.  */\n-      x = gen_rtx_fmt_ee (cmp2, VOIDmode, flags, const0_rtx);\n-      x = gen_rtx_IF_THEN_ELSE (SImode, x, const1_rtx, operands[0]);\n-      x = gen_rtx_SET (VOIDmode, operands[0], x);\n-      emit_insn (x);\n-    }\n-  else if (cmp2 != UNKNOWN)\n-    {\n-      /* We can't use movcc, but need to or in another compare.\n-\t Do this by storing the second operation into the scratch.  */\n-      x = gen_rtx_fmt_ee (cmp2, SImode, flags, const0_rtx);\n-      x = gen_rtx_SET (VOIDmode, operands[1], x);\n-      emit_insn (x);\n-\n-      emit_insn (gen_iorsi3 (operands[0], operands[0], operands[1]));\n-    }\n   DONE;\n })\n "}]}