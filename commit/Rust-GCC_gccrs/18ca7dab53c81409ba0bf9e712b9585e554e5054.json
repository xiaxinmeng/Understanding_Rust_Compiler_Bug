{"sha": "18ca7dab53c81409ba0bf9e712b9585e554e5054", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjYTdkYWI1M2M4MTQwOWJhMGJmOWU3MTJiOTU4NWU1NTRlNTA1NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-11T22:26:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-11T22:26:55Z"}, "message": "Initial revision\n\nFrom-SVN: r445", "tree": {"sha": "74c6ae082545d10b435be3e27e3351a5397dcc88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74c6ae082545d10b435be3e27e3351a5397dcc88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18ca7dab53c81409ba0bf9e712b9585e554e5054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ca7dab53c81409ba0bf9e712b9585e554e5054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18ca7dab53c81409ba0bf9e712b9585e554e5054", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ca7dab53c81409ba0bf9e712b9585e554e5054/comments", "author": null, "committer": null, "parents": [{"sha": "c27db2153867b1cf899bfa3ffe2bd16d90fa08e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c27db2153867b1cf899bfa3ffe2bd16d90fa08e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c27db2153867b1cf899bfa3ffe2bd16d90fa08e7"}], "stats": {"total": 843, "additions": 843, "deletions": 0}, "files": [{"sha": "4a696446ef6516127e7fa4bca707ba7620daeb2d", "filename": "gcc/explow.c", "status": "added", "additions": 843, "deletions": 0, "changes": 843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ca7dab53c81409ba0bf9e712b9585e554e5054/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ca7dab53c81409ba0bf9e712b9585e554e5054/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=18ca7dab53c81409ba0bf9e712b9585e554e5054", "patch": "@@ -0,0 +1,843 @@\n+/* Subroutines for manipulating rtx's in semantically interesting ways.\n+   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-codes.h\"\n+\n+/* Return an rtx for the sum of X and the integer C.  */\n+\n+rtx\n+plus_constant (x, c)\n+     register rtx x;\n+     register int c;\n+{\n+  register RTX_CODE code;\n+  register enum machine_mode mode;\n+  register rtx tem;\n+  int all_constant = 0;\n+\n+  if (c == 0)\n+    return x;\n+\n+ restart:\n+\n+  code = GET_CODE (x);\n+  mode = GET_MODE (x);\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      return gen_rtx (CONST_INT, VOIDmode, (INTVAL (x) + c));\n+\n+    case CONST_DOUBLE:\n+      {\n+\tint l1 = CONST_DOUBLE_LOW (x);\n+\tint h1 = CONST_DOUBLE_HIGH (x);\n+\tint l2 = c;\n+\tint h2 = c < 0 ? ~0 : 0;\n+\tint lv, hv;\n+\n+\tadd_double (l1, h1, l2, h2, &lv, &hv);\n+\n+\treturn immed_double_const (lv, hv, VOIDmode);\n+      }\n+\n+    case MEM:\n+      /* If this is a reference to the constant pool, try replacing it with\n+\t a reference to a new constant.  If the resulting address isn't\n+\t valid, don't return it because we have no way to validize it.  */\n+      if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n+\t{\n+\t  tem\n+\t    = force_const_mem (GET_MODE (x),\n+\t\t\t       plus_constant (get_pool_constant (XEXP (x, 0)),\n+\t\t\t\t\t      c));\n+\t  if (memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n+\t    return tem;\n+\t}\n+      break;\n+\n+    case CONST:\n+      /* If adding to something entirely constant, set a flag\n+\t so that we can add a CONST around the result.  */\n+      x = XEXP (x, 0);\n+      all_constant = 1;\n+      goto restart;\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      all_constant = 1;\n+      break;\n+\n+    case PLUS:\n+      /* The interesting case is adding the integer to a sum.\n+\t Look for constant term in the sum and combine\n+\t with C.  For an integer constant term, we make a combined\n+\t integer.  For a constant term that is not an explicit integer,\n+\t we cannot really combine, but group them together anyway.  */\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  c += INTVAL (XEXP (x, 0));\n+\t  x = XEXP (x, 1);\n+\t}\n+      else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  c += INTVAL (XEXP (x, 1));\n+\t  x = XEXP (x, 0);\n+\t}\n+      else if (CONSTANT_P (XEXP (x, 0)))\n+\treturn gen_rtx (PLUS, mode,\n+\t\t\tplus_constant (XEXP (x, 0), c),\n+\t\t\tXEXP (x, 1));\n+      else if (CONSTANT_P (XEXP (x, 1)))\n+\treturn gen_rtx (PLUS, mode,\n+\t\t\tXEXP (x, 0),\n+\t\t\tplus_constant (XEXP (x, 1), c));\n+    }\n+\n+  if (c != 0)\n+    x = gen_rtx (PLUS, mode, x, gen_rtx (CONST_INT, VOIDmode, c));\n+\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    return x;\n+  else if (all_constant)\n+    return gen_rtx (CONST, mode, x);\n+  else\n+    return x;\n+}\n+\n+/* This is the same a `plus_constant', except that it handles LO_SUM.  */\n+\n+rtx\n+plus_constant_for_output (x, c)\n+     register rtx x;\n+     register int c;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register enum machine_mode mode = GET_MODE (x);\n+  int all_constant = 0;\n+\n+  if (GET_CODE (x) == LO_SUM)\n+    return gen_rtx (LO_SUM, mode, XEXP (x, 0),\n+\t\t    plus_constant_for_output (XEXP (x, 1), c));\n+\n+  else\n+    return plus_constant (x, c);\n+}\n+\f\n+/* If X is a sum, return a new sum like X but lacking any constant terms.\n+   Add all the removed constant terms into *CONSTPTR.\n+   X itself is not altered.  The result != X if and only if\n+   it is not isomorphic to X.  */\n+\n+rtx\n+eliminate_constant_term (x, constptr)\n+     rtx x;\n+     rtx *constptr;\n+{\n+  register rtx x0, x1;\n+  rtx tem;\n+\n+  if (GET_CODE (x) != PLUS)\n+    return x;\n+\n+  /* First handle constants appearing at this level explicitly.  */\n+  if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && 0 != (tem = simplify_binary_operation (PLUS, GET_MODE (x), *constptr,\n+\t\t\t\t\t\tXEXP (x, 1)))\n+      && GET_CODE (tem) == CONST_INT)\n+    {\n+      *constptr = tem;\n+      return eliminate_constant_term (XEXP (x, 0), constptr);\n+    }\n+\n+  tem = const0_rtx;\n+  x0 = eliminate_constant_term (XEXP (x, 0), &tem);\n+  x1 = eliminate_constant_term (XEXP (x, 1), &tem);\n+  if ((x1 != XEXP (x, 1) || x0 != XEXP (x, 0))\n+      && 0 != (tem = simplify_binary_operation (PLUS, GET_MODE (x),\n+\t\t\t\t\t\t*constptr, tem))\n+      && GET_CODE (tem) == CONST_INT)\n+    {\n+      *constptr = tem;\n+      return gen_rtx (PLUS, GET_MODE (x), x0, x1);\n+    }\n+\n+  return x;\n+}\n+\n+/* Returns the insn that next references REG after INSN, or 0\n+   if REG is clobbered before next referenced or we cannot find\n+   an insn that references REG in a straight-line piece of code.  */\n+\n+rtx\n+find_next_ref (reg, insn)\n+     rtx reg;\n+     rtx insn;\n+{\n+  rtx next;\n+\n+  for (insn = NEXT_INSN (insn); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (GET_CODE (insn) == NOTE)\n+\tcontinue;\n+      if (GET_CODE (insn) == CODE_LABEL\n+\t  || GET_CODE (insn) == BARRIER)\n+\treturn 0;\n+      if (GET_CODE (insn) == INSN\n+\t  || GET_CODE (insn) == JUMP_INSN\n+\t  || GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  if (reg_set_p (reg, insn))\n+\t    return 0;\n+\t  if (reg_mentioned_p (reg, PATTERN (insn)))\n+\t    return insn;\n+\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t    {\n+\t      if (simplejump_p (insn))\n+\t\tnext = JUMP_LABEL (insn);\n+\t      else\n+\t\treturn 0;\n+\t    }\n+\t  if (GET_CODE (insn) == CALL_INSN\n+\t      && REGNO (reg) < FIRST_PSEUDO_REGISTER\n+\t      && call_used_regs[REGNO (reg)])\n+\t    return 0;\n+\t}\n+      else\n+\tabort ();\n+    }\n+  return 0;\n+}\n+\n+/* Return an rtx for the size in bytes of the value of EXP.  */\n+\n+rtx\n+expr_size (exp)\n+     tree exp;\n+{\n+  return expand_expr (size_in_bytes (TREE_TYPE (exp)),\n+\t\t      0, TYPE_MODE (sizetype), 0);\n+}\n+\f\n+/* Return a copy of X in which all memory references\n+   and all constants that involve symbol refs\n+   have been replaced with new temporary registers.\n+   Also emit code to load the memory locations and constants\n+   into those registers.\n+\n+   If X contains no such constants or memory references,\n+   X itself (not a copy) is returned.\n+\n+   If a constant is found in the address that is not a legitimate constant\n+   in an insn, it is left alone in the hope that it might be valid in the\n+   address.\n+\n+   X may contain no arithmetic except addition, subtraction and multiplication.\n+   Values returned by expand_expr with 1 for sum_ok fit this constraint.  */\n+\n+static rtx\n+break_out_memory_refs (x)\n+     register rtx x;\n+{\n+  if (GET_CODE (x) == MEM\n+      || (CONSTANT_P (x) && LEGITIMATE_CONSTANT_P (x)\n+\t  && GET_MODE (x) != VOIDmode))\n+    {\n+      register rtx temp = force_reg (GET_MODE (x), x);\n+      mark_reg_pointer (temp);\n+      x = temp;\n+    }\n+  else if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n+\t   || GET_CODE (x) == MULT)\n+    {\n+      register rtx op0 = break_out_memory_refs (XEXP (x, 0));\n+      register rtx op1 = break_out_memory_refs (XEXP (x, 1));\n+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n+\tx = gen_rtx (GET_CODE (x), Pmode, op0, op1);\n+    }\n+  return x;\n+}\n+\n+/* Given a memory address or facsimile X, construct a new address,\n+   currently equivalent, that is stable: future stores won't change it.\n+\n+   X must be composed of constants, register and memory references\n+   combined with addition, subtraction and multiplication:\n+   in other words, just what you can get from expand_expr if sum_ok is 1.\n+\n+   Works by making copies of all regs and memory locations used\n+   by X and combining them the same way X does.\n+   You could also stabilize the reference to this address\n+   by copying the address to a register with copy_to_reg;\n+   but then you wouldn't get indexed addressing in the reference.  */\n+\n+rtx\n+copy_all_regs (x)\n+     register rtx x;\n+{\n+  if (GET_CODE (x) == REG)\n+    {\n+      if (REGNO (x) != FRAME_POINTER_REGNUM)\n+\tx = copy_to_reg (x);\n+    }\n+  else if (GET_CODE (x) == MEM)\n+    x = copy_to_reg (x);\n+  else if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n+\t   || GET_CODE (x) == MULT)\n+    {\n+      register rtx op0 = copy_all_regs (XEXP (x, 0));\n+      register rtx op1 = copy_all_regs (XEXP (x, 1));\n+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n+\tx = gen_rtx (GET_CODE (x), Pmode, op0, op1);\n+    }\n+  return x;\n+}\n+\f\n+/* Return something equivalent to X but valid as a memory address\n+   for something of mode MODE.  When X is not itself valid, this\n+   works by copying X or subexpressions of it into registers.  */\n+\n+rtx\n+memory_address (mode, x)\n+     enum machine_mode mode;\n+     register rtx x;\n+{\n+  register rtx oldx;\n+\n+  /* By passing constant addresses thru registers\n+     we get a chance to cse them.  */\n+  if (! cse_not_expected && CONSTANT_P (x) && LEGITIMATE_CONSTANT_P (x))\n+    return force_reg (Pmode, x);\n+\n+  /* Accept a QUEUED that refers to a REG\n+     even though that isn't a valid address.\n+     On attempting to put this in an insn we will call protect_from_queue\n+     which will turn it into a REG, which is valid.  */\n+  if (GET_CODE (x) == QUEUED\n+      && GET_CODE (QUEUED_VAR (x)) == REG)\n+    return x;\n+\n+  /* We get better cse by rejecting indirect addressing at this stage.\n+     Let the combiner create indirect addresses where appropriate.\n+     For now, generate the code so that the subexpressions useful to share\n+     are visible.  But not if cse won't be done!  */\n+  oldx = x;\n+  if (! cse_not_expected && GET_CODE (x) != REG)\n+    x = break_out_memory_refs (x);\n+\n+  /* At this point, any valid address is accepted.  */\n+  GO_IF_LEGITIMATE_ADDRESS (mode, x, win);\n+\n+  /* If it was valid before but breaking out memory refs invalidated it,\n+     use it the old way.  */\n+  if (memory_address_p (mode, oldx))\n+    goto win2;\n+\n+  /* Perform machine-dependent transformations on X\n+     in certain cases.  This is not necessary since the code\n+     below can handle all possible cases, but machine-dependent\n+     transformations can make better code.  */\n+  LEGITIMIZE_ADDRESS (x, oldx, mode, win);\n+\n+  /* PLUS and MULT can appear in special ways\n+     as the result of attempts to make an address usable for indexing.\n+     Usually they are dealt with by calling force_operand, below.\n+     But a sum containing constant terms is special\n+     if removing them makes the sum a valid address:\n+     then we generate that address in a register\n+     and index off of it.  We do this because it often makes\n+     shorter code, and because the addresses thus generated\n+     in registers often become common subexpressions.  */\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx constant_term = const0_rtx;\n+      rtx y = eliminate_constant_term (x, &constant_term);\n+      if (constant_term == const0_rtx\n+\t  || ! memory_address_p (mode, y))\n+\treturn force_operand (x, 0);\n+\n+      y = gen_rtx (PLUS, GET_MODE (x), copy_to_reg (y), constant_term);\n+      if (! memory_address_p (mode, y))\n+\treturn force_operand (x, 0);\n+      return y;\n+    }\n+  if (GET_CODE (x) == MULT || GET_CODE (x) == MINUS)\n+    return force_operand (x, 0);\n+\n+  /* If we have a register that's an invalid address,\n+     it must be a hard reg of the wrong class.  Copy it to a pseudo.  */\n+  if (GET_CODE (x) == REG)\n+    return copy_to_reg (x);\n+\n+  /* Last resort: copy the value to a register, since\n+     the register is a valid address.  */\n+  return force_reg (Pmode, x);\n+\n+ win2:\n+  x = oldx;\n+ win:\n+  if (flag_force_addr && ! cse_not_expected && GET_CODE (x) != REG\n+      /* Don't copy an addr via a reg if it is one of our stack slots.  */\n+      && ! (GET_CODE (x) == PLUS\n+\t    && (XEXP (x, 0) == virtual_stack_vars_rtx\n+\t\t|| XEXP (x, 0) == virtual_incoming_args_rtx)))\n+    {\n+      if (general_operand (x, Pmode))\n+\treturn force_reg (Pmode, x);\n+      else\n+\treturn force_operand (x, 0);\n+    }\n+  return x;\n+}\n+\n+/* Like `memory_address' but pretend `flag_force_addr' is 0.  */\n+\n+rtx\n+memory_address_noforce (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  int ambient_force_addr = flag_force_addr;\n+  rtx val;\n+\n+  flag_force_addr = 0;\n+  val = memory_address (mode, x);\n+  flag_force_addr = ambient_force_addr;\n+  return val;\n+}\n+\n+/* Convert a mem ref into one with a valid memory address.\n+   Pass through anything else unchanged.  */\n+\n+rtx\n+validize_mem (ref)\n+     rtx ref;\n+{\n+  if (GET_CODE (ref) != MEM)\n+    return ref;\n+  if (memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n+    return ref;\n+  /* Don't alter REF itself, since that is probably a stack slot.  */\n+  return change_address (ref, GET_MODE (ref), XEXP (ref, 0));\n+}\n+\f\n+/* Return a modified copy of X with its memory address copied\n+   into a temporary register to protect it from side effects.\n+   If X is not a MEM, it is returned unchanged (and not copied).\n+   Perhaps even if it is a MEM, if there is no need to change it.  */\n+\n+rtx\n+stabilize (x)\n+     rtx x;\n+{\n+  register rtx addr;\n+  if (GET_CODE (x) != MEM)\n+    return x;\n+  addr = XEXP (x, 0);\n+  if (rtx_unstable_p (addr))\n+    {\n+      rtx temp = copy_all_regs (addr);\n+      rtx mem;\n+      if (GET_CODE (temp) != REG)\n+\ttemp = copy_to_reg (temp);\n+      mem = gen_rtx (MEM, GET_MODE (x), temp);\n+\n+      /* Mark returned memref with in_struct if it's in an array or\n+\t structure.  Copy const and volatile from original memref.  */\n+\n+      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (x) || GET_CODE (addr) == PLUS;\n+      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (x);\n+      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (x);\n+      return mem;\n+    }\n+  return x;\n+}\n+\f\n+/* Copy the value or contents of X to a new temp reg and return that reg.  */\n+\n+rtx\n+copy_to_reg (x)\n+     rtx x;\n+{\n+  register rtx temp = gen_reg_rtx (GET_MODE (x));\n+ \n+  /* If not an operand, must be an address with PLUS and MULT so\n+     do the computation.  */ \n+  if (! general_operand (x, VOIDmode))\n+    x = force_operand (x, temp);\n+  \n+  if (x != temp)\n+    emit_move_insn (temp, x);\n+\n+  return temp;\n+}\n+\n+/* Like copy_to_reg but always give the new register mode Pmode\n+   in case X is a constant.  */\n+\n+rtx\n+copy_addr_to_reg (x)\n+     rtx x;\n+{\n+  return copy_to_mode_reg (Pmode, x);\n+}\n+\n+/* Like copy_to_reg but always give the new register mode MODE\n+   in case X is a constant.  */\n+\n+rtx\n+copy_to_mode_reg (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  register rtx temp = gen_reg_rtx (mode);\n+  \n+  /* If not an operand, must be an address with PLUS and MULT so\n+     do the computation.  */ \n+  if (! general_operand (x, VOIDmode))\n+    x = force_operand (x, temp);\n+\n+  if (GET_MODE (x) != mode && GET_MODE (x) != VOIDmode)\n+    abort ();\n+  if (x != temp)\n+    emit_move_insn (temp, x);\n+  return temp;\n+}\n+\n+/* Load X into a register if it is not already one.\n+   Use mode MODE for the register.\n+   X should be valid for mode MODE, but it may be a constant which\n+   is valid for all integer modes; that's why caller must specify MODE.\n+\n+   The caller must not alter the value in the register we return,\n+   since we mark it as a \"constant\" register.  */\n+\n+rtx\n+force_reg (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  register rtx temp, insn;\n+\n+  if (GET_CODE (x) == REG)\n+    return x;\n+  temp = gen_reg_rtx (mode);\n+  insn = emit_move_insn (temp, x);\n+  /* Let optimizers know that TEMP's value never changes\n+     and that X can be substituted for it.  */\n+  if (CONSTANT_P (x))\n+    {\n+      rtx note = find_reg_note (insn, REG_EQUAL, 0);\n+\n+      if (note)\n+\tXEXP (note, 0) = x;\n+      else\n+\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, x, REG_NOTES (insn));\n+    }\n+  return temp;\n+}\n+\n+/* If X is a memory ref, copy its contents to a new temp reg and return\n+   that reg.  Otherwise, return X.  */\n+\n+rtx\n+force_not_mem (x)\n+     rtx x;\n+{\n+  register rtx temp;\n+  if (GET_CODE (x) != MEM || GET_MODE (x) == BLKmode)\n+    return x;\n+  temp = gen_reg_rtx (GET_MODE (x));\n+  emit_move_insn (temp, x);\n+  return temp;\n+}\n+\n+/* Copy X to TARGET (if it's nonzero and a reg)\n+   or to a new temp reg and return that reg.\n+   MODE is the mode to use for X in case it is a constant.  */\n+\n+rtx\n+copy_to_suggested_reg (x, target, mode)\n+     rtx x, target;\n+     enum machine_mode mode;\n+{\n+  register rtx temp;\n+\n+  if (target && GET_CODE (target) == REG)\n+    temp = target;\n+  else\n+    temp = gen_reg_rtx (mode);\n+\n+  emit_move_insn (temp, x);\n+  return temp;\n+}\n+\f\n+/* Adjust the stack pointer by ADJUST (an rtx for a number of bytes).\n+   This pops when ADJUST is positive.  ADJUST need not be constant.  */\n+\n+void\n+adjust_stack (adjust)\n+     rtx adjust;\n+{\n+  rtx temp;\n+  adjust = protect_from_queue (adjust, 0);\n+\n+  if (adjust == const0_rtx)\n+    return;\n+\n+  temp = expand_binop (Pmode,\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t       add_optab,\n+#else\n+\t\t       sub_optab,\n+#endif\n+\t\t       stack_pointer_rtx, adjust, stack_pointer_rtx, 0,\n+\t\t       OPTAB_LIB_WIDEN);\n+\n+  if (temp != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, temp);\n+}\n+\n+/* Adjust the stack pointer by minus ADJUST (an rtx for a number of bytes).\n+   This pushes when ADJUST is positive.  ADJUST need not be constant.  */\n+\n+void\n+anti_adjust_stack (adjust)\n+     rtx adjust;\n+{\n+  rtx temp;\n+  adjust = protect_from_queue (adjust, 0);\n+\n+  if (adjust == const0_rtx)\n+    return;\n+\n+  temp = expand_binop (Pmode,\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t       sub_optab,\n+#else\n+\t\t       add_optab,\n+#endif\n+\t\t       stack_pointer_rtx, adjust, stack_pointer_rtx, 0,\n+\t\t       OPTAB_LIB_WIDEN);\n+\n+  if (temp != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, temp);\n+}\n+\n+/* Round the size of a block to be pushed up to the boundary required\n+   by this machine.  SIZE is the desired size, which need not be constant.  */\n+\n+rtx\n+round_push (size)\n+     rtx size;\n+{\n+#ifdef STACK_BOUNDARY\n+  int align = STACK_BOUNDARY / BITS_PER_UNIT;\n+  if (align == 1)\n+    return size;\n+  if (GET_CODE (size) == CONST_INT)\n+    {\n+      int new = (INTVAL (size) + align - 1) / align * align;\n+      if (INTVAL (size) != new)\n+\tsize = gen_rtx (CONST_INT, VOIDmode, new);\n+    }\n+  else\n+    {\n+      size = expand_divmod (0, CEIL_DIV_EXPR, Pmode, size,\n+\t\t\t    gen_rtx (CONST_INT, VOIDmode, align),\n+\t\t\t    0, 1);\n+      size = expand_mult (Pmode, size,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, align),\n+\t\t\t  0, 1);\n+    }\n+#endif /* STACK_BOUNDARY */\n+  return size;\n+}\n+\f\n+/* Return an rtx representing the address of an area of memory dynamically\n+   pushed on the stack.  This region of memory is always aligned to\n+   a multiple of BIGGEST_ALIGNMENT.\n+\n+   Any required stack pointer alignment is preserved.\n+\n+   SIZE is an rtx representing the size of the area.\n+   TARGET is a place in which the address can be placed.  */\n+\n+rtx\n+allocate_dynamic_stack_space (size, target)\n+     rtx size;\n+     rtx target;\n+{\n+  /* Ensure the size is in the proper mode.  */\n+  if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n+    size = convert_to_mode (Pmode, size, 1);\n+\n+  /* We will need to ensure that the address we return is aligned to\n+     BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't\n+     always know its final value at this point in the compilation (it \n+     might depend on the size of the outgoing parameter lists, for\n+     example), so we must align the value to be returned in that case.\n+     (Note that STACK_DYNAMIC_OFFSET will have a default non-zero value if\n+     STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).\n+     We must also do an alignment operation on the returned value if\n+     the stack pointer alignment is less strict that BIGGEST_ALIGNMENT.\n+\n+     If we have to align, we must leave space in SIZE for the hole\n+     that might result from the alignment operation.  */\n+\n+#if defined (STACK_DYNAMIC_OFFSET) || defined(STACK_POINTER_OFFSET) || defined (ALLOCATE_OUTGOING_ARGS)\n+#define MUST_ALIGN\n+#endif\n+\n+#if ! defined (MUST_ALIGN) && (!defined(STACK_BOUNDARY) || STACK_BOUNDARY < BIGGEST_ALIGNMENT)\n+#define MUST_ALIGN\n+#endif\n+\n+#ifdef MUST_ALIGN\n+\n+  if (GET_CODE (size) == CONST_INT)\n+    size = gen_rtx (CONST_INT, VOIDmode,\n+\t\t    INTVAL (size) + (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1));\n+  else\n+    size = expand_binop (Pmode, add_optab, size,\n+\t\t\t gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t  BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n+\t\t\t 0, 1, OPTAB_LIB_WIDEN);\n+#endif\n+\n+#ifdef SETJMP_VIA_SAVE_AREA\n+  /* If setjmp restores regs from a save area in the stack frame,\n+     avoid clobbering the reg save area.  Note that the offset of\n+     virtual_incoming_args_rtx includes the preallocated stack args space.\n+     It would be no problem to clobber that, but it's on the wrong side\n+     of the old save area.  */\n+  {\n+    rtx dynamic_offset\n+      = expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n+\t\t      stack_pointer_rtx, 0, 1, OPTAB_LIB_WIDEN);\n+    size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n+\t\t\t 0, 1, OPTAB_LIB_WIDEN);\n+  }\n+#endif /* SETJMP_VIA_SAVE_AREA */\n+\n+  /* Round the size to a multiple of the required stack alignment.\n+     Since the stack if presumed to be rounded before this allocation,\n+     this will maintain the required alignment.\n+\n+     If the stack grows downward, we could save an insn by subtracting\n+     SIZE from the stack pointer and then aligning the stack pointer.\n+     The problem with this is that the stack pointer may be unaligned\n+     between the execution of the subtraction and alignment insns and\n+     some machines do not allow this.  Even on those that do, some\n+     signal handlers malfunction if a signal should occur between those\n+     insns.  Since this is an extremely rare event, we have no reliable\n+     way of knowing which systems have this problem.  So we avoid even\n+     momentarily mis-aligning the stack.  */\n+\n+  size = round_push (size);\n+\n+  do_pending_stack_adjust ();\n+\n+  if (target == 0)\n+    target = gen_reg_rtx (Pmode);\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  emit_move_insn (target, virtual_stack_dynamic_rtx);\n+#endif\n+\n+  /* Perform the required allocation from the stack.  Some systems do\n+     this differently than simply incrementing/decrementing from the\n+     stack pointer.  */\n+#ifdef HAVE_allocate_stack\n+  if (HAVE_allocate_stack)\n+    {\n+      enum machine_mode mode\n+\t= insn_operand_mode[(int) CODE_FOR_allocate_stack][0];\n+\n+      if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][0]\n+\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][0])\n+\t\t(size, mode)))\n+\tsize = copy_to_mode_reg (mode, size);\n+\n+      emit_insn (gen_allocate_stack (size));\n+    }\n+  else\n+#endif\n+    anti_adjust_stack (size);\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+  emit_move_insn (target, virtual_stack_dynamic_rtx);\n+#endif\n+\n+#ifdef MUST_ALIGN\n+  target = expand_divmod (0, CEIL_DIV_EXPR, Pmode, target,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t   BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\t  0, 1);\n+\n+  target = expand_mult (Pmode, target,\n+\t\t\tgen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\t0, 1);\n+#endif\n+  \n+  /* Some systems require a particular insn to refer to the stack\n+     to make the pages exist.  */\n+#ifdef HAVE_probe\n+  if (HAVE_probe)\n+    emit_insn (gen_probe ());\n+#endif\n+\n+  return target;\n+}\n+\f\n+/* Return an rtx representing the register or memory location\n+   in which a scalar value of data type VALTYPE\n+   was returned by a function call to function FUNC.\n+   FUNC is a FUNCTION_DECL node if the precise function is known,\n+   otherwise 0.  */\n+\n+rtx\n+hard_function_value (valtype, func)\n+     tree valtype;\n+     tree func;\n+{\n+  return FUNCTION_VALUE (valtype, func);\n+}\n+\n+/* Return an rtx representing the register or memory location\n+   in which a scalar value of mode MODE was returned by a library call.  */\n+\n+rtx\n+hard_libcall_value (mode)\n+     enum machine_mode mode;\n+{\n+  return LIBCALL_VALUE (mode);\n+}"}]}