{"sha": "be362a0d5ba42bee36bd339e25374100a9f1942c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzNjJhMGQ1YmE0MmJlZTM2YmQzMzllMjUzNzQxMDBhOWYxOTQyYw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-09-21T06:59:20Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-09-21T06:59:20Z"}, "message": "2002-09-21  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/Socket.java\n\t(sendUrgentData): New method.\n\t(getChannel): New method.\n\t* java/net/ServerSocket.java\n\t(getChannel): New method.\n\t(isBound): New method.\n\t* java/net/DatagramSocket.java\n\t(DatagramSocket): Two new methods.\n\t(bind): New method.\n\t(getChannel): New method.\n\t(isBound): New method.\n\t(send): Added newline to to make shorter lines.\n\t* java/net/PlainDatagramSocketImpl.java\n\t(mcastGrp): Added argument.\n\t(join): Use new mcastGrp.\n\t(leave): Use new mcastGrp.\n\t(joinGroup): New method.\n\t(leaveGroup): New method.\n\t* java/net/natPlainDatagramSocketImpl.cc\n\t(mcastGrp): Added argument, no yet really implemented.\n\t(getOption): Added newline for shorter lines.\n\t* java/net/natPlainSocketImpl.cc\n\t(read, setOption, getOption): Added newline for shorter lines.\n\nFrom-SVN: r57380", "tree": {"sha": "83851aefa46dabb8d83a414a2859a534a89184ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83851aefa46dabb8d83a414a2859a534a89184ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be362a0d5ba42bee36bd339e25374100a9f1942c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be362a0d5ba42bee36bd339e25374100a9f1942c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be362a0d5ba42bee36bd339e25374100a9f1942c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be362a0d5ba42bee36bd339e25374100a9f1942c/comments", "author": null, "committer": null, "parents": [{"sha": "84d7dd4a5361d64c2168b354b2c7c03b4f21a8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d7dd4a5361d64c2168b354b2c7c03b4f21a8f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d7dd4a5361d64c2168b354b2c7c03b4f21a8f5"}], "stats": {"total": 218, "additions": 205, "deletions": 13}, "files": [{"sha": "7f50578f476973cddc1d7e8012b77da34ac9776c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -1,3 +1,29 @@\n+2002-09-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/Socket.java\n+\t(sendUrgentData): New method.\n+\t(getChannel): New method.\n+\t* java/net/ServerSocket.java\n+\t(getChannel): New method.\n+\t(isBound): New method.\n+\t* java/net/DatagramSocket.java\n+\t(DatagramSocket): Two new methods.\n+\t(bind): New method.\n+\t(getChannel): New method.\n+\t(isBound): New method.\n+\t(send): Added newline to to make shorter lines.\n+\t* java/net/PlainDatagramSocketImpl.java\n+\t(mcastGrp): Added argument.\n+\t(join): Use new mcastGrp.\n+\t(leave): Use new mcastGrp.\n+\t(joinGroup): New method.\n+\t(leaveGroup): New method.\n+\t* java/net/natPlainDatagramSocketImpl.cc\n+\t(mcastGrp): Added argument, no yet really implemented.\n+\t(getOption): Added newline for shorter lines.\n+\t* java/net/natPlainSocketImpl.cc\n+\t(read, setOption, getOption): Added newline for shorter lines.\n+\n 2002-09-19  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/ClassLoader.java (resolveClass0): Set cause for"}, {"sha": "da97d6115c3340701ced0daf3d95133d9dfca761", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -1,6 +1,6 @@\n // DatagramSocket.java\n \n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -10,6 +10,7 @@\n \n package java.net;\n import java.io.IOException;\n+import java.nio.channels.DatagramChannel;\n \n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n@@ -26,11 +27,41 @@\n {\n   DatagramSocketImpl impl;\n \n+  DatagramChannel ch;\n+\n   public DatagramSocket() throws SocketException\n   {\n     this(0, null);\n   }\n \n+  /**\n+   * Creates a DatagramSocket from a specified DatagramSocketImpl instance\n+   *\n+   * @param impl The DatagramSocketImpl the socket will be created from\n+   * \n+   * @since 1.4\n+   */\n+  protected DatagramSocket (DatagramSocketImpl impl)\n+  {\n+    this.impl = impl;\n+  }\n+\n+  /**\n+   * Creates a datagram socket that is bound to a given socket address\n+   *\n+   * @param bindaddr The socket address to bind to\n+   *\n+   * @exception SocketException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  public DatagramSocket (SocketAddress bindaddr)\n+    throws SocketException\n+  {\n+    this (((InetSocketAddress) bindaddr).getPort (),\n+          ((InetSocketAddress) bindaddr).getAddress ());\n+  }\n+\n   /**\n    * Creates a datagram socket that is bound to a specific port\n    *\n@@ -84,6 +115,22 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n     impl.bind(port, laddr == null ? InetAddress.ANY_IF : laddr);\n   }\n \n+  /**\n+   * Binds the socket to the given socket addres\n+   *\n+   * @param address The socket address to bind to\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public void bind (SocketAddress address)\n+    throws SocketException\n+  {\n+    InetSocketAddress tmp = (InetSocketAddress) address;\n+    impl.bind (tmp.getPort (), tmp.getAddress ());\n+  }\n+  \n   /**\n    * Closes the datagram socket\n    */\n@@ -92,6 +139,16 @@ public void close()\n     impl.close();\n   }\n \n+  /**\n+   * Gets a datagram channel assoziated with the socket\n+   * \n+   * @since 1.4\n+   */\n+  public DatagramChannel getChannel()\n+  {\n+    return ch;\n+  }\n+\n   /**\n    * Returns the local address of the datagram socket\n    * \n@@ -199,7 +256,8 @@ public void send(DatagramPacket p) throws IOException\n \t  s.checkConnect(addr.getHostAddress(), p.getPort());\n       }\n \n-    // FIXME: if this is a subclass of MulticastSocket, use getTimeToLive for TTL val.\n+    // FIXME: if this is a subclass of MulticastSocket,\n+    // use getTimeToLive for TTL val.\n     impl.send(p);\n   }\n \n@@ -246,6 +304,25 @@ public void disconnect()\n     //impl.disconnect();\n   }\n \n+  /**\n+   * Returns the binding state of the socket\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isBound()\n+  {\n+    try\n+      {\n+        Object bindaddr = impl.getOption (SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException e)\n+      {\n+        return false;\n+      }\n+\n+    return true;\n+  }\n+\n   /**\n    * Returns the InetAddress the socket is connected to\n    * or null if the socket is not connected"}, {"sha": "54f5c2eeb00556caf16b8545ec458103acd772ff", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -72,8 +72,8 @@ protected native void bind(int lport, InetAddress laddr)\n   protected native void receive(DatagramPacket p) throws IOException;\n   public native void setOption(int optID, Object value) throws SocketException;\n   public native Object getOption(int optID) throws SocketException;\n-  private native void mcastGrp(InetAddress inetaddr, boolean join)\n-\t  throws IOException;\n+  private native void mcastGrp(InetAddress inetaddr, NetworkInterface netIf,\n+\t\t               boolean join) throws IOException;\n   protected native void close();\n \n   // Deprecated in JDK 1.2.\n@@ -90,12 +90,24 @@ protected void setTTL(byte ttl) throws IOException\n \n   protected void join(InetAddress inetaddr) throws IOException\n   {\n-    mcastGrp(inetaddr, true);\n+    mcastGrp(inetaddr, null, true);\n   }\n \n   protected void leave(InetAddress inetaddr) throws IOException\n   {\n-    mcastGrp(inetaddr, false);\n+    mcastGrp(inetaddr, null, false);\n+  }\n+\n+  protected void joinGroup (SocketAddress mcastaddr, NetworkInterface netIf)\n+\t  throws IOException\n+  {\n+    mcastGrp(((InetSocketAddress)mcastaddr).getAddress(), netIf, true);\n+  }\n+\n+  protected void leaveGroup (SocketAddress mcastaddr, NetworkInterface netIf)\n+\t  throws IOException\n+  {\n+    mcastGrp(((InetSocketAddress)mcastaddr).getAddress(), netIf, false);\n   }\n \n   protected void finalize() throws Throwable"}, {"sha": "b706acca58cf4f7772389cd1c6e8bf916dfe959f", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -38,6 +38,7 @@\n package java.net;\n \n import java.io.IOException;\n+import java.nio.channels.ServerSocketChannel;\n \n /* Written using on-line Java Platform 1.2 API Specification.\n  * Status:  I believe all methods are implemented.\n@@ -74,6 +75,12 @@\n    */\n   private SocketImpl impl;\n \n+  /**\n+   * ServerSocketChannel of this ServerSocket. This channel only exists\n+   * when the socket is created by ServerSocketChannel.open().\n+   */\n+  private ServerSocketChannel ch;\n+\n   /**\n    * Private constructor that simply sets the implementation.\n    */\n@@ -281,6 +288,39 @@ public void close () throws IOException\n     impl.close();\n   }\n \n+  /**\n+   * Returns the unique ServerSocketChannel object\n+   * associated with this socket, if any.\n+   *\n+   * The socket only has a ServerSocketChannel if its created\n+   * by ServerSocketChannel.open.\n+   * \n+   * @since 1.4\n+   */\n+  public ServerSocketChannel getChannel()\n+  {\n+    return ch;\n+  }\n+\n+  /**\n+   * Returns true then the socket is bound, otherwise false\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isBound()\n+  {\n+    try\n+      {\n+        Object bindaddr = impl.getOption (SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException e)\n+      {\n+\treturn false;\n+      }\n+    \n+    return true;\n+  }\n+\n   /**\n    * Sets the value of SO_TIMEOUT.  A value of 0 implies that SO_TIMEOUT is\n    * disabled (ie, operations never time out).  This is the number of "}, {"sha": "25f077b8013970132b7828b9363d83ef00e5d2f3", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -38,6 +38,7 @@\n package java.net;\n \n import java.io.*;\n+import java.nio.channels.SocketChannel;\n \n /* Written using on-line Java Platform 1.2 API Specification.\n  * Status:  I believe all methods are implemented.\n@@ -78,6 +79,8 @@\n    */\n   SocketImpl impl;\n \n+  SocketChannel ch; // this field must have been set if created by SocketChannel\n+  \n   // Constructors\n \n   /**\n@@ -524,6 +527,21 @@ public int getSoLinger() throws SocketException\n       return -1;\n   }\n \n+  /**\n+   * Sends urgent data through the socket\n+   *\n+   * @param data The data to send.\n+   * Only the lowest eight bits of data are sent\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public void sendUrgentData (int data) throws IOException\n+  {\n+    impl.sendUrgentData (data);\n+  }\n+\n   /**\n    * Enables/disables the SO_OOBINLINE option\n    * \n@@ -819,4 +837,14 @@ public void shutdownOutput() throws IOException\n     if (impl != null)\n       impl.shutdownOutput();\n   }\n+\n+  /**\n+   * Returns the socket channel associated with this socket.\n+   *\n+   * It returns null if no associated socket exists.\n+   */\n+  public SocketChannel getChannel()\n+  {\n+    return ch;\n+  }\n }"}, {"sha": "cf119258c11f8575b3dfd0da4d110d50d638c7d7", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -63,6 +63,7 @@ _Jv_bind (int fd, struct sockaddr *addr, int addrlen)\n #include <java/net/SocketException.h>\n #include <java/net/PlainDatagramSocketImpl.h>\n #include <java/net/InetAddress.h>\n+#include <java/net/NetworkInterface.h>\n #include <java/net/DatagramPacket.h>\n #include <java/lang/InternalError.h>\n #include <java/lang/Object.h>\n@@ -136,6 +137,7 @@ java::net::PlainDatagramSocketImpl::getTimeToLive ()\n \n void\n java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *,\n+                                              java::net::NetworkInterface *,\n \t\t\t\t\t      jboolean)\n {\n   throw new java::io::IOException (\n@@ -504,8 +506,11 @@ java::net::PlainDatagramSocketImpl::getTimeToLive ()\n \n void\n java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n+                                              java::net::NetworkInterface *,\n \t\t\t\t\t      jboolean join)\n {\n+  // FIXME: implement use of NetworkInterface\n+\n   union McastReq u;\n   jbyteArray haddress = inetaddr->addr;\n   jbyte *bytes = elements (haddress);\n@@ -769,7 +774,8 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n \t      }\n #endif\n \t    else\n-\t      throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n+\t      throw new java::net::SocketException (\n+\t\t\t      JvNewStringUTF (\"invalid family\"));\n \t    localAddress = new java::net::InetAddress (laddr, NULL);\n \t  }\n \treturn localAddress;  "}, {"sha": "a1e967eb8b39ca879a95ddb3bc930ef57b6ebc50", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be362a0d5ba42bee36bd339e25374100a9f1942c/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=be362a0d5ba42bee36bd339e25374100a9f1942c", "patch": "@@ -381,7 +381,7 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n \tthrow new java::net::SocketTimeoutException ( \n \t         JvNewStringUTF(\"Connect timed out\"));\n     }\n-    else\n+  else\n #endif\n     {\n       if (_Jv_connect (fnum, ptr, len) != 0)\n@@ -588,7 +588,8 @@ java::net::PlainSocketImpl::read(void)\n     timeout_value.tv_sec = timeout / 1000;\n     timeout_value.tv_usec = (timeout % 1000) * 1000;\n     // Select on the fds.\n-    int sel_retval = _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+    int sel_retval =\n+\t    _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n     // If select returns 0 we've waited without getting data...\n     // that means we've timed out.\n     if (sel_retval == 0)\n@@ -647,7 +648,8 @@ java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n     timeout_value.tv_sec = timeout / 1000;\n     timeout_value.tv_usec =(timeout % 1000) * 1000;\n     // Select on the fds.\n-    int sel_retval = _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+    int sel_retval = \n+\t    _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n     // We're only interested in the 0 return.\n     // error returns still require us to try to read \n     // the socket to see what happened.\n@@ -776,7 +778,8 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n     }\n   else\n     {\n-      throw new java::lang::IllegalArgumentException (JvNewStringLatin1 (\"`value' must be Boolean or Integer\"));\n+      throw new java::lang::IllegalArgumentException (\n+        JvNewStringLatin1 (\"`value' must be Boolean or Integer\"));\n     }\n \n   switch (optID) \n@@ -968,8 +971,8 @@ java::net::PlainSocketImpl::getOption (jint optID)\n \t      }\n #endif\n \t    else\n-\t      throw\n-\t\tnew java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n+\t      throw new java::net::SocketException (\n+\t\t\t      JvNewStringUTF (\"invalid family\"));\n \t    localAddress = new java::net::InetAddress (laddr, NULL);\n \t  }\n \treturn localAddress;"}]}