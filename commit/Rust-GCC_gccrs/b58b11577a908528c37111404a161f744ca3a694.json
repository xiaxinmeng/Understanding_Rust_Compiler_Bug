{"sha": "b58b11577a908528c37111404a161f744ca3a694", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU4YjExNTc3YTkwODUyOGMzNzExMTQwNGExNjFmNzQ0Y2EzYTY5NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-07-12T01:07:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-07-12T01:07:40Z"}, "message": "cgraph.c (cgraph_max_uid): New global variable.\n\n\n\t* cgraph.c (cgraph_max_uid): New global variable.\n\t(cgraph_node): Set uid field.\n\t(create_edge): Keep inline flags consistent.\n\t(dump_cgraph): Dump more info.\n\t* cgraph.h (struct cgraph_local_info): Remove inline_many and\n\tcan_inline_once; add inlinable, disgread_inline_limits, and self_insn\n\t(struct cgraph_global_info): Add insns, calls, cloned_times,\n\twill_be_output.\n\t(struct cgraph_node): Add uid.\n\t(struct cgraph_edge): Add inline_call.\n\t(cgraph_max_uid, cgraph_inline_p): Declare.\n\t* cgraph.c: Include params.h and fibheap.h\n\t(cgraph_mark_functions_to_inline_once): Kill.\n\t(INSNS_PER_CALL): New constant.\n\t(ncalls_inlined, nfunctions_inlined, initial_insns, overall_insns): New\n\tstatic variables.\n\t(cgraph_finalize_function): Do not analyze inlining.\n\t(cgraph_finalize_compilation_unit): Set inlining attributes.\n\t(cgraph_mark_functions_to_output): More consistency checks.\n\t(cgraph_optimize_function): Set current_function_decl to NULL.\n\t(cgraph_expand_function): Use new inline flags.\n\t(cgraph_postorder): Expand from cgraph_expand_functions.\n\t(INLINED_TIMES, SET_INLINED_TIMES): New macros.\n\t(cgraph_inlined_into, cgraph_inlined_callees,\n\tcgraph_estimate_size_after_inlining, cgraph_estimate_growth,\n\tcgraph_mark_inline, cgraph_check_inline_limits,\n\tcgraph_default_inline_p, cgraph_decide_inling_of_small_functions,\n\tcgraph_decide_inlining, cgraph_inline_p): New functions.\n\t* params.def (PARAM_LARGE_FUNCTION_INSNS, PARAM_LARGE_FUNCTION_GROWTH,\n\tPARAM_INLINE_UNIT_GROWTH): New parameters.\n\t* tree-inline.c (struct inline_data): New field current_decl.\n\t(expand_call_inline): Avoid forward declarations; use\n\tinlinable_function_p.\n\t(optimize_inline_calls): Set id.current_decl.\n\nCo-Authored-By: Gerald Pfeifer <pfeifer@dbai.tuwien.ac.at>\n\nFrom-SVN: r69262", "tree": {"sha": "f057de333fbf0a3f853e92f6e52227b3713693c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f057de333fbf0a3f853e92f6e52227b3713693c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b58b11577a908528c37111404a161f744ca3a694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58b11577a908528c37111404a161f744ca3a694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b58b11577a908528c37111404a161f744ca3a694", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58b11577a908528c37111404a161f744ca3a694/comments", "author": null, "committer": null, "parents": [{"sha": "27b8e366f8683050afd41e3b23d45f77591fa6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27b8e366f8683050afd41e3b23d45f77591fa6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27b8e366f8683050afd41e3b23d45f77591fa6a8"}], "stats": {"total": 1009, "additions": 884, "deletions": 125}, "files": [{"sha": "bdb8c28390bc12b2aa8d5f063cc799bf14f75d80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -1,3 +1,41 @@\n+Sat Jul 12 03:06:01 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\t\t\t       Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n+\n+\t* cgraph.c (cgraph_max_uid): New global variable.\n+\t(cgraph_node): Set uid field.\n+\t(create_edge): Keep inline flags consistent.\n+\t(dump_cgraph): Dump more info.\n+\t* cgraph.h (struct cgraph_local_info): Remove inline_many and\n+\tcan_inline_once; add inlinable, disgread_inline_limits, and self_insn\n+\t(struct cgraph_global_info): Add insns, calls, cloned_times,\n+\twill_be_output.\n+\t(struct cgraph_node): Add uid.\n+\t(struct cgraph_edge): Add inline_call.\n+\t(cgraph_max_uid, cgraph_inline_p): Declare.\n+\t* cgraph.c: Include params.h and fibheap.h\n+\t(cgraph_mark_functions_to_inline_once): Kill.\n+\t(INSNS_PER_CALL): New constant.\n+\t(ncalls_inlined, nfunctions_inlined, initial_insns, overall_insns): New\n+\tstatic variables.\n+\t(cgraph_finalize_function): Do not analyze inlining.\n+\t(cgraph_finalize_compilation_unit): Set inlining attributes.\n+\t(cgraph_mark_functions_to_output): More consistency checks.\n+\t(cgraph_optimize_function): Set current_function_decl to NULL.\n+\t(cgraph_expand_function): Use new inline flags.\n+\t(cgraph_postorder): Expand from cgraph_expand_functions.\n+\t(INLINED_TIMES, SET_INLINED_TIMES): New macros.\n+\t(cgraph_inlined_into, cgraph_inlined_callees,\n+\tcgraph_estimate_size_after_inlining, cgraph_estimate_growth,\n+\tcgraph_mark_inline, cgraph_check_inline_limits,\n+\tcgraph_default_inline_p, cgraph_decide_inling_of_small_functions, \n+\tcgraph_decide_inlining, cgraph_inline_p): New functions.\n+\t* params.def (PARAM_LARGE_FUNCTION_INSNS, PARAM_LARGE_FUNCTION_GROWTH,\n+\tPARAM_INLINE_UNIT_GROWTH): New parameters.\n+\t* tree-inline.c (struct inline_data): New field current_decl.\n+\t(expand_call_inline): Avoid forward declarations; use\n+\tinlinable_function_p.\n+\t(optimize_inline_calls): Set id.current_decl.\n+\n 2003-07-11  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* configure.in: Remove wrongly added definition of"}, {"sha": "c19138133815fc915513885d02ed94dffce6f548", "filename": "gcc/cgraph.c", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -48,6 +48,9 @@ struct cgraph_node *cgraph_nodes_queue;\n /* Number of nodes in existence.  */\n int cgraph_n_nodes;\n \n+/* Maximal uid used in cgraph nodes.  */\n+int cgraph_max_uid;\n+\n /* Set when whole unit has been analyzed so we can access global info.  */\n bool cgraph_global_info_ready = false;\n \n@@ -114,6 +117,7 @@ cgraph_node (decl)\n   node = ggc_alloc_cleared (sizeof (*node));\n   node->decl = decl;\n   node->next = cgraph_nodes;\n+  node->uid = cgraph_max_uid++;\n   if (cgraph_nodes)\n     cgraph_nodes->previous = node;\n   node->previous = NULL;\n@@ -157,6 +161,19 @@ create_edge (caller, callee)\n      struct cgraph_node *caller, *callee;\n {\n   struct cgraph_edge *edge = ggc_alloc (sizeof (struct cgraph_edge));\n+  struct cgraph_edge *edge2;\n+\n+  edge->inline_call = false;\n+  /* At the moment we don't associate calls with specific CALL_EXPRs\n+     as we probably ought to, so we must preserve inline_call flags to\n+     be the same in all copies of the same edge.  */\n+  if (cgraph_global_info_ready)\n+    for (edge2 = caller->callees; edge2; edge2 = edge2->next_caller)\n+      if (edge2->callee == callee)\n+\t{\n+\t  edge->inline_call = edge2->inline_call;\n+\t  break;\n+\t}\n \n   edge->caller = caller;\n   edge->callee = callee;\n@@ -337,6 +354,8 @@ dump_cgraph (f)\n     {\n       struct cgraph_edge *edge;\n       fprintf (f, \"%s\", cgraph_node_name (node));\n+      if (node->local.self_insns)\n+        fprintf (f, \" %i insns\", node->local.self_insns);\n       if (node->origin)\n \tfprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n       if (node->needed)\n@@ -346,13 +365,32 @@ dump_cgraph (f)\n       if (DECL_SAVED_TREE (node->decl))\n \tfprintf (f, \" tree\");\n \n+      if (node->local.disgread_inline_limits)\n+\tfprintf (f, \" always_inline\");\n+      else if (node->local.inlinable)\n+\tfprintf (f, \" inlinable\");\n+      if (node->global.insns && node->global.insns != node->local.self_insns)\n+\tfprintf (f, \" %i insns after inlining\", node->global.insns);\n+      if (node->global.cloned_times > 1)\n+\tfprintf (f, \" cloned %ix\", node->global.cloned_times);\n+      if (node->global.calls)\n+\tfprintf (f, \" %i calls\", node->global.calls);\n+\n       fprintf (f, \"\\n  called by :\");\n       for (edge = node->callers; edge; edge = edge->next_caller)\n-\tfprintf (f, \"%s \", cgraph_node_name (edge->caller));\n+\t{\n+\t  fprintf (f, \"%s \", cgraph_node_name (edge->caller));\n+\t  if (edge->inline_call)\n+\t    fprintf(f, \"(inlined) \");\n+\t}\n \n       fprintf (f, \"\\n  calls: \");\n       for (edge = node->callees; edge; edge = edge->next_callee)\n-\tfprintf (f, \"%s \", cgraph_node_name (edge->callee));\n+\t{\n+\t  fprintf (f, \"%s \", cgraph_node_name (edge->callee));\n+\t  if (edge->inline_call)\n+\t    fprintf(f, \"(inlined) \");\n+\t}\n       fprintf (f, \"\\n\");\n     }\n }"}, {"sha": "0a8a2d0d50714c4f50598234de5c9a11d6e1be53", "filename": "gcc/cgraph.h", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -30,13 +30,15 @@ struct cgraph_local_info GTY(())\n   /* Set when function function is visible in current compilation unit only\n      and it's address is never taken.  */\n   bool local;\n-  /* Set when function is small enough to be inlinable many times.  */\n-  bool inline_many;\n-  /* Set when function can be inlined once (false only for functions calling\n-     alloca, using varargs and so on).  */\n-  bool can_inline_once;\n   /* Set once it has been finalized so we consider it to be output.  */\n   bool finalized;\n+\n+  /* False when there is something making inlining impossible (such as va_arg) */\n+  bool inlinable;\n+  /* True when function should be inlined independently on it's size.  */\n+  bool disgread_inline_limits;\n+  /* Size of the function before inlining.  */\n+  int self_insns;\n };\n \n /* Information about the function that needs to be computed globally\n@@ -46,6 +48,20 @@ struct cgraph_global_info GTY(())\n {\n   /* Set when the function will be inlined exactly once.  */\n   bool inline_once;\n+\n+  /* Estimated size of the function after inlining.  */\n+  int insns;\n+\n+  /* Number of direct calls not inlined into the function body.  */\n+  int calls;\n+\n+  /* Number of times given function will be cloned during output.  */\n+  int cloned_times;\n+\n+  /* Set to true for all reachable functions before inlining is decided.\n+     Once we inline all calls to the function and the function is local,\n+     it is set to false.  */\n+  bool will_be_output;\n };\n \n /* Information about the function that is propagated by the RTL backend.\n@@ -77,6 +93,8 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   struct cgraph_node *next_nested;\n   /* Pointer to the next function in cgraph_nodes_queue.  */\n   struct cgraph_node *next_needed;\n+  /* Unique id of the node.  */\n+  int uid;\n   PTR GTY ((skip (\"\"))) aux;\n \n   /* Set when function must be output - it is externally visible\n@@ -102,6 +120,7 @@ struct cgraph_edge GTY(())\n   struct cgraph_node *callee;\n   struct cgraph_edge *next_caller;\n   struct cgraph_edge *next_callee;\n+  bool inline_call;\n };\n \n /* The cgraph_varpool data strutcture.\n@@ -124,6 +143,7 @@ struct cgraph_varpool_node GTY(())\n \n extern GTY(()) struct cgraph_node *cgraph_nodes;\n extern GTY(()) int cgraph_n_nodes;\n+extern GTY(()) int cgraph_max_uid;\n extern bool cgraph_global_info_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n extern FILE *cgraph_dump_file;\n@@ -157,5 +177,6 @@ void cgraph_finalize_compilation_unit\tPARAMS ((void));\n void cgraph_create_edges\t\tPARAMS ((tree, tree));\n void cgraph_optimize\t\t\tPARAMS ((void));\n void cgraph_mark_needed_node\t\tPARAMS ((struct cgraph_node *, int));\n+bool cgraph_inline_p\t\t\tPARAMS ((tree, tree));\n \n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "df188d58d0b99ac57c3b64719ce4f8bb300ea927", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 731, "deletions": 113, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -1,4 +1,4 @@\n-/* Callgraph handling code.\n+/* Callgraph based intraprocedural optimizations.\n    Copyright (C) 2003 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n@@ -35,15 +35,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n #include \"timevar.h\"\n+#include \"params.h\"\n+#include \"fibheap.h\"\n+#include \"c-common.h\"\n+\n+#define INSNS_PER_CALL 10\n \n static void cgraph_expand_functions PARAMS ((void));\n static void cgraph_mark_functions_to_output PARAMS ((void));\n static void cgraph_expand_function PARAMS ((struct cgraph_node *));\n static tree record_call_1 PARAMS ((tree *, int *, void *));\n static void cgraph_mark_local_functions PARAMS ((void));\n-static void cgraph_mark_functions_to_inline_once PARAMS ((void));\n static void cgraph_optimize_function PARAMS ((struct cgraph_node *));\n \n+/* Statistics we collect about inlining algorithm.  */\n+static int ncalls_inlined;\n+static int nfunctions_inlined;\n+static int initial_insns;\n+static int overall_insns;\n+\n /* Analyze function once it is parsed.  Set up the local information\n    available - create cgraph edges for function calls via BODY.  */\n \n@@ -141,6 +151,8 @@ cgraph_finalize_compilation_unit ()\n   struct cgraph_edge *edge;\n \n   cgraph_varpool_assemble_pending_decls ();\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\nAnalyzing compilation unit\\n\");\n \n   timevar_push (TV_CGRAPH);\n   if (cgraph_dump_file)\n@@ -170,14 +182,6 @@ cgraph_finalize_compilation_unit ()\n \t(*lang_hooks.callgraph.lower_function) (decl);\n \n       current_function_decl = node->decl;\n-      if (!node->needed && !DECL_COMDAT (node->decl))\n-\tnode->local.can_inline_once = tree_inlinable_function_p (decl, 1);\n-      else\n-\tnode->local.can_inline_once = 0;\n-      if (flag_inline_trees)\n-\tnode->local.inline_many = tree_inlinable_function_p (decl, 0);\n-      else\n-\tnode->local.inline_many = 0;\n \n       /* At the moment frontend automatically emits all nested functions.  */\n       if (node->nested)\n@@ -189,9 +193,18 @@ cgraph_finalize_compilation_unit ()\n \t      cgraph_mark_needed_node (node2, 0);\n \t}\n \n-      /* First kill forward declaration so reverse inling works properly.  */\n+      /* First kill forward declaration so reverse inlining works properly.  */\n       cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n \n+      node->local.inlinable = tree_inlinable_function_p (decl, 1);\n+      if (!DECL_ESTIMATED_INSNS (decl))\n+\tDECL_ESTIMATED_INSNS (decl)\n+          = (*lang_hooks.tree_inlining.estimate_num_insns) (decl);\n+      node->local.self_insns = DECL_ESTIMATED_INSNS (decl);\n+      if (node->local.inlinable)\n+\tnode->local.disgread_inline_limits\n+\t  = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n+\n       for (edge = node->callees; edge; edge = edge->next_callee)\n \t{\n \t  if (!edge->callee->reachable)\n@@ -241,16 +254,20 @@ cgraph_mark_functions_to_output ()\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       tree decl = node->decl;\n+      struct cgraph_edge *e;\n+      if (node->output)\n+\tabort ();\n+\n+      for (e = node->callers; e; e = e->next_caller)\n+\tif (!e->inline_call)\n+\t  break;\n \n       /* We need to output all local functions that are used and not\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n       if (DECL_SAVED_TREE (decl)\n \t  && (node->needed\n-\t      || (!node->local.inline_many && !node->global.inline_once\n-\t\t  && node->reachable)\n-\t      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t          && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+\t      || (e && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n \t  && !DECL_EXTERNAL (decl))\n \tnode->output = 1;\n@@ -266,6 +283,8 @@ cgraph_optimize_function (node)\n   tree decl = node->decl;\n \n   timevar_push (TV_INTEGRATION);\n+  /* optimize_inline_calls avoids inlining of current_function_decl.  */\n+  current_function_decl = 0;\n   if (flag_inline_trees)\n     optimize_inline_calls (decl);\n   if (node->nested)\n@@ -283,6 +302,7 @@ cgraph_expand_function (node)\n      struct cgraph_node *node;\n {\n   tree decl = node->decl;\n+  struct cgraph_edge *e;\n \n   announce_function (decl);\n \n@@ -292,41 +312,26 @@ cgraph_expand_function (node)\n      via lang_expand_decl_stmt.  */\n   (*lang_hooks.callgraph.expand_function) (decl);\n \n-  /* When we decided to inline the function once, we never ever should\n-     need to output it separately.  */\n-  if (node->global.inline_once)\n-    abort ();\n-  if (!node->local.inline_many\n-      || !node->callers)\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->inline_call)\n+      break;\n+  if (!e)\n     DECL_SAVED_TREE (decl) = NULL;\n   current_function_decl = NULL;\n }\n \n-\n-/* Expand all functions that must be output. \n-  \n-   Attempt to topologically sort the nodes so function is output when\n-   all called functions are already assembled to allow data to be\n-   propagated across the callgraph.  Use a stack to get smaller distance\n-   between a function and it's callees (later we may choose to use a more\n-   sophisticated algorithm for function reordering; we will likely want\n-   to use subsections to make the output functions appear in top-down\n-   order.  */\n-\n-static void\n-cgraph_expand_functions ()\n+/* Fill array order with all nodes with output flag set in the reverse\n+   topological order.  */\n+static int\n+cgraph_postorder (struct cgraph_node **order)\n {\n   struct cgraph_node *node, *node2;\n-  struct cgraph_node **stack =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n-  struct cgraph_node **order =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n   int stack_size = 0;\n   int order_pos = 0;\n   struct cgraph_edge *edge, last;\n-  int i;\n \n-  cgraph_mark_functions_to_output ();\n+  struct cgraph_node **stack =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n \n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need\n@@ -372,105 +377,747 @@ cgraph_expand_functions ()\n \t      }\n \t  }\n       }\n-  for (i = order_pos - 1; i >= 0; i--)\n+  free (stack);\n+  return order_pos;\n+}\n+\n+#define INLINED_TIMES(node) ((size_t)(node)->aux)\n+#define SET_INLINED_TIMES(node,times) ((node)->aux = (void *)(times))\n+\n+/* Return list of nodes we decided to inline NODE into, set their output\n+   flag and compute INLINED_TIMES. \n+\n+   We do simple backtracing to get INLINED_TIMES right.  This should not be\n+   expensive as we limit the amount of inlining.  Alternatively we may first\n+   discover set of nodes, topologically sort these and propagate\n+   INLINED_TIMES  */\n+\n+static int\n+cgraph_inlined_into (struct cgraph_node *node, struct cgraph_node **array)\n+{\n+  int nfound = 0;\n+  struct cgraph_edge **stack;\n+  struct cgraph_edge *e, *e1;\n+  int sp;\n+  int i;\n+\n+  /* Fast path: since we traverse in mostly topological order, we will likely\n+     find no edges.  */\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->inline_call)\n+      break;\n+\n+  if (!e)\n+    return 0;\n+\n+  /* Allocate stack for back-tracking up callgraph.  */\n+  stack = xmalloc ((cgraph_n_nodes + 1) * sizeof (struct cgraph_edge));\n+  sp = 0;\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = e;\n+\n+  while (sp)\n     {\n-      node = order[i];\n-      if (node->output)\n+      struct cgraph_node *caller;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      caller = e->caller;\n+\n+      /* Check if the caller destination has been visited yet.  */\n+      if (!caller->output)\n \t{\n-\t  if (!node->reachable)\n-\t    abort ();\n-\t  node->output = 0;\n-\t  cgraph_expand_function (node);\n+\t  array[nfound++] = e->caller;\n+\t  /* Mark that we have visited the destination.  */\n+\t  caller->output = true;\n+\t  SET_INLINED_TIMES (caller, 0);\n+\t}\n+      SET_INLINED_TIMES (caller, INLINED_TIMES (caller) + 1);\n+\n+      for (e1 = caller->callers; e1; e1 = e1->next_caller)\n+\tif (e1->inline_call)\n+\t  break;\n+      if (e1)\n+\tstack[sp++] = e1;\n+      else\n+\t{\n+\t  while (true)\n+\t    {\n+\t      for (e1 = e->next_caller; e1; e1 = e1->next_caller)\n+\t\tif (e1->inline_call)\n+\t\t  break;\n+\n+\t      if (e1)\n+\t\t{\n+\t\t  stack[sp - 1] = e1;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sp--;\n+\t\t  if (!sp)\n+\t\t    break;\n+\t\t  e = stack[sp - 1];\n+\t\t}\n+\t    }\n \t}\n     }\n+\n   free (stack);\n-  free (order);\n+\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"Found inline predecesors of %s:\",\n+\t       cgraph_node_name (node));\n+      for (i = 0; i < nfound; i++)\n+\t{\n+\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (array[i]));\n+\t  if (INLINED_TIMES (array[i]) != 1)\n+\t    fprintf (cgraph_dump_file, \" (%i times)\",\n+\t\t     INLINED_TIMES (array[i]));\n+\t}\n+      fprintf (cgraph_dump_file, \"\\n\");\n+    }\n+\n+  return nfound;\n }\n \n-/* Mark all local functions.\n-   We can not use node->needed directly as it is modified during\n-   execution of cgraph_optimize.  */\n+/* Return list of nodes we decided to inline into NODE, set their output\n+   flag and compute INLINED_TIMES. \n+\n+   This function is identical to cgraph_inlined_into with callers and callees\n+   nodes swapped.  */\n+\n+static int\n+cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n+{\n+  int nfound = 0;\n+  struct cgraph_edge **stack;\n+  struct cgraph_edge *e, *e1;\n+  int sp;\n+  int i;\n+\n+  /* Fast path: since we traverse in mostly topological order, we will likely\n+     find no edges.  */\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->inline_call)\n+      break;\n+\n+  if (!e)\n+    return 0;\n+\n+  /* Allocate stack for back-tracking up callgraph.  */\n+  stack = xmalloc ((cgraph_n_nodes + 1) * sizeof (struct cgraph_edge));\n+  sp = 0;\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = e;\n+\n+  while (sp)\n+    {\n+      struct cgraph_node *callee;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      callee = e->callee;\n+\n+      /* Check if the callee destination has been visited yet.  */\n+      if (!callee->output)\n+\t{\n+\t  array[nfound++] = e->callee;\n+\t  /* Mark that we have visited the destination.  */\n+\t  callee->output = true;\n+\t  SET_INLINED_TIMES (callee, 0);\n+\t}\n+      SET_INLINED_TIMES (callee, INLINED_TIMES (callee) + 1);\n+\n+      for (e1 = callee->callees; e1; e1 = e1->next_callee)\n+\tif (e1->inline_call)\n+\t  break;\n+      if (e1)\n+\tstack[sp++] = e1;\n+      else\n+\t{\n+\t  while (true)\n+\t    {\n+\t      for (e1 = e->next_callee; e1; e1 = e1->next_callee)\n+\t\tif (e1->inline_call)\n+\t\t  break;\n+\n+\t      if (e1)\n+\t\t{\n+\t\t  stack[sp - 1] = e1;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sp--;\n+\t\t  if (!sp)\n+\t\t    break;\n+\t\t  e = stack[sp - 1];\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  free (stack);\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"Found inline successors of %s:\",\n+\t       cgraph_node_name (node));\n+      for (i = 0; i < nfound; i++)\n+\t{\n+\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (array[i]));\n+\t  if (INLINED_TIMES (array[i]) != 1)\n+\t    fprintf (cgraph_dump_file, \" (%i times)\",\n+\t\t     INLINED_TIMES (array[i]));\n+\t}\n+      fprintf (cgraph_dump_file, \"\\n\");\n+    }\n+\n+  return nfound;\n+}\n+\n+/* Estimate size of the function after inlining WHAT into TO.  */\n+\n+static int\n+cgraph_estimate_size_after_inlining (int times,\n+\t\t\t\t     struct cgraph_node *to,\n+\t\t\t\t     struct cgraph_node *what)\n+{\n+  return (what->global.insns - INSNS_PER_CALL) *times + to->global.insns;\n+}\n+\n+/* Estimate the growth caused by inlining NODE into all callees.  */\n+\n+static int\n+cgraph_estimate_growth (struct cgraph_node *node)\n+{\n+  int growth = 0;\n+  int calls_saved = 0;\n+  int clones_added = 0;\n+  struct cgraph_edge *e;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (!e->inline_call)\n+      {\n+\tgrowth += ((cgraph_estimate_size_after_inlining (1, e->caller, node)\n+\t\t    -\n+\t\t    e->caller->global.insns) *e->caller->global.cloned_times);\n+\tcalls_saved += e->caller->global.cloned_times;\n+\tclones_added += e->caller->global.cloned_times;\n+      }\n+\n+  /* ??? Wrong for self recursive functions or cases where we decide to not\n+     inline for different reasons, but it is not big deal as in that case\n+     we will keep the body around, but we will also avoid some inlining.  */\n+  if (!node->needed && !node->origin && !DECL_EXTERNAL (node->decl))\n+    growth -= node->global.insns, clones_added--;\n+\n+  if (!calls_saved)\n+    calls_saved = 1;\n+\n+  return growth;\n+}\n+\n+/* Update insn sizes after inlining WHAT into TO that is already inlined into\n+   all nodes in INLINED array.  */\n \n static void\n-cgraph_mark_local_functions ()\n+cgraph_mark_inline (struct cgraph_node *to,\n+\t\t    struct cgraph_node *what,\n+\t\t    struct cgraph_node **inlined, int ninlined,\n+\t\t    struct cgraph_node **inlined_callees,\n+\t\t    int ninlined_callees)\n+{\n+  int i;\n+  int times = 0;\n+  int clones = 0;\n+  struct cgraph_edge *e;\n+  bool called = false;\n+  int new_insns;\n+\n+  for (e = what->callers; e; e = e->next_caller)\n+    {\n+      if (e->caller == to)\n+\t{\n+\t  if (e->inline_call)\n+\t    abort ();\n+\t  e->inline_call = true;\n+\t  times++;\n+\t  clones += e->caller->global.cloned_times;\n+\t}\n+      else if (!e->inline_call)\n+\tcalled = true;\n+    }\n+  if (!times)\n+    abort ();\n+  ncalls_inlined += times;\n+\n+  new_insns = cgraph_estimate_size_after_inlining (times, to, what);\n+  if (to->global.will_be_output)\n+    overall_insns += new_insns - to->global.insns;\n+  to->global.insns = new_insns;\n+\n+  to->global.calls += (what->global.calls - 1) *times;\n+  if (!called && !what->needed && !what->origin\n+      && !DECL_EXTERNAL (what->decl))\n+    {\n+      if (!what->global.will_be_output)\n+\tabort ();\n+      clones--;\n+      nfunctions_inlined++;\n+      what->global.will_be_output = 0;\n+      overall_insns -= what->global.insns;\n+    }\n+  what->global.cloned_times += clones;\n+  if (to->global.calls < 0)\n+    abort ();\n+  for (i = 0; i < ninlined; i++)\n+    {\n+      new_insns =\n+\tcgraph_estimate_size_after_inlining (INLINED_TIMES (inlined[i]) *\n+\t\t\t\t\t     times, inlined[i], what);\n+      if (inlined[i]->global.will_be_output)\n+\toverall_insns += new_insns - inlined[i]->global.insns;\n+      inlined[i]->global.insns = new_insns;\n+      inlined[i]->global.calls +=\n+\t(what->global.calls - 1) *INLINED_TIMES (inlined[i]) * times;\n+      if (inlined[i]->global.calls < 0)\n+\tabort ();\n+    }\n+  for (i = 0; i < ninlined_callees; i++)\n+    {\n+      inlined_callees[i]->global.cloned_times +=\n+\tINLINED_TIMES (inlined_callees[i]) * clones;\n+    }\n+}\n+\n+/* Return false when inlining WHAT into TO is not good idea as it would cause\n+   too large growth of function bodies.  */\n+\n+static bool\n+cgraph_check_inline_limits (struct cgraph_node *to,\n+\t\t\t    struct cgraph_node *what,\n+\t\t\t    struct cgraph_node **inlined, int ninlined)\n {\n+  int i;\n+  int times = 0;\n+  struct cgraph_edge *e;\n+  int newsize;\n+  int limit;\n+\n+  for (e = to->callees; e; e = e->next_callee)\n+    if (e->callee == what)\n+      times++;\n+\n+  /* When inlining large function body called once into small function,\n+     take the inlined function as base for limiting the growth.  */\n+  if (to->local.self_insns > what->local.self_insns)\n+    limit = to->local.self_insns;\n+  else\n+    limit = what->local.self_insns;\n+\n+  limit += limit * PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH) / 100;\n+\n+  newsize = cgraph_estimate_size_after_inlining (times, to, what);\n+  if (newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n+      && newsize > limit)\n+    return false;\n+  for (i = 0; i < ninlined; i++)\n+    {\n+      newsize =\n+\tcgraph_estimate_size_after_inlining (INLINED_TIMES (inlined[i]) *\n+\t\t\t\t\t     times, inlined[i], what);\n+      if (newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n+\t  && newsize >\n+\t  inlined[i]->local.self_insns *\n+\t  (100 + PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH)) / 100)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Return true when function N is small enought to be inlined.  */\n+\n+static bool\n+cgraph_default_inline_p (struct cgraph_node *n)\n+{\n+  if (!DECL_INLINE (n->decl) || !DECL_SAVED_TREE (n->decl))\n+    return false;\n+  if (DID_INLINE_FUNC (n->decl))\n+    return n->global.insns < MAX_INLINE_INSNS_AUTO;\n+  else\n+    return n->global.insns < MAX_INLINE_INSNS_SINGLE;\n+}\n+\n+/* We use greedy algorithm for inlining of small functions:\n+   All inline candidates are put into prioritized heap based on estimated\n+   growth of the overall number of instructions and then update the estimates.\n+   \n+   INLINED and INLINED_CALEES are just pointers to arrays large enought\n+   to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */\n+\n+static void\n+cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n+\t\t\t\t\t   struct cgraph_node\n+\t\t\t\t\t   **inlined_callees)\n+{\n+  int i;\n   struct cgraph_node *node;\n+  fibheap_t heap = fibheap_new ();\n+  struct fibnode **heap_node =\n+    xcalloc (sizeof (struct fibnode *), cgraph_max_uid);\n+  int ninlined, ninlined_callees;\n+  int max_insns = ((HOST_WIDEST_INT) initial_insns\n+\t\t   * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Marking local functions:\");\n+  /* Put all inline candidates into the heap.  */\n \n-  /* Figure out functions we want to assemble.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      node->local.local = (!node->needed\n-\t\t           && DECL_SAVED_TREE (node->decl)\n-\t\t\t   && !DECL_COMDAT (node->decl)\n-\t\t           && !TREE_PUBLIC (node->decl));\n-      if (cgraph_dump_file && node->local.local)\n-\tfprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+      struct cgraph_edge *e;\n+\n+      if (!node->local.inlinable || !node->callers\n+\t  || !cgraph_default_inline_p (node))\n+\tcontinue;\n+\n+      /* Rule out always_inline functions we dealt with earler.  */\n+      for (e = node->callers; e; e = e->next_caller)\n+\tif (e->inline_call)\n+\t  break;\n+      if (e)\n+\tcontinue;\n+      heap_node[node->uid] =\n+\tfibheap_insert (heap, cgraph_estimate_growth (node), node);\n     }\n+\n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\");\n+    fprintf (cgraph_dump_file, \"\\n\\nDeciding on inlining: \");\n+  while ((node = fibheap_extract_min (heap)) && overall_insns <= max_insns)\n+    {\n+      struct cgraph_edge *e;\n+      int old_insns = overall_insns;\n+\n+      heap_node[node->uid] = NULL;\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"Considering %s %i insns, growth %i.\\n\",\n+\t\t cgraph_node_name (node), node->global.insns,\n+\t\t cgraph_estimate_growth (node));\n+      if (!cgraph_default_inline_p (node))\n+\t{\n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \"Function too large.\\n\");\n+\t  continue;\n+\t}\n+      ninlined_callees = cgraph_inlined_callees (node, inlined_callees);\n+      for (e = node->callers; e; e = e->next_caller)\n+\tif (!e->inline_call && e->caller != node)\n+\t  {\n+\t    ninlined = cgraph_inlined_into (e->caller, inlined);\n+\t    if (e->callee->output\n+\t\t|| !cgraph_check_inline_limits (e->caller, node, inlined,\n+\t\t\t\t\t\tninlined))\n+\t      {\n+\t\tfor (i = 0; i < ninlined; i++)\n+\t\t  inlined[i]->output = 0, node->aux = 0;\n+\t\tif (cgraph_dump_file)\n+\t\t  fprintf (cgraph_dump_file, \"Not inlining into %s\\n\",\n+\t\t\t   cgraph_node_name (e->caller));\n+\t\tcontinue;\n+\t      }\n+\t    cgraph_mark_inline (e->caller, node, inlined, ninlined,\n+\t\t\t\tinlined_callees, ninlined_callees);\n+\t    if (heap_node[e->caller->uid])\n+\t      fibheap_replace_key (heap, heap_node[e->caller->uid],\n+\t\t\t\t   cgraph_estimate_growth (e->caller));\n+\n+\t    /* Size of the functions we updated into has changed, so update\n+\t       the keys.  */\n+\t    for (i = 0; i < ninlined; i++)\n+\t      {\n+\t\tinlined[i]->output = 0, node->aux = 0;\n+\t\tif (heap_node[inlined[i]->uid])\n+\t\t  fibheap_replace_key (heap, heap_node[inlined[i]->uid],\n+\t\t\t\t       cgraph_estimate_growth (inlined[i]));\n+\t      }\n+\t  }\n+\n+      /* Similarly all functions called by function we just inlined\n+         are now called more times; update keys.  */\n+\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (!e->inline_call && heap_node[e->callee->uid])\n+\t  fibheap_replace_key (heap, heap_node[e->callee->uid],\n+\t\t\t       cgraph_estimate_growth (e->callee));\n+\n+      for (i = 0; i < ninlined_callees; i++)\n+\t{\n+\t  struct cgraph_edge *e;\n+\n+\t  for (e = inlined_callees[i]->callees; e; e = e->next_callee)\n+\t    if (!e->inline_call && heap_node[e->callee->uid])\n+\t      fibheap_replace_key (heap, heap_node[e->callee->uid],\n+\t\t\t\t   cgraph_estimate_growth (e->callee));\n+\n+\t  inlined_callees[i]->output = 0, node->aux = 0;\n+\t}\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t \"Created %i clones, Num insns:%i (%+i), %.2f%%.\\n\\n\",\n+\t\t node->global.cloned_times - 1,\n+\t\t overall_insns, overall_insns - old_insns,\n+\t\t overall_insns * 100.0 / initial_insns);\n+    }\n+  if (cgraph_dump_file && !fibheap_empty (heap))\n+    fprintf (cgraph_dump_file, \"inline-unit-growth limit reached.\\n\");\n+  fibheap_delete (heap);\n+  free (heap_node);\n }\n \n-/* Decide what function should be inlined because they are invoked once\n-   (so inlining won't result in duplication of the code).  */\n+/* Decide on the inlining.  We do so in the topological order to avoid\n+   expenses on updating datastructures.  */\n \n static void\n-cgraph_mark_functions_to_inline_once ()\n+cgraph_decide_inlining (void)\n {\n-  struct cgraph_node *node, *node1;\n+  struct cgraph_node *node;\n+  int nnodes;\n+  struct cgraph_node **order =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  struct cgraph_node **inlined =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  struct cgraph_node **inlined_callees =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  int ninlined;\n+  int ninlined_callees;\n+  int i, y;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\\nMarking functions to inline once:\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      int ncalls = 0;\n+      struct cgraph_edge *e;\n+\n+      node->global.insns = node->local.self_insns;\n+      for (e = node->callees; e; e = e->next_callee)\n+\tncalls++;\n+      node->global.calls = ncalls;\n+      if (!DECL_EXTERNAL (node->decl))\n+\t{\n+\t  node->global.cloned_times = 1;\n+\t  initial_insns += node->local.self_insns;\n+\t  node->global.will_be_output = true;\n+\t}\n+    }\n+  overall_insns = initial_insns;\n+\n+  nnodes = cgraph_postorder (order);\n \n-  /* Now look for function called only once and mark them to inline.\n-     From this point number of calls to given function won't grow.  */\n   for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = 0;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\n\\nDeciding on always_inline functions:\\n\");\n+\n+  /* In the first pass mark all always_inline edges.  Do this with a priority\n+     so no our decisions makes this impossible.  */\n+  for (i = nnodes - 1; i >= 0; i--)\n+    {\n+      struct cgraph_edge *e;\n+\n+      node = order[i];\n+\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (e->callee->local.disgread_inline_limits)\n+\t  break;\n+      if (!e)\n+\tcontinue;\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t \"Considering %s %i insns (always inline)\\n\",\n+\t\t cgraph_node_name (node), node->global.insns);\n+      ninlined = cgraph_inlined_into (order[i], inlined);\n+      for (; e; e = e->next_callee)\n+\t{\n+\t  if (e->inline_call || !e->callee->local.disgread_inline_limits)\n+\t    continue;\n+\t  if (e->callee->output || e->callee == node)\n+\t    continue;\n+\t  ninlined_callees =\n+\t    cgraph_inlined_callees (e->callee, inlined_callees);\n+\t  cgraph_mark_inline (node, e->callee, inlined, ninlined,\n+\t\t\t      inlined_callees, ninlined_callees);\n+\t  for (y = 0; y < ninlined_callees; y++)\n+\t    inlined_callees[y]->output = 0, node->aux = 0;\n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \"Inlined %i times. Now %i insns\\n\\n\",\n+\t\t     node->global.cloned_times, overall_insns);\n+\t}\n+      for (y = 0; y < ninlined; y++)\n+\tinlined[y]->output = 0, node->aux = 0;\n+    }\n+\n+  cgraph_decide_inlining_of_small_functions (inlined, inlined_callees);\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\n\\nFunctions to inline once:\\n\");\n+\n+  /* And finally decide what functions are called once.  */\n+\n+  for (i = nnodes - 1; i >= 0; i--)\n     {\n+      node = order[i];\n+\n       if (node->callers && !node->callers->next_caller && !node->needed\n-\t  && node->local.can_inline_once)\n+\t  && node->local.inlinable && !node->callers->inline_call\n+\t  && !DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n \t{\n \t  bool ok = true;\n+\t  struct cgraph_node *node1;\n \n \t  /* Verify that we won't duplicate the caller.  */\n \t  for (node1 = node->callers->caller;\n-\t       node1->local.inline_many\n-\t       && node1->callers\n-\t       && ok;\n-\t       node1 = node1->callers->caller)\n+\t       node1->callers && node1->callers->inline_call\n+\t       && ok; node1 = node1->callers->caller)\n \t    if (node1->callers->next_caller || node1->needed)\n \t      ok = false;\n \t  if (ok)\n \t    {\n-\t      node->global.inline_once = true;\n \t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+\t\tfprintf (cgraph_dump_file,\n+\t\t\t \"Considering %s %i insns (called once)\\n\",\n+\t\t\t cgraph_node_name (node), node->global.insns);\n+\t      ninlined = cgraph_inlined_into (node->callers->caller, inlined);\n+\t      if (cgraph_check_inline_limits\n+\t\t  (node->callers->caller, node, inlined, ninlined))\n+\t\t{\n+\t\t  ninlined_callees =\n+\t\t    cgraph_inlined_callees (node, inlined_callees);\n+\t\t  cgraph_mark_inline (node->callers->caller, node, inlined,\n+\t\t\t\t      ninlined, inlined_callees,\n+\t\t\t\t      ninlined_callees);\n+\t\t  for (y = 0; y < ninlined_callees; y++)\n+\t\t    inlined_callees[y]->output = 0, node->aux = 0;\n+\t\t  if (cgraph_dump_file)\n+\t\t    fprintf (cgraph_dump_file, \"Inlined. Now %i insns\\n\\n\", overall_insns);\n+\t\t}\n+\t      for (y = 0; y < ninlined; y++)\n+\t\tinlined[y]->output = 0, node->aux = 0;\n \t    }\n \t}\n     }\n+\n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\");\n+    fprintf (cgraph_dump_file,\n+\t     \"\\nInlined %i calls, elliminated %i functions, %i insns turned to %i insns.\\n\",\n+\t     ncalls_inlined, nfunctions_inlined, initial_insns,\n+\t     overall_insns);\n+  free (order);\n+  free (inlined);\n+  free (inlined_callees);\n }\n \n+/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n+\n+bool\n+cgraph_inline_p (tree caller_decl, tree callee_decl)\n+{\n+  struct cgraph_node *caller = cgraph_node (caller_decl);\n+  struct cgraph_node *callee = cgraph_node (callee_decl);\n+  struct cgraph_edge *e;\n+\n+  for (e = caller->callees; e; e = e->next_callee)\n+    if (e->callee == callee)\n+      return e->inline_call;\n+  /* We do not record builtins in the callgraph.  Perhaps it would make more\n+     sense to do so and then prune out those not overwriten by explicit\n+     function body.  */\n+  return false;\n+}\n+/* Expand all functions that must be output. \n+  \n+   Attempt to topologically sort the nodes so function is output when\n+   all called functions are already assembled to allow data to be\n+   propagated accross the callgraph.  Use a stack to get smaller distance\n+   between a function and it's callees (later we may choose to use a more\n+   sophisticated algorithm for function reordering; we will likely want\n+   to use subsections to make the output functions appear in top-down\n+   order).  */\n+\n+static void\n+cgraph_expand_functions ()\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_node **order =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  int order_pos = 0;\n+  int i;\n+\n+  cgraph_mark_functions_to_output ();\n+\n+  order_pos = cgraph_postorder (order);\n+\n+  for (i = order_pos - 1; i >= 0; i--)\n+    {\n+      node = order[i];\n+      if (node->output)\n+\t{\n+\t  if (!node->reachable)\n+\t    abort ();\n+\t  node->output = 0;\n+\t  cgraph_expand_function (node);\n+\t}\n+    }\n+  free (order);\n+}\n+\n+/* Mark all local functions.\n+\n+   Local function is function whose calls can occur only in the\n+   current compilation unit so we change it's calling convetion.\n+   We simply mark all static functions whose address is not taken\n+   as local.  */\n+\n+static void\n+cgraph_mark_local_functions ()\n+{\n+  struct cgraph_node *node;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Marking local functions:\");\n+\n+  /* Figure out functions we want to assemble.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      node->local.local = (!node->needed\n+\t\t           && DECL_SAVED_TREE (node->decl)\n+\t\t           && !TREE_PUBLIC (node->decl));\n+      if (cgraph_dump_file && node->local.local)\n+\tfprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+    }\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"\\n\");\n+}\n \n /* Perform simple optimizations based on callgraph.  */\n \n void\n cgraph_optimize ()\n {\n-  struct cgraph_node *node;\n-  bool changed = true;\n-\n   timevar_push (TV_CGRAPHOPT);\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Performing intraprocedural optimizations\\n\");\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Initial callgraph:\");\n       dump_cgraph (cgraph_dump_file);\n     }\n   cgraph_mark_local_functions ();\n \n-  cgraph_mark_functions_to_inline_once ();\n+  cgraph_decide_inlining ();\n \n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n@@ -480,39 +1127,10 @@ cgraph_optimize ()\n     }\n   timevar_pop (TV_CGRAPHOPT);\n   if (!quiet_flag)\n-    fprintf (stderr, \"\\n\\nAssembling functions:\");\n+    fprintf (stderr, \"Assembling functions:\");\n \n-  /* Output everything.  \n-     ??? Our inline heuristic may decide to not inline functions previously\n-     marked as inlinable thus adding new function bodies that must be output.\n-     Later we should move all inlining decisions to callgraph code to make\n-     this impossible.  */\n+  /* Output everything.  */\n   cgraph_expand_functions ();\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\n\\nAssembling functions that failed to inline:\");\n-  while (changed && !errorcount && !sorrycount)\n-    {\n-      changed = false;\n-      for (node = cgraph_nodes; node; node = node->next)\n-\t{\n-\t  tree decl = node->decl;\n-\t  if (!node->origin\n-\t      && !TREE_ASM_WRITTEN (decl)\n-\t      && DECL_SAVED_TREE (decl)\n-\t      && !DECL_EXTERNAL (decl))\n-\t    {\n-\t      struct cgraph_edge *edge;\n-\n-\t      for (edge = node->callers; edge; edge = edge->next_caller)\n-\t\tif (TREE_ASM_WRITTEN (edge->caller->decl))\n-\t\t  {\n-\t\t    changed = true;\n-\t\t    cgraph_expand_function (node);\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-    }\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Final callgraph:\");"}, {"sha": "0fc713ec8edd13bdfd6278a9bfb87928243ffb57", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -4572,15 +4572,35 @@ After exceeding the maximum number of inlined instructions by repeated\n inlining, a linear function is used to decrease the allowable size\n for single functions.  The slope of that function is the negative\n reciprocal of the number specified here.\n+This parameter is ignored when @option{-funit-at-a-time} is used.\n The default value is 32.\n \n @item min-inline-insns\n The repeated inlining is throttled more and more by the linear function\n after exceeding the limit.  To avoid too much throttling, a minimum for\n this function is specified here to allow repeated inlining for very small\n functions even when a lot of repeated inlining already has been done.\n+This parameter is ignored when @option{-funit-at-a-time} is used.\n The default value is 10.\n \n+@item large-function-insns\n+The limit specifying really large functions.  For functions greater than this\n+limit inlining is constrained by @option{--param large-function-growth}.\n+This parameter is usefull primarily to avoid extreme compilation time caused by non-linear\n+algorithms used by the backend.\n+This parameter is ignored when @option{-funit-at-a-time} is not used.\n+The default value is 30000.\n+\n+@item large-function-growth\n+Specifies maximal growth of large functtion caused by inlining in percents.\n+This parameter is ignored when @option{-funit-at-a-time} is not used.\n+The default value is 200.\n+\n+@item inline-unit-growth\n+Specifies maximal overall growth of the compilation unit caused by inlining.\n+This parameter is ignored when @option{-funit-at-a-time} is not used.\n+The default value is 150.\n+\n @item max-inline-insns-rtl\n For languages that use the RTL inliner (this happens at a later stage\n than tree inlining), you can set the maximum allowable size (counted "}, {"sha": "cb527f0feae212e95cdf3ceae5a3ffc68405a79c", "filename": "gcc/params.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -152,6 +152,19 @@ DEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,\n \t \"The maximum length of scheduling's pending operations list\",\n \t 32)\n \n+DEFPARAM(PARAM_LARGE_FUNCTION_INSNS,\n+\t \"large-function-insns\",\n+\t \"The size of function body to be considered large\",\n+\t 10000)\n+DEFPARAM(PARAM_LARGE_FUNCTION_GROWTH,\n+\t \"large-function-growth\",\n+\t \"Maximal growth due to inlining of large function (in percents)\",\n+\t 100)\n+DEFPARAM(PARAM_INLINE_UNIT_GROWTH,\n+\t \"inline-unit-growth\",\n+\t \"how much can given compilation unit grow because of the inlining (in percents)\",\n+\t 50)\n+\n /* The GCSE optimization will be disabled if it would require\n    significantly more memory than this value.  */\n DEFPARAM(PARAM_MAX_GCSE_MEMORY,"}, {"sha": "f9ee4658315524dd39201691e6be6bc8c56ebc5a", "filename": "gcc/testsuite/g++.dg/warn/Winline-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinline-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinline-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinline-1.C?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -1,4 +1,4 @@\n-// { dg-options \"-Winline -O2\" }\n+// { dg-options \"-Winline -O2 -fno-unit-at-a-time\" }\n \n static inline int foo(int x); // { dg-warning \"\" }\n "}, {"sha": "3cfe702048e2ac41cd699445cce44b46d1fe0485", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b11577a908528c37111404a161f744ca3a694/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b11577a908528c37111404a161f744ca3a694/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b58b11577a908528c37111404a161f744ca3a694", "patch": "@@ -106,6 +106,7 @@ typedef struct inline_data\n   htab_t tree_pruner;\n   /* Decl of function we are inlining into.  */\n   tree decl;\n+  tree current_decl;\n } inline_data;\n \n /* Prototypes.  */\n@@ -1145,6 +1146,10 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   if (!fn)\n     return NULL_TREE;\n \n+  /* Turn forward declarations into real ones.  */\n+  if (flag_unit_at_a_time)\n+    fn = cgraph_node (fn)->decl;\n+\n   /* If fn is a declaration of a function in a nested scope that was\n      globally declared inline, we don't set its DECL_INITIAL.\n      However, we can't blindly follow DECL_ABSTRACT_ORIGIN because the\n@@ -1159,9 +1164,9 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  if ((!flag_unit_at_a_time || !DECL_SAVED_TREE (fn)\n-       || !cgraph_global_info (fn)->inline_once)\n-      && !inlinable_function_p (fn, id, 0))\n+  if (!DECL_SAVED_TREE (fn)\n+      || (flag_unit_at_a_time && !cgraph_inline_p (id->current_decl, fn))\n+      || (!flag_unit_at_a_time && !inlinable_function_p (fn, id, 0)))\n     {\n       if (warn_inline && DECL_INLINE (fn) && !DID_INLINE_FUNC (fn)\n \t  && !DECL_IN_SYSTEM_HEADER (fn))\n@@ -1403,7 +1408,12 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n     }\n \n   /* Recurse into the body of the just inlined function.  */\n-  expand_calls_inline (inlined_body, id);\n+  {\n+    tree old_decl = id->current_decl;\n+    id->current_decl = fn;\n+    expand_calls_inline (inlined_body, id);\n+    id->current_decl = old_decl;\n+  }\n   VARRAY_POP (id->fns);\n \n   /* If we've returned to the top level, clear out the record of how\n@@ -1446,6 +1456,7 @@ optimize_inline_calls (tree fn)\n   memset (&id, 0, sizeof (id));\n \n   id.decl = fn;\n+  id.current_decl = fn;\n   /* Don't allow recursion into FN.  */\n   VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n   VARRAY_PUSH_TREE (id.fns, fn);"}]}