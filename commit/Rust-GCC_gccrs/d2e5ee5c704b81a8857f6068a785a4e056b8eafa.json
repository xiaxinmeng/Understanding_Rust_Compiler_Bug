{"sha": "d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJlNWVlNWM3MDRiODFhODg1N2Y2MDY4YTc4NWE0ZTA1NmI4ZWFmYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-12-18T02:46:25Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-12-18T02:46:25Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13321", "tree": {"sha": "8756793fee8ba11b6c6e2195d2a9521061792978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8756793fee8ba11b6c6e2195d2a9521061792978"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/comments", "author": null, "committer": null, "parents": [{"sha": "f442f7234e0059d1273207752894ef364cd6078c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f442f7234e0059d1273207752894ef364cd6078c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f442f7234e0059d1273207752894ef364cd6078c"}], "stats": {"total": 516, "additions": 318, "deletions": 198}, "files": [{"sha": "c178546581f15e3b06c1871a9f643189a580db63", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 92, "deletions": 15, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1,3 +1,92 @@\n+Mon Dec 16 22:43:31 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cp-tree.h (ptr_reasonably_similar): Add decl.\n+\n+Thu Dec 12 15:00:35 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (grokvardecl): Change SPECBITS parm to be the SPECBITS_IN\n+\tpointer.  New local SPECBITS with the parm's value.\n+\t(grokdeclarator): Pass &specbits down.\n+\n+\t* parse.y (expr_no_commas): Make sure $$ is not an error_mark_node\n+\tbefore we try to do C_SET_EXP_ORIGINAL_CODE on it.\n+\n+\t* search.c (envelope_add_decl): Check that the CLASSTYPE_CID of\n+\tCONTEXT is not 0 before we try to use TYPE_DERIVES_FROM.\n+\n+\t* decl.c (cplus_expand_expr_stmt): Only expand the expr if EXP is\n+\tnot an error_mark_node.\n+\n+Sat Dec  7 17:20:22 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (TYPE_MAIN_DECL): Use TYPE_STUB_DECL.\n+\t* *.c: Use TYPE_MAIN_DECL instead of TYPE_NAME where appropriate.\n+\t\n+Fri Dec  6 14:40:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): When giving an anonymous struct a name,\n+\treplace TYPE_NAME instead of TYPE_IDENTIFIER (so TYPE_STUB_DECL is\n+\tnot affected).\n+\n+\t* typeck2.c (build_m_component_ref): If component is a pointer\n+\tto data member, resolve the OFFSET_REF now.\n+\n+\t* call.c (convert_like): Don't go into infinite recursion.\n+\n+\t* pt.c (coerce_template_parms): Use tsubst_expr for non-type args.\n+\n+\t* class.c (finish_struct_1): Set DECL_ARTIFICIAL on the vptr.\n+\t* tree.c (layout_basetypes): And on the vbase ptr.\n+\n+Thu Dec  5 02:11:28 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (BOOL_TYPE_SIZE): Define in terms of POINTER_SIZE or\n+\tCHAR_TYPE_SIZE so bool is always the same size as another type.\n+\n+\t* decl.c (pushtag): Set DECL_IGNORED_P for DWARF, too.\n+\n+Tue Dec  3 23:18:37 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (grok_x_components): Remove synthesized methods from\n+ \tTYPE_METHODS of an anonymous union, complain about member\n+ \tfunctions.\n+\t* decl.c (shadow_tag): Wipe out memory of synthesized methods in\n+\tanonymous unions.\n+\t(finish_function): Just clear the DECL_RTL of our arguments.\n+\n+Fri Nov 29 21:54:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_file): Emit DWARF debugging info for static data\n+\tmembers.\n+\n+\t* pt.c (tsubst): If t is a stub decl, return the stub decl for type.\n+\n+Wed Nov 27 14:47:15 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (build_component_ref): Don't die if COMPONENT isn't a\n+ \tIDENTIFIER_NODE.\n+\n+Wed Nov 27 16:05:19 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n+\n+\t* Make-lang.in (g++-cross$(exeext)): Fix typo.\n+\n+Wed Nov 27 08:14:00 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\tMake the g++ driver now be a standalone program, rather than one\n+\tthat tries to run the gcc driver after munging up the options.\n+\t* Make-lang.in (g++.c, g++spec.o): New rules.\n+\t(g++.o): New rule, based on gcc.o with -DLANG_SPECIFIC_DRIVER\n+\tadded.\n+\t(g++$(exeext)): New rule, based on xgcc rule.\n+\t(g++-cross$(exeext)): Now just copies g++$(exeext) over.\n+\t* g++spec.c: New file.\n+\t* g++.c: Removed file.\n+\n+Tue Nov 26 19:01:09 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Arrange for any temporary values\n+\tthat have been keep in registers until now to be put into memory.\n+\n Mon Nov 25 15:16:41 1996  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in (c++.stage[1234]): Depend upon stage[1-4]-start, so\n@@ -12,8 +101,6 @@ Thu Nov 21 16:30:24 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \t* typeck.c (c_expand_return): Fix logic.\n \t(unary_complex_lvalue): Avoid unused warning on address of INIT_EXPR.\n \n-\t* decl.c (grokfndecl): Also note_debug_info_needed on ctype here.\n-\n Wed Nov 20 18:47:31 1996  Bob Manson  <manson@charmed.cygnus.com>\n \n \t* g++.c (main): Make sure arglist has a final NULL entry.  Add\n@@ -186,20 +273,10 @@ Mon Nov 11 13:20:34 1996  Bob Manson  <manson@charmed.cygnus.com>\n Fri Nov  8 17:38:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Don't emit debug info.\n-\t* decl.c (start_function): Call note_debug_info_needed for context.\n-\t(start_decl): Likewise.\n-\t(cp_finish_decl): Not here.\n-\t(finish_function): Or here.\n-\t(pushdecl): Lose obsolete code.\n+\t* decl.c (pushdecl): Lose obsolete code.\n \t(grokdeclarator): Still do the long long thing after complaining.\n-\t(finish_enum): Don't call rest_of_type_compilation\n-\tfor DWARF.\n-\t* class.c (finish_struct_1): Don't call rest_of_type_compilation\n-\tfor DWARF.\n-\t* search.c (dfs_debug_mark): For DWARF, just call\n- \trest_of_type_compilation.\n-\t(note_debug_info_needed): Don't do anything if we're in a template.\n-\t* parse.y (named_complex_class_head_sans_basetype): Likewise.\n+\t* search.c (note_debug_info_needed): Don't do anything if we're in a \n+\ttemplate.\n \t* method.c (synthesize_method): For non-local classes,\n  \tpush_to_top_level first.\n "}, {"sha": "c4400b346a4cb9ef0fac9dc49103fdc719fb224e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -71,14 +71,32 @@ C++ c++: cc1plus\n # Tell GNU make to ignore these if they exist.\n .PHONY: C++ c++\n \n+g++.c: $(srcdir)/gcc.c\n+\t-rm -f $@\n+\tln -s $(srcdir)/gcc.c $@ || cp $(srcdir)/gcc.c $@\n+\n+g++spec.o: $(srcdir)/cp/g++spec.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+# N.B.: This is a copy of the gcc.o rule, with -DLANG_SPECIFIC_DRIVER added.\n+# It'd be nice if we could find an easier way to do this---rather than have\n+# to track changes to the toplevel gcc Makefile as well.\n+# We depend on g++.c last, to make it obvious where it came from.\n+g++.o: $(CONFIG_H) multilib.h config.status $(lang_specs_files) g++.c\n+\t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(DRIVER_DEFINES) \\\n+\t-DLANG_SPECIFIC_DRIVER \\\n+  -c g++.c\n+\n # Create the compiler driver for g++.\n-g++: $(srcdir)/cp/g++.c $(CONFIG_H) choose-temp.o pexecute.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o $@ $(srcdir)/cp/g++.c choose-temp.o pexecute.o $(LIBS)\n+g++$(exeext): g++.o g++spec.o version.o choose-temp.o pexecute.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ g++.o g++spec.o version.o \\\n+\t  choose-temp.o pexecute.o $(EXTRA_GCC_OBJS) $(LIBS)\n \n # Create a version of the g++ driver which calls the cross-compiler.\n-g++-cross: $(srcdir)/cp/g++.c choose-temp.o pexecute.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o $@ \\\n-\t   -DGCC_NAME=\\\"$(GCC_CROSS_NAME)\\\" $(srcdir)/cp/g++.c choose-temp.o pexecute.o $(LIBS)\n+g++-cross$(exeext): g++$(exeext)\n+\t-rm -f g++-cross$(exeext)\n+\tcp g++$(exeext) g++-cross$(exeext)\n \n cxxmain.o: cplus-dem.c demangle.h\n \trm -f cxxmain.c"}, {"sha": "51192fb36ec59346ea50ad1823b41a1c2f2d4f79", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1281,7 +1281,7 @@ find_scoped_type (type, inner_name, inner_types)\n       if (TREE_PURPOSE (tags) == inner_name)\n \t{\n \t  if (inner_types == NULL_TREE)\n-\t    return TYPE_NAME (TREE_VALUE (tags));\n+\t    return TYPE_MAIN_DECL (TREE_VALUE (tags));\n \t  return resolve_scope_to_name (TREE_VALUE (tags), inner_types);\n \t}\n       tags = TREE_CHAIN (tags);\n@@ -1326,7 +1326,7 @@ resolve_scope_to_name (outer_type, inner_stuff)\n \n \t  if (rval != NULL_TREE)\n \t    return rval;\n-\t  type = DECL_CONTEXT (TYPE_NAME (type));\n+\t  type = DECL_CONTEXT (TYPE_MAIN_DECL (type));\n \t}\n     }\n \n@@ -4240,6 +4240,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n       cand = candidates;\t/* any one will do */\n       cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n       ICS_USER_FLAG (cand->second_conv) = 1;\n+      ICS_BAD_FLAG (cand->second_conv) = 1;\n \n       return cand;\n     }\n@@ -4821,7 +4822,9 @@ static tree\n convert_like (convs, expr)\n      tree convs, expr;\n {\n-  if (ICS_BAD_FLAG (convs))\n+  if (ICS_BAD_FLAG (convs)\n+      && TREE_CODE (convs) != USER_CONV\n+      && TREE_CODE (convs) != AMBIG_CONV)\n     {\n       tree t = convs; \n       for (; t; t = TREE_OPERAND (t, 0))"}, {"sha": "8d766b69bd9ffaba16b306ec9bde89b579dce756", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1793,8 +1793,7 @@ finish_struct_bits (t, max_has_virtual)\n \t  && CLASSTYPE_NON_AGGREGATE (t)))\n     {\n       tree variants;\n-      if (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n-\tDECL_MODE (TYPE_NAME (t)) = BLKmode;\n+      DECL_MODE (TYPE_MAIN_DECL (t)) = BLKmode;\n       for (variants = t; variants; variants = TYPE_NEXT_VARIANT (variants))\n \t{\n \t  TYPE_MODE (variants) = BLKmode;\n@@ -1997,7 +1996,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \n   if (nonprivate_method == 0\n       && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-      && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE)\n+      && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE)\n     {\n       tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n       for (i = 0; i < n_baseclasses; i++)\n@@ -2022,7 +2021,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tTYPE_HAS_DESTRUCTOR (t) = 0;\n       else if (TREE_PRIVATE (dtor)\n \t       && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-\t       && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE\n+\t       && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE\n \t       && warn_ctor_dtor_privacy)\n \tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n \t\t    t);\n@@ -3644,7 +3643,7 @@ finish_struct_1 (t, warn_anon)\n \n       if (TYPE_HAS_CONSTRUCTOR (t)\n \t  && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n-\t  && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE)\n+\t  && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE)\n \t{\n \t  int nonprivate_ctor = 0;\n \t  tree ctor;\n@@ -3748,6 +3747,7 @@ finish_struct_1 (t, warn_anon)\n       DECL_ASSEMBLER_NAME (vfield) = get_identifier (VFIELD_BASE);\n       CLASSTYPE_VFIELD (t) = vfield;\n       DECL_VIRTUAL_P (vfield) = 1;\n+      DECL_ARTIFICIAL (vfield) = 1;\n       DECL_FIELD_CONTEXT (vfield) = t;\n       DECL_CLASS_CONTEXT (vfield) = t;\n       DECL_FCONTEXT (vfield) = t;\n@@ -3861,8 +3861,7 @@ finish_struct_1 (t, warn_anon)\n      value for DECL_OFFSET, so that we can use it as part\n      of a COMPONENT_REF for multiple inheritance.  */\n \n-  if (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n-    layout_decl (TYPE_NAME (t), 0);\n+  layout_decl (TYPE_MAIN_DECL (t), 0);\n \n   /* Now fix up any virtual base class types that we left lying\n      around.  We must get these done before we try to lay out the\n@@ -4174,9 +4173,9 @@ finish_struct_1 (t, warn_anon)\n     {\n       /* Be smarter about nested classes here.  If a type is nested,\n \t only output it if we would output the enclosing type.  */\n-      if (DECL_CONTEXT (TYPE_NAME (t))\n-\t  && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (TYPE_NAME (t)))) == 't')\n-\tDECL_IGNORED_P (TYPE_NAME (t)) = TREE_ASM_WRITTEN (TYPE_NAME (t));\n+      if (DECL_CONTEXT (TYPE_MAIN_DECL (t))\n+\t  && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (TYPE_MAIN_DECL (t)))) == 't')\n+\tDECL_IGNORED_P (TYPE_MAIN_DECL (t)) = TREE_ASM_WRITTEN (TYPE_MAIN_DECL (t));\n     }\n #endif\n \n@@ -4199,24 +4198,24 @@ finish_struct_1 (t, warn_anon)\n \t  /* Don't output full info about any type\n \t     which does not have its implementation defined here.  */\n \t  if (TYPE_VIRTUAL_P (t) && write_virtuals == 2)\n-\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t))\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t))\n \t      = (value_member (TYPE_IDENTIFIER (t), pending_vtables) == 0);\n \t  else if (CLASSTYPE_INTERFACE_ONLY (t))\n-\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n #if 0\n \t  /* XXX do something about this.  */\n \t  else if (CLASSTYPE_INTERFACE_UNKNOWN (t))\n \t    /* Only a first approximation!  */\n-\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n #endif\n \t}\n       else if (CLASSTYPE_INTERFACE_ONLY (t))\n-\tTYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n-\n-      /* Finish debugging output for this type.  */\n-      rest_of_type_compilation (t, toplevel_bindings_p ());\n+\tTYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n     }\n \n+  /* Finish debugging output for this type.  */\n+  rest_of_type_compilation (t, toplevel_bindings_p ());\n+\n   return t;\n }\n \n@@ -4355,7 +4354,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n       CLASSTYPE_TAGS (t) = x = nreverse (CLASSTYPE_TAGS (t));\n       while (x)\n \t{\n-\t  tree tag = TYPE_NAME (TREE_VALUE (x));\n+\t  tree tag = TYPE_MAIN_DECL (TREE_VALUE (x));\n \n \t  TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n \t  x = TREE_CHAIN (x);\n@@ -4747,7 +4746,7 @@ push_nested_class (type, modify)\n       || TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     return;\n   \n-  context = DECL_CONTEXT (TYPE_NAME (type));\n+  context = DECL_CONTEXT (TYPE_MAIN_DECL (type));\n \n   if (context && TREE_CODE (context) == RECORD_TYPE)\n     push_nested_class (context, 2);\n@@ -4760,7 +4759,7 @@ void\n pop_nested_class (modify)\n      int modify;\n {\n-  tree context = DECL_CONTEXT (TYPE_NAME (current_class_type));\n+  tree context = DECL_CONTEXT (TYPE_MAIN_DECL (current_class_type));\n \n   popclass (modify);\n   if (context && TREE_CODE (context) == RECORD_TYPE)"}, {"sha": "3ec8df67f65132328df7e7c2bda03b1762e54403", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -312,7 +312,7 @@ enum languages { lang_c, lang_cplusplus };\n #define TYPE_ASSEMBLER_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n \n /* The _DECL for this _TYPE.  */\n-#define TYPE_MAIN_DECL(NODE) (TYPE_NAME (NODE))\n+#define TYPE_MAIN_DECL(NODE) (TYPE_STUB_DECL (TYPE_MAIN_VARIANT (NODE)))\n \n #define IS_AGGR_TYPE(t)\t\t(TYPE_LANG_FLAG_5 (t))\n #define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE)\n@@ -2470,6 +2470,7 @@ extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, char *, tr\n extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, int));\n extern void c_expand_return\t\t\tPROTO((tree));\n extern tree c_expand_start_case\t\t\tPROTO((tree));\n+extern int ptr_reasonably_similar\t\tPROTO((tree, tree));\n extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n "}, {"sha": "aff7dee1c8e8e1db8db214e6d3f49f77f61fe0a5", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -340,8 +340,9 @@ convert_to_pointer_force (type, expr)\n \t  if (distance == -2)\n \t    {\n \t    ambig:\n-\t      cp_error (\"type `%T' is ambiguous baseclass of `%s'\", TREE_TYPE (type),\n-\t\t\t\t    TYPE_NAME_STRING (TREE_TYPE (intype)));\n+\t      cp_error (\"type `%T' is ambiguous baseclass of `%s'\",\n+\t\t\tTREE_TYPE (type),\n+\t\t\tTYPE_NAME_STRING (TREE_TYPE (intype)));\n \t      return error_mark_node;\n \t    }\n \t  if (distance == -1)\n@@ -608,6 +609,10 @@ build_up_reference (type, arg, flags, checkconst)\n       arg = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE, NULL_TREE);\n     }\n \n+  /* If we had a way to wrap this up, and say, if we ever needed it's\n+     address, transform all occurrences of the register, into a memory\n+     reference we could win better.  */\n+  mark_addressable (arg);\n   rval = build1 (ADDR_EXPR, type, arg);\n \n  done:"}, {"sha": "43a60d6f0519d8c99fa7a64f5e16712ac2879a23", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 76, "deletions": 101, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -99,9 +99,9 @@ static struct stack_level *decl_stack;\n \n #ifndef BOOL_TYPE_SIZE\n #ifdef SLOW_BYTE_ACCESS\n-#define BOOL_TYPE_SIZE ((SLOW_BYTE_ACCESS) ? (BITS_PER_WORD) : (BITS_PER_UNIT))\n+#define BOOL_TYPE_SIZE ((SLOW_BYTE_ACCESS) ? (POINTER_SIZE) : (CHAR_TYPE_SIZE))\n #else\n-#define BOOL_TYPE_SIZE BITS_PER_UNIT\n+#define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n #endif\n #endif\n \n@@ -2070,7 +2070,7 @@ pushtag (name, type, globalize)\n \t\t  set_identifier_type_value_with_scope (name, type, b);\n \t\t}\n \t      else\n-\t\td = TYPE_NAME (d);\n+\t\td = TYPE_MAIN_DECL (d);\n \n \t      TYPE_NAME (type) = d;\n \t      DECL_CONTEXT (d) = context;\n@@ -2088,7 +2088,7 @@ pushtag (name, type, globalize)\n \t      newdecl = 1;\n \t      d = build_decl (TYPE_DECL, name, type);\n \t      SET_DECL_ARTIFICIAL (d);\n-\t      TYPE_MAIN_DECL (type) = d;\n+\t      TYPE_NAME (type) = d;\n \t      DECL_CONTEXT (d) = context;\n \t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n \t\tpush_template_decl (d);\n@@ -2097,11 +2097,8 @@ pushtag (name, type, globalize)\n \t    }\n \t  if (newdecl)\n \t    {\n-\t      if (write_symbols != DWARF_DEBUG && write_symbols != DWARF2_DEBUG)\n-\t\t{\n-\t\t  if (ANON_AGGRNAME_P (name))\n-\t\t    DECL_IGNORED_P (d) = 1;\n-\t\t}\n+\t      if (ANON_AGGRNAME_P (name))\n+\t\tDECL_IGNORED_P (d) = 1;\n \n \t      TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n \t      DECL_ASSEMBLER_NAME (d)\n@@ -4103,7 +4100,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t\t    if (TYPE_SIZE (context) == NULL_TREE)\n \t\t      goto no_context;\n \t\t    /* Go to next enclosing type, if any.  */\n-\t\t    context = DECL_CONTEXT (TYPE_NAME (context));\n+\t\t    context = DECL_CONTEXT (TYPE_MAIN_DECL (context));\n \t\t    break;\n \t        case 'd':\n \t\t    context = DECL_CONTEXT (context);\n@@ -4156,34 +4153,6 @@ lookup_tag_reverse (type, name)\n     }\n   return NULL_TREE;\n }\n-\n-/* Given type TYPE which was not declared in C++ language context,\n-   attempt to find a name by which it is referred.  */\n-\n-tree\n-typedecl_for_tag (tag)\n-     tree tag;\n-{\n-  struct binding_level *b = current_binding_level;\n-\n-  if (TREE_CODE (TYPE_NAME (tag)) == TYPE_DECL)\n-    return TYPE_NAME (tag);\n-\n-  while (b)\n-    {\n-      tree decls = b->names;\n-      while (decls)\n-\t{\n-\t  if (TREE_CODE (decls) == TYPE_DECL && TREE_TYPE (decls) == tag)\n-\t    break;\n-\t  decls = TREE_CHAIN (decls);\n-\t}\n-      if (decls)\n-\treturn decls;\n-      b = b->level_chain;\n-    }\n-  return NULL_TREE;\n-}\n \f\n /* Lookup TYPE in CONTEXT (a chain of nested types or a FUNCTION_DECL).\n    Return the type value, or NULL_TREE if not found.  */\n@@ -4288,7 +4257,8 @@ make_typename_type (context, name)\n     pop_obstacks ();\n \n   TYPE_CONTEXT (t) = context;\n-  TYPE_MAIN_DECL (TREE_TYPE (d)) = d;\n+  TYPE_NAME (TREE_TYPE (d)) = d;\n+  TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n   DECL_CONTEXT (d) = context;\n   CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \n@@ -4473,7 +4443,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t  || TREE_CODE (val) == TYPE_DECL || prefer_type <= 0)\n \t;\n       else if (IDENTIFIER_HAS_TYPE_VALUE (name))\n-\tval = TYPE_NAME (IDENTIFIER_TYPE_VALUE (name));\n+\tval = TYPE_MAIN_DECL (IDENTIFIER_TYPE_VALUE (name));\n       else if (TREE_TYPE (val) == error_mark_node)\n \tval = error_mark_node;\n     }\n@@ -5588,7 +5558,7 @@ shadow_tag (declspecs)\n       code = TREE_CODE (value);\n       if (IS_AGGR_TYPE_CODE (code) || code == ENUMERAL_TYPE)\n \t{\n-\t  my_friendly_assert (TYPE_NAME (value) != NULL_TREE, 261);\n+\t  my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n \n \t  if (IS_AGGR_TYPE (value) && CLASSTYPE_USE_TEMPLATE (value))\n \t    {\n@@ -5629,16 +5599,33 @@ shadow_tag (declspecs)\n \t  || (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))))\n     {\n+      /* See also grok_x_components.  */\n+\n       tree fn;\n+      tree *q;\n+\n+      /* Wipe out memory of synthesized methods */\n+      TYPE_HAS_CONSTRUCTOR (t) = 0;\n+      TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n+      TYPE_HAS_INIT_REF (t) = 0;\n+      TYPE_HAS_CONST_INIT_REF (t) = 0;\n+      TYPE_HAS_ASSIGN_REF (t) = 0;\n+      TYPE_HAS_ASSIGNMENT (t) = 0;\n+      TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n+\n+      q = &TYPE_METHODS (t);\n+      while (*q)\n+\t{\n+\t  if (DECL_ARTIFICIAL (*q))\n+\t    *q = TREE_CHAIN (*q);\n+\t  else\n+\t    q = &TREE_CHAIN (*q);\n+\t}\n \n       /* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have\n \t function members.  */\n-      for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n-\tif (! DECL_ARTIFICIAL (fn))\n-\t  {\n-\t    error (\"an anonymous union cannot have function members\");\n-\t    break;\n-\t  }\n+      if (TYPE_METHODS (t))\n+\terror (\"an anonymous union cannot have function members\");\n \n       if (TYPE_FIELDS (t))\n \t{\n@@ -5805,12 +5792,6 @@ start_decl (declarator, declspecs, initialized)\n \t  }\n       }\n \n-  /* Do this before the decl is actually defined so that the DWARF debug\n-     info for the class reflects the declaration, rather than the\n-     definition, of this decl.  */\n-  if (TREE_CODE (decl) == VAR_DECL && context)\n-    note_debug_info_needed (context);\n-\n   if (initialized)\n     {\n       if (! toplevel_bindings_p ()\n@@ -6239,7 +6220,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       /* If we have installed this as the canonical typedef for this\n \t type, and that type has not been defined yet, delay emitting\n \t the debug informaion for it, as we will emit it later.  */\n-      if (TYPE_NAME (TREE_TYPE (decl)) == decl\n+      if (TYPE_MAIN_DECL (TREE_TYPE (decl)) == decl\n \t  && TYPE_SIZE (TREE_TYPE (decl)) == NULL_TREE)\n \tTYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n \n@@ -6455,6 +6436,10 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t/* Let debugger know it should output info for this type.  */\n \tnote_debug_info_needed (ttype);\n \n+      if (TREE_STATIC (decl) && DECL_CONTEXT (decl)\n+\t  && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')\n+\tnote_debug_info_needed (DECL_CONTEXT (decl));\n+\n       if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n \t  && DECL_SIZE (decl) != NULL_TREE\n \t  && ! TREE_CONSTANT (DECL_SIZE (decl)))\n@@ -7124,15 +7109,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n     return decl;\n \n   if (check && funcdef_flag)\n-    {\n-      /* Do this before the decl is actually defined so that the DWARF debug\n-\t info for the class reflects the declaration, rather than the\n-\t definition, of this decl.  */\n-      if (ctype)\n-\tnote_debug_info_needed (ctype);\n-\n-      DECL_INITIAL (decl) = error_mark_node;\n-    }\n+    DECL_INITIAL (decl) = error_mark_node;\n \n   if (flags == NO_SPECIAL && ctype && constructor_name (cname) == declarator)\n     {\n@@ -7242,14 +7219,15 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n }\n \n static tree\n-grokvardecl (type, declarator, specbits, initialized, constp)\n+grokvardecl (type, declarator, specbits_in, initialized, constp)\n      tree type;\n      tree declarator;\n-     RID_BIT_TYPE specbits;\n+     RID_BIT_TYPE *specbits_in;\n      int initialized;\n      int constp;\n {\n   tree decl;\n+  RID_BIT_TYPE specbits = *specbits_in;\n \n   if (TREE_CODE (type) == OFFSET_TYPE)\n     {\n@@ -8965,6 +8943,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       if (constp || volatilep)\n \ttype = cp_build_type_variant (type, constp, volatilep);\n \n+      if (decl_context == FIELD)\n+\t{\n+\t  if (declarator == current_class_name)\n+\t    cp_pedwarn (\"ANSI C++ forbids nested type `%D' with same name as enclosing class\",\n+\t\t\tdeclarator);\n+\t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n+\t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n+\t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n+\t}\n+      else\n+\tdecl = build_decl (TYPE_DECL, declarator, type);\n+\n       /* If the user declares \"struct {...} foo\" then `foo' will have\n \t an anonymous name.  Fill that name in now.  Nothing can\n \t refer to it, so nothing needs know about the name change.\n@@ -8976,31 +8966,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t{\n \t  /* replace the anonymous name with the real name everywhere.  */\n \t  lookup_tag_reverse (type, declarator);\n-\t  TYPE_IDENTIFIER (type) = declarator;\n+\t  TYPE_NAME (type) = decl;\n \n \t  if (TYPE_LANG_SPECIFIC (type))\n \t    TYPE_WAS_ANONYMOUS (type) = 1;\n \n-\t  {\n-\t    tree d = TYPE_NAME (type), c = DECL_CONTEXT (d);\n-\n-\t    DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n-\t    DECL_ASSEMBLER_NAME (d)\n-\t      = get_identifier (build_overload_name (type, 1, 1));\n-\t  }\n-\t}\n-\n-      if (decl_context == FIELD)\n-\t{\n-\t  if (declarator == current_class_name)\n-\t    cp_pedwarn (\"ANSI C++ forbids nested type `%D' with same name as enclosing class\",\n-\t\t\tdeclarator);\n-\t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n-\t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n-\t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n+\t  DECL_ASSEMBLER_NAME (decl) = DECL_NAME (decl);\n+\t  DECL_ASSEMBLER_NAME (decl)\n+\t    = get_identifier (build_overload_name (type, 1, 1));\n \t}\n-      else\n-\tdecl = build_decl (TYPE_DECL, declarator, type);\n \n       if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)\n \t{\n@@ -9290,7 +9264,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t       instantiation made the field's type be incomplete.  */\n \t    if (current_class_type\n \t\t&& TYPE_NAME (current_class_type)\n-\t\t&& IDENTIFIER_TEMPLATE (DECL_NAME (TYPE_NAME (current_class_type)))\n+\t\t&& IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (current_class_type))\n \t\t&& declspecs && TREE_VALUE (declspecs)\n \t\t&& TREE_TYPE (TREE_VALUE (declspecs)) == type)\n \t      cp_error (\"  in instantiation of template `%T'\",\n@@ -9519,7 +9493,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  }\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, declarator, specbits, initialized, constp);\n+\tdecl = grokvardecl (type, declarator, &specbits, initialized, constp);\n \tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n \n@@ -10719,8 +10693,7 @@ finish_enum (enumtype, values)\n   }\n \n   /* Finish debugging output for this type.  */\n-  if (write_symbols != DWARF_DEBUG && write_symbols != DWARF2_DEBUG)\n-    rest_of_type_compilation (enumtype, global_bindings_p ());\n+  rest_of_type_compilation (enumtype, global_bindings_p ());\n \n   return enumtype;\n }\n@@ -10912,8 +10885,8 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       if (! DECL_ARGUMENTS (decl1)\n \t  && !DECL_STATIC_FUNCTION_P (decl1)\n \t  && DECL_CONTEXT (decl1)\n-\t  && DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl1)))\n-\t  && IDENTIFIER_TEMPLATE (DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl1)))))\n+\t  && TYPE_IDENTIFIER (DECL_CONTEXT (decl1))\n+\t  && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (DECL_CONTEXT (decl1))))\n \t{\n \t  cp_error (\"redeclaration of `%#D'\", decl1);\n \t  if (IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1)))\n@@ -10999,12 +10972,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t}\n     }\n \n-  /* Do this before the decl is actually defined so that the DWARF debug\n-     info for the class reflects the declaration, rather than the\n-     definition, of this decl.  */\n-  if (DECL_FUNCTION_MEMBER_P (decl1))\n-    note_debug_info_needed (DECL_CLASS_CONTEXT (decl1));\n-\n   /* Warn if function was previously implicitly declared\n      (but not if we warned then).  */\n   if (! warn_implicit\n@@ -11991,6 +11958,9 @@ finish_function (lineno, call_poplevel, nested)\n \t  mark_inline_for_output (fndecl);\n \t}\n \n+      if (ctype && TREE_ASM_WRITTEN (fndecl))\n+\tnote_debug_info_needed (ctype);\n+\n       current_function_returns_null |= can_reach_end;\n \n       /* Since we don't normally go through c_expand_return for constructors,\n@@ -12034,13 +12004,14 @@ finish_function (lineno, call_poplevel, nested)\n \n   if (DECL_SAVED_INSNS (fndecl) == NULL_RTX)\n     {\n+      tree t;\n+\n       /* Stop pointing to the local nodes about to be freed.  */\n       /* But DECL_INITIAL must remain nonzero so we know this\n \t was an actual function definition.  */\n       DECL_INITIAL (fndecl) = error_mark_node;\n-      /* And we need the arguments for template instantiation.  */\n-      if (! processing_template_decl)\n-\tDECL_ARGUMENTS (fndecl) = NULL_TREE;\n+      for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n+\tDECL_RTL (t) = NULL_RTX;\n     }\n \n   if (DECL_STATIC_CONSTRUCTOR (fndecl))\n@@ -12411,7 +12382,11 @@ cplus_expand_expr_stmt (exp)\n \t libg++ to miscompile, and tString to core dump.  */\n       exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n #endif\n-      expand_expr_stmt (break_out_cleanups (exp));\n+      /* If we don't do this, we end up down inside expand_expr\n+\t trying to do TYPE_MODE on the ERROR_MARK, and really\n+\t go outside the bounds of the type.  */\n+      if (exp != error_mark_node)\n+\texpand_expr_stmt (break_out_cleanups (exp));\n     }\n \n   /* Clean up any pending cleanups.  This happens when a function call"}, {"sha": "85b58761ef7b83610c0a2f9ea64ae6a5b390acdb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -778,7 +778,10 @@ grok_x_components (specs, components)\n \t  if (TREE_CODE (t) == UNION_TYPE\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n \t    {\n+\t      /* See also shadow_tag.  */\n+\n \t      struct pending_inline **p;\n+\t      tree *q;\n \t      x = build_lang_field_decl (FIELD_DECL, NULL_TREE, t);\n \n \t      /* Wipe out memory of synthesized methods */\n@@ -790,6 +793,17 @@ grok_x_components (specs, components)\n \t      TYPE_HAS_ASSIGNMENT (t) = 0;\n \t      TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n \n+\t      q = &TYPE_METHODS (t);\n+\t      while (*q)\n+\t\t{\n+\t\t  if (DECL_ARTIFICIAL (*q))\n+\t\t    *q = TREE_CHAIN (*q);\n+\t\t  else\n+\t\t    q = &TREE_CHAIN (*q);\n+\t\t}\n+\t      if (TYPE_METHODS (t))\n+\t\terror (\"an anonymous union cannot have function members\");\n+\n \t      p = &pending_inlines;\n \t      for (; *p; *p = (*p)->next)\n \t\tif (DECL_CONTEXT ((*p)->fndecl) != t)\n@@ -2163,6 +2177,7 @@ finish_builtin_type (type, name, fields, len, align_type)\n #else\n   TYPE_NAME (type) = build_decl (TYPE_DECL, get_identifier (name), type);\n #endif\n+  TYPE_STUB_DECL (type) = TYPE_NAME (type);\n   layout_decl (TYPE_NAME (type), 0);\n }\n \f\n@@ -2989,13 +3004,20 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (pending_statics);\n \n-      if (TREE_USED (decl) == 1\n-\t  || TREE_READONLY (decl) == 0\n-\t  || DECL_INITIAL (decl) == 0)\n-\t{\n-\t  DECL_DEFER_OUTPUT (decl) = 0;\n-\t  rest_of_decl_compilation (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), 1, 1);\n-\t}\n+      /* Output DWARF debug information.  */\n+#ifdef DWARF_DEBUGGING_INFO\n+      if (write_symbols == DWARF_DEBUG)\n+\tdwarfout_file_scope_decl (decl, 1);\n+#endif\n+#ifdef DWARF2_DEBUGGING_INFO\n+      if (write_symbols == DWARF2_DEBUG)\n+\tdwarf2out_decl (decl);\n+#endif\n+\n+      DECL_DEFER_OUTPUT (decl) = 0;\n+      rest_of_decl_compilation\n+\t(decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), 1, 1);\n+\n       pending_statics = TREE_CHAIN (pending_statics);\n     }\n "}, {"sha": "47b821e55d20d0e0eedce087f658a2451a4c5ab2", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1486,7 +1486,7 @@ cp_file_of (t)\n   if (TREE_CODE (t) == PARM_DECL)\n     return DECL_SOURCE_FILE (DECL_CONTEXT (t));\n   else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    return DECL_SOURCE_FILE (TYPE_NAME (t));\n+    return DECL_SOURCE_FILE (TYPE_MAIN_DECL (t));\n   else\n     return DECL_SOURCE_FILE (t);\n }\n@@ -1502,7 +1502,7 @@ cp_line_of (t)\n     t = TREE_TYPE (t);\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n-    line = DECL_SOURCE_LINE (TYPE_NAME (t));\n+    line = DECL_SOURCE_LINE (TYPE_MAIN_DECL (t));\n   else\n     line = DECL_SOURCE_LINE (t);\n "}, {"sha": "006e13f83e5cd5d188cc6a2fa69069abd964b6c2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -2227,7 +2227,7 @@ is_friend (type, supplicant)\n   if (declp)\n     /* It's a function decl.  */\n     {\n-      tree list = DECL_FRIENDLIST (TYPE_NAME (type));\n+      tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type));\n       tree name = DECL_NAME (supplicant);\n       tree ctype;\n \n@@ -2259,7 +2259,7 @@ is_friend (type, supplicant)\n       if (type == supplicant)\n \treturn 1;\n       \n-      list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_NAME (type)));\n+      list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_MAIN_DECL (type)));\n       for (; list ; list = TREE_CHAIN (list))\n \tif (supplicant == TREE_VALUE (list))\n \t  return 1;\n@@ -2275,7 +2275,7 @@ is_friend (type, supplicant)\n \tif (IS_AGGR_TYPE (supplicant))\n \t  context = NULL_TREE;\n \telse\n-\t  context = DECL_CONTEXT (TYPE_NAME (supplicant));\n+\t  context = DECL_CONTEXT (TYPE_MAIN_DECL (supplicant));\n       }\n     else if (DECL_FUNCTION_MEMBER_P (supplicant))\n       context = DECL_CLASS_CONTEXT (supplicant);\n@@ -2296,7 +2296,7 @@ static void\n add_friend (type, decl)\n      tree type, decl;\n {\n-  tree typedecl = TYPE_NAME (type);\n+  tree typedecl = TYPE_MAIN_DECL (type);\n   tree list = DECL_FRIENDLIST (typedecl);\n   tree name = DECL_NAME (decl);\n \n@@ -2346,7 +2346,7 @@ static void\n add_friends (type, name, friend_type)\n      tree type, name, friend_type;\n {\n-  tree typedecl = TYPE_NAME (type);\n+  tree typedecl = TYPE_MAIN_DECL (type);\n   tree list = DECL_FRIENDLIST (typedecl);\n \n   while (list)\n@@ -2409,7 +2409,7 @@ make_friend_class (type, friend_type)\n   if (IS_SIGNATURE (friend_type))\n     {\n       error (\"signature type `%s' declared `friend'\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (friend_type))));\n+\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (friend_type)));\n       return;\n     }\n   if (type == friend_type)\n@@ -2561,7 +2561,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t  warning (\"implicitly declaring `%s' as struct\",\n \t\t   IDENTIFIER_POINTER (declarator));\n \t  decl = xref_tag (record_type_node, declarator, NULL_TREE, 1);\n-\t  decl = TYPE_NAME (decl);\n+\t  decl = TYPE_MAIN_DECL (decl);\n \t}\n \n       /* Allow abbreviated declarations of overloaded functions,\n@@ -2735,7 +2735,7 @@ build_new (placement, decl, init, use_global_new)\n \t{\n \t  /* An aggregate type.  */\n \t  type = IDENTIFIER_TYPE_VALUE (decl);\n-\t  decl = TYPE_NAME (type);\n+\t  decl = TYPE_MAIN_DECL (type);\n \t}\n       else\n \t{\n@@ -2755,7 +2755,7 @@ build_new (placement, decl, init, use_global_new)\n     {\n       type = decl;\n       true_type = type;\n-      decl = TYPE_NAME (type);\n+      decl = TYPE_MAIN_DECL (type);\n     }\n \n   if (processing_template_decl)"}, {"sha": "a34e4f0c44c95c78bebe7f9be51409e1d52945d1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1112,7 +1112,7 @@ set_vardecl_interface_info (prev, vars)\n   if (CLASSTYPE_INTERFACE_KNOWN (type))\n     {\n       if (CLASSTYPE_INTERFACE_ONLY (type))\n-\tset_typedecl_interface_info (prev, TYPE_NAME (type));\n+\tset_typedecl_interface_info (prev, TYPE_MAIN_DECL (type));\n       else\n \tCLASSTYPE_VTABLE_NEEDS_WRITING (type) = 1;\n       DECL_EXTERNAL (vars) = CLASSTYPE_INTERFACE_ONLY (type);\n@@ -2721,8 +2721,8 @@ identifier_typedecl_value (node)\n   do (IDENTIFIER_GLOBAL_VALUE (node));\n #undef do\n   /* Will this one ever happen?  */\n-  if (TYPE_NAME (type))\n-    return TYPE_NAME (type);\n+  if (TYPE_MAIN_DECL (type))\n+    return TYPE_MAIN_DECL (type);\n \n   /* We used to do an internal error of 62 here, but instead we will\n      handle the return of a null appropriately in the callers.  */\n@@ -3366,7 +3366,7 @@ real_yylex ()\n \t\t    ))\n \t      {\n \t\tpedwarn (\"floating point number exceeds range of `%s'\",\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+\t\t\t IDENTIFIER_POINTER (TYPE_IDENTIFIER (type)));\n \t      }\n \t    /* Note: garbage_chars is -1 if first char is *not* garbage.  */\n \t    while (isalnum (c))"}, {"sha": "80198c60e12af4b88b79967b37ea056f65ea8b88", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -324,7 +324,7 @@ build_overload_nested_name (decl)\n     {\n       tree context = DECL_CONTEXT (decl);\n       if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-\tcontext = TYPE_MAIN_DECL (context);\n+\tcontext = TYPE_NAME (context);\n       build_overload_nested_name (context);\n     }\n \n@@ -903,10 +903,10 @@ build_overload_name (parmtypes, begin, end)\n \t\tif (i > 9)\n \t\t  OB_PUTC ('_');\n \t\tnumeric_output_need_bar = 0;\n-\t\tbuild_overload_nested_name (TYPE_MAIN_DECL (parmtype));\n+\t\tbuild_overload_nested_name (TYPE_NAME (parmtype));\n \t      }\n \t    else\t      \n-\t      build_overload_identifier (TYPE_MAIN_DECL (parmtype));\n+\t      build_overload_identifier (TYPE_NAME (parmtype));\n \t    break;\n \t  }\n \n@@ -1075,7 +1075,7 @@ build_typename_overload (type)\n   id = get_identifier (obstack_base (&scratch_obstack));\n   IDENTIFIER_OPNAME_P (id) = 1;\n #if 0\n-  IDENTIFIER_GLOBAL_VALUE (id) = TYPE_NAME (type);\n+  IDENTIFIER_GLOBAL_VALUE (id) = TYPE_MAIN_DECL (type);\n #endif\n   TREE_TYPE (id) = type;\n   return id;"}, {"sha": "845bda2fe2db1ab61bc96090ebf7ffe9c8324339", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1208,7 +1208,8 @@ expr_no_commas:\n \t\t{ $$ = build_x_conditional_expr ($$, $3, $5); }\n \t| expr_no_commas '=' expr_no_commas\n \t\t{ $$ = build_x_modify_expr ($$, NOP_EXPR, $3);\n-                  C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }\n+\t\t  if ($$ != error_mark_node)\n+                    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }\n \t| expr_no_commas ASSIGN expr_no_commas\n \t\t{ $$ = build_x_modify_expr ($$, $2, $3); }\n \t| THROW\n@@ -2233,10 +2234,7 @@ named_complex_class_head_sans_basetype:\n \t\t{\n \t\t  current_aggr = $1;\n \t\t  if (TREE_CODE ($3) == TYPE_DECL)\n-\t\t    {\n-\t\t      $$ = $3;\n-\t\t      note_debug_info_needed (DECL_CONTEXT ($$));\n-\t\t    }\n+\t\t    $$ = $3;\n \t\t  else\n \t\t    {\n \t\t      cp_error (\"`%T' does not have a nested type named `%D'\","}, {"sha": "1a7d20efbba63c5b987cd888f32daff48c256d58", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -149,7 +149,8 @@ process_template_parm (list, next)\n       tree t = make_lang_type (TEMPLATE_TYPE_PARM);\n       CLASSTYPE_GOT_SEMICOLON (t) = 1;\n       decl = build_decl (TYPE_DECL, TREE_VALUE (parm), t);\n-      TYPE_MAIN_DECL (t) = decl;\n+      TYPE_NAME (t) = decl;\n+      TYPE_STUB_DECL (t) = decl;\n       parm = decl;\n       TEMPLATE_TYPE_SET_INFO (t, idx, processing_template_decl);\n     }\n@@ -372,9 +373,13 @@ coerce_template_parms (parms, arglist, in_decl)\n \t      else\n \t\targ = TREE_VALUE (arg);\n \t    }\n-\t  else\n+\t  else if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (parms, i)))\n+\t\t   == TYPE_DECL)\n \t    arg = tsubst (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n \t\t\t  &TREE_VEC_ELT (vec, 0), i, in_decl);\n+\t  else\n+\t    arg = tsubst_expr (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n+\t\t\t       &TREE_VEC_ELT (vec, 0), i, in_decl);\n \n \t  TREE_VEC_ELT (vec, i) = arg;\n \t}\n@@ -1679,6 +1684,9 @@ tsubst (t, args, nargs, in_decl)\n       }\n \n     case TYPE_DECL:\n+      if (t == TYPE_NAME (TREE_TYPE (t)))\n+\treturn TYPE_NAME (type);\n+\n       {\n \ttree r = copy_node (t);\n \tTREE_TYPE (r) = type;"}, {"sha": "25e68e9203a710326f86ac36689faf17951b5998", "filename": "gcc/cp/search.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -2542,17 +2542,6 @@ dfs_debug_mark (binfo)\n   if (methods == 0)\n     return;\n \n-  /* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which\n-     does not support name references between translation units.  Well, we\n-     could, but that would mean putting global labels in the debug output\n-     before each exported type and each of its functions and static data\n-     members.  */\n-  if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n-    {\n-      rest_of_type_compilation (t, global_bindings_p ());\n-      return;\n-    }\n-\n   /* If interface info is known, either we've already emitted the debug\n      info or we don't need to.  */\n   if (CLASSTYPE_INTERFACE_KNOWN (t)\n@@ -3138,6 +3127,14 @@ note_debug_info_needed (type)\n   if (current_template_parms)\n     return;\n \n+  /* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which\n+     does not support name references between translation units.  Well, we\n+     could, but that would mean putting global labels in the debug output\n+     before each exported type and each of its functions and static data\n+     members.  */\n+  if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n+    return;\n+\n   dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp);\n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     {\n@@ -3195,7 +3192,12 @@ envelope_add_decl (type, decl, values)\n \t  else\n \t    dont_add = 1;\n \t}\n-      else if (context && TYPE_DERIVES_FROM (context, type))\n+      /* If we don't check CLASSTYPE_CID on CONTEXT right now, we'll end\n+\t up subtracting from the address of MI_MATRIX, putting us off\n+\t in la la land.  */\n+      else if (context\n+\t       && CLASSTYPE_CID (context)\n+\t       && TYPE_DERIVES_FROM (context, type))\n \t{\n \t  /* Don't add in *values to list */\n \t  *values = NULL_TREE;\n@@ -3213,7 +3215,12 @@ envelope_add_decl (type, decl, values)\n \t  ? DECL_CLASS_CONTEXT (value)\n \t    : DECL_CONTEXT (value);\n \n-\tif (context && TYPE_DERIVES_FROM (context, type))\n+\t/* If we don't check CLASSTYPE_CID on CONTEXT right now, we'll end\n+\t   up subtracting from the address of MI_MATRIX, putting us off\n+\t   in la la land.  */\n+\tif (context\n+\t    && CLASSTYPE_CID (context)\n+\t    && TYPE_DERIVES_FROM (context, type))\n \t  {\n \t    /* remove *tmp from list */\n \t    *tmp = TREE_CHAIN (*tmp);"}, {"sha": "a5b791687d3a10e05299ea80cc8fba0ca019a55d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -817,6 +817,7 @@ layout_basetypes (rec, binfos)\n \t     them too.  */\n \t  DECL_ASSEMBLER_NAME (decl) = get_identifier (VTABLE_BASE);\n \t  DECL_VIRTUAL_P (decl) = 1;\n+\t  DECL_ARTIFICIAL (decl) = 1;\n \t  DECL_FIELD_CONTEXT (decl) = rec;\n \t  DECL_CLASS_CONTEXT (decl) = rec;\n \t  DECL_FCONTEXT (decl) = basetype;"}, {"sha": "fd083e16f93609485941b2c45fd7755d19e6afc1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1805,10 +1805,13 @@ build_component_ref (datum, component, basetype_path, protect)\n     }\n   else\n     {\n+      tree name = component;\n+      if (TREE_CODE (component) == VAR_DECL)\n+\tname = DECL_NAME (component);\n       if (basetype_path == NULL_TREE)\n \tbasetype_path = TYPE_BINFO (basetype);\n-      field = lookup_field (basetype_path, component,\n-\t\t\t    protect && ! VFIELD_NAME_P (component), 0);\n+      field = lookup_field (basetype_path, name,\n+\t\t\t    protect && !VFIELD_NAME_P (name), 0);\n       if (field == error_mark_node)\n \treturn error_mark_node;\n \n@@ -1817,7 +1820,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t  /* Not found as a data field, look for it as a method.  If found,\n \t     then if this is the only possible one, return it, else\n \t     report ambiguity error.  */\n-\t  tree fndecls = lookup_fnfields (basetype_path, component, 1);\n+\t  tree fndecls = lookup_fnfields (basetype_path, name, 1);\n \t  if (fndecls == error_mark_node)\n \t    return error_mark_node;\n \t  if (fndecls)\n@@ -1867,7 +1870,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t}\n \t    }\n \n-\t  cp_error (\"`%#T' has no member named `%D'\", basetype, component);\n+\t  cp_error (\"`%#T' has no member named `%D'\", basetype, name);\n \t  return error_mark_node;\n \t}\n       else if (TREE_TYPE (field) == error_mark_node)"}, {"sha": "e6f765e5bac6d00fe8d32e07d5c4b4ccff7b174a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2e5ee5c704b81a8857f6068a785a4e056b8eafa/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d2e5ee5c704b81a8857f6068a785a4e056b8eafa", "patch": "@@ -1377,7 +1377,10 @@ build_m_component_ref (datum, component)\n   else if (binfo == error_mark_node)\n     return error_mark_node;\n \n-  return build (OFFSET_REF, rettype, datum, component);\n+  component = build (OFFSET_REF, rettype, datum, component);\n+  if (TREE_CODE (type) == OFFSET_TYPE)\n+    component = resolve_offset_ref (component);\n+  return component;\n }\n \n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */"}]}