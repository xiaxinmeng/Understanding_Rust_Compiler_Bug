{"sha": "25837a2f78a9baa97f88b289a43a93a362c4d538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4MzdhMmY3OGE5YmFhOTdmODhiMjg5YTQzYTkzYTM2MmM0ZDUzOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-09-23T17:30:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-09-23T17:30:34Z"}, "message": "inline-1.c: new testcase.\n\n\n\t* gcc.dg/ipa/inline-1.c: new testcase.\n\t* gcc.dg/ipa/inline-2.c: new testcase.\n\t* gcc.dg/ipa/inline-3.c: new testcase.\n\t* gcc.dg/ipa/inline-4.c: new testcase.\n\n\t* ipa-inline-transform.c (inline_call): Add comment.\n\t* ipa-inline.h (inline_param_summary): New structure and vector.\n\t(struct inline_edge_summary): Add param field.\n\t* ipa-inline-analysis.c (CHANGED): New constant.\n\t(add_clause): Handle CHANGED and NOT_CONSTANT.\n\t(predicate_probability): New function.\n\t(dump_condition): Dump CHANGED predicate.\n\t(evaluate_conditions_for_known_args): Handle ERROR_MARK as marker\n\tof unknown function wide invariant.\n\t(evaluate_conditions_for_edge): Handle change probabilities.\n\t(inline_edge_duplication_hook): Copy param summaries.\n\t(inline_edge_removal_hook): Free param summaries.\n\t(dump_inline_edge_summary): Fix dumping of indirect edges and callee sizes;\n\tdump param summaries.\n\t(will_be_nonconstant_predicate): Use CHANGED predicate.\n\t(record_modified_bb_info): New structure.\n\t(record_modified): New function.\n\t(param_change_prob): New function.\n\t(estimate_function_body_sizes): Compute param summaries.\n\t(estimate_edge_size_and_time): Add probability argument.\n\t(estimate_node_size_and_time): Add inline_param_summary argument;\n\thandle predicate probabilities.\n\t(remap_predicate): Fix formating.\n\t(remap_edge_change_prob): New function.\n\t(remap_edge_summaries): Rename from ...; use remap_edge_change_prob.\n\t(remap_edge_predicates): ... this one.\n\t(inline_merge_summary): Remap edge summaries; handle predicate probabilities;\n\tremove param summaries after we are done.\n\t(do_estimate_edge_time): Update.\n\t(do_estimate_edge_growth): Update.\n\t(read_inline_edge_summary): Read param info.\n\t(inline_read_summary): Fix formating.\n\t(write_inline_edge_summary): Write param summaries.\n\nFrom-SVN: r179126", "tree": {"sha": "b7d4d86552fa108883f41793fa83d183e8bf9df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7d4d86552fa108883f41793fa83d183e8bf9df5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25837a2f78a9baa97f88b289a43a93a362c4d538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25837a2f78a9baa97f88b289a43a93a362c4d538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25837a2f78a9baa97f88b289a43a93a362c4d538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25837a2f78a9baa97f88b289a43a93a362c4d538/comments", "author": null, "committer": null, "parents": [{"sha": "1db4406e7799ff4e71bfb4e621f5c7e1f6bdd151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db4406e7799ff4e71bfb4e621f5c7e1f6bdd151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1db4406e7799ff4e71bfb4e621f5c7e1f6bdd151"}], "stats": {"total": 684, "additions": 617, "deletions": 67}, "files": [{"sha": "246b781b18a44a226e3b09c1bda536ca20b62497", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -1,3 +1,39 @@\n+2011-09-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-transform.c (inline_call): Add comment.\n+\t* ipa-inline.h (inline_param_summary): New structure and vector.\n+\t(struct inline_edge_summary): Add param field.\n+\t* ipa-inline-analysis.c (CHANGED): New constant.\n+\t(add_clause): Handle CHANGED and NOT_CONSTANT.\n+\t(predicate_probability): New function.\n+\t(dump_condition): Dump CHANGED predicate.\n+\t(evaluate_conditions_for_known_args): Handle ERROR_MARK as marker\n+\tof unknown function wide invariant.\n+\t(evaluate_conditions_for_edge): Handle change probabilities.\n+\t(inline_edge_duplication_hook): Copy param summaries.\n+\t(inline_edge_removal_hook): Free param summaries.\n+\t(dump_inline_edge_summary): Fix dumping of indirect edges and callee sizes;\n+\tdump param summaries.\n+\t(will_be_nonconstant_predicate): Use CHANGED predicate.\n+\t(record_modified_bb_info): New structure.\n+\t(record_modified): New function.\n+\t(param_change_prob): New function.\n+\t(estimate_function_body_sizes): Compute param summaries.\n+\t(estimate_edge_size_and_time): Add probability argument.\n+\t(estimate_node_size_and_time): Add inline_param_summary argument;\n+\thandle predicate probabilities.\n+\t(remap_predicate): Fix formating.\n+\t(remap_edge_change_prob): New function.\n+\t(remap_edge_summaries): Rename from ...; use remap_edge_change_prob.\n+\t(remap_edge_predicates): ... this one.\n+\t(inline_merge_summary): Remap edge summaries; handle predicate probabilities;\n+\tremove param summaries after we are done.\n+\t(do_estimate_edge_time): Update.\n+\t(do_estimate_edge_growth): Update.\n+\t(read_inline_edge_summary): Read param info.\n+\t(inline_read_summary): Fix formating.\n+\t(write_inline_edge_summary): Write param summaries.\n+\n 2011-09-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_print_operand): Handle %~."}, {"sha": "bd4d2eaf1444e9c79da35dad38304ff3619f581f", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 427, "deletions": 67, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -108,6 +108,11 @@ enum predicate_conditions\n /* Special condition code we use to represent test that operand is compile time\n    constant.  */\n #define IS_NOT_CONSTANT ERROR_MARK\n+/* Special condition code we use to represent test that operand is not changed\n+   across invocation of the function.  When operand IS_NOT_CONSTANT it is always\n+   CHANGED, however i.e. loop invariants can be NOT_CHANGED given percentage\n+   of executions even when they are not compile time constants.  */\n+#define CHANGED IDENTIFIER_NODE\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n@@ -287,22 +292,37 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n   /* Look for clauses that are obviously true.  I.e.\n      op0 == 5 || op0 != 5.  */\n   for (c1 = predicate_first_dynamic_condition; c1 < NUM_CONDITIONS; c1++)\n-    for (c2 = c1 + 1; c2 <= NUM_CONDITIONS; c2++)\n-      if ((clause & (1 << c1))\n-\t  && (clause & (1 << c2)))\n-\t{\n-\t  condition *cc1 = VEC_index (condition,\n-\t\t\t\t      conditions,\n-\t\t\t\t      c1 - predicate_first_dynamic_condition);\n-\t  condition *cc2 = VEC_index (condition,\n-\t\t\t\t      conditions,\n-\t\t\t\t      c2 - predicate_first_dynamic_condition);\n-\t  if (cc1->operand_num == cc2->operand_num\n-\t      && cc1->val == cc2->val\n-\t      && cc1->code == invert_tree_comparison (cc2->code,\n-\t\t\t\t\t\t      HONOR_NANS (TYPE_MODE (TREE_TYPE (cc1->val)))))\n-\t    return;\n-\t}\n+    {\n+      condition *cc1;\n+      if (!(clause & (1 << c1)))\n+\tcontinue;\n+      cc1 = VEC_index (condition,\n+\t\t       conditions,\n+\t\t       c1 - predicate_first_dynamic_condition);\n+      /* We have no way to represent !CHANGED and !IS_NOT_CONSTANT\n+\t and thus there is no point for looking for them.  */\n+      if (cc1->code == CHANGED\n+\t  || cc1->code == IS_NOT_CONSTANT)\n+\tcontinue;\n+      for (c2 = c1 + 1; c2 <= NUM_CONDITIONS; c2++)\n+\tif (clause & (1 << c2))\n+\t  {\n+\t    condition *cc1 = VEC_index (condition,\n+\t\t\t\t\tconditions,\n+\t\t\t\t\tc1 - predicate_first_dynamic_condition);\n+\t    condition *cc2 = VEC_index (condition,\n+\t\t\t\t\tconditions,\n+\t\t\t\t\tc2 - predicate_first_dynamic_condition);\n+\t    if (cc1->operand_num == cc2->operand_num\n+\t\t&& cc1->val == cc2->val\n+\t\t&& cc2->code != IS_NOT_CONSTANT\n+\t\t&& cc2->code != CHANGED\n+\t\t&& cc1->code == invert_tree_comparison \n+\t\t    (cc2->code,\n+\t\t     HONOR_NANS (TYPE_MODE (TREE_TYPE (cc1->val)))))\n+\t      return;\n+\t  }\n+    }\n \t\n \n   /* We run out of variants.  Be conservative in positive direction.  */\n@@ -420,6 +440,70 @@ evaluate_predicate (struct predicate *p, clause_t possible_truths)\n   return true;\n }\n \n+/* Return the probability in range 0...REG_BR_PROB_BASE that the predicated\n+   instruction will be recomputed per invocation of the inlined call.  */\n+\n+static int\n+predicate_probability (conditions conds,\n+\t\t       struct predicate *p, clause_t possible_truths,\n+\t\t       VEC (inline_param_summary_t, heap) *inline_param_summary)\n+{\n+  int i;\n+  int combined_prob = REG_BR_PROB_BASE;\n+\n+  /* True remains true.  */\n+  if (true_predicate_p (p))\n+    return REG_BR_PROB_BASE;\n+\n+  if (false_predicate_p (p))\n+    return 0;\n+\n+  gcc_assert (!(possible_truths & (1 << predicate_false_condition)));\n+\n+  /* See if we can find clause we can disprove.  */\n+  for (i = 0; p->clause[i]; i++)\n+    {\n+      gcc_checking_assert (i < MAX_CLAUSES);\n+      if (!(p->clause[i] & possible_truths))\n+\treturn 0;\n+      else\n+\t{\n+\t  int this_prob = 0;\n+\t  int i2;\n+\t  if (!inline_param_summary)\n+\t    return REG_BR_PROB_BASE;\n+\t  for (i2 = 0; i2 < NUM_CONDITIONS; i2++)\n+\t    if ((p->clause[i] & possible_truths) & (1 << i2))\n+\t      {\n+\t\tif (i2 >= predicate_first_dynamic_condition)\n+\t\t  {\n+\t\t    condition *c = VEC_index\n+\t\t\t\t    (condition, conds,\n+\t\t\t\t     i2 - predicate_first_dynamic_condition);\n+\t\t    if (c->code == CHANGED\n+\t\t\t&& (c->operand_num\n+\t\t\t    < VEC_length (inline_param_summary_t,\n+\t\t\t\t\t  inline_param_summary)))\n+\t\t      {\n+\t\t\tint iprob = VEC_index (inline_param_summary_t,\n+\t\t\t\t\t       inline_param_summary,\n+\t\t\t\t\t       c->operand_num)->change_prob;\n+\t\t\tthis_prob = MAX (this_prob, iprob);\n+\t\t      }\n+\t\t    else\n+\t\t      this_prob = REG_BR_PROB_BASE;\n+\t\t   }\n+\t\t else\n+\t\t   this_prob = REG_BR_PROB_BASE;\n+\t      }\n+\t  combined_prob = MIN (this_prob, combined_prob);\n+\t  if (!combined_prob)\n+            return 0;\n+\t}\n+    }\n+  return combined_prob;\n+}\n+\n \n /* Dump conditional COND.  */\n \n@@ -433,13 +517,19 @@ dump_condition (FILE *f, conditions conditions, int cond)\n     fprintf (f, \"not inlined\");\n   else\n     {\n-      c = VEC_index (condition, conditions, cond - predicate_first_dynamic_condition);\n+      c = VEC_index (condition, conditions,\n+\t\t     cond - predicate_first_dynamic_condition);\n       fprintf (f, \"op%i\", c->operand_num);\n       if (c->code == IS_NOT_CONSTANT)\n \t{\n \t  fprintf (f, \" not constant\");\n \t  return;\n \t}\n+      if (c->code == CHANGED)\n+\t{\n+\t  fprintf (f, \" changed\");\n+\t  return;\n+\t}\n       fprintf (f, \" %s \", op_symbol_code (c->code));\n       print_generic_expr (f, c->val, 1);\n     }\n@@ -571,7 +661,9 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n \n /* KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n    Return clause of possible truths. When INLINE_P is true, assume that\n-   we are inlining.  */\n+   we are inlining. \n+\n+   ERROR_MARK means compile time invariant.  */\n \n static clause_t\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n@@ -596,12 +688,15 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       else\n \tval = NULL;\n \n+      if (val == error_mark_node && c->code != CHANGED)\n+\tval = NULL;\n+\n       if (!val)\n \t{\n \t  clause |= 1 << (i + predicate_first_dynamic_condition);\n \t  continue;\n \t}\n-      if (c->code == IS_NOT_CONSTANT)\n+      if (c->code == IS_NOT_CONSTANT || c->code == CHANGED)\n \tcontinue;\n       res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);\n       if (res\n@@ -627,6 +722,7 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n     {\n       struct ipa_node_params *parms_info;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      struct inline_edge_summary *es = inline_edge_summary (e);\n       int i, count = ipa_get_cs_argument_count (args);\n       VEC (tree, heap) *known_vals = NULL;\n \n@@ -643,6 +739,11 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n \t\t\t\t\t ipa_get_ith_jump_func (args, i));\n \t  if (cst)\n \t    VEC_replace (tree, known_vals, i, cst);\n+\t  else if (inline_p\n+\t\t   && !VEC_index (inline_param_summary_t,\n+\t\t\t\t  es->param,\n+\t\t\t\t  i)->change_prob)\n+\t    VEC_replace (tree, known_vals, i, error_mark_node);\n \t}\n       clause = evaluate_conditions_for_known_args (callee,\n \t\t\t\t\t\t   inline_p, known_vals);\n@@ -898,6 +999,7 @@ inline_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t  sizeof (struct inline_edge_summary));\n   info->predicate = NULL;\n   edge_set_predicate (dst, srcinfo->predicate);\n+  info->param = VEC_copy (inline_param_summary_t, heap, srcinfo->param);\n }\n \n \n@@ -908,10 +1010,14 @@ inline_edge_removal_hook (struct cgraph_edge *edge, void *data ATTRIBUTE_UNUSED)\n {\n   if (edge_growth_cache)\n     reset_edge_growth_cache (edge);\n-  if (edge->uid < (int)VEC_length (inline_edge_summary_t, inline_edge_summary_vec))\n+  if (edge->uid\n+      < (int)VEC_length (inline_edge_summary_t, inline_edge_summary_vec))\n     {\n       edge_set_predicate (edge, NULL);\n-      memset (inline_edge_summary (edge), 0, sizeof (struct inline_edge_summary));\n+      VEC_free (inline_param_summary_t, heap,\n+\t        inline_edge_summary (edge)->param);\n+      memset (inline_edge_summary (edge), 0,\n+\t      sizeof (struct inline_edge_summary));\n     }\n }\n \n@@ -953,6 +1059,8 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n       struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+      int i;\n+\n       fprintf (f, \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i time: %2i callee size:%2i stack:%2i\",\n \t       indent, \"\", cgraph_node_name (callee),\n \t       callee->uid, \n@@ -963,18 +1071,34 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n                edge->frequency,\n \t       es->call_stmt_size,\n \t       es->call_stmt_time,\n-\t       (int)inline_summary (callee)->size,\n+\t       (int)inline_summary (callee)->size / INLINE_SIZE_SCALE,\n \t       (int)inline_summary (callee)->estimated_stack_size);\n+\n       if (es->predicate)\n \t{\n \t  fprintf (f, \" predicate: \");\n \t  dump_predicate (f, info->conds, es->predicate);\n \t}\n       else\n \t  fprintf (f, \"\\n\");\n+      if (es->param)\n+        for (i = 0; i < (int)VEC_length (inline_param_summary_t, es->param);\n+\t     i++)\n+\t  {\n+\t    int prob = VEC_index (inline_param_summary_t,\n+\t\t\t\t  es->param, i)->change_prob;\n+\n+\t    if (!prob)\n+\t      fprintf (f, \"%*s op%i is compile time invariant\\n\",\n+\t\t       indent + 2, \"\", i);\n+\t    else if (prob != REG_BR_PROB_BASE)\n+\t      fprintf (f, \"%*s op%i change %f%% of time\\n\", indent + 2, \"\", i,\n+\t\t       prob * 100.0 / REG_BR_PROB_BASE);\n+\t  }\n       if (!edge->inline_failed)\n \t{\n-          fprintf (f, \"%*sStack frame offset %i, callee self size %i, callee size %i\\n\",\n+          fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n+\t\t   \" callee size %i\\n\",\n \t\t   indent+2, \"\",\n \t\t   (int)inline_summary (callee)->stack_frame_offset,\n \t\t   (int)inline_summary (callee)->estimated_self_stack_size,\n@@ -986,7 +1110,7 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n       fprintf (f, \"%*sindirect call loop depth:%2i freq:%4i size:%2i\"\n-\t       \" time: %2i\\n\",\n+\t       \" time: %2i\",\n \t       indent, \"\",\n \t       es->loop_depth,\t\n                edge->frequency,\n@@ -1504,7 +1628,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n \t\t    (stmt, get_base_address (gimple_assign_rhs1 (stmt)));\n       p = add_condition (summary,\n \t\t\t ipa_get_param_decl_index (info, parm),\n-\t\t\t IS_NOT_CONSTANT, NULL);\n+\t\t\t CHANGED, NULL);\n       op_non_const = or_predicates (summary->conds, &p, &op_non_const);\n     }\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n@@ -1513,7 +1637,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n       if (parm && ipa_get_param_decl_index (info, parm) >= 0)\n \tp = add_condition (summary,\n \t\t\t   ipa_get_param_decl_index (info, parm),\n-\t\t\t   IS_NOT_CONSTANT, NULL);\n+\t\t\t   CHANGED, NULL);\n       else\n \tp = *VEC_index (predicate_t, nonconstant_names,\n \t\t\tSSA_NAME_VERSION (use));\n@@ -1526,6 +1650,116 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n   return op_non_const;\n }\n \n+struct record_modified_bb_info\n+{\n+  bitmap bb_set;\n+  gimple stmt;\n+};\n+\n+/* Callback of walk_aliased_vdefs.  Records basic blocks where the value may be\n+   set except for info->stmt.  */\n+\n+static bool\n+record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef,\n+\t         void *data)\n+{\n+  struct record_modified_bb_info *info = (struct record_modified_bb_info *) data;\n+  if (SSA_NAME_DEF_STMT (vdef) == info->stmt)\n+    return false;\n+  bitmap_set_bit (info->bb_set,\n+\t\t  SSA_NAME_IS_DEFAULT_DEF (vdef)\n+\t\t  ? ENTRY_BLOCK_PTR->index : gimple_bb (SSA_NAME_DEF_STMT (vdef))->index);\n+  return false;\n+}\n+\n+/* Return probability (based on REG_BR_PROB_BASE) that I-th parameter of STMT\n+   will change since last invocation of STMT. \n+\n+   Value 0 is reserved for compile time invariants.\n+   For common parameters it is REG_BR_PROB_BASE.  For loop invariants it\n+   ought to be REG_BR_PROB_BASE / estimated_iters.  */\n+\n+static int\n+param_change_prob (gimple stmt, int i)\n+{\n+  tree op = gimple_call_arg (stmt, i);\n+  basic_block bb = gimple_bb (stmt);\n+  tree base;\n+\n+  if (is_gimple_min_invariant (op))\n+    return 0;\n+  /* We would have to do non-trivial analysis to really work out what\n+     is the probability of value to change (i.e. when init statement\n+     is in a sibling loop of the call). \n+\n+     We do an conservative estimate: when call is executed N times more often\n+     than the statement defining value, we take the frequency 1/N.  */\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      int init_freq;\n+\n+      if (!bb->frequency)\n+\treturn REG_BR_PROB_BASE;\n+\n+      if (SSA_NAME_IS_DEFAULT_DEF (op))\n+\tinit_freq = ENTRY_BLOCK_PTR->frequency;\n+      else\n+\tinit_freq = gimple_bb (SSA_NAME_DEF_STMT (op))->frequency;\n+\n+      if (!init_freq)\n+\tinit_freq = 1;\n+      if (init_freq < bb->frequency)\n+        return MAX ((init_freq * REG_BR_PROB_BASE +\n+\t\t    bb->frequency / 2) / bb->frequency, 1);\n+      else\n+        return REG_BR_PROB_BASE;\n+    }\n+\n+  base = get_base_address (op);\n+  if (base)\n+    {\n+      ao_ref refd;\n+      int max;\n+      struct record_modified_bb_info info;\n+      bitmap_iterator bi;\n+      unsigned index;\n+\n+      if (const_value_known_p (base))\n+\treturn 0;\n+      if (!bb->frequency)\n+\treturn REG_BR_PROB_BASE;\n+      ao_ref_init (&refd, op);\n+      info.stmt = stmt;\n+      info.bb_set = BITMAP_ALLOC (NULL);\n+      walk_aliased_vdefs (&refd, gimple_vuse (stmt), record_modified, &info,\n+\t\t\t  NULL);\n+      if (bitmap_bit_p (info.bb_set, bb->index))\n+\t{\n+          BITMAP_FREE (info.bb_set);\n+\t  return REG_BR_PROB_BASE;\n+\t}\n+\n+      /* Assume that every memory is initialized at entry.\n+\t TODO: Can we easilly determine if value is always defined\n+\t and thus we may skip entry block?  */\n+      if (ENTRY_BLOCK_PTR->frequency)\n+\tmax = ENTRY_BLOCK_PTR->frequency;\n+      else\n+\tmax = 1;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (info.bb_set, 0, index, bi)\n+\tmax = MIN (max, BASIC_BLOCK (index)->frequency);\n+      \n+      BITMAP_FREE (info.bb_set);\n+      if (max < bb->frequency)\n+        return MAX ((max * REG_BR_PROB_BASE +\n+\t\t     bb->frequency / 2) / bb->frequency, 1);\n+      else\n+        return REG_BR_PROB_BASE;\n+    }\n+  return REG_BR_PROB_BASE;\n+}\n+\n \n /* Compute function body size parameters for NODE.\n    When EARLY is true, we compute only simple summaries without\n@@ -1626,7 +1860,24 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t{\n \t\t  struct predicate false_p = false_predicate ();\n \t\t  VEC_replace (predicate_t, nonconstant_names,\n-\t\t\t       SSA_NAME_VERSION (gimple_call_lhs (stmt)), &false_p);\n+\t\t\t       SSA_NAME_VERSION (gimple_call_lhs (stmt)),\n+\t\t\t       &false_p);\n+\t\t}\n+\t      if (ipa_node_params_vector)\n+\t\t{\n+\t          int count = gimple_call_num_args (stmt);\n+\t\t  int i;\n+\n+\t\t  if (count)\n+\t\t    VEC_safe_grow_cleared (inline_param_summary_t, heap,\n+\t\t\t\t\t   es->param, count);\n+\t\t  for (i = 0; i < count; i++)\n+\t\t    {\n+\t\t      int prob = param_change_prob (stmt, i);\n+\t\t      gcc_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n+\t\t      VEC_index (inline_param_summary_t,\n+\t\t\t\t es->param, i)->change_prob = prob;\n+\t\t    }\n \t\t}\n \n \t      es->call_stmt_size = this_size;\n@@ -1842,11 +2093,12 @@ struct gimple_opt_pass pass_inline_parameters =\n /* Increase SIZE and TIME for size and time needed to handle edge E.  */\n \n static void\n-estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time)\n+estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n+\t\t\t     int prob)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n   *size += es->call_stmt_size * INLINE_SIZE_SCALE;\n-  *time += (es->call_stmt_time\n+  *time += (es->call_stmt_time * prob / REG_BR_PROB_BASE\n \t    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE));\n   if (*time > MAX_TIME * INLINE_TIME_SCALE)\n     *time = MAX_TIME * INLINE_TIME_SCALE;\n@@ -1866,7 +2118,11 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n       if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n \t{\n \t  if (e->inline_failed)\n-\t    estimate_edge_size_and_time (e, size, time);\n+\t    {\n+\t      /* Predicates of calls shall not use NOT_CHANGED codes,\n+\t\t sowe do not need to compute probabilities.  */\n+\t      estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n+\t    }\n \t  else\n \t    estimate_calls_size_and_time (e->callee, size, time,\n \t\t\t\t\t  possible_truths);\n@@ -1877,7 +2133,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n-        estimate_edge_size_and_time (e, size, time);\n+        estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n     }\n }\n \n@@ -1888,7 +2144,9 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n static void\n estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     clause_t possible_truths,\n-\t\t       \t     int *ret_size, int *ret_time)\n+\t\t       \t     int *ret_size, int *ret_time,\n+\t\t\t     VEC (inline_param_summary_t, heap)\n+\t\t\t       *inline_param_summary)\n {\n   struct inline_summary *info = inline_summary (node);\n   size_time_entry *e;\n@@ -1918,7 +2176,20 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n     if (evaluate_predicate (&e->predicate, possible_truths))\n-      time += e->time, size += e->size;\n+      {\n+\tsize += e->size;\n+\tif (!inline_param_summary)\n+\t  time += e->time;\n+\telse\n+\t  {\n+\t    int prob = predicate_probability (info->conds,\n+\t\t\t\t\t      &e->predicate,\n+\t\t\t\t\t      possible_truths,\n+\t\t\t\t\t      inline_param_summary);\n+\t    time += e->time * prob / REG_BR_PROB_BASE;\n+\t  }\n+\t\t\t\t\t         \n+      }\n \n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n@@ -1951,21 +2222,23 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n   clause_t clause;\n \n   clause = evaluate_conditions_for_known_args (node, false, known_vals);\n-  estimate_node_size_and_time (node, clause, ret_size, ret_time);\n+  estimate_node_size_and_time (node, clause, ret_size, ret_time,\n+\t\t\t       NULL);\n }\n \n \n-/* Translate all conditions from callee representation into caller representation and\n-   symbolically evaluate predicate P into new predicate.\n+/* Translate all conditions from callee representation into caller\n+   representation and symbolically evaluate predicate P into new predicate.\n \n-   INFO is inline_summary of function we are adding predicate into, CALLEE_INFO is summary\n-   of function predicate P is from. OPERAND_MAP is array giving callee formal IDs the\n-   caller formal IDs. POSSSIBLE_TRUTHS is clausule of all callee conditions that\n-   may be true in caller context. TOPLEV_PREDICATE is predicate under which callee\n-   is executed.  */\n+   INFO is inline_summary of function we are adding predicate into,\n+   CALLEE_INFO is summary of function predicate P is from. OPERAND_MAP is\n+   array giving callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is\n+   clausule of all callee conditions that may be true in caller context.\n+   TOPLEV_PREDICATE is predicate under which callee is executed.  */\n \n static struct predicate\n-remap_predicate (struct inline_summary *info, struct inline_summary *callee_info,\n+remap_predicate (struct inline_summary *info,\n+\t\t struct inline_summary *callee_info,\n \t\t struct predicate *p,\n \t\t VEC (int, heap) *operand_map,\n \t\t clause_t possible_truths,\n@@ -2057,12 +2330,61 @@ inline_update_callee_summaries (struct cgraph_node *node,\n     inline_edge_summary (e)->loop_depth += depth;\n }\n \n+/* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n+   When functoin A is inlined in B and A calls C with parameter that\n+   changes with probability PROB1 and C is known to be passthroug\n+   of argument if B that change with probability PROB2, the probability\n+   of change is now PROB1*PROB2.  */\n+\n+static void\n+remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n+\t\t\tstruct cgraph_edge *edge)\n+{\n+  if (ipa_node_params_vector)\n+    {\n+      int i;\n+      struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n+      struct inline_edge_summary *es = inline_edge_summary (edge);\n+      struct inline_edge_summary *inlined_es\n+\t\t\t\t    = inline_edge_summary (inlined_edge);\n+\n+      for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n+\t{\n+\t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n+\t  if (jfunc->type == IPA_JF_PASS_THROUGH\n+\t      && (jfunc->value.pass_through.formal_id\n+\t\t  < VEC_length (inline_param_summary_t,\n+\t\t\t\tinlined_es->param)))\n+\t    {\n+\t      int prob1 = VEC_index (inline_param_summary_t,\n+\t\t\t\t     es->param, i)->change_prob;\n+\t      int prob2 = VEC_index\n+\t\t\t     (inline_param_summary_t,\n+\t\t\t     inlined_es->param,\n+\t\t\t     jfunc->value.pass_through.formal_id)->change_prob;\n+\t      int prob = ((prob1 * prob2 + REG_BR_PROB_BASE / 2)\n+\t\t\t  / REG_BR_PROB_BASE);\n+\n+\t      if (prob1 && prob2 && !prob)\n+\t\tprob = 1;\n+\n+\t      VEC_index (inline_param_summary_t,\n+\t\t\t es->param, i)->change_prob = prob;\n+\t    }\n+\t}\n+  }\n+}\n+\n+/* Update edge summaries of NODE after INLINED_EDGE has been inlined.\n+\n+   Remap predicates of callees of NODE.  Rest of arguments match\n+   remap_predicate.\n \n-/* Remap predicates of callees of NODE.  Rest of arguments match\n-   remap_predicate.  */\n+   Also update change probabilities.  */\n \n static void\n-remap_edge_predicates (struct cgraph_node *node,\n+remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n+\t\t       struct cgraph_node *node,\n \t\t       struct inline_summary *info,\n \t\t       struct inline_summary *callee_info,\n \t\t       VEC (int, heap) *operand_map,\n@@ -2074,17 +2396,20 @@ remap_edge_predicates (struct cgraph_node *node,\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       struct predicate p;\n+\n       if (e->inline_failed)\n \t{\n+\t  remap_edge_change_prob (inlined_edge, e);\n+\n \t  if (es->predicate)\n \t    {\n \t      p = remap_predicate (info, callee_info,\n \t\t\t\t   es->predicate, operand_map, possible_truths,\n \t\t\t\t   toplev_predicate);\n \t      edge_set_predicate (e, &p);\n-\t      /* TODO: We should remove the edge for code that will be optimized out,\n-\t\t but we need to keep verifiers and tree-inline happy.\n-\t\t Make it cold for now.  */\n+\t      /* TODO: We should remove the edge for code that will be\n+\t\t optimized out, but we need to keep verifiers and tree-inline\n+\t\t happy.  Make it cold for now.  */\n \t      if (false_predicate_p (&p))\n \t\t{\n \t\t  e->count = 0;\n@@ -2095,21 +2420,23 @@ remap_edge_predicates (struct cgraph_node *node,\n \t    edge_set_predicate (e, toplev_predicate);\n \t}\n       else\n-\tremap_edge_predicates (e->callee, info, callee_info, operand_map,\n-\t\t\t       possible_truths, toplev_predicate);\n+\tremap_edge_summaries (inlined_edge, e->callee, info, callee_info,\n+\t\t\t      operand_map, possible_truths, toplev_predicate);\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       struct predicate p;\n+\n+      remap_edge_change_prob (inlined_edge, e);\n       if (es->predicate)\n \t{\n \t  p = remap_predicate (info, callee_info,\n \t\t\t       es->predicate, operand_map, possible_truths,\n \t\t\t       toplev_predicate);\n \t  edge_set_predicate (e, &p);\n-\t  /* TODO: We should remove the edge for code that will be optimized out,\n-\t     but we need to keep verifiers and tree-inline happy.\n+\t  /* TODO: We should remove the edge for code that will be optimized\n+\t     out, but we need to keep verifiers and tree-inline happy.\n \t     Make it cold for now.  */\n \t  if (false_predicate_p (&p))\n \t    {\n@@ -2171,14 +2498,27 @@ inline_merge_summary (struct cgraph_edge *edge)\n       struct predicate p = remap_predicate (info, callee_info,\n \t\t\t\t\t    &e->predicate, operand_map, clause,\n \t\t\t\t\t    &toplev_predicate);\n-      gcov_type add_time = ((gcov_type)e->time * edge->frequency\n-\t\t\t    + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n-      if (add_time > MAX_TIME)\n-\tadd_time = MAX_TIME;\n-      account_size_time (info, e->size, add_time, &p);\n-    }\n-  remap_edge_predicates (edge->callee, info, callee_info, operand_map,\n-\t\t\t clause, &toplev_predicate);\n+      if (!false_predicate_p (&p))\n+\t{\n+\t  gcov_type add_time = ((gcov_type)e->time * edge->frequency\n+\t\t\t\t+ CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+\t  int prob = predicate_probability (callee_info->conds,\n+\t\t\t\t\t    &e->predicate,\n+\t\t\t\t\t    clause, es->param);\n+\t  add_time = add_time * prob / REG_BR_PROB_BASE;\n+\t  if (add_time > MAX_TIME * INLINE_TIME_SCALE)\n+\t    add_time = MAX_TIME * INLINE_TIME_SCALE;\n+\t  if (prob != REG_BR_PROB_BASE\n+\t      && dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\t\\tScaling time by probability:%f\\n\",\n+\t\t       (double)prob / REG_BR_PROB_BASE);\n+\t    }\n+\t  account_size_time (info, e->size, add_time, &p);\n+\t}\n+    }\n+  remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n+\t\t\tclause, &toplev_predicate);\n   info->size = 0;\n   info->time = 0;\n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n@@ -2191,6 +2531,8 @@ inline_merge_summary (struct cgraph_edge *edge)\n \n   /* We do not maintain predicates of inlined edges, free it.  */\n   edge_set_predicate (edge, &true_p);\n+  /* Similarly remove param summaries.  */\n+  VEC_free (inline_param_summary_t, heap, es->param);\n \n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n@@ -2213,9 +2555,10 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   gcc_checking_assert (edge->inline_failed);\n-  estimate_node_size_and_time (cgraph_function_or_thunk_node (edge->callee, NULL),\n+  estimate_node_size_and_time (cgraph_function_or_thunk_node (edge->callee,\n+\t\t\t\t\t\t\t      NULL),\n \t\t\t       evaluate_conditions_for_edge (edge, true),\n-\t\t\t       &size, &time);\n+\t\t\t       &size, &time, es->param);\n \n   ret = (((gcov_type)time\n \t   - es->call_stmt_time) * edge->frequency\n@@ -2267,7 +2610,7 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n   gcc_checking_assert (edge->inline_failed);\n   estimate_node_size_and_time (callee,\n \t\t\t       evaluate_conditions_for_edge (edge, true),\n-\t\t\t       &size, NULL);\n+\t\t\t       &size, NULL, NULL);\n   gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n   return size - inline_edge_summary (edge)->call_stmt_size;\n }\n@@ -2475,12 +2818,21 @@ read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n   struct predicate p;\n+  int length, i;\n \n   es->call_stmt_size = streamer_read_uhwi (ib);\n   es->call_stmt_time = streamer_read_uhwi (ib);\n   es->loop_depth = streamer_read_uhwi (ib);\n   p = read_predicate (ib);\n   edge_set_predicate (e, &p);\n+  length = streamer_read_uhwi (ib);\n+  if (length)\n+    {\n+      VEC_safe_grow_cleared (inline_param_summary_t, heap, es->param, length);\n+      for (i = 0; i < length; i++)\n+\tVEC_index (inline_param_summary_t, es->param, i)->change_prob\n+\t  = streamer_read_uhwi (ib);\n+    }\n }\n \n \n@@ -2579,13 +2931,15 @@ inline_read_summary (void)\n   while ((file_data = file_data_vec[j++]))\n     {\n       size_t len;\n-      const char *data = lto_get_section_data (file_data, LTO_section_inline_summary, NULL, &len);\n+      const char *data = lto_get_section_data (file_data,\n+\t\t\t\t\t       LTO_section_inline_summary,\n+\t\t\t\t\t       NULL, &len);\n       if (data)\n         inline_read_section (file_data, data, len);\n       else\n-\t/* Fatal error here.  We do not want to support compiling ltrans units with\n-\t   different version of compiler or different flags than the WPA unit, so\n-\t   this should never happen.  */\n+\t/* Fatal error here.  We do not want to support compiling ltrans units\n+\t   with different version of compiler or different flags than the WPA\n+\t   unit, so this should never happen.  */\n \tfatal_error (\"ipa inline summary is missing in input file\");\n     }\n   if (optimize)\n@@ -2621,10 +2975,16 @@ static void\n write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n+  int i;\n+\n   streamer_write_uhwi (ob, es->call_stmt_size);\n   streamer_write_uhwi (ob, es->call_stmt_time);\n   streamer_write_uhwi (ob, es->loop_depth);\n   write_predicate (ob, es->predicate);\n+  streamer_write_uhwi (ob, VEC_length (inline_param_summary_t, es->param));\n+  for (i = 0; i < (int)VEC_length (inline_param_summary_t, es->param); i++)\n+    streamer_write_uhwi (ob, VEC_index (inline_param_summary_t,\n+\t\t\t\t        es->param, i)->change_prob);\n }\n \n "}, {"sha": "6eb8e7388cfbbc9b93feedf9141e70d46e1e4d5f", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -248,6 +248,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n \n+  /* This must happen after inline_merge_summary that rely on jump\n+     functions of callee to not be updated.  */\n   if (optimize)\n     return ipa_propagate_indirect_call_infos (curr, new_edges);\n   else"}, {"sha": "6df7867b019ca37d874f0cd0e1b7422b296ccf14", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -104,11 +104,28 @@ struct GTY(()) inline_summary\n   VEC(size_time_entry,gc) *entry;\n };\n \n+\n typedef struct inline_summary inline_summary_t;\n DEF_VEC_O(inline_summary_t);\n DEF_VEC_ALLOC_O(inline_summary_t,gc);\n extern GTY(()) VEC(inline_summary_t,gc) *inline_summary_vec;\n \n+/* Information kept about parameter of call site.  */\n+struct inline_param_summary\n+{\n+  /* REG_BR_PROB_BASE based probability that parameter will change in between\n+     two invocation of the calls.\n+     I.e. loop invariant parameters\n+     REG_BR_PROB_BASE/estimated_iterations and regular\n+     parameters REG_BR_PROB_BASE.\n+\n+     Value 0 is reserved for compile time invariants. */\n+  int change_prob;\n+};\n+typedef struct inline_param_summary inline_param_summary_t;\n+DEF_VEC_O(inline_param_summary_t);\n+DEF_VEC_ALLOC_O(inline_param_summary_t,heap);\n+\n /* Information kept about callgraph edges.  */\n struct inline_edge_summary\n {\n@@ -118,6 +135,10 @@ struct inline_edge_summary\n   /* Depth of loop nest, 0 means no nesting.  */\n   unsigned short int loop_depth;\n   struct predicate *predicate;\n+  /* Array indexed by parameters.\n+     0 means that parameter change all the time, REG_BR_PROB_BASE means\n+     that parameter is constant.  */\n+  VEC (inline_param_summary_t, heap) *param;\n };\n \n typedef struct inline_edge_summary inline_edge_summary_t;"}, {"sha": "756a4dea03629085a5cd94953ee94b07b5e030fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -1,3 +1,10 @@\n+2011-09-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/inline-1.c: new testcase.\n+\t* gcc.dg/ipa/inline-2.c: new testcase.\n+\t* gcc.dg/ipa/inline-3.c: new testcase.\n+\t* gcc.dg/ipa/inline-4.c: new testcase.\n+\n 2011-09-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50258"}, {"sha": "c662682a3f7a0d69511132073e0719d6e8ca9f0c", "filename": "gcc/testsuite/gcc.dg/ipa/inline-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-1.c?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -0,0 +1,37 @@\n+/* Verify that analysis of function parameters works as expected.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline\"  } */\n+struct bah {int a,b,c,d,e;};\n+static struct bah bah3={2,3,4,5,6};\n+const static struct bah bah4={2,3,4,5,6};\n+void test (int, struct bah *, struct bah, struct bah, int, struct bah, struct bah, struct bah);\n+void foo (int invariant, struct bah invariant2)\n+{\n+  int i;\n+  struct bah bah2={1,2,3,4,5};\n+  struct bah bah5={1,2,3,4,5};\n+  for (i = 0; i<10; i++)\n+    {\n+      bah5.a=i;\n+      test (i, &bah2, bah2, bah3, invariant, invariant2, bah4, bah5);\n+    }\n+}\n+/* op0 change on every invocation.  */\n+/* op1 is function invariant.  */\n+/* { dg-final { scan-ipa-dump-not \"op0 is compile time invariant\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"op0 change\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"op1 is compile time invariant\"  \"inline\"  } } */\n+/* op2 is invariant within loop (we make assumption that function call does not afect it.). */\n+/* { dg-final { scan-ipa-dump \"op2 change 10.000000. of time\"  \"inline\"  } } */\n+/* op3 is invariant within loop (we make assumption that function call does not afect it.). */\n+/* { dg-final { scan-ipa-dump \"op3 change 10.000000. of time\"  \"inline\"  } } */\n+/* op4 is invariant within loop.  */\n+/* { dg-final { scan-ipa-dump \"op4 change 10.000000. of time\"  \"inline\"  } } */\n+/* op5 is invariant within loop.  */\n+/* { dg-final { scan-ipa-dump \"op5 change 10.000000. of time\"  \"inline\"  } } */\n+/* op6 is compile time invariant.  */\n+/* { dg-final { scan-ipa-dump \"op6 is compile time invariant\"  \"inline\"  } } */\n+/* op7 change.  */\n+/* { dg-final { scan-ipa-dump-not \"op7 is compile time invariant\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-not \"op7 change\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "376cf97e84139e792bcd3312dbea1615bbed85c2", "filename": "gcc/testsuite/gcc.dg/ipa/inline-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-2.c?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -0,0 +1,33 @@\n+/* Verify that logic combining probabilities works as expected.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+struct bah {int a,b,d;};\n+\n+__attribute__ ((noinline))\n+void test(int a,int b,int c,int d,int e)\n+{\n+  test3(a,b,c,d,e);\n+}\n+inline\n+static void bar (int parm1, int parm2)\n+{\n+  int i;\n+  for (i = 0; i<10; i++)\n+    {\n+      test (0,0,parm1,parm2,i);\n+    }\n+}\n+void foo (int invariant)\n+{\n+  int i;\n+  for (i = 0; i<10; i++)\n+    {\n+      bar (i, invariant);\n+    }\n+}\n+/* After inlining bar into foo, op2 is invariant within inner loop.  */\n+/* { dg-final { scan-ipa-dump \"op2 change 10.000000. of time\"  \"inline\"  } } */\n+/* After inlining bar into foo, op3 is invariant within both loops.  */\n+/* { dg-final { scan-ipa-dump \"op3 change 1.000000. of time\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "d97f0c65444b4675b77233addc502794d835a7d8", "filename": "gcc/testsuite/gcc.dg/ipa/inline-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-3.c?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -0,0 +1,25 @@\n+/* Verify that do_work is detected as being loop invariant.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline-details -fno-early-inlining\"  } */\n+\n+struct bah {int a,b,d;};\n+\n+static int do_work (struct bah s)\n+{\n+  return s.a*s.b/s.d;\n+}\n+int foo (int invariant)\n+{\n+  int i;\n+  struct bah s = {invariant,invariant,invariant};\n+  int sum = 0;\n+  for (i = 0; i<10; i++)\n+    {\n+      sum += do_work (s);\n+    }\n+  return sum;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump \"Scaling time by probability:0.100000\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "66019b30f2ed90a2c928fa25847022f8efed1ab4", "filename": "gcc/testsuite/gcc.dg/ipa/inline-4.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25837a2f78a9baa97f88b289a43a93a362c4d538/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-4.c?ref=25837a2f78a9baa97f88b289a43a93a362c4d538", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -c -fdump-ipa-inline -fno-early-inlining -fno-partial-inlining -fno-ipa-cp\"  } */\n+\n+void do_something (int shall_i_work)\n+{\n+  if (shall_i_work)\n+    {\n+      work_hard ();\n+      work_hard ();\n+      work_hard ();\n+      work_hard ();\n+      work_hard ();\n+      work_hard ();\n+      work_hard ();\n+      work_hard ();\n+    }\n+}\n+int foo (int invariant)\n+{\n+  do_something (0);\n+  do_something (1);\n+}\n+\n+\n+/* We should inline do_something(0),  but not do_something (1).  */\n+/* { dg-final { scan-ipa-dump \"Inlined 1 calls, eliminated 0 functions\"  \"inline\"  } } */\n+/* Call to work_hard should be detected as optimized out.  */\n+/* { dg-final { scan-ipa-dump-times \"predicate: .false.\" 8 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}