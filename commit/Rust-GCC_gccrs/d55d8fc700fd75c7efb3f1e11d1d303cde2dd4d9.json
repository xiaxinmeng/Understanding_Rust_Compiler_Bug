{"sha": "d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU1ZDhmYzcwMGZkNzVjN2VmYjNmMWUxMWQxZDMwM2NkZTJkZDRkOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-12-25T15:15:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-12-25T15:15:10Z"}, "message": "output.h: Fix comment typos.\n\n\t* output.h: Fix comment typos.\n\t* predict.c: Likewise.\n\t* print-tree.c: Likewise.\n\t* profile.c: Likewise.\n\t* ra-build.c: Likewise.\n\t* ra-colorize.c: Likewise.\n\t* ra-debug.c: Likewise.\n\t* ra-rewrite.c: Likewise.\n\t* ra.c: Likewise.\n\t* ra.h: Likewise.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* regclass.c: Likewise.\n\nFrom-SVN: r60502", "tree": {"sha": "c9d2c0b2dd77109ef11a66cdf42b6e1a0fc4430e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9d2c0b2dd77109ef11a66cdf42b6e1a0fc4430e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/comments", "author": null, "committer": null, "parents": [{"sha": "7a770d8b104d6ce00bf9d56b22dc6428b969f1ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a770d8b104d6ce00bf9d56b22dc6428b969f1ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a770d8b104d6ce00bf9d56b22dc6428b969f1ba"}], "stats": {"total": 111, "additions": 64, "deletions": 47}, "files": [{"sha": "318268722c5114855c71a727d196b52bdde387c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -1,3 +1,20 @@\n+2002-12-25  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* output.h: Fix comment typos.\n+\t* predict.c: Likewise.\n+\t* print-tree.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* ra-build.c: Likewise.\n+\t* ra-colorize.c: Likewise.\n+\t* ra-debug.c: Likewise.\n+\t* ra-rewrite.c: Likewise.\n+\t* ra.c: Likewise.\n+\t* ra.h: Likewise.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* regclass.c: Likewise.\n+\n 2002-12-25  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (print_operand_address): Do not negate"}, {"sha": "3f6c0cdbbdd8075fa6752f0bd86ddac2a001a427", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -461,7 +461,7 @@ extern void default_eh_frame_section\tPARAMS ((void));\n /* Default target hook that outputs nothing to a stream.  */\n extern void no_asm_to_stream PARAMS ((FILE *));\n \n-/* Flags controling properties of a section.  */\n+/* Flags controlling properties of a section.  */\n #define SECTION_ENTSIZE\t 0x000ff\t/* entity size in section */\n #define SECTION_CODE\t 0x00100\t/* contains code */\n #define SECTION_WRITE\t 0x00200\t/* data is writable */"}, {"sha": "3f3e2fc37bc8bf4d69539b9cb4d53cae25d8be37", "filename": "gcc/predict.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -113,7 +113,7 @@ static const struct predictor_info predictor_info[]= {\n #undef DEF_PREDICTOR\n \n /* Return true in case BB can be CPU intensive and should be optimized\n-   for maximal perofmrance.  */\n+   for maximal performance.  */\n \n bool\n maybe_hot_bb_p (bb)\n@@ -470,7 +470,7 @@ estimate_probability (loops_info)\n \t      }\n \n \t  /* Loop exit heuristics - predict an edge exiting the loop if the\n-\t     conditinal has no loop header successors as not taken.  */\n+\t     conditional has no loop header successors as not taken.  */\n \t  if (!header_found)\n \t    for (e = bb->succ; e; e = e->succ_next)\n \t      if (e->dest->index < 0\n@@ -565,7 +565,7 @@ estimate_probability (loops_info)\n \t  case EQ:\n \t  case UNEQ:\n \t    /* Floating point comparisons appears to behave in a very\n-\t       inpredictable way because of special role of = tests in\n+\t       unpredictable way because of special role of = tests in\n \t       FP code.  */\n \t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n \t      ;\n@@ -581,7 +581,7 @@ estimate_probability (loops_info)\n \t  case NE:\n \t  case LTGT:\n \t    /* Floating point comparisons appears to behave in a very\n-\t       inpredictable way because of special role of = tests in\n+\t       unpredictable way because of special role of = tests in\n \t       FP code.  */\n \t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n \t      ;\n@@ -801,7 +801,7 @@ process_note_predictions (bb, heads, dominators, post_dominators)\n   rtx insn;\n   edge e;\n \n-  /* Additionaly, we check here for blocks with no successors.  */\n+  /* Additionally, we check here for blocks with no successors.  */\n   int contained_noreturn_call = 0;\n   int was_bb_head = 0;\n   int noreturn_block = 1;\n@@ -1091,7 +1091,7 @@ counts_to_freqs ()\n \n /* Return true if function is likely to be expensive, so there is no point to\n    optimize performance of prologue, epilogue or do inlining at the expense\n-   of code size growth.  THRESHOLD is the limit of number of isntructions\n+   of code size growth.  THRESHOLD is the limit of number of instructions\n    function can execute at average to be still considered not expensive.  */\n \n bool"}, {"sha": "914ffcb3fcc73e7c311c6750485894ea73996e55", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -195,7 +195,7 @@ print_node (file, prefix, node, indent)\n       return;\n     }\n \n-  /* It is unsafe to look at any other filds of an ERROR_MARK node.  */\n+  /* It is unsafe to look at any other fields of an ERROR_MARK node.  */\n   if (TREE_CODE (node) == ERROR_MARK)\n     {\n       print_node_brief (file, prefix, node, indent);"}, {"sha": "d14b86244ae46a59298a6879b6e342092bb6203f", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -948,7 +948,7 @@ branch_prob ()\n       /* Add fake edges from entry block to the call insns that may return\n \t twice.  The CFG is not quite correct then, as call insn plays more\n \t role of CODE_LABEL, but for our purposes, everything should be OK,\n-\t as we never insert code to the beggining of basic block.  */\n+\t as we never insert code to the beginning of basic block.  */\n       for (insn = bb->head; insn != NEXT_INSN (bb->end);\n \t   insn = NEXT_INSN (insn))\n \t{"}, {"sha": "5f0b3e1030bc29f7165c811a6ed03b526634064d", "filename": "gcc/ra-build.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -36,7 +36,7 @@\n #include \"ggc.h\"\n #include \"ra.h\"\n \n-/* This file is part of the graph coloring register alloctor.\n+/* This file is part of the graph coloring register allocator.\n    It deals with building the interference graph.  When rebuilding\n    the graph for a function after spilling, we rebuild only those\n    parts needed, i.e. it works incrementally.\n@@ -48,7 +48,7 @@\n    conflicts.  By connecting the uses and defs, which reach each other, webs\n    (or live ranges) are built conceptually.\n \n-   The second part (make_webs() and childs) deals with converting that\n+   The second part (make_webs() and children) deals with converting that\n    structure to the nodes and edges, on which our interference graph is\n    built.  For each root web part constructed above, an instance of struct\n    web is created.  For all subregs of pseudos, which matter for allocation,\n@@ -369,7 +369,7 @@ static struct undef_table_s {\n /* Interpret *UNDEFINED as bitmask where each bit corresponds to a byte.\n    A set bit means an undefined byte.  Factor all undefined bytes into\n    groups, and return a size/ofs pair of consecutive undefined bytes,\n-   but according to certain borders.  Clear out those bits corrsponding\n+   but according to certain borders.  Clear out those bits corresponding\n    to bytes overlaid by that size/ofs pair.  REG is only used for\n    the mode, to detect if it's a floating mode or not.\n \n@@ -491,7 +491,7 @@ union_web_part_roots (r1, r2)\n     {\n       /* The new root is the smaller (pointerwise) of both.  This is crucial\n          to make the construction of webs from web parts work (so, when\n-\t scanning all parts, we see the roots before all it's childs).\n+\t scanning all parts, we see the roots before all its children).\n          Additionally this ensures, that if the web has a def at all, than\n          the root is a def (because all def parts are before use parts in the\n \t web_parts[] array), or put another way, as soon, as the root of a\n@@ -548,7 +548,7 @@ union_web_part_roots (r1, r2)\n   return r1;\n }\n \n-/* Convenience macro, that is cabable of unioning also non-roots.  */\n+/* Convenience macro, that is capable of unioning also non-roots.  */\n #define union_web_parts(p1, p2) \\\n   ((p1 == p2) ? find_web_part (p1) \\\n       : union_web_part_roots (find_web_part (p1), find_web_part (p2)))\n@@ -583,7 +583,7 @@ remember_move (insn)\n       /* XXX for now we don't remember move insns involving any subregs.\n \t Those would be difficult to coalesce (we would need to implement\n \t handling of all the subwebs in the allocator, including that such\n-\t subwebs could be source and target of coalesing).  */\n+\t subwebs could be source and target of coalescing).  */\n       if (GET_CODE (s) == REG && GET_CODE (d) == REG)\n \t{\n \t  struct move *m = (struct move *) ra_calloc (sizeof (struct move));\n@@ -673,7 +673,7 @@ defuse_overlap_p_1 (def, use)\n \t/* Now the more difficult part: the same regno is refered, but the\n \t   sizes of the references or the words differ.  E.g.\n            (subreg:SI (reg:CDI a) 0) and (subreg:DI (reg:CDI a) 2) do not\n-\t   overlap, wereas the latter overlaps with (subreg:SI (reg:CDI a) 3).\n+\t   overlap, whereas the latter overlaps with (subreg:SI (reg:CDI a) 3).\n \t   */\n \t{\n \t  unsigned HOST_WIDE_INT old_u;\n@@ -964,7 +964,7 @@ live_in (df, use, insn)\n       basic_block bb = BLOCK_FOR_INSN (insn);\n       number_seen[uid]++;\n \n-      /* We want to be as fast as possible, so explicitely write\n+      /* We want to be as fast as possible, so explicitly write\n \t this loop.  */\n       for (insn = PREV_INSN (insn); insn && !INSN_P (insn);\n \t   insn = PREV_INSN (insn))\n@@ -1046,7 +1046,7 @@ update_regnos_mentioned ()\n       }\n }\n \n-/* Handle the uses which reach a block end, but were defered due\n+/* Handle the uses which reach a block end, but were deferred due\n    to it's regno not being mentioned in that block.  This adds the\n    remaining conflicts and updates also the crosses_call and\n    spanned_deaths members.  */\n@@ -1062,7 +1062,7 @@ livethrough_conflicts_bb (bb)\n   unsigned int deaths = 0;\n   unsigned int contains_call = 0;\n \n-  /* If there are no defered uses, just return.  */\n+  /* If there are no deferred uses, just return.  */\n   if ((first = bitmap_first_set_bit (info->live_throughout)) < 0)\n     return;\n \n@@ -1141,7 +1141,7 @@ free_bb_info ()\n }\n \n /* Toplevel function for the first part of this file.\n-   Connect web parts, thereby implicitely building webs, and remember\n+   Connect web parts, thereby implicitly building webs, and remember\n    their conflicts.  */\n \n static void\n@@ -1545,7 +1545,7 @@ copy_conflict_list (web)\n /* Possibly add an edge from web FROM to TO marking a conflict between\n    those two.  This is one half of marking a complete conflict, which notes\n    in FROM, that TO is a conflict.  Adding TO to FROM's conflicts might\n-   make other conflicts superflous, because the current TO overlaps some web\n+   make other conflicts superfluous, because the current TO overlaps some web\n    already being in conflict with FROM.  In this case the smaller webs are\n    deleted from the conflict list.  Likewise if TO is overlapped by a web\n    already in the list, it isn't added at all.  Note, that this can only\n@@ -2100,7 +2100,7 @@ parts_to_webs (df)\n   sbitmap_zero (igraph);\n   sbitmap_zero (sup_igraph);\n \n-  /* Distibute the references to their webs.  */\n+  /* Distribute the references to their webs.  */\n   init_webs_defs_uses ();\n   /* And do some sanity checks if old webs, and those recreated from the\n      really are the same.  */\n@@ -2149,7 +2149,7 @@ reset_conflicts ()\n \t{\n \t  *pcl = NULL;\n \t  /* Useless conflicts will be rebuilt completely.  But check\n-\t     for cleanlyness, as the web might have come from the\n+\t     for cleanliness, as the web might have come from the\n \t     free list.  */\n \t  if (bitmap_first_set_bit (web->useless_conflicts) >= 0)\n \t    abort ();\n@@ -2985,7 +2985,7 @@ handle_asm_insn (df, insn)\n \t are not allowed by the constraints.  */\n       if (nothing_allowed)\n \t{\n-\t  /* If we had no real constraints nothing was explicitely\n+\t  /* If we had no real constraints nothing was explicitly\n \t     allowed, so we allow the whole class (i.e. we make no\n \t     additional conflicts).  */\n \t  CLEAR_HARD_REG_SET (conflict);\n@@ -3055,7 +3055,7 @@ build_i_graph (df)\n }\n \n /* Allocates or reallocates most memory for the interference graph and\n-   assiciated structures.  If it reallocates memory (meaning, this is not\n+   associated structures.  If it reallocates memory (meaning, this is not\n    the first pass), this also changes some structures to reflect the\n    additional entries in various array, and the higher number of\n    defs and uses.  */"}, {"sha": "b8672559a3c4f348e9436eb7743a7e21aa4eb423", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -338,7 +338,7 @@ build_worklists (df)\n      backed by a new pseudo, but conceptually can stand for a stackslot,\n      i.e. it doesn't really matter if they get a color or not), on\n      the SELECT stack first, those with lowest cost first.  This way\n-     they will be colored last, so do not contrain the coloring of the\n+     they will be colored last, so do not constrain the coloring of the\n      normal webs.  But still those with the highest count are colored\n      before, i.e. get a color more probable.  The use of stackregs is\n      a pure optimization, and all would work, if we used real stackslots\n@@ -1347,7 +1347,7 @@ colorize_one_web (web, hard)\n       HARD_REG_SET call_clobbered;\n \n       /* Here we choose a hard-reg for the current web.  For non spill\n-         temporaries we first search in the hardregs for it's prefered\n+         temporaries we first search in the hardregs for it's preferred\n \t class, then, if we found nothing appropriate, in those of the\n \t alternate class.  For spill temporaries we only search in\n \t usable_regs of this web (which is probably larger than that of\n@@ -1558,7 +1558,7 @@ colorize_one_web (web, hard)\n \t\t    set_cand (6, aw);\n \t\t  /* For boehm-gc/misc.c.  If we are a difficult spilltemp,\n \t\t     also coalesced neighbors are a chance, _even_ if they\n-\t\t     too are spilltemps.  At least their coalscing can be\n+\t\t     too are spilltemps.  At least their coalescing can be\n \t\t     broken up, which may be reset usable_regs, and makes\n \t\t     it easier colorable.  */\n \t\t  if (web->spill_temp != 2 && aw->is_coalesced\n@@ -2025,7 +2025,7 @@ check_colors ()\n \tif (!TEST_HARD_REG_BIT (web->usable_regs, aweb->color + c))\n \t  abort ();\n       /* Search the original (pre-coalesce) conflict list.  In the current\n-\t one some inprecise conflicts may be noted (due to combine() or\n+\t one some imprecise conflicts may be noted (due to combine() or\n \t insert_coalesced_conflicts() relocating partial conflicts) making\n \t it look like some wide webs are in conflict and having the same\n \t color.  */"}, {"sha": "e415df4e69ba5da070b434b97fe01981de5e7775", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -817,7 +817,7 @@ dump_constraints ()\n \tint uid = INSN_UID (insn);\n \tint o;\n \t/* Don't simply force rerecognition, as combine might left us\n-\t   with some unrecongnizable ones, which later leads to aborts\n+\t   with some unrecognizable ones, which later leads to aborts\n \t   in regclass, if we now destroy the remembered INSN_CODE().  */\n \t/*INSN_CODE (insn) = -1;*/\n \tcode = recog_memoized (insn);"}, {"sha": "e10ddd3551d84cbee50d50fb6d91a7026ec7e116", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -1886,7 +1886,7 @@ delete_moves ()\n       }\n }\n \n-/* Due to resons documented elsewhere we create different pseudos\n+/* Due to reasons documented elsewhere we create different pseudos\n    for all webs coalesced to hardregs.  For these parts life_analysis()\n    might have added REG_DEAD notes without considering, that only this part\n    but not the whole coalesced web dies.  The RTL is correct, there is no"}, {"sha": "785ef949bc2e07f4e7a1deef7c0e57b1fb8089ec", "filename": "gcc/ra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -75,7 +75,7 @@\n    * Lattice based rematerialization\n    * create definitions of ever-life regs at the beginning of\n      the insn chain\n-   * insert loads as soon, stores as late as possile\n+   * insert loads as soon, stores as late as possible\n    * insert spill insns as outward as possible (either looptree, or LCM)\n    * reuse stack-slots\n    * delete coalesced insns.  Partly done.  The rest can only go, when we get\n@@ -657,7 +657,7 @@ reg_alloc ()\n   /* If this is an empty function we shouldn't do all the following,\n      but instead just setup what's necessary, and return.  */\n \n-  /* We currently rely on the existance of the return value USE as\n+  /* We currently rely on the existence of the return value USE as\n      one of the last insns.  Add it if it's not there anymore.  */\n   if (last)\n     {\n@@ -698,7 +698,7 @@ reg_alloc ()\n \n   /* Run regclass first, so we know the preferred and alternate classes\n      for each pseudo.  Deactivate emitting of debug info, if it's not\n-     explicitely requested.  */\n+     explicitly requested.  */\n   if ((debug_new_regalloc & DUMP_REGCLASS) == 0)\n     rtl_dump_file = NULL;\n   regclass (get_insns (), max_reg_num (), rtl_dump_file);"}, {"sha": "04962df941b6afc1969d8c114acb1d87b9838a4e", "filename": "gcc/ra.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -62,7 +62,7 @@ struct tagged_conflict\n    In the process of building the interference graph web parts are\n    connected together, if they have common instructions and reference the\n    same register.  That way live ranges are build (by connecting defs and\n-   uses) and implicitely complete webs (by connecting web parts in common\n+   uses) and implicitly complete webs (by connecting web parts in common\n    uses).  */\n struct web_part\n {\n@@ -378,7 +378,7 @@ extern sbitmap igraph;\n /* This is the bitmap of all (even partly) conflicting super webs.\n    If bit I*num_webs+J or J*num_webs+I is set, then I and J (both being\n    super web indices) conflict, maybe only partially.  Note the\n-   assymetry.  */\n+   asymmetry.  */\n extern sbitmap sup_igraph;\n \n /* After the first pass, and when interference region spilling is\n@@ -430,7 +430,7 @@ extern struct df *df;\n    which backward reach the end of B.  */\n extern bitmap *live_at_end;\n \n-/* One pass is: collecting registers refs, buiding I-graph, spilling.\n+/* One pass is: collecting registers refs, building I-graph, spilling.\n    And this is how often we already ran that for the current function.  */\n extern int ra_pass;\n \n@@ -491,7 +491,7 @@ extern HARD_REG_SET usable_regs[N_REG_CLASSES];\n /* For each class C the count of hardregs in usable_regs[C].  */\n extern unsigned int num_free_regs[N_REG_CLASSES];\n /* For each mode M the hardregs, which are MODE_OK for M, and have\n-   enough space behind them to hold an M value.  Additinally\n+   enough space behind them to hold an M value.  Additionally\n    if reg R is OK for mode M, but it needs two hardregs, then R+1 will\n    also be set here, even if R+1 itself is not OK for M.  I.e. this\n    represent the possible resources which could be taken away be a value"}, {"sha": "7d7b4bb16377138bfc03e67cd56014eea7347087", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -3016,7 +3016,7 @@ encode_ieee_extended (fmt, buf, r)\n \n \t   Except for Motorola, which consider exp=0 and explicit\n \t   integer bit set to continue to be normalized.  In theory\n-\t   this descrepency has been taken care of by the difference\n+\t   this discrepancy has been taken care of by the difference\n \t   in fmt->emin in round_for_format.  */\n \n \tif (denormal)"}, {"sha": "340b2ee8b8260529a5fb15e6fd7e218ae52b8ce6", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -694,7 +694,7 @@ validate_replace_src_group (from, to, insn)\n   note_uses (&PATTERN (insn), validate_replace_src_1, &d);\n }\n \n-/* Same as validate_repalace_src_group, but validate by seeing if\n+/* Same as validate_replace_src_group, but validate by seeing if\n    INSN is still valid.  */\n int\n validate_replace_src (from, to, insn)\n@@ -2861,7 +2861,7 @@ split_all_insns (upd_life)\n }\n \n /* Same as split_all_insns, but do not expect CFG to be available.\n-   Used by machine depedent reorg passes.  */\n+   Used by machine dependent reorg passes.  */\n \n void\n split_all_insns_noflow ()"}, {"sha": "52eebe8f5a4de653acd37989b5ff1f654c8d7898", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -478,7 +478,7 @@ reg_to_stack (first, file)\n   /* A QNaN for initializing uninitialized variables.\n \n      ??? We can't load from constant memory in PIC mode, because\n-     we're insertting these instructions before the prologue and\n+     we're inserting these instructions before the prologue and\n      the PIC register hasn't been set up.  In that case, fall back\n      on zero, which we can get from `ldz'.  */\n \n@@ -1689,7 +1689,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\treplace_reg (dest, get_hard_regnum (regstack, *dest));\n \t      }\n \n-\t    /* Keep operand 1 maching with destination.  */\n+\t    /* Keep operand 1 matching with destination.  */\n \t    if (GET_RTX_CLASS (GET_CODE (pat_src)) == 'c'\n \t\t&& REG_P (*src1) && REG_P (*src2)\n \t\t&& REGNO (*src1) != REGNO (*dest))\n@@ -2406,7 +2406,7 @@ convert_regs_entry ()\n      the push/pop code happy, and to not scrog the register stack, we\n      must put something in these registers.  Use a QNaN.\n \n-     Note that we are insertting converted code here.  This code is\n+     Note that we are inserting converted code here.  This code is\n      never seen by the convert_regs pass.  */\n \n   for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)"}, {"sha": "6b6a6dd0adbb0c9bb402adfd6fdd2ec4aead9df1", "filename": "gcc/regclass.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=d55d8fc700fd75c7efb3f1e11d1d303cde2dd4d9", "patch": "@@ -817,7 +817,7 @@ struct costs\n   int mem_cost;\n };\n \n-/* Structure used to record preferrences of given pseudo.  */\n+/* Structure used to record preferences of given pseudo.  */\n struct reg_pref\n {\n   /* (enum reg_class) prefclass is the preferred class.  */\n@@ -841,7 +841,7 @@ static struct costs *costs;\n \n static struct costs init_cost;\n \n-/* Record preferrences of each pseudo.\n+/* Record preferences of each pseudo.\n    This is available after `regclass' is run.  */\n \n static struct reg_pref *reg_pref;\n@@ -2481,7 +2481,7 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t  && REGNO (SET_DEST (x)) >= min_regno\n \t  /* If the destination pseudo is set more than once, then other\n \t     sets might not be to a pointer value (consider access to a\n-\t     union in two threads of control in the presense of global\n+\t     union in two threads of control in the presence of global\n \t     optimizations).  So only set REG_POINTER on the destination\n \t     pseudo if this is the only set of that pseudo.  */\n \t  && REG_N_SETS (REGNO (SET_DEST (x))) == 1"}]}