{"sha": "32c9b4e92473a94323f4198c4fc2a34f6052f30e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJjOWI0ZTkyNDczYTk0MzIzZjQxOThjNGZjMmEzNGY2MDUyZjMwZQ==", "commit": {"author": {"name": "Duncan Sands", "email": "baldrick@free.fr", "date": "2009-09-28T08:50:39Z"}, "committer": {"name": "Duncan Sands", "email": "baldrick@gcc.gnu.org", "date": "2009-09-28T08:50:39Z"}, "message": "Add support for using ggc cache tables from plugins.\n\nApproved by Ian Lance Taylor.\n\nFrom-SVN: r152232", "tree": {"sha": "194a436e90764acef2d9ddd4041e1b96fecade5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/194a436e90764acef2d9ddd4041e1b96fecade5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32c9b4e92473a94323f4198c4fc2a34f6052f30e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c9b4e92473a94323f4198c4fc2a34f6052f30e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c9b4e92473a94323f4198c4fc2a34f6052f30e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c9b4e92473a94323f4198c4fc2a34f6052f30e/comments", "author": {"login": "CunningBaldrick", "id": 1713707, "node_id": "MDQ6VXNlcjE3MTM3MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1713707?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CunningBaldrick", "html_url": "https://github.com/CunningBaldrick", "followers_url": "https://api.github.com/users/CunningBaldrick/followers", "following_url": "https://api.github.com/users/CunningBaldrick/following{/other_user}", "gists_url": "https://api.github.com/users/CunningBaldrick/gists{/gist_id}", "starred_url": "https://api.github.com/users/CunningBaldrick/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CunningBaldrick/subscriptions", "organizations_url": "https://api.github.com/users/CunningBaldrick/orgs", "repos_url": "https://api.github.com/users/CunningBaldrick/repos", "events_url": "https://api.github.com/users/CunningBaldrick/events{/privacy}", "received_events_url": "https://api.github.com/users/CunningBaldrick/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd77e02dac3326a073283468832c6e5bb66291bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd77e02dac3326a073283468832c6e5bb66291bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd77e02dac3326a073283468832c6e5bb66291bf"}], "stats": {"total": 139, "additions": 94, "deletions": 45}, "files": [{"sha": "51a580bc7a5294d26cfe5961aa58d25ecf10bd04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32c9b4e92473a94323f4198c4fc2a34f6052f30e", "patch": "@@ -1,3 +1,18 @@\n+2009-09-27  Duncan Sands  <baldrick@free.fr>\n+\n+\t* gcc-plugin.h (PLUGIN_REGISTER_GGC_CACHES): New event.\n+\t* plugin.c (plugin_event_name): Add PLUGIN_REGISTER_GGC_CACHES.\n+\t(register_callback): Dispatch it.\n+\t(invoke_plugin_callbacks): Incorporate in sanity check.\n+\t* ggc.h (ggc_register_cache_tab): Add declaration.\n+\t* ggc-common.c (ggc_register_root_tab): Simplify.\n+\t(const_ggc_cache_tab_t): New typedef.\n+\t(extra_cache_vec): New vector of dynamically added cache tables.\n+\t(ggc_register_cache_tab): New function.\n+\t(ggc_scan_cache_tab): New function.\n+\t(ggc_mark_roots): Simplify dynamic roots.  Handle dynamic caches.\n+\t* doc/plugins.texi: Document PLUGIN_REGISTER_GGC_CACHES.\n+\n 2009-09-27  Richard Henderson  <rth@redhat.com>\n \n \t* tree-ssa-ccp.c (optimize_stack_restore): Relax the conditions under"}, {"sha": "bb32bccbf185d8b74365365cc4d1286a66c82ff2", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=32c9b4e92473a94323f4198c4fc2a34f6052f30e", "patch": "@@ -133,6 +133,7 @@ enum plugin_event\n   PLUGIN_GGC_MARKING,\t\t/* Extend the GGC marking. */\n   PLUGIN_GGC_END,\t\t/* Called at end of GGC. */\n   PLUGIN_REGISTER_GGC_ROOTS,\t/* Register an extra GGC root table. */\n+  PLUGIN_REGISTER_GGC_CACHES,\t/* Register an extra GGC cache table. */\n   PLUGIN_ATTRIBUTES,            /* Called during attribute registration */\n   PLUGIN_START_UNIT,            /* Called before processing a translation unit.  */\n   PLUGIN_EVENT_LAST             /* Dummy event used for indexing callback\n@@ -151,8 +152,8 @@ the arguments:\n @item @code{void *user_data}: Pointer to plugin-specific data.\n @end itemize\n \n-For the PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, and\n-PLUGIN_REGISTER_GGC_ROOTS pseudo-events the @code{callback} should be\n+For the PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, PLUGIN_REGISTER_GGC_ROOTS\n+and PLUGIN_REGISTER_GGC_CACHES pseudo-events the @code{callback} should be\n null, and the @code{user_data} is specific.\n \n @section Interacting with the pass manager\n@@ -222,16 +223,19 @@ for the @code{PLUGIN_GGC_MARKING} event. Such callbacks can call the\n (and conversely, these routines should usually not be used in plugins\n outside of the @code{PLUGIN_GGC_MARKING} event).  \n \n-Some plugins may need to add extra GGC root tables, e.g. to handle\n-their own @code{GTY}-ed data. This can be done with the\n-@code{PLUGIN_REGISTER_GGC_ROOTS} pseudo-event with a null callback and\n-the extra root table as @code{user_data}.  Running the @code{gengtype\n--p @var{source-dir} @var{file-list} @var{plugin*.c} ...} utility\n-generates this extra root table.\n+Some plugins may need to add extra GGC root tables, e.g. to handle their own\n+@code{GTY}-ed data. This can be done with the @code{PLUGIN_REGISTER_GGC_ROOTS}\n+pseudo-event with a null callback and the extra root table (of type @code{struct\n+ggc_root_tab*}) as @code{user_data}.  Plugins that want to use the\n+@code{if_marked} hash table option can add the extra GGC cache tables generated\n+by @code{gengtype} using the @code{PLUGIN_REGISTER_GGC_CACHES} pseudo-event with\n+a null callback and the extra cache table (of type @code{struct ggc_cache_tab*})\n+as @code{user_data}.  Running the @code{gengtype -p @var{source-dir}\n+@var{file-list} @var{plugin*.c} ...} utility generates these extra root tables.\n \n You should understand the details of memory management inside GCC\n-before using @code{PLUGIN_GGC_MARKING} or\n-@code{PLUGIN_REGISTER_GGC_ROOTS}.\n+before using @code{PLUGIN_GGC_MARKING}, @code{PLUGIN_REGISTER_GGC_ROOTS}\n+or @code{PLUGIN_REGISTER_GGC_CACHES}.\n \n \n @section Giving information about a plugin"}, {"sha": "84f0aedb1b30fe3b0e71294a4dfe94b821c8800d", "filename": "gcc/gcc-plugin.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fgcc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fgcc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-plugin.h?ref=32c9b4e92473a94323f4198c4fc2a34f6052f30e", "patch": "@@ -40,6 +40,7 @@ enum plugin_event\n   PLUGIN_GGC_MARKING,\t\t/* Extend the GGC marking. */\n   PLUGIN_GGC_END,\t\t/* Called at end of GGC. */\n   PLUGIN_REGISTER_GGC_ROOTS,\t/* Register an extra GGC root table. */\n+  PLUGIN_REGISTER_GGC_CACHES,\t/* Register an extra GGC cache table. */\n   PLUGIN_ATTRIBUTES,            /* Called during attribute registration.  */\n   PLUGIN_START_UNIT,            /* Called before processing a translation unit.  */\n   PLUGIN_EVENT_LAST             /* Dummy event used for indexing callback\n@@ -144,8 +145,8 @@ typedef void (*plugin_callback_func) (void *gcc_data, void *user_data);\n */\n \n /* This is also called without a callback routine for the\n-   PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, PLUGIN_REGISTER_GGC_ROOTS\n-   pseudo-events, with a specific user_data.\n+   PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, PLUGIN_REGISTER_GGC_ROOTS and\n+   PLUGIN_REGISTER_GGC_CACHES pseudo-events, with a specific user_data.\n   */\n \n extern void register_callback (const char *plugin_name,"}, {"sha": "76a35f7e029fa7d2852e42726d19b6d03361bae1", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=32c9b4e92473a94323f4198c4fc2a34f6052f30e", "patch": "@@ -91,30 +91,59 @@ ggc_htab_delete (void **slot, void *info)\n \n /* This extra vector of dynamically registered root_tab-s is used by\n    ggc_mark_roots and gives the ability to dynamically add new GGC root\n-   tables, for instance from some plugins; this vector is a heap one\n-   [since it is used by GGC internally!] */\n-typedef const struct ggc_root_tab* const_ggc_root_tab_t;\n+   tables, for instance from some plugins; this vector is on the heap\n+   since it is used by GGC internally.  */\n+typedef const struct ggc_root_tab *const_ggc_root_tab_t;\n DEF_VEC_P(const_ggc_root_tab_t);\n DEF_VEC_ALLOC_P(const_ggc_root_tab_t, heap);\n static VEC(const_ggc_root_tab_t, heap) *extra_root_vec;\n \n-\n /* Dynamically register a new GGC root table RT. This is useful for\n    plugins. */\n \n void \n ggc_register_root_tab (const struct ggc_root_tab* rt)\n {\n-  if (!rt)\n-    return;\n-  if (!extra_root_vec) \n-    {\n-      int vlen = 32;\n-      extra_root_vec = VEC_alloc (const_ggc_root_tab_t, heap, vlen);\n-    }\n-  VEC_safe_push (const_ggc_root_tab_t, heap, extra_root_vec, rt);\n+  if (rt)\n+    VEC_safe_push (const_ggc_root_tab_t, heap, extra_root_vec, rt);\n+}\n+\n+/* This extra vector of dynamically registered cache_tab-s is used by\n+   ggc_mark_roots and gives the ability to dynamically add new GGC cache\n+   tables, for instance from some plugins; this vector is on the heap\n+   since it is used by GGC internally.  */\n+typedef const struct ggc_cache_tab *const_ggc_cache_tab_t;\n+DEF_VEC_P(const_ggc_cache_tab_t);\n+DEF_VEC_ALLOC_P(const_ggc_cache_tab_t, heap);\n+static VEC(const_ggc_cache_tab_t, heap) *extra_cache_vec;\n+\n+/* Dynamically register a new GGC cache table CT. This is useful for\n+   plugins. */\n+\n+void\n+ggc_register_cache_tab (const struct ggc_cache_tab* ct)\n+{\n+  if (ct)\n+    VEC_safe_push (const_ggc_cache_tab_t, heap, extra_cache_vec, ct);\n }\n \n+/* Scan a hash table that has objects which are to be deleted if they are not\n+   already marked.  */\n+\n+static void\n+ggc_scan_cache_tab (const_ggc_cache_tab_t ctp)\n+{\n+  const struct ggc_cache_tab *cti;\n+\n+  for (cti = ctp; cti->base != NULL; cti++)\n+    if (*cti->base)\n+      {\n+        ggc_set_mark (*cti->base);\n+        htab_traverse_noresize (*cti->base, ggc_htab_delete,\n+                                CONST_CAST (void *, (const void *)cti));\n+        ggc_set_mark ((*cti->base)->entries);\n+      }\n+}\n \n /* Iterate through all registered roots and mark each element.  */\n \n@@ -123,8 +152,9 @@ ggc_mark_roots (void)\n {\n   const struct ggc_root_tab *const *rt;\n   const struct ggc_root_tab *rti;\n+  const_ggc_root_tab_t rtp;\n   const struct ggc_cache_tab *const *ct;\n-  const struct ggc_cache_tab *cti;\n+  const_ggc_cache_tab_t ctp;\n   size_t i;\n \n   for (rt = gt_ggc_deletable_rtab; *rt; rt++)\n@@ -136,18 +166,11 @@ ggc_mark_roots (void)\n       for (i = 0; i < rti->nelt; i++)\n \t(*rti->cb) (*(void **)((char *)rti->base + rti->stride * i));\n \n-  if (extra_root_vec \n-      && VEC_length(const_ggc_root_tab_t,extra_root_vec) > 0)\n+  for (i = 0; VEC_iterate (const_ggc_root_tab_t, extra_root_vec, i, rtp); i++)\n     {\n-      const_ggc_root_tab_t rtp = NULL;\n-      for (i=0; \n-\t   VEC_iterate(const_ggc_root_tab_t, extra_root_vec, i, rtp); \n-\t   i++) \n-\t{\n-\t  for (rti = rtp; rti->base != NULL; rti++)\n-\t    for (i = 0; i < rti->nelt; i++)\n-\t      (*rti->cb) (*(void **) ((char *)rti->base + rti->stride * i));\n-\t}\n+      for (rti = rtp; rti->base != NULL; rti++)\n+        for (i = 0; i < rti->nelt; i++)\n+          (*rti->cb) (*(void **) ((char *)rti->base + rti->stride * i));\n     }\n \n   if (ggc_protect_identifiers)\n@@ -156,14 +179,10 @@ ggc_mark_roots (void)\n   /* Now scan all hash tables that have objects which are to be deleted if\n      they are not already marked.  */\n   for (ct = gt_ggc_cache_rtab; *ct; ct++)\n-    for (cti = *ct; cti->base != NULL; cti++)\n-      if (*cti->base)\n-\t{\n-\t  ggc_set_mark (*cti->base);\n-\t  htab_traverse_noresize (*cti->base, ggc_htab_delete,\n-\t\t\t\t  CONST_CAST (void *, (const void *)cti));\n-\t  ggc_set_mark ((*cti->base)->entries);\n-\t}\n+    ggc_scan_cache_tab (*ct);\n+\n+  for (i = 0; VEC_iterate (const_ggc_cache_tab_t, extra_cache_vec, i, ctp); i++)\n+    ggc_scan_cache_tab (ctp);\n \n   if (! ggc_protect_identifiers)\n     ggc_purge_stringpool ();"}, {"sha": "c373de32cb70efeec5571753f0f3c05b7e9f354d", "filename": "gcc/ggc.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=32c9b4e92473a94323f4198c4fc2a34f6052f30e", "patch": "@@ -272,9 +272,13 @@ extern const char *ggc_alloc_string (const char *contents, int length);\n extern void ggc_collect\t(void);\n \n /* Register an additional root table.  This can be useful for some\n-   plugins.  Does nothing if the passed pointer is null. */\n+   plugins.  Does nothing if the passed pointer is NULL. */\n extern void ggc_register_root_tab (const struct ggc_root_tab *);\n \n+/* Register an additional cache table.  This can be useful for some\n+   plugins.  Does nothing if the passed pointer is NULL. */\n+extern void ggc_register_cache_tab (const struct ggc_cache_tab *);\n+\n /* Return the number of bytes allocated at the indicated address.  */\n extern size_t ggc_get_size (const void *);\n "}, {"sha": "7d6e85f9cefa78a53506ebb72249b5717ffcd038", "filename": "gcc/plugin.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c9b4e92473a94323f4198c4fc2a34f6052f30e/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=32c9b4e92473a94323f4198c4fc2a34f6052f30e", "patch": "@@ -57,6 +57,7 @@ const char *plugin_event_name[] =\n   \"PLUGIN_GGC_MARKING\",\n   \"PLUGIN_GGC_END\",\n   \"PLUGIN_REGISTER_GGC_ROOTS\",\n+  \"PLUGIN_REGISTER_GGC_CACHES\",\n   \"PLUGIN_START_UNIT\", \n   \"PLUGIN_EVENT_LAST\"\n };\n@@ -499,6 +500,10 @@ register_callback (const char *plugin_name,\n \tgcc_assert (!callback);\n         ggc_register_root_tab ((const struct ggc_root_tab*) user_data);\n \tbreak;\n+      case PLUGIN_REGISTER_GGC_CACHES:\n+\tgcc_assert (!callback);\n+        ggc_register_cache_tab ((const struct ggc_cache_tab*) user_data);\n+\tbreak;\n       case PLUGIN_FINISH_TYPE:\n       case PLUGIN_START_UNIT:\n       case PLUGIN_FINISH_UNIT:\n@@ -566,6 +571,7 @@ invoke_plugin_callbacks (enum plugin_event event, void *gcc_data)\n       case PLUGIN_PASS_MANAGER_SETUP:\n       case PLUGIN_EVENT_LAST:\n       case PLUGIN_REGISTER_GGC_ROOTS:\n+      case PLUGIN_REGISTER_GGC_CACHES:\n       default:\n         gcc_assert (false);\n     }"}]}