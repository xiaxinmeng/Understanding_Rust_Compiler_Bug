{"sha": "81a69b13339a5a975ab17eef54490148addaf531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFhNjliMTMzMzlhNWE5NzVhYjE3ZWVmNTQ0OTAxNDhhZGRhZjUzMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-31T20:11:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-31T20:11:17Z"}, "message": "types.c (FFI_TYPE_POINTER): Define with sizeof.\n\n        * src/types.c (FFI_TYPE_POINTER): Define with sizeof.\n        (FFI_TYPE_LONGDOUBLE): Fix for ia64.\n        * src/ia64/ffitarget.h (struct ffi_ia64_trampoline_struct): Move\n        into ffi_prep_closure.\n        * src/ia64/ia64_flags.h, src/ia64/ffi.c, src/ia64/unix.S: Rewrite\n        from scratch.\n\nFrom-SVN: r92774", "tree": {"sha": "9eac59f95be2aa7a36f95f2c7c9553e325370df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9eac59f95be2aa7a36f95f2c7c9553e325370df0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81a69b13339a5a975ab17eef54490148addaf531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a69b13339a5a975ab17eef54490148addaf531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81a69b13339a5a975ab17eef54490148addaf531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a69b13339a5a975ab17eef54490148addaf531/comments", "author": null, "committer": null, "parents": [{"sha": "bdaa445236ad169bf757aa9d81c26d7e09a28e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdaa445236ad169bf757aa9d81c26d7e09a28e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdaa445236ad169bf757aa9d81c26d7e09a28e0c"}], "stats": {"total": 1814, "additions": 957, "deletions": 857}, "files": [{"sha": "a55735efcdace7bf08377a49f0c66e8a437701e4", "filename": "libffi/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a69b13339a5a975ab17eef54490148addaf531/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a69b13339a5a975ab17eef54490148addaf531/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=81a69b13339a5a975ab17eef54490148addaf531", "patch": "@@ -1,3 +1,12 @@\n+2004-12-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* src/types.c (FFI_TYPE_POINTER): Define with sizeof.\n+\t(FFI_TYPE_LONGDOUBLE): Fix for ia64.\n+\t* src/ia64/ffitarget.h (struct ffi_ia64_trampoline_struct): Move \n+\tinto ffi_prep_closure.\n+\t* src/ia64/ia64_flags.h, src/ia64/ffi.c, src/ia64/unix.S: Rewrite\n+\tfrom scratch.\n+\n 2004-12-27  Richard Henderson  <rth@redhat.com>\n \n \t* src/x86/unix64.S: Fix typo in unwind info."}, {"sha": "e810827a81de13249e4fed7bab9fee031cfe9703", "filename": "libffi/src/ia64/ffi.c", "status": "modified", "additions": 419, "deletions": 528, "changes": 947, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=81a69b13339a5a975ab17eef54490148addaf531", "patch": "@@ -29,643 +29,534 @@\n \n #include <stdlib.h>\n #include <stdbool.h>\n+#include <float.h>\n \n #include \"ia64_flags.h\"\n \n-/* Memory image of fp register contents.  Should eventually be an fp \t*/\n-/* type long enough to hold an entire register.  For now we use double.\t*/\n-typedef double float80;\n-\n-/* The stack layout at call to ffi_prep_args.  Other_args will remain\t*/\n-/* on the stack for the actual call.  Everything else we be transferred\t*/\n-/* to registers and popped by the assembly code.\t\t\t*/\n-\n-struct ia64_args {\n-    long scratch[2];\t/* Two scratch words at top of stack.\t\t*/\n-\t\t\t/* Allows sp to be passed as arg pointer.\t*/\n-    void * r8_contents;\t/* Value to be passed in r8\t\t\t*/\n-    long spare;\t\t/* Not used.\t\t\t\t\t*/\n-    float80 fp_regs[8]; /* Contents of 8 floating point argument \t*/\n-\t\t\t/* registers.\t\t\t\t\t*/\n-    long out_regs[8];\t/* Contents of the 8 out registers used \t*/\n-\t\t\t/* for integer parameters.\t\t\t*/\n-    long other_args[0]; /* Arguments passed on stack, variable size\t*/\n-\t\t\t/* Treated as continuation of out_regs.\t\t*/\n+/* A 64-bit pointer value.  In LP64 mode, this is effectively a plain\n+   pointer.  In ILP32 mode, it's a pointer that's been extended to \n+   64 bits by \"addp4\".  */\n+typedef void *PTR64 __attribute__((mode(DI)));\n+\n+/* Memory image of fp register contents.  This is the implementation\n+   specific format used by ldf.fill/stf.spill.  All we care about is\n+   that it wants a 16 byte aligned slot.  */\n+typedef struct\n+{\n+  UINT64 x[2] __attribute__((aligned(16)));\n+} fpreg;\n+\n+\n+/* The stack layout given to ffi_call_unix and ffi_closure_unix_inner.  */\n+\n+struct ia64_args\n+{\n+  fpreg fp_regs[8];\t/* Contents of 8 fp arg registers.  */\n+  UINT64 gp_regs[8];\t/* Contents of 8 gp arg registers.  */\n+  UINT64 other_args[];\t/* Arguments passed on stack, variable size.  */\n };\n \n-static size_t float_type_size(unsigned short tp)\n+\n+/* Adjust ADDR, a pointer to an 8 byte slot, to point to the low LEN bytes.  */\n+\n+static inline void *\n+endian_adjust (void *addr, size_t len)\n {\n-  switch(tp) {\n-    case FFI_TYPE_FLOAT:\n-      return sizeof(float);\n-    case FFI_TYPE_DOUBLE:\n-      return sizeof(double);\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-    case FFI_TYPE_LONGDOUBLE:\n-      return sizeof(long double);\n+#ifdef __BIG_ENDIAN__\n+  return addr + (8 - len);\n+#else\n+  return addr;\n #endif\n-    default:\n-      FFI_ASSERT(0);\n-  }\n }\n \n-/*\n- * Is type a struct containing at most n floats, doubles, or extended\n- * doubles, all of the same fp type?\n- * If so, set *element_type to the fp type.\n- */\n-static bool is_homogeneous_fp_aggregate(ffi_type * type, int n,\n-\t\t\t\t        unsigned short * element_type)\n+/* Store VALUE to ADDR in the current cpu implementation's fp spill format.  */\n+\n+static inline void\n+stf_spill(fpreg *addr, __float80 value)\n {\n-  ffi_type **ptr; \n-  unsigned short element, struct_element;\n+  asm (\"stf.spill %0 = %1%P0\" : \"=m\" (*addr) : \"f\"(value));\n+}\n+\n+/* Load a value from ADDR, which is in the current cpu implementation's\n+   fp spill format.  */\n \n-  int type_set = 0;\n+static inline __float80\n+ldf_fill(fpreg *addr)\n+{\n+  __float80 ret;\n+  asm (\"ldf.fill %0 = %1%P1\" : \"=f\"(ret) : \"m\"(*addr));\n+  return ret;\n+}\n \n-  FFI_ASSERT(type != NULL);\n+/* Return the size of the C type associated with with TYPE.  Which will\n+   be one of the FFI_IA64_TYPE_HFA_* values.  */\n \n-  FFI_ASSERT(type->elements != NULL);\n+static size_t\n+hfa_type_size (int type)\n+{\n+  switch (type)\n+    {\n+    case FFI_IA64_TYPE_HFA_FLOAT:\n+      return sizeof(float);\n+    case FFI_IA64_TYPE_HFA_DOUBLE:\n+      return sizeof(double);\n+    case FFI_IA64_TYPE_HFA_LDOUBLE:\n+      return sizeof(__float80);\n+    default:\n+      abort ();\n+    }\n+}\n \n-  ptr = &(type->elements[0]);\n+/* Load from ADDR a value indicated by TYPE.  Which will be one of\n+   the FFI_IA64_TYPE_HFA_* values.  */\n \n-  while ((*ptr) != NULL)\n+static __float80\n+hfa_type_load (int type, void *addr)\n+{\n+  switch (type)\n     {\n-      switch((*ptr) -> type) {\n-\tcase FFI_TYPE_FLOAT:\n-\t  if (type_set && element != FFI_TYPE_FLOAT) return 0;\n-\t  if (--n < 0) return false;\n-\t  type_set = 1;\n-\t  element = FFI_TYPE_FLOAT;\n-\t  break;\n-\tcase FFI_TYPE_DOUBLE:\n-\t  if (type_set && element != FFI_TYPE_DOUBLE) return 0;\n-\t  if (--n < 0) return false;\n-\t  type_set = 1;\n-\t  element = FFI_TYPE_DOUBLE;\n-\t  break;\n-\tcase FFI_TYPE_STRUCT:\n-\t  if (!is_homogeneous_fp_aggregate(type, n, &struct_element))\n-\t      return false;\n-\t  if (type_set && struct_element != element) return false;\n-\t  n -= (type -> size)/float_type_size(element);\n-\t  element = struct_element;\n-\t  if (n < 0) return false;\n-\t  break;\n-\t/* case FFI_TYPE_LONGDOUBLE:\n-\t  Not yet implemented.\t*/\n-\tdefault:\n-\t  return false;\n-      }\n-      ptr++;\n+    case FFI_IA64_TYPE_HFA_FLOAT:\n+      return *(float *) addr;\n+    case FFI_IA64_TYPE_HFA_DOUBLE:\n+      return *(double *) addr;\n+    case FFI_IA64_TYPE_HFA_LDOUBLE:\n+      return *(__float80 *) addr;\n+    default:\n+      abort ();\n     }\n-  *element_type = element;\n-  return true;\n-   \n-} \n+}\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n-   has been allocated for the function's arguments.  It fills in\n-   the arguments in the structure referenced by stack. Returns nonzero\n-   if fp registers are used for arguments. */\n+/* Load VALUE into ADDR as indicated by TYPE.  Which will be one of\n+   the FFI_IA64_TYPE_HFA_* values.  */\n \n-static bool\n-ffi_prep_args(struct ia64_args *stack, extended_cif *ecif, int bytes)\n+static void\n+hfa_type_store (int type, void *addr, __float80 value)\n {\n-  register long i, avn;\n-  register void **p_argv;\n-  register long *argp = stack -> out_regs;\n-  register float80 *fp_argp = stack -> fp_regs;\n-  register ffi_type **p_arg;\n-\n-  /* For big return structs, r8 needs to contain the target address.\t*/\n-  /* Since r8 is otherwise dead, we set it unconditionally.\t\t*/\n-  stack -> r8_contents = ecif -> rvalue;\n-  i = 0;\n-  avn = ecif->cif->nargs;\n-  p_arg = ecif->cif->arg_types;\n-  p_argv = ecif->avalue;\n-  while (i < avn)\n+  switch (type)\n     {\n-      size_t z; /* z is in units of arg slots or words, not bytes.\t*/\n+    case FFI_IA64_TYPE_HFA_FLOAT:\n+      *(float *) addr = value;\n+      break;\n+    case FFI_IA64_TYPE_HFA_DOUBLE:\n+      *(double *) addr = value;\n+      break;\n+    case FFI_IA64_TYPE_HFA_LDOUBLE:\n+      *(__float80 *) addr = value;\n+      break;\n+    default:\n+      abort ();\n+    }\n+}\n \n-      switch ((*p_arg)->type)\n-\t{\n-\tcase FFI_TYPE_SINT8:\n-\t  z = 1;\n-\t  *(SINT64 *) argp = *(SINT8 *)(* p_argv);\n-\t  break;\n-\t\t  \n-\tcase FFI_TYPE_UINT8:\n-\t  z = 1;\n-\t  *(UINT64 *) argp = *(UINT8 *)(* p_argv);\n-\t  break;\n-\t\t  \n-\tcase FFI_TYPE_SINT16:\n-\t  z = 1;\n-\t  *(SINT64 *) argp = *(SINT16 *)(* p_argv);\n-\t  break;\n-\t\t  \n-\tcase FFI_TYPE_UINT16:\n-\t  z = 1;\n-\t  *(UINT64 *) argp = *(UINT16 *)(* p_argv);\n-\t  break;\n-\t\t  \n-\tcase FFI_TYPE_SINT32:\n-\t  z = 1;\n-\t  *(SINT64 *) argp = *(SINT32 *)(* p_argv);\n-\t  break;\n-\t\t  \n-\tcase FFI_TYPE_UINT32:\n-\t  z = 1;\n-\t  *(UINT64 *) argp = *(UINT32 *)(* p_argv);\n-\t  break;\n+/* Is TYPE a struct containing floats, doubles, or extended doubles,\n+   all of the same fp type?  If so, return the element type.  Return\n+   FFI_TYPE_VOID if not.  */\n \n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_POINTER:\n-\t  z = 1;\n-\t  *(UINT64 *) argp = *(UINT64 *)(* p_argv);\n-\t  break;\n+static int\n+hfa_element_type (ffi_type *type, int nested)\n+{\n+  int element = FFI_TYPE_VOID;\n \n-\tcase FFI_TYPE_FLOAT:\n-\t  z = 1;\n-\t  if (fp_argp - stack->fp_regs < 8)\n-\t    {\n-\t      /* Note the conversion -- all the fp regs are loaded as\n-\t\t doubles.  */\n-\t      *fp_argp++ = *(float *)(* p_argv);\n-\t    }\n-\t  /* Also put it into the integer registers or memory: */\n-\t  *(UINT64 *) argp = *(UINT32 *)(* p_argv);\n-\t  break;\n+  switch (type->type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+      /* We want to return VOID for raw floating-point types, but the\n+\t synthetic HFA type if we're nested within an aggregate.  */\n+      if (nested)\n+\telement = FFI_IA64_TYPE_HFA_FLOAT;\n+      break;\n \n-\tcase FFI_TYPE_DOUBLE:\n-\t  z = 1;\n-\t  if (fp_argp - stack->fp_regs < 8)\n-\t    *fp_argp++ = *(double *)(* p_argv);\n-\t  /* Also put it into the integer registers or memory: */\n-\t  *(double *) argp = *(double *)(* p_argv);\n-\t  break;\n+    case FFI_TYPE_DOUBLE:\n+      /* Similarly.  */\n+      if (nested)\n+\telement = FFI_IA64_TYPE_HFA_DOUBLE;\n+      break;\n \n-\tcase FFI_TYPE_STRUCT:\n+    case FFI_TYPE_LONGDOUBLE:\n+      /* Similarly, except that that HFA is true for double extended,\n+\t but not quad precision.  Both have sizeof == 16, so tell the\n+\t difference based on the precision.  */\n+      if (LDBL_MANT_DIG == 64 && nested)\n+\telement = FFI_IA64_TYPE_HFA_LDOUBLE;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      {\n+\tffi_type **ptr = &type->elements[0];\n+\n+\tfor (ptr = &type->elements[0]; *ptr ; ptr++)\n \t  {\n-\t      size_t sz = (*p_arg)->size;\n-\t      unsigned short element_type;\n-              z = ((*p_arg)->size + FFI_SIZEOF_ARG - 1)/FFI_SIZEOF_ARG;\n-\t      if (is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {\n-\t\tint i;\n-\t\tint nelements = sz/float_type_size(element_type);\n-\t\tfor (i = 0; i < nelements; ++i) {\n-\t\t  switch (element_type) {\n-\t\t    case FFI_TYPE_FLOAT:\n-\t\t      if (fp_argp - stack->fp_regs < 8)\n-\t\t\t*fp_argp++ = ((float *)(* p_argv))[i];\n-\t\t      break;\n-\t\t    case FFI_TYPE_DOUBLE:\n-\t\t      if (fp_argp - stack->fp_regs < 8)\n-\t\t\t*fp_argp++ = ((double *)(* p_argv))[i];\n-\t\t      break;\n-\t\t    default:\n-\t\t\t/* Extended precision not yet implemented. */\n-\t\t\tabort();\n-\t\t  }\n-\t\t}\n-\t      }\n-\t      /* And pass it in integer registers as a struct, with\t*/\n-\t      /* its actual field sizes packed into registers.\t\t*/\n-\t      memcpy(argp, *p_argv, (*p_arg)->size);\n+\t    int sub_element = hfa_element_type (*ptr, 1);\n+\t    if (sub_element == FFI_TYPE_VOID)\n+\t      return FFI_TYPE_VOID;\n+\n+\t    if (element == FFI_TYPE_VOID)\n+\t      element = sub_element;\n+\t    else if (element != sub_element)\n+\t      return FFI_TYPE_VOID;\n \t  }\n-\t  break;\n-\n-\tdefault:\n-\t  FFI_ASSERT(0);\n-\t}\n+      }\n+      break;\n \n-      argp += z;\n-      i++, p_arg++, p_argv++;\n+    default:\n+      return FFI_TYPE_VOID;\n     }\n-  return (fp_argp != stack -> fp_regs);\n+\n+  return element;\n }\n \n-/* Perform machine dependent cif processing */\n+\n+/* Perform machine dependent cif processing. */\n+\n ffi_status\n ffi_prep_cif_machdep(ffi_cif *cif)\n {\n-  long i, avn;\n-  bool is_simple = true;\n-  long simple_flag = FFI_SIMPLE_V;\n-  /* Adjust cif->bytes to include space for the 2 scratch words,\n-     r8 register contents, spare word,\n-     the 8 fp register contents, and all 8 integer register contents.\n-     This will be removed before the call, though 2 scratch words must\n-     remain.  */\n-\n-  cif->bytes += 4*sizeof(long) + 8 *sizeof(float80);\n+  int flags;\n+\n+  /* Adjust cif->bytes to include space for the bits of the ia64_args frame\n+     that preceeds the integer register portion.  The estimate that the \n+     generic bits did for the argument space required is good enough for the\n+     integer component.  */\n+  cif->bytes += offsetof(struct ia64_args, gp_regs[0]);\n   if (cif->bytes < sizeof(struct ia64_args))\n     cif->bytes = sizeof(struct ia64_args);\n \n-  /* The stack must be double word aligned, so round bytes up\n-     appropriately. */\n-\n-  cif->bytes = ALIGN(cif->bytes, 2*sizeof(void*));\n-\n-  avn = cif->nargs;\n-  if (avn <= 2) {\n-    for (i = 0; i < avn; ++i) {\n-      switch(cif -> arg_types[i] -> type) {\n-\tcase FFI_TYPE_SINT32:\n-\t  simple_flag = FFI_ADD_INT_ARG(simple_flag);\n-\t  break;\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_POINTER:\n-\t  simple_flag = FFI_ADD_LONG_ARG(simple_flag);\n-\t  break;\n-\tdefault:\n-\t  is_simple = false;\n-      }\n-    }\n-  } else {\n-    is_simple = false;\n-  }\n-\n-  /* Set the return type flag */\n+  /* Set the return type flag. */\n+  flags = cif->rtype->type;\n   switch (cif->rtype->type)\n     {\n-    case FFI_TYPE_VOID:\n-      cif->flags = FFI_TYPE_VOID;\n+    case FFI_TYPE_LONGDOUBLE:\n+      /* Leave FFI_TYPE_LONGDOUBLE as meaning double extended precision,\n+\t and encode quad precision as a two-word integer structure.  */\n+      if (LDBL_MANT_DIG != 64)\n+\tflags = FFI_IA64_TYPE_SMALL_STRUCT | (16 << 8);\n       break;\n \n     case FFI_TYPE_STRUCT:\n       {\n-        size_t sz = cif -> rtype -> size;\n-  \tunsigned short element_type;\n-\n-\tis_simple = false;\n-  \tif (is_homogeneous_fp_aggregate(cif -> rtype, 8, &element_type)) {\n-\t  int nelements = sz/float_type_size(element_type);\n-\t  if (nelements <= 1) {\n-\t    if (0 == nelements) {\n-\t      cif -> flags = FFI_TYPE_VOID;\n-\t    } else {\n-\t      cif -> flags = element_type;\n-\t    }\n-\t  } else {\n-\t    switch(element_type) {\n-\t      case FFI_TYPE_FLOAT:\n-\t        cif -> flags = FFI_IS_FLOAT_FP_AGGREGATE | nelements;\n-\t\tbreak;\n-\t      case FFI_TYPE_DOUBLE:\n-\t        cif -> flags = FFI_IS_DOUBLE_FP_AGGREGATE | nelements;\n-\t\tbreak;\n-\t      default:\n-\t\t/* long double NYI */\n-\t\tabort();\n-\t    }\n+        size_t size = cif->rtype->size;\n+  \tint hfa_type = hfa_element_type (cif->rtype, 0);\n+\n+\tif (hfa_type != FFI_TYPE_VOID)\n+\t  {\n+\t    size_t nelts = size / hfa_type_size (hfa_type);\n+\t    if (nelts <= 8)\n+\t      flags = hfa_type | (size << 8);\n \t  }\n-\t  break;\n-        }\n-        if (sz <= 32) {\n-\t  if (sz <= 8) {\n-              cif->flags = FFI_TYPE_INT;\n-  \t  } else if (sz <= 16) {\n-              cif->flags = FFI_IS_SMALL_STRUCT2;\n-  \t  } else if (sz <= 24) {\n-              cif->flags = FFI_IS_SMALL_STRUCT3;\n-\t  } else {\n-              cif->flags = FFI_IS_SMALL_STRUCT4;\n+\telse\n+\t  {\n+\t    if (size <= 32)\n+\t      flags = FFI_IA64_TYPE_SMALL_STRUCT | (size << 8);\n \t  }\n-        } else {\n-          cif->flags = FFI_TYPE_STRUCT;\n-\t}\n       }\n       break;\n \n-    case FFI_TYPE_FLOAT:\n-      is_simple = false;\n-      cif->flags = FFI_TYPE_FLOAT;\n-      break;\n-\n-    case FFI_TYPE_DOUBLE:\n-      is_simple = false;\n-      cif->flags = FFI_TYPE_DOUBLE;\n-      break;\n-\n     default:\n-      cif->flags = FFI_TYPE_INT;\n-      /* This seems to depend on little endian mode, and the fact that\t*/\n-      /* the return pointer always points to at least 8 bytes.  But \t*/\n-      /* that also seems to be true for other platforms.\t\t*/\n       break;\n     }\n-  \n-  if (is_simple) cif -> flags |= simple_flag;\n+  cif->flags = flags;\n+\n   return FFI_OK;\n }\n \n-extern int ffi_call_unix(bool (*)(struct ia64_args *, extended_cif *, int), \n-\t\t\t extended_cif *, unsigned, \n-\t\t\t unsigned, unsigned *, void (*)());\n+extern int ffi_call_unix (struct ia64_args *, PTR64, void (*)(), UINT64);\n \n void\n ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n-  extended_cif ecif;\n-  long simple = cif -> flags & FFI_SIMPLE;\n-\n-  /* Should this also check for Unix ABI? */\n-  /* This is almost, but not quite, machine independent.  Note that\t*/\n-  /* we can get away with not caring about length of the result because\t*/\n-  /* we assume we are little endian, and the result buffer is large \t*/\n-  /* enough.\t\t\t\t\t\t\t\t*/\n-  /* This needs work for HP/UX.\t\t\t\t\t\t*/\n-  if (simple) {\n-    long (*lfn)() = (long (*)())fn;\n-    long result;\n-    switch(simple) {\n-      case FFI_SIMPLE_V:\n-\tresult = lfn();\n-\tbreak;\n-      case FFI_SIMPLE_I:\n-\tresult = lfn(*(int *)avalue[0]);\n-\tbreak;\n-      case FFI_SIMPLE_L:\n-\tresult = lfn(*(long *)avalue[0]);\n-\tbreak;\n-      case FFI_SIMPLE_II:\n-\tresult = lfn(*(int *)avalue[0], *(int *)avalue[1]);\n-\tbreak;\n-      case FFI_SIMPLE_IL:\n-\tresult = lfn(*(int *)avalue[0], *(long *)avalue[1]);\n-\tbreak;\n-      case FFI_SIMPLE_LI:\n-\tresult = lfn(*(long *)avalue[0], *(int *)avalue[1]);\n-\tbreak;\n-      case FFI_SIMPLE_LL:\n-\tresult = lfn(*(long *)avalue[0], *(long *)avalue[1]);\n-\tbreak;\n-    }\n-    if ((cif->flags & ~FFI_SIMPLE) != FFI_TYPE_VOID && 0 != rvalue) {\n-      * (long *)rvalue = result;\n-    }\n-    return;\n-  }\n-  ecif.cif = cif;\n-  ecif.avalue = avalue;\n-  \n-  /* If the return value is a struct and we don't have a return\n-     value address then we need to make one.  */\n-  \n-  if (rvalue == NULL && cif->rtype->type == FFI_TYPE_STRUCT)\n-    ecif.rvalue = alloca(cif->rtype->size);\n-  else\n-    ecif.rvalue = rvalue;\n-    \n-  switch (cif->abi) \n-    {\n-    case FFI_UNIX:\n-      ffi_call_unix(ffi_prep_args, &ecif, cif->bytes,\n-\t\t    cif->flags, rvalue, fn);\n-      break;\n+  struct ia64_args *stack;\n+  long i, avn, gpcount, fpcount;\n+  ffi_type **p_arg;\n \n-    default:\n-      FFI_ASSERT(0);\n-      break;\n-    }\n-}\n-\n-/*\n- * Closures represent a pair consisting of a function pointer, and\n- * some user data.  A closure is invoked by reinterpreting the closure\n- * as a function pointer, and branching to it.  Thus we can make an\n- * interpreted function callable as a C function:  We turn the interpreter\n- * itself, together with a pointer specifying the interpreted procedure,\n- * into a closure.\n- * On X86, the first few words of the closure structure actually contain code,\n- * which will do the right thing.  On most other architectures, this\n- * would raise some Icache/Dcache coherence issues (which can be solved, but\n- * often not cheaply).\n- * For IA64, function pointer are already pairs consisting of a code\n- * pointer, and a gp pointer.  The latter is needed to access global variables.\n- * Here we set up such a pair as the first two words of the closure (in\n- * the \"trampoline\" area), but we replace the gp pointer with a pointer\n- * to the closure itself.  We also add the real gp pointer to the\n- * closure.  This allows the function entry code to both retrieve the\n- * user data, and to restire the correct gp pointer.\n- */\n-\n-static void \n-ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,\n-\t\t\t    void **avalue, ffi_cif *cif);\n-\n-/* This function is entered with the doctored gp (r1) value.\n- * This code is extremely gcc specific.  There is some argument that\n- * it should really be written in assembly code, since it depends on\n- * gcc properties that might change over time.\n- */\n-\n-/* ffi_closure_UNIX is an assembly routine, which copies the register \t*/\n-/* state into a struct ia64_args, and then invokes\t\t\t*/\n-/* ffi_closure_UNIX_inner.  It also recovers the closure pointer\t*/\n-/* from its fake gp pointer.\t\t\t\t\t\t*/\n-void ffi_closure_UNIX();\n-\n-#ifndef __GNUC__\n-#   error This requires gcc\n-#endif\n-void\n-ffi_closure_UNIX_inner (ffi_closure *closure, struct ia64_args * args)\n-/* Hopefully declaring this as a varargs function will force all args\t*/\n-/* to memory.\t\t\t\t\t\t\t\t*/\n-{\n-  // this is our return value storage\n-  long double    res;\n-\n-  // our various things...\n-  ffi_cif       *cif;\n-  unsigned short rtype;\n-  void          *resp;\n-  void\t\t**arg_area;\n-\n-  resp = (void*)&res;\n-  cif         = closure->cif;\n-  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  \n-\n-  /* this call will initialize ARG_AREA, such that each\n-   * element in that array points to the corresponding \n-   * value on the stack; and if the function returns\n-   * a structure, it will re-set RESP to point to the\n-   * structure return address.  */\n-\n-  ffi_prep_incoming_args_UNIX(args, (void**)&resp, arg_area, cif);\n-  \n-  (closure->fun) (cif, resp, arg_area, closure->user_data);\n-\n-  rtype = cif->flags;\n-\n-  /* now, do a generic return based on the value of rtype */\n-  if (rtype == FFI_TYPE_INT)\n-    {\n-      asm volatile (\"ld8 r8=[%0]\" : : \"r\" (resp) : \"r8\");\n-    }\n-  else if (rtype == FFI_TYPE_FLOAT)\n-    {\n-      asm volatile (\"ldfs f8=[%0]\" : : \"r\" (resp) : \"f8\");\n-    }\n-  else if (rtype == FFI_TYPE_DOUBLE)\n-    {\n-      asm volatile (\"ldfd f8=[%0]\" : : \"r\" (resp) : \"f8\");\n-    }\n-  else if (rtype == FFI_IS_SMALL_STRUCT2)\n-    {\n-      asm volatile (\"ld8 r8=[%0]; ld8 r9=[%1]\"\n-\t\t    : : \"r\" (resp), \"r\" (resp+8) : \"r8\",\"r9\");\n-    }\n-  else if (rtype == FFI_IS_SMALL_STRUCT3)\n-    {\n-      asm volatile (\"ld8 r8=[%0]; ld8 r9=[%1]; ld8 r10=[%2]\"\n-\t\t    : : \"r\" (resp), \"r\" (resp+8), \"r\" (resp+16)\n-\t\t    : \"r8\",\"r9\",\"r10\");\n-    }\n-  else if (rtype == FFI_IS_SMALL_STRUCT4)\n-    {\n-      asm volatile (\"ld8 r8=[%0]; ld8 r9=[%1]; ld8 r10=[%2]; ld8 r11=[%3]\"\n-\t\t    : : \"r\" (resp), \"r\" (resp+8), \"r\" (resp+16), \"r\" (resp+24)\n-\t\t    : \"r8\",\"r9\",\"r10\",\"r11\");\n-    }\n-  else if (rtype != FFI_TYPE_VOID && rtype != FFI_TYPE_STRUCT)\n-    {\n-      /* Can only happen for homogeneous FP aggregates?\t*/\n-      abort();\n-    }\n-}\n+  FFI_ASSERT (cif->abi == FFI_UNIX);\n \n-static void \n-ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,\n-\t\t\t    void **avalue, ffi_cif *cif)\n-{\n-  register unsigned int i;\n-  register unsigned int avn;\n-  register void **p_argv;\n-  register long *argp = args -> out_regs;\n-  unsigned fp_reg_num = 0;\n-  register ffi_type **p_arg;\n+  /* If we have no spot for a return value, make one.  */\n+  if (rvalue == NULL && cif->rtype->type != FFI_TYPE_VOID)\n+    rvalue = alloca (cif->rtype->size);\n+    \n+  /* Allocate the stack frame.  */\n+  stack = alloca (cif->bytes);\n \n+  gpcount = fpcount = 0;\n   avn = cif->nargs;\n-  p_argv = avalue;\n-\n-  for (i = cif->nargs, p_arg = cif->arg_types; i != 0; i--, p_arg++)\n+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)\n     {\n-      size_t z; /* In units of words or argument slots.\t*/\n-\n       switch ((*p_arg)->type)\n \t{\n \tcase FFI_TYPE_SINT8:\n+\t  stack->gp_regs[gpcount++] = *(SINT8 *)avalue[i];\n+\t  break;\n \tcase FFI_TYPE_UINT8:\n+\t  stack->gp_regs[gpcount++] = *(UINT8 *)avalue[i];\n+\t  break;\n \tcase FFI_TYPE_SINT16:\n+\t  stack->gp_regs[gpcount++] = *(SINT16 *)avalue[i];\n+\t  break;\n \tcase FFI_TYPE_UINT16:\n+\t  stack->gp_regs[gpcount++] = *(UINT16 *)avalue[i];\n+\t  break;\n \tcase FFI_TYPE_SINT32:\n+\t  stack->gp_regs[gpcount++] = *(SINT32 *)avalue[i];\n+\t  break;\n \tcase FFI_TYPE_UINT32:\n+\t  stack->gp_regs[gpcount++] = *(UINT32 *)avalue[i];\n+\t  break;\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n+\t  stack->gp_regs[gpcount++] = *(UINT64 *)avalue[i];\n+\t  break;\n+\n \tcase FFI_TYPE_POINTER:\n-\t  z = 1;\n-\t  *p_argv = (void *)argp;\n+\t  stack->gp_regs[gpcount++] = (UINT64)(PTR64) *(void **)avalue[i];\n \t  break;\n-\t\t  \n+\n \tcase FFI_TYPE_FLOAT:\n-\t  z = 1;\n-\t  /* Convert argument back to float in place from the saved value */\n-\t  if (argp - args->out_regs < 8 && fp_reg_num < 8) {\n-\t      *(float *)argp = args -> fp_regs[fp_reg_num++];\n-\t  }\n-\t  *p_argv = (void *)argp;\n+\t  if (gpcount < 8 && fpcount < 8)\n+\t    stf_spill (&stack->fp_regs[fpcount++], *(float *)avalue[i]);\n+\t  stack->gp_regs[gpcount++] = *(UINT32 *)avalue[i];\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  z = 1;\n-\t  if (argp - args->out_regs < 8 && fp_reg_num < 8) {\n-\t      *p_argv = args -> fp_regs + fp_reg_num++;\n-\t  } else {\n-\t      *p_argv = (void *)argp;\n-\t  }\n+\t  if (gpcount < 8 && fpcount < 8)\n+\t    stf_spill (&stack->fp_regs[fpcount++], *(double *)avalue[i]);\n+\t  stack->gp_regs[gpcount++] = *(UINT64 *)avalue[i];\n+\t  break;\n+\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if (gpcount & 1)\n+\t    gpcount++;\n+\t  if (LDBL_MANT_DIG == 64 && gpcount < 8 && fpcount < 8)\n+\t    stf_spill (&stack->fp_regs[fpcount++], *(__float80 *)avalue[i]);\n+\t  memcpy (&stack->gp_regs[gpcount], avalue[i], 16);\n+\t  gpcount += 2;\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n \t  {\n-\t      size_t sz = (*p_arg)->size;\n-\t      unsigned short element_type;\n-              z = ((*p_arg)->size + FFI_SIZEOF_ARG - 1)/FFI_SIZEOF_ARG;\n-\t      if (argp - args->out_regs < 8\n-\t\t  && is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {\n-\t\tint nelements = sz/float_type_size(element_type);\n-\t\tif (nelements + fp_reg_num >= 8) {\n-\t\t  /* hard case NYI.\t*/\n-\t\t  abort();\n-\t\t}\n-\t\tif (element_type == FFI_TYPE_DOUBLE) {\n-\t          *p_argv = args -> fp_regs + fp_reg_num;\n-\t\t  fp_reg_num += nelements;\n-\t\t  break;\n-\t\t}\n-\t\tif (element_type == FFI_TYPE_FLOAT) {\n-\t\t  int j;\n-\t\t  for (j = 0; j < nelements; ++ j) {\n-\t\t     ((float *)argp)[j] = args -> fp_regs[fp_reg_num + j];\n+\t    size_t size = (*p_arg)->size;\n+\t    size_t align = (*p_arg)->alignment;\n+\t    int hfa_type = hfa_element_type (*p_arg, 0);\n+\n+\t    FFI_ASSERT (align <= 16);\n+\t    if (align == 16 && (gpcount & 1))\n+\t      gpcount++;\n+\n+\t    if (hfa_type != FFI_TYPE_VOID)\n+\t      {\n+\t\tsize_t hfa_size = hfa_type_size (hfa_type);\n+\t\tsize_t offset = 0;\n+\t\tsize_t gp_offset = gpcount * 8;\n+\n+\t\twhile (fpcount < 8\n+\t\t       && offset < size\n+\t\t       && gp_offset < 8 * 8)\n+\t\t  {\n+\t\t    stf_spill (&stack->fp_regs[fpcount],\n+\t\t\t       hfa_type_load (hfa_type, avalue[i] + offset));\n+\t\t    offset += hfa_size;\n+\t\t    gp_offset += hfa_size;\n+\t\t    fpcount += 1;\n \t\t  }\n-\t          *p_argv = (void *)argp;\n-\t\t  fp_reg_num += nelements;\n-\t\t  break;\n-\t\t}\n-\t\tabort();  /* Other fp types NYI */\n \t      }\n+\n+\t    memcpy (&stack->gp_regs[gpcount], avalue[i], size);\n+\t    gpcount += (size + 7) / 8;\n \t  }\n \t  break;\n \n \tdefault:\n-\t  FFI_ASSERT(0);\n+\t  abort ();\n \t}\n-\n-      argp += z;\n-      p_argv++;\n-\n     }\n-  \n-  return;\n+\n+  ffi_call_unix (stack, rvalue, fn, cif->flags);\n }\n \n+/* Closures represent a pair consisting of a function pointer, and\n+   some user data.  A closure is invoked by reinterpreting the closure\n+   as a function pointer, and branching to it.  Thus we can make an\n+   interpreted function callable as a C function: We turn the\n+   interpreter itself, together with a pointer specifying the\n+   interpreted procedure, into a closure.\n \n-/* Fill in a closure to refer to the specified fun and user_data.\t*/\n-/* cif specifies the argument and result types for fun.\t\t\t*/\n-/* the cif must already be prep'ed */\n+   For IA64, function pointer are already pairs consisting of a code\n+   pointer, and a gp pointer.  The latter is needed to access global\n+   variables.  Here we set up such a pair as the first two words of\n+   the closure (in the \"trampoline\" area), but we replace the gp\n+   pointer with a pointer to the closure itself.  We also add the real\n+   gp pointer to the closure.  This allows the function entry code to\n+   both retrieve the user data, and to restire the correct gp pointer.  */\n \n-/* The layout of a function descriptor.  A C function pointer really \t*/\n-/* points to one of these.\t\t\t\t\t\t*/\n-typedef struct ia64_fd_struct {\n-    void *code_pointer;\n-    void *gp;\n-} ia64_fd;\n+extern void ffi_closure_unix ();\n \n ffi_status\n ffi_prep_closure (ffi_closure* closure,\n \t\t  ffi_cif* cif,\n \t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n \t\t  void *user_data)\n {\n-  struct ffi_ia64_trampoline_struct *tramp =\n-    (struct ffi_ia64_trampoline_struct *) (closure -> tramp);\n-  ia64_fd *fd = (ia64_fd *)(void *)ffi_closure_UNIX;\n+  /* The layout of a function descriptor.  A C function pointer really \n+     points to one of these.  */\n+  struct ia64_fd\n+  {\n+    UINT64 code_pointer;\n+    UINT64 gp;\n+  };\n+\n+  struct ffi_ia64_trampoline_struct\n+  {\n+    UINT64 code_pointer;\t/* Pointer to ffi_closure_unix.  */\n+    UINT64 fake_gp;\t\t/* Pointer to closure, installed as gp.  */\n+    UINT64 real_gp;\t\t/* Real gp value.  */\n+  };\n+\n+  struct ffi_ia64_trampoline_struct *tramp;\n+  struct ia64_fd *fd;\n \n   FFI_ASSERT (cif->abi == FFI_UNIX);\n \n-  tramp -> code_pointer = fd -> code_pointer;\n-  tramp -> real_gp = fd -> gp;\n-  tramp -> fake_gp = closure;\n-  closure->cif  = cif;\n+  tramp = (struct ffi_ia64_trampoline_struct *)closure->tramp;\n+  fd = (struct ia64_fd *)(void *)ffi_closure_unix;\n+\n+  tramp->code_pointer = fd->code_pointer;\n+  tramp->real_gp = fd->gp;\n+  tramp->fake_gp = (UINT64)(PTR64)closure;\n+  closure->cif = cif;\n   closure->user_data = user_data;\n-  closure->fun  = fun;\n+  closure->fun = fun;\n \n   return FFI_OK;\n }\n \n \n+UINT64\n+ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n+\t\t\tvoid *rvalue, void *r8)\n+{\n+  ffi_cif *cif;\n+  void **avalue;\n+  ffi_type **p_arg;\n+  long i, avn, gpcount, fpcount;\n+\n+  cif = closure->cif;\n+  avn = cif->nargs;\n+  avalue = alloca (avn * sizeof (void *));\n+\n+  /* If the structure return value is passed in memory get that location\n+     from r8 so as to pass the value directly back to the caller.  */\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    rvalue = r8;\n+\n+  gpcount = fpcount = 0;\n+  for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)\n+    {\n+      switch ((*p_arg)->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\t  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], 1);\n+\t  break;\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\t  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], 2);\n+\t  break;\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\t  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], 4);\n+\t  break;\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t  avalue[i] = &stack->gp_regs[gpcount++];\n+\t  break;\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = endian_adjust(&stack->gp_regs[gpcount++], sizeof(void*));\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  if (gpcount < 8 && fpcount < 8)\n+\t    {\n+\t      void *addr = &stack->fp_regs[fpcount++];\n+\t      avalue[i] = addr;\n+\t      *(float *)addr = ldf_fill (addr);\n+\t    }\n+\t  else\n+\t    avalue[i] = endian_adjust(&stack->gp_regs[gpcount], 4);\n+\t  gpcount++;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  if (gpcount < 8 && fpcount < 8)\n+\t    {\n+\t      void *addr = &stack->fp_regs[fpcount++];\n+\t      avalue[i] = addr;\n+\t      *(double *)addr = ldf_fill (addr);\n+\t    }\n+\t  else\n+\t    avalue[i] = &stack->gp_regs[gpcount];\n+\t  gpcount++;\n+\t  break;\n+\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if (gpcount & 1)\n+\t    gpcount++;\n+\t  if (LDBL_MANT_DIG == 64 && gpcount < 8 && fpcount < 8)\n+\t    {\n+\t      void *addr = &stack->fp_regs[fpcount++];\n+\t      avalue[i] = addr;\n+\t      *(__float80 *)addr = ldf_fill (addr);\n+\t    }\n+\t  else\n+\t    avalue[i] = &stack->gp_regs[gpcount];\n+\t  gpcount += 2;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  {\n+\t    size_t size = (*p_arg)->size;\n+\t    size_t align = (*p_arg)->alignment;\n+\t    int hfa_type = hfa_element_type (*p_arg, 0);\n+\n+\t    FFI_ASSERT (align <= 16);\n+\t    if (align == 16 && (gpcount & 1))\n+\t      gpcount++;\n+\n+\t    if (hfa_type != FFI_TYPE_VOID)\n+\t      {\n+\t\tsize_t hfa_size = hfa_type_size (hfa_type);\n+\t\tsize_t offset = 0;\n+\t\tsize_t gp_offset = gpcount * 8;\n+\t\tvoid *addr = alloca (size);\n+\n+\t\tavalue[i] = addr;\n+\n+\t\twhile (fpcount < 8\n+\t\t       && offset < size\n+\t\t       && gp_offset < 8 * 8)\n+\t\t  {\n+\t\t    hfa_type_store (hfa_type, addr + offset, \n+\t\t\t\t    ldf_fill (&stack->fp_regs[fpcount]));\n+\t\t    offset += hfa_size;\n+\t\t    gp_offset += hfa_size;\n+\t\t    fpcount += 1;\n+\t\t  }\n+\n+\t\tif (offset < size)\n+\t\t  memcpy (addr + offset, (char *)stack->gp_regs + gp_offset,\n+\t\t\t  size - offset);\n+\t      }\n+\t    else\n+\t      avalue[i] = &stack->gp_regs[gpcount];\n+\n+\t    gpcount += (size + 7) / 8;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  closure->fun (cif, rvalue, avalue, closure->user_data);\n+\n+  return cif->flags;\n+}"}, {"sha": "2f98d51c429944e9b3a21f6fc46ac904ae3ca9ea", "filename": "libffi/src/ia64/ffitarget.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffitarget.h?ref=81a69b13339a5a975ab17eef54490148addaf531", "patch": "@@ -45,14 +45,5 @@ typedef enum ffi_abi {\n \t\t\t\t/* can be interpreted as a C function\t*/\n \t\t\t\t/* descriptor:\t\t\t\t*/\n \n-#ifndef LIBFFI_ASM\n-struct ffi_ia64_trampoline_struct {\n-    void * code_pointer;\t/* Pointer to ffi_closure_UNIX\t*/\n-    void * fake_gp;\t\t/* Pointer to closure, installed as gp\t*/\n-    void * real_gp;\t\t/* Real gp value, reinstalled by \t*/\n-\t\t\t\t/* ffi_closure_UNIX.\t\t\t*/\n-};\n-#endif\n-\n #endif\n "}, {"sha": "1dd6d7e3feb63cacc8f8c79eeaf99f890ca07d6f", "filename": "libffi/src/ia64/ia64_flags.h", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Fia64_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Fia64_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fia64_flags.h?ref=81a69b13339a5a975ab17eef54490148addaf531", "patch": "@@ -25,38 +25,15 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-\n-/* Homogeneous Floating Point Aggregates (HFAs) which are returned\t*/\n-/* in FP registers.  The least significant bits specify the size in \t*/\n-/* words.\t\t\t\t\t\t\t\t*/\n-#define FFI_IS_FLOAT_FP_AGGREGATE 0x1000\n-#define FFI_IS_DOUBLE_FP_AGGREGATE 0x0800\n-#define FLOAT_FP_AGGREGATE_BIT 12\n-#define DOUBLE_FP_AGGREGATE_BIT 11\n-\n-/* Small structures containing N words.  If N=1, they are returned\t*/\n-/* as though they were integers.\t\t\t\t\t*/\n-#define FFI_IS_SMALL_STRUCT2\t0x40 /* Struct > 8, <=16 bytes\t*/\n-#define FFI_IS_SMALL_STRUCT3\t0x41 /* Struct > 16 <= 24 bytes\t*/\n-#define FFI_IS_SMALL_STRUCT4\t0x42 /* Struct > 24, <=32 bytes\t*/\n-\n-/* Flag values identifying particularly simple cases, which are \t*/\n-/* handled specially.  We treat functions as simple if they take all\t*/\n-/* arguments can be passed as 32 or 64 bit integer quantities, there is\t*/\n-/* either no return value or it can be treated as a 64bit integer, and\t*/\n-/* if there are at most 2 arguments.\t\t\t\t\t*/\n-/* This is OR'ed with the normal flag values.\t\t\t\t*/\n-#define FFI_SIMPLE_V 0x10000\t/* () -> X\t*/\n-#define FFI_SIMPLE_I 0x20000\t/* (int) -> X\t*/\n-#define FFI_SIMPLE_L 0x30000\t/* (long) -> X\t*/\n-#define FFI_SIMPLE_II 0x40000\t/* (int,int) -> X\t*/\n-#define FFI_SIMPLE_IL 0x50000\t/* (int,long) -> X\t*/\n-#define FFI_SIMPLE_LI 0x60000\t/* (long,int) -> X\t*/\n-#define FFI_SIMPLE_LL 0x70000\t/* (long,long) -> X\t*/\n-\n-/* Mask for all of the FFI_SIMPLE bits:\t*/\n-#define FFI_SIMPLE 0xf0000\n-\n-/* An easy way to build FFI_SIMPLE flags from FFI_SIMPLE_V:\t*/\n-#define FFI_ADD_LONG_ARG(flag) (((flag) << 1) | 0x10000)\n-#define FFI_ADD_INT_ARG(flag) ((flag) << 1)\n+/* \"Type\" codes used between assembly and C.  When used as a part of\n+   a cfi->flags value, the low byte will be these extra type codes,\n+   and bits 8-31 will be the actual size of the type.  */\n+\n+/* Small structures containing N words in integer registers.  */\n+#define FFI_IA64_TYPE_SMALL_STRUCT\t(FFI_TYPE_LAST + 1)\n+\n+/* Homogeneous Floating Point Aggregates (HFAs) which are returned\n+   in FP registers.  */\n+#define FFI_IA64_TYPE_HFA_FLOAT\t\t(FFI_TYPE_LAST + 2)\n+#define FFI_IA64_TYPE_HFA_DOUBLE\t(FFI_TYPE_LAST + 3)\n+#define FFI_IA64_TYPE_HFA_LDOUBLE\t(FFI_TYPE_LAST + 4)"}, {"sha": "7c68b2d3a62d2b103811c8a8b7abe8a8877a9143", "filename": "libffi/src/ia64/unix.S", "status": "modified", "additions": 514, "deletions": 267, "changes": 781, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Funix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Fia64%2Funix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Funix.S?ref=81a69b13339a5a975ab17eef54490148addaf531", "patch": "@@ -33,295 +33,542 @@\n #include <ffi.h>\n #include \"ia64_flags.h\"\n \n-/* parameters:\t*/\n-#define callback\tin0\n-#define ecifp\t\tin1\n-#define bytes\t\tin2\n-#define flags\t\tin3\n-#define raddr\t\tin4\n-#define fn\t\tin5\n-\n-#define FLOAT_SZ\t8 /* in-memory size of fp operands\t*/\n-\n-/* Allocate an ia64_args structure on the stack; call ffi_prep_args\t*/\n-/* to fill it in with argument values; copy those to the real \t\t*/\n-/* registers, leaving overflow arguments on the stack.  Then call fn\t*/\n-/* and move the result from registers into *raddr.\t\t\t*/\n \t.pred.safe_across_calls p1-p5,p16-p63\n .text\n+\n+/* int ffi_call_unix (struct ia64_args *stack, PTR64 rvalue,\n+\t\t      void (*fn)(), int flags);\n+ */\n+\n         .align 16\n-        .global ffi_call_unix\n-        .proc ffi_call_unix\n+        .global\tffi_call_unix\n+        .proc\tffi_call_unix\n ffi_call_unix:\n \t.prologue\n-\t.save\tar.pfs,r38 /* loc0 */\n-\talloc   loc0=ar.pfs,6,6,8,0\n-\t.save\trp,loc1\n-\tmov \tloc1=b0;\n-\t.vframe\tloc5\n-\tmov\tloc5=sp;\n+\t/* Bit o trickiness.  We actually share a stack frame with ffi_call.\n+\t   Rely on the fact that ffi_call uses a vframe and don't bother\n+\t   tracking one here at all.  */\n+\t.fframe\t0\n+\t.save\tar.pfs, r36 // loc0\n+\talloc   loc0 = ar.pfs, 4, 3, 8, 0\n+\t.save\trp, loc1\n+\tmov \tloc1 = b0\n \t.body\n-\tsub\tsp=sp,bytes\n-\tmov\tloc4=r1\t\t/* Save gp \t*/\n-\tld8\tr8=[callback],8\t/* code address of callback\t*/\n-\t;;\n-\tmov \tout0=sp\n-\tmov\tout1=ecifp\n-\tmov\tout2=bytes\n-\tld8\tr1=[callback]\t/* Set up gp for callback.  Unnecessary? */\n-\tmov\tb6=r8\n-\t;;\n-\tbr.call.sptk.many b0 = b6\t/* call ffi_prep_args\t\t*/\n-\tcmp.eq\tp6,p0=0,r8\t\t/* r8 nonzero ==> need fp regs\t*/\n- \t;;\n-(p6)\tadd\tloc2=32+8*FLOAT_SZ,sp\n-(p6)\tbr.cond.dptk.many\tfp_done\n-\t;;\t/* Quiets warning; needed?\t*/\n-\tadd\tloc2=32,sp\n-\tadd\tloc3=32+FLOAT_SZ,sp\n-\t;;\n-\tldfd\tf8=[loc2],2*FLOAT_SZ\n-\tldfd\tf9=[loc3],2*FLOAT_SZ\n-\t;;\n-\tldfd\tf10=[loc2],2*FLOAT_SZ\n-\tldfd\tf11=[loc3],2*FLOAT_SZ\n-\t;;\n-\tldfd\tf12=[loc2],2*FLOAT_SZ\n-\tldfd\tf13=[loc3],2*FLOAT_SZ\n-\t;;\n-\tldfd\tf14=[loc2],2*FLOAT_SZ\n-\tldfd\tf15=[loc3]\n-\t;;\n-fp_done:\n-\tadd\tr9=16,sp\t/* Pointer to r8_contents\t*/\n-\t/* loc2 points at first integer register value.  */\n-\tadd\tloc3=8,loc2\n-\t;;\n-\tld8\tr8=[r9]\t\t/* Just in case we return large struct */\n-\tld8\tout0=[loc2],16\n-\tld8\tout1=[loc3],16\n-\t;;\n-\tld8\tout2=[loc2],16\n-\tld8\tout3=[loc3],16\n-\t;;\n-\tld8\tout4=[loc2],16\n-\tld8\tout5=[loc3],16\n-\t;;\n-\tld8\tout6=[loc2]\n-\tld8\tout7=[loc3]\n-        /* Set sp to 16 bytes below the first stack parameter.  This    */\n-        /* is the value currently in loc2.                              */\n-\tmov\tsp=loc2\n-\t\n-\tld8 \tr8=[fn],8\n-\t;;\n-\tld8\tr1=[fn]\t\t/* Set up gp */\n-\tmov\tb6=r8;;\n-\tbr.call.sptk.many b0 = b6\t/* call fn\t*/\n-\t\n-\t/* Handle return value. */\n-\tcmp.eq\tp6,p0=0,raddr\n-\tcmp.eq\tp7,p0=FFI_TYPE_INT,flags\n-\tcmp.eq\tp10,p0=FFI_IS_SMALL_STRUCT2,flags\n-\tcmp.eq\tp11,p0=FFI_IS_SMALL_STRUCT3,flags\n-\tcmp.eq\tp12,p0=FFI_IS_SMALL_STRUCT4,flags\n-\t;;\n-(p6) \tbr.cond.dpnt.few done\t\t/* Dont copy ret values if raddr = 0 */\n-(p7)\tbr.cond.dptk.few copy1\n-(p10)\tbr.cond.dpnt.few copy2\n-(p11)\tbr.cond.dpnt.few copy3\n-(p12)\tbr.cond.dpnt.few copy4\n-\tcmp.eq\tp8,p0=FFI_TYPE_FLOAT,flags\n-\tcmp.eq\tp9,p0=FFI_TYPE_DOUBLE,flags\n-\ttbit.nz\tp6,p0=flags,FLOAT_FP_AGGREGATE_BIT\n-\ttbit.nz\tp7,p0=flags,DOUBLE_FP_AGGREGATE_BIT\n-\t;;\n-(p8)\tstfs\t[raddr]=f8\n-(p9)\tstfd\t[raddr]=f8\n+\tadd\tr16 = 16, in0\n+\tmov\tloc2 = gp\n+\tmov\tr8 = in1\n+\t;;\n+\n+\t/* Load up all of the argument registers.  */\n+\tldf.fill f8 = [in0], 32\n+\tldf.fill f9 = [r16], 32\n+\t;;\n+\tldf.fill f10 = [in0], 32\n+\tldf.fill f11 = [r16], 32\n+\t;;\n+\tldf.fill f12 = [in0], 32\n+\tldf.fill f13 = [r16], 32\n+\t;;\n+\tldf.fill f14 = [in0], 32\n+\tldf.fill f15 = [r16], 24\n+\t;;\n+\tld8\tout0 = [in0], 16\n+\tld8\tout1 = [r16], 16\n+\t;;\n+\tld8\tout2 = [in0], 16\n+\tld8\tout3 = [r16], 16\n+\t;;\n+\tld8\tout4 = [in0], 16\n+\tld8\tout5 = [r16], 16\n+\t;;\n+\tld8\tout6 = [in0]\n+\tld8\tout7 = [r16]\n+\t;;\n+\n+\t/* Deallocate the register save area from the stack frame.  */\n+\tmov\tsp = in0\n+\n+\t/* Call the target function.  */\n+\tld8\tr16 = [in2], 8\n+\t;;\n+\tld8\tgp = [in2]\n+\tmov\tb6 = r16\n+\tbr.call.sptk.many b0 = b6\n+\t;;\n+\n+\t/* Dispatch to handle return value.  */\n+\tmov\tgp = loc2\n+\tzxt1\tr16 = in3\n+\t;;\n+\tmov\tar.pfs = loc0\n+\taddl\tr18 = @ltoffx(.Lst_table), gp\n+\t;;\n+\tld8.mov\tr18 = [r18], .Lst_table\n+\tmov\tb0 = loc1\n+\t;;\n+\tshladd\tr18 = r16, 3, r18\n+\t;;\n+\tld8\tr17 = [r18]\n+\tshr\tin3 = in3, 8\n+\t;;\n+\tadd\tr17 = r17, r18\n+\t;;\n+\tmov\tb6 = r17\n+\tbr\tb6\n+\t;;\n+\n+.Lst_void:\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_uint8:\n+\tzxt1\tr8 = r8\n+\t;;\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_sint8:\n+\tsxt1\tr8 = r8\n+\t;;\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_uint16:\n+\tzxt2\tr8 = r8\n+\t;;\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_sint16:\n+\tsxt2\tr8 = r8\n+\t;;\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_uint32:\n+\tzxt4\tr8 = r8\n+\t;;\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_sint32:\n+\tsxt4\tr8 = r8\n+\t;;\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_int64:\n+\tst8\t[in1] = r8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_float:\n+\tstfs\t[in1] = f8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_double:\n+\tstfd\t[in1] = f8\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lst_ldouble:\n+\tstfe\t[in1] = f8\n+\tbr.ret.sptk.many b0\n \t;;\n-\t.label_state 1\n-(p6)\tbr.cond.dpnt.few handle_float_hfa\n-(p7)\tbr.cond.dpnt.few handle_double_hfa\n-\tbr done\n \n-copy4:\n-\tadd\tloc3=24,raddr\n+.Lst_small_struct:\n+\tadd\tsp = -16, sp\n+\tcmp.lt\tp6, p0 = 8, in3\n+\tcmp.lt\tp7, p0 = 16, in3\n+\tcmp.lt\tp8, p0 = 24, in3\n+\t;;\n+\tadd\tr16 = 8, sp\n+\tadd\tr17 = 16, sp\n+\tadd\tr18 = 24, sp\n+\t;;\n+\tst8\t[sp] = r8\n+(p6)\tst8\t[r16] = r9\n+\tmov\tout0 = in1\n+(p7)\tst8\t[r17] = r10\n+(p8)\tst8\t[r18] = r11\n+\tmov\tout1 = sp\n+\tmov\tout2 = in3\n+\tbr.call.sptk.many b0 = memcpy#\n \t;;\n-\tst8\t[loc3]=r11\n-copy3:\n-\tadd\tloc3=16,raddr\n+\tmov\tar.pfs = loc0\n+\tmov\tb0 = loc1\n+\tmov\tgp = loc2\n+\tbr.ret.sptk.many b0\n+\n+.Lst_hfa_float:\n+\tadd\tr16 = 4, in1\n+\tcmp.lt\tp6, p0 = 4, in3\n+\t;;\n+\tstfs\t[in1] = f8, 8\n+(p6)\tstfs\t[r16] = f9, 8\n+\tcmp.lt\tp7, p0 = 8, in3\n+\tcmp.lt\tp8, p0 = 12, in3\n+\t;;\n+(p7)\tstfs\t[in1] = f10, 8\n+(p8)\tstfs\t[r16] = f11, 8\n+\tcmp.lt\tp9, p0 = 16, in3\n+\tcmp.lt\tp10, p0 = 20, in3\n+\t;;\n+(p9)\tstfs\t[in1] = f12, 8\n+(p10)\tstfs\t[r16] = f13, 8\n+\tcmp.lt\tp6, p0 = 24, in3\n+\tcmp.lt\tp7, p0 = 28, in3\n+\t;;\n+(p6)\tstfs\t[in1] = f14\n+(p7)\tstfs\t[r16] = f15\n+\tbr.ret.sptk.many b0\n+\t;;\n+\n+.Lst_hfa_double:\n+\tadd\tr16 = 8, in1\n+\tcmp.lt\tp6, p0 = 8, in3\n+\t;;\n+\tstfd\t[in1] = f8, 16\n+(p6)\tstfd\t[r16] = f9, 16\n+\tcmp.lt\tp7, p0 = 16, in3\n+\tcmp.lt\tp8, p0 = 24, in3\n+\t;;\n+(p7)\tstfd\t[in1] = f10, 16\n+(p8)\tstfd\t[r16] = f11, 16\n+\tcmp.lt\tp9, p0 = 32, in3\n+\tcmp.lt\tp10, p0 = 40, in3\n+\t;;\n+(p9)\tstfd\t[in1] = f12, 16\n+(p10)\tstfd\t[r16] = f13, 16\n+\tcmp.lt\tp6, p0 = 48, in3\n+\tcmp.lt\tp7, p0 = 56, in3\n+\t;;\n+(p6)\tstfd\t[in1] = f14\n+(p7)\tstfd\t[r16] = f15\n+\tbr.ret.sptk.many b0\n+\t;;\n+\n+.Lst_hfa_ldouble:\n+\tadd\tr16 = 16, in1\n+\tcmp.lt\tp6, p0 = 16, in3\n+\t;;\n+\tstfe\t[in1] = f8, 32\n+(p6)\tstfe\t[r16] = f9, 32\n+\tcmp.lt\tp7, p0 = 32, in3\n+\tcmp.lt\tp8, p0 = 48, in3\n+\t;;\n+(p7)\tstfe\t[in1] = f10, 32\n+(p8)\tstfe\t[r16] = f11, 32\n+\tcmp.lt\tp9, p0 = 64, in3\n+\tcmp.lt\tp10, p0 = 80, in3\n+\t;;\n+(p9)\tstfe\t[in1] = f12, 32\n+(p10)\tstfe\t[r16] = f13, 32\n+\tcmp.lt\tp6, p0 = 96, in3\n+\tcmp.lt\tp7, p0 = 112, in3\n+\t;;\n+(p6)\tstfe\t[in1] = f14\n+(p7)\tstfe\t[r16] = f15\n+\tbr.ret.sptk.many b0\n+\t;;\n+\n+        .endp ffi_call_unix\n+\n+        .align 16\n+        .global ffi_closure_unix\n+        .proc ffi_closure_unix\n+\n+#define FRAME_SIZE\t(8*16 + 8*8 + 8*16)\n+\n+ffi_closure_unix:\n+\t.prologue\n+\t.save\tar.pfs, r40 // loc0\n+\talloc   loc0 = ar.pfs, 8, 4, 4, 0\n+\t.fframe\tFRAME_SIZE\n+\tadd\tr12 = -FRAME_SIZE, r12\n+\t.save\trp, loc1\n+\tmov\tloc1 = b0\n+\t.save\tar.unat, loc2\n+\tmov\tloc2 = ar.unat\n+\t.body\n+\n+\t/* Retrieve closure pointer and real gp.  */\n+\tmov\tout0 = gp\n+\tadd\tgp = 16, gp\n \t;;\n-\tst8\t[loc3]=r10\n-copy2:\n-\tadd\tloc3=8,raddr\n+\tld8\tgp = [gp]\n+\n+\t/* Spill all of the possible argument registers.  */\n+\tadd\tr16 = 16 + 8*16, sp\n+\tadd\tr17 = 16 + 8*16 + 16, sp\n+\t;;\n+\tstf.spill [r16] = f8, 32\n+\tstf.spill [r17] = f9, 32\n+\tmov\tloc3 = gp\n+\t;;\n+\tstf.spill [r16] = f10, 32\n+\tstf.spill [r17] = f11, 32\n+\t;;\n+\tstf.spill [r16] = f12, 32\n+\tstf.spill [r17] = f13, 32\n+\t;;\n+\tstf.spill [r16] = f14, 32\n+\tstf.spill [r17] = f15, 24\n+\t;;\n+\t.mem.offset 0, 0\n+\tst8.spill [r16] = in0, 16\n+\t.mem.offset 8, 0\n+\tst8.spill [r17] = in1, 16\n+\tadd\tout1 = 16 + 8*16, sp\n+\t;;\n+\t.mem.offset 0, 0\n+\tst8.spill [r16] = in2, 16\n+\t.mem.offset 8, 0\n+\tst8.spill [r17] = in3, 16\n+\tadd\tout2 = 16, sp\n+\t;;\n+\t.mem.offset 0, 0\n+\tst8.spill [r16] = in4, 16\n+\t.mem.offset 8, 0\n+\tst8.spill [r17] = in5, 16\n+\tmov\tout3 = r8\n+\t;;\n+\t.mem.offset 0, 0\n+\tst8.spill [r16] = in6\n+\t.mem.offset 8, 0\n+\tst8.spill [r17] = in7\n+\n+\t/* Invoke ffi_closure_unix_inner for the hard work.  */\n+\tbr.call.sptk.many b0 = ffi_closure_unix_inner\n \t;;\n-\tst8\t[loc3]=r9\n-copy1:\n-\tst8\t[raddr]=r8\n-\t/* In the big struct case, raddr was passed as an argument.\t*/\n-\t/* In the void case there was nothing to do.\t\t\t*/\n \n-done:\n-\tmov\tr1=loc4\t\t/* Restore gp\t*/\n+\t/* Dispatch to handle return value.  */\n+\tmov\tgp = loc3\n+\tzxt1\tr16 = r8\n+\t;;\n+\taddl\tr18 = @ltoffx(.Lld_table), gp\n \tmov\tar.pfs = loc0\n+\t;;\n+\tld8.mov\tr18 = [r18], .Lld_table\n \tmov\tb0 = loc1\n+\t;;\n+\tshladd\tr18 = r16, 3, r18\n+\tmov\tar.unat = loc2\n+\t;;\n+\tld8\tr17 = [r18]\n+\tshr\tr8 = r8, 8\n+\t;;\n+\tadd\tr17 = r17, r18\n+\tadd\tr16 = 16, sp\n+\t;;\n+\tmov\tb6 = r17\n+\tbr\tb6\n+\t;;\n+\t.label_state 1\n+\n+.Lld_void:\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lld_int8:\n+\t.body\n+\t.copy_state 1\n+\tld1\tr8 = [r16]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lld_int16:\n+\t.body\n+\t.copy_state 1\n+\tld2\tr8 = [r16]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lld_int32:\n+\t.body\n+\t.copy_state 1\n+\tld4\tr8 = [r16]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lld_int64:\n+\t.body\n+\t.copy_state 1\n+\tld8\tr8 = [r16]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lld_float:\n+\t.body\n+\t.copy_state 1\n+\tldfs\tf8 = [r16]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n+.Lld_double:\n+\t.body\n+\t.copy_state 1\n+\tldfd\tf8 = [r16]\n \t.restore sp\n-\tmov\tsp = loc5\n+\tadd\tsp = FRAME_SIZE, sp\n \tbr.ret.sptk.many b0\n+\t;;\n+.Lld_ldouble:\n+\t.body\n+\t.copy_state 1\n+\tldfe\tf8 = [r16]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n \n-handle_double_hfa:\n+.Lld_small_struct:\n \t.body\n \t.copy_state 1\n-\t/* Homogeneous floating point array of doubles is returned in\t*/\n-\t/* registers f8-f15.  Save one at a time to return area.\t*/\n-\tand\tflags=0xf,flags\t/* Retrieve size\t*/\n-\t;;\n-\tcmp.eq\tp6,p0=2,flags\n-\tcmp.eq\tp7,p0=3,flags\n-\tcmp.eq\tp8,p0=4,flags\n-\tcmp.eq\tp9,p0=5,flags\n-\tcmp.eq\tp10,p0=6,flags\n-\tcmp.eq\tp11,p0=7,flags\n-\tcmp.eq\tp12,p0=8,flags\n-\t;;\n-(p6)\tbr.cond.dptk.few\tdhfa2\n-(p7)\tbr.cond.dptk.few\tdhfa3\n-(p8)\tbr.cond.dptk.few\tdhfa4\n-(p9)\tbr.cond.dptk.few\tdhfa5\n-(p10)\tbr.cond.dptk.few\tdhfa6\n-(p11)\tbr.cond.dptk.few\tdhfa7\n-dhfa8:\tadd \tloc3=7*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f15\n-dhfa7:\tadd \tloc3=6*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f14\n-dhfa6:\tadd \tloc3=5*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f13\n-dhfa5:\tadd \tloc3=4*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f12\n-dhfa4:\tadd \tloc3=3*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f11\n-dhfa3:\tadd \tloc3=2*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f10\n-dhfa2:\tadd \tloc3=1*8,raddr\n-\t;;\n-\tstfd\t[loc3]=f9\n-\tstfd\t[raddr]=f8\n-\tbr\tdone\n-\n-handle_float_hfa:\n-\t/* Homogeneous floating point array of floats is returned in\t*/\n-\t/* registers f8-f15.  Save one at a time to return area.\t*/\n-\tand\tflags=0xf,flags\t/* Retrieve size\t*/\n-\t;;\n-\tcmp.eq\tp6,p0=2,flags\n-\tcmp.eq\tp7,p0=3,flags\n-\tcmp.eq\tp8,p0=4,flags\n-\tcmp.eq\tp9,p0=5,flags\n-\tcmp.eq\tp10,p0=6,flags\n-\tcmp.eq\tp11,p0=7,flags\n-\tcmp.eq\tp12,p0=8,flags\n-\t;;\n-(p6)\tbr.cond.dptk.few\tshfa2\n-(p7)\tbr.cond.dptk.few\tshfa3\n-(p8)\tbr.cond.dptk.few\tshfa4\n-(p9)\tbr.cond.dptk.few\tshfa5\n-(p10)\tbr.cond.dptk.few\tshfa6\n-(p11)\tbr.cond.dptk.few\tshfa7\n-shfa8:\tadd \tloc3=7*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f15\n-shfa7:\tadd \tloc3=6*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f14\n-shfa6:\tadd \tloc3=5*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f13\n-shfa5:\tadd \tloc3=4*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f12\n-shfa4:\tadd \tloc3=3*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f11\n-shfa3:\tadd \tloc3=2*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f10\n-shfa2:\tadd \tloc3=1*4,raddr\n-\t;;\n-\tstfd\t[loc3]=f9\n-\tstfd\t[raddr]=f8\n-\tbr\tdone\n+\tadd\tr17 = 8, r16\n+\tcmp.lt\tp6, p0 = 8, r8\n+\tcmp.lt\tp7, p0 = 16, r8\n+\tcmp.lt\tp8, p0 = 24, r8\n+\t;;\n+\tld8\tr8 = [r16], 16\n+(p6)\tld8\tr9 = [r17], 16\n+\t;;\n+(p7)\tld8\tr10 = [r16]\n+(p8)\tld8\tr11 = [r17]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n \n-        .endp ffi_call_unix\n+.Lld_hfa_float:\n+\t.body\n+\t.copy_state 1\n+\tadd\tr17 = 4, r16\n+\tcmp.lt\tp6, p0 = 4, r8\n+\t;;\n+\tldfs\tf8 = [r16], 8\n+(p6)\tldfs\tf9 = [r17], 8\n+\tcmp.lt\tp7, p0 = 8, r8\n+\tcmp.lt\tp8, p0 = 12, r8\n+\t;;\n+(p7)\tldfs\tf10 = [r16], 8\n+(p8)\tldfs\tf11 = [r17], 8\n+\tcmp.lt\tp9, p0 = 16, r8\n+\tcmp.lt\tp10, p0 = 20, r8\n+\t;;\n+(p9)\tldfs\tf12 = [r16], 8\n+(p10)\tldfs\tf13 = [r17], 8\n+\tcmp.lt\tp6, p0 = 24, r8\n+\tcmp.lt\tp7, p0 = 28, r8\n+\t;;\n+(p6)\tldfs\tf14 = [r16]\n+(p7)\tldfs\tf15 = [r17]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n \n+.Lld_hfa_double:\n+\t.body\n+\t.copy_state 1\n+\tadd\tr17 = 8, r16\n+\tcmp.lt\tp6, p0 = 8, r8\n+\t;;\n+\tldfd\tf8 = [r16], 16\n+(p6)\tldfd\tf9 = [r17], 16\n+\tcmp.lt\tp7, p0 = 16, r8\n+\tcmp.lt\tp8, p0 = 24, r8\n+\t;;\n+(p7)\tldfd\tf10 = [r16], 16\n+(p8)\tldfd\tf11 = [r17], 16\n+\tcmp.lt\tp9, p0 = 32, r8\n+\tcmp.lt\tp10, p0 = 40, r8\n+\t;;\n+(p9)\tldfd\tf12 = [r16], 16\n+(p10)\tldfd\tf13 = [r17], 16\n+\tcmp.lt\tp6, p0 = 48, r8\n+\tcmp.lt\tp7, p0 = 56, r8\n+\t;;\n+(p6)\tldfd\tf14 = [r16]\n+(p7)\tldfd\tf15 = [r17]\n+\t.restore sp\n+\tadd\tsp = FRAME_SIZE, sp\n+\tbr.ret.sptk.many b0\n+\t;;\n \n-\t.pred.safe_across_calls p1-p5,p16-p63\n-.text\n-        .align 16\n-        .global ffi_closure_UNIX\n-        .proc ffi_closure_UNIX\n-ffi_closure_UNIX:\n-\t.prologue\n-\t.save \tar.pfs,r40 /* loc0 */\n-\talloc   loc0=ar.pfs,8,3,2,0\n-\t.save\trp,loc1\n-\tmov\tloc1=b0\n-\t.vframe\tloc2\n-\tmov\tloc2=sp\n-\t/* Retrieve closure pointer and real gp.\t*/\n-\tmov\tout0=gp\n-\tadd\tgp=16,gp\n-\t;;\n-\tld8\tgp=[gp]\n-\t/* Reserve a structia64_args on the stack such that arguments\t*/\n-\t/* past the first 8 are automatically placed in the right\t*/\n-\t/* slot.  Note that when we start the sp points at 2 8-byte\t*/\n-\t/* scratch words, followed by the extra arguments.\t\t*/\n-#\tdefine BASIC_ARGS_SZ (8*FLOAT_SZ+8*8+2*8)\n-#\tdefine FIRST_FP_OFFSET (4*8)\n-\tadd\tr14=-(BASIC_ARGS_SZ-FIRST_FP_OFFSET),sp\n-\tadd\tr15=-(BASIC_ARGS_SZ-FIRST_FP_OFFSET-FLOAT_SZ),sp\n-\tadd\tsp=-BASIC_ARGS_SZ,sp\n-\t/* r14 points to fp_regs[0], r15 points to fp_regs[1]\t*/\n-\t;;\n-\tstfd\t[r14]=f8,2*FLOAT_SZ\n-\tstfd\t[r15]=f9,2*FLOAT_SZ\n-\t;;\n-\tstfd\t[r14]=f10,2*FLOAT_SZ\n-\tstfd\t[r15]=f11,2*FLOAT_SZ\n-\t;;\n-\tstfd\t[r14]=f12,2*FLOAT_SZ\n-\tstfd\t[r15]=f13,2*FLOAT_SZ\n-\t;;\n-\tstfd\t[r14]=f14,2*FLOAT_SZ\n-\tstfd\t[r15]=f15,FLOAT_SZ+8\n-\t;;\n-\t/* r14 points to first parameter register area, r15 to second. */\n-\tst8\t[r14]=in0,2*8\n-\tst8\t[r15]=in1,2*8\n-\t;;\n-\tst8\t[r14]=in2,2*8\n-\tst8\t[r15]=in3,2*8\n-\t;;\n-\tst8\t[r14]=in4,2*8\n-\tst8\t[r15]=in5,2*8\n-\t;;\n-\tst8\t[r14]=in6,2*8\n-\tst8\t[r15]=in7,2*8\n-\t/* Call ffi_closure_UNIX_inner */\n-\tmov\tout1=sp\n-\tbr.call.sptk.many b0=ffi_closure_UNIX_inner\n-\t;;\n-\tmov\tb0=loc1\n-\tmov \tar.pfs=loc0\n+.Lld_hfa_ldouble:\n+\t.body\n+\t.copy_state 1\n+\tadd\tr17 = 16, r16\n+\tcmp.lt\tp6, p0 = 16, r8\n+\t;;\n+\tldfe\tf8 = [r16], 32\n+(p6)\tldfe\tf9 = [r17], 32\n+\tcmp.lt\tp7, p0 = 32, r8\n+\tcmp.lt\tp8, p0 = 48, r8\n+\t;;\n+(p7)\tldfe\tf10 = [r16], 32\n+(p8)\tldfe\tf11 = [r17], 32\n+\tcmp.lt\tp9, p0 = 64, r8\n+\tcmp.lt\tp10, p0 = 80, r8\n+\t;;\n+(p9)\tldfe\tf12 = [r16], 32\n+(p10)\tldfe\tf13 = [r17], 32\n+\tcmp.lt\tp6, p0 = 96, r8\n+\tcmp.lt\tp7, p0 = 112, r8\n+\t;;\n+(p6)\tldfe\tf14 = [r16]\n+(p7)\tldfe\tf15 = [r17]\n \t.restore sp\n-\tmov\tsp=loc2\n+\tadd\tsp = FRAME_SIZE, sp\n \tbr.ret.sptk.many b0\n-\t.endp ffi_closure_UNIX\n-\t\n+\t;;\n+\n+\t.endp\tffi_closure_unix\n+\n+\t.section .rodata\n+\t.align\t8\n+.Lst_table:\n+\tdata8\t@pcrel(.Lst_void)\t\t// FFI_TYPE_VOID\n+\tdata8\t@pcrel(.Lst_sint32)\t\t// FFI_TYPE_INT\n+\tdata8\t@pcrel(.Lst_float)\t\t// FFI_TYPE_FLOAT\n+\tdata8\t@pcrel(.Lst_double)\t\t// FFI_TYPE_DOUBLE\n+\tdata8\t@pcrel(.Lst_ldouble)\t\t// FFI_TYPE_LONGDOUBLE\n+\tdata8\t@pcrel(.Lst_uint8)\t\t// FFI_TYPE_UINT8\n+\tdata8\t@pcrel(.Lst_sint8)\t\t// FFI_TYPE_SINT8\n+\tdata8\t@pcrel(.Lst_uint16)\t\t// FFI_TYPE_UINT16\n+\tdata8\t@pcrel(.Lst_sint16)\t\t// FFI_TYPE_SINT16\n+\tdata8\t@pcrel(.Lst_uint32)\t\t// FFI_TYPE_UINT32\n+\tdata8\t@pcrel(.Lst_sint32)\t\t// FFI_TYPE_SINT32\n+\tdata8\t@pcrel(.Lst_int64)\t\t// FFI_TYPE_UINT64\n+\tdata8\t@pcrel(.Lst_int64)\t\t// FFI_TYPE_SINT64\n+\tdata8\t@pcrel(.Lst_void)\t\t// FFI_TYPE_STRUCT\n+\tdata8\t@pcrel(.Lst_int64)\t\t// FFI_TYPE_POINTER\n+\tdata8 \t@pcrel(.Lst_small_struct)\t// FFI_IA64_TYPE_SMALL_STRUCT\n+\tdata8\t@pcrel(.Lst_hfa_float)\t\t// FFI_IA64_TYPE_HFA_FLOAT\n+\tdata8\t@pcrel(.Lst_hfa_double)\t\t// FFI_IA64_TYPE_HFA_DOUBLE\n+\tdata8\t@pcrel(.Lst_hfa_ldouble)\t// FFI_IA64_TYPE_HFA_LDOUBLE\n \n+.Lld_table:\n+\tdata8\t@pcrel(.Lld_void)\t\t// FFI_TYPE_VOID\n+\tdata8\t@pcrel(.Lld_int32)\t\t// FFI_TYPE_INT\n+\tdata8\t@pcrel(.Lld_float)\t\t// FFI_TYPE_FLOAT\n+\tdata8\t@pcrel(.Lld_double)\t\t// FFI_TYPE_DOUBLE\n+\tdata8\t@pcrel(.Lld_ldouble)\t\t// FFI_TYPE_LONGDOUBLE\n+\tdata8\t@pcrel(.Lld_int8)\t\t// FFI_TYPE_UINT8\n+\tdata8\t@pcrel(.Lld_int8)\t\t// FFI_TYPE_SINT8\n+\tdata8\t@pcrel(.Lld_int16)\t\t// FFI_TYPE_UINT16\n+\tdata8\t@pcrel(.Lld_int16)\t\t// FFI_TYPE_SINT16\n+\tdata8\t@pcrel(.Lld_int32)\t\t// FFI_TYPE_UINT32\n+\tdata8\t@pcrel(.Lld_int32)\t\t// FFI_TYPE_SINT32\n+\tdata8\t@pcrel(.Lld_int64)\t\t// FFI_TYPE_UINT64\n+\tdata8\t@pcrel(.Lld_int64)\t\t// FFI_TYPE_SINT64\n+\tdata8\t@pcrel(.Lld_void)\t\t// FFI_TYPE_STRUCT\n+\tdata8\t@pcrel(.Lld_int64)\t\t// FFI_TYPE_POINTER\n+\tdata8 \t@pcrel(.Lld_small_struct)\t// FFI_IA64_TYPE_SMALL_STRUCT\n+\tdata8\t@pcrel(.Lld_hfa_float)\t\t// FFI_IA64_TYPE_HFA_FLOAT\n+\tdata8\t@pcrel(.Lld_hfa_double)\t\t// FFI_IA64_TYPE_HFA_DOUBLE\n+\tdata8\t@pcrel(.Lld_hfa_ldouble)\t// FFI_IA64_TYPE_HFA_LDOUBLE"}, {"sha": "06c9e6939c936da6ff28992df29ece29f7d43b09", "filename": "libffi/src/types.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a69b13339a5a975ab17eef54490148addaf531/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=81a69b13339a5a975ab17eef54490148addaf531", "patch": "@@ -42,23 +42,9 @@ FFI_INTEGRAL_TYPEDEF(uint32, 4, 4, FFI_TYPE_UINT32);\n FFI_INTEGRAL_TYPEDEF(sint32, 4, 4, FFI_TYPE_SINT32);\n FFI_INTEGRAL_TYPEDEF(float, 4, 4, FFI_TYPE_FLOAT);\n \n-#if defined ALPHA || defined SPARC64 || defined X86_64 || defined S390X \\\n-    || defined IA64 || defined POWERPC64\n+FFI_INTEGRAL_TYPEDEF(pointer, sizeof(void*), sizeof(void*), FFI_TYPE_POINTER);\n \n-FFI_INTEGRAL_TYPEDEF(pointer, 8, 8, FFI_TYPE_POINTER);\n-\n-#else\n-\n-FFI_INTEGRAL_TYPEDEF(pointer, 4, 4, FFI_TYPE_POINTER);\n-\n-#endif\n-\n-#if defined X86 || defined ARM || defined M68K\n-\n-FFI_INTEGRAL_TYPEDEF(uint64, 8, 4, FFI_TYPE_UINT64);\n-FFI_INTEGRAL_TYPEDEF(sint64, 8, 4, FFI_TYPE_SINT64);\n-\n-#elif defined SH\n+#if defined X86 || defined ARM || defined M68K || SH\n \n FFI_INTEGRAL_TYPEDEF(uint64, 8, 4, FFI_TYPE_UINT64);\n FFI_INTEGRAL_TYPEDEF(sint64, 8, 4, FFI_TYPE_SINT64);\n@@ -99,7 +85,7 @@ FFI_INTEGRAL_TYPEDEF(longdouble, 16, 16, FFI_TYPE_LONGDOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 16, 8, FFI_TYPE_LONGDOUBLE);\n #endif\n \n-#elif defined X86_64 || defined POWERPC64\n+#elif defined X86_64 || defined POWERPC64 || defined IA64\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 16, 16, FFI_TYPE_LONGDOUBLE);\n@@ -110,4 +96,3 @@ FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 8, 8, FFI_TYPE_LONGDOUBLE);\n \n #endif\n-"}]}