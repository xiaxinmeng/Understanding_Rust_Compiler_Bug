{"sha": "911a71a72912cfa7bc2d762f35e76e2f58e3097c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTExYTcxYTcyOTEyY2ZhN2JjMmQ3NjJmMzVlNzZlMmY1OGUzMDk3Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-07-31T00:24:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-07-31T00:24:44Z"}, "message": "Allow indirect primary bases.\n\n\t* cp-tree.h (struct lang_type): Remove vfield_parent.  Add\n\tprimary_base.\n\t(CLASSTYPE_VFIELD_PARENT): Remove.\n\t(CLASSTYPE_PRIMARY_BINFO): Reimplement.\n\t(BINFO_PRIMARY_BINFO): Remove.\n\t(CLASSTYPE_HAS_PRIMARY_BASE_P): Reimplement.\n\t(BINFO_VBASE_PRIMARY_P): Likewise.\n\t(BINFO_PRIMARY_BASE_OF): New macro.\n\t(BINFO_INDIRECT_PRIMARY_P): Likewise.\n\t(get_primary_binfo): New function.\n\t* decl.c (lang_mark_tree): Make lang_type::primary_base.\n\t* class.c (vcall_offset_data_s): Rename to ...\n\t(vtbl_init_data_s): ... this.  Rename primary_p to primary_vtbl_p,\n\tand add ctor_vtbl_p.\n\t(get_derived_offset): Use get_primary_binfo.\n\t(dfs_mark_primary_bases): Adjust handling of virtual primary\n\tbases.\n\t(mark_primary_bases): Likewise.\n\t(set_primary_base): Take a binfo, not an integer, as a\n\trepresentation of the primary base.\n\t(indirect_primary_base_p): Remove.\n\t(determine_primary_base): Adjust for indirect primary bases.\n\t(dfs_find_final_overrider): Fix typo in coment.\n\t(update_vtable_entry_for_fn): Use get_primary_binfo.\n\t(layout_nonempty_base_or_field): Tweak.\n\t(build_base_fields): Adjust for new primary base semantics.\n\t(dfs_propagate_binfo_offsets): Remove.\n\t(propagate_binfo_offsets): Rewrite.\n\t(dfs_set_offset_for_shared_vbases): Remove.\n\t(layout_virtual_bases): Don't use it.\n\t(layout_class_type): Set CLASSTYPE_SIZE correctly under the new\n\tABI.\n\t(finish_struct_1): Set CLASSTYPE_PRIMARY_BINFO, not\n\tCLASSTYPE_VFIELD_PARENT.\n\t(dfs_get_primary_binfo): New function.\n\t(get_primary_binfo): Likewise.\n\t(dump_class_hierarchy_r): Tweak printing of primary bases.\n\t(build_vtbl_initializer): Fix typo in comments.  Use\n\tvtbl_init_data.\n\t(build_vcall_and_vbase_vtbl_entries): Likewise.\n\t(build_vbaes_offset_vtbl_entries): Likewise.\n\t(dfs_build_vcall_offset_vtbl_entries): Adjust setting of\n\tBV_VCALL_INDEX to handle indirect primary bases.\n\t(build_vcall_offset_vtbl_entries): Use vtbl_init_data.\n\t(build_rtti_vtbl_entries): Likewise.\n\t* search.c (get_shared_vbase_if_not_primary): Tweak.\n\t(find_vbase_instance): Likewise.\n\t(binfo_for_vtable): Simplify.\n\t* tree.c (unshare_base_binfos): Clear BINFO_PRIMARY_BASE_OF.\n\t(make_binfo): Make it have 11 entries.\n\nFrom-SVN: r35360", "tree": {"sha": "f5e6db4529d8998e2fb63301af6575d2207b1b8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5e6db4529d8998e2fb63301af6575d2207b1b8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/911a71a72912cfa7bc2d762f35e76e2f58e3097c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911a71a72912cfa7bc2d762f35e76e2f58e3097c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/911a71a72912cfa7bc2d762f35e76e2f58e3097c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911a71a72912cfa7bc2d762f35e76e2f58e3097c/comments", "author": null, "committer": null, "parents": [{"sha": "abe24fb317afba1def8da53761032da29d9592d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe24fb317afba1def8da53761032da29d9592d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe24fb317afba1def8da53761032da29d9592d4"}], "stats": {"total": 653, "additions": 376, "deletions": 277}, "files": [{"sha": "3a2fdd4c87a7200f2847286fcb14e1bb2dca2590", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=911a71a72912cfa7bc2d762f35e76e2f58e3097c", "patch": "@@ -1,3 +1,57 @@\n+2000-07-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tAllow indirect primary bases.\n+\t* cp-tree.h (struct lang_type): Remove vfield_parent.  Add\n+\tprimary_base.\n+\t(CLASSTYPE_VFIELD_PARENT): Remove.\n+\t(CLASSTYPE_PRIMARY_BINFO): Reimplement.\n+\t(BINFO_PRIMARY_BINFO): Remove.\n+\t(CLASSTYPE_HAS_PRIMARY_BASE_P): Reimplement.\n+\t(BINFO_VBASE_PRIMARY_P): Likewise.\n+\t(BINFO_PRIMARY_BASE_OF): New macro.\n+\t(BINFO_INDIRECT_PRIMARY_P): Likewise.\n+\t(get_primary_binfo): New function.\n+\t* decl.c (lang_mark_tree): Make lang_type::primary_base.\n+\t* class.c (vcall_offset_data_s): Rename to ...\n+\t(vtbl_init_data_s): ... this.  Rename primary_p to primary_vtbl_p,\n+\tand add ctor_vtbl_p.\n+\t(get_derived_offset): Use get_primary_binfo.\n+\t(dfs_mark_primary_bases): Adjust handling of virtual primary\n+\tbases.\n+\t(mark_primary_bases): Likewise.\n+\t(set_primary_base): Take a binfo, not an integer, as a\n+\trepresentation of the primary base.\n+\t(indirect_primary_base_p): Remove.\n+\t(determine_primary_base): Adjust for indirect primary bases.\n+\t(dfs_find_final_overrider): Fix typo in coment.\n+\t(update_vtable_entry_for_fn): Use get_primary_binfo.\n+\t(layout_nonempty_base_or_field): Tweak.\n+\t(build_base_fields): Adjust for new primary base semantics.\n+\t(dfs_propagate_binfo_offsets): Remove.\n+\t(propagate_binfo_offsets): Rewrite.\n+\t(dfs_set_offset_for_shared_vbases): Remove.\n+\t(layout_virtual_bases): Don't use it.\n+\t(layout_class_type): Set CLASSTYPE_SIZE correctly under the new\n+\tABI.\n+\t(finish_struct_1): Set CLASSTYPE_PRIMARY_BINFO, not\n+\tCLASSTYPE_VFIELD_PARENT.\n+\t(dfs_get_primary_binfo): New function.\n+\t(get_primary_binfo): Likewise.\n+\t(dump_class_hierarchy_r): Tweak printing of primary bases.\n+\t(build_vtbl_initializer): Fix typo in comments.  Use\n+\tvtbl_init_data.\n+\t(build_vcall_and_vbase_vtbl_entries): Likewise.\n+\t(build_vbaes_offset_vtbl_entries): Likewise.\n+\t(dfs_build_vcall_offset_vtbl_entries): Adjust setting of\n+\tBV_VCALL_INDEX to handle indirect primary bases.\n+\t(build_vcall_offset_vtbl_entries): Use vtbl_init_data.\n+\t(build_rtti_vtbl_entries): Likewise.\n+\t* search.c (get_shared_vbase_if_not_primary): Tweak.\n+\t(find_vbase_instance): Likewise.\n+\t(binfo_for_vtable): Simplify.\n+\t* tree.c (unshare_base_binfos): Clear BINFO_PRIMARY_BASE_OF.\n+\t(make_binfo): Make it have 11 entries.\n+\t\n 2000-07-30  Alex Samuel  <samuel@codesourcery.com>\n \n \t* mangle.c (DECL_TEMPLATE_ID_P): Remove."}, {"sha": "cf62937a4816fa145bdadb2799474f7670e79057", "filename": "gcc/cp/class.c", "status": "modified", "additions": 292, "deletions": 230, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=911a71a72912cfa7bc2d762f35e76e2f58e3097c", "patch": "@@ -62,8 +62,10 @@ typedef struct class_stack_node {\n   splay_tree names_used;\n }* class_stack_node_t;\n \n-typedef struct vcall_offset_data_s\n+typedef struct vtbl_init_data_s\n {\n+  /* The base for which we're building initializers.  */\n+  tree binfo;\n   /* The binfo for the most-derived type.  */\n   tree derived;\n   /* The negative-index vtable initializers built up so far.  These\n@@ -72,7 +74,7 @@ typedef struct vcall_offset_data_s\n   /* The last (i.e., most negative entry in INITS.  */\n   tree* last_init;\n   /* The binfo for the virtual base for which we're building\n-     initializers.  */\n+     vcall offset initializers.  */\n   tree vbase;\n   /* The functions in vbase for which we have already provided vcall\n      offsets.  */\n@@ -81,8 +83,11 @@ typedef struct vcall_offset_data_s\n   tree index;\n   /* Nonzero if we are building the initializer for the primary\n      vtable.  */\n-  int primary_p;\n-} vcall_offset_data;\n+  int primary_vtbl_p;\n+  /* Nonzero if we are building the initializer for a construction\n+     vtable.  */\n+  int ctor_vtbl_p;\n+} vtbl_init_data;\n \n /* The stack itself.  This is an dynamically resized array.  The\n    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */\n@@ -150,15 +155,13 @@ static tree create_vtable_ptr PARAMS ((tree, int *, int *, tree *, tree *));\n static void layout_class_type PARAMS ((tree, int *, int *, tree *, tree *));\n static void fixup_pending_inline PARAMS ((struct pending_inline *));\n static void fixup_inline_methods PARAMS ((tree));\n-static void set_primary_base PARAMS ((tree, int, int *));\n-static tree dfs_propagate_binfo_offsets PARAMS ((tree, void *));\n+static void set_primary_base PARAMS ((tree, tree, int *));\n static void propagate_binfo_offsets PARAMS ((tree, tree));\n static void layout_virtual_bases PARAMS ((tree, varray_type *));\n-static tree dfs_set_offset_for_shared_vbases PARAMS ((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n-static void build_vbase_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *));\n+static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static tree dfs_build_vcall_offset_vtbl_entries PARAMS ((tree, void *));\n-static void build_vcall_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *));\n+static void build_vcall_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static void layout_vtable_decl PARAMS ((tree, int));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n static tree find_final_overrider PARAMS ((tree, tree, tree));\n@@ -179,9 +182,9 @@ static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n static void layout_empty_base PARAMS ((tree, tree, varray_type));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static void set_vindex PARAMS ((tree, tree, int *));\n-static void build_rtti_vtbl_entries PARAMS ((tree, tree, vcall_offset_data *));\n+static void build_rtti_vtbl_entries PARAMS ((tree, tree, vtbl_init_data *));\n static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n-\t\t\t\t\t\t\tvcall_offset_data *));\n+\t\t\t\t\t\t\tvtbl_init_data *));\n static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n static void mark_primary_bases PARAMS ((tree));\n static void clone_constructors_and_destructors PARAMS ((tree));\n@@ -193,8 +196,8 @@ static void build_vtt PARAMS ((tree));\n static tree *build_vtt_inits PARAMS ((tree, tree, int, tree *, tree *));\n static tree dfs_build_secondary_vptr_vtt_inits PARAMS ((tree, void *));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n-static int indirect_primary_base_p PARAMS ((tree, tree));\n static tree get_matching_base PARAMS ((tree, tree));\n+static tree dfs_get_primary_binfo PARAMS ((tree, void*));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -687,7 +690,7 @@ get_derived_offset (binfo, type)\n   tree offset2;\n \n   while (!same_type_p (BINFO_TYPE (binfo), type))\n-    binfo = BINFO_PRIMARY_BINFO (binfo);\n+    binfo = get_primary_binfo (binfo);\n \n   offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n   return size_binop (MINUS_EXPR, offset1, offset2);\n@@ -1701,19 +1704,14 @@ dfs_mark_primary_bases (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  int i;\n   tree base_binfo;\n \n   if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n     return NULL_TREE;\n \n-  i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-  base_binfo = BINFO_BASETYPE (binfo, i);\n+  base_binfo = get_primary_binfo (binfo);\n \n-  if (!TREE_VIA_VIRTUAL (base_binfo))\n-    /* Non-virtual base classes are easy.  */\n-    BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n-  else\n+  if (TREE_VIA_VIRTUAL (base_binfo))\n     {\n       tree shared_binfo;\n       tree type;\n@@ -1723,20 +1721,22 @@ dfs_mark_primary_bases (binfo, data)\n \n       /* If this virtual base is not already primary somewhere else in\n \t the hiearchy, then we'll be using this copy.  */\n-      if (!BINFO_VBASE_PRIMARY_P (shared_binfo))\n+      if (!BINFO_PRIMARY_MARKED_P (shared_binfo))\n \t{\n \t  /* Make sure the CLASSTYPE_VBASECLASSES list contains the\n \t     primary copy; it's the one that really exists.  */\n \t  if (base_binfo != shared_binfo)\n \t    TREE_VALUE (purpose_member (BINFO_TYPE (base_binfo),\n \t\t\t\t\tCLASSTYPE_VBASECLASSES (type)))\n \t      = base_binfo;\n-\n-\t  BINFO_VBASE_PRIMARY_P (base_binfo) = 1;\n-\t  BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n \t}\n+      else\n+\tbase_binfo = NULL_TREE;\n     }\n \n+  if (base_binfo)\n+    BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n+\n   return NULL_TREE;\n }\n \n@@ -1774,72 +1774,36 @@ mark_primary_bases (type)\n \tcontinue;\n \n       vbase = binfo_for_vbase (BINFO_TYPE (vbases), type);\n-      if (BINFO_VBASE_PRIMARY_P (vbase))\n+      if (BINFO_PRIMARY_MARKED_P (vbase))\n \t/* This virtual base was already included in the hierarchy, so\n \t   there's nothing to do here.  */\n \tcontinue;\n \n-      /* Temporarily pretend that VBASE is primary so that its bases\n-\t will be walked; this is the real copy of VBASE.  */\n-      BINFO_PRIMARY_MARKED_P (vbase) = 1;\n-\n       /* Now, walk its bases.  */\n       dfs_walk_real (vbase, dfs_mark_primary_bases, NULL,\n \t\t     dfs_skip_nonprimary_vbases_unmarkedp, type);\n-\n-      /* VBASE wasn't really primary.  */\n-      BINFO_PRIMARY_MARKED_P (vbase) = 0;\n     }\n }\n \n-/* Make the Ith baseclass of T its primary base.  */\n+/* Make the BINFO the primary base of T.  */\n \n static void\n-set_primary_base (t, i, vfuns_p)\n+set_primary_base (t, binfo, vfuns_p)\n      tree t;\n-     int i;\n+     tree binfo;\n      int *vfuns_p;\n {\n   tree basetype;\n \n-  CLASSTYPE_VFIELD_PARENT (t) = i;\n-  basetype = BINFO_TYPE (CLASSTYPE_PRIMARY_BINFO (t));\n+  CLASSTYPE_PRIMARY_BINFO (t) = binfo;\n+  basetype = BINFO_TYPE (binfo);\n   TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n   TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n   TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n   CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n   *vfuns_p = CLASSTYPE_VSIZE (basetype);\n }\n \n-/* Returns true iff BINFO (a direct virtual base of T) is an indirect\n-   primary base.  */\n-\n-static int\n-indirect_primary_base_p (t, binfo)\n-     tree t;\n-     tree binfo;\n-{\n-  int i;\n-\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n-    {\n-      tree type;\n-      tree b;\n-\n-      /* Figure out to which type the Ith base corresponds.  */\n-      type = TYPE_BINFO_BASETYPE (t, i);\n-      /* See if any of the primary bases have the same type as BINFO.  */\n-      for (b = TYPE_BINFO (type); b; b = TREE_CHAIN (b))\n-\t/* If this base is primary, and has the same type as BINFO,\n-\t   then BINFO is an indirect primary base.  */\n-\tif (BINFO_PRIMARY_MARKED_P (b)\n-\t    && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n-\t  return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Determine the primary class for T.  */\n \n static void\n@@ -1848,16 +1812,18 @@ determine_primary_base (t, vfuns_p)\n      int *vfuns_p;\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  tree vbases;\n+  tree type_binfo;\n \n   /* If there are no baseclasses, there is certainly no primary base.  */\n   if (n_baseclasses == 0)\n     return;\n \n-  *vfuns_p = 0;\n+  type_binfo = TYPE_BINFO (t);\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n+      tree base_binfo = BINFO_BASETYPE (type_binfo, i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n       if (TYPE_CONTAINS_VPTR_P (basetype))\n@@ -1876,7 +1842,7 @@ determine_primary_base (t, vfuns_p)\n \n \t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t    {\n-\t      set_primary_base (t, i, vfuns_p);\n+\t      set_primary_base (t, base_binfo, vfuns_p);\n \t      CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n \t    }\n \t  else\n@@ -1895,60 +1861,93 @@ determine_primary_base (t, vfuns_p)\n \t\t\t\t CLASSTYPE_VFIELDS (t));\n \n \t      if (!flag_new_abi && *vfuns_p == 0)\n-\t\tset_primary_base (t, i, vfuns_p);\n+\t\tset_primary_base (t, base_binfo, vfuns_p);\n \t    }\n \t}\n     }\n \n   if (!TYPE_VFIELD (t))\n-    CLASSTYPE_VFIELD_PARENT (t) = -1;\n+    CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n+\n+  /* Mark the indirect primary bases.  */\n+  for (vbases = CLASSTYPE_VBASECLASSES (t);\n+       vbases;\n+       vbases = TREE_CHAIN (vbases)) \n+    {\n+      tree binfo = TREE_VALUE (vbases);\n+\n+      /* See if this virtual base is an indirect primary base.  If so,\n+\t it must be either a primary base or an indirect primary base\n+\t in one of the direct bases.  */\n+      for (i = 0; i < n_baseclasses; ++i) \n+\t{\n+\t  tree basetype;\n+\t  tree v;\n+\n+\t  basetype = TYPE_BINFO_BASETYPE (t, i);\n+\t  for (v = CLASSTYPE_VBASECLASSES (basetype); \n+\t       v; \n+\t       v = TREE_CHAIN (v))\n+\t    {\n+\t      tree b = TREE_VALUE (v);\n+\t      if ((BINFO_PRIMARY_MARKED_P (b)\n+\t\t   || BINFO_INDIRECT_PRIMARY_P (b))\n+\t\t  && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n+\t\t{\n+\t\t  BINFO_INDIRECT_PRIMARY_P (binfo) = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* If we've discovered that this virtual base is an indirect\n+\t     primary base, then we can move on to the next virtual\n+\t     base.  */\n+\t  if (BINFO_INDIRECT_PRIMARY_P (binfo))\n+\t    break;\n+\t}\n+    }\n \n   /* The new ABI allows for the use of a \"nearly-empty\" virtual base\n      class as the primary base class if no non-virtual polymorphic\n      base can be found.  */\n   if (flag_new_abi && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n-      /* If not -1, this is the index in TYPE_BINFO_BASETYPEs of the\n-\t best primary base candidate we have found so far.  */\n-      int candidate = -1;\n+      /* If not NULL, this is the best primary base candidate we have\n+         found so far.  */\n+      tree candidate = NULL_TREE;\n+      tree base_binfo;\n \n       /* Loop over the baseclasses.  */\n-      for (i = 0; i < n_baseclasses; ++i)\n+      for (base_binfo = TYPE_BINFO (t);\n+\t   base_binfo;\n+\t   base_binfo = TREE_CHAIN (base_binfo))\n \t{\n-\t  tree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n \t  tree basetype = BINFO_TYPE (base_binfo);\n \n \t  if (TREE_VIA_VIRTUAL (base_binfo) \n \t      && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n \t    {\n-\t      int indirect_primary_p;\n-\n-\t      /* Figure out whether or not this base is an indirect\n-\t\t primary base.  */\n-\t      indirect_primary_p = indirect_primary_base_p (t, base_binfo);\n-\n \t      /* If this is not an indirect primary base, then it's\n \t\t definitely our primary base.  */\n-\t      if (!indirect_primary_p) \n+\t      if (!BINFO_INDIRECT_PRIMARY_P (base_binfo))\n \t\t{\n-\t\t  candidate = i;\n+\t\t  candidate = base_binfo;\n \t\t  break;\n \t\t}\n \t      /* If this was an indirect primary base, it's still our\n \t\t primary base -- unless there's another nearly-empty\n \t\t virtual base that isn't an indirect primary base.  */\n-\t      else if (candidate == -1)\n-\t\tcandidate = i;\n+\t      else if (!candidate)\n+\t\tcandidate = base_binfo;\n \t    }\n \t}\n \n       /* If we've got a primary base, use it.  */\n-      if (candidate != -1) \n+      if (candidate)\n \t{\n \t  set_primary_base (t, candidate, vfuns_p);\n \t  CLASSTYPE_VFIELDS (t) \n-\t    = copy_list (CLASSTYPE_VFIELDS (TYPE_BINFO_BASETYPE (t, \n-\t\t\t\t\t\t\t\t candidate)));\n+\t    = copy_list (CLASSTYPE_VFIELDS (BINFO_TYPE (candidate)));\n \t}\t\n     }\n \n@@ -2475,9 +2474,10 @@ dfs_find_final_overrider (binfo, data)\n \t{\n \t  tree base;\n \n-\t  /* Assume the path is non-virtual.  See if there are any base from\n-\t     (but not including) the overrider up to and including the\n-\t     base where the function is defined. */\n+\t  /* Assume the path is non-virtual.  See if there are any\n+\t     virtual bases from (but not including) the overrider up\n+\t     to and including the base where the function is\n+\t     defined. */\n \t  for (base = TREE_CHAIN (path); base; base = TREE_CHAIN (base))\n \t    if (TREE_VIA_VIRTUAL (TREE_VALUE (base)))\n \t      {\n@@ -2612,7 +2612,7 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n       tree primary_base;\n       tree f;\n \n-      primary_base = BINFO_PRIMARY_BINFO (b);\n+      primary_base = get_primary_binfo (b);\n       if (!primary_base)\n \tbreak;\n \n@@ -3792,7 +3792,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n       /* Now that we know where it wil be placed, update its\n \t BINFO_OFFSET.  */\n       offset = byte_position (decl);\n-      if (binfo)\n+      if (binfo && CLASS_TYPE_P (BINFO_TYPE (binfo)))\n \tpropagate_binfo_offsets (binfo, \n \t\t\t\t convert (ssizetype, offset));\n  \n@@ -3978,13 +3978,13 @@ build_base_fields (rli, empty_p)\n     {\n       tree base_binfo;\n \n+      base_binfo = BINFO_BASETYPE (TYPE_BINFO (rec), i);\n+\n       /* Under the new ABI, the primary base was already allocated\n \t above, so we don't need to allocate it again here.  */\n-      if (flag_new_abi && i == CLASSTYPE_VFIELD_PARENT (rec))\n+      if (flag_new_abi && base_binfo == CLASSTYPE_PRIMARY_BINFO (rec))\n \tcontinue;\n \n-      base_binfo = BINFO_BASETYPE (TYPE_BINFO (rec), i);\n-\n       /* A primary virtual base class is allocated just like any other\n \t base class, but a non-primary virtual base is allocated\n \t later, in layout_virtual_bases.  */\n@@ -4486,66 +4486,60 @@ fixup_inline_methods (type)\n   CLASSTYPE_INLINE_FRIENDS (type) = NULL_TREE;\n }\n \n-/* Called from propagate_binfo_offsets via dfs_walk.  */\n-\n-static tree\n-dfs_propagate_binfo_offsets (binfo, data)\n-     tree binfo; \n-     void *data;\n-{\n-  tree offset = (tree) data;\n-\n-  /* Update the BINFO_OFFSET for this base.  Allow for the case where it\n-     might be negative.  */\n-  BINFO_OFFSET (binfo)\n-    = convert (sizetype, size_binop (PLUS_EXPR,\n-\t\t\t\t     convert (ssizetype, BINFO_OFFSET (binfo)),\n-\t\t\t\t\t      offset));\n-  SET_BINFO_MARKED (binfo);\n-\n-  return NULL_TREE;\n-}\n-\n /* Add OFFSET to all base types of BINFO which is a base in the\n    hierarchy dominated by T.\n \n-   OFFSET, which is a type offset, is number of bytes.\n-\n-   Note that we don't have to worry about having two paths to the\n-   same base type, since this type owns its association list.  */\n+   OFFSET, which is a type offset, is number of bytes.  */\n \n static void\n propagate_binfo_offsets (binfo, offset)\n      tree binfo;\n      tree offset;\n {\n-  dfs_walk (binfo, \n-\t    dfs_propagate_binfo_offsets, \n-\t    dfs_skip_nonprimary_vbases_unmarkedp,\n-\t    offset);\n-  dfs_walk (binfo,\n-\t    dfs_unmark,\n-\t    dfs_skip_nonprimary_vbases_markedp,\n-\t    NULL);\n-}\n+  int i;\n+  tree primary_binfo;\n \n-/* Called via dfs_walk from layout_virtual bases.  */\n+  /* Update BINFO's offset.  */\n+  BINFO_OFFSET (binfo)\n+    = convert (sizetype, \n+\t       size_binop (PLUS_EXPR,\n+\t\t\t   convert (ssizetype, BINFO_OFFSET (binfo)),\n+\t\t\t   offset));\n \n-static tree\n-dfs_set_offset_for_shared_vbases (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  if (TREE_VIA_VIRTUAL (binfo) && BINFO_PRIMARY_MARKED_P (binfo))\n+  /* Find the primary base class.  */\n+  primary_binfo = get_primary_binfo (binfo);\n+\n+  /* Scan all of the bases, pushing the BINFO_OFFSET adjust\n+     downwards.  */\n+  for (i = -1; i < BINFO_N_BASETYPES (binfo); ++i)\n     {\n-      /* Update the shared copy.  */\n-      tree shared_binfo;\n+      tree base_binfo;\n \n-      shared_binfo = binfo_for_vbase (BINFO_TYPE (binfo), (tree) data);\n-      BINFO_OFFSET (shared_binfo) = BINFO_OFFSET (binfo);\n-    }\n+      /* On the first through the loop, do the primary base.  Because\n+\t the primary base need not be an immediate base, we must\n+\t handle the primary base specially.  */\n+      if (i == -1) \n+\t{\n+\t  if (!primary_binfo) \n+\t    continue;\n \n-  return NULL_TREE;\n+\t  base_binfo = primary_binfo;\n+\t}\n+      else\n+\t{\n+\t  base_binfo = BINFO_BASETYPE (binfo, i);\n+\t  /* Don't do the primary base twice.  */\n+\t  if (base_binfo == primary_binfo)\n+\t    continue;\n+\t}\n+\n+      /* Skip virtual bases that aren't our primary base.  */\n+      if (TREE_VIA_VIRTUAL (base_binfo)\n+\t  && BINFO_PRIMARY_BASE_OF (base_binfo) != binfo)\n+\tcontinue;\n+\n+      propagate_binfo_offsets (base_binfo, offset);\n+    }\n }\n \n /* Called via dfs_walk from layout_virtual bases.  */\n@@ -4622,7 +4616,7 @@ layout_virtual_bases (t, base_offsets)\n       else\n \tvbase = TREE_VALUE (vbases);\n \n-      if (!BINFO_VBASE_PRIMARY_P (vbase))\n+      if (!BINFO_PRIMARY_MARKED_P (vbase))\n \t{\n \t  /* This virtual base is not a primary base of any class in the\n \t     hierarchy, so we have to add space for it.  */\n@@ -4673,16 +4667,7 @@ layout_virtual_bases (t, base_offsets)\n \t}\n     }\n \n-  /* Make sure that all of the CLASSTYPE_VBASECLASSES have their\n-     BINFO_OFFSET set correctly.  Those we just allocated certainly\n-     will.  The others are primary baseclasses; we walk the hierarchy\n-     to find the primary copies and update the shared copy.  */\n-  dfs_walk (TYPE_BINFO (t), \n-\t    dfs_set_offset_for_shared_vbases, \n-\t    dfs_unmarked_real_bases_queue_p,\n-\t    t);\n-\n-  /* Now, go through the TYPE_BINFO hierarchy again, setting the\n+  /* Now, go through the TYPE_BINFO hierarchy, setting the\n      BINFO_OFFSETs correctly for all non-primary copies of the virtual\n      bases and their direct and indirect bases.  The ambiguity checks\n      in get_base_distance depend on the BINFO_OFFSETs being set\n@@ -4942,8 +4927,7 @@ layout_class_type (t, empty_p, vfuns_p,\n       CLASSTYPE_SIZE (t) = bitsize_zero_node;\n       CLASSTYPE_SIZE_UNIT (t) = size_zero_node;\n     }\n-  else if (flag_new_abi && TYPE_HAS_COMPLEX_INIT_REF (t)\n-\t   && TYPE_HAS_COMPLEX_ASSIGN_REF (t))\n+  else if (flag_new_abi)\n     {\n       CLASSTYPE_SIZE (t) = TYPE_BINFO_SIZE (t);\n       CLASSTYPE_SIZE_UNIT (t) = TYPE_BINFO_SIZE_UNIT (t);\n@@ -5034,7 +5018,7 @@ finish_struct_1 (t)\n      make sure we lay it out again.  */\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n-  CLASSTYPE_VFIELD_PARENT (t) = -1;\n+  CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n   vfuns = 0;\n   CLASSTYPE_RTTI (t) = NULL_TREE;\n \n@@ -6472,6 +6456,69 @@ get_vtbl_decl_for_binfo (binfo)\n   return decl;\n }\n \n+/* Called from get_primary_binfo via dfs_walk.  */\n+\n+static tree\n+dfs_get_primary_binfo (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree primary_base = (tree) data;\n+\n+  if (TREE_VIA_VIRTUAL (binfo) \n+      && same_type_p (TREE_TYPE (binfo), TREE_TYPE (primary_base)))\n+    return binfo;\n+  \n+  return NULL_TREE;\n+}\n+\n+/* Returns the binfo for the primary base of BINFO.  Note that in a\n+   complex hierarchy the resulting BINFO may not actually *be*\n+   primary.  In particular if the resulting BINFO is a virtual base,\n+   and it occurs elsewhere in the hierarchy, then this occurrence may\n+   not actually be a primary base in the complete object.  Check\n+   BINFO_PRIMARY_MARKED_P to be sure.  */\n+\n+tree\n+get_primary_binfo (binfo)\n+     tree binfo;\n+{\n+  tree primary_base;\n+  tree result;\n+\n+  primary_base = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (binfo));\n+  if (!primary_base)\n+    return NULL_TREE;\n+\n+  /* A non-virtual primary base is always a direct base, and easy to\n+     find.  */\n+  if (!TREE_VIA_VIRTUAL (primary_base))\n+    {\n+      int i;\n+\n+      /* Scan the direct basetypes until we find a base with the same\n+\t type as the primary base.  */\n+      for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+\t{\n+\t  tree base_binfo = BINFO_BASETYPE (binfo, i);\n+\t  \n+\t  if (same_type_p (BINFO_TYPE (base_binfo),\n+\t\t\t   BINFO_TYPE (primary_base)))\n+\t    return base_binfo;\n+\t}\n+\n+      /* We should always find the primary base.  */\n+      my_friendly_abort (20000729);\n+    }\n+\n+  /* For a primary virtual base, we have to scan the entire hierarchy\n+     rooted at BINFO; the virtual base could be an indirect virtual\n+     base.  */\n+  result = dfs_walk (binfo, dfs_get_primary_binfo, NULL, primary_base);\n+  my_friendly_assert (result != NULL_TREE, 20000730);\n+  return result;\n+}\n+\n /* Dump the offsets of all the bases rooted at BINFO (in the hierarchy\n    dominated by T) to stderr.  INDENT should be zero when called from\n    the top level; it is incremented recursively.  */\n@@ -6493,8 +6540,8 @@ dump_class_hierarchy_r (t, binfo, indent)\n     fprintf (stderr, \" virtual\");\n   if (BINFO_PRIMARY_MARKED_P (binfo)\n       || (TREE_VIA_VIRTUAL (binfo) \n-\t  && BINFO_VBASE_PRIMARY_P (binfo_for_vbase (BINFO_TYPE (binfo), \n-\t\t\t\t\t\t     t))))\n+\t  && BINFO_PRIMARY_MARKED_P (binfo_for_vbase (BINFO_TYPE (binfo), \n+\t\t\t\t\t\t      t))))\n     fprintf (stderr, \" primary\");\n   fprintf (stderr, \"\\n\");\n \n@@ -7021,15 +7068,22 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n    is part of the hierarchy dominated by T.  If we're building a\n    construction vtable, the ORIG_BINFO is the binfo we should use to\n    find the actual function pointers to put in the vtable.  Otherwise,\n-   ORIG_BINFO should be the same as BINFO.  The RTTI_DOMINATOR is the\n+   ORIG_BINFO should be the same as BINFO.  The RTTI_BINFO is the\n    BINFO that should be indicated by the RTTI information in the\n    vtable; it will be a base class of T, rather than T itself, if we\n    are building a construction vtable.\n \n    The value returned is a TREE_LIST suitable for wrapping in a\n    CONSTRUCTOR to use as the DECL_INITIAL for a vtable.  If\n    NON_FN_ENTRIES_P is not NULL, *NON_FN_ENTRIES_P is set to the\n-   number of non-function entries in the vtable.  */\n+   number of non-function entries in the vtable.  \n+\n+   It might seem that this function should never be called with a\n+   BINFO for which BINFO_PRIMARY_MARKED_P holds, the vtable for such a\n+   base is always subsumed by a derived class vtable.  However, when\n+   we are building construction vtables we do build vtables for\n+   primary bases; we need these while the primary base is being\n+   constructed.  */\n \n static tree\n build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n@@ -7040,23 +7094,25 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n      int *non_fn_entries_p;\n {\n   tree v;\n-   tree vfun_inits;\n+  tree vfun_inits;\n   tree vbase;\n-  vcall_offset_data vod;\n-\n-  /* Initialize those parts of VOD that matter.  */\n-  vod.derived = t;\n-  vod.inits = NULL_TREE;\n-  vod.last_init = &vod.inits;\n-  vod.primary_p = (binfo == TYPE_BINFO (t));\n+  vtbl_init_data vid;\n+\n+  /* Initialize VID.  */\n+  vid.binfo = binfo;\n+  vid.derived = t;\n+  vid.inits = NULL_TREE;\n+  vid.last_init = &vid.inits;\n+  vid.primary_vtbl_p = (binfo == TYPE_BINFO (t));\n+  vid.ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n-  vod.index = ssize_int (-3);\n+  vid.index = ssize_int (-3);\n \n   /* Add entries to the vtable for RTTI.  */\n-  build_rtti_vtbl_entries (binfo, rtti_binfo, &vod);\n+  build_rtti_vtbl_entries (binfo, rtti_binfo, &vid);\n \n   /* Add the vcall and vbase offset entries.  */\n-  build_vcall_and_vbase_vtbl_entries (binfo, &vod);\n+  build_vcall_and_vbase_vtbl_entries (binfo, &vid);\n    /* Clear BINFO_VTABLE_PAATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n   for (vbase = CLASSTYPE_VBASECLASSES (t); \n@@ -7065,7 +7121,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n     CLEAR_BINFO_VTABLE_PATH_MARKED (TREE_VALUE (vbase));\n \n   if (non_fn_entries_p)\n-    *non_fn_entries_p = list_length (vod.inits);\n+    *non_fn_entries_p = list_length (vid.inits);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n@@ -7116,32 +7172,32 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   vfun_inits = nreverse (vfun_inits);\n   \n   /* The negative offset initializers are also in reverse order.  */\n-  vod.inits = nreverse (vod.inits);\n+  vid.inits = nreverse (vid.inits);\n \n   /* Chain the two together.  */\n-  return chainon (vod.inits, vfun_inits);\n+  return chainon (vid.inits, vfun_inits);\n }\n \n-/* Sets vod->inits to be the initializers for the vbase and vcall\n+/* Sets vid->inits to be the initializers for the vbase and vcall\n    offsets in BINFO, which is in the hierarchy dominated by T.  */\n \n static void\n-build_vcall_and_vbase_vtbl_entries (binfo, vod)\n+build_vcall_and_vbase_vtbl_entries (binfo, vid)\n      tree binfo;\n-     vcall_offset_data *vod;\n+     vtbl_init_data *vid;\n {\n   tree b;\n \n   /* If this is a derived class, we must first create entries\n      corresponding to the primary base class.  */\n-  b = BINFO_PRIMARY_BINFO (binfo);\n+  b = get_primary_binfo (binfo);\n   if (b)\n-    build_vcall_and_vbase_vtbl_entries (b, vod);\n+    build_vcall_and_vbase_vtbl_entries (b, vid);\n \n   /* Add the vbase entries for this base.  */\n-  build_vbase_offset_vtbl_entries (binfo, vod);\n+  build_vbase_offset_vtbl_entries (binfo, vid);\n   /* Add the vcall entries for this base.  */\n-  build_vcall_offset_vtbl_entries (binfo, vod);\n+  build_vcall_offset_vtbl_entries (binfo, vid);\n }\n \n /* Returns the initializers for the vbase offset entries in the vtable\n@@ -7150,9 +7206,9 @@ build_vcall_and_vbase_vtbl_entries (binfo, vod)\n    where the next vbase offset will go.  */\n \n static void\n-build_vbase_offset_vtbl_entries (binfo, vod)\n+build_vbase_offset_vtbl_entries (binfo, vid)\n      tree binfo;\n-     vcall_offset_data *vod;\n+     vtbl_init_data *vid;\n {\n   tree vbase;\n   tree t;\n@@ -7167,7 +7223,7 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n   if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n     return;\n \n-  t = vod->derived;\n+  t = vid->derived;\n \n   /* Go through the virtual bases, adding the offsets.  */\n   for (vbase = TYPE_BINFO (BINFO_TYPE (binfo));\n@@ -7192,10 +7248,10 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \n       /* Figure out where we can find this vbase offset.  */\n       delta = size_binop (MULT_EXPR, \n-\t\t\t  vod->index,\n+\t\t\t  vid->index,\n \t\t\t  convert (ssizetype,\n \t\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n-      if (vod->primary_p)\n+      if (vid->primary_vtbl_p)\n \tBINFO_VPTR_FIELD (b) = delta;\n \n       if (binfo != TYPE_BINFO (t))\n@@ -7213,19 +7269,19 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \t}\n \n       /* The next vbase will come at a more negative offset.  */\n-      vod->index = size_binop (MINUS_EXPR, vod->index, ssize_int (1));\n+      vid->index = size_binop (MINUS_EXPR, vid->index, ssize_int (1));\n \n       /* The initializer is the delta from BINFO to this virtual base.\n \t The vbase offsets go in reverse inheritance-graph order, and\n \t we are walking in inheritance graph order so these end up in\n \t the right order.  */\n       delta = size_diffop (BINFO_OFFSET (b), BINFO_OFFSET (binfo));\n-      *vod->last_init \n+      *vid->last_init \n \t= build_tree_list (NULL_TREE,\n \t\t\t   fold (build1 (NOP_EXPR, \n \t\t\t\t\t vtable_entry_type,\n \t\t\t\t\t delta)));\n-      vod->last_init = &TREE_CHAIN (*vod->last_init);\n+      vid->last_init = &TREE_CHAIN (*vid->last_init);\n     }\n }\n \n@@ -7236,7 +7292,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  vcall_offset_data* vod;\n+  vtbl_init_data* vid;\n   tree derived_virtuals;\n   tree base_virtuals;\n   tree binfo_inits;\n@@ -7247,7 +7303,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n   tree primary_binfo;\n   int i;\n \n-  vod = (vcall_offset_data *) data;\n+  vid = (vtbl_init_data *) data;\n   binfo_inits = NULL_TREE;\n \n   /* We might be a primary base class.  Go up the inheritance\n@@ -7256,8 +7312,21 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n   non_primary_binfo = binfo;\n   while (BINFO_INHERITANCE_CHAIN (non_primary_binfo))\n     {\n-      tree b = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n-      if (BINFO_PRIMARY_BINFO (b) != non_primary_binfo)\n+      tree b;\n+\n+      /* If we have reached a virtual base, then it must be the\n+\t virtual base for which we are building vcall offsets.  In\n+\t turn, the virtual base must be a (possibly indirect) primary\n+\t base of the class that we are initializing, or we wouldn't\n+\t care about its vtable offsets.  */\n+      if (TREE_VIA_VIRTUAL (non_primary_binfo))\n+\t{\n+\t  non_primary_binfo = vid->binfo;\n+\t  break;\n+\t}\n+\n+      b = BINFO_INHERITANCE_CHAIN (non_primary_binfo);\n+      if (get_primary_binfo (b) != non_primary_binfo)\n \tbreak;\n       non_primary_binfo = b;\n     }\n@@ -7266,7 +7335,7 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n      class.  */\n   base_virtuals = BINFO_VIRTUALS (binfo);\n   derived_virtuals = BINFO_VIRTUALS (non_primary_binfo);\n-  primary_binfo = BINFO_PRIMARY_BINFO (binfo);\n+  primary_binfo = get_primary_binfo (binfo);\n   if (primary_binfo)\n     for (i = 0; i < CLASSTYPE_VSIZE (BINFO_TYPE (primary_binfo)); ++i)\n       {\n@@ -7289,67 +7358,60 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \t signature as FN, then we do not need a second vcall offset.\n \t Check the list of functions already present in the derived\n \t class vtable.  */\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (vod->fns); ++i) \n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (vid->fns); ++i) \n \t{\n \t  tree derived_entry;\n \n-\t  derived_entry = VARRAY_TREE (vod->fns, i);\n+\t  derived_entry = VARRAY_TREE (vid->fns, i);\n \t  if (same_signature_p (BV_FN (derived_entry), fn))\n \t    {\n \t      BV_VCALL_INDEX (derived_virtuals) \n \t\t= BV_VCALL_INDEX (derived_entry);\n \t      break;\n \t    }\n \t}\n-      if (i != VARRAY_ACTIVE_SIZE (vod->fns))\n+      if (i != VARRAY_ACTIVE_SIZE (vid->fns))\n \tcontinue;\n \n       /* The FN comes from BASE.  So, we must caculate the adjustment\n \t from the virtual base that derived from BINFO to BASE.  */\n       base = DECL_CONTEXT (fn);\n-      base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n+      base_binfo = get_binfo (base, vid->derived, /*protect=*/0);\n \n       /* Compute the vcall offset.  */\n-      *vod->last_init \n+      *vid->last_init \n \t= (build_tree_list \n \t   (NULL_TREE,\n \t    fold (build1 (NOP_EXPR, vtable_entry_type,\n \t\t\t  size_diffop (BINFO_OFFSET (base_binfo),\n-\t\t\t\t       BINFO_OFFSET (vod->vbase))))));\n-      vod->last_init = &TREE_CHAIN (*vod->last_init);\n-\n-      /* If there is already a vcall index, then we are processing a\n-\t construction vtable.  The index should be the same as it was\n-\t when we processed the vtable for the base class.  */\n-      if (BV_VCALL_INDEX (derived_virtuals))\n-\tmy_friendly_assert (tree_int_cst_equal (BV_VCALL_INDEX\n-\t\t\t\t\t\t(derived_virtuals),\n-\t\t\t\t\t\tvod->index),\n-\t\t\t    20000516);\n+\t\t\t\t       BINFO_OFFSET (vid->vbase))))));\n+      vid->last_init = &TREE_CHAIN (*vid->last_init);\n+\n       /* Keep track of the vtable index where this vcall offset can be\n-\t found.  */\n-      else\n-\tBV_VCALL_INDEX (derived_virtuals) = vod->index;\n+\t found.  For a construction vtable, we already made this\n+\t annotation when we build the original vtable.  */\n+      if (!vid->ctor_vtbl_p)\n+\tBV_VCALL_INDEX (derived_virtuals) = vid->index;\n \n       /* The next vcall offset will be found at a more negative\n \t offset.  */\n-      vod->index = size_binop (MINUS_EXPR, vod->index, ssize_int (1));\n+      vid->index = size_binop (MINUS_EXPR, vid->index, ssize_int (1));\n \n       /* Keep track of this function.  */\n-      VARRAY_PUSH_TREE (vod->fns, derived_virtuals);\n+      VARRAY_PUSH_TREE (vid->fns, derived_virtuals);\n     }\n \n   return NULL_TREE;\n }\n \n /* Adds the initializers for the vcall offset entries in the vtable\n    for BINFO (which is part of the class hierarchy dominated by T) to\n-   VOD->INITS.  */\n+   VID->INITS.  */\n \n static void\n-build_vcall_offset_vtbl_entries (binfo, vod)\n+build_vcall_offset_vtbl_entries (binfo, vid)\n      tree binfo;\n-     vcall_offset_data *vod;\n+     vtbl_init_data *vid;\n {\n   /* Under the old ABI, the adjustments to the `this' pointer were made\n      elsewhere.  */\n@@ -7382,25 +7444,25 @@ build_vcall_offset_vtbl_entries (binfo, vod)\n      in our non-virtual bases vtables.  For each base, the entries\n      appear in the same order as in the base; but the bases themselves\n      appear in reverse depth-first, left-to-right order.  */\n-  vod->vbase = binfo;\n-  VARRAY_TREE_INIT (vod->fns, 32, \"fns\");\n+  vid->vbase = binfo;\n+  VARRAY_TREE_INIT (vid->fns, 32, \"fns\");\n   dfs_walk_real (binfo,\n \t\t dfs_build_vcall_offset_vtbl_entries,\n \t\t NULL,\n \t\t dfs_skip_vbases,\n-\t\t vod);\n-  VARRAY_FREE (vod->fns);\n+\t\t vid);\n+  VARRAY_FREE (vid->fns);\n }\n \n /* Return vtbl initializers for the RTTI entries coresponding to the\n    BINFO's vtable.  The RTTI entries should indicate the object given\n    by RTTI_BINFO.  */\n \n static void\n-build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n+build_rtti_vtbl_entries (binfo, rtti_binfo, vid)\n      tree binfo;\n      tree rtti_binfo;\n-     vcall_offset_data *vod;\n+     vtbl_init_data *vid;\n {\n   tree b;\n   tree t;\n@@ -7423,7 +7485,7 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n     {\n       tree primary_base;\n \n-      primary_base = BINFO_PRIMARY_BINFO (b);\n+      primary_base = get_primary_binfo (b);\n       if (!BINFO_PRIMARY_MARKED_P (primary_base))\n \tbreak;\n       b = primary_base;\n@@ -7459,8 +7521,8 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n       init = build_vtable_entry (offset, NULL_TREE, init, \n \t\t\t\t /*generate_with_vtable_p=*/0);\n     }\n-  *vod->last_init = build_tree_list (NULL_TREE, init);\n-  vod->last_init = &TREE_CHAIN (*vod->last_init);\n+  *vid->last_init = build_tree_list (NULL_TREE, init);\n+  vid->last_init = &TREE_CHAIN (*vid->last_init);\n \n   /* Add the offset-to-top entry.  It comes earlier in the vtable that\n      the the typeinfo entry.  */\n@@ -7470,8 +7532,8 @@ build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n \t we can put it in the vtable.  */\n       init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n       TREE_CONSTANT (init) = 1;\n-      *vod->last_init = build_tree_list (NULL_TREE, init);\n-      vod->last_init = &TREE_CHAIN (*vod->last_init);\n+      *vid->last_init = build_tree_list (NULL_TREE, init);\n+      vid->last_init = &TREE_CHAIN (*vid->last_init);\n     }\n }\n "}, {"sha": "63c1e8ef24848b0cf2c8dcefb371328901cb4605", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=911a71a72912cfa7bc2d762f35e76e2f58e3097c", "patch": "@@ -69,9 +69,8 @@ Boston, MA 02111-1307, USA.  */\n           or FIELD_DECL).\n       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n-   5: BINFO_PRIMARY_MARKED_P (in BINFO)\n-   6: BINFO_VBASE_PRIMARY_P (in BINFO)\n-      BINFO_ACCESS (in BINFO)\n+   5: Unused.\n+   6: BINFO_ACCESS (in BINFO)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: C_TYPE_FIELDS_READONLY (in RECORD_TYPE or UNION_TYPE).\n@@ -100,7 +99,10 @@ Boston, MA 02111-1307, USA.  */\n       DECL_THUNK_P (in a member FUNCTION_DECL)\n \n    Usage of language-independent fields in a language-dependent manner:\n-   \n+\n+   TREE_USED\n+     This field is BINFO_INDIRECT_PRIMARY_P in a BINFO.\n+\n    TYPE_ALIAS_SET\n      This field is used by TYPENAME_TYPEs, TEMPLATE_TYPE_PARMs, and so\n      forth as a substitute for the mark bits provided in `lang_type'.\n@@ -1391,8 +1393,8 @@ struct lang_type\n   unsigned dummy : 8;\n       \n   int vsize;\n-  int vfield_parent;\n \n+  tree primary_base;\n   tree vfields;\n   tree vbases;\n   tree tags;\n@@ -1562,34 +1564,16 @@ struct lang_type\n    nested member class templates.  */\n #define CLASSTYPE_TAGS(NODE)\t\t(TYPE_LANG_SPECIFIC(NODE)->tags)\n \n-/* If this value is non-negative, it is the index (in the\n-   TYPE_BINFO_BASETYPES) for the base-class whose vtable pointer we\n-   are reusing.  For example, in D : B1, B2, PARENT would be 0, if D's\n-   vtable came from B1, 1, if D's vtable came from B2.  */\n-#define CLASSTYPE_VFIELD_PARENT(NODE)\t(TYPE_LANG_SPECIFIC(NODE)->vfield_parent)\n-\n /* Nonzero if NODE has a primary base class, i.e., a base class with\n    which it shares the virtual fucntion table pointer.  */\n #define CLASSTYPE_HAS_PRIMARY_BASE_P(NODE) \\\n-  (CLASSTYPE_VFIELD_PARENT (NODE) != -1)\n+  (CLASSTYPE_PRIMARY_BINFO (NODE) != NULL_TREE)\n \n /* If non-NULL, this is the binfo for the primary base class, i.e.,\n    the base class which contains the virtual function table pointer\n    for this class.  */\n #define CLASSTYPE_PRIMARY_BINFO(NODE) \\\n-  (BINFO_PRIMARY_BINFO (TYPE_BINFO (NODE)))\n-\n-/* If non-NULL, this is the binfo for the primary base of BINFO.  Note\n-   that in a complex hierarchy the resulting BINFO may not actually\n-   *be* primary.  In particular if the resulting BINFO is a virtual\n-   base, and it occurs elsewhere in the hierarchy, then this\n-   occurrence may not actually be a primary base in the complete\n-   object.  Check BINFO_PRIMARY_MARKED_P to be sure.  */\n-#define BINFO_PRIMARY_BINFO(NODE)\t\t\t\t\t\\\n-  (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (NODE))\t\t\t\\\n-   ? BINFO_BASETYPE (NODE, \t\t\t\t\t\t\\\n-\t\t     CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (NODE)))\t\\\n-   : NULL_TREE)\n+  (TYPE_LANG_SPECIFIC (NODE)->primary_base)\n \n /* The number of virtual functions present in this class' virtual\n    function table.  */\n@@ -1752,11 +1736,8 @@ struct lang_type\n    class of a non-primary virtual base.  This flag is only valid for\n    paths (given by BINFO_INHERITANCE_CHAIN) that really exist in the\n    final object.  */\n-#define BINFO_PRIMARY_MARKED_P(NODE) TREE_LANG_FLAG_5 (NODE)\n-\n-/* Nonzero if the virtual baseclass with the type given by this BINFO\n-   is primary *somewhere* in the hierarchy.  */\n-#define BINFO_VBASE_PRIMARY_P(NODE) TREE_LANG_FLAG_6 (NODE)\n+#define BINFO_PRIMARY_MARKED_P(NODE) \\\n+  (BINFO_PRIMARY_BASE_OF (NODE) != NULL_TREE)\n \n /* The index in the VTT where this subobject's sub-VTT can be found.\n    NULL_TREE if there is no sub-VTT.  */\n@@ -1766,10 +1747,21 @@ struct lang_type\n    found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n #define BINFO_VPTR_INDEX(NODE) TREE_VEC_ELT ((NODE), 9)\n \n+/* The binfo of which NODE is a primary base.  (This is different from\n+   BINFO_INHERITANCE_CHAIN for virtual base because a virtual base is\n+   sometimes a primary base for a class for which it is not an\n+   immediate base.)  */\n+#define BINFO_PRIMARY_BASE_OF(NODE) TREE_VEC_ELT ((NODE), 10)\n+\n /* Nonzero if this binfo declares a virtual function which is\n    overridden along a virtual path.  */\n #define BINFO_OVERRIDE_ALONG_VIRTUAL_PATH_P(NODE) TREE_LANG_FLAG_2 (NODE)\n \n+/* Nonzero if this binfo is an indirect primary base, i.e. a virtual\n+   base that is a primary base of some of other class in the\n+   hierarchy.  */\n+#define BINFO_INDIRECT_PRIMARY_P(NODE) TREE_USED (NODE)\n+\n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n@@ -3844,6 +3836,7 @@ extern void note_name_declared_in_class         PARAMS ((tree, tree));\n extern tree get_vtbl_decl_for_binfo             PARAMS ((tree));\n extern tree in_charge_arg_for_name              PARAMS ((tree));\n extern tree get_vtt_name                        PARAMS ((tree));\n+extern tree get_primary_binfo                   PARAMS ((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));"}, {"sha": "8832dab6c79c71cd23c04c419d05082ddab1794d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=911a71a72912cfa7bc2d762f35e76e2f58e3097c", "patch": "@@ -15007,6 +15007,7 @@ lang_mark_tree (t)\n \t\t  && TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE))\n \t{\n \t  ggc_mark (lt);\n+\t  ggc_mark_tree (lt->primary_base);\n \t  ggc_mark_tree (lt->vfields);\n \t  ggc_mark_tree (lt->vbases);\n \t  ggc_mark_tree (lt->tags);"}, {"sha": "bf19ce8575542ae1f93f1daaa7cf32105dea5ea1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=911a71a72912cfa7bc2d762f35e76e2f58e3097c", "patch": "@@ -2199,7 +2199,7 @@ get_shared_vbase_if_not_primary (binfo, data)\n       /* This is a non-primary virtual base.  If there is no primary\n \t version, get the shared version.  */\n       binfo = binfo_for_vbase (BINFO_TYPE (binfo), type);\n-      if (BINFO_VBASE_PRIMARY_P (binfo))\n+      if (BINFO_PRIMARY_MARKED_P (binfo))\n \treturn NULL_TREE;\n     }\n \n@@ -2883,7 +2883,7 @@ find_vbase_instance (base, type)\n   tree instance;\n \n   instance = binfo_for_vbase (base, type);\n-  if (!BINFO_VBASE_PRIMARY_P (instance))\n+  if (!BINFO_PRIMARY_MARKED_P (instance))\n     return instance;\n \n   return dfs_walk (TYPE_BINFO (type), \n@@ -3357,21 +3357,9 @@ binfo_for_vtable (var)\n      tree var;\n {\n   tree binfo = TYPE_BINFO (DECL_CONTEXT (var));\n-  tree binfos;\n-  int i;\n \n-  while (1)\n-    {\n-      binfos = BINFO_BASETYPES (binfo);\n-      if (binfos == NULL_TREE)\n-\tbreak;\n-\n-      i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      if (i == -1)\n-\tbreak;\n-\n-      binfo = TREE_VEC_ELT (binfos, i);\n-    }\n+  while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+    binfo = get_primary_binfo (binfo);\n \n   return binfo;\n }"}, {"sha": "01d2fd94b761e409e0e0199bde047d1d3dd784c4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911a71a72912cfa7bc2d762f35e76e2f58e3097c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=911a71a72912cfa7bc2d762f35e76e2f58e3097c", "patch": "@@ -687,6 +687,7 @@ unshare_base_binfos (binfo)\n       TREE_VIA_PROTECTED (new_binfo) = TREE_VIA_PROTECTED (base_binfo);\n       TREE_VIA_VIRTUAL (new_binfo) = TREE_VIA_VIRTUAL (base_binfo);\n       BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n+      BINFO_PRIMARY_BASE_OF (new_binfo) = NULL_TREE;\n       unshare_base_binfos (new_binfo);\n     }\n }\n@@ -851,7 +852,7 @@ make_binfo (offset, binfo, vtable, virtuals)\n      tree offset, binfo;\n      tree vtable, virtuals;\n {\n-  tree new_binfo = make_tree_vec (10);\n+  tree new_binfo = make_tree_vec (11);\n   tree type;\n \n   if (TREE_CODE (binfo) == TREE_VEC)"}]}