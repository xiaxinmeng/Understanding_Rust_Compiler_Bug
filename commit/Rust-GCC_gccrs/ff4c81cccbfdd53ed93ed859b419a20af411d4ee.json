{"sha": "ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY0YzgxY2NjYmZkZDUzZWQ5M2VkODU5YjQxOWEyMGFmNDExZDRlZQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2013-10-28T20:03:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-28T20:03:46Z"}, "message": "df-scan.c (df_collection_rec): Adjust.\n\n\t* df-scan.c (df_collection_rec): Adjust.\n\t(copy_defs): New constant.\n\t(copy_uses): Likewise.\n\t(copy_eq_uses): Likewise.\n\t(copy_mw): Likewise.\n\t(copy_all): Likewise.\n\t(df_insn_rescan): Adjust.\n\t(df_notes_rescan): Likewise.\n\t(df_swap_refs): Likewise.\n\t(df_sort_and_compress_refs): Likewise.\n\t(df_sort_and_compress_mws): Likewise.\n\t(df_install_refs): Likewise.\n\t(df_install_mws): Likewise.\n\t(df_refs_add_to_chains): Add flags parameter controlling which vectors\n\tare coppied.\n\t(df_bb_refs_record): Adjust.\n\t(df_record_entry_block_defs): Likewise.\n\t(df_record_exit_block_defs): Likewise.\n\t(df_refs_verify): Likewise.\n\t(df_mws_verify): Likewise.\n\t(df_insn_refs_verify): Likewise.\n\t(df_bb_verify): Likewise.\n\t* ipa-pure-const.c (finish_state): Remove.\n\t(propagate): Adjust.\n\t* tree-data-ref.c tree-ssa-alias.c tree-ssa-loop-ivcanon.c\n\ttree-ssa-threadedge.c tree-vect-loop-manip.c tree-vect-slp.c\n\tvar-tracking.c: Adjust.\n\t* vec.c (stack_vecs): Remove.\n\t(register_stack_vec): Likewise.\n\t(stack_vec_register_index): Likewise.\n\t(unregister_stack_vec): Likewise.\n\t* vec.h (struct va_stack): Remove.\n\t(struct vec<T, A, vl_ptr>): Specialize as\n\tstruct vec<T, va_heap, vl_ptr> instead since va_heap is the only\n\tallocation strategy compatable with the vl_ptr layout.\n\t(struct vec<T, va_gc, vl_ptr>): Remove because it now gets an empty\n\tspecialization anyway.\n\t(class stack_vec): New class.\n\t(vec_stack_alloc): Remove.\n\t(vec<T, va_heap, vl_ptr>::using_auto_storage): New method.\n\n\t* gcc-interface/decl.c (components_to_record): Adjust.\n\nFrom-SVN: r204137", "tree": {"sha": "938f27ac3813c8dca626ab865ab187f166eab2ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/938f27ac3813c8dca626ab865ab187f166eab2ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/comments", "author": null, "committer": null, "parents": [{"sha": "b868b7cae49515ed5311910be0bc91bce44e47f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b868b7cae49515ed5311910be0bc91bce44e47f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b868b7cae49515ed5311910be0bc91bce44e47f1"}], "stats": {"total": 673, "additions": 260, "deletions": 413}, "files": [{"sha": "e525748949467504f60803441c06cbf18f880962", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -1,3 +1,46 @@\n+2013-10-28  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* df-scan.c (df_collection_rec): Adjust.\n+\t(copy_defs): New constant.\n+\t(copy_uses): Likewise.\n+\t(copy_eq_uses): Likewise.\n+\t(copy_mw): Likewise.\n+\t(copy_all): Likewise.\n+\t(df_insn_rescan): Adjust.\n+\t(df_notes_rescan): Likewise.\n+\t(df_swap_refs): Likewise.\n+\t(df_sort_and_compress_refs): Likewise.\n+\t(df_sort_and_compress_mws): Likewise.\n+\t(df_install_refs): Likewise.\n+\t(df_install_mws): Likewise.\n+\t(df_refs_add_to_chains): Add flags parameter controlling which vectors\n+\tare coppied.\n+\t(df_bb_refs_record): Adjust.\n+\t(df_record_entry_block_defs): Likewise.\n+\t(df_record_exit_block_defs): Likewise.\n+\t(df_refs_verify): Likewise.\n+\t(df_mws_verify): Likewise.\n+\t(df_insn_refs_verify): Likewise.\n+\t(df_bb_verify): Likewise.\n+\t* ipa-pure-const.c (finish_state): Remove.\n+\t(propagate): Adjust.\n+\t* tree-data-ref.c tree-ssa-alias.c tree-ssa-loop-ivcanon.c\n+\ttree-ssa-threadedge.c tree-vect-loop-manip.c tree-vect-slp.c\n+\tvar-tracking.c: Adjust.\n+\t* vec.c (stack_vecs): Remove.\n+\t(register_stack_vec): Likewise.\n+\t(stack_vec_register_index): Likewise.\n+\t(unregister_stack_vec): Likewise.\n+\t* vec.h (struct va_stack): Remove.\n+\t(struct vec<T, A, vl_ptr>): Specialize as\n+\tstruct vec<T, va_heap, vl_ptr> instead since va_heap is the only\n+\tallocation strategy compatable with the vl_ptr layout.\n+\t(struct vec<T, va_gc, vl_ptr>): Remove because it now gets an empty\n+\tspecialization anyway.\n+\t(class stack_vec): New class.\n+\t(vec_stack_alloc): Remove.\n+\t(vec<T, va_heap, vl_ptr>::using_auto_storage): New method.\n+\n 2013-10-28  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Sergey Lega  <sergey.s.lega@intel.com>"}, {"sha": "c5275d8f3a56623093eb9a6496d158e01fbdd238", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -1,3 +1,7 @@\n+2013-10-28  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* gcc-interface/decl.c (components_to_record): Adjust.\n+\n 2013-10-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc-interface/Make-lang.in (ADA_DEPS): Fix quoting."}, {"sha": "d38660231556fb349ec7cb50e53e947320321e2e", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -7003,13 +7003,11 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       tree gnu_union_type, gnu_union_name;\n       tree this_first_free_pos, gnu_variant_list = NULL_TREE;\n       bool union_field_needs_strict_alignment = false;\n-      vec <vinfo_t, va_stack> variant_types;\n+      stack_vec <vinfo_t, 16> variant_types;\n       vinfo_t *gnu_variant;\n       unsigned int variants_align = 0;\n       unsigned int i;\n \n-      vec_stack_alloc (vinfo_t, variant_types, 16);\n-\n       if (TREE_CODE (gnu_name) == TYPE_DECL)\n \tgnu_name = DECL_NAME (gnu_name);\n \n@@ -7205,9 +7203,6 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  gnu_variant_list = gnu_field;\n \t}\n \n-      /* We are done with the variants.  */\n-      variant_types.release ();\n-\n       /* Only make the QUAL_UNION_TYPE if there are non-empty variants.  */\n       if (gnu_variant_list)\n \t{"}, {"sha": "aace96d45363b8fe0beaf390f20d6fb8979e9c63", "filename": "gcc/df-scan.c", "status": "modified", "additions": 52, "deletions": 86, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -86,10 +86,10 @@ static HARD_REG_SET elim_reg_set;\n \n struct df_collection_rec\n {\n-  vec<df_ref, va_stack> def_vec;\n-  vec<df_ref, va_stack> use_vec;\n-  vec<df_ref, va_stack> eq_use_vec;\n-  vec<df_mw_hardreg_ptr, va_stack> mw_vec;\n+  stack_vec<df_ref, 128> def_vec;\n+  stack_vec<df_ref, 32> use_vec;\n+  stack_vec<df_ref, 32> eq_use_vec;\n+  stack_vec<df_mw_hardreg_ptr, 32> mw_vec;\n };\n \n static df_ref df_null_ref_rec[1];\n@@ -131,7 +131,7 @@ static void df_ref_chain_delete_du_chain (df_ref *);\n static void df_ref_chain_delete (df_ref *);\n \n static void df_refs_add_to_chains (struct df_collection_rec *,\n-\t\t\t\t   basic_block, rtx);\n+\t\t\t\t   basic_block, rtx, unsigned int);\n \n static bool df_insn_refs_verify (struct df_collection_rec *, basic_block, rtx, bool);\n static void df_entry_block_defs_collect (struct df_collection_rec *, bitmap);\n@@ -153,6 +153,14 @@ static void df_insn_info_delete (unsigned int);\n    and epilogue to save and restore registers as needed.  */\n \n static bool regs_ever_live[FIRST_PSEUDO_REGISTER];\n+\n+/* Flags used to tell df_refs_add_to_chains() which vectors it should copy. */\n+static const unsigned int copy_defs = 0x1;\n+static const unsigned int copy_uses = 0x2;\n+static const unsigned int copy_eq_uses = 0x4;\n+static const unsigned int copy_mw = 0x8;\n+static const unsigned int copy_all = copy_defs | copy_uses | copy_eq_uses\n+| copy_mw;\n \f\n /*----------------------------------------------------------------------------\n    SCANNING DATAFLOW PROBLEM\n@@ -1268,11 +1276,6 @@ df_insn_rescan (rtx insn)\n       return false;\n     }\n \n-  vec_stack_alloc (df_ref, collection_rec.def_vec, 128);\n-  vec_stack_alloc (df_ref, collection_rec.use_vec, 32);\n-  vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n-  vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n-\n   bitmap_clear_bit (&df->insns_to_delete, uid);\n   bitmap_clear_bit (&df->insns_to_rescan, uid);\n   bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n@@ -1306,15 +1309,10 @@ df_insn_rescan (rtx insn)\n \tfprintf (dump_file, \"scanning new insn with uid = %d.\\n\", uid);\n     }\n \n-  df_refs_add_to_chains (&collection_rec, bb, insn);\n+  df_refs_add_to_chains (&collection_rec, bb, insn, copy_all);\n   if (!DEBUG_INSN_P (insn))\n     df_set_bb_dirty (bb);\n \n-  collection_rec.def_vec.release ();\n-  collection_rec.use_vec.release ();\n-  collection_rec.eq_use_vec.release ();\n-  collection_rec.mw_vec.release ();\n-\n   return true;\n }\n \n@@ -2221,10 +2219,6 @@ df_notes_rescan (rtx insn)\n       unsigned int num_deleted;\n       unsigned int mw_len;\n \n-      memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-      vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n-      vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n-\n       num_deleted = df_mw_hardreg_chain_delete_eq_uses (insn_info);\n       df_ref_chain_delete (insn_info->eq_uses);\n       insn_info->eq_uses = NULL;\n@@ -2287,11 +2281,7 @@ df_notes_rescan (rtx insn)\n \t      insn_info->mw_hardregs[mw_len] = NULL;\n \t    }\n \t}\n-      /* Get rid of the mw_rec so that df_refs_add_to_chains will\n-\t ignore it.  */\n-      collection_rec.mw_vec.release ();\n-      df_refs_add_to_chains (&collection_rec, bb, insn);\n-      collection_rec.eq_use_vec.release ();\n+      df_refs_add_to_chains (&collection_rec, bb, insn, copy_eq_uses);\n     }\n   else\n     df_insn_rescan (insn);\n@@ -2391,7 +2381,7 @@ df_ref_compare (const void *r1, const void *r2)\n }\n \n static void\n-df_swap_refs (vec<df_ref, va_stack> *ref_vec, int i, int j)\n+df_swap_refs (vec<df_ref, va_heap> *ref_vec, int i, int j)\n {\n   df_ref tmp = (*ref_vec)[i];\n   (*ref_vec)[i] = (*ref_vec)[j];\n@@ -2401,7 +2391,7 @@ df_swap_refs (vec<df_ref, va_stack> *ref_vec, int i, int j)\n /* Sort and compress a set of refs.  */\n \n static void\n-df_sort_and_compress_refs (vec<df_ref, va_stack> *ref_vec)\n+df_sort_and_compress_refs (vec<df_ref, va_heap> *ref_vec)\n {\n   unsigned int count;\n   unsigned int i;\n@@ -2510,7 +2500,7 @@ df_mw_compare (const void *m1, const void *m2)\n /* Sort and compress a set of refs.  */\n \n static void\n-df_sort_and_compress_mws (vec<df_mw_hardreg_ptr, va_stack> *mw_vec)\n+df_sort_and_compress_mws (vec<df_mw_hardreg_ptr, va_heap> *mw_vec)\n {\n   unsigned int count;\n   struct df_scan_problem_data *problem_data\n@@ -2621,14 +2611,12 @@ df_install_ref (df_ref this_ref,\n \n static df_ref *\n df_install_refs (basic_block bb,\n-\t\t vec<df_ref, va_stack> old_vec,\n+\t\t const vec<df_ref, va_heap> *old_vec,\n \t\t struct df_reg_info **reg_info,\n \t\t struct df_ref_info *ref_info,\n \t\t bool is_notes)\n {\n-  unsigned int count;\n-\n-  count = old_vec.length ();\n+  unsigned int count = old_vec->length ();\n   if (count)\n     {\n       df_ref *new_vec = XNEWVEC (df_ref, count + 1);\n@@ -2659,7 +2647,7 @@ df_install_refs (basic_block bb,\n       if (add_to_table && df->analyze_subset)\n \tadd_to_table = bitmap_bit_p (df->blocks_to_analyze, bb->index);\n \n-      FOR_EACH_VEC_ELT (old_vec, ix, this_ref)\n+      FOR_EACH_VEC_ELT (*old_vec, ix, this_ref)\n \t{\n \t  new_vec[ix] = this_ref;\n \t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)],\n@@ -2678,16 +2666,14 @@ df_install_refs (basic_block bb,\n    insn.  */\n \n static struct df_mw_hardreg **\n-df_install_mws (vec<df_mw_hardreg_ptr, va_stack> old_vec)\n+df_install_mws (const vec<df_mw_hardreg_ptr, va_heap> *old_vec)\n {\n-  unsigned int count;\n-\n-  count = old_vec.length ();\n+  unsigned int count = old_vec->length ();\n   if (count)\n     {\n       struct df_mw_hardreg **new_vec\n \t= XNEWVEC (struct df_mw_hardreg*, count + 1);\n-      memcpy (new_vec, old_vec.address (),\n+      memcpy (new_vec, old_vec->address (),\n \t      sizeof (struct df_mw_hardreg*) * count);\n       new_vec[count] = NULL;\n       return new_vec;\n@@ -2702,43 +2688,43 @@ df_install_mws (vec<df_mw_hardreg_ptr, va_stack> old_vec)\n \n static void\n df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n-\t\t       basic_block bb, rtx insn)\n+\t\t       basic_block bb, rtx insn, unsigned int flags)\n {\n   if (insn)\n     {\n       struct df_insn_info *insn_rec = DF_INSN_INFO_GET (insn);\n       /* If there is a vector in the collection rec, add it to the\n \t insn.  A null rec is a signal that the caller will handle the\n \t chain specially.  */\n-      if (collection_rec->def_vec.exists ())\n+      if (flags & copy_defs)\n \t{\n \t  df_scan_free_ref_vec (insn_rec->defs);\n \t  insn_rec->defs\n-\t    = df_install_refs (bb, collection_rec->def_vec,\n+\t    = df_install_refs (bb, &collection_rec->def_vec,\n \t\t\t       df->def_regs,\n \t\t\t       &df->def_info, false);\n \t}\n-      if (collection_rec->use_vec.exists ())\n+      if (flags & copy_uses)\n \t{\n \t  df_scan_free_ref_vec (insn_rec->uses);\n \t  insn_rec->uses\n-\t    = df_install_refs (bb, collection_rec->use_vec,\n+\t    = df_install_refs (bb, &collection_rec->use_vec,\n \t\t\t       df->use_regs,\n \t\t\t       &df->use_info, false);\n \t}\n-      if (collection_rec->eq_use_vec.exists ())\n+      if (flags & copy_eq_uses)\n \t{\n \t  df_scan_free_ref_vec (insn_rec->eq_uses);\n \t  insn_rec->eq_uses\n-\t    = df_install_refs (bb, collection_rec->eq_use_vec,\n+\t    = df_install_refs (bb, &collection_rec->eq_use_vec,\n \t\t\t       df->eq_use_regs,\n \t\t\t       &df->use_info, true);\n \t}\n-      if (collection_rec->mw_vec.exists ())\n+      if (flags & copy_mw)\n \t{\n \t  df_scan_free_mws_vec (insn_rec->mw_hardregs);\n \t  insn_rec->mw_hardregs\n-\t    = df_install_mws (collection_rec->mw_vec);\n+\t    = df_install_mws (&collection_rec->mw_vec);\n \t}\n     }\n   else\n@@ -2747,12 +2733,12 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n \n       df_scan_free_ref_vec (bb_info->artificial_defs);\n       bb_info->artificial_defs\n-\t= df_install_refs (bb, collection_rec->def_vec,\n+\t= df_install_refs (bb, &collection_rec->def_vec,\n \t\t\t   df->def_regs,\n \t\t\t   &df->def_info, false);\n       df_scan_free_ref_vec (bb_info->artificial_uses);\n       bb_info->artificial_uses\n-\t= df_install_refs (bb, collection_rec->use_vec,\n+\t= df_install_refs (bb, &collection_rec->use_vec,\n \t\t\t   df->use_regs,\n \t\t\t   &df->use_info, false);\n     }\n@@ -3633,17 +3619,12 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n   int luid = 0;\n-  struct df_collection_rec collection_rec;\n \n   if (!df)\n     return;\n \n+  df_collection_rec collection_rec;\n   df_grow_bb_info (df_scan);\n-  vec_stack_alloc (df_ref, collection_rec.def_vec, 128);\n-  vec_stack_alloc (df_ref, collection_rec.use_vec, 32);\n-  vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n-  vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n-\n   if (scan_insns)\n     /* Scan the block an insn at a time from beginning to end.  */\n     FOR_BB_INSNS (bb, insn)\n@@ -3657,19 +3638,14 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n \t    /* Record refs within INSN.  */\n \t    DF_INSN_INFO_LUID (insn_info) = luid++;\n \t    df_insn_refs_collect (&collection_rec, bb, DF_INSN_INFO_GET (insn));\n-\t    df_refs_add_to_chains (&collection_rec, bb, insn);\n+\t    df_refs_add_to_chains (&collection_rec, bb, insn, copy_all);\n \t  }\n \tDF_INSN_INFO_LUID (insn_info) = luid;\n       }\n \n   /* Other block level artificial refs */\n   df_bb_refs_collect (&collection_rec, bb);\n-  df_refs_add_to_chains (&collection_rec, bb, NULL);\n-\n-  collection_rec.def_vec.release ();\n-  collection_rec.use_vec.release ();\n-  collection_rec.eq_use_vec.release ();\n-  collection_rec.mw_vec.release ();\n+  df_refs_add_to_chains (&collection_rec, bb, NULL, copy_all);\n \n   /* Now that the block has been processed, set the block as dirty so\n      LR and LIVE will get it processed.  */\n@@ -3911,13 +3887,11 @@ static void\n df_record_entry_block_defs (bitmap entry_block_defs)\n {\n   struct df_collection_rec collection_rec;\n-  memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  vec_stack_alloc (df_ref, collection_rec.def_vec, FIRST_PSEUDO_REGISTER);\n   df_entry_block_defs_collect (&collection_rec, entry_block_defs);\n \n   /* Process bb_refs chain */\n-  df_refs_add_to_chains (&collection_rec, BASIC_BLOCK (ENTRY_BLOCK), NULL);\n-  collection_rec.def_vec.release ();\n+  df_refs_add_to_chains (&collection_rec, BASIC_BLOCK (ENTRY_BLOCK), NULL,\n+\t\t\t copy_defs);\n }\n \n \n@@ -4084,13 +4058,11 @@ static void\n df_record_exit_block_uses (bitmap exit_block_uses)\n {\n   struct df_collection_rec collection_rec;\n-  memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  vec_stack_alloc (df_ref, collection_rec.use_vec, FIRST_PSEUDO_REGISTER);\n   df_exit_block_uses_collect (&collection_rec, exit_block_uses);\n \n   /* Process bb_refs chain */\n-  df_refs_add_to_chains (&collection_rec, BASIC_BLOCK (EXIT_BLOCK), NULL);\n-  collection_rec.use_vec.release ();\n+  df_refs_add_to_chains (&collection_rec, BASIC_BLOCK (EXIT_BLOCK), NULL,\n+\t\t\t copy_uses);\n }\n \n \n@@ -4331,13 +4303,13 @@ df_reg_chain_verify_unmarked (df_ref refs)\n /* Verify that NEW_REC and OLD_REC have exactly the same members. */\n \n static bool\n-df_refs_verify (vec<df_ref, va_stack> new_rec, df_ref *old_rec,\n+df_refs_verify (const vec<df_ref, va_heap> *new_rec, df_ref *old_rec,\n \t\tbool abort_if_fail)\n {\n   unsigned int ix;\n   df_ref new_ref;\n \n-  FOR_EACH_VEC_ELT (new_rec, ix, new_ref)\n+  FOR_EACH_VEC_ELT (*new_rec, ix, new_ref)\n     {\n       if (*old_rec == NULL || !df_ref_equal_p (new_ref, *old_rec))\n \t{\n@@ -4369,14 +4341,14 @@ df_refs_verify (vec<df_ref, va_stack> new_rec, df_ref *old_rec,\n /* Verify that NEW_REC and OLD_REC have exactly the same members. */\n \n static bool\n-df_mws_verify (vec<df_mw_hardreg_ptr, va_stack> new_rec,\n+df_mws_verify (const vec<df_mw_hardreg_ptr, va_heap> *new_rec,\n \t       struct df_mw_hardreg **old_rec,\n \t       bool abort_if_fail)\n {\n   unsigned int ix;\n   struct df_mw_hardreg *new_reg;\n \n-  FOR_EACH_VEC_ELT (new_rec, ix, new_reg)\n+  FOR_EACH_VEC_ELT (*new_rec, ix, new_reg)\n     {\n       if (*old_rec == NULL || !df_mw_equal_p (new_reg, *old_rec))\n \t{\n@@ -4430,13 +4402,13 @@ df_insn_refs_verify (struct df_collection_rec *collection_rec,\n \n   /* Unfortunately we cannot opt out early if one of these is not\n      right because the marks will not get cleared.  */\n-  ret1 = df_refs_verify (collection_rec->def_vec, DF_INSN_UID_DEFS (uid),\n+  ret1 = df_refs_verify (&collection_rec->def_vec, DF_INSN_UID_DEFS (uid),\n \t\t\t abort_if_fail);\n-  ret2 = df_refs_verify (collection_rec->use_vec, DF_INSN_UID_USES (uid),\n+  ret2 = df_refs_verify (&collection_rec->use_vec, DF_INSN_UID_USES (uid),\n \t\t\t abort_if_fail);\n-  ret3 = df_refs_verify (collection_rec->eq_use_vec, DF_INSN_UID_EQ_USES (uid),\n+  ret3 = df_refs_verify (&collection_rec->eq_use_vec, DF_INSN_UID_EQ_USES (uid),\n \t\t\t abort_if_fail);\n-  ret4 = df_mws_verify (collection_rec->mw_vec, DF_INSN_UID_MWS (uid),\n+  ret4 = df_mws_verify (&collection_rec->mw_vec, DF_INSN_UID_MWS (uid),\n \t\t       abort_if_fail);\n   return (ret1 && ret2 && ret3 && ret4);\n }\n@@ -4453,12 +4425,6 @@ df_bb_verify (basic_block bb)\n   struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb->index);\n   struct df_collection_rec collection_rec;\n \n-  memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  vec_stack_alloc (df_ref, collection_rec.def_vec, 128);\n-  vec_stack_alloc (df_ref, collection_rec.use_vec, 32);\n-  vec_stack_alloc (df_ref, collection_rec.eq_use_vec, 32);\n-  vec_stack_alloc (df_mw_hardreg_ptr, collection_rec.mw_vec, 32);\n-\n   gcc_assert (bb_info);\n \n   /* Scan the block, one insn at a time, from beginning to end.  */\n@@ -4472,8 +4438,8 @@ df_bb_verify (basic_block bb)\n \n   /* Do the artificial defs and uses.  */\n   df_bb_refs_collect (&collection_rec, bb);\n-  df_refs_verify (collection_rec.def_vec, df_get_artificial_defs (bb->index), true);\n-  df_refs_verify (collection_rec.use_vec, df_get_artificial_uses (bb->index), true);\n+  df_refs_verify (&collection_rec.def_vec, df_get_artificial_defs (bb->index), true);\n+  df_refs_verify (&collection_rec.use_vec, df_get_artificial_uses (bb->index), true);\n   df_free_collection_rec (&collection_rec);\n \n   return true;"}, {"sha": "d5f334ef5f4618ada406d80fdf7dcd182a8c6b4c", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -190,15 +190,6 @@ warn_function_noreturn (tree decl)\n \t\t\t   true, warned_about, \"noreturn\");\n }\n \n-/* Init the function state.  */\n-\n-static void\n-finish_state (void)\n-{\n-  funct_state_vec.release ();\n-}\n-\n-\n /* Return true if we have a function state for NODE.  */\n \n static inline bool\n@@ -1488,7 +1479,6 @@ propagate (void)\n     if (has_function_state (node))\n       free (get_function_state (node));\n   funct_state_vec.release ();\n-  finish_state ();\n   return 0;\n }\n "}, {"sha": "ffa4cbf14d7bca7cf92fa5f5942bc0329e29b91b", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -4325,7 +4325,7 @@ typedef struct data_ref_loc_d\n    true if STMT clobbers memory, false otherwise.  */\n \n static bool\n-get_references_in_stmt (gimple stmt, vec<data_ref_loc, va_stack> *references)\n+get_references_in_stmt (gimple stmt, vec<data_ref_loc, va_heap> *references)\n {\n   bool clobbers_memory = false;\n   data_ref_loc ref;\n@@ -4417,17 +4417,13 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n-  vec<data_ref_loc, va_stack> references;\n+  stack_vec<data_ref_loc, 2> references;\n   data_ref_loc *ref;\n   bool ret = true;\n   data_reference_p dr;\n \n-  vec_stack_alloc (data_ref_loc, references, 2);\n   if (get_references_in_stmt (stmt, &references))\n-    {\n-      references.release ();\n-      return false;\n-    }\n+    return false;\n \n   FOR_EACH_VEC_ELT (references, i, ref)\n     {\n@@ -4451,17 +4447,13 @@ graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple stmt,\n \t\t\t\t       vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n-  vec<data_ref_loc, va_stack> references;\n+  stack_vec<data_ref_loc, 2> references;\n   data_ref_loc *ref;\n   bool ret = true;\n   data_reference_p dr;\n \n-  vec_stack_alloc (data_ref_loc, references, 2);\n   if (get_references_in_stmt (stmt, &references))\n-    {\n-      references.release ();\n-      return false;\n-    }\n+    return false;\n \n   FOR_EACH_VEC_ELT (references, i, ref)\n     {"}, {"sha": "a3046ad4f8127e43147a6275a562e0432943b6f8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -736,11 +736,8 @@ aliasing_component_refs_p (tree ref1,\n static bool\n nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n {\n-  vec<tree, va_stack> component_refs1;\n-  vec<tree, va_stack> component_refs2;\n-\n-  vec_stack_alloc (tree, component_refs1, 16);\n-  vec_stack_alloc (tree, component_refs2, 16);\n+  stack_vec<tree, 16> component_refs1;\n+  stack_vec<tree, 16> component_refs2;\n \n   /* Create the stack of handled components for REF1.  */\n   while (handled_component_p (ref1))"}, {"sha": "6f8f04e457ebc10ce334521380559e5ce576b99d", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -1100,7 +1100,7 @@ propagate_constants_for_unrolling (basic_block bb)\n \n static bool\n tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n-\t\t\t\tvec<loop_p, va_stack>& father_stack,\n+\t\t\t\tvec<loop_p, va_heap>& father_stack,\n \t\t\t\tstruct loop *loop)\n {\n   struct loop *loop_father;\n@@ -1164,12 +1164,11 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n unsigned int\n tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n {\n-  vec<loop_p, va_stack> father_stack;\n+  stack_vec<loop_p, 16> father_stack;\n   bool changed;\n   int iteration = 0;\n   bool irred_invalidated = false;\n \n-  vec_stack_alloc (loop_p, father_stack, 16);\n   do\n     {\n       changed = false;"}, {"sha": "c3e7bd0d1388745ee10bf5c00afcc4befe235b6f", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -644,16 +644,14 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n       i++;\n     }\n \n-  vec<tree, va_stack> fewvars = vNULL;\n+  stack_vec<tree, alloc_count> fewvars;\n   pointer_set_t *vars = NULL;\n \n   /* If we're already starting with 3/4 of alloc_count, go for a\n      pointer_set, otherwise start with an unordered stack-allocated\n      VEC.  */\n   if (i * 4 > alloc_count * 3)\n     vars = pointer_set_create ();\n-  else if (alloc_count)\n-    vec_stack_alloc (tree, fewvars, alloc_count);\n \n   /* Now go through the initial debug stmts in DEST again, this time\n      actually inserting in VARS or FEWVARS.  Don't bother checking for"}, {"sha": "62eea7d6e9be2a1ced431dbc0bfbe16287f9ad8b", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -115,7 +115,7 @@ typedef struct\n    with a PHI DEF that would soon become non-dominant, and when we got\n    to the suitable one, it wouldn't have anything to substitute any\n    more.  */\n-static vec<adjust_info, va_stack> adjust_vec;\n+static vec<adjust_info, va_heap> adjust_vec;\n \n /* Adjust any debug stmts that referenced AI->from values to use the\n    loop-closed AI->to, if the references are dominated by AI->bb and\n@@ -1133,7 +1133,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   if (MAY_HAVE_DEBUG_STMTS)\n     {\n       gcc_assert (!adjust_vec.exists ());\n-      vec_stack_alloc (adjust_info, adjust_vec, 32);\n+      adjust_vec.create (32);\n     }\n \n   if (e == exit_e)"}, {"sha": "825f73a429ab2c8b4521806973e58b58936fee35", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -1934,7 +1934,7 @@ vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n \n static unsigned\n vect_bb_slp_scalar_cost (basic_block bb,\n-\t\t\t slp_tree node, vec<bool, va_stack> life)\n+\t\t\t slp_tree node, vec<bool, va_heap> *life)\n {\n   unsigned scalar_cost = 0;\n   unsigned i;\n@@ -1948,7 +1948,7 @@ vect_bb_slp_scalar_cost (basic_block bb,\n       def_operand_p def_p;\n       stmt_vec_info stmt_info;\n \n-      if (life[i])\n+      if ((*life)[i])\n \tcontinue;\n \n       /* If there is a non-vectorized use of the defs then the scalar\n@@ -1965,11 +1965,11 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \t\t|| gimple_bb (use_stmt) != bb\n \t\t|| !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (use_stmt)))\n \t      {\n-\t\tlife[i] = true;\n+\t\t(*life)[i] = true;\n \t\tBREAK_FROM_IMM_USE_STMT (use_iter);\n \t      }\n \t}\n-      if (life[i])\n+      if ((*life)[i])\n \tcontinue;\n \n       stmt_info = vinfo_for_stmt (stmt);\n@@ -2023,13 +2023,11 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   /* Calculate scalar cost.  */\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n-      vec<bool, va_stack> life;\n-      vec_stack_alloc (bool, life, SLP_INSTANCE_GROUP_SIZE (instance));\n-      life.quick_grow_cleared (SLP_INSTANCE_GROUP_SIZE (instance));\n+      stack_vec<bool, 20> life;\n+      life.safe_grow_cleared (SLP_INSTANCE_GROUP_SIZE (instance));\n       scalar_cost += vect_bb_slp_scalar_cost (BB_VINFO_BB (bb_vinfo),\n \t\t\t\t\t      SLP_INSTANCE_TREE (instance),\n-\t\t\t\t\t      life);\n-      life.release ();\n+\t\t\t\t\t      &life);\n     }\n \n   /* Complete the target-specific cost calculation.  */"}, {"sha": "8b07f9fbf9f123cff0ce5f3c0fdc3714c6a97e85", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -7907,15 +7907,15 @@ struct expand_loc_callback_data\n \n   /* Stack of values and debug_exprs under expansion, and their\n      children.  */\n-  vec<rtx, va_stack> expanding;\n+  stack_vec<rtx, 4> expanding;\n \n   /* Stack of values and debug_exprs whose expansion hit recursion\n      cycles.  They will have VALUE_RECURSED_INTO marked when added to\n      this list.  This flag will be cleared if any of its dependencies\n      resolves to a valid location.  So, if the flag remains set at the\n      end of the search, we know no valid location for this one can\n      possibly exist.  */\n-  vec<rtx, va_stack> pending;\n+  stack_vec<rtx, 4> pending;\n \n   /* The maximum depth among the sub-expressions under expansion.\n      Zero indicates no expansion so far.  */\n@@ -8417,11 +8417,11 @@ vt_expand_loc_callback (rtx x, bitmap regs,\n    This function performs this finalization of NULL locations.  */\n \n static void\n-resolve_expansions_pending_recursion (vec<rtx, va_stack> pending)\n+resolve_expansions_pending_recursion (vec<rtx, va_heap> *pending)\n {\n-  while (!pending.is_empty ())\n+  while (!pending->is_empty ())\n     {\n-      rtx x = pending.pop ();\n+      rtx x = pending->pop ();\n       decl_or_value dv;\n \n       if (!VALUE_RECURSED_INTO (x))\n@@ -8441,16 +8441,14 @@ resolve_expansions_pending_recursion (vec<rtx, va_stack> pending)\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       (d).vars = (v);\t\t\t\t\t\t\\\n-      vec_stack_alloc (rtx, (d).expanding, 4);\t\t\t\\\n-      vec_stack_alloc (rtx, (d).pending, 4);\t\t\t\\\n       (d).depth.complexity = (d).depth.entryvals = 0;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n /* Finalize expand_loc_callback_data D, resolved to location L.  */\n #define FINI_ELCD(d, l)\t\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      resolve_expansions_pending_recursion ((d).pending);\t\\\n+      resolve_expansions_pending_recursion (&(d).pending);\t\\\n       (d).pending.release ();\t\t\t\t\t\\\n       (d).expanding.release ();\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n@@ -8744,7 +8742,7 @@ emit_note_insn_var_location (variable_def **varp, emit_note_data *data)\n \n int\n var_track_values_to_stack (variable_def **slot,\n-\t\t\t   vec<rtx, va_stack> *changed_values_stack)\n+\t\t\t   vec<rtx, va_heap> *changed_values_stack)\n {\n   variable var = *slot;\n \n@@ -8779,7 +8777,7 @@ remove_value_from_changed_variables (rtx val)\n \n static void\n notify_dependents_of_changed_value (rtx val, variable_table_type htab,\n-\t\t\t\t    vec<rtx, va_stack> *changed_values_stack)\n+\t\t\t\t    vec<rtx, va_heap> *changed_values_stack)\n {\n   variable_def **slot;\n   variable var;\n@@ -8864,13 +8862,11 @@ process_changed_values (variable_table_type htab)\n {\n   int i, n;\n   rtx val;\n-  vec<rtx, va_stack> changed_values_stack;\n-\n-  vec_stack_alloc (rtx, changed_values_stack, 20);\n+  stack_vec<rtx, 20> changed_values_stack;\n \n   /* Move values from changed_variables to changed_values_stack.  */\n   changed_variables\n-    .traverse <vec<rtx, va_stack>*, var_track_values_to_stack>\n+    .traverse <vec<rtx, va_heap>*, var_track_values_to_stack>\n       (&changed_values_stack);\n \n   /* Back-propagate change notifications in values while popping\n@@ -8891,8 +8887,6 @@ process_changed_values (variable_table_type htab)\n \t  n--;\n \t}\n     }\n-\n-  changed_values_stack.release ();\n }\n \n /* Emit NOTE_INSN_VAR_LOCATION note for each variable from a chain"}, {"sha": "f3c331507d55212ba8249ad03d082d6f33065f56", "filename": "gcc/vec.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -217,49 +217,6 @@ vec_prefix::calculate_allocation (vec_prefix *pfx, unsigned reserve,\n }\n \n \n-/* Stack vectors are a little different.  VEC_alloc turns into a call\n-   to vec<T, A>::stack_reserve and passes in space allocated via a\n-   call to alloca.  We record that pointer so that we know that we\n-   shouldn't free it.  If the vector is resized, we resize it on the\n-   heap.  We record the pointers in a vector and search it in LIFO\n-   order--i.e., we look for the newest stack vectors first.  We don't\n-   expect too many stack vectors at any one level, and searching from\n-   the end should normally be efficient even if they are used in a\n-   recursive function.  */\n-\n-static vec<void *> stack_vecs;\n-\n-/* Add a stack vector to STACK_VECS.  */\n-\n-void\n-register_stack_vec (void *vec)\n-{\n-  stack_vecs.safe_push (vec);\n-}\n-\n-\n-/* If VEC is registered in STACK_VECS, return its index.\n-   Otherwise, return -1.  */\n-\n-int\n-stack_vec_register_index (void *vec)\n-{\n-  for (unsigned ix = stack_vecs.length (); ix > 0; --ix)\n-    if (stack_vecs[ix - 1] == vec)\n-      return static_cast<int> (ix - 1);\n-  return -1;\n-}\n-\n-\n-/* Remove vector at slot IX from the list of registered stack vectors.  */\n-\n-void\n-unregister_stack_vec (unsigned ix)\n-{\n-  stack_vecs.unordered_remove (ix);\n-}\n-\n-\n /* Helper for qsort; sort descriptors by amount of memory consumed.  */\n \n static int"}, {"sha": "f97e022f24a5c06c341ccc7e4ee78c4f7a0d86d1", "filename": "gcc/vec.h", "status": "modified", "additions": 131, "deletions": 217, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff4c81cccbfdd53ed93ed859b419a20af411d4ee/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=ff4c81cccbfdd53ed93ed859b419a20af411d4ee", "patch": "@@ -101,8 +101,6 @@ along with GCC; see the file COPYING3.  If not see\n \t- Heap: allocation is done using malloc/free.  This is the\n \t  default allocation strategy.\n \n-  \t- Stack: allocation is done using alloca.\n-\n   \t- GC: allocation is done using ggc_alloc/ggc_free.\n \n   \t- GC atomic: same as GC with the exception that the elements\n@@ -233,9 +231,9 @@ struct vec_prefix\n   friend struct va_gc;\n   friend struct va_gc_atomic;\n   friend struct va_heap;\n-  friend struct va_stack;\n \n-  unsigned m_alloc;\n+  unsigned m_alloc : 31;\n+  unsigned m_has_auto_buf : 1;\n   unsigned m_num;\n };\n \n@@ -255,8 +253,7 @@ struct vl_ptr { };\n    va_heap\t- Allocation uses malloc/free.\n    va_gc\t- Allocation uses ggc_alloc.\n    va_gc_atomic\t- Same as GC, but individual elements of the array\n-\t\t  do not need to be marked during collection.\n-   va_stack\t- Allocation uses alloca.  */\n+\t\t  do not need to be marked during collection.  */\n \n /* Allocator type for heap vectors.  */\n struct va_heap\n@@ -401,107 +398,6 @@ struct va_gc_atomic : va_gc\n };\n \n \n-/* Allocator type for stack vectors.  */\n-struct va_stack\n-{\n-  /* Use vl_ptr as the default layout for stack vectors.  */\n-  typedef vl_ptr default_layout;\n-\n-  template<typename T>\n-  static void alloc (vec<T, va_stack, vl_ptr>&, unsigned,\n-\t\t     vec<T, va_stack, vl_embed> *);\n-\n-  template <typename T>\n-  static void reserve (vec<T, va_stack, vl_embed> *&, unsigned, bool\n-\t\t       CXX_MEM_STAT_INFO);\n-\n-  template <typename T>\n-  static void release (vec<T, va_stack, vl_embed> *&);\n-};\n-\n-/* Helper functions to keep track of vectors allocated on the stack.  */\n-void register_stack_vec (void *);\n-int stack_vec_register_index (void *);\n-void unregister_stack_vec (unsigned);\n-\n-/* Allocate a vector V which uses alloca for the initial allocation.\n-   SPACE is space allocated using alloca.  NELEMS is the number of\n-   entries allocated.  */\n-\n-template<typename T>\n-void\n-va_stack::alloc (vec<T, va_stack, vl_ptr> &v, unsigned nelems,\n-\t\t vec<T, va_stack, vl_embed> *space)\n-{\n-  v.m_vec = space;\n-  register_stack_vec (static_cast<void *> (v.m_vec));\n-  v.m_vec->embedded_init (nelems, 0);\n-}\n-\n-\n-/* Reserve NELEMS slots for a vector initially allocated on the stack.\n-   When this happens, we switch back to heap allocation.  We remove\n-   the vector from stack_vecs, if it is there, since we no longer need\n-   to avoid freeing it.  If EXACT is true, grow exactly, otherwise\n-   grow exponentially.  */\n-\n-template<typename T>\n-void\n-va_stack::reserve (vec<T, va_stack, vl_embed> *&v, unsigned nelems, bool exact\n-\t\t   MEM_STAT_DECL)\n-{\n-  int ix = stack_vec_register_index (static_cast<void *> (v));\n-  if (ix >= 0)\n-    unregister_stack_vec (ix);\n-  else\n-    {\n-      /* V is already on the heap.  */\n-      va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&> (v),\n-\t\t\tnelems, exact PASS_MEM_STAT);\n-      return;\n-    }\n-\n-  /* Move VEC_ to the heap.  */\n-  nelems += v->m_vecpfx.m_num;\n-  vec<T, va_stack, vl_embed> *oldvec = v;\n-  v = NULL;\n-  va_heap::reserve (reinterpret_cast<vec<T, va_heap, vl_embed> *&>(v), nelems,\n-\t\t    exact PASS_MEM_STAT);\n-  if (v && oldvec)\n-    {\n-      v->m_vecpfx.m_num = oldvec->length ();\n-      memcpy (v->m_vecdata,\n-\t      oldvec->m_vecdata,\n-\t      oldvec->length () * sizeof (T));\n-    }\n-}\n-\n-\n-/* Free a vector allocated on the stack.  Don't actually free it if we\n-   find it in the hash table.  */\n-\n-template<typename T>\n-void\n-va_stack::release (vec<T, va_stack, vl_embed> *&v)\n-{\n-  if (v == NULL)\n-    return;\n-\n-  int ix = stack_vec_register_index (static_cast<void *> (v));\n-  if (ix >= 0)\n-    {\n-      unregister_stack_vec (ix);\n-      v = NULL;\n-    }\n-  else\n-    {\n-      /* The vector was not on the list of vectors allocated on the stack, so it\n-\t must be allocated on the heap.  */\n-      va_heap::release (reinterpret_cast<vec<T, va_heap, vl_embed> *&> (v));\n-    }\n-}\n-\n-\n /* Generic vector template.  Default values for A and L indicate the\n    most commonly used strategies.\n \n@@ -597,7 +493,6 @@ struct GTY((user)) vec<T, A, vl_embed>\n   friend struct va_gc;\n   friend struct va_gc_atomic;\n   friend struct va_heap;\n-  friend struct va_stack;\n \n   /* FIXME - These fields should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n@@ -1112,6 +1007,7 @@ inline void\n vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num)\n {\n   m_vecpfx.m_alloc = alloc;\n+  m_vecpfx.m_has_auto_buf = 0;\n   m_vecpfx.m_num = num;\n }\n \n@@ -1218,8 +1114,8 @@ gt_pch_nx (vec<T, A, vl_embed> *v, gt_pointer_operator op, void *cookie)\n    As long as we use C++03, we cannot have constructors nor\n    destructors in classes that are stored in unions.  */\n \n-template<typename T, typename A>\n-struct vec<T, A, vl_ptr>\n+template<typename T>\n+struct vec<T, va_heap, vl_ptr>\n {\n public:\n   /* Memory allocation and deallocation for the embedded vector.\n@@ -1284,23 +1180,39 @@ struct vec<T, A, vl_ptr>\n   void qsort (int (*) (const void *, const void *));\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n \n-  template<typename T1>\n-  friend void va_stack::alloc (vec<T1, va_stack, vl_ptr>&, unsigned,\n-\t\t\t       vec<T1, va_stack, vl_embed> *);\n+  bool using_auto_storage () const;\n \n   /* FIXME - This field should be private, but we need to cater to\n \t     compilers that have stricter notions of PODness for types.  */\n-  vec<T, A, vl_embed> *m_vec;\n+  vec<T, va_heap, vl_embed> *m_vec;\n };\n \n \n-/* Empty specialization for GC allocation.  This will prevent GC\n-   vectors from using the vl_ptr layout.  FIXME: This is needed to\n-   circumvent limitations in the GTY machinery.  */\n-\n-template<typename T>\n-struct vec<T, va_gc, vl_ptr>\n+/* stack_vec is a subclass of vec containing N elements of internal storage.\n+  You probably only want to allocate this on the stack because if the array\n+  ends up being larger or much smaller than N it will be wasting space. */\n+template<typename T, size_t N>\n+class stack_vec : public vec<T, va_heap>\n {\n+public:\n+  stack_vec ()\n+  {\n+    m_header.m_alloc = N;\n+    m_header.m_has_auto_buf = 1;\n+    m_header.m_num = 0;\n+    this->m_vec = reinterpret_cast<vec<T, va_heap, vl_embed> *> (&m_header);\n+  }\n+\n+  ~stack_vec ()\n+  {\n+    this->release ();\n+  }\n+\n+private:\n+  friend class vec<T, va_heap, vl_ptr>;\n+\n+  vec_prefix m_header;\n+  T m_data[N];\n };\n \n \n@@ -1343,55 +1255,16 @@ vec_free (vec<T> *&v)\n }\n \n \n-/* Allocate a new stack vector with space for exactly NELEMS objects.\n-   If NELEMS is zero, NO vector is created.\n-\n-   For the stack allocator, no memory is really allocated.  The vector\n-   is initialized to be at address SPACE and contain NELEMS slots.\n-   Memory allocation actually occurs in the expansion of VEC_alloc.\n-\n-   Usage notes:\n-\n-   * This does not allocate an instance of vec<T, A>.  It allocates the\n-     actual vector of elements (i.e., vec<T, A, vl_embed>) inside a\n-     vec<T, A> instance.\n-\n-   * This allocator must always be a macro:\n-\n-     We support a vector which starts out with space on the stack and\n-     switches to heap space when forced to reallocate.  This works a\n-     little differently.  In the case of stack vectors, vec_alloc will\n-     expand to a call to vec_alloc_1 that calls XALLOCAVAR to request\n-     the initial allocation.  This uses alloca to get the initial\n-     space. Since alloca can not be usefully called in an inline\n-     function, vec_alloc must always be a macro.\n-\n-     Important limitations of stack vectors:\n-\n-     - Only the initial allocation will be made using alloca, so pass\n-       a reasonable estimate that doesn't use too much stack space;\n-       don't pass zero.\n-\n-     - Don't return a stack-allocated vector from the function which\n-       allocated it.  */\n-\n-#define vec_stack_alloc(T,V,N)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    typedef vec<T, va_stack, vl_embed> stackv;\t\t\t\t\\\n-    va_stack::alloc (V, N, XALLOCAVAR (stackv, stackv::embedded_size (N)));\\\n-  } while (0)\n-\n-\n /* Return iteration condition and update PTR to point to the IX'th\n    element of this vector.  Use this to iterate over the elements of a\n    vector as follows,\n \n      for (ix = 0; v.iterate (ix, &ptr); ix++)\n        continue;  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline bool\n-vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const\n+vec<T, va_heap, vl_ptr>::iterate (unsigned ix, T *ptr) const\n {\n   if (m_vec)\n     return m_vec->iterate (ix, ptr);\n@@ -1412,9 +1285,9 @@ vec<T, A, vl_ptr>::iterate (unsigned ix, T *ptr) const\n \n    This variant is for vectors of objects.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline bool\n-vec<T, A, vl_ptr>::iterate (unsigned ix, T **ptr) const\n+vec<T, va_heap, vl_ptr>::iterate (unsigned ix, T **ptr) const\n {\n   if (m_vec)\n     return m_vec->iterate (ix, ptr);\n@@ -1451,11 +1324,11 @@ vec<T, A, vl_ptr>::iterate (unsigned ix, T **ptr) const\n \n /* Return a copy of this vector.  */\n \n-template<typename T, typename A>\n-inline vec<T, A, vl_ptr>\n-vec<T, A, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n+template<typename T>\n+inline vec<T, va_heap, vl_ptr>\n+vec<T, va_heap, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n {\n-  vec<T, A, vl_ptr> new_vec = vNULL;\n+  vec<T, va_heap, vl_ptr> new_vec = vNULL;\n   if (length ())\n     new_vec.m_vec = m_vec->copy ();\n   return new_vec;\n@@ -1471,14 +1344,34 @@ vec<T, A, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n    Note that this can cause the embedded vector to be reallocated.\n    Returns true iff reallocation actually occurred.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline bool\n-vec<T, A, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n-{\n-  bool extend = nelems ? !space (nelems) : false;\n-  if (extend)\n-    A::reserve (m_vec, nelems, exact PASS_MEM_STAT);\n-  return extend;\n+vec<T, va_heap, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n+{\n+  if (!nelems || space (nelems))\n+    return false;\n+\n+  /* For now play a game with va_heap::reserve to hide our auto storage if any,\n+     this is necessary because it doesn't have enough information to know the\n+     embedded vector is in auto storage, and so should not be freed.  */\n+  vec<T, va_heap, vl_embed> *oldvec = m_vec;\n+  unsigned int oldsize = 0;\n+  bool handle_auto_vec = m_vec && using_auto_storage ();\n+  if (handle_auto_vec)\n+    {\n+      m_vec = NULL;\n+      oldsize = oldvec->length ();\n+      nelems += oldsize;\n+    }\n+\n+  va_heap::reserve (m_vec, nelems, exact PASS_MEM_STAT);\n+  if (handle_auto_vec)\n+    {\n+      memcpy (m_vec->address (), oldvec->address (), sizeof (T) * oldsize);\n+      m_vec->m_vecpfx.m_num = oldsize;\n+    }\n+\n+  return true;\n }\n \n \n@@ -1487,9 +1380,9 @@ vec<T, A, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n    embedded vector to be reallocated.  Returns true iff reallocation\n    actually occurred.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline bool\n-vec<T, A, vl_ptr>::reserve_exact (unsigned nelems MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::reserve_exact (unsigned nelems MEM_STAT_DECL)\n {\n   return reserve (nelems, true PASS_MEM_STAT);\n }\n@@ -1500,9 +1393,9 @@ vec<T, A, vl_ptr>::reserve_exact (unsigned nelems MEM_STAT_DECL)\n    unconditionally allocated from scratch.  The old one, if it\n    existed, is lost.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::create (unsigned nelems MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::create (unsigned nelems MEM_STAT_DECL)\n {\n   m_vec = NULL;\n   if (nelems > 0)\n@@ -1512,23 +1405,30 @@ vec<T, A, vl_ptr>::create (unsigned nelems MEM_STAT_DECL)\n \n /* Free the memory occupied by the embedded vector.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::release (void)\n+vec<T, va_heap, vl_ptr>::release (void)\n {\n-  if (m_vec)\n-    A::release (m_vec);\n-}\n+  if (!m_vec)\n+    return;\n \n+  if (using_auto_storage ())\n+    {\n+      static_cast<stack_vec<T, 1> *> (this)->m_header.m_num = 0;\n+      return;\n+    }\n+\n+  va_heap::release (m_vec);\n+}\n \n /* Copy the elements from SRC to the end of this vector as if by memcpy.\n    SRC and this vector must be allocated with the same memory\n    allocation mechanism. This vector is assumed to have sufficient\n    headroom available.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::splice (vec<T, A, vl_ptr> &src)\n+vec<T, va_heap, vl_ptr>::splice (vec<T, va_heap, vl_ptr> &src)\n {\n   if (src.m_vec)\n     m_vec->splice (*(src.m_vec));\n@@ -1540,9 +1440,10 @@ vec<T, A, vl_ptr>::splice (vec<T, A, vl_ptr> &src)\n    If there is not enough headroom in this vector, it will be reallocated\n    as needed.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::safe_splice (vec<T, A, vl_ptr> &src MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::safe_splice (vec<T, va_heap, vl_ptr> &src\n+\t\t\t\t      MEM_STAT_DECL)\n {\n   if (src.length ())\n     {\n@@ -1556,9 +1457,9 @@ vec<T, A, vl_ptr>::safe_splice (vec<T, A, vl_ptr> &src MEM_STAT_DECL)\n    sufficient space in the vector.  Return a pointer to the slot\n    where OBJ was inserted.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline T *\n-vec<T, A, vl_ptr>::quick_push (const T &obj)\n+vec<T, va_heap, vl_ptr>::quick_push (const T &obj)\n {\n   return m_vec->quick_push (obj);\n }\n@@ -1568,9 +1469,9 @@ vec<T, A, vl_ptr>::quick_push (const T &obj)\n    the embedded vector, if needed.  Return a pointer to the slot where\n    OBJ was inserted.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline T *\n-vec<T, A, vl_ptr>::safe_push (const T &obj MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::safe_push (const T &obj MEM_STAT_DECL)\n {\n   reserve (1, false PASS_MEM_STAT);\n   return quick_push (obj);\n@@ -1579,9 +1480,9 @@ vec<T, A, vl_ptr>::safe_push (const T &obj MEM_STAT_DECL)\n \n /* Pop and return the last element off the end of the vector.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline T &\n-vec<T, A, vl_ptr>::pop (void)\n+vec<T, va_heap, vl_ptr>::pop (void)\n {\n   return m_vec->pop ();\n }\n@@ -1590,9 +1491,9 @@ vec<T, A, vl_ptr>::pop (void)\n /* Set the length of the vector to LEN.  The new length must be less\n    than or equal to the current length.  This is an O(1) operation.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::truncate (unsigned size)\n+vec<T, va_heap, vl_ptr>::truncate (unsigned size)\n {\n   if (m_vec)\n     m_vec->truncate (size);\n@@ -1605,9 +1506,9 @@ vec<T, A, vl_ptr>::truncate (unsigned size)\n    longer than the current length.  The new elements are\n    uninitialized.  Reallocate the internal vector, if needed.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::safe_grow (unsigned len MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::safe_grow (unsigned len MEM_STAT_DECL)\n {\n   unsigned oldlen = length ();\n   gcc_checking_assert (oldlen <= len);\n@@ -1620,9 +1521,9 @@ vec<T, A, vl_ptr>::safe_grow (unsigned len MEM_STAT_DECL)\n    long or longer than the current length.  The new elements are\n    initialized to zero.  Reallocate the internal vector, if needed.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::safe_grow_cleared (unsigned len MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::safe_grow_cleared (unsigned len MEM_STAT_DECL)\n {\n   unsigned oldlen = length ();\n   safe_grow (len PASS_MEM_STAT);\n@@ -1633,9 +1534,9 @@ vec<T, A, vl_ptr>::safe_grow_cleared (unsigned len MEM_STAT_DECL)\n /* Same as vec::safe_grow but without reallocation of the internal vector.\n    If the vector cannot be extended, a runtime assertion will be triggered.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::quick_grow (unsigned len)\n+vec<T, va_heap, vl_ptr>::quick_grow (unsigned len)\n {\n   gcc_checking_assert (m_vec);\n   m_vec->quick_grow (len);\n@@ -1646,9 +1547,9 @@ vec<T, A, vl_ptr>::quick_grow (unsigned len)\n    internal vector. If the vector cannot be extended, a runtime\n    assertion will be triggered.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::quick_grow_cleared (unsigned len)\n+vec<T, va_heap, vl_ptr>::quick_grow_cleared (unsigned len)\n {\n   gcc_checking_assert (m_vec);\n   m_vec->quick_grow_cleared (len);\n@@ -1658,9 +1559,9 @@ vec<T, A, vl_ptr>::quick_grow_cleared (unsigned len)\n /* Insert an element, OBJ, at the IXth position of this vector.  There\n    must be sufficient space.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::quick_insert (unsigned ix, const T &obj)\n+vec<T, va_heap, vl_ptr>::quick_insert (unsigned ix, const T &obj)\n {\n   m_vec->quick_insert (ix, obj);\n }\n@@ -1669,9 +1570,9 @@ vec<T, A, vl_ptr>::quick_insert (unsigned ix, const T &obj)\n /* Insert an element, OBJ, at the IXth position of the vector.\n    Reallocate the embedded vector, if necessary.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::safe_insert (unsigned ix, const T &obj MEM_STAT_DECL)\n+vec<T, va_heap, vl_ptr>::safe_insert (unsigned ix, const T &obj MEM_STAT_DECL)\n {\n   reserve (1, false PASS_MEM_STAT);\n   quick_insert (ix, obj);\n@@ -1682,9 +1583,9 @@ vec<T, A, vl_ptr>::safe_insert (unsigned ix, const T &obj MEM_STAT_DECL)\n    remaining elements is preserved.  This is an O(N) operation due to\n    a memmove.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::ordered_remove (unsigned ix)\n+vec<T, va_heap, vl_ptr>::ordered_remove (unsigned ix)\n {\n   m_vec->ordered_remove (ix);\n }\n@@ -1693,9 +1594,9 @@ vec<T, A, vl_ptr>::ordered_remove (unsigned ix)\n /* Remove an element from the IXth position of this vector.  Ordering\n    of remaining elements is destroyed.  This is an O(1) operation.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::unordered_remove (unsigned ix)\n+vec<T, va_heap, vl_ptr>::unordered_remove (unsigned ix)\n {\n   m_vec->unordered_remove (ix);\n }\n@@ -1704,9 +1605,9 @@ vec<T, A, vl_ptr>::unordered_remove (unsigned ix)\n /* Remove LEN elements starting at the IXth.  Ordering is retained.\n    This is an O(N) operation due to memmove.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::block_remove (unsigned ix, unsigned len)\n+vec<T, va_heap, vl_ptr>::block_remove (unsigned ix, unsigned len)\n {\n   m_vec->block_remove (ix, len);\n }\n@@ -1715,9 +1616,9 @@ vec<T, A, vl_ptr>::block_remove (unsigned ix, unsigned len)\n /* Sort the contents of this vector with qsort.  CMP is the comparison\n    function to pass to qsort.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline void\n-vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n+vec<T, va_heap, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n {\n   if (m_vec)\n     m_vec->qsort (cmp);\n@@ -1729,14 +1630,27 @@ vec<T, A, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n    function that returns true if the first argument is strictly less\n    than the second.  */\n \n-template<typename T, typename A>\n+template<typename T>\n inline unsigned\n-vec<T, A, vl_ptr>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n+vec<T, va_heap, vl_ptr>::lower_bound (T obj,\n+\t\t\t\t      bool (*lessthan)(const T &, const T &))\n     const\n {\n   return m_vec ? m_vec->lower_bound (obj, lessthan) : 0;\n }\n \n+template<typename T>\n+inline bool\n+vec<T, va_heap, vl_ptr>::using_auto_storage () const\n+{\n+  if (!m_vec->m_vecpfx.m_has_auto_buf)\n+    return false;\n+\n+  const vec_prefix *auto_header\n+    = &static_cast<const stack_vec<T, 1> *> (this)->m_header;\n+  return reinterpret_cast<vec_prefix *> (m_vec) == auto_header;\n+}\n+\n #if (GCC_VERSION >= 3000)\n # pragma GCC poison m_vec m_vecpfx m_vecdata\n #endif"}]}