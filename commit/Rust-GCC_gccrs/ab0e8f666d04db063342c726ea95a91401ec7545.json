{"sha": "ab0e8f666d04db063342c726ea95a91401ec7545", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwZThmNjY2ZDA0ZGIwNjMzNDJjNzI2ZWE5NWE5MTQwMWVjNzU0NQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-05T16:44:17Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-05T16:44:17Z"}, "message": "fold-const.c (fold): Optimize unsigned modulus by a power of two into a bit-wise AND, i.e.\n\n\n\t* fold-const.c (fold) <TRUNC_MOD_EXPR>: Optimize unsigned modulus\n\tby a power of two into a bit-wise AND, i.e. \"X % C\" as \"X & (C-1)\".\n\tNormalize \"X % C\" as \"X % -C\" for signed modulus and negative C.\n\tOptimize \"X % -Y\" as \"X % Y\" for signed modulus.\n\t<EQ_EXPR>: Recursively call \"fold\" when transforming \"(X % Y) == 0\"\n\tinto \"((unsigned) X % Y) == 0\".\n\nFrom-SVN: r84122", "tree": {"sha": "8295df6654e3966bffcbd5af16d6026cf42c98c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8295df6654e3966bffcbd5af16d6026cf42c98c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab0e8f666d04db063342c726ea95a91401ec7545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0e8f666d04db063342c726ea95a91401ec7545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0e8f666d04db063342c726ea95a91401ec7545", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0e8f666d04db063342c726ea95a91401ec7545/comments", "author": null, "committer": null, "parents": [{"sha": "48eb4e53cdecda5736763287719b422e58c1058f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48eb4e53cdecda5736763287719b422e58c1058f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48eb4e53cdecda5736763287719b422e58c1058f"}], "stats": {"total": 71, "additions": 64, "deletions": 7}, "files": [{"sha": "e6d474f43cc852f1e46e68545ced35b515d5ed79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e8f666d04db063342c726ea95a91401ec7545/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e8f666d04db063342c726ea95a91401ec7545/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab0e8f666d04db063342c726ea95a91401ec7545", "patch": "@@ -1,3 +1,12 @@\n+2004-07-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold) <TRUNC_MOD_EXPR>: Optimize unsigned modulus\n+\tby a power of two into a bit-wise AND, i.e. \"X % C\" as \"X & (C-1)\".\n+\tNormalize \"X % C\" as \"X % -C\" for signed modulus and negative C.\n+\tOptimize \"X % -Y\" as \"X % Y\" for signed modulus.\n+\t<EQ_EXPR>: Recursively call \"fold\" when transforming \"(X % Y) == 0\"\n+\tinto \"((unsigned) X % Y) == 0\".\n+\n 2004-07-05  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* sourcebuild.texi (Config Fragments): Use @comma{} in"}, {"sha": "38547777ca09c387b0db9647ce000be8f5064486", "filename": "gcc/fold-const.c", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e8f666d04db063342c726ea95a91401ec7545/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e8f666d04db063342c726ea95a91401ec7545/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ab0e8f666d04db063342c726ea95a91401ec7545", "patch": "@@ -7538,13 +7538,60 @@ fold (tree expr)\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n       if (integer_zerop (arg1))\n \treturn t;\n+\n       /* X % -1 is zero.  */\n       if (!TYPE_UNSIGNED (type)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_INT_CST_LOW (arg1) == (unsigned HOST_WIDE_INT) -1\n \t  && TREE_INT_CST_HIGH (arg1) == -1)\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n \n+      /* Optimize unsigned TRUNC_MOD_EXPR by a power of two into a\n+\t BIT_AND_EXPR, i.e. \"X % C\" into \"X & C2\".  */\n+      if (code == TRUNC_MOD_EXPR\n+\t  && TYPE_UNSIGNED (type)\n+\t  && integer_pow2p (arg1))\n+\t{\n+\t  unsigned HOST_WIDE_INT high, low;\n+\t  tree mask;\n+\t  int l;\n+\n+\t  l = tree_log2 (arg1);\n+\t  if (l >= HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      high = ((unsigned HOST_WIDE_INT) 1\n+\t\t      << (l - HOST_BITS_PER_WIDE_INT)) - 1;\n+\t      low = -1;\n+\t    }\n+\t  else\n+\t    {\n+\t      high = 0;\n+\t      low = ((unsigned HOST_WIDE_INT) 1 << l) - 1;\n+\t    }\n+\n+\t  mask = build_int_2 (low, high);\n+\t  TREE_TYPE (mask) = type;\n+\t  return fold (build2 (BIT_AND_EXPR, type,\n+\t\t\t       fold_convert (type, arg0), mask));\n+\t}\n+\n+      /* X % -C is the same as X % C (for all rounding moduli).  */\n+      if (!TYPE_UNSIGNED (type)\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_INT_CST_HIGH (arg1) < 0\n+\t  && !flag_trapv\n+\t  /* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */\n+\t  && !sign_bit_p (arg1, arg1))\n+\treturn fold (build2 (code, type, fold_convert (type, arg0),\n+\t\t\t     fold_convert (type, negate_expr (arg1))));\n+\n+      /* X % -Y is the same as X % Y (for all rounding moduli).  */\n+      if (!TYPE_UNSIGNED (type)\n+\t  && TREE_CODE (arg1) == NEGATE_EXPR\n+\t  && !flag_trapv)\n+\treturn fold (build2 (code, type, fold_convert (type, arg0),\n+\t\t\t     fold_convert (type, TREE_OPERAND (arg1, 0))));\n+\n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n \t\t\t\t\t code, NULL_TREE)))\n@@ -8268,13 +8315,14 @@ fold (tree expr)\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n \t{\n \t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n-\t  tree newmod = build2 (TREE_CODE (arg0), newtype,\n-\t\t\t\tfold_convert (newtype,\n-\t\t\t\t\t      TREE_OPERAND (arg0, 0)),\n-\t\t\t\tfold_convert (newtype,\n-\t\t\t\t\t      TREE_OPERAND (arg0, 1)));\n-\n-\t  return build2 (code, type, newmod, fold_convert (newtype, arg1));\n+\t  tree newmod = fold (build2 (TREE_CODE (arg0), newtype,\n+\t\t\t\t      fold_convert (newtype,\n+\t\t\t\t\t\t    TREE_OPERAND (arg0, 0)),\n+\t\t\t\t      fold_convert (newtype,\n+\t\t\t\t\t\t    TREE_OPERAND (arg0, 1))));\n+\n+\t  return fold (build2 (code, type, newmod,\n+\t\t\t       fold_convert (newtype, arg1)));\n \t}\n \n       /* If this is an NE comparison of zero with an AND of one, remove the"}]}