{"sha": "2b1a40704643808e702356fe13a267664317dd5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxYTQwNzA0NjQzODA4ZTcwMjM1NmZlMTNhMjY3NjY0MzE3ZGQ1ZQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@nerim.net", "date": "2002-08-02T13:51:46Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-08-02T13:51:46Z"}, "message": "valarray_meta.h (__unary_plus, [...]): New function object classes.\n\n\t* include/bits/valarray_meta.h (__unary_plus, __negate,\n\t__bitwise_not, __plus, __minus, __multiplies, __divides,\n\t__modulus, __bitwise_xor, __bitwise_or, __bitwise_and,\n\t__shift_left, __shift_right, __logical_and, __logical_or,\n\t__logical_not, __equal_to, __not_equal_to, __less, __less_equal,\n\t__greater_equal, __greater, __atan2, __pow): New function object\n\tclasses.\n\t(__fun<>):  New function traits class.\n\nFrom-SVN: r55985", "tree": {"sha": "34d7ac1ca5bfbf5be859a5f65d06037276ee5190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34d7ac1ca5bfbf5be859a5f65d06037276ee5190"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b1a40704643808e702356fe13a267664317dd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1a40704643808e702356fe13a267664317dd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1a40704643808e702356fe13a267664317dd5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1a40704643808e702356fe13a267664317dd5e/comments", "author": null, "committer": null, "parents": [{"sha": "a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a77a9a18c058d41eeb634e6c6a6f56d9bae04d55"}], "stats": {"total": 245, "additions": 245, "deletions": 0}, "files": [{"sha": "b331fff850019b5d8acd07af7d577a31ca5977f6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1a40704643808e702356fe13a267664317dd5e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1a40704643808e702356fe13a267664317dd5e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2b1a40704643808e702356fe13a267664317dd5e", "patch": "@@ -1,3 +1,14 @@\n+2002-08-02  Gabriel Dos Reis  <gdr@nerim.net>\n+\n+\t* include/bits/valarray_meta.h (__unary_plus, __negate,\n+\t__bitwise_not, __plus, __minus, __multiplies, __divides,\n+\t__modulus, __bitwise_xor, __bitwise_or, __bitwise_and,\n+\t__shift_left, __shift_right, __logical_and, __logical_or,\n+\t__logical_not, __equal_to, __not_equal_to, __less, __less_equal,\n+\t__greater_equal, __greater, __atan2, __pow): New function object\n+\tclasses. \n+\t(__fun<>):  New function traits class.\n+\n 2002-08-01  Rick Danos  <rdanos@hotmail.com>\n \n \tPR libstdc++/7461"}, {"sha": "d5e758f6d9ab2287f454e0e6952558b2fd2d96fe", "filename": "libstdc++-v3/include/bits/valarray_meta.h", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1a40704643808e702356fe13a267664317dd5e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1a40704643808e702356fe13a267664317dd5e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h?ref=2b1a40704643808e702356fe13a267664317dd5e", "patch": "@@ -165,6 +165,240 @@ namespace std\n       _Tp operator()(const _Tp& __t) const { return sqrt(__t); }\n   };\n \n+  // In the past, we used to tailor operator applications semantics\n+  // to the specialization of standard function objects (i.e. plus<>, etc.)\n+  // That is incorrect.  Therefore we provide our own surrogates.\n+\n+  struct __unary_plus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return +__t; }\n+  };\n+\n+  struct __negate\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return -__t; }\n+  };\n+\n+  struct __bitwise_not\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return ~__t; }\n+  };\n+\n+  struct __plus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x + __y; }\n+  };\n+\n+  struct __minus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x - __y; }\n+  };\n+\n+  struct __multiplies\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x * __y; }\n+  };\n+\n+  struct __divides\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x / __y; }\n+  };\n+\n+  struct __modulus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x % __y; }\n+  };\n+\n+  struct __bitwise_xor\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x ^ __y; }\n+  };\n+\n+  struct __bitwise_and\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x & __y; }\n+  };\n+\n+  struct __bitwise_or\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x | __y; }\n+  };\n+\n+  struct __shift__left\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x << __y; }\n+  };\n+\n+  struct __shift_right\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x >> __y; }\n+  };\n+\n+  struct __logical_and\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x && __y; }\n+  };\n+\n+  struct __logical_or\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x || __y; }\n+  };\n+\n+  struct __logical_not\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x) const { return !__x; }\n+  };\n+\n+  struct __equal_to\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x == __y; }\n+  };\n+\n+  struct __not_equal_to\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x == __y; }\n+  };\n+\n+  struct __less\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x < __y; }\n+  };\n+\n+  struct __greater\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x > __y; }\n+  };\n+\n+  struct __less_equal\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x <= __y; }\n+  };\n+\n+  struct __greater_equal\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x >= __y; }\n+  };\n+\n+  // The few binary functions we miss.\n+  struct __atan2\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return atan2(__x, __y); }\n+  };\n+\n+  struct __pow\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return pow(__x, __y); }\n+  };\n+\n+\n+  // We need these bits in order to recover the return type of\n+  // some functions/operators now that we're no longer using\n+  // function templates.\n+  template<typename, typename _Tp>\n+    struct __fun\n+    {\n+      typedef _Tp result_type;\n+    };\n+\n+  // several specializations for relational operators.\n+  template<typename _Tp>\n+    struct __fun<__logical_not, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__logical_and, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__logical_or, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__less, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__greater, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__less_equal, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__greater_equal, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__equal_to, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__not_equal_to, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n   template<template<class, class> class _Meta, class _Dom, typename _Op>\n     class _UnFunClos;\n     "}]}