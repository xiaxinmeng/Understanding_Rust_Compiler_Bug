{"sha": "fee0225a383cdc396a720a2a8639d4fb99e7f084", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVlMDIyNWEzODNjZGMzOTZhNzIwYTJhODYzOWQ0ZmI5OWU3ZjA4NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-04T03:08:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-04T03:08:50Z"}, "message": "configure.in (ia64-linux): Add ia64/t-glibc.\n\n\t* configure.in (ia64-linux) [tmake_file]: Add ia64/t-glibc.\n\t* config/ia64/crtbegin.asm (__EH_FRAME_BEGIN__): Remove.\n\t(segrel_ofs): Remove.\n\t(__ia64_app_header): New.\n\t(frame_object): Remove.\n\t(.init): Set __ia64_app_header when non-shared.\n\t(__do_global_dtors_aux): Do not call __deregister_frame_info.\n\t(__do_frame_setup): Remove.\n\t* config/ia64/crtend.asm (__EH_FRAME_END__): Remove.\n\t(__do_frame_setup_aux): Remove.\n\t* config/ia64/frame-ia64.c (object_mutex): Remove.\n\t(bad_record): Remove.\n\t(init_object_mutex): Remove.\n\t(init_object_mutex_once): Remove.\n\t(fde_compare): Remove.\n\t(__register_frame_info_aux): Remove.\n\t(frame_init): Remove.\n\t(find_fde): Remove.\n\t(*): Use ISO function definitions.\n\t(P3_record_types): Constify.\n\t(P7_record_types, P7_additional_fields): Constify.\n\t(P8_record_types, P8_additional_fields): Constify.\n\t(read_P_record): Remove parenthesis warning.  Use structure\n\tassignment instead of memcpy.\n\t(execute_one_ia64_descriptor): Likewise.\n\t(__build_ia64_frame_state): Use __ia64_find_fde.\n\t(record_name, print_record, print_all_records): Remove.\n\t* config/ia64/frame-ia64.h: New file.\n\t* config/ia64/fde-glibc.c: New file.\n\t* config/ia64/t-glibc: New file.\n\nFrom-SVN: r36705", "tree": {"sha": "670b15daaad2d99fa60833fe8b45cc2f759a4318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/670b15daaad2d99fa60833fe8b45cc2f759a4318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fee0225a383cdc396a720a2a8639d4fb99e7f084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee0225a383cdc396a720a2a8639d4fb99e7f084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee0225a383cdc396a720a2a8639d4fb99e7f084", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee0225a383cdc396a720a2a8639d4fb99e7f084/comments", "author": null, "committer": null, "parents": [{"sha": "7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e51098e709b1248a2334b7a19b6d27e6ce88cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e51098e709b1248a2334b7a19b6d27e6ce88cfc"}], "stats": {"total": 939, "additions": 285, "deletions": 654}, "files": [{"sha": "1b57a99316c687345a54b4ca950b994495b24b40", "filename": "gcc/config/ia64/crtbegin.asm", "status": "modified", "additions": 19, "deletions": 112, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -26,20 +26,19 @@ __CTOR_LIST__:\n __DTOR_LIST__:\n \tdata8\t-1\n \n-.section .IA_64.unwind\n-\t.align\t8\n-__EH_FRAME_BEGIN__:\n-\n .section .sdata\n \t.type dtor_ptr#,@object\n \t.size dtor_ptr#,8\n dtor_ptr:\n \tdata8\t__DTOR_LIST__# + 8\n \n-\t.type segrel_ofs#,@object\n-\t.size segrel_ofs#,8\n-segrel_ofs:\n+#ifndef SHARED\n+\t.type __ia64_app_header#,@object\n+\t.size __ia64_app_header#,8\n+\t.global __ia64_app_header\n+__ia64_app_header:\n \tdata8\t@segrel(.Lsegrel_ref#)\n+#endif\n \n \t/* A handle for __cxa_finalize to manage c++ local destructors.  */\n \t.global __dso_handle#\n@@ -56,14 +55,6 @@ __dso_handle:\n #endif\n \t.hidden __dso_handle#\n \n-\t/* The frame object.  */\n-\t/* ??? How can we rationally keep this size correct?  */\n-.section .bss\n-\t.type frame_object#,@object\n-\t.size frame_object#,64\n-\t.align 8\n-frame_object:\n-\t.zero 64\n \n /*\n  * Fragment of the ELF _fini routine that invokes our dtor cleanup.\n@@ -94,25 +85,28 @@ frame_object:\n \t  ;;\n \t}\n \n+#ifndef SHARED\n /*\n- * Fragment of the ELF _init routine that sets up the frame info.\n+ * Fragment of the ELF _init routine that sets up __ia64_app_header\n  */\n \n .section .init,\"ax\",\"progbits\"\n-\t{ .mlx\n-\t  movl r2 = @gprel(__do_frame_setup#)\n+.Lsegrel_ref:\n+\t{ .mmi\n+\t  addl r2 = @gprel(__ia64_app_header), gp\n+\t  mov r16 = ip\n \t  ;;\n \t}\n-\t{ .mii\n-\t  nop.m 0\n-\t  add r2 = r2, gp\n+\t{ .mmi\n+\t  ld8 r3 = [r2]\n \t  ;;\n-\t  mov b6 = r2\n-\t}\n-\t{ .bbb\n-\t  br.call.sptk.many b0 = b6\n+\t  sub r16 = r16, r3\n \t  ;;\n \t}\n+\t{ .mfb\n+\t  st8 [r2] = r16\n+\t}\n+#endif\n \n .section .text\n \t.align\t16\n@@ -193,33 +187,6 @@ __do_global_dtors_aux:\n \t{ .mfb\n \t  cmp.ne p6, p0 = r0, r16\n (p6)\t  br.cond.sptk.few 0b\n-\t}\n-\t/*\n-\t\tif (__deregister_frame_info)\n-\t\t  __deregister_frame_info(__EH_FRAME_BEGIN__)\n-\t*/\n-\t{ .mmi\n-\t  mov gp = loc2\n-\t  ;;\n-\t  addl r16 = @ltoff(@fptr(__deregister_frame_info#)), gp\n-\t  addl out0 = @ltoff(__EH_FRAME_BEGIN__#), gp\n-\t  ;;\n-\t}\n-\t{ .mmi\n-\t  ld8 r16 = [r16]\n-\t  ld8 out0 = [out0]\n-\t  ;;\n-\t}\n-\t{ .mmi\n-\t  cmp.ne p7, p0 = r0, r16\n-\t  ;;\n-(p7)\t  ld8 r18 = [r16], 8\n-\t  ;;\n-\t}\n-\t{ .mib\n-(p7)\t  ld8 gp = [r16]\n-(p7)\t  mov b6 = r18\n-(p7)\t  br.call.sptk.many b0 = b6\n \t}\n \t{ .mii\n \t  mov gp = loc2\n@@ -232,66 +199,6 @@ __do_global_dtors_aux:\n \t}\n \t.endp\t__do_global_dtors_aux#\n \n-\t.proc\t__do_frame_setup#\n-__do_frame_setup:\n-\t/*\n-\t\tif (__register_frame_info)\n-\t\t  __register_frame_info(__EH_FRAME_BEGIN__)\n-\t*/\n-\t{ .mii\n-\t  alloc loc2 = ar.pfs, 0, 3, 2, 0\n-\t  addl r16 = @ltoff(@fptr(__register_frame_info#)), gp\n-\t  addl out0 = @ltoff(__EH_FRAME_BEGIN__#), gp\n-\t}\n-\t/* frame_object.pc_base = segment_base_offset;\n-\t   pc_base is at offset 0 within frame_object.  */\n-.Lsegrel_ref:\n-\t{ .mmi\n-\t  addl out1 = @ltoff(frame_object#), gp\n-\t  ;;\n-\t  addl r2 = @gprel(segrel_ofs#), gp\n-\t  mov r3 = ip\n-\t  ;;\n-\t}\n-\t{ .mmi\n-\t  ld8 r2 = [r2]\n-\t  ld8 r16 = [r16]\n-\t  mov loc0 = b0\n-\t  ;;\n-\t}\n-\t{ .mii\n-\t  ld8 out1 = [out1]\n-\t  cmp.ne p7, p0 = r0, r16\n-\t  sub r3 = r3, r2\n-\t  ;;\n-\t}\n-\t{ .mmi\n-\t  st8 [out1] = r3 \n-(p7)\t  ld8 r18 = [r16], 8\n-\t  mov loc1 = gp\n-\t  ;;\n-\t}\n-\t{ .mfb\n-\t  ld8 out0 = [out0]  \n-\t}\n-\t{ .mib\n-(p7)\t  ld8 gp = [r16]\n-(p7)\t  mov b6 = r18\n-(p7)\t  br.call.sptk.many b0 = b6\n-\t}\n-\t{ .mii\n-\t  mov gp = loc1\n-\t  mov b0 = loc0\n-\t  mov ar.pfs = loc2\n-\t}\n-\t{ .bbb\n-\t  br.ret.sptk.many b0\n-\t  ;;\n-\t}\n-\t.endp\t__do_frame_setup#\n-\n #ifdef SHARED\n .weak __cxa_finalize#\n #endif\n-.weak __deregister_frame_info#\n-.weak __register_frame_info#"}, {"sha": "81f90198fb61fcac3918131e13d0039d3b557010", "filename": "gcc/config/ia64/crtend.asm", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtend.asm?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -26,9 +26,6 @@ __CTOR_END__:\n __DTOR_END__:\n \tdata8\t0\n \n-.section .IA_64.unwind\n-__EH_FRAME_END__:\n-\n /*\n  * Fragment of the ELF _init routine that invokes our dtor cleanup.\n  *\n@@ -110,54 +107,3 @@ __do_global_ctors_aux:\n \t  ;;\n \t}\n \t.endp __do_global_ctors_aux#\n-\n-.section .init,\"ax\",\"progbits\"\n-\t{ .mlx\n-\t  movl r2 = @gprel(__do_frame_setup_aux#)\n-\t  ;;\n-\t}\n-\t{ .mii\n-\t  nop.m 0\n-\t  add r2 = r2, gp\n-\t  ;;\n-\t  mov b6 = r2\n-\t}\n-\t{ .bbb\n-\t  br.call.sptk.many b0 = b6\n-\t  ;;\n-        }\n-\n-.text\n-\t.align 16\n-\t.proc\t__do_frame_setup_aux#\n-__do_frame_setup_aux:\n-\t/*\n-\t\tif (__register_frame_info_aux)\n-\t\t  __register_frame_info_aux(__EH_FRAME_END__)\n-\t*/\n-\talloc loc0 = ar.pfs, 0, 3, 1, 0\n-\taddl r14 = @ltoff(@fptr(__register_frame_info_aux#)), gp\n-\tmov loc1 = b0\n-\t;;\n-\tld8 r15 = [r14]\n-\taddl r16 = @ltoff(__EH_FRAME_END__#), gp\n-\tmov loc2 = gp\n-\t;;\n-\tcmp.eq p6, p7 = 0, r15\n-\t(p6) br.cond.dptk 1f\n-\tld8 r8 = [r15], 8\n-\tld8 out0 = [r16]\n-\t;;\n-\tld8 gp = [r15]\n-\tmov b6 = r8\n-\t;;\n-\tbr.call.sptk.many b0 = b6\n-\t;;\n-1:\n-\tmov gp = loc2\n-\tmov ar.pfs = loc0\n-\tmov b0 = loc1\n-\tbr.ret.sptk.many b0\n-\t.endp\t__do_frame_setup_aux#\n-\n-.weak __register_frame_info_aux#"}, {"sha": "094849562055b62f429cbeb4192ec0a73492ad66", "filename": "gcc/config/ia64/fde-glibc.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ffde-glibc.c?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -0,0 +1,141 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@cygnus.com>.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* Locate the FDE entry for a given address, using glibc ld.so routines\n+   to avoid register/deregister calls at DSO load/unload.  */\n+\n+#include <stdlib.h>\n+#include <link.h>\n+#include <bits/libc-lock.h>\n+#include \"frame-ia64.h\"\n+\n+\n+/* Initialized by crtbegin from the main application.  */\n+extern Elf64_Ehdr *__ia64_app_header;\n+\n+/* ??? A redeclaration of the lock in ld.so.  Perhaps this should\n+   appear in <link.h> in a new glibc version.  */\n+__libc_lock_define (extern, _dl_load_lock)\n+\n+/* ??? _dl_load_lock is not exported from glibc 2.1, but it is \n+   from glibc 2.2.  Remove this when folks have migrated.  */\n+#pragma weak _dl_load_lock\n+\n+/* This always exists, even in a static application.  */\n+extern struct link_map *_dl_loaded;\n+\n+static fde *\n+find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr)\n+{\n+  Elf64_Phdr *phdr, *p_unwind;\n+  long n, match;\n+  Elf64_Addr load_base, seg_base;\n+  fde *f;\n+\n+  /* Verify that we are looking at an ELF header.  */\n+  if (ehdr->e_ident[0] != 0x7f\n+      || ehdr->e_ident[1] != 'E'\n+      || ehdr->e_ident[2] != 'L'\n+      || ehdr->e_ident[3] != 'F'\n+      || ehdr->e_ident[EI_CLASS] != ELFCLASS64\n+      || ehdr->e_ident[EI_DATA] != ELFDATA2LSB\n+      || ehdr->e_machine != EM_IA_64)\n+    abort ();\n+\n+  match = 0;\n+  phdr = (Elf64_Phdr *)((char *)ehdr + ehdr->e_phoff);\n+  load_base = (ehdr->e_type == ET_DYN ? (Elf64_Addr)ehdr : 0);\n+  p_unwind = NULL;\n+\n+  /* See if PC falls into one of the loaded segments.  Find the unwind\n+     segment at the same time.  */\n+  for (n = ehdr->e_phnum; --n >= 0; phdr++)\n+    {\n+      if (phdr->p_type == PT_LOAD)\n+\t{\n+\t  Elf64_Addr vaddr = phdr->p_vaddr + load_base;\n+\t  if (pc >= vaddr && pc < vaddr + phdr->p_memsz)\n+\t    match = 1;\n+\t}\n+      else if (phdr->p_type == PT_IA_64_UNWIND)\n+\tp_unwind = phdr;\n+    }\n+  if (!match || !p_unwind)\n+    return NULL;\n+\n+  /* Search for the FDE within the unwind segment.  */\n+  /* ??? Ideally ld would have sorted this for us by address.  Until\n+     that's fixed, we must do a linear search.  */\n+\n+  f = (fde *) (p_unwind->p_vaddr + load_base);\n+  seg_base = (Elf64_Addr) ehdr;\n+  for (n = p_unwind->p_memsz / sizeof (fde); --n >= 0; ++f)\n+    if (pc >= f->start_offset + seg_base && pc < f->end_offset + seg_base)\n+      return f;\n+\n+  return NULL;\n+}\n+\n+/* Return a pointer to the FDE for the function containing PC.  */\n+fde *\n+__ia64_find_fde (void *pc, void **pc_base)\n+{\n+  fde *ret;\n+  struct link_map *map;\n+\n+  /* Check the main application first, hoping that most of the user's\n+     code is there instead of in some library.  */\n+  ret = find_fde_for_dso ((Elf64_Addr)pc, __ia64_app_header);\n+  if (ret)\n+    {\n+      *pc_base = __ia64_app_header;\n+      return ret;\n+    }\n+\n+  /* Glibc is probably unique in that we can (with certain restrictions)\n+     dynamicly load libraries into staticly linked applications.  Thus\n+     we _always_ check _dl_loaded.  */\n+\n+  if (&_dl_load_lock)\n+    __libc_lock_lock (_dl_load_lock);\n+\n+  for (map = _dl_loaded; map ; map = map->l_next)\n+    {\n+      /* Skip the main application's entry.  */\n+      if (map->l_name[0] == 0)\n+\tcontinue;\n+      ret = find_fde_for_dso ((Elf64_Addr)pc, (Elf64_Ehdr *)map->l_addr);\n+      if (ret)\n+\tbreak;\n+    }\n+\n+  if (&_dl_load_lock)\n+    __libc_lock_unlock (_dl_load_lock);\n+\n+  *pc_base = (void *)(map ? map->l_addr : 0);\n+  return ret;\n+}"}, {"sha": "cd0f21c888e922bfaa4ad11f27be70ea3abcd6be", "filename": "gcc/config/ia64/frame-ia64.c", "status": "modified", "additions": 86, "deletions": 486, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fframe-ia64.c?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -40,32 +40,14 @@ Boston, MA 02111-1307, USA.  */\n /* ??? This is not a good solution, since prototypes may be required in\n    some cases for correct code.  See also libgcc2.c/crtstuff.c.  */\n #ifndef inhibit_libc\n-/* fixproto guarantees these system headers exist. */\n #include <stdlib.h>\n #include <unistd.h>\n-\n #else\n #include <stddef.h>\n-#ifndef malloc\n-extern void *malloc (size_t);\n-#endif\n-#ifndef free\n-extern void free (void *);\n-#endif\n #endif\n \n #include \"defaults.h\"\n-#include \"gthr.h\"\n-\n-/* Define a mutex for frame information modification. */\n-#ifdef __GTHREAD_MUTEX_INIT\n-static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n-#else\n-static __gthread_mutex_t object_mutex;\n-#endif\n-\n-/* This is undefined below if we need it to be an actual function.  */\n-#define init_object_mutex_once()\n+#include \"frame-ia64.h\"\n \n /* Some types used by the DWARF 2 spec.  */\n \n@@ -75,141 +57,8 @@ typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n typedef          int  saddr __attribute__ ((mode (pointer)));\n typedef unsigned char ubyte;\n \n-static void bad_record (unsigned char*, int) __attribute__ ((__noreturn__));\n-\n-#if __GTHREADS\n-#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n-\n-/* Helper for init_object_mutex_once.  */\n-\n-static void\n-init_object_mutex (void)\n-{\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n-}\n-\n-/* Call this to arrange to initialize the object mutex.  */\n-\n-#undef init_object_mutex_once\n-static void\n-init_object_mutex_once (void)\n-{\n-  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-  __gthread_once (&once, init_object_mutex);\n-}\n-\n-#endif /* __GTHREAD_MUTEX_INIT_FUNCTION */\n-#endif /* __GTHREADS */\n-\n-/* This structure represents a single unwind table entry.  We lie and say\n-   its the dwarf_fde structure to use the common object in frame.h */\n-\n-typedef struct dwarf_fde\n-{\n-  long start_offset;\n-  long end_offset;\n-  long unwind_offset;\n-} unwind_table_entry;\n-  \n-/* Defining dwarf_fde allows us to use the common object registration.  */\n-typedef unwind_table_entry dwarf_fde;\n-typedef unwind_table_entry fde;\n-\n #include \"frame.h\" \n \n-static struct object *objects = NULL;\n-\n-static inline saddr\n-fde_compare (fde *x, fde *y)\n-{\n-  return (saddr)x->start_offset - (saddr)y->start_offset;\n-}\n-\n-#include \"frame.c\"\n-\n-/* called from crtend.o to register the end of the unwind info for an\n-   object.  */\n-void\n-__register_frame_info_aux (struct dwarf_fde *end)\n-{\n-  objects->fde_end = end;\n-}\n-  \n-static void\n-frame_init (struct object *ob)\n-{\n-  int count = 0;  /* reserve one for the dummy last entry.  */\n-  fde_accumulator accu;\n-  unwind_table_entry *ptr = ob->fde_begin;\n-\n-  if (ptr == 0)\n-    return;\n-\n-  /* Count the number of entries objects.  */\n-  for ( ; ptr < ob->fde_end; ptr++)\n-    count++;\n-\n-  ob->pc_begin = (void *)(uaddr) - 1;\n-  ob->pc_end = 0;\n-\n-  start_fde_sort (&accu, count);\n-  for (ptr = ob->fde_begin; ptr < ob->fde_end; ptr++)\n-  {\n-    if (ob->pc_base + ptr->start_offset < ob->pc_begin)\n-      ob->pc_begin = ob->pc_base + ptr->start_offset;\n-    if (ob->pc_base + ptr->end_offset > ob->pc_end)\n-      ob->pc_end = ob->pc_base + ptr->end_offset;\n-    fde_insert (&accu, (fde *)ptr);\n-  }\n-\n-  ob->fde_array = end_fde_sort (&accu, count);\n-  ob->count = count;\n-}\n-\n-/* Return a pointer to the FDE for the function containing PC.  */\n-\n-static fde *\n-find_fde (void *pc, void **pc_base)\n-{\n-  struct object *ob;\n-  size_t lo, hi;\n-\n-  *pc_base = NULL;\n-\n-  init_object_mutex_once ();\n-  __gthread_mutex_lock (&object_mutex);\n-\n-  for (ob = objects; ob; ob = ob->next)\n-    {\n-      if (ob->pc_begin == 0)\n-\tframe_init (ob);\n-      if (pc >= ob->pc_begin && pc < ob->pc_end)\n-\tbreak;\n-    }\n-\n-  __gthread_mutex_unlock (&object_mutex);\n-\n-  if (ob == 0)\n-    return 0;\n-\n-  *pc_base = ob->pc_base;\n-  /* Standard binary search algorithm.  */\n-  for (lo = 0, hi = ob->count; lo < hi; )\n-    {\n-      size_t i = (lo + hi) / 2;\n-      fde *f = ob->fde_array[i];\n-\n-      if (pc - ob->pc_base < f->start_offset)\n-\thi = i;\n-      else if (pc - ob->pc_base >= f->end_offset)\n-\tlo = i + 1;\n-      else\n-\treturn f;\n-    }\n-\n-  return 0;\n-}\n-\n /* Decode the unsigned LEB128 constant at BUF and return it. The value at\n    MEM is updated to reflect the next position in the buffer.  */\n \n@@ -232,60 +81,9 @@ read_uleb128 (unsigned char **mem)\n   return result;\n }\n \n-static void\n-bad_record (ptr, offset)\n-     unsigned char *ptr;\n-     int offset;\n-{\n-#if 0\n-  printf (\"Bad unwind record format value '%x' at offset %d in record %p\\n\",\n-  \t  *(ptr + offset), offset , ptr);\n-#endif  \n-  abort ();\n-}\n-\n-static unsigned char *read_R_record (unwind_record *, unsigned char, unsigned char *);\n-static unsigned char *read_X_record (unwind_record *, unsigned char, unsigned char *);\n-static unsigned char *read_B_record (unwind_record *, unsigned char, unsigned char *);\n-static unsigned char *read_P_record (unwind_record *, unsigned char, unsigned char *, unwind_record *);\n-\n-\n-/* This routine will determine what type of record the memory pointer\n-   is refering to, and fill in the appropriate fields for that record type. \n-   HEADER is a pointer to the last region header unwind record.\n-   DATA is a pointer to an unwind record which will be filled in.\n-   PTR is a pointer to the current location in the unwind table where we\n-   will read the next record from.  \n-   The return value is the start of the next record.  */\n-\n-extern unsigned char *\n-get_unwind_record (header, data, ptr)\n-     unwind_record *header;\n-     unwind_record *data;\n-     unsigned char *ptr;\n-{\n-  unsigned char val = *ptr++;\n-\n-  if ((val & 0x80) == 0)\n-    {\n-      return read_R_record (data, val, ptr);\n-    }\n-\n-  if (val == UNW_X1 || val == UNW_X2 || val == UNW_X3 || val == UNW_X4)\n-    return read_X_record (data, val, ptr);\n-\n-  if (header->type != body)\n-    return read_P_record (data, val, ptr, header);\n-  else\n-    return read_B_record (data, val, ptr);\n-}\n-\n \n static unsigned char *\n-read_R_record (data, val, ptr)\n-     unwind_record *data;\n-     unsigned char val;\n-     unsigned char *ptr;\n+read_R_record (unwind_record *data, unsigned char val, unsigned char *ptr)\n {\n   if ((val & 0x40) == 0)\n     {\n@@ -321,17 +119,15 @@ read_R_record (data, val, ptr)\n         if (val == 1)\n \t  data->type = body;\n \telse\n-\t  bad_record (ptr - 1, 0);\n+\t  abort ();\n       data->record.r.rlen = read_uleb128 (&ptr);\n       return ptr;\n     }\n-  bad_record (ptr - 1, 0);\n+  abort ();\n }\n \n static void\n-process_a_b_reg_code(data, val)\n-     unwind_record *data;\n-     unsigned char val;\n+process_a_b_reg_code(unwind_record *data, unsigned char val)\n {\n   int code = (val & 0x60) >> 5;\n   int reg = (val & 0x1f);\n@@ -354,10 +150,7 @@ process_a_b_reg_code(data, val)\n }\n \n static unsigned char *\n-read_X_record (data, val, ptr)\n-     unwind_record *data;\n-     unsigned char val;\n-     unsigned char *ptr;\n+read_X_record (unwind_record *data, unsigned char val, unsigned char *ptr)\n {\n   unsigned long tmp;\n   int byte1, byte2;\n@@ -407,7 +200,7 @@ read_X_record (data, val, ptr)\n \t        data->record.x.treg = BR_REG (treg);\n \t        break;\n \t      case 3:\n-\t        bad_record (ptr - 3, 2);\n+\t        abort ();\n \t    }\n \t  data->record.x.t = read_uleb128 (&ptr);\n         }\n@@ -431,16 +224,13 @@ read_X_record (data, val, ptr)\n \t  }\t\n \treturn ptr;\n       default:\n-\tbad_record (ptr - 1, 0);\n+\tabort ();\n     }\n   return NULL;\n }\n \n static unsigned char *\n-read_B_record (data, val, ptr)\n-     unwind_record *data;\n-     unsigned char val;\n-     unsigned char *ptr;\n+read_B_record (unwind_record *data, unsigned char val, unsigned char *ptr)\n {\n   if ((val & 0xc0) == 0x80)\n     {\n@@ -486,58 +276,58 @@ read_B_record (data, val, ptr)\n       data->record.b.label = read_uleb128 (&ptr);\n       return ptr;\n     }\n-\n-  bad_record (ptr - 1, 0);\n-\n+  abort ();\n }\n \n /* This array is used to set the TYPE field for format P3.  */\n-static unw_record_type P3_record_types[] = {\n+static unw_record_type const P3_record_types[] = {\n   psp_gr, rp_gr, pfs_gr, preds_gr, unat_gr, lc_gr, rp_br, rnat_gr,\n-  bsp_gr, bspstore_gr, fpsr_gr, priunat_gr };\n+  bsp_gr, bspstore_gr, fpsr_gr, priunat_gr\n+};\n \n /* This array is used to set the TYPE field for format P7.  */\n-static unw_record_type P7_record_types[] = {\n+static unw_record_type const P7_record_types[] = {\n   mem_stack_f, mem_stack_v, spill_base, psp_sprel, rp_when, rp_psprel,\n   pfs_when, pfs_psprel, preds_when, preds_psprel, lc_when, lc_psprel,\n-  unat_when, unat_psprel, fpsr_when, fpsr_psprel };\n+  unat_when, unat_psprel, fpsr_when, fpsr_psprel\n+};\n \n /* These values and the array are used to determine which additional ULEB128\n    fields are required for the P7 format.  */\n #define P7_T_SIZE\t0\n #define P7_T\t\t1\n #define P7_PSPOFF       2\n #define P7_SPOFF\t3\n-static unsigned char P7_additional_fields [] = {\n+static unsigned char const P7_additional_fields [] = {\n    P7_T_SIZE, P7_T, P7_PSPOFF, P7_SPOFF, P7_T, P7_PSPOFF, \n-   P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF };\n+   P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF\n+};\n \n /* This array is used to set the TYPE field for format P8. \n    Note that entry 0 is not used in this array, so it is filled with\n    rp_spel for completely arbitrary reasons.  */\n-static unw_record_type P8_record_types[] = {\n+static unw_record_type const P8_record_types[] = {\n   rp_sprel, rp_sprel, pfs_sprel, preds_sprel, lc_sprel, unat_sprel, fpsr_sprel, \n   bsp_when, bsp_psprel, bsp_sprel, bspstore_when, bspstore_psprel,\n   bspstore_sprel, rnat_when, rnat_psprel, rnat_sprel, priunat_when_gr,\n-  priunat_psprel, priunat_sprel, priunat_when_mem };\n+  priunat_psprel, priunat_sprel, priunat_when_mem\n+};\n \n /* These values and the array are used to determine which additional ULEB128\n    fields are required for the P8 format.  */\n #define P8_T\t\t0\n #define P8_PSPOFF       1\n #define P8_SPOFF\t2\n-static unsigned char P8_additional_fields [] = {\n+static unsigned char const P8_additional_fields [] = {\n   P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF,\n   P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF,\n-  P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF, P8_T };\n+  P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF, P8_T\n+};\n \n \n static unsigned char *\n-read_P_record (data, val, ptr, header)\n-     unwind_record *data;\n-     unsigned char val;\n-     unsigned char *ptr;\n-     unwind_record *header;\n+read_P_record (unwind_record *data, unsigned char val, unsigned char *ptr,\n+\t       unwind_record *header)\n {\n   if ((val & 0xe0) == 0x80)\n     {\n@@ -553,7 +343,7 @@ read_P_record (data, val, ptr, header)\n       int byte1;\n       data->type = br_gr;\n       byte1 = *ptr++;\n-      data->record.p.brmask = (val & 0x0f) << 1 + (byte1 >> 7);\n+      data->record.p.brmask = ((val & 0x0f) << 1) + (byte1 >> 7);\n       data->record.p.gr = GR_REG (byte1 & 0x7f);\n       return ptr;\n     }\n@@ -569,7 +359,7 @@ read_P_record (data, val, ptr, header)\n       else\n         data->record.p.gr = GR_REG (byte1 & 0x7f);\n       if (r > 11)\n-        bad_record (ptr - 2, 0);\n+        abort ();\n       return ptr;\n     }\n \n@@ -579,8 +369,7 @@ read_P_record (data, val, ptr, header)\n       int size = (header->record.r.rlen * 2 + 7) / 8;\n \n       data->type = spill_mask;\n-      data->record.p.imask = (unsigned char *) malloc (size);\n-      memcpy (data->record.p.imask, ptr, size);\n+      data->record.p.imask = ptr;\n       return ptr+size;\n     }\n \n@@ -664,24 +453,49 @@ read_P_record (data, val, ptr, header)\n   \n   if (val == UNW_P10)\n     {\n+#if 0\n       /* P10 format.  */\n-      int abi = *ptr++;\n-      int context = *ptr++;\n+      int abi = ptr[0];\n+      int context = ptr[1];\n       /* TODO. something about abi entries.  */\n-      return ptr;\n+#endif\n+      return ptr + 2;\n     }\n \n   return ptr;\n }\n \n+/* This routine will determine what type of record the memory pointer\n+   is refering to, and fill in the appropriate fields for that record type. \n+   HEADER is a pointer to the last region header unwind record.\n+   DATA is a pointer to an unwind record which will be filled in.\n+   PTR is a pointer to the current location in the unwind table where we\n+   will read the next record from.  \n+   The return value is the start of the next record.  */\n+\n+static unsigned char *\n+get_unwind_record (unwind_record *header, unwind_record *data,\n+\t\t   unsigned char *ptr)\n+{\n+  unsigned char val = *ptr++;\n+\n+  if ((val & 0x80) == 0)\n+    return read_R_record (data, val, ptr);\n+\n+  if (val == UNW_X1 || val == UNW_X2 || val == UNW_X3 || val == UNW_X4)\n+    return read_X_record (data, val, ptr);\n+\n+  if (header->type != body)\n+    return read_P_record (data, val, ptr, header);\n+  else\n+    return read_B_record (data, val, ptr);\n+}\n \f\n /* Frame processing routines.  */\n \n /* Initialize a single register structure.  */\n static inline void \n-init_ia64_reg_loc (reg, size)\n-     ia64_reg_loc *reg;\n-     short size;\n+init_ia64_reg_loc (ia64_reg_loc *reg, short size)\n {\n   reg->when = -1;\n   reg->loc_type = IA64_UNW_LOC_TYPE_NONE;\n@@ -691,8 +505,7 @@ init_ia64_reg_loc (reg, size)\n \n /* Iniitialize an entire frame to the default of nothing.  */\n static void\n-init_ia64_unwind_frame (frame) \n-     ia64_frame_state *frame;\n+init_ia64_unwind_frame (ia64_frame_state *frame) \n {\n   int x;\n   \n@@ -726,15 +539,13 @@ init_ia64_unwind_frame (frame)\n    the return value is a pointer to the start of the next descriptor.  */\n \n static void *\n-execute_one_ia64_descriptor (addr, frame, len)\n-     void *addr;\n-     ia64_frame_state *frame;\n-     long *len;\n+execute_one_ia64_descriptor (void *addr, ia64_frame_state *frame, long *len)\n {\n-  unwind_record r;\n   /* The last region_header.  Needed to distinguish between prologue and body\n      descriptors.  Also needed for length of P4 format.  */\n   static unwind_record region_header;\n+\n+  unwind_record r;\n   ia64_reg_loc *loc_ptr = NULL;\n   int grmask = 0, frmask = 0;\n \n@@ -750,7 +561,7 @@ execute_one_ia64_descriptor (addr, frame, len)\n       case prologue:\n       case body:\n \t*len = r.record.r.rlen;\n-\tmemcpy (&region_header, &r, sizeof (unwind_record));\n+\tregion_header = r;\n \tbreak;\n       case prologue_gr:\n         {\n@@ -783,7 +594,7 @@ execute_one_ia64_descriptor (addr, frame, len)\n \t      frame->pr.loc_type  = IA64_UNW_LOC_TYPE_GR;\n \t      frame->pr.l.regno = reg++;\n \t    }\n-\t  memcpy (&region_header, &r, sizeof (unwind_record));\n+\t  region_header = r;\n \t  break;\n \t}\n       case mem_stack_f:\n@@ -1048,7 +859,8 @@ rse_address_add(unsigned char *addr, int nslots)\n \n   new_addr = addr + 8 * (nslots + mandatory_nat_slots);\n \n-  if (((long)new_addr >> 9)  != ((long)(addr + 8 * 64 * mandatory_nat_slots) >> 9))\n+  if (((long)new_addr >> 9)\n+      != ((long)(addr + 8 * 64 * mandatory_nat_slots) >> 9))\n     new_addr += 8 * direction;\n \n   if (IS_NaT_COLLECTION_ADDR(new_addr))\n@@ -1061,9 +873,7 @@ rse_address_add(unsigned char *addr, int nslots)\n /* Normalize a record to originate in either a register or memory \n    location.  */\n static void\n-normalize_reg_loc (frame, reg)\n-     ia64_frame_state *frame;\n-     ia64_reg_loc *reg;\n+normalize_reg_loc (ia64_frame_state *frame, ia64_reg_loc *reg)\n {\n   unsigned char *tmp;\n   switch (reg->loc_type)\n@@ -1122,10 +932,8 @@ normalize_reg_loc (frame, reg)\n    It is executed if it is exectued at START time. It is NOT\n    executed if it happens at END time. */\n static void \n-maybe_normalize_reg_loc (frame, reg, start, end)\n-     ia64_frame_state *frame;\n-     ia64_reg_loc *reg;\n-     int start, end;\n+maybe_normalize_reg_loc (ia64_frame_state *frame, ia64_reg_loc *reg,\n+\t\t\t long start, long end)\n {\n   if (reg->loc_type != IA64_UNW_LOC_TYPE_NONE \n       && reg->when >= start && reg->when < end)\n@@ -1135,8 +943,7 @@ maybe_normalize_reg_loc (frame, reg, start, end)\n \n /* Only works for 8 byte or less registers.  */\n void *\n-__get_real_reg_value (reg)\n-     ia64_reg_loc *reg;\n+__get_real_reg_value (ia64_reg_loc *reg)\n {\n   if (reg->loc_type == IA64_UNW_LOC_TYPE_MEM)\n     return *((void **)(reg->l.mem));\n@@ -1147,9 +954,7 @@ __get_real_reg_value (reg)\n }\n \n void\n-__set_real_reg_value (reg, val) \n-     ia64_reg_loc *reg;\n-     void *val;\n+__set_real_reg_value (ia64_reg_loc *reg, void *val) \n {\n   if (reg->loc_type == IA64_UNW_LOC_TYPE_MEM)\n     {\n@@ -1161,9 +966,7 @@ __set_real_reg_value (reg, val)\n }\n \n static void\n-copy_reg_value (src, dest)\n-     ia64_reg_loc *src;\n-     ia64_reg_loc *dest;\n+copy_reg_value (ia64_reg_loc *src, ia64_reg_loc *dest)\n {\n   void **p = dest->l.mem;\n   if (src->loc_type == IA64_UNW_LOC_TYPE_NONE)\n@@ -1190,9 +993,7 @@ copy_reg_value (src, dest)\n /* Copy the values of any relevant saved registers in one frame \n    to another for unwinding.  */\n void \n-__copy_saved_reg_state (dest, src)\n-     ia64_frame_state *dest;\n-     ia64_frame_state *src;\n+__copy_saved_reg_state (ia64_frame_state *dest, ia64_frame_state *src)\n {\n   int x;\n   for (x = 0; x < 4 ; x++)\n@@ -1213,9 +1014,7 @@ __copy_saved_reg_state (dest, src)\n \n \n static void \n-process_state_between (frame, start, end)\n-     ia64_frame_state *frame;\n-     int start, end;\n+process_state_between (ia64_frame_state *frame, long start, long end)\n {\n   int x;\n   /* PSP, RP, SP, and PFS are handled seperately from here. */\n@@ -1253,9 +1052,7 @@ process_state_between (frame, start, end)\n      that has a WHEN record beyond this time is cleared since it\n      isn't relevant.  */\n static void\n-frame_translate (frame, unwind_time)\n-     ia64_frame_state *frame;\n-     long unwind_time;\n+frame_translate (ia64_frame_state *frame, long unwind_time)\n {\n   /* ??? Is this supposed to mark the end of the stack?  */\n   if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE)\n@@ -1324,11 +1121,8 @@ frame_translate (frame, unwind_time)\n    frame is the frame_state structure to be set up.\n    Returns a pointer to the unwind info pointer for the frame.  */\n unwind_info_ptr *\n-__build_ia64_frame_state (pc, frame, bsp, sp, pc_base_ptr)\n-     unsigned char *pc;\n-     ia64_frame_state *frame;\n-     void *bsp, *sp;\n-     void **pc_base_ptr;\n+__build_ia64_frame_state (unsigned char *pc, ia64_frame_state *frame,\n+\t\t\t  void *bsp, void *sp, void **pc_base_ptr)\n {\n   long len;\n   int region_offset = 0;\n@@ -1340,7 +1134,7 @@ __build_ia64_frame_state (pc, frame, bsp, sp, pc_base_ptr)\n   int pc_offset;\n   struct unwind_info_ptr *unw_info_ptr;\n \n-  entry = find_fde (pc, &pc_base);\n+  entry = __ia64_find_fde (pc, &pc_base);\n   if (!entry)\n     return 0;\n \n@@ -1378,8 +1172,7 @@ __build_ia64_frame_state (pc, frame, bsp, sp, pc_base_ptr)\n \n /* Given an unwind info pointer, return the personality routine.  */\n void *\n-__get_personality (ptr)\n-     unwind_info_ptr *ptr;\n+__get_personality (unwind_info_ptr *ptr)\n {\n   void **p;\n \n@@ -1396,8 +1189,7 @@ __get_personality (ptr)\n \n /* Given an unwind info pointer, return the exception table.  */\n void *\n-__get_except_table (ptr)\n-     unwind_info_ptr *ptr;\n+__get_except_table (unwind_info_ptr *ptr)\n {\n   void *table;\n \n@@ -1415,9 +1207,7 @@ __get_except_table (ptr)\n \n /* Given a PFS value, and the current BSp, calculate the BSp of the caller.  */\n void *\n-__calc_caller_bsp (pfs, bsp)\n-     long pfs;\n-     unsigned char *bsp;\n+__calc_caller_bsp (long pfs, unsigned char *bsp)\n {\n   int size_of_locals;\n \n@@ -1459,6 +1249,8 @@ ia64_backtrace_helper (void **array, ia64_frame_state *throw_frame,\n }\n \n /* This is equivalent to glibc's backtrace(). */\n+\n+extern int __ia64_backtrace (void **array, int size);\n   \n int\n __ia64_backtrace (void **array, int size)\n@@ -1478,195 +1270,3 @@ __ia64_backtrace (void **array, int size)\n   return ia64_backtrace_helper (array, &my_frame, &originator, bsp,\n \t\t\t\tstack_pointer, size);\n }\n-\n-\f\n-\n-#ifndef inhibit_libc\n-\n-#if 0\n-#undef NULL;\n-#include <stdio.h>\n-\n-/* Routines required to generate debug info for the ia64\n-   unwind descriptors.  */\n-\n-static unsigned char *record_name[] = { \n-  \"prologue\", \"prologue_gr\", \"body\", \"mem_stack_f\", \"mem_stack_v\", \"psp_gr\", \n-  \"psp_sprel\", \"rp_when\", \"rp_gr\", \"rp_br\", \"rp_psprel\", \"rp_sprel\", \n-  \"pfs_when\", \"pfs_gr\", \"pfs_psprel\", \"pfs_sprel\", \"preds_when\", \"preds_gr\", \n-  \"preds_psprel\", \"preds_sprel\", \"fr_mem\", \"frgr_mem\", \"gr_gr\", \"gr_mem\", \n-  \"br_mem\", \"br_gr\", \"spill_base\", \"spill_mask\", \"unat_when\", \"unat_gr\", \n-  \"unat_psprel\", \"unat_sprel\", \"lc_when\", \"lc_gr\", \"lc_psprel\", \"lc_sprel\", \n-  \"fpsr_when\", \"fpsr_gr\", \"fpsr_psprel\", \"fpsr_sprel\", \"priunat_when_gr\", \n-  \"priunat_when_mem\", \"priunat_gr\", \"priunat_psprel\", \"priunat_sprel\", \n-  \"bsp_when\", \"bsp_gr\", \"bsp_psprel\", \"bsp_sprel\", \"bspstore_when\", \n-  \"bspstore_gr\", \"bspstore_psprel\", \"bspstore_sprel\", \"rnat_when\", \"rnat_gr\", \n-  \"rnat_psprel\", \"rnat_sprel\", \"epilogue\", \"label_state\", \"copy_state\", \n-  \"spill_psprel\", \"spill_sprel\", \"spill_reg\", \"spill_psprel_p\", \n-  \"spill_sprel_p\",\"spill_reg_p\" \n-};\n-\n-\n-\n-static void\n-print_record (f, ptr)\n-     FILE *f;\n-     unwind_record *ptr;\n-{\n-  fprintf (f, \" %s \",record_name[ptr->type]);\n-  switch (ptr->type) \n-    {\n-      case prologue:\n-      case body:\n-\tfprintf (f, \"(R1) rlen = %d\", ptr->record.r.rlen);\n-\tbreak;\n-      case prologue_gr:\n-\tfprintf (f, \"(R2) rlen = %d : \", ptr->record.r.rlen);\n-\tfprintf (f, \"grmask = %x, grsave = r%d\", ptr->record.r.mask, \n-\t\t\t\t\t\t ptr->record.r.grsave);\n-\tbreak;\n-      case mem_stack_f:\n-\tfprintf (f, \"(P7) t = %d, size = %d\", ptr->record.p.t, \n-\t\t\t\t\t ptr->record.p.size);\n-\tbreak;\n-      case mem_stack_v:\n-\tfprintf (f, \"(P7) t = %d\", ptr->record.p.t);\n-\tbreak;\n-      case psp_gr:\n-      case rp_gr:\n-      case pfs_gr:\n-      case preds_gr:\n-      case unat_gr:\n-      case lc_gr:\n-      case fpsr_gr:\n-      case priunat_gr:\n-      case bsp_gr:\n-      case bspstore_gr:\n-      case rnat_gr:\n-\tfprintf (f, \"(P3) r%d\", ptr->record.p.gr);\n-\tbreak;\n-      case rp_br:\n-\tfprintf (f, \"(P3) b%d\", ptr->record.p.br);\n-\tbreak;\n-      case psp_sprel:\n-\tfprintf (f, \"(P7) spoff = %d\", ptr->record.p.spoff);\n-\tbreak;\n-      case rp_when:\n-      case pfs_when:\n-      case preds_when:\n-      case unat_when:\n-      case lc_when:\n-      case fpsr_when:\n-\tfprintf (f, \"(P7) t = %d\", ptr->record.p.t);\n-\tbreak;\n-      case rp_psprel:\n-      case pfs_psprel:\n-      case preds_psprel:\n-      case unat_psprel:\n-      case lc_psprel:\n-      case fpsr_psprel:\n-      case spill_base:\n-\tfprintf (f, \"(P7) pspoff = %d\", ptr->record.p.pspoff, 0);\n-\tbreak;\n-      case rp_sprel:\n-      case pfs_sprel:\n-      case preds_sprel:\n-      case unat_sprel:\n-      case lc_sprel:\n-      case fpsr_sprel:\n-      case priunat_sprel:\n-      case bsp_sprel:\n-      case bspstore_sprel:\n-      case rnat_sprel:\n-\tfprintf (f, \"(P8) spoff = %d\", ptr->record.p.spoff);\n-\tbreak;\n-      case fr_mem:\n-      case gr_mem:\n-\tfprintf (f, \"(P6) rmask = %x\", ptr->record.p.rmask);\n-\tbreak;\n-      case frgr_mem:\n-\tfprintf (f, \"(P5) grmask = %x,  frmask = %x\", ptr->record.p.grmask, \n-\t\t\t\t\t\t ptr->record.p.frmask);\n-\tbreak;\n-      case gr_gr:\n-\tfprintf (f, \"(P9) grmask = %x  gr = r%d\\n\", ptr->record.p.grmask, \n-\t\t\t\t\t       ptr->record.p.gr);\n-\tbreak;\n-      case br_mem:\n-\tfprintf (f, \"(P1) brmask = %x\", ptr->record.p.brmask);\n-\tbreak;\n-      case br_gr:\n-\tfprintf (f, \"(P2) brmask = %x,  gr = r%d\", ptr->record.p.brmask, \n-\t\t\t\t\t      ptr->record.p.gr);\n-\tbreak;\n-      case spill_mask:\n-\tfprintf (f, \"spill mask....  unimplemented\");\n-\tbreak;\n-      case priunat_when_gr:\n-      case priunat_when_mem:\n-      case bsp_when:\n-      case bspstore_when:\n-      case rnat_when:\n-\tfprintf (f, \"(P8) t = %d\\n\", ptr->record.p.t);\n-\tbreak;\n-      case priunat_psprel:\n-      case bsp_psprel:\n-      case bspstore_psprel:\n-      case rnat_psprel:\n-\tfprintf (f, \"(P8) pspoff = %d\", ptr->record.p.pspoff);\n-\tbreak;\n-      case epilogue:\n-\tfprintf (f, \"epilogue record unimplemented.\");\n-\tbreak;\n-      case label_state:\n-\tfprintf (f, \"label_state record unimplemented.\");\n-\tbreak;\n-      case copy_state:\n-\tfprintf (f, \"copy_state record unimplemented.\");\n-\tbreak;\n-      case spill_psprel:\n-      case spill_sprel:\n-      case spill_reg:\n-      case spill_psprel_p:\n-      case spill_sprel_p:\n-      case spill_reg_p:\n-\tfprintf (f, \"spill_* record unimplemented.\");\n-\tbreak;\n-      default:\n-\tfprintf (f, \"record_type_not_valid\");\n-\tbreak;\n-    }\n-  fprintf (f, \"\\n\");\n-  \n-}\n-\n-static void\n-print_all_records (f, mem, size)\n-     FILE *f;\n-     unsigned char *mem;\n-     int size;\n-{\n-  unsigned char *end = mem + size;\n-  unwind_record r;\n-  static unwind_record region_header;\n-\n-  fprintf (f, \"UNWIND IMAGE:\\n\");\n-  while (mem < end) \n-    {\n-      mem = get_unwind_record (&region_header, &r, mem);\n-      print_record (f, &r);\n-      switch (r.type)\n-\t{\n-\tcase prologue:\n-\tcase body:\n-\tcase prologue_gr:\n-\t  memcpy (region_header, r, sizeof (unwind_record));\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  fprintf (f, \"--end unwind image--\\n\\n\");\n-}\n-#endif /* If 0 */\n-#endif /* inhibit_libc */"}, {"sha": "d638ca3862b8d99a841e13f0369e22acb838c5fc", "filename": "gcc/config/ia64/frame-ia64.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fframe-ia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Fframe-ia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fframe-ia64.h?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod  <amacleod@cygnus.com>\n+                  Andrew Haley  <aph@cygnus.com>\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This structure represents a single unwind table entry.  We lie and say\n+   its the dwarf_fde structure to use the common object in frame.h */\n+\n+typedef struct dwarf_fde\n+{\n+  long start_offset;\n+  long end_offset;\n+  long unwind_offset;\n+} unwind_table_entry;\n+  \n+/* Defining dwarf_fde allows us to use the common object registration.  */\n+typedef unwind_table_entry dwarf_fde;\n+typedef unwind_table_entry fde;\n+\n+extern fde *__ia64_find_fde (void *, void **);"}, {"sha": "a1056628b501443b7310beeca41cdd7f76458fd7", "filename": "gcc/config/ia64/t-glibc", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Ft-glibc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfig%2Fia64%2Ft-glibc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-glibc?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -0,0 +1 @@\n+LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c"}, {"sha": "cf2175178f479e468d70f127497d4de5126bf889", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -5059,7 +5059,7 @@ for machine in $build $host $target; do\n \t\t;;\n \tia64*-*-linux*)\n \t\ttm_file=ia64/linux.h\n-\t\ttmake_file=\"t-linux ia64/t-ia64\"\n+\t\ttmake_file=\"t-linux ia64/t-ia64 ia64/t-glibc\"\n \t\ttarget_cpu_default=\"MASK_GNU_AS|MASK_GNU_LD\"\n  \t\tif test x$enable_threads = xyes; then\n  \t\t\tthread_file='posix'"}, {"sha": "3745fd66d995d6e312ffa7144c786c6f60d6a63e", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee0225a383cdc396a720a2a8639d4fb99e7f084/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=fee0225a383cdc396a720a2a8639d4fb99e7f084", "patch": "@@ -2046,7 +2046,7 @@ changequote([,])dnl\n \t\t;;\n \tia64*-*-linux*)\n \t\ttm_file=ia64/linux.h\n-\t\ttmake_file=\"t-linux ia64/t-ia64\"\n+\t\ttmake_file=\"t-linux ia64/t-ia64 ia64/t-glibc\"\n \t\ttarget_cpu_default=\"MASK_GNU_AS|MASK_GNU_LD\"\n  \t\tif test x$enable_threads = xyes; then\n  \t\t\tthread_file='posix'"}]}