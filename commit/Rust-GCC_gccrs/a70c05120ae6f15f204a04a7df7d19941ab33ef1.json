{"sha": "a70c05120ae6f15f204a04a7df7d19941ab33ef1", "node_id": "C_kwDOANBUbNoAKGE3MGMwNTEyMGFlNmYxNWYyMDRhMDRhN2RmN2QxOTk0MWFiMzNlZjE", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-02T17:57:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-02T17:57:51Z"}, "message": "Static chain support in ipa-modref\n\nTeach ipa-modref about the static chain that is, like\nretslot, a hiden argument.  The patch is pretty much symemtric to what\nwas done for retslot handling and I verified it does the intended job\nfor Ada LTO bootstrap.\n\ngcc/ChangeLog:\n\n\t* gimple.c (gimple_call_static_chain_flags): New function.\n\t* gimple.h (gimple_call_static_chain_flags): Declare\n\t* ipa-modref.c (modref_summary::modref_summary): Initialize\n\tstatic_chain_flags.\n\t(modref_summary_lto::modref_summary_lto): Likewise.\n\t(modref_summary::useful_p): Test static_chain_flags.\n\t(modref_summary_lto::useful_p): Likewise.\n\t(struct modref_summary_lto): Add static_chain_flags.\n\t(modref_summary::dump): Dump static_chain_flags.\n\t(modref_summary_lto::dump): Likewise.\n\t(struct escape_point): Add static_cahin_arg.\n\t(analyze_ssa_name_flags): Use gimple_call_static_chain_flags.\n\t(analyze_parms): Handle static chains.\n\t(modref_summaries::duplicate): Duplicate static_chain_flags.\n\t(modref_summaries_lto::duplicate): Likewise.\n\t(modref_write): Stream static_chain_flags.\n\t(read_section): Likewise.\n\t(modref_merge_call_site_flags): Handle static_chain_flags.\n\t* ipa-modref.h (struct modref_summary): Add static_chain_flags.\n\t* tree-ssa-structalias.c (handle_rhs_call): Use\n\tgimple_static_chain_flags.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/ipa/modref-3.c: New test.", "tree": {"sha": "234844b801a3446e044d1c2be530e4afb386d0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/234844b801a3446e044d1c2be530e4afb386d0d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a70c05120ae6f15f204a04a7df7d19941ab33ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70c05120ae6f15f204a04a7df7d19941ab33ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70c05120ae6f15f204a04a7df7d19941ab33ef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70c05120ae6f15f204a04a7df7d19941ab33ef1/comments", "author": null, "committer": null, "parents": [{"sha": "164bbf701ff10ff44e272525e8f462ed3ff1cf43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164bbf701ff10ff44e272525e8f462ed3ff1cf43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/164bbf701ff10ff44e272525e8f462ed3ff1cf43"}], "stats": {"total": 117, "additions": 109, "deletions": 8}, "files": [{"sha": "76768c19c8ece50d9b37da62995ef2039f6ba8ca", "filename": "gcc/gimple.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=a70c05120ae6f15f204a04a7df7d19941ab33ef1", "patch": "@@ -1647,6 +1647,33 @@ gimple_call_retslot_flags (const gcall *stmt)\n   return flags;\n }\n \n+/* Detects argument flags for static chain on call STMT.  */\n+\n+int\n+gimple_call_static_chain_flags (const gcall *stmt)\n+{\n+  int flags = 0;\n+\n+  tree callee = gimple_call_fndecl (stmt);\n+  if (callee)\n+    {\n+      cgraph_node *node = cgraph_node::get (callee);\n+      modref_summary *summary = node ? get_modref_function_summary (node)\n+\t\t\t\t: NULL;\n+\n+      if (summary)\n+\t{\n+\t  int modref_flags = summary->static_chain_flags;\n+\n+\t  /* We have possibly optimized out load.  Be conservative here.  */\n+\t  gcc_checking_assert (node->binds_to_current_def_p ());\n+\t  if (dbg_cnt (ipa_mod_ref_pta))\n+\t    flags |= modref_flags;\n+\t}\n+    }\n+  return flags;\n+}\n+\n /* Detects return flags for the call STMT.  */\n \n int"}, {"sha": "3cde3cde7fee20870fa9c63aeace9a149dc41429", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=a70c05120ae6f15f204a04a7df7d19941ab33ef1", "patch": "@@ -1590,6 +1590,7 @@ bool gimple_call_same_target_p (const gimple *, const gimple *);\n int gimple_call_flags (const gimple *);\n int gimple_call_arg_flags (const gcall *, unsigned);\n int gimple_call_retslot_flags (const gcall *);\n+int gimple_call_static_chain_flags (const gcall *);\n int gimple_call_return_flags (const gcall *);\n bool gimple_call_nonnull_result_p (gcall *);\n tree gimple_call_nonnull_arg (gcall *);"}, {"sha": "bb5131286331e5d9004d07b028a5cade05ec1659", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=a70c05120ae6f15f204a04a7df7d19941ab33ef1", "patch": "@@ -272,7 +272,8 @@ static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n /* Summary for a single function which this pass produces.  */\n \n modref_summary::modref_summary ()\n-  : loads (NULL), stores (NULL), retslot_flags (0), writes_errno (false)\n+  : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n+    writes_errno (false)\n {\n }\n \n@@ -327,6 +328,9 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n   arg_flags.release ();\n   if (check_flags && remove_useless_eaf_flags (retslot_flags, ecf_flags, false))\n     return true;\n+  if (check_flags\n+      && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n+    return true;\n   if (ecf_flags & ECF_CONST)\n     return false;\n   if (loads && !loads->every_base)\n@@ -369,6 +373,7 @@ struct GTY(()) modref_summary_lto\n   modref_records_lto *stores;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   eaf_flags_t retslot_flags;\n+  eaf_flags_t static_chain_flags;\n   bool writes_errno;\n \n   modref_summary_lto ();\n@@ -380,7 +385,8 @@ struct GTY(()) modref_summary_lto\n /* Summary for a single function which this pass produces.  */\n \n modref_summary_lto::modref_summary_lto ()\n-  : loads (NULL), stores (NULL), retslot_flags (0), writes_errno (false)\n+  : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n+    writes_errno (false)\n {\n }\n \n@@ -408,6 +414,9 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n   arg_flags.release ();\n   if (check_flags && remove_useless_eaf_flags (retslot_flags, ecf_flags, false))\n     return true;\n+  if (check_flags\n+      && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n+    return true;\n   if (ecf_flags & ECF_CONST)\n     return false;\n   if (loads && !loads->every_base)\n@@ -621,6 +630,11 @@ modref_summary::dump (FILE *out)\n       fprintf (out, \"  Retslot flags:\");\n       dump_eaf_flags (out, retslot_flags);\n     }\n+  if (static_chain_flags)\n+    {\n+      fprintf (out, \"  Static chain flags:\");\n+      dump_eaf_flags (out, static_chain_flags);\n+    }\n }\n \n /* Dump summary.  */\n@@ -648,6 +662,11 @@ modref_summary_lto::dump (FILE *out)\n       fprintf (out, \"  Retslot flags:\");\n       dump_eaf_flags (out, retslot_flags);\n     }\n+  if (static_chain_flags)\n+    {\n+      fprintf (out, \"  Static chain flags:\");\n+      dump_eaf_flags (out, static_chain_flags);\n+    }\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n@@ -1417,7 +1436,8 @@ struct escape_point\n   /* Extra hidden args we keep track of.  */\n   enum hidden_args\n   {\n-    retslot_arg = -1\n+    retslot_arg = -1,\n+    static_chain_arg = -2\n   };\n   /* Value escapes to this call.  */\n   gcall *call;\n@@ -1787,11 +1807,9 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t    lattice[index].merge (gimple_call_retslot_flags (call));\n \t\t}\n \n-\t      /* We do not track accesses to the static chain (we could)\n-\t\t so give up.  */\n \t      if (gimple_call_chain (call)\n \t\t  && (gimple_call_chain (call) == name))\n-\t\tlattice[index].merge (0);\n+\t\tlattice[index].merge (gimple_call_static_chain_flags (call));\n \n \t      /* Process internal functions and right away.  */\n \t      bool record_ipa = ipa && !gimple_call_internal_p (call);\n@@ -1983,6 +2001,7 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n   unsigned int count = 0;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n   tree retslot = NULL;\n+  tree static_chain = NULL;\n \n   /* For novops functions we have nothing to gain by EAF flags.  */\n   if (ecf_flags & ECF_NOVOPS)\n@@ -1992,12 +2011,14 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n   if (DECL_RESULT (current_function_decl)\n       && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n     retslot = ssa_default_def (cfun, DECL_RESULT (current_function_decl));\n+  if (cfun->static_chain_decl)\n+    static_chain = ssa_default_def (cfun, cfun->static_chain_decl);\n \n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n        parm = TREE_CHAIN (parm))\n     count++;\n \n-  if (!count && !retslot)\n+  if (!count && !retslot && !static_chain)\n     return;\n \n   auto_vec<modref_lattice> lattice;\n@@ -2071,6 +2092,22 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t\t\t\tescape_point::retslot_arg, flags);\n \t}\n     }\n+  if (static_chain)\n+    {\n+      analyze_ssa_name_flags (static_chain, lattice, 0, ipa);\n+      int flags = lattice[SSA_NAME_VERSION (static_chain)].flags;\n+\n+      flags = remove_useless_eaf_flags (flags, ecf_flags, false);\n+      if (flags)\n+\t{\n+\t  if (summary)\n+\t    summary->static_chain_flags = flags;\n+\t  if (summary_lto)\n+\t    summary_lto->static_chain_flags = flags;\n+\t  record_escape_points (lattice[SSA_NAME_VERSION (static_chain)],\n+\t\t\t\tescape_point::static_chain_arg, flags);\n+\t}\n+    }\n   if (ipa)\n     for (unsigned int i = 0; i < num_ssa_names; i++)\n       lattice[i].release ();\n@@ -2355,6 +2392,7 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n   dst_data->retslot_flags = src_data->retslot_flags;\n+  dst_data->static_chain_flags = src_data->static_chain_flags;\n }\n \n /* Called when new clone is inserted to callgraph late.  */\n@@ -2381,6 +2419,7 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n   dst_data->retslot_flags = src_data->retslot_flags;\n+  dst_data->static_chain_flags = src_data->static_chain_flags;\n }\n \n namespace\n@@ -2698,6 +2737,7 @@ modref_write ()\n \t  for (unsigned int i = 0; i < r->arg_flags.length (); i++)\n \t    streamer_write_uhwi (ob, r->arg_flags[i]);\n \t  streamer_write_uhwi (ob, r->retslot_flags);\n+\t  streamer_write_uhwi (ob, r->static_chain_flags);\n \n \t  write_modref_records (r->loads, ob);\n \t  write_modref_records (r->stores, ob);\n@@ -2799,6 +2839,13 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \tmodref_sum->retslot_flags = flags;\n       if (modref_sum_lto)\n \tmodref_sum_lto->retslot_flags = flags;\n+\n+      flags = streamer_read_uhwi (&ib);\n+      if (modref_sum)\n+\tmodref_sum->static_chain_flags = flags;\n+      if (modref_sum_lto)\n+\tmodref_sum_lto->static_chain_flags = flags;\n+\n       read_modref_records (&ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->loads : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->loads : NULL);\n@@ -3888,6 +3935,8 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t{\n \t  eaf_flags_t &f = ee->parm_index == escape_point::retslot_arg\n \t\t\t   ? cur_summary->retslot_flags\n+\t\t\t   : ee->parm_index == escape_point::static_chain_arg\n+\t\t\t   ? cur_summary->static_chain_flags\n \t\t\t   : cur_summary->arg_flags[ee->parm_index];\n \t  if ((f & flags) != f)\n \t    {\n@@ -3903,6 +3952,8 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t{\n \t  eaf_flags_t &f = ee->parm_index == escape_point::retslot_arg\n \t\t\t   ? cur_summary_lto->retslot_flags\n+\t\t\t   : ee->parm_index == escape_point::static_chain_arg\n+\t\t\t   ? cur_summary_lto->static_chain_flags\n \t\t\t   : cur_summary_lto->arg_flags[ee->parm_index];\n \t  if ((f & flags_lto) != f)\n \t    {"}, {"sha": "ddc868690698022e12b0247821fb3534ba2f7c80", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=a70c05120ae6f15f204a04a7df7d19941ab33ef1", "patch": "@@ -32,6 +32,7 @@ struct GTY(()) modref_summary\n   modref_records *stores;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   eaf_flags_t retslot_flags;\n+  eaf_flags_t static_chain_flags;\n   bool writes_errno;\n \n   modref_summary ();"}, {"sha": "84013541ce8535d7ee7cd4b26b36f812bf3da353", "filename": "gcc/testsuite/gcc.dg/ipa/modref-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-3.c?ref=a70c05120ae6f15f204a04a7df7d19941ab33ef1", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fdump-ipa-modref\"  } */\n+/* { dg-do link } */\n+int *ptr;\n+void linker_error ();\n+int\n+main ()\n+{\n+  int a;\n+  __attribute__((noinline)) int test2 ()\n+  {\n+    ptr = 0;\n+    return a;\n+  }\n+  a = 1;\n+  test2 ();\n+  if (a != 1)\n+    linker_error ();\n+  return 0;\n+}\n+/* { dg-final { scan-ipa-dump \"Static chain flags: noclobber noescape nodirectescape\" \"modref\" } } */"}, {"sha": "c70f5af8949af0c57531227cc9d9136b00a56ab9", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70c05120ae6f15f204a04a7df7d19941ab33ef1/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a70c05120ae6f15f204a04a7df7d19941ab33ef1", "patch": "@@ -4254,7 +4254,8 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results,\n   /* The static chain escapes as well.  */\n   if (gimple_call_chain (stmt))\n     handle_call_arg (stmt, gimple_call_chain (stmt), results,\n-\t\t     implicit_eaf_flags,\n+\t\t     implicit_eaf_flags\n+\t\t     | gimple_call_static_chain_flags (stmt),\n \t\t     callescape->id, writes_global_memory);\n \n   /* And if we applied NRV the address of the return slot escapes as well.  */"}]}