{"sha": "17653c00b9d77f94272588e58400de197005b3a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2NTNjMDBiOWQ3N2Y5NDI3MjU4OGU1ODQwMGRlMTk3MDA1YjNhNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-05-01T16:08:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-05-01T16:08:15Z"}, "message": "tree-pass.h (opt_pass): Add IPA_PASS.\n\n\n\t* tree-pass.h (opt_pass): Add IPA_PASS.\n\t(varpool_node, cgraph_node): Forward declare.\n\t(ipa_opt_pass): Define.\n\t(pass_ipa_inline): Turn into ipa_opt_pass.\n\t(pass_apply_inline): Remove.\n\t* ipa-inline.c (pass_ipa_inline): Turn into ipa_opt_pass.\n\t(apply_inline): Turn into ....\n\t(inline_transform): ... this one.\n\t(inline_generate_summary): New function.\n\t(pass_apply_inline): Remove.\n\t* function.h (ipa_opt_pass): Forward declare structure; typedef;\n\tvector.\n\t(struct function): Add ipa_transforms_to_apply.\n\t* passes.c (register_one_dump_file): Work on IPA_PASS.\n\t(init_optimization_passes): Remove pass_inline_parameters and\n\tpass_apply_inline.\n\t(pass_init_dump_file, pass_fini_dump_file): Break out from ....\n\t(execute_one_pass) ... here; apply transforms when possible.\n\t(add_ipa_transform_pass, execute_ipa_summary_asses,\n\texecute_one_ipa_transform_pass): New.\n\t(execute_ipa_pass_list): Update for IPA_PASS type.\n\nFrom-SVN: r134859", "tree": {"sha": "417705d74e26aac95b03885b54a88b3c22e0d807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/417705d74e26aac95b03885b54a88b3c22e0d807"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17653c00b9d77f94272588e58400de197005b3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17653c00b9d77f94272588e58400de197005b3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17653c00b9d77f94272588e58400de197005b3a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17653c00b9d77f94272588e58400de197005b3a6/comments", "author": null, "committer": null, "parents": [{"sha": "bd9513ea36c626d301024efb0d0eebd43ca2489a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9513ea36c626d301024efb0d0eebd43ca2489a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9513ea36c626d301024efb0d0eebd43ca2489a"}], "stats": {"total": 338, "additions": 259, "deletions": 79}, "files": [{"sha": "fe9d9c4cb2385341cf0cdbd6fd7d6f22c8f51774", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17653c00b9d77f94272588e58400de197005b3a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17653c00b9d77f94272588e58400de197005b3a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17653c00b9d77f94272588e58400de197005b3a6", "patch": "@@ -1,3 +1,27 @@\n+2008-05-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (opt_pass): Add IPA_PASS.\n+\t(varpool_node, cgraph_node): Forward declare.\n+\t(ipa_opt_pass): Define.\n+\t(pass_ipa_inline): Turn into ipa_opt_pass.\n+\t(pass_apply_inline): Remove.\n+\t* ipa-inline.c (pass_ipa_inline): Turn into ipa_opt_pass.\n+\t(apply_inline): Turn into ....\n+\t(inline_transform): ... this one.\n+\t(inline_generate_summary): New function.\n+\t(pass_apply_inline): Remove.\n+\t* function.h (ipa_opt_pass): Forward declare structure; typedef;\n+\tvector.\n+\t(struct function): Add ipa_transforms_to_apply.\n+\t* passes.c (register_one_dump_file): Work on IPA_PASS.\n+\t(init_optimization_passes): Remove pass_inline_parameters and\n+\tpass_apply_inline.\n+\t(pass_init_dump_file, pass_fini_dump_file): Break out from ....\n+\t(execute_one_pass) ... here; apply transforms when possible.\n+\t(add_ipa_transform_pass, execute_ipa_summary_asses,\n+\texecute_one_ipa_transform_pass): New.\n+\t(execute_ipa_pass_list): Update for IPA_PASS type.\n+\n 2008-05-01  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (ix86_builtin_type): Add"}, {"sha": "fcfd3b65f430bebb43427a7408e1ce0c57cfed7b", "filename": "gcc/function.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=17653c00b9d77f94272588e58400de197005b3a6", "patch": "@@ -179,6 +179,11 @@ struct call_site_record;\n \n DEF_VEC_P(temp_slot_p);\n DEF_VEC_ALLOC_P(temp_slot_p,gc);\n+struct ipa_opt_pass;\n+typedef struct ipa_opt_pass *ipa_opt_pass;\n+\n+DEF_VEC_P(ipa_opt_pass);\n+DEF_VEC_ALLOC_P(ipa_opt_pass,heap);\n \n enum function_frequency {\n   /* This function most likely won't be executed at all.\n@@ -466,6 +471,10 @@ struct function GTY(())\n   /* Properties used by the pass manager.  */\n   unsigned int curr_properties;\n   unsigned int last_verified;\n+  /* Interprocedural passes scheduled to have their transform functions\n+     applied next time we execute local pass on them.  We maintain it\n+     per-function in order to allow IPA passes to introduce new functions.  */\n+  VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n \n   /* Collected bit flags.  */\n "}, {"sha": "f0a7819cacf6e328d536265a5734e1948cc04976", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=17653c00b9d77f94272588e58400de197005b3a6", "patch": "@@ -1426,26 +1426,6 @@ cgraph_gate_inlining (void)\n   return flag_inline_trees;\n }\n \n-struct simple_ipa_opt_pass pass_ipa_inline = \n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"inline\",\t\t\t\t/* name */\n-  cgraph_gate_inlining,\t\t\t/* gate */\n-  cgraph_decide_inlining,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  PROP_cfg,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  TODO_remove_functions,\t\t/* todo_flags_finish */\n-  TODO_dump_cgraph | TODO_dump_func\n-  | TODO_remove_functions\t\t/* todo_flags_finish */\n- }\n-};\n-\n /* Because inlining might remove no-longer reachable nodes, we need to\n    keep the array visible to garbage collector to avoid reading collected\n    out nodes.  */\n@@ -1579,13 +1559,20 @@ struct gimple_opt_pass pass_inline_parameters =\n  }\n };\n \n-/* Apply inline plan to the function.  */\n-static unsigned int\n-apply_inline (void)\n+/* Note function body size.  */\n+void\n+inline_generate_summary (struct cgraph_node *node ATTRIBUTE_UNUSED)\n+{\n+  compute_inline_parameters ();\n+  return;\n+}\n+\n+/* Apply inline plan to function.  */\n+int\n+inline_transform (struct cgraph_node *node)\n {\n   unsigned int todo = 0;\n   struct cgraph_edge *e;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n \n   /* Even when not optimizing, ensure that always_inline functions get inlined.\n    */\n@@ -1617,24 +1604,33 @@ apply_inline (void)\n   return todo | execute_fixup_cfg ();\n }\n \n-struct gimple_opt_pass pass_apply_inline = \n+struct ipa_opt_pass pass_ipa_inline = \n {\n  {\n-  GIMPLE_PASS,\n-  \"apply_inline\",\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  apply_inline,\t\t\t\t/* execute */\n+  IPA_PASS,\n+  \"inline\",\t\t\t\t/* name */\n+  cgraph_gate_inlining,\t\t\t/* gate */\n+  cgraph_decide_inlining,\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n   0,\t                                /* properties_required */\n   PROP_cfg,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_verify_flow\n-  | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n- }\n+  TODO_remove_functions,\t\t/* todo_flags_finish */\n+  TODO_dump_cgraph | TODO_dump_func\n+  | TODO_remove_functions\t\t/* todo_flags_finish */\n+ },\n+ inline_generate_summary,\t\t/* function_generate_summary */\n+ NULL,\t\t\t\t\t/* variable_generate_summary */\n+ NULL,\t\t\t\t\t/* function_write_summary */\n+ NULL,\t\t\t\t\t/* variable_write_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ NULL,\t\t\t\t\t/* variable_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ inline_transform,\t\t\t/* function_transform */\n+ NULL,\t\t\t\t\t/* variable_transform */\n };\n \n #include \"gt-ipa-inline.h\""}, {"sha": "196e5a70a714c5c4f8059908def89898da61c474", "filename": "gcc/passes.c", "status": "modified", "additions": 162, "deletions": 41, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=17653c00b9d77f94272588e58400de197005b3a6", "patch": "@@ -352,7 +352,7 @@ register_one_dump_file (struct opt_pass *pass)\n \t\t\t ? 1 : pass->static_pass_number));\n \n   dot_name = concat (\".\", pass->name, num, NULL);\n-  if (pass->type == SIMPLE_IPA_PASS)\n+  if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)\n     prefix = \"ipa-\", flags = TDF_IPA;\n   else if (pass->type == GIMPLE_PASS)\n     prefix = \"tree-\", flags = TDF_TREE;\n@@ -538,7 +538,6 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_release_ssa_names);\n \t}\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n-      NEXT_PASS (pass_inline_parameters);\n     }\n   NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_matrix_reorg);\n@@ -554,7 +553,6 @@ init_optimization_passes (void)\n   /* These passes are run after IPA passes on every function that is being\n      output to the assembler file.  */\n   p = &all_passes;\n-  NEXT_PASS (pass_apply_inline);\n   NEXT_PASS (pass_all_optimizations);\n     {\n       struct opt_pass **p = &pass_all_optimizations.pass.sub;\n@@ -1054,8 +1052,58 @@ verify_curr_properties (void *data)\n }\n #endif\n \n+/* Initialize pass dump file.  */\n+\n+static bool\n+pass_init_dump_file (struct opt_pass *pass)\n+{\n+  /* If a dump file name is present, open it if enabled.  */\n+  if (pass->static_pass_number != -1)\n+    {\n+      bool initializing_dump = !dump_initialized_p (pass->static_pass_number);\n+      dump_file_name = get_dump_file_name (pass->static_pass_number);\n+      dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n+      if (dump_file && current_function_decl)\n+\t{\n+\t  const char *dname, *aname;\n+\t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n+\t  aname = (IDENTIFIER_POINTER\n+\t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n+\t  fprintf (dump_file, \"\\n;; Apply transform to function %s (%s)%s\\n\\n\", dname, aname,\n+\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     ? \" (hot)\"\n+\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     ? \" (unlikely executed)\"\n+\t     : \"\");\n+\t}\n+      return initializing_dump;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Flush PASS dump file.  */\n+\n+static void\n+pass_fini_dump_file (struct opt_pass *pass)\n+{\n+  /* Flush and close dump file.  */\n+  if (dump_file_name)\n+    {\n+      free (CONST_CAST (char *, dump_file_name));\n+      dump_file_name = NULL;\n+    }\n+\n+  if (dump_file)\n+    {\n+      dump_end (pass->static_pass_number, dump_file);\n+      dump_file = NULL;\n+    }\n+}\n+\n /* After executing the pass, apply expected changes to the function\n    properties. */\n+\n static void\n update_properties_after_pass (void *data)\n {\n@@ -1064,6 +1112,80 @@ update_properties_after_pass (void *data)\n \t\t           & ~pass->properties_destroyed;\n }\n \n+/* Schedule IPA transform pass DATA for CFUN.  */\n+\n+static void\n+add_ipa_transform_pass (void *data)\n+{\n+  struct ipa_opt_pass *ipa_pass = (struct ipa_opt_pass *) data;\n+  VEC_safe_push (ipa_opt_pass, heap, cfun->ipa_transforms_to_apply, ipa_pass);\n+}\n+\n+/* Execute IPA pass function summary generation. DATA is pointer to\n+   pass list to execute.  */\n+\n+static void\n+execute_ipa_summary_passes (void *data)\n+{\n+  struct ipa_opt_pass *ipa_pass = (struct ipa_opt_pass *)data;\n+  struct cgraph_node *node = cgraph_node (cfun->decl);\n+  while (ipa_pass && ipa_pass->pass.type == IPA_PASS)\n+    {\n+      struct opt_pass *pass = &ipa_pass->pass;\n+      if (!pass->gate || pass->gate ())\n+\t{\n+\t  pass_init_dump_file (pass);\n+\t  ipa_pass->function_generate_summary (node);\n+\t  pass_fini_dump_file (pass);\n+\t}\n+      ipa_pass = (struct ipa_opt_pass *)ipa_pass->pass.next;\n+    }\n+}\n+\n+/* Execute IPA_PASS function transform on NODE.  */\n+\n+static void\n+execute_one_ipa_transform_pass (struct cgraph_node *node,\n+\t\t\t\tstruct ipa_opt_pass *ipa_pass)\n+{\n+  struct opt_pass *pass = &ipa_pass->pass;\n+  unsigned int todo_after = 0;\n+\n+  current_pass = pass;\n+  if (!ipa_pass->function_transform)\n+    return;\n+\n+  /* Note that the folders should only create gimple expressions.\n+     This is a hack until the new folder is ready.  */\n+  in_gimple_form = (cfun && (cfun->curr_properties & PROP_trees)) != 0;\n+\n+  pass_init_dump_file (pass);\n+\n+  /* Run pre-pass verification.  */\n+  execute_todo (pass->todo_flags_start);\n+\n+  /* If a timevar is present, start it.  */\n+  if (pass->tv_id)\n+    timevar_push (pass->tv_id);\n+\n+  /* Do it!  */\n+  todo_after = ipa_pass->function_transform (node);\n+\n+  /* Stop timevar.  */\n+  if (pass->tv_id)\n+    timevar_pop (pass->tv_id);\n+\n+  /* Run post-pass cleanup and verification.  */\n+  execute_todo (todo_after);\n+  verify_interpass_invariants ();\n+\n+  pass_fini_dump_file (pass);\n+\n+  current_pass = NULL;\n+  /* Reset in_gimple_form to not break non-unit-at-a-time mode.  */\n+  in_gimple_form = false;\n+}\n+\n static bool\n execute_one_pass (struct opt_pass *pass)\n {\n@@ -1072,11 +1194,26 @@ execute_one_pass (struct opt_pass *pass)\n \n   /* IPA passes are executed on whole program, so cfun should be NULL.\n      Ohter passes needs function context set.  */\n-  if (pass->type == SIMPLE_IPA_PASS)\n+  if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)\n     gcc_assert (!cfun && !current_function_decl);\n   else\n     gcc_assert (cfun && current_function_decl);\n \n+  if (cfun && cfun->ipa_transforms_to_apply)\n+    {\n+      unsigned int i;\n+      struct cgraph_node *node = cgraph_node (current_function_decl);\n+\n+      for (i = 0; i < VEC_length (ipa_opt_pass, cfun->ipa_transforms_to_apply);\n+\t   i++)\n+\texecute_one_ipa_transform_pass (node,\n+\t\t\t\t        VEC_index (ipa_opt_pass,\n+\t\t\t\t\t\t   cfun->ipa_transforms_to_apply,\n+\t\t\t\t\t\t   i));\n+      VEC_free (ipa_opt_pass, heap, cfun->ipa_transforms_to_apply);\n+      cfun->ipa_transforms_to_apply = NULL;\n+    }\n+\n   current_pass = pass;\n   /* See if we're supposed to run this pass.  */\n   if (pass->gate && !pass->gate ())\n@@ -1100,28 +1237,7 @@ execute_one_pass (struct opt_pass *pass)\n \t\t   (void *)(size_t)pass->properties_required);\n #endif\n \n-  /* If a dump file name is present, open it if enabled.  */\n-  if (pass->static_pass_number != -1)\n-    {\n-      initializing_dump = !dump_initialized_p (pass->static_pass_number);\n-      dump_file_name = get_dump_file_name (pass->static_pass_number);\n-      dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n-      if (dump_file && current_function_decl)\n-\t{\n-\t  const char *dname, *aname;\n-\t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n-\t  aname = (IDENTIFIER_POINTER\n-\t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n-\t  fprintf (dump_file, \"\\n;; Function %s (%s)%s\\n\\n\", dname, aname,\n-\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n-\t     ? \" (hot)\"\n-\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n-\t     ? \" (unlikely executed)\"\n-\t     : \"\");\n-\t}\n-    }\n-  else\n-    initializing_dump = false;\n+  initializing_dump = pass_init_dump_file (pass);\n \n   /* If a timevar is present, start it.  */\n   if (pass->tv_id)\n@@ -1154,24 +1270,15 @@ execute_one_pass (struct opt_pass *pass)\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after | pass->todo_flags_finish);\n   verify_interpass_invariants ();\n+  if (pass->type == IPA_PASS)\n+    do_per_function (add_ipa_transform_pass, pass);\n \n   if (!current_function_decl)\n     cgraph_process_new_functions ();\n \n-  /* Flush and close dump file.  */\n-  if (dump_file_name)\n-    {\n-      free (CONST_CAST (char *, dump_file_name));\n-      dump_file_name = NULL;\n-    }\n-\n-  if (dump_file)\n-    {\n-      dump_end (pass->static_pass_number, dump_file);\n-      dump_file = NULL;\n-    }\n+  pass_fini_dump_file (pass);\n \n-  if (pass->type != SIMPLE_IPA_PASS)\n+  if (pass->type != SIMPLE_IPA_PASS && pass->type != IPA_PASS)\n     gcc_assert (!(cfun->curr_properties & PROP_trees)\n \t\t|| pass->type != RTL_PASS);\n \n@@ -1201,17 +1308,31 @@ execute_pass_list (struct opt_pass *pass)\n void\n execute_ipa_pass_list (struct opt_pass *pass)\n {\n+  bool summaries_generated = false;\n   do\n     {\n       gcc_assert (!current_function_decl);\n       gcc_assert (!cfun);\n-      gcc_assert (pass->type == SIMPLE_IPA_PASS);\n+      gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n+      if (pass->type == IPA_PASS && (!pass->gate || pass->gate ()))\n+\t{\n+\t  if (!summaries_generated)\n+\t    {\n+\t      if (!quiet_flag && !cfun)\n+\t\tfprintf (stderr, \" <summary generate>\");\n+\t      do_per_function_toporder (execute_ipa_summary_passes, pass);\n+\t    }\n+\t  summaries_generated = true;\n+\t}\n+      else\n+\tsummaries_generated = false;\n       if (execute_one_pass (pass) && pass->sub)\n \t{\n \t  if (pass->sub->type == GIMPLE_PASS)\n \t    do_per_function_toporder ((void (*)(void *))execute_pass_list,\n \t\t\t\t      pass->sub);\n-\t  else if (pass->sub->type == SIMPLE_IPA_PASS)\n+\t  else if (pass->sub->type == SIMPLE_IPA_PASS\n+\t\t   || pass->sub->type == IPA_PASS)\n \t    execute_ipa_pass_list (pass->sub);\n \t  else\n \t    gcc_unreachable ();"}, {"sha": "4d16ed697d468b2666348d9a517c6e359564d626", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17653c00b9d77f94272588e58400de197005b3a6/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=17653c00b9d77f94272588e58400de197005b3a6", "patch": "@@ -96,7 +96,8 @@ struct opt_pass\n   enum opt_pass_type {\n     GIMPLE_PASS,\n     RTL_PASS,\n-    SIMPLE_IPA_PASS\n+    SIMPLE_IPA_PASS,\n+    IPA_PASS\n   } type;\n   /* Terse name of the pass used as a fragment of the dump file name.  */\n   const char *name;\n@@ -133,7 +134,7 @@ struct opt_pass\n   unsigned int todo_flags_finish;\n };\n \n-/* Description or GIMPLE pass.  */\n+/* Description of GIMPLE pass.  */\n struct gimple_opt_pass\n {\n   struct opt_pass pass;\n@@ -145,7 +146,36 @@ struct rtl_opt_pass\n   struct opt_pass pass;\n };\n \n-/* Description if simple IPA pass.  Simple IPA passes have just one execute\n+struct varpool_node;\n+struct cgraph_node;\n+\n+/* Description of IPA pass with generate summary, write, execute, read and\n+   transform stages.  */\n+struct ipa_opt_pass\n+{\n+  struct opt_pass pass;\n+\n+  /* IPA passes can analyze function body and variable initializers using this\n+      hook and produce summary.  */\n+  void (*function_generate_summary) (struct cgraph_node *);\n+  void (*variable_generate_summary) (struct varpool_node *);\n+\n+  /* These hooks will be used to serialize IPA summaries on disk.  For a moment\n+      they are just placeholders.  */\n+  void (*function_write_summary) (struct cgraph_node *); \n+  void (*variable_write_summary) (struct varpool_node *);\n+  void (*function_read_summary) (struct cgraph_node *);\n+  void (*variable_read_summary) (struct varpool_node *);\n+\n+  /* Results of interprocedural propagation of an IPA pass is applied to\n+     function body via this hook.  */\n+  unsigned int function_transform_todo_flags_start;\n+  unsigned int (*function_transform) (struct cgraph_node *);\n+  void (*variable_transform) (struct varpool_node *);\n+\n+};\n+\n+/* Description of simple IPA pass.  Simple IPA passes have just one execute\n    hook.  */\n struct simple_ipa_opt_pass\n {\n@@ -353,9 +383,10 @@ extern struct gimple_opt_pass pass_build_cgraph_edges;\n extern struct gimple_opt_pass pass_reset_cc_flags;\n \n /* IPA Passes */\n+extern struct ipa_opt_pass pass_ipa_inline;\n+\n extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;\n extern struct simple_ipa_opt_pass pass_ipa_cp;\n-extern struct simple_ipa_opt_pass pass_ipa_inline;\n extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n extern struct simple_ipa_opt_pass pass_ipa_reference;\n extern struct simple_ipa_opt_pass pass_ipa_pure_const;\n@@ -471,7 +502,6 @@ extern struct rtl_opt_pass pass_rtl_seqabstr;\n extern struct gimple_opt_pass pass_release_ssa_names;\n extern struct gimple_opt_pass pass_early_inline;\n extern struct gimple_opt_pass pass_inline_parameters;\n-extern struct gimple_opt_pass pass_apply_inline;\n extern struct gimple_opt_pass pass_all_early_optimizations;\n extern struct gimple_opt_pass pass_update_address_taken;\n "}]}