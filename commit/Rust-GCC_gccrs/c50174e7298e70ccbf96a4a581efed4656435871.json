{"sha": "c50174e7298e70ccbf96a4a581efed4656435871", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwMTc0ZTcyOThlNzBjY2JmOTZhNGE1ODFlZmVkNDY1NjQzNTg3MQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-06-12T11:00:29Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-06-12T11:00:29Z"}, "message": "* doc/gcov.texi: Use more logical markup.\n\nFrom-SVN: r43253", "tree": {"sha": "ef24e311c1029728c31d50dffc82256faf86fdb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef24e311c1029728c31d50dffc82256faf86fdb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c50174e7298e70ccbf96a4a581efed4656435871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50174e7298e70ccbf96a4a581efed4656435871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c50174e7298e70ccbf96a4a581efed4656435871", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50174e7298e70ccbf96a4a581efed4656435871/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17d6c819b243430b45e57e2a556fa37912f2c7e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17d6c819b243430b45e57e2a556fa37912f2c7e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17d6c819b243430b45e57e2a556fa37912f2c7e4"}], "stats": {"total": 124, "additions": 64, "deletions": 60}, "files": [{"sha": "971b753876db29de1d19418d0ce9afeeb8d085e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50174e7298e70ccbf96a4a581efed4656435871/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50174e7298e70ccbf96a4a581efed4656435871/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c50174e7298e70ccbf96a4a581efed4656435871", "patch": "@@ -1,3 +1,7 @@\n+2001-06-12  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* doc/gcov.texi: Use more logical markup.\n+\n 2001-06-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* unroll.c (initial_reg_note_copy): Use PUT_REG_NOTE_KIND and"}, {"sha": "e2080670392375466f8f83af612f3b09f51b8e65", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50174e7298e70ccbf96a4a581efed4656435871/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50174e7298e70ccbf96a4a581efed4656435871/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=c50174e7298e70ccbf96a4a581efed4656435871", "patch": "@@ -27,12 +27,12 @@ English.\n @end ignore\n \n @node Gcov\n-@chapter @code{gcov}: a Test Coverage Program\n+@chapter @command{gcov}: a Test Coverage Program\n \n-@code{gcov} is a tool you can use in conjunction with @sc{gnu} CC to\n+@command{gcov} is a tool you can use in conjunction with @sc{gnu} CC to\n test code coverage in your programs.\n \n-This chapter describes version 1.5 of @code{gcov}.\n+This chapter describes version 1.5 of @command{gcov}.\n \n @menu\n * Gcov Intro::         \t        Introduction to gcov.\n@@ -42,19 +42,19 @@ This chapter describes version 1.5 of @code{gcov}.\n @end menu\n \n @node Gcov Intro\n-@section Introduction to @code{gcov}\n+@section Introduction to @command{gcov}\n @c man begin DESCRIPTION\n \n-@code{gcov} is a test coverage program.  Use it in concert with @sc{gnu}\n+@command{gcov} is a test coverage program.  Use it in concert with @sc{gnu}\n CC to analyze your programs to help create more efficient, faster\n-running code.  You can use @code{gcov} as a profiling tool to help\n+running code.  You can use @command{gcov} as a profiling tool to help\n discover where your optimization efforts will best affect your code.  You\n-can also use @code{gcov} along with the other profiling tool,\n-@code{gprof}, to assess which parts of your code use the greatest amount\n+can also use @command{gcov} along with the other profiling tool,\n+@command{gprof}, to assess which parts of your code use the greatest amount\n of computing time.\n \n Profiling tools help you analyze your code's performance.  Using a\n-profiler such as @code{gcov} or @code{gprof}, you can find out some\n+profiler such as @command{gcov} or @command{gprof}, you can find out some\n basic performance statistics, such as:\n \n @itemize @bullet\n@@ -70,7 +70,7 @@ how much computing time each section of code uses\n \n Once you know these things about how your code works when compiled, you\n can look at each module to see which modules should be optimized.\n-@code{gcov} helps you determine where to work on optimization.\n+@command{gcov} helps you determine where to work on optimization.\n \n Software developers also use coverage testing in concert with\n testsuites, to make sure software is actually good enough for a release.\n@@ -81,25 +81,25 @@ to be added to the testsuites to create both better testing and a better\n final product.\n \n You should compile your code without optimization if you plan to use\n-@code{gcov} because the optimization, by combining some lines of code\n+@command{gcov} because the optimization, by combining some lines of code\n into one function, may not give you as much information as you need to\n look for `hot spots' where the code is using a great deal of computer\n-time.  Likewise, because @code{gcov} accumulates statistics by line (at\n+time.  Likewise, because @command{gcov} accumulates statistics by line (at\n the lowest resolution), it works best with a programming style that\n places only one statement on each line.  If you use complicated macros\n that expand to loops or to other control structures, the statistics are\n less helpful---they only report on the line where the macro call\n appears.  If your complex macros behave like functions, you can replace\n them with inline functions to solve this problem.\n \n-@code{gcov} creates a logfile called @file{@var{sourcefile}.gcov} which\n+@command{gcov} creates a logfile called @file{@var{sourcefile}.gcov} which\n indicates how many times each line of a source file @file{@var{sourcefile}.c}\n-has executed.  You can use these logfiles along with @code{gprof} to aid\n-in fine-tuning the performance of your programs.  @code{gprof} gives\n+has executed.  You can use these logfiles along with @command{gprof} to aid\n+in fine-tuning the performance of your programs.  @command{gprof} gives\n timing information you can use along with the information you get from\n-@code{gcov}.\n+@command{gcov}.\n \n-@code{gcov} works only on code compiled with @sc{gnu} CC.  It is not\n+@command{gcov} works only on code compiled with @sc{gnu} CC.  It is not\n compatible with any other profiling or test coverage mechanism.\n \n @c man end\n@@ -121,7 +121,7 @@ gcc(1) and the Info entry for @file{gcc}.\n @end ignore\n \n @c man begin OPTIONS\n-@table @code\n+@table @gcctabopt\n @item -b\n Write branch frequencies to the output file, and write branch summary\n info to the standard output.  This option allows you to see how often\n@@ -132,28 +132,28 @@ Write branch frequencies as the number of branches taken, rather than\n the percentage of branches taken.\n \n @item -v\n-Display the @code{gcov} version number (on the standard error stream).\n+Display the @command{gcov} version number (on the standard error stream).\n \n @item -n\n-Do not create the @code{gcov} output file.\n+Do not create the @command{gcov} output file.\n \n @item -l\n Create long file names for included source files.  For example, if the\n-header file @samp{x.h} contains code, and was included in the file\n-@samp{a.c}, then running @code{gcov} on the file @samp{a.c} will produce\n-an output file called @samp{a.c.x.h.gcov} instead of @samp{x.h.gcov}.\n-This can be useful if @samp{x.h} is included in multiple source files.\n+header file @file{x.h} contains code, and was included in the file\n+@file{a.c}, then running @command{gcov} on the file @file{a.c} will produce\n+an output file called @file{a.c.x.h.gcov} instead of @file{x.h.gcov}.\n+This can be useful if @file{x.h} is included in multiple source files.\n \n @item -f\n Output summaries for each function in addition to the file level summary.\n \n @item -o\n-The directory where the object files live.  Gcov will search for @code{.bb},\n-@code{.bbg}, and @code{.da} files in this directory.\n+The directory where the object files live.  Gcov will search for @file{.bb},\n+@file{.bbg}, and @file{.da} files in this directory.\n @end table\n \n @need 3000\n-When using @code{gcov}, you must first compile your program with two\n+When using @command{gcov}, you must first compile your program with two\n special @sc{gnu} CC options: @samp{-fprofile-arcs -ftest-coverage}.\n This tells the compiler to generate additional information needed by\n gcov (basically a flow graph of the program) and also includes\n@@ -162,13 +162,13 @@ information needed by gcov.  These additional files are placed in the\n directory where the source code is located.\n \n Running the program will cause profile output to be generated.  For each\n-source file compiled with -fprofile-arcs, an accompanying @code{.da}\n+source file compiled with @option{-fprofile-arcs}, an accompanying @file{.da}\n file will be placed in the source directory.\n \n-Running @code{gcov} with your program's source file names as arguments\n+Running @command{gcov} with your program's source file names as arguments\n will now produce a listing of the code along with frequency of execution\n-for each line.  For example, if your program is called @samp{tmp.c}, this\n-is what you see when you use the basic @code{gcov} facility:\n+for each line.  For example, if your program is called @file{tmp.c}, this\n+is what you see when you use the basic @command{gcov} facility:\n \n @smallexample\n $ gcc -fprofile-arcs -ftest-coverage tmp.c\n@@ -178,7 +178,7 @@ $ gcov tmp.c\n Creating tmp.c.gcov.\n @end smallexample\n \n-The file @file{tmp.c.gcov} contains output from @code{gcov}.\n+The file @file{tmp.c.gcov} contains output from @command{gcov}.\n Here is a sample:\n \n @smallexample\n@@ -199,7 +199,7 @@ Here is a sample:\n @end smallexample\n \n @need 450\n-When you use the @samp{-b} option, your output looks like this:\n+When you use the @option{-b} option, your output looks like this:\n \n @smallexample\n $ gcov -b tmp.c\n@@ -257,25 +257,25 @@ of times the call was executed will be printed.  This will usually be\n and thus may not return every time they are called.\n \n The execution counts are cumulative.  If the example program were\n-executed again without removing the @code{.da} file, the count for the\n+executed again without removing the @file{.da} file, the count for the\n number of times each line in the source was executed would be added to\n the results of the previous run(s).  This is potentially useful in\n several ways.  For example, it could be used to accumulate data over a\n number of program runs as part of a test verification suite, or to\n provide more accurate long-term information over a large number of\n program runs.\n \n-The data in the @code{.da} files is saved immediately before the program\n-exits.  For each source file compiled with -fprofile-arcs, the profiling\n-code first attempts to read in an existing @code{.da} file; if the file\n+The data in the @file{.da} files is saved immediately before the program\n+exits.  For each source file compiled with @option{-fprofile-arcs}, the profiling\n+code first attempts to read in an existing @file{.da} file; if the file\n doesn't match the executable (differing number of basic block counts) it\n will ignore the contents of the file.  It then adds in the new execution\n counts and finally writes the data to the file.\n \n @node Gcov and Optimization\n-@section Using @code{gcov} with GCC Optimization\n+@section Using @command{gcov} with GCC Optimization\n \n-If you plan to use @code{gcov} to help optimize your code, you must\n+If you plan to use @command{gcov} to help optimize your code, you must\n first compile your program with two special @sc{gnu} CC options:\n @samp{-fprofile-arcs -ftest-coverage}.  Aside from that, you can use any\n other @sc{gnu} CC options; but if you want to prove that every single line\n@@ -293,9 +293,9 @@ else\n \n @noindent\n can be compiled into one instruction on some machines.  In this case,\n-there is no way for @code{gcov} to calculate separate execution counts\n+there is no way for @command{gcov} to calculate separate execution counts\n for each line because there isn't separate code for each line.  Hence\n-the @code{gcov} output looks like this if you compiled the program with\n+the @command{gcov} output looks like this if you compiled the program with\n optimization:\n \n @smallexample\n@@ -313,35 +313,35 @@ many times the result was 1.\n @c man end\n \n @node Gcov Data Files\n-@section Brief description of @code{gcov} data files\n+@section Brief description of @command{gcov} data files\n \n-@code{gcov} uses three files for doing profiling.  The names of these\n+@command{gcov} uses three files for doing profiling.  The names of these\n files are derived from the original @emph{source} file by substituting\n-the file suffix with either @code{.bb}, @code{.bbg}, or @code{.da}.  All\n+the file suffix with either @file{.bb}, @file{.bbg}, or @file{.da}.  All\n of these files are placed in the same directory as the source file, and\n contain data stored in a platform-independent method.\n \n-The @code{.bb} and @code{.bbg} files are generated when the source file\n-is compiled with the @sc{gnu} CC @samp{-ftest-coverage} option.  The\n-@code{.bb} file contains a list of source files (including headers),\n+The @file{.bb} and @file{.bbg} files are generated when the source file\n+is compiled with the @sc{gnu} CC @option{-ftest-coverage} option.  The\n+@file{.bb} file contains a list of source files (including headers),\n functions within those files, and line numbers corresponding to each\n basic block in the source file.\n \n-The @code{.bb} file format consists of several lists of 4-byte integers\n+The @file{.bb} file format consists of several lists of 4-byte integers\n which correspond to the line numbers of each basic block in the\n file.  Each list is terminated by a line number of 0.  A line number of -1\n is used to designate that the source file name (padded to a 4-byte\n boundary and followed by another -1) follows.  In addition, a line number\n of -2 is used to designate that the name of a function (also padded to a\n 4-byte boundary and followed by a -2) follows.\n \n-The @code{.bbg} file is used to reconstruct the program flow graph for\n+The @file{.bbg} file is used to reconstruct the program flow graph for\n the source file.  It contains a list of the program flow arcs (possible\n branches taken from one basic block to another) for each function which,\n-in combination with the @code{.bb} file, enables gcov to reconstruct the\n+in combination with the @file{.bb} file, enables gcov to reconstruct the\n program flow.\n \n-In the @code{.bbg} file, the format is:\n+In the @file{.bbg} file, the format is:\n @smallexample\n         number of basic blocks for function #0 (4-byte number)\n         total number of arcs for function #0 (4-byte number)\n@@ -363,24 +363,24 @@ A -1 (stored as a 4-byte number) is used to separate each function's\n list of basic blocks, and to verify that the file has been read\n correctly.\n \n-The @code{.da} file is generated when a program containing object files\n-built with the @sc{gnu} CC @samp{-fprofile-arcs} option is executed.  A\n-separate @code{.da} file is created for each source file compiled with\n-this option, and the name of the @code{.da} file is stored as an\n+The @file{.da} file is generated when a program containing object files\n+built with the @sc{gnu} CC @option{-fprofile-arcs} option is executed.  A\n+separate @file{.da} file is created for each source file compiled with\n+this option, and the name of the @file{.da} file is stored as an\n absolute pathname in the resulting object file.  This path name is\n-derived from the source file name by substituting a @code{.da} suffix.\n+derived from the source file name by substituting a @file{.da} suffix.\n \n-The format of the @code{.da} file is fairly simple.  The first 8-byte\n+The format of the @file{.da} file is fairly simple.  The first 8-byte\n number is the number of counts in the file, followed by the counts\n (stored as 8-byte numbers).  Each count corresponds to the number of\n times each arc in the program is executed.  The counts are cumulative;\n each time the program is executed, it attempts to combine the existing\n-@code{.da} files with the new counts for this invocation of the\n-program.  It ignores the contents of any @code{.da} files whose number of\n+@file{.da} files with the new counts for this invocation of the\n+program.  It ignores the contents of any @file{.da} files whose number of\n arcs doesn't correspond to the current program, and merely overwrites\n them instead.\n \n-All three of these files use the functions in @code{gcov-io.h} to store\n+All three of these files use the functions in @file{gcov-io.h} to store\n integers; the functions in this header provide a machine-independent\n mechanism for storing and retrieving data from a stream.\n "}]}