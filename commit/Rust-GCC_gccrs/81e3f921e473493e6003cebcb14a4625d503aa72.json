{"sha": "81e3f921e473493e6003cebcb14a4625d503aa72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFlM2Y5MjFlNDczNDkzZTYwMDNjZWJjYjE0YTQ2MjVkNTAzYWE3Mg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-25T16:41:29Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-25T16:41:29Z"}, "message": "config/arm: Use rtx_insn and rtx_code_label\n\ngcc/\n\t* config/arm/arm-protos.h (arm_final_prescan_insn): Strengthen\n\tparam from rtx to rtx_insn *.\n\t(thumb1_final_prescan_insn): Likewise.\n\t(thumb2_final_prescan_insn): Likewise.\n\n\t* config/arm/arm.c (emit_set_insn): Strengthen return type from\n\trtx to rtx_insn *.\n\t(struct minipool_node): Likewise for field \"insn\".\n\t(dump_minipool): Likewise for param \"scan\".\n\t(create_fix_barrier): Likewise for local \"from\".  Strengthen local\n\t\"label\" from rtx to rtx_code_label *.\n\t(push_minipool_barrier): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(push_minipool_fix): Likewise.\n\t(note_invalid_constants): Likewise.\n\t(thumb2_reorg): Likewise for local \"insn\".\n\t(arm_reorg): Likewise.\n\t(thumb2_final_prescan_insn): Likewise for param\n\t\"insn\" and local \"first_insn\".\n\t(arm_final_prescan_insn): Likewise for param \"insn\" and locals\n\t\"start_insn\", \"this_insn\".\n\t(arm_debugger_arg_offset): Likewise for param \"insn\".\n\t(thumb1_emit_multi_reg_push): Likewise for return type and local\n\t\"insn\".\n\t(thumb1_final_prescan_insn): Likewise for param \"insn\".\n\t(thumb_far_jump_used_p): Likewise for local \"insn\".\n\t(thumb1_expand_prologue): Likewise.\n\t(arm_expand_epilogue_apcs_frame): Likewise.\n\t(arm_expand_epilogue): Likewise for locals \"insn\", \"tmp\".\n\t(arm_split_compare_and_swap): Strengthen locals \"label1\", \"label2\"\n\tfrom rtx to rtx_code_label *.\n\t(arm_split_atomic_op): Likewise for local \"label\".\n\t(arm_emit_coreregs_64bit_shift): Likewise for local \"done_label\".\n\nFrom-SVN: r214437", "tree": {"sha": "7f658e9f7cc522d2ef70d94a151b75482ab97cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f658e9f7cc522d2ef70d94a151b75482ab97cc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81e3f921e473493e6003cebcb14a4625d503aa72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e3f921e473493e6003cebcb14a4625d503aa72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81e3f921e473493e6003cebcb14a4625d503aa72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e3f921e473493e6003cebcb14a4625d503aa72/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3458f6117797fd0fff6b451e771a18fe6ba0434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3458f6117797fd0fff6b451e771a18fe6ba0434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3458f6117797fd0fff6b451e771a18fe6ba0434"}], "stats": {"total": 133, "additions": 87, "deletions": 46}, "files": [{"sha": "9e53eb29a99a2c19d42cb4e835b01a42f938fe2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81e3f921e473493e6003cebcb14a4625d503aa72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81e3f921e473493e6003cebcb14a4625d503aa72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81e3f921e473493e6003cebcb14a4625d503aa72", "patch": "@@ -1,3 +1,39 @@\n+2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* config/arm/arm-protos.h (arm_final_prescan_insn): Strengthen\n+\tparam from rtx to rtx_insn *.\n+\t(thumb1_final_prescan_insn): Likewise.\n+\t(thumb2_final_prescan_insn): Likewise.\n+\n+\t* config/arm/arm.c (emit_set_insn): Strengthen return type from\n+\trtx to rtx_insn *.\n+\t(struct minipool_node): Likewise for field \"insn\".\n+\t(dump_minipool): Likewise for param \"scan\".\n+\t(create_fix_barrier): Likewise for local \"from\".  Strengthen local\n+\t\"label\" from rtx to rtx_code_label *.\n+\t(push_minipool_barrier): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(push_minipool_fix): Likewise.\n+\t(note_invalid_constants): Likewise.\n+\t(thumb2_reorg): Likewise for local \"insn\".\n+\t(arm_reorg): Likewise.\n+\t(thumb2_final_prescan_insn): Likewise for param\n+\t\"insn\" and local \"first_insn\".\n+\t(arm_final_prescan_insn): Likewise for param \"insn\" and locals\n+\t\"start_insn\", \"this_insn\".\n+\t(arm_debugger_arg_offset): Likewise for param \"insn\".\n+\t(thumb1_emit_multi_reg_push): Likewise for return type and local\n+\t\"insn\".\n+\t(thumb1_final_prescan_insn): Likewise for param \"insn\".\n+\t(thumb_far_jump_used_p): Likewise for local \"insn\".\n+\t(thumb1_expand_prologue): Likewise.\n+\t(arm_expand_epilogue_apcs_frame): Likewise.\n+\t(arm_expand_epilogue): Likewise for locals \"insn\", \"tmp\".\n+\t(arm_split_compare_and_swap): Strengthen locals \"label1\", \"label2\"\n+\tfrom rtx to rtx_code_label *.\n+\t(arm_split_atomic_op): Likewise for local \"label\".\n+\t(arm_emit_coreregs_64bit_shift): Likewise for local \"done_label\".\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/arc/arc-protos.h (arc_final_prescan_insn): Strengthen"}, {"sha": "d3540c779c026cd5b2e73f07ec2818ffcade982b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81e3f921e473493e6003cebcb14a4625d503aa72/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81e3f921e473493e6003cebcb14a4625d503aa72/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=81e3f921e473493e6003cebcb14a4625d503aa72", "patch": "@@ -144,7 +144,7 @@ extern const char *arithmetic_instr (rtx, int);\n extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);\n extern const char *output_return_instruction (rtx, bool, bool, bool);\n extern void arm_poke_function_name (FILE *, const char *);\n-extern void arm_final_prescan_insn (rtx);\n+extern void arm_final_prescan_insn (rtx_insn *);\n extern int arm_debugger_arg_offset (int, rtx);\n extern bool arm_is_long_call_p (tree);\n extern int    arm_emit_vector_const (FILE *, rtx);\n@@ -185,8 +185,8 @@ extern int is_called_in_ARM_mode (tree);\n extern int thumb_shiftable_const (unsigned HOST_WIDE_INT);\n #ifdef RTX_CODE\n extern enum arm_cond_code maybe_get_arm_condition_code (rtx);\n-extern void thumb1_final_prescan_insn (rtx);\n-extern void thumb2_final_prescan_insn (rtx);\n+extern void thumb1_final_prescan_insn (rtx_insn *);\n+extern void thumb2_final_prescan_insn (rtx_insn *);\n extern const char *thumb_load_double_from_address (rtx *);\n extern const char *thumb_output_move_mem_multiple (int, rtx *);\n extern const char *thumb_call_via_reg (rtx);"}, {"sha": "c33c17996b1b58833c23023eff281d33c9c20ce7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81e3f921e473493e6003cebcb14a4625d503aa72/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81e3f921e473493e6003cebcb14a4625d503aa72/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=81e3f921e473493e6003cebcb14a4625d503aa72", "patch": "@@ -115,14 +115,14 @@ static Mnode *move_minipool_fix_backward_ref (Mnode *, Mnode *, HOST_WIDE_INT);\n static Mnode *add_minipool_backward_ref (Mfix *);\n static void assign_minipool_offsets (Mfix *);\n static void arm_print_value (FILE *, rtx);\n-static void dump_minipool (rtx);\n+static void dump_minipool (rtx_insn *);\n static int arm_barrier_cost (rtx);\n static Mfix *create_fix_barrier (Mfix *, HOST_WIDE_INT);\n-static void push_minipool_barrier (rtx, HOST_WIDE_INT);\n-static void push_minipool_fix (rtx, HOST_WIDE_INT, rtx *, enum machine_mode,\n-\t\t\t       rtx);\n+static void push_minipool_barrier (rtx_insn *, HOST_WIDE_INT);\n+static void push_minipool_fix (rtx_insn *, HOST_WIDE_INT, rtx *,\n+\t\t\t       enum machine_mode, rtx);\n static void arm_reorg (void);\n-static void note_invalid_constants (rtx, HOST_WIDE_INT, int);\n+static void note_invalid_constants (rtx_insn *, HOST_WIDE_INT, int);\n static unsigned long arm_compute_save_reg0_reg12_mask (void);\n static unsigned long arm_compute_save_reg_mask (void);\n static unsigned long arm_isr_value (tree);\n@@ -180,7 +180,7 @@ static rtx arm_expand_unop_builtin (enum insn_code, tree, rtx, int);\n static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static tree arm_builtin_decl (unsigned, bool);\n static void emit_constant_insn (rtx cond, rtx pattern);\n-static rtx emit_set_insn (rtx, rtx);\n+static rtx_insn *emit_set_insn (rtx, rtx);\n static rtx emit_multi_reg_push (unsigned long, unsigned long);\n static int arm_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t  tree, bool);\n@@ -2075,7 +2075,7 @@ arm_constant_limit (bool size_p)\n \n /* Emit an insn that's a simple single-set.  Both the operands must be known\n    to be valid.  */\n-inline static rtx\n+inline static rtx_insn *\n emit_set_insn (rtx x, rtx y)\n {\n   return emit_insn (gen_rtx_SET (VOIDmode, x, y));\n@@ -16091,7 +16091,7 @@ struct minipool_node\n struct minipool_fixup\n {\n   Mfix *            next;\n-  rtx               insn;\n+  rtx_insn *        insn;\n   HOST_WIDE_INT     address;\n   rtx *             loc;\n   enum machine_mode mode;\n@@ -16571,7 +16571,7 @@ assign_minipool_offsets (Mfix *barrier)\n \n /* Output the literal table */\n static void\n-dump_minipool (rtx scan)\n+dump_minipool (rtx_insn *scan)\n {\n   Mnode * mp;\n   Mnode * nmp;\n@@ -16694,16 +16694,16 @@ static Mfix *\n create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n {\n   HOST_WIDE_INT count = 0;\n-  rtx barrier;\n-  rtx from = fix->insn;\n+  rtx_barrier *barrier;\n+  rtx_insn *from = fix->insn;\n   /* The instruction after which we will insert the jump.  */\n   rtx selected = NULL;\n   int selected_cost;\n   /* The address at which the jump instruction will be placed.  */\n   HOST_WIDE_INT selected_address;\n   Mfix * new_fix;\n   HOST_WIDE_INT max_count = max_address - fix->address;\n-  rtx label = gen_label_rtx ();\n+  rtx_code_label *label = gen_label_rtx ();\n \n   selected_cost = arm_barrier_cost (from);\n   selected_address = fix->address;\n@@ -16792,7 +16792,7 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n /* Record that there is a natural barrier in the insn stream at\n    ADDRESS.  */\n static void\n-push_minipool_barrier (rtx insn, HOST_WIDE_INT address)\n+push_minipool_barrier (rtx_insn *insn, HOST_WIDE_INT address)\n {\n   Mfix * fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (* fix));\n \n@@ -16814,7 +16814,7 @@ push_minipool_barrier (rtx insn, HOST_WIDE_INT address)\n    fixing; VALUE is the constant that must be loaded, which is of type\n    MODE.  */\n static void\n-push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n+push_minipool_fix (rtx_insn *insn, HOST_WIDE_INT address, rtx *loc,\n \t\t   enum machine_mode mode, rtx value)\n {\n   Mfix * fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (* fix));\n@@ -16970,7 +16970,7 @@ arm_const_double_by_immediates (rtx val)\n    If DO_PUSHES is false we do not actually push any of the fixups\n    needed.  */\n static void\n-note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n+note_invalid_constants (rtx_insn *insn, HOST_WIDE_INT address, int do_pushes)\n {\n   int opno;\n \n@@ -17130,7 +17130,7 @@ thumb2_reorg (void)\n \t  && optimize_bb_for_speed_p (bb))\n \tcontinue;\n \n-      rtx insn;\n+      rtx_insn *insn;\n       Convert_Action action = SKIP;\n       Convert_Action action_for_partial_flag_setting\n \t= (current_tune->disparage_partial_flag_setting_t16_encodings\n@@ -17324,7 +17324,7 @@ thumb2_reorg (void)\n static void\n arm_reorg (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   HOST_WIDE_INT address = 0;\n   Mfix * fix;\n \n@@ -22569,9 +22569,9 @@ get_arm_condition_code (rtx comparison)\n /* Tell arm_asm_output_opcode to output IT blocks for conditionally executed\n    instructions.  */\n void\n-thumb2_final_prescan_insn (rtx insn)\n+thumb2_final_prescan_insn (rtx_insn *insn)\n {\n-  rtx first_insn = insn;\n+  rtx_insn *first_insn = insn;\n   rtx body = PATTERN (insn);\n   rtx predicate;\n   enum arm_cond_code code;\n@@ -22653,7 +22653,7 @@ thumb2_final_prescan_insn (rtx insn)\n }\n \n void\n-arm_final_prescan_insn (rtx insn)\n+arm_final_prescan_insn (rtx_insn *insn)\n {\n   /* BODY will hold the body of INSN.  */\n   rtx body = PATTERN (insn);\n@@ -22668,7 +22668,7 @@ arm_final_prescan_insn (rtx insn)\n \n   /* START_INSN will hold the insn from where we start looking.  This is the\n      first insn after the following code_label if REVERSE is true.  */\n-  rtx start_insn = insn;\n+  rtx_insn *start_insn = insn;\n \n   /* If in state 4, check if the target branch is reached, in order to\n      change back to state 0.  */\n@@ -22740,7 +22740,8 @@ arm_final_prescan_insn (rtx insn)\n       int fail = FALSE, succeed = FALSE;\n       /* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */\n       int then_not_else = TRUE;\n-      rtx this_insn = start_insn, label = 0;\n+      rtx_insn *this_insn = start_insn;\n+      rtx label = 0;\n \n       /* Register the insn jumped to.  */\n       if (reverse)\n@@ -23111,7 +23112,7 @@ arm_regno_class (int regno)\n int\n arm_debugger_arg_offset (int value, rtx addr)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* We are only interested if dbxout_parms() failed to compute the offset.  */\n   if (value != 0)\n@@ -26145,11 +26146,12 @@ number_of_first_bit_set (unsigned mask)\n    to be saved; REAL_REGS is the set of registers to be described as\n    saved.  If REAL_REGS is 0, only describe the stack adjustment.  */\n \n-static rtx\n+static rtx_insn *\n thumb1_emit_multi_reg_push (unsigned long mask, unsigned long real_regs)\n {\n   unsigned long regno;\n-  rtx par[10], tmp, reg, insn;\n+  rtx par[10], tmp, reg;\n+  rtx_insn *insn;\n   int i, j;\n \n   /* Build the parallel of the registers actually being stored.  */\n@@ -26545,7 +26547,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n    For Thumb-1, we track the status of the condition codes; this\n    information is used in the cbranchsi4_insn pattern.  */\n void\n-thumb1_final_prescan_insn (rtx insn)\n+thumb1_final_prescan_insn (rtx_insn *insn)\n {\n   if (flag_print_asm_name)\n     asm_fprintf (asm_out_file, \"%@ 0x%04x\\n\",\n@@ -26614,7 +26616,7 @@ thumb_shiftable_const (unsigned HOST_WIDE_INT val)\n static int\n thumb_far_jump_used_p (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   bool far_jump = false;\n   unsigned int func_size = 0;\n \n@@ -27063,7 +27065,7 @@ thumb_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n void\n thumb1_expand_prologue (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   HOST_WIDE_INT amount;\n   arm_stack_offsets *offsets;\n@@ -27515,7 +27517,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n       int saved_size = arm_get_vfp_saved_size ();\n       if (saved_size > 0)\n         {\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n           floats_from_frame += saved_size;\n           insn = emit_insn (gen_addsi3 (ip_rtx,\n \t\t\t\t\thard_frame_pointer_rtx,\n@@ -27554,7 +27556,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n     {\n       /* The frame pointer is guaranteed to be non-double-word aligned, as\n          it is set to double-word-aligned old_stack_pointer - 4.  */\n-      rtx insn;\n+      rtx_insn *insn;\n       int lrm_count = (num_regs % 2) ? (num_regs + 2) : (num_regs + 1);\n \n       for (i = LAST_IWMMXT_REGNUM; i >= FIRST_IWMMXT_REGNUM; i--)\n@@ -27594,7 +27596,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n   num_regs = bit_count (saved_regs_mask);\n   if ((offsets->outgoing_args != (1 + num_regs)) || cfun->calls_alloca)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       emit_insn (gen_blockage ());\n       /* Unwind the stack to just below the saved registers.  */\n       insn = emit_insn (gen_addsi3 (stack_pointer_rtx,\n@@ -27611,7 +27613,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n     {\n       /* Interrupt handlers will have pushed the\n          IP onto the stack, so restore it now.  */\n-      rtx insn;\n+      rtx_insn *insn;\n       rtx addr = gen_rtx_MEM (SImode,\n                               gen_rtx_POST_INC (SImode,\n                               stack_pointer_rtx));\n@@ -27680,7 +27682,7 @@ arm_expand_epilogue (bool really_return)\n \n   if (frame_pointer_needed)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       /* Restore stack pointer if necessary.  */\n       if (TARGET_ARM)\n         {\n@@ -27737,7 +27739,7 @@ arm_expand_epilogue (bool really_return)\n       amount = offsets->outgoing_args - offsets->saved_regs;\n       if (amount)\n         {\n-\t  rtx tmp;\n+\t  rtx_insn *tmp;\n           /* Force out any pending memory operations that reference stacked data\n              before stack de-allocation occurs.  */\n           emit_insn (gen_blockage ());\n@@ -27789,7 +27791,7 @@ arm_expand_epilogue (bool really_return)\n     for (i = FIRST_IWMMXT_REGNUM; i <= LAST_IWMMXT_REGNUM; i++)\n       if (df_regs_ever_live_p (i) && !call_used_regs[i])\n         {\n-          rtx insn;\n+          rtx_insn *insn;\n           rtx addr = gen_rtx_MEM (V2SImode,\n                                   gen_rtx_POST_INC (SImode,\n                                                     stack_pointer_rtx));\n@@ -27878,9 +27880,10 @@ arm_expand_epilogue (bool really_return)\n     {\n       int i, j;\n       rtx dwarf = NULL_RTX;\n-      rtx tmp = emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t   stack_pointer_rtx,\n-\t\t\t   GEN_INT (crtl->args.pretend_args_size)));\n+      rtx_insn *tmp =\n+\temit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       GEN_INT (crtl->args.pretend_args_size)));\n \n       RTX_FRAME_RELATED_P (tmp) = 1;\n \n@@ -30436,7 +30439,8 @@ arm_split_compare_and_swap (rtx operands[])\n   enum machine_mode mode;\n   enum memmodel mod_s, mod_f;\n   bool is_weak;\n-  rtx label1, label2, x, cond;\n+  rtx_code_label *label1, *label2;\n+  rtx x, cond;\n \n   rval = operands[0];\n   mem = operands[1];\n@@ -30462,7 +30466,7 @@ arm_split_compare_and_swap (rtx operands[])\n   if (!(use_acquire || use_release))\n     arm_pre_atomic_barrier (mod_s);\n \n-  label1 = NULL_RTX;\n+  label1 = NULL;\n   if (!is_weak)\n     {\n       label1 = gen_label_rtx ();\n@@ -30512,7 +30516,8 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n   enum memmodel model = (enum memmodel) INTVAL (model_rtx);\n   enum machine_mode mode = GET_MODE (mem);\n   enum machine_mode wmode = (mode == DImode ? DImode : SImode);\n-  rtx label, x;\n+  rtx_code_label *label;\n+  rtx x;\n \n   bool use_acquire = TARGET_HAVE_LDACQ\n                      && !(model == MEMMODEL_RELAXED\n@@ -31438,7 +31443,7 @@ arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n \t\t\t  ORR (SHIFT (ASHIFT, in_up, scratch1), out_down)));\n \t  if (code == ASHIFTRT)\n \t    {\n-\t      rtx done_label = gen_label_rtx ();\n+\t      rtx_code_label *done_label = gen_label_rtx ();\n \t      emit_jump_insn (BRANCH (LT, done_label));\n \t      emit_insn (SET (out_down, ORR (SHIFT (ASHIFTRT, in_up, scratch2),\n \t\t\t\t\t     out_down)));\n@@ -31457,7 +31462,7 @@ arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n \n \t  if (code == ASHIFTRT)\n \t    {\n-\t      rtx done_label = gen_label_rtx ();\n+\t      rtx_code_label *done_label = gen_label_rtx ();\n \t      emit_jump_insn (BRANCH (LT, done_label));\n \t      emit_insn (SET (scratch2, SHIFT (ASHIFTRT, in_up, scratch2)));\n \t      emit_insn (SET (out_down, ORR (out_down, scratch2)));"}]}