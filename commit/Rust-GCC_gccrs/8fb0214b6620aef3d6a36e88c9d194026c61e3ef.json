{"sha": "8fb0214b6620aef3d6a36e88c9d194026c61e3ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZiMDIxNGI2NjIwYWVmM2Q2YTM2ZTg4YzlkMTk0MDI2YzYxZTNlZg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-10-19T16:32:55Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-19T16:32:55Z"}, "message": "i386.c (output_387_binary_op): Rewrite SSE part.\n\n\t* config/i386/i386.c (output_387_binary_op): Rewrite SSE part.\n\t(ix86_emit_mode_set): Rewrite insn mnemonic construction.\n\t(ix86_prepare_fp_compare_args): Redefine is_sse as bool.\n\nFrom-SVN: r253903", "tree": {"sha": "77798a85215c57b921fba39c4217a036bca3776c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77798a85215c57b921fba39c4217a036bca3776c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fb0214b6620aef3d6a36e88c9d194026c61e3ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fb0214b6620aef3d6a36e88c9d194026c61e3ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fb0214b6620aef3d6a36e88c9d194026c61e3ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fb0214b6620aef3d6a36e88c9d194026c61e3ef/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5ba8fd1087285a379cf25d549574330abdef6f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ba8fd1087285a379cf25d549574330abdef6f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ba8fd1087285a379cf25d549574330abdef6f0"}], "stats": {"total": 160, "additions": 74, "deletions": 86}, "files": [{"sha": "9a35b2c3eb6e63d4494bc6df16b605749b0c1911", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb0214b6620aef3d6a36e88c9d194026c61e3ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb0214b6620aef3d6a36e88c9d194026c61e3ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fb0214b6620aef3d6a36e88c9d194026c61e3ef", "patch": "@@ -1,3 +1,9 @@\n+2017-10-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (output_387_binary_op): Rewrite SSE part.\n+\t(ix86_emit_mode_set): Rewrite insn mnemonic construction.\n+\t(ix86_prepare_fp_compare_args): Redefine is_sse as bool.\n+\n 2017-10-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/82596"}, {"sha": "f301d91ab6a86e51843ca6a43c3f9e4b49828d7c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 68, "deletions": 86, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb0214b6620aef3d6a36e88c9d194026c61e3ef/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb0214b6620aef3d6a36e88c9d194026c61e3ef/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8fb0214b6620aef3d6a36e88c9d194026c61e3ef", "patch": "@@ -18149,89 +18149,66 @@ output_387_binary_op (rtx_insn *insn, rtx *operands)\n {\n   static char buf[40];\n   const char *p;\n-  const char *ssep;\n-  int is_sse = SSE_REG_P (operands[0]) || SSE_REG_P (operands[1]) || SSE_REG_P (operands[2]);\n+  bool is_sse\n+    = (SSE_REG_P (operands[0])\n+       || SSE_REG_P (operands[1]) || SSE_REG_P (operands[2]));\n \n-  /* Even if we do not want to check the inputs, this documents input\n-     constraints.  Which helps in understanding the following code.  */\n-  if (flag_checking)\n-    {\n-      if (STACK_REG_P (operands[0])\n-\t  && ((REG_P (operands[1])\n-\t       && REGNO (operands[0]) == REGNO (operands[1])\n-\t       && (STACK_REG_P (operands[2]) || MEM_P (operands[2])))\n-\t      || (REG_P (operands[2])\n-\t\t  && REGNO (operands[0]) == REGNO (operands[2])\n-\t\t  && (STACK_REG_P (operands[1]) || MEM_P (operands[1]))))\n-\t  && (STACK_TOP_P (operands[1]) || STACK_TOP_P (operands[2])))\n-\t; /* ok */\n-      else\n-\tgcc_assert (is_sse);\n-    }\n+  if (is_sse)\n+    p = \"%v\";\n+  else if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+\t   || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n+    p = \"fi\";\n+  else\n+    p = \"f\";\n+\n+  strcpy (buf, p);\n \n   switch (GET_CODE (operands[3]))\n     {\n     case PLUS:\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n-\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n-\tp = \"fiadd\";\n-      else\n-\tp = \"fadd\";\n-      ssep = \"vadd\";\n-      break;\n-\n+      p = \"add\"; break;\n     case MINUS:\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n-\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n-\tp = \"fisub\";\n-      else\n-\tp = \"fsub\";\n-      ssep = \"vsub\";\n-      break;\n-\n+      p = \"sub\"; break;\n     case MULT:\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n-\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n-\tp = \"fimul\";\n-      else\n-\tp = \"fmul\";\n-      ssep = \"vmul\";\n-      break;\n-\n+      p = \"mul\"; break;\n     case DIV:\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n-\t  || GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT)\n-\tp = \"fidiv\";\n-      else\n-\tp = \"fdiv\";\n-      ssep = \"vdiv\";\n-      break;\n-\n+      p = \"div\"; break;\n     default:\n       gcc_unreachable ();\n     }\n \n+  strcat (buf, p);\n+\n   if (is_sse)\n    {\n+     p = (GET_MODE (operands[0]) == SFmode) ? \"ss\" : \"sd\";\n+     strcat (buf, p);\n+\n      if (TARGET_AVX)\n-       {\n-\t strcpy (buf, ssep);\n-\t if (GET_MODE (operands[0]) == SFmode)\n-\t   strcat (buf, \"ss\\t{%2, %1, %0|%0, %1, %2}\");\n-\t else\n-\t   strcat (buf, \"sd\\t{%2, %1, %0|%0, %1, %2}\");\n-       }\n+       p = \"\\t{%2, %1, %0|%0, %1, %2}\";\n      else\n-       {\n-\t strcpy (buf, ssep + 1);\n-\t if (GET_MODE (operands[0]) == SFmode)\n-\t   strcat (buf, \"ss\\t{%2, %0|%0, %2}\");\n-\t else\n-\t   strcat (buf, \"sd\\t{%2, %0|%0, %2}\");\n-       }\n-      return buf;\n+       p = \"\\t{%2, %0|%0, %2}\";\n+\n+     strcat (buf, p);\n+     return buf;\n    }\n-  strcpy (buf, p);\n+\n+  /* Even if we do not want to check the inputs, this documents input\n+     constraints.  Which helps in understanding the following code.  */\n+  if (flag_checking)\n+    {\n+      if (STACK_REG_P (operands[0])\n+\t  && ((REG_P (operands[1])\n+\t       && REGNO (operands[0]) == REGNO (operands[1])\n+\t       && (STACK_REG_P (operands[2]) || MEM_P (operands[2])))\n+\t      || (REG_P (operands[2])\n+\t\t  && REGNO (operands[0]) == REGNO (operands[2])\n+\t\t  && (STACK_REG_P (operands[1]) || MEM_P (operands[1]))))\n+\t  && (STACK_TOP_P (operands[1]) || STACK_TOP_P (operands[2])))\n+\t; /* ok */\n+      else\n+\tgcc_unreachable ();\n+    }\n \n   switch (GET_CODE (operands[3]))\n     {\n@@ -18820,10 +18797,13 @@ ix86_emit_mode_set (int entity, int mode, int prev_mode ATTRIBUTE_UNUSED,\n const char *\n output_fix_trunc (rtx_insn *insn, rtx *operands, bool fisttp)\n {\n-  int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n-  int dimode_p = GET_MODE (operands[0]) == DImode;\n+  bool stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG);\n+  bool dimode_p = GET_MODE (operands[0]) == DImode;\n   int round_mode = get_attr_i387_cw (insn);\n \n+  static char buf[40];\n+  const char *p;\n+\n   /* Jump through a hoop or two for DImode, since the hardware has no\n      non-popping instruction.  We used to do this a different way, but\n      that was somewhat fragile and broke with post-reload splitters.  */\n@@ -18835,18 +18815,20 @@ output_fix_trunc (rtx_insn *insn, rtx *operands, bool fisttp)\n   gcc_assert (GET_MODE (operands[1]) != TFmode);\n \n   if (fisttp)\n-      output_asm_insn (\"fisttp%Z0\\t%0\", operands);\n-  else\n-    {\n-      if (round_mode != I387_CW_ANY)\n-\toutput_asm_insn (\"fldcw\\t%3\", operands);\n-      if (stack_top_dies || dimode_p)\n-\toutput_asm_insn (\"fistp%Z0\\t%0\", operands);\n-      else\n-\toutput_asm_insn (\"fist%Z0\\t%0\", operands);\n-      if (round_mode != I387_CW_ANY)\n-\toutput_asm_insn (\"fldcw\\t%2\", operands);\n-    }\n+    return \"fisttp%Z0\\t%0\";\n+\n+  strcpy (buf, \"fist\");\n+\n+  if (round_mode != I387_CW_ANY)\n+    output_asm_insn (\"fldcw\\t%3\", operands);\n+\n+  p = \"p%Z0\\t%0\";\n+  strcat (buf, p + !(stack_top_dies || dimode_p));\n+\n+  output_asm_insn (buf, operands);\n+\n+  if (round_mode != I387_CW_ANY)\n+    output_asm_insn (\"fldcw\\t%2\", operands);\n \n   return \"\";\n }\n@@ -18890,7 +18872,7 @@ output_fp_compare (rtx_insn *insn, rtx *operands,\n   bool stack_top_dies;\n \n   static char buf[40];\n-  const char *p, *r;\n+  const char *p;\n \n   gcc_assert (STACK_TOP_P (xops[0]));\n \n@@ -18901,8 +18883,8 @@ output_fp_compare (rtx_insn *insn, rtx *operands,\n       p = unordered_p ? \"fucomi\" : \"fcomi\";\n       strcpy (buf, p);\n \n-      r = \"p\\t{%y1, %0|%0, %y1}\";\n-      strcat (buf, r + !stack_top_dies);\n+      p = \"p\\t{%y1, %0|%0, %y1}\";\n+      strcat (buf, p + !stack_top_dies);\n \n       return buf;\n     }\n@@ -18936,8 +18918,8 @@ output_fp_compare (rtx_insn *insn, rtx *operands,\n \n       strcpy (buf, p);\n \n-      r = \"p%Z2\\t%y2\";\n-      strcat (buf, r + !stack_top_dies);\n+      p = \"p%Z2\\t%y2\";\n+      strcat (buf, p + !stack_top_dies);\n     }\n \n   output_asm_insn (buf, operands);\n@@ -21763,7 +21745,7 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n   machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n   rtx op0 = *pop0, op1 = *pop1;\n   machine_mode op_mode = GET_MODE (op0);\n-  int is_sse = TARGET_SSE_MATH && SSE_FLOAT_MODE_P (op_mode);\n+  bool is_sse = TARGET_SSE_MATH && SSE_FLOAT_MODE_P (op_mode);\n \n   /* All of the unordered compare instructions only work on registers.\n      The same is true of the fcomi compare instructions.  The XFmode"}]}