{"sha": "aa0432005f36f6ac51dc9dcecb717fe739d39b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEwNDMyMDA1ZjM2ZjZhYzUxZGM5ZGNlY2I3MTdmZTczOWQzOWI4OA==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-12-09T11:20:01Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-12-09T11:20:01Z"}, "message": "OpenMP: C/C++ parse 'omp allocate'\n\ngcc/c-family/ChangeLog:\n\n\t* c-pragma.c (omp_pragmas): Add 'allocate'.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_ALLOCATE.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_omp_allocate): New.\n\t(c_parser_omp_construct): Call it.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_omp_allocate): New.\n\t(cp_parser_omp_construct, cp_parser_pragma): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/allocate-5.c: New test.", "tree": {"sha": "e042d0b2699770fac5950e8f930c18a21b06a72b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e042d0b2699770fac5950e8f930c18a21b06a72b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa0432005f36f6ac51dc9dcecb717fe739d39b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0432005f36f6ac51dc9dcecb717fe739d39b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa0432005f36f6ac51dc9dcecb717fe739d39b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0432005f36f6ac51dc9dcecb717fe739d39b88/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85f0a4d98229203181014fb84a1e4f74813aab9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f0a4d98229203181014fb84a1e4f74813aab9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f0a4d98229203181014fb84a1e4f74813aab9e"}], "stats": {"total": 138, "additions": 137, "deletions": 1}, "files": [{"sha": "5fd43603362cf129c8648eb7a5645f9b4e1af419", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=aa0432005f36f6ac51dc9dcecb717fe739d39b88", "patch": "@@ -1309,6 +1309,7 @@ static const struct omp_pragma_def oacc_pragmas[] = {\n   { \"wait\", PRAGMA_OACC_WAIT }\n };\n static const struct omp_pragma_def omp_pragmas[] = {\n+  { \"allocate\", PRAGMA_OMP_ALLOCATE },\n   { \"atomic\", PRAGMA_OMP_ATOMIC },\n   { \"barrier\", PRAGMA_OMP_BARRIER },\n   { \"cancel\", PRAGMA_OMP_CANCEL },"}, {"sha": "e0e4da6b6b3d047fb1325345d6ee26b9b73176a5", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=aa0432005f36f6ac51dc9dcecb717fe739d39b88", "patch": "@@ -42,6 +42,7 @@ enum pragma_kind {\n   PRAGMA_OACC_UPDATE,\n   PRAGMA_OACC_WAIT,\n \n+  PRAGMA_OMP_ALLOCATE,\n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n   PRAGMA_OMP_CANCEL,"}, {"sha": "69ecdb5e82260cb2fa14732432da3439a18c13fe", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=aa0432005f36f6ac51dc9dcecb717fe739d39b88", "patch": "@@ -17250,6 +17250,55 @@ c_parser_oacc_wait (location_t loc, c_parser *parser, char *p_name)\n   return stmt;\n }\n \n+/* OpenMP 5.0:\n+   # pragma omp allocate (list)  [allocator(allocator)]  */\n+\n+static void\n+c_parser_omp_allocate (location_t loc, c_parser *parser)\n+{\n+  tree allocator = NULL_TREE;\n+  tree nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      matching_parens parens;\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      c_parser_consume_token (parser);\n+      if (strcmp (\"allocator\", p) != 0)\n+\terror_at (c_parser_peek_token (parser)->location,\n+\t\t  \"expected %<allocator%>\");\n+      else if (parens.require_open (parser))\n+\t{\n+\t  location_t expr_loc = c_parser_peek_token (parser)->location;\n+\t  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+\t  allocator = expr.value;\n+\t  allocator = c_fully_fold (allocator, false, NULL);\n+\t  tree orig_type\n+\t    = expr.original_type ? expr.original_type : TREE_TYPE (allocator);\n+\t  orig_type = TYPE_MAIN_VARIANT (orig_type);\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (allocator))\n+\t      || TREE_CODE (orig_type) != ENUMERAL_TYPE\n+\t      || TYPE_NAME (orig_type)\n+\t\t != get_identifier (\"omp_allocator_handle_t\"))\n+\t    {\n+\t      error_at (expr_loc, \"%<allocator%> clause allocator expression \"\n+\t\t\t\t\"has type %qT rather than \"\n+\t\t\t\t\"%<omp_allocator_handle_t%>\",\n+\t\t\t\tTREE_TYPE (allocator));\n+\t      allocator = NULL_TREE;\n+\t    }\n+\t  parens.skip_until_found_close (parser);\n+\t}\n+    }\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  if (allocator)\n+    for (tree c = nl; c != NULL_TREE; c = OMP_CLAUSE_CHAIN (c))\n+      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\n+  sorry_at (loc, \"%<#pragma omp allocate%> not yet supported\");\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp atomic new-line\n      expression-stmt\n@@ -21537,6 +21586,9 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       strcpy (p_name, \"#pragma wait\");\n       stmt = c_parser_oacc_wait (loc, parser, p_name);\n       break;\n+    case PRAGMA_OMP_ALLOCATE:\n+      c_parser_omp_allocate (loc, parser);\n+      return;\n     case PRAGMA_OMP_ATOMIC:\n       c_parser_omp_atomic (loc, parser, false);\n       return;"}, {"sha": "0ff000cd053693dc33c843c948d97141994e4b6a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=aa0432005f36f6ac51dc9dcecb717fe739d39b88", "patch": "@@ -38198,6 +38198,42 @@ cp_parser_omp_structured_block (cp_parser *parser, bool *if_p)\n   return finish_omp_structured_block (stmt);\n }\n \n+/* OpenMP 5.0:\n+   # pragma omp allocate (list)  [allocator(allocator)]  */\n+\n+static void\n+cp_parser_omp_allocate (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree allocator = NULL_TREE;\n+  location_t loc = pragma_tok->location;\n+  tree nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      matching_parens parens;\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n+      cp_lexer_consume_token (parser->lexer);\n+      if (strcmp (p, \"allocator\") != 0)\n+\terror_at (cloc, \"expected %<allocator%>\");\n+      else if (parens.require_open (parser))\n+\t{\n+\t  allocator = cp_parser_assignment_expression (parser);\n+\t  if (allocator == error_mark_node)\n+\t    allocator = NULL_TREE;\n+\t  parens.require_close (parser);\n+\t}\n+    }\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  if (allocator)\n+    for (tree c = nl; c != NULL_TREE; c = OMP_CLAUSE_CHAIN (c))\n+      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\n+  sorry_at (loc, \"%<#pragma omp allocate%> not yet supported\");\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp atomic new-line\n      expression-stmt\n@@ -43838,6 +43874,9 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n     case PRAGMA_OACC_WAIT:\n       stmt = cp_parser_oacc_wait (parser, pragma_tok);\n       break;\n+    case PRAGMA_OMP_ALLOCATE:\n+      cp_parser_omp_allocate (parser, pragma_tok);\n+      return;\n     case PRAGMA_OMP_ATOMIC:\n       cp_parser_omp_atomic (parser, pragma_tok, false);\n       return;\n@@ -44483,7 +44522,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \tgoto bad_stmt;\n       cp_parser_omp_construct (parser, pragma_tok, if_p);\n       return true;\n-\n+    case PRAGMA_OMP_ALLOCATE:\n+      cp_parser_omp_allocate (parser, pragma_tok);\n+      return false;\n     case PRAGMA_OACC_ATOMIC:\n     case PRAGMA_OACC_CACHE:\n     case PRAGMA_OACC_DATA:"}, {"sha": "34dcb48c3d7cdad350e82e62cfbef1a05d83a1fd", "filename": "gcc/testsuite/c-c++-common/gomp/allocate-5.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0432005f36f6ac51dc9dcecb717fe739d39b88/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-5.c?ref=aa0432005f36f6ac51dc9dcecb717fe739d39b88", "patch": "@@ -0,0 +1,41 @@\n+typedef enum omp_allocator_handle_t\n+#if __cplusplus >= 201103L\n+: __UINTPTR_TYPE__\n+#endif\n+{\n+  omp_null_allocator = 0,\n+  omp_default_mem_alloc = 1,\n+  omp_large_cap_mem_alloc = 2,\n+  omp_const_mem_alloc = 3,\n+  omp_high_bw_mem_alloc = 4,\n+  omp_low_lat_mem_alloc = 5,\n+  omp_cgroup_mem_alloc = 6,\n+  omp_pteam_mem_alloc = 7,\n+  omp_thread_mem_alloc = 8,\n+  __omp_allocator_handle_t_max__ = __UINTPTR_MAX__\n+} omp_allocator_handle_t;\n+\n+void\n+foo ()\n+{\n+  int a, b;\n+  omp_allocator_handle_t my_allocator;\n+#pragma omp allocate (a)  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" } */\n+#pragma omp allocate (b) allocator(my_allocator)  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" } */\n+}\n+\n+void\n+bar ()\n+{\n+  int a, b;\n+  omp_allocator_handle_t my_allocator;\n+#pragma omp allocate  /* { dg-error \"expected '\\\\(' before end of line\" } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+#pragma omp allocate allocator(my_allocator)  /* { dg-error \"expected '\\\\(' before 'allocator'\" } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+#pragma omp allocate(a) foo(my_allocator) /* { dg-error \"expected 'allocator'\" } */\n+  /* { dg-error \"expected end of line before '\\\\(' token\" \"\" { target *-*-* } .-1 } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-2 } */\n+#pragma omp allocate(a) allocator(b)  /* { dg-error \"'allocator' clause allocator expression has type 'int' rather than 'omp_allocator_handle_t'\" \"todo: cp/semantics.c\" { xfail c++ } } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+}"}]}