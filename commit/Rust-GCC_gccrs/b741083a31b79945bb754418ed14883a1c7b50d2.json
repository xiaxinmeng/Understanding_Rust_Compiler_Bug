{"sha": "b741083a31b79945bb754418ed14883a1c7b50d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0MTA4M2EzMWI3OTk0NWJiNzU0NDE4ZWQxNDg4M2ExYzdiNTBkMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2015-05-12T08:25:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-12T08:25:39Z"}, "message": "sem_ch3.adb (Analyze_Object_Declaration): New function Has_Delayed_Aspect...\n\n2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): New function\n\tHas_Delayed_Aspect, used to defer resolution of an aggregate\n\texpression when the object declaration carries aspects Address\n\tand/or Alignment.\n\t* freeze.adb (Freeze_Object_Declaration): New subsidiary procedure\n\tto Freeze_Entity.  In addition to the previous processing steps\n\tat the freeze point of an object, this procedure also handles\n\taggregates in object declarations, when the declaration carries\n\tdelayed aspects that require that the initialization of the\n\tobject be attached to its freeze actions.\n\n2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Declaration): Following\n\tAI12-0147, null procedures and expression functions are allowed\n\tin protected bodies.\n\nFrom-SVN: r223041", "tree": {"sha": "b4a00b7468712c6c20a4b9f7496dc7834cd0bf63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4a00b7468712c6c20a4b9f7496dc7834cd0bf63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b741083a31b79945bb754418ed14883a1c7b50d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b741083a31b79945bb754418ed14883a1c7b50d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b741083a31b79945bb754418ed14883a1c7b50d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b741083a31b79945bb754418ed14883a1c7b50d2/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0a10853345a395b64e44df41dbb743661301ef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a10853345a395b64e44df41dbb743661301ef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a10853345a395b64e44df41dbb743661301ef0"}], "stats": {"total": 447, "additions": 275, "deletions": 172}, "files": [{"sha": "661b4b005b62e9960c480551fd5c0943b4af0735", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b741083a31b79945bb754418ed14883a1c7b50d2", "patch": "@@ -1,3 +1,22 @@\n+2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): New function\n+\tHas_Delayed_Aspect, used to defer resolution of an aggregate\n+\texpression when the object declaration carries aspects Address\n+\tand/or Alignment.\n+\t* freeze.adb (Freeze_Object_Declaration): New subsidiary procedure\n+\tto Freeze_Entity.  In addition to the previous processing steps\n+\tat the freeze point of an object, this procedure also handles\n+\taggregates in object declarations, when the declaration carries\n+\tdelayed aspects that require that the initialization of the\n+\tobject be attached to its freeze actions.\n+\n+2015-05-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Declaration): Following\n+\tAI12-0147, null procedures and expression functions are allowed\n+\tin protected bodies.\n+\n 2015-05-12  Tristan Gingold  <gingold@adacore.com>\n \n \t* i-cpoint.adb (Copy_Terminated_Array): Copy nothing if Length is 0."}, {"sha": "0b9d2b73e56313de645480498def6c9ccbc6a777", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 210, "deletions": 170, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b741083a31b79945bb754418ed14883a1c7b50d2", "patch": "@@ -1894,6 +1894,10 @@ package body Freeze is\n       procedure Freeze_Array_Type (Arr : Entity_Id);\n       --  Freeze array type, including freezing index and component types\n \n+      procedure Freeze_Object_Declaration (E : Entity_Id);\n+      --  Perfom checks and generate freeze node if needed for a constant\n+      --  or variable declared by an object declaration.\n+\n       function Freeze_Generic_Entities (Pack : Entity_Id) return List_Id;\n       --  Create Freeze_Generic_Entity nodes for types declared in a generic\n       --  package. Recurse on inner generic packages.\n@@ -2782,6 +2786,211 @@ package body Freeze is\n          end if;\n       end Freeze_Array_Type;\n \n+      -------------------------------\n+      -- Freeze_Object_Declaration --\n+      -------------------------------\n+\n+      procedure Freeze_Object_Declaration (E : Entity_Id) is\n+      begin\n+         --  Abstract type allowed only for C++ imported variables or\n+         --  constants.\n+\n+         --  Note: we inhibit this check for objects that do not come\n+         --  from source because there is at least one case (the\n+         --  expansion of x'Class'Input where x is abstract) where we\n+         --  legitimately generate an abstract object.\n+\n+         if Is_Abstract_Type (Etype (E))\n+           and then Comes_From_Source (Parent (E))\n+           and then not (Is_Imported (E) and then Is_CPP_Class (Etype (E)))\n+         then\n+            Error_Msg_N (\"type of object cannot be abstract\",\n+                           Object_Definition (Parent (E)));\n+\n+            if Is_CPP_Class (Etype (E)) then\n+               Error_Msg_NE (\"\\} may need a cpp_constructor\",\n+                  Object_Definition (Parent (E)), Etype (E));\n+\n+            elsif Present (Expression (Parent (E))) then\n+               Error_Msg_N --  CODEFIX\n+                 (\"\\maybe a class-wide type was meant\",\n+                  Object_Definition (Parent (E)));\n+            end if;\n+         end if;\n+\n+         --  For object created by object declaration, perform required\n+         --  categorization (preelaborate and pure) checks. Defer these\n+         --  checks to freeze time since pragma Import inhibits default\n+         --  initialization and thus pragma Import affects these checks.\n+\n+         Validate_Object_Declaration (Declaration_Node (E));\n+\n+         --  If there is an address clause, check that it is valid\n+         --  and if need be move initialization to the freeze node.\n+\n+         Check_Address_Clause (E);\n+\n+         --  Similar processing is needed for aspects that may affect\n+         --  object layout, like Alignment, if there is an initialization\n+         --  expression.\n+\n+         if Has_Delayed_Aspects (E)\n+           and then Expander_Active\n+           and then Is_Array_Type (Etype (E))\n+           and then Present (Expression (Parent (E)))\n+         then\n+            declare\n+               Decl : constant Node_Id := Parent (E);\n+               Lhs  : constant Node_Id :=  New_Occurrence_Of (E, Loc);\n+            begin\n+\n+               --  Capture initialization value at point of declaration,\n+               --  and make explicit assignment legal, because object may\n+               --  be a constant.\n+\n+               Remove_Side_Effects (Expression (Decl));\n+               Set_Assignment_OK (Lhs);\n+\n+               --  Move initialization to freeze actions.\n+\n+               Append_Freeze_Action (E,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => Lhs,\n+                   Expression => Expression (Decl)));\n+\n+               Set_No_Initialization (Decl);\n+               --  Set_Is_Frozen (E, False);\n+            end;\n+         end if;\n+\n+         --  Reset Is_True_Constant for non-constant aliased object. We\n+         --  consider that the fact that a non-constant object is aliased\n+         --  may indicate that some funny business is going on, e.g. an\n+         --  aliased object is passed by reference to a procedure which\n+         --  captures the address of the object, which is later used to\n+         --  assign a new value, even though the compiler thinks that it\n+         --  is not modified. Such code is highly dubious, but we choose\n+         --  to make it \"work\" for non-constant aliased objects.\n+         --  Note that we used to do this for all aliased objects, whether\n+         --  or not constant, but this caused anomalies down the line\n+         --  because we ended up with static objects that were not\n+         --  Is_True_Constant. Not resetting Is_True_Constant for (aliased)\n+         --  constant objects ensures that this anomaly never occurs.\n+\n+         --  However, we don't do that for internal entities. We figure\n+         --  that if we deliberately set Is_True_Constant for an internal\n+         --  entity, e.g. a dispatch table entry, then we mean it.\n+\n+         if Ekind (E) /= E_Constant\n+           and then (Is_Aliased (E) or else Is_Aliased (Etype (E)))\n+           and then not Is_Internal_Name (Chars (E))\n+         then\n+            Set_Is_True_Constant (E, False);\n+         end if;\n+\n+         --  If the object needs any kind of default initialization, an\n+         --  error must be issued if No_Default_Initialization applies.\n+         --  The check doesn't apply to imported objects, which are not\n+         --  ever default initialized, and is why the check is deferred\n+         --  until freezing, at which point we know if Import applies.\n+         --  Deferred constants are also exempted from this test because\n+         --  their completion is explicit, or through an import pragma.\n+\n+         if Ekind (E) = E_Constant\n+           and then Present (Full_View (E))\n+         then\n+            null;\n+\n+         elsif Comes_From_Source (E)\n+           and then not Is_Imported (E)\n+           and then not Has_Init_Expression (Declaration_Node (E))\n+           and then\n+             ((Has_Non_Null_Base_Init_Proc (Etype (E))\n+                and then not No_Initialization (Declaration_Node (E))\n+                and then not Is_Value_Type (Etype (E))\n+                and then not Initialization_Suppressed (Etype (E)))\n+              or else\n+                (Needs_Simple_Initialization (Etype (E))\n+                  and then not Is_Internal (E)))\n+         then\n+            Has_Default_Initialization := True;\n+            Check_Restriction\n+              (No_Default_Initialization, Declaration_Node (E));\n+         end if;\n+\n+         --  Check that a Thread_Local_Storage variable does not have\n+         --  default initialization, and any explicit initialization must\n+         --  either be the null constant or a static constant.\n+\n+         if Has_Pragma_Thread_Local_Storage (E) then\n+            declare\n+               Decl : constant Node_Id := Declaration_Node (E);\n+            begin\n+               if Has_Default_Initialization\n+                 or else\n+                   (Has_Init_Expression (Decl)\n+                     and then\n+                      (No (Expression (Decl))\n+                        or else not\n+                          (Is_OK_Static_Expression (Expression (Decl))\n+                            or else Nkind (Expression (Decl)) = N_Null)))\n+               then\n+                  Error_Msg_NE\n+                    (\"Thread_Local_Storage variable& is \"\n+                     & \"improperly initialized\", Decl, E);\n+                  Error_Msg_NE\n+                    (\"\\only allowed initialization is explicit \"\n+                     & \"NULL or static expression\", Decl, E);\n+               end if;\n+            end;\n+         end if;\n+\n+         --  For imported objects, set Is_Public unless there is also an\n+         --  address clause, which means that there is no external symbol\n+         --  needed for the Import (Is_Public may still be set for other\n+         --  unrelated reasons). Note that we delayed this processing\n+         --  till freeze time so that we can be sure not to set the flag\n+         --  if there is an address clause. If there is such a clause,\n+         --  then the only purpose of the Import pragma is to suppress\n+         --  implicit initialization.\n+\n+         if Is_Imported (E) and then No (Address_Clause (E)) then\n+            Set_Is_Public (E);\n+         end if;\n+\n+         --  For source objects that are not Imported and are library\n+         --  level, if no linker section pragma was given inherit the\n+         --  appropriate linker section from the corresponding type.\n+\n+         if Comes_From_Source (E)\n+           and then not Is_Imported (E)\n+           and then Is_Library_Level_Entity (E)\n+           and then No (Linker_Section_Pragma (E))\n+         then\n+            Set_Linker_Section_Pragma\n+              (E, Linker_Section_Pragma (Etype (E)));\n+         end if;\n+\n+         --  For convention C objects of an enumeration type, warn if the\n+         --  size is not integer size and no explicit size given. Skip\n+         --  warning for Boolean, and Character, assume programmer expects\n+         --  8-bit sizes for these cases.\n+\n+         if (Convention (E) = Convention_C\n+               or else Convention (E) = Convention_CPP)\n+           and then Is_Enumeration_Type (Etype (E))\n+           and then not Is_Character_Type (Etype (E))\n+           and then not Is_Boolean_Type (Etype (E))\n+           and then Esize (Etype (E)) < Standard_Integer_Size\n+           and then not Has_Size_Clause (E)\n+         then\n+            Error_Msg_Uint_1 := UI_From_Int (Standard_Integer_Size);\n+            Error_Msg_N\n+              (\"??convention C enumeration object has size less than ^\", E);\n+            Error_Msg_N (\"\\??use explicit size clause to set size\", E);\n+         end if;\n+      end Freeze_Object_Declaration;\n+\n       -----------------------------\n       -- Freeze_Generic_Entities --\n       -----------------------------\n@@ -4690,176 +4899,7 @@ package body Freeze is\n             --  Special processing for objects created by object declaration\n \n             if Nkind (Declaration_Node (E)) = N_Object_Declaration then\n-\n-               --  Abstract type allowed only for C++ imported variables or\n-               --  constants.\n-\n-               --  Note: we inhibit this check for objects that do not come\n-               --  from source because there is at least one case (the\n-               --  expansion of x'Class'Input where x is abstract) where we\n-               --  legitimately generate an abstract object.\n-\n-               if Is_Abstract_Type (Etype (E))\n-                 and then Comes_From_Source (Parent (E))\n-                 and then not (Is_Imported (E)\n-                                 and then Is_CPP_Class (Etype (E)))\n-               then\n-                  Error_Msg_N (\"type of object cannot be abstract\",\n-                               Object_Definition (Parent (E)));\n-\n-                  if Is_CPP_Class (Etype (E)) then\n-                     Error_Msg_NE\n-                       (\"\\} may need a cpp_constructor\",\n-                        Object_Definition (Parent (E)), Etype (E));\n-\n-                  elsif Present (Expression (Parent (E))) then\n-                     Error_Msg_N --  CODEFIX\n-                       (\"\\maybe a class-wide type was meant\",\n-                        Object_Definition (Parent (E)));\n-                  end if;\n-               end if;\n-\n-               --  For object created by object declaration, perform required\n-               --  categorization (preelaborate and pure) checks. Defer these\n-               --  checks to freeze time since pragma Import inhibits default\n-               --  initialization and thus pragma Import affects these checks.\n-\n-               Validate_Object_Declaration (Declaration_Node (E));\n-\n-               --  If there is an address clause, check that it is valid\n-\n-               Check_Address_Clause (E);\n-\n-               --  Reset Is_True_Constant for non-constant aliased object. We\n-               --  consider that the fact that a non-constant object is aliased\n-               --  may indicate that some funny business is going on, e.g. an\n-               --  aliased object is passed by reference to a procedure which\n-               --  captures the address of the object, which is later used to\n-               --  assign a new value, even though the compiler thinks that\n-               --  it is not modified. Such code is highly dubious, but we\n-               --  choose to make it \"work\" for non-constant aliased objects.\n-               --  Note that we used to do this for all aliased objects,\n-               --  whether or not constant, but this caused anomalies down\n-               --  the line because we ended up with static objects that\n-               --  were not Is_True_Constant. Not resetting Is_True_Constant\n-               --  for (aliased) constant objects ensures that this anomaly\n-               --  never occurs.\n-\n-               --  However, we don't do that for internal entities. We figure\n-               --  that if we deliberately set Is_True_Constant for an internal\n-               --  entity, e.g. a dispatch table entry, then we mean it.\n-\n-               if Ekind (E) /= E_Constant\n-                 and then (Is_Aliased (E) or else Is_Aliased (Etype (E)))\n-                 and then not Is_Internal_Name (Chars (E))\n-               then\n-                  Set_Is_True_Constant (E, False);\n-               end if;\n-\n-               --  If the object needs any kind of default initialization, an\n-               --  error must be issued if No_Default_Initialization applies.\n-               --  The check doesn't apply to imported objects, which are not\n-               --  ever default initialized, and is why the check is deferred\n-               --  until freezing, at which point we know if Import applies.\n-               --  Deferred constants are also exempted from this test because\n-               --  their completion is explicit, or through an import pragma.\n-\n-               if Ekind (E) = E_Constant\n-                 and then Present (Full_View (E))\n-               then\n-                  null;\n-\n-               elsif Comes_From_Source (E)\n-                 and then not Is_Imported (E)\n-                 and then not Has_Init_Expression (Declaration_Node (E))\n-                 and then\n-                   ((Has_Non_Null_Base_Init_Proc (Etype (E))\n-                      and then not No_Initialization (Declaration_Node (E))\n-                      and then not Is_Value_Type (Etype (E))\n-                      and then not Initialization_Suppressed (Etype (E)))\n-                    or else\n-                      (Needs_Simple_Initialization (Etype (E))\n-                        and then not Is_Internal (E)))\n-               then\n-                  Has_Default_Initialization := True;\n-                  Check_Restriction\n-                    (No_Default_Initialization, Declaration_Node (E));\n-               end if;\n-\n-               --  Check that a Thread_Local_Storage variable does not have\n-               --  default initialization, and any explicit initialization must\n-               --  either be the null constant or a static constant.\n-\n-               if Has_Pragma_Thread_Local_Storage (E) then\n-                  declare\n-                     Decl : constant Node_Id := Declaration_Node (E);\n-                  begin\n-                     if Has_Default_Initialization\n-                       or else\n-                         (Has_Init_Expression (Decl)\n-                           and then\n-                            (No (Expression (Decl))\n-                              or else not\n-                                (Is_OK_Static_Expression (Expression (Decl))\n-                                  or else\n-                                    Nkind (Expression (Decl)) = N_Null)))\n-                     then\n-                        Error_Msg_NE\n-                          (\"Thread_Local_Storage variable& is \"\n-                           & \"improperly initialized\", Decl, E);\n-                        Error_Msg_NE\n-                          (\"\\only allowed initialization is explicit \"\n-                           & \"NULL or static expression\", Decl, E);\n-                     end if;\n-                  end;\n-               end if;\n-\n-               --  For imported objects, set Is_Public unless there is also an\n-               --  address clause, which means that there is no external symbol\n-               --  needed for the Import (Is_Public may still be set for other\n-               --  unrelated reasons). Note that we delayed this processing\n-               --  till freeze time so that we can be sure not to set the flag\n-               --  if there is an address clause. If there is such a clause,\n-               --  then the only purpose of the Import pragma is to suppress\n-               --  implicit initialization.\n-\n-               if Is_Imported (E) and then No (Address_Clause (E)) then\n-                  Set_Is_Public (E);\n-               end if;\n-\n-               --  For source objects that are not Imported and are library\n-               --  level, if no linker section pragma was given inherit the\n-               --  appropriate linker section from the corresponding type.\n-\n-               if Comes_From_Source (E)\n-                 and then not Is_Imported (E)\n-                 and then Is_Library_Level_Entity (E)\n-                 and then No (Linker_Section_Pragma (E))\n-               then\n-                  Set_Linker_Section_Pragma\n-                    (E, Linker_Section_Pragma (Etype (E)));\n-               end if;\n-\n-               --  For convention C objects of an enumeration type, warn if\n-               --  the size is not integer size and no explicit size given.\n-               --  Skip warning for Boolean, and Character, assume programmer\n-               --  expects 8-bit sizes for these cases.\n-\n-               if (Convention (E) = Convention_C\n-                     or else\n-                   Convention (E) = Convention_CPP)\n-                 and then Is_Enumeration_Type (Etype (E))\n-                 and then not Is_Character_Type (Etype (E))\n-                 and then not Is_Boolean_Type (Etype (E))\n-                 and then Esize (Etype (E)) < Standard_Integer_Size\n-                 and then not Has_Size_Clause (E)\n-               then\n-                  Error_Msg_Uint_1 := UI_From_Int (Standard_Integer_Size);\n-                  Error_Msg_N\n-                    (\"??convention C enumeration object has size less than ^\",\n-                     E);\n-                  Error_Msg_N (\"\\??use explicit size clause to set size\", E);\n-               end if;\n+               Freeze_Object_Declaration (E);\n             end if;\n \n             --  Check that a constant which has a pragma Volatile[_Components]"}, {"sha": "8047b464615855481d83ce0258718f608d3da896", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b741083a31b79945bb754418ed14883a1c7b50d2", "patch": "@@ -3336,6 +3336,18 @@ package body Sem_Ch3 is\n       --  or a variant record type is encountered, Check_Restrictions is called\n       --  indicating the count is unknown.\n \n+      function Delayed_Aspect_Present return Boolean;\n+      --  If the declaration has an expression that is an aggregate, and it\n+      --  has aspects that require delayed analysis, the resolution of the\n+      --  aggregate must be deferred to the freeze point of the objet. This\n+      --  special processing was created for address clauses, but it must\n+      --  also apply to Alignment.\n+      --  This must be done before the aspect specifications are analyzed\n+      --  because we must handle the aggregate before the analysis of the\n+      --  object declaration is complete.\n+\n+      --  any other relevant delayed aspects on object declarations ???\n+\n       -----------------\n       -- Count_Tasks --\n       -----------------\n@@ -3390,6 +3402,32 @@ package body Sem_Ch3 is\n          end if;\n       end Count_Tasks;\n \n+      ----------------------------\n+      -- Delayed_Aspect_Present --\n+      ----------------------------\n+\n+      function Delayed_Aspect_Present return Boolean is\n+         A : Node_Id;\n+         A_Id : Aspect_Id;\n+\n+      begin\n+         if Present (Aspect_Specifications (N)) then\n+            A    := First (Aspect_Specifications (N));\n+            A_Id :=   Get_Aspect_Id (Chars (Identifier (A)));\n+            while Present (A) loop\n+               if\n+                 A_Id = Aspect_Alignment or else A_Id = Aspect_Address\n+               then\n+                  return True;\n+               end if;\n+\n+               Next (A);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Delayed_Aspect_Present;\n+\n    --  Start of processing for Analyze_Object_Declaration\n \n    begin\n@@ -3705,7 +3743,8 @@ package body Sem_Ch3 is\n          if Comes_From_Source (N)\n            and then Expander_Active\n            and then Nkind (E) = N_Aggregate\n-           and then Present (Following_Address_Clause (N))\n+           and then (Present (Following_Address_Clause (N))\n+                      or else Delayed_Aspect_Present)\n          then\n             Set_Etype (E, T);\n "}, {"sha": "77a812335ed48494376420aadc32d475c7987cea", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b741083a31b79945bb754418ed14883a1c7b50d2/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b741083a31b79945bb754418ed14883a1c7b50d2", "patch": "@@ -4346,7 +4346,12 @@ package body Sem_Ch6 is\n       then\n          Check_SPARK_05_Restriction (\"null procedure is not allowed\", N);\n \n-         if Is_Protected_Type (Current_Scope) then\n+         --  Null procedures are allowed in protected types, following\n+         --  the recent AI12-0147.\n+\n+         if Is_Protected_Type (Current_Scope)\n+           and then Ada_Version < Ada_2012\n+         then\n             Error_Msg_N (\"protected operation cannot be a null procedure\", N);\n          end if;\n "}]}