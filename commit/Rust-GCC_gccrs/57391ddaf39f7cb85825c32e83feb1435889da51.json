{"sha": "57391ddaf39f7cb85825c32e83feb1435889da51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTczOTFkZGFmMzlmN2NiODU4MjVjMzJlODNmZWIxNDM1ODg5ZGE1MQ==", "commit": {"author": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2020-04-07T15:59:36Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2020-04-07T17:18:38Z"}, "message": "Fix PR fortran/93871 and re-implement degree-valued trigonometric intrinsics.\n\n2020-04-01  Fritz Reese  <foreese@gcc.gnu.org>\n\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n\ngcc/fortran/ChangeLog\n\n\tPR fortran/93871\n\t* gfortran.h (GFC_ISYM_ACOSD, GFC_ISYM_ASIND, GFC_ISYM_ATAN2D,\n\tGFC_ISYM_ATAND, GFC_ISYM_COSD, GFC_ISYM_COTAND, GFC_ISYM_SIND,\n\tGFC_ISYM_TAND): New.\n\t* intrinsic.c (add_functions): Remove check for flag_dec_math.\n\tGive degree trig functions simplification and name resolution\n\tfunctions (e.g, gfc_simplify_atrigd () and gfc_resolve_atrigd ()).\n\t(do_simplify): Remove special casing of degree trig functions.\n\t* intrinsic.h (gfc_simplify_acosd, gfc_simplify_asind,\n\tgfc_simplify_atand, gfc_simplify_cosd, gfc_simplify_cotand,\n\tgfc_simplify_sind, gfc_simplify_tand, gfc_resolve_trigd2): Add new\n\tprototypes.\n\t(gfc_simplify_atrigd, gfc_simplify_trigd, gfc_resolve_cotan,\n\tresolve_atrigd): Remove prototypes of deleted functions.\n\t* iresolve.c (is_trig_resolved, copy_replace_function_shallow,\n\tgfc_resolve_cotan, get_radians, get_degrees, resolve_trig_call,\n\tgfc_resolve_atrigd, gfc_resolve_atan2d): Delete functions.\n\t(gfc_resolve_trigd, gfc_resolve_trigd2): Resolve to library functions.\n\t* simplify.c (rad2deg, deg2rad, gfc_simplify_acosd, gfc_simplify_asind,\n\tgfc_simplify_atand, gfc_simplify_atan2d, gfc_simplify_cosd,\n\tgfc_simplify_sind, gfc_simplify_tand, gfc_simplify_cotand): New\n\tfunctions.\n\t(gfc_simplify_atan2): Fix error message.\n\t(simplify_trig_call, gfc_simplify_trigd, gfc_simplify_atrigd,\n\tradians_f): Delete functions.\n\t* trans-intrinsic.c: Add LIB_FUNCTION decls for sind, cosd, tand.\n\t(rad2deg, gfc_conv_intrinsic_atrigd, gfc_conv_intrinsic_cotan,\n\tgfc_conv_intrinsic_cotand, gfc_conv_intrinsic_atan2d): New functions.\n\t(gfc_conv_intrinsic_function): Handle ACOSD, ASIND, ATAND, COTAN,\n\tCOTAND, ATAN2D.\n\t* trigd_fe.inc: New file. Included by simplify.c to implement\n\tsimplify_sind, simplify_cosd, simplify_tand with code common to the\n\tlibgfortran implementation.\n\ngcc/testsuite/ChangeLog\n\n\tPR fortran/93871\n\t* gfortran.dg/dec_math.f90: Extend coverage to real(10) and real(16).\n\t* gfortran.dg/dec_math_2.f90: New test.\n\t* gfortran.dg/dec_math_3.f90: Likewise.\n\t* gfortran.dg/dec_math_4.f90: Likewise.\n\t* gfortran.dg/dec_math_5.f90: Likewise.\n\nlibgfortran/ChangeLog\n\n\tPR fortran/93871\n\t* Makefile.am, Makefile.in: New make rule for intrinsics/trigd.c.\n\t* gfortran.map: New routines for {sind, cosd, tand}X{r4, r8, r10, r16}.\n\t* intrinsics/trigd.c, intrinsics/trigd_lib.inc, intrinsics/trigd.inc:\n\tNew files. Defines native degree-valued trig functions.", "tree": {"sha": "fa7a024410eba781d9676526155c893830cb9f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa7a024410eba781d9676526155c893830cb9f9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57391ddaf39f7cb85825c32e83feb1435889da51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57391ddaf39f7cb85825c32e83feb1435889da51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57391ddaf39f7cb85825c32e83feb1435889da51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57391ddaf39f7cb85825c32e83feb1435889da51/comments", "author": null, "committer": null, "parents": [{"sha": "2daa92ac4b51387e55e88ee48bdc2fab7ba25981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2daa92ac4b51387e55e88ee48bdc2fab7ba25981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2daa92ac4b51387e55e88ee48bdc2fab7ba25981"}], "stats": {"total": 2977, "additions": 2331, "deletions": 646}, "files": [{"sha": "fdbb8dad82cd559efe751acd88a8c7287da6626a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -1,3 +1,40 @@\n+2020-04-07  Fritz Reese  <foreese@gcc.gnu.org>\n+\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/93871\n+\t* gfortran.h (GFC_ISYM_ACOSD, GFC_ISYM_ASIND, GFC_ISYM_ATAN2D,\n+\tGFC_ISYM_ATAND, GFC_ISYM_COSD, GFC_ISYM_COTAND, GFC_ISYM_SIND,\n+\tGFC_ISYM_TAND): New.\n+\t* intrinsic.c (add_functions): Remove check for flag_dec_math.\n+\tGive degree trig functions simplification and name resolution\n+\tfunctions (e.g, gfc_simplify_atrigd () and gfc_resolve_atrigd ()).\n+\t(do_simplify): Remove special casing of degree trig functions.\n+\t* intrinsic.h (gfc_simplify_acosd, gfc_simplify_asind,\n+\tgfc_simplify_atand, gfc_simplify_cosd, gfc_simplify_cotand,\n+\tgfc_simplify_sind, gfc_simplify_tand, gfc_resolve_trigd2): Add new\n+\tprototypes.\n+\t(gfc_simplify_atrigd, gfc_simplify_trigd, gfc_resolve_cotan,\n+\tresolve_atrigd): Remove prototypes of deleted functions.\n+\t* iresolve.c (is_trig_resolved, copy_replace_function_shallow,\n+\tgfc_resolve_cotan, get_radians, get_degrees, resolve_trig_call,\n+\tgfc_resolve_atrigd, gfc_resolve_atan2d): Delete functions.\n+\t(gfc_resolve_trigd, gfc_resolve_trigd2): Resolve to library functions.\n+\t* simplify.c (rad2deg, deg2rad, gfc_simplify_acosd, gfc_simplify_asind,\n+\tgfc_simplify_atand, gfc_simplify_atan2d, gfc_simplify_cosd,\n+\tgfc_simplify_sind, gfc_simplify_tand, gfc_simplify_cotand): New\n+\tfunctions.\n+\t(gfc_simplify_atan2): Fix error message.\n+\t(simplify_trig_call, gfc_simplify_trigd, gfc_simplify_atrigd,\n+\tradians_f): Delete functions.\n+\t* trans-intrinsic.c: Add LIB_FUNCTION decls for sind, cosd, tand.\n+\t(rad2deg, gfc_conv_intrinsic_atrigd, gfc_conv_intrinsic_cotan,\n+\tgfc_conv_intrinsic_cotand, gfc_conv_intrinsic_atan2d): New functions.\n+\t(gfc_conv_intrinsic_function): Handle ACOSD, ASIND, ATAND, COTAN,\n+\tCOTAND, ATAN2D.\n+\t* trigd_fe.inc: New file. Included by simplify.c to implement\n+\tsimplify_sind, simplify_cosd, simplify_tand with code common to the\n+\tlibgfortran implementation.\n+\n 2020-04-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/93686"}, {"sha": "70a64054c95d2292a6e315a1477d9b9672a78262", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -357,6 +357,7 @@ enum gfc_isym_id\n   GFC_ISYM_ACCESS,\n   GFC_ISYM_ACHAR,\n   GFC_ISYM_ACOS,\n+  GFC_ISYM_ACOSD,\n   GFC_ISYM_ACOSH,\n   GFC_ISYM_ADJUSTL,\n   GFC_ISYM_ADJUSTR,\n@@ -369,10 +370,13 @@ enum gfc_isym_id\n   GFC_ISYM_ANINT,\n   GFC_ISYM_ANY,\n   GFC_ISYM_ASIN,\n+  GFC_ISYM_ASIND,\n   GFC_ISYM_ASINH,\n   GFC_ISYM_ASSOCIATED,\n   GFC_ISYM_ATAN,\n   GFC_ISYM_ATAN2,\n+  GFC_ISYM_ATAN2D,\n+  GFC_ISYM_ATAND,\n   GFC_ISYM_ATANH,\n   GFC_ISYM_ATOMIC_ADD,\n   GFC_ISYM_ATOMIC_AND,\n@@ -410,8 +414,10 @@ enum gfc_isym_id\n   GFC_ISYM_CONJG,\n   GFC_ISYM_CONVERSION,\n   GFC_ISYM_COS,\n+  GFC_ISYM_COSD,\n   GFC_ISYM_COSH,\n   GFC_ISYM_COTAN,\n+  GFC_ISYM_COTAND,\n   GFC_ISYM_COUNT,\n   GFC_ISYM_CPU_TIME,\n   GFC_ISYM_CSHIFT,\n@@ -598,6 +604,7 @@ enum gfc_isym_id\n   GFC_ISYM_SIGNAL,\n   GFC_ISYM_SI_KIND,\n   GFC_ISYM_SIN,\n+  GFC_ISYM_SIND,\n   GFC_ISYM_SINH,\n   GFC_ISYM_SIZE,\n   GFC_ISYM_SLEEP,\n@@ -618,6 +625,7 @@ enum gfc_isym_id\n   GFC_ISYM_SYSTEM,\n   GFC_ISYM_SYSTEM_CLOCK,\n   GFC_ISYM_TAN,\n+  GFC_ISYM_TAND,\n   GFC_ISYM_TANH,\n   GFC_ISYM_TEAM_NUMBER,\n   GFC_ISYM_THIS_IMAGE,"}, {"sha": "17f5efc65660d4be4beade3c295c7904efbde9ed", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 99, "deletions": 94, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -3281,116 +3281,130 @@ add_functions (void)\n \n   make_generic (\"loc\", GFC_ISYM_LOC, GFC_STD_GNU);\n \n-  if (flag_dec_math)\n-    {\n-      add_sym_1 (\"acosd\", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n-\n-      add_sym_1 (\"dacosd\", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"acosd\", GFC_ISYM_ACOS, GFC_STD_GNU);\n+  /* The next of intrinsic subprogram are the degree trignometric functions.\n+     These were hidden behind the -fdec-math option, but are now simply\n+     included as extensions to the set of intrinsic subprograms.  */\n \n-      add_sym_1 (\"asind\", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"acosd\", GFC_ISYM_ACOSD, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_acosd, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_1 (\"dasind\", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  add_sym_1 (\"dacosd\", GFC_ISYM_ACOSD, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_acosd, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"asind\", GFC_ISYM_ASIN, GFC_STD_GNU);\n+  make_generic (\"acosd\", GFC_ISYM_ACOSD, GFC_STD_GNU);\n \n-      add_sym_1 (\"atand\", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"asind\", GFC_ISYM_ASIND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_asind, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_1 (\"datand\", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  add_sym_1 (\"dasind\", GFC_ISYM_ASIND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_asind, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"atand\", GFC_ISYM_ATAN, GFC_STD_GNU);\n+  make_generic (\"asind\", GFC_ISYM_ASIND, GFC_STD_GNU);\n \n-      add_sym_2 (\"atan2d\",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_atan2, gfc_simplify_atan2d, gfc_resolve_atan2d,\n-\t\t y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"atand\", GFC_ISYM_ATAND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_atand, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_2 (\"datan2d\",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_datan2, gfc_simplify_atan2d, gfc_resolve_atan2d,\n-\t\t y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);\n+  add_sym_1 (\"datand\", GFC_ISYM_ATAND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_atand, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"atan2d\", GFC_ISYM_ATAN2, GFC_STD_GNU);\n+  make_generic (\"atand\", GFC_ISYM_ATAND, GFC_STD_GNU);\n \n-      add_sym_1 (\"cosd\", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_2 (\"atan2d\", GFC_ISYM_ATAN2D, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_atan2, gfc_simplify_atan2d, gfc_resolve_trigd2,\n+\t     y, BT_REAL, dr, REQUIRED,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_1 (\"dcosd\", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  add_sym_2 (\"datan2d\", GFC_ISYM_ATAN2D, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_datan2, gfc_simplify_atan2d, gfc_resolve_trigd2,\n+\t     y, BT_REAL, dd, REQUIRED,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"cosd\", GFC_ISYM_COS, GFC_STD_GNU);\n+  make_generic (\"atan2d\", GFC_ISYM_ATAN2D, GFC_STD_GNU);\n \n-      add_sym_1 (\"cotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_rc2008, gfc_simplify_cotan, gfc_resolve_cotan,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"cosd\", GFC_ISYM_COSD, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_cosd, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_1 (\"dcotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_cotan, gfc_resolve_cotan,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  add_sym_1 (\"dcosd\", GFC_ISYM_COSD, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_cosd, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"cotan\", GFC_ISYM_COTAN, GFC_STD_GNU);\n+  make_generic (\"cosd\", GFC_ISYM_COSD, GFC_STD_GNU);\n \n-      add_sym_1 (\"cotand\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"cotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_rc2008, gfc_simplify_cotan, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_1 (\"dcotand\",GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  add_sym_1 (\"dcotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_cotan, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      make_generic (\"cotand\", GFC_ISYM_COTAN, GFC_STD_GNU);\n+  add_sym_1 (\"ccotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_COMPLEX, dz, GFC_STD_GNU,\n+\t     NULL, gfc_simplify_cotan, gfc_resolve_trigd,\n+\t     x, BT_COMPLEX, dz, REQUIRED);\n \n-      add_sym_1 (\"sind\", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"zcotan\", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_COMPLEX, dd, GFC_STD_GNU,\n+\t     NULL, gfc_simplify_cotan, gfc_resolve_trigd,\n+\t     x, BT_COMPLEX, dd, REQUIRED);\n \n-      add_sym_1 (\"dsind\", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  make_generic (\"cotan\", GFC_ISYM_COTAN, GFC_STD_GNU);\n \n-      make_generic (\"sind\", GFC_ISYM_SIN, GFC_STD_GNU);\n+  add_sym_1 (\"cotand\", GFC_ISYM_COTAND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_cotand, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n \n-      add_sym_1 (\"tand\", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dr, GFC_STD_GNU,\n-\t\t gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dr, REQUIRED);\n+  add_sym_1 (\"dcotand\", GFC_ISYM_COTAND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_cotand, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n \n-      add_sym_1 (\"dtand\", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,\n-\t\t dd, GFC_STD_GNU,\n-\t\t gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,\n-\t\t x, BT_REAL, dd, REQUIRED);\n+  make_generic (\"cotand\", GFC_ISYM_COTAND, GFC_STD_GNU);\n \n-      make_generic (\"tand\", GFC_ISYM_TAN, GFC_STD_GNU);\n-    }\n+  add_sym_1 (\"sind\", GFC_ISYM_SIND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_sind, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n+\n+  add_sym_1 (\"dsind\", GFC_ISYM_SIND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_sind, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n+\n+  make_generic (\"sind\", GFC_ISYM_SIND, GFC_STD_GNU);\n+\n+  add_sym_1 (\"tand\", GFC_ISYM_TAND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dr, GFC_STD_GNU,\n+\t     gfc_check_fn_r, gfc_simplify_tand, gfc_resolve_trigd,\n+\t     x, BT_REAL, dr, REQUIRED);\n+\n+  add_sym_1 (\"dtand\", GFC_ISYM_TAND, CLASS_ELEMENTAL, ACTUAL_YES,\n+\t     BT_REAL, dd, GFC_STD_GNU,\n+\t     gfc_check_fn_d, gfc_simplify_tand, gfc_resolve_trigd,\n+\t     x, BT_REAL, dd, REQUIRED);\n+\n+  make_generic (\"tand\", GFC_ISYM_TAND, GFC_STD_GNU);\n \n   /* The following function is internally used for coarray libray functions.\n      \"make_from_module\" makes it inaccessible for external users.  */\n@@ -4566,15 +4580,6 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n       goto finish;\n     }\n \n-  /* Some math intrinsics need to wrap the original expression.  */\n-  if (specific->simplify.f1 == gfc_simplify_trigd\n-      || specific->simplify.f1 == gfc_simplify_atrigd\n-      || specific->simplify.f1 == gfc_simplify_cotan)\n-    {\n-      result = (*specific->simplify.f1) (e);\n-      goto finish;\n-    }\n-\n   if (specific->simplify.f1 == NULL)\n     {\n       result = NULL;"}, {"sha": "166ae7929392444aa75aa591f528de5d047eddf4", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -237,13 +237,14 @@ bool gfc_check_unlink_sub (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_abs (gfc_expr *);\n gfc_expr *gfc_simplify_achar (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_acos (gfc_expr *);\n+gfc_expr *gfc_simplify_acosd (gfc_expr *);\n gfc_expr *gfc_simplify_acosh (gfc_expr *);\n gfc_expr *gfc_simplify_adjustl (gfc_expr *);\n gfc_expr *gfc_simplify_adjustr (gfc_expr *);\n gfc_expr *gfc_simplify_aimag (gfc_expr *);\n gfc_expr *gfc_simplify_aint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_all (gfc_expr *, gfc_expr *);\n-gfc_expr *gfc_simplify_atrigd (gfc_expr *);\n+gfc_expr *gfc_simplify_asind (gfc_expr *);\n gfc_expr *gfc_simplify_dint (gfc_expr *);\n gfc_expr *gfc_simplify_anint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dnint (gfc_expr *);\n@@ -252,6 +253,7 @@ gfc_expr *gfc_simplify_any (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_asin (gfc_expr *);\n gfc_expr *gfc_simplify_asinh (gfc_expr *);\n gfc_expr *gfc_simplify_atan (gfc_expr *);\n+gfc_expr *gfc_simplify_atand (gfc_expr *);\n gfc_expr *gfc_simplify_atanh (gfc_expr *);\n gfc_expr *gfc_simplify_atan2 (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_atan2d (gfc_expr *, gfc_expr *);\n@@ -277,8 +279,10 @@ gfc_expr *gfc_simplify_compiler_version (void);\n gfc_expr *gfc_simplify_complex (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_conjg (gfc_expr *);\n gfc_expr *gfc_simplify_cos (gfc_expr *);\n+gfc_expr *gfc_simplify_cosd (gfc_expr *);\n gfc_expr *gfc_simplify_cosh (gfc_expr *);\n gfc_expr *gfc_simplify_cotan (gfc_expr *);\n+gfc_expr *gfc_simplify_cotand (gfc_expr *);\n gfc_expr *gfc_simplify_count (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dcmplx (gfc_expr *, gfc_expr *);\n@@ -404,6 +408,7 @@ gfc_expr *gfc_simplify_shifta (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_shiftl (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_shiftr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sin (gfc_expr *);\n+gfc_expr *gfc_simplify_sind (gfc_expr *);\n gfc_expr *gfc_simplify_sinh (gfc_expr *);\n gfc_expr *gfc_simplify_size (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sizeof (gfc_expr *);\n@@ -414,13 +419,13 @@ gfc_expr *gfc_simplify_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_sqrt (gfc_expr *);\n gfc_expr *gfc_simplify_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_tan (gfc_expr *);\n+gfc_expr *gfc_simplify_tand (gfc_expr *);\n gfc_expr *gfc_simplify_tanh (gfc_expr *);\n gfc_expr *gfc_simplify_this_image (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_tiny (gfc_expr *);\n gfc_expr *gfc_simplify_trailz (gfc_expr *);\n gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_transpose (gfc_expr *);\n-gfc_expr *gfc_simplify_trigd (gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -473,7 +478,6 @@ void gfc_resolve_conjg (gfc_expr *, gfc_expr *);\n void gfc_resolve_cos (gfc_expr *, gfc_expr *);\n void gfc_resolve_cosh (gfc_expr *, gfc_expr *);\n void gfc_resolve_count (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_cotan (gfc_expr *, gfc_expr *);\n void gfc_resolve_cshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ctime (gfc_expr *, gfc_expr *);\n void gfc_resolve_dble (gfc_expr *, gfc_expr *);\n@@ -612,7 +616,7 @@ void gfc_resolve_time8 (gfc_expr *);\n void gfc_resolve_transfer (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_transpose (gfc_expr *, gfc_expr *);\n void gfc_resolve_trigd (gfc_expr *, gfc_expr *);\n-void gfc_resolve_atrigd (gfc_expr *, gfc_expr *);\n+void gfc_resolve_trigd2 (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_trim (gfc_expr *, gfc_expr *);\n void gfc_resolve_ttynam (gfc_expr *, gfc_expr *);\n void gfc_resolve_ubound (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "7ecb6595f59b6db953fd90cc11efc957afdbb658", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 24, "deletions": 232, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -689,86 +689,6 @@ gfc_resolve_cosh (gfc_expr *f, gfc_expr *x)\n }\n \n \n-/* Our replacement of elements of a trig call with an EXPR_OP (e.g.\n-   multiplying the result or operands by a factor to convert to/from degrees)\n-   will cause the resolve_* function to be invoked again when resolving the\n-   freshly created EXPR_OP.  See gfc_resolve_trigd, gfc_resolve_atrigd,\n-   gfc_resolve_cotan.  We must observe this and avoid recursively creating\n-   layers of nested EXPR_OP expressions.  */\n-\n-static bool\n-is_trig_resolved (gfc_expr *f)\n-{\n-  /* We know we've already resolved the function if we see the lib call\n-     starting with '__'.  */\n-  return (f->value.function.name != NULL\n-\t  && gfc_str_startswith (f->value.function.name, \"__\"));\n-}\n-\n-/* Return a shallow copy of the function expression f.  The original expression\n-   has its pointers cleared so that it may be freed without affecting the\n-   shallow copy.  This is similar to gfc_copy_expr, but doesn't perform a deep\n-   copy of the argument list, allowing it to be reused somewhere else,\n-   setting the expression up nicely for gfc_replace_expr.  */\n-\n-static gfc_expr *\n-copy_replace_function_shallow (gfc_expr *f)\n-{\n-  gfc_expr *fcopy;\n-  gfc_actual_arglist *args;\n-\n-  /* The only thing deep-copied in gfc_copy_expr is args.  */\n-  args = f->value.function.actual;\n-  f->value.function.actual = NULL;\n-  fcopy = gfc_copy_expr (f);\n-  fcopy->value.function.actual = args;\n-\n-  /* Clear the old function so the shallow copy is not affected if the old\n-     expression is freed.  */\n-  f->value.function.name = NULL;\n-  f->value.function.isym = NULL;\n-  f->value.function.actual = NULL;\n-  f->value.function.esym = NULL;\n-  f->shape = NULL;\n-  f->ref = NULL;\n-\n-  return fcopy;\n-}\n-\n-\n-/* Resolve cotan = cos / sin.  */\n-\n-void\n-gfc_resolve_cotan (gfc_expr *f, gfc_expr *x)\n-{\n-  gfc_expr *result, *fcopy, *sin;\n-  gfc_actual_arglist *sin_args;\n-\n-  if (is_trig_resolved (f))\n-    return;\n-\n-  /* Compute cotan (x) = cos (x) / sin (x).  */\n-  f->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_COS);\n-  gfc_resolve_cos (f, x);\n-\n-  sin_args = gfc_get_actual_arglist ();\n-  sin_args->expr = gfc_copy_expr (x);\n-\n-  sin = gfc_get_expr ();\n-  sin->ts = f->ts;\n-  sin->where = f->where;\n-  sin->expr_type = EXPR_FUNCTION;\n-  sin->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_SIN);\n-  sin->value.function.actual = sin_args;\n-  gfc_resolve_sin (sin, sin_args->expr);\n-\n-  /* Replace f with cos/sin - we do this in place in f for the caller.  */\n-  fcopy = copy_replace_function_shallow (f);\n-  result = gfc_divide (fcopy, sin);\n-  gfc_replace_expr (f, result);\n-}\n-\n-\n void\n gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n@@ -2912,158 +2832,6 @@ gfc_resolve_tanh (gfc_expr *f, gfc_expr *x)\n }\n \n \n-/* Build an expression for converting degrees to radians.  */\n-\n-static gfc_expr *\n-get_radians (gfc_expr *deg)\n-{\n-  gfc_expr *result, *factor;\n-  gfc_actual_arglist *mod_args;\n-\n-  gcc_assert (deg->ts.type == BT_REAL);\n-\n-  /* Set deg = deg % 360 to avoid offsets from large angles.  */\n-  factor = gfc_get_constant_expr (deg->ts.type, deg->ts.kind, &deg->where);\n-  mpfr_set_d (factor->value.real, 360.0, GFC_RND_MODE);\n-\n-  mod_args = gfc_get_actual_arglist ();\n-  mod_args->expr = deg;\n-  mod_args->next = gfc_get_actual_arglist ();\n-  mod_args->next->expr = factor;\n-\n-  result = gfc_get_expr ();\n-  result->ts = deg->ts;\n-  result->where = deg->where;\n-  result->expr_type = EXPR_FUNCTION;\n-  result->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_MOD);\n-  result->value.function.actual = mod_args;\n-\n-  /* Set factor = pi / 180.  */\n-  factor = gfc_get_constant_expr (deg->ts.type, deg->ts.kind, &deg->where);\n-  mpfr_const_pi (factor->value.real, GFC_RND_MODE);\n-  mpfr_div_ui (factor->value.real, factor->value.real, 180, GFC_RND_MODE);\n-\n-  /* Result is rad = (deg % 360) * (pi / 180).  */\n-  result = gfc_multiply (result, factor);\n-  return result;\n-}\n-\n-\n-/* Build an expression for converting radians to degrees.  */\n-\n-static gfc_expr *\n-get_degrees (gfc_expr *rad)\n-{\n-  gfc_expr *result, *factor;\n-  gfc_actual_arglist *mod_args;\n-  mpfr_t tmp;\n-\n-  gcc_assert (rad->ts.type == BT_REAL);\n-\n-  /* Set rad = rad % 2pi to avoid offsets from large angles.  */\n-  factor = gfc_get_constant_expr (rad->ts.type, rad->ts.kind, &rad->where);\n-  mpfr_const_pi (factor->value.real, GFC_RND_MODE);\n-  mpfr_mul_ui (factor->value.real, factor->value.real, 2, GFC_RND_MODE);\n-\n-  mod_args = gfc_get_actual_arglist ();\n-  mod_args->expr = rad;\n-  mod_args->next = gfc_get_actual_arglist ();\n-  mod_args->next->expr = factor;\n-\n-  result = gfc_get_expr ();\n-  result->ts = rad->ts;\n-  result->where = rad->where;\n-  result->expr_type = EXPR_FUNCTION;\n-  result->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_MOD);\n-  result->value.function.actual = mod_args;\n-\n-  /* Set factor = 180 / pi.  */\n-  factor = gfc_get_constant_expr (rad->ts.type, rad->ts.kind, &rad->where);\n-  mpfr_set_ui (factor->value.real, 180, GFC_RND_MODE);\n-  mpfr_init (tmp);\n-  mpfr_const_pi (tmp, GFC_RND_MODE);\n-  mpfr_div (factor->value.real, factor->value.real, tmp, GFC_RND_MODE);\n-  mpfr_clear (tmp);\n-\n-  /* Result is deg = (rad % 2pi) * (180 / pi).  */\n-  result = gfc_multiply (result, factor);\n-  return result;\n-}\n-\n-\n-/* Resolve a call to a trig function.  */\n-\n-static void\n-resolve_trig_call (gfc_expr *f, gfc_expr *x)\n-{\n-  switch (f->value.function.isym->id)\n-    {\n-    case GFC_ISYM_ACOS:\n-      return gfc_resolve_acos (f, x);\n-    case GFC_ISYM_ASIN:\n-      return gfc_resolve_asin (f, x);\n-    case GFC_ISYM_ATAN:\n-      return gfc_resolve_atan (f, x);\n-    case GFC_ISYM_ATAN2:\n-      /* NB. arg3 is unused for atan2 */\n-      return gfc_resolve_atan2 (f, x, NULL);\n-    case GFC_ISYM_COS:\n-      return gfc_resolve_cos (f, x);\n-    case GFC_ISYM_COTAN:\n-      return gfc_resolve_cotan (f, x);\n-    case GFC_ISYM_SIN:\n-      return gfc_resolve_sin (f, x);\n-    case GFC_ISYM_TAN:\n-      return gfc_resolve_tan (f, x);\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Resolve degree trig function as trigd (x) = trig (radians (x)).  */\n-\n-void\n-gfc_resolve_trigd (gfc_expr *f, gfc_expr *x)\n-{\n-  if (is_trig_resolved (f))\n-    return;\n-\n-  x = get_radians (x);\n-  f->value.function.actual->expr = x;\n-\n-  resolve_trig_call (f, x);\n-}\n-\n-\n-/* Resolve degree inverse trig function as atrigd (x) = degrees (atrig (x)).  */\n-\n-void\n-gfc_resolve_atrigd (gfc_expr *f, gfc_expr *x)\n-{\n-  gfc_expr *result, *fcopy;\n-\n-  if (is_trig_resolved (f))\n-    return;\n-\n-  resolve_trig_call (f, x);\n-\n-  fcopy = copy_replace_function_shallow (f);\n-  result = get_degrees (fcopy);\n-  gfc_replace_expr (f, result);\n-}\n-\n-\n-/* Resolve atan2d(x) = degrees(atan2(x)).  */\n-\n-void\n-gfc_resolve_atan2d (gfc_expr *f, gfc_expr *x, gfc_expr *y ATTRIBUTE_UNUSED)\n-{\n-  /* Note that we lose the second arg here - that's okay because it is\n-     unused in gfc_resolve_atan2 anyway.  */\n-  gfc_resolve_atrigd (f, x);\n-}\n-\n-\n /* Resolve failed_images (team, kind).  */\n \n void\n@@ -3298,6 +3066,30 @@ gfc_resolve_trim (gfc_expr *f, gfc_expr *string)\n }\n \n \n+/* Resolve the degree trignometric functions.  This amounts to setting\n+   the function return type-spec from its argument and building a\n+   library function names of the form _gfortran_sind_r4.  */\n+\n+void\n+gfc_resolve_trigd (gfc_expr *f, gfc_expr *x)\n+{\n+  f->ts = x->ts;\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s_%c%d\"), f->value.function.isym->name,\n+\t\t      gfc_type_letter (x->ts.type), x->ts.kind);\n+}\n+\n+\n+void\n+gfc_resolve_trigd2 (gfc_expr *f, gfc_expr *y, gfc_expr *x)\n+{\n+  f->ts = y->ts;\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s_%d\"), f->value.function.isym->name,\n+\t\t      x->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_ubound (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {"}, {"sha": "f63f63c9ef659f79b95100b6636a77cb4918c652", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 184, "deletions": 116, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -1107,6 +1107,91 @@ gfc_simplify_asin (gfc_expr *x)\n }\n \n \n+/* Convert radians to degrees, i.e., x * 180 / pi.  */\n+\n+static void\n+rad2deg (mpfr_t x)\n+{\n+  mpfr_t tmp;\n+\n+  mpfr_init (tmp);\n+  mpfr_const_pi (tmp, GFC_RND_MODE);\n+  mpfr_mul_ui (x, x, 180, GFC_RND_MODE);\n+  mpfr_div (x, x, tmp, GFC_RND_MODE);\n+  mpfr_clear (tmp);\n+}\n+\n+\n+/* Simplify ACOSD(X) where the returned value has units of degree.  */\n+\n+gfc_expr *\n+gfc_simplify_acosd (gfc_expr *x)\n+{\n+  gfc_expr *result;\n+\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  if (mpfr_cmp_si (x->value.real, 1) > 0\n+      || mpfr_cmp_si (x->value.real, -1) < 0)\n+    {\n+      gfc_error (\"Argument of ACOSD at %L must be between -1 and 1\",\n+\t\t &x->where);\n+      return &gfc_bad_expr;\n+    }\n+\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_acos (result->value.real, x->value.real, GFC_RND_MODE);\n+  rad2deg (result->value.real);\n+\n+  return range_check (result, \"ACOSD\");\n+}\n+\n+\n+/* Simplify asind (x) where the returned value has units of degree. */\n+\n+gfc_expr *\n+gfc_simplify_asind (gfc_expr *x)\n+{\n+  gfc_expr *result;\n+\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  if (mpfr_cmp_si (x->value.real, 1) > 0\n+      || mpfr_cmp_si (x->value.real, -1) < 0)\n+    {\n+      gfc_error (\"Argument of ASIND at %L must be between -1 and 1\",\n+\t\t &x->where);\n+      return &gfc_bad_expr;\n+    }\n+\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_asin (result->value.real, x->value.real, GFC_RND_MODE);\n+  rad2deg (result->value.real);\n+\n+  return range_check (result, \"ASIND\");\n+}\n+\n+\n+/* Simplify atand (x) where the returned value has units of degree. */\n+\n+gfc_expr *\n+gfc_simplify_atand (gfc_expr *x)\n+{\n+  gfc_expr *result;\n+\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_atan (result->value.real, x->value.real, GFC_RND_MODE);\n+  rad2deg (result->value.real);\n+\n+  return range_check (result, \"ATAND\");\n+}\n+\n+\n gfc_expr *\n gfc_simplify_asinh (gfc_expr *x)\n {\n@@ -1208,8 +1293,8 @@ gfc_simplify_atan2 (gfc_expr *y, gfc_expr *x)\n \n   if (mpfr_zero_p (y->value.real) && mpfr_zero_p (x->value.real))\n     {\n-      gfc_error (\"If first argument of ATAN2 %L is zero, then the \"\n-\t\t \"second argument must not be zero\", &x->where);\n+      gfc_error (\"If first argument of ATAN2 at %L is zero, then the \"\n+\t\t \"second argument must not be zero\", &y->where);\n       return &gfc_bad_expr;\n     }\n \n@@ -1736,172 +1821,153 @@ gfc_simplify_conjg (gfc_expr *e)\n   return range_check (result, \"CONJG\");\n }\n \n-/* Return the simplification of the constant expression in icall, or NULL\n-   if the expression is not constant.  */\n \n-static gfc_expr *\n-simplify_trig_call (gfc_expr *icall)\n-{\n-  gfc_isym_id func = icall->value.function.isym->id;\n-  gfc_expr *x = icall->value.function.actual->expr;\n-\n-  /* The actual simplifiers will return NULL for non-constant x.  */\n-  switch (func)\n-    {\n-    case GFC_ISYM_ACOS:\n-      return gfc_simplify_acos (x);\n-    case GFC_ISYM_ASIN:\n-      return gfc_simplify_asin (x);\n-    case GFC_ISYM_ATAN:\n-      return gfc_simplify_atan (x);\n-    case GFC_ISYM_COS:\n-      return gfc_simplify_cos (x);\n-    case GFC_ISYM_COTAN:\n-      return gfc_simplify_cotan (x);\n-    case GFC_ISYM_SIN:\n-      return gfc_simplify_sin (x);\n-    case GFC_ISYM_TAN:\n-      return gfc_simplify_tan (x);\n-    default:\n-      gfc_internal_error (\"in simplify_trig_call(): Bad intrinsic\");\n+/* Simplify atan2d (x) where the unit is degree.  */\n+\n+gfc_expr *\n+gfc_simplify_atan2d (gfc_expr *y, gfc_expr *x)\n+{\n+  gfc_expr *result;\n+\n+  if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  if (mpfr_zero_p (y->value.real) && mpfr_zero_p (x->value.real))\n+    {\n+      gfc_error (\"If first argument of ATAN2D at %L is zero, then the \"\n+\t\t \"second argument must not be zero\", &y->where);\n+      return &gfc_bad_expr;\n     }\n+\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_atan2 (result->value.real, y->value.real, x->value.real, GFC_RND_MODE);\n+  rad2deg (result->value.real);\n+\n+  return range_check (result, \"ATAN2D\");\n }\n \n-/* Convert a floating-point number from radians to degrees.  */\n \n-static void\n-degrees_f (mpfr_t x, mpfr_rnd_t rnd_mode)\n+gfc_expr *\n+gfc_simplify_cos (gfc_expr *x)\n {\n-  mpfr_t tmp;\n-  mpfr_init (tmp);\n+  gfc_expr *result;\n \n-  /* Set x = x * 180.  */\n-  mpfr_mul_ui (x, x, 180, rnd_mode);\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n \n-  /* Set x = x / pi.  */\n-  mpfr_const_pi (tmp, rnd_mode);\n-  mpfr_div (x, x, tmp, rnd_mode);\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_clear (tmp);\n+  switch (x->ts.type)\n+    {\n+      case BT_REAL:\n+\tmpfr_cos (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+\n+      case BT_COMPLEX:\n+\tgfc_set_model_kind (x->ts.kind);\n+\tmpc_cos (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n+\tbreak;\n+\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n+    }\n+\n+  return range_check (result, \"COS\");\n }\n \n-/* Convert a floating-point number from degrees to radians.  */\n \n static void\n-radians_f (mpfr_t x, mpfr_rnd_t rnd_mode)\n+deg2rad (mpfr_t x)\n {\n-  mpfr_t tmp;\n-  mpfr_init (tmp);\n+  mpfr_t d2r;\n \n-  /* Set x = x % 360 to avoid offsets with large angles.  */\n-  mpfr_set_ui (tmp, 360, rnd_mode);\n-  mpfr_fmod (tmp, x, tmp, rnd_mode);\n+  mpfr_init (d2r);\n+  mpfr_const_pi (d2r, GFC_RND_MODE);\n+  mpfr_div_ui (d2r, d2r, 180, GFC_RND_MODE);\n+  mpfr_mul (x, x, d2r, GFC_RND_MODE);\n+  mpfr_clear (d2r);\n+}\n \n-  /* Set x = x * pi.  */\n-  mpfr_const_pi (tmp, rnd_mode);\n-  mpfr_mul (x, x, tmp, rnd_mode);\n \n-  /* Set x = x / 180.  */\n-  mpfr_div_ui (x, x, 180, rnd_mode);\n-\n-  mpfr_clear (tmp);\n-}\n+/* Simplification routines for SIND, COSD, TAND.  */\n+#include \"trigd_fe.inc\"\n \n \n-/* Convert argument to radians before calling a trig function.  */\n+/* Simplify COSD(X) where X has the unit of degree.  */\n \n gfc_expr *\n-gfc_simplify_trigd (gfc_expr *icall)\n+gfc_simplify_cosd (gfc_expr *x)\n {\n-  gfc_expr *arg;\n-\n-  arg = icall->value.function.actual->expr;\n+  gfc_expr *result;\n \n-  if (arg->ts.type != BT_REAL)\n-    gfc_internal_error (\"in gfc_simplify_trigd(): Bad type\");\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n \n-  if (arg->expr_type == EXPR_CONSTANT)\n-    /* Convert constant to radians before passing off to simplifier.  */\n-    radians_f (arg->value.real, GFC_RND_MODE);\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+  simplify_cosd (result->value.real);\n \n-  /* Let the usual simplifier take over - we just simplified the arg.  */\n-  return simplify_trig_call (icall);\n+  return range_check (result, \"COSD\");\n }\n \n-/* Convert result of an inverse trig function to degrees.  */\n+\n+/* Simplify SIND(X) where X has the unit of degree.  */\n \n gfc_expr *\n-gfc_simplify_atrigd (gfc_expr *icall)\n+gfc_simplify_sind (gfc_expr *x)\n {\n   gfc_expr *result;\n \n-  if (icall->value.function.actual->expr->ts.type != BT_REAL)\n-    gfc_internal_error (\"in gfc_simplify_atrigd(): Bad type\");\n-\n-  /* See if another simplifier has work to do first.  */\n-  result = simplify_trig_call (icall);\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n \n-  if (result && result->expr_type == EXPR_CONSTANT)\n-    {\n-      /* Convert constant to degrees after passing off to actual simplifier.  */\n-      degrees_f (result->value.real, GFC_RND_MODE);\n-      return result;\n-    }\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+  simplify_sind (result->value.real);\n \n-  /* Let gfc_resolve_atrigd take care of the non-constant case.  */\n-  return NULL;\n+  return range_check (result, \"SIND\");\n }\n \n-/* Convert the result of atan2 to degrees.  */\n+\n+/* Simplify TAND(X) where X has the unit of degree.  */\n \n gfc_expr *\n-gfc_simplify_atan2d (gfc_expr *y, gfc_expr *x)\n+gfc_simplify_tand (gfc_expr *x)\n {\n   gfc_expr *result;\n \n-  if (x->ts.type != BT_REAL || y->ts.type != BT_REAL)\n-    gfc_internal_error (\"in gfc_simplify_atan2d(): Bad type\");\n+  if (x->expr_type != EXPR_CONSTANT)\n+    return NULL;\n \n-  if (x->expr_type == EXPR_CONSTANT && y->expr_type == EXPR_CONSTANT)\n-    {\n-      result = gfc_simplify_atan2 (y, x);\n-      if (result != NULL)\n-\t{\n-\t  degrees_f (result->value.real, GFC_RND_MODE);\n-\t  return result;\n-\t}\n-    }\n+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+  simplify_tand (result->value.real);\n \n-  /* Let gfc_resolve_atan2d take care of the non-constant case.  */\n-  return NULL;\n+  return range_check (result, \"TAND\");\n }\n \n+\n+/* Simplify COTAND(X) where X has the unit of degree.  */\n+\n gfc_expr *\n-gfc_simplify_cos (gfc_expr *x)\n+gfc_simplify_cotand (gfc_expr *x)\n {\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n+  /* Implement COTAND = -TAND(x+90).\n+     TAND offers correct exact values for multiples of 30 degrees.\n+     This implementation is also compatible with the behavior of some legacy\n+     compilers.  Keep this consistent with gfc_conv_intrinsic_cotand.  */\n   result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+  mpfr_set (result->value.real, x->value.real, GFC_RND_MODE);\n+  mpfr_add_ui (result->value.real, result->value.real, 90, GFC_RND_MODE);\n+  simplify_tand (result->value.real);\n+  mpfr_neg (result->value.real, result->value.real, GFC_RND_MODE);\n \n-  switch (x->ts.type)\n-    {\n-      case BT_REAL:\n-\tmpfr_cos (result->value.real, x->value.real, GFC_RND_MODE);\n-\tbreak;\n-\n-      case BT_COMPLEX:\n-\tgfc_set_model_kind (x->ts.kind);\n-\tmpc_cos (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-\tbreak;\n-\n-      default:\n-\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n-    }\n-\n-  return range_check (result, \"COS\");\n+  return range_check (result, \"COTAND\");\n }\n \n \n@@ -7778,6 +7844,8 @@ gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n }\n \n \n+/* Simplify COTAN(X) where X has the unit of radian.  */\n+\n gfc_expr *\n gfc_simplify_cotan (gfc_expr *x)\n {\n@@ -7799,8 +7867,8 @@ gfc_simplify_cotan (gfc_expr *x)\n       /* There is no builtin mpc_cot, so compute cot = cos / sin.  */\n       val = &result->value.complex;\n       mpc_init2 (swp, mpfr_get_default_prec ());\n-      mpc_cos (swp, x->value.complex, GFC_MPC_RND_MODE);\n-      mpc_sin (*val, x->value.complex, GFC_MPC_RND_MODE);\n+      mpc_sin_cos (*val, swp, x->value.complex, GFC_MPC_RND_MODE,\n+\t\t   GFC_MPC_RND_MODE);\n       mpc_div (*val, swp, *val, GFC_MPC_RND_MODE);\n       mpc_clear (swp);\n       break;"}, {"sha": "fd8809902b7ae684ca931fcb19494fd734aa766a", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -120,6 +120,9 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n \n   /* Functions in libgfortran.  */\n   LIB_FUNCTION (ERFC_SCALED, \"erfc_scaled\", false),\n+  LIB_FUNCTION (SIND, \"sind\", false),\n+  LIB_FUNCTION (COSD, \"cosd\", false),\n+  LIB_FUNCTION (TAND, \"tand\", false),\n \n   /* End the list.  */\n   LIB_FUNCTION (NONE, NULL, false)\n@@ -4385,6 +4388,181 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   se->expr = resvar;\n }\n \n+\n+/* Generate the constant 180 / pi, which is used in the conversion\n+   of acosd(), asind(), atand(), atan2d().  */\n+\n+static tree\n+rad2deg (int kind)\n+{\n+  tree retval;\n+  mpfr_t pi, t0;\n+\n+  gfc_set_model_kind (kind);\n+  mpfr_init (pi);\n+  mpfr_init (t0);\n+  mpfr_set_si (t0, 180, GFC_RND_MODE);\n+  mpfr_const_pi (pi, GFC_RND_MODE);\n+  mpfr_div (t0, t0, pi, GFC_RND_MODE);\n+  retval = gfc_conv_mpfr_to_tree (t0, kind, 0);\n+  mpfr_clear (t0);\n+  mpfr_clear (pi);\n+  return retval;\n+}\n+\n+\n+/* ACOSD(x) is translated into ACOS(x) * 180 / pi.\n+   ASIND(x) is translated into ASIN(x) * 180 / pi.\n+   ATAND(x) is translated into ATAN(x) * 180 / pi.  */\n+\n+static void\n+gfc_conv_intrinsic_atrigd (gfc_se * se, gfc_expr * expr, gfc_isym_id id)\n+{\n+  tree arg;\n+  tree atrigd;\n+  tree type;\n+\n+  type = gfc_typenode_for_spec (&expr->ts);\n+\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+\n+  if (id == GFC_ISYM_ACOSD)\n+    atrigd = gfc_builtin_decl_for_float_kind (BUILT_IN_ACOS, expr->ts.kind);\n+  else if (id == GFC_ISYM_ASIND)\n+    atrigd = gfc_builtin_decl_for_float_kind (BUILT_IN_ASIN, expr->ts.kind);\n+  else if (id == GFC_ISYM_ATAND)\n+    atrigd = gfc_builtin_decl_for_float_kind (BUILT_IN_ATAN, expr->ts.kind);\n+  else\n+    gcc_unreachable ();\n+\n+  atrigd = build_call_expr_loc (input_location, atrigd, 1, arg);\n+\n+  se->expr = fold_build2_loc (input_location, MULT_EXPR, type, atrigd,\n+\t\t\t      fold_convert (type, rad2deg (expr->ts.kind)));\n+}\n+\n+\n+/* COTAN(X) is translated into -TAN(X+PI/2) for REAL argument and\n+   COS(X) / SIN(X) for COMPLEX argument.  */\n+\n+static void\n+gfc_conv_intrinsic_cotan (gfc_se *se, gfc_expr *expr)\n+{\n+  gfc_intrinsic_map_t *m;\n+  tree arg;\n+  tree type;\n+\n+  type = gfc_typenode_for_spec (&expr->ts);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+\n+  if (expr->ts.type == BT_REAL)\n+    {\n+      tree tan;\n+      tree tmp;\n+      mpfr_t pio2;\n+\n+      /* Create pi/2.  */\n+      gfc_set_model_kind (expr->ts.kind);\n+      mpfr_init (pio2);\n+      mpfr_const_pi (pio2, GFC_RND_MODE);\n+      mpfr_div_ui (pio2, pio2, 2, GFC_RND_MODE);\n+      tmp = gfc_conv_mpfr_to_tree (pio2, expr->ts.kind, 0);\n+      mpfr_clear (pio2);\n+\n+      /* Find tan builtin function.  */\n+      m = gfc_intrinsic_map;\n+      for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n+\tif (GFC_ISYM_TAN == m->id)\n+\t  break;\n+\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, type, arg, tmp);\n+      tan = gfc_get_intrinsic_lib_fndecl (m, expr);\n+      tan = build_call_expr_loc (input_location, tan, 1, tmp);\n+      se->expr = fold_build1_loc (input_location, NEGATE_EXPR, type, tan);\n+    }\n+  else\n+    {\n+      tree sin;\n+      tree cos;\n+\n+      /* Find cos builtin function.  */\n+      m = gfc_intrinsic_map;\n+      for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n+\tif (GFC_ISYM_COS == m->id)\n+\t  break;\n+\n+      cos = gfc_get_intrinsic_lib_fndecl (m, expr);\n+      cos = build_call_expr_loc (input_location, cos, 1, arg);\n+\n+      /* Find sin builtin function.  */\n+      m = gfc_intrinsic_map;\n+      for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n+\tif (GFC_ISYM_SIN == m->id)\n+\t  break;\n+\n+      sin = gfc_get_intrinsic_lib_fndecl (m, expr);\n+      sin = build_call_expr_loc (input_location, sin, 1, arg);\n+\n+      /* Divide cos by sin. */\n+      se->expr = fold_build2_loc (input_location, RDIV_EXPR, type, cos, sin);\n+   }\n+}\n+\n+\n+/* COTAND(X) is translated into -TAND(X+90) for REAL argument.  */\n+\n+static void\n+gfc_conv_intrinsic_cotand (gfc_se *se, gfc_expr *expr)\n+{\n+  tree arg;\n+  tree type;\n+  tree ninety_tree;\n+  mpfr_t ninety;\n+\n+  type = gfc_typenode_for_spec (&expr->ts);\n+  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+\n+  gfc_set_model_kind (expr->ts.kind);\n+\n+  /* Build the tree for x + 90.  */\n+  mpfr_init_set_ui (ninety, 90, GFC_RND_MODE);\n+  ninety_tree = gfc_conv_mpfr_to_tree (ninety, expr->ts.kind, 0);\n+  arg = fold_build2_loc (input_location, PLUS_EXPR, type, arg, ninety_tree);\n+  mpfr_clear (ninety);\n+\n+  /* Find tand.  */\n+  gfc_intrinsic_map_t *m = gfc_intrinsic_map;\n+  for (; m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n+    if (GFC_ISYM_TAND == m->id)\n+      break;\n+\n+  tree tand = gfc_get_intrinsic_lib_fndecl (m, expr);\n+  tand = build_call_expr_loc (input_location, tand, 1, arg);\n+\n+  se->expr = fold_build1_loc (input_location, NEGATE_EXPR, type, tand);\n+}\n+\n+\n+/* ATAN2D(Y,X) is translated into ATAN2(Y,X) * 180 / PI. */\n+\n+static void\n+gfc_conv_intrinsic_atan2d (gfc_se *se, gfc_expr *expr)\n+{\n+  tree args[2];\n+  tree atan2d;\n+  tree type;\n+\n+  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  type = TREE_TYPE (args[0]);\n+\n+  atan2d = gfc_builtin_decl_for_float_kind (BUILT_IN_ATAN2, expr->ts.kind);\n+  atan2d = build_call_expr_loc (input_location, atan2d, 2, args[0], args[1]);\n+\n+  se->expr = fold_build2_loc (input_location, MULT_EXPR, type, atan2d,\n+\t\t\t      rad2deg (expr->ts.kind));\n+}\n+\n+\n /* COUNT(A) = Number of true elements in A.  */\n static void\n gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n@@ -9895,6 +10073,24 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_anyall (se, expr, NE_EXPR);\n       break;\n \n+    case GFC_ISYM_ACOSD:\n+    case GFC_ISYM_ASIND:\n+    case GFC_ISYM_ATAND:\n+      gfc_conv_intrinsic_atrigd (se, expr, expr->value.function.isym->id);\n+      break;\n+\n+    case GFC_ISYM_COTAN:\n+      gfc_conv_intrinsic_cotan (se, expr);\n+      break;\n+\n+    case GFC_ISYM_COTAND:\n+      gfc_conv_intrinsic_cotand (se, expr);\n+      break;\n+\n+    case GFC_ISYM_ATAN2D:\n+      gfc_conv_intrinsic_atan2d (se, expr);\n+      break;\n+\n     case GFC_ISYM_BTEST:\n       gfc_conv_intrinsic_btest (se, expr);\n       break;"}, {"sha": "78ca4416a21fb023901a0f5b1db238d27c5443f3", "filename": "gcc/fortran/trigd_fe.inc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Ftrigd_fe.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ffortran%2Ftrigd_fe.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrigd_fe.inc?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,50 @@\n+\n+\n+/* Stub for defining degree-valued trigonemetric functions using MPFR.\n+   Copyright (C) 2000-2020 Free Software Foundation, Inc.\n+   Contributed by Fritz Reese <foreese@gcc.gnu.org>\n+   and Steven G. Kargl <kargl@gcc.gnu.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define FTYPE mpfr_t\n+#define RETTYPE void\n+#define RETURN(x) do { } while (0)\n+#define ITYPE mpz_t\n+\n+#define ISFINITE(x) mpfr_number_p(x)\n+#define D2R(x) deg2rad(x)\n+\n+#define SIND simplify_sind\n+#define COSD simplify_cosd\n+#define TAND simplify_tand\n+\n+#ifdef HAVE_GFC_REAL_16\n+#define COSD30 8.66025403784438646763723170752936183e-01Q\n+#else\n+#define COSD30 8.66025403784438646763723170752936183e-01L\n+#endif\n+\n+#define SET_COSD30(x) mpfr_set_ld((x), COSD30, GFC_RND_MODE)\n+\n+static RETTYPE SIND (FTYPE);\n+static RETTYPE COSD (FTYPE);\n+static RETTYPE TAND (FTYPE);\n+\n+#include \"../../libgfortran/intrinsics/trigd.inc\"\n+\n+/* vim: set ft=c: */"}, {"sha": "096cfce891eaf10a1d1b65b9cca165eb069a1b36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -1,3 +1,12 @@\n+2020-04-01  Fritz Reese  <foreese@gcc.gnu.org>\n+\n+\t PR fortran/93871\n+\t * gfortran.dg/dec_math.f90: Extend coverage to real(10) and real(16).\n+\t * gfortran.dg/dec_math_2.f90: New test.\n+\t * gfortran.dg/dec_math_3.f90: Likewise.\n+\t * gfortran.dg/dec_math_4.f90: Likewise.\n+\t * gfortran.dg/dec_math_5.f90: Likewise.\n+\n 2020-04-07  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* g++.target/arm/mve.exp: New."}, {"sha": "cc141aba4129c12e1ea45b5da8579002c7270193", "filename": "gcc/testsuite/gfortran.dg/dec_math.f90", "status": "modified", "additions": 606, "deletions": 195, "changes": 801, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math.f90?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -1,289 +1,700 @@\n-! { dg-options \"-fdec-math\" }\n+! { dg-options \"-cpp -std=gnu\" }\n ! { dg-do run }\n !\n-! Test extra math intrinsics offered by -fdec-math.\n+! Test extra math intrinsics formerly offered by -fdec-math,\n+! now included with -std=gnu or -std=legacy.\n !\n \n-  subroutine cmpf(f1, f2, tolerance, str)\n+module dec_math\n+\n+  implicit none\n+\n+  real(4), parameter :: pi_f = 3.14159274_4\n+  real(8), parameter :: pi_d = 3.1415926535897931_8\n+#ifdef __GFC_REAL_10__\n+  real(10), parameter :: pi_l = 3.1415926535897932383_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+  real(16), parameter :: pi_q = 3.1415926535897932384626433832795028_16\n+#endif\n+\n+  real(4), parameter :: r2d_f = 180.0_4 / pi_f\n+  real(8), parameter :: r2d_d = 180.0_8 / pi_d\n+#ifdef __GFC_REAL_10__\n+  real(10), parameter :: r2d_l = 180.0_10 / pi_l\n+#endif\n+#ifdef __GFC_REAL_16__\n+  real(16), parameter :: r2d_q = 180.0_16 / pi_q\n+#endif\n+\n+contains\n+\n+  function d2rf(x)\n+    implicit none\n+    real(4), intent(in) :: x\n+    real(4) :: d2rf\n+    d2rf = (x * pi_f) / 180.0_4\n+  endfunction\n+\n+  subroutine cmpf(x, f1, f2, tolerance, str)\n     implicit none\n-    real(4), intent(in) :: f1, f2, tolerance\n+    real(4), intent(in) :: x, f1, f2, tolerance\n     character(len=*), intent(in) :: str\n     if ( abs(f2 - f1) .gt. tolerance ) then\n-      write (*, '(A,F12.6,F12.6)') str, f1, f2\n+      write (*, '(A,A,F12.6,A,F12.6,F12.6)') str, \"(\", x, \")\", f1, f2\n       STOP 1\n     endif\n   endsubroutine\n \n-  subroutine cmpd(d1, d2, tolerance, str)\n+  function d2rd(x)\n     implicit none\n-    real(8), intent(in) :: d1, d2, tolerance\n+    real(8), intent(in) :: x\n+    real(8) :: d2rd\n+    d2rd = (x * pi_d) / 180.0_8\n+  endfunction\n+\n+  subroutine cmpd(x, d1, d2, tolerance, str)\n+    implicit none\n+    real(8), intent(in) :: x, d1, d2, tolerance\n     character(len=*), intent(in) :: str\n     if ( dabs(d2 - d1) .gt. tolerance ) then\n-      write (*, '(A,F12.6,F12.6)') str, d1, d2\n+      write (*, '(A,A,F18.14,A,F18.14,F18.14)') str, \"(\", x, \")\", d1, d2\n       STOP 2\n     endif\n   endsubroutine\n \n-implicit none\n+#ifdef __GFC_REAL_10__\n+  function d2rl(x)\n+    implicit none\n+    real(10), intent(in) :: x\n+    real(10) :: d2rl\n+    d2rl = (x * pi_l) / 180.0_10\n+  endfunction\n \n-  real(4), parameter :: pi_f = (4.0_4 *  atan(1.0_4))\n-  real(8), parameter :: pi_d = (4.0_8 * datan(1.0_8))\n-  real(4), parameter :: r2d_f = 180.0_4 / pi_f\n-  real(8), parameter :: r2d_d = 180.0_8 / pi_d\n-  real(4), parameter :: d2r_f = pi_f / 180.0_4\n-  real(8), parameter :: d2r_d = pi_d / 180.0_8\n+  subroutine cmpl(x, f1, f2, tolerance, str)\n+    implicit none\n+    real(10), intent(in) :: x, f1, f2, tolerance\n+    character(len=*), intent(in) :: str\n+    if ( abs(f2 - f1) .gt. tolerance ) then\n+      write (*, '(A,A,F21.17,A,F21.17,F21.17)') str, \"(\", x, \")\", f1, f2\n+      STOP 1\n+    endif\n+  endsubroutine\n+#endif\n+\n+#ifdef __GFC_REAL_16__\n+  function d2rq(x)\n+    implicit none\n+    real(16), intent(in) :: x\n+    real(16) :: d2rq\n+    d2rq = (x * pi_q) / 180.0_16\n+  endfunction\n+\n+  subroutine cmpq(x, f1, f2, tolerance, str)\n+    implicit none\n+    real(16), intent(in) :: x, f1, f2, tolerance\n+    character(len=*), intent(in) :: str\n+    if ( abs(f2 - f1) .gt. tolerance ) then\n+      write (*, '(A,A,F34.30,A,F34.30,F34.30)') str, \"(\", x, \")\", f1, f2\n+      STOP 1\n+    endif\n+  endsubroutine\n+#endif\n+\n+end module\n+\n+use dec_math\n+\n+implicit none\n \n ! inputs\n real(4) :: f_i1, f_i2\n real(4), volatile :: xf\n real(8) :: d_i1, d_i2\n real(8), volatile :: xd\n+#ifdef __GFC_REAL_10__\n+real(10) :: l_i1, l_i2\n+real(10), volatile :: xl\n+#endif\n+#ifdef __GFC_REAL_16__\n+real(16) :: q_i1, q_i2\n+real(16), volatile :: xq\n+#endif\n \n ! expected outputs from (oe) default (oxe) expression\n real(4) :: f_oe, f_oxe\n real(8) :: d_oe, d_oxe\n+#ifdef __GFC_REAL_10__\n+real(10) :: l_oe, l_oxe\n+#endif\n+#ifdef __GFC_REAL_16__\n+real(16) :: q_oe, q_oxe\n+#endif\n \n ! actual outputs from (oa) default (oc) constant (ox) expression\n real(4) :: f_oa, f_oc, f_ox\n real(8) :: d_oa, d_oc, d_ox\n+#ifdef __GFC_REAL_10__\n+real(10) :: l_oa, l_oc, l_ox\n+#endif\n+#ifdef __GFC_REAL_16__\n+real(16) :: q_oa, q_oc, q_ox\n+#endif\n \n ! tolerance of the answer: assert |exp-act| <= tol\n-real(4) :: f_tol\n-real(8) :: d_tol\n-\n-! equivalence tolerance\n-f_tol = 5e-5_4\n-d_tol = 5e-6_8\n-\n-! multiplication factors to test non-constant expressions\n+! accept loss of ~four decimal places\n+real(4), parameter :: f_tol  = 5e-3_4\n+real(8), parameter :: d_tol  = 5e-10_8\n+#ifdef __GFC_REAL_10__\n+real(10), parameter :: l_tol = 5e-15_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+real(16), parameter :: q_tol = 5e-20_16\n+#endif\n+\n+! volatile multiplication factors to test non-constant expressions\n xf = 2.0_4\n xd = 2.0_8\n-\n-! Input\n-f_i1 = 0.68032123_4\n-d_i1 = 0.68032123_8\n-\n-! Expected\n-f_oe =     r2d_f*acos (f_i1)\n-f_oxe = xf*r2d_f*acos (f_i1)\n-d_oe =     r2d_d*dacos(d_i1)\n-d_oxe = xd*r2d_d*dacos(d_i1)\n+#ifdef __GFC_REAL_10__\n+xl = 2.0_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+xq = 2.0_16\n+#endif\n+\n+! Input -- cos(pi/4)\n+f_i1 = 0.707107_4\n+d_i1 = 0.707106781186548_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 0.707106781186547573_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 0.707106781186547572737310929369414_16\n+#endif\n+\n+! Expected -- pi/4\n+f_oe =  r2d_f * acos (f_i1)\n+f_oxe = r2d_f * acos (xf * f_i1)\n+d_oe =  r2d_d * acos (d_i1)\n+d_oxe = r2d_d * acos (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oe =  r2d_l * acos (l_i1)\n+l_oxe = r2d_l * acos (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe =  r2d_q * acos (q_i1)\n+q_oxe = r2d_q * acos (xq * q_i1)\n+#endif\n \n ! Actual\n f_oa =    acosd (f_i1)\n-f_oc =    acosd (0.68032123_4)\n-f_ox = xf*acosd (f_i1)\n-d_oa =    dacosd (d_i1)\n-d_oc =    dacosd (0.68032123_8)\n-d_ox = xd*dacosd (0.68032123_8)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) acosd\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) acosd\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) acosd\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dacosd\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dacosd\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) dacosd\")\n+f_oc =    acosd (0.707107_4)\n+f_ox = acosd (xf * f_i1)\n+d_oa =     acosd (d_i1)\n+d_oc =     acosd (0.707106781186548_8)\n+d_ox = acosd (xd * 0.707106781186548_8)\n+#ifdef __GFC_REAL_10__\n+l_oa =    acosd (l_i1)\n+l_oc =    acosd (0.707106781186547573_10)\n+l_ox = acosd (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa =    acosd (q_i1)\n+q_oc =    acosd (0.707106781186547572737310929369414_16)\n+q_ox = acosd (xq * 0.707106781186547572737310929369414_16)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) facosd\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) facosd\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) facosd\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dacosd\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dacosd\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) dacosd\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) lacosd\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) lacosd\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) lacosd\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qacosd\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qacosd\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qacosd\")\n+#endif\n \n ! Input\n f_i1 = 60.0_4\n d_i1 = 60.0_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 60.0_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 60.0_16\n+#endif\n \n ! Expected\n-f_oe  =    cos (d2r_f*f_i1)\n-f_oxe = xf*cos (d2r_f*f_i1)\n-d_oe  =    cos (d2r_d*d_i1)\n-d_oxe = xd*cos (d2r_d*d_i1)\n+f_oe  = cos (d2rf(f_i1))\n+f_oxe = cos (d2rf(xf * f_i1))\n+d_oe  = cos (d2rd(d_i1))\n+d_oxe = cos (d2rd(xd * d_i1))\n+#ifdef __GFC_REAL_10__\n+l_oe  = cos (d2rl(l_i1))\n+l_oxe = cos (d2rl(xl * l_i1))\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = cos (d2rq(q_i1))\n+q_oxe = cos (d2rq(xq * q_i1))\n+#endif\n \n ! Actual\n-f_oa =     cosd (f_i1)\n-f_oc =     cosd (60.0_4)\n-f_ox = xf* cosd (f_i1)\n-d_oa =    dcosd (d_i1)\n-d_oc =    dcosd (60.0_8)\n-d_ox = xd* cosd (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) cosd\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) cosd\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) cosd\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dcosd\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dcosd\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) cosd\")\n-\n-! Input\n-f_i1 = 0.79345021_4\n-d_i1 = 0.79345021_8\n-\n-! Expected\n-f_oe  =    r2d_f*asin (f_i1)\n-f_oxe = xf*r2d_f*asin (f_i1)\n-d_oe  =    r2d_d*asin (d_i1)\n-d_oxe = xd*r2d_d*asin (d_i1)\n+f_oa = cosd (f_i1)\n+f_oc = cosd (60.0_4)\n+f_ox = cosd (xf * f_i1)\n+d_oa = cosd (d_i1)\n+d_oc = cosd (60.0_8)\n+d_ox = cosd (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = cosd (l_i1)\n+l_oc = cosd (60.0_10)\n+l_ox = cosd (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = cosd (q_i1)\n+q_oc = cosd (60.0_16)\n+q_ox = cosd (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fcosd\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fcosd\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fcosd\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dcosd\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dcosd\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) cosd\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) lcosd\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) lcosd\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) lcosd\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qcosd\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qcosd\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qcosd\")\n+#endif\n+\n+! Input -- sin(pi/4)\n+f_i1 = 0.707107_4\n+d_i1 = 0.707106781186548_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 0.707106781186547573_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 0.707106781186547572737310929369414_16\n+#endif\n+\n+! Expected -- pi/4\n+f_oe  = r2d_f * asin (f_i1)\n+f_oxe = r2d_f * asin (xf * f_i1)\n+d_oe  = r2d_d * asin (d_i1)\n+d_oxe = r2d_d * asin (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oe  = r2d_l * asin (l_i1)\n+l_oxe = r2d_l * asin (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = r2d_q * asin (q_i1)\n+q_oxe = r2d_q * asin (xq * q_i1)\n+#endif\n \n ! Actual\n-f_oa =     asind (f_i1)\n-f_oc =     asind (0.79345021_4)\n-f_ox = xf* asind (f_i1)\n-d_oa =    dasind (d_i1)\n-d_oc =    dasind (0.79345021_8)\n-d_ox = xd* asind (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) asind\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) asind\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) asind\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dasind\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dasind\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) asind\")\n+f_oa = asind (f_i1)\n+f_oc = asind (0.707107_4)\n+f_ox = asind (xf * f_i1)\n+d_oa = asind (d_i1)\n+d_oc = asind (0.707106781186548_8)\n+d_ox = asind (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = asind (l_i1)\n+l_oc = asind (0.707106781186547573_10)\n+l_ox = asind (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = asind (q_i1)\n+q_oc = asind (0.707106781186547572737310929369414_16)\n+q_ox = asind (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fasind\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fasind\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fasind\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dasind\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dasind\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) asind\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) lasind\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) lasind\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) lasind\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qasind\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qasind\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qasind\")\n+#endif\n \n ! Input\n f_i1 = 60.0_4\n d_i1 = 60.0_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 60.0_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 60.0_16\n+#endif\n \n ! Expected\n-f_oe  =    sin (d2r_f*f_i1)\n-f_oxe = xf*sin (d2r_f*f_i1)\n-d_oe  =    sin (d2r_d*d_i1)\n-d_oxe = xd*sin (d2r_d*d_i1)\n+f_oe  = sin (d2rf(f_i1))\n+f_oxe = sin (d2rf(xf * f_i1))\n+d_oe  = sin (d2rd(d_i1))\n+d_oxe = sin (d2rd(xd * d_i1))\n+#ifdef __GFC_REAL_10__\n+l_oe  = sin (d2rl(l_i1))\n+l_oxe = sin (d2rl(xl * l_i1))\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = sin (d2rq(q_i1))\n+q_oxe = sin (d2rq(xq * q_i1))\n+#endif\n \n ! Actual\n-f_oa =     sind (f_i1)\n-f_oc =     sind (60.0_4)\n-f_ox = xf* sind (f_i1)\n-d_oa =    dsind (d_i1)\n-d_oc =    dsind (60.0_8)\n-d_ox = xd* sind (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) sind\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) sind\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) sind\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dsind\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dsind\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) sind\")\n+f_oa = sind (f_i1)\n+f_oc = sind (60.0_4)\n+f_ox = sind (xf * f_i1)\n+d_oa = sind (d_i1)\n+d_oc = sind (60.0_8)\n+d_ox = sind (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = sind (l_i1)\n+l_oc = sind (60.0_10)\n+l_ox = sind (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = sind (q_i1)\n+q_oc = sind (60.0_16)\n+q_ox = sind (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fsind\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fsind\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fsind\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dsind\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dsind\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) sind\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) lsind\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) lsind\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) lsind\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qsind\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qsind\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qsind\")\n+#endif\n \n ! Input\n-f_i1 = 2.679676_4\n-f_i2 = 1.0_4\n-d_i1 = 2.679676_8\n-d_i2 = 1.0_8\n+f_i1 = 1.0_4\n+f_i2 = 2.0_4\n+d_i1 = 1.0_8\n+d_i2 = 2.0_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 1.0_10\n+l_i2 = 2.0_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 1.0_16\n+q_i2 = 2.0_16\n+#endif\n \n ! Expected\n-f_oe  =    r2d_f*atan2 (f_i1, f_i2)\n-f_oxe = xf*r2d_f*atan2 (f_i1, f_i2)\n-d_oe  =    r2d_d*atan2 (d_i1, d_i2)\n-d_oxe = xd*r2d_d*atan2 (d_i1, d_i2)\n+f_oe  = r2d_f * atan2 (f_i1, f_i2)\n+f_oxe = r2d_f * atan2 (xf * f_i1, f_i2)\n+d_oe  = r2d_d * atan2 (d_i1, d_i2)\n+d_oxe = r2d_d * atan2 (xd * d_i1, d_i2)\n+#ifdef __GFC_REAL_10__\n+l_oe  = r2d_l * atan2 (l_i1, l_i2)\n+l_oxe = r2d_l * atan2 (xl * l_i1, l_i2)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = r2d_q * atan2 (q_i1, q_i2)\n+q_oxe = r2d_q * atan2 (xq * q_i1, q_i2)\n+#endif\n \n ! Actual\n-f_oa =     atan2d (f_i1, f_i2)\n-f_oc =     atan2d (2.679676_4, 1.0_4)\n-f_ox = xf* atan2d (f_i1, f_i2)\n-d_oa =    datan2d (d_i1, d_i2)\n-d_oc =    datan2d (2.679676_8, 1.0_8)\n-d_ox = xd* atan2d (d_i1, d_i2)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) atan2d\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) atan2d\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) atan2d\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) datan2d\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) datan2d\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) atan2d\")\n+f_oa = atan2d (f_i1, f_i2)\n+f_oc = atan2d (1.0_4, 2.0_4)\n+f_ox = atan2d (xf * f_i1, f_i2)\n+d_oa = atan2d (d_i1, d_i2)\n+d_oc = atan2d (1.0_8, 2.0_8)\n+d_ox = atan2d (xd * d_i1, d_i2)\n+#ifdef __GFC_REAL_10__\n+l_oa = atan2d (l_i1, l_i2)\n+l_oc = atan2d (1.0_10, 2.0_10)\n+l_ox = atan2d (xl * l_i1, l_i2)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = atan2d (q_i1, q_i2)\n+q_oc = atan2d (1.0_16, 2.0_16)\n+q_ox = atan2d (xq * q_i1, q_i2)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fatan2d\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fatan2d\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fatan2d\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) datan2d\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) datan2d\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) atan2d\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) latan2d\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) latan2d\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) latan2d\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qatan2d\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qatan2d\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qatan2d\")\n+#endif\n \n ! Input\n-f_i1 = 1.5874993_4\n-d_i1 = 1.5874993_8\n+f_i1 = 1.55741_4\n+d_i1 = 1.5574077246549_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 1.55740772465490229_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 1.55740772465490229237161656783428_16\n+#endif\n \n ! Expected\n-f_oe  =    r2d_f*atan (f_i1)\n-f_oxe = xf*r2d_f*atan (f_i1)\n-d_oe  =    r2d_d*atan (d_i1)\n-d_oxe = xd*r2d_d*atan (d_i1)\n+f_oe  = r2d_f * atan (f_i1)\n+f_oxe = r2d_f * atan (xf * f_i1)\n+d_oe  = r2d_d * atan (d_i1)\n+d_oxe = r2d_d * atan (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oe  = r2d_l * atan (l_i1)\n+l_oxe = r2d_l * atan (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = r2d_q * atan (q_i1)\n+q_oxe = r2d_q * atan (xq * q_i1)\n+#endif\n \n ! Actual\n-f_oa =     atand (f_i1)\n-f_oc =     atand (1.5874993_4)\n-f_ox = xf* atand (f_i1)\n-d_oa =    datand (d_i1)\n-d_oc =    datand (1.5874993_8)\n-d_ox = xd* atand (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) atand\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) atand\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) atand\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) datand\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) datand\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) atand\")\n+f_oa = atand (f_i1)\n+f_oc = atand (1.55741_4)\n+f_ox = atand (xf * f_i1)\n+d_oa = atand (d_i1)\n+d_oc = atand (1.5574077246549_8)\n+d_ox = atand (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = atand (l_i1)\n+l_oc = atand (1.55740772465490229_10)\n+l_ox = atand (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = atand (q_i1)\n+q_oc = atand (1.55740772465490229237161656783428_16)\n+q_ox = atand (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fatand\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fatand\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fatand\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) datand\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) datand\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) atand\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) latand\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) latand\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) latand\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qatand\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qatand\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qatand\")\n+#endif\n \n ! Input\n-f_i1 = 0.6_4\n-d_i1 = 0.6_8\n+f_i1 = 34.3775_4\n+d_i1 = 34.3774677078494_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 34.3774677078493909_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 34.3774677078493908766176900826395_16\n+#endif\n \n ! Expected\n-f_oe  =    cotan (d2r_f*f_i1)\n-f_oxe = xf*cotan (d2r_f*f_i1)\n-d_oe  =    cotan (d2r_d*d_i1)\n-d_oxe = xd*cotan (d2r_d*d_i1)\n+f_oe  = 1.0_4/tan (f_i1)\n+f_oxe = 1.0_4/tan (xf * f_i1)\n+d_oe  = 1.0_8/tan (d_i1)\n+d_oxe = 1.0_8/tan (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oe  = 1.0_10/tan (l_i1)\n+l_oxe = 1.0_10/tan (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = 1.0_16/tan (q_i1)\n+q_oxe = 1.0_16/tan (xq * q_i1)\n+#endif\n \n ! Actual\n-f_oa =     cotand (f_i1)\n-f_oc =     cotand (0.6_4)\n-f_ox = xf* cotand (f_i1)\n-d_oa =    dcotand (d_i1)\n-d_oc =    dcotand (0.6_8)\n-d_ox = xd* cotand (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) cotand\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) cotand\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) cotand\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dcotand\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dcotand\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) cotand\")\n+f_oa = cotan (f_i1)\n+f_oc = cotan (34.3775_4)\n+f_ox = cotan (xf * f_i1)\n+d_oa = cotan (d_i1)\n+d_oc = cotan (34.3774677078494_8)\n+d_ox = cotan (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = cotan (l_i1)\n+l_oc = cotan (34.3774677078493909_10)\n+l_ox = cotan (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = cotan (q_i1)\n+q_oc = cotan (34.3774677078493908766176900826395_16)\n+q_ox = cotan (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fcotan\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fcotan\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fcotan\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dcotan\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dcotan\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) cotan\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) lcotan\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) lcotan\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) lcotan\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qcotan\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qcotan\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qcotan\")\n+#endif\n \n ! Input\n f_i1 = 0.6_4\n d_i1 = 0.6_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 0.6_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 0.6_16\n+#endif\n \n ! Expected\n-f_oe  =     1.0_4/tan (f_i1)\n-f_oxe = xf* 1.0_4/tan (f_i1)\n-d_oe  =    1.0_8/dtan (d_i1)\n-d_oxe = xd*1.0_8/dtan (d_i1)\n+f_oe  = cotan (d2rf(f_i1))\n+f_oxe = cotan (d2rf(xf * f_i1))\n+d_oe  = cotan (d2rd(d_i1))\n+d_oxe = cotan (d2rd(xd * d_i1))\n+#ifdef __GFC_REAL_10__\n+l_oe  = cotan (d2rl(l_i1))\n+l_oxe = cotan (d2rl(xl * l_i1))\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = cotan (d2rq(q_i1))\n+q_oxe = cotan (d2rq(xq * q_i1))\n+#endif\n \n ! Actual\n-f_oa =     cotan (f_i1)\n-f_oc =     cotan (0.6_4)\n-f_ox = xf* cotan (f_i1)\n-d_oa =    dcotan (d_i1)\n-d_oc =    dcotan (0.6_8)\n-d_ox = xd* cotan (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) cotan\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) cotan\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) cotan\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dcotan\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dcotan\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) cotan\")\n+f_oa = cotand (f_i1)\n+f_oc = cotand (0.6_4)\n+f_ox = cotand (xf * f_i1)\n+d_oa = cotand (d_i1)\n+d_oc = cotand (0.6_8)\n+d_ox = cotand (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = cotand (l_i1)\n+l_oc = cotand (0.6_10)\n+l_ox = cotand (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = cotand (q_i1)\n+q_oc = cotand (0.6_16)\n+q_ox = cotand (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) fcotand\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) fcotand\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) fcotand\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dcotand\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dcotand\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) cotand\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) lcotand\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) lcotand\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) lcotand\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qcotand\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qcotand\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qcotand\")\n+#endif\n \n ! Input\n f_i1 = 60.0_4\n d_i1 = 60.0_8\n+#ifdef __GFC_REAL_10__\n+l_i1 = 60.0_10\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_i1 = 60.0_16\n+#endif\n \n ! Expected\n-f_oe  =    tan (d2r_f*f_i1)\n-f_oxe = xf*tan (d2r_f*f_i1)\n-d_oe  =    tan (d2r_d*d_i1)\n-d_oxe = xd*tan (d2r_d*d_i1)\n+f_oe  = tan (d2rf(f_i1))\n+f_oxe = tan (d2rf(xf * f_i1))\n+d_oe  = tan (d2rd(d_i1))\n+d_oxe = tan (d2rd(xd * d_i1))\n+#ifdef __GFC_REAL_10__\n+l_oe  = tan (d2rl(l_i1))\n+l_oxe = tan (d2rl(xl * l_i1))\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oe  = tan (d2rq(q_i1))\n+q_oxe = tan (d2rq(xq * q_i1))\n+#endif\n \n ! Actual\n-f_oa =     tand (f_i1)\n-f_oc =     tand (60.0_4)\n-f_ox = xf* tand (f_i1)\n-d_oa =    dtand (d_i1)\n-d_oc =    dtand (60.0_8)\n-d_ox = xd* tand (d_i1)\n-\n-call cmpf(f_oe,  f_oa, f_tol, \"( ) tand\")\n-call cmpf(f_oe,  f_oc, f_tol, \"(c) tand\")\n-call cmpf(f_oxe, f_ox, f_tol, \"(x) tand\")\n-call cmpd(d_oe,  d_oa, d_tol, \"( ) dtand\")\n-call cmpd(d_oe,  d_oc, d_tol, \"(c) dtand\")\n-call cmpd(d_oxe, d_ox, d_tol, \"(x) tand\")\n+f_oa = tand (f_i1)\n+f_oc = tand (60.0_4)\n+f_ox = tand (xf * f_i1)\n+d_oa = tand (d_i1)\n+d_oc = tand (60.0_8)\n+d_ox = tand (xd * d_i1)\n+#ifdef __GFC_REAL_10__\n+l_oa = tand (l_i1)\n+l_oc = tand (60.0_10)\n+l_ox = tand (xl * l_i1)\n+#endif\n+#ifdef __GFC_REAL_16__\n+q_oa = tand (q_i1)\n+q_oc = tand (60.0_16)\n+q_ox = tand (xq * q_i1)\n+#endif\n+\n+call cmpf(f_i1, f_oe,  f_oa, f_tol, \"( ) ftand\")\n+call cmpf(f_i1, f_oe,  f_oc, f_tol, \"(c) ftand\")\n+call cmpf(f_i1, f_oxe, f_ox, f_tol, \"(x) ftand\")\n+call cmpd(d_i1, d_oe,  d_oa, d_tol, \"( ) dtand\")\n+call cmpd(d_i1, d_oe,  d_oc, d_tol, \"(c) dtand\")\n+call cmpd(d_i1, d_oxe, d_ox, d_tol, \"(x) dtand\")\n+#ifdef __GFC_REAL_10__\n+call cmpl(l_i1, l_oe,  l_oa, l_tol, \"( ) ltand\")\n+call cmpl(l_i1, l_oe,  l_oc, l_tol, \"(c) ltand\")\n+call cmpl(l_i1, l_oxe, l_ox, l_tol, \"(x) ltand\")\n+#endif\n+#ifdef __GFC_REAL_16__\n+call cmpq(q_i1, q_oe,  q_oa, q_tol, \"( ) qtand\")\n+call cmpq(q_i1, q_oe,  q_oc, q_tol, \"(c) qtand\")\n+call cmpq(q_i1, q_oxe, q_ox, q_tol, \"(x) qtand\")\n+#endif\n \n end"}, {"sha": "ac49e273dd78a86a4d59843dd6cf84c097f3f0a6", "filename": "gcc/testsuite/gfortran.dg/dec_math_2.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_2.f90?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,14 @@\n+! { dg-options \"-fdec-math\" }\n+! { dg-do compile }\n+!\n+! Ensure extra math intrinsics formerly offered by -fdec-math\n+! are still available with -fdec-math.\n+!\n+\n+print *, sind(0.0)\n+print *, cosd(0.0)\n+print *, tand(0.0)\n+print *, cotan(1.0)\n+print *, cotand(90.0)\n+\n+end"}, {"sha": "5bf4398d0f23c5c6540555c3cf988b2161721142", "filename": "gcc/testsuite/gfortran.dg/dec_math_3.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_3.f90?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,8 @@\n+! { dg-options \"-std=gnu\" }\n+! { dg-do compile }\n+\n+! Former ICE when simplifying asind, plus wrong function name in error message\n+real, parameter :: d = asind(1.1) ! { dg-error \"Argument of ASIND at.*must be between -1 and 1\" }\n+print *, d\n+\n+end"}, {"sha": "f83210a473222c1033a00227a186b671e960e874", "filename": "gcc/testsuite/gfortran.dg/dec_math_4.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_4.f90?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,8 @@\n+! { dg-options \"-std=gnu\" }\n+! { dg-do compile }\n+\n+! Former ICE when simplifying complex cotan\n+complex, parameter :: z = cotan((1., 1.))\n+print *, z\n+\n+end"}, {"sha": "d761e039cc8a28b8c422d43ac8fa22a35d064f7b", "filename": "gcc/testsuite/gfortran.dg/dec_math_5.f90", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_math_5.f90?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,228 @@\n+! { dg-options \"-cpp -std=gnu\" }\n+! { dg-do run }\n+!\n+! Test values for degree-valued trigonometric intrinsics.\n+!\n+\n+module dec_math_5\n+\n+\n+  ! Use the highest precision available.\n+  ! Note however that if both __GFC_REAL_10__ and __GFC_REAL_16__ are defined,\n+  ! the size of real(16) is actually that of REAL(10) (80 bits) in which case\n+  ! we should not over-estimate the precision available, or the test will fail.\n+#if defined(__GFC_REAL_10__)\n+  integer, parameter :: real_kind = 10\n+  real(real_kind), parameter :: eps = 5e-11_10\n+\n+  real(real_kind), parameter :: pi_2 = 1.57079632679489656_10\n+  real(real_kind), parameter :: pi = 3.14159265358979312_10\n+  real(real_kind), parameter :: tau = 6.28318530717958623_10\n+\n+#elif defined(__GFC_REAL_16__)\n+  integer, parameter :: real_kind = 16\n+  real(real_kind), parameter :: eps = 5e-16_16\n+\n+  real(real_kind), parameter :: pi_2 = 1.5707963267948966192313216916397514_16\n+  real(real_kind), parameter :: pi = 3.1415926535897932384626433832795_16\n+  real(real_kind), parameter :: tau = 6.28318530717958647692528676655900559_16\n+\n+#else\n+  integer, parameter :: real_kind = 8\n+  real(real_kind), parameter :: eps = 5e-10_8\n+\n+  real(real_kind), parameter :: pi_2 = 1.57079632679490_8\n+  real(real_kind), parameter :: pi = 3.14159265358979_8\n+  real(real_kind), parameter :: tau = 6.28318530717959_8\n+\n+#endif\n+\n+  ! Important angles in canonical form.\n+\n+  integer, parameter :: nangle = 16\n+\n+  real(real_kind), dimension(nangle), parameter :: degrees = (/ &\n+      0, & !  180 * 0\n+     30, & ! 180 * 1/6\n+     45, & ! 180 * 1/4\n+     60, & ! 180 * 1/3\n+     90, & ! 180 * 1/2\n+    120, & ! 180 * 2/3\n+    135, & ! 180 * 3/4\n+    150, & ! 180 * 5/6\n+    180, & ! 180\n+    210, & ! 180 * 7/6\n+    225, & ! 180 * 5/4\n+    240, & ! 180 * 4/3\n+    270, & ! 180 * 3/2\n+    300, & ! 180 * 5/3\n+    315, & ! 180 * 7/4\n+    330  & ! 180 * 11/6\n+  /)\n+\n+  real(real_kind), dimension(nangle), parameter :: radians = (/ &\n+#ifdef __GFC_REAL_10__\n+    0.000000000000000000_10, & ! pi * 0\n+    0.523598775598298873_10, & ! pi * 1/6\n+    0.785398163397448310_10, & ! pi * 1/4\n+    1.047197551196597750_10, & ! pi * 1/3\n+    1.570796326794896620_10, & ! pi * 1/2\n+    2.094395102393195490_10, & ! pi * 2/3\n+    2.356194490192344930_10, & ! pi * 3/4\n+    2.617993877991494370_10, & ! pi * 5/6\n+    3.141592653589793240_10, & ! pi\n+    3.665191429188092110_10, & ! pi * 7/6\n+    3.926990816987241550_10, & ! pi * 5/4\n+    4.188790204786390980_10, & ! pi * 4/3\n+    4.712388980384689860_10, & ! pi * 3/2\n+    5.235987755982988730_10, & ! pi * 5/3\n+    5.497787143782138170_10, & ! pi * 7/4\n+    5.759586531581287600_10  & ! pi * 11/6\n+\n+#elif defined(__GFC_REAL_16__)\n+    0.000000000000000000000000000000000_16, & ! pi * 0\n+    0.523598775598298873077107230546584_16, & ! pi * 1/6\n+    0.785398163397448309615660845819876_16, & ! pi * 1/4\n+    1.047197551196597746154214461093170_16, & ! pi * 1/3\n+    1.570796326794896619231321691639750_16, & ! pi * 1/2\n+    2.094395102393195492308428922186330_16, & ! pi * 2/3\n+    2.356194490192344928846982537459630_16, & ! pi * 3/4\n+    2.617993877991494365385536152732920_16, & ! pi * 5/6\n+    3.141592653589793238462643383279500_16, & ! pi\n+    3.665191429188092111539750613826090_16, & ! pi * 7/6\n+    3.926990816987241548078304229099380_16, & ! pi * 5/4\n+    4.188790204786390984616857844372670_16, & ! pi * 4/3\n+    4.712388980384689857693965074919250_16, & ! pi * 3/2\n+    5.235987755982988730771072305465840_16, & ! pi * 5/3\n+    5.497787143782138167309625920739130_16, & ! pi * 7/4\n+    5.759586531581287603848179536012420_16  & ! pi * 11/6\n+\n+#else\n+    0.000000000000000_8, & ! pi * 0\n+    0.523598775598299_8, & ! pi * 1/6\n+    0.785398163397448_8, & ! pi * 1/4\n+    1.047197551196600_8, & ! pi * 1/3\n+    1.570796326794900_8, & ! pi * 1/2\n+    2.094395102393200_8, & ! pi * 2/3\n+    2.356194490192340_8, & ! pi * 3/4\n+    2.617993877991490_8, & ! pi * 5/6\n+    3.141592653589790_8, & ! pi\n+    3.665191429188090_8, & ! pi * 7/6\n+    3.926990816987240_8, & ! pi * 5/4\n+    4.188790204786390_8, & ! pi * 4/3\n+    4.712388980384690_8, & ! pi * 3/2\n+    5.235987755982990_8, & ! pi * 5/3\n+    5.497787143782140_8, & ! pi * 7/4\n+    5.759586531581290_8  & ! pi * 11/6\n+#endif\n+  /)\n+\n+  ! sind, cosd, tand, cotand\n+\n+  ! Ensure precision degrades minimally for large values.\n+  integer, parameter :: nphase = 5\n+\n+  integer, dimension(nphase), parameter :: phases = (/ &\n+    0, 1, 5, 100, 10000  &\n+  /)\n+\n+contains\n+\n+  subroutine compare(strl, xl_in, xl_out, strr, xr_in, xr_out, eps)\n+    use ieee_arithmetic\n+    implicit none\n+    character(*), intent(in) :: strl, strr\n+    real(real_kind), intent(in) :: xl_in, xl_out, xr_in, xr_out, eps\n+\n+    if ((ieee_is_nan(xl_out) .neqv. ieee_is_nan(xr_out)) &\n+        .or. (ieee_is_finite(xl_out) .neqv. ieee_is_finite(xr_out)) &\n+        .or. (abs(xl_out - xr_out) .gt. eps)) then\n+      write (*, 100) strl, \"(\", xl_in, \"): \", xl_out\n+      write (*, 100) strr, \"(\", xr_in, \"): \", xr_out\n+\n+      if ((ieee_is_nan(xl_out) .eqv. ieee_is_nan(xr_out)) &\n+          .and. ieee_is_finite(xl_out) .and. ieee_is_finite(xr_out)) then\n+        write (*, 300) \"|xl - xr| = \", abs(xl_out - xr_out)\n+        write (*, 300) \"    > eps = \", eps\n+      endif\n+\n+      call abort()\n+    endif\n+\n+#ifdef __GFC_REAL_16__\n+    100  format((A8,A,F34.30,A,F34.30,F34.30))\n+    200  format((A12,F34.30))\n+    !500  format((A8,A,G34.29,A,G34.29,G34.29))\n+#elif defined(__GFC_REAL_10__)\n+    100  format((A8,A,F21.17,A,F21.17,F21.17))\n+    200  format((A12,F21.17))\n+    !500  format((A8,A,G21.16,A,G21.16,G21.16))\n+#else\n+    100  format((A8,A,F18.14,A,F18.14,F18.14))\n+    200  format((A12,F18.14))\n+    !500  format((A8,A,G18.13,A,G18.13,G18.13))\n+#endif\n+    300  format((A12,G8.2))\n+  endsubroutine\n+\n+endmodule\n+\n+use dec_math_5\n+use ieee_arithmetic\n+implicit none\n+\n+integer :: phase_index, angle_index, phase\n+real(real_kind) :: deg_in, deg_out, deg_out2, rad_in, rad_out\n+\n+! Try every value in degrees, and make sure they are correct compared to the\n+! corresponding radian function.\n+\n+do phase_index = 1, size(phases)\n+  phase = phases(phase_index)\n+\n+  do angle_index = 1, size(degrees)\n+    ! eqv to degrees(angle_index) modulo 360\n+    deg_in = degrees(angle_index) + phase * 360\n+    rad_in = radians(angle_index) + phase * tau\n+\n+    ! sind vs. sin\n+    deg_out = sind(deg_in)\n+    rad_out = sin(rad_in)\n+    call compare(\"sind\", deg_in, deg_out, \"sin\", rad_in, rad_out, eps)\n+\n+    ! cosd vs. cos\n+    deg_out = cosd(deg_in)\n+    rad_out = cos(rad_in)\n+    call compare(\"cosd\", deg_in, deg_out, \"cos\", rad_in, rad_out, eps)\n+\n+    ! tand vs. tan\n+    deg_out = tand(deg_in)\n+    rad_out = tan(rad_in)\n+    if ( ieee_is_finite(deg_out) ) then\n+      call compare(\"tand\", deg_in, deg_out, \"tan\", rad_in, rad_out, eps)\n+    endif\n+\n+    ! cotand vs. cotan\n+    deg_out = cotand(deg_in)\n+    rad_out = cotan(rad_in)\n+\n+    ! Skip comparing infinity, because cotan does not return infinity\n+    if ( ieee_is_finite(deg_out) ) then\n+      call compare(\"cotand\", deg_in, deg_out, \"cotan\", rad_in, rad_out, eps)\n+\n+      ! cotand vs. tand\n+      deg_out = cotand(deg_in)\n+      deg_out2 = -tand(deg_in + 90)\n+\n+      call compare(\"cotand\", deg_in, deg_out, \"-tand+90\", deg_in, deg_out2, eps)\n+      deg_out2 = 1 / tand(deg_in)\n+      call compare(\"cotand\", deg_in, deg_out, \"1/tand\", deg_in, deg_out2, eps)\n+    endif\n+\n+  enddo\n+\n+\n+enddo\n+\n+\n+end"}, {"sha": "e33d3495028b49539103647793d66eb3c801ba1d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -1,3 +1,12 @@\n+2020-04-01  Fritz Reese  <foreese@gcc.gnu.org>\n+\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/93871\n+\t* Makefile.am, Makefile.in: New make rule for intrinsics/trigd.c.\n+\t* gfortran.map: New routines for {sind, cosd, tand}X{r4, r8, r10, r16}.\n+\t* intrinsics/trigd.c, intrinsics/trigd_lib.inc, intrinsics/trigd.inc:\n+\tNew files. Defines native degree-valued trig functions.\n+\n 2020-02-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/93599"}, {"sha": "8ca0f6c290d1895d4d4648af14f943424fc7a6c3", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -141,6 +141,7 @@ intrinsics/reshape_generic.c \\\n intrinsics/reshape_packed.c \\\n intrinsics/selected_int_kind.f90 \\\n intrinsics/selected_real_kind.f90 \\\n+intrinsics/trigd.c \\\n intrinsics/unpack_generic.c \\\n runtime/in_pack_generic.c \\\n runtime/in_unpack_generic.c"}, {"sha": "97a978aa80fc25a329e6814c8e0fe0e76a07b612", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -422,8 +422,9 @@ am__objects_58 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \tpack_generic.lo selected_char_kind.lo size.lo \\\n \tspread_generic.lo string_intrinsics.lo rand.lo random.lo \\\n \treshape_generic.lo reshape_packed.lo selected_int_kind.lo \\\n-\tselected_real_kind.lo unpack_generic.lo in_pack_generic.lo \\\n-\tin_unpack_generic.lo $(am__objects_56) $(am__objects_57)\n+\tselected_real_kind.lo trigd.lo unpack_generic.lo \\\n+\tin_pack_generic.lo in_unpack_generic.lo $(am__objects_56) \\\n+\t$(am__objects_57)\n @IEEE_SUPPORT_TRUE@am__objects_59 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n am__objects_60 =\n@@ -771,9 +772,9 @@ gfor_helper_src = intrinsics/associated.c intrinsics/abort.c \\\n \tintrinsics/rand.c intrinsics/random.c \\\n \tintrinsics/reshape_generic.c intrinsics/reshape_packed.c \\\n \tintrinsics/selected_int_kind.f90 \\\n-\tintrinsics/selected_real_kind.f90 intrinsics/unpack_generic.c \\\n-\truntime/in_pack_generic.c runtime/in_unpack_generic.c \\\n-\t$(am__append_3) $(am__append_4)\n+\tintrinsics/selected_real_kind.f90 intrinsics/trigd.c \\\n+\tintrinsics/unpack_generic.c runtime/in_pack_generic.c \\\n+\truntime/in_unpack_generic.c $(am__append_3) $(am__append_4)\n @IEEE_SUPPORT_FALSE@gfor_ieee_src = \n @IEEE_SUPPORT_TRUE@gfor_ieee_src = \\\n @IEEE_SUPPORT_TRUE@ieee/ieee_arithmetic.F90 \\\n@@ -2252,6 +2253,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transfer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transfer128.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/trigd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/umask.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unit.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unix.Plo@am__quote@\n@@ -6404,6 +6406,13 @@ reshape_packed.lo: intrinsics/reshape_packed.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o reshape_packed.lo `test -f 'intrinsics/reshape_packed.c' || echo '$(srcdir)/'`intrinsics/reshape_packed.c\n \n+trigd.lo: intrinsics/trigd.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT trigd.lo -MD -MP -MF $(DEPDIR)/trigd.Tpo -c -o trigd.lo `test -f 'intrinsics/trigd.c' || echo '$(srcdir)/'`intrinsics/trigd.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/trigd.Tpo $(DEPDIR)/trigd.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='intrinsics/trigd.c' object='trigd.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o trigd.lo `test -f 'intrinsics/trigd.c' || echo '$(srcdir)/'`intrinsics/trigd.c\n+\n unpack_generic.lo: intrinsics/unpack_generic.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_generic.lo -MD -MP -MF $(DEPDIR)/unpack_generic.Tpo -c -o unpack_generic.lo `test -f 'intrinsics/unpack_generic.c' || echo '$(srcdir)/'`intrinsics/unpack_generic.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/unpack_generic.Tpo $(DEPDIR)/unpack_generic.Plo"}, {"sha": "ebf1a6ff40b5856e82508273a1ea74d1260baca5", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -1606,4 +1606,16 @@ GFORTRAN_9.2 {\n GFORTRAN_10 {\n   global:\n   _gfortran_os_error_at;\n+  _gfortran_sind_r4;\n+  _gfortran_sind_r8;\n+  _gfortran_sind_r10;\n+  _gfortran_sind_r16;\n+  _gfortran_cosd_r4;\n+  _gfortran_cosd_r8;\n+  _gfortran_cosd_r10;\n+  _gfortran_cosd_r16;\n+  _gfortran_tand_r4;\n+  _gfortran_tand_r8;\n+  _gfortran_tand_r10;\n+  _gfortran_tand_r16;\n } GFORTRAN_9.2;"}, {"sha": "81699069545a3b207ba3243f7ef5e0a9f87b5639", "filename": "libgfortran/intrinsics/trigd.c", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fintrinsics%2Ftrigd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fintrinsics%2Ftrigd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftrigd.c?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,205 @@\n+/* Implementation of the degree trignometric functions COSD, SIND, TAND.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Steven G. Kargl <kargl@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+#include <math.h>\n+\n+\n+/*\n+   For real x, let {x}_P or x_P be the closest representible number in the\n+   floating point representation which uses P binary bits of fractional\n+   precision (with IEEE rounding semantics).\n+\n+   Similarly, let f_P(x) be shorthand for {f(x)}_P.\n+\n+   Let ulp_P(x) be the unit of least precision for x: in other words the\n+   maximal value of |a_P - b_P| where a_P <= x <= b_P and a_P != b_P.\n+\n+   Let x  ~= y <-> | x - y | <  ulp_P(x - y).\n+\n+   Let deg(x) be the value of x radians in degrees.\n+\n+   Values for each precision P were selected as follows.\n+\n+\n+   COSD_SMALL = 2**{-N} such that for all x <= COSD_SMALL:\n+\n+     * cos(deg(x)) ~= 1, or equivalently:\n+\n+       |      1 - cos(deg(x))  | < ulp_P(1).\n+\n+   Unfortunately for SIND (and therefore TAND) a similar relation is only\n+   possible for REAL(4) and REAL(8). With REAL(10) and REAL(16), enough\n+   precision is available such that sin_P(x) != x_P for some x less than any\n+   value. (There are values where this equality holds, but the distance has\n+   inflection points.)\n+\n+   For REAL(4) and REAL(8), we can select SIND_SMALL such that:\n+\n+     * sin(deg(x)) ~= deg(x), or equivalently:\n+\n+       | deg(x) - sin(deg(x)) | < ulp_P(deg(x)).\n+\n+ */\n+\n+/* Build _gfortran_sind_r4, _gfortran_cosd_r4, and _gfortran_tand_r4  */\n+\n+#define FTYPE       GFC_REAL_4\n+#define SIND        sind_r4\n+#define COSD        cosd_r4\n+#define TAND        tand_r4\n+#define SUFFIX(x)   x ## f\n+\n+#define TINY        0x1.p-100f\t/* ~= 7.889e-31 */\n+#define COSD_SMALL  0x1.p-7f\t/*  = 7.8125e-3 */\n+#define SIND_SMALL  0x1.p-5f\t/*  = 3.125e-2 */\n+#define COSD30      8.66025388e-01f\n+\n+#define PIO180H     1.74560547e-02f\t/* high 12 bits.  */\n+#define PIO180L    -2.76216747e-06f\t/* Next 24 bits.  */\n+\n+#include \"trigd_lib.inc\"\n+\n+#undef FTYPE\n+#undef TINY\n+#undef COSD_SMALL\n+#undef SIND_SMALL\n+#undef COSD30\n+#undef PIO180H\n+#undef PIO180L\n+#undef SIND\n+#undef COSD\n+#undef TAND\n+#undef SUFFIX\n+\n+\n+/* Build _gfortran_sind_r8, _gfortran_cosd_r8, and _gfortran_tand_r8.  */\n+\n+#define FTYPE       GFC_REAL_8\n+#define SIND        sind_r8\n+#define COSD        cosd_r8\n+#define TAND        tand_r8\n+#define SUFFIX(x)   x\n+\n+#define TINY        0x1.p-1000\t/* ~= 9.33e-302 (min exp -1074) */\n+#define COSD_SMALL  0x1.p-21\t/* ~= 4.768e-7 */\n+#define SIND_SMALL  0x1.p-19\t/* ~= 9.537e-7 */\n+#define COSD30      8.6602540378443860e-01\n+\n+#define PIO180H     1.7453283071517944e-02\t/* high 21 bits.  */\n+#define PIO180L     9.4484253514332993e-09\t/* Next 53 bits.  */\n+\n+#include \"trigd_lib.inc\"\n+\n+#undef FTYPE\n+#undef TINY\n+#undef COSD_SMALL\n+#undef SIND_SMALL\n+#undef COSD30\n+#undef PIO180H\n+#undef PIO180L\n+#undef SIND\n+#undef COSD\n+#undef TAND\n+#undef SUFFIX\n+\n+\n+/* Build _gfortran_sind_r10, _gfortran_cosd_r10, and _gfortran_tand_r10.  */\n+\n+#ifdef HAVE_GFC_REAL_10\n+\n+#define FTYPE       GFC_REAL_10\n+#define SIND        sind_r10\n+#define COSD        cosd_r10\n+#define TAND        tand_r10\n+#define SUFFIX(x)   x ## l\t/* L */\n+\n+#define TINY        0x1.p-16400L\t/* ~= 1.28e-4937 (min exp -16494) */\n+#define COSD_SMALL  0x1.p-26L\t/* ~= 1.490e-8 */\n+#undef  SIND_SMALL\t\t/* not precise */\n+#define COSD30       8.66025403784438646787e-01L\n+\n+#define PIO180H     1.74532925229868851602e-02L\t/* high 32 bits */\n+#define PIO180L    -3.04358939097084072823e-12L\t/* Next 64 bits */\n+\n+#include \"trigd_lib.inc\"\n+#undef FTYPE\n+#undef TINY\n+#undef COSD_SMALL\n+#undef SIND_SMALL\n+#undef COSD30\n+#undef PIO180H\n+#undef PIO180L\n+#undef SIND\n+#undef COSD\n+#undef TAND\n+#undef SUFFIX\n+#endif /* HAVE_GFC_REAL_10 */\n+\n+\n+/* Build _gfortran_sind_r16, _gfortran_cosd_r16, and _gfortran_tand_r16.  */\n+\n+#ifdef HAVE_GFC_REAL_16\n+\n+#define FTYPE       GFC_REAL_16\n+#define SIND        sind_r16\n+#define COSD        cosd_r16\n+#define TAND        tand_r16\n+\n+#ifdef GFC_REAL_16_IS_FLOAT128\t/* libquadmath.  */\n+#define SUFFIX(x) x ## q\n+#else\n+#define SUFFIX(x) x ## l\n+#endif /* GFC_REAL_16_IS_FLOAT128  */\n+\n+#define TINY        SUFFIX(0x1.p-16400)\t/* ~= 1.28e-4937 */\n+#define COSD_SMALL  SUFFIX(0x1.p-51)\t/* ~= 4.441e-16 */\n+#undef  SIND_SMALL\t\t/* not precise */\n+#define COSD30      SUFFIX(8.66025403784438646763723170752936183e-01)\n+#define PIO180H     SUFFIX(1.74532925199433197605003442731685936e-02)\n+#define PIO180L     SUFFIX(-2.39912634365882824665106671063098954e-17)\n+\n+#include \"trigd_lib.inc\"\n+\n+#undef FTYPE\n+#undef COSD_SMALL\n+#undef SIND_SMALL\n+#undef COSD30\n+#undef PIO180H\n+#undef PIO180L\n+#undef PIO180\n+#undef D2R\n+#undef CPYSGN\n+#undef FABS\n+#undef FMOD\n+#undef SIN\n+#undef COS\n+#undef TAN\n+#undef SIND\n+#undef COSD\n+#undef TAND\n+#undef SUFFIX\n+#endif /* HAVE_GFC_REAL_16 */"}, {"sha": "98bfae7e8396731e12d5481125278bd29285be10", "filename": "libgfortran/intrinsics/trigd.inc", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fintrinsics%2Ftrigd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fintrinsics%2Ftrigd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftrigd.inc?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,464 @@\n+/* Implementation of the degree trignometric functions COSD, SIND, TAND.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Steven G. Kargl <kargl@gcc.gnu.org>\n+   and Fritz Reese <foreese@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/*\n+\n+This file is included from both the FE and the runtime library code.\n+Operations are generalized using GMP/MPFR functions. When included from\n+libgfortran, these should be overridden using macros which will use native\n+operations conforming to the same API. From the FE, the GMP/MPFR functions can\n+be used as-is.\n+\n+The following macros and GMP/FMPR functions are used and must be defined.\n+\n+\n+Types and names:\n+\n+FTYPE\n+    Type name for the real-valued parameter.\n+    Variables of this type are constructed/destroyed using mpfr_init()\n+    and mpfr_clear.\n+\n+RETTYPE\n+    Return type of the functions.\n+\n+RETURN(x)\n+    Insert code to return a value.\n+    The parameter x is the result variable, which was also the input parameter.\n+\n+ITYPE\n+    Type name for integer types.\n+\n+SIND, COSD, TRIGD\n+    Names for the degree-valued trig functions defined by this module.\n+\n+\n+Literal values:\n+\n+TINY [optional]\n+    Value subtracted from 1 to cause rase INEXACT for COSD(x)\n+    for x << 1. If not set, COSD(x) for x <= COSD_SMALL simply returns 1.\n+\n+COSD_SMALL [optional]\n+    Value such that x <= COSD_SMALL implies COSD(x) = 1 to within the\n+    precision of FTYPE. If not set, this condition is not checked.\n+\n+SIND_SMALL [optional]\n+    Value such that x <= SIND_SMALL implies SIND(x) = D2R(x) to within\n+    the precision of FTYPE. If not set, this condition is not checked.\n+\n+COSD30\n+    Value of SIND(60) and COSD(30).\n+\n+*/\n+\n+\n+/* Compute sind(x) = sin(x * pi / 180). */\n+\n+RETTYPE\n+SIND (FTYPE x)\n+{\n+  if (ISFINITE (x))\n+    {\n+      FTYPE s, one;\n+\n+      /* sin(-x) = - sin(x).  */\n+      mpfr_init (s);\n+      mpfr_init_set_ui (one, 1, GFC_RND_MODE);\n+      mpfr_copysign (s, one, x, GFC_RND_MODE);\n+      mpfr_clear (one);\n+\n+#ifdef SIND_SMALL\n+      /* sin(x) = x as x -> 0; but only for some precisions. */\n+      FTYPE ax;\n+      mpfr_init (ax);\n+      mpfr_abs (ax, x, GFC_RND_MODE);\n+      if (mpfr_cmp_ld (ax, SIND_SMALL) < 0)\n+\t{\n+\t  D2R (x);\n+\t  mpfr_clear (ax);\n+\t  return x;\n+\t}\n+\n+      mpfr_swap (x, ax);\n+      mpfr_clear (ax);\n+\n+#else\n+      mpfr_abs (x, x, GFC_RND_MODE);\n+#endif /* SIND_SMALL */\n+\n+      /* Reduce angle to x in [0,360].  */\n+      FTYPE period;\n+      mpfr_init_set_ui (period, 360, GFC_RND_MODE);\n+      mpfr_fmod (x, x, period, GFC_RND_MODE);\n+      mpfr_clear (period);\n+\n+      /* Special cases with exact results.  */\n+      ITYPE n;\n+      mpz_init (n);\n+      if (mpfr_get_z (n, x, GFC_RND_MODE) == 0 && mpz_divisible_ui_p (n, 30))\n+\t{\n+\t  /* Flip sign for odd n*pi (x is % 360 so this is only for 180).\n+\t     This respects sgn(sin(x)) = sgn(d/dx sin(x)) = sgn(cos(x)). */\n+\t  if (mpz_divisible_ui_p (n, 180))\n+\t    {\n+\t      mpfr_set_ui (x, 0, GFC_RND_MODE);\n+\t      if (mpz_cmp_ui (n, 180) == 0)\n+\t\tmpfr_neg (s, s, GFC_RND_MODE);\n+\t    }\n+\t  else if (mpz_divisible_ui_p (n, 90))\n+\t    mpfr_set_si (x, (mpz_cmp_ui (n, 90) == 0 ? 1 : -1), GFC_RND_MODE);\n+\t  else if (mpz_divisible_ui_p (n, 60))\n+\t    {\n+\t      SET_COSD30 (x);\n+\t      if (mpz_cmp_ui (n, 180) >= 0)\n+\t\tmpfr_neg (x, x, GFC_RND_MODE);\n+\t    }\n+\t  else\n+\t    mpfr_set_ld (x, (mpz_cmp_ui (n, 180) < 0 ? 0.5L : -0.5L),\n+\t\t\t GFC_RND_MODE);\n+\t}\n+\n+      /* Fold [0,360] into the range [0,45], and compute either SIN() or\n+         COS() depending on symmetry of shifting into the [0,45] range.  */\n+      else\n+\t{\n+\t  bool fold_cos = false;\n+\t  if (mpfr_cmp_ui (x, 180) <= 0)\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 90) <= 0)\n+\t\t{\n+\t\t  if (mpfr_cmp_ui (x, 45) > 0)\n+\t\t    {\n+\t\t      /* x = COS(D2R(90 - x)) */\n+\t\t      mpfr_ui_sub (x, 90, x, GFC_RND_MODE);\n+\t\t      fold_cos = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (mpfr_cmp_ui (x, 135) <= 0)\n+\t\t    {\n+\t\t      mpfr_sub_ui (x, x, 90, GFC_RND_MODE);\n+\t\t      fold_cos = true;\n+\t\t    }\n+\t\t  else\n+\t\t    mpfr_ui_sub (x, 180, x, GFC_RND_MODE);\n+\t\t}\n+\t    }\n+\n+\t  else if (mpfr_cmp_ui (x, 270) <= 0)\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 225) <= 0)\n+\t\tmpfr_sub_ui (x, x, 180, GFC_RND_MODE);\n+\t      else\n+\t\t{\n+\t\t  mpfr_ui_sub (x, 270, x, GFC_RND_MODE);\n+\t\t  fold_cos = true;\n+\t\t}\n+\t      mpfr_neg (s, s, GFC_RND_MODE);\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 315) <= 0)\n+\t\t{\n+\t\t  mpfr_sub_ui (x, x, 270, GFC_RND_MODE);\n+\t\t  fold_cos = true;\n+\t\t}\n+\t      else\n+\t\tmpfr_ui_sub (x, 360, x, GFC_RND_MODE);\n+\t      mpfr_neg (s, s, GFC_RND_MODE);\n+\t    }\n+\n+\t  D2R (x);\n+\n+\t  if (fold_cos)\n+\t    mpfr_cos (x, x, GFC_RND_MODE);\n+\t  else\n+\t    mpfr_sin (x, x, GFC_RND_MODE);\n+\t}\n+\n+      mpfr_mul (x, x, s, GFC_RND_MODE);\n+      mpz_clear (n);\n+      mpfr_clear (s);\n+    }\n+\n+  /* Return NaN for +-Inf and NaN and raise exception.  */\n+  else\n+    mpfr_sub (x, x, x, GFC_RND_MODE);\n+\n+  RETURN (x);\n+}\n+\n+\n+/* Compute cosd(x) = cos(x * pi / 180).  */\n+\n+RETTYPE\n+COSD (FTYPE x)\n+{\n+#if defined(TINY) && defined(COSD_SMALL)\n+  static const volatile FTYPE tiny = TINY;\n+#endif\n+\n+  if (ISFINITE (x))\n+    {\n+#ifdef COSD_SMALL\n+      FTYPE ax;\n+      mpfr_init (ax);\n+\n+      mpfr_abs (ax, x, GFC_RND_MODE);\n+      /* No spurious underflows!.  In radians, cos(x) = 1-x*x/2 as x -> 0.  */\n+      if (mpfr_cmp_ld (ax, COSD_SMALL) <= 0)\n+\t{\n+\t  mpfr_set_ui (x, 1, GFC_RND_MODE);\n+#ifdef TINY\n+\t  /* Cause INEXACT.  */\n+\t  if (!mpfr_zero_p (ax))\n+\t    mpfr_sub_d (x, x, tiny, GFC_RND_MODE);\n+#endif\n+\n+\t  mpfr_clear (ax);\n+\t  return x;\n+\t}\n+\n+      mpfr_swap (x, ax);\n+      mpfr_clear (ax);\n+#else\n+      mpfr_abs (x, x, GFC_RND_MODE);\n+#endif /* COSD_SMALL */\n+\n+      /* Reduce angle to ax in [0,360].  */\n+      FTYPE period;\n+      mpfr_init_set_ui (period, 360, GFC_RND_MODE);\n+      mpfr_fmod (x, x, period, GFC_RND_MODE);\n+      mpfr_clear (period);\n+\n+      /* Special cases with exact results.\n+         Return negative zero for cosd(270) for consistency with libm cos().  */\n+      ITYPE n;\n+      mpz_init (n);\n+      if (mpfr_get_z (n, x, GFC_RND_MODE) == 0 && mpz_divisible_ui_p (n, 30))\n+\t{\n+\t  if (mpz_divisible_ui_p (n, 180))\n+\t    mpfr_set_si (x, (mpz_cmp_ui (n, 180) == 0 ? -1 : 1),\n+\t\t\t GFC_RND_MODE);\n+\t  else if (mpz_divisible_ui_p (n, 90))\n+\t    mpfr_set_zero (x, 0);\n+\t  else if (mpz_divisible_ui_p (n, 60))\n+\t    {\n+\t      mpfr_set_ld (x, 0.5, GFC_RND_MODE);\n+\t      if (mpz_cmp_ui (n, 60) != 0 && mpz_cmp_ui (n, 300) != 0)\n+\t\tmpfr_neg (x, x, GFC_RND_MODE);\n+\t    }\n+\t  else\n+\t    {\n+\t      SET_COSD30 (x);\n+\t      if (mpz_cmp_ui (n, 30) != 0 && mpz_cmp_ui (n, 330) != 0)\n+\t\tmpfr_neg (x, x, GFC_RND_MODE);\n+\t    }\n+\t}\n+\n+      /* Fold [0,360] into the range [0,45], and compute either SIN() or\n+         COS() depending on symmetry of shifting into the [0,45] range.  */\n+      else\n+\t{\n+\t  bool neg = false;\n+\t  bool fold_sin = false;\n+\t  if (mpfr_cmp_ui (x, 180) <= 0)\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 90) <= 0)\n+\t\t{\n+\t\t  if (mpfr_cmp_ui (x, 45) > 0)\n+\t\t    {\n+\t\t      mpfr_ui_sub (x, 90, x, GFC_RND_MODE);\n+\t\t      fold_sin = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (mpfr_cmp_ui (x, 135) <= 0)\n+\t\t    {\n+\t\t      mpfr_sub_ui (x, x, 90, GFC_RND_MODE);\n+\t\t      fold_sin = true;\n+\t\t    }\n+\t\t  else\n+\t\t    mpfr_ui_sub (x, 180, x, GFC_RND_MODE);\n+\t\t  neg = true;\n+\t\t}\n+\t    }\n+\n+\t  else if (mpfr_cmp_ui (x, 270) <= 0)\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 225) <= 0)\n+\t\tmpfr_sub_ui (x, x, 180, GFC_RND_MODE);\n+\t      else\n+\t\t{\n+\t\t  mpfr_ui_sub (x, 270, x, GFC_RND_MODE);\n+\t\t  fold_sin = true;\n+\t\t}\n+\t      neg = true;\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 315) <= 0)\n+\t\t{\n+\t\t  mpfr_sub_ui (x, x, 270, GFC_RND_MODE);\n+\t\t  fold_sin = true;\n+\t\t}\n+\t      else\n+\t\tmpfr_ui_sub (x, 360, x, GFC_RND_MODE);\n+\t    }\n+\n+\t  D2R (x);\n+\n+\t  if (fold_sin)\n+\t    mpfr_sin (x, x, GFC_RND_MODE);\n+\t  else\n+\t    mpfr_cos (x, x, GFC_RND_MODE);\n+\n+\t  if (neg)\n+\t    mpfr_neg (x, x, GFC_RND_MODE);\n+\t}\n+\n+      mpz_clear (n);\n+    }\n+\n+  /* Return NaN for +-Inf and NaN and raise exception.  */\n+  else\n+    mpfr_sub (x, x, x, GFC_RND_MODE);\n+\n+  RETURN (x);\n+}\n+\n+\n+/* Compute tand(x) = tan(x * pi / 180).  */\n+\n+RETTYPE\n+TAND (FTYPE x)\n+{\n+  if (ISFINITE (x))\n+    {\n+      FTYPE s, one;\n+\n+      /* tan(-x) = - tan(x).  */\n+      mpfr_init (s);\n+      mpfr_init_set_ui (one, 1, GFC_RND_MODE);\n+      mpfr_copysign (s, one, x, GFC_RND_MODE);\n+      mpfr_clear (one);\n+\n+#ifdef SIND_SMALL\n+      /* tan(x) = x as x -> 0; but only for some precisions. */\n+      FTYPE ax;\n+      mpfr_init (ax);\n+      mpfr_abs (ax, x, GFC_RND_MODE);\n+      if (mpfr_cmp_ld (ax, SIND_SMALL) < 0)\n+\t{\n+\t  D2R (x);\n+\t  mpfr_clear (ax);\n+\t  return x;\n+\t}\n+\n+      mpfr_swap (x, ax);\n+      mpfr_clear (ax);\n+\n+#else\n+      mpfr_abs (x, x, GFC_RND_MODE);\n+#endif /* SIND_SMALL */\n+\n+      /* Reduce angle to x in [0,360].  */\n+      FTYPE period;\n+      mpfr_init_set_ui (period, 360, GFC_RND_MODE);\n+      mpfr_fmod (x, x, period, GFC_RND_MODE);\n+      mpfr_clear (period);\n+\n+      /* Special cases with exact results. */\n+      ITYPE n;\n+      mpz_init (n);\n+      if (mpfr_get_z (n, x, GFC_RND_MODE) == 0 && mpz_divisible_ui_p (n, 45))\n+\t{\n+\t  if (mpz_divisible_ui_p (n, 180))\n+\t    mpfr_set_zero (x, 0);\n+\n+\t  /* Though mathematically NaN is more appropriate for tan(n*90),\n+\t     returning +/-Inf offers the advantage that 1/tan(n*90) returns 0,\n+\t     which is mathematically sound. In fact we rely on this behavior\n+\t     to implement COTAND(x) = 1 / TAND(x).\n+\t   */\n+\t  else if (mpz_divisible_ui_p (n, 90))\n+\t    mpfr_set_inf (x, mpz_cmp_ui (n, 90) == 0 ? 0 : 1);\n+\n+\t  else\n+\t    {\n+\t      mpfr_set_ui (x, 1, GFC_RND_MODE);\n+\t      if (mpz_cmp_ui (n, 45) != 0 && mpz_cmp_ui (n, 225) != 0)\n+\t\tmpfr_neg (x, x, GFC_RND_MODE);\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  /* Fold [0,360] into the range [0,90], and compute TAN().  */\n+\t  if (mpfr_cmp_ui (x, 180) <= 0)\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 90) > 0)\n+\t\t{\n+\t\t  mpfr_ui_sub (x, 180, x, GFC_RND_MODE);\n+\t\t  mpfr_neg (s, s, GFC_RND_MODE);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (mpfr_cmp_ui (x, 270) <= 0)\n+\t\t{\n+\t\t  mpfr_sub_ui (x, x, 180, GFC_RND_MODE);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  mpfr_ui_sub (x, 360, x, GFC_RND_MODE);\n+\t\t  mpfr_neg (s, s, GFC_RND_MODE);\n+\t\t}\n+\t    }\n+\n+\t  D2R (x);\n+\t  mpfr_tan (x, x, GFC_RND_MODE);\n+\t}\n+\n+      mpfr_mul (x, x, s, GFC_RND_MODE);\n+      mpz_clear (n);\n+      mpfr_clear (s);\n+    }\n+\n+  /* Return NaN for +-Inf and NaN and raise exception.  */\n+  else\n+    mpfr_sub (x, x, x, GFC_RND_MODE);\n+\n+  RETURN (x);\n+}\n+\n+/* vim: set ft=c: */"}, {"sha": "b6d4145b99527fbb422ae0e5f48c37368ef61fb2", "filename": "libgfortran/intrinsics/trigd_lib.inc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fintrinsics%2Ftrigd_lib.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57391ddaf39f7cb85825c32e83feb1435889da51/libgfortran%2Fintrinsics%2Ftrigd_lib.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftrigd_lib.inc?ref=57391ddaf39f7cb85825c32e83feb1435889da51", "patch": "@@ -0,0 +1,147 @@\n+/* Stub for defining degree-valued trigonometric functions in libgfortran.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Steven G. Kargl <kargl@gcc.gnu.org>\n+   and Fritz Reese <foreese@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/*\n+This replaces all GMP/MPFR functions used by trigd.inc with native versions.\n+The precision is defined by FTYPE defined before including this file.\n+The module which includes this file must define the following:\n+\n+FTYPE             -- floating point type\n+SIND, COSD, TAND  -- names of the functions to define\n+SUFFIX(x)         -- add a literal suffix for floating point constants (f, ...)\n+\n+COSD_SMALL [optional] -- for x <= COSD_SMALL, COSD(x) = 1 if set\n+TINY       [optional] -- subtract from 1 under the above condition if set\n+SIND_SMALL [optional] -- for x <= SIND_SMALL, SIND(x) = D2R(x) if set\n+COSD30                -- literal value of COSD(30) to the precision of FTYPE\n+PIO180H               -- upper bits of pi/180 for FMA\n+PIO180L               -- lower bits of pi/180 for FMA\n+\n+ */\n+\n+#define ITYPE int\n+#define GFC_RND_MODE 0\n+#define RETTYPE FTYPE\n+#define RETURN(x) return (x)\n+\n+#define ISFINITE(x) isfinite(x)\n+#define mpfr_init(x) do { } while (0)\n+#define mpfr_init_set_ui(x, v, rnd) (x = (v))\n+#define mpfr_clear(x) do { } while (0)\n+#define mpfr_swap(x, y) do { FTYPE z = y; y = x; x = z; } while (0)\n+#define mpfr_copysign(rop, op1, op2, rnd) rop = SUFFIX(copysign)((op1), (op2))\n+#define mpfr_fmod(rop, x, d, rnd) (rop = SUFFIX(fmod)((x), (d)))\n+#define mpfr_abs(rop, op, rnd) (rop = SUFFIX(fabs)(op))\n+#define mpfr_cmp_ld(x, y) ((x) - (y))\n+#define mpfr_cmp_ui(x, n) ((x) - (n))\n+#define mpfr_zero_p(x) ((x) == 0)\n+#define mpfr_set(rop, x, rnd) (rop = (x))\n+#define mpfr_set_zero(rop, s) (rop = SUFFIX(copysign)(0, (s)))\n+#define mpfr_set_inf(rop, s) (rop = ((s)*-2 + 1) * INFINITY)\n+#define mpfr_set_ui(rop, n, rnd) (rop = (n))\n+#define mpfr_set_si(rop, n, rnd) (rop = (n))\n+#define mpfr_set_ld(rop, x, rnd) (rop = (x))\n+#define mpfr_set_si_2exp(rop, op, exp, rnd) (rop = (0x1.p##exp))\n+#define mpfr_get_z(rop, x, rnd) ((rop = (int)(x)), (rop - (x)))\n+#define mpfr_mul(rop, op1, op2, rnd)    (rop = ((op1) * (op2)))\n+#define mpfr_sub_d(rop, op1, op2, rnd)  (rop = ((op1) - (op2)))\n+#define mpfr_sub_ui(rop, op1, op2, rnd) (rop = ((op1) - (op2)))\n+#define mpfr_sub(rop, op1, op2, rnd)    (rop = ((op1) - (op2)))\n+#define mpfr_ui_sub(rop, op1, op2, rnd) (rop = ((op1) - (op2)))\n+#define mpfr_neg(rop, op, rnd) (rop = -(op))\n+#define mpfr_sin(rop, x, rnd) (rop = SUFFIX(sin)(x))\n+#define mpfr_cos(rop, x, rnd) (rop = SUFFIX(cos)(x))\n+#define mpfr_tan(rop, x, rnd) (rop = SUFFIX(tan)(x))\n+\n+#define mpz_init(n) do { } while (0)\n+#define mpz_clear(x) do { } while (0)\n+#define mpz_cmp_ui(x, y) ((x) - (y))\n+#define mpz_divisible_ui_p(n, d) ((n) % (d) == 0)\n+\n+#define FMA(x,y,z)  SUFFIX(fma)((x), (y), (z))\n+#define D2R(x) (x = FMA((x), PIO180H, (x) * PIO180L))\n+\n+#define SET_COSD30(x) (x = COSD30)\n+\n+\n+extern FTYPE SIND (FTYPE);\n+export_proto (SIND);\n+\n+extern FTYPE COSD (FTYPE);\n+export_proto (COSD);\n+\n+extern FTYPE TAND (FTYPE);\n+export_proto (TAND);\n+\n+#include \"trigd.inc\"\n+\n+#undef ITYPE\n+#undef GFC_RND_MODE\n+#undef RETTYPE\n+#undef RETURN\n+\n+#undef ISFINITE\n+#undef mpfr_signbit\n+\n+#undef mpfr_init\n+#undef mpfr_init_set_ui\n+#undef mpfr_clear\n+#undef mpfr_swap\n+#undef mpfr_fmod\n+#undef mpfr_abs\n+#undef mpfr_cmp_ld\n+#undef mpfr_cmp_ui\n+#undef mpfr_zero_p\n+#undef mpfr_set\n+#undef mpfr_set_zero\n+#undef mpfr_set_inf\n+#undef mpfr_set_ui\n+#undef mpfr_set_si\n+#undef mpfr_set_ld\n+#undef mpfr_set_si_2exp\n+#undef mpfr_get_z\n+#undef mpfr_mul_si\n+#undef mpfr_sub_d\n+#undef mpfr_sub_ui\n+#undef mpfr_sub\n+#undef mpfr_ui_sub\n+#undef mpfr_neg\n+#undef mpfr_sin\n+#undef mpfr_cos\n+#undef mpfr_tan\n+\n+#undef mpz_init\n+#undef mpz_clear\n+#undef mpz_cmp_ui\n+#undef mpz_divisible_ui_p\n+\n+#undef FMA\n+#undef D2R\n+\n+#undef SET_COSD30\n+\n+\n+/* vim: set ft=c: */"}]}