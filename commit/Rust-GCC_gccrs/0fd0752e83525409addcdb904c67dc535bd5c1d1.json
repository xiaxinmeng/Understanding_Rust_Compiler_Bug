{"sha": "0fd0752e83525409addcdb904c67dc535bd5c1d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZkMDc1MmU4MzUyNTQwOWFkZGNkYjkwNGM2N2RjNTM1YmQ1YzFkMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-05-03T16:19:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-05-03T16:19:02Z"}, "message": "dwarf2out.c (modified_type_die): Use scope_die_for.\n\n\t* dwarf2out.c (modified_type_die): Use scope_die_for.\n\t(gen_type_die_with_usage, dwarf2out_finish): Likewise.\n\t(uses_local_type_r, uses_local_type): New.\n\t(scope_die_for): Keep a type that uses a local type in local scope.\n\tUse get_context_die for namespace and type scope.\n\nFrom-SVN: r187106", "tree": {"sha": "202354d91f7ecdca36fe2d675450e45fdce487aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/202354d91f7ecdca36fe2d675450e45fdce487aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fd0752e83525409addcdb904c67dc535bd5c1d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd0752e83525409addcdb904c67dc535bd5c1d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fd0752e83525409addcdb904c67dc535bd5c1d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd0752e83525409addcdb904c67dc535bd5c1d1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63aaf27c3bf9ac859f5db5ae9774e2751695a2f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63aaf27c3bf9ac859f5db5ae9774e2751695a2f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63aaf27c3bf9ac859f5db5ae9774e2751695a2f9"}], "stats": {"total": 139, "additions": 99, "deletions": 40}, "files": [{"sha": "aad998f6910b7dee0c09e5d362f947124b4d14aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fd0752e83525409addcdb904c67dc535bd5c1d1", "patch": "@@ -1,3 +1,11 @@\n+2012-05-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* dwarf2out.c (modified_type_die): Use scope_die_for.\n+\t(gen_type_die_with_usage, dwarf2out_finish): Likewise.\n+\t(uses_local_type_r, uses_local_type): New.\n+\t(scope_die_for): Keep a type that uses a local type in local scope.\n+\tUse get_context_die for namespace and type scope.\n+\n 2012-05-03  Jason Merrill  <jason@redhat.com>\n \n \t* config/i386/i386.c (ix86_code_end): Set DECL_IGNORED_P on the"}, {"sha": "34cb81da429253c773b35647da85d176527ac28d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0fd0752e83525409addcdb904c67dc535bd5c1d1", "patch": "@@ -9021,6 +9021,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   tree item_type = NULL;\n   tree qualified_type;\n   tree name, low, high;\n+  dw_die_ref mod_scope;\n \n   if (code == ERROR_MARK)\n     return NULL;\n@@ -9081,24 +9082,26 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n       /* Else cv-qualified version of named type; fall through.  */\n     }\n \n+  mod_scope = scope_die_for (type, context_die);\n+\n   if (is_const_type\n       /* If both is_const_type and is_volatile_type, prefer the path\n \t which leads to a qualified type.  */\n       && (!is_volatile_type\n \t  || get_qualified_type (type, TYPE_QUAL_CONST) == NULL_TREE\n \t  || get_qualified_type (type, TYPE_QUAL_VOLATILE) != NULL_TREE))\n     {\n-      mod_type_die = new_die (DW_TAG_const_type, comp_unit_die (), type);\n+      mod_type_die = new_die (DW_TAG_const_type, mod_scope, type);\n       sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n     }\n   else if (is_volatile_type)\n     {\n-      mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die (), type);\n+      mod_type_die = new_die (DW_TAG_volatile_type, mod_scope, type);\n       sub_die = modified_type_die (type, is_const_type, 0, context_die);\n     }\n   else if (code == POINTER_TYPE)\n     {\n-      mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die (), type);\n+      mod_type_die = new_die (DW_TAG_pointer_type, mod_scope, type);\n       add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n@@ -9109,10 +9112,10 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   else if (code == REFERENCE_TYPE)\n     {\n       if (TYPE_REF_IS_RVALUE (type) && dwarf_version >= 4)\n-\tmod_type_die = new_die (DW_TAG_rvalue_reference_type, comp_unit_die (),\n+\tmod_type_die = new_die (DW_TAG_rvalue_reference_type, mod_scope,\n \t\t\t\ttype);\n       else\n-\tmod_type_die = new_die (DW_TAG_reference_type, comp_unit_die (), type);\n+\tmod_type_die = new_die (DW_TAG_reference_type, mod_scope, type);\n       add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n@@ -15301,29 +15304,61 @@ pop_decl_scope (void)\n   VEC_pop (tree, decl_scope_table);\n }\n \n+/* walk_tree helper function for uses_local_type, below.  */\n+\n+static tree\n+uses_local_type_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (!TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  else\n+    {\n+      tree name = TYPE_NAME (*tp);\n+      if (name && DECL_P (name) && decl_function_context (name))\n+\treturn *tp;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* If TYPE involves a function-local type (including a local typedef to a\n+   non-local type), returns that type; otherwise returns NULL_TREE.  */\n+\n+static tree\n+uses_local_type (tree type)\n+{\n+  tree used = walk_tree_without_duplicates (&type, uses_local_type_r, NULL);\n+  return used;\n+}\n+\n /* Return the DIE for the scope that immediately contains this type.\n-   Non-named types get global scope.  Named types nested in other\n-   types get their containing scope if it's open, or global scope\n-   otherwise.  All other types (i.e. function-local named types) get\n+   Non-named types that do not involve a function-local type get global\n+   scope.  Named types nested in namespaces or other types get their\n+   containing scope.  All other types (i.e. function-local named types) get\n    the current active scope.  */\n \n static dw_die_ref\n scope_die_for (tree t, dw_die_ref context_die)\n {\n   dw_die_ref scope_die = NULL;\n   tree containing_scope;\n-  int i;\n \n   /* Non-types always go in the current scope.  */\n   gcc_assert (TYPE_P (t));\n \n-  containing_scope = TYPE_CONTEXT (t);\n+  /* Use the scope of the typedef, rather than the scope of the type\n+     it refers to.  */\n+  if (TYPE_NAME (t) && DECL_P (TYPE_NAME (t)))\n+    containing_scope = DECL_CONTEXT (TYPE_NAME (t));\n+  else\n+    containing_scope = TYPE_CONTEXT (t);\n \n-  /* Use the containing namespace if it was passed in (for a declaration).  */\n+  /* Use the containing namespace if there is one.  */\n   if (containing_scope && TREE_CODE (containing_scope) == NAMESPACE_DECL)\n     {\n       if (context_die == lookup_decl_die (containing_scope))\n \t/* OK */;\n+      else if (debug_info_level > DINFO_LEVEL_TERSE)\n+\tcontext_die = get_context_die (containing_scope);\n       else\n \tcontaining_scope = NULL_TREE;\n     }\n@@ -15335,30 +15370,25 @@ scope_die_for (tree t, dw_die_ref context_die)\n     containing_scope = NULL_TREE;\n \n   if (SCOPE_FILE_SCOPE_P (containing_scope))\n-    scope_die = comp_unit_die ();\n+    {\n+      /* If T uses a local type keep it local as well, to avoid references\n+\t to function-local DIEs from outside the function.  */\n+      if (current_function_decl && uses_local_type (t))\n+\tscope_die = context_die;\n+      else\n+\tscope_die = comp_unit_die ();\n+    }\n   else if (TYPE_P (containing_scope))\n     {\n-      /* For types, we can just look up the appropriate DIE.  But\n-\t first we check to see if we're in the middle of emitting it\n-\t so we know where the new DIE should go.  */\n-      for (i = VEC_length (tree, decl_scope_table) - 1; i >= 0; --i)\n-\tif (VEC_index (tree, decl_scope_table, i) == containing_scope)\n-\t  break;\n-\n-      if (i < 0)\n+      /* For types, we can just look up the appropriate DIE.  */\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\tscope_die = get_context_die (containing_scope);\n+      else\n \t{\n-\t  gcc_assert (debug_info_level <= DINFO_LEVEL_TERSE\n-\t\t      || TREE_ASM_WRITTEN (containing_scope));\n-\t  /*We are not in the middle of emitting the type\n-\t    CONTAINING_SCOPE. Let's see if it's emitted already.  */\n-\t  scope_die = lookup_type_die (containing_scope);\n-\n-\t  /* If none of the current dies are suitable, we get file scope.  */\n+\t  scope_die = lookup_type_die_strip_naming_typedef (containing_scope);\n \t  if (scope_die == NULL)\n \t    scope_die = comp_unit_die ();\n \t}\n-      else\n-\tscope_die = lookup_type_die_strip_naming_typedef (containing_scope);\n     }\n   else\n     scope_die = context_die;\n@@ -18154,12 +18184,8 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       /* Prevent broken recursion; we can't hand off to the same type.  */\n       gcc_assert (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) != type);\n \n-      /* Use the DIE of the containing namespace as the parent DIE of\n-         the type description DIE we want to generate.  */\n-      if (DECL_FILE_SCOPE_P (TYPE_NAME (type))\n-\t  || (DECL_CONTEXT (TYPE_NAME (type))\n-\t      && TREE_CODE (DECL_CONTEXT (TYPE_NAME (type))) == NAMESPACE_DECL))\n-\tcontext_die = get_context_die (DECL_CONTEXT (TYPE_NAME (type)));\n+      /* Give typedefs the right scope.  */\n+      context_die = scope_die_for (type, context_die);\n \n       TREE_ASM_WRITTEN (type) = 1;\n \n@@ -21782,16 +21808,15 @@ dwarf2out_finish (const char *filename)\n \t\t inlined and optimized out.  In that case we are lost and\n \t\t assign the empty child.  This should not be big issue as\n \t\t the function is likely unreachable too.  */\n-\t      tree context = NULL_TREE;\n-\n \t      gcc_assert (node->created_for);\n \n \t      if (DECL_P (node->created_for))\n-\t\tcontext = DECL_CONTEXT (node->created_for);\n+\t\torigin = get_context_die (DECL_CONTEXT (node->created_for));\n \t      else if (TYPE_P (node->created_for))\n-\t\tcontext = TYPE_CONTEXT (node->created_for);\n+\t\torigin = scope_die_for (node->created_for, comp_unit_die ());\n+\t      else\n+\t\torigin = comp_unit_die ();\n \n-\t      origin = get_context_die (context);\n \t      add_child_die (origin, die);\n \t    }\n \t}"}, {"sha": "a0ae5744437ab39b2a9ddc1c79bb19f0595db018", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fd0752e83525409addcdb904c67dc535bd5c1d1", "patch": "@@ -1,3 +1,8 @@\n+2012-05-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/debug/dwarf2/namespace-2.C: New.\n+\t* g++.dg/debug/dwarf2/localclass3.C: New.\n+\n 2012-05-03  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/debug/dwarf2/thunk1.C: New."}, {"sha": "be28a19716872c20535f5a82b296d6af5a0edd14", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/localclass3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Flocalclass3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Flocalclass3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Flocalclass3.C?ref=0fd0752e83525409addcdb904c67dc535bd5c1d1", "patch": "@@ -0,0 +1,11 @@\n+// Test that the A* pointer_type is also within the debug info for f.\n+// Currently GCC emits it immediately before A, which is simple to test for.\n+// { dg-options \"-g -dA\" }\n+\n+void f()\n+{\n+  struct A { int i; } *ap;\n+  ap->i = 42;\n+}\n+\n+// { dg-final { scan-assembler \"DW_TAG_pointer_type.\\[^)\\]*. DW_TAG_structure_type\" } }"}, {"sha": "0289e9022d3efed197ede079f0339ec175c4227e", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/namespace-2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fnamespace-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd0752e83525409addcdb904c67dc535bd5c1d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fnamespace-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fnamespace-2.C?ref=0fd0752e83525409addcdb904c67dc535bd5c1d1", "patch": "@@ -0,0 +1,10 @@\n+// Test that we define A inside the namespace rather than declaring it\n+// there and then defining it at CU scope.\n+// { dg-options \"-g -dA\" }\n+// { dg-final { scan-assembler-not \"DW_AT_declaration\" } }\n+\n+namespace N {\n+  struct A;\n+}\n+\n+struct N::A { } a;"}]}