{"sha": "ede31f6ffe73357705e95016046e77c7e3d6ad13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRlMzFmNmZmZTczMzU3NzA1ZTk1MDE2MDQ2ZTc3YzdlM2Q2YWQxMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-01T19:46:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-01T19:46:09Z"}, "message": "tree-ssa-alias.c (nonoverlapping_component_refs_since_match_p): Rename to ...\n\n\n\t* tree-ssa-alias.c (nonoverlapping_component_refs_since_match_p):\n\tRename to ...\n\t(nonoverlapping_refs_since_match_p): ... this; handle also\n\tARRAY_REFs.\n\t(alias_stats): Update stats.\n\t(dump_alias_stats): Likewise.\n\t(cheap_array_ref_low_bound): New function.\n\t(aliasing_matching_component_refs_p): Add partial_overlap\n\targument;\n\tpass it to nonoverlapping_refs_since_match_p.\n\t(aliasing_component_refs_walk): Update call of\n\taliasing_matching_component_refs_p\n\t(nonoverlapping_array_refs_p): New function.\n\t(decl_refs_may_alias_p, indirect_ref_may_alias_decl_p,\n\tindirect_refs_may_alias_p): Update calls of\n\tnonoverlapping_refs_since_match_p.\n\n\t* gcc.dg/tree-ssa/alias-access-path-10.c: New testcase.\n\t* gcc.dg/tree-ssa/alias-access-path-11.c: New testcase.\n\nFrom-SVN: r276427", "tree": {"sha": "5735f5fe70e3ea24643d4bd94f63f78376be0482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5735f5fe70e3ea24643d4bd94f63f78376be0482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ede31f6ffe73357705e95016046e77c7e3d6ad13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede31f6ffe73357705e95016046e77c7e3d6ad13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede31f6ffe73357705e95016046e77c7e3d6ad13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede31f6ffe73357705e95016046e77c7e3d6ad13/comments", "author": null, "committer": null, "parents": [{"sha": "11f2ce1f49f480c7ef0951bdee5c35bd7449f2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f2ce1f49f480c7ef0951bdee5c35bd7449f2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f2ce1f49f480c7ef0951bdee5c35bd7449f2bd"}], "stats": {"total": 342, "additions": 279, "deletions": 63}, "files": [{"sha": "b7feecc35318dffd4f9965696ca35e0fb51a2966", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ede31f6ffe73357705e95016046e77c7e3d6ad13", "patch": "@@ -1,3 +1,22 @@\n+2019-10-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (nonoverlapping_component_refs_since_match_p):\n+\tRename to ...\n+\t(nonoverlapping_refs_since_match_p): ... this; handle also\n+\tARRAY_REFs.\n+\t(alias_stats): Update stats.\n+\t(dump_alias_stats): Likewise.\n+\t(cheap_array_ref_low_bound): New function.\n+\t(aliasing_matching_component_refs_p): Add partial_overlap\n+\targument;\n+\tpass it to nonoverlapping_refs_since_match_p.\n+\t(aliasing_component_refs_walk): Update call of\n+\taliasing_matching_component_refs_p\n+\t(nonoverlapping_array_refs_p): New function.\n+\t(decl_refs_may_alias_p, indirect_ref_may_alias_decl_p,\n+\tindirect_refs_may_alias_p): Update calls of\n+\tnonoverlapping_refs_since_match_p.\n+\n 2019-10-01  Maya Rashish  <coypu@sdf.org>\n \n \tPR target/85401"}, {"sha": "f7256b59d158c7865978a191d9db315ab20ef12e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ede31f6ffe73357705e95016046e77c7e3d6ad13", "patch": "@@ -1,3 +1,8 @@\n+2019-10-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-10.c: New testcase.\n+\t* gcc.dg/tree-ssa/alias-access-path-11.c: New testcase.\n+\n 2019-10-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/lto/odr-6_0.C: New testcase."}, {"sha": "c42a6ce8f40af48e0267b67dadb83868027a34d0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-10.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-10.c?ref=ede31f6ffe73357705e95016046e77c7e3d6ad13", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+\n+struct a {int array[3];} a[10];\n+int\n+test(int i,int j)\n+{\n+  a[i].array[1]=123;\n+  a[j].array[2]=2;\n+  return a[i].array[1];\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"fre1\"} } */"}, {"sha": "1f8371431eae8a1f24fd70f5f8c839cd231e9e4d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-11.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-11.c?ref=ede31f6ffe73357705e95016046e77c7e3d6ad13", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-strict-aliasing -fdump-tree-fre3\" } */\n+typedef int outerarray[10][10][10];\n+typedef int innerarray[10][10];\n+outerarray *barptr;\n+\n+int\n+test(int i,int j)\n+{\n+  innerarray *innerptr = (innerarray *)barptr;\n+  (*barptr)[i][2][j]=10;;\n+  (*innerptr)[3][j]=11;\n+  return (*barptr)[i][2][j];\n+}\n+/* { dg-final { scan-tree-dump-times \"return 10\" 1 \"fre3\"} } */"}, {"sha": "d6c443848ab7a99c09626ff1fe59d4a84c994842", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 228, "deletions": 63, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede31f6ffe73357705e95016046e77c7e3d6ad13/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ede31f6ffe73357705e95016046e77c7e3d6ad13", "patch": "@@ -87,7 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n    this file.  Low-level disambiguators dealing with points-to\n    information are in tree-ssa-structalias.c.  */\n \n-static int nonoverlapping_component_refs_since_match_p (tree, tree, tree, tree);\n+static int nonoverlapping_refs_since_match_p (tree, tree, tree, tree, bool);\n static bool nonoverlapping_component_refs_p (const_tree, const_tree);\n \n /* Query statistics for the different low-level disambiguators.\n@@ -104,9 +104,9 @@ static struct {\n   unsigned HOST_WIDE_INT aliasing_component_refs_p_no_alias;\n   unsigned HOST_WIDE_INT nonoverlapping_component_refs_p_may_alias;\n   unsigned HOST_WIDE_INT nonoverlapping_component_refs_p_no_alias;\n-  unsigned HOST_WIDE_INT nonoverlapping_component_refs_since_match_p_may_alias;\n-  unsigned HOST_WIDE_INT nonoverlapping_component_refs_since_match_p_must_overlap;\n-  unsigned HOST_WIDE_INT nonoverlapping_component_refs_since_match_p_no_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_may_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_must_overlap;\n+  unsigned HOST_WIDE_INT nonoverlapping_refs_since_match_p_no_alias;\n } alias_stats;\n \n void\n@@ -137,15 +137,15 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.nonoverlapping_component_refs_p_no_alias,\n \t   alias_stats.nonoverlapping_component_refs_p_no_alias\n \t   + alias_stats.nonoverlapping_component_refs_p_may_alias);\n-  fprintf (s, \"  nonoverlapping_component_refs_since_match_p: \"\n+  fprintf (s, \"  nonoverlapping_refs_since_match_p: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" must overlaps, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n-\t   alias_stats.nonoverlapping_component_refs_since_match_p_no_alias,\n-\t   alias_stats.nonoverlapping_component_refs_since_match_p_must_overlap,\n-\t   alias_stats.nonoverlapping_component_refs_since_match_p_no_alias\n-\t   + alias_stats.nonoverlapping_component_refs_since_match_p_may_alias\n-\t   + alias_stats.nonoverlapping_component_refs_since_match_p_must_overlap);\n+\t   alias_stats.nonoverlapping_refs_since_match_p_no_alias,\n+\t   alias_stats.nonoverlapping_refs_since_match_p_must_overlap,\n+\t   alias_stats.nonoverlapping_refs_since_match_p_no_alias\n+\t   + alias_stats.nonoverlapping_refs_since_match_p_may_alias\n+\t   + alias_stats.nonoverlapping_refs_since_match_p_must_overlap);\n   fprintf (s, \"  aliasing_component_refs_p: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n@@ -856,7 +856,8 @@ type_has_components_p (tree type)\n \n /* MATCH1 and MATCH2 which are part of access path of REF1 and REF2\n    respectively are either pointing to same address or are completely\n-   disjoint.\n+   disjoint. If PARITAL_OVERLAP is true, assume that outermost arrays may\n+   just partly overlap.\n \n    Try to disambiguate using the access path starting from the match\n    and return false if there is no conflict.\n@@ -867,24 +868,27 @@ static bool\n aliasing_matching_component_refs_p (tree match1, tree ref1,\n \t\t\t\t    poly_int64 offset1, poly_int64 max_size1,\n \t\t\t\t    tree match2, tree ref2,\n-\t\t\t\t    poly_int64 offset2, poly_int64 max_size2)\n+\t\t\t\t    poly_int64 offset2, poly_int64 max_size2,\n+\t\t\t\t    bool partial_overlap)\n {\n   poly_int64 offadj, sztmp, msztmp;\n   bool reverse;\n \n-\n-  get_ref_base_and_extent (match2, &offadj, &sztmp, &msztmp, &reverse);\n-  offset2 -= offadj;\n-  get_ref_base_and_extent (match1, &offadj, &sztmp, &msztmp, &reverse);\n-  offset1 -= offadj;\n-  if (!ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+  if (!partial_overlap)\n     {\n-      ++alias_stats.aliasing_component_refs_p_no_alias;\n-      return false;\n+      get_ref_base_and_extent (match2, &offadj, &sztmp, &msztmp, &reverse);\n+      offset2 -= offadj;\n+      get_ref_base_and_extent (match1, &offadj, &sztmp, &msztmp, &reverse);\n+      offset1 -= offadj;\n+      if (!ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+\t{\n+\t  ++alias_stats.aliasing_component_refs_p_no_alias;\n+\t  return false;\n+\t}\n     }\n \n-  int cmp = nonoverlapping_component_refs_since_match_p (match1, ref1,\n-\t\t\t\t\t\t\t match2, ref2);\n+  int cmp = nonoverlapping_refs_since_match_p (match1, ref1, match2, ref2,\n+\t\t\t\t\t       partial_overlap);\n   if (cmp == 1\n       || (cmp == -1 && nonoverlapping_component_refs_p (ref1, ref2)))\n     {\n@@ -964,6 +968,8 @@ aliasing_component_refs_walk (tree ref1, tree type1, tree base1,\n     }\n   if (same_p == 1)\n     {\n+      bool partial_overlap = false;\n+\n       /* We assume that arrays can overlap by multiple of their elements\n \t size as tested in gcc.dg/torture/alias-2.c.\n \t This partial overlap happen only when both arrays are bases of\n@@ -973,15 +979,18 @@ aliasing_component_refs_walk (tree ref1, tree type1, tree base1,\n \t  && (!TYPE_SIZE (TREE_TYPE (base1))\n \t      || TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) != INTEGER_CST\n \t      || ref == base2))\n-\t/* Setting maybe_match to true triggers\n-\t   nonoverlapping_component_refs_p test later that still may do\n-\t   useful disambiguation.  */\n-\t*maybe_match = true;\n-      else\n-\treturn aliasing_matching_component_refs_p (base1, ref1,\n-\t\t\t\t\t\t   offset1, max_size1,\n-\t\t\t\t\t\t   ref, ref2,\n-\t\t\t\t\t\t   offset2, max_size2);\n+\t{\n+\t  /* Setting maybe_match to true triggers\n+\t     nonoverlapping_component_refs_p test later that still may do\n+\t     useful disambiguation.  */\n+\t  *maybe_match = true;\n+\t  partial_overlap = true;\n+\t}\n+      return aliasing_matching_component_refs_p (base1, ref1,\n+\t\t\t\t\t\t offset1, max_size1,\n+\t\t\t\t\t\t ref, ref2,\n+\t\t\t\t\t\t offset2, max_size2,\n+\t\t\t\t\t\t partial_overlap);\n     }\n   return -1;\n }\n@@ -1225,10 +1234,98 @@ nonoverlapping_component_refs_p_1 (const_tree field1, const_tree field2)\n   return -1;\n }\n \n+/* Return low bound of array. Do not produce new trees\n+   and thus do not care about particular type of integer constant\n+   and placeholder exprs.  */\n+\n+static tree\n+cheap_array_ref_low_bound (tree ref)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+\n+  /* Avoid expensive array_ref_low_bound.\n+     low bound is either stored in operand2, or it is TYPE_MIN_VALUE of domain\n+     type or it is zero.  */\n+  if (TREE_OPERAND (ref, 2))\n+    return TREE_OPERAND (ref, 2);\n+  else if (domain_type && TYPE_MIN_VALUE (domain_type))\n+    return TYPE_MIN_VALUE (domain_type);\n+  else\n+    return integer_zero_node;\n+}\n+\n+/* REF1 and REF2 are ARRAY_REFs with either same base address or which are\n+   completely disjoint.\n+\n+   Return 1 if the refs are non-overlapping.\n+   Return 0 if they are possibly overlapping but if so the overlap again\n+   starts on the same address.\n+   Return -1 otherwise.  */\n+\n+int\n+nonoverlapping_array_refs_p (tree ref1, tree ref2)\n+{\n+  tree index1 = TREE_OPERAND (ref1, 1);\n+  tree index2 = TREE_OPERAND (ref2, 1);\n+  tree low_bound1 = cheap_array_ref_low_bound(ref1);\n+  tree low_bound2 = cheap_array_ref_low_bound(ref2);\n+\n+  /* Handle zero offsets first: we do not need to match type size in this\n+     case.  */\n+  if (operand_equal_p (index1, low_bound1, 0)\n+      && operand_equal_p (index2, low_bound2, 0))\n+    return 0;\n+\n+  /* If type sizes are different, give up.\n+\n+     Avoid expensive array_ref_element_size.\n+     If operand 3 is present it denotes size in the alignmnet units.\n+     Otherwise size is TYPE_SIZE of the element type.\n+     Handle only common cases where types are of the same \"kind\".  */\n+  if ((TREE_OPERAND (ref1, 3) == NULL) != (TREE_OPERAND (ref2, 3) == NULL))\n+    return -1;\n+\n+  tree elmt_type1 = TREE_TYPE (TREE_TYPE (TREE_OPERAND (ref1, 0)));\n+  tree elmt_type2 = TREE_TYPE (TREE_TYPE (TREE_OPERAND (ref2, 0)));\n+\n+  if (TREE_OPERAND (ref1, 3))\n+    {\n+      if (TYPE_ALIGN (elmt_type1) != TYPE_ALIGN (elmt_type2)\n+\t  || !operand_equal_p (TREE_OPERAND (ref1, 3),\n+\t\t\t       TREE_OPERAND (ref2, 3), 0))\n+\treturn -1;\n+    }\n+  else\n+    {\n+      if (!operand_equal_p (TYPE_SIZE_UNIT (elmt_type1),\n+\t\t\t    TYPE_SIZE_UNIT (elmt_type2), 0))\n+\treturn -1;\n+    }\n+\n+  /* Since we know that type sizes are the same, there is no need to return\n+     -1 after this point. Partial overlap can not be introduced.  */\n+\n+  /* We may need to fold trees in this case.\n+     TODO: Handle integer constant case at least.  */\n+  if (!operand_equal_p (low_bound1, low_bound2, 0))\n+    return 0;\n+\n+  if (TREE_CODE (index1) == INTEGER_CST && TREE_CODE (index2) == INTEGER_CST)\n+    {\n+      if (tree_int_cst_equal (index1, index2))\n+\treturn 0;\n+      return 1;\n+    }\n+  /* TODO: We can use VRP to further disambiguate here. */\n+  return 0;\n+}\n+\n /* Try to disambiguate REF1 and REF2 under the assumption that MATCH1 and\n    MATCH2 either point to the same address or are disjoint.\n    MATCH1 and MATCH2 are assumed to be ref in the access path of REF1 and REF2\n    respectively or NULL in the case we established equivalence of bases.\n+   If PARTIAL_OVERLAP is true assume that the toplevel arrays may actually\n+   overlap by exact multiply of their element size.\n \n    This test works by matching the initial segment of the access path\n    and does not rely on TBAA thus is safe for !flag_strict_aliasing if\n@@ -1247,8 +1344,9 @@ nonoverlapping_component_refs_p_1 (const_tree field1, const_tree field2)\n    oracles.  */\n \n static int\n-nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n-\t\t\t\t\t     tree match2, tree ref2)\n+nonoverlapping_refs_since_match_p (tree match1, tree ref1,\n+\t\t\t\t   tree match2, tree ref2,\n+\t\t\t\t   bool partial_overlap)\n {\n   /* Early return if there are no references to match, we do not need\n      to walk the access paths.\n@@ -1301,7 +1399,7 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n \t  && !tree_int_cst_equal (TREE_OPERAND (ref1, 1),\n \t\t\t\t  TREE_OPERAND (ref2, 1))))\n     {\n-      ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+      ++alias_stats.nonoverlapping_refs_since_match_p_may_alias;\n       return -1;\n     }\n \n@@ -1318,18 +1416,78 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n      case the return value will precisely be false.  */\n   while (true)\n     {\n-      bool seen_noncomponent_ref_p = false;\n+      /* Track if we seen unmatched ref with non-zero offset.  In this case\n+\t we must look for partial overlaps.  */\n+      bool seen_unmatched_ref_p = false;\n+\n+      /* First match ARRAY_REFs an try to disambiguate.  */\n+      if (!component_refs1.is_empty ()\n+\t  && !component_refs2.is_empty ())\n+\t{\n+\t  unsigned int narray_refs1=0, narray_refs2=0;\n+\n+\t  /* We generally assume that both access paths starts by same sequence\n+\t     of refs.  However if number of array refs is not in sync, try\n+\t     to recover and pop elts until number match.  This helps the case\n+\t     where one access path starts by array and other by element.  */\n+\t  for (narray_refs1 = 0; narray_refs1 < component_refs1.length ();\n+\t       narray_refs1++)\n+\t    if (TREE_CODE (component_refs1 [component_refs1.length()\n+\t\t\t\t\t    - 1 - narray_refs1]) != ARRAY_REF)\n+\t      break;\n+\n+\t  for (narray_refs2 = 0; narray_refs2 < component_refs2.length ();\n+\t       narray_refs2++)\n+\t    if (TREE_CODE (component_refs2 [component_refs2.length()\n+\t\t\t\t\t    - 1 - narray_refs2]) != ARRAY_REF)\n+\t      break;\n+\t  for (; narray_refs1 > narray_refs2; narray_refs1--)\n+\t    {\n+\t      ref1 = component_refs1.pop ();\n+\t      /* Track whether we possibly introduced partial overlap assuming\n+\t\t that innermost type sizes does not match.  This only can\n+\t\t happen if the offset introduced by the ARRAY_REF\n+\t\t is non-zero.  */\n+\t      if (!operand_equal_p (TREE_OPERAND (ref1, 1),\n+\t\t\t\t    cheap_array_ref_low_bound (ref1), 0))\n+\t        seen_unmatched_ref_p = true;\n+\t    }\n+\t  for (; narray_refs2 > narray_refs1; narray_refs2--)\n+\t    {\n+\t      ref2 = component_refs2.pop ();\n+\t      if (!operand_equal_p (TREE_OPERAND (ref2, 1),\n+\t\t\t\t    cheap_array_ref_low_bound (ref2), 0))\n+\t        seen_unmatched_ref_p = true;\n+\t    }\n+\t  /* Try to disambiguate matched arrays.  */\n+\t  for (unsigned int i = 0; i < narray_refs1; i++)\n+\t    {\n+\t      int cmp = nonoverlapping_array_refs_p (component_refs1.pop (),\n+\t\t\t\t\t\t     component_refs2.pop ());\n+\t      if (cmp == 1 && !partial_overlap)\n+\t\t{\n+\t\t  ++alias_stats\n+\t\t    .nonoverlapping_refs_since_match_p_no_alias;\n+\t\t  return 1;\n+\t\t}\n+\t      partial_overlap = false;\n+\t      if (cmp == -1)\n+\t\tseen_unmatched_ref_p = true;\n+\t    }\n+\t}\n+\n+      /* Next look for component_refs.  */\n       do\n \t{\n \t  if (component_refs1.is_empty ())\n \t    {\n \t      ++alias_stats\n-\t\t.nonoverlapping_component_refs_since_match_p_must_overlap;\n+\t\t.nonoverlapping_refs_since_match_p_must_overlap;\n \t      return 0;\n \t    }\n \t  ref1 = component_refs1.pop ();\n \t  if (TREE_CODE (ref1) != COMPONENT_REF)\n-\t    seen_noncomponent_ref_p = true;\n+\t    seen_unmatched_ref_p = true;\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref1, 0))));\n \n@@ -1338,12 +1496,12 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n \t  if (component_refs2.is_empty ())\n \t    {\n \t      ++alias_stats\n-\t\t.nonoverlapping_component_refs_since_match_p_must_overlap;\n+\t\t.nonoverlapping_refs_since_match_p_must_overlap;\n \t      return 0;\n \t    }\n \t  ref2 = component_refs2.pop ();\n \t  if (TREE_CODE (ref2) != COMPONENT_REF)\n-\t    seen_noncomponent_ref_p = true;\n+\t    seen_unmatched_ref_p = true;\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref2, 0))));\n \n@@ -1361,32 +1519,34 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n       tree type1 = DECL_CONTEXT (field1);\n       tree type2 = DECL_CONTEXT (field2);\n \n+      partial_overlap = false;\n+\n       /* If we skipped array refs on type of different sizes, we can\n \t no longer be sure that there are not partial overlaps.  */\n-      if (seen_noncomponent_ref_p\n+      if (seen_unmatched_ref_p\n \t  && !operand_equal_p (TYPE_SIZE (type1), TYPE_SIZE (type2), 0))\n \t{\n \t  ++alias_stats\n-\t    .nonoverlapping_component_refs_since_match_p_may_alias;\n+\t    .nonoverlapping_refs_since_match_p_may_alias;\n \t  return -1;\n \t}\n \n       int cmp = nonoverlapping_component_refs_p_1 (field1, field2);\n       if (cmp == -1)\n \t{\n \t  ++alias_stats\n-\t    .nonoverlapping_component_refs_since_match_p_may_alias;\n+\t    .nonoverlapping_refs_since_match_p_may_alias;\n \t  return -1;\n \t}\n       else if (cmp == 1)\n \t{\n \t  ++alias_stats\n-\t    .nonoverlapping_component_refs_since_match_p_no_alias;\n+\t    .nonoverlapping_refs_since_match_p_no_alias;\n \t  return 1;\n \t}\n     }\n \n-  ++alias_stats.nonoverlapping_component_refs_since_match_p_must_overlap;\n+  ++alias_stats.nonoverlapping_refs_since_match_p_must_overlap;\n   return 0;\n }\n \n@@ -1583,8 +1743,7 @@ decl_refs_may_alias_p (tree ref1, tree base1,\n      so we disambiguate component references manually.  */\n   if (ref1 && ref2\n       && handled_component_p (ref1) && handled_component_p (ref2)\n-      && nonoverlapping_component_refs_since_match_p (NULL, ref1,\n-\t\t\t\t\t\t      NULL, ref2) == 1)\n+      && nonoverlapping_refs_since_match_p (NULL, ref1, NULL, ref2, false) == 1)\n     return false;\n \n   return true;     \n@@ -1709,19 +1868,22 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n        || (!TMR_INDEX (base1) && !TMR_INDEX2 (base1)))\n        && (TREE_CODE (dbase2) != TARGET_MEM_REF\n \t   || (!TMR_INDEX (dbase2) && !TMR_INDEX2 (dbase2))))\n-      && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1\n-      && (TREE_CODE (TREE_TYPE (base1)) != ARRAY_TYPE\n-\t  || (TYPE_SIZE (TREE_TYPE (base1))\n-\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) == INTEGER_CST)))\n+      && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1)\n     {\n-      if (!ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2))\n+      bool partial_overlap = (TREE_CODE (TREE_TYPE (base1)) == ARRAY_TYPE\n+\t\t\t      && (TYPE_SIZE (TREE_TYPE (base1))\n+\t\t\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1)))\n+\t\t\t\t != INTEGER_CST));\n+      if (!partial_overlap\n+\t  && !ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2))\n \treturn false;\n       if (!ref1 || !ref2\n \t  /* If there is must alias, there is no use disambiguating further.  */\n-\t  || (known_eq (size1, max_size1) && known_eq (size2, max_size2)))\n+\t  || (!partial_overlap\n+\t      && known_eq (size1, max_size1) && known_eq (size2, max_size2)))\n \treturn true;\n-      int res = nonoverlapping_component_refs_since_match_p (base1, ref1,\n-\t\t\t\t\t\t\t     base2, ref2);\n+      int res = nonoverlapping_refs_since_match_p (base1, ref1, base2, ref2,\n+\t\t\t\t\t\t   partial_overlap);\n       if (res == -1)\n \treturn !nonoverlapping_component_refs_p (ref1, ref2);\n       return !res;\n@@ -1805,8 +1967,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \treturn true;\n       if (ref1 && ref2)\n \t{\n-\t  int res = nonoverlapping_component_refs_since_match_p (NULL, ref1,\n-\t\t\t\t\t\t\t\t NULL, ref2);\n+\t  int res = nonoverlapping_refs_since_match_p (NULL, ref1, NULL, ref2,\n+\t\t\t\t\t\t       false);\n \t  if (res != -1)\n \t    return !res;\n \t}\n@@ -1844,19 +2006,22 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       && (TREE_CODE (base2) != TARGET_MEM_REF\n \t  || (!TMR_INDEX (base2) && !TMR_INDEX2 (base2)))\n       && same_type_for_tbaa (TREE_TYPE (ptrtype1),\n-\t\t\t     TREE_TYPE (ptrtype2)) == 1\n+\t\t\t     TREE_TYPE (ptrtype2)) == 1)\n+    {\n       /* But avoid treating arrays as \"objects\", instead assume they\n          can overlap by an exact multiple of their element size.\n          See gcc.dg/torture/alias-2.c.  */\n-      && TREE_CODE (TREE_TYPE (ptrtype1)) != ARRAY_TYPE)\n-    {\n-      if (!ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+      bool partial_overlap = TREE_CODE (TREE_TYPE (ptrtype1)) == ARRAY_TYPE;\n+\n+      if (!partial_overlap\n+\t  && !ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n \treturn false;\n       if (!ref1 || !ref2\n-\t  || (known_eq (size1, max_size1) && known_eq (size2, max_size2)))\n+\t  || (!partial_overlap\n+\t      && known_eq (size1, max_size1) && known_eq (size2, max_size2)))\n \treturn true;\n-      int res = nonoverlapping_component_refs_since_match_p (base1, ref1,\n-\t\t\t\t\t\t\t     base2, ref2);\n+      int res = nonoverlapping_refs_since_match_p (base1, ref1, base2, ref2,\n+\t\t\t\t\t\t   partial_overlap);\n       if (res == -1)\n \treturn !nonoverlapping_component_refs_p (ref1, ref2);\n       return !res;"}]}