{"sha": "30e8a59c742c7fe9e5f622371564d40ad46a8a68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBlOGE1OWM3NDJjN2ZlOWU1ZjYyMjM3MTU2NGQ0MGFkNDZhOGE2OA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2005-01-11T20:19:56Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-01-11T20:19:56Z"}, "message": "PR libgcj/14012, PR libgcj/14013, PR libgcj/15157, PR libgcj/15509\n\n2005-01-11  Michael Koch  <konqueror@gmx.de>\n\n\tPR libgcj/14012, PR libgcj/14013, PR libgcj/15157, PR libgcj/15509\n\t* gnu/java/net/BASE64.java,\n\tgnu/java/net/EmptyX509TrustManager.java,\n\tgnu/java/net/LineInputStream.java,\n\tgnu/java/net/protocol/http/Authenticator.java,\n\tgnu/java/net/protocol/http/ByteArrayRequestBodyWriter.java,\n\tgnu/java/net/protocol/http/ByteArrayResponseBodyReader.java,\n\tgnu/java/net/protocol/http/ChunkedInputStream.java,\n\tgnu/java/net/protocol/http/Cookie.java,\n\tgnu/java/net/protocol/http/CookieManager.java,\n\tgnu/java/net/protocol/http/Credentials.java,\n\tgnu/java/net/protocol/http/HTTPConnection.java,\n\tgnu/java/net/protocol/http/HTTPDateFormat.java,\n\tgnu/java/net/protocol/http/HTTPURLConnection.java,\n\tgnu/java/net/protocol/http/Headers.java,\n\tgnu/java/net/protocol/http/Request.java,\n\tgnu/java/net/protocol/http/RequestBodyWriter.java,\n\tgnu/java/net/protocol/http/Response.java,\n\tgnu/java/net/protocol/http/ResponseBodyReader.java,\n\tgnu/java/net/protocol/http/ResponseHeaderHandler.java,\n\tgnu/java/net/protocol/http/SimpleCookieManager.java,\n\tgnu/java/net/protocol/http/event/ConnectionEvent.java,\n\tgnu/java/net/protocol/http/event/ConnectionListener.java,\n\tgnu/java/net/protocol/http/event/RequestEvent.java,\n\tgnu/java/net/protocol/http/event/RequestListener.java: New files.\n\t* gnu/java/net/protocol/http/Connection.java: Removed.\n\t* gnu/java/net/protocol/http/Handler.java,\n\tjavax/net/ssl/HttpsURLConnection.java: Updated.\n\t* Makefile.am: Added new files and remove old ones.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r93195", "tree": {"sha": "b57d5d648fcfa2eb2485ab53c50224d99fa4fff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b57d5d648fcfa2eb2485ab53c50224d99fa4fff5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30e8a59c742c7fe9e5f622371564d40ad46a8a68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30e8a59c742c7fe9e5f622371564d40ad46a8a68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30e8a59c742c7fe9e5f622371564d40ad46a8a68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30e8a59c742c7fe9e5f622371564d40ad46a8a68/comments", "author": null, "committer": null, "parents": [{"sha": "7eb3b9ec89e8f61bdc8d265955610561ef35d336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb3b9ec89e8f61bdc8d265955610561ef35d336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eb3b9ec89e8f61bdc8d265955610561ef35d336"}], "stats": {"total": 6087, "additions": 5469, "deletions": 618}, "files": [{"sha": "3c962937681956889e88dd831ea87d7dd81cd9d7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -1,3 +1,36 @@\n+2005-01-11  Michael Koch  <konqueror@gmx.de>\n+\n+\tPR libgcj/14012, PR libgcj/14013, PR libgcj/15157, PR libgcj/15509\n+\t* gnu/java/net/BASE64.java,\n+\tgnu/java/net/EmptyX509TrustManager.java,\n+\tgnu/java/net/LineInputStream.java,\n+\tgnu/java/net/protocol/http/Authenticator.java,\n+\tgnu/java/net/protocol/http/ByteArrayRequestBodyWriter.java,\n+\tgnu/java/net/protocol/http/ByteArrayResponseBodyReader.java,\n+\tgnu/java/net/protocol/http/ChunkedInputStream.java,\n+\tgnu/java/net/protocol/http/Cookie.java,\n+\tgnu/java/net/protocol/http/CookieManager.java,\n+\tgnu/java/net/protocol/http/Credentials.java,\n+\tgnu/java/net/protocol/http/HTTPConnection.java,\n+\tgnu/java/net/protocol/http/HTTPDateFormat.java,\n+\tgnu/java/net/protocol/http/HTTPURLConnection.java,\n+\tgnu/java/net/protocol/http/Headers.java,\n+\tgnu/java/net/protocol/http/Request.java,\n+\tgnu/java/net/protocol/http/RequestBodyWriter.java,\n+\tgnu/java/net/protocol/http/Response.java,\n+\tgnu/java/net/protocol/http/ResponseBodyReader.java,\n+\tgnu/java/net/protocol/http/ResponseHeaderHandler.java,\n+\tgnu/java/net/protocol/http/SimpleCookieManager.java,\n+\tgnu/java/net/protocol/http/event/ConnectionEvent.java,\n+\tgnu/java/net/protocol/http/event/ConnectionListener.java,\n+\tgnu/java/net/protocol/http/event/RequestEvent.java,\n+\tgnu/java/net/protocol/http/event/RequestListener.java: New files.\n+\t* gnu/java/net/protocol/http/Connection.java: Removed.\n+\t* gnu/java/net/protocol/http/Handler.java,\n+\tjavax/net/ssl/HttpsURLConnection.java: Updated.\n+\t* Makefile.am: Added new files and remove old ones.\n+\t* Makefile.in: Regenerated.\n+\n 2005-01-11  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/18840:"}, {"sha": "a6aa9b5ceb7090718c044bf7b1604ecdf6a2fa44", "filename": "libjava/Makefile.am", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -2854,8 +2854,11 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/net/BASE64.java \\\n gnu/java/net/DefaultContentHandlerFactory.java \\\n+gnu/java/net/EmptyX509TrustManager.java \\\n gnu/java/net/HeaderFieldHelper.java \\\n+gnu/java/net/LineInputStream.java \\\n gnu/java/net/PlainDatagramSocketImpl.java \\\n gnu/java/net/PlainSocketImpl.java \\\n gnu/java/net/URLParseError.java \\\n@@ -2866,8 +2869,28 @@ gnu/java/net/protocol/file/Connection.java \\\n gnu/java/net/protocol/file/Handler.java \\\n gnu/java/net/protocol/gcjlib/Connection.java \\\n gnu/java/net/protocol/gcjlib/Handler.java \\\n-gnu/java/net/protocol/http/Connection.java \\\n+gnu/java/net/protocol/http/Authenticator.java \\\n+gnu/java/net/protocol/http/ByteArrayRequestBodyWriter.java \\\n+gnu/java/net/protocol/http/ByteArrayResponseBodyReader.java \\\n+gnu/java/net/protocol/http/ChunkedInputStream.java \\\n+gnu/java/net/protocol/http/Cookie.java \\\n+gnu/java/net/protocol/http/CookieManager.java \\\n+gnu/java/net/protocol/http/Credentials.java \\\n+gnu/java/net/protocol/http/HTTPConnection.java \\\n+gnu/java/net/protocol/http/HTTPDateFormat.java \\\n+gnu/java/net/protocol/http/HTTPURLConnection.java \\\n gnu/java/net/protocol/http/Handler.java \\\n+gnu/java/net/protocol/http/Headers.java \\\n+gnu/java/net/protocol/http/Request.java \\\n+gnu/java/net/protocol/http/RequestBodyWriter.java \\\n+gnu/java/net/protocol/http/Response.java \\\n+gnu/java/net/protocol/http/ResponseBodyReader.java \\\n+gnu/java/net/protocol/http/ResponseHeaderHandler.java \\\n+gnu/java/net/protocol/http/SimpleCookieManager.java \\\n+gnu/java/net/protocol/http/event/ConnectionEvent.java \\\n+gnu/java/net/protocol/http/event/ConnectionListener.java \\\n+gnu/java/net/protocol/http/event/RequestEvent.java \\\n+gnu/java/net/protocol/http/event/RequestListener.java \\\n gnu/java/net/protocol/jar/Connection.java \\\n gnu/java/net/protocol/jar/Handler.java \\\n gnu/java/nio/ChannelInputStream.java \\"}, {"sha": "7c5e3733473bfee18e6380c25cb86b0249b58601", "filename": "libjava/Makefile.in", "status": "modified", "additions": 222, "deletions": 11, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -754,9 +754,11 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc link.cc \\\n \tgnu/java/locale/LocaleInformation_zh_HK.java \\\n \tgnu/java/locale/LocaleInformation_zh_SG.java \\\n \tgnu/java/locale/LocaleInformation_zh_TW.java \\\n-\tgnu/java/math/MPN.java \\\n+\tgnu/java/math/MPN.java gnu/java/net/BASE64.java \\\n \tgnu/java/net/DefaultContentHandlerFactory.java \\\n+\tgnu/java/net/EmptyX509TrustManager.java \\\n \tgnu/java/net/HeaderFieldHelper.java \\\n+\tgnu/java/net/LineInputStream.java \\\n \tgnu/java/net/PlainDatagramSocketImpl.java \\\n \tgnu/java/net/PlainSocketImpl.java \\\n \tgnu/java/net/URLParseError.java \\\n@@ -767,8 +769,28 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc link.cc \\\n \tgnu/java/net/protocol/file/Handler.java \\\n \tgnu/java/net/protocol/gcjlib/Connection.java \\\n \tgnu/java/net/protocol/gcjlib/Handler.java \\\n-\tgnu/java/net/protocol/http/Connection.java \\\n+\tgnu/java/net/protocol/http/Authenticator.java \\\n+\tgnu/java/net/protocol/http/ByteArrayRequestBodyWriter.java \\\n+\tgnu/java/net/protocol/http/ByteArrayResponseBodyReader.java \\\n+\tgnu/java/net/protocol/http/ChunkedInputStream.java \\\n+\tgnu/java/net/protocol/http/Cookie.java \\\n+\tgnu/java/net/protocol/http/CookieManager.java \\\n+\tgnu/java/net/protocol/http/Credentials.java \\\n+\tgnu/java/net/protocol/http/HTTPConnection.java \\\n+\tgnu/java/net/protocol/http/HTTPDateFormat.java \\\n+\tgnu/java/net/protocol/http/HTTPURLConnection.java \\\n \tgnu/java/net/protocol/http/Handler.java \\\n+\tgnu/java/net/protocol/http/Headers.java \\\n+\tgnu/java/net/protocol/http/Request.java \\\n+\tgnu/java/net/protocol/http/RequestBodyWriter.java \\\n+\tgnu/java/net/protocol/http/Response.java \\\n+\tgnu/java/net/protocol/http/ResponseBodyReader.java \\\n+\tgnu/java/net/protocol/http/ResponseHeaderHandler.java \\\n+\tgnu/java/net/protocol/http/SimpleCookieManager.java \\\n+\tgnu/java/net/protocol/http/event/ConnectionEvent.java \\\n+\tgnu/java/net/protocol/http/event/ConnectionListener.java \\\n+\tgnu/java/net/protocol/http/event/RequestEvent.java \\\n+\tgnu/java/net/protocol/http/event/RequestListener.java \\\n \tgnu/java/net/protocol/jar/Connection.java \\\n \tgnu/java/net/protocol/jar/Handler.java \\\n \tgnu/java/nio/ChannelInputStream.java \\\n@@ -3786,9 +3808,11 @@ am__objects_14 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/locale/LocaleInformation_zh_HK.lo \\\n \tgnu/java/locale/LocaleInformation_zh_SG.lo \\\n \tgnu/java/locale/LocaleInformation_zh_TW.lo \\\n-\tgnu/java/math/MPN.lo \\\n+\tgnu/java/math/MPN.lo gnu/java/net/BASE64.lo \\\n \tgnu/java/net/DefaultContentHandlerFactory.lo \\\n+\tgnu/java/net/EmptyX509TrustManager.lo \\\n \tgnu/java/net/HeaderFieldHelper.lo \\\n+\tgnu/java/net/LineInputStream.lo \\\n \tgnu/java/net/PlainDatagramSocketImpl.lo \\\n \tgnu/java/net/PlainSocketImpl.lo gnu/java/net/URLParseError.lo \\\n \tgnu/java/net/protocol/core/Connection.lo \\\n@@ -3798,8 +3822,28 @@ am__objects_14 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/net/protocol/file/Handler.lo \\\n \tgnu/java/net/protocol/gcjlib/Connection.lo \\\n \tgnu/java/net/protocol/gcjlib/Handler.lo \\\n-\tgnu/java/net/protocol/http/Connection.lo \\\n+\tgnu/java/net/protocol/http/Authenticator.lo \\\n+\tgnu/java/net/protocol/http/ByteArrayRequestBodyWriter.lo \\\n+\tgnu/java/net/protocol/http/ByteArrayResponseBodyReader.lo \\\n+\tgnu/java/net/protocol/http/ChunkedInputStream.lo \\\n+\tgnu/java/net/protocol/http/Cookie.lo \\\n+\tgnu/java/net/protocol/http/CookieManager.lo \\\n+\tgnu/java/net/protocol/http/Credentials.lo \\\n+\tgnu/java/net/protocol/http/HTTPConnection.lo \\\n+\tgnu/java/net/protocol/http/HTTPDateFormat.lo \\\n+\tgnu/java/net/protocol/http/HTTPURLConnection.lo \\\n \tgnu/java/net/protocol/http/Handler.lo \\\n+\tgnu/java/net/protocol/http/Headers.lo \\\n+\tgnu/java/net/protocol/http/Request.lo \\\n+\tgnu/java/net/protocol/http/RequestBodyWriter.lo \\\n+\tgnu/java/net/protocol/http/Response.lo \\\n+\tgnu/java/net/protocol/http/ResponseBodyReader.lo \\\n+\tgnu/java/net/protocol/http/ResponseHeaderHandler.lo \\\n+\tgnu/java/net/protocol/http/SimpleCookieManager.lo \\\n+\tgnu/java/net/protocol/http/event/ConnectionEvent.lo \\\n+\tgnu/java/net/protocol/http/event/ConnectionListener.lo \\\n+\tgnu/java/net/protocol/http/event/RequestEvent.lo \\\n+\tgnu/java/net/protocol/http/event/RequestListener.lo \\\n \tgnu/java/net/protocol/jar/Connection.lo \\\n \tgnu/java/net/protocol/jar/Handler.lo \\\n \tgnu/java/nio/ChannelInputStream.lo \\\n@@ -6687,8 +6731,11 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/net/BASE64.java \\\n gnu/java/net/DefaultContentHandlerFactory.java \\\n+gnu/java/net/EmptyX509TrustManager.java \\\n gnu/java/net/HeaderFieldHelper.java \\\n+gnu/java/net/LineInputStream.java \\\n gnu/java/net/PlainDatagramSocketImpl.java \\\n gnu/java/net/PlainSocketImpl.java \\\n gnu/java/net/URLParseError.java \\\n@@ -6699,8 +6746,28 @@ gnu/java/net/protocol/file/Connection.java \\\n gnu/java/net/protocol/file/Handler.java \\\n gnu/java/net/protocol/gcjlib/Connection.java \\\n gnu/java/net/protocol/gcjlib/Handler.java \\\n-gnu/java/net/protocol/http/Connection.java \\\n+gnu/java/net/protocol/http/Authenticator.java \\\n+gnu/java/net/protocol/http/ByteArrayRequestBodyWriter.java \\\n+gnu/java/net/protocol/http/ByteArrayResponseBodyReader.java \\\n+gnu/java/net/protocol/http/ChunkedInputStream.java \\\n+gnu/java/net/protocol/http/Cookie.java \\\n+gnu/java/net/protocol/http/CookieManager.java \\\n+gnu/java/net/protocol/http/Credentials.java \\\n+gnu/java/net/protocol/http/HTTPConnection.java \\\n+gnu/java/net/protocol/http/HTTPDateFormat.java \\\n+gnu/java/net/protocol/http/HTTPURLConnection.java \\\n gnu/java/net/protocol/http/Handler.java \\\n+gnu/java/net/protocol/http/Headers.java \\\n+gnu/java/net/protocol/http/Request.java \\\n+gnu/java/net/protocol/http/RequestBodyWriter.java \\\n+gnu/java/net/protocol/http/Response.java \\\n+gnu/java/net/protocol/http/ResponseBodyReader.java \\\n+gnu/java/net/protocol/http/ResponseHeaderHandler.java \\\n+gnu/java/net/protocol/http/SimpleCookieManager.java \\\n+gnu/java/net/protocol/http/event/ConnectionEvent.java \\\n+gnu/java/net/protocol/http/event/ConnectionListener.java \\\n+gnu/java/net/protocol/http/event/RequestEvent.java \\\n+gnu/java/net/protocol/http/event/RequestListener.java \\\n gnu/java/net/protocol/jar/Connection.java \\\n gnu/java/net/protocol/jar/Handler.java \\\n gnu/java/nio/ChannelInputStream.java \\\n@@ -9435,11 +9502,17 @@ gnu/java/math/$(DEPDIR)/$(am__dirstamp):\n \t@: > gnu/java/math/$(DEPDIR)/$(am__dirstamp)\n gnu/java/math/MPN.lo: gnu/java/math/$(am__dirstamp) \\\n \tgnu/java/math/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/BASE64.lo: gnu/java/net/$(am__dirstamp) \\\n+\tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/DefaultContentHandlerFactory.lo:  \\\n \tgnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/EmptyX509TrustManager.lo: gnu/java/net/$(am__dirstamp) \\\n+\tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/HeaderFieldHelper.lo: gnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/LineInputStream.lo: gnu/java/net/$(am__dirstamp) \\\n+\tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/PlainDatagramSocketImpl.lo: gnu/java/net/$(am__dirstamp) \\\n \tgnu/java/net/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/PlainSocketImpl.lo: gnu/java/net/$(am__dirstamp) \\\n@@ -9485,12 +9558,78 @@ gnu/java/net/protocol/http/$(am__dirstamp):\n gnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/net/protocol/http/$(DEPDIR)\n \t@: > gnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n-gnu/java/net/protocol/http/Connection.lo:  \\\n+gnu/java/net/protocol/http/Authenticator.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/ByteArrayRequestBodyWriter.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/ByteArrayResponseBodyReader.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/ChunkedInputStream.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/Cookie.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/CookieManager.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/Credentials.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/HTTPConnection.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/HTTPDateFormat.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/HTTPURLConnection.lo:  \\\n \tgnu/java/net/protocol/http/$(am__dirstamp) \\\n \tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/protocol/http/Handler.lo:  \\\n \tgnu/java/net/protocol/http/$(am__dirstamp) \\\n \tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/Headers.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/Request.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/RequestBodyWriter.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/Response.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/ResponseBodyReader.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/ResponseHeaderHandler.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/SimpleCookieManager.lo:  \\\n+\tgnu/java/net/protocol/http/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/event/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/net/protocol/http/event\n+\t@: > gnu/java/net/protocol/http/event/$(am__dirstamp)\n+gnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/net/protocol/http/event/$(DEPDIR)\n+\t@: > gnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/event/ConnectionEvent.lo:  \\\n+\tgnu/java/net/protocol/http/event/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/event/ConnectionListener.lo:  \\\n+\tgnu/java/net/protocol/http/event/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/event/RequestEvent.lo:  \\\n+\tgnu/java/net/protocol/http/event/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/net/protocol/http/event/RequestListener.lo:  \\\n+\tgnu/java/net/protocol/http/event/$(am__dirstamp) \\\n+\tgnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp)\n gnu/java/net/protocol/jar/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/net/protocol/jar\n \t@: > gnu/java/net/protocol/jar/$(am__dirstamp)\n@@ -15332,10 +15471,16 @@ mostlyclean-compile:\n \t-rm -f gnu/java/locale/LocaleInformation_zh_TW.lo\n \t-rm -f gnu/java/math/MPN.$(OBJEXT)\n \t-rm -f gnu/java/math/MPN.lo\n+\t-rm -f gnu/java/net/BASE64.$(OBJEXT)\n+\t-rm -f gnu/java/net/BASE64.lo\n \t-rm -f gnu/java/net/DefaultContentHandlerFactory.$(OBJEXT)\n \t-rm -f gnu/java/net/DefaultContentHandlerFactory.lo\n+\t-rm -f gnu/java/net/EmptyX509TrustManager.$(OBJEXT)\n+\t-rm -f gnu/java/net/EmptyX509TrustManager.lo\n \t-rm -f gnu/java/net/HeaderFieldHelper.$(OBJEXT)\n \t-rm -f gnu/java/net/HeaderFieldHelper.lo\n+\t-rm -f gnu/java/net/LineInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/LineInputStream.lo\n \t-rm -f gnu/java/net/PlainDatagramSocketImpl.$(OBJEXT)\n \t-rm -f gnu/java/net/PlainDatagramSocketImpl.lo\n \t-rm -f gnu/java/net/PlainSocketImpl.$(OBJEXT)\n@@ -15362,10 +15507,50 @@ mostlyclean-compile:\n \t-rm -f gnu/java/net/protocol/gcjlib/Connection.lo\n \t-rm -f gnu/java/net/protocol/gcjlib/Handler.$(OBJEXT)\n \t-rm -f gnu/java/net/protocol/gcjlib/Handler.lo\n-\t-rm -f gnu/java/net/protocol/http/Connection.$(OBJEXT)\n-\t-rm -f gnu/java/net/protocol/http/Connection.lo\n+\t-rm -f gnu/java/net/protocol/http/Authenticator.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/Authenticator.lo\n+\t-rm -f gnu/java/net/protocol/http/ByteArrayRequestBodyWriter.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/ByteArrayRequestBodyWriter.lo\n+\t-rm -f gnu/java/net/protocol/http/ByteArrayResponseBodyReader.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/ByteArrayResponseBodyReader.lo\n+\t-rm -f gnu/java/net/protocol/http/ChunkedInputStream.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/ChunkedInputStream.lo\n+\t-rm -f gnu/java/net/protocol/http/Cookie.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/Cookie.lo\n+\t-rm -f gnu/java/net/protocol/http/CookieManager.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/CookieManager.lo\n+\t-rm -f gnu/java/net/protocol/http/Credentials.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/Credentials.lo\n+\t-rm -f gnu/java/net/protocol/http/HTTPConnection.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/HTTPConnection.lo\n+\t-rm -f gnu/java/net/protocol/http/HTTPDateFormat.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/HTTPDateFormat.lo\n+\t-rm -f gnu/java/net/protocol/http/HTTPURLConnection.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/HTTPURLConnection.lo\n \t-rm -f gnu/java/net/protocol/http/Handler.$(OBJEXT)\n \t-rm -f gnu/java/net/protocol/http/Handler.lo\n+\t-rm -f gnu/java/net/protocol/http/Headers.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/Headers.lo\n+\t-rm -f gnu/java/net/protocol/http/Request.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/Request.lo\n+\t-rm -f gnu/java/net/protocol/http/RequestBodyWriter.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/RequestBodyWriter.lo\n+\t-rm -f gnu/java/net/protocol/http/Response.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/Response.lo\n+\t-rm -f gnu/java/net/protocol/http/ResponseBodyReader.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/ResponseBodyReader.lo\n+\t-rm -f gnu/java/net/protocol/http/ResponseHeaderHandler.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/ResponseHeaderHandler.lo\n+\t-rm -f gnu/java/net/protocol/http/SimpleCookieManager.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/SimpleCookieManager.lo\n+\t-rm -f gnu/java/net/protocol/http/event/ConnectionEvent.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/event/ConnectionEvent.lo\n+\t-rm -f gnu/java/net/protocol/http/event/ConnectionListener.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/event/ConnectionListener.lo\n+\t-rm -f gnu/java/net/protocol/http/event/RequestEvent.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/event/RequestEvent.lo\n+\t-rm -f gnu/java/net/protocol/http/event/RequestListener.$(OBJEXT)\n+\t-rm -f gnu/java/net/protocol/http/event/RequestListener.lo\n \t-rm -f gnu/java/net/protocol/jar/Connection.$(OBJEXT)\n \t-rm -f gnu/java/net/protocol/jar/Connection.lo\n \t-rm -f gnu/java/net/protocol/jar/Handler.$(OBJEXT)\n@@ -20116,8 +20301,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/locale/$(DEPDIR)/LocaleInformation_zh_SG.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/locale/$(DEPDIR)/LocaleInformation_zh_TW.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/math/$(DEPDIR)/MPN.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/BASE64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/DefaultContentHandlerFactory.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/EmptyX509TrustManager.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/HeaderFieldHelper.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/LineInputStream.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/PlainDatagramSocketImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/PlainSocketImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/$(DEPDIR)/URLParseError.Plo@am__quote@\n@@ -20131,8 +20319,28 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/file/$(DEPDIR)/Handler.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/gcjlib/$(DEPDIR)/Connection.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/gcjlib/$(DEPDIR)/Handler.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Connection.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Authenticator.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/ByteArrayRequestBodyWriter.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/ByteArrayResponseBodyReader.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/ChunkedInputStream.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Cookie.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/CookieManager.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Credentials.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/HTTPConnection.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/HTTPDateFormat.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/HTTPURLConnection.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Handler.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Headers.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Request.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/RequestBodyWriter.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/Response.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/ResponseBodyReader.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/ResponseHeaderHandler.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/$(DEPDIR)/SimpleCookieManager.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/event/$(DEPDIR)/ConnectionEvent.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/event/$(DEPDIR)/ConnectionListener.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/event/$(DEPDIR)/RequestEvent.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/http/event/$(DEPDIR)/RequestListener.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/jar/$(DEPDIR)/Connection.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/net/protocol/jar/$(DEPDIR)/Handler.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/nio/$(DEPDIR)/ChannelInputStream.Plo@am__quote@\n@@ -23174,6 +23382,7 @@ clean-libtool:\n \t-rm -rf gnu/java/net/protocol/file/.libs gnu/java/net/protocol/file/_libs\n \t-rm -rf gnu/java/net/protocol/gcjlib/.libs gnu/java/net/protocol/gcjlib/_libs\n \t-rm -rf gnu/java/net/protocol/http/.libs gnu/java/net/protocol/http/_libs\n+\t-rm -rf gnu/java/net/protocol/http/event/.libs gnu/java/net/protocol/http/event/_libs\n \t-rm -rf gnu/java/net/protocol/jar/.libs gnu/java/net/protocol/jar/_libs\n \t-rm -rf gnu/java/nio/.libs gnu/java/nio/_libs\n \t-rm -rf gnu/java/nio/channels/.libs gnu/java/nio/channels/_libs\n@@ -23699,6 +23908,8 @@ distclean-generic:\n \t-rm -f gnu/java/net/protocol/gcjlib/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/http/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/http/$(am__dirstamp)\n+\t-rm -f gnu/java/net/protocol/http/event/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/java/net/protocol/http/event/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/jar/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/net/protocol/jar/$(am__dirstamp)\n \t-rm -f gnu/java/nio/$(DEPDIR)/$(am__dirstamp)\n@@ -23951,7 +24162,7 @@ clean-am: clean-binPROGRAMS clean-generic clean-libtool clean-local \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-local distclean-tags\n@@ -23981,7 +24192,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/color/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/http/event/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "e711bb6e8ff3b6d6757f1090d6dca41e39d74377", "filename": "libjava/gnu/java/net/BASE64.java", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2FBASE64.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2FBASE64.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FBASE64.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,184 @@\n+/* BASE.java --\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+/**\n+ * Encodes and decodes text according to the BASE64 encoding.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public final class BASE64\n+{\n+  private static final byte[] src = {\n+    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,\n+    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54,\n+    0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64,\n+    0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,\n+    0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n+    0x79, 0x7a, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x2b, 0x2f\n+  };\n+\n+  private static final byte[] dst;\n+  static\n+  {\n+    dst = new byte[0x100];\n+    for (int i = 0x0; i < 0xff; i++)\n+      {\n+        dst[i] = -1;\n+      }\n+    for (int i = 0; i < src.length; i++)\n+      {\n+        dst[src[i]] = (byte) i;\n+      }\n+  }\n+\n+  private BASE64()\n+  {\n+  }\n+\n+  /**\n+   * Encode the specified byte array using the BASE64 algorithm.\n+   *\n+   * @param bs the source byte array\n+   */\n+  public static byte[] encode(byte[] bs)\n+  {\n+    int si = 0, ti = 0;         // source/target array indices\n+    byte[] bt = new byte[((bs.length + 2) * 4) / 3];     // target byte array\n+    for (; si < bs.length; si += 3)\n+      {\n+        int buflen = bs.length - si;\n+        if (buflen == 1)\n+          {\n+            byte b = bs[si];\n+            int i = 0;\n+            bt[ti++] = src[b >>> 2 & 0x3f];\n+            bt[ti++] = src[(b << 4 & 0x30) + (i >>> 4 & 0xf)];\n+          }\n+        else if (buflen == 2)\n+          {\n+            byte b1 = bs[si], b2 = bs[si + 1];\n+            int i = 0;\n+            bt[ti++] = src[b1 >>> 2 & 0x3f];\n+            bt[ti++] = src[(b1 << 4 & 0x30) + (b2 >>> 4 & 0xf)];\n+            bt[ti++] = src[(b2 << 2 & 0x3c) + (i >>> 6 & 0x3)];\n+          }\n+        else\n+          {\n+            byte b1 = bs[si], b2 = bs[si + 1], b3 = bs[si + 2];\n+            bt[ti++] = src[b1 >>> 2 & 0x3f];\n+            bt[ti++] = src[(b1 << 4 & 0x30) + (b2 >>> 4 & 0xf)];\n+            bt[ti++] = src[(b2 << 2 & 0x3c) + (b3 >>> 6 & 0x3)];\n+            bt[ti++] = src[b3 & 0x3f];\n+          }\n+      }\n+    /*while (ti < bt.length)\n+      {\n+        bt[ti++] = 0x3d;\n+      }*/\n+    return bt;\n+  }\n+\n+  /**\n+   * Decode the specified byte array using the BASE64 algorithm.\n+   *\n+   * @param bs the source byte array\n+   */\n+  public static byte[] decode(byte[] bs)\n+  {\n+    int srclen = bs.length;\n+    while (srclen > 0 && bs[srclen - 1] == 0x3d)\n+      {\n+        srclen--; /* strip padding character */\n+      }\n+    byte[] buffer = new byte[srclen];\n+    int buflen = 0;\n+    int si = 0;\n+    int len = srclen - si;\n+    while (len > 0)\n+      {\n+        byte b0 = dst[bs[si++] & 0xff];\n+        byte b2 = dst[bs[si++] & 0xff];\n+        buffer[buflen++] = (byte) (b0 << 2 & 0xfc | b2 >>> 4 & 0x3);\n+        if (len > 2)\n+          {\n+            b0 = b2;\n+            b2 = dst[bs[si++] & 0xff];\n+            buffer[buflen++] = (byte) (b0 << 4 & 0xf0 | b2 >>> 2 & 0xf);\n+            if (len > 3)\n+              {\n+                b0 = b2;\n+                b2 = dst[bs[si++] & 0xff];\n+                buffer[buflen++] = (byte) (b0 << 6 & 0xc0 | b2 & 0x3f);\n+              }\n+          }\n+        len = srclen - si;\n+      }\n+    byte[] bt = new byte[buflen];\n+    System.arraycopy(buffer, 0, bt, 0, buflen);\n+    return bt;\n+  }\n+  \n+  public static void main(String[] args)\n+  {\n+    boolean decode = false;\n+    for (int i = 0; i < args.length; i++)\n+      {\n+        if (args[i].equals(\"-d\"))\n+          {\n+            decode = true;\n+          }\n+        else\n+          {\n+            try\n+              {\n+                byte[] in = args[i].getBytes(\"US-ASCII\");\n+                byte[] out = decode ? decode(in) : encode(in);\n+                System.out.println(args[i] + \" = \" +\n+                                   new String(out, \"US-ASCII\"));\n+              }\n+            catch (java.io.UnsupportedEncodingException e)\n+              {\n+                e.printStackTrace(System.err);\n+              }\n+          }\n+      }\n+  }\n+}"}, {"sha": "c7e9055a3ab2fdf5df867af9dfac36ee3505a512", "filename": "libjava/gnu/java/net/EmptyX509TrustManager.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2FEmptyX509TrustManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2FEmptyX509TrustManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FEmptyX509TrustManager.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,69 @@\n+/* EmptyX509TrustManager.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.X509TrustManager;\n+\n+/**\n+ * Empty implementation of an X509 trust manager.\n+ * This implementation does not check any certificates in the chain.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class EmptyX509TrustManager\n+  implements X509TrustManager\n+{\n+  public void checkClientTrusted(X509Certificate[] chain, String authType)\n+    throws CertificateException\n+  {\n+  }\n+\n+  public void checkServerTrusted(X509Certificate[] chain, String authType)\n+    throws CertificateException\n+  {\n+  }\n+\n+  public X509Certificate[] getAcceptedIssuers()\n+  {\n+    return new X509Certificate[0];\n+  }\n+}\n+"}, {"sha": "491e6f78e0770831e73f4e9b1048c97cdc717111", "filename": "libjava/gnu/java/net/LineInputStream.java", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2FLineInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2FLineInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FLineInputStream.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,198 @@\n+/* LineInputStream.java --\n+   Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * An input stream that can read lines of input.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class LineInputStream\n+  extends FilterInputStream\n+{\n+  /*\n+   * Line buffer.\n+   */\n+  private ByteArrayOutputStream buf;\n+\n+  /*\n+   * Encoding to use when translating bytes to characters.\n+   */\n+  private String encoding;\n+\n+  /*\n+   * End-of-stream flag.\n+   */\n+  private boolean eof;\n+\n+  /**\n+   * Whether we can use block reads.\n+   */\n+  private final boolean blockReads;\n+\n+  /**\n+   * Constructor using the US-ASCII character encoding.\n+   * @param in the underlying input stream\n+   */\n+  public LineInputStream(InputStream in)\n+  {\n+    this(in, \"US-ASCII\");\n+  }\n+\n+  /**\n+   * Constructor.\n+   * @param in the underlying input stream\n+   * @param encoding the character encoding to use\n+   */\n+  public LineInputStream(InputStream in, String encoding)\n+  {\n+    super(in);\n+    buf = new ByteArrayOutputStream();\n+    this.encoding = encoding;\n+    eof = false;\n+    blockReads = in.markSupported();\n+  }\n+\n+  /**\n+   * Read a line of input.\n+   */\n+  public String readLine()\n+    throws IOException\n+  {\n+    if (eof)\n+      {\n+        return null;\n+      }\n+    do\n+      {\n+        if (blockReads)\n+          {\n+            // Use mark and reset to read chunks of bytes\n+            final int MIN_LENGTH = 1024;\n+            int len, pos;\n+            \n+            len = in.available();\n+            len = (len < MIN_LENGTH) ? MIN_LENGTH : len;\n+            byte[] b = new byte[len];\n+            in.mark(len);\n+            // Read into buffer b\n+            len = in.read(b, 0, len);\n+            // Handle EOF\n+            if (len == -1)\n+              {\n+                eof = true;\n+                if (buf.size() == 0)\n+                  {\n+                    return null;\n+                  }\n+                else\n+                  {\n+                    // We don't care about resetting buf\n+                    return buf.toString(encoding);\n+                  }\n+              }\n+            // Get index of LF in b\n+            pos = indexOf(b, len, (byte) 0x0a);\n+            if (pos != -1)\n+              {\n+                // Write pos bytes to buf\n+                buf.write(b, 0, pos);\n+                // Reset stream, and read pos + 1 bytes\n+                in.reset();\n+                pos += 1;\n+                while (pos > 0)\n+                  {\n+                    len = in.read(b, 0, pos);\n+                    pos = (len == -1) ? -1 : pos - len;\n+                  }\n+                // Return line\n+                String ret = buf.toString(encoding);\n+                buf.reset();\n+                return ret;\n+              }\n+            else\n+              {\n+                // Append everything to buf and fall through to re-read.\n+                buf.write(b, 0, len);\n+              }\n+          }\n+        else\n+          {\n+            // We must use character reads in order not to read too much\n+            // from the underlying stream.\n+            int c = in.read();\n+            switch (c)\n+              {\n+              case -1:\n+                eof = true;\n+                if (buf.size() == 0)\n+                  {\n+                    return null;\n+                  }\n+                // Fall through and return contents of buffer.\n+              case 0x0a:                // LF\n+                String ret = buf.toString(encoding);\n+                buf.reset();\n+                return ret;\n+              default:\n+                buf.write(c);\n+              }\n+          }\n+      }\n+    while (true);\n+  }\n+\n+  private int indexOf(byte[] b, int len, byte c)\n+  {\n+    for (int pos = 0; pos < len; pos++)\n+      {\n+        if (b[pos] == c)\n+          {\n+            return pos;\n+          }\n+      }\n+    return -1;\n+  }\n+}\n+"}, {"sha": "1943810c9f556beae7097a6d4c2ad898ad0412a6", "filename": "libjava/gnu/java/net/protocol/http/Authenticator.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FAuthenticator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FAuthenticator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FAuthenticator.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,59 @@\n+/* Authenticator.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Callback interface for managing authentication.\n+ * @see Request#setAuthenticator\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface Authenticator\n+{\n+\n+  /**\n+   * Returns the credentials to supply for the given realm.\n+   * @param realm the authentication realm\n+   * @param attempt zero on first authentication attempt, increments on each\n+   * unsuccessful attempt\n+   */\n+  Credentials getCredentials(String realm, int attempt);\n+  \n+}\n+"}, {"sha": "d817114dc4f9c48750e68c94c2a231127885f8c9", "filename": "libjava/gnu/java/net/protocol/http/ByteArrayRequestBodyWriter.java", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FByteArrayRequestBodyWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FByteArrayRequestBodyWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FByteArrayRequestBodyWriter.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,107 @@\n+/* ByteArrayRequestBodyWriter.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * A simple request body writer using a byte array.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class ByteArrayRequestBodyWriter\n+  implements RequestBodyWriter\n+{\n+\n+  /**\n+   * The content.\n+   */\n+  protected byte[] content;\n+\n+  /**\n+   * The position within the content at which the next read will occur.\n+   */\n+  protected int pos;\n+\n+  /**\n+   * Constructs a new byte array request body writer with the specified\n+   * content.\n+   * @param content the content buffer\n+   */\n+  public ByteArrayRequestBodyWriter(byte[] content)\n+  {\n+    this.content = content;\n+    pos = 0;\n+  }\n+\n+  /**\n+   * Returns the total number of bytes that will be written in a single pass\n+   * by this writer.\n+   */\n+  public int getContentLength()\n+  {\n+    return content.length;\n+  }\n+\n+  /**\n+   * Initialises the writer.\n+   * This will be called before each pass.\n+   */\n+  public void reset()\n+  {\n+    pos = 0;\n+  }\n+\n+  /**\n+   * Writes body content to the supplied buffer.\n+   * @param buffer the content buffer\n+   * @return the number of bytes written\n+   */\n+  public int write(byte[] buffer)\n+  {\n+    int len = content.length - pos;\n+    len = (buffer.length < len) ? buffer.length : len;\n+    if (len > -1)\n+      {\n+        System.arraycopy(content, pos, buffer, 0, len);\n+        pos += len;\n+      }\n+    return len;\n+  }\n+  \n+}\n+"}, {"sha": "1e615916cf855d86da0adec6a7d0ea5ab3092ad2", "filename": "libjava/gnu/java/net/protocol/http/ByteArrayResponseBodyReader.java", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FByteArrayResponseBodyReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FByteArrayResponseBodyReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FByteArrayResponseBodyReader.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,123 @@\n+/* Authenticator.java --ByteArrayResponseBodyReader.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Simple response body reader that stores content in a byte array.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class ByteArrayResponseBodyReader\n+  implements ResponseBodyReader\n+{\n+\n+  /**\n+   * The content.\n+   */\n+  protected byte[] content;\n+\n+  /**\n+   * The position in the content at which the next write will occur.\n+   */\n+  protected int pos;\n+\n+  /**\n+   * The length of the buffer.\n+   */\n+  protected int len;\n+\n+  /**\n+   * Constructs a new byte array response body reader.\n+   */\n+  public ByteArrayResponseBodyReader()\n+  {\n+    this(4096);\n+  }\n+  \n+  /**\n+   * Constructs a new byte array response body reader with the specified\n+   * initial buffer size.\n+   * @param size the initial buffer size\n+   */\n+  public ByteArrayResponseBodyReader(int size)\n+  {\n+    content = new byte[size];\n+    pos = len = 0;\n+  }\n+\n+  /**\n+   * This reader accepts all responses.\n+   */ \n+  public boolean accept(Request request, Response response)\n+  {\n+    return true;\n+  }\n+\n+  public void read(byte[] buffer, int offset, int length)\n+  {\n+    int l = length - offset;\n+    if (pos + l > content.length)\n+      {\n+        byte[] tmp = new byte[content.length * 2];\n+        System.arraycopy(content, 0, tmp, 0, pos);\n+        content = tmp;\n+      }\n+    System.arraycopy(buffer, offset, content, pos, l);\n+    pos += l;\n+    len = pos;\n+  }\n+\n+  public void close()\n+  {\n+    pos = 0;\n+  }\n+\n+  /**\n+   * Retrieves the content of this reader as a byte array.\n+   * The size of the returned array is the number of bytes read.\n+   */\n+  public byte[] toByteArray()\n+  {\n+    byte[] ret = new byte[len];\n+    System.arraycopy(content, 0, ret, 0, len);\n+    return ret;\n+  }\n+  \n+}\n+"}, {"sha": "cb051bf71a5f06d532aac6c9042cf98acbecf0ed", "filename": "libjava/gnu/java/net/protocol/http/ChunkedInputStream.java", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FChunkedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FChunkedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FChunkedInputStream.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,172 @@\n+/* ChunkedInputStream.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.ProtocolException;\n+\n+/**\n+ * Input stream wrapper for the \"chunked\" transfer-coding.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class ChunkedInputStream\n+  extends FilterInputStream\n+{\n+\n+  private static final byte CR = 0x0d;\n+  private static final byte LF = 0x0a;\n+\n+  int size;\n+  int count;\n+  boolean meta;\n+  boolean eof;\n+  Headers headers;\n+\n+  /**\n+   * Constructor.\n+   * @param in the response socket input stream\n+   * @param headers the headers to receive additional header lines\n+   */\n+  public ChunkedInputStream(InputStream in, Headers headers)\n+  {\n+    super(in);\n+    this.headers = headers;\n+    size = -1;\n+    count = 0;\n+    meta = true;\n+  }\n+\n+  public int read()\n+    throws IOException\n+  {\n+    byte[] buf = new byte[1];\n+    int len = read(buf, 0, 1);\n+    if (len == -1)\n+      {\n+        return -1;\n+      }\n+    int ret = (int) buf[0];\n+    if (ret < 0)\n+      {\n+        ret += 0x100;\n+      }\n+    return ret;\n+  }\n+\n+  public int read(byte[] buffer)\n+    throws IOException\n+  {\n+    return read(buffer, 0, buffer.length);\n+  }\n+\n+  public int read(byte[] buffer, int offset, int length)\n+    throws IOException\n+  {\n+    if (eof)\n+      {\n+        return -1;\n+      }\n+    if (meta)\n+      {\n+        // Read chunk header\n+        int c, last = 0;\n+        boolean seenSemi = false;\n+        StringBuffer buf = new StringBuffer();\n+        do\n+          {\n+            c = in.read();\n+            if (c == 0x3b) // ;\n+              {\n+                seenSemi = true;\n+              }\n+            else if (c == 0x0a && last == 0x0d) // CRLF\n+              {\n+                size = Integer.parseInt(buf.toString(), 16);\n+                break;\n+              }\n+            else if (!seenSemi && c >= 0x30)\n+              {\n+                buf.append ((char) c);\n+              }\n+            last = c;\n+          }\n+        while(c != -1);\n+        count = 0;\n+        meta = false;\n+      }\n+    if (size == 0)\n+      {\n+        // Read trailer\n+        headers.parse(in);\n+        eof = true;\n+        return -1;\n+      }\n+    else\n+      {\n+        int diff = length - offset;\n+        int max = size - count;\n+        max = (diff < max) ? diff : max;\n+        int len = (max > 0) ? in.read(buffer, offset, max) : 0;\n+        count += len;\n+        if (count == size)\n+          {\n+            // Read CRLF\n+            int c1 = in.read();\n+            int c2 = in.read();\n+            if (c1 == -1 && c2 == -1)\n+              {\n+                // EOF before CRLF: bad, but ignore\n+                eof = true;\n+                return -1;\n+              }\n+            if (c1 != 0x0d || c2 != 0x0a)\n+              {\n+                throw new ProtocolException(\"expecting CRLF: \" + c1 + \",\" + c2);\n+              }\n+            meta = true;\n+          }\n+        return len;\n+      }\n+  }\n+  \n+}\n+"}, {"sha": "aac565c71324560265335d6f23ca2e2442686b41", "filename": "libjava/gnu/java/net/protocol/http/Connection.java", "status": "removed", "additions": 0, "deletions": 553, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb3b9ec89e8f61bdc8d265955610561ef35d336/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb3b9ec89e8f61bdc8d265955610561ef35d336/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java?ref=7eb3b9ec89e8f61bdc8d265955610561ef35d336", "patch": "@@ -1,553 +0,0 @@\n-/* HttpURLConnection.java -- URLConnection class for HTTP protocol\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.net.protocol.http;\n-\n-import gnu.java.net.HeaderFieldHelper;\n-import gnu.java.security.action.GetPropertyAction;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedOutputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.InputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.net.HttpURLConnection;\n-import java.net.ProtocolException;\n-import java.net.Socket;\n-import java.net.URL;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-/**\n- * This subclass of java.net.URLConnection models a URLConnection via\n- * the HTTP protocol.\n- *\n- * Status: Minimal subset of functionality.  Proxies only partially\n- * handled; Redirects not yet handled.  FileNameMap handling needs to\n- * be considered.  useCaches, ifModifiedSince, and\n- * allowUserInteraction need consideration as well as doInput and\n- * doOutput.\n- * \n- * @author Aaron M. Renn <arenn@urbanophile.com>\n- * @author Warren Levy <warrenl@cygnus.com>\n- */\n-public final class Connection extends HttpURLConnection\n-{\n-  /**\n-   * The socket we are connected to\n-   */\n-  private Socket socket;\n-  \n-  // Properties depeending on system properties settings\n-  static int proxyPort = 80;\n-  static boolean proxyInUse = false;\n-  static String proxyHost = null;\n-  static String userAgent;\n-\n-  static \n-  {\n-    // Recognize some networking properties listed at\n-    // http://java.sun.com/j2se/1.4/docs/guide/net/properties.html.\n-    String port = null;\n-    GetPropertyAction getProperty = new GetPropertyAction(\"http.proxyHost\");\n-    proxyHost = (String) AccessController.doPrivileged(getProperty);\n-    if (proxyHost != null)\n-      {\n-\tproxyInUse = true;\n-\tgetProperty.setParameters(\"http.proxyPort\");\n-\tport = (String) AccessController.doPrivileged(getProperty);\n-\tif (port != null)\n-\t  {\n-\t    try\n-\t      {\n-\t\tproxyPort = Integer.parseInt(port);\n-\t      }\n-\t    catch (NumberFormatException ex)\n-\t      {\n-\t\t// Nothing.  \n-\t      }\n-\t  }\n-      }\n-\n-    getProperty.setParameters(\"http.agent\");\n-    userAgent = (String) AccessController.doPrivileged(getProperty);\n-  }\n-\n-  /**\n-   * The InputStream for this connection.\n-   */\n-  private DataInputStream inputStream;\n-\n-  /**\n-   * The OutputStream for this connection\n-   */\n-  private OutputStream outputStream;\n-\n-  /**\n-   * bufferedOutputStream is a buffer to contain content of the HTTP request,\n-   * and will be written to outputStream all at once\n-   */\n-  private ByteArrayOutputStream bufferedOutputStream;\n-\n-  /**\n-   * This object holds the request properties.\n-   */\n-  private HashMap requestProperties = new HashMap();\n-\n-  /**\n-   * This is the object that holds the header field information\n-   */\n-  private HeaderFieldHelper headers = new HeaderFieldHelper();\n-\n-  /**\n-   * Calls superclass constructor to initialize\n-   */\n-  protected Connection(URL url)\n-  {\n-    super(url);\n-\n-    /* Set up some variables */\n-    doOutput = false;\n-  }\n-\n-  /**\n-   * Connects to the remote host, sends the request, and parses the reply\n-   * code and header information returned\n-   */\n-  public void connect() throws IOException\n-  {\n-    // Call is ignored if already connected.\n-    if (connected)\n-      return;\n-\n-    // Get address and port number.\n-    int port;\n-    if (proxyInUse)\n-      {\n-\tport = proxyPort;\n-\tsocket = new Socket(proxyHost, port);\n-      }\n-    else\n-      {\n-\tif ((port = url.getPort()) == -1)\n-\t  port = 80;\n-\t// Open socket and output stream.\n-\tsocket = new Socket(url.getHost(), port);\n-      }\n-\n-    inputStream =\n-      new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n-    outputStream = new BufferedOutputStream (socket.getOutputStream());\n-\n-    sendRequest();\n-    receiveReply();\n-\n-    connected = true;\n-  }\n-\n-  /**\n-   * Disconnects from the remote server.\n-   */\n-  public void disconnect()\n-  {\n-    if (socket != null)\n-      {\n-\ttry\n-\t  {\n-\t    socket.close();\n-\t  }\n-\tcatch (IOException e)\n-\t  {\n-\t    // Ignore errors in closing socket.\n-\t  }\n-\tsocket = null;\n-      }\n-  }\n-\n-  /**\n-   * Write HTTP request header and content to outputWriter.\n-   */\n-  void sendRequest() throws IOException\n-  {\n-    // Create PrintWriter for easier sending of headers.\n-    PrintWriter outputWriter =\n-      new PrintWriter(new OutputStreamWriter(outputStream, \"8859_1\")); \n-    \n-    // Send request including any request properties that were set.\n-    String requestFile = url.getFile();\n-    outputWriter.print(getRequestMethod() + \" \"\n-\t\t       + (requestFile.length() != 0 ? requestFile : \"/\")\n-                       + \" HTTP/1.1\\r\\n\");\n-\n-    // Set additional HTTP headers.\n-    if (getRequestProperty (\"Host\") == null)\n-      setRequestProperty (\"Host\", url.getHost());\n-    \n-    if (getRequestProperty (\"Connection\") == null)\n-      setRequestProperty (\"Connection\", \"Close\");\n-    \n-    if (getRequestProperty (\"user-agent\") == null)\n-      setRequestProperty (\"user-agent\", userAgent);\n-    \n-    if (getRequestProperty (\"accept\") == null)\n-      setRequestProperty (\"accept\", \"*/*\");\n-    \n-    if (getRequestProperty (\"Content-type\") == null)\n-      setRequestProperty (\"Content-type\", \"application/x-www-form-urlencoded\");\n-\n-    // Set correct content length.\n-    if (bufferedOutputStream != null)\n-      setRequestProperty (\"Content-length\", String.valueOf (bufferedOutputStream.size()));\n-\n-    // Write all req_props name-value pairs to the output writer.\n-    Iterator itr = getRequestProperties().entrySet().iterator();\n-\n-    while (itr.hasNext())\n-      {\n-        Map.Entry e = (Map.Entry) itr.next();\n-        outputWriter.print (e.getKey() + \": \" + e.getValue() + \"\\r\\n\");\n-      }\n-\n-    // One more CR-LF indicates end of header.\n-    outputWriter.print (\"\\r\\n\");\n-    outputWriter.flush();\n-\n-    // Write content\n-    if (bufferedOutputStream != null)\n-      {\n-\tbufferedOutputStream.writeTo (outputStream);\n-\toutputStream.flush();\n-      }\n-  }\n-\n-  /**\n-   * Read HTTP reply from inputStream.\n-   */\n-  private void receiveReply() throws IOException\n-  {\n-    // Parse the reply\n-    String line = inputStream.readLine();\n-    String saveline = line;\n-    int idx = line.indexOf (\" \");\n-\n-    if ((idx == -1)\n-        || (line.length() < (idx + 6)))\n-      throw new IOException (\"Server reply was unparseable: \" + saveline);\n-\n-    headers.addHeaderField (null, line);\n-\n-    line = line.substring (idx + 1);\n-    String code = line.substring (0, 3);\n-    \n-    try\n-      {\n-        responseCode = Integer.parseInt (code);\n-      }\n-    catch (NumberFormatException e)\n-      {\n-        throw new IOException (\"Server reply was unparseable: \" + saveline);\n-      }\n-    \n-    responseMessage = line.substring (4);\n-\n-    // Now read the header lines\n-    String key = null, value = null;\n-    \n-    while (true)\n-      {\n-        line = inputStream.readLine();\n-        \n-        if (line.equals(\"\"))\n-          break;\n-\n-        // Check for folded lines\n-        if (line.startsWith (\" \")\n-            || line.startsWith(\"\\t\"))\n-          {\n-            // Trim off leading space\n-            do\n-              {\n-                if (line.length() == 1)\n-                  throw new IOException(\"Server header lines were unparseable: \"\n-                                        + line);\n-\n-                line = line.substring (1);\n-              }\n-            while (line.startsWith(\" \")\n-                   || line.startsWith(\"\\t\"));\n-\n-            value = value + \" \" + line;\n-          }\n-        else \n-          {\n-            if (key != null)\n-              {\n-                headers.addHeaderField (key.toLowerCase(), value);\n-                key = null;\n-                value = null;\n-              }\n-\n-            // Parse out key and value\n-            idx = line.indexOf (\":\");\n-            if ((idx == -1)\n-                || (line.length() < (idx + 2)))\n-              throw new IOException (\"Server header lines were unparseable: \"\n-                                     + line);\n-\n-            key = line.substring (0, idx);\n-            value = line.substring (idx + 1);\n-\n-            // Trim off leading space\n-            while (value.startsWith (\" \")\n-                   || value.startsWith (\"\\t\"))\n-              {\n-                if (value.length() == 1)\n-                  throw new IOException (\"Server header lines were unparseable: \"\n-                                         + line);\n-\n-                value = value.substring (1);\n-              }\n-          }\n-      }\n-    \n-    if (key != null)\n-      {\n-        headers.addHeaderField (key.toLowerCase(), value.toLowerCase());\n-      }\n-  }\n-\n-  /**\n-   * Return a boolean indicating whether or not this connection is\n-   * going through a proxy\n-   *\n-   * @return true if using a proxy, false otherwise\n-   */\n-  public boolean usingProxy()\n-  {\n-    return proxyInUse;\n-  }\n-\n-  /**\n-   * Returns an InputStream for reading from this connection.  This stream\n-   * will be \"queued up\" for reading just the contents of the requested file.\n-   * Overrides URLConnection.getInputStream()\n-   *\n-   * @return An InputStream for this connection.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public InputStream getInputStream() throws IOException\n-  {\n-    if (!connected)\n-      connect();\n-\n-    if (!doInput)\n-      throw new ProtocolException(\"Can't open InputStream if doInput is false\");\n-    \n-    return inputStream;\n-  }\n-\n-  /**\n-   * Returns on OutputStream for writing to this connection. This method\n-   * implicitely changes request method to <code>POST</code>.\n-   *\n-   * @return An OutputStream for this connection.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public OutputStream getOutputStream() throws IOException\n-  {\n-    if (connected)\n-      throw new ProtocolException\n-\t(\"You cannot get an output stream for an existing http connection\");\n-\n-    if (!doOutput)\n-      throw new ProtocolException\n-        (\"Want output stream while haven't setDoOutput(true)\");\n-    \n-    if (bufferedOutputStream == null)\n-      bufferedOutputStream = new ByteArrayOutputStream (256); //default is too small\n-    \n-    // Force POST request method.\n-    setRequestMethod(\"POST\");\n-\n-    return bufferedOutputStream;\n-  }\n-\n-  /**\n-   * Overrides java.net.HttpURLConnection.setRequestMethod() in order to\n-   * restrict the available methods to only those we support.\n-   *\n-   * @param method The RequestMethod to use\n-   *\n-   * @exception ProtocolException If the specified method is not valid\n-   */\n-  public void setRequestMethod (String method) throws ProtocolException\n-  {\n-    method = method.toUpperCase();\n-    \n-    if (method.equals(\"GET\")\n-        || method.equals(\"HEAD\")\n-        || method.equals(\"POST\"))\n-      super.setRequestMethod (method);\n-    else\n-      throw new ProtocolException (\"Unsupported or unknown request method \" +\n-                                   method);\n-  }\n-\n-  public void addRequestProperty(String key, String value)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-    \n-    String old = (String) requestProperties.put(key, value);\n-\n-    if (old != null)\n-      requestProperties.put(key, old + \",\" + value);\n-  }\n-\n-  public String getRequestProperty(String key)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-    \n-    return (String) requestProperties.get(key);\n-  }\n-\n-  public void setRequestProperty(String key, String value)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-    \n-    requestProperties.put(key, value);\n-  }\n-\n-  public Map getRequestProperties()\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-    \n-    return requestProperties;\n-  }\n-\n-  public String getHeaderField(String name)\n-  {\n-    if (!connected)\n-      try\n-        {\n-\t  connect();\n-\t}\n-      catch (IOException x)\n-        {\n-\t  return null;\n-\t}\n-\n-    return (String) headers.getHeaderFieldValueByKey(name.toLowerCase());\n-  }\n-\n-  public Map getHeaderFields()\n-  {\n-    if (!connected)\n-      try\n-        {\n-\t  connect();\n-\t}\n-      catch (IOException x)\n-        {\n-\t  return null;\n-\t}\n-\n-    return headers.getHeaderFields();\n-  }\n-\n-  /**\n-   * This method returns the header field value at the specified numeric\n-   * index.\n-   *\n-   * @param n The index into the header field array\n-   *\n-   * @return The value of the specified header field, or <code>null</code>\n-   * if the specified index is not valid.\n-   */\n-  public String getHeaderField(int n)\n-  {\n-    if (!connected)\n-      try\n-        {\n-\t  connect();\n-\t}\n-      catch (IOException x)\n-        {\n-\t  return null;\n-\t}\n-\n-    return headers.getHeaderFieldValueByIndex (n);\n-  }\n-\n-  /**\n-   * This method returns the header field key at the specified numeric\n-   * index.\n-   *\n-   * @param n The index into the header field array\n-   *\n-   * @return The name of the header field key, or <code>null</code> if the\n-   * specified index is not valid.\n-   */\n-  public String getHeaderFieldKey(int n)\n-  {\n-    if (!connected)\n-      try\n-        {\n-\t  connect();\n-\t}\n-      catch (IOException x)\n-        {\n-\t  return null;\n-\t}\n-\n-    return headers.getHeaderFieldKeyByIndex (n);\n-  }\n-}"}, {"sha": "fc4fde4f0dd49cfa23309e6936182c22c4f1ab14", "filename": "libjava/gnu/java/net/protocol/http/Cookie.java", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCookie.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCookie.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCookie.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,161 @@\n+/* Cookie.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import java.text.ParseException;\n+import java.util.Date;\n+\n+/**\n+ * An HTTP cookie, as specified in RFC 2109.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class Cookie\n+{\n+\n+  /**\n+   * The name of the cookie.\n+   */\n+  protected final String name;\n+\n+  /**\n+   * The value of the cookie.\n+   */\n+  protected final String value;\n+\n+  /**\n+   * Optional documentation of the intended use of the cookie.\n+   */\n+  protected final String comment;\n+\n+  /**\n+   * The domain for which the cookie is valid.\n+   */\n+  protected final String domain;\n+\n+  /**\n+   * Optional subset of URL paths within the domain for which the cookie is\n+   * valid.\n+   */\n+  protected final String path;\n+\n+  /**\n+   * Indicates that the user-agent should only use secure means to transmit\n+   * this cookie to the server.\n+   */\n+  protected final boolean secure;\n+\n+  /**\n+   * The date at which this cookie expires.\n+   */\n+  protected final Date expires;\n+\n+  public Cookie(String name, String value, String comment, String domain,\n+                String path, boolean secure, Date expires)\n+  {\n+    this.name = name;\n+    this.value = value;\n+    this.comment = comment;\n+    this.domain = domain;\n+    this.path = path;\n+    this.secure = secure;\n+    this.expires = expires;\n+  }\n+\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public String getValue()\n+  {\n+    return value;\n+  }\n+\n+  public String getComment()\n+  {\n+    return comment;\n+  }\n+\n+  public String getDomain()\n+  {\n+    return domain;\n+  }\n+\n+  public String getPath()\n+  {\n+    return path;\n+  }\n+\n+  public boolean isSecure()\n+  {\n+    return secure;\n+  }\n+\n+  public Date getExpiryDate()\n+  {\n+    return expires;\n+  }\n+\n+  public String toString()\n+  {\n+    return toString(true, true);\n+  }\n+  \n+  public String toString(boolean showPath, boolean showDomain)\n+  {\n+    StringBuffer buf = new StringBuffer();\n+    buf.append(name);\n+    buf.append('=');\n+    buf.append(value);\n+    if (showPath)\n+      {\n+        buf.append(\"; $Path=\");\n+        buf.append(path);\n+      }\n+    if (showDomain)\n+      {\n+        buf.append(\"; $Domain=\");\n+        buf.append(domain);\n+      }\n+    return buf.toString();\n+  }\n+\n+}\n+"}, {"sha": "59a36e3170f0f5288db928aa59811c49f31f692f", "filename": "libjava/gnu/java/net/protocol/http/CookieManager.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCookieManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCookieManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCookieManager.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,65 @@\n+/* CookieManager.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Cookie manager interface.\n+ * If an application wants to handle cookies, they should implement this\n+ * interface and register the instance with each HTTPConnection they use.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface CookieManager\n+{\n+\n+  /**\n+   * Stores a cookie in the cookie manager.\n+   * @param cookie the cookie to store\n+   */\n+  void setCookie(Cookie cookie);\n+\n+  /**\n+   * Retrieves the cookies matching the specified criteria.\n+   * @param host the host name\n+   * @param secure whether the connection is secure\n+   * @param path the path to access\n+   */\n+  Cookie[] getCookies(String host, boolean secure, String path);\n+  \n+}"}, {"sha": "ff4a9ad12d97f63a4a7fc049822d5146fde6ac33", "filename": "libjava/gnu/java/net/protocol/http/Credentials.java", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCredentials.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCredentials.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FCredentials.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,88 @@\n+/* Credentials.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Represents a username/password combination that can be used to\n+ * authenticate to an HTTP server.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class Credentials\n+{\n+\n+  /**\n+   * The username.\n+   */\n+  private String username;\n+\n+  /**\n+   * The password.\n+   */\n+  private String password;\n+\n+  /**\n+   * Constructor.\n+   * @param username the username\n+   * @param password the password\n+   */\n+  public Credentials(String username, String password)\n+  {\n+    this.username = username;\n+    this.password = password;\n+  }\n+\n+  /**\n+   * Returns the username.\n+   */\n+  public String getUsername()\n+  {\n+    return username;\n+  }\n+\n+  /**\n+   * Returns the password.\n+   */\n+  public String getPassword()\n+  {\n+    return password;\n+  }\n+  \n+}\n+"}, {"sha": "00cb7036c75fef47d10058b798bdc17e673544e1", "filename": "libjava/gnu/java/net/protocol/http/HTTPConnection.java", "status": "added", "additions": 701, "deletions": 0, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPConnection.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,701 @@\n+/* HTTPConnection.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import gnu.classpath.Configuration;\n+import gnu.java.net.protocol.http.event.ConnectionEvent;\n+import gnu.java.net.protocol.http.event.ConnectionListener;\n+import gnu.java.net.protocol.http.event.RequestEvent;\n+import gnu.java.net.protocol.http.event.RequestListener;\n+import gnu.java.net.EmptyX509TrustManager;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import javax.net.SocketFactory;\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+\n+/**\n+ * A connection to an HTTP server.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class HTTPConnection\n+{\n+\n+  /**\n+   * The default HTTP port.\n+   */\n+  public static final int HTTP_PORT = 80;\n+\n+  /**\n+   * The default HTTPS port.\n+   */\n+  public static final int HTTPS_PORT = 443;\n+\n+  private static final String userAgent = initUserAgent();\n+\n+  private static String initUserAgent()\n+  {\n+    try\n+      {\n+        StringBuffer buf = new StringBuffer(\"libgcj\");\n+        buf.append(\" (\");\n+        buf.append(System.getProperty(\"os.name\"));\n+        buf.append(\"; \");\n+        buf.append(System.getProperty(\"os.arch\"));\n+        buf.append(\"; \");\n+        buf.append(System.getProperty(\"user.language\"));\n+        buf.append(\")\");\n+        return buf.toString();\n+      }\n+    catch (SecurityException e)\n+      {\n+        return \"inetlib/1.1\";\n+      }\n+  }\n+\n+  /**\n+   * The host name of the server to connect to.\n+   */\n+  protected final String hostname;\n+\n+  /**\n+   * The port to connect to.\n+   */\n+  protected final int port;\n+\n+  /**\n+   * Whether the connection should use transport level security (HTTPS).\n+   */\n+  protected final boolean secure;\n+\n+  /**\n+   * The connection timeout for connecting the underlying socket.\n+   */\n+  protected final int connectionTimeout;\n+\n+  /**\n+   * The read timeout for reads on the underlying socket.\n+   */\n+  protected final int timeout;\n+\n+  /**\n+   * The host name of the proxy to connect to.\n+   */\n+  protected String proxyHostname;\n+\n+  /**\n+   * The port on the proxy to connect to.\n+   */\n+  protected int proxyPort;\n+\n+  /**\n+   * The major version of HTTP supported by this client.\n+   */\n+  protected int majorVersion;\n+\n+  /**\n+   * The minor version of HTTP supported by this client.\n+   */\n+  protected int minorVersion;\n+\n+  private final List connectionListeners;\n+  private final List requestListeners;\n+  private final List handshakeCompletedListeners;\n+\n+  /**\n+   * The socket this connection communicates on.\n+   */\n+  protected Socket socket;\n+\n+  /**\n+   * The SSL socket factory to use.\n+   */\n+  private SSLSocketFactory sslSocketFactory;\n+\n+  /**\n+   * The socket input stream.\n+   */\n+  protected InputStream in;\n+\n+  /**\n+   * The socket output stream.\n+   */\n+  protected OutputStream out;\n+\n+  /**\n+   * Nonce values seen by this connection.\n+   */\n+  private Map nonceCounts;\n+\n+  /**\n+   * The cookie manager for this connection.\n+   */\n+  protected CookieManager cookieManager;\n+\n+  /**\n+   * Creates a new HTTP connection.\n+   * @param hostname the name of the host to connect to\n+   */\n+  public HTTPConnection(String hostname)\n+  {\n+    this(hostname, HTTP_PORT, false, 0, 0);\n+  }\n+\n+  /**\n+   * Creates a new HTTP or HTTPS connection.\n+   * @param hostname the name of the host to connect to\n+   * @param secure whether to use a secure connection\n+   */\n+  public HTTPConnection(String hostname, boolean secure)\n+  {\n+    this(hostname, secure ? HTTPS_PORT : HTTP_PORT, secure, 0, 0);\n+  }\n+\n+  /**\n+   * Creates a new HTTP or HTTPS connection on the specified port.\n+   * @param hostname the name of the host to connect to\n+   * @param secure whether to use a secure connection\n+   * @param connectionTimeout the connection timeout\n+   * @param timeout the socket read timeout\n+   */\n+  public HTTPConnection(String hostname, boolean secure,\n+                        int connectionTimeout, int timeout)\n+  {\n+    this(hostname, secure ? HTTPS_PORT : HTTP_PORT, secure,\n+         connectionTimeout, timeout);\n+  }\n+  \n+  /**\n+   * Creates a new HTTP connection on the specified port.\n+   * @param hostname the name of the host to connect to\n+   * @param port the port on the host to connect to\n+   */\n+  public HTTPConnection(String hostname, int port)\n+  {\n+    this(hostname, port, false, 0, 0);\n+  }\n+\n+  /**\n+   * Creates a new HTTP or HTTPS connection on the specified port.\n+   * @param hostname the name of the host to connect to\n+   * @param port the port on the host to connect to\n+   * @param secure whether to use a secure connection\n+   */\n+  public HTTPConnection(String hostname, int port, boolean secure)\n+  {\n+    this(hostname, port, secure, 0, 0);\n+  }\n+  \n+  /**\n+   * Creates a new HTTP or HTTPS connection on the specified port.\n+   * @param hostname the name of the host to connect to\n+   * @param port the port on the host to connect to\n+   * @param secure whether to use a secure connection\n+   * @param connectionTimeout the connection timeout\n+   * @param timeout the socket read timeout\n+   */\n+  public HTTPConnection(String hostname, int port, boolean secure,\n+                        int connectionTimeout, int timeout)\n+  {\n+    this.hostname = hostname;\n+    this.port = port;\n+    this.secure = secure;\n+    this.connectionTimeout = connectionTimeout;\n+    this.timeout = timeout;\n+    majorVersion = minorVersion = 1;\n+    connectionListeners = new ArrayList(4);\n+    requestListeners = new ArrayList(4);\n+    handshakeCompletedListeners = new ArrayList(2);\n+  }\n+\n+  /**\n+   * Returns the name of the host to connect to.\n+   */\n+  public String getHostName()\n+  {\n+    return hostname;\n+  }\n+\n+  /**\n+   * Returns the port on the host to connect to.\n+   */\n+  public int getPort()\n+  {\n+    return port;\n+  }\n+\n+  /**\n+   * Indicates whether to use a secure connection or not.\n+   */\n+  public boolean isSecure()\n+  {\n+    return secure;\n+  }\n+\n+  /**\n+   * Returns the HTTP version string supported by this connection.\n+   * @see #version\n+   */\n+  public String getVersion()\n+  {\n+    return \"HTTP/\" + majorVersion + '.' + minorVersion;\n+  }\n+\n+  /**\n+   * Sets the HTTP version supported by this connection.\n+   * @param majorVersion the major version\n+   * @param minorVersion the minor version\n+   */\n+  public void setVersion(int majorVersion, int minorVersion)\n+  {\n+    if (majorVersion != 1)\n+      {\n+        throw new IllegalArgumentException(\"major version not supported: \" +\n+                                           majorVersion);\n+      }\n+    if (minorVersion < 0 || minorVersion > 1)\n+      {\n+        throw new IllegalArgumentException(\"minor version not supported: \" +\n+                                           minorVersion);\n+      }\n+    this.majorVersion = majorVersion;\n+    this.minorVersion = minorVersion;\n+  }\n+\n+  /**\n+   * Directs this connection to use the specified proxy.\n+   * @param hostname the proxy host name\n+   * @param port the port on the proxy to connect to\n+   */\n+  public void setProxy(String hostname, int port)\n+  {\n+    proxyHostname = hostname;\n+    proxyPort = port;\n+  }\n+\n+  /**\n+   * Indicates whether this connection is using an HTTP proxy.\n+   */\n+  public boolean isUsingProxy()\n+  {\n+    return (proxyHostname != null && proxyPort > 0);\n+  }\n+\n+  /**\n+   * Sets the cookie manager to use for this connection.\n+   * @param cookieManager the cookie manager\n+   */\n+  public void setCookieManager(CookieManager cookieManager)\n+  {\n+    this.cookieManager = cookieManager;\n+  }\n+\n+  /**\n+   * Returns the cookie manager in use for this connection.\n+   */\n+  public CookieManager getCookieManager()\n+  {\n+    return cookieManager;\n+  }\n+\n+  /**\n+   * Creates a new request using this connection.\n+   * @param method the HTTP method to invoke\n+   * @param path the URI-escaped RFC2396 <code>abs_path</code> with\n+   * optional query part\n+   */\n+  public Request newRequest(String method, String path)\n+  {\n+    if (method == null || method.length() == 0)\n+      {\n+        throw new IllegalArgumentException(\"method must have non-zero length\");\n+      }\n+    if (path == null || path.length() == 0)\n+      {\n+        path = \"/\";\n+      }\n+    Request ret = new Request(this, method, path);\n+    if ((secure && port != HTTPS_PORT) ||\n+        (!secure && port != HTTP_PORT))\n+      {\n+        ret.setHeader(\"Host\", hostname + \":\" + port);\n+      }\n+    else\n+      {\n+        ret.setHeader(\"Host\", hostname);\n+      }\n+    ret.setHeader(\"User-Agent\", userAgent);\n+    ret.setHeader(\"Connection\", \"keep-alive\");\n+    ret.setHeader(\"Accept-Encoding\",\n+                  \"chunked;q=1.0, gzip;q=0.9, deflate;q=0.8, \" +\n+                  \"identity;q=0.6, *;q=0\");\n+    if (cookieManager != null)\n+      {\n+        Cookie[] cookies = cookieManager.getCookies(hostname, secure, path);\n+        if (cookies != null && cookies.length > 0)\n+          {\n+            StringBuffer buf = new StringBuffer();\n+            buf.append(\"$Version=1\");\n+            for (int i = 0; i < cookies.length; i++)\n+              {\n+                buf.append(',');\n+                buf.append(' ');\n+                buf.append(cookies[i].toString());\n+              }\n+            ret.setHeader(\"Cookie\", buf.toString());\n+          }\n+      }\n+    fireRequestEvent(RequestEvent.REQUEST_CREATED, ret);\n+    return ret;\n+  }\n+\n+  /**\n+   * Closes this connection.\n+   */\n+  public void close()\n+    throws IOException\n+  {\n+    try\n+      {\n+        closeConnection();\n+      }\n+    finally\n+      {\n+        fireConnectionEvent(ConnectionEvent.CONNECTION_CLOSED);\n+      }\n+  }\n+\n+  /**\n+   * Retrieves the socket associated with this connection.\n+   * This creates the socket if necessary.\n+   */\n+  protected Socket getSocket()\n+    throws IOException\n+  {\n+    if (socket == null)\n+      {\n+        String connectHostname = hostname;\n+        int connectPort = port;\n+        if (isUsingProxy())\n+          {\n+            connectHostname = proxyHostname;\n+            connectPort = proxyPort;\n+          }\n+        socket = new Socket();\n+        InetSocketAddress address =\n+          new InetSocketAddress(connectHostname, connectPort);\n+        if (connectionTimeout > 0)\n+          {\n+            socket.connect(address, connectionTimeout);\n+          }\n+        else\n+          {\n+            socket.connect(address);\n+          }\n+        if (timeout > 0)\n+          {\n+            socket.setSoTimeout(timeout);\n+          }\n+        if (secure)\n+          {\n+            try\n+              {\n+                SSLSocketFactory factory = getSSLSocketFactory();\n+                SSLSocket ss =\n+                  (SSLSocket) factory.createSocket(socket, connectHostname,\n+                                                   connectPort, true);\n+                String[] protocols = { \"TLSv1\", \"SSLv3\" };\n+                ss.setEnabledProtocols(protocols);\n+                ss.setUseClientMode(true);\n+                synchronized (handshakeCompletedListeners)\n+                  {\n+                    if (!handshakeCompletedListeners.isEmpty())\n+                      {\n+                        for (Iterator i =\n+                             handshakeCompletedListeners.iterator();\n+                             i.hasNext(); )\n+                          {\n+                            HandshakeCompletedListener l =\n+                              (HandshakeCompletedListener) i.next();\n+                            ss.addHandshakeCompletedListener(l);\n+                          }\n+                      }\n+                  }\n+                ss.startHandshake();\n+                socket = ss;\n+              }\n+            catch (GeneralSecurityException e)\n+              {\n+                throw new IOException(e.getMessage());\n+              }\n+          }\n+        in = socket.getInputStream();\n+        in = new BufferedInputStream(in);\n+        out = socket.getOutputStream();\n+        out = new BufferedOutputStream(out);\n+      }\n+    return socket;\n+  }\n+\n+  SSLSocketFactory getSSLSocketFactory()\n+    throws GeneralSecurityException\n+  {\n+    if (sslSocketFactory == null)\n+      {\n+        TrustManager tm = new EmptyX509TrustManager();\n+        SSLContext context = SSLContext.getInstance(\"SSL\");\n+        TrustManager[] trust = new TrustManager[] { tm };\n+        context.init(null, trust, null);\n+        sslSocketFactory = context.getSocketFactory();\n+      }\n+    return sslSocketFactory;\n+  }\n+\n+  void setSSLSocketFactory(SSLSocketFactory factory)\n+  {\n+    sslSocketFactory = factory;\n+  }\n+\n+  protected InputStream getInputStream()\n+    throws IOException\n+  {\n+    if (socket == null)\n+      {\n+        getSocket();\n+      }\n+    return in;\n+  }\n+\n+  protected OutputStream getOutputStream()\n+    throws IOException\n+  {\n+    if (socket == null)\n+      {\n+        getSocket();\n+      }\n+    return out;\n+  }\n+\n+  /**\n+   * Closes the underlying socket, if any.\n+   */\n+  protected void closeConnection()\n+    throws IOException\n+  {\n+    if (socket != null)\n+      {\n+        try\n+          {\n+            socket.close();\n+          }\n+        finally\n+          {\n+            socket = null;\n+          }\n+      }\n+  }\n+\n+  /**\n+   * Returns a URI representing the connection.\n+   * This does not include any request path component.\n+   */\n+  protected String getURI()\n+  {\n+    StringBuffer buf = new StringBuffer();\n+    buf.append(secure ? \"https://\" : \"http://\");\n+    buf.append(hostname);\n+    if (secure)\n+      {\n+        if (port != HTTPConnection.HTTPS_PORT)\n+          {\n+            buf.append(':');\n+            buf.append(port);\n+          }\n+      }\n+    else\n+      {\n+        if (port != HTTPConnection.HTTP_PORT)\n+          {\n+            buf.append(':');\n+            buf.append(port);\n+          }\n+      }\n+    return buf.toString();\n+  }\n+\n+  /**\n+   * Get the number of times the specified nonce has been seen by this\n+   * connection.\n+   */\n+  int getNonceCount(String nonce)\n+  {\n+    if (nonceCounts == null)\n+      {\n+        return 0;\n+      }\n+    return((Integer) nonceCounts.get(nonce)).intValue();\n+  }\n+\n+  /**\n+   * Increment the number of times the specified nonce has been seen.\n+   */\n+  void incrementNonce(String nonce)\n+  {\n+    int current = getNonceCount(nonce);\n+    if (nonceCounts == null)\n+      {\n+        nonceCounts = new HashMap();\n+      }\n+    nonceCounts.put(nonce, new Integer(current + 1));\n+  }\n+\n+  // -- Events --\n+  \n+  public void addConnectionListener(ConnectionListener l)\n+  {\n+    synchronized (connectionListeners)\n+      {\n+        connectionListeners.add(l);\n+      }\n+  }\n+\n+  public void removeConnectionListener(ConnectionListener l)\n+  {\n+    synchronized (connectionListeners)\n+      {\n+        connectionListeners.remove(l);\n+      }\n+  }\n+\n+  protected void fireConnectionEvent(int type)\n+  {\n+    ConnectionEvent event = new ConnectionEvent(this, type);\n+    ConnectionListener[] l = null;\n+    synchronized (connectionListeners)\n+      {\n+        l = new ConnectionListener[connectionListeners.size()];\n+        connectionListeners.toArray(l);\n+      }\n+    for (int i = 0; i < l.length; i++)\n+      {\n+        switch (type)\n+          {\n+          case ConnectionEvent.CONNECTION_CLOSED:\n+            l[i].connectionClosed(event);\n+            break;\n+          }\n+      }\n+  }\n+\n+  public void addRequestListener(RequestListener l)\n+  {\n+    synchronized (requestListeners)\n+      {\n+        requestListeners.add(l);\n+      }\n+  }\n+\n+  public void removeRequestListener(RequestListener l)\n+  {\n+    synchronized (requestListeners)\n+      {\n+        requestListeners.remove(l);\n+      }\n+  }\n+\n+  protected void fireRequestEvent(int type, Request request)\n+  {\n+    RequestEvent event = new RequestEvent(this, type, request);\n+    RequestListener[] l = null;\n+    synchronized (requestListeners)\n+      {\n+        l = new RequestListener[requestListeners.size()];\n+        requestListeners.toArray(l);\n+      }\n+    for (int i = 0; i < l.length; i++)\n+      {\n+        switch (type)\n+          {\n+          case RequestEvent.REQUEST_CREATED:\n+            l[i].requestCreated(event);\n+            break;\n+          case RequestEvent.REQUEST_SENDING:\n+            l[i].requestSent(event);\n+            break;\n+          case RequestEvent.REQUEST_SENT:\n+            l[i].requestSent(event);\n+            break;\n+          }\n+      }\n+  }\n+\n+  void addHandshakeCompletedListener(HandshakeCompletedListener l)\n+  {\n+    synchronized (handshakeCompletedListeners)\n+      {\n+        handshakeCompletedListeners.add(l);\n+      }\n+  }\n+  void removeHandshakeCompletedListener(HandshakeCompletedListener l)\n+  {\n+    synchronized (handshakeCompletedListeners)\n+      {\n+        handshakeCompletedListeners.remove(l);\n+      }\n+  }\n+\n+}\n+"}, {"sha": "22ef05631e991e924a1fad6141b33c8849f88fef", "filename": "libjava/gnu/java/net/protocol/http/HTTPDateFormat.java", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPDateFormat.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,435 @@\n+/* HTTPDateFormat.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import java.io.PrintStream;\n+import java.text.*;\n+import java.util.*;\n+\n+/**\n+ * HTTP date formatter and parser.\n+ * Formats dates according to RFC 822 (updated by RFC 1123).\n+ * Parses dates according to the above, <i>or</i> RFC 1036, <i>or</i> the\n+ * ANSI C <code>asctime()</code> format.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class HTTPDateFormat\n+  extends DateFormat\n+{\n+\n+  static final String[] DAYS_OF_WEEK = {\n+    null, \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n+  };\n+\n+  static final String[] MONTHS = {\n+    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n+  };\n+\n+  public HTTPDateFormat()\n+  {\n+    calendar = new GregorianCalendar(TimeZone.getTimeZone (\"GMT\"));\n+    numberFormat = new DecimalFormat();\n+  }\n+\n+  /**\n+   * Appends the textual value for the specified field to the given string\n+   * buffer. This method should be avoided, use <code>format(Date)</code>\n+   * instead.\n+   * @param date the Date object\n+   * @param buf the buffer to append to\n+   * @param field the current field position\n+   * @return the modified buffer\n+   */\n+  public StringBuffer format(Date date, StringBuffer buf,\n+                             FieldPosition field)\n+  {\n+    calendar.clear();\n+    calendar.setTime(date);\n+    buf.setLength(0);\n+\n+    // Day of week\n+    buf.append(DAYS_OF_WEEK[calendar.get(Calendar.DAY_OF_WEEK)]);\n+    buf.append(',');\n+    buf.append(' ');\n+\n+    // Day of month\n+    int day = calendar.get(Calendar.DAY_OF_MONTH);\n+    buf.append(Character.forDigit(day / 10, 10));\n+    buf.append(Character.forDigit(day % 10, 10));\n+    buf.append(' ');\n+\n+    // Month\n+    buf.append(MONTHS[calendar.get(Calendar.MONTH)]);\n+    buf.append(' ');\n+\n+    // Year\n+    int year = calendar.get(Calendar.YEAR);\n+    if (year < 1000)\n+      {\n+        buf.append('0');\n+        if (year < 100)\n+          {\n+            buf.append('0');\n+            if (year < 10)\n+              {\n+                buf.append('0');\n+              }\n+          }\n+      }\n+    buf.append(Integer.toString(year));\n+    buf.append(' ');\n+\n+    // Hour\n+    int hour = calendar.get(Calendar.HOUR_OF_DAY);\n+    buf.append(Character.forDigit(hour / 10, 10));\n+    buf.append(Character.forDigit(hour % 10, 10));\n+    buf.append(':');\n+\n+    // Minute\n+    int minute = calendar.get(Calendar.MINUTE);\n+    buf.append(Character.forDigit(minute / 10, 10));\n+    buf.append(Character.forDigit(minute % 10, 10));\n+    buf.append(':');\n+\n+    // Second\n+    int second = calendar.get(Calendar.SECOND);\n+    buf.append(Character.forDigit(second / 10, 10));\n+    buf.append(Character.forDigit(second % 10, 10));\n+    buf.append(' ');\n+\n+    // Timezone\n+    // Get time offset in minutes\n+    int zoneOffset =(calendar.get(Calendar.ZONE_OFFSET) +\n+                     calendar.get(Calendar.DST_OFFSET)) / 60000;\n+    \n+    // Apply + or - appropriately\n+    if (zoneOffset < 0)\n+      {\n+        zoneOffset = -zoneOffset;\n+        buf.append('-');\n+      }\n+    else\n+      {\n+        buf.append('+');\n+      }\n+    \n+    // Set the 2 2-char fields as specified above\n+    int tzhours = zoneOffset / 60;\n+    buf.append(Character.forDigit(tzhours / 10, 10));\n+    buf.append(Character.forDigit(tzhours % 10, 10));\n+    int tzminutes = zoneOffset % 60;\n+    buf.append(Character.forDigit(tzminutes / 10, 10));\n+    buf.append(Character.forDigit(tzminutes % 10, 10));\n+\n+    field.setBeginIndex(0);\n+    field.setEndIndex(buf.length());\n+    return buf;\n+  }\n+\n+  /**\n+   * Parses the given date in the current TimeZone.\n+   * @param text the formatted date to be parsed\n+   * @param pos the current parse position\n+   */\n+  public Date parse(String text, ParsePosition pos)\n+  {\n+    int date, month, year, hour, minute, second;\n+    String monthText;\n+    int start = 0, end = -1;\n+    int len = text.length();\n+    calendar.clear();\n+    pos.setIndex(start);\n+    try\n+      {\n+        // Advance to date\n+        if (Character.isLetter(text.charAt(start)))\n+          {\n+            start = skipNonWhitespace(text, start);\n+          }\n+        // Determine mode\n+        switch(start)\n+          {\n+          case 3:\n+            // asctime\n+            start = skipWhitespace(text, start);\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            monthText = text.substring(start, end);\n+            month = -1;\n+            for (int i = 0; i < 12; i++)\n+              {\n+                if (MONTHS[i].equals(monthText))\n+                  {\n+                    month = i;\n+                    break;\n+                  }\n+              }\n+            if (month == -1)\n+              {\n+                pos.setErrorIndex(end);\n+                return null;\n+              }\n+            // Advance to date\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            date = Integer.parseInt(text.substring(start, end));\n+            // Advance to hour\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, ':');\n+            hour = Integer.parseInt(text.substring(start, end));\n+            // Advance to minute\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, ':');\n+            minute = Integer.parseInt(text.substring(start, end));\n+            // Advance to second\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            second = Integer.parseInt(text.substring(start, end));\n+            // Advance to year\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            year = Integer.parseInt(text.substring(start, end));\n+            break;\n+          case 0:\n+          case 4:\n+            // rfc822\n+            start = skipWhitespace(text, start);\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            date = Integer.parseInt(text.substring(start, end));\n+            // Advance to month\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            monthText = text.substring(start, end);\n+            month = -1;\n+            for (int i = 0; i < 12; i++)\n+              {\n+                if (MONTHS[i].equals(monthText))\n+                  {\n+                    month = i;\n+                    break;\n+                  }\n+              }\n+            if (month == -1)\n+              {\n+                pos.setErrorIndex(end);\n+                return null;\n+              }\n+            // Advance to year\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            year = Integer.parseInt(text.substring(start, end));\n+            // Advance to hour\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, ':');\n+            hour = Integer.parseInt(text.substring(start, end));\n+            // Advance to minute\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, ':');\n+            minute = Integer.parseInt(text.substring(start, end));\n+            // Advance to second\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = start + 1;\n+            while (end < len && !Character.isWhitespace(text.charAt(end)))\n+              {\n+                end++;\n+              }\n+            second = Integer.parseInt(text.substring(start, end));\n+            break;\n+          default:\n+            // rfc850(obsolete)\n+            start = skipWhitespace(text, start);\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, '-');\n+            date = Integer.parseInt(text.substring(start, end));\n+            // Advance to month\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, '-');\n+            monthText = text.substring(start, end);\n+            month = -1;\n+            for (int i = 0; i < 12; i++)\n+              {\n+                if (MONTHS[i].equals(monthText))\n+                  {\n+                    month = i;\n+                    break;\n+                  }\n+              }\n+            if (month == -1)\n+              {\n+                pos.setErrorIndex(end);\n+                return null;\n+              }\n+            // Advance to year\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = skipNonWhitespace(text, start + 1);\n+            year = 1900 + Integer.parseInt(text.substring(start, end));\n+            // Advance to hour\n+            start = skipWhitespace(text, end + 1);\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, ':');\n+            hour = Integer.parseInt(text.substring(start, end));\n+            // Advance to minute\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = skipTo(text, start + 1, ':');\n+            minute = Integer.parseInt(text.substring(start, end));\n+            // Advance to second\n+            start = end + 1;\n+            pos.setIndex(start);\n+            end = start + 1;\n+            while (end < len && !Character.isWhitespace(text.charAt(end)))\n+              {\n+                end++;\n+              }\n+            second = Integer.parseInt(text.substring(start, end));\n+          }\n+        \n+        calendar.set(Calendar.YEAR, year);\n+        calendar.set(Calendar.MONTH, month);\n+        calendar.set(Calendar.DAY_OF_MONTH, date);\n+        calendar.set(Calendar.HOUR, hour);\n+        calendar.set(Calendar.MINUTE, minute);\n+        calendar.set(Calendar.SECOND, second);\n+        \n+        if (end != len)\n+          {\n+            // Timezone\n+            start = skipWhitespace(text, end + 1);\n+            end = start + 1;\n+            while (end < len && !Character.isWhitespace(text.charAt(end)))\n+              {\n+                end++;\n+              }\n+            char pm = text.charAt(start);\n+            if (Character.isLetter(pm))\n+              {\n+                TimeZone tz =\n+                  TimeZone.getTimeZone(text.substring(start, end));\n+                calendar.set(Calendar.ZONE_OFFSET, tz.getRawOffset());\n+              }\n+            else\n+              {\n+                int zoneOffset = 0;\n+                zoneOffset += 600 * Character.digit(text.charAt(++start), 10);\n+                zoneOffset += 60 * Character.digit(text.charAt(++start), 10);\n+                zoneOffset += 10 * Character.digit(text.charAt(++start), 10);\n+                zoneOffset += Character.digit(text.charAt(++start), 10);\n+                zoneOffset *= 60000; // minutes -> ms\n+                if ('-' == pm)\n+                  {\n+                    zoneOffset = -zoneOffset;\n+                  }\n+                calendar.set(Calendar.ZONE_OFFSET, zoneOffset);\n+              }\n+          }\n+        pos.setIndex(end);\n+        \n+        return calendar.getTime();\n+      }\n+    catch (NumberFormatException e)\n+      {\n+        pos.setErrorIndex(Math.max(start, end));\n+      }\n+    catch (StringIndexOutOfBoundsException e)\n+      {\n+        pos.setErrorIndex(Math.max(start, end));\n+      }\n+    return null;\n+  }\n+\n+  private int skipWhitespace(String text, int pos)\n+  {\n+    while(Character.isWhitespace(text.charAt(pos)))\n+      {\n+        pos++;\n+      }\n+    return pos;    \n+  }\n+\n+  private int skipNonWhitespace(String text, int pos)\n+  {\n+    while(!Character.isWhitespace(text.charAt(pos)))\n+      {\n+        pos++;\n+      }\n+    return pos;    \n+  }\n+\n+  private int skipTo(String text, int pos, char c)\n+  {\n+    while(text.charAt(pos) != c)\n+      {\n+        pos++;\n+      }\n+    return pos;    \n+  }\n+\n+  /**\n+   * Don't allow setting the calendar.\n+   */\n+  public void setCalendar(Calendar newCalendar)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Don't allow setting the NumberFormat.\n+   */\n+  public void setNumberFormat(NumberFormat newNumberFormat)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+}\n+"}, {"sha": "b289860ebddee9aed455aa9e5acd0ad831551d4d", "filename": "libjava/gnu/java/net/protocol/http/HTTPURLConnection.java", "status": "added", "additions": 649, "deletions": 0, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHTTPURLConnection.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,649 @@\n+/* HTTPURLConnection.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.cert.Certificate;\n+import java.util.Date;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.net.ssl.HandshakeCompletedEvent;\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+/**\n+ * A URLConnection that uses the HTTPConnection class.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class HTTPURLConnection\n+  extends HttpsURLConnection\n+  implements HandshakeCompletedListener\n+{\n+\n+  /**\n+   * Pool of reusable connections, used if keepAlive is true.\n+   */\n+  private static final Map connectionPool = new LinkedHashMap();\n+\n+  /*\n+   * The underlying connection.\n+   */\n+  private HTTPConnection connection;\n+\n+  private String proxyHostname;\n+  private int proxyPort;\n+  private String agent;\n+  private boolean keepAlive;\n+  private int maxConnections;\n+\n+  private Request request;\n+  private Headers requestHeaders;\n+  private ByteArrayOutputStream requestSink;\n+  private boolean requestMethodSetExplicitly;\n+\n+  private Response response;\n+  private ByteArrayInputStream responseSink;\n+\n+  private HandshakeCompletedEvent handshakeEvent;\n+\n+  /**\n+   * Constructor.\n+   * @param url the URL\n+   */\n+  public HTTPURLConnection(URL url)\n+    throws IOException\n+  {\n+    super(url);\n+    requestHeaders = new Headers();\n+    AccessController.doPrivileged(this.new GetHTTPPropertiesAction());\n+  }\n+\n+  class GetHTTPPropertiesAction\n+    implements PrivilegedAction\n+  {\n+\n+    public Object run()\n+    {\n+      proxyHostname = System.getProperty(\"http.proxyHost\");\n+      if (proxyHostname != null && proxyHostname.length() > 0)\n+        {\n+          String port = System.getProperty(\"http.proxyPort\");\n+          if (port != null && port.length() > 0)\n+            {\n+              proxyPort = Integer.parseInt(port);\n+            }\n+          else\n+            {\n+              proxyHostname = null;\n+              proxyPort = -1;\n+            }\n+        }\n+      agent = System.getProperty(\"http.agent\");\n+      String ka = System.getProperty(\"http.keepAlive\");\n+      keepAlive = !(ka != null && \"false\".equals(ka));\n+      String mc = System.getProperty(\"http.maxConnections\");\n+      maxConnections = (mc != null && mc.length() > 0) ?\n+        Math.max(Integer.parseInt(mc), 1) : 5;\n+      return null;\n+    }\n+\n+  }\n+\n+  public void connect()\n+    throws IOException\n+  {\n+    if (connected)\n+      {\n+        return;\n+      }\n+    String protocol = url.getProtocol();\n+    boolean secure = \"https\".equals(protocol);\n+    String host = url.getHost();\n+    int port = url.getPort();\n+    if (port < 0)\n+      {\n+        port = secure ? HTTPConnection.HTTPS_PORT :\n+          HTTPConnection.HTTP_PORT;\n+      }\n+    String file = url.getFile();\n+    String username = url.getUserInfo();\n+    String password = null;\n+    if (username != null)\n+      {\n+        int ci = username.indexOf(':');\n+        if (ci != -1)\n+          {\n+            password = username.substring(ci + 1);\n+            username = username.substring(0, ci);\n+          }\n+      }\n+    final Credentials creds = (username == null) ? null :\n+      new Credentials (username, password);\n+    \n+    boolean retry;\n+    do\n+      {\n+        retry = false;\n+        if (connection == null)\n+          {\n+            connection = getConnection(host, port, secure);\n+            if (secure)\n+              {\n+                SSLSocketFactory factory = getSSLSocketFactory();\n+                HostnameVerifier verifier = getHostnameVerifier();\n+                if (factory != null)\n+                  {\n+                    connection.setSSLSocketFactory(factory);\n+                  }\n+                connection.addHandshakeCompletedListener(this);\n+                // TODO verifier\n+              }\n+          }\n+        if (proxyHostname != null)\n+          {\n+            if (proxyPort < 0)\n+              {\n+                proxyPort = secure ? HTTPConnection.HTTPS_PORT :\n+                  HTTPConnection.HTTP_PORT;\n+              }\n+            connection.setProxy(proxyHostname, proxyPort);\n+          }\n+        request = connection.newRequest(method, file);\n+        if (!keepAlive)\n+          {\n+            request.setHeader(\"Connection\", \"close\");\n+          }\n+        if (agent != null)\n+          {\n+            request.setHeader(\"User-Agent\", agent);\n+          }\n+        request.getHeaders().putAll(requestHeaders);\n+        if (requestSink != null)\n+          {\n+            byte[] content = requestSink.toByteArray();\n+            RequestBodyWriter writer = new ByteArrayRequestBodyWriter(content);\n+            request.setRequestBodyWriter(writer);\n+          }\n+        ByteArrayResponseBodyReader reader = new ByteArrayResponseBodyReader();\n+        request.setResponseBodyReader(reader);\n+        if (creds != null)\n+          {\n+            request.setAuthenticator(new Authenticator() {\n+              public Credentials getCredentials(String realm, int attempts)\n+              {\n+                return (attempts < 2) ? creds : null;\n+              }\n+            });\n+          }\n+        response = request.dispatch();\n+        if (response.getCodeClass() == 3 && getInstanceFollowRedirects())\n+          {\n+            // Follow redirect\n+            String location = response.getHeader(\"Location\");\n+            String connectionUri = connection.getURI();\n+            int start = connectionUri.length();\n+            if (location.startsWith(connectionUri) &&\n+                location.charAt(start) == '/')\n+              {\n+                file = location.substring(start);\n+                retry = true;\n+              }\n+            else if (location.startsWith(\"http:\"))\n+              {\n+                connection.close();\n+                connection = null;\n+                secure = false;\n+                start = 7;\n+                int end = location.indexOf('/', start);\n+                host = location.substring(start, end);\n+                int ci = host.lastIndexOf(':');\n+                if (ci != -1)\n+                  {\n+                    port = Integer.parseInt(host.substring (ci + 1));\n+                    host = host.substring(0, ci);\n+                  }\n+                else\n+                  {\n+                    port = HTTPConnection.HTTP_PORT;\n+                  }\n+                file = location.substring(end);\n+                retry = true;\n+              }\n+            else if (location.startsWith(\"https:\"))\n+              {\n+                connection.close();\n+                connection = null;\n+                secure = true;\n+                start = 8;\n+                int end = location.indexOf('/', start);\n+                host = location.substring(start, end);\n+                int ci = host.lastIndexOf(':');\n+                if (ci != -1)\n+                  {\n+                    port = Integer.parseInt(host.substring (ci + 1));\n+                    host = host.substring(0, ci);\n+                  }\n+                else\n+                  {\n+                    port = HTTPConnection.HTTPS_PORT;\n+                  }\n+                file = location.substring(end);\n+                retry = true;\n+              }\n+            // Otherwise this is not an HTTP redirect, can't follow\n+          }\n+        else\n+          {\n+            responseSink = new ByteArrayInputStream(reader.toByteArray ());\n+          }\n+      }\n+    while (retry);\n+    connected = true;\n+  }\n+\n+  /**\n+   * Returns a connection, from the pool if necessary.\n+   */\n+  HTTPConnection getConnection(String host, int port, boolean secure)\n+    throws IOException\n+  {\n+    HTTPConnection connection;\n+    if (keepAlive)\n+      {\n+        StringBuffer buf = new StringBuffer(secure ? \"https://\" : \"http://\");\n+        buf.append(host);\n+        buf.append(':');\n+        buf.append(port);\n+        String key = buf.toString();\n+        synchronized (connectionPool)\n+          {\n+            connection = (HTTPConnection) connectionPool.get(key);\n+            if (connection == null)\n+              {\n+                connection = new HTTPConnection(host, port, secure);\n+                // Good housekeeping\n+                if (connectionPool.size() == maxConnections)\n+                  {\n+                    // maxConnections must always be >= 1\n+                    Object lru = connectionPool.keySet().iterator().next();\n+                    connectionPool.remove(lru);\n+                  }\n+                connectionPool.put(key, connection);\n+              }\n+          }\n+      }\n+    else\n+      {\n+        connection = new HTTPConnection(host, port, secure);\n+      }\n+    return connection;\n+  }\n+\n+  public void disconnect()\n+  {\n+    if (connection != null)\n+      {\n+        try\n+          {\n+            connection.close();\n+          }\n+        catch (IOException e)\n+          {\n+          }\n+      }\n+  }\n+\n+  public boolean usingProxy()\n+  {\n+    return (proxyHostname != null);\n+  }\n+\n+  /**\n+   * Overrides the corresponding method in HttpURLConnection to permit\n+   * arbitrary methods, as long as they're valid ASCII alphabetic\n+   * characters. This is to permit WebDAV and other HTTP extensions to\n+   * function.\n+   * @param method the method\n+   */\n+  public void setRequestMethod(String method)\n+    throws ProtocolException\n+  {\n+    if (connected)\n+      {\n+        throw new ProtocolException(\"Already connected\");\n+      }\n+    // Validate\n+    method = method.toUpperCase();\n+    int len = method.length();\n+    if (len == 0)\n+      {\n+        throw new ProtocolException(\"Empty method name\");\n+      }\n+    for (int i = 0; i < len; i++)\n+      {\n+        char c = method.charAt(i);\n+        if (c < 0x41 || c > 0x5a)\n+          {\n+            throw new ProtocolException(\"Illegal character '\" + c +\n+                                        \"' at index \" + i);\n+          }\n+      }\n+    // OK\n+    this.method = method;\n+    requestMethodSetExplicitly = true;\n+  }\n+\n+  public String getRequestProperty(String key)\n+  {\n+    return requestHeaders.getValue(key);\n+  }\n+\n+  public Map getRequestProperties()\n+  {\n+    return requestHeaders;\n+  }\n+\n+  public void setRequestProperty(String key, String value)\n+  {\n+    requestHeaders.put(key, value);\n+  }\n+\n+  public void addRequestProperty(String key, String value)\n+  {\n+    String old = requestHeaders.getValue(key);\n+    if (old == null)\n+      {\n+        requestHeaders.put(key, value);\n+      }\n+    else\n+      {\n+        requestHeaders.put(key, old + \",\" + value);\n+      }\n+  }\n+\n+  public OutputStream getOutputStream()\n+    throws IOException\n+  {\n+    if (connected)\n+      {\n+        throw new ProtocolException(\"Already connected\");\n+      }\n+    if (!doOutput)\n+      {\n+        throw new ProtocolException(\"doOutput is false\");\n+      }\n+    else if (!requestMethodSetExplicitly)\n+      {\n+        /*\n+         * Silently change the method to POST if no method was set\n+         * explicitly. This is due to broken applications depending on this\n+         * behaviour (Apache XMLRPC for one).\n+         */\n+        method = \"POST\";\n+      }\n+    if (requestSink == null)\n+      {\n+        requestSink = new ByteArrayOutputStream();\n+      }\n+    return requestSink;\n+  }\n+  \n+  // -- Response --\n+  \n+  public InputStream getInputStream()\n+    throws IOException\n+  {\n+    if (!connected)\n+      {\n+        connect();\n+      }\n+    if (!doInput)\n+      {\n+        throw new ProtocolException(\"doInput is false\");\n+      }\n+    return responseSink;\n+  }\n+\n+  public Map getHeaderFields()\n+  {\n+    if (!connected)\n+      {\n+        try\n+          {\n+            connect();\n+          }\n+        catch (IOException e)\n+          {\n+            return null;\n+          }\n+      }\n+    Map headers = response.getHeaders();\n+    Map ret = new LinkedHashMap();\n+    ret.put(\"\", Collections.singletonList(getStatusLine(response)));\n+    for (Iterator i = headers.entrySet().iterator(); i.hasNext(); )\n+      {\n+        Map.Entry entry = (Map.Entry) i.next();\n+        String key = (String) entry.getKey();\n+        String value = (String) entry.getValue();\n+        ret.put(key, Collections.singletonList(value));\n+      }\n+    return ret;\n+  }\n+\n+  String getStatusLine(Response response)\n+  {\n+    return \"HTTP/\" + response.getMajorVersion() +\n+      \".\" + response.getMinorVersion() +\n+      \" \" + response.getCode() +\n+      \" \" + response.getMessage();\n+  }\n+  \n+  public String getHeaderField(int index)\n+  {\n+    if (!connected)\n+      {\n+        try\n+          {\n+            connect();\n+          }\n+        catch (IOException e)\n+          {\n+            return null;\n+          }\n+      }\n+    if (index == 0)\n+      {\n+        return getStatusLine(response);\n+      }\n+    Iterator i = response.getHeaders().entrySet().iterator();\n+    Map.Entry entry;\n+    int count = 1;\n+    do\n+      {\n+        if (!i.hasNext())\n+          {\n+            return null;\n+          }\n+        entry = (Map.Entry) i.next();\n+        count++;\n+      }\n+    while (count <= index);\n+    return (String) entry.getValue();\n+  }\n+\n+  public String getHeaderFieldKey(int index)\n+  {\n+    if (!connected)\n+      {\n+        try\n+          {\n+            connect();\n+          }\n+        catch (IOException e)\n+          {\n+            return null;\n+          }\n+      }\n+    if (index == 0)\n+      {\n+        return null;\n+      }\n+    Iterator i = response.getHeaders().entrySet().iterator();\n+    Map.Entry entry;\n+    int count = 1;\n+    do\n+      {\n+        entry = (Map.Entry) i.next();\n+        count++;\n+      }\n+    while (count <= index);\n+    return (String) entry.getKey();\n+  }\n+\n+  public String getHeaderField(String name)\n+  {\n+    if (!connected)\n+      {\n+        try\n+          {\n+            connect();\n+          }\n+        catch (IOException e)\n+          {\n+            return null;\n+          }\n+      }\n+    return (String) response.getHeader(name);\n+  }\n+\n+  public long getHeaderFieldDate(String name, long def)\n+  {\n+    if (!connected)\n+      {\n+        try\n+          {\n+            connect();\n+          }\n+        catch (IOException e)\n+          {\n+            return def;\n+          }\n+      }\n+    Date date = response.getDateHeader(name);\n+    return (date == null) ? def : date.getTime();\n+  }\n+\n+  public String getContentType()\n+  {\n+    return getHeaderField(\"Content-Type\");\n+  }\n+\n+  public int getResponseCode()\n+    throws IOException\n+  {\n+    if (!connected)\n+      {\n+        connect();\n+      }\n+    return response.getCode();\n+  }\n+\n+  public String getResponseMessage()\n+    throws IOException\n+  {\n+    if (!connected)\n+      {\n+        connect();\n+      }\n+    return response.getMessage();\n+  }\n+\n+  // -- HTTPS specific --\n+\n+  public String getCipherSuite()\n+  {\n+    if (!connected)\n+      {\n+        throw new IllegalStateException(\"not connected\");\n+      }\n+    return handshakeEvent.getCipherSuite();\n+  }\n+  \n+  public Certificate[] getLocalCertificates()\n+  {\n+    if (!connected)\n+      {\n+        throw new IllegalStateException(\"not connected\");\n+      }\n+    return handshakeEvent.getLocalCertificates();\n+  }\n+\n+  public Certificate[] getServerCertificates()\n+    throws SSLPeerUnverifiedException\n+  {\n+    if (!connected)\n+      {\n+        throw new IllegalStateException(\"not connected\");\n+      }\n+    return handshakeEvent.getPeerCertificates();\n+  }\n+\n+  // HandshakeCompletedListener\n+\n+  public void handshakeCompleted(HandshakeCompletedEvent event)\n+  {\n+    handshakeEvent = event;\n+  }\n+\n+}\n+"}, {"sha": "43ff63df9b3ea6e710d9276fd63255e092315d08", "filename": "libjava/gnu/java/net/protocol/http/Handler.java", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHandler.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -1,13 +1,13 @@\n-/* Handler.java -- HTTP protocol handler for java.net\n-   Copyright (c) 1998, 1999, 2003 Free Software Foundation, Inc.\n+/* Handler.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n-\n+ \n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.net.protocol.http;\n \n import java.io.IOException;\n@@ -43,44 +44,30 @@\n import java.net.URLStreamHandler;\n \n /**\n- * This is the protocol handler for the HTTP protocol.  It implements\n- * the abstract openConnection() method from URLStreamHandler by returning\n- * a new HttpURLConnection object (from this package).  All other \n- * methods are inherited\n+ * An HTTP URL stream handler.\n  *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Warren Levy\n- * @author Anthony Green <green@redhat.com>\n+ * @author Chris Burdess (dog@gnu.org)\n  */\n-public class Handler extends URLStreamHandler\n+public class Handler\n+  extends URLStreamHandler\n {\n-  /**\n-   * A do nothing constructor\n-   */\n-  public Handler()\n-  {\n-  }\n \n   /**\n-   * This method returs a new HttpURLConnection for the specified URL\n-   *\n-   * @param url The URL to return a connection for\n-   *\n-   * @return The URLConnection\n-   *\n-   * @exception IOException If an error occurs\n+   * Returns the default HTTP port (80).\n    */\n-  protected URLConnection openConnection (URL url) throws IOException\n+  protected int getDefaultPort()\n   {\n-    return new Connection (url);\n+    return HTTPConnection.HTTP_PORT;\n   }\n \n   /**\n-   * Returns the default port for a URL parsed by this handler.\n+   * Returns an HTTPURLConnection for the given URL.\n    */\n-  protected int getDefaultPort()\n+  public URLConnection openConnection(URL url)\n+    throws IOException\n   {\n-    return 80;\n+    return new HTTPURLConnection(url);\n   }\n \n-} // class Handler\n+}\n+"}, {"sha": "e56139f0284fa08ae4bc2ef33e508163968666f7", "filename": "libjava/gnu/java/net/protocol/http/Headers.java", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHeaders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHeaders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FHeaders.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,363 @@\n+/* Headers.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import gnu.java.net.LineInputStream;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A collection of HTTP header names and associated values.\n+ * Retrieval of values is case insensitive. An iteration over the keys\n+ * returns the header names in the order they were received.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class Headers\n+  implements Map\n+{\n+\n+  static final DateFormat dateFormat = new HTTPDateFormat();\n+\n+  static class Header\n+  {\n+\n+    final String name;\n+\n+    Header(String name)\n+    {\n+      if (name == null || name.length() == 0)\n+        {\n+          throw new IllegalArgumentException(name);\n+        }\n+      this.name = name;\n+    }\n+\n+    public int hashCode()\n+    {\n+      return name.toLowerCase().hashCode();\n+    }\n+\n+    public boolean equals(Object other)\n+    {\n+      if (other instanceof Header)\n+        {\n+          return ((Header) other).name.equalsIgnoreCase(name);\n+        }\n+      return false;\n+    }\n+\n+    public String toString()\n+    {\n+      return name;\n+    }\n+    \n+  }\n+\n+  static class HeaderEntry\n+    implements Map.Entry\n+  {\n+\n+    final Map.Entry entry;\n+\n+    HeaderEntry(Map.Entry entry)\n+    {\n+      this.entry = entry;\n+    }\n+\n+    public Object getKey()\n+    {\n+      return ((Header) entry.getKey()).name;\n+    }\n+\n+    public Object getValue()\n+    {\n+      return entry.getValue();\n+    }\n+\n+    public Object setValue(Object value)\n+    {\n+      return entry.setValue(value);\n+    }\n+\n+    public int hashCode()\n+    {\n+      return entry.hashCode();\n+    }\n+\n+    public boolean equals(Object other)\n+    {\n+      return entry.equals(other);\n+    }\n+\n+    public String toString()\n+    {\n+      return getKey().toString() + \"=\" + getValue();\n+    }\n+    \n+  }\n+\n+  private LinkedHashMap headers;\n+\n+  public Headers()\n+  {\n+    headers = new LinkedHashMap();\n+  }\n+\n+  public int size()\n+  {\n+    return headers.size();\n+  }\n+\n+  public boolean isEmpty()\n+  {\n+    return headers.isEmpty();\n+  }\n+\n+  public boolean containsKey(Object key)\n+  {\n+    return headers.containsKey(new Header((String) key));\n+  }\n+\n+  public boolean containsValue(Object value)\n+  {\n+    return headers.containsValue(value);\n+  }\n+\n+  public Object get(Object key)\n+  {\n+    return headers.get(new Header((String) key));\n+  }\n+\n+  /**\n+   * Returns the value of the specified header as a string.\n+   */\n+  public String getValue(String header)\n+  {\n+    return (String) headers.get(new Header(header));\n+  }\n+\n+  /**\n+   * Returns the value of the specified header as an integer,\n+   * or -1 if the header is not present or not an integer.\n+   */\n+  public int getIntValue(String header)\n+  {\n+    String val = getValue(header);\n+    if (val == null)\n+      {\n+        return -1;\n+      }\n+    try\n+      {\n+        return Integer.parseInt(val);\n+      }\n+    catch (NumberFormatException e)\n+      {\n+      }\n+    return -1;\n+  }\n+\n+  /**\n+   * Returns the value of the specified header as a date,\n+   * or <code>null</code> if the header is not present or not a date.\n+   */\n+  public Date getDateValue(String header)\n+  {\n+    String val = getValue(header);\n+    if (val == null)\n+      {\n+        return null;\n+      }\n+    try\n+      {\n+        return dateFormat.parse(val);\n+      }\n+    catch (ParseException e)\n+      {\n+        return null;\n+      }\n+  }\n+\n+  public Object put(Object key, Object value)\n+  {\n+    return headers.put(new Header((String) key), value);\n+  }\n+\n+  public Object remove(Object key)\n+  {\n+    return headers.remove(new Header((String) key));\n+  }\n+\n+  public void putAll(Map t)\n+  {\n+    for (Iterator i = t.keySet().iterator(); i.hasNext(); )\n+      {\n+        String key = (String) i.next();\n+        String value = (String) t.get(key);\n+        headers.put(new Header(key), value);\n+      }\n+  }\n+  \n+  public void clear()\n+  {\n+    headers.clear();\n+  }\n+\n+  public Set keySet()\n+  {\n+    Set keys = headers.keySet();\n+    Set ret = new LinkedHashSet();\n+    for (Iterator i = keys.iterator(); i.hasNext(); )\n+      {\n+        ret.add(((Header) i.next()).name);\n+      }\n+    return ret;\n+  }\n+\n+  public Collection values()\n+  {\n+    return headers.values();\n+  }\n+\n+  public Set entrySet()\n+  {\n+    Set entries = headers.entrySet();\n+    Set ret = new LinkedHashSet();\n+    for (Iterator i = entries.iterator(); i.hasNext(); )\n+      {\n+        Map.Entry entry = (Map.Entry) i.next();\n+        ret.add(new HeaderEntry(entry));\n+      }\n+    return ret;\n+  }\n+\n+  public boolean equals(Object other)\n+  {\n+    return headers.equals(other);\n+  }\n+\n+  public int hashCode()\n+  {\n+    return headers.hashCode();\n+  }\n+\n+  /**\n+   * Parse the specified input stream, adding headers to this collection.\n+   */\n+  public void parse(InputStream in)\n+    throws IOException\n+  {\n+    LineInputStream lin = (in instanceof LineInputStream) ?\n+      (LineInputStream) in : new LineInputStream(in);\n+    \n+    String name = null;\n+    StringBuffer value = new StringBuffer();\n+    while (true)\n+      {\n+        String line = lin.readLine();\n+        if (line == null)\n+          {\n+            if (name != null)\n+              {\n+                addValue(name, value.toString());\n+              }\n+            break;\n+          }\n+        int len = line.length();\n+        if (len < 2)\n+          {\n+            if (name != null)\n+              {\n+                addValue(name, value.toString());\n+              }\n+            break;\n+          }\n+        char c1 = line.charAt(0);\n+        if (c1 == ' ' || c1 == '\\t')\n+          {\n+            // Continuation\n+            value.append(line.substring(0, len - 1));\n+          }\n+        else\n+          {\n+            if (name != null)\n+              {\n+                addValue(name, value.toString());\n+              }\n+            \n+            int di = line.indexOf(':');\n+            name = line.substring(0, di);\n+            value.setLength(0);\n+            do\n+              {\n+                di++;\n+              }\n+            while (di < len && line.charAt(di) == ' ');\n+            value.append(line.substring(di, len - 1));\n+          }\n+      }\n+  }\n+  \n+  private void addValue(String name, String value)\n+  {\n+    Header key = new Header(name);\n+    String old = (String) headers.get(key);\n+    if (old == null)\n+      {\n+        headers.put(key, value);\n+      }\n+    else\n+      {\n+        headers.put(key, old + \", \" + value);\n+      }\n+  }\n+  \n+}\n+"}, {"sha": "123e889c065ada96e2ba11025a9833acd0e549ea", "filename": "libjava/gnu/java/net/protocol/http/Request.java", "status": "added", "additions": 915, "deletions": 0, "changes": 915, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FRequest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FRequest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FRequest.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,915 @@\n+/* Request.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import gnu.java.net.protocol.http.event.RequestEvent;\n+import gnu.java.net.BASE64;\n+import gnu.java.net.LineInputStream;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.Socket;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.InflaterInputStream;\n+\n+/**\n+ * A single HTTP request.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class Request\n+{\n+\n+  /**\n+   * The connection context in which this request is invoked.\n+   */\n+  protected final HTTPConnection connection;\n+\n+  /**\n+   * The HTTP method to invoke.\n+   */\n+  protected final String method;\n+\n+  /**\n+   * The path identifying the resource.\n+   * This string must conform to the abs_path definition given in RFC2396,\n+   * with an optional \"?query\" part, and must be URI-escaped by the caller.\n+   */\n+  protected final String path;\n+\n+  /**\n+   * The headers in this request.\n+   */\n+  protected final Headers requestHeaders;\n+\n+  /**\n+   * The request body provider.\n+   */\n+  protected RequestBodyWriter requestBodyWriter;\n+\n+  /**\n+   * Request body negotiation threshold for 100-continue expectations.\n+   */\n+  protected int requestBodyNegotiationThreshold;\n+\n+  /**\n+   * The response body reader.\n+   */\n+  protected ResponseBodyReader responseBodyReader;\n+\n+  /**\n+   * Map of response header handlers.\n+   */\n+  protected Map responseHeaderHandlers;\n+\n+  /**\n+   * The authenticator.\n+   */\n+  protected Authenticator authenticator;\n+\n+  /**\n+   * Whether this request has been dispatched yet.\n+   */\n+  private boolean dispatched;\n+\n+  /**\n+   * Constructor for a new request.\n+   * @param connection the connection context\n+   * @param method the HTTP method\n+   * @param path the resource path including query part\n+   */\n+  protected Request(HTTPConnection connection, String method,\n+                    String path)\n+  {\n+    this.connection = connection;\n+    this.method = method;\n+    this.path = path;\n+    requestHeaders = new Headers();\n+    responseHeaderHandlers = new HashMap();\n+    requestBodyNegotiationThreshold = 4096;\n+  }\n+\n+  /**\n+   * Returns the connection associated with this request.\n+   * @see #connection\n+   */\n+  public HTTPConnection getConnection()\n+  {\n+    return connection;\n+  }\n+\n+  /**\n+   * Returns the HTTP method to invoke.\n+   * @see #method\n+   */\n+  public String getMethod()\n+  {\n+    return method;\n+  }\n+\n+  /**\n+   * Returns the resource path.\n+   * @see #path\n+   */\n+  public String getPath()\n+  {\n+    return path;\n+  }\n+\n+  /**\n+   * Returns the full request-URI represented by this request, as specified\n+   * by HTTP/1.1.\n+   */\n+  public String getRequestURI()\n+  {\n+    return connection.getURI() + path;\n+  }\n+\n+  /**\n+   * Returns the headers in this request.\n+   */\n+  public Headers getHeaders()\n+  {\n+    return requestHeaders;\n+  }\n+\n+  /**\n+   * Returns the value of the specified header in this request.\n+   * @param name the header name\n+   */\n+  public String getHeader(String name)\n+  {\n+    return requestHeaders.getValue(name);\n+  }\n+\n+  /**\n+   * Returns the value of the specified header in this request as an integer.\n+   * @param name the header name\n+   */\n+  public int getIntHeader(String name)\n+  {\n+    return requestHeaders.getIntValue(name);\n+  }\n+\n+  /**\n+   * Returns the value of the specified header in this request as a date.\n+   * @param name the header name\n+   */\n+  public Date getDateHeader(String name)\n+  {\n+    return requestHeaders.getDateValue(name);\n+  }\n+\n+  /**\n+   * Sets the specified header in this request.\n+   * @param name the header name\n+   * @param value the header value\n+   */\n+  public void setHeader(String name, String value)\n+  {\n+    requestHeaders.put(name, value);\n+  }\n+\n+  /**\n+   * Convenience method to set the entire request body.\n+   * @param requestBody the request body content\n+   */\n+  public void setRequestBody(byte[] requestBody)\n+  {\n+    setRequestBodyWriter(new ByteArrayRequestBodyWriter(requestBody));\n+  }\n+\n+  /**\n+   * Sets the request body provider.\n+   * @param requestBodyWriter the handler used to obtain the request body\n+   */\n+  public void setRequestBodyWriter(RequestBodyWriter requestBodyWriter)\n+  {\n+    this.requestBodyWriter = requestBodyWriter;\n+  }\n+\n+  /**\n+   * Sets the response body reader.\n+   * @param responseBodyReader the handler to receive notifications of\n+   * response body content\n+   */\n+  public void setResponseBodyReader(ResponseBodyReader responseBodyReader)\n+  {\n+    this.responseBodyReader = responseBodyReader;\n+  }\n+\n+  /**\n+   * Sets a callback handler to be invoked for the specified header name.\n+   * @param name the header name\n+   * @param handler the handler to receive the value for the header\n+   */\n+  public void setResponseHeaderHandler(String name,\n+                                       ResponseHeaderHandler handler)\n+  {\n+    responseHeaderHandlers.put(name, handler);\n+  }\n+\n+  /**\n+   * Sets an authenticator that can be used to handle authentication\n+   * automatically.\n+   * @param authenticator the authenticator\n+   */\n+  public void setAuthenticator(Authenticator authenticator)\n+  {\n+    this.authenticator = authenticator;\n+  }\n+\n+  /**\n+   * Sets the request body negotiation threshold.\n+   * If this is set, it determines the maximum size that the request body\n+   * may be before body negotiation occurs(via the\n+   * <code>100-continue</code> expectation). This ensures that a large\n+   * request body is not sent when the server wouldn't have accepted it\n+   * anyway.\n+   * @param threshold the body negotiation threshold, or &lt;=0 to disable\n+   * request body negotation entirely\n+   */\n+  public void setRequestBodyNegotiationThreshold(int threshold)\n+  {\n+    requestBodyNegotiationThreshold = threshold;\n+  }\n+\n+  /**\n+   * Dispatches this request.\n+   * A request can only be dispatched once; calling this method a second\n+   * time results in a protocol exception.\n+   * @exception IOException if an I/O error occurred\n+   * @return an HTTP response object representing the result of the operation\n+   */\n+  public Response dispatch()\n+    throws IOException\n+  {\n+    if (dispatched)\n+      {\n+        throw new ProtocolException(\"request already dispatched\");\n+      }\n+    final String CRLF = \"\\r\\n\";\n+    final String HEADER_SEP = \": \";\n+    final String US_ASCII = \"US-ASCII\";\n+    final String version = connection.getVersion();\n+    Response response;\n+    int contentLength = -1;\n+    boolean retry = false;\n+    int attempts = 0;\n+    boolean expectingContinue = false;\n+    if (requestBodyWriter != null)\n+      {\n+        contentLength = requestBodyWriter.getContentLength();\n+        if (contentLength > requestBodyNegotiationThreshold)\n+          {\n+            expectingContinue = true;\n+            setHeader(\"Expect\", \"100-continue\");\n+          }\n+        else\n+          {\n+            setHeader(\"Content-Length\", Integer.toString(contentLength));\n+          }\n+      }\n+    \n+    try\n+      {\n+        // Loop while authentication fails or continue\n+        do\n+          {\n+            retry = false;\n+            // Send request\n+            connection.fireRequestEvent(RequestEvent.REQUEST_SENDING, this);\n+            \n+            // Get socket output and input streams\n+            OutputStream out = connection.getOutputStream();\n+            LineInputStream in =\n+              new LineInputStream(connection.getInputStream());\n+            // Request line\n+            String requestUri = path;\n+            if (connection.isUsingProxy() &&\n+                !\"*\".equals(requestUri) &&\n+                !\"CONNECT\".equals(method))\n+              {\n+                requestUri = getRequestURI();\n+              }\n+            String line = method + ' ' + requestUri + ' ' + version + CRLF;\n+            out.write(line.getBytes(US_ASCII));\n+            // Request headers\n+            for (Iterator i = requestHeaders.keySet().iterator();\n+                 i.hasNext(); )\n+              {\n+                String name =(String) i.next();\n+                String value =(String) requestHeaders.get(name);\n+                line = name + HEADER_SEP + value + CRLF;\n+                out.write(line.getBytes(US_ASCII));\n+              }\n+            out.write(CRLF.getBytes(US_ASCII));\n+            // Request body\n+            if (requestBodyWriter != null && !expectingContinue)\n+              {\n+                byte[] buffer = new byte[4096];\n+                int len;\n+                int count = 0;\n+                \n+                requestBodyWriter.reset();\n+                do\n+                  {\n+                    len = requestBodyWriter.write(buffer);\n+                    if (len > 0)\n+                      {\n+                        out.write(buffer, 0, len);\n+                      }\n+                    count += len;\n+                  }\n+                while (len > -1 && count < contentLength);\n+                out.write(CRLF.getBytes(US_ASCII));\n+              }\n+            out.flush();\n+            // Sent event\n+            connection.fireRequestEvent(RequestEvent.REQUEST_SENT, this);\n+            // Get response\n+            response = readResponse(in);\n+            int sc = response.getCode();\n+            if (sc == 401 && authenticator != null)\n+              {\n+                if (authenticate(response, attempts++))\n+                  {\n+                    retry = true;\n+                  }\n+              }\n+            else if (sc == 100 && expectingContinue)\n+              {\n+                requestHeaders.remove(\"Expect\");\n+                setHeader(\"Content-Length\", Integer.toString(contentLength));\n+                expectingContinue = false;\n+                retry = true;\n+              }\n+          }\n+        while (retry);\n+      }\n+    catch (IOException e)\n+      {\n+        connection.close();\n+        throw e;\n+      }\n+    return response;\n+  }\n+    \n+  Response readResponse(LineInputStream in)\n+    throws IOException\n+  {\n+    String line;\n+    int len;\n+    \n+    // Read response status line\n+    line = in.readLine();\n+    if (line == null)\n+      {\n+        throw new ProtocolException(\"Peer closed connection\");\n+      }\n+    if (!line.startsWith(\"HTTP/\"))\n+      {\n+        throw new ProtocolException(line);\n+      }\n+    len = line.length();\n+    int start = 5, end = 6;\n+    while (line.charAt(end) != '.')\n+      {\n+        end++;\n+      }\n+    int majorVersion = Integer.parseInt(line.substring(start, end));\n+    start = end + 1;\n+    end = start + 1;\n+    while (line.charAt(end) != ' ')\n+      {\n+        end++;\n+      }\n+    int minorVersion = Integer.parseInt(line.substring(start, end));\n+    start = end + 1;\n+    end = start + 3;\n+    int code = Integer.parseInt(line.substring(start, end));\n+    String message = line.substring(end + 1, len - 1);\n+    // Read response headers\n+    Headers responseHeaders = new Headers();\n+    responseHeaders.parse(in);\n+    notifyHeaderHandlers(responseHeaders);\n+    // Construct response\n+    int codeClass = code / 100;\n+    Response ret = new Response(majorVersion, minorVersion, code,\n+                                codeClass, message, responseHeaders);\n+    switch (code)\n+      {\n+      case 204:\n+      case 205:\n+        break;\n+      default:\n+        // Does response body reader want body?\n+        boolean notify = (responseBodyReader != null);\n+        if (notify)\n+          {\n+            if (!responseBodyReader.accept(this, ret))\n+              {\n+                notify = false;\n+              }\n+          }\n+        readResponseBody(ret, in, notify);\n+      }\n+    return ret;\n+  }\n+\n+  void notifyHeaderHandlers(Headers headers)\n+  {\n+    for (Iterator i = headers.entrySet().iterator(); i.hasNext(); )\n+      {\n+        Map.Entry entry = (Map.Entry) i.next();\n+        String name =(String) entry.getKey();\n+        // Handle Set-Cookie\n+        if (\"Set-Cookie\".equalsIgnoreCase(name))\n+          {\n+            String value = (String) entry.getValue();\n+            handleSetCookie(value);\n+          }\n+        ResponseHeaderHandler handler =\n+          (ResponseHeaderHandler) responseHeaderHandlers.get(name);\n+        if (handler != null)\n+          {\n+            String value = (String) entry.getValue();\n+            handler.setValue(value);\n+          }\n+      }\n+  }\n+\n+  void readResponseBody(Response response, InputStream in,\n+                        boolean notify)\n+    throws IOException\n+  {\n+    byte[] buffer = new byte[4096];\n+    int contentLength = -1;\n+    Headers trailer = null;\n+    \n+    String transferCoding = response.getHeader(\"Transfer-Encoding\");\n+    if (\"chunked\".equalsIgnoreCase(transferCoding))\n+      {\n+        trailer = new Headers();\n+        in = new ChunkedInputStream(in, trailer);\n+      } \n+    else\n+      {\n+        contentLength = response.getIntHeader(\"Content-Length\");\n+      }\n+    String contentCoding = response.getHeader(\"Content-Encoding\");\n+    if (contentCoding != null && !\"identity\".equals(contentCoding))\n+      {\n+        if (\"gzip\".equals(contentCoding))\n+          {\n+            in = new GZIPInputStream(in);\n+          }\n+        else if (\"deflate\".equals(contentCoding))\n+          {\n+            in = new InflaterInputStream(in);\n+          }\n+        else\n+          {\n+            throw new ProtocolException(\"Unsupported Content-Encoding: \" +\n+                                        contentCoding);\n+          }\n+      }\n+    \n+    // Persistent connections are the default in HTTP/1.1\n+    boolean doClose = \"close\".equalsIgnoreCase(getHeader(\"Connection\")) ||\n+      \"close\".equalsIgnoreCase(response.getHeader(\"Connection\")) ||\n+      (connection.majorVersion == 1 && connection.minorVersion == 0) ||\n+      (response.majorVersion == 1 && response.minorVersion == 0);\n+    \n+    int count = contentLength;\n+    int len = (count > -1) ? count : buffer.length;\n+    len = (len > buffer.length) ? buffer.length : len;\n+    while (len > -1)\n+      {\n+        len = in.read(buffer, 0, len);\n+        if (len < 0)\n+          {\n+            // EOF\n+            connection.closeConnection();\n+            break;\n+          }\n+        if (notify)\n+          {\n+            responseBodyReader.read(buffer, 0, len);\n+          }\n+        if (count > -1)\n+          {\n+            count -= len;\n+            if (count < 1)\n+              {\n+                if (doClose)\n+                  {\n+                    connection.closeConnection();\n+                  }\n+                break;\n+              }\n+          }\n+      }\n+    if (notify)\n+      {\n+        responseBodyReader.close();\n+      }\n+    if (trailer != null)\n+      {\n+        response.getHeaders().putAll(trailer);\n+        notifyHeaderHandlers(trailer);\n+      }\n+  }\n+\n+  boolean authenticate(Response response, int attempts)\n+    throws IOException\n+  {\n+    String challenge = response.getHeader(\"WWW-Authenticate\");\n+    if (challenge == null)\n+      {\n+        challenge = response.getHeader(\"Proxy-Authenticate\");\n+      }\n+    int si = challenge.indexOf(' ');\n+    String scheme = (si == -1) ? challenge : challenge.substring(0, si);\n+    if (\"Basic\".equalsIgnoreCase(scheme))\n+      {\n+        Properties params = parseAuthParams(challenge.substring(si + 1));\n+        String realm = params.getProperty(\"realm\");\n+        Credentials creds = authenticator.getCredentials(realm, attempts);\n+        String userPass = creds.getUsername() + ':' + creds.getPassword();\n+        byte[] b_userPass = userPass.getBytes(\"US-ASCII\");\n+        byte[] b_encoded = BASE64.encode(b_userPass);\n+        String authorization =\n+          scheme + \" \" + new String(b_encoded, \"US-ASCII\");\n+        setHeader(\"Authorization\", authorization);\n+        return true;\n+      }\n+    else if (\"Digest\".equalsIgnoreCase(scheme))\n+      {\n+        Properties params = parseAuthParams(challenge.substring(si + 1));\n+        String realm = params.getProperty(\"realm\");\n+        String nonce = params.getProperty(\"nonce\");\n+        String qop = params.getProperty(\"qop\");\n+        String algorithm = params.getProperty(\"algorithm\");\n+        String digestUri = getRequestURI();\n+        Credentials creds = authenticator.getCredentials(realm, attempts);\n+        String username = creds.getUsername();\n+        String password = creds.getPassword();\n+        connection.incrementNonce(nonce);\n+        try\n+          {\n+            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n+            final byte[] COLON = { 0x3a };\n+            \n+            // Calculate H(A1)\n+            md5.reset();\n+            md5.update(username.getBytes(\"US-ASCII\"));\n+            md5.update(COLON);\n+            md5.update(realm.getBytes(\"US-ASCII\"));\n+            md5.update(COLON);\n+            md5.update(password.getBytes(\"US-ASCII\"));\n+            byte[] ha1 = md5.digest();\n+            if (\"md5-sess\".equals(algorithm))\n+              {\n+                byte[] cnonce = generateNonce();\n+                md5.reset();\n+                md5.update(ha1);\n+                md5.update(COLON);\n+                md5.update(nonce.getBytes(\"US-ASCII\"));\n+                md5.update(COLON);\n+                md5.update(cnonce);\n+                ha1 = md5.digest();\n+              }\n+            String ha1Hex = toHexString(ha1);\n+            \n+            // Calculate H(A2)\n+            md5.reset();\n+            md5.update(method.getBytes(\"US-ASCII\"));\n+            md5.update(COLON);\n+            md5.update(digestUri.getBytes(\"US-ASCII\"));\n+            if (\"auth-int\".equals(qop))\n+              {\n+                byte[] hEntity = null; // TODO hash of entity body\n+                md5.update(COLON);\n+                md5.update(hEntity);\n+              }\n+            byte[] ha2 = md5.digest();\n+            String ha2Hex = toHexString(ha2);\n+            \n+            // Calculate response\n+            md5.reset();\n+            md5.update(ha1Hex.getBytes(\"US-ASCII\"));\n+            md5.update(COLON);\n+            md5.update(nonce.getBytes(\"US-ASCII\"));\n+            if (\"auth\".equals(qop) || \"auth-int\".equals(qop))\n+              {\n+                String nc = getNonceCount(nonce);\n+                byte[] cnonce = generateNonce();\n+                md5.update(COLON);\n+                md5.update(nc.getBytes(\"US-ASCII\"));\n+                md5.update(COLON);\n+                md5.update(cnonce);\n+                md5.update(COLON);\n+                md5.update(qop.getBytes(\"US-ASCII\"));\n+              }\n+            md5.update(COLON);\n+            md5.update(ha2Hex.getBytes(\"US-ASCII\"));\n+            String digestResponse = toHexString(md5.digest());\n+            \n+            String authorization = scheme + \n+              \" username=\\\"\" + username + \"\\\"\" +\n+              \" realm=\\\"\" + realm + \"\\\"\" +\n+              \" nonce=\\\"\" + nonce + \"\\\"\" +\n+              \" uri=\\\"\" + digestUri + \"\\\"\" +\n+              \" response=\\\"\" + digestResponse + \"\\\"\";\n+            setHeader(\"Authorization\", authorization);\n+            return true;\n+          }\n+        catch (NoSuchAlgorithmException e)\n+          {\n+            return false;\n+          }\n+      }\n+    // Scheme not recognised\n+    return false;\n+  }\n+\n+  Properties parseAuthParams(String text)\n+  {\n+    int len = text.length();\n+    String key = null;\n+    StringBuffer buf = new StringBuffer();\n+    Properties ret = new Properties();\n+    boolean inQuote = false;\n+    for (int i = 0; i < len; i++)\n+      {\n+        char c = text.charAt(i);\n+        if (c == '\"')\n+          {\n+            inQuote = !inQuote;\n+          }\n+        else if (c == '=' && key == null)\n+          {\n+            key = buf.toString().trim();\n+            buf.setLength(0);\n+          }\n+        else if (c == ' ' && !inQuote)\n+          {\n+            String value = unquote(buf.toString().trim());\n+            ret.put(key, value);\n+            key = null;\n+            buf.setLength(0);\n+          }\n+        else if (c != ',' || (i <(len - 1) && text.charAt(i + 1) != ' '))\n+          {   \n+            buf.append(c);\n+          }\n+      }\n+    if (key != null)\n+      {\n+        String value = unquote(buf.toString().trim());\n+        ret.put(key, value);\n+      }\n+    return ret;\n+  }\n+\n+  String unquote(String text)\n+  {\n+    int len = text.length();\n+    if (len > 0 && text.charAt(0) == '\"' && text.charAt(len - 1) == '\"')\n+      {\n+        return text.substring(1, len - 1);\n+      }\n+    return text;\n+  }\n+\n+  /**\n+   * Returns the number of times the specified nonce value has been seen.\n+   * This always returns an 8-byte 0-padded hexadecimal string.\n+   */\n+  String getNonceCount(String nonce)\n+  {\n+    int nc = connection.getNonceCount(nonce);\n+    String hex = Integer.toHexString(nc);\n+    StringBuffer buf = new StringBuffer();\n+    for (int i = 8 - hex.length(); i > 0; i--)\n+      {\n+        buf.append('0');\n+      }\n+    buf.append(hex);\n+    return buf.toString();\n+  }\n+\n+  /**\n+   * Client nonce value.\n+   */\n+  byte[] nonce;\n+\n+  /**\n+   * Generates a new client nonce value.\n+   */\n+  byte[] generateNonce()\n+    throws IOException, NoSuchAlgorithmException\n+  {\n+    if (nonce == null)\n+      {\n+        long time = System.currentTimeMillis();\n+        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n+        md5.update(Long.toString(time).getBytes(\"US-ASCII\"));\n+        nonce = md5.digest();\n+      }\n+    return nonce;\n+  }\n+\n+  String toHexString(byte[] bytes)\n+  {\n+    char[] ret = new char[bytes.length * 2];\n+    for (int i = 0, j = 0; i < bytes.length; i++)\n+      {\n+        int c =(int) bytes[i];\n+        if (c < 0)\n+          {\n+            c += 0x100;\n+          }\n+        ret[j++] = Character.forDigit(c / 0x10, 0x10);\n+        ret[j++] = Character.forDigit(c % 0x10, 0x10);\n+      }\n+    return new String(ret);\n+  }\n+\n+  /**\n+   * Parse the specified cookie list and notify the cookie manager.\n+   */\n+  void handleSetCookie(String text)\n+  {\n+    CookieManager cookieManager = connection.getCookieManager();\n+    if (cookieManager == null)\n+      {\n+        return;\n+      }\n+    String name = null;\n+    String value = null;\n+    String comment = null;\n+    String domain = connection.getHostName();\n+    String path = this.path;\n+    int lsi = path.lastIndexOf('/');\n+    if (lsi != -1)\n+      {\n+        path = path.substring(0, lsi);\n+      }\n+    boolean secure = false;\n+    Date expires = null;\n+\n+    int len = text.length();\n+    String attr = null;\n+    StringBuffer buf = new StringBuffer();\n+    boolean inQuote = false;\n+    for (int i = 0; i <= len; i++)\n+      {\n+        char c =(i == len) ? '\\u0000' : text.charAt(i);\n+        if (c == '\"')\n+          {\n+            inQuote = !inQuote;\n+          }\n+        else if (!inQuote)\n+          {\n+            if (c == '=' && attr == null)\n+              {\n+                attr = buf.toString().trim();\n+                buf.setLength(0);\n+              }\n+            else if (c == ';' || i == len || c == ',')\n+              {\n+                String val = unquote(buf.toString().trim());\n+                if (name == null)\n+                  {\n+                    name = attr;\n+                    value = val;\n+                  }\n+                else if (\"Comment\".equalsIgnoreCase(attr))\n+                  {\n+                    comment = val;\n+                  }\n+                else if (\"Domain\".equalsIgnoreCase(attr))\n+                  {\n+                    domain = val;\n+                  }\n+                else if (\"Path\".equalsIgnoreCase(attr))\n+                  {\n+                    path = val;\n+                  }\n+                else if (\"Secure\".equalsIgnoreCase(val))\n+                  {\n+                    secure = true;\n+                  }\n+                else if (\"Max-Age\".equalsIgnoreCase(attr))\n+                  {\n+                    int delta = Integer.parseInt(val);\n+                    Calendar cal = Calendar.getInstance();\n+                    cal.setTimeInMillis(System.currentTimeMillis());\n+                    cal.add(Calendar.SECOND, delta);\n+                    expires = cal.getTime();\n+                  }\n+                else if (\"Expires\".equalsIgnoreCase(attr))\n+                  {\n+                    DateFormat dateFormat = new HTTPDateFormat();\n+                    try\n+                      {\n+                        expires = dateFormat.parse(val);\n+                      }\n+                    catch (ParseException e)\n+                      {\n+                        // if this isn't a valid date, it may be that\n+                        // the value was returned unquoted; in that case, we\n+                        // want to continue buffering the value\n+                        buf.append(c);\n+                        continue;\n+                      }\n+                  }\n+                attr = null;\n+                buf.setLength(0);\n+                // case EOL\n+                if (i == len || c == ',')\n+                  {\n+                    Cookie cookie = new Cookie(name, value, comment, domain,\n+                                               path, secure, expires);\n+                    cookieManager.setCookie(cookie);\n+                  }\n+                if (c == ',')\n+                  {\n+                    // Reset cookie fields\n+                    name = null;\n+                    value = null;\n+                    comment = null;\n+                    domain = connection.getHostName();\n+                    path = this.path;\n+                    if (lsi != -1)\n+                      {\n+                        path = path.substring(0, lsi);\n+                      }\n+                    secure = false;\n+                    expires = null;\n+                  }\n+              }\n+            else\n+              {\n+                buf.append(c);\n+              }\n+          }\n+        else\n+          {\n+            buf.append(c);\n+          }\n+      }\n+  }\n+\n+}\n+"}, {"sha": "c977451c36e607c6aa1a7491c1e2bbe1c46174f7", "filename": "libjava/gnu/java/net/protocol/http/RequestBodyWriter.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FRequestBodyWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FRequestBodyWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FRequestBodyWriter.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,69 @@\n+/* RequestBodyWriter.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Callback interface for writing request body content.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface RequestBodyWriter\n+{\n+\n+  /**\n+   * Returns the total number of bytes that will be written in a single pass\n+   * by this writer.\n+   */\n+  int getContentLength();\n+\n+  /**\n+   * Initialises the writer.\n+   * This will be called before each pass.\n+   */\n+  void reset();\n+\n+  /**\n+   * Writes body content to the supplied buffer.\n+   * @param buffer the content buffer\n+   * @return the number of bytes written\n+   */\n+  int write(byte[] buffer);\n+  \n+}\n+"}, {"sha": "5a0a618f876c22540081695e4305d9fdee1b9a10", "filename": "libjava/gnu/java/net/protocol/http/Response.java", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponse.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponse.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponse.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,185 @@\n+/* Response.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import java.util.Date;\n+\n+/**\n+ * An HTTP response.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class Response\n+{\n+\n+  /**\n+   * The HTTP major version of the server issuing the response.\n+   */\n+  protected final int majorVersion;\n+\n+  /**\n+   * The HTTP minor version of the server issuing the response.\n+   */\n+  protected final int minorVersion;\n+\n+  /**\n+   * The HTTP status code of the response.\n+   */ \n+  protected final int code;\n+\n+  /**\n+   * The class of the response. This is the most significant digit of the\n+   * status code.\n+   * <dl>\n+   * <dt><code>1xx</code></dt> <dd>Informational response</dd>\n+   * <dt><code>2xx</code></dt> <dd>Success</dd>\n+   * <dt><code>3xx</code></dt> <dd>Redirection</dd>\n+   * <dt><code>4xx</code></dt> <dd>Client error</dd>\n+   * <dt><code>5xx</code></dt> <dd>Server error</dd>\n+   * </dl>\n+   */\n+  protected final int codeClass;\n+\n+  /**\n+   * Human-readable text of the response.\n+   */\n+  protected final String message;\n+\n+  /**\n+   * The response headers.\n+   */\n+  protected final Headers headers;\n+\n+  /**\n+   * Constructs a new response with the specified parameters.\n+   */\n+  protected Response(int majorVersion, int minorVersion, int code,\n+                     int codeClass, String message,\n+                     Headers headers)\n+  {\n+    this.majorVersion = majorVersion;\n+    this.minorVersion = minorVersion;\n+    this.code = code;\n+    this.codeClass = codeClass;\n+    this.message = message;\n+    this.headers = headers;\n+  }\n+\n+  /**\n+   * Returns the HTTP major version of the server issuing the response.\n+   * @see #majorVersion\n+   */\n+  public int getMajorVersion()\n+  {\n+    return majorVersion;\n+  }\n+\n+  /**\n+   * Returns the HTTP minor version of the server issuing the response.\n+   * @see #minorVersion\n+   */\n+  public int getMinorVersion()\n+  {\n+    return minorVersion;\n+  }\n+\n+  /**\n+   * Returns the HTTP status code of the response.\n+   * @see #code\n+   */ \n+  public int getCode()\n+  {\n+    return code;\n+  }\n+\n+  /**\n+   * Returns the class of the response.\n+   * @see #codeClass\n+   */\n+  public int getCodeClass()\n+  {\n+    return codeClass;\n+  }\n+\n+  /**\n+   * Returns the human-readable text of the response.\n+   * @see #message\n+   */\n+  public String getMessage()\n+  {\n+    return message;\n+  }\n+\n+  /**\n+   * Returns the headers in the response.\n+   */\n+  public Headers getHeaders()\n+  {\n+    return headers;\n+  }\n+\n+  /**\n+   * Returns the header value for the specified name.\n+   * @param name the header name\n+   */\n+  public String getHeader(String name)\n+  {\n+    return headers.getValue(name);\n+  }\n+\n+  /**\n+   * Returns the header value for the specified name as an integer.\n+   * @param name the header name\n+   */\n+  public int getIntHeader(String name)\n+  {\n+    return headers.getIntValue(name);\n+  }\n+\n+  /**\n+   * Returns the header value for the specified name as a date.\n+   * @param name the header name\n+   */\n+  public Date getDateHeader(String name)\n+  {\n+    return headers.getDateValue(name);\n+  }\n+\n+}\n+"}, {"sha": "dea3ce9bb7384429f7f1597d2c1eb9f264e7db4b", "filename": "libjava/gnu/java/net/protocol/http/ResponseBodyReader.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponseBodyReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponseBodyReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponseBodyReader.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,70 @@\n+/* ResponseBodyReader.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Callback interface for receiving notification of response body content.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface ResponseBodyReader\n+{\n+\n+  /**\n+   * Indicate whether this reader is interested in the specified response.\n+   * If it returns false, it will not receive body content notifications for\n+   * that response.\n+   */ \n+  boolean accept(Request request, Response response);\n+\n+  /**\n+   * Receive notification of body content.\n+   * @param buffer the content buffer\n+   * @param offset the offset within the buffer that content starts\n+   * @param length the length of the content\n+   */\n+  void read(byte[] buffer, int offset, int length);\n+\n+  /**\n+   * Notifies the reader that the end of the content was reached.\n+   */\n+  void close();\n+  \n+}\n+"}, {"sha": "ea0112076de2ad3d1d3685b2671968c355348770", "filename": "libjava/gnu/java/net/protocol/http/ResponseHeaderHandler.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponseHeaderHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponseHeaderHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FResponseHeaderHandler.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,57 @@\n+/* ResponseHeaderHandler.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+/**\n+ * Callback interface for objects that wish to be notified of response\n+ * header values.\n+ * @see Request#setHeaderHandler(String)\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface ResponseHeaderHandler\n+{\n+\n+  /**\n+   * Sets the value for the header associated with this handler.\n+   */\n+  void setValue(String value);\n+  \n+}\n+"}, {"sha": "19649074a998fef8c1e7871f7460533981daf06f", "filename": "libjava/gnu/java/net/protocol/http/SimpleCookieManager.java", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FSimpleCookieManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FSimpleCookieManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FSimpleCookieManager.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,140 @@\n+/* CookieManager.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A simple non-persistent cookie manager. This class can be extended to\n+ * provide cookie persistence.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class SimpleCookieManager\n+  implements CookieManager\n+{\n+\n+  /**\n+   * The cookie cache.\n+   * This is a dictionary mapping domains to maps of cookies by name.\n+   */\n+  protected Map cookies;\n+\n+  /**\n+   * Constructor.\n+   */\n+  public SimpleCookieManager()\n+  {\n+    cookies = new HashMap();\n+  }\n+\n+  public void setCookie(Cookie cookie)\n+  {\n+    String domain = cookie.getDomain();\n+    Map map =(Map) cookies.get(domain);\n+    if (map == null)\n+      {\n+        map = new HashMap();\n+        cookies.put(domain, map);\n+      }\n+    String name = cookie.getName();\n+    map.put(name, cookie); // will replace a cookie of the same name\n+  }\n+\n+  public Cookie[] getCookies(String host, boolean secure, String path)\n+  {\n+    List matches = new ArrayList();\n+    Date now = new Date();\n+    if (Character.isLetter(host.charAt(0)))\n+      {\n+        int di = host.indexOf('.');\n+        while (di != -1)\n+          {\n+            addCookies(matches, host, secure, path, now);\n+            host = host.substring(di);\n+            di = host.indexOf('.', 1);\n+          }\n+      }\n+    addCookies(matches, host, secure, path, now);\n+    Cookie[] ret = new Cookie[matches.size()];\n+    matches.toArray(ret);\n+    return ret;\n+  }\n+\n+  private void addCookies(List matches, String domain, boolean secure,\n+                          String path, Date now)\n+  {\n+    Map map = (Map) cookies.get(domain);\n+    if (map != null)\n+      {\n+        List expired = new ArrayList();\n+        for (Iterator i = map.entrySet().iterator(); i.hasNext(); )\n+          {\n+            Map.Entry entry = (Map.Entry) i.next();\n+            Cookie cookie = (Cookie) entry.getValue();\n+            Date expires = cookie.getExpiryDate();\n+            if (expires != null && expires.before(now))\n+              {\n+                expired.add(entry.getKey());\n+                continue;\n+              }\n+            if (secure && !cookie.isSecure())\n+              {\n+                continue;\n+              }\n+            if (path.startsWith(cookie.getPath()))\n+              {\n+                matches.add(cookie);\n+              }\n+          }\n+        // Good housekeeping\n+        for (Iterator i = expired.iterator(); i.hasNext(); )\n+          {\n+            map.remove(i.next());\n+          }\n+      }\n+  }\n+  \n+}\n+"}, {"sha": "749f711fa3a42a758dbff780db0abf99135061cd", "filename": "libjava/gnu/java/net/protocol/http/event/ConnectionEvent.java", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FConnectionEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FConnectionEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FConnectionEvent.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,81 @@\n+/* ConnectionEvent.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http.event;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * A connection event.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class ConnectionEvent\n+  extends EventObject\n+{\n+\n+  /**\n+   * The connection closed event type.\n+   */\n+  public static final int CONNECTION_CLOSED = 0;\n+  \n+  /**\n+   * The type of this event.\n+   */\n+  protected int type;\n+\n+  /**\n+   * Constructs a connection event with the specified source and type.\n+   */\n+  public ConnectionEvent(Object source, int type)\n+  {\n+    super(source);\n+    this.type = type;\n+  }\n+\n+  /**\n+   * Returns the type of this event.\n+   * @see #type\n+   */\n+  public int getType()\n+  {\n+    return type;\n+  }\n+  \n+}\n+"}, {"sha": "a29955d8025f9cfdf7cbddfd3ec410af99a77524", "filename": "libjava/gnu/java/net/protocol/http/event/ConnectionListener.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FConnectionListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FConnectionListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FConnectionListener.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,58 @@\n+/* ConnectionListener.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http.event;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * A connection listener.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface ConnectionListener\n+  extends EventListener\n+{\n+\n+  /**\n+   * Callback invoked when the associated connection is closed.\n+   */\n+  void connectionClosed(ConnectionEvent event);\n+  \n+}\n+"}, {"sha": "ebc91d2ef58bde6f7878e4c5f282da799e06455b", "filename": "libjava/gnu/java/net/protocol/http/event/RequestEvent.java", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FRequestEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FRequestEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FRequestEvent.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,107 @@\n+/* RequestEvent.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http.event;\n+\n+import gnu.java.net.protocol.http.Request;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * A request event.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public class RequestEvent\n+  extends EventObject\n+{\n+\n+  /**\n+   * The request created event type.\n+   */\n+  public static final int REQUEST_CREATED = 0;\n+  \n+  /**\n+   * The request sending event type.\n+   */\n+  public static final int REQUEST_SENDING = 1;\n+  \n+  /**\n+   * The request sent event type.\n+   */\n+  public static final int REQUEST_SENT = 2;\n+  \n+  /**\n+   * The type of this event.\n+   */\n+  protected int type;\n+\n+  /**\n+   * The request associated with this event.\n+   */\n+  protected Request request;\n+\n+  /**\n+   * Constructs a request event with the specified source, type, and request.\n+   */\n+  public RequestEvent(Object source, int type, Request request)\n+  {\n+    super(source);\n+    this.type = type;\n+    this.request = request;\n+  }\n+\n+  /**\n+   * Returns the type of this event.\n+   * @see #type\n+   */\n+  public int getType()\n+  {\n+    return type;\n+  }\n+\n+  /**\n+   * Returns the request associated with this event.\n+   */\n+  public Request getRequest()\n+  {\n+    return request;\n+  }\n+  \n+}\n+"}, {"sha": "6bf0c96e68f0d76d1e4bfedaac86b10e9f27dddb", "filename": "libjava/gnu/java/net/protocol/http/event/RequestListener.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FRequestListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FRequestListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2Fevent%2FRequestListener.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -0,0 +1,70 @@\n+/* RequestListener.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net.protocol.http.event;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * A request listener.\n+ *\n+ * @author Chris Burdess (dog@gnu.org)\n+ */\n+public interface RequestListener\n+  extends EventListener\n+{\n+\n+  /**\n+   * Callback invoked when a request is created from the associated\n+   * connection.\n+   */\n+  void requestCreated(RequestEvent event);\n+\n+  /**\n+   * Callback invoked when the request has been initialised with all data\n+   * and before sending this data to the server.\n+   */\n+  void requestSending(RequestEvent event);\n+\n+  /**\n+   * Callback invoked after all request data has been sent to the server.\n+   */\n+  void requestSent(RequestEvent event);\n+  \n+}\n+"}, {"sha": "38e686af832b6716cf070e3ae203e5bf24ca7c03", "filename": "libjava/javax/net/ssl/HttpsURLConnection.java", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fjavax%2Fnet%2Fssl%2FHttpsURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30e8a59c742c7fe9e5f622371564d40ad46a8a68/libjava%2Fjavax%2Fnet%2Fssl%2FHttpsURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnet%2Fssl%2FHttpsURLConnection.java?ref=30e8a59c742c7fe9e5f622371564d40ad46a8a68", "patch": "@@ -59,10 +59,18 @@ public abstract class HttpsURLConnection extends HttpURLConnection\n   // Fields.\n   // ------------------------------------------------------------------\n \n-  /** The default verifier. */\n+  /**\n+   * The default verifier.\n+   * This is lazily initialized as required.\n+   * @see #getDefaultHostnameVerifier\n+   */\n   private static HostnameVerifier defaultVerifier;\n \n-  /** The default factory. */\n+  /**\n+   * The default factory.\n+   * This is lazily initialized as required.\n+   * @see #getDefaultSSLSocketFactory\n+   */\n   private static SSLSocketFactory defaultFactory;\n \n   /**\n@@ -75,21 +83,6 @@ public abstract class HttpsURLConnection extends HttpURLConnection\n    */\n   private SSLSocketFactory factory;\n \n-  // Static initializer.\n-  // ------------------------------------------------------------------\n-\n-  static {\n-    defaultVerifier = new TrivialHostnameVerifier();\n-    try\n-      {\n-        defaultFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n-      }\n-    catch (Throwable t)\n-      {\n-        t.printStackTrace();\n-      }\n-  }\n-\n   // Constructor.\n   // ------------------------------------------------------------------\n \n@@ -102,8 +95,6 @@ public abstract class HttpsURLConnection extends HttpURLConnection\n   protected HttpsURLConnection(URL url) throws IOException\n   {\n     super(url);\n-    hostnameVerifier = defaultVerifier;\n-    factory = defaultFactory;\n   }\n \n   // Class methods.\n@@ -112,11 +103,17 @@ protected HttpsURLConnection(URL url) throws IOException\n   /**\n    * Returns the default hostname verifier used in all new\n    * connections.\n+   * If the default verifier has not been set, a new default one will be\n+   * provided by this method.\n    *\n    * @return The default hostname verifier.\n    */\n-  public static HostnameVerifier getDefaultHostnameVerifier()\n+  public static synchronized HostnameVerifier getDefaultHostnameVerifier()\n   {\n+    if (defaultVerifier == null)\n+      {\n+        defaultVerifier = new TrivialHostnameVerifier();\n+      }\n     return defaultVerifier;\n   }\n \n@@ -137,17 +134,33 @@ public static void setDefaultHostnameVerifier(HostnameVerifier newDefault)\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkPermission(new SSLPermission(\"setHostnameVerifier\"));\n-    defaultVerifier = newDefault;\n+    synchronized (HttpsURLConnection.class)\n+      {\n+        defaultVerifier = newDefault;\n+      }\n   }\n \n   /**\n    * Returns the default SSL socket factory used in all new\n    * connections.\n+   * If the default SSL socket factory has not been set, a new default one\n+   * will be provided by this method.\n    *\n    * @return The default SSL socket factory.\n    */\n-  public static SSLSocketFactory getDefaultSSLSocketFactory()\n+  public static synchronized SSLSocketFactory getDefaultSSLSocketFactory()\n   {\n+    if (defaultFactory == null)\n+      {\n+        try\n+          {\n+            defaultFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n+          }\n+        catch (Throwable t)\n+          {\n+            t.printStackTrace();\n+          }\n+      }\n     return defaultFactory;\n   }\n \n@@ -168,7 +181,10 @@ public static void setDefaultSSLSocketFactory(SSLSocketFactory newDefault)\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkSetFactory();\n-    defaultFactory = newDefault;\n+    synchronized (HttpsURLConnection.class)\n+      {\n+        defaultFactory = newDefault;\n+      }\n   }\n \n   // Instance methods.\n@@ -181,6 +197,10 @@ public static void setDefaultSSLSocketFactory(SSLSocketFactory newDefault)\n    */\n   public HostnameVerifier getHostnameVerifier()\n   {\n+    if (hostnameVerifier == null)\n+      {\n+        hostnameVerifier = getDefaultHostnameVerifier();\n+      }\n     return hostnameVerifier;\n   }\n \n@@ -205,6 +225,10 @@ public void setHostnameVerifier(HostnameVerifier hostnameVerifier)\n    */\n   public SSLSocketFactory getSSLSocketFactory()\n   {\n+    if (factory == null)\n+      {\n+        factory = getDefaultSSLSocketFactory();\n+      }\n     return factory;\n   }\n "}]}