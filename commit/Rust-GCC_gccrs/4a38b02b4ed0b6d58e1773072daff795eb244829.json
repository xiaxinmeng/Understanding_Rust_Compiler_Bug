{"sha": "4a38b02b4ed0b6d58e1773072daff795eb244829", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEzOGIwMmI0ZWQwYjZkNThlMTc3MzA3MmRhZmY3OTVlYjI0NDgyOQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2015-12-15T14:56:50Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-12-15T14:56:50Z"}, "message": "c-common.c (c_common_attribute_table): Handle \"omp declare target link\" attribute.\n\ngcc/c-family/\n\t* c-common.c (c_common_attribute_table): Handle \"omp declare target\n\tlink\" attribute.\ngcc/\n\t* cgraphunit.c (output_in_order): Do not assemble \"omp declare target\n\tlink\" variables in ACCEL_COMPILER.\n\t* gimplify.c (gimplify_adjust_omp_clauses): Do not remove mapping of\n\t\"omp declare target link\" variables.\n\t* omp-low.c (scan_sharing_clauses): Do not remove mapping of \"omp\n\tdeclare target link\" variables.\n\t(add_decls_addresses_to_decl_constructor): For \"omp declare target link\"\n\tvariables output address of the artificial pointer instead of address of\n\tthe variable.  Set most significant bit of the size to mark them.\n\t(pass_data_omp_target_link): New pass_data.\n\t(pass_omp_target_link): New class.\n\t(find_link_var_op): New static function.\n\t(make_pass_omp_target_link): New function.\n\t* passes.def: Add pass_omp_target_link.\n\t* tree-pass.h (make_pass_omp_target_link): Declare.\n\t* varpool.c (symbol_table::output_variables): Do not assemble \"omp\n\tdeclare target link\" variables in ACCEL_COMPILER.\ngcc/lto/\n\t* lto.c: Include stringpool.h and fold-const.h.\n\t(offload_handle_link_vars): New static function.\n\t(lto_main): Call offload_handle_link_vars.\nlibgomp/\n\t* libgomp.h (REFCOUNT_LINK): Define.\n\t(struct splay_tree_key_s): Add link_key.\n\t* target.c (gomp_map_vars): Treat REFCOUNT_LINK objects as not mapped.\n\tReplace target address of the pointer with target address of newly\n\tmapped object in the splay tree.  Set link pointer on target to the\n\tdevice address of the mapped object.\n\t(gomp_unmap_vars): Restore target address of the pointer in the splay\n\ttree for REFCOUNT_LINK objects after unmapping.\n\t(gomp_load_image_to_device): Set refcount to REFCOUNT_LINK for \"omp\n\tdeclare target link\" objects.\n\t(gomp_unload_image_from_device): Replace j with i.  Force unmap of all\n\t\"omp declare target link\" objects, which were mapped for the image.\n\t(gomp_exit_data): Restore target address of the pointer in the splay\n\ttree for REFCOUNT_LINK objects after unmapping.\n\t* testsuite/libgomp.c/target-link-1.c: New file.\n\nFrom-SVN: r231655", "tree": {"sha": "3ded94420f4c91b3d08a1e815cabbd436cccb009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ded94420f4c91b3d08a1e815cabbd436cccb009"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a38b02b4ed0b6d58e1773072daff795eb244829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a38b02b4ed0b6d58e1773072daff795eb244829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a38b02b4ed0b6d58e1773072daff795eb244829", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a38b02b4ed0b6d58e1773072daff795eb244829/comments", "author": null, "committer": null, "parents": [{"sha": "b7e2dd6fb446b6b55358f1a6ec7abcf7d28b5590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e2dd6fb446b6b55358f1a6ec7abcf7d28b5590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e2dd6fb446b6b55358f1a6ec7abcf7d28b5590"}], "stats": {"total": 392, "additions": 368, "deletions": 24}, "files": [{"sha": "02c2117836db29ef88dcb17248ce8355b3abfe99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -1,3 +1,23 @@\n+2015-12-15  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* cgraphunit.c (output_in_order): Do not assemble \"omp declare target\n+\tlink\" variables in ACCEL_COMPILER.\n+\t* gimplify.c (gimplify_adjust_omp_clauses): Do not remove mapping of\n+\t\"omp declare target link\" variables.\n+\t* omp-low.c (scan_sharing_clauses): Do not remove mapping of \"omp\n+\tdeclare target link\" variables.\n+\t(add_decls_addresses_to_decl_constructor): For \"omp declare target link\"\n+\tvariables output address of the artificial pointer instead of address of\n+\tthe variable.  Set most significant bit of the size to mark them.\n+\t(pass_data_omp_target_link): New pass_data.\n+\t(pass_omp_target_link): New class.\n+\t(find_link_var_op): New static function.\n+\t(make_pass_omp_target_link): New function.\n+\t* passes.def: Add pass_omp_target_link.\n+\t* tree-pass.h (make_pass_omp_target_link): Declare.\n+\t* varpool.c (symbol_table::output_variables): Do not assemble \"omp\n+\tdeclare target link\" variables in ACCEL_COMPILER.\n+\n 2015-12-15  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR middle-end/21273"}, {"sha": "525cc16f17bd2d0307940d27d84e9a8ef66749b9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -1,3 +1,8 @@\n+2015-12-15  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* c-common.c (c_common_attribute_table): Handle \"omp declare target\n+\tlink\" attribute.\n+\n 2015-12-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/68833"}, {"sha": "4250cdf1ceedcf6dbae01668efa9ab15ddd0274a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -821,6 +821,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_simd_attribute, false },\n   { \"omp declare target\",     0, 0, true, false, false,\n \t\t\t      handle_omp_declare_target_attribute, false },\n+  { \"omp declare target link\", 0, 0, true, false, false,\n+\t\t\t      handle_omp_declare_target_attribute, false },\n   { \"alloc_align\",\t      1, 1, false, true, true,\n \t\t\t      handle_alloc_align_attribute, false },\n   { \"assume_aligned\",\t      1, 2, false, true, true,"}, {"sha": "8443cb092a71641157a2e01359fdd70b109bfaef", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -2210,6 +2210,13 @@ output_in_order (bool no_reorder)\n \t  break;\n \n \tcase ORDER_VAR:\n+#ifdef ACCEL_COMPILER\n+\t  /* Do not assemble \"omp declare target link\" vars.  */\n+\t  if (DECL_HAS_VALUE_EXPR_P (nodes[i].u.v->decl)\n+\t      && lookup_attribute (\"omp declare target link\",\n+\t\t\t\t   DECL_ATTRIBUTES (nodes[i].u.v->decl)))\n+\t    break;\n+#endif\n \t  nodes[i].u.v->assemble_decl ();\n \t  break;\n "}, {"sha": "438efba57e12a71fedfbc9b0e47c00779f46b86e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -7910,7 +7910,9 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n \t  if ((ctx->region_type & ORT_TARGET) != 0\n \t      && !(n->value & GOVD_SEEN)\n-\t      && GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) == 0)\n+\t      && GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) == 0\n+\t      && !lookup_attribute (\"omp declare target link\",\n+\t\t\t\t    DECL_ATTRIBUTES (decl)))\n \t    {\n \t      remove = true;\n \t      /* For struct element mapping, if struct is never referenced"}, {"sha": "ac20a3f2dde4baddc26a4a24abc345f679984a6c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -1,3 +1,9 @@\n+2015-12-15  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* lto.c: Include stringpool.h and fold-const.h.\n+\t(offload_handle_link_vars): New static function.\n+\t(lto_main): Call offload_handle_link_vars.\n+\n 2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (lto_read_in_decl_state): Unpickle compressed bit."}, {"sha": "5fd50dc1d26f85b10871ebde3aaed7c6c034b733", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -50,6 +50,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"gomp-constants.h\"\n #include \"lto-symtab.h\"\n+#include \"stringpool.h\"\n+#include \"fold-const.h\"\n \n \n /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */\n@@ -3226,6 +3228,37 @@ lto_init (void)\n #endif\n }\n \n+/* Create artificial pointers for \"omp declare target link\" vars.  */\n+\n+static void\n+offload_handle_link_vars (void)\n+{\n+#ifdef ACCEL_COMPILER\n+  varpool_node *var;\n+  FOR_EACH_VARIABLE (var)\n+    if (lookup_attribute (\"omp declare target link\",\n+\t\t\t  DECL_ATTRIBUTES (var->decl)))\n+      {\n+\ttree type = build_pointer_type (TREE_TYPE (var->decl));\n+\ttree link_ptr_var = make_node (VAR_DECL);\n+\tTREE_TYPE (link_ptr_var) = type;\n+\tTREE_USED (link_ptr_var) = 1;\n+\tTREE_STATIC (link_ptr_var) = 1;\n+\tDECL_MODE (link_ptr_var) = TYPE_MODE (type);\n+\tDECL_SIZE (link_ptr_var) = TYPE_SIZE (type);\n+\tDECL_SIZE_UNIT (link_ptr_var) = TYPE_SIZE_UNIT (type);\n+\tDECL_ARTIFICIAL (link_ptr_var) = 1;\n+\ttree var_name = DECL_ASSEMBLER_NAME (var->decl);\n+\tchar *new_name\n+\t  = ACONCAT ((IDENTIFIER_POINTER (var_name), \"_linkptr\", NULL));\n+\tDECL_NAME (link_ptr_var) = get_identifier (new_name);\n+\tSET_DECL_ASSEMBLER_NAME (link_ptr_var, DECL_NAME (link_ptr_var));\n+\tSET_DECL_VALUE_EXPR (var->decl, build_simple_mem_ref (link_ptr_var));\n+\tDECL_HAS_VALUE_EXPR_P (var->decl) = 1;\n+      }\n+#endif\n+}\n+\n \n /* Main entry point for the GIMPLE front end.  This front end has\n    three main personalities:\n@@ -3274,6 +3307,8 @@ lto_main (void)\n \n   if (!seen_error ())\n     {\n+      offload_handle_link_vars ();\n+\n       /* If WPA is enabled analyze the whole call graph and create an\n \t optimization plan.  Otherwise, read in all the function\n \t bodies and continue with optimization.  */"}, {"sha": "676b1dfce88f62987bedd547f90830d08455f1fc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 123, "deletions": 8, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -2026,15 +2026,18 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  /* Global variables with \"omp declare target\" attribute\n \t     don't need to be copied, the receiver side will use them\n-\t     directly.  */\n+\t     directly.  However, global variables with \"omp declare target link\"\n+\t     attribute need to be copied.  */\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      && DECL_P (decl)\n \t      && ((OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t\t   && (OMP_CLAUSE_MAP_KIND (c)\n \t\t       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n-\t      && varpool_node::get_create (decl)->offloadable)\n+\t      && varpool_node::get_create (decl)->offloadable\n+\t      && !lookup_attribute (\"omp declare target link\",\n+\t\t\t\t    DECL_ATTRIBUTES (decl)))\n \t    break;\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER)\n@@ -18588,13 +18591,45 @@ add_decls_addresses_to_decl_constructor (vec<tree, va_gc> *v_decls,\n   for (unsigned i = 0; i < len; i++)\n     {\n       tree it = (*v_decls)[i];\n-      bool is_function = TREE_CODE (it) != VAR_DECL;\n+      bool is_var = TREE_CODE (it) == VAR_DECL;\n+      bool is_link_var\n+\t= is_var\n+#ifdef ACCEL_COMPILER\n+\t  && DECL_HAS_VALUE_EXPR_P (it)\n+#endif\n+\t  && lookup_attribute (\"omp declare target link\", DECL_ATTRIBUTES (it));\n \n-      CONSTRUCTOR_APPEND_ELT (v_ctor, NULL_TREE, build_fold_addr_expr (it));\n-      if (!is_function)\n-\tCONSTRUCTOR_APPEND_ELT (v_ctor, NULL_TREE,\n-\t\t\t\tfold_convert (const_ptr_type_node,\n-\t\t\t\t\t      DECL_SIZE_UNIT (it)));\n+      tree size = NULL_TREE;\n+      if (is_var)\n+\tsize = fold_convert (const_ptr_type_node, DECL_SIZE_UNIT (it));\n+\n+      tree addr;\n+      if (!is_link_var)\n+\taddr = build_fold_addr_expr (it);\n+      else\n+\t{\n+#ifdef ACCEL_COMPILER\n+\t  /* For \"omp declare target link\" vars add address of the pointer to\n+\t     the target table, instead of address of the var.  */\n+\t  tree value_expr = DECL_VALUE_EXPR (it);\n+\t  tree link_ptr_decl = TREE_OPERAND (value_expr, 0);\n+\t  varpool_node::finalize_decl (link_ptr_decl);\n+\t  addr = build_fold_addr_expr (link_ptr_decl);\n+#else\n+\t  addr = build_fold_addr_expr (it);\n+#endif\n+\n+\t  /* Most significant bit of the size marks \"omp declare target link\"\n+\t     vars in host and target tables.  */\n+\t  unsigned HOST_WIDE_INT isize = tree_to_uhwi (size);\n+\t  isize |= 1ULL << (int_size_in_bytes (const_ptr_type_node)\n+\t\t\t    * BITS_PER_UNIT - 1);\n+\t  size = wide_int_to_tree (const_ptr_type_node, isize);\n+\t}\n+\n+      CONSTRUCTOR_APPEND_ELT (v_ctor, NULL_TREE, addr);\n+      if (is_var)\n+\tCONSTRUCTOR_APPEND_ELT (v_ctor, NULL_TREE, size);\n     }\n }\n \n@@ -19831,4 +19866,84 @@ make_pass_oacc_device_lower (gcc::context *ctxt)\n   return new pass_oacc_device_lower (ctxt);\n }\n \n+/* \"omp declare target link\" handling pass.  */\n+\n+namespace {\n+\n+const pass_data pass_data_omp_target_link =\n+{\n+  GIMPLE_PASS,\t\t\t/* type */\n+  \"omptargetlink\",\t\t/* name */\n+  OPTGROUP_NONE,\t\t/* optinfo_flags */\n+  TV_NONE,\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_update_ssa,\t\t/* todo_flags_finish */\n+};\n+\n+class pass_omp_target_link : public gimple_opt_pass\n+{\n+public:\n+  pass_omp_target_link (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_omp_target_link, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun)\n+    {\n+#ifdef ACCEL_COMPILER\n+      tree attrs = DECL_ATTRIBUTES (fun->decl);\n+      return lookup_attribute (\"omp declare target\", attrs)\n+\t     || lookup_attribute (\"omp target entrypoint\", attrs);\n+#else\n+      (void) fun;\n+      return false;\n+#endif\n+    }\n+\n+  virtual unsigned execute (function *);\n+};\n+\n+/* Callback for walk_gimple_stmt used to scan for link var operands.  */\n+\n+static tree\n+find_link_var_op (tree *tp, int *walk_subtrees, void *)\n+{\n+  tree t = *tp;\n+\n+  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t)\n+      && lookup_attribute (\"omp declare target link\", DECL_ATTRIBUTES (t)))\n+    {\n+      *walk_subtrees = 0;\n+      return t;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+unsigned\n+pass_omp_target_link::execute (function *fun)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tif (walk_gimple_stmt (&gsi, NULL, find_link_var_op, NULL))\n+\t  gimple_regimplify_operands (gsi_stmt (gsi), &gsi);\n+    }\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_omp_target_link (gcc::context *ctxt)\n+{\n+  return new pass_omp_target_link (ctxt);\n+}\n+\n #include \"gt-omp-low.h\""}, {"sha": "c72b38ba1e50b5882b1a489cceea2537cf4d9b0f", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -170,6 +170,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_lower_eh_dispatch);\n   NEXT_PASS (pass_oacc_device_lower);\n+  NEXT_PASS (pass_omp_target_link);\n   NEXT_PASS (pass_all_optimizations);\n   PUSH_INSERT_PASSES_WITHIN (pass_all_optimizations)\n       NEXT_PASS (pass_remove_cgraph_callee_edges);"}, {"sha": "a13a8653f23c010bce630ba176fc0133b6329571", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -417,6 +417,7 @@ extern gimple_opt_pass *make_pass_lower_omp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_diagnose_omp_blocks (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_expand_omp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_expand_omp_ssa (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_omp_target_link (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_oacc_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);"}, {"sha": "d0101a1081894d2f8b475976885bc1ae86423f8b", "filename": "gcc/varpool.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -748,6 +748,13 @@ symbol_table::output_variables (void)\n       /* Handled in output_in_order.  */\n       if (node->no_reorder)\n \tcontinue;\n+#ifdef ACCEL_COMPILER\n+      /* Do not assemble \"omp declare target link\" vars.  */\n+      if (DECL_HAS_VALUE_EXPR_P (node->decl)\n+\t  && lookup_attribute (\"omp declare target link\",\n+\t\t\t       DECL_ATTRIBUTES (node->decl)))\n+\tcontinue;\n+#endif\n       if (node->assemble_decl ())\n         changed = true;\n     }"}, {"sha": "9315d8b83b2de908fadb3944877c4ac9332f79d8", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -1,3 +1,21 @@\n+2015-12-15  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* libgomp.h (REFCOUNT_LINK): Define.\n+\t(struct splay_tree_key_s): Add link_key.\n+\t* target.c (gomp_map_vars): Treat REFCOUNT_LINK objects as not mapped.\n+\tReplace target address of the pointer with target address of newly\n+\tmapped object in the splay tree.  Set link pointer on target to the\n+\tdevice address of the mapped object.\n+\t(gomp_unmap_vars): Restore target address of the pointer in the splay\n+\ttree for REFCOUNT_LINK objects after unmapping.\n+\t(gomp_load_image_to_device): Set refcount to REFCOUNT_LINK for \"omp\n+\tdeclare target link\" objects.\n+\t(gomp_unload_image_from_device): Replace j with i.  Force unmap of all\n+\t\"omp declare target link\" objects, which were mapped for the image.\n+\t(gomp_exit_data): Restore target address of the pointer in the splay\n+\ttree for REFCOUNT_LINK objects after unmapping.\n+\t* testsuite/libgomp.c/target-link-1.c: New file.\n+\n 2015-12-14  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* libgomp.h (gomp_device_state): New enum."}, {"sha": "73aa513b47c0f84a6cd136cf1624ece1e40bc692", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -817,6 +817,9 @@ struct target_mem_desc {\n \n /* Special value for refcount - infinity.  */\n #define REFCOUNT_INFINITY (~(uintptr_t) 0)\n+/* Special value for refcount - tgt_offset contains target address of the\n+   artificial pointer to \"omp declare target link\" object.  */\n+#define REFCOUNT_LINK (~(uintptr_t) 1)\n \n struct splay_tree_key_s {\n   /* Address of the host object.  */\n@@ -831,6 +834,8 @@ struct splay_tree_key_s {\n   uintptr_t refcount;\n   /* Asynchronous reference count.  */\n   uintptr_t async_refcount;\n+  /* Pointer to the original mapping of \"omp declare target link\" object.  */\n+  splay_tree_key link_key;\n };\n \n /* The comparison function.  */"}, {"sha": "1ab30f7ca25309023588b3b1cc977fb4c67fdcf5", "filename": "libgomp/target.c", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -464,7 +464,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t}\n       else\n \tn = splay_tree_lookup (mem_map, &cur_node);\n-      if (n)\n+      if (n && n->refcount != REFCOUNT_LINK)\n \tgomp_map_vars_existing (devicep, n, &cur_node, &tgt->list[i],\n \t\t\t\tkind & typemask);\n       else\n@@ -628,11 +628,19 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t    else\n \t      k->host_end = k->host_start + sizeof (void *);\n \t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n-\t    if (n)\n+\t    if (n && n->refcount != REFCOUNT_LINK)\n \t      gomp_map_vars_existing (devicep, n, k, &tgt->list[i],\n \t\t\t\t      kind & typemask);\n \t    else\n \t      {\n+\t\tk->link_key = NULL;\n+\t\tif (n && n->refcount == REFCOUNT_LINK)\n+\t\t  {\n+\t\t    /* Replace target address of the pointer with target address\n+\t\t       of mapped object in the splay tree.  */\n+\t\t    splay_tree_remove (mem_map, n);\n+\t\t    k->link_key = n;\n+\t\t  }\n \t\tsize_t align = (size_t) 1 << (kind >> rshift);\n \t\ttgt->list[i].key = k;\n \t\tk->tgt = tgt;\n@@ -752,6 +760,16 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    gomp_fatal (\"%s: unhandled kind 0x%.2x\", __FUNCTION__,\n \t\t\t\tkind);\n \t\t  }\n+\n+\t\tif (k->link_key)\n+\t\t  {\n+\t\t    /* Set link pointer on target to the device address of the\n+\t\t       mapped object.  */\n+\t\t    void *tgt_addr = (void *) (tgt->tgt_start + k->tgt_offset);\n+\t\t    devicep->host2dev_func (devicep->target_id,\n+\t\t\t\t\t    (void *) n->tgt_offset,\n+\t\t\t\t\t    &tgt_addr, sizeof (void *));\n+\t\t  }\n \t\tarray++;\n \t      }\n \t  }\n@@ -884,6 +902,9 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n       if (do_unmap)\n \t{\n \t  splay_tree_remove (&devicep->mem_map, k);\n+\t  if (k->link_key)\n+\t    splay_tree_insert (&devicep->mem_map,\n+\t\t\t       (splay_tree_node) k->link_key);\n \t  if (k->tgt->refcount > 1)\n \t    k->tgt->refcount--;\n \t  else\n@@ -1020,31 +1041,40 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       k->tgt_offset = target_table[i].start;\n       k->refcount = REFCOUNT_INFINITY;\n       k->async_refcount = 0;\n+      k->link_key = NULL;\n       array->left = NULL;\n       array->right = NULL;\n       splay_tree_insert (&devicep->mem_map, array);\n       array++;\n     }\n \n+  /* Most significant bit of the size in host and target tables marks\n+     \"omp declare target link\" variables.  */\n+  const uintptr_t link_bit = 1ULL << (sizeof (uintptr_t) * __CHAR_BIT__ - 1);\n+  const uintptr_t size_mask = ~link_bit;\n+\n   for (i = 0; i < num_vars; i++)\n     {\n       struct addr_pair *target_var = &target_table[num_funcs + i];\n-      if (target_var->end - target_var->start\n-\t  != (uintptr_t) host_var_table[i * 2 + 1])\n+      uintptr_t target_size = target_var->end - target_var->start;\n+\n+      if ((uintptr_t) host_var_table[i * 2 + 1] != target_size)\n \t{\n \t  gomp_mutex_unlock (&devicep->lock);\n \t  if (is_register_lock)\n \t    gomp_mutex_unlock (&register_lock);\n-\t  gomp_fatal (\"Can't map target variables (size mismatch)\");\n+\t  gomp_fatal (\"Cannot map target variables (size mismatch)\");\n \t}\n \n       splay_tree_key k = &array->key;\n       k->host_start = (uintptr_t) host_var_table[i * 2];\n-      k->host_end = k->host_start + (uintptr_t) host_var_table[i * 2 + 1];\n+      k->host_end\n+\t= k->host_start + (size_mask & (uintptr_t) host_var_table[i * 2 + 1]);\n       k->tgt = tgt;\n       k->tgt_offset = target_var->start;\n-      k->refcount = REFCOUNT_INFINITY;\n+      k->refcount = target_size & link_bit ? REFCOUNT_LINK : REFCOUNT_INFINITY;\n       k->async_refcount = 0;\n+      k->link_key = NULL;\n       array->left = NULL;\n       array->right = NULL;\n       splay_tree_insert (&devicep->mem_map, array);\n@@ -1072,7 +1102,6 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n   int num_funcs = host_funcs_end - host_func_table;\n   int num_vars  = (host_vars_end - host_var_table) / 2;\n \n-  unsigned j;\n   struct splay_tree_key_s k;\n   splay_tree_key node = NULL;\n \n@@ -1088,21 +1117,46 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n   devicep->unload_image_func (devicep->target_id, version, target_data);\n \n   /* Remove mappings from splay tree.  */\n-  for (j = 0; j < num_funcs; j++)\n+  int i;\n+  for (i = 0; i < num_funcs; i++)\n     {\n-      k.host_start = (uintptr_t) host_func_table[j];\n+      k.host_start = (uintptr_t) host_func_table[i];\n       k.host_end = k.host_start + 1;\n       splay_tree_remove (&devicep->mem_map, &k);\n     }\n \n-  for (j = 0; j < num_vars; j++)\n+  /* Most significant bit of the size in host and target tables marks\n+     \"omp declare target link\" variables.  */\n+  const uintptr_t link_bit = 1ULL << (sizeof (uintptr_t) * __CHAR_BIT__ - 1);\n+  const uintptr_t size_mask = ~link_bit;\n+  bool is_tgt_unmapped = false;\n+\n+  for (i = 0; i < num_vars; i++)\n     {\n-      k.host_start = (uintptr_t) host_var_table[j * 2];\n-      k.host_end = k.host_start + (uintptr_t) host_var_table[j * 2 + 1];\n-      splay_tree_remove (&devicep->mem_map, &k);\n+      k.host_start = (uintptr_t) host_var_table[i * 2];\n+      k.host_end\n+\t= k.host_start + (size_mask & (uintptr_t) host_var_table[i * 2 + 1]);\n+\n+      if (!(link_bit & (uintptr_t) host_var_table[i * 2 + 1]))\n+\tsplay_tree_remove (&devicep->mem_map, &k);\n+      else\n+\t{\n+\t  splay_tree_key n = splay_tree_lookup (&devicep->mem_map, &k);\n+\t  splay_tree_remove (&devicep->mem_map, n);\n+\t  if (n->link_key)\n+\t    {\n+\t      if (n->tgt->refcount > 1)\n+\t\tn->tgt->refcount--;\n+\t      else\n+\t\t{\n+\t\t  is_tgt_unmapped = true;\n+\t\t  gomp_unmap_tgt (n->tgt);\n+\t\t}\n+\t    }\n+\t}\n     }\n \n-  if (node)\n+  if (node && !is_tgt_unmapped)\n     {\n       free (node->tgt);\n       free (node);\n@@ -1658,6 +1712,9 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \t  if (k->refcount == 0)\n \t    {\n \t      splay_tree_remove (&devicep->mem_map, k);\n+\t      if (k->link_key)\n+\t\tsplay_tree_insert (&devicep->mem_map,\n+\t\t\t\t   (splay_tree_node) k->link_key);\n \t      if (k->tgt->refcount > 1)\n \t\tk->tgt->refcount--;\n \t      else"}, {"sha": "681677cc2aa90e48ca30adace57333c144140862", "filename": "libgomp/testsuite/libgomp.c/target-link-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-link-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a38b02b4ed0b6d58e1773072daff795eb244829/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-link-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-link-1.c?ref=4a38b02b4ed0b6d58e1773072daff795eb244829", "patch": "@@ -0,0 +1,63 @@\n+struct S { int s, t; };\n+\n+int a = 1, b = 1;\n+double c[27];\n+struct S d = { 8888, 8888 };\n+#pragma omp declare target link (a) to (b) link (c, d)\n+\n+int\n+foo (void)\n+{\n+  return a++ + b++;\n+}\n+\n+int\n+bar (int n)\n+{\n+  int *p1 = &a;\n+  int *p2 = &b;\n+  c[n] += 2.0;\n+  d.s -= 2;\n+  d.t -= 2;\n+  return *p1 + *p2 + d.s + d.t;\n+}\n+\n+#pragma omp declare target (foo, bar)\n+\n+int\n+main ()\n+{\n+  a = b = 2;\n+  d.s = 17;\n+  d.t = 18;\n+\n+  int res, n = 10;\n+  #pragma omp target map (to: a, b, c, d) map (from: res)\n+  {\n+    res = foo () + foo ();\n+    c[n] = 3.0;\n+    res += bar (n);\n+  }\n+\n+  int shared_mem = 0;\n+  #pragma omp target map (alloc: shared_mem)\n+    shared_mem = 1;\n+\n+  if ((shared_mem && res != (2 + 2) + (3 + 3) + (4 + 4 + 15 + 16))\n+      || (!shared_mem && res != (2 + 1) + (3 + 2) + (4 + 3 + 15 + 16)))\n+    __builtin_abort ();\n+\n+  #pragma omp target enter data map (to: c)\n+  #pragma omp target update from (c)\n+  res = (int) (c[n] + 0.5);\n+  if ((shared_mem && res != 5) || (!shared_mem && res != 0))\n+    __builtin_abort ();\n+\n+  #pragma omp target map (to: a, b) map (from: res)\n+    res = foo ();\n+\n+  if ((shared_mem && res != 4 + 4) || (!shared_mem && res != 2 + 3))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}