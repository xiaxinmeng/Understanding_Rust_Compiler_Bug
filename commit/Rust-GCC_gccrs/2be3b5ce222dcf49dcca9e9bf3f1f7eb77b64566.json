{"sha": "2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJlM2I1Y2UyMjJkY2Y0OWRjY2E5ZTliZjNmMWY3ZWI3N2I2NDU2Ng==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-04-23T13:09:36Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-04-23T13:09:36Z"}, "message": "re PR rtl-optimization/10339 ([sparc,ppc,ppc64] Invalid optimization: replacing strncmp by memcmp)\n\n\n\tPR optimization/10339\n\t* builtins.c (expand_builtin_strcmp): Try to emit cmpstrsi insn\n\tdirectly instead of unsafely transforming call into a memcmp.\n\t(expand_builtin_strncmp): Likewise.\n\nFrom-SVN: r65985", "tree": {"sha": "230395e871566201655181b395a35db7db6d6141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/230395e871566201655181b395a35db7db6d6141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566/comments", "author": null, "committer": null, "parents": [{"sha": "d8c3061141850f24406d79172265410ce93fe2e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8c3061141850f24406d79172265410ce93fe2e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8c3061141850f24406d79172265410ce93fe2e3"}], "stats": {"total": 235, "additions": 166, "deletions": 69}, "files": [{"sha": "ce228651954694053942c06b562573bc9847c76d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "patch": "@@ -1,3 +1,10 @@\n+2003-04-23  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/10339\n+\t* builtins.c (expand_builtin_strcmp): Try to emit cmpstrsi insn\n+\tdirectly instead of unsafely transforming call into a memcmp.\n+\t(expand_builtin_strncmp): Likewise.\n+\n 2003-04-22  Roger Sayle  <roger@eyesopen.com>\n \n \t* alias.c (mark_constant_function):  Check for constancy and"}, {"sha": "b24ecd32b3cd96b8956fdf1ae349379f29075996", "filename": "gcc/builtins.c", "status": "modified", "additions": 159, "deletions": 69, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2be3b5ce222dcf49dcca9e9bf3f1f7eb77b64566", "patch": "@@ -2715,7 +2715,7 @@ expand_builtin_bzero (exp)\n   return result;\n }\n \n-/* Expand expression EXP, which is a call to the memcmp or the strcmp builtin.\n+/* Expand expression EXP, which is a call to the memcmp built-in function.\n    ARGLIST is the argument list for this call.  Return 0 if we failed and the\n    caller should emit a normal call, otherwise try to get the result in\n    TARGET, if convenient (and in mode MODE, if that's convenient).  */\n@@ -2852,7 +2852,7 @@ expand_builtin_strcmp (exp, target, mode)\n      enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg1, arg2, len, len2, fn;\n+  tree arg1, arg2;\n   const char *p1, *p2;\n \n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n@@ -2888,49 +2888,88 @@ expand_builtin_strcmp (exp, target, mode)\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n-  len = c_strlen (arg1);\n-  len2 = c_strlen (arg2);\n+#ifdef HAVE_cmpstrsi\n+  if (HAVE_cmpstrsi)\n+  {\n+    tree len, len1, len2;\n+    rtx arg1_rtx, arg2_rtx, arg3_rtx;\n+    rtx result, insn;\n \n-  if (len)\n-    len = size_binop (PLUS_EXPR, ssize_int (1), len);\n+    int arg1_align\n+      = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    int arg2_align\n+      = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    enum machine_mode insn_mode\n+      = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n \n-  if (len2)\n-    len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+    len1 = c_strlen (arg1);\n+    len2 = c_strlen (arg2);\n+\n+    if (len1)\n+      len1 = size_binop (PLUS_EXPR, ssize_int (1), len1);\n+    if (len2)\n+      len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+\n+    /* If we don't have a constant length for the first, use the length\n+       of the second, if we know it.  We don't require a constant for\n+       this case; some cost analysis could be done if both are available\n+       but neither is constant.  For now, assume they're equally cheap,\n+       unless one has side effects.  If both strings have constant lengths,\n+       use the smaller.  */\n+\n+    if (!len1)\n+      len = len2;\n+    else if (!len2)\n+      len = len1;\n+    else if (TREE_SIDE_EFFECTS (len1))\n+      len = len2;\n+    else if (TREE_SIDE_EFFECTS (len2))\n+      len = len1;\n+    else if (TREE_CODE (len1) != INTEGER_CST)\n+      len = len2;\n+    else if (TREE_CODE (len2) != INTEGER_CST)\n+      len = len1;\n+    else if (tree_int_cst_lt (len1, len2))\n+      len = len1;\n+    else\n+      len = len2;\n \n-  /* If we don't have a constant length for the first, use the length\n-     of the second, if we know it.  We don't require a constant for\n-     this case; some cost analysis could be done if both are available\n-     but neither is constant.  For now, assume they're equally cheap\n-     unless one has side effects.\n+    /* If both arguments have side effects, we cannot optimize.  */\n+    if (!len || TREE_SIDE_EFFECTS (len))\n+      return 0;\n \n-     If both strings have constant lengths, use the smaller.  This\n-     could arise if optimization results in strcpy being called with\n-     two fixed strings, or if the code was machine-generated.  We should\n-     add some code to the `memcmp' handler below to deal with such\n-     situations, someday.  */\n+    /* If we don't have POINTER_TYPE, call the function.  */\n+    if (arg1_align == 0 || arg2_align == 0)\n+      return 0;\n \n-  if (!len || TREE_CODE (len) != INTEGER_CST)\n-    {\n-      if (len2 && !TREE_SIDE_EFFECTS (len2))\n-\tlen = len2;\n-      else if (len == 0)\n-\treturn 0;\n-    }\n-  else if (len2 && TREE_CODE (len2) == INTEGER_CST\n-\t   && tree_int_cst_lt (len2, len))\n-    len = len2;\n+    /* Make a place to write the result of the instruction.  */\n+    result = target;\n+    if (! (result != 0\n+\t   && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n+\t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+      result = gen_reg_rtx (insn_mode);\n \n-  /* If both arguments have side effects, we cannot optimize.  */\n-  if (TREE_SIDE_EFFECTS (len))\n-    return 0;\n+    arg1_rtx = get_memory_rtx (arg1);\n+    arg2_rtx = get_memory_rtx (arg2);\n+    arg3_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+    insn = gen_cmpstrsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n+\t\t\t GEN_INT (MIN (arg1_align, arg2_align)));\n+    if (!insn)\n+      return 0;\n \n-  fn = implicit_built_in_decls[BUILT_IN_MEMCMP];\n-  if (!fn)\n-    return 0;\n+    emit_insn (insn);\n \n-  chainon (arglist, build_tree_list (NULL_TREE, len));\n-  return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t      target, mode, EXPAND_NORMAL);\n+    /* Return the value in the proper mode for this function.  */\n+    mode = TYPE_MODE (TREE_TYPE (exp));\n+    if (GET_MODE (result) == mode)\n+      return result;\n+    if (target == 0)\n+      return convert_to_mode (mode, result, 0);\n+    convert_move (target, result, 0);\n+    return target;\n+  }\n+#endif\n+  return 0;\n }\n \n /* Expand expression EXP, which is a call to the strncmp builtin.  Return 0\n@@ -2944,7 +2983,6 @@ expand_builtin_strncmp (exp, target, mode)\n      enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree fn, newarglist, len = 0;\n   tree arg1, arg2, arg3;\n   const char *p1, *p2;\n \n@@ -2998,41 +3036,93 @@ expand_builtin_strncmp (exp, target, mode)\n     }\n \n   /* If c_strlen can determine an expression for one of the string\n-     lengths, and it doesn't have side effects, then call\n-     expand_builtin_memcmp() using length MIN(strlen(string)+1, arg3).  */\n-\n-  /* Perhaps one of the strings is really constant, if so prefer\n-     that constant length over the other string's length.  */\n-  if (p1)\n-    len = c_strlen (arg1);\n-  else if (p2)\n-    len = c_strlen (arg2);\n-\n-  /* If we still don't have a len, try either string arg as long\n-     as they don't have side effects.  */\n-  if (!len && !TREE_SIDE_EFFECTS (arg1))\n-    len = c_strlen (arg1);\n-  if (!len && !TREE_SIDE_EFFECTS (arg2))\n-    len = c_strlen (arg2);\n-  /* If we still don't have a length, punt.  */\n-  if (!len)\n-    return 0;\n+     lengths, and it doesn't have side effects, then emit cmpstrsi\n+     using length MIN(strlen(string)+1, arg3).  */\n+#ifdef HAVE_cmpstrsi\n+  if (HAVE_cmpstrsi)\n+  {\n+    tree len, len1, len2;\n+    rtx arg1_rtx, arg2_rtx, arg3_rtx;\n+    rtx result, insn;\n \n-  fn = implicit_built_in_decls[BUILT_IN_MEMCMP];\n-  if (!fn)\n-    return 0;\n+    int arg1_align\n+      = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    int arg2_align\n+      = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    enum machine_mode insn_mode\n+      = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n \n-  /* Add one to the string length.  */\n-  len = fold (size_binop (PLUS_EXPR, len, ssize_int (1)));\n+    len1 = c_strlen (arg1);\n+    len2 = c_strlen (arg2);\n+\n+    if (len1)\n+      len1 = size_binop (PLUS_EXPR, ssize_int (1), len1);\n+    if (len2)\n+      len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+\n+    /* If we don't have a constant length for the first, use the length\n+       of the second, if we know it.  We don't require a constant for\n+       this case; some cost analysis could be done if both are available\n+       but neither is constant.  For now, assume they're equally cheap,\n+       unless one has side effects.  If both strings have constant lengths,\n+       use the smaller.  */\n+\n+    if (!len1)\n+      len = len2;\n+    else if (!len2)\n+      len = len1;\n+    else if (TREE_SIDE_EFFECTS (len1))\n+      len = len2;\n+    else if (TREE_SIDE_EFFECTS (len2))\n+      len = len1;\n+    else if (TREE_CODE (len1) != INTEGER_CST)\n+      len = len2;\n+    else if (TREE_CODE (len2) != INTEGER_CST)\n+      len = len1;\n+    else if (tree_int_cst_lt (len1, len2))\n+      len = len1;\n+    else\n+      len = len2;\n \n-  /* The actual new length parameter is MIN(len,arg3).  */\n-  len = fold (build (MIN_EXPR, TREE_TYPE (len), len, arg3));\n+    /* If both arguments have side effects, we cannot optimize.  */\n+    if (!len || TREE_SIDE_EFFECTS (len))\n+      return 0;\n \n-  newarglist = build_tree_list (NULL_TREE, len);\n-  newarglist = tree_cons (NULL_TREE, arg2, newarglist);\n-  newarglist = tree_cons (NULL_TREE, arg1, newarglist);\n-  return expand_expr (build_function_call_expr (fn, newarglist),\n-\t\t      target, mode, EXPAND_NORMAL);\n+    /* The actual new length parameter is MIN(len,arg3).  */\n+    len = fold (build (MIN_EXPR, TREE_TYPE (len), len, arg3));\n+\n+    /* If we don't have POINTER_TYPE, call the function.  */\n+    if (arg1_align == 0 || arg2_align == 0)\n+      return 0;\n+\n+    /* Make a place to write the result of the instruction.  */\n+    result = target;\n+    if (! (result != 0\n+\t   && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n+\t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+      result = gen_reg_rtx (insn_mode);\n+\n+    arg1_rtx = get_memory_rtx (arg1);\n+    arg2_rtx = get_memory_rtx (arg2);\n+    arg3_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+    insn = gen_cmpstrsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n+\t\t\t GEN_INT (MIN (arg1_align, arg2_align)));\n+    if (!insn)\n+      return 0;\n+\n+    emit_insn (insn);\n+\n+    /* Return the value in the proper mode for this function.  */\n+    mode = TYPE_MODE (TREE_TYPE (exp));\n+    if (GET_MODE (result) == mode)\n+      return result;\n+    if (target == 0)\n+      return convert_to_mode (mode, result, 0);\n+    convert_move (target, result, 0);\n+    return target;\n+  }\n+#endif\n+  return 0;\n }\n \n /* Expand expression EXP, which is a call to the strcat builtin."}]}