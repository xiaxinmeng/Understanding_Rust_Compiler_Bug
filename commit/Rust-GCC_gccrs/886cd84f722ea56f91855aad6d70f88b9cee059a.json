{"sha": "886cd84f722ea56f91855aad6d70f88b9cee059a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg2Y2Q4NGY3MjJlYTU2ZjkxODU1YWFkNmQ3MGY4OGI5Y2VlMDU5YQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-27T11:11:45Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-27T11:11:45Z"}, "message": "tree-switch-conversion.c (struct switch_conv_info): Add range_max, reorganize some fields and update comments.\n\ngcc/\n\t* tree-switch-conversion.c (struct switch_conv_info): Add range_max,\n\treorganize some fields and update comments.  Rename bit_test_uniq\n\tand bit_test_count to uniq resp. count.  Remove bit_test_bb.\n\t(collect_switch_conv_info): New function, collects info about a\n\tGIMPLE_SWITCH into a struct switch_conv_info.\n\t(check_range): Simplify to use pre-recorded info.  Fix think-o in\n\trange-branch ratio check.\n\t(check_process_case): Remove function.\n\t(check_all_empty_except_final): New function, verifies that all\n\tnon-final basic blocks are empty.\n\t(process_switch): Simplify to use pre-recorded info.  Call\n\tcollect_switch_conv_info to do that.  Assert that degenerate switch\n\tstatements have been cleaned up.\n\nFrom-SVN: r186901", "tree": {"sha": "5f1f64dd213b78b4b9122f2cd3032963c065bd34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f1f64dd213b78b4b9122f2cd3032963c065bd34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/886cd84f722ea56f91855aad6d70f88b9cee059a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886cd84f722ea56f91855aad6d70f88b9cee059a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886cd84f722ea56f91855aad6d70f88b9cee059a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886cd84f722ea56f91855aad6d70f88b9cee059a/comments", "author": null, "committer": null, "parents": [{"sha": "07ab2b1b27330b441efdf35bf31f1b2c99dc4ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ab2b1b27330b441efdf35bf31f1b2c99dc4ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ab2b1b27330b441efdf35bf31f1b2c99dc4ebc"}], "stats": {"total": 307, "additions": 154, "deletions": 153}, "files": [{"sha": "f4c19ea566bee68333ad50dd3e30f3b3ffcc2e91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886cd84f722ea56f91855aad6d70f88b9cee059a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886cd84f722ea56f91855aad6d70f88b9cee059a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=886cd84f722ea56f91855aad6d70f88b9cee059a", "patch": "@@ -1,3 +1,19 @@\n+2012-04-27  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree-switch-conversion.c (struct switch_conv_info): Add range_max,\n+\treorganize some fields and update comments.  Rename bit_test_uniq\n+\tand bit_test_count to uniq resp. count.  Remove bit_test_bb.\n+\t(collect_switch_conv_info): New function, collects info about a\n+\tGIMPLE_SWITCH into a struct switch_conv_info.\n+\t(check_range): Simplify to use pre-recorded info.  Fix think-o in\n+\trange-branch ratio check.\n+\t(check_process_case): Remove function.\n+\t(check_all_empty_except_final): New function, verifies that all\n+\tnon-final basic blocks are empty.\n+\t(process_switch): Simplify to use pre-recorded info.  Call\n+\tcollect_switch_conv_info to do that.  Assert that degenerate switch\n+\tstatements have been cleaned up.\n+\n 2012-04-27  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR middle-end/27139"}, {"sha": "3d10750e4dc480996f0bc2322fbd7d2be7a83d2d", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 138, "deletions": 153, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886cd84f722ea56f91855aad6d70f88b9cee059a/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886cd84f722ea56f91855aad6d70f88b9cee059a/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=886cd84f722ea56f91855aad6d70f88b9cee059a", "patch": "@@ -48,6 +48,7 @@ provided.  For example, the following code:\n          default:\n                 a_4 = 16;\n                 b_4 = 1;\n+\t\tbreak;\n         }\n \ta_5 = PHI <a_1, a_2, a_3, a_4>\n \tb_5 = PHI <b_1, b_2, b_3, b_4>\n@@ -69,8 +70,8 @@ is changed into:\n \t    a_7 = 16;\n \t    b_7 = 1;\n           }\n-\t  a_5 = PHI <a_6, a_7>\n-\t  b_b = PHI <b_6, b_7>\n+\ta_5 = PHI <a_6, a_7>\n+\tb_b = PHI <b_6, b_7>\n \n There are further constraints.  Specifically, the range of values across all\n case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default\n@@ -99,25 +100,38 @@ eight) times the number of the actual switch branches. */\n /* The main structure of the pass.  */\n struct switch_conv_info\n {\n-  /* The expression used to decide the switch branch.  (It is subsequently used\n-     as the index to the created array.) */\n+  /* The expression used to decide the switch branch.  */\n   tree index_expr;\n \n-  /* The following integer constants store the minimum value covered by the\n-     cases.  */\n+  /* The following integer constants store the minimum and maximum value\n+     covered by the case labels.  */\n   tree range_min;\n+  tree range_max;\n \n-  /* The difference between the above two numbers, i.e. The size of the array\n-     that would have to be created by the transformation.  */\n+  /* The difference between the above two numbers.  Stored here because it\n+     is used in all the conversion heuristics, as well as for some of the\n+     transformation, and it is expensive to re-compute it all the time.  */\n   tree range_size;\n \n-  /* Basic block that contains the actual SWITCH_EXPR.  */\n+  /* Basic block that contains the actual GIMPLE_SWITCH.  */\n   basic_block switch_bb;\n \n-  /* All branches of the switch statement must have a single successor stored in\n-     the following variable.  */\n+  /* Basic block that is the target of the default case.  */\n+  basic_block default_bb;\n+\n+  /* The single successor block of all branches out of the GIMPLE_SWITCH,\n+     if such a block exists.  Otherwise NULL.  */\n   basic_block final_bb;\n \n+  /* The probability of the default edge in the replaced switch.  */\n+  int default_prob;\n+\n+  /* The count of the default edge in the replaced switch.  */\n+  gcov_type default_count;\n+\n+  /* Combined count of all other (non-default) edges in the replaced switch.  */\n+  gcov_type other_count;\n+\n   /* Number of phi nodes in the final bb (that we'll be replacing).  */\n   int phi_count;\n \n@@ -135,15 +149,6 @@ struct switch_conv_info\n      switch expression is out of range.  */\n   tree *target_outbound_names;\n \n-  /* The probability of the default edge in the replaced switch.  */\n-  int default_prob;\n-\n-  /* The count of the default edge in the replaced switch.  */\n-  gcov_type default_count;\n-\n-  /* Combined count of all other (non-default) edges in the replaced switch.  */\n-  gcov_type other_count;\n-\n   /* The first load statement that loads a temporary from a new static array.\n    */\n   gimple arr_ref_first;\n@@ -157,41 +162,104 @@ struct switch_conv_info\n \n   /* Parameters for expand_switch_using_bit_tests.  Should be computed\n      the same way as in expand_case.  */\n-  unsigned int bit_test_uniq;\n-  unsigned int bit_test_count;\n-  basic_block bit_test_bb[2];\n+  unsigned int uniq;\n+  unsigned int count;\n };\n \n-/* Checks whether the range given by individual case statements of the SWTCH\n-   switch statement isn't too big and whether the number of branches actually\n-   satisfies the size of the new array.  */\n+/* Collect information about GIMPLE_SWITCH statement SWTCH into INFO.  */\n \n-static bool\n-check_range (gimple swtch, struct switch_conv_info *info)\n+static void\n+collect_switch_conv_info (gimple swtch, struct switch_conv_info *info)\n {\n-  tree min_case, max_case;\n   unsigned int branch_num = gimple_switch_num_labels (swtch);\n-  tree range_max;\n+  tree min_case, max_case;\n+  unsigned int count, i;\n+  edge e, e_default;\n+  edge_iterator ei;\n+\n+  memset (info, 0, sizeof (*info));\n \n   /* The gimplifier has already sorted the cases by CASE_LOW and ensured there\n      is a default label which is the first in the vector.  */\n+  gcc_assert (CASE_LOW (gimple_switch_label (swtch, 0)) == NULL_TREE);\n \n-  min_case = gimple_switch_label (swtch, 1);\n-  info->range_min = CASE_LOW (min_case);\n+  /* Collect the bits we can deduce from the CFG.  */\n+  info->index_expr = gimple_switch_index (swtch);\n+  info->switch_bb = gimple_bb (swtch);\n+  info->default_bb =\n+    label_to_block (CASE_LABEL (gimple_switch_label (swtch, 0)));\n+  e_default = find_edge (info->switch_bb, info->default_bb);\n+  info->default_prob = e_default->probability;\n+  info->default_count = e_default->count;\n+  FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+    if (e != e_default)\n+      info->other_count += e->count;\n \n-  gcc_assert (branch_num > 1);\n-  gcc_assert (CASE_LOW (gimple_switch_label (swtch, 0)) == NULL_TREE);\n+  /* See if there is one common successor block for all branch\n+     targets.  If it exists, record it in FINAL_BB.  */\n+  FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+    {\n+      if (! single_pred_p (e->dest))\n+\t{\n+\t  info->final_bb = e->dest;\n+\t  break;\n+\t}\n+    }\n+  if (info->final_bb)\n+    FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n+      {\n+\tif (e->dest == info->final_bb)\n+\t  continue;\n+\n+\tif (single_pred_p (e->dest)\n+\t    && single_succ_p (e->dest)\n+\t    && single_succ (e->dest) == info->final_bb)\n+\t  continue;\n+\n+\tinfo->final_bb = NULL;\n+\tbreak;\n+      }\n+\n+  /* Get upper and lower bounds of case values, and the covered range.  */\n+  min_case = gimple_switch_label (swtch, 1);\n   max_case = gimple_switch_label (swtch, branch_num - 1);\n+\n+  info->range_min = CASE_LOW (min_case);\n   if (CASE_HIGH (max_case) != NULL_TREE)\n-    range_max = CASE_HIGH (max_case);\n+    info->range_max = CASE_HIGH (max_case);\n   else\n-    range_max = CASE_LOW (max_case);\n+    info->range_max = CASE_LOW (max_case);\n \n-  gcc_assert (info->range_min);\n-  gcc_assert (range_max);\n+  info->range_size =\n+    int_const_binop (MINUS_EXPR, info->range_max, info->range_min);\n \n-  info->range_size = int_const_binop (MINUS_EXPR, range_max, info->range_min);\n+  /* Get a count of the number of case labels.  Single-valued case labels\n+     simply count as one, but a case range counts double, since it may\n+     require two compares if it gets lowered as a branching tree.  */\n+  count = 0;\n+  for (i = 1; i < branch_num; i++)\n+    {\n+      tree elt = gimple_switch_label (swtch, i);\n+      count++;\n+      if (CASE_HIGH (elt)\n+\t  && ! tree_int_cst_equal (CASE_LOW (elt), CASE_HIGH (elt)))\n+\tcount++;\n+    }\n+  info->count = count;\n+ \n+  /* Get the number of unique non-default targets out of the GIMPLE_SWITCH\n+     block.  Assume a CFG cleanup would have already removed degenerate\n+     switch statements, this allows us to just use EDGE_COUNT.  */\n+  info->uniq = EDGE_COUNT (gimple_bb (swtch)->succs) - 1;\n+}\n \n+/* Checks whether the range given by individual case statements of the SWTCH\n+   switch statement isn't too big and whether the number of branches actually\n+   satisfies the size of the new array.  */\n+\n+static bool\n+check_range (struct switch_conv_info *info)\n+{\n   gcc_assert (info->range_size);\n   if (!host_integerp (info->range_size, 1))\n     {\n@@ -200,7 +268,7 @@ check_range (gimple swtch, struct switch_conv_info *info)\n     }\n \n   if ((unsigned HOST_WIDE_INT) tree_low_cst (info->range_size, 1)\n-      > ((unsigned) branch_num * SWITCH_CONVERSION_BRANCH_RATIO))\n+      > ((unsigned) info->count * SWITCH_CONVERSION_BRANCH_RATIO))\n     {\n       info->reason = \"the maximum range-branch ratio exceeded\";\n       return false;\n@@ -209,86 +277,24 @@ check_range (gimple swtch, struct switch_conv_info *info)\n   return true;\n }\n \n-/* Checks the given CS switch case whether it is suitable for conversion\n-   (whether all but the default basic blocks are empty and so on).  If it is,\n-   adds the case to the branch list along with values for the defined variables\n-   and returns true.  Otherwise returns false.  */\n+/* Checks whether all but the FINAL_BB basic blocks are empty.  */\n \n static bool\n-check_process_case (tree cs, struct switch_conv_info *info)\n+check_all_empty_except_final (struct switch_conv_info *info)\n {\n-  tree ldecl;\n-  basic_block label_bb, following_bb;\n   edge e;\n+  edge_iterator ei;\n \n-  ldecl = CASE_LABEL (cs);\n-  label_bb = label_to_block (ldecl);\n-\n-  e = find_edge (info->switch_bb, label_bb);\n-  gcc_assert (e);\n-\n-  if (CASE_LOW (cs) == NULL_TREE)\n-    {\n-      /* Default branch.  */\n-      info->default_prob = e->probability;\n-      info->default_count = e->count;\n-    }\n-  else\n-    {\n-      int i;\n-      info->other_count += e->count;\n-      for (i = 0; i < 2; i++)\n-\tif (info->bit_test_bb[i] == label_bb)\n-\t  break;\n-\telse if (info->bit_test_bb[i] == NULL)\n-\t  {\n-\t    info->bit_test_bb[i] = label_bb;\n-\t    info->bit_test_uniq++;\n-\t    break;\n-\t  }\n-      if (i == 2)\n-\tinfo->bit_test_uniq = 3;\n-      if (CASE_HIGH (cs) != NULL_TREE\n-\t  && ! tree_int_cst_equal (CASE_LOW (cs), CASE_HIGH (cs)))\n-\tinfo->bit_test_count += 2;\n-      else\n-\tinfo->bit_test_count++;\n-    }\n-\n-  if (!label_bb)\n-    {\n-      info->reason = \"bad case - cs BB  label is NULL\";\n-      return false;\n-    }\n-\n-  if (!single_pred_p (label_bb))\n+  FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n     {\n-      if (info->final_bb && info->final_bb != label_bb)\n-\t{\n-\t  info->reason = \"bad case - a non-final BB has two predecessors\";\n-\t  return false; /* sth complex going on in this branch  */\n-\t}\n+      if (e->dest == info->final_bb)\n+\tcontinue;\n \n-      following_bb = label_bb;\n-    }\n-  else\n-    {\n-      if (!empty_block_p (label_bb))\n+      if (!empty_block_p (e->dest))\n \t{\n \t  info->reason = \"bad case - a non-final BB not empty\";\n \t  return false;\n \t}\n-\n-      e = single_succ_edge (label_bb);\n-      following_bb = single_succ (label_bb);\n-    }\n-\n-  if (!info->final_bb)\n-    info->final_bb = following_bb;\n-  else if (info->final_bb != following_bb)\n-    {\n-      info->reason = \"bad case - different final BB\";\n-      return false; /* the only successor is not common for all the branches */\n     }\n \n   return true;\n@@ -878,63 +884,42 @@ gen_inbound_check (gimple swtch, struct switch_conv_info *info)\n static const char *\n process_switch (gimple swtch)\n {\n-  unsigned int i, branch_num = gimple_switch_num_labels (swtch);\n-  tree index_type;\n   struct switch_conv_info info;\n \n-  /* Operand 2 is either NULL_TREE or a vector of cases (stmt.c).  */\n-  if (branch_num < 2)\n-    return \"switch has no labels\";\n-\n-  info.reason = NULL;\n-  info.final_bb = NULL;\n-  info.switch_bb = gimple_bb (swtch);\n-  info.index_expr = gimple_switch_index (swtch);\n-  info.arr_ref_first = NULL;\n-  info.arr_ref_last = NULL;\n-  info.default_prob = 0;\n-  info.default_count = 0;\n-  info.other_count = 0;\n-  info.bit_test_uniq = 0;\n-  info.bit_test_count = 0;\n-  info.bit_test_bb[0] = NULL;\n-  info.bit_test_bb[1] = NULL;\n-\n-  /* An ERROR_MARK occurs for various reasons including invalid data type.\n-     (comment from stmt.c) */\n-  index_type = TREE_TYPE (info.index_expr);\n-  if (index_type == error_mark_node)\n-    return \"index error\\n\";\n+  /* Degenerate case with only a default label should never happen.  */\n+  gcc_checking_assert (gimple_switch_num_labels (swtch) > 1);\n+\n+  collect_switch_conv_info (swtch, &info);\n+\n+  /* No error markers should reach here (they should be filtered out\n+     during gimplification).  */\n+  gcc_checking_assert (TREE_TYPE (info.index_expr) != error_mark_node);\n+\n+  /* If there is no common successor, we cannot do the transformation.  */\n+  if (! info.final_bb)\n+    return \"no common successor to all case label target blocks found\";\n+\n+  if (info.uniq <= 2)\n+    {\n+      if (expand_switch_using_bit_tests_p (info.index_expr, info.range_size,\n+\t\t\t\t\t   info.uniq, info.count))\n+\treturn \"expanding as bit test is preferable\";\n+    }\n \n   /* Check the case label values are within reasonable range:  */\n-  if (!check_range (swtch, &info))\n+  if (!check_range (&info))\n     {\n       gcc_assert (info.reason);\n       return info.reason;\n     }\n \n   /* For all the cases, see whether they are empty, the assignments they\n      represent constant and so on...  */\n-  for (i = 0; i < branch_num; i++)\n-    if (!check_process_case (gimple_switch_label (swtch, i), &info))\n-      {\n-\tgcc_assert (info.reason);\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"processing of case %i failed\\n\\t\", i);\n-\treturn info.reason;\n-      }\n-\n-  if (info.bit_test_uniq <= 2)\n+  if (! check_all_empty_except_final (&info))\n     {\n-      rtl_profile_for_bb (gimple_bb (swtch));\n-      if (expand_switch_using_bit_tests_p (gimple_switch_index (swtch),\n-\t\t\t\t\t   info.range_size, info.bit_test_uniq,\n-\t\t\t\t\t   info.bit_test_count))\n-\t{\n-\t  return \"expanding as bit test is preferable\";\n-\t}\n+      gcc_assert (info.reason);\n+      return info.reason;\n     }\n-\n   if (!check_final_bb (&info))\n     {\n       gcc_assert (info.reason);"}]}