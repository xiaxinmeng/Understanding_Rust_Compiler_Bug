{"sha": "dea71ad06f751484f3eb5c52bf12622e4c06b33a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVhNzFhZDA2Zjc1MTQ4NGYzZWI1YzUyYmYxMjYyMmU0YzA2YjMzYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-02-19T18:27:14Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-02-19T18:27:14Z"}, "message": "re PR fortran/79402 (ICE with submodules: module procedure interface defined in parent module)\n\n2017-02-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/79402\n\t* resolve.c (fixup_unique_dummy): New function.\n\t(gfc_resolve_expr): Call it for dummy variables with a unique\n\tsymtree name.\n\n2017-02-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/79402\n\t* gfortran.dg/submodule_23.f90: New test.\n\nFrom-SVN: r245580", "tree": {"sha": "902eaa7282803c05549571ccaaa973291c2f44a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/902eaa7282803c05549571ccaaa973291c2f44a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dea71ad06f751484f3eb5c52bf12622e4c06b33a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea71ad06f751484f3eb5c52bf12622e4c06b33a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea71ad06f751484f3eb5c52bf12622e4c06b33a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea71ad06f751484f3eb5c52bf12622e4c06b33a/comments", "author": null, "committer": null, "parents": [{"sha": "e0396d770f84acfbbbb2397cd2bc53aa57996550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0396d770f84acfbbbb2397cd2bc53aa57996550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0396d770f84acfbbbb2397cd2bc53aa57996550"}], "stats": {"total": 76, "additions": 75, "deletions": 1}, "files": [{"sha": "82733be6fa444eff8e8a060e07f5068605a16eff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dea71ad06f751484f3eb5c52bf12622e4c06b33a", "patch": "@@ -1,3 +1,10 @@\n+017-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/79402\n+\t* resolve.c (fixup_unique_dummy): New function.\n+\t(gfc_resolve_expr): Call it for dummy variables with a unique\n+\tsymtree name.\n+\n 2017-02-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/79335"}, {"sha": "876f3cd5d8cf83991b2d962e7a3d7c858d57a7db", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=dea71ad06f751484f3eb5c52bf12622e4c06b33a", "patch": "@@ -6433,6 +6433,31 @@ gfc_is_expandable_expr (gfc_expr *e)\n   return false;\n }\n \n+\n+/* Sometimes variables in specification expressions of the result\n+   of module procedures in submodules wind up not being the 'real'\n+   dummy.  Find this, if possible, in the namespace of the first\n+   formal argument.  */\n+\n+static void\n+fixup_unique_dummy (gfc_expr *e)\n+{\n+  gfc_symtree *st = NULL;\n+  gfc_symbol *s = NULL;\n+\n+  if (e->symtree->n.sym->ns->proc_name\n+      && e->symtree->n.sym->ns->proc_name->formal)\n+    s = e->symtree->n.sym->ns->proc_name->formal->sym;\n+\n+  if (s != NULL)\n+    st = gfc_find_symtree (s->ns->sym_root, e->symtree->n.sym->name);\n+\n+  if (st != NULL\n+      && st->n.sym != NULL\n+      && st->n.sym->attr.dummy)\n+    e->symtree = st;\n+}\n+\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -6457,6 +6482,14 @@ gfc_resolve_expr (gfc_expr *e)\n       actual_arg = false;\n       first_actual_arg = false;\n     }\n+  else if (e->symtree != NULL\n+\t   && *e->symtree->name == '@'\n+\t   && e->symtree->n.sym->attr.dummy)\n+    {\n+      /* Deal with submodule specification expressions that are not\n+\t found to be referenced in module.c(read_cleanup).  */\n+      fixup_unique_dummy (e);\n+    }\n \n   switch (e->expr_type)\n     {"}, {"sha": "ada192093afc8d9eb82d9096157a1472f895946b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dea71ad06f751484f3eb5c52bf12622e4c06b33a", "patch": "@@ -1,3 +1,8 @@\n+2017-02-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/79402\n+\t* gfortran.dg/submodule_23.f90: New test.\n+\n 2017-02-19  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/79380\n@@ -142,7 +147,7 @@\n \n \tPR target/79481\n \t* gcc.target/i386/sse-14.c (test_2vx): Add void return type.\n-\t(test_3vx): Change return type from int to void. \n+\t(test_3vx): Change return type from int to void.\n \t(_mm512_prefetch_i32gather_ps, _mm512_prefetch_i32scatter_ps,\n \t_mm512_prefetch_i64gather_ps, _mm512_prefetch_i64scatter_ps,\n \t_mm512_prefetch_i32gather_pd, _mm512_prefetch_i32scatter_pd,"}, {"sha": "63674fb499357d0aa50245d5ea1d07670064817a", "filename": "gcc/testsuite/gfortran.dg/submodule_23.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dea71ad06f751484f3eb5c52bf12622e4c06b33a/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_23.f90?ref=dea71ad06f751484f3eb5c52bf12622e4c06b33a", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR79402, in which the module procedure 'fun1' picked\n+! up a spurious symbol for the dummy 'n' in the specification expression\n+! for the result 'y'.\n+!\n+! Contributed by Chris Coutinho  <chrisbcoutinho@gmail.com>\n+!\n+module mod\n+  interface myfun\n+    module function fun1(n) result(y)\n+      integer,  intent(in)    :: n\n+      real, dimension(n)  :: y\n+    end function fun1\n+  end interface myfun\n+\n+end module mod\n+\n+submodule (mod) submod\n+contains\n+  module procedure fun1\n+    integer :: i\n+    y = [(float (i), i = 1, n)]\n+  end procedure fun1\n+end submodule\n+\n+  use mod\n+  print *, fun1(10)\n+end"}]}