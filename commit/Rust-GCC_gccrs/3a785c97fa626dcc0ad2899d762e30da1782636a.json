{"sha": "3a785c97fa626dcc0ad2899d762e30da1782636a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3ODVjOTdmYTYyNmRjYzBhZDI4OTlkNzYyZTMwZGExNzgyNjM2YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-10-12T18:23:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-10-12T18:23:03Z"}, "message": "re PR c/54381 (-Wsizeof-pointer-memaccess refers to \"destination\" for strncmp)\n\n\tPR c/54381\n\t* c-common.h (sizeof_pointer_memaccess_warning): Adjust prototype.\n\t* c-common.c (sizeof_pointer_memaccess_warning): Take array of 3\n\tlocs and array of 3 trees instead of just single loc and single\n\tsizeof_arg tree.  Handle __builtin___*_chk builtins too, and\n\talso stpncpy, bcopy, bcmp, bzero, snprintf and vsnprintf builtins.\n\tFor *cmp* builtins that take two sources strings report warnings\n\tabout first and second source, not about destination and source.\n\n\t* c-parser.c (struct c_tree_loc_pair): Removed.\n\t(c_parser_expr_list): Remove struct c_tree_loc_pair * argument,\n\tadd location_t * and tree * arguments, fill in array of 3\n\tsizeof_arg trees and corresponding locs.\n\t(c_parser_attributes, c_parser_objc_keywordexpr): Adjust\n\tc_parser_expr_list callers.\n\t(c_parser_postfix_expression_after_primary): Likewise.  Pass\n\tarray of 3 sizeof_arg trees and locs (corresponding to first\n\t3 arguments) to sizeof_pointer_memaccess_warning.\n\n\t* semantics.c (finish_call_expr): Pass array of 3 sizeof_arg\n\ttrees and locs (corresponding to first 3 arguments) to\n\tsizeof_pointer_memaccess_warning.\n\n\t* c-c++-common/Wsizeof-pointer-memaccess1.c: New test.\n\t* c-c++-common/Wsizeof-pointer-memaccess2.c: New test.\n\t* gcc.dg/Wsizeof-pointer-memaccess1.c: New test.\n\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Test also stpncpy.\n\tAdjust expected wording of warnings for *cmp* builtins.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Likewise.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Likewise.\n\nFrom-SVN: r192406", "tree": {"sha": "53a2b873d7fe4f0c44a653a6e7c37c843b92ade2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53a2b873d7fe4f0c44a653a6e7c37c843b92ade2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a785c97fa626dcc0ad2899d762e30da1782636a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a785c97fa626dcc0ad2899d762e30da1782636a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a785c97fa626dcc0ad2899d762e30da1782636a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a785c97fa626dcc0ad2899d762e30da1782636a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "313465bbbd04019184339161f0e30a46a5c0e4ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313465bbbd04019184339161f0e30a46a5c0e4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313465bbbd04019184339161f0e30a46a5c0e4ab"}], "stats": {"total": 1752, "additions": 1543, "deletions": 209}, "files": [{"sha": "bb82be4d72d50ef7a86b6e7204670a5534160e70", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -1,3 +1,14 @@\n+2012-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/54381\n+\t* c-common.h (sizeof_pointer_memaccess_warning): Adjust prototype.\n+\t* c-common.c (sizeof_pointer_memaccess_warning): Take array of 3\n+\tlocs and array of 3 trees instead of just single loc and single\n+\tsizeof_arg tree.  Handle __builtin___*_chk builtins too, and\n+\talso stpncpy, bcopy, bcmp, bzero, snprintf and vsnprintf builtins.\n+\tFor *cmp* builtins that take two sources strings report warnings\n+\tabout first and second source, not about destination and source.\n+\n 2012-10-12  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/53055"}, {"sha": "34cfb98f85ba53e994e1a551649494caddf2fdb5", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 152, "deletions": 16, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -1847,52 +1847,105 @@ strict_aliasing_warning (tree otype, tree type, tree expr)\n    sizeof as last operand of certain builtins.  */\n \n void\n-sizeof_pointer_memaccess_warning (location_t loc, tree callee,\n-\t\t\t\t  VEC(tree, gc) *params, tree sizeof_arg,\n+sizeof_pointer_memaccess_warning (location_t *sizeof_arg_loc, tree callee,\n+\t\t\t\t  VEC(tree, gc) *params, tree *sizeof_arg,\n \t\t\t\t  bool (*comp_types) (tree, tree))\n {\n   tree type, dest = NULL_TREE, src = NULL_TREE, tem;\n-  bool strop = false;\n+  bool strop = false, cmp = false;\n+  unsigned int idx = ~0;\n+  location_t loc;\n \n   if (TREE_CODE (callee) != FUNCTION_DECL\n       || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n-      || sizeof_arg == error_mark_node\n       || VEC_length (tree, params) <= 1)\n     return;\n \n-  type = TYPE_P (sizeof_arg) ? sizeof_arg : TREE_TYPE (sizeof_arg);\n-  if (!POINTER_TYPE_P (type))\n-    return;\n-\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_STRNCMP:\n     case BUILT_IN_STRNCASECMP:\n+      cmp = true;\n+      /* FALLTHRU */\n     case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n     case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STRNCAT_CHK:\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n       strop = true;\n       /* FALLTHRU */\n     case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+      if (VEC_length (tree, params) < 3)\n+\treturn;\n+      src = VEC_index (tree, params, 1);\n+      dest = VEC_index (tree, params, 0);\n+      idx = 2;\n+      break;\n+    case BUILT_IN_BCOPY:\n+      if (VEC_length (tree, params) < 3)\n+\treturn;\n+      src = VEC_index (tree, params, 0);\n+      dest = VEC_index (tree, params, 1);\n+      idx = 2;\n+      break;\n     case BUILT_IN_MEMCMP:\n+    case BUILT_IN_BCMP:\n       if (VEC_length (tree, params) < 3)\n \treturn;\n       src = VEC_index (tree, params, 1);\n       dest = VEC_index (tree, params, 0);\n+      idx = 2;\n+      cmp = true;\n       break;\n     case BUILT_IN_MEMSET:\n+    case BUILT_IN_MEMSET_CHK:\n       if (VEC_length (tree, params) < 3)\n \treturn;\n       dest = VEC_index (tree, params, 0);\n+      idx = 2;\n+      break;\n+    case BUILT_IN_BZERO:\n+      dest = VEC_index (tree, params, 0);\n+      idx = 1;\n       break;\n     case BUILT_IN_STRNDUP:\n       src = VEC_index (tree, params, 0);\n       strop = true;\n+      idx = 1;\n+      break;\n+    case BUILT_IN_MEMCHR:\n+      if (VEC_length (tree, params) < 3)\n+\treturn;\n+      src = VEC_index (tree, params, 0);\n+      idx = 2;\n+      break;\n+    case BUILT_IN_SNPRINTF:\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      dest = VEC_index (tree, params, 0);\n+      idx = 1;\n+      strop = true;\n       break;\n     default:\n       break;\n     }\n \n+  if (idx >= 3)\n+    return;\n+\n+  if (sizeof_arg[idx] == NULL || sizeof_arg[idx] == error_mark_node)\n+    return;\n+\n+  type = TYPE_P (sizeof_arg[idx])\n+\t ? sizeof_arg[idx] : TREE_TYPE (sizeof_arg[idx]);\n+  if (!POINTER_TYPE_P (type))\n+    return;\n+\n   if (dest\n       && (tem = tree_strip_nop_conversions (dest))\n       && POINTER_TYPE_P (TREE_TYPE (tem))\n@@ -1905,13 +1958,15 @@ sizeof_pointer_memaccess_warning (location_t loc, tree callee,\n       && comp_types (TREE_TYPE (TREE_TYPE (tem)), type))\n     return;\n \n-  if (dest)\n+  loc = sizeof_arg_loc[idx];\n+\n+  if (dest && !cmp)\n     {\n-      if (!TYPE_P (sizeof_arg)\n-\t  && operand_equal_p (dest, sizeof_arg, 0)\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (dest, sizeof_arg[idx], 0)\n \t  && comp_types (TREE_TYPE (dest), type))\n \t{\n-\t  if (TREE_CODE (sizeof_arg) == ADDR_EXPR && !strop)\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n \t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n \t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n \t\t\t\"expression as the destination; did you mean to \"\n@@ -1945,13 +2000,13 @@ sizeof_pointer_memaccess_warning (location_t loc, tree callee,\n \t}\n     }\n \n-  if (src)\n+  if (src && !cmp)\n     {\n-      if (!TYPE_P (sizeof_arg)\n-\t  && operand_equal_p (src, sizeof_arg, 0)\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (src, sizeof_arg[idx], 0)\n \t  && comp_types (TREE_TYPE (src), type))\n \t{\n-\t  if (TREE_CODE (sizeof_arg) == ADDR_EXPR && !strop)\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n \t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n \t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n \t\t\t\"expression as the source; did you mean to \"\n@@ -1984,6 +2039,87 @@ sizeof_pointer_memaccess_warning (location_t loc, tree callee,\n \t  return;\n \t}\n     }\n+\n+  if (dest)\n+    {\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (dest, sizeof_arg[idx], 0)\n+\t  && comp_types (TREE_TYPE (dest), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the first source; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the first source; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the first source; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (dest))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (dest), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the first source; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (dest),\n+\t\t      TREE_TYPE (TREE_TYPE (dest)));\n+\t  return;\n+\t}\n+    }\n+\n+  if (src)\n+    {\n+      if (!TYPE_P (sizeof_arg[idx])\n+\t  && operand_equal_p (src, sizeof_arg[idx], 0)\n+\t  && comp_types (TREE_TYPE (src), type))\n+\t{\n+\t  if (TREE_CODE (sizeof_arg[idx]) == ADDR_EXPR && !strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the second source; did you mean to \"\n+\t\t\t\"remove the addressof?\", callee);\n+\t  else if ((TYPE_PRECISION (TREE_TYPE (type))\n+\t\t    == TYPE_PRECISION (char_type_node))\n+\t\t   || strop)\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the second source; did you mean to \"\n+\t\t\t\"provide an explicit length?\", callee);\n+\t  else\n+\t    warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t\t\"argument to %<sizeof%> in %qD call is the same \"\n+\t\t\t\"expression as the second source; did you mean to \"\n+\t\t\t\"dereference it?\", callee);\n+\t  return;\n+\t}\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (src))\n+\t  && !strop\n+\t  && comp_types (TREE_TYPE (src), type)\n+\t  && !VOID_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  warning_at (loc, OPT_Wsizeof_pointer_memaccess,\n+\t\t      \"argument to %<sizeof%> in %qD call is the same \"\n+\t\t      \"pointer type %qT as the second source; expected %qT \"\n+\t\t      \"or an explicit length\", callee, TREE_TYPE (src),\n+\t\t      TREE_TYPE (TREE_TYPE (src)));\n+\t  return;\n+\t}\n+    }\n+\n }\n \n /* Warn for unlikely, improbable, or stupid DECL declarations"}, {"sha": "94449a5f3f35d134b045b4a72f8aad4157e40664", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -769,8 +769,8 @@ extern tree fix_string_type (tree);\n extern void constant_expression_warning (tree);\n extern void constant_expression_error (tree);\n extern bool strict_aliasing_warning (tree, tree, tree);\n-extern void sizeof_pointer_memaccess_warning (location_t, tree,\n-\t\t\t\t\t      VEC(tree, gc) *, tree,\n+extern void sizeof_pointer_memaccess_warning (location_t *, tree,\n+\t\t\t\t\t      VEC(tree, gc) *, tree *,\n \t\t\t\t\t      bool (*) (tree, tree));\n extern void warnings_for_convert_and_check (tree, tree, tree);\n extern tree convert_and_check (tree, tree);"}, {"sha": "89d89f7aca26cccdeafae129f2d05c7f09f5d67f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -1,3 +1,16 @@\n+2012-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/54381\n+\t* c-parser.c (struct c_tree_loc_pair): Removed.\n+\t(c_parser_expr_list): Remove struct c_tree_loc_pair * argument,\n+\tadd location_t * and tree * arguments, fill in array of 3\n+\tsizeof_arg trees and corresponding locs.\n+\t(c_parser_attributes, c_parser_objc_keywordexpr): Adjust\n+\tc_parser_expr_list callers.\n+\t(c_parser_postfix_expression_after_primary): Likewise.  Pass\n+\tarray of 3 sizeof_arg trees and locs (corresponding to first\n+\t3 arguments) to sizeof_pointer_memaccess_warning.\n+\n 2012-10-09  Lawrence Crowl  <crowl@google.com>\n \n \t* Make-lang.in (c-decl.o): Add dependence on hash-table.h."}, {"sha": "bfa98afef01fa62f69374a0de2d646700adb7664", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -1111,12 +1111,6 @@ enum c_parser_prec {\n   NUM_PRECS\n };\n \n-/* Expression and its location.  */\n-struct c_tree_loc_pair {\n-  tree expr;\n-  location_t loc;\n-};\n-\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n@@ -1185,8 +1179,8 @@ static tree c_parser_transaction_cancel (c_parser *);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static VEC(tree,gc) *c_parser_expr_list (c_parser *, bool, bool,\n-\t\t\t\t\t VEC(tree,gc) **,\n-\t\t\t\t\t struct c_tree_loc_pair *);\n+\t\t\t\t\t VEC(tree,gc) **, location_t *,\n+\t\t\t\t\t tree *);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -3586,7 +3580,7 @@ c_parser_attributes (c_parser *parser)\n \t\t  tree tree_list;\n \t\t  c_parser_consume_token (parser);\n \t\t  expr_list = c_parser_expr_list (parser, false, true,\n-\t\t\t\t\t\t  NULL, NULL);\n+\t\t\t\t\t\t  NULL, NULL, NULL);\n \t\t  tree_list = build_tree_list_vec (expr_list);\n \t\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n \t\t  release_tree_vector (expr_list);\n@@ -3599,7 +3593,7 @@ c_parser_attributes (c_parser *parser)\n \t      else\n \t\t{\n \t\t  expr_list = c_parser_expr_list (parser, false, true,\n-\t\t\t\t\t\t  NULL, NULL);\n+\t\t\t\t\t\t  NULL, NULL, NULL);\n \t\t  attr_args = build_tree_list_vec (expr_list);\n \t\t  release_tree_vector (expr_list);\n \t\t}\n@@ -6875,7 +6869,9 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n {\n   struct c_expr orig_expr;\n   tree ident, idx;\n-  struct c_tree_loc_pair sizeof_arg;\n+  location_t sizeof_arg_loc[3];\n+  tree sizeof_arg[3];\n+  unsigned int i;\n   VEC(tree,gc) *exprlist;\n   VEC(tree,gc) *origtypes;\n   while (true)\n@@ -6896,21 +6892,24 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_OPEN_PAREN:\n \t  /* Function call.  */\n \t  c_parser_consume_token (parser);\n-\t  sizeof_arg.expr = NULL_TREE;\n+\t  for (i = 0; i < 3; i++)\n+\t    {\n+\t      sizeof_arg[i] = NULL_TREE;\n+\t      sizeof_arg_loc[i] = UNKNOWN_LOCATION;\n+\t    }\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t    exprlist = NULL;\n \t  else\n \t    exprlist = c_parser_expr_list (parser, true, false, &origtypes,\n-\t\t\t\t\t   &sizeof_arg);\n+\t\t\t\t\t   sizeof_arg_loc, sizeof_arg);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  orig_expr = expr;\n \t  mark_exp_read (expr.value);\n-\t  if (warn_sizeof_pointer_memaccess\n-\t      && sizeof_arg.expr != NULL_TREE)\n-\t    sizeof_pointer_memaccess_warning (sizeof_arg.loc,\n+\t  if (warn_sizeof_pointer_memaccess)\n+\t    sizeof_pointer_memaccess_warning (sizeof_arg_loc,\n \t\t\t\t\t      expr.value, exprlist,\n-\t\t\t\t\t      sizeof_arg.expr,\n+\t\t\t\t\t      sizeof_arg,\n \t\t\t\t\t      sizeof_ptr_memacc_comptypes);\n \t  /* FIXME diagnostics: Ideally we want the FUNCNAME, not the\n \t     \"(\" after the FUNCNAME, which is what we have now.    */\n@@ -7072,14 +7071,15 @@ c_parser_expression_conv (c_parser *parser)\n \n static VEC(tree,gc) *\n c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n-\t\t    VEC(tree,gc) **p_orig_types,\n-\t\t    struct c_tree_loc_pair *sizeof_arg)\n+\t\t    VEC(tree,gc) **p_orig_types, location_t *sizeof_arg_loc,\n+\t\t    tree *sizeof_arg)\n {\n   VEC(tree,gc) *ret;\n   VEC(tree,gc) *orig_types;\n   struct c_expr expr;\n   location_t loc = c_parser_peek_token (parser)->location;\n-  location_t sizeof_arg_loc = UNKNOWN_LOCATION;\n+  location_t cur_sizeof_arg_loc = UNKNOWN_LOCATION;\n+  unsigned int idx = 0;\n \n   ret = make_tree_vector ();\n   if (p_orig_types == NULL)\n@@ -7089,7 +7089,7 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \n   if (sizeof_arg != NULL\n       && c_parser_next_token_is_keyword (parser, RID_SIZEOF))\n-    sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n+    cur_sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n     expr = default_function_array_read_conversion (loc, expr);\n@@ -7098,15 +7098,22 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n   VEC_quick_push (tree, ret, expr.value);\n   if (orig_types != NULL)\n     VEC_quick_push (tree, orig_types, expr.original_type);\n+  if (sizeof_arg != NULL\n+      && cur_sizeof_arg_loc != UNKNOWN_LOCATION\n+      && expr.original_code == SIZEOF_EXPR)\n+    {\n+      sizeof_arg[0] = c_last_sizeof_arg;\n+      sizeof_arg_loc[0] = cur_sizeof_arg_loc;\n+    }\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n       loc = c_parser_peek_token (parser)->location;\n       if (sizeof_arg != NULL\n \t  && c_parser_next_token_is_keyword (parser, RID_SIZEOF))\n-\tsizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n+\tcur_sizeof_arg_loc = c_parser_peek_2nd_token (parser)->location;\n       else\n-\tsizeof_arg_loc = UNKNOWN_LOCATION;\n+\tcur_sizeof_arg_loc = UNKNOWN_LOCATION;\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n \texpr = default_function_array_read_conversion (loc, expr);\n@@ -7115,19 +7122,13 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n       VEC_safe_push (tree, gc, ret, expr.value);\n       if (orig_types != NULL)\n \tVEC_safe_push (tree, gc, orig_types, expr.original_type);\n-    }\n-  if (sizeof_arg != NULL)\n-    {\n-      if (sizeof_arg_loc != UNKNOWN_LOCATION\n+      if (++idx < 3\n+\t  && sizeof_arg != NULL\n+\t  && cur_sizeof_arg_loc != UNKNOWN_LOCATION\n \t  && expr.original_code == SIZEOF_EXPR)\n \t{\n-\t  sizeof_arg->expr = c_last_sizeof_arg;\n-\t  sizeof_arg->loc = sizeof_arg_loc;\n-\t}\n-      else\n-\t{\n-\t  sizeof_arg->expr = NULL_TREE;\n-\t  sizeof_arg->loc = UNKNOWN_LOCATION;\n+\t  sizeof_arg[idx] = c_last_sizeof_arg;\n+\t  sizeof_arg_loc[idx] = cur_sizeof_arg_loc;\n \t}\n     }\n   if (orig_types != NULL)\n@@ -8209,7 +8210,7 @@ c_parser_objc_keywordexpr (c_parser *parser)\n {\n   tree ret;\n   VEC(tree,gc) *expr_list = c_parser_expr_list (parser, true, true,\n-\t\t\t\t\t\tNULL, NULL);\n+\t\t\t\t\t\tNULL, NULL, NULL);\n   if (VEC_length (tree, expr_list) == 1)\n     {\n       /* Just return the expression, remove a level of"}, {"sha": "27f0d55ac97342c4058f8e9191f297b099911492", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -1,3 +1,10 @@\n+2012-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/54381\n+\t* semantics.c (finish_call_expr): Pass array of 3 sizeof_arg\n+\ttrees and locs (corresponding to first 3 arguments) to\n+\tsizeof_pointer_memaccess_warning.\n+\n 2012-10-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/24449"}, {"sha": "6798c1bf5d4d1ce95348c97ad560bbd5879eba96", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -2173,16 +2173,30 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n \t{\n \t  if (warn_sizeof_pointer_memaccess\n \t      && !VEC_empty(tree, *args)\n-\t      && TREE_CODE (VEC_last(tree, *args)) == SIZEOF_EXPR\n \t      && !processing_template_decl)\n \t    {\n-\t      tree sizeof_arg = VEC_last(tree, *args);\n-\t      if (SIZEOF_EXPR_TYPE_P (sizeof_arg))\n-\t\tsizeof_arg = TREE_TYPE (TREE_OPERAND (sizeof_arg, 0));\n-\t      else\n-\t\tsizeof_arg = TREE_OPERAND (sizeof_arg, 0);\n+\t      location_t sizeof_arg_loc[3];\n+\t      tree sizeof_arg[3];\n+\t      unsigned int i;\n+\t      for (i = 0; i < 3; i++)\n+\t\t{\n+\t\t  tree t;\n+\n+\t\t  sizeof_arg_loc[i] = UNKNOWN_LOCATION;\n+\t\t  sizeof_arg[i] = NULL_TREE;\n+\t\t  if (i >= VEC_length (tree, *args))\n+\t\t    continue;\n+\t\t  t = VEC_index (tree, *args, i);\n+\t\t  if (TREE_CODE (t) != SIZEOF_EXPR)\n+\t\t    continue;\n+\t\t  if (SIZEOF_EXPR_TYPE_P (t))\n+\t\t    sizeof_arg[i] = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t\t  else\n+\t\t    sizeof_arg[i] = TREE_OPERAND (t, 0);\n+\t\t  sizeof_arg_loc[i] = EXPR_LOCATION (t);\n+\t\t}\n \t      sizeof_pointer_memaccess_warning\n-\t\t(EXPR_LOCATION (VEC_last(tree, *args)), fn, *args,\n+\t\t(sizeof_arg_loc, fn, *args,\n \t\t sizeof_arg, same_type_ignoring_top_level_qualifiers_p);\n \t    }\n "}, {"sha": "0faa27b8b2aa1fe130f962806fb26bbe7bbb7fac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -1,3 +1,14 @@\n+2012-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/54381\n+\t* c-c++-common/Wsizeof-pointer-memaccess1.c: New test.\n+\t* c-c++-common/Wsizeof-pointer-memaccess2.c: New test.\n+\t* gcc.dg/Wsizeof-pointer-memaccess1.c: New test.\n+\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Test also stpncpy.\n+\tAdjust expected wording of warnings for *cmp* builtins.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Likewise.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Likewise.\n+\n 2012-10-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/24449"}, {"sha": "2a5f4193b214c6cfd407e3078b145635963fdfe4", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -0,0 +1,161 @@\n+/* Test -Wsizeof-pointer-memaccess warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern int snprintf (char *, size_t, const char *, ...);\n+extern int vsnprintf (char *, size_t, const char *, __builtin_va_list);\n+extern void *memchr (const void *, int, size_t);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+struct A { short a, b; int c, d; long e, f; };\n+typedef struct A TA;\n+typedef struct A *PA;\n+typedef TA *PTA;\n+struct B {};\n+typedef struct B TB;\n+typedef struct B *PB;\n+typedef TB *PTB;\n+typedef int X[3][3][3];\n+\n+void foo (void **);\n+\n+void\n+f1 (void *x)\n+{\n+  struct A a, *pa1 = &a;\n+  TA *pa2 = &a;\n+  PA pa3 = &a;\n+  PTA pa4 = &a;\n+  void *arr[100];\n+  int i = 0;\n+  arr[i++] = memchr (&a, 0, sizeof (&a));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  arr[i++] = memchr (pa1, 0, sizeof (pa1));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pa2, 0, sizeof pa2);\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pa3, 0, sizeof (pa3));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pa4, 0, sizeof pa4);\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pa1, 0, sizeof (struct A *));\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  arr[i++] = memchr (pa2, 0, sizeof (PTA));\t\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  arr[i++] = memchr (pa3, 0, sizeof (PA));\t\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  arr[i++] = memchr (pa4, 0, sizeof (__typeof (pa4)));\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  arr[i++] = memchr (&a, 0, sizeof a);\n+  arr[i++] = memchr (&a, 0, sizeof (a));\n+  arr[i++] = memchr (&a, 0, sizeof (struct A));\n+  arr[i++] = memchr (&a, 0, sizeof (const struct A));\n+  arr[i++] = memchr (&a, 0, sizeof (volatile struct A));\n+  arr[i++] = memchr (&a, 0, sizeof (volatile const struct A));\n+  arr[i++] = memchr (&a, 0, sizeof (TA));\n+  arr[i++] = memchr (&a, 0, sizeof (__typeof (*&a)));\n+  arr[i++] = memchr (pa1, 0, sizeof (*pa1));\n+  arr[i++] = memchr (pa2, 0, sizeof (*pa3));\n+  arr[i++] = memchr (pa3, 0, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  arr[i++] = memchr ((void *) &a, 0, sizeof (&a));\n+  arr[i++] = memchr ((char *) &a, 0, sizeof (&a));\n+  arr[i++] = memchr (&a, 0, sizeof (&a) + 0);\n+  arr[i++] = memchr (&a, 0, 0 + sizeof (&a));\n+\n+  foo (arr);\n+}\n+\n+void\n+f2 (void *x)\n+{\n+  struct B b, *pb1 = &b;\n+  TB *pb2 = &b;\n+  PB pb3 = &b;\n+  PTB pb4 = &b;\n+  void *arr[100];\n+  int i = 0;\n+  arr[i++] = memchr (&b, 0, sizeof (&b));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  arr[i++] = memchr (pb1, 0, sizeof (pb1));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pb2, 0, sizeof pb2);\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pb3, 0, sizeof (pb3));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pb4, 0, sizeof pb4);\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  arr[i++] = memchr (pb1, 0, sizeof (struct B *));\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  arr[i++] = memchr (pb2, 0, sizeof (PTB));\t\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  arr[i++] = memchr (pb3, 0, sizeof (PB));\t\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  arr[i++] = memchr (pb4, 0, sizeof (__typeof (pb4)));\t/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  arr[i++] = memchr (&b, 0, sizeof b);\n+  arr[i++] = memchr (&b, 0, sizeof (b));\n+  arr[i++] = memchr (&b, 0, sizeof (struct B));\n+  arr[i++] = memchr (&b, 0, sizeof (const struct B));\n+  arr[i++] = memchr (&b, 0, sizeof (volatile struct B));\n+  arr[i++] = memchr (&b, 0, sizeof (volatile const struct B));\n+  arr[i++] = memchr (&b, 0, sizeof (TB));\n+  arr[i++] = memchr (&b, 0, sizeof (__typeof (*&b)));\n+  arr[i++] = memchr (pb1, 0, sizeof (*pb1));\n+  arr[i++] = memchr (pb2, 0, sizeof (*pb3));\n+  arr[i++] = memchr (pb3, 0, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  arr[i++] = memchr ((void *) &b, 0, sizeof (&b));\n+  arr[i++] = memchr ((char *) &b, 0, sizeof (&b));\n+  arr[i++] = memchr (&b, 0, sizeof (&b) + 0);\n+  arr[i++] = memchr (&b, 0, 0 + sizeof (&b));\n+\n+  foo (arr);\n+}\n+\n+void\n+f3 (void *x, char *y, int z, X w)\n+{\n+  unsigned char *y1 = (unsigned char *) __builtin_alloca (z + 16);\n+  char buf1[7];\n+  signed char buf2[z + 32];\n+  long buf3[17];\n+  int *buf4[9];\n+  signed char *y2 = buf2;\n+  char c;\n+  void *arr[100];\n+  int i = 0;\n+  arr[i++] = memchr (y, 0, sizeof (y));\t\t\t/* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  arr[i++] = memchr (y1, 0, sizeof (y1));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  arr[i++] = memchr (y2, 0, sizeof (y2));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  arr[i++] = memchr (&c, 0, sizeof (&c));\t\t/* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  arr[i++] = memchr (w, 0, sizeof w);\t\t\t/* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  /* These are correct, no warning.  */\n+  arr[i++] = memchr (y, 0, sizeof (*y));\n+  arr[i++] = memchr (y1, 0, sizeof (*y2));\n+  arr[i++] = memchr (buf1, 0, sizeof buf1);\n+  arr[i++] = memchr (buf3, 0, sizeof (buf3));\n+  arr[i++] = memchr (&buf3[0], 0, sizeof (buf3));\n+  arr[i++] = memchr (&buf4[0], 0, sizeof (buf4));\n+  arr[i++] = memchr (w, 0, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  arr[i++] = memchr ((void *) y, 0, sizeof (y));\n+  arr[i++] = memchr ((char *) y1, 0, sizeof (y2));\n+  arr[i++] = memchr (y, 0, sizeof (y) + 0);\n+  arr[i++] = memchr (y1, 0, 0 + sizeof (y2));\n+  arr[i++] = memchr ((void *) &c, 0, sizeof (&c));\n+  arr[i++] = memchr ((signed char *) &c, 0, sizeof (&c));\n+  arr[i++] = memchr (&c, 0, sizeof (&c) + 0);\n+  arr[i++] = memchr (&c, 0, 0 + sizeof (&c));\n+\n+  foo (arr);\n+}\n+\n+void\n+f4 (char x[64], char *y, __builtin_va_list ap)\n+{\n+  char buf[128], *p = buf;\n+  snprintf (x, sizeof (x), \"%s\", y);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  vsnprintf (x, sizeof (x), \"%s\", ap);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  snprintf (p, sizeof (p), \"%s\", y);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  vsnprintf (p, sizeof (p), \"%s\", ap);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  snprintf (buf, sizeof (buf), \"%s\", y);\n+  vsnprintf (buf, sizeof (buf), \"%s\", ap);\n+  snprintf (p, sizeof (buf), \"%s\", y);\n+  vsnprintf (p, sizeof (buf), \"%s\", ap);\n+}"}, {"sha": "73cdf0eaba7b83d85e83e940a5036895a4438222", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess2.c", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -0,0 +1,482 @@\n+/* Test -Wsizeof-pointer-memaccess warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -O2\" } */\n+\n+#define bos(ptr) __builtin_object_size (ptr, 1)\n+#define bos0(ptr) __builtin_object_size (ptr, 0)\n+\n+#define memset(dst, val, sz) __builtin___memset_chk (dst, val, sz, bos (dst))\n+#define memcpy(dst, src, sz) __builtin___memcpy_chk (dst, src, sz, bos (dst))\n+#define memmove(dst, src, sz) __builtin___memmove_chk (dst, src, sz, bos (dst))\n+#define strncpy(dst, src, sz) __builtin___strncpy_chk (dst, src, sz, bos (dst))\n+#define strncat(dst, src, sz) __builtin___strncat_chk (dst, src, sz, bos (dst))\n+#define stpncpy(dst, src, sz) __builtin___stpncpy_chk (dst, src, sz, bos (dst))\n+\n+struct A { short a, b; int c, d; long e, f; };\n+typedef struct A TA;\n+typedef struct A *PA;\n+typedef TA *PTA;\n+struct B {};\n+typedef struct B TB;\n+typedef struct B *PB;\n+typedef TB *PTB;\n+typedef int X[3][3][3];\n+\n+void\n+f1 (void *x)\n+{\n+  struct A a, *pa1 = &a;\n+  TA *pa2 = &a;\n+  PA pa3 = &a;\n+  PTA pa4 = &a;\n+  memset (&a, 0, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memset (pa1, 0, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa2, 0, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa3, 0, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa4, 0, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pa1, 0, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pa2, 0, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pa3, 0, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pa4, 0, sizeof (__typeof (pa4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (&a, x, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memcpy (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa2, x, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa4, x, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pa1, x, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pa2, x, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pa3, x, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pa4, x, sizeof (__typeof (pa4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (x, &a, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memcpy (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa2, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa4, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pa1, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pa2, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pa3, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pa4, sizeof (__typeof (pa4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (&a, x, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memmove (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa2, x, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa4, x, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pa1, x, sizeof (struct A *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pa2, x, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pa3, x, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pa4, x, sizeof (__typeof (pa4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (x, &a, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memmove (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa2, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa4, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pa1, sizeof (struct A *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pa2, sizeof (PTA));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pa4, sizeof (__typeof (pa4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  memset (&a, 0, sizeof a);\n+  memset (&a, 0, sizeof (a));\n+  memset (&a, 0, sizeof (struct A));\n+  memset (&a, 0, sizeof (const struct A));\n+  memset (&a, 0, sizeof (volatile struct A));\n+  memset (&a, 0, sizeof (volatile const struct A));\n+  memset (&a, 0, sizeof (TA));\n+  memset (&a, 0, sizeof (__typeof (*&a)));\n+  memset (pa1, 0, sizeof (*pa1));\n+  memset (pa2, 0, sizeof (*pa3));\n+  memset (pa3, 0, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memset ((void *) &a, 0, sizeof (&a));\n+  memset ((char *) &a, 0, sizeof (&a));\n+  memset (&a, 0, sizeof (&a) + 0);\n+  memset (&a, 0, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (&a, x, sizeof a);\n+  memcpy (&a, x, sizeof (a));\n+  memcpy (&a, x, sizeof (struct A));\n+  memcpy (&a, x, sizeof (const struct A));\n+  memcpy (&a, x, sizeof (volatile struct A));\n+  memcpy (&a, x, sizeof (volatile const struct A));\n+  memcpy (&a, x, sizeof (TA));\n+  memcpy (&a, x, sizeof (__typeof (*&a)));\n+  memcpy (pa1, x, sizeof (*pa1));\n+  memcpy (pa2, x, sizeof (*pa3));\n+  memcpy (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy ((void *) &a, x, sizeof (&a));\n+  memcpy ((char *) &a, x, sizeof (&a));\n+  memcpy (&a, x, sizeof (&a) + 0);\n+  memcpy (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (x, &a, sizeof a);\n+  memcpy (x, &a, sizeof (a));\n+  memcpy (x, &a, sizeof (struct A));\n+  memcpy (x, &a, sizeof (const struct A));\n+  memcpy (x, &a, sizeof (volatile struct A));\n+  memcpy (x, &a, sizeof (volatile const struct A));\n+  memcpy (x, &a, sizeof (TA));\n+  memcpy (x, &a, sizeof (__typeof (*&a)));\n+  memcpy (x, pa1, sizeof (*pa1));\n+  memcpy (x, pa2, sizeof (*pa3));\n+  memcpy (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy (x, (void *) &a, sizeof (&a));\n+  memcpy (x, (char *) &a, sizeof (&a));\n+  memcpy (x, &a, sizeof (&a) + 0);\n+  memcpy (x, &a, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memmove (&a, x, sizeof a);\n+  memmove (&a, x, sizeof (a));\n+  memmove (&a, x, sizeof (struct A));\n+  memmove (&a, x, sizeof (const struct A));\n+  memmove (&a, x, sizeof (volatile struct A));\n+  memmove (&a, x, sizeof (volatile const struct A));\n+  memmove (&a, x, sizeof (TA));\n+  memmove (&a, x, sizeof (__typeof (*&a)));\n+  memmove (pa1, x, sizeof (*pa1));\n+  memmove (pa2, x, sizeof (*pa3));\n+  memmove (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove ((void *) &a, x, sizeof (&a));\n+  memmove ((char *) &a, x, sizeof (&a));\n+  memmove (&a, x, sizeof (&a) + 0);\n+  memmove (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  memmove (x, &a, sizeof a);\n+  memmove (x, &a, sizeof (a));\n+  memmove (x, &a, sizeof (struct A));\n+  memmove (x, &a, sizeof (const struct A));\n+  memmove (x, &a, sizeof (volatile struct A));\n+  memmove (x, &a, sizeof (volatile const struct A));\n+  memmove (x, &a, sizeof (TA));\n+  memmove (x, &a, sizeof (__typeof (*&a)));\n+  memmove (x, pa1, sizeof (*pa1));\n+  memmove (x, pa2, sizeof (*pa3));\n+  memmove (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove (x, (void *) &a, sizeof (&a));\n+  memmove (x, (char *) &a, sizeof (&a));\n+  memmove (x, &a, sizeof (&a) + 0);\n+  memmove (x, &a, 0 + sizeof (&a));\n+}\n+\n+void\n+f2 (void *x)\n+{\n+  struct B b, *pb1 = &b;\n+  TB *pb2 = &b;\n+  PB pb3 = &b;\n+  PTB pb4 = &b;\n+  memset (&b, 0, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memset (pb1, 0, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb2, 0, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb3, 0, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb4, 0, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memset (pb1, 0, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pb2, 0, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pb3, 0, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memset (pb4, 0, sizeof (__typeof (pb4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (&b, x, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memcpy (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb2, x, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb4, x, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memcpy (pb1, x, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pb2, x, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pb3, x, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (pb4, x, sizeof (__typeof (pb4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memcpy (x, &b, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memcpy (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb2, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb4, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memcpy (x, pb1, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pb2, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pb3, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memcpy (x, pb4, sizeof (__typeof (pb4))); /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (&b, x, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memmove (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb2, x, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb4, x, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  memmove (pb1, x, sizeof (struct B *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pb2, x, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pb3, x, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (pb4, x, sizeof (__typeof (pb4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  memmove (x, &b, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memmove (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb2, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb4, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  memmove (x, pb1, sizeof (struct B *));    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pb2, sizeof (PTB));    \t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  memmove (x, pb4, sizeof (__typeof (pb4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  memset (&b, 0, sizeof b);\n+  memset (&b, 0, sizeof (b));\n+  memset (&b, 0, sizeof (struct B));\n+  memset (&b, 0, sizeof (const struct B));\n+  memset (&b, 0, sizeof (volatile struct B));\n+  memset (&b, 0, sizeof (volatile const struct B));\n+  memset (&b, 0, sizeof (TB));\n+  memset (&b, 0, sizeof (__typeof (*&b)));\n+  memset (pb1, 0, sizeof (*pb1));\n+  memset (pb2, 0, sizeof (*pb3));\n+  memset (pb3, 0, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memset ((void *) &b, 0, sizeof (&b));\n+  memset ((char *) &b, 0, sizeof (&b));\n+  memset (&b, 0, sizeof (&b) + 0);\n+  memset (&b, 0, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (&b, x, sizeof b);\n+  memcpy (&b, x, sizeof (b));\n+  memcpy (&b, x, sizeof (struct B));\n+  memcpy (&b, x, sizeof (const struct B));\n+  memcpy (&b, x, sizeof (volatile struct B));\n+  memcpy (&b, x, sizeof (volatile const struct B));\n+  memcpy (&b, x, sizeof (TB));\n+  memcpy (&b, x, sizeof (__typeof (*&b)));\n+  memcpy (pb1, x, sizeof (*pb1));\n+  memcpy (pb2, x, sizeof (*pb3));\n+  memcpy (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy ((void *) &b, x, sizeof (&b));\n+  memcpy ((char *) &b, x, sizeof (&b));\n+  memcpy (&b, x, sizeof (&b) + 0);\n+  memcpy (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (x, &b, sizeof b);\n+  memcpy (x, &b, sizeof (b));\n+  memcpy (x, &b, sizeof (struct B));\n+  memcpy (x, &b, sizeof (const struct B));\n+  memcpy (x, &b, sizeof (volatile struct B));\n+  memcpy (x, &b, sizeof (volatile const struct B));\n+  memcpy (x, &b, sizeof (TB));\n+  memcpy (x, &b, sizeof (__typeof (*&b)));\n+  memcpy (x, pb1, sizeof (*pb1));\n+  memcpy (x, pb2, sizeof (*pb3));\n+  memcpy (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy (x, (void *) &b, sizeof (&b));\n+  memcpy (x, (char *) &b, sizeof (&b));\n+  memcpy (x, &b, sizeof (&b) + 0);\n+  memcpy (x, &b, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memmove (&b, x, sizeof b);\n+  memmove (&b, x, sizeof (b));\n+  memmove (&b, x, sizeof (struct B));\n+  memmove (&b, x, sizeof (const struct B));\n+  memmove (&b, x, sizeof (volatile struct B));\n+  memmove (&b, x, sizeof (volatile const struct B));\n+  memmove (&b, x, sizeof (TB));\n+  memmove (&b, x, sizeof (__typeof (*&b)));\n+  memmove (pb1, x, sizeof (*pb1));\n+  memmove (pb2, x, sizeof (*pb3));\n+  memmove (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove ((void *) &b, x, sizeof (&b));\n+  memmove ((char *) &b, x, sizeof (&b));\n+  memmove (&b, x, sizeof (&b) + 0);\n+  memmove (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  memmove (x, &b, sizeof b);\n+  memmove (x, &b, sizeof (b));\n+  memmove (x, &b, sizeof (struct B));\n+  memmove (x, &b, sizeof (const struct B));\n+  memmove (x, &b, sizeof (volatile struct B));\n+  memmove (x, &b, sizeof (volatile const struct B));\n+  memmove (x, &b, sizeof (TB));\n+  memmove (x, &b, sizeof (__typeof (*&b)));\n+  memmove (x, pb1, sizeof (*pb1));\n+  memmove (x, pb2, sizeof (*pb3));\n+  memmove (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove (x, (void *) &b, sizeof (&b));\n+  memmove (x, (char *) &b, sizeof (&b));\n+  memmove (x, &b, sizeof (&b) + 0);\n+  memmove (x, &b, 0 + sizeof (&b));\n+}\n+\n+void\n+f3 (void *x, char *y, int z, X w)\n+{\n+  unsigned char *y1 = (unsigned char *) __builtin_alloca (z + 16);\n+  char buf1[7];\n+  signed char buf2[z + 32];\n+  long buf3[17];\n+  int *buf4[9];\n+  signed char *y2 = buf2;\n+  char c;\n+  char *y3;\n+  memset (y, 0, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memset (y1, 0, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memset (y2, 0, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memset (&c, 0, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memset (w, 0, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  memcpy (y, x, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memcpy (y1, x, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memcpy (y2, x, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memcpy (&c, x, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memcpy (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  memcpy (x, y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memcpy (x, y1, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memcpy (x, y2, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memcpy (x, &c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memcpy (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  memmove (y, x, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memmove (y1, x, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memmove (y2, x, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  memmove (&c, x, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  memmove (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  memmove (x, y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memmove (x, y1, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memmove (x, y2, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  memmove (x, &c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  memmove (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  /* These are correct, no warning.  */\n+  memset (y, 0, sizeof (*y));\n+  memset (y1, 0, sizeof (*y2));\n+  memset (buf1, 0, sizeof buf1);\n+  memset (buf3, 0, sizeof (buf3));\n+  memset (&buf3[0], 0, sizeof (buf3));\n+  memset (&buf4[0], 0, sizeof (buf4));\n+  memset (w, 0, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memset ((void *) y, 0, sizeof (y));\n+  memset ((char *) y1, 0, sizeof (y2));\n+  memset (y, 0, sizeof (y) + 0);\n+  memset (y1, 0, 0 + sizeof (y2));\n+  memset ((void *) &c, 0, sizeof (&c));\n+  memset ((signed char *) &c, 0, sizeof (&c));\n+  memset (&c, 0, sizeof (&c) + 0);\n+  memset (&c, 0, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (y, x, sizeof (*y));\n+  memcpy (y1, x, sizeof (*y2));\n+  memcpy (buf1, x, sizeof buf1);\n+  memcpy (buf3, x, sizeof (buf3));\n+  memcpy (&buf3[0], x, sizeof (buf3));\n+  memcpy (&buf4[0], x, sizeof (buf4));\n+  memcpy (&y3, y, sizeof (y3));\n+  memcpy ((char *) &y3, y, sizeof (y3));\n+  memcpy (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy ((void *) y, x, sizeof (y));\n+  memcpy ((char *) y1, x, sizeof (y2));\n+  memcpy (y, x, sizeof (y) + 0);\n+  memcpy (y1, x, 0 + sizeof (y2));\n+  memcpy ((void *) &c, x, sizeof (&c));\n+  memcpy ((signed char *) &c, x, sizeof (&c));\n+  memcpy (&c, x, sizeof (&c) + 0);\n+  memcpy (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memcpy (x, y, sizeof (*y));\n+  memcpy (x, y1, sizeof (*y2));\n+  memcpy (x, buf1, sizeof buf1);\n+  memcpy (x, buf3, sizeof (buf3));\n+  memcpy (x, &buf3[0], sizeof (buf3));\n+  memcpy (x, &buf4[0], sizeof (buf4));\n+  memcpy (y, &y3, sizeof (y3));\n+  memcpy (y, (char *) &y3, sizeof (y3));\n+  memcpy (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memcpy (x, (void *) y, sizeof (y));\n+  memcpy (x, (char *) y1, sizeof (y2));\n+  memcpy (x, y, sizeof (y) + 0);\n+  memcpy (x, y1, 0 + sizeof (y2));\n+  memcpy (x, (void *) &c, sizeof (&c));\n+  memcpy (x, (signed char *) &c, sizeof (&c));\n+  memcpy (x, &c, sizeof (&c) + 0);\n+  memcpy (x, &c, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memmove (y, x, sizeof (*y));\n+  memmove (y1, x, sizeof (*y2));\n+  memmove (buf1, x, sizeof buf1);\n+  memmove (buf3, x, sizeof (buf3));\n+  memmove (&buf3[0], x, sizeof (buf3));\n+  memmove (&buf4[0], x, sizeof (buf4));\n+  memmove (&y3, y, sizeof (y3));\n+  memmove ((char *) &y3, y, sizeof (y3));\n+  memmove (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove ((void *) y, x, sizeof (y));\n+  memmove ((char *) y1, x, sizeof (y2));\n+  memmove (y, x, sizeof (y) + 0);\n+  memmove (y1, x, 0 + sizeof (y2));\n+  memmove ((void *) &c, x, sizeof (&c));\n+  memmove ((signed char *) &c, x, sizeof (&c));\n+  memmove (&c, x, sizeof (&c) + 0);\n+  memmove (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  memmove (x, y, sizeof (*y));\n+  memmove (x, y1, sizeof (*y2));\n+  memmove (x, buf1, sizeof buf1);\n+  memmove (x, buf3, sizeof (buf3));\n+  memmove (x, &buf3[0], sizeof (buf3));\n+  memmove (x, &buf4[0], sizeof (buf4));\n+  memmove (y, &y3, sizeof (y3));\n+  memmove (y, (char *) &y3, sizeof (y3));\n+  memmove (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  memmove (x, (void *) y, sizeof (y));\n+  memmove (x, (char *) y1, sizeof (y2));\n+  memmove (x, y, sizeof (y) + 0);\n+  memmove (x, y1, 0 + sizeof (y2));\n+  memmove (x, (void *) &c, sizeof (&c));\n+  memmove (x, (signed char *) &c, sizeof (&c));\n+  memmove (x, &c, sizeof (&c) + 0);\n+  memmove (x, &c, 0 + sizeof (&c));\n+}\n+\n+void\n+f4 (char *x, char **y, int z, char w[64])\n+{\n+  const char *s1 = \"foobarbaz\";\n+  const char *s2 = \"abcde12345678\";\n+  strncpy (x, s1, sizeof (s1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  strncat (x, s2, sizeof (s2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  stpncpy (x, s1, sizeof (s1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+\n+  strncpy (w, s1, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  strncat (w, s2, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  stpncpy (w, s1, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  const char s3[] = \"foobarbaz\";\n+  const char s4[] = \"abcde12345678\";\n+  strncpy (x, s3, sizeof (s3));\n+  strncat (x, s4, sizeof (s4));\n+  stpncpy (x, s3, sizeof (s3));\n+}\n+\n+/* { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" } */"}, {"sha": "6cb39809d6ce5c4e74c8f9d5c74eaa2bb2128a53", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -14,6 +14,7 @@ extern void *memmove (void *__restrict, const void *__restrict, size_t);\n extern int memcmp (const void *, const void *, size_t);\n extern char *strncpy (char *__restrict, const char *__restrict, size_t);\n extern char *strncat (char *__restrict, const char *__restrict, size_t);\n+extern char *stpncpy (char *__restrict, const char *__restrict, size_t);\n extern char *strndup (const char *, size_t);\n extern int strncmp (const char *, const char *, size_t);\n extern int strncasecmp (const char *, const char *, size_t);\n@@ -56,6 +57,13 @@ strncat (char *dest, const char *src, size_t len)\n {\n   return __builtin___strncat_chk (dest, src, len, bos (dest));\n }\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+stpncpy (char *__restrict dest, const char *__restrict src, size_t len)\n+{\n+  return __builtin___stpncpy_chk (dest, src, len, bos (dest));\n+}\n #endif\n \n }\n@@ -127,23 +135,23 @@ f1 (void *x, int z)\n   memmove (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n   memmove (x, pa4, sizeof (__typeof (pa4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n-  z += memcmp (&a, x, sizeof (&a));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n-  z += memcmp (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa2, x, sizeof pa2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa4, x, sizeof pa4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa1, x, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pa2, x, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-\n-  z += memcmp (x, &a, sizeof (&a));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n-  z += memcmp (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa2, sizeof pa2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa4, sizeof pa4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa1, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pa2, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (&a, x, sizeof (&a));\t    // { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" }\n+  z += memcmp (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa2, x, sizeof pa2);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa4, x, sizeof pa4);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa1, x, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa2, x, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &a, sizeof (&a));\t    // { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa2, sizeof pa2);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa4, sizeof pa4);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa1, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa2, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n   // These are correct, no warning. \n   memset (&a, 0, sizeof a);\n@@ -331,23 +339,23 @@ f2 (void *x, int z)\n   memmove (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n   memmove (x, pb4, sizeof (__typeof (pb4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n-  z += memcmp (&b, x, sizeof (&b));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n-  z += memcmp (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb2, x, sizeof pb2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb4, x, sizeof pb4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb1, x, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pb2, x, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-\n-  z += memcmp (x, &b, sizeof (&b));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n-  z += memcmp (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb2, sizeof pb2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb4, sizeof pb4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb1, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pb2, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (&b, x, sizeof (&b));\t    // { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" }\n+  z += memcmp (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb2, x, sizeof pb2);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb4, x, sizeof pb4);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb1, x, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb2, x, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &b, sizeof (&b));\t    // { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb2, sizeof pb2);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb4, sizeof pb4);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb1, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb2, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n   // These are correct, no warning. \n   memset (&b, 0, sizeof b);\n@@ -519,17 +527,17 @@ f3 (void *x, char *y, int z, X w)\n   memmove (x, &c, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n   memmove (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n \n-  z += memcmp (y, x, sizeof (y));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += memcmp (y1, x, sizeof (y1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += memcmp (y2, x, sizeof (y2));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += memcmp (&c, x, sizeof (&c));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n-  z += memcmp (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (y, x, sizeof (y));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += memcmp (y1, x, sizeof (y1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += memcmp (y2, x, sizeof (y2));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += memcmp (&c, x, sizeof (&c));\t    // { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" }\n+  z += memcmp (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n \n-  z += memcmp (x, y, sizeof (y));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += memcmp (x, y1, sizeof (y1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += memcmp (x, y2, sizeof (y2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += memcmp (x, &c, sizeof (&c));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n-  z += memcmp (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, y, sizeof (y));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y1, sizeof (y1));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y2, sizeof (y2));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, &c, sizeof (&c));\t    // { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" }\n+  z += memcmp (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n \n   // These are correct, no warning. \n   memset (y, 0, sizeof (*y));\n@@ -673,23 +681,29 @@ f3 (void *x, char *y, int z, X w)\n }\n \n int\n-f4 (char *x, char **y, int z)\n+f4 (char *x, char **y, int z, char w[64])\n {\n   const char *s1 = \"foobarbaz\";\n   const char *s2 = \"abcde12345678\";\n   strncpy (x, s1, sizeof (s1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n   strncat (x, s2, sizeof (s2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  stpncpy (x, s1, sizeof (s1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n   y[0] = strndup (s1, sizeof (s1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += strncmp (s1, s2, sizeof (s1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += strncmp (s1, s2, sizeof (s2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += strncasecmp (s1, s2, sizeof (s1));   // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += strncasecmp (s1, s2, sizeof (s2));   // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s2));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s1));   // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s2));   // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+\n+  strncpy (w, s1, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  strncat (w, s2, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  stpncpy (w, s1, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n \n   // These are correct, no warning. \n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n   strncpy (x, s3, sizeof (s3));\n   strncat (x, s4, sizeof (s4));\n+  stpncpy (x, s3, sizeof (s3));\n   y[1] = strndup (s3, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s4));"}, {"sha": "9e2805d2b7466369ad571cb7a1fd549338571d87", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess2.C", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -14,6 +14,7 @@ extern void *memmove (void *__restrict, const void *__restrict, size_t);\n extern int memcmp (const void *, const void *, size_t);\n extern char *strncpy (char *__restrict, const char *__restrict, size_t);\n extern char *strncat (char *__restrict, const char *__restrict, size_t);\n+extern char *stpncpy (char *__restrict, const char *__restrict, size_t);\n extern char *strndup (const char *, size_t);\n extern int strncmp (const char *, const char *, size_t);\n extern int strncasecmp (const char *, const char *, size_t);\n@@ -56,6 +57,13 @@ strncat (char *dest, const char *src, size_t len)\n {\n   return __builtin___strncat_chk (dest, src, len, bos (dest));\n }\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+stpncpy (char *__restrict dest, const char *__restrict src, size_t len)\n+{\n+  return __builtin___stpncpy_chk (dest, src, len, bos (dest));\n+}\n #endif\n \n }\n@@ -128,23 +136,23 @@ f1 (void *x, int z)\n   memmove (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n   memmove (x, pa4, sizeof (__typeof (pa4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n-  z += memcmp (&a, x, sizeof (&a));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n-  z += memcmp (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa2, x, sizeof pa2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa4, x, sizeof pa4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pa1, x, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pa2, x, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-\n-  z += memcmp (x, &a, sizeof (&a));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n-  z += memcmp (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa2, sizeof pa2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa4, sizeof pa4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pa1, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pa2, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (&a, x, sizeof (&a));\t    // { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" }\n+  z += memcmp (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa2, x, sizeof pa2);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa4, x, sizeof pa4);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pa1, x, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa2, x, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &a, sizeof (&a));\t    // { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa2, sizeof pa2);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa4, sizeof pa4);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pa1, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa2, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n   // These are correct, no warning. \n   memset (&a, 0, sizeof a);\n@@ -333,23 +341,23 @@ f2 (void *x, int z)\n   memmove (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n   memmove (x, pb4, sizeof (__typeof (pb4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n-  z += memcmp (&b, x, sizeof (&b));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n-  z += memcmp (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb2, x, sizeof pb2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb4, x, sizeof pb4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n-  z += memcmp (pb1, x, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pb2, x, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n-\n-  z += memcmp (x, &b, sizeof (&b));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n-  z += memcmp (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb2, sizeof pb2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb4, sizeof pb4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n-  z += memcmp (x, pb1, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pb2, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n-  z += memcmp (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (&b, x, sizeof (&b));\t    // { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" }\n+  z += memcmp (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb2, x, sizeof pb2);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb4, x, sizeof pb4);\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n+  z += memcmp (pb1, x, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb2, x, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &b, sizeof (&b));\t    // { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb2, sizeof pb2);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb4, sizeof pb4);\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n+  z += memcmp (x, pb1, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb2, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" }\n \n   // These are correct, no warning. \n   memset (&b, 0, sizeof b);\n@@ -522,17 +530,17 @@ f3 (void *x, char *y, int z, X w)\n   memmove (x, &c, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n   memmove (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n \n-  z += memcmp (y, x, sizeof (y));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += memcmp (y1, x, sizeof (y1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += memcmp (y2, x, sizeof (y2));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += memcmp (&c, x, sizeof (&c));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n-  z += memcmp (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (y, x, sizeof (y));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += memcmp (y1, x, sizeof (y1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += memcmp (y2, x, sizeof (y2));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += memcmp (&c, x, sizeof (&c));\t    // { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" }\n+  z += memcmp (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" }\n \n-  z += memcmp (x, y, sizeof (y));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += memcmp (x, y1, sizeof (y1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += memcmp (x, y2, sizeof (y2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += memcmp (x, &c, sizeof (&c));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n-  z += memcmp (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, y, sizeof (y));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y1, sizeof (y1));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y2, sizeof (y2));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, &c, sizeof (&c));\t    // { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" }\n+  z += memcmp (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" }\n \n   // These are correct, no warning. \n   memset (y, 0, sizeof (*y));\n@@ -677,23 +685,29 @@ f3 (void *x, char *y, int z, X w)\n \n template <int N>\n int\n-f4 (char *x, char **y, int z)\n+f4 (char *x, char **y, int z, char w[64])\n {\n   const char *s1 = \"foobarbaz\";\n   const char *s2 = \"abcde12345678\";\n   strncpy (x, s1, sizeof (s1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n   strncat (x, s2, sizeof (s2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  stpncpy (x, s1, sizeof (s1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n   y[0] = strndup (s1, sizeof (s1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += strncmp (s1, s2, sizeof (s1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += strncmp (s1, s2, sizeof (s2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n-  z += strncasecmp (s1, s2, sizeof (s1));   // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n-  z += strncasecmp (s1, s2, sizeof (s2));   // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s1));\t    // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s2));\t    // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s1));   // { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s2));   // { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" }\n+\n+  strncpy (w, s1, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  strncat (w, s2, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  stpncpy (w, s1, sizeof (w));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n \n   // These are correct, no warning. \n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n   strncpy (x, s3, sizeof (s3));\n   strncat (x, s4, sizeof (s4));\n+  stpncpy (x, s3, sizeof (s3));\n   y[1] = strndup (s3, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s4));\n@@ -704,12 +718,12 @@ f4 (char *x, char **y, int z)\n }\n \n int\n-f (void *x, char *y, int z, X w, char **u)\n+f (void *x, char *y, int z, X w, char **u, char v[64])\n {\n   z += f1<0> (x, z);\n   z += f2<0> (x, z);\n   z += f3<0> (x, y, z, w);\n-  z += f4<0> (y, u, z);\n+  z += f4<0> (y, u, z, v);\n   return z;\n }\n "}, {"sha": "b683be7ceff8307dc59a801d5c7c9c4c16479cf6", "filename": "gcc/testsuite/gcc.dg/Wsizeof-pointer-memaccess1.c", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -0,0 +1,456 @@\n+/* Test -Wsizeof-pointer-memaccess warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void bzero (void *, size_t);\n+extern void bcopy (void *, const void *, size_t);\n+extern int bcmp (const void *, const void *, size_t);\n+\n+struct A { short a, b; int c, d; long e, f; };\n+typedef struct A TA;\n+typedef struct A *PA;\n+typedef TA *PTA;\n+struct B {};\n+typedef struct B TB;\n+typedef struct B *PB;\n+typedef TB *PTB;\n+typedef int X[3][3][3];\n+\n+int\n+f1 (void *x, int z)\n+{\n+  struct A a, *pa1 = &a;\n+  TA *pa2 = &a;\n+  PA pa3 = &a;\n+  PTA pa4 = &a;\n+  bzero (&a, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  bzero (pa1, sizeof (pa1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pa2, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pa3, sizeof (pa3));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pa4, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pa1, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bzero (pa2, sizeof (PTA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bzero (pa3, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bzero (pa4, sizeof (__typeof (pa4)));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  bcopy (x, &a, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  bcopy (x, pa1, sizeof (pa1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pa2, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pa3, sizeof (pa3));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pa4, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pa1, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (x, pa2, sizeof (PTA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (x, pa3, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (x, pa4, sizeof (__typeof (pa4)));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  bcopy (&a, x, sizeof (&a));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  bcopy (pa1, x, sizeof (pa1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pa2, x, sizeof pa2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pa3, x, sizeof (pa3));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pa4, x, sizeof pa4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pa1, x, sizeof (struct A *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (pa2, x, sizeof (PTA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (pa3, x, sizeof (PA));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (pa4, x, sizeof (__typeof (pa4)));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += bcmp (&a, x, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" } */\n+  z += bcmp (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pa2, x, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pa4, x, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pa1, x, sizeof (struct A *));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (pa2, x, sizeof (PTA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (pa3, x, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += bcmp (x, &a, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" } */\n+  z += bcmp (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pa2, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pa4, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pa1, sizeof (struct A *));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (x, pa2, sizeof (PTA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  bzero (&a, sizeof a);\n+  bzero (&a, sizeof (a));\n+  bzero (&a, sizeof (struct A));\n+  bzero (&a, sizeof (const struct A));\n+  bzero (&a, sizeof (volatile struct A));\n+  bzero (&a, sizeof (volatile const struct A));\n+  bzero (&a, sizeof (TA));\n+  bzero (&a, sizeof (__typeof (*&a)));\n+  bzero (pa1, sizeof (*pa1));\n+  bzero (pa2, sizeof (*pa3));\n+  bzero (pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bzero ((void *) &a, sizeof (&a));\n+  bzero ((char *) &a, sizeof (&a));\n+  bzero (&a, sizeof (&a) + 0);\n+  bzero (&a, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  bcopy (x, &a, sizeof a);\n+  bcopy (x, &a, sizeof (a));\n+  bcopy (x, &a, sizeof (struct A));\n+  bcopy (x, &a, sizeof (const struct A));\n+  bcopy (x, &a, sizeof (volatile struct A));\n+  bcopy (x, &a, sizeof (volatile const struct A));\n+  bcopy (x, &a, sizeof (TA));\n+  bcopy (x, &a, sizeof (__typeof (*&a)));\n+  bcopy (x, pa1, sizeof (*pa1));\n+  bcopy (x, pa2, sizeof (*pa3));\n+  bcopy (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bcopy (x, (void *) &a, sizeof (&a));\n+  bcopy (x, (char *) &a, sizeof (&a));\n+  bcopy (x, &a, sizeof (&a) + 0);\n+  bcopy (x, &a, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  bcopy (&a, x, sizeof a);\n+  bcopy (&a, x, sizeof (a));\n+  bcopy (&a, x, sizeof (struct A));\n+  bcopy (&a, x, sizeof (const struct A));\n+  bcopy (&a, x, sizeof (volatile struct A));\n+  bcopy (&a, x, sizeof (volatile const struct A));\n+  bcopy (&a, x, sizeof (TA));\n+  bcopy (&a, x, sizeof (__typeof (*&a)));\n+  bcopy (pa1, x, sizeof (*pa1));\n+  bcopy (pa2, x, sizeof (*pa3));\n+  bcopy (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bcopy ((void *) &a, x, sizeof (&a));\n+  bcopy ((char *) &a, x, sizeof (&a));\n+  bcopy (&a, x, sizeof (&a) + 0);\n+  bcopy (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  z += bcmp (&a, x, sizeof a);\n+  z += bcmp (&a, x, sizeof (a));\n+  z += bcmp (&a, x, sizeof (struct A));\n+  z += bcmp (&a, x, sizeof (const struct A));\n+  z += bcmp (&a, x, sizeof (volatile struct A));\n+  z += bcmp (&a, x, sizeof (volatile const struct A));\n+  z += bcmp (&a, x, sizeof (TA));\n+  z += bcmp (&a, x, sizeof (__typeof (*&a)));\n+  z += bcmp (pa1, x, sizeof (*pa1));\n+  z += bcmp (pa2, x, sizeof (*pa3));\n+  z += bcmp (pa3, x, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += bcmp ((void *) &a, x, sizeof (&a));\n+  z += bcmp ((char *) &a, x, sizeof (&a));\n+  z += bcmp (&a, x, sizeof (&a) + 0);\n+  z += bcmp (&a, x, 0 + sizeof (&a));\n+\n+  /* These are correct, no warning.  */\n+  z += bcmp (x, &a, sizeof a);\n+  z += bcmp (x, &a, sizeof (a));\n+  z += bcmp (x, &a, sizeof (struct A));\n+  z += bcmp (x, &a, sizeof (const struct A));\n+  z += bcmp (x, &a, sizeof (volatile struct A));\n+  z += bcmp (x, &a, sizeof (volatile const struct A));\n+  z += bcmp (x, &a, sizeof (TA));\n+  z += bcmp (x, &a, sizeof (__typeof (*&a)));\n+  z += bcmp (x, pa1, sizeof (*pa1));\n+  z += bcmp (x, pa2, sizeof (*pa3));\n+  z += bcmp (x, pa3, sizeof (__typeof (*pa3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += bcmp (x, (void *) &a, sizeof (&a));\n+  z += bcmp (x, (char *) &a, sizeof (&a));\n+  z += bcmp (x, &a, sizeof (&a) + 0);\n+  z += bcmp (x, &a, 0 + sizeof (&a));\n+\n+  return z;\n+}\n+\n+int\n+f2 (void *x, int z)\n+{\n+  struct B b, *pb1 = &b;\n+  TB *pb2 = &b;\n+  PB pb3 = &b;\n+  PTB pb4 = &b;\n+  bzero (&b, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  bzero (pb1, sizeof (pb1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pb2, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pb3, sizeof (pb3));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pb4, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bzero (pb1, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bzero (pb2, sizeof (PTB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bzero (pb3, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bzero (pb4, sizeof (__typeof (pb4)));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  bcopy (x, &b, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  bcopy (x, pb1, sizeof (pb1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pb2, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pb3, sizeof (pb3));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pb4, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  bcopy (x, pb1, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (x, pb2, sizeof (PTB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (x, pb3, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (x, pb4, sizeof (__typeof (pb4)));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  bcopy (&b, x, sizeof (&b));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  bcopy (pb1, x, sizeof (pb1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pb2, x, sizeof pb2);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pb3, x, sizeof (pb3));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pb4, x, sizeof pb4);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  bcopy (pb1, x, sizeof (struct B *));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (pb2, x, sizeof (PTB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (pb3, x, sizeof (PB));\t\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  bcopy (pb4, x, sizeof (__typeof (pb4)));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += bcmp (&b, x, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" } */\n+  z += bcmp (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pb2, x, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pb4, x, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += bcmp (pb1, x, sizeof (struct B *));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (pb2, x, sizeof (PTB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (pb3, x, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += bcmp (x, &b, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" } */\n+  z += bcmp (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pb2, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pb4, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += bcmp (x, pb1, sizeof (struct B *));  /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (x, pb2, sizeof (PTB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += bcmp (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  /* These are correct, no warning.  */\n+  bzero (&b, sizeof b);\n+  bzero (&b, sizeof (b));\n+  bzero (&b, sizeof (struct B));\n+  bzero (&b, sizeof (const struct B));\n+  bzero (&b, sizeof (volatile struct B));\n+  bzero (&b, sizeof (volatile const struct B));\n+  bzero (&b, sizeof (TB));\n+  bzero (&b, sizeof (__typeof (*&b)));\n+  bzero (pb1, sizeof (*pb1));\n+  bzero (pb2, sizeof (*pb3));\n+  bzero (pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bzero ((void *) &b, sizeof (&b));\n+  bzero ((char *) &b, sizeof (&b));\n+  bzero (&b, sizeof (&b) + 0);\n+  bzero (&b, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  bcopy (x, &b, sizeof b);\n+  bcopy (x, &b, sizeof (b));\n+  bcopy (x, &b, sizeof (struct B));\n+  bcopy (x, &b, sizeof (const struct B));\n+  bcopy (x, &b, sizeof (volatile struct B));\n+  bcopy (x, &b, sizeof (volatile const struct B));\n+  bcopy (x, &b, sizeof (TB));\n+  bcopy (x, &b, sizeof (__typeof (*&b)));\n+  bcopy (x, pb1, sizeof (*pb1));\n+  bcopy (x, pb2, sizeof (*pb3));\n+  bcopy (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bcopy (x, (void *) &b, sizeof (&b));\n+  bcopy (x, (char *) &b, sizeof (&b));\n+  bcopy (x, &b, sizeof (&b) + 0);\n+  bcopy (x, &b, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  bcopy (&b, x, sizeof b);\n+  bcopy (&b, x, sizeof (b));\n+  bcopy (&b, x, sizeof (struct B));\n+  bcopy (&b, x, sizeof (const struct B));\n+  bcopy (&b, x, sizeof (volatile struct B));\n+  bcopy (&b, x, sizeof (volatile const struct B));\n+  bcopy (&b, x, sizeof (TB));\n+  bcopy (&b, x, sizeof (__typeof (*&b)));\n+  bcopy (pb1, x, sizeof (*pb1));\n+  bcopy (pb2, x, sizeof (*pb3));\n+  bcopy (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bcopy ((void *) &b, x, sizeof (&b));\n+  bcopy ((char *) &b, x, sizeof (&b));\n+  bcopy (&b, x, sizeof (&b) + 0);\n+  bcopy (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  z += bcmp (&b, x, sizeof b);\n+  z += bcmp (&b, x, sizeof (b));\n+  z += bcmp (&b, x, sizeof (struct B));\n+  z += bcmp (&b, x, sizeof (const struct B));\n+  z += bcmp (&b, x, sizeof (volatile struct B));\n+  z += bcmp (&b, x, sizeof (volatile const struct B));\n+  z += bcmp (&b, x, sizeof (TB));\n+  z += bcmp (&b, x, sizeof (__typeof (*&b)));\n+  z += bcmp (pb1, x, sizeof (*pb1));\n+  z += bcmp (pb2, x, sizeof (*pb3));\n+  z += bcmp (pb3, x, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += bcmp ((void *) &b, x, sizeof (&b));\n+  z += bcmp ((char *) &b, x, sizeof (&b));\n+  z += bcmp (&b, x, sizeof (&b) + 0);\n+  z += bcmp (&b, x, 0 + sizeof (&b));\n+\n+  /* These are correct, no warning.  */\n+  z += bcmp (x, &b, sizeof b);\n+  z += bcmp (x, &b, sizeof (b));\n+  z += bcmp (x, &b, sizeof (struct B));\n+  z += bcmp (x, &b, sizeof (const struct B));\n+  z += bcmp (x, &b, sizeof (volatile struct B));\n+  z += bcmp (x, &b, sizeof (volatile const struct B));\n+  z += bcmp (x, &b, sizeof (TB));\n+  z += bcmp (x, &b, sizeof (__typeof (*&b)));\n+  z += bcmp (x, pb1, sizeof (*pb1));\n+  z += bcmp (x, pb2, sizeof (*pb3));\n+  z += bcmp (x, pb3, sizeof (__typeof (*pb3)));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += bcmp (x, (void *) &b, sizeof (&b));\n+  z += bcmp (x, (char *) &b, sizeof (&b));\n+  z += bcmp (x, &b, sizeof (&b) + 0);\n+  z += bcmp (x, &b, 0 + sizeof (&b));\n+\n+  return z;\n+}\n+\n+int\n+f3 (void *x, char *y, int z, X w)\n+{\n+  unsigned char *y1 = (unsigned char *) __builtin_alloca (z + 16);\n+  char buf1[7];\n+  signed char buf2[z + 32];\n+  long buf3[17];\n+  int *buf4[9];\n+  signed char *y2 = buf2;\n+  char c;\n+  char *y3;\n+  bzero (y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  bzero (y1, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  bzero (y2, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  bzero (&c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  bzero (w, sizeof w);\t\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  bcopy (x, y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  bcopy (x, y1, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  bcopy (x, y2, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  bcopy (x, &c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n+  bcopy (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+\n+  bcopy (y, x, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  bcopy (y1, x, sizeof (y1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  bcopy (y2, x, sizeof (y2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  bcopy (&c, x, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n+  bcopy (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+\n+  z += bcmp (y, x, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += bcmp (y1, x, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += bcmp (y2, x, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += bcmp (&c, x, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" } */\n+  z += bcmp (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+\n+  z += bcmp (x, y, sizeof (y));\t\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += bcmp (x, y1, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += bcmp (x, y2, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += bcmp (x, &c, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" } */\n+  z += bcmp (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+\n+  /* These are correct, no warning.  */\n+  bzero (y, sizeof (*y));\n+  bzero (y1, sizeof (*y2));\n+  bzero (buf1, sizeof buf1);\n+  bzero (buf3, sizeof (buf3));\n+  bzero (&buf3[0], sizeof (buf3));\n+  bzero (&buf4[0], sizeof (buf4));\n+  bzero (w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bzero ((void *) y, sizeof (y));\n+  bzero ((char *) y1, sizeof (y2));\n+  bzero (y, sizeof (y) + 0);\n+  bzero (y1, 0 + sizeof (y2));\n+  bzero ((void *) &c, sizeof (&c));\n+  bzero ((signed char *) &c, sizeof (&c));\n+  bzero (&c, sizeof (&c) + 0);\n+  bzero (&c, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  bcopy (x, y, sizeof (*y));\n+  bcopy (x, y1, sizeof (*y2));\n+  bcopy (x, buf1, sizeof buf1);\n+  bcopy (x, buf3, sizeof (buf3));\n+  bcopy (x, &buf3[0], sizeof (buf3));\n+  bcopy (x, &buf4[0], sizeof (buf4));\n+  bcopy (y, &y3, sizeof (y3));\n+  bcopy (y, (char *) &y3, sizeof (y3));\n+  bcopy (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bcopy (x, (void *) y, sizeof (y));\n+  bcopy (x, (char *) y1, sizeof (y2));\n+  bcopy (x, y, sizeof (y) + 0);\n+  bcopy (x, y1, 0 + sizeof (y2));\n+  bcopy (x, (void *) &c, sizeof (&c));\n+  bcopy (x, (signed char *) &c, sizeof (&c));\n+  bcopy (x, &c, sizeof (&c) + 0);\n+  bcopy (x, &c, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  bcopy (y, x, sizeof (*y));\n+  bcopy (y1, x, sizeof (*y2));\n+  bcopy (buf1, x, sizeof buf1);\n+  bcopy (buf3, x, sizeof (buf3));\n+  bcopy (&buf3[0], x, sizeof (buf3));\n+  bcopy (&buf4[0], x, sizeof (buf4));\n+  bcopy (&y3, y, sizeof (y3));\n+  bcopy ((char *) &y3, y, sizeof (y3));\n+  bcopy (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  bcopy ((void *) y, x, sizeof (y));\n+  bcopy ((char *) y1, x, sizeof (y2));\n+  bcopy (y, x, sizeof (y) + 0);\n+  bcopy (y1, x, 0 + sizeof (y2));\n+  bcopy ((void *) &c, x, sizeof (&c));\n+  bcopy ((signed char *) &c, x, sizeof (&c));\n+  bcopy (&c, x, sizeof (&c) + 0);\n+  bcopy (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  z += bcmp (y, x, sizeof (*y));\n+  z += bcmp (y1, x, sizeof (*y2));\n+  z += bcmp (buf1, x, sizeof buf1);\n+  z += bcmp (buf3, x, sizeof (buf3));\n+  z += bcmp (&buf3[0], x, sizeof (buf3));\n+  z += bcmp (&buf4[0], x, sizeof (buf4));\n+  z += bcmp (&y3, y, sizeof (y3));\n+  z += bcmp ((char *) &y3, y, sizeof (y3));\n+  z += bcmp (w, x, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += bcmp ((void *) y, x, sizeof (y));\n+  z += bcmp ((char *) y1, x, sizeof (y2));\n+  z += bcmp (y, x, sizeof (y) + 0);\n+  z += bcmp (y1, x, 0 + sizeof (y2));\n+  z += bcmp ((void *) &c, x, sizeof (&c));\n+  z += bcmp ((signed char *) &c, x, sizeof (&c));\n+  z += bcmp (&c, x, sizeof (&c) + 0);\n+  z += bcmp (&c, x, 0 + sizeof (&c));\n+\n+  /* These are correct, no warning.  */\n+  z += bcmp (x, y, sizeof (*y));\n+  z += bcmp (x, y1, sizeof (*y2));\n+  z += bcmp (x, buf1, sizeof buf1);\n+  z += bcmp (x, buf3, sizeof (buf3));\n+  z += bcmp (x, &buf3[0], sizeof (buf3));\n+  z += bcmp (x, &buf4[0], sizeof (buf4));\n+  z += bcmp (y, &y3, sizeof (y3));\n+  z += bcmp (y, (char *) &y3, sizeof (y3));\n+  z += bcmp (x, w, sizeof (X));\n+  /* These are probably broken, but obfuscated, no warning.  */\n+  z += bcmp (x, (void *) y, sizeof (y));\n+  z += bcmp (x, (char *) y1, sizeof (y2));\n+  z += bcmp (x, y, sizeof (y) + 0);\n+  z += bcmp (x, y1, 0 + sizeof (y2));\n+  z += bcmp (x, (void *) &c, sizeof (&c));\n+  z += bcmp (x, (signed char *) &c, sizeof (&c));\n+  z += bcmp (x, &c, sizeof (&c) + 0);\n+  z += bcmp (x, &c, 0 + sizeof (&c));\n+\n+  return z;\n+}"}, {"sha": "8d01bc616a77bc0a012227cb879c777558bb7995", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a785c97fa626dcc0ad2899d762e30da1782636a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=3a785c97fa626dcc0ad2899d762e30da1782636a", "patch": "@@ -12,6 +12,7 @@ extern void *memmove (void *__restrict, const void *__restrict, size_t);\n extern int memcmp (const void *, const void *, size_t);\n extern char *strncpy (char *__restrict, const char *__restrict, size_t);\n extern char *strncat (char *__restrict, const char *__restrict, size_t);\n+extern char *stpncpy (char *__restrict, const char *__restrict, size_t);\n extern char *strndup (const char *, size_t);\n extern int strncmp (const char *, const char *, size_t);\n extern int strncasecmp (const char *, const char *, size_t);\n@@ -54,6 +55,13 @@ strncat (char *dest, const char *src, size_t len)\n {\n   return __builtin___strncat_chk (dest, src, len, bos (dest));\n }\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+stpncpy (char *__restrict dest, const char *__restrict src, size_t len)\n+{\n+  return __builtin___stpncpy_chk (dest, src, len, bos (dest));\n+}\n #endif\n \n struct A { short a, b; int c, d; long e, f; };\n@@ -123,23 +131,23 @@ f1 (void *x, int z)\n   memmove (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n   memmove (x, pa4, sizeof (__typeof (pa4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n \n-  z += memcmp (&a, x, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n-  z += memcmp (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pa2, x, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pa4, x, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pa1, x, sizeof (struct A *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (pa2, x, sizeof (PTA));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (pa3, x, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-\n-  z += memcmp (x, &a, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n-  z += memcmp (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pa2, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pa4, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pa1, sizeof (struct A *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (x, pa2, sizeof (PTA));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (&a, x, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" } */\n+  z += memcmp (pa1, x, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pa2, x, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pa3, x, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pa4, x, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pa1, x, sizeof (struct A *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pa2, x, sizeof (PTA));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pa3, x, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += memcmp (x, &a, sizeof (&a));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" } */\n+  z += memcmp (x, pa1, sizeof (pa1));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa2, sizeof pa2);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa3, sizeof (pa3));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa4, sizeof pa4);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pa1, sizeof (struct A *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pa2, sizeof (PTA));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pa3, sizeof (PA));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n \n   /* These are correct, no warning.  */\n   memset (&a, 0, sizeof a);\n@@ -327,23 +335,23 @@ f2 (void *x, int z)\n   memmove (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n   memmove (x, pb4, sizeof (__typeof (pb4)));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n \n-  z += memcmp (&b, x, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n-  z += memcmp (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pb2, x, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pb4, x, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n-  z += memcmp (pb1, x, sizeof (struct B *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (pb2, x, sizeof (PTB));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (pb3, x, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-\n-  z += memcmp (x, &b, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n-  z += memcmp (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pb2, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pb4, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n-  z += memcmp (x, pb1, sizeof (struct B *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (x, pb2, sizeof (PTB));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n-  z += memcmp (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (&b, x, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" } */\n+  z += memcmp (pb1, x, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pb2, x, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pb3, x, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pb4, x, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n+  z += memcmp (pb1, x, sizeof (struct B *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pb2, x, sizeof (PTB));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (pb3, x, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the first source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+\n+  z += memcmp (x, &b, sizeof (&b));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" } */\n+  z += memcmp (x, pb1, sizeof (pb1));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb2, sizeof pb2);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb3, sizeof (pb3));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb4, sizeof pb4);\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n+  z += memcmp (x, pb1, sizeof (struct B *));/* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pb2, sizeof (PTB));       /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n+  z += memcmp (x, pb3, sizeof (PB));\t    /* { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the second source; expected \\[^\\n\\r\\]* or an explicit length\" } */\n \n   /* These are correct, no warning.  */\n   memset (&b, 0, sizeof b);\n@@ -515,17 +523,17 @@ f3 (void *x, char *y, int z, X w)\n   memmove (x, &c, sizeof (&c));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n   memmove (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n \n-  z += memcmp (y, x, sizeof (y));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n-  z += memcmp (y1, x, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n-  z += memcmp (y2, x, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n-  z += memcmp (&c, x, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" } */\n-  z += memcmp (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" } */\n+  z += memcmp (y, x, sizeof (y));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += memcmp (y1, x, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += memcmp (y2, x, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += memcmp (&c, x, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to remove the addressof\" } */\n+  z += memcmp (w, x, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the first source; did you mean to dereference it\" } */\n \n-  z += memcmp (x, y, sizeof (y));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n-  z += memcmp (x, y1, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n-  z += memcmp (x, y2, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n-  z += memcmp (x, &c, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" } */\n-  z += memcmp (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to dereference it\" } */\n+  z += memcmp (x, y, sizeof (y));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += memcmp (x, y1, sizeof (y1));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += memcmp (x, y2, sizeof (y2));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += memcmp (x, &c, sizeof (&c));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to remove the addressof\" } */\n+  z += memcmp (x, w, sizeof w);\t\t    /* { dg-warning \"call is the same expression as the second source; did you mean to dereference it\" } */\n \n   /* These are correct, no warning.  */\n   memset (y, 0, sizeof (*y));\n@@ -669,23 +677,29 @@ f3 (void *x, char *y, int z, X w)\n }\n \n int\n-f4 (char *x, char **y, int z)\n+f4 (char *x, char **y, int z, char w[64])\n {\n   const char *s1 = \"foobarbaz\";\n   const char *s2 = \"abcde12345678\";\n   strncpy (x, s1, sizeof (s1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n   strncat (x, s2, sizeof (s2));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  stpncpy (x, s1, sizeof (s1));\t\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n   y[0] = strndup (s1, sizeof (s1));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n-  z += strncmp (s1, s2, sizeof (s1));\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n-  z += strncmp (s1, s2, sizeof (s2));\t    /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n-  z += strncasecmp (s1, s2, sizeof (s1));   /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n-  z += strncasecmp (s1, s2, sizeof (s2));   /* { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" } */\n+  z += strncmp (s1, s2, sizeof (s1));\t    /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += strncmp (s1, s2, sizeof (s2));\t    /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+  z += strncasecmp (s1, s2, sizeof (s1));   /* { dg-warning \"call is the same expression as the first source; did you mean to provide an explicit length\" } */\n+  z += strncasecmp (s1, s2, sizeof (s2));   /* { dg-warning \"call is the same expression as the second source; did you mean to provide an explicit length\" } */\n+\n+  strncpy (w, s1, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  strncat (w, s2, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n+  stpncpy (w, s1, sizeof (w));\t\t    /* { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" } */\n \n   /* These are correct, no warning.  */\n   const char s3[] = \"foobarbaz\";\n   const char s4[] = \"abcde12345678\";\n   strncpy (x, s3, sizeof (s3));\n   strncat (x, s4, sizeof (s4));\n+  stpncpy (x, s3, sizeof (s3));\n   y[1] = strndup (s3, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s3));\n   z += strncmp (s3, s4, sizeof (s4));"}]}