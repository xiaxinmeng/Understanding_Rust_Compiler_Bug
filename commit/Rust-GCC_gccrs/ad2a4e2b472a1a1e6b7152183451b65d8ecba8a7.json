{"sha": "ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyYTRlMmI0NzJhMWExZTZiNzE1MjE4MzQ1MWI2NWQ4ZWNiYThhNw==", "commit": {"author": {"name": "Stephan Buys", "email": "sbproxy@icon.co.za", "date": "2002-02-08T02:19:06Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-02-08T02:19:06Z"}, "message": "stl_map.h: Tweak doxygen markup.\n\n2002-02-07  Stephan Buys  <sbproxy@icon.co.za>\n\n\t* include/bits/stl_map.h:  Tweak doxygen markup.\n\t* include/bits/stl_multimap.h:  Doxygenate and remove extra spaces.\n\t* include/bits/stl_vector.h:  Likewise.\n\nFrom-SVN: r49602", "tree": {"sha": "0c46c275a3375eedd4c163c1165fcac05ea919ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c46c275a3375eedd4c163c1165fcac05ea919ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/comments", "author": null, "committer": null, "parents": [{"sha": "07814743cf9b934c94d540a7820a3683abacfb38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07814743cf9b934c94d540a7820a3683abacfb38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07814743cf9b934c94d540a7820a3683abacfb38"}], "stats": {"total": 612, "additions": 555, "deletions": 57}, "files": [{"sha": "39b67eac647f7d328252f72a4ccb7e0f8b4d714c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "patch": "@@ -1,3 +1,9 @@\n+2002-02-07  Stephan Buys  <sbproxy@icon.co.za>\n+\n+\t* include/bits/stl_map.h:  Tweak doxygen markup.\n+\t* include/bits/stl_multimap.h:  Doxygenate and remove extra spaces.\n+\t* include/bits/stl_vector.h:  Likewise.\n+\n 2002-02-07  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tlibstdc++/5286\n@@ -75,7 +81,7 @@\n \t* docs/doxygen/run_doxygen:  Adjust for new mainpage.\n \t* docs/doxygen/user.cfg.in:  Likewise.\n \n-2002-02-04  Stephan Buys  <s.buys@icon.co.za>\n+2002-02-04  Stephan Buys  <sbproxy@icon.co.za>\n \n \t* include/bits/stl_map.h:  Initial doxygen markup.\n \t* include/std/std_fstream.h:  Initial doxygen markup."}, {"sha": "07c62e4fb5b4f10448dc5d252971f891cdf2285e", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "patch": "@@ -212,6 +212,7 @@ class map\n   /**\n    *  @brief Subscript ( [] ) access to map data.\n    *  @param  k  The key for which data should be retrieved.\n+   * \n    *  Allows for easy lookup with the subscript ( [] ) operator.  Returns the\n    *  data associated with the key specified in subscript.  If the key does\n    *  not exist a pair with that key is created with a default value, which\n@@ -278,19 +279,20 @@ class map\n    *  This function erases an element, pointed to by the given iterator, from\n    *  a map.  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  That is the user's responsibilty.\n+   *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n   void erase(iterator __position) { _M_t.erase(__position); }\n \n   /**\n    *  @brief Erases an element according to the provided key.\n    *  @param  x  Key of element to be erased.\n-   *  @return  Doc me!\n+   *  @return  Doc me! (Number of elements that match key? Only makes sense\n+   *           with multimap)\n    *\n    *  This function erases an element, located by the given key, from a map.\n    *  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  That is the user's responsibilty.\n+   *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n   size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n \n@@ -302,12 +304,16 @@ class map\n    *  This function erases a sequence of elements from a map.\n    *  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n-   *  in any way.  That is the user's responsibilty.\n+   *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n   void erase(iterator __first, iterator __last)\n     { _M_t.erase(__first, __last); }\n \n-  /** Erases all elements in a map.  */\n+  /** Erases all elements in a map.  Note that this function only erases\n+   *  the elements, and that if the elements themselves are pointers, the\n+   *  pointed-to memory is not touched in any way.  Managing the pointer is\n+   *  the user's responsibilty.\n+  */\n   void clear() { _M_t.clear(); }\n \n   // map operations:"}, {"sha": "5947d7537a67154cd3339841f7d04f9843f3fd0c", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 237, "deletions": 11, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "patch": "@@ -65,22 +65,28 @@\n \n namespace std\n {\n-\n // Forward declaration of operators < and ==, needed for friend declaration.\n-\n-template <class _Key, class _Tp, \n+template <class _Key, class _Tp,\n           class _Compare = less<_Key>,\n           class _Alloc = allocator<pair<const _Key, _Tp> > >\n class multimap;\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n \n+/**\n+ *  @brief A standard container made up of pairs (see std::pair in <utility>)\n+ *         which can be retrieved based on a key.\n+ *\n+ *  This is an associative container.  Values contained within it can be\n+ *  quickly retrieved through a key element. In contrast with a map a\n+ *  multimap can have multiple duplicate keys.\n+*/\n template <class _Key, class _Tp, class _Compare, class _Alloc>\n class multimap\n {\n@@ -110,7 +116,7 @@ class multimap\n   };\n \n private:\n-  typedef _Rb_tree<key_type, value_type, \n+  typedef _Rb_tree<key_type, value_type,\n                   _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n   _Rep_type _M_t;  // red-black tree representing multimap\n public:\n@@ -157,51 +163,271 @@ class multimap\n   value_compare value_comp() const { return value_compare(_M_t.key_comp()); }\n   allocator_type get_allocator() const { return _M_t.get_allocator(); }\n \n+  /**\n+   *  Returns a read/write iterator that points to the first pair in the\n+   *  multimap.  Iteration is done in ascending order according to the keys.\n+  */\n   iterator begin() { return _M_t.begin(); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points to the first pair\n+   *  in the multimap.  Iteration is done in ascending order according to the\n+   *  keys.\n+  */\n   const_iterator begin() const { return _M_t.begin(); }\n+\n+  /**\n+   *  Returns a read/write iterator that points one past the last pair in the\n+   *  multimap.  Iteration is done in ascending order according to the keys.\n+  */\n   iterator end() { return _M_t.end(); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points one past the last\n+   *  pair in the multimap.  Iteration is done in ascending order according\n+   *  to the keys.\n+  */\n   const_iterator end() const { return _M_t.end(); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to the last pair in\n+   *  the multimap.  Iteration is done in descending order according to the\n+   *  keys.\n+  */\n   reverse_iterator rbegin() { return _M_t.rbegin(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to the last\n+   *  pair in the multimap.  Iteration is done in descending order according\n+   *  to the keys.\n+  */\n   const_reverse_iterator rbegin() const { return _M_t.rbegin(); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to one before the\n+   *  first pair in the multimap.  Iteration is done in descending order\n+   *  according to the keys.\n+  */\n   reverse_iterator rend() { return _M_t.rend(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to one\n+   *  before the first pair in the multimap.  Iteration is done in descending\n+   *  order according to the keys.\n+  */\n   const_reverse_iterator rend() const { return _M_t.rend(); }\n+\n+  /** Returns true if the map is empty.  (Thus begin() would equal end().)  */\n   bool empty() const { return _M_t.empty(); }\n+\n+  /** Returns the size of the map.  */\n   size_type size() const { return _M_t.size(); }\n+\n+  /** Returns the maximum size of the map.  */\n   size_type max_size() const { return _M_t.max_size(); }\n+\n   void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n \n   // insert/erase\n-\n+  /**\n+   *  @brief Inserts a std::pair into the multimap.\n+   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+   *             pairs).\n+   *  @return An iterator that points to the inserted (key,value) pair.\n+   *\n+   *  This function inserts a (key, value) pair into the multimap.  Contrary\n+   *  to a std::map the multimap does not rely on unique keys and thus a\n+   *  multiple pairs with the same key can be inserted.\n+  */\n   iterator insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n+\n+  /**\n+   *  @brief Inserts a std::pair into the multimap.\n+   *  @param  position  An iterator that serves as a hint as to where the\n+   *                    pair should be inserted.\n+   *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n+   *             pairs).\n+   *  @return An iterator that points to the inserted (key,value) pair.\n+   *\n+   *  This function inserts a (key, value) pair into the multimap.  Contrary\n+   *  to a std::map the multimap does not rely on unique keys and thus a\n+   *  multiple pairs with the same key can be inserted.\n+   *  Note that the first parameter is only a hint and can potentially\n+   *  improve the performance of the insertion process.  A bad hint would\n+   *  cause no gains in efficiency.\n+  */\n   iterator insert(iterator __position, const value_type& __x) {\n     return _M_t.insert_equal(__position, __x);\n   }\n+\n+  /**\n+   *  @brief A template function that attemps to insert elements from\n+   *         another range (possibly another multimap or standard container).\n+   *  @param  first  Iterator pointing to the start of the range to be\n+   *                 inserted.\n+   *  @param  last  Iterator pointing to the end of the range to be inserted.\n+  */\n   template <class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_equal(__first, __last);\n   }\n+\n+  /**\n+   *  @brief Erases an element from a multimap.\n+   *  @param  position  An iterator pointing to the element to be erased.\n+   *\n+   *  This function erases an element, pointed to by the given iterator, from\n+   *  a mutlimap.  Note that this function only erases the element, and that\n+   *  if the element is itself a pointer, the pointed-to memory is not\n+   *  touched in any way.  Managing the pointer is the user's responsibilty.\n+  */\n   void erase(iterator __position) { _M_t.erase(__position); }\n+\n+  /**\n+   *  @brief Erases an element according to the provided key.\n+   *  @param  x  Key of element to be erased.\n+   *  @return  Doc me! (Number of elements erased?)\n+   *\n+   *  This function erases all elements, located by the given key, from a\n+   *  multimap.\n+   *  Note that this function only erases the element, and that if\n+   *  the element is itself a pointer, the pointed-to memory is not touched\n+   *  in any way.  Managing the pointer is the user's responsibilty.\n+  */\n   size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+\n+  /**\n+   *  @brief Erases a [first,last) range of elements from a multimap.\n+   *  @param  first  Iterator pointing to the start of the range to be erased.\n+   *  @param  last  Iterator pointing to the end of the range to be erased.\n+   *\n+   *  This function erases a sequence of elements from a multimap.\n+   *  Note that this function only erases the elements, and that if\n+   *  the elements themselves are pointers, the pointed-to memory is not\n+   *  touched in any way.  Managing the pointer is the user's responsibilty.\n+  */\n   void erase(iterator __first, iterator __last)\n     { _M_t.erase(__first, __last); }\n+\n+  /** Erases all elements in a multimap.  Note that this function only erases\n+   *  the elements, and that if the elements themselves are pointers, the\n+   *  pointed-to memory is not touched in any way.  Managing the pointer is\n+   *  the user's responsibilty.\n+  */\n   void clear() { _M_t.clear(); }\n \n   // multimap operations:\n \n+  /**\n+   *  @brief Tries to locate an element in a multimap.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Iterator pointing to sought-after (first matching?) element,\n+   *           or end() if not found.\n+   *\n+   *  This function takes a key and tries to locate the element with which\n+   *  the key matches.  If successful the function returns an iterator\n+   *  pointing to the sought after pair. If unsuccessful it returns the\n+   *  one past the end ( end() ) iterator.\n+  */\n   iterator find(const key_type& __x) { return _M_t.find(__x); }\n+\n+  /**\n+   *  @brief Tries to locate an element in a multimap.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Read-only (constant) iterator pointing to sought-after (first\n+   *           matching?) element, or end() if not found.\n+   *\n+   *  This function takes a key and tries to locate the element with which\n+   *  the key matches.  If successful the function returns a constant iterator\n+   *  pointing to the sought after pair. If unsuccessful it returns the\n+   *  one past the end ( end() ) iterator.\n+  */\n   const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+\n+  /**\n+   *  @brief Finds the number of elements with given key.\n+   *  @param  x  Key of (key, value) pairs to be located.\n+   *  @return Number of elements with specified key.\n+  */\n   size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+\n+  /**\n+   *  @brief Finds the beginning of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Iterator pointing to first element matching given key, or\n+   *           end() if not found.\n+   *\n+   *  This function returns the first element of a subsequence of elements\n+   *  that matches the given key.  If unsuccessful it returns an iterator\n+   *  pointing to the first element that has a greater value than given key\n+   *  or end() if no such element exists.\n+  */\n   iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n+\n+  /**\n+   *  @brief Finds the beginning of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Read-only (constant) iterator pointing to first element\n+   *           matching given key, or end() if not found.\n+   *\n+   *  This function returns the first element of a subsequence of elements\n+   *  that matches the given key.  If unsuccessful the iterator will point\n+   *  to the next greatest element or, if no such greater element exists, to\n+   *  end().\n+  */\n   const_iterator lower_bound(const key_type& __x) const {\n-    return _M_t.lower_bound(__x); \n+    return _M_t.lower_bound(__x);\n   }\n+\n+  /**\n+   *  @brief Finds the end of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return Iterator pointing to last element matching given key.\n+  */\n   iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }\n+\n+  /**\n+   *  @brief Finds the end of a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pair to be located.\n+   *  @return  Read-only (constant) iterator pointing to last element matching\n+   *           given key.\n+  */\n   const_iterator upper_bound(const key_type& __x) const {\n-    return _M_t.upper_bound(__x); \n+    return _M_t.upper_bound(__x);\n   }\n-   pair<iterator,iterator> equal_range(const key_type& __x) {\n+\n+  /**\n+   *  @brief Finds a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pairs to be located.\n+   *  @return  Pair of iterators that possibly points to the subsequence\n+   *           matching given key.\n+   *\n+   *  This function improves on lower_bound() and upper_bound() by giving a more\n+   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  element possibly points to the first element matching the given key\n+   *  and the second element possibly points to the last element matching the\n+   *  given key.  If unsuccessful the first element of the returned pair will\n+   *  contain an iterator pointing to the next greatest element or, if no such\n+   *  greater element exists, to end().\n+  */\n+  pair<iterator,iterator> equal_range(const key_type& __x) {\n     return _M_t.equal_range(__x);\n   }\n+\n+  /**\n+   *  @brief Finds a subsequence matching given key.\n+   *  @param  x  Key of (key, value) pairs to be located.\n+   *  @return  Pair of read-only (constant) iterators that possibly points to\n+   *           the subsequence matching given key.\n+   *\n+   *  This function improves on lower_bound() and upper_bound() by giving a more\n+   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  element possibly points to the first element matching the given key\n+   *  and the second element possibly points to the last element matching the\n+   *  given key.  If unsuccessful the first element of the returned pair will\n+   *  contain an iterator pointing to the next greatest element or, if no such\n+   *  a greater element exists, to end().\n+  */\n   pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n     return _M_t.equal_range(__x);\n   }\n@@ -215,7 +441,7 @@ class multimap\n };\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n+inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n   return __x._M_t == __y._M_t;\n }"}, {"sha": "4d8e7513e9f6af5a9f6d7ce093b213cb9f6b400b", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 300, "deletions": 40, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=ad2a4e2b472a1a1e6b7152183451b65d8ecba8a7", "patch": "@@ -66,7 +66,7 @@\n #include <bits/concept_check.h>\n \n namespace std\n-{ \n+{\n \n // The vector base class serves two purposes.  First, its constructor\n // and destructor allocate (but don't initialize) storage.  This makes\n@@ -83,9 +83,9 @@ class _Vector_alloc_base {\n   allocator_type get_allocator() const { return _M_data_allocator; }\n \n   _Vector_alloc_base(const allocator_type& __a)\n-    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) \n+    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n   {}\n-  \n+\n protected:\n   allocator_type _M_data_allocator;\n   _Tp* _M_start;\n@@ -99,7 +99,7 @@ class _Vector_alloc_base {\n };\n \n // Specialization for allocators that have the property that we don't\n-// actually have to store an allocator object.  \n+// actually have to store an allocator object.\n template <class _Tp, class _Allocator>\n class _Vector_alloc_base<_Tp, _Allocator, true> {\n public:\n@@ -108,9 +108,9 @@ class _Vector_alloc_base<_Tp, _Allocator, true> {\n   allocator_type get_allocator() const { return allocator_type(); }\n \n   _Vector_alloc_base(const allocator_type&)\n-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) \n+    : _M_start(0), _M_finish(0), _M_end_of_storage(0)\n   {}\n-  \n+\n protected:\n   _Tp* _M_start;\n   _Tp* _M_finish;\n@@ -128,7 +128,7 @@ struct _Vector_base\n   : public _Vector_alloc_base<_Tp, _Alloc,\n                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n {\n-  typedef _Vector_alloc_base<_Tp, _Alloc, \n+  typedef _Vector_alloc_base<_Tp, _Alloc,\n                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n           _Base;\n   typedef typename _Base::allocator_type allocator_type;\n@@ -141,11 +141,20 @@ struct _Vector_base\n   }\n \n   ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n-};    \n+};\n \n \n+/**\n+ *  @brief  A standard container which offers fixed time access to individual\n+ *  elements in any order.\n+ *\n+ *  In some terminology a vector can be described as a dynamic C-style array,\n+ *  it offers fast and efficient access to individual elements in any order\n+ *  and saves the user from worrying about memory and size allocation.\n+ *  Subscripting ( [] ) access is also provided as with C-style arrays.\n+*/\n template <class _Tp, class _Alloc = allocator<_Tp> >\n-class vector : protected _Vector_base<_Tp, _Alloc> \n+class vector : protected _Vector_base<_Tp, _Alloc>\n {\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n@@ -182,56 +191,147 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   void _M_insert_aux(iterator __position);\n \n public:\n+  /**\n+   *  Returns a read/write iterator that points to the first element in the\n+   *  vector.  Iteration is done in ordinary element order.\n+  */\n   iterator begin() { return iterator (_M_start); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points to the first element\n+   *  in the vector.  Iteration is done in ordinary element order.\n+  */\n   const_iterator begin() const\n     { return const_iterator (_M_start); }\n+\n+  /**\n+   *  Returns a read/write iterator that points one past the last element in\n+   *  the vector.  Iteration is done in ordinary element order.\n+  */\n   iterator end() { return iterator (_M_finish); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points one past the last\n+   *  element in the vector.  Iteration is done in ordinary element order.\n+  */\n   const_iterator end() const { return const_iterator (_M_finish); }\n \n+  /**\n+   *  Returns a read/write reverse iterator that points to the last element in\n+   *  the vector.  Iteration is done in reverse element order.\n+  */\n   reverse_iterator rbegin()\n     { return reverse_iterator(end()); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to the last\n+   *  element in the vector.  Iteration is done in reverse element order.\n+  */\n   const_reverse_iterator rbegin() const\n     { return const_reverse_iterator(end()); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to one before the\n+   *  first element in the vector.  Iteration is done in reverse element\n+   *  order.\n+  */\n   reverse_iterator rend()\n     { return reverse_iterator(begin()); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to one\n+   *  before the first element in the vector.  Iteration is done in reverse\n+   *  element order.\n+  */\n   const_reverse_iterator rend() const\n     { return const_reverse_iterator(begin()); }\n \n+  /**  Returns the number of elements in the vector.  */\n   size_type size() const\n     { return size_type(end() - begin()); }\n+\n+  /**  Returns the size of the largest possible vector.  */\n   size_type max_size() const\n     { return size_type(-1) / sizeof(_Tp); }\n+\n+  /**\n+   *  Returns the amount of memory that has been alocated for the current\n+   *  elements (?).\n+  */\n   size_type capacity() const\n     { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n+\n+  /**\n+   *  Returns true if the vector is empty.  (Thus begin() would equal end().)\n+  */\n   bool empty() const\n     { return begin() == end(); }\n \n+  /**\n+   *  @brief  Subscript access to the data contained in the vector.\n+   *  @param  n  The element for which data should be accessed.\n+   *  @return  Read/write reference to data.\n+   *\n+   *  This operator allows for easy, array-style, data access.\n+   *  Note that data access with this operator is unchecked and out_of_range\n+   *  lookups are not defined. (For checked lookups see at().)\n+  */\n   reference operator[](size_type __n) { return *(begin() + __n); }\n+\n+  /**\n+   *  @brief  Subscript access to the data contained in the vector.\n+   *  @param  n  The element for which data should be accessed.\n+   *  @return  Read-only (constant) reference to data.\n+   *\n+   *  This operator allows for easy, array-style, data access.\n+   *  Note that data access with this operator is unchecked and out_of_range\n+   *  lookups are not defined. (For checked lookups see at().)\n+  */\n   const_reference operator[](size_type __n) const { return *(begin() + __n); }\n \n   void _M_range_check(size_type __n) const {\n     if (__n >= this->size())\n       __throw_out_of_range(\"vector\");\n   }\n \n+  /**\n+   *  @brief  Provides access to the data contained in the vector.\n+   *  @param  n  The element for which data should be accessed.\n+   *  @return  Read/write reference to data.\n+   *\n+   *  This function provides for safer data access.  The parameter is first\n+   *  checked that it is in the range of the vector.  The function throws\n+   *  out_of_range if the check fails.\n+  */\n   reference at(size_type __n)\n     { _M_range_check(__n); return (*this)[__n]; }\n+\n+  /**\n+   *  @brief  Provides access to the data contained in the vector.\n+   *  @param  n  The element for which data should be accessed.\n+   *  @return  Read-only (constant) reference to data.\n+   *\n+   *  This function provides for safer data access.  The parameter is first\n+   *  checked that it is in the range of the vector.  The function throws\n+   *  out_of_range if the check fails.\n+  */\n   const_reference at(size_type __n) const\n     { _M_range_check(__n); return (*this)[__n]; }\n \n+\n   explicit vector(const allocator_type& __a = allocator_type())\n     : _Base(__a) {}\n \n   vector(size_type __n, const _Tp& __value,\n-         const allocator_type& __a = allocator_type()) \n+         const allocator_type& __a = allocator_type())\n     : _Base(__n, __a)\n     { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n \n   explicit vector(size_type __n)\n     : _Base(__n, allocator_type())\n     { _M_finish = uninitialized_fill_n(_M_start, __n, _Tp()); }\n \n-  vector(const vector<_Tp, _Alloc>& __x) \n+  vector(const vector<_Tp, _Alloc>& __x)\n     : _Base(__x.size(), __x.get_allocator())\n     { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n \n@@ -249,7 +349,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     void _M_initialize_aux(_Integer __n, _Integer __value, __true_type)\n \t{\n       _M_start = _M_allocate(__n);\n-      _M_end_of_storage = _M_start + __n; \n+      _M_end_of_storage = _M_start + __n;\n       _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n     }\n \n@@ -265,6 +365,21 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   { _Destroy(_M_start, _M_finish); }\n \n   vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);\n+\n+  /**\n+   *  @brief  Attempt to preallocate enough memory for specified number of\n+   *          elements.\n+   *  @param  n  Number of elements required\n+   *\n+   *  This function attempts to reserve enough memory for the vector to hold\n+   *  the specified number of elements.  If the number requested is more than\n+   *  max_size() length_error is thrown.\n+   *\n+   *  The advantage of this function is that if optimal code is a necessity\n+   *  and the user can determine the number of elements that will be required\n+   *  the user can reserve the memory and thus prevent a possible\n+   *  reallocation of memory and copy of vector data.\n+  */\n   void reserve(size_type __n) {\n     if (capacity() < __n) {\n       const size_type __old_size = size();\n@@ -282,6 +397,17 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   // The range version is a member template, so we dispatch on whether\n   // or not the type is an integer.\n \n+  /**\n+   *  @brief  Assigns a given value or range to a vector.\n+   *  @param  n  Number of elements to be assigned.\n+   *  @param  val  Value to be assigned.\n+   *\n+   *  This function can be used to assign a range to a vector or fill it\n+   *  with a specified number of copies of the given value.\n+   *  Note that the assignment completely changes the vector and that the\n+   *  resulting vector's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n+  */\n   void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n   void _M_fill_assign(size_type __n, const _Tp& __val);\n \n@@ -312,13 +438,41 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n \n   template <class _ForwardIterator>\n   void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                     forward_iterator_tag); \n+                     forward_iterator_tag);\n \n+  /**\n+   *  Returns a read/write reference to the data at the first element of the\n+   *  vector.\n+  */\n   reference front() { return *begin(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the vector.\n+  */\n   const_reference front() const { return *begin(); }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the last element of the\n+   *  vector.\n+  */\n   reference back() { return *(end() - 1); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the vector.\n+  */\n   const_reference back() const { return *(end() - 1); }\n \n+  /**\n+   *  @brief  Add data to the end of the vector.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical stack operation.  The function creates an element at\n+   *  the end of the vector and assigns the given data to it.\n+   *  Due to the nature of a vector this operation can be done in constant\n+   *  time if the vector has preallocated space available.\n+  */\n   void\n   push_back(const _Tp& __x)\n   {\n@@ -330,6 +484,10 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       _M_insert_aux(end(), __x);\n   }\n \n+  /**\n+   *  Add an element to the end of the vector.  The element is\n+   *  default-constructed.\n+  */\n   void\n   push_back()\n   {\n@@ -349,6 +507,17 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     std::swap(_M_end_of_storage, __x._M_end_of_storage);\n   }\n \n+  /**\n+   *  @brief  Inserts given value into vector at specified element.\n+   *  @param  position  An iterator that points to the element where data\n+   *                    should be inserted.\n+   *  @param  x  Data to be inserted.\n+   *  @return  An iterator that points to the inserted data.\n+   *\n+   *  This function will insert the given value into the specified location.\n+   *  Note that this kind of operation could be expensive for a vector and if\n+   *  it is frequently used the user should consider using std::list.\n+  */\n   iterator\n   insert(iterator __position, const _Tp& __x)\n   {\n@@ -362,6 +531,17 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     return begin() + __n;\n   }\n \n+  /**\n+   *  @brief  Inserts an empty element into the vector.\n+   *  @param  position  An iterator that points to the element where empty\n+   *                    element should be inserted.\n+   *  @param  x  Data to be inserted.\n+   *  @return  An iterator that points to the inserted element.\n+   *\n+   *  This function will insert an empty element into the specified location.\n+   *  Note that this kind of operation could be expensive for a vector and if\n+   *  it is frequently used the user should consider using std::list.\n+  */\n   iterator\n   insert(iterator __position)\n   {\n@@ -399,42 +579,122 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       _M_range_insert(__pos, __first, __last, _IterCategory());\n     }\n \n+  /**\n+   *  @brief  Inserts a number of copies of given data into the vector.\n+   *  @param  position  An iterator that points to the element where data\n+   *                    should be inserted.\n+   *  @param  n  Amount of elements to be inserted.\n+   *  @param  x  Data to be inserted.\n+   *\n+   *  This function will insert a specified number of copies of the given data\n+   *  into the specified location.\n+   *\n+   *  Note that this kind of operation could be expensive for a vector and if\n+   *  it is frequently used the user should consider using std::list.\n+  */\n   void insert (iterator __pos, size_type __n, const _Tp& __x)\n     { _M_fill_insert(__pos, __n, __x); }\n \n   void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);\n \n+  /**\n+   *  @brief  Removes last element from vector.\n+   *\n+   *  This is a typical stack operation. It allows us to shrink the vector by\n+   *  one.\n+   *\n+   *  Note that no data is returned and if last element's data is needed it\n+   *  should be retrieved before pop_back() is called.\n+  */\n   void pop_back() {\n     --_M_finish;\n     _Destroy(_M_finish);\n   }\n+\n+  /**\n+   *  @brief  Remove element at given position\n+   *  @param  position  Iterator pointing to element to be erased.\n+   *  @return  Doc Me! (Iterator pointing to new element at old location?)\n+   *\n+   *  This function will erase the element at the given position and thus\n+   *  shorten the vector by one.\n+   *\n+   *  Note This operation could be expensive and if it is frequently used the\n+   *  user should consider using std::list.  The user is also cautioned that\n+   *  this function only erases the element, and that if the element is itself\n+   *  a pointer, the pointed-to memory is not touched in any way.  Managing\n+   *  the pointer is the user's responsibilty.\n+  */\n   iterator erase(iterator __position) {\n     if (__position + 1 != end())\n       copy(__position + 1, end(), __position);\n     --_M_finish;\n     _Destroy(_M_finish);\n     return __position;\n   }\n+\n+  /**\n+   *  @brief  Remove a range of elements from a vector.\n+   *  @param  first  Iterator pointing to the first element to be erased.\n+   *  @param  last  Iterator pointing to the last element to be erased.\n+   *  @return  Doc Me! (Iterator pointing to new element at old location?)\n+   *\n+   *  This function will erase the elements in the given range and shorten the\n+   *  vector accordingly.\n+   *\n+   *  Note This operation could be expensive and if it is frequently used the\n+   *  user should consider using std::list.  The user is also cautioned that\n+   *  this function only erases the elements, and that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n   iterator erase(iterator __first, iterator __last) {\n     iterator __i(copy(__last, end(), __first));\n     _Destroy(__i, end());\n     _M_finish = _M_finish - (__last - __first);\n     return __first;\n   }\n \n+  /**\n+   *  @brief  Resizes the vector to the specified number of elements.\n+   *  @param  new_size  Number of elements the vector should contain.\n+   *  @param  x  Data with which new elements should be populated.\n+   *\n+   *  This function will resize the vector to the specified number of\n+   *  elements.  If the number is smaller than the vector's current size the\n+   *  vector is truncated, otherwise the vector is extended and new elements\n+   *  are populated with given data.\n+  */\n   void resize(size_type __new_size, const _Tp& __x) {\n-    if (__new_size < size()) \n+    if (__new_size < size())\n       erase(begin() + __new_size, end());\n     else\n       insert(end(), __new_size - size(), __x);\n   }\n+\n+  /**\n+   *  @brief  Resizes the vector to the specified number of elements.\n+   *  @param  new_size  Number of elements the vector should contain.\n+   *\n+   *  This function will resize the vector to the specified number of\n+   *  elements.  If the number is smaller than the vector's current size the\n+   *  vector is truncated, otherwise the vector is extended and new elements\n+   *  are left uninitialized.\n+  */\n   void resize(size_type __new_size) { resize(__new_size, _Tp()); }\n+\n+  /**\n+   *  Erases all elements in vector.  Note that this function only erases the\n+   *  elements, and that if the elements themselves are pointers, the\n+   *  pointed-to memory is not touched in any way.  Managing the pointer is\n+   *  the user's responsibilty.\n+  */\n   void clear() { erase(begin(), end()); }\n \n protected:\n \n   template <class _ForwardIterator>\n-  pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first, \n+  pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first,\n                                                _ForwardIterator __last)\n   {\n     pointer __result = _M_allocate(__n);\n@@ -443,21 +703,21 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       return __result;\n     }\n     catch(...)\n-      { \n+      {\n \t_M_deallocate(__result, __n);\n \t__throw_exception_again;\n       }\n   }\n \n   template <class _InputIterator>\n-  void _M_range_initialize(_InputIterator __first,  \n+  void _M_range_initialize(_InputIterator __first,\n                            _InputIterator __last, input_iterator_tag)\n   {\n     for ( ; __first != __last; ++__first)\n       push_back(*__first);\n   }\n \n-  // This function is only called by the constructor. \n+  // This function is only called by the constructor.\n   template <class _ForwardIterator>\n   void _M_range_initialize(_ForwardIterator __first,\n                            _ForwardIterator __last, forward_iterator_tag)\n@@ -480,18 +740,18 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n };\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n {\n   return __x.size() == __y.size() &&\n          equal(__x.begin(), __x.end(), __y.begin());\n }\n \n template <class _Tp, class _Alloc>\n-inline bool \n+inline bool\n operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n {\n-  return lexicographical_compare(__x.begin(), __x.end(), \n+  return lexicographical_compare(__x.begin(), __x.end(),\n                                  __y.begin(), __y.end());\n }\n \n@@ -526,7 +786,7 @@ operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n }\n \n template <class _Tp, class _Alloc>\n-vector<_Tp,_Alloc>& \n+vector<_Tp,_Alloc>&\n vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n {\n   if (&__x != this) {\n@@ -552,7 +812,7 @@ vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n }\n \n template <class _Tp, class _Alloc>\n-void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val) \n+void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)\n {\n   if (__n > capacity()) {\n     vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());\n@@ -605,7 +865,7 @@ vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIter __first, _ForwardIter __last,\n }\n \n template <class _Tp, class _Alloc>\n-void \n+void\n vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n {\n   if (_M_finish != _M_end_of_storage) {\n@@ -629,8 +889,8 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n                                         __new_finish);\n     }\n     catch(...)\n-      { \n-\t_Destroy(__new_start,__new_finish); \n+      {\n+\t_Destroy(__new_start,__new_finish);\n \t_M_deallocate(__new_start.base(),__len);\n \t__throw_exception_again;\n       }\n@@ -643,13 +903,13 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n }\n \n template <class _Tp, class _Alloc>\n-void \n+void\n vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n {\n   if (_M_finish != _M_end_of_storage) {\n     _Construct(_M_finish, *(_M_finish - 1));\n     ++_M_finish;\n-    copy_backward(__position, iterator(_M_finish - 2), \n+    copy_backward(__position, iterator(_M_finish - 2),\n \t\t  iterator(_M_finish - 1));\n     *__position = _Tp();\n   }\n@@ -659,16 +919,16 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n     pointer __new_start = _M_allocate(__len);\n     pointer __new_finish = __new_start;\n     try {\n-      __new_finish = uninitialized_copy(iterator(_M_start), __position, \n+      __new_finish = uninitialized_copy(iterator(_M_start), __position,\n \t\t\t\t\t__new_start);\n       _Construct(__new_finish);\n       ++__new_finish;\n-      __new_finish = uninitialized_copy(__position, iterator(_M_finish), \n+      __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n \t\t\t\t\t__new_finish);\n     }\n     catch(...)\n       {\n-\t_Destroy(__new_start,__new_finish); \n+\t_Destroy(__new_start,__new_finish);\n \t_M_deallocate(__new_start,__len);\n \t__throw_exception_again;\n       }\n@@ -681,7 +941,7 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n }\n \n template <class _Tp, class _Alloc>\n-void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n, \n+void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n                                          const _Tp& __x)\n {\n   if (__n != 0) {\n@@ -704,7 +964,7 @@ void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n       }\n     }\n     else {\n-      const size_type __old_size = size();        \n+      const size_type __old_size = size();\n       const size_type __len = __old_size + max(__old_size, __n);\n       iterator __new_start(_M_allocate(__len));\n       iterator __new_finish(__new_start);\n@@ -716,7 +976,7 @@ void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n       }\n       catch(...)\n \t{\n-\t  _Destroy(__new_start,__new_finish); \n+\t  _Destroy(__new_start,__new_finish);\n \t  _M_deallocate(__new_start.base(),__len);\n \t  __throw_exception_again;\n \t}\n@@ -730,9 +990,9 @@ void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n }\n \n template <class _Tp, class _Alloc> template <class _InputIterator>\n-void \n-vector<_Tp, _Alloc>::_M_range_insert(iterator __pos, \n-                                     _InputIterator __first, \n+void\n+vector<_Tp, _Alloc>::_M_range_insert(iterator __pos,\n+                                     _InputIterator __first,\n                                      _InputIterator __last,\n                                      input_iterator_tag)\n {\n@@ -743,7 +1003,7 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __pos,\n }\n \n template <class _Tp, class _Alloc> template <class _ForwardIterator>\n-void \n+void\n vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n                                      _ForwardIterator __first,\n                                      _ForwardIterator __last,\n@@ -776,7 +1036,7 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n       iterator __new_start(_M_allocate(__len));\n       iterator __new_finish(__new_start);\n       try {\n-        __new_finish = uninitialized_copy(iterator(_M_start), \n+        __new_finish = uninitialized_copy(iterator(_M_start),\n \t\t\t\t\t  __position, __new_start);\n         __new_finish = uninitialized_copy(__first, __last, __new_finish);\n         __new_finish\n@@ -797,7 +1057,7 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n   }\n }\n \n-} // namespace std \n+} // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_VECTOR_H */\n "}]}