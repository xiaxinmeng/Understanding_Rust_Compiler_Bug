{"sha": "18fc70aa9c753d17c00211cea9fa5bd843fe94fd", "node_id": "C_kwDOANBUbNoAKDE4ZmM3MGFhOWM3NTNkMTdjMDAyMTFjZWE5ZmE1YmQ4NDNmZTk0ZmQ", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-12-21T07:06:29Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-12-21T07:14:32Z"}, "message": "gfortran.dg/read_dir.f90: Make PASS on Windows\n\nOn non-Cygwin Windows, use '.' and expect the documented fail when opening\na directory (EACCESS).  As gfortran does not set __WIN32__ this check is\ndone on the C side. (On __CYGWIN__, __WIN32__ is not set - but to make it\nclear, !__CYGWIN__ is used in #if.)\n\nOn non-Windows, replace the 'call system' shell call by the POSIX functions\nstat/mkdir/rmdir for better compatibility, especially on embedded systems;\nadditionally add some more checks. In particular, confirm that 'close' with\nstatus='delete' indeed deleted the directory.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/read_dir-aux.c: New; provides my_mkdir, my_rmdir,\n\tmy_verify_not_exists and expect_open_to_fail.\n\t* gfortran.dg/read_dir.f90: Call those; expect that opening a\n\tdirectory fails on Windows.", "tree": {"sha": "6f034de60c1f27c842a404c1ef74ea5e62a1afdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f034de60c1f27c842a404c1ef74ea5e62a1afdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18fc70aa9c753d17c00211cea9fa5bd843fe94fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fc70aa9c753d17c00211cea9fa5bd843fe94fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fc70aa9c753d17c00211cea9fa5bd843fe94fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fc70aa9c753d17c00211cea9fa5bd843fe94fd/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b1a604a9b28fbf4f382060bebd04adb83acc2f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1a604a9b28fbf4f382060bebd04adb83acc2f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1a604a9b28fbf4f382060bebd04adb83acc2f9"}], "stats": {"total": 122, "additions": 117, "deletions": 5}, "files": [{"sha": "307b44472aff5cb1efcfe16dda3fe56c7f1a338f", "filename": "gcc/testsuite/gfortran.dg/read_dir-aux.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fc70aa9c753d17c00211cea9fa5bd843fe94fd/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_dir-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fc70aa9c753d17c00211cea9fa5bd843fe94fd/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_dir-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_dir-aux.c?ref=18fc70aa9c753d17c00211cea9fa5bd843fe94fd", "patch": "@@ -0,0 +1,68 @@\n+#if defined(__WIN32__) && !defined(__CYGWIN__)\n+  /* Mostly skip on Windows, cf. main file why. */\n+\n+int expect_open_to_fail () { return 1; }\n+\n+void my_verify_not_exists (const char *dir) { }\n+void my_mkdir (const char *dir) { }\n+void my_rmdir (const char *dir) { }\n+\n+#else\n+\n+#include <sys/stat.h>  /* For mkdir + permission bits.  */\n+#include <unistd.h>  /* For rmdir.  */\n+#include <errno.h>  /* For errno.  */\n+#include <stdio.h>  /* For perror.  */\n+#include <stdlib.h>  /* For abort.  */\n+ \n+\n+int expect_open_to_fail () { return 0; }\n+\n+void\n+my_verify_not_exists (const char *dir)\n+{\n+  struct stat path_stat;\n+  int err = stat (dir, &path_stat);\n+  if (err && errno == ENOENT)\n+    return;  /* OK */\n+  if (err)\n+    perror (\"my_verify_not_exists\");\n+  else\n+    printf (\"my_verify_not_exists: pathname %s still exists\\n\", dir);\n+  abort ();\n+ }\n+\n+void\n+my_mkdir (const char *dir)\n+{\n+  int err;\n+  struct stat path_stat;\n+\n+  /* Check whether 'dir' exists and is a directory.  */\n+  err = stat (dir, &path_stat);\n+  if (err && errno != ENOENT)\n+    {\n+      perror (\"my_mkdir: failed to call stat for directory\");\n+      abort ();\n+    }\n+  if (err == 0 && !S_ISDIR (path_stat.st_mode))\n+    {\n+      printf (\"my_mkdir: pathname %s is not a directory\\n\", dir);\n+      abort ();\n+    }\n+\n+  err = mkdir (dir, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n+  if (err != 0)\n+    {\n+      perror (\"my_mkdir: failed to create directory\");\n+      abort ();\n+    }    \n+}\n+\n+void\n+my_rmdir (const char *dir)\n+{\n+  rmdir (dir);\n+}\n+\n+#endif  /* !defined(__WIN32__) || defined(__CYGWIN__) */"}, {"sha": "2778210f0791ef26dbb079a0b982485a7b245d58", "filename": "gcc/testsuite/gfortran.dg/read_dir.f90", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fc70aa9c753d17c00211cea9fa5bd843fe94fd/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_dir.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fc70aa9c753d17c00211cea9fa5bd843fe94fd/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_dir.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_dir.f90?ref=18fc70aa9c753d17c00211cea9fa5bd843fe94fd", "patch": "@@ -1,20 +1,64 @@\n ! { dg-do run }\n+! { dg-additional-sources read_dir-aux.c }\n+!\n ! PR67367\n+\n program bug\n+   use iso_c_binding\n    implicit none\n+\n+   interface\n+     integer(c_int) function expect_open_to_fail () bind(C)\n+       import\n+     end\n+     subroutine my_verify_not_exists(s) bind(C)\n+       ! Aborts if the passed pathname (still) exists\n+       import\n+       character(len=1,kind=c_char) :: s(*)\n+     end subroutine\n+     subroutine my_mkdir(s) bind(C)\n+       ! Call POSIX's mkdir - and ignore fails due to\n+       ! existing directories but fail otherwise\n+       import\n+       character(len=1,kind=c_char) :: s(*)\n+     end subroutine\n+     subroutine my_rmdir(s) bind(C)\n+       ! Call POSIX's rmdir - and ignore fails\n+       import\n+       character(len=1,kind=c_char) :: s(*)\n+     end subroutine\n+   end interface\n+\n+   character(len=*), parameter :: sdir = \"junko.dir\"\n+   character(len=*,kind=c_char), parameter :: c_sdir = sdir // c_null_char\n+\n    character(len=1) :: c\n-   character(len=256) :: message\n    integer ios\n-   call system('[ -d junko.dir ] || mkdir junko.dir')\n-   open(unit=10, file='junko.dir',iostat=ios,action='read',access='stream')\n+\n+   if (expect_open_to_fail () /= 0) then\n+      ! Windows is documented to fail with EACCESS when trying to open a\n+      ! directory. However, target macros such as __WIN32__ are not defined\n+      ! in Fortran; hence, we use a detour via this C function.\n+      ! Check for '.' which is a known-to-exist directory:\n+      open(unit=10, file='.',iostat=ios,action='read',access='stream')\n+      if (ios == 0) &\n+          stop 3  ! Error: open to fail (EACCESS)\n+       stop 0  ! OK\n+   endif\n+\n+   call my_mkdir(c_sdir)\n+   open(unit=10, file=sdir,iostat=ios,action='read',access='stream')\n+\n    if (ios.ne.0) then\n-      call system('rmdir junko.dir')\n+      call my_rmdir(c_sdir)\n       STOP 1\n    end if\n    read(10, iostat=ios) c\n-   if (ios.ne.21.and.ios.ne.0) then \n+   if (ios.ne.21.and.ios.ne.0) then  ! EISDIR has often the value 21\n       close(10, status='delete')\n+      call my_verify_not_exists(c_sdir)\n       STOP 2\n    end if\n    close(10, status='delete')\n+   call my_verify_not_exists(c_sdir)\n end program bug"}]}