{"sha": "0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiY2ZiYWZjOGFhMzZmNjJlYjRkMzQ3MzAxY2Y4MDQ5OGFjMzQ2NA==", "commit": {"author": {"name": "Herman A.J. ten Brugge", "email": "Haj.Ten.Brugge@net.HCC.nl", "date": "2001-01-22T10:40:31Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-22T10:40:31Z"}, "message": "c4x.c (c4x_valid_rptb_p, [...]): New functions.\n\n\t* c4x.c (c4x_valid_rptb_p, c4x_label_ref_used_p): New functions.\n\t(c4x_rptb_insert): Call c4x_valid_rptb_p to check if repeat block is\n\tvalid.  If not replace it by equivalent insns.\n\nFrom-SVN: r39181", "tree": {"sha": "2404210dc2f2e256537dd6050491719edb21682f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2404210dc2f2e256537dd6050491719edb21682f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbcfbafc8aa36f62eb4d347301cf80498ac3464/comments", "author": null, "committer": null, "parents": [{"sha": "5078f5eb76d9796bfb97fff2a269508e71b12ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5078f5eb76d9796bfb97fff2a269508e71b12ad2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5078f5eb76d9796bfb97fff2a269508e71b12ad2"}], "stats": {"total": 120, "additions": 119, "deletions": 1}, "files": [{"sha": "47d9e2e9d2931800a0ebad89aa70968124eff510", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bbcfbafc8aa36f62eb4d347301cf80498ac3464/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bbcfbafc8aa36f62eb4d347301cf80498ac3464/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "patch": "@@ -1,3 +1,9 @@\n+2001-01-22 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n+\n+\t* c4x.c (c4x_valid_rptb_p, c4x_label_ref_used_p): New functions.\n+\t(c4x_rptb_insert): Call c4x_valid_rptb_p to check if repeat block is\n+\tvalid.  If not replace it by equivalent insns.\n+\n 2001-01-22 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n \t* c4x.c (c4x_check_legit_addr): Only check CONST.  Not if CONST"}, {"sha": "3ce7987c06d36c8e5ac12444599deaff95af3507", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 113, "deletions": 1, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bbcfbafc8aa36f62eb4d347301cf80498ac3464/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bbcfbafc8aa36f62eb4d347301cf80498ac3464/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "patch": "@@ -187,6 +187,8 @@ static int c4x_arn_mem_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n static void c4x_check_attribute PARAMS ((const char *, tree, tree, tree *));\n static int c4x_parse_pragma PARAMS ((const char *, tree *, tree *));\n static int c4x_r11_set_p PARAMS ((rtx));\n+static int c4x_rptb_valid_p PARAMS ((rtx, rtx));\n+static int c4x_label_ref_used_p PARAMS ((rtx, rtx));\n \n /* Called to register all of our global variables with the garbage\n    collector.  */\n@@ -2288,7 +2290,105 @@ c4x_rptb_nop_p (insn)\n   there are no instructions in the loop which would cause problems).\n   Any additional labels can be emitted at this point.  In addition, if\n   the desired loop count register was not allocated, this routine does\n-  nothing.  */\n+  nothing. \n+\n+  Before we can create a repeat block looping instruction we have to\n+  verify that there are no jumps outside the loop and no jumps outside\n+  the loop go into this loop. This can happen in the basic blocks reorder\n+  pass. The C4x cpu can not handle this.  */\n+\n+static int\n+c4x_label_ref_used_p (x, code_label)\n+     rtx x, code_label;\n+{\n+  enum rtx_code code;\n+  int i, j;\n+  const char *fmt;\n+\n+  if (x == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+  if (code == LABEL_REF)\n+    return INSN_UID (XEXP (x,0)) == INSN_UID (code_label);\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+          if (c4x_label_ref_used_p (XEXP (x, i), code_label))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+        for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+          if (c4x_label_ref_used_p (XVECEXP (x, i, j), code_label))\n+\t    return 1;\n+    }\n+  return 0;\n+}\n+\n+\n+static int\n+c4x_rptb_valid_p (insn, start_label)\n+     rtx insn, start_label;\n+{\n+  rtx end = insn;\n+  rtx start;\n+  rtx tmp;\n+\n+  /* Find the start label.  */\n+  for (; insn; insn = PREV_INSN (insn))\n+    if (insn == start_label)\n+      break;\n+\n+  /* Note found then we can not use a rptb or rpts.  The label was\n+     probably moved by the basic block reorder pass.  */\n+  if (! insn)\n+    return 0;\n+\n+  start = insn;\n+  /* If any jump jumps inside this block then we must fail.  */\n+  for (insn = PREV_INSN (start); insn; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  for (tmp = NEXT_INSN (start); tmp != end; tmp = NEXT_INSN(tmp))\n+\t    if (GET_CODE (tmp) == JUMP_INSN\n+                && c4x_label_ref_used_p (tmp, insn))\n+\t      return 0;\n+        }\n+    }\n+  for (insn = NEXT_INSN (end); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  for (tmp = NEXT_INSN (start); tmp != end; tmp = NEXT_INSN(tmp))\n+\t    if (GET_CODE (tmp) == JUMP_INSN\n+                && c4x_label_ref_used_p (tmp, insn))\n+\t      return 0;\n+        }\n+    }\n+  /* If any jump jumps outside this block then we must fail.  */\n+  for (insn = NEXT_INSN (start); insn != end; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  for (tmp = NEXT_INSN (end); tmp; tmp = NEXT_INSN(tmp))\n+\t    if (GET_CODE (tmp) == JUMP_INSN\n+                && c4x_label_ref_used_p (tmp, insn))\n+\t      return 0;\n+\t  for (tmp = PREV_INSN (start); tmp; tmp = PREV_INSN(tmp))\n+\t    if (GET_CODE (tmp) == JUMP_INSN\n+                && c4x_label_ref_used_p (tmp, insn))\n+\t      return 0;\n+        }\n+    }\n+\n+  /* All checks OK.  */\n+  return 1;\n+}\n+\n \n void\n c4x_rptb_insert (insn)\n@@ -2310,6 +2410,18 @@ c4x_rptb_insert (insn)\n   /* Extract the start label from the jump pattern (rptb_end).  */\n   start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0);\n   \n+  if (! c4x_rptb_valid_p (insn, start_label))\n+    {\n+      /* We can not use the rptb insn.  Replace it so reorg can use\n+         the delay slots of the jump insn.  */\n+      emit_insn_before (gen_addqi3 (count_reg, count_reg, GEN_INT (-1)), insn);\n+      emit_insn_before (gen_cmpqi (count_reg, GEN_INT (0)), insn);\n+      emit_insn_before (gen_bge (start_label), insn);\n+      LABEL_NUSES (start_label)++;\n+      delete_insn (insn);\n+      return;\n+    }\n+\n   end_label = gen_label_rtx ();\n   LABEL_NUSES (end_label)++;\n   emit_label_after (end_label, insn);"}]}