{"sha": "43998ed92e06a48a1d52a37536fcc609ab2a608d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5OThlZDkyZTA2YTQ4YTFkNTJhMzc1MzZmY2M2MDlhYjJhNjA4ZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-03-28T14:04:14Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-03-28T14:04:14Z"}, "message": "re PR fortran/32626 (Run-time check for recursive functions)\n\n2009-03-28  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/32626\n        * option.c (gfc_handle_runtime_check_option): Enable recursion check.\n        * trans-decl.c (gfc_generate_function_code): Add recursion check.\n        * invoke.texi (-fcheck): Add recursive option.\n\nFrom-SVN: r145188", "tree": {"sha": "f7ba51c41dbc70d06547423c13013047c63f8adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7ba51c41dbc70d06547423c13013047c63f8adc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43998ed92e06a48a1d52a37536fcc609ab2a608d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43998ed92e06a48a1d52a37536fcc609ab2a608d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43998ed92e06a48a1d52a37536fcc609ab2a608d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43998ed92e06a48a1d52a37536fcc609ab2a608d/comments", "author": null, "committer": null, "parents": [{"sha": "dc186969b5524ab768c53c2e2f226bf24d0a35f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc186969b5524ab768c53c2e2f226bf24d0a35f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc186969b5524ab768c53c2e2f226bf24d0a35f8"}], "stats": {"total": 88, "additions": 82, "deletions": 6}, "files": [{"sha": "5373c9df08ebe9ff0dbad7cdcb90d4f5c17a7c82", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=43998ed92e06a48a1d52a37536fcc609ab2a608d", "patch": "@@ -1,3 +1,10 @@\n+2009-03-28  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/32626\n+\t* option.c (gfc_handle_runtime_check_option): Enable recursion check.\n+\t* trans-decl.c (gfc_generate_function_code): Add recursion check.\n+\t* invoke.texi (-fcheck): Add recursive option.\n+\n 2009-03-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/38432\n@@ -8,12 +15,12 @@\n \t    Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.h (gfc_option_t): Add rtcheck.\n-\t* lang.opt: New option -fruntime-check.\n+\t* lang.opt: New option -fcheck.\n \t* libgfortran.h: Add GFC_RTCHECK_* constants.\n-\t* invoke.texi: Document -fruntime-check.\n+\t* invoke.texi: Document -fcheck.\n \t* options.c (gfc_handle_runtime_check_option): New function.\n \t(gfc_init_options,gfc_post_options,gfc_handle_option):\n-\tAdd -fruntime-check option.\n+\tAdd -fcheck option.\n \n 2009-03-27  Richard Guenther  <rguenther@suse.de>\n "}, {"sha": "9eb5de1a05c95f8e513246eff846630a3ba37dd7", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=43998ed92e06a48a1d52a37536fcc609ab2a608d", "patch": "@@ -1220,6 +1220,10 @@ the compilation of the main program.\n \n Note: In the future this may also include other forms of checking, e.g.,\n checking substring references.\n+\n+@item @samp{recursion}\n+Enable generation of run-time checks for recursively called subroutines and\n+functions which are not marked as recursive. See also @option{-frecursive}.\n @end table\n \n "}, {"sha": "fd9fb880d83cc9b58df286f974a1cfae2f403ae9", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=43998ed92e06a48a1d52a37536fcc609ab2a608d", "patch": "@@ -458,10 +458,10 @@ gfc_handle_runtime_check_option (const char *arg)\n {\n   int result, pos = 0, n;\n   static const char * const optname[] = { \"all\", \"bounds\", \"array-temps\",\n-\t\t\t\t\t  /* \"recursion\", \"do\", */ NULL };\n+\t\t\t\t\t  \"recursion\", /* \"do\", */ NULL };\n   static const int optmask[] = { GFC_RTCHECK_ALL, GFC_RTCHECK_BOUNDS,\n \t\t\t\t GFC_RTCHECK_ARRAY_TEMPS,\n-\t\t\t\t /* GFC_RTCHECK_RECURSION, GFC_RTCHECK_DO, */\n+\t\t\t\t GFC_RTCHECK_RECURSION, /* GFC_RTCHECK_DO, */\n \t\t\t\t 0 };\n  \n   while (*arg)"}, {"sha": "6cfc86a4bb7d191963ab9586570c3ef1fbcf7a4c", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=43998ed92e06a48a1d52a37536fcc609ab2a608d", "patch": "@@ -3679,6 +3679,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   stmtblock_t block;\n   stmtblock_t body;\n   tree result;\n+  tree recurcheckvar = NULL;\n   gfc_symbol *sym;\n   int rank;\n \n@@ -3846,6 +3847,22 @@ gfc_generate_function_code (gfc_namespace * ns)\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n+   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION) && !sym->attr.recursive)\n+     {\n+       char * msg;\n+\n+       asprintf (&msg, \"Recursive call to nonrecursive procedure '%s'\",\n+\t\t sym->name);\n+       recurcheckvar = gfc_create_var (boolean_type_node, \"is_recursive\");\n+       TREE_STATIC (recurcheckvar) = 1;\n+       DECL_INITIAL (recurcheckvar) = boolean_false_node;\n+       gfc_add_expr_to_block (&block, recurcheckvar);\n+       gfc_trans_runtime_check (true, false, recurcheckvar, &block,\n+\t\t\t\t&sym->declared_at, msg);\n+       gfc_add_modify (&block, recurcheckvar, boolean_true_node);\n+       gfc_free (msg);\n+    }\n+\n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node\n       && sym->attr.subroutine)\n     {\n@@ -3924,6 +3941,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n   else\n     gfc_add_expr_to_block (&block, tmp);\n \n+ /* Reset recursion-check variable.  */\n+ if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION) && !sym->attr.recursive)\n+   gfc_add_modify (&block, recurcheckvar, boolean_false_node);\n \n   /* Add all the decls we created during processing.  */\n   decl = saved_function_decls;"}, {"sha": "aba092f9695f71cf24eecffecf6545ba6e66e73b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43998ed92e06a48a1d52a37536fcc609ab2a608d", "patch": "@@ -1,4 +1,9 @@\n-2009-03-28 Tobias Burnus  <burnus@net-b.de>\n+2009-03-28  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/32626\n+\t* gfortran.dg/recursive_check_7.f90: New test.\n+\n+2009-03-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/38432\n \t* gfortran.dg/do_check_5.f90: New test."}, {"sha": "c1af8adc810222bc254769cadbc6158916361a56", "filename": "gcc/testsuite/gfortran.dg/recursive_check_7.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43998ed92e06a48a1d52a37536fcc609ab2a608d/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_7.f90?ref=43998ed92e06a48a1d52a37536fcc609ab2a608d", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=recursion\" }\n+! { dg-shouldfail \"Recursion check\" }\n+!\n+! PR fortran/32626\n+! Recursion run-time check\n+!\n+\n+subroutine NormalFunc()\n+end subroutine NormalFunc\n+\n+recursive subroutine valid(x)\n+  logical :: x\n+  if(x) call sndValid()\n+  print *, 'OK'\n+end subroutine valid\n+\n+subroutine sndValid()\n+  call valid(.false.)\n+end subroutine sndValid\n+\n+subroutine invalid(x)\n+  logical :: x\n+  if(x) call sndInvalid()\n+  print *, 'BUG'\n+  call abort()\n+end subroutine invalid\n+\n+subroutine sndInvalid()\n+  call invalid(.false.)\n+end subroutine sndInvalid\n+\n+call valid(.true.)\n+call valid(.true.)\n+call NormalFunc()\n+call NormalFunc()\n+call invalid(.true.)\n+end\n+\n+! { dg-output \"Fortran runtime error: Recursive call to nonrecursive procedure 'invalid'\" }"}]}