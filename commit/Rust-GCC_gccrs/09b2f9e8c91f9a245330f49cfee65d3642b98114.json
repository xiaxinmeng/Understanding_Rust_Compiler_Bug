{"sha": "09b2f9e8c91f9a245330f49cfee65d3642b98114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDliMmY5ZThjOTFmOWEyNDUzMzBmNDljZmVlNjVkMzY0MmI5ODExNA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-06-20T02:33:52Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-06-20T02:33:52Z"}, "message": "fold-const.c (swap_tree_comparison): Add support for unordered floating point comparisons.\n\n\n\t* fold-const.c (swap_tree_comparison): Add support for unordered\n\tfloating point comparisons.\n\t* tree-vrp.c (opposite_comparison): Delete.\n\t(extract_range_from_assert): Replace calls to opposite_comparison\n\twith calls to swap_tree_comparison.\n\t(register_edge_assert_for): Likewise.\n\t(vrp_evaluate_conditional): Likewise.\n\nFrom-SVN: r101201", "tree": {"sha": "d643478192e3bd2111176dee180dc26f4b51715b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d643478192e3bd2111176dee180dc26f4b51715b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09b2f9e8c91f9a245330f49cfee65d3642b98114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b2f9e8c91f9a245330f49cfee65d3642b98114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b2f9e8c91f9a245330f49cfee65d3642b98114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b2f9e8c91f9a245330f49cfee65d3642b98114/comments", "author": null, "committer": null, "parents": [{"sha": "115766b691bab20c8c9748fae898dc93246c1e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115766b691bab20c8c9748fae898dc93246c1e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115766b691bab20c8c9748fae898dc93246c1e18"}], "stats": {"total": 70, "additions": 26, "deletions": 44}, "files": [{"sha": "d459e07d47d903bf30bb538ed247bfc0b8553aa7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b2f9e8c91f9a245330f49cfee65d3642b98114/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b2f9e8c91f9a245330f49cfee65d3642b98114/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09b2f9e8c91f9a245330f49cfee65d3642b98114", "patch": "@@ -1,3 +1,13 @@\n+2005-06-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (swap_tree_comparison): Add support for unordered\n+\tfloating point comparisons.\n+\t* tree-vrp.c (opposite_comparison): Delete.\n+\t(extract_range_from_assert): Replace calls to opposite_comparison\n+\twith calls to swap_tree_comparison.\n+\t(register_edge_assert_for): Likewise.\n+\t(vrp_evaluate_conditional): Likewise.\n+\n 2005-06-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* integrate.c (allocate_initial_values): Update the references"}, {"sha": "5d25cb9a40eb6af0d468c732d0aa80d6113c67ea", "filename": "gcc/fold-const.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b2f9e8c91f9a245330f49cfee65d3642b98114/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b2f9e8c91f9a245330f49cfee65d3642b98114/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=09b2f9e8c91f9a245330f49cfee65d3642b98114", "patch": "@@ -2169,6 +2169,10 @@ swap_tree_comparison (enum tree_code code)\n     {\n     case EQ_EXPR:\n     case NE_EXPR:\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n+    case LTGT_EXPR:\n+    case UNEQ_EXPR:\n       return code;\n     case GT_EXPR:\n       return LT_EXPR;\n@@ -2178,6 +2182,14 @@ swap_tree_comparison (enum tree_code code)\n       return GT_EXPR;\n     case LE_EXPR:\n       return GE_EXPR;\n+    case UNGT_EXPR:\n+      return UNLT_EXPR;\n+    case UNGE_EXPR:\n+      return UNLE_EXPR;\n+    case UNLT_EXPR:\n+      return UNGT_EXPR;\n+    case UNLE_EXPR:\n+      return UNGE_EXPR;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "217ecc30ae2a3b370d5e412ece0e4f7b62d75806", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b2f9e8c91f9a245330f49cfee65d3642b98114/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b2f9e8c91f9a245330f49cfee65d3642b98114/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=09b2f9e8c91f9a245330f49cfee65d3642b98114", "patch": "@@ -94,46 +94,6 @@ static sbitmap blocks_visited;\n    of values that SSA name N_I may take.  */\n static value_range_t **vr_value;\n \n-/* Given a comparison code, return its opposite.  Note that this is *not*\n-   the same as inverting its truth value (invert_tree_comparison).  Here we\n-   just want to literally flip the comparison around.\n-   \n-   So, '<' gets '>', '<=' gets '>='.  Both '==' and '!=' are returned\n-   unchanged.  */\n-\n-static enum tree_code\n-opposite_comparison (enum tree_code code)\n-{\n-  switch (code)\n-    {\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case ORDERED_EXPR:\n-    case UNORDERED_EXPR:\n-    case LTGT_EXPR:\n-    case UNEQ_EXPR:\n-      return code;\n-    case GT_EXPR:\n-      return LT_EXPR;\n-    case GE_EXPR:\n-      return LE_EXPR;\n-    case LT_EXPR:\n-      return GT_EXPR;\n-    case LE_EXPR:\n-      return GE_EXPR;\n-    case UNGT_EXPR:\n-      return UNLT_EXPR;\n-    case UNGE_EXPR:\n-      return UNLE_EXPR;\n-    case UNLT_EXPR:\n-      return UNGT_EXPR;\n-    case UNLE_EXPR:\n-      return UNGE_EXPR;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n \n /* Return true if EXPR computes a non-zero value.  */\n \n@@ -711,7 +671,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t to flip around the comparison code to create the proper range\n \t for VAR.  */\n       limit = TREE_OPERAND (cond, 0);\n-      cond_code = opposite_comparison (TREE_CODE (cond));\n+      cond_code = swap_tree_comparison (TREE_CODE (cond));\n     }\n \n   type = TREE_TYPE (limit);\n@@ -2231,7 +2191,7 @@ register_edge_assert_for (tree name, edge e, block_stmt_iterator si)\n \t      /* If the predicate is of the form VAL COMP NAME, flip\n \t\t COMP around because we need to register NAME as the\n \t\t first operand in the predicate.  */\n-\t      comp_code = opposite_comparison (TREE_CODE (cond));\n+\t      comp_code = swap_tree_comparison (TREE_CODE (cond));\n \t      val = TREE_OPERAND (cond, 0);\n \t    }\n \t  else\n@@ -3023,7 +2983,7 @@ vrp_evaluate_conditional (tree cond, bool use_equiv_p)\n \t    return compare_name_with_value (TREE_CODE (cond), op0, op1);\n \t  else if (TREE_CODE (op1) == SSA_NAME)\n \t    return compare_name_with_value (\n-\t\t    opposite_comparison (TREE_CODE (cond)), op1, op0);\n+\t\t    swap_tree_comparison (TREE_CODE (cond)), op1, op0);\n \t}\n       else\n \t{\n@@ -3038,7 +2998,7 @@ vrp_evaluate_conditional (tree cond, bool use_equiv_p)\n \t    return compare_range_with_value (TREE_CODE (cond), vr0, op1);\n \t  else if (vr0 == NULL && vr1)\n \t    return compare_range_with_value (\n-\t\t    opposite_comparison (TREE_CODE (cond)), vr1, op0);\n+\t\t    swap_tree_comparison (TREE_CODE (cond)), vr1, op0);\n \t}\n     }\n "}]}