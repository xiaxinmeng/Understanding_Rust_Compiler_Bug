{"sha": "fcbd8ef220090816ab831029cf83dc50caa6a5b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNiZDhlZjIyMDA5MDgxNmFiODMxMDI5Y2Y4M2RjNTBjYWE2YTViMQ==", "commit": {"author": {"name": "Jeffrey Oldham", "email": "oldham@codesourcery.com", "date": "2001-01-05T20:25:09Z"}, "committer": {"name": "Jeffrey D. Oldham", "email": "oldham@gcc.gnu.org", "date": "2001-01-05T20:25:09Z"}, "message": "varasm.c (mark_constant_pool): Improve initial comments.\n\n2001-01-05  Jeffrey Oldham  <oldham@codesourcery.com>\n\n\t* varasm.c (mark_constant_pool): Improve initial comments.\n\t(mark_constants): Move marking of constants to mark_constant.\n\t(mark_constant): New function to recursively mark all constants\n\treferred to by a constant.\n\nFrom-SVN: r38721", "tree": {"sha": "452da27ee7085135690b8a9458b02489159d500a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/452da27ee7085135690b8a9458b02489159d500a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcbd8ef220090816ab831029cf83dc50caa6a5b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcbd8ef220090816ab831029cf83dc50caa6a5b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcbd8ef220090816ab831029cf83dc50caa6a5b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcbd8ef220090816ab831029cf83dc50caa6a5b1/comments", "author": null, "committer": null, "parents": [{"sha": "ebb0cdf335554673adc52f752ce7f9bc2dd2121e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb0cdf335554673adc52f752ce7f9bc2dd2121e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb0cdf335554673adc52f752ce7f9bc2dd2121e"}], "stats": {"total": 116, "additions": 66, "deletions": 50}, "files": [{"sha": "cba6dea9484fbd42691acafff1d8c4991f2aef05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcbd8ef220090816ab831029cf83dc50caa6a5b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcbd8ef220090816ab831029cf83dc50caa6a5b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcbd8ef220090816ab831029cf83dc50caa6a5b1", "patch": "@@ -1,3 +1,10 @@\n+2001-01-05  Jeffrey Oldham  <oldham@codesourcery.com>\n+\n+\t* varasm.c (mark_constant_pool): Improve initial comments.\n+\t(mark_constants): Move marking of constants to mark_constant.\n+\t(mark_constant): New function to recursively mark all constants\n+\treferred to by a constant.\n+\n 2001-01-05  Catherine Moore  <clm@redhat.com>\n \n \t* dbxout.c ((dbxout_parms): Handle invisible ref where decl is a REG."}, {"sha": "272593c7ce3213a5b678cf4a5935503151ea14e6", "filename": "gcc/varasm.c", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcbd8ef220090816ab831029cf83dc50caa6a5b1/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcbd8ef220090816ab831029cf83dc50caa6a5b1/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fcbd8ef220090816ab831029cf83dc50caa6a5b1", "patch": "@@ -169,6 +169,7 @@ static struct constant_descriptor *record_constant_rtx PARAMS ((enum machine_mod\n static struct pool_constant *find_pool_constant PARAMS ((struct function *, rtx));\n static void mark_constant_pool\t\tPARAMS ((void));\n static void mark_constants\t\tPARAMS ((rtx));\n+static int mark_constant\t\tPARAMS ((rtx *current_rtx, void *data));\n static int output_addressed_constants\tPARAMS ((tree));\n static void output_after_function_constants PARAMS ((void));\n static unsigned HOST_WIDE_INT array_size_for_constructor PARAMS ((tree));\n@@ -3927,7 +3928,8 @@ output_constant_pool (fnname, fndecl)\n }\n \n /* Look through the instructions for this function, and mark all the\n-   entries in the constant pool which are actually being used.  */\n+   entries in the constant pool which are actually being used.\n+   Emit used deferred strings.  */\n \n static void\n mark_constant_pool ()\n@@ -3950,41 +3952,16 @@ mark_constant_pool ()\n        insn = XEXP (insn, 1))\n     if (INSN_P (insn))\n       mark_constants (PATTERN (insn));\n-\n-  /* It's possible that the only reference to a symbol is in a symbol\n-     that's in the constant pool.  This happens in Fortran under some\n-     situations.  (When the constant contains the address of another\n-     constant, and only the first is used directly in an insn.) \n-     This is potentially suboptimal if there's ever a possibility of\n-     backwards (in pool order) 2'd level references.  However, it's\n-     not clear that 2'd level references can happen. */\n-  for (pool = first_pool; pool; pool = pool->next)\n-    {\n-      struct pool_constant *tem;\n-      const char *label;\n-\n-      /* skip unmarked entries; no insn refers to them. */\n-      if (!pool->mark)\n-\t  continue;\n-\n-      /* Skip everything except SYMBOL_REFs.  */\n-      if (GET_CODE (pool->constant) != SYMBOL_REF)\n-\tcontinue;\n-      label = XSTR (pool->constant, 0);\n-\n-      /* Be sure the symbol's value is marked. */\n-      for (tem = const_rtx_sym_hash_table[SYMHASH (label)]; tem; \n-           tem = tem->next)\n-\t  if (tem->label == label)\n-\t    tem->mark = 1;\n-      /* If we didn't find it, there's something truly wrong here, but it\n-\t will be announced by the assembler. */\n-    }\n }\n \n+/* Look through appropriate parts of X, marking all entries in the\n+   constant pool which are actually being used.  Entries that are only\n+   referenced by other constants are also marked as used.  Emit\n+   deferred strings that are used.  */\n+\n static void\n mark_constants (x)\n-     register rtx x;\n+     rtx x;\n {\n   register int i;\n   register const char *format_ptr;\n@@ -3994,24 +3971,7 @@ mark_constants (x)\n \n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n-      if (CONSTANT_POOL_ADDRESS_P (x))\n-\tfind_pool_constant (cfun, x)->mark = 1;\n-      else if (STRING_POOL_ADDRESS_P (x))\n-\t{\n-\t  struct deferred_string **defstr;\n-\n-\t  defstr = (struct deferred_string **)\n-\t\t   htab_find_slot_with_hash (const_str_htab, XSTR (x, 0),\n-\t\t\t\t\t     STRHASH (XSTR (x, 0)), NO_INSERT);\n-\t  if (defstr)\n-\t    {\n-\t      struct deferred_string *p = *defstr;\n-\n-\t      STRING_POOL_ADDRESS_P (x) = 0;\n-\t      output_constant_def_contents (p->exp, 0, p->labelno);\n-\t      htab_clear_slot (const_str_htab, (void **) defstr);\n-\t    }\n-\t}\n+      mark_constant (&x, NULL);\n       return;\n     }\n   /* Never search inside a CONST_DOUBLE, because CONST_DOUBLE_MEM may be\n@@ -4062,6 +4022,55 @@ mark_constants (x)\n \t}\n     }\n }\n+\n+/* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers\n+   to as used.  Emit referenced deferred strings.  This function can\n+   be used with for_each_rtx () to mark all SYMBOL_REFs in an rtx.  */\n+\n+static int\n+mark_constant (current_rtx, data)\n+     rtx *current_rtx;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *current_rtx;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+  else if (GET_CODE(x) == CONST_DOUBLE)\n+    /* Never search inside a CONST_DOUBLE because CONST_DOUBLE_MEM may\n+       be a MEM but does not constitute a use of that MEM.  */\n+    return -1;\n+  else if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      if (CONSTANT_POOL_ADDRESS_P (x))\n+\t{\n+\t  struct pool_constant *pool = find_pool_constant (cfun, x);\n+\t  if (pool->mark == 0) {\n+\t    pool->mark = 1;\n+\t    for_each_rtx (&(pool->constant), &mark_constant, NULL);\n+\t  }\n+\t  else\n+\t    return -1;\n+\t}\n+      else if (STRING_POOL_ADDRESS_P (x))\n+\t{\n+\t  struct deferred_string **defstr;\n+\n+\t  defstr = (struct deferred_string **)\n+\t    htab_find_slot_with_hash (const_str_htab, XSTR (x, 0),\n+\t\t\t\t      STRHASH (XSTR (x, 0)), NO_INSERT);\n+\t  if (defstr)\n+\t    {\n+\t      struct deferred_string *p = *defstr;\n+\n+\t      STRING_POOL_ADDRESS_P (x) = 0;\n+\t      output_constant_def_contents (p->exp, 0, p->labelno);\n+\t      htab_clear_slot (const_str_htab, (void **) defstr);\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n \f\n /* Find all the constants whose addresses are referenced inside of EXP,\n    and make sure assembler code with a label has been output for each one."}]}