{"sha": "9e69dd9f3a3e70cd53e5cf9717094030a1590e13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2OWRkOWYzYTNlNzBjZDUzZTVjZjk3MTcwOTQwMzBhMTU5MGUxMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-12T20:23:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-12T20:23:42Z"}, "message": "(movqi): Handle copying an address register to or\nfrom memory when the address uses the address register.\n\nFrom-SVN: r4668", "tree": {"sha": "f3c6482a671be6ffae28f57686dfc67241a0dec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3c6482a671be6ffae28f57686dfc67241a0dec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e69dd9f3a3e70cd53e5cf9717094030a1590e13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e69dd9f3a3e70cd53e5cf9717094030a1590e13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e69dd9f3a3e70cd53e5cf9717094030a1590e13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e69dd9f3a3e70cd53e5cf9717094030a1590e13/comments", "author": null, "committer": null, "parents": [{"sha": "09d65479966b04ed960e295f7bc17f853dbe57e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d65479966b04ed960e295f7bc17f853dbe57e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09d65479966b04ed960e295f7bc17f853dbe57e3"}], "stats": {"total": 76, "additions": 76, "deletions": 0}, "files": [{"sha": "ce6b42f8e9bd5cc7601bf6fca0c1e4ab661e3501", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e69dd9f3a3e70cd53e5cf9717094030a1590e13/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e69dd9f3a3e70cd53e5cf9717094030a1590e13/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=9e69dd9f3a3e70cd53e5cf9717094030a1590e13", "patch": "@@ -932,6 +932,44 @@\n   /* Use d0 as an intermediate, but don't clobber its contents.  */\n   if (ADDRESS_REG_P (operands[0]) && GET_CODE (operands[1]) == MEM)\n     {\n+      /* ??? For 2.5, don't allow this choice and use secondary reloads\n+\t instead.\n+\n+\t See if the address register is used in the address.  If it\n+\t is, we have to generate a more complex sequence than those below.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands[1], NULL_RTX))\n+\t{\n+\t  /* See if the stack pointer is used in the address.  If it isn't,\n+\t     we can push d0 or d1 (the insn can't use both of them) on\n+\t     the stack, perform our move into d0/d1, copy the byte from d0/1,\n+\t     and pop d0/1.  */\n+\t  if (! reg_mentioned_p (stack_pointer_rtx, operands[1]))\n+\t    {\n+\t      if (refers_to_regno_p (0, 1, operands[1], NULL_RTX))\n+\t\treturn \\\"move%.l %/d0,%-\\;move%.b %1,%/d0\\;move%.l %/d0,%0\\;move%.l %+,%/d0\\\";\n+\t      else\n+\t\treturn \\\"move%.l %/d1,%-\\;move%.b %1,%/d1\\;move%.l %/d1,%0\\;move%.l %+,%/d1\\\";\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, we know that d0 cannot be used in the address\n+\t\t (since sp and one address register is).  Assume that sp is\n+\t\t being used as a base register and replace the address\n+\t\t register that is our operand[0] with d0.  */\n+\t      rtx reg_map[FIRST_PSEUDO_REGISTER];\n+\t      int i;\n+\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\treg_map[i] = 0;\n+\n+\t      reg_map[REGNO (operands[0])] = gen_rtx (REG, Pmode, 0);\n+\t      operands[1] = copy_rtx (operands[1]);\n+\t      replace_regs (operands[1], reg_map, FIRST_PSEUDO_REGISTER, 0);\n+\t      return \\\"exg %/d0,%0\\;move%.b %1,%/d0\\;exg %/d0,%0\\\";\n+\t    }\n+\t}\n+\n       /* If the address of operand 1 uses d0, choose d1 as intermediate.  */\n       if (refers_to_regno_p (0, 1, operands[1], NULL_RTX))\n \treturn \\\"exg %/d1,%0\\;move%.b %1,%/d1\\;exg %/d1,%0\\\";\n@@ -944,6 +982,44 @@\n   /* Likewise for moving from an address reg.  */\n   if (ADDRESS_REG_P (operands[1]) && GET_CODE (operands[0]) == MEM)\n     {\n+      /* ??? For 2.5, don't allow this choice and use secondary reloads\n+\t instead.\n+\n+\t See if the address register is used in the address.  If it\n+\t is, we have to generate a more complex sequence than those below.  */\n+      if (refers_to_regno_p (REGNO (operands[1]), REGNO (operands[1]) + 1,\n+\t\t\t     operands[0], NULL_RTX))\n+\t{\n+\t  /* See if the stack pointer is used in the address.  If it isn't,\n+\t     we can push d0 or d1 (the insn can't use both of them) on\n+\t     the stack, copy the byte to d0/1, perform our move from d0/d1, \n+\t     and pop d0/1.  */\n+\t  if (! reg_mentioned_p (stack_pointer_rtx, operands[0]))\n+\t    {\n+\t      if (refers_to_regno_p (0, 1, operands[0], NULL_RTX))\n+\t\treturn \\\"move%.l %/d0,%-\\;move%.l %1,%/d0\\;move%.b %/d0,%0\\;move%.l %+,%/d0\\\";\n+\t      else\n+\t\treturn \\\"move%.l %/d1,%-\\;move%.l %1,%/d1\\;move%.b %/d1,%0\\;move%.l %+,%/d1\\\";\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, we know that d0 cannot be used in the address\n+\t\t (since sp and one address register is).  Assume that sp is\n+\t\t being used as a base register and replace the address\n+\t\t register that is our operand[1] with d0.  */\n+\t      rtx reg_map[FIRST_PSEUDO_REGISTER];\n+\t      int i;\n+\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\treg_map[i] = 0;\n+\n+\t      reg_map[REGNO (operands[1])] = gen_rtx (REG, Pmode, 0);\n+\t      operands[0] = copy_rtx (operands[0]);\n+\t      replace_regs (operands[0], reg_map, FIRST_PSEUDO_REGISTER, 0);\n+\t      return \\\"exg %/d0,%1\\;move%.b %/d0,%0\\;exg %/d0,%1\\\";\n+\t    }\n+\t}\n+\n       if (refers_to_regno_p (0, 1, operands[0], NULL_RTX))\n         return \\\"exg %/d1,%1\\;move%.b %/d1,%0\\;exg %/d1,%1\\\";\n       else"}]}