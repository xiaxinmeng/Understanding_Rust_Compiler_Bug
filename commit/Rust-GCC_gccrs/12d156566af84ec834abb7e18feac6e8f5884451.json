{"sha": "12d156566af84ec834abb7e18feac6e8f5884451", "node_id": "C_kwDOANBUbNoAKDEyZDE1NjU2NmFmODRlYzgzNGFiYjdlMThmZWFjNmU4ZjU4ODQ0NTE", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-28T12:49:45Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-01T10:19:11Z"}, "message": "parser: Allow parsing macro invocations as statements\n\nWhen parsing a macro invocation as a statement, the parser would parse\nan expression and then try parsing a semicolon. Since no actual\nlookahead was done (which is a good thing), we couldn't convert a\n`MacroInvocation` to a `MacroInvocationSemi` after the fact.\n\nSince, unlike function calls, macro invocations can act differently\nbased on whether or not they are followed by a semicolon, we actually\nneed to differentiate between the two up until expansion.\n\nThis commits adds a new virtual method for ExprWithoutBlock when\nconverting to ExprStmtWithoutBlock so that classes inheriting\nExprWithoutBlock can specify a new behavior. In the case of our\nMacroInvocation class, it simply means toggling a boolean: If we're\nconverting a macro from an expression to a statement, it must mean that\nit should contain a semicolon.", "tree": {"sha": "53dc6f2d0af871c54c32ff851a3005c7ae1cecf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53dc6f2d0af871c54c32ff851a3005c7ae1cecf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12d156566af84ec834abb7e18feac6e8f5884451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d156566af84ec834abb7e18feac6e8f5884451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d156566af84ec834abb7e18feac6e8f5884451", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d156566af84ec834abb7e18feac6e8f5884451/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf92a1012264f2544e73a7a8dd0ac1e473c7f658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf92a1012264f2544e73a7a8dd0ac1e473c7f658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf92a1012264f2544e73a7a8dd0ac1e473c7f658"}], "stats": {"total": 558, "additions": 262, "deletions": 296}, "files": [{"sha": "f3af42e1595b9d9dd884cb62a595e34071e7429c", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -54,7 +54,6 @@ class MacroItem;\n class TraitItem;\n class InherentImplItem;\n class TraitImplItem;\n-class MacroInvocationSemi;\n struct Crate;\n class PathExpr;\n "}, {"sha": "82abab9f1b1d093d52f19b99f796477ef5cf5077", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -1275,17 +1275,18 @@ TypeAlias::as_string () const\n   return str;\n }\n \n-std::string\n-MacroInvocationSemi::as_string () const\n-{\n-  std::string str = \"MacroInvocationSemi: \";\n-\n-  str += append_attributes (outer_attrs, OUTER);\n-\n-  str += \"\\n\" + invoc_data.as_string ();\n-\n-  return str;\n-}\n+// FIXME: ARTHUR: Check if this is necessary for MacroInvocation\n+// std::string\n+// MacroInvocationSemi::as_string () const\n+// {\n+//   std::string str = \"MacroInvocationSemi: \";\n+//\n+//   str += append_attributes (outer_attrs, OUTER);\n+//\n+//   str += \"\\n\" + invoc_data.as_string ();\n+//\n+//   return str;\n+// }\n \n std::string\n ExternBlock::as_string () const\n@@ -1377,6 +1378,9 @@ MacroInvocation::as_string () const\n \n   str += \"\\n \" + invoc_data.as_string ();\n \n+  str += \"\\n has semicolon: \";\n+  str += has_semicolon () ? \"true\" : \"false\";\n+\n   return str;\n }\n \n@@ -4921,12 +4925,6 @@ LifetimeParam::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-MacroInvocationSemi::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n PathInExpression::accept_vis (ASTVisitor &vis)\n {"}, {"sha": "d3383b45ddba1bc609ae06831e1b7f14e33a5767", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -52,7 +52,6 @@ class ASTVisitor\n   // virtual void visit(TraitItem& trait_item) = 0;\n   // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n   // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n-  virtual void visit (MacroInvocationSemi &macro) = 0;\n \n   // rust-path.h\n   virtual void visit (PathInExpression &path) = 0;"}, {"sha": "08ecd1858606109855426b69eb4f7a15458b57da", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 5, "deletions": 99, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -861,7 +861,9 @@ class Item : public Stmt\n   add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n   {}\n \n-  bool is_item () const override final { return true; }\n+  // FIXME: ARTHUR: Is it okay to have removed that final? Is it *required*\n+  // behavior that we have items that can also be expressions?\n+  bool is_item () const override { return true; }\n \n protected:\n   // Clone function implementation as pure virtual method\n@@ -957,6 +959,8 @@ class ExprWithoutBlock : public Expr\n   {\n     return clone_expr_without_block_impl ();\n   }\n+\n+  virtual ExprWithoutBlock *to_stmt () const { return clone_expr_impl (); }\n };\n \n /* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n@@ -1630,104 +1634,6 @@ class ASTFragment\n   std::vector<SingleASTNode> &get_nodes () { return nodes; }\n };\n \n-/* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n- * invocation) */\n-class MacroInvocationSemi : public MacroItem,\n-\t\t\t    public TraitItem,\n-\t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem,\n-\t\t\t    public ExternalItem\n-{\n-  std::vector<Attribute> outer_attrs;\n-  MacroInvocData invoc_data;\n-  Location locus;\n-  NodeId node_id;\n-\n-  // this is the expanded macro\n-  ASTFragment fragment;\n-\n-public:\n-  std::string as_string () const override;\n-\n-  MacroInvocationSemi (MacroInvocData invoc_data,\n-\t\t       std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n-      fragment (ASTFragment::create_empty ())\n-  {}\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  // Clones this macro invocation semi.\n-  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n-  {\n-    return std::unique_ptr<MacroInvocationSemi> (\n-      clone_macro_invocation_semi_impl ());\n-  }\n-\n-  void mark_for_strip () override { invoc_data.mark_for_strip (); }\n-  bool is_marked_for_strip () const override\n-  {\n-    return invoc_data.is_marked_for_strip ();\n-  }\n-\n-  // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n-  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n-\n-  Location get_locus () const override final { return locus; }\n-\n-  MacroInvocData &get_invoc_data () { return invoc_data; }\n-\n-  ASTFragment &get_fragment () { return fragment; }\n-\n-  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n-\n-  NodeId get_macro_node_id () const { return node_id; }\n-\n-protected:\n-  MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n-  {\n-    return new MacroInvocationSemi (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_inherent_impl_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_trait_impl_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_trait_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  MacroInvocationSemi *clone_external_item_impl () const final override\n-  {\n-    return clone_macro_invocation_semi_impl ();\n-  }\n-};\n-\n // A crate AST object - holds all the data for a single compilation unit\n struct Crate\n {"}, {"sha": "567da0cb18c125aa6f06eb3faf2fdae1950f2b3f", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -28,7 +28,6 @@ namespace AST {\n // forward decls\n class BlockExpr;\n class TypePath;\n-class MacroInvocationSemi;\n \n // TODO: inline?\n /*struct AbiName {\n@@ -4306,7 +4305,6 @@ class ExternBlock : public VisItem\n \n // Replaced with forward decls - defined in \"rust-macro.h\"\n class MacroItem;\n-class MacroInvocationSemi;\n class MacroRulesDefinition;\n } // namespace AST\n } // namespace Rust"}, {"sha": "de1d0a538bca1e6df592a3db69d23fc3ad2eff5c", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -27,7 +27,6 @@ namespace AST {\n \n // Decls as definitions moved to rust-ast.h\n class MacroItem;\n-class MacroInvocationSemi;\n \n enum MacroFragSpec\n {\n@@ -454,6 +453,10 @@ class MacroRulesDefinition : public MacroItem\n  * compile time */\n class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n+\t\t\tpublic MacroItem,\n+\t\t\tpublic TraitItem,\n+\t\t\tpublic TraitImplItem,\n+\t\t\tpublic InherentImplItem,\n \t\t\tpublic ExprWithoutBlock\n {\n   std::vector<Attribute> outer_attrs;\n@@ -463,14 +466,18 @@ class MacroInvocation : public TypeNoBounds,\n   // this is the expanded macro\n   ASTFragment fragment;\n \n+  // Important for when we actually expand the macro\n+  bool is_semi_coloned;\n+\n public:\n   std::string as_string () const override;\n \n   MacroInvocation (MacroInvocData invoc_data,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+\t\t   std::vector<Attribute> outer_attrs, Location locus,\n+\t\t   bool is_semi_coloned = false)\n     : outer_attrs (std::move (outer_attrs)),\n       invoc_data (std::move (invoc_data)), locus (locus),\n-      fragment (ASTFragment::create_empty ())\n+      fragment (ASTFragment::create_empty ()), is_semi_coloned (is_semi_coloned)\n   {}\n \n   Location get_locus () const override final { return locus; }\n@@ -503,6 +510,8 @@ class MacroInvocation : public TypeNoBounds,\n \n   void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n \n+  bool has_semicolon () const { return is_semi_coloned; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -529,6 +538,40 @@ class MacroInvocation : public TypeNoBounds,\n   {\n     return new MacroInvocation (*this);\n   }\n+\n+  Item *clone_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  bool is_item () const override { return !has_semicolon (); }\n+\n+  TraitItem *clone_trait_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  };\n+\n+  TraitImplItem *clone_trait_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  };\n+\n+  InherentImplItem *clone_inherent_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  ExprWithoutBlock *to_stmt () const override\n+  \n+   \n+   \n+   \n+  { \n+    auto new_impl  = clone_macro_invocation_impl();\n+    new_impl->is_semi_coloned = true;\n+\n+    return new_impl;\n+  }\n };\n \n // more generic meta item path-only form"}, {"sha": "942da7f4db5e86a5a0c188ab0dd53d73b2286baa", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -211,8 +211,9 @@ class ExprStmtWithoutBlock : public ExprStmt\n   std::string as_string () const override;\n \n   ExprStmtWithoutBlock (std::unique_ptr<ExprWithoutBlock> expr, Location locus)\n-    : ExprStmt (locus), expr (std::move (expr))\n+    : ExprStmt (locus), expr (std::move (expr->to_stmt ()))\n   {}\n+\n   /*ExprStmtWithoutBlock (std::unique_ptr<Expr> expr, Location locus)\n     : ExprStmt (locus), expr (std::move (expr))\n   {}*/\n@@ -336,9 +337,6 @@ class ExprStmtWithBlock : public ExprStmt\n   }\n };\n \n-/* Replaced definition of MacroInvocationSemi with forward decl - defined in\n- * rust-macro.h */\n-class MacroInvocationSemi;\n } // namespace AST\n } // namespace Rust\n "}, {"sha": "f52b24a25928be8b9cf89a9ad96bcb2e80d82e42", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -309,29 +309,32 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // supposedly does not require - cfg does nothing\n   }\n-  void visit (AST::MacroInvocationSemi &macro_invoc) override\n-  {\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n-      {\n-\tmacro_invoc.mark_for_strip ();\n-\treturn;\n-      }\n \n-    // can't strip simple path\n+  // FIXME: ARTHUR: Check to see if necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &macro_invoc) override\n+  // {\n+  //   // initial strip test based on outer attrs\n+  //   expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n+  //   if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n+  //     {\n+  // macro_invoc.mark_for_strip ();\n+  // return;\n+  //     }\n \n-    // I don't think any macro token trees can be stripped in any way\n+  //   // can't strip simple path\n \n-    // TODO: maybe have cfg! macro stripping behaviour here?\n+  //   // I don't think any macro token trees can be stripped in any way\n \n-    expander.expand_invoc_semi (macro_invoc);\n+  //   // TODO: maybe have cfg! macro stripping behaviour here?\n \n-    // we need to visit the expanded fragments since it may need cfg expansion\n-    // and it may be recursive\n-    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  //   expander.expand_invoc_semi (macro_invoc);\n+\n+  //   // we need to visit the expanded fragments since it may need cfg\n+  //   expansion\n+  //   // and it may be recursive\n+  //   for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::PathInExpression &path) override\n   {\n@@ -3207,46 +3210,48 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n   invoc.set_fragment (std::move (fragment));\n }\n \n-void\n-MacroExpander::expand_invoc_semi (AST::MacroInvocationSemi &invoc)\n-{\n-  if (depth_exceeds_recursion_limit ())\n-    {\n-      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n-      return;\n-    }\n-\n-  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n-\n-  // lookup the rules for this macro\n-  NodeId resolved_node = UNKNOWN_NODEID;\n-  bool found = resolver->get_macro_scope ().lookup (\n-    Resolver::CanonicalPath::new_seg (invoc.get_macro_node_id (),\n-\t\t\t\t      invoc_data.get_path ().as_string ()),\n-    &resolved_node);\n-  if (!found)\n-    {\n-      rust_error_at (invoc.get_locus (), \"unknown macro\");\n-      return;\n-    }\n-\n-  // lookup the rules\n-  AST::MacroRulesDefinition *rules_def = nullptr;\n-  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n-  rust_assert (ok);\n-\n-  auto fragment = AST::ASTFragment::create_empty ();\n-\n-  if (rules_def->is_builtin ())\n-    fragment\n-      = rules_def->get_builtin_transcriber () (invoc.get_locus (), invoc_data);\n-  else\n-    fragment\n-      = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n-\n-  // lets attach this fragment to the invocation\n-  invoc.set_fragment (std::move (fragment));\n-}\n+// FIXME: ARTHUR: Check to see if necessary for MacroInvocation\n+// void\n+// MacroExpander::expand_invoc_semi (AST::MacroInvocationSemi &invoc)\n+// {\n+//   if (depth_exceeds_recursion_limit ())\n+//     {\n+//       rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+//       return;\n+//     }\n+//\n+//   AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+//\n+//   // lookup the rules for this macro\n+//   NodeId resolved_node = UNKNOWN_NODEID;\n+//   bool found = resolver->get_macro_scope ().lookup (\n+//     Resolver::CanonicalPath::new_seg (invoc.get_macro_node_id (),\n+// \t\t\t\t      invoc_data.get_path ().as_string ()),\n+//     &resolved_node);\n+//   if (!found)\n+//     {\n+//       rust_error_at (invoc.get_locus (), \"unknown macro\");\n+//       return;\n+//     }\n+//\n+//   // lookup the rules\n+//   AST::MacroRulesDefinition *rules_def = nullptr;\n+//   bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+//   rust_assert (ok);\n+//\n+//   auto fragment = AST::ASTFragment::create_empty ();\n+//\n+//   if (rules_def->is_builtin ())\n+//     fragment\n+//       = rules_def->get_builtin_transcriber () (invoc.get_locus (),\n+//       invoc_data);\n+//   else\n+//     fragment\n+//       = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n+//\n+//   // lets attach this fragment to the invocation\n+//   invoc.set_fragment (std::move (fragment));\n+// }\n \n /* Determines whether any cfg predicate is false and hence item with attributes\n  * should be stripped. Note that attributes must be expanded before calling. */"}, {"sha": "597680644d238db9638dd6aed2626bac2d726af9", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -150,7 +150,6 @@ struct MacroExpander\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n   void expand_invoc (AST::MacroInvocation &invoc);\n-  void expand_invoc_semi (AST::MacroInvocationSemi &invoc);\n \n   // Expands a single declarative macro.\n   AST::ASTFragment expand_decl_macro (Location locus,"}, {"sha": "738ed58e3db8481f99a17d7e6ec3ea4408107221", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -56,7 +56,6 @@ class ASTLoweringBase : public AST::ASTVisitor\n   //  virtual void visit(TraitItem& trait_item) {}\n   //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n   //  virtual void visit(TraitImplItem& trait_impl_item) {}\n-  virtual void visit (AST::MacroInvocationSemi &macro) {}\n \n   // rust-path.h\n   virtual void visit (AST::PathInExpression &path) {}"}, {"sha": "8d684288f300d59c41a7a3f3cb10d1a596404559", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -52,15 +52,16 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n \n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n-  }\n+  //   // FIXME\n+  //   // this assertion might go away, maybe on failure's to expand a macro?\n+  //   rust_assert (!fragment.get_nodes ().empty ());\n+  //   fragment.get_nodes ().at (0).accept_vis (*this);\n+  // }\n \n   void visit (AST::TypeAlias &alias) override\n   {\n@@ -318,15 +319,16 @@ class ASTLowerTraitItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n \n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n-  }\n+  //   // FIXME\n+  //   // this assertion might go away, maybe on failure's to expand a macro?\n+  //   rust_assert (!fragment.get_nodes ().empty ());\n+  //   fragment.get_nodes ().at (0).accept_vis (*this);\n+  // }\n \n   void visit (AST::TraitItemFunc &func) override\n   {"}, {"sha": "05276244dfbe8516be85171a7ecb78aaf4a7d9fe", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -51,15 +51,16 @@ class ASTLoweringItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+  //   // FIXME\n+  //   // this assertion might go away, maybe on failure's to expand a macro?\n+  //   rust_assert (!fragment.get_nodes ().empty ());\n+  //   fragment.get_nodes ().at (0).accept_vis (*this);\n+  // }\n \n   void visit (AST::Module &module) override\n   {"}, {"sha": "0373a3865684f25934088bb91477b35ebc528eb4", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -45,15 +45,16 @@ class ASTLoweringStmt : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this implementation is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+  //   // FIXME\n+  //   // this assertion might go away, maybe on failure's to expand a macro?\n+  //   rust_assert (!fragment.get_nodes ().empty ());\n+  //   fragment.get_nodes ().at (0).accept_vis (*this);\n+  // }\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {"}, {"sha": "8559c3b92c7902357ffedc8a492dc5cd65da0470", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -1529,7 +1529,7 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (AST::AttrVec outer_attrs)\n \n // Parses a semi-coloned (except for full block) macro invocation item.\n template <typename ManagedTokenSource>\n-std::unique_ptr<AST::MacroInvocationSemi>\n+std::unique_ptr<AST::MacroInvocation>\n Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n   AST::AttrVec outer_attrs)\n {\n@@ -1618,10 +1618,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n \n-\t      return std::unique_ptr<AST::MacroInvocationSemi> (\n-\t\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t\t      std::move (outer_attrs),\n-\t\t\t\t\t      macro_locus));\n+\t      return std::unique_ptr<AST::MacroInvocation> (\n+\t\tnew AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t\t  std::move (outer_attrs), macro_locus,\n+\t\t\t\t\t  true));\n \t    }\n \t}\n \n@@ -1630,9 +1630,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t\t  t->get_token_description (),\n \t\t  lexer.peek_token ()->get_token_description ());\n \n-      return std::unique_ptr<AST::MacroInvocationSemi> (\n-\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t      std::move (outer_attrs), macro_locus));\n+      return std::unique_ptr<AST::MacroInvocation> (\n+\tnew AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t  std::move (outer_attrs), macro_locus, true));\n     }\n   else\n     {\n@@ -7200,7 +7200,11 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n   // attempt to parse via parse_expr_without_block - seems to work\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n   Location locus = lexer.peek_token ()->get_locus ();\n-  expr = parse_expr_without_block (std::move (outer_attrs));\n+\n+  auto restrictions = ParseRestrictions ();\n+  restrictions.expr_can_be_stmt = true;\n+\n+  expr = parse_expr_without_block (std::move (outer_attrs), restrictions);\n   if (expr == nullptr)\n     {\n       // expr is required, error\n@@ -7227,7 +7231,8 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n  * disambiguates). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprWithoutBlock>\n-Parser<ManagedTokenSource>::parse_expr_without_block (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_without_block (\n+  AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n {\n   /* Notes on types of expr without block:\n    *  - literal expr          tokens that are literals\n@@ -7298,7 +7303,8 @@ Parser<ManagedTokenSource>::parse_expr_without_block (AST::AttrVec outer_attrs)\n \t/* HACK: piggyback on pratt parsed expr and abuse polymorphism to\n \t * essentially downcast */\n \n-\tstd::unique_ptr<AST::Expr> expr = parse_expr (std::move (outer_attrs));\n+\tstd::unique_ptr<AST::Expr> expr\n+\t  = parse_expr (std::move (outer_attrs), restrictions);\n \n \tif (expr == nullptr)\n \t  {\n@@ -11825,18 +11831,20 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t      {\n \t\tlexer.skip_token ();\n \n-\t\tstd::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t\t  new AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t\t\tstd::move (outer_attrs),\n-\t\t\t\t\t\tstmt_or_expr_loc));\n+\t\tstd::unique_ptr<AST::MacroInvocation> stmt (\n+\t\t  new AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t\t    stmt_or_expr_loc),\n+\t\t  true);\n \t\treturn ExprOrStmt (std::move (stmt));\n \t      }\n \n \t    // otherwise, create macro invocation\n \t    std::unique_ptr<AST::MacroInvocation> expr (\n \t      new AST::MacroInvocation (std::move (invoc_data),\n \t\t\t\t\tstd::move (outer_attrs),\n-\t\t\t\t\tstmt_or_expr_loc));\n+\t\t\t\t\tstmt_or_expr_loc),\n+\t      false);\n \t    return ExprOrStmt (std::move (expr));\n \t  }\n \telse\n@@ -12145,10 +12153,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \t{\n \t  lexer.skip_token ();\n \n-\t  std::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t    new AST::MacroInvocationSemi (std::move (invoc_data),\n-\t\t\t\t\t  std::move (outer_attrs),\n-\t\t\t\t\t  macro_locus));\n+\t  std::unique_ptr<AST::MacroInvocation> stmt (\n+\t    new AST::MacroInvocation (std::move (invoc_data),\n+\t\t\t\t      std::move (outer_attrs), macro_locus),\n+\t    true);\n \t  return ExprOrStmt (std::move (stmt));\n \t}\n \n@@ -12430,7 +12438,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t  case EXCLAM:\n \t    // macro\n \t    return parse_macro_invocation_partial (std::move (path),\n-\t\t\t\t\t\t   std::move (outer_attrs));\n+\t\t\t\t\t\t   std::move (outer_attrs),\n+\t\t\t\t\t\t   restrictions);\n \t    case LEFT_CURLY: {\n \t      bool not_a_block\n \t\t= lexer.peek_token (1)->get_id () == IDENTIFIER\n@@ -14331,7 +14340,8 @@ Parser<ManagedTokenSource>::parse_function_call_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroInvocation>\n Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n-  AST::PathInExpression path, AST::AttrVec outer_attrs)\n+  AST::PathInExpression path, AST::AttrVec outer_attrs,\n+  ParseRestrictions restrictions)\n {\n   // macro invocation\n   if (!skip_token (EXCLAM))\n@@ -14356,10 +14366,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n \n   Location macro_locus = converted_path.get_locus ();\n \n-  return std::unique_ptr<AST::MacroInvocation> (\n-    new AST::MacroInvocation (AST::MacroInvocData (std::move (converted_path),\n-\t\t\t\t\t\t   std::move (tok_tree)),\n-\t\t\t      std::move (outer_attrs), macro_locus));\n+  return std::unique_ptr<AST::MacroInvocation> (new AST::MacroInvocation (\n+    AST::MacroInvocData (std::move (converted_path), std::move (tok_tree)),\n+    std::move (outer_attrs), macro_locus, restrictions.expr_can_be_stmt));\n }\n \n /* Parses a struct expr struct with a path in expression already parsed (but not"}, {"sha": "b283197b2cc45d6357612bc7322e10dcce601a97", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -80,6 +80,7 @@ struct ParseRestrictions\n    * like struct exprs being parsed from a dereference. */\n   bool entered_from_unary = false;\n   bool expr_can_be_null = false;\n+  bool expr_can_be_stmt = false;\n };\n \n // Parser implementation for gccrs.\n@@ -157,7 +158,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TokenTree> parse_token_tree ();\n   std::unique_ptr<AST::MacroRulesDefinition>\n   parse_macro_rules_def (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::MacroInvocationSemi>\n+  std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation_semi (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation (AST::AttrVec outer_attrs);\n@@ -468,9 +469,9 @@ template <typename ManagedTokenSource> class Parser\n   parse_index_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> array_expr,\n \t\t    AST::AttrVec outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::MacroInvocation>\n-  parse_macro_invocation_partial (AST::PathInExpression path,\n-\t\t\t\t  AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroInvocation> parse_macro_invocation_partial (\n+    AST::PathInExpression path, AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::StructExprStruct>\n   parse_struct_expr_struct_partial (AST::PathInExpression path,\n \t\t\t\t    AST::AttrVec outer_attrs);\n@@ -490,7 +491,9 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::ExprWithBlock>\n   parse_expr_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec ());\n+  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t    ParseRestrictions restrictions\n+\t\t\t    = ParseRestrictions ());\n   // When given a pratt_parsed_loc, use it as the location of the\n   // first token parsed in the expression (the parsing of that first\n   // token should be skipped)."}, {"sha": "eca9694da960b3706ca1f35c3a4397ded2b63c05", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -38,7 +38,6 @@ class ResolverBase : public AST::ASTVisitor\n   void visit (AST::IdentifierExpr &) {}\n   void visit (AST::Lifetime &) {}\n   void visit (AST::LifetimeParam &) {}\n-  void visit (AST::MacroInvocationSemi &) {}\n   void visit (AST::PathInExpression &) {}\n   void visit (AST::TypePathSegment &) {}\n   void visit (AST::TypePathSegmentGeneric &) {}"}, {"sha": "32dd90fba17440c0044b93bb2002f8eec9feaae5", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -49,12 +49,13 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::TypeAlias &type) override\n   {\n@@ -144,12 +145,13 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::TraitItemFunc &function) override\n   {\n@@ -254,12 +256,13 @@ class ResolveToplevelExternItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::ExternalFunctionItem &function) override\n   {"}, {"sha": "5f9500d6e5012848a37d52a0c682bc176f10d9b7", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -45,12 +45,13 @@ class ResolveTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::TraitItemType &type) override\n   {\n@@ -234,12 +235,13 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::TypeAlias &alias) override\n   {"}, {"sha": "81a37b7d4138c22542a9f20a69c3f84c5c244a05", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -44,13 +44,14 @@ class ResolveStmt : public ResolverBase\n     stmt->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {"}, {"sha": "762010c6660c69bf691738bf0e3ada69c0a042bd", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12d156566af84ec834abb7e18feac6e8f5884451/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=12d156566af84ec834abb7e18feac6e8f5884451", "patch": "@@ -43,12 +43,13 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocationSemi &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n+  // void visit (AST::MacroInvocationSemi &invoc) override\n+  // {\n+  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  //   for (auto &node : fragment.get_nodes ())\n+  //     node.accept_vis (*this);\n+  // }\n \n   void visit (AST::Module &module) override\n   {"}]}