{"sha": "c383667d4fa396fc2748cc163b3527c8de0f7f21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM4MzY2N2Q0ZmEzOTZmYzI3NDhjYzE2M2IzNTI3YzhkZTBmN2YyMQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-05-12T18:23:56Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-05-12T18:23:56Z"}, "message": "Replace ARM_REG_PREFIX with REGISTER_PREFIX.\n\nReplace ARM_COMMENT_CHAR with ASM_COMMENT_START.\n(REGISTER_PREFIX): Define.\n(USER_LABEL_PREFIX, LOCAL_LABEL_PREFIX): Define.\n(SECONDARY_OUTPUT_RELOAD_CLASS): Handle DFmodes only if TARGET_HARD_FLOAT.\n(PREDICATE_CODES): Add soft_df_operand.\n\nFrom-SVN: r9651", "tree": {"sha": "2ce9ed6b9e73894b77d8a980f63309a4816b53d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce9ed6b9e73894b77d8a980f63309a4816b53d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c383667d4fa396fc2748cc163b3527c8de0f7f21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c383667d4fa396fc2748cc163b3527c8de0f7f21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c383667d4fa396fc2748cc163b3527c8de0f7f21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c383667d4fa396fc2748cc163b3527c8de0f7f21/comments", "author": null, "committer": null, "parents": [{"sha": "f6789c7753fa2305592d2f0db5c14d23dc78700b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6789c7753fa2305592d2f0db5c14d23dc78700b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6789c7753fa2305592d2f0db5c14d23dc78700b"}], "stats": {"total": 101, "additions": 51, "deletions": 50}, "files": [{"sha": "cd783f4fefb8a24dcea6fbb77a4676e845012f74", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c383667d4fa396fc2748cc163b3527c8de0f7f21/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c383667d4fa396fc2748cc163b3527c8de0f7f21/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c383667d4fa396fc2748cc163b3527c8de0f7f21", "patch": "@@ -565,7 +565,8 @@ enum reg_class\n    NO_REGS is returned.  */\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X)\t\\\n   (((MODE) == DFmode && (CLASS) == GENERAL_REGS\t\t\\\n-    && true_regnum (X) == -1) ? GENERAL_REGS\t\t\\\n+    && true_regnum (X) == -1 && TARGET_HARD_FLOAT)\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\\\n    : ((MODE) == HImode && true_regnum (X) == -1) ? GENERAL_REGS : NO_REGS)\n \n /* If we need to load shorts byte-at-a-time, then we need a scratch. */\n@@ -733,7 +734,7 @@ enum reg_class\n    to mind about this!  */\n #define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n {\t\t\t\t\t\t\t\t\t    \\\n-    fprintf(STREAM, \"\\tmov\\t%sip, %slr\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+    fprintf(STREAM, \"\\tmov\\t%sip, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n     fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\t\t    \\\n     fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\t\t    \\\n }\n@@ -832,10 +833,10 @@ enum reg_class\n \t   .word\tfunction's address  */\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\tldr\\t%sr8, [%spc, #0]\\n\", ARM_REG_PREFIX,\t\\\n-\t   ARM_REG_PREFIX);\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\tldr\\t%spc, [%spc, #0]\\n\", ARM_REG_PREFIX,\t\\\n-\t   ARM_REG_PREFIX);\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\tldr\\t%sr8, [%spc, #0]\\n\",\t\t\t\\\n+\t   REGISTER_PREFIX, REGISTER_PREFIX);\t\t\t\\\n+  fprintf ((FILE), \"\\tldr\\t%spc, [%spc, #0]\\n\",\t\t\t\\\n+\t   REGISTER_PREFIX, REGISTER_PREFIX);\t\t\t\\\n   fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n   fprintf ((FILE), \"\\t.word\\t0\\n\");\t\t\t\t\\\n }\n@@ -1352,6 +1353,7 @@ extern int arm_compare_fp;\n   {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\\n   {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATERT, MULT}},\t\\\n   {\"di_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}},\t\t\\\n+  {\"soft_df_operand\", {SUBREG, REG, CONST_DOUBLE, MEM}},\t\t\\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n   {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n@@ -1374,15 +1376,15 @@ extern int arm_compare_fp;\n #define ASM_FILE_START(STREAM)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   extern char *version_string;\t\t\t\t\t\t  \\\n-  fprintf (STREAM,\"%c Generated by gcc %s for ARM/%s\\n\",\t\t  \\\n-\t   ARM_COMMENT_CHAR, version_string, ARM_OS_NAME);\t\t  \\\n-  fprintf (STREAM,\"%srfp\\t.req\\t%sr9\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n-  fprintf (STREAM,\"%ssl\\t.req\\t%sr10\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n-  fprintf (STREAM,\"%sfp\\t.req\\t%sr11\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n-  fprintf (STREAM,\"%sip\\t.req\\t%sr12\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n-  fprintf (STREAM,\"%ssp\\t.req\\t%sr13\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n-  fprintf (STREAM,\"%slr\\t.req\\t%sr14\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n-  fprintf (STREAM,\"%spc\\t.req\\t%sr15\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n+  fprintf (STREAM,\"%s Generated by gcc %s for ARM/%s\\n\",\t\t  \\\n+\t   ASM_COMMENT_START, version_string, ARM_OS_NAME);\t\t  \\\n+  fprintf (STREAM,\"%srfp\\t.req\\t%sr9\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%ssl\\t.req\\t%sr10\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%sfp\\t.req\\t%sr11\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%sip\\t.req\\t%sr12\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%ssp\\t.req\\t%sr13\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%slr\\t.req\\t%sr14\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%spc\\t.req\\t%sr15\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n }\n \n #define ASM_APP_ON  \"\"\n@@ -1392,6 +1394,10 @@ extern int arm_compare_fp;\n #define TEXT_SECTION_ASM_OP  \".text\"\n #define DATA_SECTION_ASM_OP  \".data\"\n \n+#define REGISTER_PREFIX \"\"\n+#define USER_LABEL_PREFIX \"_\"\n+#define LOCAL_LABEL_PREFIX \"\"\n+\n /* The assembler's names for the registers.  */\n #ifndef REGISTER_NAMES\n #define REGISTER_NAMES  \\\n@@ -1471,7 +1477,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Output a reference to a label.  */\n #define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n-  fprintf (STREAM, \"_%s\", NAME)\n+  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, NAME)\n \n /* Make an internal label into a string.  */\n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n@@ -1506,13 +1512,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n    sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n \n /* Output a push or a pop instruction (only used when profiling).  */\n-#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\t    \\\n-  fprintf(STREAM,\"\\tstmfd\\t%ssp!,{%s%s}\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX, \\\n-\t  reg_names[REGNO])\n+#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO) \\\n+  fprintf(STREAM,\"\\tstmfd\\t%ssp!,{%s%s}\\n\", \\\n+\t  REGISTER_PREFIX, REGISTER_PREFIX, reg_names[REGNO])\n \n-#define ASM_OUTPUT_REG_POP(STREAM,REGNO)\t\t\t\t    \\\n-  fprintf(STREAM,\"\\tldmfd\\t%ssp!,{%s%s}\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX, \\\n-\t  reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(STREAM,REGNO) \\\n+  fprintf(STREAM,\"\\tldmfd\\t%ssp!,{%s%s}\\n\", \\\n+\t  REGISTER_PREFIX, REGISTER_PREFIX, reg_names[REGNO])\n \n /* Output a relative address. Not needed since jump tables are absolute\n    but we must define it anyway.  */\n@@ -1535,11 +1541,11 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n      if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%x,0x%x,0x%x\\t%c long double %s\\n\",\t\\\n-\t\tl[2], l[1], l[0], ARM_COMMENT_CHAR, dstr);\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%x,0x%x,0x%x\\t%s long double %s\\n\",\t\\\n+\t\tl[2], l[1], l[0], ASM_COMMENT_START, dstr);\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%c long double %s\\n\",\\\n-\t\tl[0], l[1], l[2], ARM_COMMENT_CHAR, dstr);\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\",\\\n+\t\tl[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\\\n    } while (0)\n \n     \n@@ -1550,11 +1556,11 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n      REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n      if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%x, 0x%x\\t%c double %s\\n\", l[0],\t\\\n-\t\tl[1], ARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%x, 0x%x\\t%s double %s\\n\", l[0],\t\\\n+\t\tl[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%c double %s\\n\", l[0],\t\\\n-\t\tl[1], ARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n+\t\tl[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n    } while (0)\n \n #define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n@@ -1564,11 +1570,11 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n      REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n      if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.word 0x%x\\t%c float %s\\n\", l,\t\t\\\n-\t\tARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.word 0x%x\\t%s float %s\\n\", l,\t\t\\\n+\t\tASM_COMMENT_START, dstr);\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.word 0x%lx\\t%c float %s\\n\", l,\t\t\\\n-\t\tARM_COMMENT_CHAR, dstr);\t\t\t\t\\\n+       fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\t\\\n+\t\tASM_COMMENT_START, dstr);\t\t\t\t\\\n    } while (0);\n \n #define ASM_OUTPUT_INT(STREAM, EXP)\t\\\n@@ -1622,7 +1628,7 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n   (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \t\t\t\\\n    assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n-   fprintf(STREAM, \", %d\\t%c%d\\n\", ROUNDED, ARM_COMMENT_CHAR, SIZE))\n+   fprintf(STREAM, \", %d\\t%s %d\\n\", ROUNDED, ASM_COMMENT_START, SIZE))\n \n /* Output a local common block.  /bin/as can't do this, so hack a `.space' into\n    the bss segment.  Note that this is *bad* practice.  */\n@@ -1655,13 +1661,8 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n   if (optimize)\t\t\t\t\t    \\\n     final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n-#ifndef ARM_COMMENT_CHAR\n-#define ARM_COMMENT_CHAR '@'\n-#endif\n-\n-/* Default is for register names not to have a prefix.  */\n-#ifndef ARM_REG_PREFIX\n-#define ARM_REG_PREFIX \"\"\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \"@\"\n #endif\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n@@ -1684,7 +1685,7 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n     int is_minus = GET_CODE (X) == MINUS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"[%s%s, #0]\", ARM_REG_PREFIX,\t\t\t\\\n+\tfprintf (STREAM, \"[%s%s, #0]\", REGISTER_PREFIX,\t\t\t\\\n \t\t reg_names[REGNO (X)]);\t\t\t\t\t\\\n     else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -1706,14 +1707,14 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \t    offset = INTVAL (index);\t\t\t\t\t\\\n \t    if (is_minus)\t\t\t\t\t\t\\\n \t      offset = -offset;\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, #%d]\", ARM_REG_PREFIX,\t\t\\\n+\t    fprintf (STREAM, \"[%s%s, #%d]\", REGISTER_PREFIX,\t\t\\\n \t\t     base_reg_name, offset);\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case REG:\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, %s%s%s]\", ARM_REG_PREFIX,\t\t\\\n+\t    fprintf (STREAM, \"[%s%s, %s%s%s]\", REGISTER_PREFIX,\t\t\\\n \t\t     base_reg_name, is_minus ? \"-\" : \"\",\t\t\\\n-\t\t     ARM_REG_PREFIX, reg_names[REGNO (index)] );\t\\\n+\t\t     REGISTER_PREFIX, reg_names[REGNO (index)] );\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case MULT:\t\t\t\t\t\t\t\\\n@@ -1722,8 +1723,8 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \t  case ASHIFT:\t\t\t\t\t\t\t\\\n \t  case ROTATERT:\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, %s%s%s\", ARM_REG_PREFIX,\t\t\\\n-\t\t     base_reg_name, is_minus ? \"-\" : \"\", ARM_REG_PREFIX,\\\n+\t    fprintf (STREAM, \"[%s%s, %s%s%s\", REGISTER_PREFIX,\t\t\\\n+\t\t     base_reg_name, is_minus ? \"-\" : \"\", REGISTER_PREFIX,\\\n \t\t     reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n \t    arm_print_operand (STREAM, index, 'S');\t\t\t\\\n \t    fputs (\"]\", STREAM);\t\t\t\t\t\\\n@@ -1743,12 +1744,12 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \tabort ();\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n-\tfprintf (STREAM, \"[%s%s, #%s%d]!\", ARM_REG_PREFIX,\t\t\\\n+\tfprintf (STREAM, \"[%s%s, #%s%d]!\", REGISTER_PREFIX,\t\t\\\n \t\t reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n \t\t GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\t\\\n \t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"[%s%s], #%s%d\", ARM_REG_PREFIX,\t\t\\\n+\tfprintf (STREAM, \"[%s%s], #%s%d\", REGISTER_PREFIX,\t\t\\\n \t\t reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n \t\t GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\t\\\n \t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\"}]}