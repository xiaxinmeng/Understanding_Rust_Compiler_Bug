{"sha": "ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMzZTlmODI2NzczYTdhYTRjZmMxMzViNGNjOWUyZGUyMjJiYzEzNw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-10T09:38:52Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-10T09:38:52Z"}, "message": "In gcc/: 2010-12-10 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* c-parser.c (c_parser_objc_class_definition): Recognize\n\tObjective-C 2.0 class extensions.\n\nIn gcc/cp/:\n2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* parser.c (cp_parser_objc_superclass_or_category): Recognize\n\tObjective-C 2.0 class extensions.  Added iface_p and\n\tis_class_extension arguments.\n\t(cp_parser_objc_class_interface): Updated call to\n\tcp_parser_objc_superclass_or_category.\n\t(cp_parser_objc_class_implementation): Same change.\n\t\nIn gcc/objc/:\n2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc-act.c (objc_in_class_extension): New.\n\t(objc_start_category_interface): If -fobjc-std=objc1\n\twas specified, produce an error if a class extension is used.\n\t(objc_finish_interface): Reset objc_in_class_extension to false.\n\t(objc_add_property_declaration): Allow a class extension to extend\n\treadonly properties in the main @interface to be readwrite.\n\t(start_class): Added code to deal with class extensions.  In that\n\tcase, return the existing interface after adding any additional\n\tprotocols to it and setting objc_in_class_extension to true.\n\t(continue_class): If in a class extension, do not generate the\n\tinstance variable template.\n\nIn gcc/testsuite/:\n2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc.dg/class-extension-1.m: New.\n\t* objc.dg/class-extension-2.m: New.\n\t* objc.dg/class-extension-3.m: New.\n\t* objc.dg/property/at-property-26.m: New.\n\t* objc.dg/property/at-property-27.m: New.\n\t* objc.dg/property/at-property-28.m: New.\n\t* obj-c++.dg/class-extension-1.mm: New.\n\t* obj-c++.dg/class-extension-2.mm: New.\n\t* obj-c++.dg/class-extension-3.mm: New.\n\t* obj-c++.dg/property/at-property-26.mm: New.\n\t* obj-c++.dg/property/at-property-27.mm: New.\n\t* obj-c++.dg/property/at-property-28.mm: New.\n\nFrom-SVN: r167680", "tree": {"sha": "1455b598d50eb7e482cbb74cb6884dc439905ab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1455b598d50eb7e482cbb74cb6884dc439905ab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aff7f4c416f03bcadf563a3f73896ddabd8da844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff7f4c416f03bcadf563a3f73896ddabd8da844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff7f4c416f03bcadf563a3f73896ddabd8da844"}], "stats": {"total": 886, "additions": 811, "deletions": 75}, "files": [{"sha": "66ece2c3f5e107eed39c16560e6782105071e79f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -1,3 +1,8 @@\n+2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-parser.c (c_parser_objc_class_definition): Recognize\n+\tObjective-C 2.0 class extensions.\n+\n 2010-12-10  Iain Sandoe <iains@gcc.gnu.org>\n \n \t* config/darwin.c: Remove c-tree.h and c-lang.h"}, {"sha": "8238506b540606e6bea01a3517df0a37ba496446", "filename": "gcc/c-parser.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -6743,6 +6743,8 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n        objc-class-instance-variables[opt]\n      @interface identifier ( identifier ) objc-protocol-refs[opt]\n        objc-methodprotolist @end\n+     @interface identifier ( ) objc-protocol-refs[opt]\n+       objc-methodprotolist @end\n      @implementation identifier ( identifier )\n \n    objc-superclass:\n@@ -6777,17 +6779,29 @@ c_parser_objc_class_definition (c_parser *parser, tree attributes)\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n+      /* We have a category or class extension.  */\n       tree id2;\n       tree proto = NULL_TREE;\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is_not (parser, CPP_NAME))\n \t{\n-\t  c_parser_error (parser, \"expected identifier\");\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t  return;\n+\t  if (iface_p && c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\t    {\n+\t      /* We have a class extension.  */\n+\t      id2 = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      c_parser_error (parser, \"expected identifier or %<)%>\");\n+\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  id2 = c_parser_peek_token (parser)->value;\n+\t  c_parser_consume_token (parser);\n \t}\n-      id2 = c_parser_peek_token (parser)->value;\n-      c_parser_consume_token (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n       if (!iface_p)\n \t{"}, {"sha": "a78f82c7c86f9181a25af98d61b1989070a04eda", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -1,3 +1,12 @@\n+2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* parser.c (cp_parser_objc_superclass_or_category): Recognize\n+\tObjective-C 2.0 class extensions.  Added iface_p and\n+\tis_class_extension arguments.\n+\t(cp_parser_objc_class_interface): Updated call to\n+\tcp_parser_objc_superclass_or_category.\n+\t(cp_parser_objc_class_implementation): Same change.\n+\t\n 2010-12-09  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* call.c (print_conversion_rejection): Indent messages two spaces."}, {"sha": "4c8ca7288c63806889dcf1c339c0531f2122093f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -22435,12 +22435,15 @@ cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n /* Parse an Objective-C superclass or category.  */\n \n static void\n-cp_parser_objc_superclass_or_category (cp_parser *parser, tree *super,\n-\t\t\t\t\t\t\t  tree *categ)\n+cp_parser_objc_superclass_or_category (cp_parser *parser, \n+\t\t\t\t       bool iface_p,\n+\t\t\t\t       tree *super,\n+\t\t\t\t       tree *categ, bool *is_class_extension)\n {\n   cp_token *next = cp_lexer_peek_token (parser->lexer);\n \n   *super = *categ = NULL_TREE;\n+  *is_class_extension = false;\n   if (next->type == CPP_COLON)\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n@@ -22449,7 +22452,17 @@ cp_parser_objc_superclass_or_category (cp_parser *parser, tree *super,\n   else if (next->type == CPP_OPEN_PAREN)\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n-      *categ = cp_parser_identifier (parser);\n+\n+      /* If there is no category name, and this is an @interface, we\n+\t have a class extension.  */\n+      if (iface_p && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t{\n+\t  *categ = NULL_TREE;\n+\t  *is_class_extension = true;\n+\t}\n+      else\n+\t*categ = cp_parser_identifier (parser);\n+\n       cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n     }\n }\n@@ -22460,6 +22473,7 @@ static void\n cp_parser_objc_class_interface (cp_parser* parser, tree attributes)\n {\n   tree name, super, categ, protos;\n+  bool is_class_extension;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@interface'.  */\n   name = cp_parser_identifier (parser);\n@@ -22472,11 +22486,12 @@ cp_parser_objc_class_interface (cp_parser* parser, tree attributes)\n       */\n       return;\n     }\n-  cp_parser_objc_superclass_or_category (parser, &super, &categ);\n+  cp_parser_objc_superclass_or_category (parser, true, &super, &categ,\n+\t\t\t\t\t &is_class_extension);\n   protos = cp_parser_objc_protocol_refs_opt (parser);\n \n   /* We have either a class or a category on our hands.  */\n-  if (categ)\n+  if (categ || is_class_extension)\n     objc_start_category_interface (name, categ, protos, attributes);\n   else\n     {\n@@ -22495,6 +22510,7 @@ static void\n cp_parser_objc_class_implementation (cp_parser* parser)\n {\n   tree name, super, categ;\n+  bool is_class_extension;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@implementation'.  */\n   name = cp_parser_identifier (parser);\n@@ -22508,7 +22524,8 @@ cp_parser_objc_class_implementation (cp_parser* parser)\n       */\n       return;\n     }\n-  cp_parser_objc_superclass_or_category (parser, &super, &categ);\n+  cp_parser_objc_superclass_or_category (parser, false, &super, &categ,\n+\t\t\t\t\t &is_class_extension);\n \n   /* We have either a class or a category on our hands.  */\n   if (categ)"}, {"sha": "f079cb5cb80deead2a9e7b3d11892d41e4758c63", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -1,3 +1,17 @@\n+2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_in_class_extension): New.\n+\t(objc_start_category_interface): If -fobjc-std=objc1\n+\twas specified, produce an error if a class extension is used.\n+\t(objc_finish_interface): Reset objc_in_class_extension to false.\n+\t(objc_add_property_declaration): Allow a class extension to extend\n+\treadonly properties in the main @interface to be readwrite.\n+\t(start_class): Added code to deal with class extensions.  In that\n+\tcase, return the existing interface after adding any additional\n+\tprotocols to it and setting objc_in_class_extension to true.\n+\t(continue_class): If in a class extension, do not generate the\n+\tinstance variable template.\n+\n 2010-12-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_throw_stmt): Check that the argument of"}, {"sha": "131ce5524e4c306a45a38562d4b243577b4aa7c2", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 142, "deletions": 64, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -402,6 +402,12 @@ static bool objc_method_optional_flag = false;\n \n static int objc_collecting_ivars = 0;\n \n+/* Flag that is set to 'true' while we are processing a class\n+   extension.  Since a class extension just \"reopens\" the main\n+   @interface, this can be used to determine if we are in the main\n+   @interface, or in a class extension.  */\n+static bool objc_in_class_extension = false;\n+\n #define BUFSIZE\t\t1024\n \n static char *errbuf;\t/* Buffer for error diagnostics */\n@@ -748,6 +754,11 @@ objc_start_category_interface (tree klass, tree categ,\n \t\t    \"category attributes are not available in this version\"\n \t\t    \" of the compiler, (ignored)\");\n     }\n+  if (categ == NULL_TREE)\n+    {\n+      if (flag_objc1_only)\n+\terror_at (input_location, \"class extensions are not available in Objective-C 1.0\");\n+    }\n   objc_interface_context\n     = start_class (CATEGORY_INTERFACE_TYPE, klass, categ, protos, NULL_TREE);\n   objc_ivar_chain\n@@ -778,6 +789,7 @@ objc_finish_interface (void)\n   finish_class (objc_interface_context);\n   objc_interface_context = NULL_TREE;\n   objc_method_optional_flag = false;\n+  objc_in_class_extension = false;\n }\n \n void\n@@ -952,6 +964,7 @@ objc_add_property_declaration (location_t location, tree decl,\n      is readwrite).  */\n   bool property_readonly = false;\n   objc_property_assign_semantics property_assign_semantics = OBJC_PROPERTY_ASSIGN;\n+  bool property_extension_in_class_extension = false;\n \n   if (flag_objc1_only)\n     error_at (input_location, \"%<@property%> is not available in Objective-C 1.0\");\n@@ -1125,60 +1138,80 @@ objc_add_property_declaration (location_t location, tree decl,\n \n   /* Check for duplicate property declarations.  We first check the\n      immediate context for a property with the same name.  Any such\n-     declarations are an error.  */\n+     declarations are an error, unless this is a class extension and\n+     we are extending a property from readonly to readwrite.  */\n   for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n     {\n       if (PROPERTY_NAME (x) == DECL_NAME (decl))\n \t{\n-\t  location_t original_location = DECL_SOURCE_LOCATION (x);\n-\t  \n-\t  error_at (location, \"redeclaration of property %qD\", decl);\n-\n-\t  if (original_location != UNKNOWN_LOCATION)\n-\t    inform (original_location, \"originally specified here\");\n-\t  return;\n-      }\n+\t  if (objc_in_class_extension\n+\t      && property_readonly == 0\n+\t      && PROPERTY_READONLY (x) == 1)\n+\t    {\n+\t      /* This is a class extension, and we are extending an\n+\t\t existing readonly property to a readwrite one.\n+\t\t That's fine.  :-) */\n+\t      property_extension_in_class_extension = true;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      location_t original_location = DECL_SOURCE_LOCATION (x);\n+\t      \n+\t      error_at (location, \"redeclaration of property %qD\", decl);\n+\t      \n+\t      if (original_location != UNKNOWN_LOCATION)\n+\t\tinform (original_location, \"originally specified here\");\n+\t      return;\n+\t    }\n+\t}\n     }\n \n-  /* We now need to check for existing property declarations (in the\n-     superclass, other categories or protocols) and check that the new\n-     declaration is not in conflict with existing ones.  */\n+  /* If x is not NULL_TREE, we must be in a class extension and we're\n+     extending a readonly property.  In that case, no point in\n+     searching for another declaration.  */\n+  if (x == NULL_TREE)\n+    {\n+      /* We now need to check for existing property declarations (in\n+\t the superclass, other categories or protocols) and check that\n+\t the new declaration is not in conflict with existing\n+\t ones.  */\n \n-  /* Search for a previous, existing declaration of a property with\n-     the same name in superclasses, protocols etc.  If one is found,\n-     it will be in the 'x' variable.  */\n-  x = NULL_TREE;\n+      /* Search for a previous, existing declaration of a property\n+\t with the same name in superclasses, protocols etc.  If one is\n+\t found, it will be in the 'x' variable.  */\n \n-  /* Note that, for simplicity, the following may search again the\n-     local context.  That's Ok as nothing will be found (else we'd\n-     have thrown an error above); it's only a little inefficient, but\n-     the code is simpler.  */\n-  switch (TREE_CODE (objc_interface_context))\n-    {\n-    case CLASS_INTERFACE_TYPE:\n-      /* Look up the property in the current @interface (which will\n-\t find nothing), then its protocols and categories and\n-\t superclasses.  */\n-      x = lookup_property (objc_interface_context, DECL_NAME (decl));\n-      break;\n-    case CATEGORY_INTERFACE_TYPE:\n-      /* Look up the property in the main @interface, then protocols\n-\t and categories (one of them is ours, and will find nothing)\n-\t and superclasses.  */\n-      x = lookup_property (lookup_interface (CLASS_NAME (objc_interface_context)),\n-\t\t\t   DECL_NAME (decl));\n-      break;\n-    case PROTOCOL_INTERFACE_TYPE:\n-      /* Looks up the property in any protocols attached to the\n-\t current protocol.  */\n-      if (PROTOCOL_LIST (objc_interface_context))\n+      /* Note that, for simplicity, the following may search again the\n+\t local context.  That's Ok as nothing will be found (else we'd\n+\t have thrown an error above); it's only a little inefficient,\n+\t but the code is simpler.  */\n+      switch (TREE_CODE (objc_interface_context))\n \t{\n-\t  x = lookup_property_in_protocol_list (PROTOCOL_LIST (objc_interface_context),\n-\t\t\t\t\t\tDECL_NAME (decl));\n+\tcase CLASS_INTERFACE_TYPE:\n+\t  /* Look up the property in the current @interface (which\n+\t     will find nothing), then its protocols and categories and\n+\t     superclasses.  */\n+\t  x = lookup_property (objc_interface_context, DECL_NAME (decl));\n+\t  break;\n+\tcase CATEGORY_INTERFACE_TYPE:\n+\t  /* Look up the property in the main @interface, then\n+\t     protocols and categories (one of them is ours, and will\n+\t     find nothing) and superclasses.  */\n+\t  x = lookup_property (lookup_interface (CLASS_NAME (objc_interface_context)),\n+\t\t\t       DECL_NAME (decl));\n+\t  break;\n+\tcase PROTOCOL_INTERFACE_TYPE:\n+\t  /* Looks up the property in any protocols attached to the\n+\t     current protocol.  */\n+\t  if (PROTOCOL_LIST (objc_interface_context))\n+\t    {\n+\t      x = lookup_property_in_protocol_list (PROTOCOL_LIST (objc_interface_context),\n+\t\t\t\t\t\t    DECL_NAME (decl));\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n     }\n \n   if (x != NULL_TREE)\n@@ -1278,6 +1311,17 @@ objc_add_property_declaration (location_t location, tree decl,\n \t    inform (original_location, \"originally specified here\");\n \t  return;\n \t}\n+\n+      /* If we are in a class extension and we're extending a readonly\n+\t property in the main @interface, we'll just update the\n+\t existing property with the readwrite flag and potentially the\n+\t new setter name.  */\n+      if (property_extension_in_class_extension)\n+\t{\n+\t  PROPERTY_READONLY (x) = 0;\n+\t  PROPERTY_SETTER_NAME (x) = parsed_property_setter_ident;\n+\t  return;\n+\t}\n     }\n \n   /* Create a PROPERTY_DECL node.  */\n@@ -9417,21 +9461,24 @@ check_protocols (tree proto_list, const char *type, tree name)\n     }\n }\n \f\n-/* Make sure that the class CLASS_NAME is defined\n-   CODE says which kind of thing CLASS_NAME ought to be.\n-   It can be CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n-   CATEGORY_INTERFACE_TYPE, or CATEGORY_IMPLEMENTATION_TYPE.  */\n-\n+/* Make sure that the class CLASS_NAME is defined CODE says which kind\n+   of thing CLASS_NAME ought to be.  It can be CLASS_INTERFACE_TYPE,\n+   CLASS_IMPLEMENTATION_TYPE, CATEGORY_INTERFACE_TYPE, or\n+   CATEGORY_IMPLEMENTATION_TYPE.  For a CATEGORY_INTERFACE_TYPE,\n+   SUPER_NAME is the name of the category.  For a class extension,\n+   CODE is CATEGORY_INTERFACE_TYPE and SUPER_NAME is NULL_TREE.  */\n static tree\n start_class (enum tree_code code, tree class_name, tree super_name,\n \t     tree protocol_list, tree attributes)\n {\n-  tree klass, decl;\n+  tree klass = NULL_TREE;\n+  tree decl;\n \n #ifdef OBJCPLUS\n-  if (current_namespace != global_namespace) {\n-    error (\"Objective-C declarations may only appear in global scope\");\n-  }\n+  if (current_namespace != global_namespace)\n+    {\n+      error (\"Objective-C declarations may only appear in global scope\");\n+    }\n #endif /* OBJCPLUS */\n \n   if (objc_implementation_context)\n@@ -9442,8 +9489,14 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n       objc_implementation_context = NULL_TREE;\n     }\n \n-  klass = make_node (code);\n-  TYPE_LANG_SLOT_1 (klass) = make_tree_vec (CLASS_LANG_SLOT_ELTS);\n+  /* If this is a class extension, we'll be \"reopening\" the existing\n+     CLASS_INTERFACE_TYPE, so in that case there is no need to create\n+     a new node.  */\n+  if (code != CATEGORY_INTERFACE_TYPE || super_name != NULL_TREE)\n+    {\n+      klass = make_node (code);\n+      TYPE_LANG_SLOT_1 (klass) = make_tree_vec (CLASS_LANG_SLOT_ELTS);\n+    }\n \n   /* Check for existence of the super class, if one was specified.  Note\n      that we must have seen an @interface, not just a @class.  If we\n@@ -9473,9 +9526,12 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t}\n     }\n \n-  CLASS_NAME (klass) = class_name;\n-  CLASS_SUPER_NAME (klass) = super_name;\n-  CLASS_CLS_METHODS (klass) = NULL_TREE;\n+  if (code != CATEGORY_INTERFACE_TYPE || super_name != NULL_TREE)\n+    {\n+      CLASS_NAME (klass) = class_name;\n+      CLASS_SUPER_NAME (klass) = super_name;\n+      CLASS_CLS_METHODS (klass) = NULL_TREE;\n+    }\n \n   if (! objc_is_class_name (class_name)\n       && (decl = lookup_name (class_name)))\n@@ -9592,15 +9648,35 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t    if (TREE_DEPRECATED (class_category_is_assoc_with))\n \t      warning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\", \n \t\t       class_name);\n-\t    add_category (class_category_is_assoc_with, klass);\n-\t  }\n \n-\tif (protocol_list)\n-\t  CLASS_PROTOCOL_LIST (klass)\n-\t    = lookup_and_install_protocols (protocol_list);\n+\t    if (super_name == NULL_TREE)\n+\t      {\n+\t\t/* This is a class extension.  Get the original\n+\t\t   interface, and continue working on it.  */\n+\t\tobjc_in_class_extension = true;\n+\t\tklass = class_category_is_assoc_with;\n+\n+\t\tif (protocol_list)\n+\t\t  {\n+\t\t    /* Append protocols to the original protocol\n+\t\t       list.  */\n+\t\t    CLASS_PROTOCOL_LIST (klass)\n+\t\t      = chainon (CLASS_PROTOCOL_LIST (klass),\n+\t\t\t\t lookup_and_install_protocols (protocol_list));\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tadd_category (class_category_is_assoc_with, klass);\n+\t\t\n+\t\tif (protocol_list)\n+\t\t  CLASS_PROTOCOL_LIST (klass)\n+\t\t    = lookup_and_install_protocols (protocol_list);\n+\t      }\n+\t  }\n       }\n       break;\n-\n+\t\n     case CATEGORY_IMPLEMENTATION_TYPE:\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n@@ -9673,6 +9749,8 @@ continue_class (tree klass)\n       }\n     case CLASS_INTERFACE_TYPE:\n       {\n+\tif (objc_in_class_extension)\n+\t  return NULL_TREE;\n #ifdef OBJCPLUS\n \tpush_lang_context (lang_name_c);\n #endif /* OBJCPLUS */"}, {"sha": "afba479e3c798148b66969d68595e1dd4276b9a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -1,3 +1,18 @@\n+2010-12-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/class-extension-1.m: New.\n+\t* objc.dg/class-extension-2.m: New.\n+\t* objc.dg/class-extension-3.m: New.\n+\t* objc.dg/property/at-property-26.m: New.\n+\t* objc.dg/property/at-property-27.m: New.\n+\t* objc.dg/property/at-property-28.m: New.\n+\t* obj-c++.dg/class-extension-1.mm: New.\n+\t* obj-c++.dg/class-extension-2.mm: New.\n+\t* obj-c++.dg/class-extension-3.mm: New.\n+\t* obj-c++.dg/property/at-property-26.mm: New.\n+\t* obj-c++.dg/property/at-property-27.mm: New.\n+\t* obj-c++.dg/property/at-property-28.mm: New.\t\n+\t\n 2010-12-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/46057"}, {"sha": "eab59c4137c3a8eaf5b1ee503dae66a475db1d19", "filename": "gcc/testsuite/obj-c++.dg/class-extension-1.mm", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-1.mm?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,30 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* This test tests the basic of class extensions.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+- (int) test;\n+@end\n+\n+@interface MyObject ()\n+- (int) test2;\n+- (int) test3;\n+@end\n+\n+@implementation MyObject\n+- (int) test\n+{\n+  return 20;\n+}\n+- (int) test2\n+{\n+  return 20;\n+}\n+@end /* { dg-warning \"incomplete implementation of class .MyObject.\" } */\n+     /* { dg-warning \"method definition for .-test3. not found\" \"\" { target *-*-* } 29 } */"}, {"sha": "79b126f529a77b0aeb148d712de04d440d3ccef4", "filename": "gcc/testsuite/obj-c++.dg/class-extension-2.mm", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-2.mm?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,56 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* This test tests class extensions and protocols.  */\n+\n+#include <objc/objc.h>\n+\n+/* First, a simple test where a plain class has a protocol attached to\n+   it in a class extension.  */\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@protocol MyProtocol\n+- (void) test;\n+@end\n+\n+@interface MyObject () <MyProtocol>\n+@end\n+\n+@implementation MyObject\n+@end /* { dg-warning \"incomplete implementation of class .MyObject.\" } */\n+     /* { dg-warning \"method definition for .-test. not found\" \"\" { target *-*-* } 24 } */\n+     /* { dg-warning \"class .MyObject. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 24 } */\n+\n+\n+\n+/* Second, a more interesting test where protocols are added from the\n+   main class and from two different class extensions.  */\n+@interface MyObject2 : MyObject <MyProtocol>\n+@end\n+\n+@protocol MyProtocol2\n+- (void) test2;\n+@end\n+\n+@protocol MyProtocol3\n+- (void) test3;\n+@end\n+\n+@interface MyObject2 () <MyProtocol2>\n+@end\n+\n+@interface MyObject2 () <MyProtocol3>\n+@end\n+\n+@implementation MyObject2\n+@end /* { dg-warning \"incomplete implementation of class .MyObject2.\" } */\n+     /* { dg-warning \"method definition for .-test. not found\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"class .MyObject2. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"method definition for .-test2. not found\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"class .MyObject2. does not fully implement the .MyProtocol2. protocol\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"method definition for .-test3. not found\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"class .MyObject2. does not fully implement the .MyProtocol3. protocol\" \"\" { target *-*-* } 50 } */"}, {"sha": "8feb5c9b6f20142ce1e47bdf89582986ecc08620", "filename": "gcc/testsuite/obj-c++.dg/class-extension-3.mm", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-3.mm?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,26 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* This test tests warnings on class extensions.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+  int count;\n+}\n+- (int) test;\n+@property int count; /* { dg-warning \"originally specified here\" } */\n+@end\n+\n+@interface MyObject ()\n+- (void) test; /* { dg-error \"duplicate declaration of method .-test.\" } */\n+@end\n+\n+@interface MyObject ()\n+@end\n+\n+@interface MyObject ()\n+@property int count; /* { dg-error \"redeclaration of property .count.\" } */\n+@end"}, {"sha": "c45757e239a08cb8af93a28b795701e5d1d2d58c", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-26.mm", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-26.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-26.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-26.mm?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,85 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @properties in class extensions.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count4\n+/* Use a different getters/setters, so that the only way to compile\n+   object.countX is to find the actual @property.  */\n+@property (getter=number4, setter=setNumber4:) int count4;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+{\n+  int count1;\n+  int count2;\n+  int count3;\n+  int count4;\n+}\n+@property (getter=number1, setter=setNumber1:) int count1;\n+@end\n+\n+@interface MySubClass ()\n+@property (getter=number2, setter=setNumber2:) int count2;\n+@end\n+\n+@interface MySubClass ()  <count4>\n+@property (getter=number3, setter=setNumber3:) int count3;\n+@end\n+\n+@implementation MySubClass\n+@synthesize count1;\n+@synthesize count2;\n+- (int) number3\n+{\n+  return count3;\n+}\n+- (void) setNumber3: (int)value\n+{\n+  count3 = value;\n+}\n+@synthesize count4;\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count1 = 20;\n+  if (object.count1 != 20)\n+    abort ();\n+\n+  object.count2 = 11;\n+  if (object.count2 != 11)\n+    abort ();\n+\n+  object.count3 = 19;\n+  if (object.count3 != 19)\n+    abort ();\n+\n+  object.count4 = 74;\n+  if (object.count4 != 74)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "727834684fe69c7f349e99c4b3f526823e905d50", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-27.mm", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-27.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-27.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-27.mm?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,66 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test overriding a readonly @property with a readwrite one in a class extension.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count2\n+/* Use a different getters/setters, so that the only way to compile\n+   object.countX is to find the actual @property.  */\n+@property (readonly, getter=number2) int count2;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+{\n+  int count1;\n+  int count2;\n+}\n+@property (readonly, getter=number1) int count1;\n+@end\n+\n+@interface MySubClass ()\n+@property (readwrite, getter=number1, setter=setNumber1:) int count1;\n+@end\n+\n+@interface MySubClass ()  <count2>\n+@property (readwrite, getter=number2, setter=setNumber2:) int count2;\n+@end\n+\n+@implementation MySubClass\n+@synthesize count1;\n+@synthesize count2;\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count1 = 20;\n+  if (object.count1 != 20)\n+    abort ();\n+\n+  object.count2 = 11;\n+  if (object.count2 != 11)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "23b357c8505c12df483cae7c4eaa1ebc6feccdb8", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-28.mm", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-28.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-28.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-28.mm?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,29 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test errors when extending a property in a class extension.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property (readonly, retain)    id property1; /* { dg-warning \"originally specified here\" } */\n+@property (readonly)           int property2; /* { dg-warning \"originally specified here\" } */\n+@property (readonly, getter=y) int property3; /* { dg-warning \"originally specified here\" } */\n+@property (readonly)           int property4; /* Ok */\n+@property (readonly)           int property5; /* { dg-warning \"originally specified here\" } */\n+@end\n+\n+@interface MyRootClass ()\n+@property (readwrite, copy)       id property1; /* { dg-warning \"assign semantics attributes of property .property1. conflict with previous declaration\" } */\n+@property (readwrite, nonatomic) int property2; /* { dg-warning \".nonatomic. attribute of property .property2. conflicts with previous declaration\" } */\n+@property (readwrite, getter=x)  int property3; /* { dg-warning \".getter. attribute of property .property3. conflicts with previous declaration\" } */\n+@property (readwrite)            int property4; /* Ok */\n+@property (readwrite)          float property5; /* { dg-warning \"type of property .property5. conflicts with previous declaration\" } */\n+@end\n+\n+\n+"}, {"sha": "eab59c4137c3a8eaf5b1ee503dae66a475db1d19", "filename": "gcc/testsuite/objc.dg/class-extension-1.m", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-1.m?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,30 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* This test tests the basic of class extensions.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+- (int) test;\n+@end\n+\n+@interface MyObject ()\n+- (int) test2;\n+- (int) test3;\n+@end\n+\n+@implementation MyObject\n+- (int) test\n+{\n+  return 20;\n+}\n+- (int) test2\n+{\n+  return 20;\n+}\n+@end /* { dg-warning \"incomplete implementation of class .MyObject.\" } */\n+     /* { dg-warning \"method definition for .-test3. not found\" \"\" { target *-*-* } 29 } */"}, {"sha": "79b126f529a77b0aeb148d712de04d440d3ccef4", "filename": "gcc/testsuite/objc.dg/class-extension-2.m", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-2.m?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,56 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* This test tests class extensions and protocols.  */\n+\n+#include <objc/objc.h>\n+\n+/* First, a simple test where a plain class has a protocol attached to\n+   it in a class extension.  */\n+@interface MyObject\n+{\n+  Class isa;\n+}\n+@end\n+\n+@protocol MyProtocol\n+- (void) test;\n+@end\n+\n+@interface MyObject () <MyProtocol>\n+@end\n+\n+@implementation MyObject\n+@end /* { dg-warning \"incomplete implementation of class .MyObject.\" } */\n+     /* { dg-warning \"method definition for .-test. not found\" \"\" { target *-*-* } 24 } */\n+     /* { dg-warning \"class .MyObject. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 24 } */\n+\n+\n+\n+/* Second, a more interesting test where protocols are added from the\n+   main class and from two different class extensions.  */\n+@interface MyObject2 : MyObject <MyProtocol>\n+@end\n+\n+@protocol MyProtocol2\n+- (void) test2;\n+@end\n+\n+@protocol MyProtocol3\n+- (void) test3;\n+@end\n+\n+@interface MyObject2 () <MyProtocol2>\n+@end\n+\n+@interface MyObject2 () <MyProtocol3>\n+@end\n+\n+@implementation MyObject2\n+@end /* { dg-warning \"incomplete implementation of class .MyObject2.\" } */\n+     /* { dg-warning \"method definition for .-test. not found\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"class .MyObject2. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"method definition for .-test2. not found\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"class .MyObject2. does not fully implement the .MyProtocol2. protocol\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"method definition for .-test3. not found\" \"\" { target *-*-* } 50 } */\n+     /* { dg-warning \"class .MyObject2. does not fully implement the .MyProtocol3. protocol\" \"\" { target *-*-* } 50 } */"}, {"sha": "9564bf022cb583b25e940df211f11549990b758f", "filename": "gcc/testsuite/objc.dg/class-extension-3.m", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-3.m?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,26 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* This test tests warnings on class extensions.  */\n+\n+#include <objc/objc.h>\n+\n+@interface MyObject\n+{\n+  Class isa;\n+  int count;\n+}\n+- (int) test;\n+@property int count; /* { dg-message \"originally specified here\" } */\n+@end\n+\n+@interface MyObject ()\n+- (void) test; /* { dg-error \"duplicate declaration of method .-test.\" } */\n+@end\n+\n+@interface MyObject ()\n+@end\n+\n+@interface MyObject ()\n+@property int count; /* { dg-error \"redeclaration of property .count.\" } */\n+@end"}, {"sha": "c45757e239a08cb8af93a28b795701e5d1d2d58c", "filename": "gcc/testsuite/objc.dg/property/at-property-26.m", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-26.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-26.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-26.m?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,85 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @properties in class extensions.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count4\n+/* Use a different getters/setters, so that the only way to compile\n+   object.countX is to find the actual @property.  */\n+@property (getter=number4, setter=setNumber4:) int count4;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+{\n+  int count1;\n+  int count2;\n+  int count3;\n+  int count4;\n+}\n+@property (getter=number1, setter=setNumber1:) int count1;\n+@end\n+\n+@interface MySubClass ()\n+@property (getter=number2, setter=setNumber2:) int count2;\n+@end\n+\n+@interface MySubClass ()  <count4>\n+@property (getter=number3, setter=setNumber3:) int count3;\n+@end\n+\n+@implementation MySubClass\n+@synthesize count1;\n+@synthesize count2;\n+- (int) number3\n+{\n+  return count3;\n+}\n+- (void) setNumber3: (int)value\n+{\n+  count3 = value;\n+}\n+@synthesize count4;\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count1 = 20;\n+  if (object.count1 != 20)\n+    abort ();\n+\n+  object.count2 = 11;\n+  if (object.count2 != 11)\n+    abort ();\n+\n+  object.count3 = 19;\n+  if (object.count3 != 19)\n+    abort ();\n+\n+  object.count4 = 74;\n+  if (object.count4 != 74)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "727834684fe69c7f349e99c4b3f526823e905d50", "filename": "gcc/testsuite/objc.dg/property/at-property-27.m", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-27.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-27.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-27.m?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,66 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test overriding a readonly @property with a readwrite one in a class extension.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count2\n+/* Use a different getters/setters, so that the only way to compile\n+   object.countX is to find the actual @property.  */\n+@property (readonly, getter=number2) int count2;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+{\n+  int count1;\n+  int count2;\n+}\n+@property (readonly, getter=number1) int count1;\n+@end\n+\n+@interface MySubClass ()\n+@property (readwrite, getter=number1, setter=setNumber1:) int count1;\n+@end\n+\n+@interface MySubClass ()  <count2>\n+@property (readwrite, getter=number2, setter=setNumber2:) int count2;\n+@end\n+\n+@implementation MySubClass\n+@synthesize count1;\n+@synthesize count2;\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count1 = 20;\n+  if (object.count1 != 20)\n+    abort ();\n+\n+  object.count2 = 11;\n+  if (object.count2 != 11)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "de5122443c6f0507ddaa3c52ebce82c483d6c27e", "filename": "gcc/testsuite/objc.dg/property/at-property-28.m", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-28.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3e9f826773a7aa4cfc135b4cc9e2de222bc137/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-28.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-28.m?ref=ec3e9f826773a7aa4cfc135b4cc9e2de222bc137", "patch": "@@ -0,0 +1,29 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test errors when extending a property in a class extension.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property (readonly, retain)    id property1; /* { dg-message \"originally specified here\" } */\n+@property (readonly)           int property2; /* { dg-message \"originally specified here\" } */\n+@property (readonly, getter=y) int property3; /* { dg-message \"originally specified here\" } */\n+@property (readonly)           int property4; /* Ok */\n+@property (readonly)           int property5; /* { dg-message \"originally specified here\" } */\n+@end\n+\n+@interface MyRootClass ()\n+@property (readwrite, copy)       id property1; /* { dg-warning \"assign semantics attributes of property .property1. conflict with previous declaration\" } */\n+@property (readwrite, nonatomic) int property2; /* { dg-warning \".nonatomic. attribute of property .property2. conflicts with previous declaration\" } */\n+@property (readwrite, getter=x)  int property3; /* { dg-warning \".getter. attribute of property .property3. conflicts with previous declaration\" } */\n+@property (readwrite)            int property4; /* Ok */\n+@property (readwrite)          float property5; /* { dg-warning \"type of property .property5. conflicts with previous declaration\" } */\n+@end\n+\n+\n+"}]}