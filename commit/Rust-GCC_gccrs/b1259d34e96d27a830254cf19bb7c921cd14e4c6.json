{"sha": "b1259d34e96d27a830254cf19bb7c921cd14e4c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyNTlkMzRlOTZkMjdhODMwMjU0Y2YxOWJiN2M5MjFjZDE0ZTRjNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-06-04T11:55:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-06-04T11:55:29Z"}, "message": "tree-ssa-alias.c (stmt_may_clobber_ref_p): Improve handling of accesses with non-invariant address.\n\n2014-06-04  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-alias.c (stmt_may_clobber_ref_p): Improve handling\n\tof accesses with non-invariant address.\n\n\t* gcc.dg/tree-ssa/ssa-dse-16.c: New testcase.\n\nFrom-SVN: r211223", "tree": {"sha": "8a7dd276505bc9ee18b88032a2740dcfc7620216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a7dd276505bc9ee18b88032a2740dcfc7620216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1259d34e96d27a830254cf19bb7c921cd14e4c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1259d34e96d27a830254cf19bb7c921cd14e4c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1259d34e96d27a830254cf19bb7c921cd14e4c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1259d34e96d27a830254cf19bb7c921cd14e4c6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8be2dc8cb24d93b16176d3bb049482c10cf6ed54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8be2dc8cb24d93b16176d3bb049482c10cf6ed54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8be2dc8cb24d93b16176d3bb049482c10cf6ed54"}], "stats": {"total": 83, "additions": 76, "deletions": 7}, "files": [{"sha": "d82234cf2b1ac175b9775363add659c443b6a79c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1259d34e96d27a830254cf19bb7c921cd14e4c6", "patch": "@@ -1,3 +1,8 @@\n+2014-06-04  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.c (stmt_may_clobber_ref_p): Improve handling\n+\tof accesses with non-invariant address.\n+\n 2014-06-04  Martin Liska  <mliska@suse.cz>\n \n \t* cgraph.h (cgraph_make_wrapper): New function introduced."}, {"sha": "b3e39d37df63226298d514ec9750d30ff10f9801", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1259d34e96d27a830254cf19bb7c921cd14e4c6", "patch": "@@ -1,3 +1,7 @@\n+2014-06-04  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-dse-16.c: New testcase.\n+\n 2014-06-04  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR c/58942"}, {"sha": "1cc512c020f083113fc54863664e4b68a086cdf6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-16.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-16.c?ref=b1259d34e96d27a830254cf19bb7c921cd14e4c6", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse1-details\" } */\n+\n+struct X { struct A { int a[2]; } b[10]; };\n+void foo (struct X *x, int i)\n+{\n+  struct A a;\n+ /* Confuse SRA here with using a variable index, otherwise it will mess\n+    with the IL too much.  */\n+  a.a[i] = 3;\n+  a.a[1] = 0;\n+  /* The following store is dead.  */\n+  x->b[i].a[0] = 1;\n+  x->b[i] = a;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Deleted dead store\" \"dse1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dse1\" } } */"}, {"sha": "f18cb486f20ffc75466ee2fa04bf8d5f0f008484", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1259d34e96d27a830254cf19bb7c921cd14e4c6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b1259d34e96d27a830254cf19bb7c921cd14e4c6", "patch": "@@ -2174,11 +2174,7 @@ stmt_may_clobber_ref_p (gimple stmt, tree ref)\n static bool\n stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n {\n-  /* For a must-alias check we need to be able to constrain\n-     the access properly.\n-     FIXME: except for BUILTIN_FREE.  */\n-  if (!ao_ref_base (ref)\n-      || ref->max_size == -1)\n+  if (!ao_ref_base (ref))\n     return false;\n \n   if (gimple_has_lhs (stmt)\n@@ -2191,9 +2187,51 @@ stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n \t might throw as well.  */\n       && !stmt_can_throw_internal (stmt))\n     {\n-      tree base, lhs = gimple_get_lhs (stmt);\n+      tree lhs = gimple_get_lhs (stmt);\n+      /* If LHS is literally a base of the access we are done.  */\n+      if (ref->ref)\n+\t{\n+\t  tree base = ref->ref;\n+\t  if (handled_component_p (base))\n+\t    {\n+\t      tree saved_lhs0 = NULL_TREE;\n+\t      if (handled_component_p (lhs))\n+\t\t{\n+\t\t  saved_lhs0 = TREE_OPERAND (lhs, 0);\n+\t\t  TREE_OPERAND (lhs, 0) = integer_zero_node;\n+\t\t}\n+\t      do\n+\t\t{\n+\t\t  /* Just compare the outermost handled component, if\n+\t\t     they are equal we have found a possible common\n+\t\t     base.  */\n+\t\t  tree saved_base0 = TREE_OPERAND (base, 0);\n+\t\t  TREE_OPERAND (base, 0) = integer_zero_node;\n+\t\t  bool res = operand_equal_p (lhs, base, 0);\n+\t\t  TREE_OPERAND (base, 0) = saved_base0;\n+\t\t  if (res)\n+\t\t    break;\n+\t\t  /* Otherwise drop handled components of the access.  */\n+\t\t  base = saved_base0;\n+\t\t}\n+\t      while (handled_component_p (base));\n+\t      if (saved_lhs0)\n+\t\tTREE_OPERAND (lhs, 0) = saved_lhs0;\n+\t    }\n+\t  /* Finally check if lhs is equal or equal to the base candidate\n+\t     of the access.  */\n+\t  if (operand_equal_p (lhs, base, 0))\n+\t    return true;\n+\t}\n+\n+      /* Now look for non-literal equal bases with the restriction of\n+         handling constant offset and size.  */\n+      /* For a must-alias check we need to be able to constrain\n+\t the access properly.  */\n+      if (ref->max_size == -1)\n+\treturn false;\n       HOST_WIDE_INT size, offset, max_size, ref_offset = ref->offset;\n-      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+      tree base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n       /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n \t so base == ref->base does not always hold.  */\n       if (base != ref->base)\n@@ -2261,6 +2299,10 @@ stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n \t  case BUILT_IN_MEMMOVE_CHK:\n \t  case BUILT_IN_MEMSET_CHK:\n \t    {\n+\t      /* For a must-alias check we need to be able to constrain\n+\t\t the access properly.  */\n+\t      if (ref->max_size == -1)\n+\t\treturn false;\n \t      tree dest = gimple_call_arg (stmt, 0);\n \t      tree len = gimple_call_arg (stmt, 2);\n \t      if (!tree_fits_shwi_p (len))"}]}