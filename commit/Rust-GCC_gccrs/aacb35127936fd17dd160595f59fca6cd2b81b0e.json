{"sha": "aacb35127936fd17dd160595f59fca6cd2b81b0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjYjM1MTI3OTM2ZmQxN2RkMTYwNTk1ZjU5ZmNhNmNkMmI4MWIwZQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2005-06-22T14:51:07Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2005-06-22T14:51:07Z"}, "message": "abi: New directory.\n\n        * gcc.target/x86-64/abi: New directory.\n        * gcc.target/x86-64/abi/abi-x86_64.exp: New testsuite.\n        * gcc.target/x86-64/abi/README.gcc: New file.\n        * gcc.target/x86-64/abi/{args.h,defines.h,macros.h}: New headers.\n        * gcc.target/x86-64/abi/asm-support.s: New file.\n        * gcc.target/x86_64/abi/test_3_element_struct_and_unions.c: New test.\n        * gcc.target/x86_64/abi/test_basic_alignment.c: New test.\n        * gcc.target/x86_64/abi/test_basic_array_size_and_align.c: New test.\n        * gcc.target/x86_64/abi/test_basic_returning.c: New test.\n        * gcc.target/x86_64/abi/test_basic_sizes.c: New test.\n        * gcc.target/x86_64/abi/test_basic_struct_size_and_align.c: New test.\n        * gcc.target/x86_64/abi/test_basic_union_size_and_align.c: New test.\n        * gcc.target/x86_64/abi/test_bitfields.c: New test.\n        * gcc.target/x86_64/abi/test_complex_returning.c: New test.\n        * gcc.target/x86_64/abi/test_passing_floats.c: New test.\n        * gcc.target/x86_64/abi/test_passing_integers.c: New test.\n        * gcc.target/x86_64/abi/test_passing_structs_and_unions.c: New test.\n        * gcc.target/x86_64/abi/test_passing_structs.c: New test.\n        * gcc.target/x86_64/abi/test_passing_unions.c: New test.\n        * gcc.target/x86_64/abi/test_struct_returning.c: New test.\n        * gcc.target/x86_64/abi/test_varargs.c: New test.\n\nFrom-SVN: r101249", "tree": {"sha": "adce24ee5fccdc9357459afe4ef2787b174b7cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adce24ee5fccdc9357459afe4ef2787b174b7cc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aacb35127936fd17dd160595f59fca6cd2b81b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacb35127936fd17dd160595f59fca6cd2b81b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aacb35127936fd17dd160595f59fca6cd2b81b0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacb35127936fd17dd160595f59fca6cd2b81b0e/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d26b2ff459632459d4b620244431e059528718b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d26b2ff459632459d4b620244431e059528718b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d26b2ff459632459d4b620244431e059528718b"}], "stats": {"total": 2911, "additions": 2911, "deletions": 0}, "files": [{"sha": "606d4049d3f382b6c7eaeb4a86720b691a9a49dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -1,3 +1,27 @@\n+2005-06-22  Michael Matz  <matz@suse.de>\n+\n+\t* gcc.target/x86-64/abi: New directory.\n+\t* gcc.target/x86-64/abi/abi-x86_64.exp: New testsuite.\n+\t* gcc.target/x86-64/abi/README.gcc: New file.\n+\t* gcc.target/x86-64/abi/{args.h,defines.h,macros.h}: New headers.\n+\t* gcc.target/x86-64/abi/asm-support.s: New file.\n+\t* gcc.target/x86_64/abi/test_3_element_struct_and_unions.c: New test.\n+\t* gcc.target/x86_64/abi/test_basic_alignment.c: New test.\n+\t* gcc.target/x86_64/abi/test_basic_array_size_and_align.c: New test.\n+\t* gcc.target/x86_64/abi/test_basic_returning.c: New test.\n+\t* gcc.target/x86_64/abi/test_basic_sizes.c: New test.\n+\t* gcc.target/x86_64/abi/test_basic_struct_size_and_align.c: New test.\n+\t* gcc.target/x86_64/abi/test_basic_union_size_and_align.c: New test.\n+\t* gcc.target/x86_64/abi/test_bitfields.c: New test.\n+\t* gcc.target/x86_64/abi/test_complex_returning.c: New test.\n+\t* gcc.target/x86_64/abi/test_passing_floats.c: New test.\n+\t* gcc.target/x86_64/abi/test_passing_integers.c: New test.\n+\t* gcc.target/x86_64/abi/test_passing_structs_and_unions.c: New test.\n+\t* gcc.target/x86_64/abi/test_passing_structs.c: New test.\n+\t* gcc.target/x86_64/abi/test_passing_unions.c: New test.\n+\t* gcc.target/x86_64/abi/test_struct_returning.c: New test.\n+\t* gcc.target/x86_64/abi/test_varargs.c: New test.\n+\n 2005-06-21  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* g++.dg/abi/mangle24.C, g++.dg/abi/mangle25.C: Pass -mmmx for"}, {"sha": "fca0dfe76440a0c9dce84c90bf7758c095851491", "filename": "gcc/testsuite/gcc.target/x86_64/abi/README.gcc", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2FREADME.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2FREADME.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2FREADME.gcc?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,18 @@\n+This contains a testsuite for the AMD64 psABI.\n+The ABI document is at http://www.x86-64.org/documentation/abi.pdf .\n+The content of this directory in the GCC tree is just a (partial) copy of the\n+ABI testsuite at cvs.x86-64.org.\n+\n+See http://www.x86-64.org/cvsaccess for accessing the anonymous CVS server.\n+The module 'abitest' contains the master copy of this directory.\n+\n+The whole testsuite is licensed under GPL v2.\n+\n+Be aware that some of the test_*.c files here are generated, with the\n+generators only being in the master copy of the testsuite.\n+\n+To change anything, please contact discuss@x86-64.org or the current\n+maintainer of the testuite directly.\n+\n+The current maintainer is:\n+  matz@suse.de"}, {"sha": "e7e6313c28ed7627abf73d27133d8b9041f8bad7", "filename": "gcc/testsuite/gcc.target/x86_64/abi/abi-x86_64.exp", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fabi-x86_64.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fabi-x86_64.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fabi-x86_64.exp?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,37 @@\n+# Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# The x86-64 ABI testsuite needs one additional assembler file for most\n+# testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64] } then {\n+  return\n+}\n+\n+\n+set additional_flags \"-W -Wall\"\n+\n+foreach src [lsort [find $srcdir/$subdir test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+\tc-torture-execute [list $src \\\n+\t\t\t        $srcdir/$subdir/asm-support.s] \\\n+\t\t\t\t$additional_flags\n+    }\n+}"}, {"sha": "db54268c49fda219cdcd8176a38987a147831ef4", "filename": "gcc/testsuite/gcc.target/x86_64/abi/args.h", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fargs.h?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,144 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+#include <string.h>\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 rdi\n+#define I1 rsi\n+#define I2 rdx\n+#define I3 rcx\n+#define I4 r8\n+#define I5 r9\n+#define F0 xmm0\n+#define F1 xmm1\n+#define F2 xmm2\n+#define F3 xmm3\n+#define F4 xmm4\n+#define F5 xmm5\n+#define F6 xmm6\n+#define F7 xmm7\n+\n+typedef union {\n+  float _float[4];\n+  double _double[2];\n+  long _long[2];\n+  int _int[4];\n+  unsigned long _ulong[2];\n+} XMM_T;\n+\n+typedef union {\n+  float _float;\n+  double _double;\n+  ldouble _ldouble;\n+  ulong _ulong[2];\n+} X87_T;\n+extern void (*callthis)(void);\n+extern unsigned long rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp,r8,r9,r10,r11,r12,r13,r14,r15;\n+XMM_T xmm_regs[16];\n+X87_T x87_regs[8];\n+extern volatile unsigned long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%rax, %%rax\\n\\t\" \\\n+\t\t    \"xor %%rbx, %%rbx\\n\\t\" \\\n+\t\t    \"xor %%rcx, %%rcx\\n\\t\" \\\n+\t\t    \"xor %%rdx, %%rdx\\n\\t\" \\\n+\t\t    \"xor %%rsi, %%rsi\\n\\t\" \\\n+\t\t    \"xor %%rdi, %%rdi\\n\\t\" \\\n+\t\t    \"xor %%r8, %%r8\\n\\t\" \\\n+\t\t    \"xor %%r9, %%r9\\n\\t\" \\\n+\t\t    \"xor %%r10, %%r10\\n\\t\" \\\n+\t\t    \"xor %%r11, %%r11\\n\\t\" \\\n+\t\t    \"xor %%r12, %%r12\\n\\t\" \\\n+\t\t    \"xor %%r13, %%r13\\n\\t\" \\\n+\t\t    \"xor %%r14, %%r14\\n\\t\" \\\n+\t\t    \"xor %%r15, %%r15\\n\\t\" \\\n+\t\t    ::: \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \\\n+\t\t    \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long rax, rbx, rcx, rdx, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;\n+};\n+struct FloatRegisters\n+{\n+  double mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;\n+  ldouble st0, st1, st2, st3, st4, st5, st6, st7;\n+  XMM_T xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8, xmm9,\n+        xmm10, xmm11, xmm12, xmm13, xmm14, xmm15;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs;\n+extern struct FloatRegisters fregs;\n+extern unsigned int num_iregs, num_fregs;\n+\n+#define check_int_arguments do { \\\n+  assert (num_iregs <= 0 || iregs.I0 == I0); \\\n+  assert (num_iregs <= 1 || iregs.I1 == I1); \\\n+  assert (num_iregs <= 2 || iregs.I2 == I2); \\\n+  assert (num_iregs <= 3 || iregs.I3 == I3); \\\n+  assert (num_iregs <= 4 || iregs.I4 == I4); \\\n+  assert (num_iregs <= 5 || iregs.I5 == I5); \\\n+  } while (0)\n+\n+#define check_char_arguments check_int_arguments\n+#define check_short_arguments check_int_arguments\n+#define check_long_arguments check_int_arguments\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  rax = rbx = rcx = rdx = rdi = rsi = rbp = rsp \\\n+    = r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0; \\\n+  memset (&iregs, 0, sizeof (iregs)); \\\n+  memset (&fregs, 0, sizeof (fregs)); \\\n+  memset (xmm_regs, 0, sizeof (xmm_regs)); \\\n+  memset (x87_regs, 0, sizeof (x87_regs));\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+/* TODO: Do the checking.  */\n+#define check_f_arguments(T) { \\\n+  assert (num_fregs <= 0 || fregs.xmm0._ ## T [0] == xmm_regs[0]._ ## T [0]); \\\n+  assert (num_fregs <= 1 || fregs.xmm1._ ## T [0] == xmm_regs[1]._ ## T [0]); \\\n+  assert (num_fregs <= 2 || fregs.xmm2._ ## T [0] == xmm_regs[2]._ ## T [0]); \\\n+  assert (num_fregs <= 3 || fregs.xmm3._ ## T [0] == xmm_regs[3]._ ## T [0]); \\\n+  assert (num_fregs <= 4 || fregs.xmm4._ ## T [0] == xmm_regs[4]._ ## T [0]); \\\n+  assert (num_fregs <= 5 || fregs.xmm5._ ## T [0] == xmm_regs[5]._ ## T [0]); \\\n+  assert (num_fregs <= 6 || fregs.xmm6._ ## T [0] == xmm_regs[6]._ ## T [0]); \\\n+  assert (num_fregs <= 7 || fregs.xmm7._ ## T [0] == xmm_regs[7]._ ## T [0]); \\\n+  } while (0)\n+\n+#define check_float_arguments check_f_arguments(float)\n+#define check_double_arguments check_f_arguments(double)\n+\n+/* ldoubles are not passed in registers */\n+#define check_ldouble_arguments\n+\n+/* TODO: Do the clearing.  */\n+#define clear_float_hardware_registers\n+#define clear_x87_hardware_registers\n+\n+#define clear_float_registers \\\n+  clear_struct_registers \\\n+  clear_float_hardware_registers\n+\n+#define clear_x87_registers \\\n+  clear_struct_registers \\\n+  clear_x87_hardware_registers\n+\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "00a08c020fd60e1068d20376911630c10f1ec2c1", "filename": "gcc/testsuite/gcc.target/x86_64/abi/asm-support.s", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fasm-support.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fasm-support.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fasm-support.s?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,80 @@\n+\t.file\t\"snapshot.S\"\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+.LFB3:\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rbx, rbx(%rip)\n+\tmovq\t%rcx, rcx(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovq\t%rdi, rdi(%rip)\n+\tmovq\t%rsi, rsi(%rip)\n+\tmovq\t%rbp, rbp(%rip)\n+\tmovq\t%rsp, rsp(%rip)\n+\tmovq\t%r8, r8(%rip)\n+\tmovq\t%r9, r9(%rip)\n+\tmovq\t%r10, r10(%rip)\n+\tmovq\t%r11, r11(%rip)\n+\tmovq\t%r12, r12(%rip)\n+\tmovq\t%r13, r13(%rip)\n+\tmovq\t%r14, r14(%rip)\n+\tmovq\t%r15, r15(%rip)\n+\tmovdqu\t%xmm0, xmm_regs+0(%rip)\n+\tmovdqu\t%xmm1, xmm_regs+16(%rip)\n+\tmovdqu\t%xmm2, xmm_regs+16*2(%rip)\n+\tmovdqu\t%xmm3, xmm_regs+16*3(%rip)\n+\tmovdqu\t%xmm4, xmm_regs+16*4(%rip)\n+\tmovdqu\t%xmm5, xmm_regs+16*5(%rip)\n+\tmovdqu\t%xmm6, xmm_regs+16*6(%rip)\n+\tmovdqu\t%xmm7, xmm_regs+16*7(%rip)\n+\tmovdqu\t%xmm8, xmm_regs+16*8(%rip)\n+\tmovdqu\t%xmm9, xmm_regs+16*9(%rip)\n+\tmovdqu\t%xmm10, xmm_regs+16*10(%rip)\n+\tmovdqu\t%xmm11, xmm_regs+16*11(%rip)\n+\tmovdqu\t%xmm12, xmm_regs+16*12(%rip)\n+\tmovdqu\t%xmm13, xmm_regs+16*13(%rip)\n+\tmovdqu\t%xmm14, xmm_regs+16*14(%rip)\n+\tmovdqu\t%xmm15, xmm_regs+16*15(%rip)\n+\tjmp\t*callthis(%rip)\n+.LFE3:\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovq\t%rdi, rdi(%rip)\n+\tcall\t*callthis(%rip)\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovdqu\t%xmm0, xmm_regs+0(%rip)\n+\tmovdqu\t%xmm1, xmm_regs+16(%rip)\n+\tfstpt\tx87_regs(%rip)\n+\tfstpt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs(%rip)\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.comm\tcallthis,8,8\n+\t.comm\trax,8,8\n+\t.comm\trbx,8,8\n+\t.comm\trcx,8,8\n+\t.comm\trdx,8,8\n+\t.comm\trsi,8,8\n+\t.comm\trdi,8,8\n+\t.comm\trsp,8,8\n+\t.comm\trbp,8,8\n+\t.comm\tr8,8,8\n+\t.comm\tr9,8,8\n+\t.comm\tr10,8,8\n+\t.comm\tr11,8,8\n+\t.comm\tr12,8,8\n+\t.comm\tr13,8,8\n+\t.comm\tr14,8,8\n+\t.comm\tr15,8,8\n+\t.comm\txmm_regs,256,32\n+\t.comm\tx87_regs,128,32\n+\t.comm   volatile_var,8,8"}, {"sha": "34707a815e67a229e39a7258d1bdd8005ca40b82", "filename": "gcc/testsuite/gcc.target/x86_64/abi/defines.h", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fdefines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fdefines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fdefines.h?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,145 @@\n+#ifndef DEFINED_DEFINES_H\n+#define DEFINED_DEFINES_H\n+\n+typedef unsigned long ulong;\n+typedef long double ldouble;\n+\n+/* These defines determines what part of the test should be run.  When\n+   GCC implements these parts, the defines should be uncommented to\n+   enable testing.  */\n+\n+/* Scalar type __int128.  */\n+/* #define CHECK_INT128 */\n+\n+/* Scalar type long double.  */\n+#define CHECK_LONG_DOUBLE\n+\n+/* Scalar type __float128.  */\n+/* #define CHECK_FLOAT128 */\n+\n+/* Scalar types __m64 and __m128.  */\n+/* #define CHECK_M64_M128 */\n+\n+/* Returning of complex type.  */\n+#define CHECK_COMPLEX\n+\n+/* Structs with size >= 16.  */\n+#define CHECK_LARGER_STRUCTS\n+\n+/* Checks for passing floats and doubles.  */\n+#define CHECK_FLOAT_DOUBLE_PASSING\n+\n+/* Union passing with not-extremely-simple unions.  */\n+#define CHECK_LARGER_UNION_PASSING\n+\n+/* Variable args.  */\n+#define CHECK_VARARGS\n+\n+/* Check argument passing and returning for scalar types with sizeof = 16.  */\n+/* TODO: Implement these tests. Don't activate them for now.  */\n+#define CHECK_LARGE_SCALAR_PASSING\n+\n+/* Defines for sizing and alignment.  */\n+\n+#define TYPE_SIZE_CHAR         1\n+#define TYPE_SIZE_SHORT        2\n+#define TYPE_SIZE_INT          4\n+#define TYPE_SIZE_LONG         8\n+#define TYPE_SIZE_LONG_LONG    8\n+#define TYPE_SIZE_INT128       16\n+#define TYPE_SIZE_FLOAT        4\n+#define TYPE_SIZE_DOUBLE       8\n+#define TYPE_SIZE_LONG_DOUBLE  16\n+#define TYPE_SIZE_FLOAT128     16\n+#define TYPE_SIZE_M64          8\n+#define TYPE_SIZE_M128         16\n+#define TYPE_SIZE_ENUM         4\n+#define TYPE_SIZE_POINTER      8\n+\n+#define TYPE_ALIGN_CHAR        1\n+#define TYPE_ALIGN_SHORT       2\n+#define TYPE_ALIGN_INT         4\n+#define TYPE_ALIGN_LONG        8\n+#define TYPE_ALIGN_LONG_LONG   8\n+#define TYPE_ALIGN_INT128      16\n+#define TYPE_ALIGN_FLOAT       4\n+#define TYPE_ALIGN_DOUBLE      8\n+#define TYPE_ALIGN_LONG_DOUBLE 16\n+#define TYPE_ALIGN_FLOAT128    16\n+#define TYPE_ALIGN_M64         8\n+#define TYPE_ALIGN_M128        16\n+#define TYPE_ALIGN_ENUM        4\n+#define TYPE_ALIGN_POINTER     8\n+\n+/* These defines control the building of the list of types to check. There\n+   is a string identifying the type (with a comma after), a size of the type\n+   (also with a comma and an integer for adding to the total amount of types)\n+   and an alignment of the type (which is currently not really needed since\n+   the abi specifies that alignof == sizeof for all scalar types).  */\n+#ifdef CHECK_INT128\n+#define CI128_STR \"__int128\",\n+#define CI128_SIZ TYPE_SIZE_INT128,\n+#define CI128_ALI TYPE_ALIGN_INT128,\n+#define CI128_RET \"???\",\n+#else\n+#define CI128_STR\n+#define CI128_SIZ\n+#define CI128_ALI\n+#define CI128_RET\n+#endif\n+#ifdef CHECK_LONG_DOUBLE\n+#define CLD_STR \"long double\",\n+#define CLD_SIZ TYPE_SIZE_LONG_DOUBLE,\n+#define CLD_ALI TYPE_ALIGN_LONG_DOUBLE,\n+#define CLD_RET \"x87_regs[0]._ldouble\",\n+#else\n+#define CLD_STR\n+#define CLD_SIZ\n+#define CLD_ALI\n+#define CLD_RET\n+#endif\n+#ifdef CHECK_FLOAT128\n+#define CF128_STR \"__float128\",\n+#define CF128_SIZ TYPE_SIZE_FLOAT128,\n+#define CF128_ALI TYPE_ALIGN_FLOAT128, \n+#define CF128_RET \"???\",\n+#else\n+#define CF128_STR\n+#define CF128_SIZ\n+#define CF128_ALI\n+#define CF128_RET\n+#endif\n+#ifdef CHECK_M64_M128\n+#define CMM_STR \"__m64\", \"__m128\",\n+#define CMM_SIZ TYPE_SIZE_M64, TYPE_SIZE_M128,\n+#define CMM_ALI TYPE_ALIGN_M64, TYPE_ALIGN_M128,\n+#define CMM_RET \"???\", \"???\",\n+#else\n+#define CMM_STR\n+#define CMM_SIZ\n+#define CMM_ALI\n+#define CMM_RET\n+#endif\n+\n+/* Used in size and alignment tests.  */\n+enum dummytype { enumtype };\n+\n+extern void abort (void);\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+#ifdef __GNUC__\n+#define PACKED __attribute__((__packed__))\n+#else\n+#warning Some tests will fail due to missing __packed__ support\n+#define PACKED\n+#endif\n+\n+#endif /* DEFINED_DEFINES_H */"}, {"sha": "98fbc660f277504edecccd7425b1cca41a19932f", "filename": "gcc/testsuite/gcc.target/x86_64/abi/macros.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Fmacros.h?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,53 @@\n+#ifndef MACROS_H\n+\n+#define check_size(_t, _size) assert(sizeof(_t) == (_size))\n+\n+#define check_align(_t, _align) assert(__alignof__(_t) == (_align))\n+\n+#define check_align_lv(_t, _align) assert(__alignof__(_t) == (_align) \\\n+\t\t\t\t\t  && (((unsigned long)&(_t)) & ((_align) - 1) ) == 0)\n+\n+#define check_basic_struct_size_and_align(_type, _size, _align) { \\\n+  struct _str { _type dummy; } _t; \\\n+  check_size(_t, _size); \\\n+  check_align_lv(_t, _align); \\\n+}\n+\n+#define check_array_size_and_align(_type, _size, _align) { \\\n+  _type _a[1]; _type _b[2]; _type _c[16]; \\\n+  struct _str { _type _a[1]; } _s; \\\n+  check_align_lv(_a[0], _align); \\\n+  check_size(_a, _size); \\\n+  check_size(_b, (_size*2)); \\\n+  check_size(_c, (_size*16)); \\\n+  check_size(_s, _size); \\\n+  check_align_lv(_s._a[0], _align); \\\n+}\n+\n+#define check_basic_union_size_and_align(_type, _size, _align) { \\\n+  union _union { _type dummy; } _u; \\\n+  check_size(_u, _size); \\\n+  check_align_lv(_u, _align); \\\n+}\n+\n+#define run_signed_tests2(_function, _arg1, _arg2) \\\n+  _function(_arg1, _arg2); \\\n+  _function(signed _arg1, _arg2); \\\n+  _function(unsigned _arg1, _arg2);\n+\n+#define run_signed_tests3(_function, _arg1, _arg2, _arg3) \\\n+  _function(_arg1, _arg2, _arg3); \\\n+  _function(signed _arg1, _arg2, _arg3); \\\n+  _function(unsigned _arg1, _arg2, _arg3);\n+\n+/* Check size of a struct and a union of three types.  */\n+\n+#define check_struct_and_union3(type1, type2, type3, struct_size, align_size) \\\n+{ \\\n+  struct _str { type1 t1; type2 t2; type3 t3; } _t; \\\n+  union _uni { type1 t1; type2 t2; type3 t3; } _u; \\\n+  check_size(_t, struct_size); \\\n+  check_size(_u, align_size); \\\n+}\n+\n+#endif // MACROS_H"}, {"sha": "5227c60879214c89fbc1864a5e958ce427c2c998", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_3_element_struct_and_unions.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_3_element_struct_and_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_3_element_struct_and_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_3_element_struct_and_unions.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,523 @@\n+/* This is an autogenerated file. Do not edit.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+/* Check structs and unions of all permutations of 3 basic types.  */\n+int\n+main (void)\n+{\n+  check_struct_and_union3(char, char, char, 3, 1);\n+  check_struct_and_union3(char, char, short, 4, 2);\n+  check_struct_and_union3(char, char, int, 8, 4);\n+  check_struct_and_union3(char, char, long, 16, 8);\n+  check_struct_and_union3(char, char, long long, 16, 8);\n+  check_struct_and_union3(char, char, float, 8, 4);\n+  check_struct_and_union3(char, char, double, 16, 8);\n+  check_struct_and_union3(char, char, long double, 32, 16);\n+  check_struct_and_union3(char, short, char, 6, 2);\n+  check_struct_and_union3(char, short, short, 6, 2);\n+  check_struct_and_union3(char, short, int, 8, 4);\n+  check_struct_and_union3(char, short, long, 16, 8);\n+  check_struct_and_union3(char, short, long long, 16, 8);\n+  check_struct_and_union3(char, short, float, 8, 4);\n+  check_struct_and_union3(char, short, double, 16, 8);\n+  check_struct_and_union3(char, short, long double, 32, 16);\n+  check_struct_and_union3(char, int, char, 12, 4);\n+  check_struct_and_union3(char, int, short, 12, 4);\n+  check_struct_and_union3(char, int, int, 12, 4);\n+  check_struct_and_union3(char, int, long, 16, 8);\n+  check_struct_and_union3(char, int, long long, 16, 8);\n+  check_struct_and_union3(char, int, float, 12, 4);\n+  check_struct_and_union3(char, int, double, 16, 8);\n+  check_struct_and_union3(char, int, long double, 32, 16);\n+  check_struct_and_union3(char, long, char, 24, 8);\n+  check_struct_and_union3(char, long, short, 24, 8);\n+  check_struct_and_union3(char, long, int, 24, 8);\n+  check_struct_and_union3(char, long, long, 24, 8);\n+  check_struct_and_union3(char, long, long long, 24, 8);\n+  check_struct_and_union3(char, long, float, 24, 8);\n+  check_struct_and_union3(char, long, double, 24, 8);\n+  check_struct_and_union3(char, long, long double, 32, 16);\n+  check_struct_and_union3(char, long long, char, 24, 8);\n+  check_struct_and_union3(char, long long, short, 24, 8);\n+  check_struct_and_union3(char, long long, int, 24, 8);\n+  check_struct_and_union3(char, long long, long, 24, 8);\n+  check_struct_and_union3(char, long long, long long, 24, 8);\n+  check_struct_and_union3(char, long long, float, 24, 8);\n+  check_struct_and_union3(char, long long, double, 24, 8);\n+  check_struct_and_union3(char, long long, long double, 32, 16);\n+  check_struct_and_union3(char, float, char, 12, 4);\n+  check_struct_and_union3(char, float, short, 12, 4);\n+  check_struct_and_union3(char, float, int, 12, 4);\n+  check_struct_and_union3(char, float, long, 16, 8);\n+  check_struct_and_union3(char, float, long long, 16, 8);\n+  check_struct_and_union3(char, float, float, 12, 4);\n+  check_struct_and_union3(char, float, double, 16, 8);\n+  check_struct_and_union3(char, float, long double, 32, 16);\n+  check_struct_and_union3(char, double, char, 24, 8);\n+  check_struct_and_union3(char, double, short, 24, 8);\n+  check_struct_and_union3(char, double, int, 24, 8);\n+  check_struct_and_union3(char, double, long, 24, 8);\n+  check_struct_and_union3(char, double, long long, 24, 8);\n+  check_struct_and_union3(char, double, float, 24, 8);\n+  check_struct_and_union3(char, double, double, 24, 8);\n+  check_struct_and_union3(char, double, long double, 32, 16);\n+  check_struct_and_union3(char, long double, char, 48, 16);\n+  check_struct_and_union3(char, long double, short, 48, 16);\n+  check_struct_and_union3(char, long double, int, 48, 16);\n+  check_struct_and_union3(char, long double, long, 48, 16);\n+  check_struct_and_union3(char, long double, long long, 48, 16);\n+  check_struct_and_union3(char, long double, float, 48, 16);\n+  check_struct_and_union3(char, long double, double, 48, 16);\n+  check_struct_and_union3(char, long double, long double, 48, 16);\n+  check_struct_and_union3(short, char, char, 4, 2);\n+  check_struct_and_union3(short, char, short, 6, 2);\n+  check_struct_and_union3(short, char, int, 8, 4);\n+  check_struct_and_union3(short, char, long, 16, 8);\n+  check_struct_and_union3(short, char, long long, 16, 8);\n+  check_struct_and_union3(short, char, float, 8, 4);\n+  check_struct_and_union3(short, char, double, 16, 8);\n+  check_struct_and_union3(short, char, long double, 32, 16);\n+  check_struct_and_union3(short, short, char, 6, 2);\n+  check_struct_and_union3(short, short, short, 6, 2);\n+  check_struct_and_union3(short, short, int, 8, 4);\n+  check_struct_and_union3(short, short, long, 16, 8);\n+  check_struct_and_union3(short, short, long long, 16, 8);\n+  check_struct_and_union3(short, short, float, 8, 4);\n+  check_struct_and_union3(short, short, double, 16, 8);\n+  check_struct_and_union3(short, short, long double, 32, 16);\n+  check_struct_and_union3(short, int, char, 12, 4);\n+  check_struct_and_union3(short, int, short, 12, 4);\n+  check_struct_and_union3(short, int, int, 12, 4);\n+  check_struct_and_union3(short, int, long, 16, 8);\n+  check_struct_and_union3(short, int, long long, 16, 8);\n+  check_struct_and_union3(short, int, float, 12, 4);\n+  check_struct_and_union3(short, int, double, 16, 8);\n+  check_struct_and_union3(short, int, long double, 32, 16);\n+  check_struct_and_union3(short, long, char, 24, 8);\n+  check_struct_and_union3(short, long, short, 24, 8);\n+  check_struct_and_union3(short, long, int, 24, 8);\n+  check_struct_and_union3(short, long, long, 24, 8);\n+  check_struct_and_union3(short, long, long long, 24, 8);\n+  check_struct_and_union3(short, long, float, 24, 8);\n+  check_struct_and_union3(short, long, double, 24, 8);\n+  check_struct_and_union3(short, long, long double, 32, 16);\n+  check_struct_and_union3(short, long long, char, 24, 8);\n+  check_struct_and_union3(short, long long, short, 24, 8);\n+  check_struct_and_union3(short, long long, int, 24, 8);\n+  check_struct_and_union3(short, long long, long, 24, 8);\n+  check_struct_and_union3(short, long long, long long, 24, 8);\n+  check_struct_and_union3(short, long long, float, 24, 8);\n+  check_struct_and_union3(short, long long, double, 24, 8);\n+  check_struct_and_union3(short, long long, long double, 32, 16);\n+  check_struct_and_union3(short, float, char, 12, 4);\n+  check_struct_and_union3(short, float, short, 12, 4);\n+  check_struct_and_union3(short, float, int, 12, 4);\n+  check_struct_and_union3(short, float, long, 16, 8);\n+  check_struct_and_union3(short, float, long long, 16, 8);\n+  check_struct_and_union3(short, float, float, 12, 4);\n+  check_struct_and_union3(short, float, double, 16, 8);\n+  check_struct_and_union3(short, float, long double, 32, 16);\n+  check_struct_and_union3(short, double, char, 24, 8);\n+  check_struct_and_union3(short, double, short, 24, 8);\n+  check_struct_and_union3(short, double, int, 24, 8);\n+  check_struct_and_union3(short, double, long, 24, 8);\n+  check_struct_and_union3(short, double, long long, 24, 8);\n+  check_struct_and_union3(short, double, float, 24, 8);\n+  check_struct_and_union3(short, double, double, 24, 8);\n+  check_struct_and_union3(short, double, long double, 32, 16);\n+  check_struct_and_union3(short, long double, char, 48, 16);\n+  check_struct_and_union3(short, long double, short, 48, 16);\n+  check_struct_and_union3(short, long double, int, 48, 16);\n+  check_struct_and_union3(short, long double, long, 48, 16);\n+  check_struct_and_union3(short, long double, long long, 48, 16);\n+  check_struct_and_union3(short, long double, float, 48, 16);\n+  check_struct_and_union3(short, long double, double, 48, 16);\n+  check_struct_and_union3(short, long double, long double, 48, 16);\n+  check_struct_and_union3(int, char, char, 8, 4);\n+  check_struct_and_union3(int, char, short, 8, 4);\n+  check_struct_and_union3(int, char, int, 12, 4);\n+  check_struct_and_union3(int, char, long, 16, 8);\n+  check_struct_and_union3(int, char, long long, 16, 8);\n+  check_struct_and_union3(int, char, float, 12, 4);\n+  check_struct_and_union3(int, char, double, 16, 8);\n+  check_struct_and_union3(int, char, long double, 32, 16);\n+  check_struct_and_union3(int, short, char, 8, 4);\n+  check_struct_and_union3(int, short, short, 8, 4);\n+  check_struct_and_union3(int, short, int, 12, 4);\n+  check_struct_and_union3(int, short, long, 16, 8);\n+  check_struct_and_union3(int, short, long long, 16, 8);\n+  check_struct_and_union3(int, short, float, 12, 4);\n+  check_struct_and_union3(int, short, double, 16, 8);\n+  check_struct_and_union3(int, short, long double, 32, 16);\n+  check_struct_and_union3(int, int, char, 12, 4);\n+  check_struct_and_union3(int, int, short, 12, 4);\n+  check_struct_and_union3(int, int, int, 12, 4);\n+  check_struct_and_union3(int, int, long, 16, 8);\n+  check_struct_and_union3(int, int, long long, 16, 8);\n+  check_struct_and_union3(int, int, float, 12, 4);\n+  check_struct_and_union3(int, int, double, 16, 8);\n+  check_struct_and_union3(int, int, long double, 32, 16);\n+  check_struct_and_union3(int, long, char, 24, 8);\n+  check_struct_and_union3(int, long, short, 24, 8);\n+  check_struct_and_union3(int, long, int, 24, 8);\n+  check_struct_and_union3(int, long, long, 24, 8);\n+  check_struct_and_union3(int, long, long long, 24, 8);\n+  check_struct_and_union3(int, long, float, 24, 8);\n+  check_struct_and_union3(int, long, double, 24, 8);\n+  check_struct_and_union3(int, long, long double, 32, 16);\n+  check_struct_and_union3(int, long long, char, 24, 8);\n+  check_struct_and_union3(int, long long, short, 24, 8);\n+  check_struct_and_union3(int, long long, int, 24, 8);\n+  check_struct_and_union3(int, long long, long, 24, 8);\n+  check_struct_and_union3(int, long long, long long, 24, 8);\n+  check_struct_and_union3(int, long long, float, 24, 8);\n+  check_struct_and_union3(int, long long, double, 24, 8);\n+  check_struct_and_union3(int, long long, long double, 32, 16);\n+  check_struct_and_union3(int, float, char, 12, 4);\n+  check_struct_and_union3(int, float, short, 12, 4);\n+  check_struct_and_union3(int, float, int, 12, 4);\n+  check_struct_and_union3(int, float, long, 16, 8);\n+  check_struct_and_union3(int, float, long long, 16, 8);\n+  check_struct_and_union3(int, float, float, 12, 4);\n+  check_struct_and_union3(int, float, double, 16, 8);\n+  check_struct_and_union3(int, float, long double, 32, 16);\n+  check_struct_and_union3(int, double, char, 24, 8);\n+  check_struct_and_union3(int, double, short, 24, 8);\n+  check_struct_and_union3(int, double, int, 24, 8);\n+  check_struct_and_union3(int, double, long, 24, 8);\n+  check_struct_and_union3(int, double, long long, 24, 8);\n+  check_struct_and_union3(int, double, float, 24, 8);\n+  check_struct_and_union3(int, double, double, 24, 8);\n+  check_struct_and_union3(int, double, long double, 32, 16);\n+  check_struct_and_union3(int, long double, char, 48, 16);\n+  check_struct_and_union3(int, long double, short, 48, 16);\n+  check_struct_and_union3(int, long double, int, 48, 16);\n+  check_struct_and_union3(int, long double, long, 48, 16);\n+  check_struct_and_union3(int, long double, long long, 48, 16);\n+  check_struct_and_union3(int, long double, float, 48, 16);\n+  check_struct_and_union3(int, long double, double, 48, 16);\n+  check_struct_and_union3(int, long double, long double, 48, 16);\n+  check_struct_and_union3(long, char, char, 16, 8);\n+  check_struct_and_union3(long, char, short, 16, 8);\n+  check_struct_and_union3(long, char, int, 16, 8);\n+  check_struct_and_union3(long, char, long, 24, 8);\n+  check_struct_and_union3(long, char, long long, 24, 8);\n+  check_struct_and_union3(long, char, float, 16, 8);\n+  check_struct_and_union3(long, char, double, 24, 8);\n+  check_struct_and_union3(long, char, long double, 32, 16);\n+  check_struct_and_union3(long, short, char, 16, 8);\n+  check_struct_and_union3(long, short, short, 16, 8);\n+  check_struct_and_union3(long, short, int, 16, 8);\n+  check_struct_and_union3(long, short, long, 24, 8);\n+  check_struct_and_union3(long, short, long long, 24, 8);\n+  check_struct_and_union3(long, short, float, 16, 8);\n+  check_struct_and_union3(long, short, double, 24, 8);\n+  check_struct_and_union3(long, short, long double, 32, 16);\n+  check_struct_and_union3(long, int, char, 16, 8);\n+  check_struct_and_union3(long, int, short, 16, 8);\n+  check_struct_and_union3(long, int, int, 16, 8);\n+  check_struct_and_union3(long, int, long, 24, 8);\n+  check_struct_and_union3(long, int, long long, 24, 8);\n+  check_struct_and_union3(long, int, float, 16, 8);\n+  check_struct_and_union3(long, int, double, 24, 8);\n+  check_struct_and_union3(long, int, long double, 32, 16);\n+  check_struct_and_union3(long, long, char, 24, 8);\n+  check_struct_and_union3(long, long, short, 24, 8);\n+  check_struct_and_union3(long, long, int, 24, 8);\n+  check_struct_and_union3(long, long, long, 24, 8);\n+  check_struct_and_union3(long, long, long long, 24, 8);\n+  check_struct_and_union3(long, long, float, 24, 8);\n+  check_struct_and_union3(long, long, double, 24, 8);\n+  check_struct_and_union3(long, long, long double, 32, 16);\n+  check_struct_and_union3(long, long long, char, 24, 8);\n+  check_struct_and_union3(long, long long, short, 24, 8);\n+  check_struct_and_union3(long, long long, int, 24, 8);\n+  check_struct_and_union3(long, long long, long, 24, 8);\n+  check_struct_and_union3(long, long long, long long, 24, 8);\n+  check_struct_and_union3(long, long long, float, 24, 8);\n+  check_struct_and_union3(long, long long, double, 24, 8);\n+  check_struct_and_union3(long, long long, long double, 32, 16);\n+  check_struct_and_union3(long, float, char, 16, 8);\n+  check_struct_and_union3(long, float, short, 16, 8);\n+  check_struct_and_union3(long, float, int, 16, 8);\n+  check_struct_and_union3(long, float, long, 24, 8);\n+  check_struct_and_union3(long, float, long long, 24, 8);\n+  check_struct_and_union3(long, float, float, 16, 8);\n+  check_struct_and_union3(long, float, double, 24, 8);\n+  check_struct_and_union3(long, float, long double, 32, 16);\n+  check_struct_and_union3(long, double, char, 24, 8);\n+  check_struct_and_union3(long, double, short, 24, 8);\n+  check_struct_and_union3(long, double, int, 24, 8);\n+  check_struct_and_union3(long, double, long, 24, 8);\n+  check_struct_and_union3(long, double, long long, 24, 8);\n+  check_struct_and_union3(long, double, float, 24, 8);\n+  check_struct_and_union3(long, double, double, 24, 8);\n+  check_struct_and_union3(long, double, long double, 32, 16);\n+  check_struct_and_union3(long, long double, char, 48, 16);\n+  check_struct_and_union3(long, long double, short, 48, 16);\n+  check_struct_and_union3(long, long double, int, 48, 16);\n+  check_struct_and_union3(long, long double, long, 48, 16);\n+  check_struct_and_union3(long, long double, long long, 48, 16);\n+  check_struct_and_union3(long, long double, float, 48, 16);\n+  check_struct_and_union3(long, long double, double, 48, 16);\n+  check_struct_and_union3(long, long double, long double, 48, 16);\n+  check_struct_and_union3(long long, char, char, 16, 8);\n+  check_struct_and_union3(long long, char, short, 16, 8);\n+  check_struct_and_union3(long long, char, int, 16, 8);\n+  check_struct_and_union3(long long, char, long, 24, 8);\n+  check_struct_and_union3(long long, char, long long, 24, 8);\n+  check_struct_and_union3(long long, char, float, 16, 8);\n+  check_struct_and_union3(long long, char, double, 24, 8);\n+  check_struct_and_union3(long long, char, long double, 32, 16);\n+  check_struct_and_union3(long long, short, char, 16, 8);\n+  check_struct_and_union3(long long, short, short, 16, 8);\n+  check_struct_and_union3(long long, short, int, 16, 8);\n+  check_struct_and_union3(long long, short, long, 24, 8);\n+  check_struct_and_union3(long long, short, long long, 24, 8);\n+  check_struct_and_union3(long long, short, float, 16, 8);\n+  check_struct_and_union3(long long, short, double, 24, 8);\n+  check_struct_and_union3(long long, short, long double, 32, 16);\n+  check_struct_and_union3(long long, int, char, 16, 8);\n+  check_struct_and_union3(long long, int, short, 16, 8);\n+  check_struct_and_union3(long long, int, int, 16, 8);\n+  check_struct_and_union3(long long, int, long, 24, 8);\n+  check_struct_and_union3(long long, int, long long, 24, 8);\n+  check_struct_and_union3(long long, int, float, 16, 8);\n+  check_struct_and_union3(long long, int, double, 24, 8);\n+  check_struct_and_union3(long long, int, long double, 32, 16);\n+  check_struct_and_union3(long long, long, char, 24, 8);\n+  check_struct_and_union3(long long, long, short, 24, 8);\n+  check_struct_and_union3(long long, long, int, 24, 8);\n+  check_struct_and_union3(long long, long, long, 24, 8);\n+  check_struct_and_union3(long long, long, long long, 24, 8);\n+  check_struct_and_union3(long long, long, float, 24, 8);\n+  check_struct_and_union3(long long, long, double, 24, 8);\n+  check_struct_and_union3(long long, long, long double, 32, 16);\n+  check_struct_and_union3(long long, long long, char, 24, 8);\n+  check_struct_and_union3(long long, long long, short, 24, 8);\n+  check_struct_and_union3(long long, long long, int, 24, 8);\n+  check_struct_and_union3(long long, long long, long, 24, 8);\n+  check_struct_and_union3(long long, long long, long long, 24, 8);\n+  check_struct_and_union3(long long, long long, float, 24, 8);\n+  check_struct_and_union3(long long, long long, double, 24, 8);\n+  check_struct_and_union3(long long, long long, long double, 32, 16);\n+  check_struct_and_union3(long long, float, char, 16, 8);\n+  check_struct_and_union3(long long, float, short, 16, 8);\n+  check_struct_and_union3(long long, float, int, 16, 8);\n+  check_struct_and_union3(long long, float, long, 24, 8);\n+  check_struct_and_union3(long long, float, long long, 24, 8);\n+  check_struct_and_union3(long long, float, float, 16, 8);\n+  check_struct_and_union3(long long, float, double, 24, 8);\n+  check_struct_and_union3(long long, float, long double, 32, 16);\n+  check_struct_and_union3(long long, double, char, 24, 8);\n+  check_struct_and_union3(long long, double, short, 24, 8);\n+  check_struct_and_union3(long long, double, int, 24, 8);\n+  check_struct_and_union3(long long, double, long, 24, 8);\n+  check_struct_and_union3(long long, double, long long, 24, 8);\n+  check_struct_and_union3(long long, double, float, 24, 8);\n+  check_struct_and_union3(long long, double, double, 24, 8);\n+  check_struct_and_union3(long long, double, long double, 32, 16);\n+  check_struct_and_union3(long long, long double, char, 48, 16);\n+  check_struct_and_union3(long long, long double, short, 48, 16);\n+  check_struct_and_union3(long long, long double, int, 48, 16);\n+  check_struct_and_union3(long long, long double, long, 48, 16);\n+  check_struct_and_union3(long long, long double, long long, 48, 16);\n+  check_struct_and_union3(long long, long double, float, 48, 16);\n+  check_struct_and_union3(long long, long double, double, 48, 16);\n+  check_struct_and_union3(long long, long double, long double, 48, 16);\n+  check_struct_and_union3(float, char, char, 8, 4);\n+  check_struct_and_union3(float, char, short, 8, 4);\n+  check_struct_and_union3(float, char, int, 12, 4);\n+  check_struct_and_union3(float, char, long, 16, 8);\n+  check_struct_and_union3(float, char, long long, 16, 8);\n+  check_struct_and_union3(float, char, float, 12, 4);\n+  check_struct_and_union3(float, char, double, 16, 8);\n+  check_struct_and_union3(float, char, long double, 32, 16);\n+  check_struct_and_union3(float, short, char, 8, 4);\n+  check_struct_and_union3(float, short, short, 8, 4);\n+  check_struct_and_union3(float, short, int, 12, 4);\n+  check_struct_and_union3(float, short, long, 16, 8);\n+  check_struct_and_union3(float, short, long long, 16, 8);\n+  check_struct_and_union3(float, short, float, 12, 4);\n+  check_struct_and_union3(float, short, double, 16, 8);\n+  check_struct_and_union3(float, short, long double, 32, 16);\n+  check_struct_and_union3(float, int, char, 12, 4);\n+  check_struct_and_union3(float, int, short, 12, 4);\n+  check_struct_and_union3(float, int, int, 12, 4);\n+  check_struct_and_union3(float, int, long, 16, 8);\n+  check_struct_and_union3(float, int, long long, 16, 8);\n+  check_struct_and_union3(float, int, float, 12, 4);\n+  check_struct_and_union3(float, int, double, 16, 8);\n+  check_struct_and_union3(float, int, long double, 32, 16);\n+  check_struct_and_union3(float, long, char, 24, 8);\n+  check_struct_and_union3(float, long, short, 24, 8);\n+  check_struct_and_union3(float, long, int, 24, 8);\n+  check_struct_and_union3(float, long, long, 24, 8);\n+  check_struct_and_union3(float, long, long long, 24, 8);\n+  check_struct_and_union3(float, long, float, 24, 8);\n+  check_struct_and_union3(float, long, double, 24, 8);\n+  check_struct_and_union3(float, long, long double, 32, 16);\n+  check_struct_and_union3(float, long long, char, 24, 8);\n+  check_struct_and_union3(float, long long, short, 24, 8);\n+  check_struct_and_union3(float, long long, int, 24, 8);\n+  check_struct_and_union3(float, long long, long, 24, 8);\n+  check_struct_and_union3(float, long long, long long, 24, 8);\n+  check_struct_and_union3(float, long long, float, 24, 8);\n+  check_struct_and_union3(float, long long, double, 24, 8);\n+  check_struct_and_union3(float, long long, long double, 32, 16);\n+  check_struct_and_union3(float, float, char, 12, 4);\n+  check_struct_and_union3(float, float, short, 12, 4);\n+  check_struct_and_union3(float, float, int, 12, 4);\n+  check_struct_and_union3(float, float, long, 16, 8);\n+  check_struct_and_union3(float, float, long long, 16, 8);\n+  check_struct_and_union3(float, float, float, 12, 4);\n+  check_struct_and_union3(float, float, double, 16, 8);\n+  check_struct_and_union3(float, float, long double, 32, 16);\n+  check_struct_and_union3(float, double, char, 24, 8);\n+  check_struct_and_union3(float, double, short, 24, 8);\n+  check_struct_and_union3(float, double, int, 24, 8);\n+  check_struct_and_union3(float, double, long, 24, 8);\n+  check_struct_and_union3(float, double, long long, 24, 8);\n+  check_struct_and_union3(float, double, float, 24, 8);\n+  check_struct_and_union3(float, double, double, 24, 8);\n+  check_struct_and_union3(float, double, long double, 32, 16);\n+  check_struct_and_union3(float, long double, char, 48, 16);\n+  check_struct_and_union3(float, long double, short, 48, 16);\n+  check_struct_and_union3(float, long double, int, 48, 16);\n+  check_struct_and_union3(float, long double, long, 48, 16);\n+  check_struct_and_union3(float, long double, long long, 48, 16);\n+  check_struct_and_union3(float, long double, float, 48, 16);\n+  check_struct_and_union3(float, long double, double, 48, 16);\n+  check_struct_and_union3(float, long double, long double, 48, 16);\n+  check_struct_and_union3(double, char, char, 16, 8);\n+  check_struct_and_union3(double, char, short, 16, 8);\n+  check_struct_and_union3(double, char, int, 16, 8);\n+  check_struct_and_union3(double, char, long, 24, 8);\n+  check_struct_and_union3(double, char, long long, 24, 8);\n+  check_struct_and_union3(double, char, float, 16, 8);\n+  check_struct_and_union3(double, char, double, 24, 8);\n+  check_struct_and_union3(double, char, long double, 32, 16);\n+  check_struct_and_union3(double, short, char, 16, 8);\n+  check_struct_and_union3(double, short, short, 16, 8);\n+  check_struct_and_union3(double, short, int, 16, 8);\n+  check_struct_and_union3(double, short, long, 24, 8);\n+  check_struct_and_union3(double, short, long long, 24, 8);\n+  check_struct_and_union3(double, short, float, 16, 8);\n+  check_struct_and_union3(double, short, double, 24, 8);\n+  check_struct_and_union3(double, short, long double, 32, 16);\n+  check_struct_and_union3(double, int, char, 16, 8);\n+  check_struct_and_union3(double, int, short, 16, 8);\n+  check_struct_and_union3(double, int, int, 16, 8);\n+  check_struct_and_union3(double, int, long, 24, 8);\n+  check_struct_and_union3(double, int, long long, 24, 8);\n+  check_struct_and_union3(double, int, float, 16, 8);\n+  check_struct_and_union3(double, int, double, 24, 8);\n+  check_struct_and_union3(double, int, long double, 32, 16);\n+  check_struct_and_union3(double, long, char, 24, 8);\n+  check_struct_and_union3(double, long, short, 24, 8);\n+  check_struct_and_union3(double, long, int, 24, 8);\n+  check_struct_and_union3(double, long, long, 24, 8);\n+  check_struct_and_union3(double, long, long long, 24, 8);\n+  check_struct_and_union3(double, long, float, 24, 8);\n+  check_struct_and_union3(double, long, double, 24, 8);\n+  check_struct_and_union3(double, long, long double, 32, 16);\n+  check_struct_and_union3(double, long long, char, 24, 8);\n+  check_struct_and_union3(double, long long, short, 24, 8);\n+  check_struct_and_union3(double, long long, int, 24, 8);\n+  check_struct_and_union3(double, long long, long, 24, 8);\n+  check_struct_and_union3(double, long long, long long, 24, 8);\n+  check_struct_and_union3(double, long long, float, 24, 8);\n+  check_struct_and_union3(double, long long, double, 24, 8);\n+  check_struct_and_union3(double, long long, long double, 32, 16);\n+  check_struct_and_union3(double, float, char, 16, 8);\n+  check_struct_and_union3(double, float, short, 16, 8);\n+  check_struct_and_union3(double, float, int, 16, 8);\n+  check_struct_and_union3(double, float, long, 24, 8);\n+  check_struct_and_union3(double, float, long long, 24, 8);\n+  check_struct_and_union3(double, float, float, 16, 8);\n+  check_struct_and_union3(double, float, double, 24, 8);\n+  check_struct_and_union3(double, float, long double, 32, 16);\n+  check_struct_and_union3(double, double, char, 24, 8);\n+  check_struct_and_union3(double, double, short, 24, 8);\n+  check_struct_and_union3(double, double, int, 24, 8);\n+  check_struct_and_union3(double, double, long, 24, 8);\n+  check_struct_and_union3(double, double, long long, 24, 8);\n+  check_struct_and_union3(double, double, float, 24, 8);\n+  check_struct_and_union3(double, double, double, 24, 8);\n+  check_struct_and_union3(double, double, long double, 32, 16);\n+  check_struct_and_union3(double, long double, char, 48, 16);\n+  check_struct_and_union3(double, long double, short, 48, 16);\n+  check_struct_and_union3(double, long double, int, 48, 16);\n+  check_struct_and_union3(double, long double, long, 48, 16);\n+  check_struct_and_union3(double, long double, long long, 48, 16);\n+  check_struct_and_union3(double, long double, float, 48, 16);\n+  check_struct_and_union3(double, long double, double, 48, 16);\n+  check_struct_and_union3(double, long double, long double, 48, 16);\n+  check_struct_and_union3(long double, char, char, 32, 16);\n+  check_struct_and_union3(long double, char, short, 32, 16);\n+  check_struct_and_union3(long double, char, int, 32, 16);\n+  check_struct_and_union3(long double, char, long, 32, 16);\n+  check_struct_and_union3(long double, char, long long, 32, 16);\n+  check_struct_and_union3(long double, char, float, 32, 16);\n+  check_struct_and_union3(long double, char, double, 32, 16);\n+  check_struct_and_union3(long double, char, long double, 48, 16);\n+  check_struct_and_union3(long double, short, char, 32, 16);\n+  check_struct_and_union3(long double, short, short, 32, 16);\n+  check_struct_and_union3(long double, short, int, 32, 16);\n+  check_struct_and_union3(long double, short, long, 32, 16);\n+  check_struct_and_union3(long double, short, long long, 32, 16);\n+  check_struct_and_union3(long double, short, float, 32, 16);\n+  check_struct_and_union3(long double, short, double, 32, 16);\n+  check_struct_and_union3(long double, short, long double, 48, 16);\n+  check_struct_and_union3(long double, int, char, 32, 16);\n+  check_struct_and_union3(long double, int, short, 32, 16);\n+  check_struct_and_union3(long double, int, int, 32, 16);\n+  check_struct_and_union3(long double, int, long, 32, 16);\n+  check_struct_and_union3(long double, int, long long, 32, 16);\n+  check_struct_and_union3(long double, int, float, 32, 16);\n+  check_struct_and_union3(long double, int, double, 32, 16);\n+  check_struct_and_union3(long double, int, long double, 48, 16);\n+  check_struct_and_union3(long double, long, char, 32, 16);\n+  check_struct_and_union3(long double, long, short, 32, 16);\n+  check_struct_and_union3(long double, long, int, 32, 16);\n+  check_struct_and_union3(long double, long, long, 32, 16);\n+  check_struct_and_union3(long double, long, long long, 32, 16);\n+  check_struct_and_union3(long double, long, float, 32, 16);\n+  check_struct_and_union3(long double, long, double, 32, 16);\n+  check_struct_and_union3(long double, long, long double, 48, 16);\n+  check_struct_and_union3(long double, long long, char, 32, 16);\n+  check_struct_and_union3(long double, long long, short, 32, 16);\n+  check_struct_and_union3(long double, long long, int, 32, 16);\n+  check_struct_and_union3(long double, long long, long, 32, 16);\n+  check_struct_and_union3(long double, long long, long long, 32, 16);\n+  check_struct_and_union3(long double, long long, float, 32, 16);\n+  check_struct_and_union3(long double, long long, double, 32, 16);\n+  check_struct_and_union3(long double, long long, long double, 48, 16);\n+  check_struct_and_union3(long double, float, char, 32, 16);\n+  check_struct_and_union3(long double, float, short, 32, 16);\n+  check_struct_and_union3(long double, float, int, 32, 16);\n+  check_struct_and_union3(long double, float, long, 32, 16);\n+  check_struct_and_union3(long double, float, long long, 32, 16);\n+  check_struct_and_union3(long double, float, float, 32, 16);\n+  check_struct_and_union3(long double, float, double, 32, 16);\n+  check_struct_and_union3(long double, float, long double, 48, 16);\n+  check_struct_and_union3(long double, double, char, 32, 16);\n+  check_struct_and_union3(long double, double, short, 32, 16);\n+  check_struct_and_union3(long double, double, int, 32, 16);\n+  check_struct_and_union3(long double, double, long, 32, 16);\n+  check_struct_and_union3(long double, double, long long, 32, 16);\n+  check_struct_and_union3(long double, double, float, 32, 16);\n+  check_struct_and_union3(long double, double, double, 32, 16);\n+  check_struct_and_union3(long double, double, long double, 48, 16);\n+  check_struct_and_union3(long double, long double, char, 48, 16);\n+  check_struct_and_union3(long double, long double, short, 48, 16);\n+  check_struct_and_union3(long double, long double, int, 48, 16);\n+  check_struct_and_union3(long double, long double, long, 48, 16);\n+  check_struct_and_union3(long double, long double, long long, 48, 16);\n+  check_struct_and_union3(long double, long double, float, 48, 16);\n+  check_struct_and_union3(long double, long double, double, 48, 16);\n+  check_struct_and_union3(long double, long double, long double, 48, 16);\n+  return 0;\n+}"}, {"sha": "d3d57d788f267efb1eb7e1da4f5556427730d685", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_basic_alignment.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_alignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_alignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_alignment.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,42 @@\n+/* This checks alignment of basic types.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests2(check_align, char, TYPE_ALIGN_CHAR);\n+  run_signed_tests2(check_align, short, TYPE_ALIGN_SHORT);\n+  run_signed_tests2(check_align, int, TYPE_ALIGN_INT);\n+  run_signed_tests2(check_align, long, TYPE_ALIGN_LONG);\n+  run_signed_tests2(check_align, long long, TYPE_ALIGN_LONG_LONG);\n+#ifdef CHECK_INT128\n+  run_signed_tests2(check_align, __int128, TYPE_ALIGN_INT128);\n+#endif\n+  check_align(enumtype, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_align(float, TYPE_ALIGN_FLOAT);\n+  check_align(double, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_align(long double, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_align(__float128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Packed types - MMX, 3DNow!, SSE and SSE2.  */\n+#ifdef CHECK_M64_M128\n+  check_align(__m64, TYPE_ALIGN_M64);\n+  check_align(__m128, TYPE_ALIGN_M128);\n+#endif\n+\n+  /* Pointer types.  */\n+  check_align(void *, TYPE_ALIGN_POINTER);\n+  check_align(void (*)(), TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "09c737f052b99f7e60ca72cccad56089111116ba", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_basic_array_size_and_align.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_array_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_array_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_array_size_and_align.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,41 @@\n+/* This checks .  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests3(check_array_size_and_align, char, TYPE_SIZE_CHAR, TYPE_ALIGN_CHAR);\n+  run_signed_tests3(check_array_size_and_align, short, TYPE_SIZE_SHORT, TYPE_ALIGN_SHORT);\n+  run_signed_tests3(check_array_size_and_align, int, TYPE_SIZE_INT, TYPE_ALIGN_INT);\n+  run_signed_tests3(check_array_size_and_align, long, TYPE_SIZE_LONG, TYPE_ALIGN_LONG);\n+  run_signed_tests3(check_array_size_and_align, long long, TYPE_SIZE_LONG_LONG, TYPE_ALIGN_LONG_LONG);\n+#ifdef CHECK_INT128\n+  run_signed_tests3(check_array_size_and_align, __int128, TYPE_SIZE_INT128, TYPE_ALIGN_INT128);\n+#endif\n+  check_array_size_and_align(enum dummytype, TYPE_SIZE_ENUM, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_array_size_and_align(float, TYPE_SIZE_FLOAT, TYPE_ALIGN_FLOAT);\n+  check_array_size_and_align(double, TYPE_SIZE_DOUBLE, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_array_size_and_align(long double, TYPE_SIZE_LONG_DOUBLE, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_array_size_and_align(__float128, TYPE_SIZE_FLOAT128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Packed types - MMX, 3DNow!, SSE and SSE2.  */\n+#ifdef CHECK_M64_M128\n+  check_array_size_and_align(__m64, TYPE_SIZE_M64, TYPE_ALIGN_M64);\n+  check_array_size_and_align(__m128, TYPE_SIZE_M128, TYPE_ALIGN_M128);\n+#endif\n+\n+  /* Pointer types. The function pointer doesn't work with these macros.  */\n+  check_array_size_and_align(void *, TYPE_SIZE_POINTER, TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "92c906fc852ee9ac72c32754ce211c211d8c4881", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_basic_returning.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_returning.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,78 @@\n+/* This is an autogenerated file. Do not edit.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+char\n+fun_test_returning_char (void)\n+{\n+  volatile_var++;\n+  return 64;\n+}\n+\n+short\n+fun_test_returning_short (void)\n+{\n+  volatile_var++;\n+  return 65;\n+}\n+\n+int\n+fun_test_returning_int (void)\n+{\n+  volatile_var++;\n+  return 66;\n+}\n+\n+long\n+fun_test_returning_long (void)\n+{\n+  volatile_var++;\n+  return 67;\n+}\n+\n+long long\n+fun_test_returning_long_long (void)\n+{\n+  volatile_var++;\n+  return 68;\n+}\n+\n+float\n+fun_test_returning_float (void)\n+{\n+  volatile_var++;\n+  return 69;\n+}\n+\n+double\n+fun_test_returning_double (void)\n+{\n+  volatile_var++;\n+  return 70;\n+}\n+\n+long double\n+fun_test_returning_long_double (void)\n+{\n+  volatile_var++;\n+  return 71;\n+}\n+\n+#define def_test_returning_type_xmm(fun, type, ret, reg) \\\n+  { type var = WRAP_RET (fun) (); \\\n+  assert (ret == (type) reg && ret == var); }\n+int\n+main (void)\n+{\n+  def_test_returning_type_xmm(fun_test_returning_char, char, 64, rax);\n+  def_test_returning_type_xmm(fun_test_returning_short, short, 65, rax);\n+  def_test_returning_type_xmm(fun_test_returning_int, int, 66, rax);\n+  def_test_returning_type_xmm(fun_test_returning_long, long, 67, rax);\n+  def_test_returning_type_xmm(fun_test_returning_long_long, long long, 68, rax);\n+  def_test_returning_type_xmm(fun_test_returning_float, float, 69, xmm_regs[0]._float[0]);\n+  def_test_returning_type_xmm(fun_test_returning_double, double, 70, xmm_regs[0]._double[0]);\n+  def_test_returning_type_xmm(fun_test_returning_long_double, long double, 71, x87_regs[0]._ldouble);\n+  return 0;\n+}"}, {"sha": "74427c6944f0b981e9f02f9f7de43907b8500a45", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_basic_sizes.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_sizes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_sizes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_sizes.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,42 @@\n+/* This checks sizes of basic types.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests2(check_size, char, TYPE_SIZE_CHAR);\n+  run_signed_tests2(check_size, short, TYPE_SIZE_SHORT);\n+  run_signed_tests2(check_size, int, TYPE_SIZE_INT);\n+  run_signed_tests2(check_size, long, TYPE_SIZE_LONG);\n+  run_signed_tests2(check_size, long long, TYPE_SIZE_LONG_LONG);\n+#ifdef CHECK_INT128\n+  run_signed_tests2(check_size, __int128, TYPE_SIZE_INT128);\n+#endif\n+  check_size(enumtype, TYPE_SIZE_ENUM);\n+\n+  /* Floating point types.  */\n+  check_size(float, TYPE_SIZE_FLOAT);\n+  check_size(double, TYPE_SIZE_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_size(long double, TYPE_SIZE_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_size(__float128, TYPE_SIZE_FLOAT128);\n+#endif\n+\n+  /* Packed types - MMX, 3DNow!, SSE and SSE2.  */\n+#ifdef CHECK_M64_M128\n+  check_size(__m64, TYPE_SIZE_M64);\n+  check_size(__m128, TYPE_SIZE_M128);\n+#endif\n+\n+  /* Pointer types.  */\n+  check_size(void *, TYPE_SIZE_POINTER);\n+  check_size(void (*)(), TYPE_SIZE_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "783da6ff56fd51977828b5863cbcc70be562658c", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_basic_struct_size_and_align.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_struct_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_struct_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_struct_size_and_align.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,42 @@\n+/* This checks size and alignment of structs with a single basic type\n+   element. All basic types are checked.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests3(check_basic_struct_size_and_align, char, TYPE_SIZE_CHAR, TYPE_ALIGN_CHAR);\n+  run_signed_tests3(check_basic_struct_size_and_align, short, TYPE_SIZE_SHORT, TYPE_ALIGN_SHORT);\n+  run_signed_tests3(check_basic_struct_size_and_align, int, TYPE_SIZE_INT, TYPE_ALIGN_INT);\n+  run_signed_tests3(check_basic_struct_size_and_align, long, TYPE_SIZE_LONG, TYPE_ALIGN_LONG);\n+  run_signed_tests3(check_basic_struct_size_and_align, long long, TYPE_SIZE_LONG_LONG, TYPE_ALIGN_LONG_LONG);\n+#ifdef CHECK_INT128\n+  run_signed_tests3(check_basic_struct_size_and_align, __int128, TYPE_SIZE_INT128, TYPE_ALIGN_INT128);\n+#endif\n+  check_basic_struct_size_and_align(enum dummytype, TYPE_SIZE_ENUM, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_basic_struct_size_and_align(float, TYPE_SIZE_FLOAT, TYPE_ALIGN_FLOAT);\n+  check_basic_struct_size_and_align(double, TYPE_SIZE_DOUBLE, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_basic_struct_size_and_align(long double, TYPE_SIZE_LONG_DOUBLE, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_basic_struct_size_and_align(__float128, TYPE_SIZE_FLOAT128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Packed types - MMX, 3DNow!, SSE and SSE2.  */\n+#ifdef CHECK_M64_M128\n+  check_basic_struct_size_and_align(__m64, TYPE_SIZE_M64, TYPE_ALIGN_M64);\n+  check_basic_struct_size_and_align(__m128, TYPE_SIZE_M128, TYPE_ALIGN_M128);\n+#endif\n+\n+  /* Pointer types. The function pointer doesn't work with these macros.  */\n+  check_basic_struct_size_and_align(void *, TYPE_SIZE_POINTER, TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "a5a51f290be864308eacc78e80bceef7946a37e8", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_basic_union_size_and_align.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_union_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_union_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_basic_union_size_and_align.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,41 @@\n+/* Test of simple unions, size and alignment.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests3(check_basic_union_size_and_align, char, TYPE_SIZE_CHAR, TYPE_ALIGN_CHAR);\n+  run_signed_tests3(check_basic_union_size_and_align, short, TYPE_SIZE_SHORT, TYPE_ALIGN_SHORT);\n+  run_signed_tests3(check_basic_union_size_and_align, int, TYPE_SIZE_INT, TYPE_ALIGN_INT);\n+  run_signed_tests3(check_basic_union_size_and_align, long, TYPE_SIZE_LONG, TYPE_ALIGN_LONG);\n+  run_signed_tests3(check_basic_union_size_and_align, long long, TYPE_SIZE_LONG_LONG, TYPE_ALIGN_LONG_LONG);\n+#ifdef CHECK_INT128\n+  run_signed_tests3(check_basic_union_size_and_align, __int128, TYPE_SIZE_INT128, TYPE_ALIGN_INT128);\n+#endif\n+  check_basic_union_size_and_align(enum dummytype, TYPE_SIZE_ENUM, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_basic_union_size_and_align(float, TYPE_SIZE_FLOAT, TYPE_ALIGN_FLOAT);\n+  check_basic_union_size_and_align(double, TYPE_SIZE_DOUBLE, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_basic_union_size_and_align(long double, TYPE_SIZE_LONG_DOUBLE, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_basic_union_size_and_align(__float128, TYPE_SIZE_FLOAT128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Packed types - MMX, 3DNow!, SSE and SSE2.  */\n+#ifdef CHECK_M64_M128\n+  check_basic_union_size_and_align(__m64, TYPE_SIZE_M64, TYPE_ALIGN_M64);\n+  check_basic_union_size_and_align(__m128, TYPE_SIZE_M128, TYPE_ALIGN_M128);\n+#endif\n+\n+  /* Pointer types. The function pointer doesn't work with these macros.  */\n+  check_basic_union_size_and_align(void *, TYPE_SIZE_POINTER, TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "27ab1c6aa1dd4218ce70dbf53cb0cd7c86ec4413", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_bitfields.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_bitfields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_bitfields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_bitfields.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,162 @@\n+/* This is a small test to see if bitfields are working.  It is only a\n+   few structs and a union and a test to see if they have the correct\n+   size, if values can be read and written and a couple of argument\n+   passing tests.  No alignment testing is done.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+/* These five bitfields are taken from the System V ABI, Intel 386\n+   architecture supplement.  */\n+\n+/* Word aligned, sizeof is 4.  */\n+struct RightToLeft\n+{\n+  int j:5;\n+  int k:6;\n+  int m:7;\n+};\n+\n+/* Word aligned, sizeof is 12.  */\n+struct BoundaryAlignment\n+{\n+  short s:9;\n+  int   j:9;\n+  char  c;\n+  short t:9;\n+  short u:9;\n+  char  d;\n+};\n+\n+/* Halfword aligned, sizeof is 2.  */\n+struct StorageUnitSharing\n+{\n+  char  c;\n+  short s:8;\n+};\n+\n+/* Halfword aligned, sizeof is 2.  */\n+union Allocation\n+{\n+  char  c;\n+  short s:8;\n+};\n+\n+/* Byte aligned, sizeof is 9.  */\n+struct Unnamed\n+{\n+  char  c;\n+  int    :0;\n+  char  d;\n+  short  :9;\n+  char  e;\n+  char   :0;\n+};\n+\n+/* Extra struct testing bitfields in larger types.\n+   Doubleword aligned, sizeof is 8.  */\n+struct LargerTypes\n+{\n+  long long l:33;\n+  int       i:31;\n+};\n+\n+\n+void\n+passing1 (struct RightToLeft str, int j, int k, int m)\n+{\n+  assert (str.j == j);\n+  assert (str.k == k);\n+  assert (str.m == m);\n+}\n+\n+void\n+passing2 (struct BoundaryAlignment str, short s, int j, char c, short t,\n+\t  short u, char d)\n+{\n+  assert (str.s == s);\n+  assert (str.j == j);\n+  assert (str.c == c);\n+  assert (str.t == t);\n+  assert (str.u == u);\n+  assert (str.d == d);\n+}\n+\n+void\n+passing3 (struct StorageUnitSharing str, char c, short s)\n+{\n+  assert (str.c == c);\n+  assert (str.s == s);\n+}\n+\n+void\n+passing4 (struct Unnamed str, char c, char d, char e)\n+{\n+  assert (str.c == c);\n+  assert (str.d == d);\n+  assert (str.e == e);\n+}\n+\n+void\n+passing5 (struct LargerTypes str, long long l, int i)\n+{\n+  assert (str.l == l);\n+  assert (str.i == i);\n+}\n+\n+\n+void\n+passingU (union Allocation u, char c)\n+{\n+  assert (u.c == c);\n+  assert (u.s == c);\n+}\n+\n+\n+int\n+main (void)\n+{\n+  struct RightToLeft str1;\n+  struct BoundaryAlignment str2;\n+  struct StorageUnitSharing str3;\n+  struct Unnamed str4;\n+  struct LargerTypes str5;\n+  union Allocation u;\n+\n+  /* Check sizeof's.  */\n+  check_size(str1, 4);\n+  check_size(str2, 12);\n+  check_size(str3, 2);\n+  check_size(str4, 9);\n+  check_size(str5, 8);\n+  check_size(u, 2);\n+\n+  /* Check alignof's.  */\n+  check_align_lv(str1, 4);\n+  check_align_lv(str2, 4);\n+  check_align_lv(str3, 2);\n+  check_align_lv(str4, 1);\n+  check_align_lv(str5, 8);\n+  check_align_lv(u, 2);\n+\n+  /* Check passing.  */\n+  str1.j = str2.s = str3.c = str4.c = str5.l = 4;\n+  str1.k = str2.j = str3.s = str4.d = str5.i = 5;\n+  str1.m = str2.c = str4.e = 6;\n+  str2.t = 7;\n+  str2.u = 8;\n+  str2.d = 9;\n+  passing1 (str1, 4, 5, 6);\n+  passing2 (str2, 4, 5, 6, 7, 8, 9);\n+  passing3 (str3, 4, 5);\n+  passing4 (str4, 4, 5, 6);\n+  passing5 (str5, 4, 5);\n+\n+  u.c = 5;\n+  passingU (u, 5);\n+  u.s = 6;\n+  passingU (u, 6);\n+\n+  return 0;\n+}"}, {"sha": "9e9678d7b024146323f21f8845aaea2260462ef9", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_complex_returning.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_complex_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_complex_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_complex_returning.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,83 @@\n+/* This is a small test case for returning a complex number. Written by\n+   Andreas Jaeger.  */\n+\n+#include \"defines.h\"\n+\n+\n+#define BUILD_F_COMPLEX(real, imag) \\\n+  ({ __complex__ float __retval; \\\n+     __real__ __retval = (real); \\\n+     __imag__ __retval = (imag); \\\n+     __retval; })\n+\n+#define BUILD_D_COMPLEX(real, imag) \\\n+  ({ __complex__ double __retval; \\\n+     __real__ __retval = (real); \\\n+     __imag__ __retval = (imag); \\\n+     __retval; })\n+\n+#define BUILD_LD_COMPLEX(real, imag) \\\n+  ({ __complex__ long double __retval; \\\n+     __real__ __retval = (real); \\\n+     __imag__ __retval = (imag); \\\n+     __retval; })\n+\n+__complex__ float\n+aj_f_times2 (__complex__ float x)\n+{\n+  __complex__ float res;\n+\n+  __real__ res = (2.0 * __real__ x);\n+  __imag__ res = (2.0 * __imag__ x);\n+\n+  return res;\n+}\n+\n+__complex__ double\n+aj_d_times2 (__complex__ double x)\n+{\n+  __complex__ double res;\n+\n+  __real__ res = (2.0 * __real__ x);\n+  __imag__ res = (2.0 * __imag__ x);\n+\n+  return res;\n+}\n+\n+__complex__ long double\n+aj_ld_times2 (__complex__ long double x)\n+{\n+  __complex__ long double res;\n+\n+  __real__ res = (2.0 * __real__ x);\n+  __imag__ res = (2.0 * __imag__ x);\n+\n+  return res;\n+}\n+\n+int\n+main (void)\n+{\n+#ifdef CHECK_COMPLEX\n+  _Complex float fc, fd;\n+  _Complex double dc, dd;\n+  _Complex long double ldc, ldd;\n+\n+  fc = BUILD_LD_COMPLEX (2.0f, 3.0f);\n+  fd = aj_f_times2 (fc);\n+\n+  assert (__real__ fd == 4.0f && __imag__ fd == 6.0f);\n+\n+  dc = BUILD_LD_COMPLEX (2.0, 3.0);\n+  dd = aj_ld_times2 (dc);\n+\n+  assert (__real__ dd == 4.0 && __imag__ dd == 6.0);\n+\n+  ldc = BUILD_LD_COMPLEX (2.0L, 3.0L);\n+  ldd = aj_ld_times2 (ldc);\n+\n+  assert (__real__ ldd == 4.0L && __imag__ ldd == 6.0L);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "42fff97b0ef7e1b8474b0ae46a5e9164da89f0b3", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_floats.c", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_floats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_floats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_floats.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,502 @@\n+/* This is an autogenerated file. Do not edit.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  float f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values_float;\n+\n+struct \n+{\n+  double f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values_double;\n+\n+struct \n+{\n+  ldouble f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values_ldouble;\n+\n+void\n+fun_check_float_passing_float8_values (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_float.f0 == f0);\n+  assert (values_float.f1 == f1);\n+  assert (values_float.f2 == f2);\n+  assert (values_float.f3 == f3);\n+  assert (values_float.f4 == f4);\n+  assert (values_float.f5 == f5);\n+  assert (values_float.f6 == f6);\n+  assert (values_float.f7 == f7);\n+\n+}\n+\n+void\n+fun_check_float_passing_float8_regs (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_float_arguments;\n+}\n+\n+void\n+fun_check_float_passing_float16_values (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_float.f0 == f0);\n+  assert (values_float.f1 == f1);\n+  assert (values_float.f2 == f2);\n+  assert (values_float.f3 == f3);\n+  assert (values_float.f4 == f4);\n+  assert (values_float.f5 == f5);\n+  assert (values_float.f6 == f6);\n+  assert (values_float.f7 == f7);\n+  assert (values_float.f8 == f8);\n+  assert (values_float.f9 == f9);\n+  assert (values_float.f10 == f10);\n+  assert (values_float.f11 == f11);\n+  assert (values_float.f12 == f12);\n+  assert (values_float.f13 == f13);\n+  assert (values_float.f14 == f14);\n+  assert (values_float.f15 == f15);\n+\n+}\n+\n+void\n+fun_check_float_passing_float16_regs (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_float_arguments;\n+}\n+\n+void\n+fun_check_float_passing_float20_values (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED, float f16 ATTRIBUTE_UNUSED, float f17 ATTRIBUTE_UNUSED, float f18 ATTRIBUTE_UNUSED, float f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_float.f0 == f0);\n+  assert (values_float.f1 == f1);\n+  assert (values_float.f2 == f2);\n+  assert (values_float.f3 == f3);\n+  assert (values_float.f4 == f4);\n+  assert (values_float.f5 == f5);\n+  assert (values_float.f6 == f6);\n+  assert (values_float.f7 == f7);\n+  assert (values_float.f8 == f8);\n+  assert (values_float.f9 == f9);\n+  assert (values_float.f10 == f10);\n+  assert (values_float.f11 == f11);\n+  assert (values_float.f12 == f12);\n+  assert (values_float.f13 == f13);\n+  assert (values_float.f14 == f14);\n+  assert (values_float.f15 == f15);\n+  assert (values_float.f16 == f16);\n+  assert (values_float.f17 == f17);\n+  assert (values_float.f18 == f18);\n+  assert (values_float.f19 == f19);\n+\n+}\n+\n+void\n+fun_check_float_passing_float20_regs (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED, float f16 ATTRIBUTE_UNUSED, float f17 ATTRIBUTE_UNUSED, float f18 ATTRIBUTE_UNUSED, float f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_float_arguments;\n+}\n+\n+void\n+fun_check_float_passing_double8_values (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_double.f0 == f0);\n+  assert (values_double.f1 == f1);\n+  assert (values_double.f2 == f2);\n+  assert (values_double.f3 == f3);\n+  assert (values_double.f4 == f4);\n+  assert (values_double.f5 == f5);\n+  assert (values_double.f6 == f6);\n+  assert (values_double.f7 == f7);\n+\n+}\n+\n+void\n+fun_check_float_passing_double8_regs (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_double_arguments;\n+}\n+\n+void\n+fun_check_float_passing_double16_values (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_double.f0 == f0);\n+  assert (values_double.f1 == f1);\n+  assert (values_double.f2 == f2);\n+  assert (values_double.f3 == f3);\n+  assert (values_double.f4 == f4);\n+  assert (values_double.f5 == f5);\n+  assert (values_double.f6 == f6);\n+  assert (values_double.f7 == f7);\n+  assert (values_double.f8 == f8);\n+  assert (values_double.f9 == f9);\n+  assert (values_double.f10 == f10);\n+  assert (values_double.f11 == f11);\n+  assert (values_double.f12 == f12);\n+  assert (values_double.f13 == f13);\n+  assert (values_double.f14 == f14);\n+  assert (values_double.f15 == f15);\n+\n+}\n+\n+void\n+fun_check_float_passing_double16_regs (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_double_arguments;\n+}\n+\n+void\n+fun_check_float_passing_double20_values (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED, double f16 ATTRIBUTE_UNUSED, double f17 ATTRIBUTE_UNUSED, double f18 ATTRIBUTE_UNUSED, double f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_double.f0 == f0);\n+  assert (values_double.f1 == f1);\n+  assert (values_double.f2 == f2);\n+  assert (values_double.f3 == f3);\n+  assert (values_double.f4 == f4);\n+  assert (values_double.f5 == f5);\n+  assert (values_double.f6 == f6);\n+  assert (values_double.f7 == f7);\n+  assert (values_double.f8 == f8);\n+  assert (values_double.f9 == f9);\n+  assert (values_double.f10 == f10);\n+  assert (values_double.f11 == f11);\n+  assert (values_double.f12 == f12);\n+  assert (values_double.f13 == f13);\n+  assert (values_double.f14 == f14);\n+  assert (values_double.f15 == f15);\n+  assert (values_double.f16 == f16);\n+  assert (values_double.f17 == f17);\n+  assert (values_double.f18 == f18);\n+  assert (values_double.f19 == f19);\n+\n+}\n+\n+void\n+fun_check_float_passing_double20_regs (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED, double f16 ATTRIBUTE_UNUSED, double f17 ATTRIBUTE_UNUSED, double f18 ATTRIBUTE_UNUSED, double f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_double_arguments;\n+}\n+\n+void\n+fun_check_x87_passing_ldouble8_values (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_ldouble.f0 == f0);\n+  assert (values_ldouble.f1 == f1);\n+  assert (values_ldouble.f2 == f2);\n+  assert (values_ldouble.f3 == f3);\n+  assert (values_ldouble.f4 == f4);\n+  assert (values_ldouble.f5 == f5);\n+  assert (values_ldouble.f6 == f6);\n+  assert (values_ldouble.f7 == f7);\n+\n+}\n+\n+void\n+fun_check_x87_passing_ldouble8_regs (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_ldouble_arguments;\n+}\n+\n+void\n+fun_check_x87_passing_ldouble16_values (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_ldouble.f0 == f0);\n+  assert (values_ldouble.f1 == f1);\n+  assert (values_ldouble.f2 == f2);\n+  assert (values_ldouble.f3 == f3);\n+  assert (values_ldouble.f4 == f4);\n+  assert (values_ldouble.f5 == f5);\n+  assert (values_ldouble.f6 == f6);\n+  assert (values_ldouble.f7 == f7);\n+  assert (values_ldouble.f8 == f8);\n+  assert (values_ldouble.f9 == f9);\n+  assert (values_ldouble.f10 == f10);\n+  assert (values_ldouble.f11 == f11);\n+  assert (values_ldouble.f12 == f12);\n+  assert (values_ldouble.f13 == f13);\n+  assert (values_ldouble.f14 == f14);\n+  assert (values_ldouble.f15 == f15);\n+\n+}\n+\n+void\n+fun_check_x87_passing_ldouble16_regs (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_ldouble_arguments;\n+}\n+\n+void\n+fun_check_x87_passing_ldouble20_values (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED, ldouble f16 ATTRIBUTE_UNUSED, ldouble f17 ATTRIBUTE_UNUSED, ldouble f18 ATTRIBUTE_UNUSED, ldouble f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_ldouble.f0 == f0);\n+  assert (values_ldouble.f1 == f1);\n+  assert (values_ldouble.f2 == f2);\n+  assert (values_ldouble.f3 == f3);\n+  assert (values_ldouble.f4 == f4);\n+  assert (values_ldouble.f5 == f5);\n+  assert (values_ldouble.f6 == f6);\n+  assert (values_ldouble.f7 == f7);\n+  assert (values_ldouble.f8 == f8);\n+  assert (values_ldouble.f9 == f9);\n+  assert (values_ldouble.f10 == f10);\n+  assert (values_ldouble.f11 == f11);\n+  assert (values_ldouble.f12 == f12);\n+  assert (values_ldouble.f13 == f13);\n+  assert (values_ldouble.f14 == f14);\n+  assert (values_ldouble.f15 == f15);\n+  assert (values_ldouble.f16 == f16);\n+  assert (values_ldouble.f17 == f17);\n+  assert (values_ldouble.f18 == f18);\n+  assert (values_ldouble.f19 == f19);\n+\n+}\n+\n+void\n+fun_check_x87_passing_ldouble20_regs (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED, ldouble f16 ATTRIBUTE_UNUSED, ldouble f17 ATTRIBUTE_UNUSED, ldouble f18 ATTRIBUTE_UNUSED, ldouble f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_ldouble_arguments;\n+}\n+\n+#define def_check_float_passing8(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7); \\\n+  \\\n+  clear_float_registers; \\\n+  fregs.F0._ ## TYPE [0] = _f0; \\\n+  fregs.F1._ ## TYPE [0] = _f1; \\\n+  fregs.F2._ ## TYPE [0] = _f2; \\\n+  fregs.F3._ ## TYPE [0] = _f3; \\\n+  fregs.F4._ ## TYPE [0] = _f4; \\\n+  fregs.F5._ ## TYPE [0] = _f5; \\\n+  fregs.F6._ ## TYPE [0] = _f6; \\\n+  fregs.F7._ ## TYPE [0] = _f7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7);\n+\n+#define def_check_float_passing16(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15); \\\n+  \\\n+  clear_float_registers; \\\n+  fregs.F0._ ## TYPE [0] = _f0; \\\n+  fregs.F1._ ## TYPE [0] = _f1; \\\n+  fregs.F2._ ## TYPE [0] = _f2; \\\n+  fregs.F3._ ## TYPE [0] = _f3; \\\n+  fregs.F4._ ## TYPE [0] = _f4; \\\n+  fregs.F5._ ## TYPE [0] = _f5; \\\n+  fregs.F6._ ## TYPE [0] = _f6; \\\n+  fregs.F7._ ## TYPE [0] = _f7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15);\n+\n+#define def_check_float_passing20(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  values_ ## TYPE .f16 = _f16; \\\n+  values_ ## TYPE .f17 = _f17; \\\n+  values_ ## TYPE .f18 = _f18; \\\n+  values_ ## TYPE .f19 = _f19; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19); \\\n+  \\\n+  clear_float_registers; \\\n+  fregs.F0._ ## TYPE [0] = _f0; \\\n+  fregs.F1._ ## TYPE [0] = _f1; \\\n+  fregs.F2._ ## TYPE [0] = _f2; \\\n+  fregs.F3._ ## TYPE [0] = _f3; \\\n+  fregs.F4._ ## TYPE [0] = _f4; \\\n+  fregs.F5._ ## TYPE [0] = _f5; \\\n+  fregs.F6._ ## TYPE [0] = _f6; \\\n+  fregs.F7._ ## TYPE [0] = _f7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19);\n+\n+#define def_check_x87_passing8(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7); \\\n+  \\\n+  clear_x87_registers; \\\n+  num_fregs = 0; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7);\n+\n+#define def_check_x87_passing16(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15); \\\n+  \\\n+  clear_x87_registers; \\\n+  num_fregs = 0; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15);\n+\n+#define def_check_x87_passing20(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  values_ ## TYPE .f16 = _f16; \\\n+  values_ ## TYPE .f17 = _f17; \\\n+  values_ ## TYPE .f18 = _f18; \\\n+  values_ ## TYPE .f19 = _f19; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19); \\\n+  \\\n+  clear_x87_registers; \\\n+  num_fregs = 0; \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19);\n+\n+void\n+test_floats_on_stack ()\n+{\n+  def_check_float_passing8(32, 33, 34, 35, 36, 37, 38, 39, fun_check_float_passing_float8_values, fun_check_float_passing_float8_regs, float);\n+\n+  def_check_float_passing16(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, fun_check_float_passing_float16_values, fun_check_float_passing_float16_regs, float);\n+}\n+\n+void\n+test_too_many_floats ()\n+{\n+  def_check_float_passing20(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, fun_check_float_passing_float20_values, fun_check_float_passing_float20_regs, float);\n+}\n+\n+void\n+test_doubles_on_stack ()\n+{\n+  def_check_float_passing8(32, 33, 34, 35, 36, 37, 38, 39, fun_check_float_passing_double8_values, fun_check_float_passing_double8_regs, double);\n+\n+  def_check_float_passing16(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, fun_check_float_passing_double16_values, fun_check_float_passing_double16_regs, double);\n+}\n+\n+void\n+test_too_many_doubles ()\n+{\n+  def_check_float_passing20(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, fun_check_float_passing_double20_values, fun_check_float_passing_double20_regs, double);\n+}\n+\n+void\n+test_long_doubles_on_stack ()\n+{\n+  def_check_x87_passing8(32, 33, 34, 35, 36, 37, 38, 39, fun_check_x87_passing_ldouble8_values, fun_check_x87_passing_ldouble8_regs, ldouble);\n+}\n+\n+void\n+test_too_many_long_doubles ()\n+{\n+  def_check_x87_passing20(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, fun_check_x87_passing_ldouble20_values, fun_check_x87_passing_ldouble20_regs, ldouble);\n+}\n+\n+void\n+test_float128s_on_stack ()\n+{\n+}\n+\n+void\n+test_too_many_float128s ()\n+{\n+}\n+\n+\n+int\n+main (void)\n+{\n+  test_floats_on_stack ();\n+  test_too_many_floats ();\n+  test_doubles_on_stack ();\n+  test_too_many_doubles ();\n+  test_long_doubles_on_stack ();\n+  test_too_many_long_doubles ();\n+  test_float128s_on_stack ();\n+  test_too_many_float128s ();\n+  return 0;\n+}"}, {"sha": "d0d0f1fd22265c36f7465e49a7924c7439c78fbc", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_integers.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_integers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_integers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_integers.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,203 @@\n+/* This is an autogenerated file. Do not edit.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  int i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23;\n+} values_int;\n+\n+struct \n+{\n+  long i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23;\n+} values_long;\n+\n+void\n+fun_check_int_passing_int6_values (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_int.i0 == i0);\n+  assert (values_int.i1 == i1);\n+  assert (values_int.i2 == i2);\n+  assert (values_int.i3 == i3);\n+  assert (values_int.i4 == i4);\n+  assert (values_int.i5 == i5);\n+\n+}\n+\n+void\n+fun_check_int_passing_int6_regs (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_int_arguments;\n+}\n+\n+void\n+fun_check_int_passing_int12_values (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED, int i6 ATTRIBUTE_UNUSED, int i7 ATTRIBUTE_UNUSED, int i8 ATTRIBUTE_UNUSED, int i9 ATTRIBUTE_UNUSED, int i10 ATTRIBUTE_UNUSED, int i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_int.i0 == i0);\n+  assert (values_int.i1 == i1);\n+  assert (values_int.i2 == i2);\n+  assert (values_int.i3 == i3);\n+  assert (values_int.i4 == i4);\n+  assert (values_int.i5 == i5);\n+  assert (values_int.i6 == i6);\n+  assert (values_int.i7 == i7);\n+  assert (values_int.i8 == i8);\n+  assert (values_int.i9 == i9);\n+  assert (values_int.i10 == i10);\n+  assert (values_int.i11 == i11);\n+\n+}\n+\n+void\n+fun_check_int_passing_int12_regs (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED, int i6 ATTRIBUTE_UNUSED, int i7 ATTRIBUTE_UNUSED, int i8 ATTRIBUTE_UNUSED, int i9 ATTRIBUTE_UNUSED, int i10 ATTRIBUTE_UNUSED, int i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_int_arguments;\n+}\n+\n+void\n+fun_check_int_passing_long6_values (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_long.i0 == i0);\n+  assert (values_long.i1 == i1);\n+  assert (values_long.i2 == i2);\n+  assert (values_long.i3 == i3);\n+  assert (values_long.i4 == i4);\n+  assert (values_long.i5 == i5);\n+\n+}\n+\n+void\n+fun_check_int_passing_long6_regs (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_long_arguments;\n+}\n+\n+void\n+fun_check_int_passing_long12_values (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED, long i6 ATTRIBUTE_UNUSED, long i7 ATTRIBUTE_UNUSED, long i8 ATTRIBUTE_UNUSED, long i9 ATTRIBUTE_UNUSED, long i10 ATTRIBUTE_UNUSED, long i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_long.i0 == i0);\n+  assert (values_long.i1 == i1);\n+  assert (values_long.i2 == i2);\n+  assert (values_long.i3 == i3);\n+  assert (values_long.i4 == i4);\n+  assert (values_long.i5 == i5);\n+  assert (values_long.i6 == i6);\n+  assert (values_long.i7 == i7);\n+  assert (values_long.i8 == i8);\n+  assert (values_long.i9 == i9);\n+  assert (values_long.i10 == i10);\n+  assert (values_long.i11 == i11);\n+\n+}\n+\n+void\n+fun_check_int_passing_long12_regs (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED, long i6 ATTRIBUTE_UNUSED, long i7 ATTRIBUTE_UNUSED, long i8 ATTRIBUTE_UNUSED, long i9 ATTRIBUTE_UNUSED, long i10 ATTRIBUTE_UNUSED, long i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_long_arguments;\n+}\n+\n+#define def_check_int_passing6(_i0, _i1, _i2, _i3, _i4, _i5, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .i0 = _i0; \\\n+  values_ ## TYPE .i1 = _i1; \\\n+  values_ ## TYPE .i2 = _i2; \\\n+  values_ ## TYPE .i3 = _i3; \\\n+  values_ ## TYPE .i4 = _i4; \\\n+  values_ ## TYPE .i5 = _i5; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5); \\\n+  \\\n+  clear_int_registers; \\\n+  iregs.I0 = _i0; \\\n+  iregs.I1 = _i1; \\\n+  iregs.I2 = _i2; \\\n+  iregs.I3 = _i3; \\\n+  iregs.I4 = _i4; \\\n+  iregs.I5 = _i5; \\\n+  num_iregs = 6; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5);\n+\n+#define def_check_int_passing12(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .i0 = _i0; \\\n+  values_ ## TYPE .i1 = _i1; \\\n+  values_ ## TYPE .i2 = _i2; \\\n+  values_ ## TYPE .i3 = _i3; \\\n+  values_ ## TYPE .i4 = _i4; \\\n+  values_ ## TYPE .i5 = _i5; \\\n+  values_ ## TYPE .i6 = _i6; \\\n+  values_ ## TYPE .i7 = _i7; \\\n+  values_ ## TYPE .i8 = _i8; \\\n+  values_ ## TYPE .i9 = _i9; \\\n+  values_ ## TYPE .i10 = _i10; \\\n+  values_ ## TYPE .i11 = _i11; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11); \\\n+  \\\n+  clear_int_registers; \\\n+  iregs.I0 = _i0; \\\n+  iregs.I1 = _i1; \\\n+  iregs.I2 = _i2; \\\n+  iregs.I3 = _i3; \\\n+  iregs.I4 = _i4; \\\n+  iregs.I5 = _i5; \\\n+  num_iregs = 6; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11);\n+\n+void\n+test_ints_on_stack ()\n+{\n+  def_check_int_passing6(32, 33, 34, 35, 36, 37, fun_check_int_passing_int6_values, fun_check_int_passing_int6_regs, int);\n+}\n+\n+void\n+test_too_many_ints ()\n+{\n+  def_check_int_passing12(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, fun_check_int_passing_int12_values, fun_check_int_passing_int12_regs, int);\n+}\n+\n+void\n+test_longs_on_stack ()\n+{\n+  def_check_int_passing6(32, 33, 34, 35, 36, 37, fun_check_int_passing_long6_values, fun_check_int_passing_long6_regs, long);\n+}\n+\n+void\n+test_too_many_longs ()\n+{\n+  def_check_int_passing12(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, fun_check_int_passing_long12_values, fun_check_int_passing_long12_regs, long);\n+}\n+\n+void\n+test_int128s_on_stack ()\n+{\n+}\n+\n+void\n+test_too_many_int128s ()\n+{\n+}\n+\n+\n+int\n+main (void)\n+{\n+  test_ints_on_stack ();\n+  test_too_many_ints ();\n+  test_longs_on_stack ();\n+  test_too_many_longs ();\n+  test_int128s_on_stack ();\n+  test_too_many_int128s ();\n+  return 0;\n+}"}, {"sha": "211c700cac4b733eafd53218b80b7236881a53d2", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_structs.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,94 @@\n+/* This tests passing of structs. Only integers are tested.  */\n+\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+struct int_struct\n+{\n+  int i;\n+};\n+\n+struct long_struct\n+{\n+  long l;\n+};\n+\n+struct long2_struct\n+{\n+  long l1, l2;\n+};\n+\n+struct long3_struct\n+{\n+  long l1, l2, l3;\n+};\n+\n+\n+/* Check that the struct is passed as the individual members in iregs.  */\n+void\n+check_struct_passing1 (struct int_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing2 (struct long_struct ls ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing3 (struct long2_struct ls ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing4 (struct long3_struct ls ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ls.l1 == rsp+8);\n+  assert ((unsigned long)&ls.l2 == rsp+16);\n+  assert ((unsigned long)&ls.l3 == rsp+24);\n+}\n+\n+\n+int\n+main (void)\n+{\n+  struct int_struct is = { 48 };\n+  struct long_struct ls = { 49 };\n+#ifdef CHECK_LARGER_STRUCTS\n+  struct long2_struct l2s = { 50, 51 };\n+  struct long3_struct l3s = { 52, 53, 54 };\n+#endif\n+\n+  clear_struct_registers;\n+  iregs.I0 = is.i;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing1)(is);\n+\n+  clear_struct_registers;\n+  iregs.I0 = ls.l;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing2)(ls);\n+\n+#ifdef CHECK_LARGER_STRUCTS\n+  clear_struct_registers;\n+  iregs.I0 = l2s.l1;\n+  iregs.I1 = l2s.l2;\n+  num_iregs = 2;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing3)(l2s);\n+  WRAP_CALL (check_struct_passing4)(l3s);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "5b40196d4814056efa8160b51d17052709286d22", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_structs_and_unions.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs_and_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs_and_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_structs_and_unions.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,95 @@\n+/* This tests passing of structs. Only integers are tested.  */\n+\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+struct int_struct\n+{\n+  int i;\n+};\n+\n+struct long_struct\n+{\n+  long l;\n+};\n+\n+struct long2_struct\n+{\n+  long l1, l2;\n+};\n+\n+struct long3_struct\n+{\n+  long l1, l2, l3;\n+};\n+\n+union un1\n+{\n+  char c;\n+  int i;\n+};\n+\n+union un2\n+{\n+  char c1;\n+  long l;\n+  char c2;\n+};\n+\n+union un3\n+{\n+  struct int_struct is;\n+  struct long_struct ls;\n+  union un1 un;\n+};\n+\n+\n+void\n+check_mixed_passing1 (char c1 ATTRIBUTE_UNUSED, struct int_struct is ATTRIBUTE_UNUSED, char c2 ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_mixed_passing2 (char c1 ATTRIBUTE_UNUSED, struct long3_struct ls ATTRIBUTE_UNUSED, char c2 ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ls.l1 == rsp+8);\n+  assert ((unsigned long)&ls.l2 == rsp+16);\n+  assert ((unsigned long)&ls.l3 == rsp+24);\n+}\n+\n+int\n+main (void)\n+{\n+  struct int_struct is = { 64 };\n+#ifdef CHECK_LARGER_STRUCTS\n+  struct long3_struct l3s = { 65, 66, 67 };\n+#endif\n+\n+  clear_struct_registers;\n+  iregs.I0 = 8;\n+  iregs.I1 = 64;\n+  iregs.I2 = 9;\n+  num_iregs = 3;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_mixed_passing1)(8, is, 9);\n+\n+#ifdef CHECK_LARGER_STRUCTS \n+  clear_struct_registers;\n+  iregs.I0 = 10;\n+  iregs.I1 = 11;\n+  num_iregs = 2;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_mixed_passing2)(10, l3s, 11);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "0b6070464955af0a48b445ec45251eb86727692b", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_passing_unions.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_passing_unions.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,144 @@\n+/* This tests passing of structs. Only integers are tested.  */\n+\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+struct int_struct\n+{\n+  int i;\n+};\n+\n+struct long_struct\n+{\n+  long l;\n+};\n+\n+union un1\n+{\n+  char c;\n+  int i;\n+};\n+\n+union un2\n+{\n+  char c1;\n+  long l;\n+  char c2;\n+};\n+\n+union un3\n+{\n+  struct int_struct is;\n+  struct long_struct ls;\n+  union un1 un;\n+};\n+\n+\n+void\n+check_union_passing1(union un1 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_union_passing2(union un2 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_union_passing3(union un3 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+#define check_union_passing1 WRAP_CALL(check_union_passing1)\n+#define check_union_passing2 WRAP_CALL(check_union_passing2)\n+#define check_union_passing3 WRAP_CALL(check_union_passing3)\n+\n+int\n+main (void)\n+{\n+  union un1 u1;\n+#ifdef CHECK_LARGER_UNION_PASSING\n+  union un2 u2;\n+  union un3 u3;\n+  struct int_struct is;\n+  struct long_struct ls;\n+#endif /* CHECK_LARGER_UNION_PASSING */\n+\n+  /* Check a union with char, int.  */\n+  clear_struct_registers;\n+  u1.i = 0;  /* clear the struct to not have high bits left */\n+  u1.c = 32;\n+  iregs.I0 = 32;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing1(u1);\n+  u1.i = 0;  /* clear the struct to not have high bits left */\n+  u1.i = 33;\n+  iregs.I0 = 33;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing1(u1);\n+\n+  /* Check a union with char, long, char.  */\n+#ifdef CHECK_LARGER_UNION_PASSING\n+  clear_struct_registers;\n+  u2.l = 0;  /* clear the struct to not have high bits left */\n+  u2.c1 = 34;\n+  iregs.I0 = 34;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing2(u2);\n+  u2.l = 0;  /* clear the struct to not have high bits left */\n+  u2.l = 35;\n+  iregs.I0 = 35;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing2(u2);\n+  u2.l = 0;  /* clear the struct to not have high bits left */\n+  u2.c2 = 36;\n+  iregs.I0 = 36;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing2(u2);\n+\n+  /* check a union containing two structs and a union.  */\n+  clear_struct_registers;\n+  is.i = 37;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.is = is;\n+  iregs.I0 = 37;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+  ls.l = 38;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.ls = ls;\n+  iregs.I0 = 38;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+  u1.c = 39;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.un = u1;\n+  iregs.I0 = 39;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+  u1.i = 40;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.un = u1;\n+  iregs.I0 = 40;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+#endif /* CHECK_LARGER_UNION_PASSING */\n+\n+  return 0;\n+}"}, {"sha": "09fe710ca6cf8f02636b439a1ec2cb762dfa2338", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_struct_returning.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_struct_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_struct_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_struct_returning.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,221 @@\n+/* This tests returning of structures.  */\n+\n+#include <stdio.h>\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+int current_test;\n+int num_failed = 0;\n+\n+#undef assert\n+#define assert(test) do { if (!(test)) {fprintf (stderr, \"failed in test %d\\n\", current_test); num_failed++; } } while (0)\n+\n+#define xmm0f xmm_regs[0]._float\n+#define xmm0d xmm_regs[0]._double\n+#define xmm1f xmm_regs[1]._float\n+#define xmm1d xmm_regs[1]._double\n+\n+typedef enum {\n+  INT = 0,\n+  SSE_F,\n+  SSE_D,\n+  X87,\n+  MEM,\n+  INT_SSE,\n+  SSE_INT,\n+  SSE_F_V\n+} Type;\n+\n+/* Structures which should be returned in INTEGER.  */\n+#define D(I,MEMBERS,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = INT; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; memset (&s, 0, sizeof(s)); B; return s; }\n+\n+D(1,char m1, s.m1=42)\n+D(2,short m1, s.m1=42)\n+D(3,int m1, s.m1=42)\n+D(4,long m1, s.m1=42)\n+D(5,long long m1, s.m1=42)\n+D(6,char m1;short s, s.m1=42)\n+D(7,char m1;int i, s.m1=42)\n+D(8,char m1; long l, s.m1=42)\n+D(9,char m1; long long l, s.m1=42)\n+D(10,char m1[16], s.m1[0]=42)\n+D(11,short m1[8], s.m1[0]=42)\n+D(12,int m1[4], s.m1[0]=42)\n+D(13,long m1[2], s.m1[0]=42)\n+D(14,long long m1[2], s.m1[0]=42)\n+\n+#undef D\n+\n+/* Structures which should be returned in SSE.  */\n+#define D(I,MEMBERS,C,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = C; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; memset (&s, 0, sizeof(s)); B; return s; }\n+\n+D(100,float f,SSE_F, s.f=42)\n+D(101,double d,SSE_D, s.d=42)\n+D(102,float f;float f2,SSE_F, s.f=42)\n+D(103,float f;double d,SSE_F, s.f=42)\n+D(104,double d; float f,SSE_D, s.d=42)\n+D(105,double d; double d2,SSE_D, s.d=42)\n+D(106,float f[2],SSE_F, s.f[0]=42)\n+D(107,float f[3],SSE_F, s.f[0]=42)\n+D(108,float f[4],SSE_F, s.f[0]=42)\n+D(109,double d[2],SSE_D, s.d[0]=42)\n+D(110,float f[2]; double d,SSE_F, s.f[0]=42)\n+D(111,double d;float f[2],SSE_D, s.d=42)\n+\n+#undef D\n+\n+/* Structures which should be returned on x87 stack.  */\n+#define D(I,MEMBERS) struct S_ ## I { MEMBERS ; }; Type class_ ## I = X87; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s = { 42 }; return s; }\n+\n+/* The only struct containing a long double, which is returned in\n+   registers at all, is the singleton struct.  All others are too large.\n+   This includes a struct containing complex long double, which is passed\n+   in memory, although a complex long double type itself is returned in\n+   two registers.  */\n+D(200,long double ld)\n+\n+#undef D\n+\n+/* Structures which should be returned in INT (low) and SSE (high).  */\n+#define D(I,MEMBERS) struct S_ ## I { MEMBERS ; }; Type class_ ## I = INT_SSE; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s = { 42,43 }; return s; }\n+\n+D(300,char m1; float m2)\n+D(301,char m1; double m2)\n+D(302,short m1; float m2)\n+D(303,short m1; double m2)\n+D(304,int m1; float m2)\n+D(305,int m1; double m2)\n+D(306,long m1; float m2)\n+D(307,long m1; double m2)\n+\n+#undef D\n+\n+void check_300 (void)\n+{\n+  XMM_T x;\n+  x._ulong[0] = rax;\n+  switch (current_test) {\n+    case 300: assert ((rax & 0xff) == 42 && x._float[1] == 43); break;\n+    case 301: assert ((rax & 0xff) == 42 && xmm0d[0] == 43); break;\n+    case 302: assert ((rax & 0xffff) == 42 && x._float[1] == 43); break;\n+    case 303: assert ((rax & 0xffff) == 42 && xmm0d[0] == 43); break;\n+    case 304: assert ((rax & 0xffffffff) == 42 && x._float[1] == 43); break;\n+    case 305: assert ((rax & 0xffffffff) == 42 && xmm0d[0] == 43); break;\n+    case 306: assert (rax == 42 && xmm0f[0] == 43); break;\n+    case 307: assert (rax == 42 && xmm0d[0] == 43); break;\n+    default: assert (0); break;\n+  }\n+}\n+\n+/* Structures which should be returned in SSE (low) and INT (high).  */\n+#define D(I,MEMBERS,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = SSE_INT; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; memset (&s, 0, sizeof(s));  B; return s; }\n+\n+D(400,float f[2];char c, s.f[0]=42; s.c=43)\n+D(401,double d;char c, s.d=42; s.c=43)\n+\n+#undef D\n+\n+void check_400 (void)\n+{\n+  switch (current_test) {\n+    case 400: assert (xmm0f[0] == 42 && (rax & 0xff) == 43); break;\n+    case 401: assert (xmm0d[0] == 42 && (rax & 0xff) == 43); break;\n+    default: assert (0); break;\n+  }\n+}\n+\n+/* Structures which should be returned in MEM.  */\n+void *struct_addr;\n+#define D(I,MEMBERS) struct S_ ## I { MEMBERS ; }; Type class_ ## I = MEM; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; memset (&s, 0, sizeof(s)); s.m1[0] = 42; return s; }\n+\n+/* Too large.  */\n+D(500,char m1[17])\n+D(501,short m1[9])\n+D(502,int m1[5])\n+D(503,long m1[3])\n+D(504,short m1[8];char c)\n+D(505,char m1[1];int i[4])\n+D(506,float m1[5])\n+D(507,double m1[3])\n+D(508,char m1[1];float f[4])\n+D(509,char m1[1];double d[2])\n+D(510,__complex long double m1[1])\n+\n+/* Too large due to padding.  */\n+D(520,char m1[1];int i;char c2; int i2; char c3)\n+\n+/* Unnaturally aligned members.  */\n+D(530,short m1[1];int i PACKED)\n+\n+#undef D\n+\n+\n+/* Special tests.  */\n+#define D(I,MEMBERS,C,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = C; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; B; return s; }\n+D(600,float f[4], SSE_F_V, s.f[0] = s.f[1] = s.f[2] = s.f[3] = 42)\n+#undef D\n+\n+void clear_all (void)\n+{\n+  clear_int_registers;\n+  clear_float_registers;\n+  clear_x87_registers;\n+}\n+\n+void check_all (Type class, unsigned long size)\n+{\n+  switch (class) {\n+    case INT: if (size < 8) rax &= ~0UL >> (64-8*size); assert (rax == 42); break;\n+    case SSE_F: assert (xmm0f[0] == 42); break;\n+    case SSE_D: assert (xmm0d[0] == 42); break;\n+    case SSE_F_V: assert (xmm0f[0] == 42 && xmm0f[1]==42 && xmm1f[0] == 42 && xmm1f[1] == 42); break;\n+    case X87: assert (x87_regs[0]._ldouble == 42); break;\n+    case INT_SSE: check_300(); break;\n+    case SSE_INT: check_400(); break;\n+    case MEM: assert (rax == (unsigned long)struct_addr && rdi == rax); break;\n+  }\n+}\n+\n+#define D(I) { struct S_ ## I s; current_test = I; struct_addr = (void*)&s; \\\n+  clear_all(); \\\n+  s = WRAP_RET(f_ ## I) (); \\\n+  check_all(class_ ## I, sizeof(s)); \\\n+}\n+\n+int\n+main (void)\n+{\n+  D(1) D(2) D(3) D(4) D(5) D(6) D(7) D(8) D(9) D(10) D(11) D(12) D(13) D(14)\n+  \n+  D(100) D(101) D(102) D(103) D(104) D(105) D(106) D(107) D(108) D(109) D(110)\n+  D(111)\n+\n+  D(200)\n+\n+  D(300) D(301) D(302) D(303) D(304) D(305) D(306) D(307)\n+\n+  D(400) D(401)\n+\n+  D(500) D(501) D(502) D(503) D(504) D(505) D(506) D(507) D(508) D(509)\n+  D(520)\n+  D(530)\n+\n+  D(600)\n+  if (num_failed)\n+    abort ();\n+\n+  return 0;\n+}\n+#undef D"}, {"sha": "e6d99461d2c4020b9d24d5dbc00973b1fb074111", "filename": "gcc/testsuite/gcc.target/x86_64/abi/test_varargs.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_varargs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacb35127936fd17dd160595f59fca6cd2b81b0e/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_varargs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Ftest_varargs.c?ref=aacb35127936fd17dd160595f59fca6cd2b81b0e", "patch": "@@ -0,0 +1,97 @@\n+/* Test variable number of arguments passed to functions. For now this is\n+   just a simple test to see if it's working.  */\n+\n+#include <stdarg.h>\n+#include \"defines.h\"\n+\n+\n+#define ARG_INT     1\n+#define ARG_DOUBLE  2\n+#define ARG_POINTER 3\n+\n+union types\n+{\n+  int ivalue;\n+  double dvalue;\n+  void *pvalue;\n+};\n+\n+struct arg\n+{\n+  int type;\n+  union types value;\n+};\n+\n+struct arg *arglist;\n+\n+/* This tests the argumentlist to see if it matches the format string which\n+   is printf-like. Nothing will be printed of course. It can handle ints,\n+   doubles and void pointers. The given value will be tested against the\n+   values given in arglist.  \n+   This test only assures that the variable argument passing is working.\n+   No attempt is made to see if argument passing is done the right way.\n+   Since the ABI doesn't say how it's done, checking this is not really\n+   relevant.  */\n+void\n+my_noprintf (char *format, ...)\n+{\n+  va_list va_arglist;\n+  char *c;\n+\n+  int ivalue;\n+  double dvalue;\n+  void *pvalue;\n+  struct arg *argp = arglist;\n+\n+  va_start (va_arglist, format);\n+  for (c = format; *c; c++)\n+    if (*c == '%')\n+      {\n+\tswitch (*++c)\n+\t  {\n+\t  case 'd':\n+\t    assert (argp->type == ARG_INT);\n+\t    ivalue = va_arg (va_arglist, int);\n+\t    assert (argp->value.ivalue == ivalue);\n+\t    break;\n+\t  case 'f':\n+\t    assert (argp->type == ARG_DOUBLE);\n+\t    dvalue = va_arg (va_arglist, double);\n+\t    assert (argp->value.dvalue == dvalue);\n+\t    break;\n+\t  case 'p':\n+\t    assert (argp->type == ARG_POINTER);\n+\t    pvalue = va_arg (va_arglist, void *);\n+\t    assert (argp->value.pvalue == pvalue);\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\n+\targp++;\n+      }\n+}\n+\n+int\n+main (void)\n+{\n+#ifdef CHECK_VARARGS\n+  struct arg al[5];\n+\n+  al[0].type = ARG_INT;\n+  al[0].value.ivalue = 256;\n+  al[1].type = ARG_DOUBLE;\n+  al[1].value.dvalue = 257.0;\n+  al[2].type = ARG_POINTER;\n+  al[2].value.pvalue = al;\n+  al[3].type = ARG_DOUBLE;\n+  al[3].value.dvalue = 258.0;\n+  al[4].type = ARG_INT;\n+  al[4].value.ivalue = 259;\n+\n+  arglist = al;\n+  my_noprintf(\"%d%f%p%f%d\", 256, 257.0, al, 258.0, 259);\n+#endif\n+\n+  return 0;\n+}"}]}