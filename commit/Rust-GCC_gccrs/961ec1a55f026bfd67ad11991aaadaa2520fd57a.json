{"sha": "961ec1a55f026bfd67ad11991aaadaa2520fd57a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYxZWMxYTU1ZjAyNmJmZDY3YWQxMTk5MWFhYWRhYTI1MjBmZDU3YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-05-20T02:46:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-05-20T02:46:16Z"}, "message": "decl2.c (start_objects, [...]): Split out from...\n\n\t* decl2.c (start_objects, finish_objects, do_dtors,\n\tdo_ctors): Split out from...\n\t(finish_file): ...here.\n\nFrom-SVN: r19904", "tree": {"sha": "afd518bdd509f86fff49f0814bb2404e4e574a6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afd518bdd509f86fff49f0814bb2404e4e574a6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/961ec1a55f026bfd67ad11991aaadaa2520fd57a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961ec1a55f026bfd67ad11991aaadaa2520fd57a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/961ec1a55f026bfd67ad11991aaadaa2520fd57a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961ec1a55f026bfd67ad11991aaadaa2520fd57a/comments", "author": null, "committer": null, "parents": [{"sha": "2a3215614b78469bb6cae5c0e2c5803921101136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3215614b78469bb6cae5c0e2c5803921101136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3215614b78469bb6cae5c0e2c5803921101136"}], "stats": {"total": 411, "additions": 214, "deletions": 197}, "files": [{"sha": "101b598641588dfbf45ad44c29eab747d85e0d0f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961ec1a55f026bfd67ad11991aaadaa2520fd57a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961ec1a55f026bfd67ad11991aaadaa2520fd57a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=961ec1a55f026bfd67ad11991aaadaa2520fd57a", "patch": "@@ -1,3 +1,9 @@\n+Wed May 20 02:16:01 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (start_objects, finish_objects, do_dtors,\n+\tdo_ctors): Split out from...\n+\t(finish_file): ...here.\n+\n Tue May 19 20:36:23 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tree.c (is_overloaded_fn): Don't abort on placeholders from\n@@ -65,10 +71,6 @@ Tue May 19 02:43:25 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n Mon May 18 23:22:52 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n-\t* decl2.c (setup_initp, start_objects, finish_objects): New fns.\n-\t(do_dtors, do_ctors): Split out from...\n-\t(finish_file): ...here.  Support init_priority.\n-\n \t* decl2.c (get_sentry): Use end_temporary_allocation.\n \tDon't declare permanent_obstack.\n \n@@ -9610,10 +9612,3 @@ Wed Oct 11 16:30:34 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* parse.y (fn.def1): Call split_specs_attrs in\n \tdeclmods notype_declarator case.\n-\f\n-Use a consistent time stamp format in ChangeLog entries.\n-Not everyone has Emacs 20 yet, so stick with Emacs 19 format for now.\n-\n-Local Variables:\n-add-log-time-format: current-time-string\n-End:"}, {"sha": "a57bc3c40ed509e4fcb4b68245b1f93070737d6e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961ec1a55f026bfd67ad11991aaadaa2520fd57a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961ec1a55f026bfd67ad11991aaadaa2520fd57a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=961ec1a55f026bfd67ad11991aaadaa2520fd57a", "patch": "@@ -3926,12 +3926,10 @@ compare_ics (ics1, ics2)\n       if (is_subseq (ics2, ics1))\n \treturn -1;\n     }\n-  else\n-    /* One sequence cannot be a subsequence of the other; they don't\n-       start with the same type.  This can happen when comparing the\n-       second standard conversion sequence in two user-defined\n-       conversion sequences.  */\n-    ;\n+  /* Otherwise, one sequence cannot be a subsequence of the other; they\n+     don't start with the same type.  This can happen when comparing the\n+     second standard conversion sequence in two user-defined conversion\n+     sequences.  */\n \n   /* [over.ics.rank]\n "}, {"sha": "57e3def6d9d3d1984ba7627fb10de26d98fab5fb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 204, "deletions": 180, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961ec1a55f026bfd67ad11991aaadaa2520fd57a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961ec1a55f026bfd67ad11991aaadaa2520fd57a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=961ec1a55f026bfd67ad11991aaadaa2520fd57a", "patch": "@@ -2800,6 +2800,204 @@ get_sentry (base)\n   return sentry;\n }\n \n+/* Start the process of running a particular set of global constructors\n+   or destructors.  Subroutine of do_[cd]tors.  */\n+\n+static void\n+start_objects (method_type)\n+     int method_type;\n+{\n+  tree fnname;\n+\n+  /* Make ctor or dtor function.  METHOD_TYPE may be 'I' or 'D'.  */\n+\n+  fnname = get_file_function_name (method_type);\n+\n+  start_function (void_list_node,\n+\t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n+\t\t\t\t\tNULL_TREE),\n+\t\t  NULL_TREE, 0);\n+\n+  store_parm_decls ();\n+  pushlevel (0);\n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n+}\n+\n+/* Finish the process of running a particular set of global constructors\n+   or destructors.  Subroutine of do_[cd]tors.  */\n+\n+static void\n+finish_objects (method_type)\n+     int method_type;\n+{\n+  char *fnname;\n+\n+  tree list = (method_type == 'I' ? static_ctors : static_dtors);\n+\n+  if (! current_function_decl && list)\n+    start_objects (method_type);\n+\n+  for (; list; list = TREE_CHAIN (list))\n+    expand_expr_stmt (build_function_call (TREE_VALUE (list), NULL_TREE));\n+\n+  if (! current_function_decl)\n+    return;\n+\n+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+\n+  /* Finish up. */\n+  expand_end_bindings (getdecls (), 1, 0);\n+  poplevel (1, 0, 0);\n+  pop_momentary ();\n+  finish_function (lineno, 0, 0);\n+\n+  if (method_type == 'I')\n+    assemble_constructor (fnname);\n+  else\n+    assemble_destructor (fnname);\n+}\n+\n+/* Generate a function to run a set of global destructors.  Subroutine of\n+   finish_file.  */\n+\n+static void\n+do_dtors ()\n+{\n+  tree vars = static_aggregates;\n+\n+  for (; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree decl = TREE_VALUE (vars);\n+      tree type = TREE_TYPE (decl);\n+      tree temp;\n+\n+      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars)\n+\t  && ! DECL_EXTERNAL (decl))\n+\t{\n+\t  int protect = (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n+\t\t\t\t\t\t|| DECL_ONE_ONLY (decl)\n+\t\t\t\t\t\t|| DECL_WEAK (decl)));\n+\n+\t  if (! current_function_decl)\n+\t    start_objects ('D');\n+\n+\t  temp = build_cleanup (decl);\n+\n+\t  if (protect)\n+\t    {\n+\t      tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+\t      sentry = build_unary_op (PREDECREMENT_EXPR, sentry, 0);\n+\t      sentry = build_binary_op (EQ_EXPR, sentry, integer_zero_node, 1);\n+\t      expand_start_cond (sentry, 0);\n+\t    }\n+\n+\t  expand_expr_stmt (temp);\n+\n+\t  if (protect)\n+\t    expand_end_cond ();\n+\t}\n+    }\n+\n+  finish_objects ('D');\n+}\n+\n+/* Generate a function to run a set of global constructors.  Subroutine of\n+   finish_file.  */\n+\n+static void\n+do_ctors ()\n+{\n+  tree vars = static_aggregates;\n+\n+  /* Reverse the list so it's in the right order for ctors.  */\n+  vars = nreverse (vars);\n+\n+  for (; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree decl = TREE_VALUE (vars);\n+      tree init = TREE_PURPOSE (vars);\n+\n+      /* If this was a static attribute within some function's scope,\n+\t then don't initialize it here.  Also, don't bother\n+\t with initializers that contain errors.  */\n+      if (TREE_STATIC (vars)\n+\t  || DECL_EXTERNAL (decl)\n+\t  || (init && TREE_CODE (init) == TREE_LIST\n+\t      && value_member (error_mark_node, init)))\n+\tcontinue;\n+\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\t{\n+\t  int protect = (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n+\t\t\t\t\t\t|| DECL_ONE_ONLY (decl)\n+\t\t\t\t\t\t|| DECL_WEAK (decl)));\n+\n+\t  if (! current_function_decl)\n+\t    start_objects ('I');\n+\n+\t  /* Set these global variables so that GDB at least puts\n+\t     us near the declaration which required the initialization.  */\n+\t  input_filename = DECL_SOURCE_FILE (decl);\n+\t  lineno = DECL_SOURCE_LINE (decl);\n+\t  emit_note (input_filename, lineno);\n+\n+\t  /* 9.5p5: The initializer of a static member of a class has\n+\t     the same access rights as a member function.  */\n+\t  if (member_p (decl))\n+\t    {\n+\t      DECL_CLASS_CONTEXT (current_function_decl)\n+\t\t= DECL_CONTEXT (decl);\n+\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n+\t    }\n+\n+\t  if (protect)\n+\t    {\n+\t      tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n+\t      sentry = build_unary_op (PREINCREMENT_EXPR, sentry, 0);\n+\t      sentry = build_binary_op\n+\t\t(EQ_EXPR, sentry, integer_one_node, 1);\n+\t      expand_start_cond (sentry, 0);\n+\t    }\n+\n+\t  expand_start_target_temps ();\n+\n+\t  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n+\t      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\t    expand_aggr_init (decl, init, 0, 0);\n+\t  else if (TREE_CODE (init) == TREE_VEC)\n+\t    {\n+\t      expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n+\t\t\t\t\t    TREE_VEC_ELT (init, 1),\n+\t\t\t\t\t    TREE_VEC_ELT (init, 2), 0),\n+\t\t\t   const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n+\t  else\n+\t    expand_assignment (decl, init, 0, 0);\n+\t      \n+\t  /* The expression might have involved increments and\n+\t     decrements.  */\n+\t  emit_queue ();\n+\n+\t  /* Cleanup any temporaries needed for the initial value.  */\n+\t  expand_end_target_temps ();\n+\n+\t  if (protect)\n+\t    expand_end_cond ();\n+\n+\t  DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n+\t  DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n+\t}\n+      else if (decl == error_mark_node)\n+\t/* OK */;\n+      else\n+\tmy_friendly_abort (22);\n+    }\n+\n+  finish_objects ('I');\n+}\n+\n /* This routine is called from the last rule in yyparse ().\n    Its job is to create all the code needed to initialize and\n    destroy the global aggregates.  We do the destruction\n@@ -2901,193 +3099,19 @@ finish_file ()\n \n   if (static_ctors || vars)\n     needs_messing_up = 1;\n-  if (static_dtors)\n+  if (static_dtors || vars)\n     needs_cleaning = 1;\n \n-  /* See if we really need the hassle.  */\n-  while (vars && needs_cleaning == 0)\n-    {\n-      tree decl = TREE_VALUE (vars);\n-      tree type = TREE_TYPE (decl);\n-      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars))\n-\t{\n-\t  needs_cleaning = 1;\n-\t  break;\n-\t}\n-\n-      vars = TREE_CHAIN (vars);\n-    }\n-\n-  if (needs_cleaning == 0)\n-    goto mess_up;\n-\n-  fnname = get_file_function_name ('D');\n-  start_function (void_list_node,\n-\t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n-\t\t\t\t\tNULL_TREE),\n-\t\t  NULL_TREE, 0);\n-  fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n-  store_parm_decls ();\n-\n-  pushlevel (0);\n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n-\n-  /* These must be done in backward order to destroy,\n-     in which they happen to be!  */\n-  for (vars = static_aggregates; vars; vars = TREE_CHAIN (vars))\n+  /* The aggregates are listed in reverse declaration order, for cleaning.  */\n+  if (needs_cleaning)\n     {\n-      tree decl = TREE_VALUE (vars);\n-      tree type = TREE_TYPE (decl);\n-      tree temp = TREE_PURPOSE (vars);\n-\n-      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars)\n-\t  && ! DECL_EXTERNAL (decl))\n-\t{\n-\t  int protect = (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n-\t\t\t\t\t\t|| DECL_ONE_ONLY (decl)\n-\t\t\t\t\t\t|| DECL_WEAK (decl)));\n-\n-\t  temp = build_cleanup (decl);\n-\n-\t  if (protect)\n-\t    {\n-\t      tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n-\t      sentry = build_unary_op (PREDECREMENT_EXPR, sentry, 0);\n-\t      sentry = build_binary_op (EQ_EXPR, sentry, integer_zero_node, 1);\n-\t      expand_start_cond (sentry, 0);\n-\t    }\n-\n-\t  expand_expr_stmt (temp);\n-\n-\t  if (protect)\n-\t    expand_end_cond ();\n-\t}\n+      do_dtors ();\n     }\n \n-  for (; static_dtors; static_dtors = TREE_CHAIN (static_dtors))\n-    expand_expr_stmt (build_function_call (TREE_VALUE (static_dtors),\n-\t\t\t\t\t   NULL_TREE));\n-      \n-  expand_end_bindings (getdecls (), 1, 0);\n-  poplevel (1, 0, 0);\n-  pop_momentary ();\n-\n-  finish_function (lineno, 0, 0);\n-\n-  assemble_destructor (IDENTIFIER_POINTER (fnname));\n-\n-  /* If it needed cleaning, then it will need messing up: drop through.  */\n-\n- mess_up:\n-  /* Must do this while we think we are at the top level.  */\n-  vars = nreverse (static_aggregates);\n+  /* do_ctors will reverse the lists for messing up.  */\n   if (needs_messing_up)\n     {\n-      fnname = get_file_function_name ('I');\n-      start_function (void_list_node,\n-\t\t      make_call_declarator (fnname, void_list_node, NULL_TREE,\n-\t\t\t\t\t    NULL_TREE),\n-\t\t      NULL_TREE, 0);\n-      fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n-      store_parm_decls ();\n-\n-      pushlevel (0);\n-      clear_last_expr ();\n-      push_momentary ();\n-      expand_start_bindings (0);\n-\n-      while (vars)\n-\t{\n-\t  tree decl = TREE_VALUE (vars);\n-\t  tree init = TREE_PURPOSE (vars);\n-\n-\t  /* If this was a static attribute within some function's scope,\n-\t     then don't initialize it here.  Also, don't bother\n-\t     with initializers that contain errors.  */\n-\t  if (TREE_STATIC (vars)\n-\t      || DECL_EXTERNAL (decl)\n-\t      || (init && TREE_CODE (init) == TREE_LIST\n-\t\t  && value_member (error_mark_node, init)))\n-\t    goto next_mess;\n-\n-\t  if (TREE_CODE (decl) == VAR_DECL)\n-\t    {\n-\t      int protect = (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n-\t\t\t\t\t\t    || DECL_ONE_ONLY (decl)\n-\t\t\t\t\t\t    || DECL_WEAK (decl)));\n-\n-\t      /* Set these global variables so that GDB at least puts\n-\t\t us near the declaration which required the initialization.  */\n-\t      input_filename = DECL_SOURCE_FILE (decl);\n-\t      lineno = DECL_SOURCE_LINE (decl);\n-\t      emit_note (input_filename, lineno);\n-\n-\t      /* 9.5p5: The initializer of a static member of a class has\n-\t\t the same access rights as a member function.  */\n-\t      if (member_p (decl))\n-\t\t{\n-\t\t  DECL_CLASS_CONTEXT (current_function_decl)\n-\t\t    = DECL_CONTEXT (decl);\n-\t\t  DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n-\t\t}\n-\n-\t      if (protect)\n-\t\t{\n-\t\t  tree sentry = get_sentry (DECL_ASSEMBLER_NAME (decl));\n-\t\t  sentry = build_unary_op (PREINCREMENT_EXPR, sentry, 0);\n-\t\t  sentry = build_binary_op\n-\t\t    (EQ_EXPR, sentry, integer_one_node, 1);\n-\t\t  expand_start_cond (sentry, 0);\n-\t\t}\n-\n-\t      expand_start_target_temps ();\n-\n-\t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n-\t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t\texpand_aggr_init (decl, init, 0, 0);\n-\t      else if (TREE_CODE (init) == TREE_VEC)\n-\t\t{\n-\t\t  expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n-\t\t\t\t\t\tTREE_VEC_ELT (init, 1),\n-\t\t\t\t\t\tTREE_VEC_ELT (init, 2), 0),\n-\t\t\t       const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t\t}\n-\t      else\n-\t\texpand_assignment (decl, init, 0, 0);\n-\t      \n-\t      /* The expression might have involved increments and\n-\t\t decrements.  */\n-\t      emit_queue ();\n-\n-\t      /* Cleanup any temporaries needed for the initial value.  */\n-\t      expand_end_target_temps ();\n-\n-\t      if (protect)\n-\t\texpand_end_cond ();\n-\n-\t      DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n-\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n-\t    }\n-\t  else if (decl == error_mark_node)\n-\t    ;\n-\t  else my_friendly_abort (22);\n-\n-\tnext_mess:\n-\t  vars = TREE_CHAIN (vars);\n-\t}\n-\n-      for (; static_ctors; static_ctors = TREE_CHAIN (static_ctors))\n-\texpand_expr_stmt (build_function_call (TREE_VALUE (static_ctors),\n-\t\t\t\t\t       NULL_TREE));\n-      \n-      expand_end_bindings (getdecls (), 1, 0);\n-      poplevel (1, 0, 0);\n-      pop_momentary ();\n-\n-      finish_function (lineno, 0, 0);\n-      assemble_constructor (IDENTIFIER_POINTER (fnname));\n+      do_ctors ();\n     }\n \n   permanent_allocation (1);"}]}