{"sha": "7e825da03edc82020de4d245b22fb123f5e976d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4MjVkYTAzZWRjODIwMjBkZTRkMjQ1YjIyZmIxMjNmNWU5NzZkOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-12-13T07:59:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-12-13T07:59:01Z"}, "message": "struct-layout-1.exp: Do not link with libiberty.\n\n\t* g++.dg/compat/struct-layout-1.exp: Do not link with libiberty.\n\t* g++.dg/compat/struct-layout-1_generate.c (config.h): Do not include.\n\t(limits.h): Include unconditionally.\n\t(stdlib.h): Likewise.\n\t(hashtab.h): Do not include.\n\t(getopt.h): Likewise.\n\t(stddef.h): Include.\n\t(hashval_t): Define.\n\t(struct entry): Add \"next\" field.\n\t(HASH_SIZE): New macro.\n\t(hash_table): New variable.\n\t(switchfiles): Do not use xmalloc.\n\t(mix): New macro.\n\t(iterative_hash): New function.\n\t(hasht): Remove.\n\t(e_exists): New function.\n\t(e_insert): Likewise.\n\t(output): Use, instead of libiberty hashtable functions.\n\t(main): Do not use getopt.  Do not call htab_create.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r108461", "tree": {"sha": "089cfdd0fe97d0b89fb33c6c4b21b49a92036670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/089cfdd0fe97d0b89fb33c6c4b21b49a92036670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e825da03edc82020de4d245b22fb123f5e976d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e825da03edc82020de4d245b22fb123f5e976d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e825da03edc82020de4d245b22fb123f5e976d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e825da03edc82020de4d245b22fb123f5e976d8/comments", "author": null, "committer": null, "parents": [{"sha": "e2796397694a9bf221c808d7e8af297c45918e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2796397694a9bf221c808d7e8af297c45918e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2796397694a9bf221c808d7e8af297c45918e88"}], "stats": {"total": 262, "additions": 219, "deletions": 43}, "files": [{"sha": "9bde74d9640a7ea548acdf4cdf552fcc38c817ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e825da03edc82020de4d245b22fb123f5e976d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e825da03edc82020de4d245b22fb123f5e976d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e825da03edc82020de4d245b22fb123f5e976d8", "patch": "@@ -1,4 +1,25 @@\n-2005-12-13  Jakub Jelinek  <jakub@redhat.com>\n+2005-12-13  Mark Mitchell  <mark@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/compat/struct-layout-1.exp: Do not link with libiberty.\n+\t* g++.dg/compat/struct-layout-1_generate.c (config.h): Do not include.\n+\t(limits.h): Include unconditionally.\n+\t(stdlib.h): Likewise.\n+\t(hashtab.h): Do not include.\n+\t(getopt.h): Likewise.\n+\t(stddef.h): Include.\n+\t(hashval_t): Define.\n+\t(struct entry): Add \"next\" field.\n+\t(HASH_SIZE): New macro.\n+\t(hash_table): New variable.\n+\t(switchfiles): Do not use xmalloc.\n+\t(mix): New macro.\n+\t(iterative_hash): New function.\n+\t(hasht): Remove.\n+\t(e_exists): New function.\n+\t(e_insert): Likewise.\n+\t(output): Use, instead of libiberty hashtable functions.\n+\t(main): Do not use getopt.  Do not call htab_create.\n \n \tPR c++/25331\n \t* gcc.dg/compat/struct-layout-1_generate.c (subfield): Don't"}, {"sha": "e0a13f7d100a1f7717f5b5bac034b51ab2471bba", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1.exp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e825da03edc82020de4d245b22fb123f5e976d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e825da03edc82020de4d245b22fb123f5e976d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.exp?ref=7e825da03edc82020de4d245b22fb123f5e976d8", "patch": "@@ -127,10 +127,7 @@ set generator \"$tmpdir/g++.dg-struct-layout-1_generate\"\n set generator_src \"$srcdir/$subdir/struct-layout-1_generate.c\"\n set generator_src \"$generator_src $srcdir/$subdir/../../gcc.dg/compat/generate-random.c\"\n set generator_src \"$generator_src $srcdir/$subdir/../../gcc.dg/compat/generate-random_r.c\"\n-set generator_inc \"-I$srcdir/$subdir -I$srcdir/../../include\"\n-set generator_inc \"$generator_inc -I$rootme/../libiberty\"\n-set generator_lib \"-L$rootme/../libiberty -liberty\"\n-set generator_cmd \"-o $generator $generator_src $generator_inc $generator_lib\"\n+set generator_cmd \"-o $generator $generator_src\"\n \n set status [remote_exec host \"$HOSTCC $HOSTCFLAGS $generator_cmd\"]\n set status [lindex $status 0]"}, {"sha": "a2aba71ba8e6019fd7678a816ff1fbe31144f437", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 196, "deletions": 38, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e825da03edc82020de4d245b22fb123f5e976d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e825da03edc82020de4d245b22fb123f5e976d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=7e825da03edc82020de4d245b22fb123f5e976d8", "patch": "@@ -19,23 +19,15 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-/* Compile with gcc -I$(srcdir)/../include -{I,L}$(objdir)/../libiberty/ \\\n-   -o struct-layout-1_generate{,.c} generate_random{,_r}.c -liberty */\n+/* Compile with gcc -o struct-layout-1_generate{,.c} generate_random{,_r}.c */\n \n-#include \"config.h\"\n-#ifdef HAVE_LIMITS_H\n+/* N.B. -- This program cannot use libiberty as that will not work\n+   when testing an installed compiler.  */\n #include <limits.h>\n-#endif\n-#include \"libiberty.h\"\n #include <stdio.h>\n-#ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n-#endif\n-#ifdef HAVE_STRING_H\n #include <string.h>\n-#endif\n-#include \"hashtab.h\"\n-#include \"getopt.h\"\n+#include <stddef.h>\n /* We use our own pseudo-random number generator, so that it gives the same\n    values on all hosts.  */\n #include \"../../gcc.dg/compat/generate-random.h\"\n@@ -44,6 +36,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n # error Need 64-bit long long\n #endif\n \n+typedef unsigned int hashval_t;\n+\n enum TYPE\n {\n   TYPE_INT,\n@@ -390,6 +384,8 @@ struct entry\n   unsigned char arr_len;\n   struct types *type;\n   const char *attrib;\n+  /* Used to chain together entries in the hash table.  */\n+  struct entry *next;\n };\n struct types attrib_array_types[] = {\n { \"Talx1char\", TYPE_UINT, 127, 'C' },\n@@ -478,6 +474,10 @@ struct types attrib_array_types[] = {\n #define NAATYPES2 (sizeof (attrib_array_types) / sizeof (attrib_array_types[0]))\n };\n \n+/* A prime number giving the number of slots in the hash table.  */\n+#define HASH_SIZE 32749\n+static struct entry *hash_table[HASH_SIZE];\n+\n static int idx, limidx, output_one;\n static const char *destdir;\n static const char *srcdir;\n@@ -499,7 +499,9 @@ switchfiles (int fields)\n   if (destbuf == NULL)\n     {\n       size_t len = strlen (destdir);\n-      destbuf = xmalloc (len + 20);\n+      destbuf = malloc (len + 20);\n+      if (!destbuf)\n+\tabort ();\n       memcpy (destbuf, destdir, len);\n       if (!len || destbuf[len - 1] != '/')\n \tdestbuf[len++] = '/';\n@@ -916,6 +918,130 @@ subvalues (struct entry *e, char *p, char *letter)\n     }\n }\n \n+/* DERIVED FROM:\n+--------------------------------------------------------------------\n+lookup2.c, by Bob Jenkins, December 1996, Public Domain.\n+hash(), hash2(), hash3, and mix() are externally useful functions.\n+Routines to test the hash are included if SELF_TEST is defined.\n+You can use this free for any purpose.  It has no warranty.\n+--------------------------------------------------------------------\n+*/\n+\n+/*\n+--------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+For every delta with one or two bit set, and the deltas of all three\n+  high bits or all three low bits, whether the original value of a,b,c\n+  is almost all zero or is uniformly distributed,\n+* If mix() is run forward or backward, at least 32 bits in a,b,c\n+  have at least 1/4 probability of changing.\n+* If mix() is run forward, every bit of c will change between 1/3 and\n+  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)\n+mix() was built out of 36 single-cycle latency instructions in a \n+  structure that could supported 2x parallelism, like so:\n+      a -= b; \n+      a -= c; x = (c>>13);\n+      b -= c; a ^= x;\n+      b -= a; x = (a<<8);\n+      c -= a; b ^= x;\n+      c -= b; x = (b>>13);\n+      ...\n+  Unfortunately, superscalar Pentiums and Sparcs can't take advantage \n+  of that parallelism.  They've also turned some of those single-cycle\n+  latency instructions into multi-cycle latency instructions.  Still,\n+  this is the fastest good hash I could find.  There were about 2^^68\n+  to choose from.  I only looked at a billion or so.\n+--------------------------------------------------------------------\n+*/\n+/* same, but slower, works on systems that might have 8 byte hashval_t's */\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= b; a -= c; a ^= (c>>13); \\\n+  b -= c; b -= a; b ^= (a<< 8); \\\n+  c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \\\n+  a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \\\n+  b -= c; b -= a; b = (b ^ (a<<16)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>> 5)) & 0xffffffff; \\\n+  a -= b; a -= c; a = (a ^ (c>> 3)) & 0xffffffff; \\\n+  b -= c; b -= a; b = (b ^ (a<<10)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>>15)) & 0xffffffff; \\\n+}\n+\n+/*\n+--------------------------------------------------------------------\n+hash() -- hash a variable-length key into a 32-bit value\n+  k     : the key (the unaligned variable-length array of bytes)\n+  len   : the length of the key, counting by bytes\n+  level : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Every 1-bit and 2-bit delta achieves avalanche.\n+About 36+6len instructions.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (ub1 **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);\n+\n+By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+See http://burtleburtle.net/bob/hash/evahash.html\n+Use for hash table lookup, or anything where one collision in 2^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+--------------------------------------------------------------------\n+*/\n+\n+static hashval_t\n+iterative_hash (const void *k_in /* the key */,\n+\t\tregister size_t  length /* the length of the key */,\n+\t\tregister hashval_t initval /* the previous hash, or\n+\t\t\t\t\t      an arbitrary value */)\n+{\n+  register const unsigned char *k = (const unsigned char *)k_in;\n+  register hashval_t a,b,c,len;\n+\n+  /* Set up the internal state */\n+  len = length;\n+  a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */\n+  c = initval;\t   /* the previous hash value */\n+\n+  /*---------------------------------------- handle most of the key */\n+    while (len >= 12)\n+      {\n+\ta += (k[0] +((hashval_t)k[1]<<8) +((hashval_t)k[2]<<16) +((hashval_t)k[3]<<24));\n+\tb += (k[4] +((hashval_t)k[5]<<8) +((hashval_t)k[6]<<16) +((hashval_t)k[7]<<24));\n+\tc += (k[8] +((hashval_t)k[9]<<8) +((hashval_t)k[10]<<16)+((hashval_t)k[11]<<24));\n+\tmix(a,b,c);\n+\tk += 12; len -= 12;\n+      }\n+\n+  /*------------------------------------- handle the last 11 bytes */\n+  c += length;\n+  switch(len)\t      /* all the case statements fall through */\n+    {\n+    case 11: c+=((hashval_t)k[10]<<24);\n+    case 10: c+=((hashval_t)k[9]<<16);\n+    case 9 : c+=((hashval_t)k[8]<<8);\n+      /* the first byte of c is reserved for the length */\n+    case 8 : b+=((hashval_t)k[7]<<24);\n+    case 7 : b+=((hashval_t)k[6]<<16);\n+    case 6 : b+=((hashval_t)k[5]<<8);\n+    case 5 : b+=k[4];\n+    case 4 : a+=((hashval_t)k[3]<<24);\n+    case 3 : a+=((hashval_t)k[2]<<16);\n+    case 2 : a+=((hashval_t)k[1]<<8);\n+    case 1 : a+=k[0];\n+      /* case 0: nothing left to add */\n+    }\n+  mix(a,b,c);\n+  /*-------------------------------------------- report the result */\n+  return c;\n+}\n+\n hashval_t\n e_hash (const void *a)\n {\n@@ -961,24 +1087,45 @@ e_eq (const void *a, const void *b)\n   return 1;\n }\n \n-htab_t hasht;\n+static int \n+e_exists (const struct entry *e) \n+{\n+  struct entry *h;\n+  hashval_t hval;\n+\n+  hval = e_hash (e);\n+  for (h = hash_table[hval % HASH_SIZE]; h; h = h->next)\n+    if (e_eq (e, h))\n+      return 1;\n+  return 0;\n+}\n+\n+static void\n+e_insert (struct entry *e)\n+{\n+  hashval_t hval;\n+\n+  hval = e_hash (e);\n+  e->next = hash_table[hval % HASH_SIZE];\n+  hash_table[hval % HASH_SIZE] = e;\n+}\n \n void\n output (struct entry *e)\n {\n   int i;\n   char c;\n-  void **p;\n+  struct entry *n;\n \n   if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n     abort ();\n \n-  p = htab_find_slot (hasht, e, INSERT);\n-  if (*p != NULL)\n+  if (e_exists (e))\n     return;\n \n-  *p = malloc ((e[0].len + 1) * sizeof (struct entry));\n-  memcpy (*p, e, (e[0].len + 1) * sizeof (struct entry));\n+  n = (struct entry *) malloc ((e[0].len + 1) * sizeof (struct entry));\n+  memcpy (n, e, (e[0].len + 1) * sizeof (struct entry));\n+  e_insert (n);\n \n   if (idx == limidx)\n     switchfiles (e[0].len);\n@@ -1357,29 +1504,41 @@ int\n main (int argc, char **argv)\n {\n   int i, j, count, c, n = 3000;\n+  char *optarg;\n \n   if (sizeof (int) != 4 || sizeof (long long) != 8)\n     return 1;\n-\n-  while ((c = getopt (argc, argv, \"d:i:n:s:\")) != -1)\n-    switch (c)\n-      {\n-      case 'n':\n-\tn = atoi (optarg);\n-\tbreak;\n-      case 'd':\n-\tdestdir = optarg;\n-\tbreak;\n-      case 's':\n-\tsrcdir = optarg;\n-\tbreak;\n-      case 'i':\n-\toutput_one = 1;\n-\tlimidx = atoi (optarg);\n-\tbreak;\n-      default:\n+  \n+  i = 1;\n+  while (i < argc) \n+    {\n+      c = '\\0';\n+      if (argv[i][0] == '-' && argv[i][2] == '\\0')\n+\tc = argv[i][1];\n+      optarg = argv[i + 1];\n+      if (!optarg)\n \tgoto usage;\n+      switch (c)\n+\t{\n+\tcase 'n':\n+\t  n = atoi (optarg);\n+\t  break;\n+\tcase 'd':\n+\t  destdir = optarg;\n+\t  break;\n+\tcase 's':\n+\t  srcdir = optarg;\n+\t  break;\n+\tcase 'i':\n+\t  output_one = 1;\n+\t  limidx = atoi (optarg);\n+\t  break;\n+\tdefault:\n+\t  fprintf (stderr, \"unrecognized option %s\\n\", argv[i]);\n+\t  goto usage;\n       }\n+      i += 2;\n+    }\n \n   if (output_one)\n     {\n@@ -1404,7 +1563,6 @@ Either -s srcdir -d destdir or -i idx must be used\\n\", argv[0]);\n   if (srcdir == NULL && !output_one)\n     goto usage;\n \n-  hasht = htab_create (40000, e_hash, e_eq, NULL);\n   for (i = 0; i < NTYPES2; ++i)\n     if (base_types[i].bitfld)\n       bitfld_types[n_bitfld_types++] = base_types[i];"}]}