{"sha": "b69960ac72922e24256e50e02320f56626097113", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5OTYwYWM3MjkyMmUyNDI1NmU1MGUwMjMyMGY1NjYyNjA5NzExMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-27T19:08:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-27T19:08:26Z"}, "message": "(force_to_mode, case ASHIFTRT): Properly handle mask wider than\nHOST_WIDE_INT.\n\nFrom-SVN: r10534", "tree": {"sha": "119e038ed62856bfc42ceb44b8f6ff3720aee098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/119e038ed62856bfc42ceb44b8f6ff3720aee098"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b69960ac72922e24256e50e02320f56626097113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69960ac72922e24256e50e02320f56626097113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b69960ac72922e24256e50e02320f56626097113", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69960ac72922e24256e50e02320f56626097113/comments", "author": null, "committer": null, "parents": [{"sha": "bcbed709847b6a0461ff70a574c14681af66844c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcbed709847b6a0461ff70a574c14681af66844c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcbed709847b6a0461ff70a574c14681af66844c"}], "stats": {"total": 26, "additions": 24, "deletions": 2}, "files": [{"sha": "e622b169acc88b1159edbefc9ca3a7c7dc4f7282", "filename": "gcc/combine.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69960ac72922e24256e50e02320f56626097113/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69960ac72922e24256e50e02320f56626097113/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b69960ac72922e24256e50e02320f56626097113", "patch": "@@ -6035,8 +6035,30 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t{\n \t  int i = -1;\n \n-\t  nonzero = GET_MODE_MASK (GET_MODE (x));\n-\t  nonzero >>= INTVAL (XEXP (x, 1));\n+\t  /* If the considered data is wider then HOST_WIDE_INT, we can't\n+\t     represent a mask for all its bits in a single scalar.\n+\t     But we only care about the lower bits, so calculate these.  */\n+\n+\t  if (GET_MODE_SIZE (GET_MODE (x)) > sizeof (HOST_WIDE_INT))\n+\t    {\n+\t      nonzero = ~(HOST_WIDE_INT)0;\n+\n+\t      /* GET_MODE_BITSIZE (GET_MODE (x)) - INTVAL (XEXP (x, 1))\n+\t\t is the number of bits a full-width mask would have set.\n+\t\t We need only shift if these are fewer than nonzero can\n+\t\t hold.  If not, we must keep all bits set in nonzero.  */\n+\n+\t      if (GET_MODE_BITSIZE (GET_MODE (x)) - INTVAL (XEXP (x, 1))\n+\t\t  < HOST_BITS_PER_WIDE_INT)\n+\t\tnonzero >>= INTVAL (XEXP (x, 1))\n+\t\t\t    + HOST_BITS_PER_WIDE_INT\n+\t\t\t    - GET_MODE_BITSIZE (GET_MODE (x)) ;\n+\t    }\n+\t  else\n+\t    {\n+\t      nonzero = GET_MODE_MASK (GET_MODE (x));\n+\t      nonzero >>= INTVAL (XEXP (x, 1));\n+\t    }\n \n \t  if ((mask & ~ nonzero) == 0\n \t      || (i = exact_log2 (mask)) >= 0)"}]}