{"sha": "31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjNTZhOGJhN2MxMGNjYWNmYTFmMzU2NmQ4ZWIxNmRkZGFkYmZkMg==", "commit": {"author": {"name": "Fergus Henderson", "email": "fjh@cs.mu.oz.au", "date": "2003-07-10T08:18:53Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2003-07-10T08:18:53Z"}, "message": "Remove C language front end dependencies.\n\n* tree-convert.c: New file.\n* treetree.c: Don't include c-tree.h.  Include target.h.\n(struct lang_identifier, union lang_tree_node, struct lang_type,\nstruct lang_function): New, minimal language-specific datastructs.\n(tree_lang_truthvalue_conversion, tree_mark_addressable,\ntree_lang_type_for_size, tree_lang_type_for_mode,\ntree_lang_unsigned_type, tree_lang_signed_type,\ntree_lang_signed_or_unsigned): New functions.\n(LANG_HOOKS_*): Don't use C front end langhooks.  Use new functions.\n(pushlevel, poplevel, global_bindings_p, insert_block, set_block,\npushdecl, getdecls, kept_level_p, tree_push_type_decl,\ntree_push_atomic_type_decl): New functions.\n(struct resword, struct reswords): Remove.\n* Make-lang.in: Update.  Don't depend on C front end objects.\n* config-lang.in: Likewise.\n\nCo-Authored-By: Steven Bosscher <steven@gcc.gnu.org>\n\nFrom-SVN: r69178", "tree": {"sha": "85a5c15df04a69d60efc798d7a74c75b8f71af3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a5c15df04a69d60efc798d7a74c75b8f71af3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/comments", "author": null, "committer": null, "parents": [{"sha": "cde6384093dcf3f9f90babf65aea62ceb64f8755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde6384093dcf3f9f90babf65aea62ceb64f8755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde6384093dcf3f9f90babf65aea62ceb64f8755"}], "stats": {"total": 1059, "additions": 670, "deletions": 389}, "files": [{"sha": "db873ac3097f9f365dc07b2537dfb664b2a3a412", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "patch": "@@ -1,3 +1,22 @@\n+2003-07-10  Fergus Henderson  <fjh@cs.mu.oz.au>\n+\t    Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree-convert.c: New file.\n+\t* treetree.c: Don't include c-tree.h.  Include target.h.\n+\t(struct lang_identifier, union lang_tree_node, struct lang_type,\n+\tstruct lang_function): New, minimal language-specific datastructs.\n+\t(tree_lang_truthvalue_conversion, tree_mark_addressable,\n+\ttree_lang_type_for_size, tree_lang_type_for_mode,\n+\ttree_lang_unsigned_type, tree_lang_signed_type,\n+\ttree_lang_signed_or_unsigned): New functions.\n+\t(LANG_HOOKS_*): Don't use C front end langhooks.  Use new functions.\n+\t(pushlevel, poplevel, global_bindings_p, insert_block, set_block,\n+\tpushdecl, getdecls, kept_level_p, tree_push_type_decl,\n+\ttree_push_atomic_type_decl): New functions.\n+\t(struct resword, struct reswords): Remove.\n+\t* Make-lang.in: Update.  Don't depend on C front end objects.\n+\t* config-lang.in: Likewise.\n+\n 2003-07-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* treelang/treetree.c (tree_code_if_start, tree_code_if_else,"}, {"sha": "c1663945b9056e517693dc3cbc47c573aa553309", "filename": "gcc/treelang/Make-lang.in", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FMake-lang.in?ref=31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "patch": "@@ -47,7 +47,9 @@ TREELANGSED = sed\n TREELANGSEDFLAGS = -n\n \n # back end compiler libraries etc\n-TREE_BE_LIBS = $(C_TARGET_OBJS) $(BACKEND) $(LIBIBERTY) $(INTLLIBS) $(LIBS) $(LIBDEPS)\n+TREE_BE_LIBS = $(BACKEND) $(LIBIBERTY) $(INTLIBS) $(LIBS) $(LIBDEPS)\n+\n+\n GCC_EXTRAS = -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include\n \n # ./xgcc is the just built compiler. See GCC_FOR_TARGET in the GCC Makefile.in.\n@@ -56,10 +58,9 @@ GCC_EXTRAS = -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include\n \n # GCC_FOR_TREELANG = ./xgcc $(GCC_EXTRAS)\n \n-TREE_GENERATED = $(srcdir)/treelang/lex.c $(srcdir)/treelang/parse.c\\\n-\t$(srcdir)/treelang/parse.h $(srcdir)/treelang/parse.output $(srcdir)/treelang/TAGS\n-\n-TREE_SOURCE = ${srcdir}/treelang/parse.y ${srcdir}/treelang/lex.l ${srcdir}/treelang/tree1.c ${srcdir}/treelang/treelang.h ${srcdir}/treelang/treetree.c $(srcdir)/treelang/treetree.h ${srcdir}/treelang/opts.h\n+TREE_GENERATED = $(srcdir)/treelang/lex.c $(srcdir)/treelang/parse.c \\\n+  $(srcdir)/treelang/parse.h $(srcdir)/treelang/parse.output \\\n+  $(srcdir)/treelang/TAGS\n \n TREE_EXES = tree1$(exeext)\n \n@@ -83,13 +84,13 @@ treelang.done: tree1$(exeext)\n # no preprocessor\n \n # core compiler\n-tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o\\\n-\t$(TREE_BE_LIBS) c-convert.o c-typeck.o c-common.o c-cppbuiltin.o \\\n-\tc-decl.o attribs.o\n+tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/tree-convert.o \\\n+\ttreelang/lex.o treelang/parse.o \\\n+\t$(TREE_BE_LIBS) attribs.o\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n-\ttreelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o \\\n-\tc-convert.o c-typeck.o c-common.o c-cppbuiltin.o c-decl.o attribs.o \\\n-\t$(TREE_BE_LIBS)\n+\ttreelang/tree1.o treelang/treetree.o treelang/tree-convert.o \\\n+\ttreelang/lex.o treelang/parse.o \\\n+\t$(TREE_BE_LIBS) attribs.o\n \n #\f\n # Compiling object files from source files.\n@@ -106,6 +107,9 @@ treelang/treetree.o: treelang/treetree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   varray.h $(LANGHOOKS_DEF_H) langhooks.h treelang/treelang.h input.h \\\n   treelang/treetree.h treelang/parse.h\n \n+treelang/tree-convert.o: treelang/tree-convert.c $(CONFIG_H) $(SYSTEM_) \\\n+  coretypes.h diagnostic.h $(TREE_H) flags.h toplev.h langhooks.h\n+\n treelang/parse.o: treelang/parse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   $(TM_H) diagnostic.h treelang/treelang.h input.h treelang/treetree.h\n \n@@ -314,13 +318,12 @@ treelang.check.fix: force\n \t-cp testsuite/treelang/*runpgm* t\n \t-rm -f t/*nofilename\n \n-treelang.wc: force\n-\twc  ${TREE_SOURCE}\n-\n #\f\n \n .PHONY: treelang.html\n \n treelang.html:\n \tcd $(srcdir)/treelang && texi2html -I ../doc/include -verbose -menu -split_chapter -number treelang.texi\n #\tmv treelang*.html $(srcdir)/treelang\n+\n+config.status: treelang/config-lang.in"}, {"sha": "f8a52f9787fa9f9b0621d2772c966029a4e098b0", "filename": "gcc/treelang/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fconfig-lang.in?ref=31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "patch": "@@ -36,4 +36,4 @@ diff_excludes=\"-x lex.c -x parse.c -x parse.h\"\n headers=\n build_by_default=\"no\"\n \n-gtfiles=\"\\$(srcdir)/c-decl.c \\$(srcdir)/c-common.c \\$(srcdir)/c-common.h \\$(srcdir)/treelang/tree1.c \\$(srcdir)/treelang/treelang.h\"\n+gtfiles=\"\\$(srcdir)/treelang/tree1.c \\$(srcdir)/treelang/treetree.c \\$(srcdir)/treelang/treelang.h\""}, {"sha": "6d50ef5a76a205ad5fbe7b2e1fc14c6f81fd827d", "filename": "gcc/treelang/tree-convert.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2Ftree-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2Ftree-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree-convert.c?ref=31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "patch": "@@ -0,0 +1,108 @@\n+/* Language-level data type conversion for Treelang.\n+   This is a very slightly modified copy of c-convert.c.\n+   Copyright (C) 1987, 1988, 1991, 1998, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+\n+/* This file contains the functions for converting C expressions\n+   to different data types.  The only entry point is `convert'.\n+   Every language front end must have a `convert' function\n+   but what kind of conversions it does will depend on the language.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"diagnostic.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"convert.h\"\n+#include \"toplev.h\"\n+#include \"langhooks.h\"\n+\n+/* Change of width--truncation and extension of integers or reals--\n+   is represented with NOP_EXPR.  Proper functioning of many things\n+   assumes that no other conversions can be NOP_EXPRs.\n+\n+   Conversion between integer and pointer is represented with CONVERT_EXPR.\n+   Converting integer to real uses FLOAT_EXPR\n+   and real to integer uses FIX_TRUNC_EXPR.\n+\n+   Here is a list of all the functions that assume that widening and\n+   narrowing is always done with a NOP_EXPR:\n+     In convert.c, convert_to_integer.\n+     In c-typeck.c, build_binary_op (boolean ops), and\n+\tc_common_truthvalue_conversion.\n+     In expr.c: expand_expr, for operands of a MULT_EXPR.\n+     In fold-const.c: fold.\n+     In tree.c: get_narrower and get_unwidened.  */\n+\f\n+/* Create an expression whose value is that of EXPR,\n+   converted to type TYPE.  The TREE_TYPE of the value\n+   is always TYPE.  This function implements all reasonable\n+   conversions; callers should filter out those that are\n+   not permitted by the language being compiled.  */\n+\n+tree\n+convert (type, expr)\n+     tree type, expr;\n+{\n+  tree e = expr;\n+  enum tree_code code = TREE_CODE (type);\n+\n+  if (type == TREE_TYPE (expr)\n+      || TREE_CODE (expr) == ERROR_MARK\n+      || code == ERROR_MARK || TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+    return expr;\n+\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n+    return fold (build1 (NOP_EXPR, type, expr));\n+  if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+    return error_mark_node;\n+  if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n+    {\n+      error (\"void value not ignored as it ought to be\");\n+      return error_mark_node;\n+    }\n+  if (code == VOID_TYPE)\n+    return build1 (CONVERT_EXPR, type, e);\n+  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n+    return fold (convert_to_integer (type, e));\n+  if (code == BOOLEAN_TYPE)\n+    {\n+      tree t = (*lang_hooks.truthvalue_conversion) (expr);\n+      /* If it returns a NOP_EXPR, we must fold it here to avoid\n+\t infinite recursion between fold () and convert ().  */\n+      if (TREE_CODE (t) == NOP_EXPR)\n+\treturn fold (build1 (NOP_EXPR, type, TREE_OPERAND (t, 0)));\n+      else\n+\treturn fold (build1 (NOP_EXPR, type, t));\n+    }\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n+    return fold (convert_to_pointer (type, e));\n+  if (code == REAL_TYPE)\n+    return fold (convert_to_real (type, e));\n+  if (code == COMPLEX_TYPE)\n+    return fold (convert_to_complex (type, e));\n+  if (code == VECTOR_TYPE)\n+    return fold (convert_to_vector (type, e));\n+\n+  error (\"conversion to non-scalar type requested\");\n+  return error_mark_node;\n+}"}, {"sha": "2b8fd149b43c9928f4440e4f7feb4ce622385779", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 525, "deletions": 374, "changes": 899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=31c56a8ba7c10ccacfa1f3566d8eb16dddadbfd2", "patch": "@@ -63,13 +63,13 @@\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"output.h\"\n-#include \"c-tree.h\"\n #include \"rtl.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"varray.h\"\n #include \"langhooks-def.h\"\n #include \"langhooks.h\"\n+#include \"target.h\"\n \n #include \"treelang.h\"\n #include \"treetree.h\"\n@@ -78,31 +78,94 @@\n extern int option_main;\n extern char **file_names;\n \n+/* Types expected by gcc's garbage collector.\n+   These types exist to allow language front-ends to\n+   add extra information in gcc's parse tree data structure.\n+   But the treelang front end doesn't use them -- it has\n+   its own parse tree data structure.\n+   We define them here only to satisfy gcc's garbage collector.  */\n+\n+/* Language-specific identifier information.  */\n+\n+struct lang_identifier GTY(())\n+{\n+  struct tree_identifier common;\n+};\n+\n+/* Language-specific tree node information.  */\n+\n+union lang_tree_node \n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+{\n+  union tree_node GTY ((tag (\"0\"), \n+\t\t\tdesc (\"tree_node_structure (&%h)\"))) \n+    generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n+};\n+\n+/* Language-specific type information.  */\n+\n+struct lang_type GTY(())\n+{\n+  char junk; /* dummy field to ensure struct is not empty */\n+};\n+\n+/* Language-specific declaration information.  */\n+\n+struct lang_decl GTY(())\n+{\n+  char junk; /* dummy field to ensure struct is not empty */\n+};\n+\n+struct language_function GTY(())\n+{\n+  char junk; /* dummy field to ensure struct is not empty */\n+};\n+\n+static tree tree_lang_truthvalue_conversion PARAMS((tree expr));\n+static bool tree_mark_addressable PARAMS((tree exp));\n+static tree tree_lang_type_for_size PARAMS((unsigned precision,\n+\t\t\t\t\t    int unsignedp));\n+static tree tree_lang_type_for_mode PARAMS((enum machine_mode mode,\n+\t\t\t\t\t    int unsignedp));\n+static tree tree_lang_unsigned_type PARAMS((tree type_node));\n+static tree tree_lang_signed_type PARAMS((tree type_node));\n+static tree tree_lang_signed_or_unsigned_type PARAMS((int unsignedp,\n+\t\t\t\t\t\t      tree type));\n+\n+/* XXX these should be static */\n+void pushlevel PARAMS((int ignore));\n+tree poplevel PARAMS((int keep, int reverse, int functionbody));\n+int global_bindings_p PARAMS((void));\n+void insert_block PARAMS((tree block));\n+void set_block PARAMS((tree block));\n+tree pushdecl PARAMS((tree decl));\n+tree getdecls PARAMS((void));\n+int kept_level_p PARAMS((void));\n+\n+static void tree_push_type_decl PARAMS((tree id, tree type_node));\n+static void tree_push_atomic_type_decl PARAMS((tree id, tree type_node));\n+\n /* The front end language hooks (addresses of code for this front\n-   end).  Mostly just use the C routines.  */\n+   end).  These are not really very language-dependent, i.e.\n+   treelang, C, Mercury, etc. can all use almost the same definitions.  */\n \n #undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n-#define LANG_HOOKS_TRUTHVALUE_CONVERSION c_common_truthvalue_conversion\n+#define LANG_HOOKS_TRUTHVALUE_CONVERSION tree_lang_truthvalue_conversion\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n-#define LANG_HOOKS_MARK_ADDRESSABLE c_mark_addressable\n+#define LANG_HOOKS_MARK_ADDRESSABLE tree_mark_addressable\n #undef LANG_HOOKS_SIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_TYPE c_common_signed_type\n+#define LANG_HOOKS_SIGNED_TYPE tree_lang_signed_type\n #undef LANG_HOOKS_UNSIGNED_TYPE\n-#define LANG_HOOKS_UNSIGNED_TYPE c_common_unsigned_type\n+#define LANG_HOOKS_UNSIGNED_TYPE tree_lang_unsigned_type\n #undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n-#define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE c_common_signed_or_unsigned_type\n+#define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE tree_lang_signed_or_unsigned_type\n #undef LANG_HOOKS_TYPE_FOR_MODE\n-#define LANG_HOOKS_TYPE_FOR_MODE c_common_type_for_mode\n+#define LANG_HOOKS_TYPE_FOR_MODE tree_lang_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n-#define LANG_HOOKS_TYPE_FOR_SIZE c_common_type_for_size\n+#define LANG_HOOKS_TYPE_FOR_SIZE tree_lang_type_for_size\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE treelang_parse_file\n-#undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n-#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table\n-#undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n-#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE c_common_format_attribute_table\n-#undef LANG_HOOKS_INSERT_DEFAULT_ATTRIBUTES\n-#define LANG_HOOKS_INSERT_DEFAULT_ATTRIBUTES c_insert_default_attributes\n \n /* Hook routines and data unique to treelang.  */\n \n@@ -805,483 +868,571 @@ tree_code_get_numeric_type (unsigned int size1, unsigned int sign1)\n   return ret1;\n }\n \n-/* Garbage Collection.  */\n-\n-/* Callback to mark storage M as used always.  */\n-\n-void\n-tree_ggc_storage_always_used (void * m)\n-{\n-  void **mm; /* Actually M is a pointer to a pointer to the memory.  */\n-  mm = (void**)m;\n-\n-  if (*mm)\n-    ggc_mark (*mm);\n-}\n-\n-/* Following  from c-lang.c.  */\n-\n-/* Used by c-typeck.c (build_external_ref), but only for objc.  */\n+/* Get a stringpool entry for a string S of length L.  This is needed\n+   because the GTY routines don't mark strings, forcing you to put\n+   them into stringpool, which is never freed.  */\n \n-tree\n-lookup_objc_ivar (tree id ATTRIBUTE_UNUSED)\n+const char*\n+get_string (const char *s, size_t l)\n {\n-  return 0;\n+  tree t;\n+  t = get_identifier_with_length (s, l);\n+  return IDENTIFIER_POINTER(t);\n }\n+  \n+/* Save typing debug_tree all the time. Dump a tree T pretty and\n+   concise.  */\n \n-/* Dummy routines called from c code. Save copying c-decl.c, c-common.c etc.  */\n-\n-tree\n-objc_is_id (tree arg ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n+void dt (tree t);\n \n void\n-check_function_format (int *status ATTRIBUTE_UNUSED,\n-                       tree attrs ATTRIBUTE_UNUSED,\n-                       tree params ATTRIBUTE_UNUSED)\n+dt (tree t)\n {\n-  return;\n+  debug_tree (t);\n }\n \n-/* Tell the c code we are not objective C.  */\n+/* Routines Expected by gcc:  */\n \n-int\n-objc_comptypes (tree lhs ATTRIBUTE_UNUSED,\n-                tree rhs ATTRIBUTE_UNUSED,\n-                int reflexive ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n+/* These are used to build types for various sizes.  The code below\n+   is a simplified version of that of GNAT.  */\n \n-/* Should not be called for treelang.  Needed by RS6000 backend.  */\n+#ifndef MAX_BITS_PER_WORD\n+#define MAX_BITS_PER_WORD  BITS_PER_WORD\n+#endif\n \n-int c_lex (tree *value);\n+/* This variable keeps a table for types for each precision so that we only \n+   allocate each of them once. Signed and unsigned types are kept separate.  */\n+static GTY(()) tree signed_and_unsigned_types[MAX_BITS_PER_WORD + 1][2];\n \n-int\n-c_lex (tree *value ATTRIBUTE_UNUSED)\n+/* XXX is this definition OK? */\n+static tree\n+tree_lang_truthvalue_conversion (expr)\n+     tree expr;\n {\n-  abort ();\n+  return expr;\n }\n \n-/* Should not be called for treelang.   */\n+/* Mark EXP saying that we need to be able to take the\n+   address of it; it should not be allocated in a register.\n+   Value is 1 if successful.  \n+   \n+   This implementation was copied from c-decl.c. */\n \n-tree\n-build_stmt (enum tree_code code  ATTRIBUTE_UNUSED, ...)\n+static bool\n+tree_mark_addressable (exp)\n+     tree exp;\n {\n-  abort ();\n+  register tree x = exp;\n+  while (1)\n+    switch (TREE_CODE (x))\n+      {\n+      case COMPONENT_REF:\n+      case ADDR_EXPR:\n+      case ARRAY_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+  \n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn 1;\n+\n+      case VAR_DECL:\n+      case CONST_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n+\t    && DECL_NONLOCAL (x))\n+\t  {\n+\t    if (TREE_PUBLIC (x))\n+\t      {\n+\t\terror (\"global register variable `%s' used in nested function\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\treturn 0;\n+\t      }\n+\t    pedwarn (\"register variable `%s' used in nested function\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t  }\n+\telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n+\t  {\n+\t    if (TREE_PUBLIC (x))\n+\t      {\n+\t\terror (\"address of global register variable `%s' requested\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t\treturn 0;\n+\t      }\n+\n+\t    pedwarn (\"address of register variable `%s' requested\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t  }\n+\tput_var_into_stack (x, /*rescan=*/ true);\n+\n+\t/* drops in */\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\n+      default:\n+\treturn 1;\n+    }\n }\n-\n-/* Should not be called for treelang.   */\n-\n-tree\n-add_stmt (tree t ATTRIBUTE_UNUSED)\n+  \n+/* Return an integer type with the number of bits of precision given by  \n+   PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n+   it is a signed type.  */\n+  \n+static tree\n+tree_lang_type_for_size (precision, unsignedp)\n+     unsigned precision;\n+     int unsignedp;\n {\n-  abort ();\n-}\n+  tree t;\n \n-/* Should not be called for treelang.   */\n+  if (precision <= MAX_BITS_PER_WORD\n+      && signed_and_unsigned_types[precision][unsignedp] != 0)\n+    return signed_and_unsigned_types[precision][unsignedp];\n \n-tree\n-build_return_stmt (tree expr ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n+  if (unsignedp)\n+    t = signed_and_unsigned_types[precision][1]\n+      = make_unsigned_type (precision);\n+  else\n+    t = signed_and_unsigned_types[precision][0]\n+      = make_signed_type (precision);\n+  \n+  return t;\n }\n \n-/* C warning, ignore.  */\n+/* Return a data type that has machine mode MODE.  UNSIGNEDP selects\n+   an unsigned type; otherwise a signed type is returned.  */\n \n-void\n-pedwarn_c99 (const char *msgid ATTRIBUTE_UNUSED, ...)\n+static tree\n+tree_lang_type_for_mode (mode, unsignedp)\n+     enum machine_mode mode;\n+     int unsignedp;\n {\n-  return;\n+  return tree_lang_type_for_size (GET_MODE_BITSIZE (mode), unsignedp);\n }\n \n-/* Should not be called for treelang.   */\n+/* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n \n-tree\n-build_case_label (tree low_value ATTRIBUTE_UNUSED,\n-                  tree high_value ATTRIBUTE_UNUSED,\n-                  tree label_decl ATTRIBUTE_UNUSED)\n+static tree\n+tree_lang_unsigned_type (type_node)\n+     tree type_node;\n {\n-  abort ();\n+  return tree_lang_type_for_size (TYPE_PRECISION (type_node), 1);\n }\n \n-/* Should not be called for treelang.   */\n+/* Return the signed version of a TYPE_NODE, a scalar type.  */\n \n-void\n-emit_local_var (tree decl ATTRIBUTE_UNUSED)\n+static tree\n+tree_lang_signed_type (type_node)\n+     tree type_node;\n {\n-  abort ();\n+  return tree_lang_type_for_size (TYPE_PRECISION (type_node), 0);\n }\n \n-/* Should not be called for treelang.   */\n+/* Return a type the same as TYPE except unsigned or signed according to\n+   UNSIGNEDP.  */\n \n-void\n-expand_stmt (tree t ATTRIBUTE_UNUSED)\n+static tree\n+tree_lang_signed_or_unsigned_type (unsignedp, type)\n+     int unsignedp;\n+     tree type;\n {\n-  abort ();\n+  if (! INTEGRAL_TYPE_P (type) || TREE_UNSIGNED (type) == unsignedp)\n+    return type;\n+  else\n+    return tree_lang_type_for_size (TYPE_PRECISION (type), unsignedp);\n }\n+\f\n+/* These functions and variables deal with binding contours.  We only\n+   need these functions for the list of PARM_DECLs, but we leave the\n+   functions more general; these are a simplified version of the\n+   functions from GNAT.  */\n \n-/* Should not be called for treelang.   */\n+/* For each binding contour we allocate a binding_level structure which records\n+   the entities defined or declared in that contour. Contours include:\n \n-cpp_reader *\n-cpp_create_reader (enum c_lang lang ATTRIBUTE_UNUSED,\n-\t\t   struct ht *table ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n+\tthe global one\n+\tone for each subprogram definition\n+\tone for each compound statement (declare block)\n \n-/* Should not be called for treelang.   */\n+   Binding contours are used to create GCC tree BLOCK nodes.  */\n \n-void\n-init_c_lex (void)\n+struct binding_level\n {\n-  abort ();\n-}\n+  /* A chain of ..._DECL nodes for all variables, constants, functions,\n+     parameters and type declarations.  These ..._DECL nodes are chained\n+     through the TREE_CHAIN field. Note that these ..._DECL nodes are stored\n+     in the reverse of the order supplied to be compatible with the\n+     back-end.  */\n+  tree names;\n+  /* For each level (except the global one), a chain of BLOCK nodes for all\n+     the levels that were entered and exited one level down from this one.  */\n+  tree blocks;\n+  /* The back end may need, for its own internal processing, to create a BLOCK\n+     node. This field is set aside for this purpose. If this field is non-null\n+     when the level is popped, i.e. when poplevel is invoked, we will use such\n+     block instead of creating a new one from the 'names' field, that is the\n+     ..._DECL nodes accumulated so far.  Typically the routine 'pushlevel'\n+     will be called before setting this field, so that if the front-end had\n+     inserted ..._DECL nodes in the current block they will not be lost.   */\n+  tree block_created_by_back_end;\n+  /* The binding level containing this one (the enclosing binding level). */\n+  struct binding_level *level_chain;\n+};\n \n-/* Should not be called for treelang.   */\n+/* The binding level currently in effect.  */\n+static struct binding_level *current_binding_level = NULL;\n \n-void init_pragma (void);\n+/* The outermost binding level. This binding level is created when the\n+   compiler is started and it will exist through the entire compilation.  */\n+static struct binding_level *global_binding_level;\n \n-void\n-init_pragma ()\n-{\n-  abort ();\n-}\n-\n-/* Should not be called for treelang.   */\n+/* Binding level structures are initialized by copying this one.  */\n+static struct binding_level clear_binding_level = {NULL, NULL, NULL, NULL};\n+\f\n+/* Return non-zero if we are currently in the global binding level.  */\n \n int\n-cpp_finish (cpp_reader *pfile ATTRIBUTE_UNUSED, FILE *f ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n-\n-/* Should not be called for treelang.   */\n-\n-unsigned int\n-cpp_errors (cpp_reader *pfile ATTRIBUTE_UNUSED)\n+global_bindings_p ()\n {\n-  abort ();\n+  return current_binding_level == global_binding_level ? -1 : 0;\n }\n \n-/* Dummy called by C.   */\n+/* Return the list of declarations in the current level. Note that this list\n+   is in reverse order (it has to be so for back-end compatibility).  */\n \n tree\n-handle_format_attribute (tree *node ATTRIBUTE_UNUSED,\n-                         tree name ATTRIBUTE_UNUSED,\n-                         tree args ATTRIBUTE_UNUSED,\n-                         int flags ATTRIBUTE_UNUSED,\n-                         bool *no_add_attrs ATTRIBUTE_UNUSED)\n+getdecls ()\n {\n-  return NULL_TREE;\n+  return current_binding_level->names;\n }\n \n-/* Should not be called for treelang.   */\n+/* Nonzero if the current level needs to have a BLOCK made.  */\n \n-tree\n-handle_format_arg_attribute (tree *node ATTRIBUTE_UNUSED,\n-     tree name ATTRIBUTE_UNUSED,\n-     tree args ATTRIBUTE_UNUSED,\n-     int flags ATTRIBUTE_UNUSED,\n-     bool *no_add_attrs ATTRIBUTE_UNUSED)\n+int\n+kept_level_p ()\n {\n-  abort ();\n+  return (current_binding_level->names != 0);\n }\n \n-/* Should not be called for treelang.   */\n+/* Enter a new binding level. The input parameter is ignored, but has to be\n+   specified for back-end compatibility.  */\n \n void\n-cpp_assert (cpp_reader * cr ATTRIBUTE_UNUSED,\n-            const char *s ATTRIBUTE_UNUSED)\n+pushlevel (ignore)\n+     int ignore ATTRIBUTE_UNUSED;\n {\n-  abort ();\n-}\n+  struct binding_level *newlevel\n+    = (struct binding_level *) xmalloc (sizeof (struct binding_level));\n \n-/* Should not be called for treelang.   */\n+  *newlevel = clear_binding_level;\n \n-void\n-set_Wformat (int setting ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n+  /* Add this level to the front of the chain (stack) of levels that are\n+     active.  */\n+  newlevel->level_chain = current_binding_level;\n+  current_binding_level = newlevel;\n }\n \n-/* Used for objective C.  */\n+/* Exit a binding level.\n+   Pop the level off, and restore the state of the identifier-decl mappings\n+   that were in effect when this level was entered.\n \n-void\n-objc_check_decl (tree decl ATTRIBUTE_UNUSED);\n+   If KEEP is nonzero, this level had explicit declarations, so\n+   and create a \"block\" (a BLOCK node) for the level\n+   to record its declarations and subblocks for symbol table output.\n \n-void\n-objc_check_decl (tree decl ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n+   If FUNCTIONBODY is nonzero, this level is the body of a function,\n+   so create a block as if KEEP were set and also clear out all\n+   label names.\n \n-/* Tell the c code we are not objective C.  */\n+   If REVERSE is nonzero, reverse the order of decls before putting\n+   them into the BLOCK.  */\n \n tree\n-objc_message_selector (void);\n-\n-tree\n-objc_message_selector ()\n+poplevel (keep, reverse, functionbody)\n+     int keep;\n+     int reverse;\n+     int functionbody;\n {\n-  return 0;\n-}\n-\n-/* Should not be called for treelang.   */\n-\n-void\n-gen_aux_info_record (tree fndecl ATTRIBUTE_UNUSED,\n-                     int is_definition ATTRIBUTE_UNUSED,\n-                     int is_implicit ATTRIBUTE_UNUSED,\n-                     int is_prototyped ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n+  /* Points to a BLOCK tree node. This is the BLOCK node construted for the\n+     binding level that we are about to exit and which is returned by this\n+     routine.  */\n+  tree block_node = NULL_TREE;\n+  tree decl_chain;\n+  tree subblock_chain = current_binding_level->blocks;\n+  tree subblock_node;\n+  tree block_created_by_back_end;\n+\n+  /* Reverse the list of *_DECL nodes if desired.  Note that the ..._DECL\n+     nodes chained through the `names' field of current_binding_level are in\n+     reverse order except for PARM_DECL node, which are explicitely stored in\n+     the right order.  */\n+  decl_chain = (reverse) ? nreverse (current_binding_level->names)\n+\t\t\t : current_binding_level->names;\n+\n+  block_created_by_back_end = current_binding_level->block_created_by_back_end;\n+  if (block_created_by_back_end != 0)\n+    {\n+      block_node = block_created_by_back_end;\n+\n+      /* Check if we are about to discard some information that was gathered\n+\t by the front-end. Nameley check if the back-end created a new block \n+\t without calling pushlevel first. To understand why things are lost\n+\t just look at the next case (i.e. no block created by back-end.  */\n+      if ((keep || functionbody) && (decl_chain || subblock_chain))\n+\tabort ();\n+    }\n \n-/* Should not be called for treelang, but it is.   */\n+  /* If there were any declarations in the current binding level, or if this\n+     binding level is a function body, or if there are any nested blocks then\n+     create a BLOCK node to record them for the life of this function.  */\n+  else if (keep || functionbody)\n+    block_node = build_block (keep ? decl_chain : 0, 0, subblock_chain, 0, 0);\n+\n+  /* Record the BLOCK node just built as the subblock its enclosing scope.  */\n+  for (subblock_node = subblock_chain; subblock_node;\n+       subblock_node = TREE_CHAIN (subblock_node))\n+    BLOCK_SUPERCONTEXT (subblock_node) = block_node;\n+\n+  /* Clear out the meanings of the local variables of this level.  */\n+\n+  for (subblock_node = decl_chain; subblock_node;\n+       subblock_node = TREE_CHAIN (subblock_node))\n+    if (DECL_NAME (subblock_node) != 0)\n+      /* If the identifier was used or addressed via a local extern decl,  \n+\t don't forget that fact.   */\n+      if (DECL_EXTERNAL (subblock_node))\n+\t{\n+\t  if (TREE_USED (subblock_node))\n+\t    TREE_USED (DECL_NAME (subblock_node)) = 1;\n+\t  if (TREE_ADDRESSABLE (subblock_node))\n+\t    TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (subblock_node)) = 1;\n+\t}\n+\n+  /* Pop the current level.  */\n+  current_binding_level = current_binding_level->level_chain;\n+\n+  if (functionbody)\n+    {\n+      /* This is the top level block of a function. The ..._DECL chain stored\n+\t in BLOCK_VARS are the function's parameters (PARM_DECL nodes). Don't\n+\t leave them in the BLOCK because they are found in the FUNCTION_DECL\n+\t instead.  */\n+      DECL_INITIAL (current_function_decl) = block_node;\n+      BLOCK_VARS (block_node) = 0;\n+    }\n+  else if (block_node)\n+    {\n+      if (block_created_by_back_end == NULL)\n+\tcurrent_binding_level->blocks\n+\t  = chainon (current_binding_level->blocks, block_node);\n+    }\n \n-void\n-c_parse_init ()\n-{\n-  return;\n+  /* If we did not make a block for the level just exited, any blocks made for\n+     inner levels (since they cannot be recorded as subblocks in that level)\n+     must be carried forward so they will later become subblocks of something\n+     else.  */\n+  else if (subblock_chain)\n+    current_binding_level->blocks\n+      = chainon (current_binding_level->blocks, subblock_chain);\n+  if (block_node)\n+    TREE_USED (block_node) = 1;\n+\n+  return block_node;\n }\n-\n-/* Should not be called for treelang.   */\n-\n-void maybe_apply_pragma_weak (tree decl);\n+\f\n+/* Insert BLOCK at the end of the list of subblocks of the\n+   current binding level.  This is used when a BIND_EXPR is expanded,\n+   to handle the BLOCK node inside the BIND_EXPR.  */\n \n void\n-maybe_apply_pragma_weak (tree decl ATTRIBUTE_UNUSED)\n+insert_block (block)\n+     tree block;\n {\n-  abort ();\n+  TREE_USED (block) = 1;\n+  current_binding_level->blocks\n+    = chainon (current_binding_level->blocks, block);\n }\n \n-/* Should not be called for treelang.   */\n+/* Set the BLOCK node for the innermost scope\n+   (the one we are currently in).  */\n \n void\n-add_decl_stmt (tree decl ATTRIBUTE_UNUSED)\n+set_block (block)\n+     tree block;\n {\n-  abort ();\n+  current_binding_level->block_created_by_back_end = block;\n }\n \n-/* Should not be called for treelang.   */\n-\n-tree\n-maybe_apply_renaming_pragma (tree decl, tree asmname);\n-\n-/* Should not be called for treelang.   */\n+/* Records a ..._DECL node DECL as belonging to the current lexical scope.\n+   Returns the ..._DECL node. */\n \n tree\n-maybe_apply_renaming_pragma (tree decl ATTRIBUTE_UNUSED, tree asmname ATTRIBUTE_UNUSED)\n+pushdecl (decl)\n+     tree decl;\n {\n-  abort ();\n-}\n+  /* External objects aren't nested, other objects may be.  */\n+    \n+  if ((DECL_EXTERNAL (decl)) || (decl==current_function_decl))\n+    DECL_CONTEXT (decl) = 0;\n+  else\n+    DECL_CONTEXT (decl) = current_function_decl;\n \n-/* Should not be called for treelang.   */\n+  /* Put the declaration on the list.  The list of declarations is in reverse\n+     order. The list will be reversed later if necessary.  This needs to be\n+     this way for compatibility with the back-end.  */\n \n-void\n-begin_stmt_tree (tree *t ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n+  TREE_CHAIN (decl) = current_binding_level->names;\n+  current_binding_level->names = decl;\n \n-/* Should not be called for treelang.   */\n+  /* For the declartion of a type, set its name if it is not already set. */\n \n-void\n-finish_stmt_tree (tree *t ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      && TYPE_NAME (TREE_TYPE (decl)) == 0)\n+    TYPE_NAME (TREE_TYPE (decl)) = DECL_NAME (decl);\n \n-/* Should not be called for treelang.   */\n-\n-int\n-defer_fn (tree fn ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n+  return decl;\n }\n+\f\n \n-/* Should not be called for treelang.   */\n-\n-cpp_options\n-*cpp_get_options (cpp_reader * cr ATTRIBUTE_UNUSED)\n+static void\n+tree_push_type_decl(id, type_node)\n+     tree id;\n+     tree type_node;\n {\n-  abort ();\n+  tree decl = build_decl (TYPE_DECL, id, type_node);\n+  TYPE_NAME (type_node) = decl;\n+  TYPE_STUB_DECL (type_node) = decl;\n+  pushdecl (decl);\n }\n \n-/* Should not be called for treelang.   */\n+/* push_atomic_type_decl() ensures that the type's type is itself. \n+   Needed for DBX.  Must only be used for atomic types,\n+   not for e.g. pointer or array types.  */\n \n-void\n-cpp_define (cpp_reader * cr ATTRIBUTE_UNUSED, const char * c ATTRIBUTE_UNUSED)\n+static void\n+tree_push_atomic_type_decl(id, type_node)\n+     tree id;\n+     tree type_node;\n {\n-  abort ();\n+  TREE_TYPE (type_node) = type_node;\n+  tree_push_type_decl (id, type_node);\n }\n \n-/* Should not be called for treelang.   */\n-\n-cpp_callbacks *\n-cpp_get_callbacks (cpp_reader * cr ATTRIBUTE_UNUSED)\n-{\n-  abort ();\n-}\n+#define NULL_BINDING_LEVEL (struct binding_level *) NULL                        \n \n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *) 0).\n    Initialize the global binding level.\n    Make definitions for built-in primitive functions.  */\n \n-  /* `unsigned long' is the standard type for sizeof.\n-     Note that stddef.h uses `unsigned long',\n-     and this must agree, even if long and int are the same size.  */\n-\n-/* The reserved keyword table.  */\n-struct resword\n-{\n-  const char *word;\n-  ENUM_BITFIELD(rid) rid : 16;\n-  unsigned int disable   : 16;\n-};\n-\n-static const struct resword reswords[] =\n-{\n-  { \"_Bool\",\t\tRID_BOOL,\t0 },\n-  { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n-  { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n-  { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n-  { \"__alignof\",\tRID_ALIGNOF,\t0 },\n-  { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n-  { \"__asm\",\t\tRID_ASM,\t0 },\n-  { \"__asm__\",\t\tRID_ASM,\t0 },\n-  { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n-  { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n-  { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, 0 },\n-  { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, 0 },\n-  { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n-  { \"__complex\",\tRID_COMPLEX,\t0 },\n-  { \"__complex__\",\tRID_COMPLEX,\t0 },\n-  { \"__const\",\t\tRID_CONST,\t0 },\n-  { \"__const__\",\tRID_CONST,\t0 },\n-  { \"__extension__\",\tRID_EXTENSION,\t0 },\n-  { \"__func__\",\t\tRID_C99_FUNCTION_NAME, 0 },\n-  { \"__imag\",\t\tRID_IMAGPART,\t0 },\n-  { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n-  { \"__inline\",\t\tRID_INLINE,\t0 },\n-  { \"__inline__\",\tRID_INLINE,\t0 },\n-  { \"__label__\",\tRID_LABEL,\t0 },\n-  { \"__ptrbase\",\tRID_PTRBASE,\t0 },\n-  { \"__ptrbase__\",\tRID_PTRBASE,\t0 },\n-  { \"__ptrextent\",\tRID_PTREXTENT,\t0 },\n-  { \"__ptrextent__\",\tRID_PTREXTENT,\t0 },\n-  { \"__ptrvalue\",\tRID_PTRVALUE,\t0 },\n-  { \"__ptrvalue__\",\tRID_PTRVALUE,\t0 },\n-  { \"__real\",\t\tRID_REALPART,\t0 },\n-  { \"__real__\",\t\tRID_REALPART,\t0 },\n-  { \"__restrict\",\tRID_RESTRICT,\t0 },\n-  { \"__restrict__\",\tRID_RESTRICT,\t0 },\n-  { \"__signed\",\t\tRID_SIGNED,\t0 },\n-  { \"__signed__\",\tRID_SIGNED,\t0 },\n-  { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n-  { \"__typeof__\",\tRID_TYPEOF,\t0 },\n-  { \"__volatile\",\tRID_VOLATILE,\t0 },\n-  { \"__volatile__\",\tRID_VOLATILE,\t0 },\n-  { \"asm\",\t\tRID_ASM,\t0 },\n-  { \"auto\",\t\tRID_AUTO,\t0 },\n-  { \"break\",\t\tRID_BREAK,\t0 },\n-  { \"case\",\t\tRID_CASE,\t0 },\n-  { \"char\",\t\tRID_CHAR,\t0 },\n-  { \"const\",\t\tRID_CONST,\t0 },\n-  { \"continue\",\t\tRID_CONTINUE,\t0 },\n-  { \"default\",\t\tRID_DEFAULT,\t0 },\n-  { \"do\",\t\tRID_DO,\t\t0 },\n-  { \"double\",\t\tRID_DOUBLE,\t0 },\n-  { \"else\",\t\tRID_ELSE,\t0 },\n-  { \"enum\",\t\tRID_ENUM,\t0 },\n-  { \"extern\",\t\tRID_EXTERN,\t0 },\n-  { \"float\",\t\tRID_FLOAT,\t0 },\n-  { \"for\",\t\tRID_FOR,\t0 },\n-  { \"goto\",\t\tRID_GOTO,\t0 },\n-  { \"if\",\t\tRID_IF,\t\t0 },\n-  { \"inline\",\t\tRID_INLINE,\t0 },\n-  { \"int\",\t\tRID_INT,\t0 },\n-  { \"long\",\t\tRID_LONG,\t0 },\n-  { \"register\",\t\tRID_REGISTER,\t0 },\n-  { \"restrict\",\t\tRID_RESTRICT,\t0 },\n-  { \"return\",\t\tRID_RETURN,\t0 },\n-  { \"short\",\t\tRID_SHORT,\t0 },\n-  { \"signed\",\t\tRID_SIGNED,\t0 },\n-  { \"sizeof\",\t\tRID_SIZEOF,\t0 },\n-  { \"static\",\t\tRID_STATIC,\t0 },\n-  { \"struct\",\t\tRID_STRUCT,\t0 },\n-  { \"switch\",\t\tRID_SWITCH,\t0 },\n-  { \"typedef\",\t\tRID_TYPEDEF,\t0 },\n-  { \"typeof\",\t\tRID_TYPEOF,\t0 },\n-  { \"union\",\t\tRID_UNION,\t0 },\n-  { \"unsigned\",\t\tRID_UNSIGNED,\t0 },\n-  { \"void\",\t\tRID_VOID,\t0 },\n-  { \"volatile\",\t\tRID_VOLATILE,\t0 },\n-  { \"while\",\t\tRID_WHILE,\t0 },\n-};\n-#define N_reswords (sizeof reswords / sizeof (struct resword))\n-\n-/* Init enough to allow the C decl code to work, then clean up\n-   afterwards.  */\n-\n void\n treelang_init_decl_processing ()\n {\n-  unsigned int i;\n-  tree id;\n-\n-  ridpointers = (tree *) ggc_calloc ((int) RID_MAX, sizeof (tree));\n-\n-  for (i = 0; i < N_reswords; i++)\n-    {\n-      id = get_identifier (reswords[i].word);\n-      C_RID_CODE (id) = reswords[i].rid;\n-      C_IS_RESERVED_WORD (id) = 1;\n-      ridpointers [(int) reswords[i].rid] = id;\n-    }\n-\n-  c_init_decl_processing ();\n-\n-  /* ix86_return_pops_args takes the type of these so need to patch\n-     their own type as themselves.  */\n-\n-  for (i = 0; i < itk_none; i++)\n-    {\n-      if (integer_types[i])\n-        TREE_TYPE (integer_types [i]) = integer_types[i];\n-    }\n-\n-  /* Probably these ones too.  */\n-  TREE_TYPE (float_type_node) = float_type_node;\n-  TREE_TYPE (double_type_node) = double_type_node;\n-  TREE_TYPE (long_double_type_node) = long_double_type_node;\n-\n+  current_function_decl = NULL;\n+  current_binding_level = NULL_BINDING_LEVEL;\n+  pushlevel (0);\t/* make the binding_level structure for global names */\n+  global_binding_level = current_binding_level;\n+\n+  build_common_tree_nodes (flag_signed_char);\n+\n+  /* set standard type names */\n+\n+  /* Define `int' and `char' first so that dbx will output them first.  */\n+\n+  tree_push_atomic_type_decl (get_identifier (\"int\"), integer_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"char\"), char_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"long int\"),\n+\t\t\t      long_integer_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"unsigned int\"),\n+\t\t\t      unsigned_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"long unsigned int\"),\n+\t\t\t      long_unsigned_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"long long int\"),\n+\t\t\t      long_long_integer_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"long long unsigned int\"),\n+\t\t\t      long_long_unsigned_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"short int\"),\n+\t\t\t      short_integer_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"short unsigned int\"),\n+\t\t\t      short_unsigned_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"signed char\"),\n+\t\t\t      signed_char_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"unsigned char\"),\n+\t\t\t      unsigned_char_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, intQI_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, intHI_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, intSI_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, intDI_type_node);\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  tree_push_atomic_type_decl (NULL_TREE, intTI_type_node);\n+#endif\n+  tree_push_atomic_type_decl (NULL_TREE, unsigned_intQI_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, unsigned_intHI_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, unsigned_intSI_type_node);\n+  tree_push_atomic_type_decl (NULL_TREE, unsigned_intDI_type_node);\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  tree_push_atomic_type_decl (NULL_TREE, unsigned_intTI_type_node);\n+#endif\n+  \n+  size_type_node = make_unsigned_type (POINTER_SIZE);\n+  tree_push_atomic_type_decl (get_identifier (\"size_t\"), size_type_node);\n+  set_sizetype (size_type_node);\n+\n+  build_common_tree_nodes_2 (/* short_double= */ 0);\n+\n+  tree_push_atomic_type_decl (get_identifier (\"float\"), float_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"double\"), double_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"long double\"), long_double_type_node);\n+  tree_push_atomic_type_decl (get_identifier (\"void\"), void_type_node);\n+\n+  /* Add any target-specific builtin functions.  */\n+  (*targetm.init_builtins) ();\n+\n+  pedantic_lvalues = pedantic;\n }\n \n-/* Save typing debug_tree all the time. Dump a tree T pretty and\n-   concise.  */\n+/* Return a definition for a builtin function named NAME and whose data type\n+   is TYPE.  TYPE should be a function type with argument types.\n+   FUNCTION_CODE tells later passes how to compile calls to this function.\n+   See tree.h for its possible values.\n \n-void dt (tree t);\n+   If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n+   the name to be called if we can't opencode the function.  If\n+   ATTRS is nonzero, use that for the function's attribute list.\n \n-void\n-dt (tree t)\n-{\n-  debug_tree (t);\n-}\n-\n-/* Get a stringpool entry for a string S of length L.  This is needed\n-   because the GTY routines don't mark strings, forcing you to put\n-   them into stringpool, which is never freed.  */\n+   copied from gcc/c-decl.c\n+*/\n \n-const char*\n-get_string (const char *s, size_t l)\n+tree\n+builtin_function (name, type, function_code, class, library_name, attrs)\n+     const char *name;\n+     tree type;\n+     int function_code;\n+     enum built_in_class class;\n+     const char *library_name;\n+     tree attrs;\n {\n-  tree t;\n-  t = get_identifier_with_length (s, l);\n-  return IDENTIFIER_POINTER(t);\n+  tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  if (library_name)\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n+  make_decl_rtl (decl, NULL);\n+  pushdecl (decl);\n+  DECL_BUILT_IN_CLASS (decl) = class;\n+  DECL_FUNCTION_CODE (decl) = function_code;\n+\n+  /* Possibly apply some default attributes to this built-in function.  */\n+  if (attrs)\n+    decl_attributes (&decl, attrs, ATTR_FLAG_BUILT_IN);\n+  else\n+    decl_attributes (&decl, NULL_TREE, 0);\n+\n+  return decl;\n }\n \n+#include \"debug.h\" /* for debug_hooks, needed by gt-treelang-treetree.h */\n+#include \"gt-treelang-treetree.h\""}]}