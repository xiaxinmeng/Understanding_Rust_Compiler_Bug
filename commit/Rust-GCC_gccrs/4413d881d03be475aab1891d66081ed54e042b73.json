{"sha": "4413d881d03be475aab1891d66081ed54e042b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQxM2Q4ODFkMDNiZTQ3NWFhYjE4OTFkNjYwODFlZDU0ZTA0MmI3Mw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-10-29T02:02:10Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-10-29T02:02:10Z"}, "message": "re PR middle-end/29335 (transcendental functions with constant arguments should be resolved at compile-time)\n\n\tPR middle-end/29335\n\t* builtins.c (do_mpfr_arg2, fold_builtin_hypot): New.\n\t(fold_builtin_pow): Evaluate constant arguments at compile-time\n\tusing MPFR.\n\t(fold_builtin_1): Handle BUILT_IN_ATAN2 and BUILT_IN_HYPOT.\n\t(do_mpfr_ckconv): New helper function.\n\t(do_mpfr_arg1): Use do_mpfr_ckconv.\n\t(do_mpfr_arg2): New.\n\ntestsuite:\n\t* gcc.dg/builtins-20.c: Add tests for hypot.\n\t* gcc.dg/torture/builtin-math-2.c (TESTIT2): New.  Add tests for\n\ttwo-argument builtins.\n\t* gcc.dg/torture/builtin-math-3.c (TESTIT_R): Renamed from\n\tTESTIT2.  Update all callers.\n\t(TESTIT2, TESTIT2_R): New helper macros.\n\tAdd testcases for pow, hypot and atan2.\n\nFrom-SVN: r118129", "tree": {"sha": "cab82ea78089af1aeb39e45b02ea963d4f45a7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cab82ea78089af1aeb39e45b02ea963d4f45a7e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4413d881d03be475aab1891d66081ed54e042b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4413d881d03be475aab1891d66081ed54e042b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4413d881d03be475aab1891d66081ed54e042b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4413d881d03be475aab1891d66081ed54e042b73/comments", "author": null, "committer": null, "parents": [{"sha": "5c9ab0a6eec9628575740a3640cf3d12e0d70132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9ab0a6eec9628575740a3640cf3d12e0d70132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c9ab0a6eec9628575740a3640cf3d12e0d70132"}], "stats": {"total": 432, "additions": 365, "deletions": 67}, "files": [{"sha": "0f33ba89a709f49d5bcd02b31ccff95912639853", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413d881d03be475aab1891d66081ed54e042b73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413d881d03be475aab1891d66081ed54e042b73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4413d881d03be475aab1891d66081ed54e042b73", "patch": "@@ -1,3 +1,14 @@\n+2006-10-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/29335\n+\t* builtins.c (do_mpfr_arg2, fold_builtin_hypot): New.\n+\t(fold_builtin_pow): Evaluate constant arguments at compile-time\n+\tusing MPFR.\n+\t(fold_builtin_1): Handle BUILT_IN_ATAN2 and BUILT_IN_HYPOT.\n+\t(do_mpfr_ckconv): New helper function.\n+\t(do_mpfr_arg1): Use do_mpfr_ckconv.\n+\t(do_mpfr_arg2): New.\n+\n 2006-10-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR tree-opt/29271"}, {"sha": "aedecc9afd073b36a98c57e7ea059faecf0d0ddd", "filename": "gcc/builtins.c", "status": "modified", "additions": 152, "deletions": 29, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4413d881d03be475aab1891d66081ed54e042b73", "patch": "@@ -205,6 +205,8 @@ static char target_percent_s[3];\n static char target_percent_s_newline[4];\n static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n+static tree do_mpfr_arg2 (tree, tree, tree,\n+\t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n \n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n@@ -7662,17 +7664,72 @@ fold_builtin_logarithm (tree fndecl, tree arglist,\n   return 0;\n }\n \n+/* Fold a builtin function call to hypot, hypotf, or hypotl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_hypot (tree fndecl, tree arglist, tree type)\n+{\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree res;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpfr_arg2 (arg0, arg1, type, mpfr_hypot)))\n+    return res;\n+  \n+  /* If either argument is zero, hypot is fabs of the other.  */\n+  if (real_zerop (arg0))\n+    return fold_build1 (ABS_EXPR, type, arg1);\n+  else if (real_zerop (arg1))\n+    return fold_build1 (ABS_EXPR, type, arg0);\n+      \n+  /* hypot(x,x) -> x*sqrt(2).  */\n+  if (operand_equal_p (arg0, arg1, OEP_PURE_SAME))\n+    {\n+      REAL_VALUE_TYPE sqrt2;\n+\n+      real_sqrt (&sqrt2, TYPE_MODE (type), &dconst2);\n+      return fold_build2 (MULT_EXPR, type, arg0,\n+\t\t\t  build_real (type, sqrt2));\n+    }\n+\n+  /* Transform hypot(-x,y) or hypot(x,-y) or hypot(-x,-y) into\n+     hypot(x,y).  */\n+  if (TREE_CODE (arg0) == NEGATE_EXPR || TREE_CODE (arg1) == NEGATE_EXPR)\n+    {\n+      tree narg0 = (TREE_CODE (arg0) == NEGATE_EXPR)\n+\t? TREE_OPERAND (arg0, 0) : arg0;\n+      tree narg1 = (TREE_CODE (arg1) == NEGATE_EXPR)\n+\t? TREE_OPERAND (arg1, 0) : arg1;\n+      tree narglist = tree_cons (NULL_TREE, narg0,\n+\t\t\t\t build_tree_list (NULL_TREE, narg1));\n+      return build_function_call_expr (fndecl, narglist);\n+    }\n+  \n+  return NULL_TREE;\n+}\n+\n+\n /* Fold a builtin function call to pow, powf, or powl.  Return\n    NULL_TREE if no simplification can be made.  */\n static tree\n fold_builtin_pow (tree fndecl, tree arglist, tree type)\n {\n   tree arg0 = TREE_VALUE (arglist);\n   tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n \n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpfr_arg2 (arg0, arg1, type, mpfr_pow)))\n+    return res;\n+\n   /* Optimize pow(1.0,y) = 1.0.  */\n   if (real_onep (arg0))\n     return omit_one_operand (type, build_real (type, dconst1), arg1);\n@@ -9093,6 +9150,16 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n \t\t\t     &dconstm1, NULL, false);\n     break;\n \n+    CASE_FLT_FN (BUILT_IN_ATAN2):\n+      if (validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+\treturn do_mpfr_arg2 (TREE_VALUE (arglist),\n+\t\t\t     TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t     type, mpfr_atan2);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_HYPOT):\n+      return fold_builtin_hypot (fndecl, arglist, type);\n+    \n     CASE_FLT_FN (BUILT_IN_POW):\n       return fold_builtin_pow (fndecl, arglist, type);\n \n@@ -11303,6 +11370,43 @@ init_target_chars (void)\n   return true;\n }\n \n+/* Helper function for do_mpfr_arg*().  Ensure M is a normal number\n+   and no overflow/underflow occurred.  INEXACT is true if M was not\n+   exacly calculated.  TYPE is the tree type for the result.  This\n+   function assumes that you cleared the MPFR flags and then\n+   calculated M to see if anything subsequently set a flag prior to\n+   entering this function.  Return NULL_TREE if any checks fail.  */\n+\n+static tree\n+do_mpfr_ckconv(mpfr_srcptr m, tree type, int inexact)\n+{\n+  /* Proceed iff we get a normal number, i.e. not NaN or Inf and no\n+     overflow/underflow occurred.  If -frounding-math, proceed iff the\n+     result of calling FUNC was exact.  */\n+  if (mpfr_number_p (m) && !mpfr_overflow_p() && !mpfr_underflow_p()\n+      && (!flag_rounding_math || !inexact))\n+    {\n+      REAL_VALUE_TYPE rr;\n+\n+      real_from_mpfr (&rr, m);\n+      /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR value,\n+\t check for overflow/underflow.  If the REAL_VALUE_TYPE is zero\n+\t but the mpft_t is not, then we underflowed in the\n+\t conversion.  */\n+      if (!real_isnan (&rr) && !real_isinf (&rr)\n+\t  && (rr.cl == rvc_zero) == (mpfr_zero_p (m) != 0))\n+        {\n+\t  REAL_VALUE_TYPE rmode;\n+\n+\t  real_convert (&rmode, TYPE_MODE (type), &rr);\n+\t  /* Proceed iff the specified mode can hold the value.  */\n+\t  if (real_identical (&rmode, &rr))\n+\t    return build_real (type, rmode);\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n /* If argument ARG is a REAL_CST, call the one-argument mpfr function\n    FUNC on it and return the resulting value as a tree with type TYPE.\n    If MIN and/or MAX are not NULL, then the supplied ARG must be\n@@ -11323,46 +11427,65 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \n   if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n     {\n-      REAL_VALUE_TYPE r = TREE_REAL_CST (arg);\n+      const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n \n-      if (!real_isnan (&r) && !real_isinf (&r)\n-\t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , &r, min))\n-\t  && (!max || real_compare (inclusive ? LE_EXPR: LT_EXPR , &r, max)))\n+      if (!real_isnan (ra) && !real_isinf (ra)\n+\t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , ra, min))\n+\t  && (!max || real_compare (inclusive ? LE_EXPR: LT_EXPR , ra, max)))\n         {\n-\t  const enum machine_mode mode = TYPE_MODE (type);\n-\t  const int prec = REAL_MODE_FORMAT (mode)->p;\n+\t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n \t  int inexact;\n \t  mpfr_t m;\n \n \t  mpfr_init2 (m, prec);\n-\t  mpfr_from_real (m, &r);\n+\t  mpfr_from_real (m, ra);\n \t  mpfr_clear_flags();\n \t  inexact = func (m, m, GMP_RNDN);\n-\n-\t  /* Proceed iff we get a normal number, i.e. not NaN or Inf\n-\t     and no overflow/underflow occurred.  If -frounding-math,\n-\t     proceed iff the result of calling FUNC was exact.  */\n-\t  if (mpfr_number_p (m) && !mpfr_overflow_p() && !mpfr_underflow_p()\n-\t      && (!flag_rounding_math || !inexact))\n-\t    {\n-\t      real_from_mpfr (&r, m);\n-\t      /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR\n-\t\t value, check for overflow/underflow.  If the\n-\t\t REAL_VALUE_TYPE is zero but the mpft_t is not, then\n-\t\t we underflowed in the conversion.  */\n-\t      if (!real_isnan (&r) && !real_isinf (&r)\n-\t\t  && (r.cl == rvc_zero) == (mpfr_zero_p (m) != 0))\n-\t        {\n-\t\t  REAL_VALUE_TYPE rmode;\n-\t\t  real_convert (&rmode, mode, &r);\n-\t\t  /* Proceed iff the specified mode can hold the value.  */\n-\t\t  if (real_identical (&rmode, &r))\n-\t\t    result = build_real (type, rmode);\n-\t\t}\n-\t    }\n+\t  result = do_mpfr_ckconv (m, type, inexact);\n \t  mpfr_clear (m);\n \t}\n     }\n   \n   return result;\n }\n+\n+/* If argument ARG is a REAL_CST, call the two-argument mpfr function\n+   FUNC on it and return the resulting value as a tree with type TYPE.\n+   The mpfr precision is set to the precision of TYPE.  We assume that\n+   function FUNC returns zero if the result could be calculated\n+   exactly within the requested precision.  */\n+\n+static tree\n+do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n+\t      int (*func)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t))\n+{\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg1);\n+  STRIP_NOPS (arg2);\n+\n+  if (TREE_CODE (arg1) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg1)\n+      && TREE_CODE (arg2) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg2))\n+    {\n+      const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n+      const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n+\n+      if (!real_isnan (ra1) && !real_isinf (ra1)\n+\t  && !real_isnan (ra2) && !real_isinf (ra2))\n+        {\n+\t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n+\t  int inexact;\n+\t  mpfr_t m1, m2;\n+\n+\t  mpfr_inits2 (prec, m1, m2, NULL);\n+\t  mpfr_from_real (m1, ra1);\n+\t  mpfr_from_real (m2, ra2);\n+\t  mpfr_clear_flags();\n+\t  inexact = func (m1, m1, m2, GMP_RNDN);\n+\t  result = do_mpfr_ckconv (m1, type, inexact);\n+\t  mpfr_clears (m1, m2, NULL);\n+\t}\n+    }\n+  \n+  return result;\n+}"}, {"sha": "28024ecf57900c802b450c5d820bdf8c9f7f9baf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4413d881d03be475aab1891d66081ed54e042b73", "patch": "@@ -1,3 +1,13 @@\n+2006-10-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/builtins-20.c: Add tests for hypot.\n+\t* gcc.dg/torture/builtin-math-2.c (TESTIT2): New.  Add tests for\n+\ttwo-argument builtins.\n+\t* gcc.dg/torture/builtin-math-3.c (TESTIT_R): Renamed from\n+\tTESTIT2.  Update all callers.\n+\t(TESTIT2, TESTIT2_R): New helper macros.\n+\tAdd testcases for pow, hypot and atan2.\n+\n 2006-10-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR C++/29295"}, {"sha": "1c8bb9b0cb99cd7d86375ef39a8abad125c6b8ef", "filename": "gcc/testsuite/gcc.dg/builtins-20.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-20.c?ref=4413d881d03be475aab1891d66081ed54e042b73", "patch": "@@ -15,12 +15,15 @@\n extern double cos (double);\n extern double sin (double);\n extern double tan (double);\n+extern double hypot (double, double);\n extern float cosf (float);\n extern float sinf (float);\n extern float tanf (float);\n+extern float hypotf (float, float);\n extern long double cosl (long double);\n extern long double sinl (long double);\n extern long double tanl (long double);\n+extern long double hypotl (long double, long double);\n \n extern void link_error(void);\n \n@@ -55,6 +58,24 @@ void test2(double x, double y)\n \n   if (-sin(x-y) != sin(y-x))\n     link_error ();\n+\n+  if (hypot (x, 0) != __builtin_fabs(x))\n+    link_error ();\n+\n+  if (hypot (0, x) != __builtin_fabs(x))\n+    link_error ();\n+\n+  if (hypot (x, x) != x * __builtin_sqrt(2))\n+    link_error ();\n+\n+  if (hypot (-x, y) != hypot (x, y))\n+    link_error ();\n+\n+  if (hypot (x, -y) != hypot (x, y))\n+    link_error ();\n+\n+  if (hypot (-x, -y) != hypot (x, y))\n+    link_error ();\n }\n \n void test1f(float x)\n@@ -90,6 +111,24 @@ void test2f(float x, float y)\n \n   if (-sinf(x-y) != sinf(y-x))\n     link_error ();\n+\n+  if (hypotf (x, 0) != __builtin_fabsf(x))\n+    link_error ();\n+\n+  if (hypotf (0, x) != __builtin_fabsf(x))\n+    link_error ();\n+\n+  if (hypotf (x, x) != x * __builtin_sqrtf(2))\n+    link_error ();\n+\n+  if (hypotf (-x, y) != hypotf (x, y))\n+    link_error ();\n+\n+  if (hypotf (x, -y) != hypotf (x, y))\n+    link_error ();\n+\n+  if (hypotf (-x, -y) != hypotf (x, y))\n+    link_error ();\n }\n \n \n@@ -126,6 +165,24 @@ void test2l(long double x, long double y)\n \n   if (-sinl(x-y) != sinl(y-x))\n     link_error ();\n+\n+  if (hypotl (x, 0) != __builtin_fabsl(x))\n+    link_error ();\n+\n+  if (hypotl (0, x) != __builtin_fabsl(x))\n+    link_error ();\n+\n+  if (hypotl (x, x) != x * __builtin_sqrtl(2))\n+    link_error ();\n+\n+  if (hypotl (-x, y) != hypotl (x, y))\n+    link_error ();\n+\n+  if (hypotl (x, -y) != hypotl (x, y))\n+    link_error ();\n+\n+  if (hypotl (-x, -y) != hypotl (x, y))\n+    link_error ();\n }\n \n int main()"}, {"sha": "a2213da2f913ccd05ff1091f303e9a0cab6681b7", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-2.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-2.c?ref=4413d881d03be475aab1891d66081ed54e042b73", "patch": "@@ -18,6 +18,12 @@ extern void fool (long double);\n   fool (__builtin_##FUNC##l (ARG##L)); \\\n } while (0)\n \n+#define TESTIT2(FUNC, ARG1, ARG2) do { \\\n+  foof (__builtin_##FUNC##f (ARG1##F, ARG2##F)); \\\n+  foo (__builtin_##FUNC (ARG1, ARG2)); \\\n+  fool (__builtin_##FUNC##l (ARG1##L, ARG2##L)); \\\n+} while (0)\n+\n void bar()\n {\n   /* An argument of NaN is not evaluated at compile-time.  */\n@@ -83,6 +89,43 @@ void bar()\n   /* The log1p arg must be [-1 ... Inf] EXclusive.  */\n   TESTIT (log1p, -2.0);\n   TESTIT (log1p, -1.0);\n+\n+  /* An argument of NaN is not evaluated at compile-time.  */\n+  foof (__builtin_powf (__builtin_nanf(\"\"), 2.5F));\n+  foo (__builtin_pow (__builtin_nan(\"\"), 2.5));\n+  fool (__builtin_powl (__builtin_nanl(\"\"), 2.5L));\n+  foof (__builtin_powf (2.5F, __builtin_nanf(\"\")));\n+  foo (__builtin_pow (2.5, __builtin_nan(\"\")));\n+  fool (__builtin_powl (2.5L, __builtin_nanl(\"\")));\n+\n+  /* An argument of Inf/-Inf is not evaluated at compile-time.  */\n+  foof (__builtin_powf (__builtin_inff(), 2.5F));\n+  foo (__builtin_pow (__builtin_inf(), 2.5));\n+  fool (__builtin_powl (__builtin_infl(), 2.5L));\n+  foof (__builtin_powf (-__builtin_inff(), 2.5F));\n+  foo (__builtin_pow (-__builtin_inf(), 2.5));\n+  fool (__builtin_powl (-__builtin_infl(), 2.5L));\n+  foof (__builtin_powf (2.5F, __builtin_inff()));\n+  foo (__builtin_pow (2.5, __builtin_inf()));\n+  fool (__builtin_powl (2.5L, __builtin_infl()));\n+  foof (__builtin_powf (2.5F, -__builtin_inff()));\n+  foo (__builtin_pow (2.5, -__builtin_inf()));\n+  fool (__builtin_powl (2.5L, -__builtin_infl()));\n+\n+  /* Check for Inv/NaN return values.  */\n+  TESTIT2 (pow, -0.0, -4.5); /* Returns Inf */\n+  TESTIT2 (pow, 0.0, -4.5); /* Returns Inf */\n+  TESTIT2 (pow, -3.0, -4.5); /* Returns NaN */\n+\n+  /* Check for overflow/underflow.  */\n+  foof (__builtin_powf (__FLT_MAX__, 3.5F));\n+  foo (__builtin_pow (__DBL_MAX__, 3.5));\n+  fool (__builtin_powl (__LDBL_MAX__, 3.5L));\n+  TESTIT2 (pow, 2.0, 0x1p50);\n+  foof (__builtin_powf (__FLT_MAX__, -3.5F));\n+  foo (__builtin_pow (__DBL_MAX__, -3.5));\n+  fool (__builtin_powl (__LDBL_MAX__, -3.5L));\n+  TESTIT2 (pow, 2.0, -0x1p50);\n }\n \n /* { dg-final { scan-tree-dump-times \"exp2 \" 9 \"original\" } } */\n@@ -112,4 +155,7 @@ void bar()\n /* { dg-final { scan-tree-dump-times \"log1p \" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"log1pf\" 2 \"original\" } } */\n /* { dg-final { scan-tree-dump-times \"log1pl\" 2 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"pow \" 13 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"powf\" 13 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"powl\" 13 \"original\" } } */\n /* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "3efe021d8db00330d3cd24099f639f92a37e21c6", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-3.c", "status": "modified", "additions": 89, "deletions": 38, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4413d881d03be475aab1891d66081ed54e042b73/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c?ref=4413d881d03be475aab1891d66081ed54e042b73", "patch": "@@ -23,8 +23,8 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   } while (0);\n \n-/* Test that (LOW) < FUNC(ARG) < (HI).  */\n-#define TESTIT2(FUNC,ARG,LOW,HI) do { \\\n+/* Range test, check that (LOW) < FUNC(ARG) < (HI).  */\n+#define TESTIT_R(FUNC,ARG,LOW,HI) do { \\\n   if (__builtin_##FUNC##f(ARG) <= (LOW) || __builtin_##FUNC##f(ARG) >= (HI)) \\\n     link_error(__LINE__); \\\n   if (__builtin_##FUNC(ARG) <= (LOW) || __builtin_##FUNC(ARG) >= (HI)) \\\n@@ -33,70 +33,93 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   } while (0);\n \n+/* Test that FUNC(ARG1, ARG2) == (RES).  */\n+#define TESTIT2(FUNC,ARG1,ARG2,RES) do { \\\n+  if (__builtin_##FUNC##f(ARG1##F, ARG2##F) != RES##F) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG1, ARG2) != RES) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG1##L, ARG2##L) != RES##L) \\\n+    link_error(__LINE__); \\\n+  } while (0);\n+\n+/* Range test, check that (LOW) < FUNC(ARG1,ARG2) < (HI).  */\n+#define TESTIT2_R(FUNC,ARG1,ARG2,LOW,HI) do { \\\n+  if (__builtin_##FUNC##f(ARG1, ARG2) <= (LOW) \\\n+      || __builtin_##FUNC##f(ARG1, ARG2) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG1, ARG2) <= (LOW) \\\n+      || __builtin_##FUNC(ARG1, ARG2) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG1, ARG2) <= (LOW) \\\n+      || __builtin_##FUNC##l(ARG1, ARG2) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  } while (0);\n+\n int main (void)\n {\n-  TESTIT2 (asin, -1.0, -3.15/2.0, -3.14/2.0); /* asin(-1) == -pi/2 */\n+  TESTIT_R (asin, -1.0, -3.15/2.0, -3.14/2.0); /* asin(-1) == -pi/2 */\n   TESTIT (asin, 0.0, 0.0); /* asin(0) == 0 */\n   TESTIT (asin, -0.0, -0.0); /* asin(-0) == -0 */\n-  TESTIT2 (asin, 1.0, 3.14/2.0, 3.15/2.0); /* asin(1) == pi/2 */\n+  TESTIT_R (asin, 1.0, 3.14/2.0, 3.15/2.0); /* asin(1) == pi/2 */\n \n-  TESTIT2 (acos, -1.0, 3.14, 3.15); /* acos(-1) == pi */\n-  TESTIT2 (acos, 0.0, 3.14/2.0, 3.15/2.0); /* acos(0) == pi/2 */\n-  TESTIT2 (acos, -0.0, 3.14/2.0, 3.15/2.0); /* acos(-0) == pi/2 */\n+  TESTIT_R (acos, -1.0, 3.14, 3.15); /* acos(-1) == pi */\n+  TESTIT_R (acos, 0.0, 3.14/2.0, 3.15/2.0); /* acos(0) == pi/2 */\n+  TESTIT_R (acos, -0.0, 3.14/2.0, 3.15/2.0); /* acos(-0) == pi/2 */\n   TESTIT (acos, 1.0, 0.0); /* acos(1) == 0 */\n \n-  TESTIT2 (atan, -1.0, -3.15/4.0, -3.14/4.0); /* atan(-1) == -pi/4 */\n+  TESTIT_R (atan, -1.0, -3.15/4.0, -3.14/4.0); /* atan(-1) == -pi/4 */\n   TESTIT (atan, 0.0, 0.0); /* atan(0) == 0 */\n   TESTIT (atan, -0.0, -0.0); /* atan(-0) == -0 */\n-  TESTIT2 (atan, 1.0, 3.14/4.0, 3.15/4.0); /* atan(1) == pi/4 */\n+  TESTIT_R (atan, 1.0, 3.14/4.0, 3.15/4.0); /* atan(1) == pi/4 */\n \n-  TESTIT2 (asinh, -1.0, -0.89, -0.88); /* asinh(-1) == -0.881... */\n+  TESTIT_R (asinh, -1.0, -0.89, -0.88); /* asinh(-1) == -0.881... */\n   TESTIT (asinh, 0.0, 0.0); /* asinh(0) == 0 */\n   TESTIT (asinh, -0.0, -0.0); /* asinh(-0) == -0 */\n-  TESTIT2 (asinh, 1.0, 0.88, 0.89); /* asinh(1) == 0.881... */\n+  TESTIT_R (asinh, 1.0, 0.88, 0.89); /* asinh(1) == 0.881... */\n \n   TESTIT (acosh, 1.0, 0.0); /* acosh(1) == 0. */\n-  TESTIT2 (acosh, 2.0, 1.31, 1.32); /* acosh(2) == 1.316... */\n+  TESTIT_R (acosh, 2.0, 1.31, 1.32); /* acosh(2) == 1.316... */\n \n-  TESTIT2 (atanh, -0.5, -0.55, -0.54); /* atanh(-0.5) == -0.549... */\n+  TESTIT_R (atanh, -0.5, -0.55, -0.54); /* atanh(-0.5) == -0.549... */\n   TESTIT (atanh, 0.0, 0.0); /* atanh(0) == 0 */\n   TESTIT (atanh, -0.0, -0.0); /* atanh(-0) == -0 */\n-  TESTIT2 (atanh, 0.5, 0.54, 0.55); /* atanh(0.5) == 0.549... */\n+  TESTIT_R (atanh, 0.5, 0.54, 0.55); /* atanh(0.5) == 0.549... */\n \n-  TESTIT2 (sin, -1.0, -0.85, -0.84); /* sin(-1) == -0.841... */\n+  TESTIT_R (sin, -1.0, -0.85, -0.84); /* sin(-1) == -0.841... */\n   TESTIT (sin, 0.0, 0.0); /* sin(0) == 0 */\n   TESTIT (sin, -0.0, -0.0); /* sin(-0) == -0 */\n-  TESTIT2 (sin, 1.0, 0.84, 0.85); /* sin(1) == 0.841... */\n+  TESTIT_R (sin, 1.0, 0.84, 0.85); /* sin(1) == 0.841... */\n \n-  TESTIT2 (cos, -1.0, 0.54, 0.55); /* cos(-1) == 0.5403... */\n+  TESTIT_R (cos, -1.0, 0.54, 0.55); /* cos(-1) == 0.5403... */\n   TESTIT (cos, 0.0, 1.0); /* cos(0) == 1 */\n   TESTIT (cos, -0.0, 1.0); /* cos(-0) == 1 */\n-  TESTIT2 (cos, 1.0, 0.54, 0.55); /* cos(1) == 0.5403... */\n+  TESTIT_R (cos, 1.0, 0.54, 0.55); /* cos(1) == 0.5403... */\n \n-  TESTIT2 (tan, -1.0, -1.56, 1.55); /* tan(-1) == -1.557... */\n+  TESTIT_R (tan, -1.0, -1.56, 1.55); /* tan(-1) == -1.557... */\n   TESTIT (tan, 0.0, 0.0); /* tan(0) == 0 */\n   TESTIT (tan, -0.0, -0.0); /* tan(-0) == -0 */\n-  TESTIT2 (tan, 1.0, 1.55, 1.56); /* tan(1) == 1.557... */\n+  TESTIT_R (tan, 1.0, 1.55, 1.56); /* tan(1) == 1.557... */\n \n-  TESTIT2 (sinh, -1.0, -1.18, -1.17); /* sinh(-1) == -1.175... */\n+  TESTIT_R (sinh, -1.0, -1.18, -1.17); /* sinh(-1) == -1.175... */\n   TESTIT (sinh, 0.0, 0.0); /* sinh(0) == 0 */\n   TESTIT (sinh, -0.0, -0.0); /* sinh(-0) == -0 */\n-  TESTIT2 (sinh, 1.0, 1.17, 1.18); /* sinh(1) == 1.175... */\n+  TESTIT_R (sinh, 1.0, 1.17, 1.18); /* sinh(1) == 1.175... */\n \n-  TESTIT2 (cosh, -1.0, 1.54, 1.55); /* cosh(-1) == 1.543... */\n+  TESTIT_R (cosh, -1.0, 1.54, 1.55); /* cosh(-1) == 1.543... */\n   TESTIT (cosh, 0.0, 1.0); /* cosh(0) == 1 */\n   TESTIT (cosh, -0.0, 1.0); /* cosh(-0) == 1 */\n-  TESTIT2 (cosh, 1.0, 1.54, 1.55); /* cosh(1) == 1.543... */\n+  TESTIT_R (cosh, 1.0, 1.54, 1.55); /* cosh(1) == 1.543... */\n \n-  TESTIT2 (tanh, -1.0, -0.77, -0.76); /* tanh(-1) == -0.761... */\n+  TESTIT_R (tanh, -1.0, -0.77, -0.76); /* tanh(-1) == -0.761... */\n   TESTIT (tanh, -0.0, -0.0); /* tanh(-0) == -0 */\n   TESTIT (tanh, 0.0, 0.0); /* tanh(0) == 0 */\n-  TESTIT2 (tanh, 1.0, 0.76, 0.77); /* tanh(1) == 0.761... */\n+  TESTIT_R (tanh, 1.0, 0.76, 0.77); /* tanh(1) == 0.761... */\n \n-  TESTIT2 (exp, -1.0, 0.36, 0.37); /* exp(-1) == 1/e */\n+  TESTIT_R (exp, -1.0, 0.36, 0.37); /* exp(-1) == 1/e */\n   TESTIT (exp, -0.0, 1.0); /* exp(-0) == 1 */\n   TESTIT (exp, 0.0, 1.0); /* exp(0) == 1 */\n-  TESTIT2 (exp, 1.0, 2.71, 2.72); /* exp(1) == e */\n+  TESTIT_R (exp, 1.0, 2.71, 2.72); /* exp(1) == e */\n \n   TESTIT (exp2, -1.0, 0.5); /* exp2(-1) == 1/2 */\n   TESTIT (exp2, -0.0, 1.0); /* exp2(-0) == 1 */\n@@ -113,14 +136,14 @@ int main (void)\n   TESTIT (pow10, 0.0, 1.0); /* pow10(0) == 1 */\n   TESTIT (pow10, 1.0, 10.0); /* pow10(1) == 10 */\n \n-  TESTIT2 (expm1, -1.0, -0.64, -0.63); /* expm1(-1) == 1/e - 1 */\n+  TESTIT_R (expm1, -1.0, -0.64, -0.63); /* expm1(-1) == 1/e - 1 */\n   TESTIT (expm1, -0.0, -0.0); /* expm1(-0) == 0 */\n   TESTIT (expm1, 0.0, 0.0); /* expm1(0) == 0 */\n-  TESTIT2 (expm1, 1.0, 1.71, 1.72); /* expm1(1) == e - 1 */\n+  TESTIT_R (expm1, 1.0, 1.71, 1.72); /* expm1(1) == e - 1 */\n \n   TESTIT (log, 1.0, 0.0); /* log(1) == 0 */\n-  TESTIT2 (log, M_E, 0.99, 1.01); /* log(e) == 1.000... */\n-  TESTIT2 (log, M_E*M_E, 1.99, 2.01); /* log(e*e) == 2.000... */\n+  TESTIT_R (log, M_E, 0.99, 1.01); /* log(e) == 1.000... */\n+  TESTIT_R (log, M_E*M_E, 1.99, 2.01); /* log(e*e) == 2.000... */\n \n   TESTIT (log2, 1.0, 0.0); /* log2(1) == 0 */\n   TESTIT (log2, 2.0, 1.0); /* log2(2) == 1 */\n@@ -132,8 +155,8 @@ int main (void)\n \n   TESTIT (log1p, 0.0, 0.0); /* log1p(0) == 0 */\n   TESTIT (log1p, -0.0, -0.0); /* log1p(-0) == -0 */\n-  TESTIT2 (log1p, M_E-1, 0.99, 1.01); /* log1p(e-1) == 1.000... */\n-  TESTIT2 (log1p, M_E*M_E-1, 1.99, 2.01); /* log1p(e*e-1) == 2.000... */\n+  TESTIT_R (log1p, M_E-1, 0.99, 1.01); /* log1p(e-1) == 1.000... */\n+  TESTIT_R (log1p, M_E*M_E-1, 1.99, 2.01); /* log1p(e*e-1) == 2.000... */\n \n   TESTIT (cbrt, -0.0, -0.0); /* cbrt(-0) == -0 */\n   TESTIT (cbrt, 0.0, 0.0); /* cbrt(0) == 0 */\n@@ -144,13 +167,41 @@ int main (void)\n \n   TESTIT (erf, -0.0, -0.0); /* erf(-0) == -0 */\n   TESTIT (erf, 0.0, 0.0); /* erf(0) == 0 */\n-  TESTIT2 (erf, 1.0, 0.84, 0.85); /* erf(1) == 0.842... */\n-  TESTIT2 (erf, -1.0, -0.85, -0.84); /* erf(-1) == -0.842... */\n+  TESTIT_R (erf, 1.0, 0.84, 0.85); /* erf(1) == 0.842... */\n+  TESTIT_R (erf, -1.0, -0.85, -0.84); /* erf(-1) == -0.842... */\n \n   TESTIT (erfc, -0.0, 1.0); /* erfc(-0) == 1 */\n   TESTIT (erfc, 0.0, 1.0); /* erfc(0) == 1 */\n-  TESTIT2 (erfc, 1.0, 0.15, 0.16); /* erfc(1) == 0.157... */\n-  TESTIT2 (erfc, -1.0, 1.84, 1.85); /* erfc(-1) == 1.842... */\n+  TESTIT_R (erfc, 1.0, 0.15, 0.16); /* erfc(1) == 0.157... */\n+  TESTIT_R (erfc, -1.0, 1.84, 1.85); /* erfc(-1) == 1.842... */\n+\n+  TESTIT2 (pow, 3.0, 4.0, 81.0); /* pow(3,4) == 81 */\n+  TESTIT2 (pow, -3.0, 5.0, -243.0); /* pow(-3,5) == -243 */\n+  TESTIT2 (pow, 16.0, 0.25, 2.0); /* pow(16,1/4) == 2 */\n+  TESTIT2 (pow, 4.0, -2.0, 0.0625); /* pow(4,-2) == 1/16 */\n+  TESTIT2 (pow, -2.0, -3.0, -0.125); /* pow(-2,-3) == -1/8 */\n+  TESTIT2_R (pow, -1.5, -3.0, -0.297, -0.296); /* pow(-1.5,-3) == -1/3.375 */\n+\n+  TESTIT2 (hypot, 0.0, 0.0, 0.0); /* hypot(0,0) == 0 */\n+  TESTIT2 (hypot, -0.0, 0.0, 0.0); /* hypot(-0,0) == 0 */\n+  TESTIT2 (hypot, 0.0, -0.0, 0.0); /* hypot(0,-0) == 0 */\n+  TESTIT2 (hypot, -0.0, -0.0, 0.0); /* hypot(-0,-0) == 0 */\n+  TESTIT2 (hypot, 3.0, 4.0, 5.0); /* hypot(3,4) == 5 */\n+  TESTIT2 (hypot, -3.0, 4.0, 5.0); /* hypot(-3,4) == 5 */\n+  TESTIT2 (hypot, 3.0, -4.0, 5.0); /* hypot(3,-4) == 5 */\n+  TESTIT2 (hypot, -3.0, -4.0, 5.0); /* hypot(-3,-4) == 5 */\n+  TESTIT2_R (hypot, 4.0, 5.0, 6.40, 6.41); /* hypot(4,5) == 6.403... */\n+\n+  TESTIT2 (atan2, 0.0, 0.0, 0.0) /* atan2(0,0) == 0 */\n+  TESTIT2 (atan2, -0.0, 0.0, -0.0) /* atan2(-0,0) == -0 */\n+  TESTIT2_R (atan2, 0.0, -0.0, 3.14, 3.15) /* atan2(0,-0) == pi */\n+  TESTIT2_R (atan2, -0.0, -0.0, -3.15, -3.14) /* atan2(-0,-0) == -pi */\n+  TESTIT2_R (atan2, 0.0, -1.0, 3.14, 3.15) /* atan2(0,-1) == pi */\n+  TESTIT2_R (atan2, -0.0, -1.0, -3.15, -3.14) /* atan2(-0,-1) == -pi */\n+  TESTIT2 (atan2, 0.0, 1.0, 0.0) /* atan2(0,1) == 0 */\n+  TESTIT2 (atan2, -0.0, 1.0, -0.0) /* atan2(-0,1) == -0 */\n+  TESTIT2_R (atan2, -1.0, 0.0, -1.58, -1.57) /* atan2(-1,0) == -pi/2 */\n+  TESTIT2_R (atan2, 1.0, 0.0, 1.57, 1.58) /* atan2(1,0) == pi/2 */\n \n   return 0;\n }"}]}