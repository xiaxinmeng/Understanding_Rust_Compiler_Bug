{"sha": "40bc204a9b045fb4ddcd4412dddf93cdea720a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiYzIwNGE5YjA0NWZiNGRkY2Q0NDEyZGRkZjkzY2RlYTcyMGEyZQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-15T21:53:26Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-15T21:53:26Z"}, "message": "Revert previous inintended changes.\n\nFrom-SVN: r83203", "tree": {"sha": "ff5b912a6b949ca7edf8234ca9c25fbde176a0ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff5b912a6b949ca7edf8234ca9c25fbde176a0ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40bc204a9b045fb4ddcd4412dddf93cdea720a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bc204a9b045fb4ddcd4412dddf93cdea720a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40bc204a9b045fb4ddcd4412dddf93cdea720a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40bc204a9b045fb4ddcd4412dddf93cdea720a2e/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef4215401ab8001886973790886dfd75446c037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef4215401ab8001886973790886dfd75446c037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ef4215401ab8001886973790886dfd75446c037"}], "stats": {"total": 130, "additions": 129, "deletions": 1}, "files": [{"sha": "88e8773a07a4d22b39c446455ed3992642136e57", "filename": "gcc/testsuite/lib/f-torture.exp", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40bc204a9b045fb4ddcd4412dddf93cdea720a2e/gcc%2Ftestsuite%2Flib%2Ff-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40bc204a9b045fb4ddcd4412dddf93cdea720a2e/gcc%2Ftestsuite%2Flib%2Ff-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ff-torture.exp?ref=40bc204a9b045fb4ddcd4412dddf93cdea720a2e", "patch": "@@ -124,7 +124,135 @@ proc f-torture-compile { src option } {\n #\n # f-torture-execute -- utility to compile and execute a testcase\n #\n-# SRC is the full pathname of the\n+# SRC is the full pathname of the testcase.\n+#\n+# If the testcase has an associated .x file, we source that to run the\n+# test instead.  We use .x so that we don't lengthen the existing filename\n+# to more than 14 chars.\n+#\n+proc f-torture-execute { src } {\n+    global tmpdir tool srcdir output compiler_conditional_xfail_data\n+\n+    # Check for alternate driver.\n+    if [file exists [file rootname $src].x] {\n+\tverbose \"Using alternate driver [file rootname [file tail $src]].x\" 2\n+\tset done_p 0\n+\tcatch \"set done_p \\[source [file rootname $src].x\\]\"\n+\tif { $done_p } {\n+\t    return\n+\t}\n+    }\n+   \n+    # Look for a loop within the source code - if we don't find one,\n+    # don't pass -funroll[-all]-loops.\n+    global torture_with_loops torture_without_loops\n+    if [expr [search_for_re $src \"do *\\[0-9\\]\"]+[search_for_re $src \"end *do\"]] then {\n+\tset option_list $torture_with_loops\n+    } else {\n+\tset option_list $torture_without_loops\n+    }\n+\n+    set executable $tmpdir/[file tail [file rootname $src].x]\n+\n+    regsub \"^$srcdir/?\" $src \"\" testcase\n+    # If we couldn't rip $srcdir out of `src' then just do the best we can.\n+    # The point is to reduce the unnecessary noise in the logs.  Don't strip\n+    # out too much because different testcases with the same name can confuse\n+    # `test-tool'.\n+    if [string match \"/*\" $testcase] {\n+\tset testcase \"[file tail [file dirname $src]]/[file tail $src]\"\n+    }\n+\n+    foreach option $option_list {\n+\t# torture_{compile,execute}_xfail are set by the .x script\n+\t# (if present)\n+\tif [info exists torture_compile_xfail] {\n+\t    setup_xfail $torture_compile_xfail\n+\t}\n+\n+\t# torture_execute_before_{compile,execute} can be set by the .x script\n+\t# (if present)\n+\tif [info exists torture_eval_before_compile] {\n+            set ignore_me [eval $torture_eval_before_compile]\n+\t}\n+\n+\tremote_file build delete $executable\n+\tverbose \"Testing $testcase, $option\" 1\n+\n+\tset options \"\"\n+\tlappend options \"additional_flags=-w $option\"\n+\tset comp_output [g77_target_compile \"$src\" \"$executable\" executable $options];\n+\n+\t# Set a few common compiler messages.\n+\tset fatal_signal \"*77*: Internal compiler error: program*got fatal signal\"\n+\t\n+\tif [string match \"$fatal_signal 6\" $comp_output] then {\n+\t    g77_fail $testcase \"Got Signal 6, $option\"\n+\t    remote_file build delete $executable\n+\t    continue\n+\t}\n+\t\n+\tif [string match \"$fatal_signal 11\" $comp_output] then {\n+\t    g77_fail $testcase \"Got Signal 11, $option\"\n+\t    remote_file build delete $executable\n+\t    continue\n+\t}\n+\t\n+\t# We shouldn't get these because of -w, but just in case.\n+\tif [string match \"*77*:*warning:*\" $comp_output] then {\n+\t    warning \"$testcase: (with warnings) $option\"\n+\t    send_log \"$comp_output\\n\"\n+\t    unresolved \"$testcase, $option\"\n+\t    remote_file build delete $executable\n+\t    continue\n+\t}\n+\t\n+\tset comp_output [prune_warnings $comp_output]\n+\t\n+\tset unsupported_message [g77_check_unsupported_p $comp_output]\n+\n+\tif { $unsupported_message != \"\" } {\n+\t    unsupported \"$testcase: $unsupported_message\"\n+\t    continue\n+\t} elseif ![file exists $executable] {\n+\t    if ![is3way] {\n+\t\tfail \"$testcase compilation, $option\"\n+\t\tuntested \"$testcase execution, $option\"\n+\t\tcontinue\n+\t    } else {\n+\t\t# FIXME: since we can't test for the existance of a remote\n+\t\t# file without short of doing an remote file list, we assume\n+\t\t# that since we got no output, it must have compiled.\n+\t\tpass \"$testcase compilation, $option\"\t\t\n+\t    }\n+\t} else {\n+\t    pass \"$testcase compilation, $option\"\n+\t}\n+\n+\t# See if this source file uses \"long long\" types, if it does, and\n+\t# no_long_long is set, skip execution of the test.\n+\tif [target_info exists no_long_long] then {\n+\t    if [expr [search_for_re $src \"integer\\*8\"]] then {\n+\t\tuntested \"$testcase execution, $option\"\n+\t\tcontinue\n+\t    }\n+\t}\n+\n+\tif [info exists torture_execute_xfail] {\n+\t    setup_xfail $torture_execute_xfail\n+\t}\n+\n+\tif [info exists torture_eval_before_execute] {\n+            set ignore_me [eval $torture_eval_before_execute]\n+\t}\n+\n+\tset result [g77_load \"$executable\" \"\" \"\"]\n+\tset status [lindex $result 0];\n+\tset output [lindex $result 1];\n+        if { $status == \"pass\" } {\n+\t    remote_file build delete $executable\n+        }\n+\t$status \"$testcase execution, $option\"\n     }\n }\n "}]}