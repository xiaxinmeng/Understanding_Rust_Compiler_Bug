{"sha": "e78410bf1198e3ce4a37678c991821359b0fde79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc4NDEwYmYxMTk4ZTNjZTRhMzc2NzhjOTkxODIxMzU5YjBmZGU3OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-28T21:14:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-28T21:14:23Z"}, "message": "basic-block.h (RDIV): Define.\n\n\t* basic-block.h (RDIV): Define.\n\t(EDGE_FREQUENCY): Simplify.\n\t(check_probability, combine_probabilities, apply_probability,\n\tinverse_probability): New.\n\t* cfgloop.c (scale_loop_profile): New function.\n\t* cfgloop.h (scale_loop_profile): Declare.\n\t(slpeel_add_loop_guard): Add probability parameter.\n\t(set_prologue_iterations): Add probability parameter.\n\t(slpeel_tree_peel_loop_to_edge): Add bound1 and bound2 parameters;\n\tupdate probabilities correctly.\n\t(vect_do_peeling_for_alignment, vect_gen_niters_for_prolog_loop): New.\n\nFrom-SVN: r191839", "tree": {"sha": "c4ddc30456b3babd4ddd7a75d077274a158cd121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4ddc30456b3babd4ddd7a75d077274a158cd121"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e78410bf1198e3ce4a37678c991821359b0fde79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78410bf1198e3ce4a37678c991821359b0fde79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78410bf1198e3ce4a37678c991821359b0fde79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78410bf1198e3ce4a37678c991821359b0fde79/comments", "author": null, "committer": null, "parents": [{"sha": "0380c51fefbf548d957595868069e1af09190e69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0380c51fefbf548d957595868069e1af09190e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0380c51fefbf548d957595868069e1af09190e69"}], "stats": {"total": 249, "additions": 235, "deletions": 14}, "files": [{"sha": "78c31bca6f40c450c4304bcde0250eb1397d0436", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e78410bf1198e3ce4a37678c991821359b0fde79", "patch": "@@ -1,3 +1,17 @@\n+2012-09-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (RDIV): Define.\n+\t(EDGE_FREQUENCY): Simplify.\n+\t(check_probability, combine_probabilities, apply_probability,\n+\tinverse_probability): New.\n+\t* cfgloop.c (scale_loop_profile): New function.\n+\t* cfgloop.h (scale_loop_profile): Declare.\n+\t(slpeel_add_loop_guard): Add probability parameter.\n+\t(set_prologue_iterations): Add probability parameter.\n+\t(slpeel_tree_peel_loop_to_edge): Add bound1 and bound2 parameters;\n+\tupdate probabilities correctly.\n+\t(vect_do_peeling_for_alignment, vect_gen_niters_for_prolog_loop): New.\n+\n 2012-09-20  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR bootstrap/54688"}, {"sha": "a5491b030119546cedfc93be2dd30dc42e55f276", "filename": "gcc/basic-block.h", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e78410bf1198e3ce4a37678c991821359b0fde79", "patch": "@@ -478,11 +478,10 @@ struct edge_list\n #define BRANCH_EDGE(bb)\t\t\t(EDGE_SUCC ((bb), 0)->flags & EDGE_FALLTHRU \\\n \t\t\t\t\t ? EDGE_SUCC ((bb), 1) : EDGE_SUCC ((bb), 0))\n \n+#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n /* Return expected execution frequency of the edge E.  */\n-#define EDGE_FREQUENCY(e)\t\t(((e)->src->frequency \\\n-\t\t\t\t\t  * (e)->probability \\\n-\t\t\t\t\t  + REG_BR_PROB_BASE / 2) \\\n-\t\t\t\t\t / REG_BR_PROB_BASE)\n+#define EDGE_FREQUENCY(e)\t\tRDIV ((e)->src->frequency * (e)->probability, \\\n+\t\t\t\t\t      REG_BR_PROB_BASE)\n \n /* Return nonzero if edge is critical.  */\n #define EDGE_CRITICAL_P(e)\t\t(EDGE_COUNT ((e)->src->succs) >= 2 \\\n@@ -910,4 +909,40 @@ extern void default_rtl_profile (void);\n /* In profile.c.  */\n extern gcov_working_set_t *find_working_set(unsigned pct_times_10);\n \n+/* Check tha probability is sane.  */\n+\n+static inline void\n+check_probability (int prob)\n+{\n+  gcc_checking_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n+}\n+\n+/* Given PROB1 and PROB2, return PROB1*PROB2/REG_BR_PROB_BASE. \n+   Used to combine BB probabilities.  */\n+\n+static inline int\n+combine_probabilities (int prob1, int prob2)\n+{\n+  check_probability (prob1);\n+  check_probability (prob2);\n+  return RDIV (prob1 * prob2, REG_BR_PROB_BASE);\n+}\n+\n+/* Apply probability PROB on frequency or count FREQ.  */\n+\n+static inline gcov_type\n+apply_probability (gcov_type freq, int prob)\n+{\n+  check_probability (prob);\n+  return RDIV (freq * prob, REG_BR_PROB_BASE);\n+}\n+\n+/* Return inverse probability for PROB.  */\n+\n+static inline int\n+inverse_probability (int prob1)\n+{\n+  check_probability (prob1);\n+  return REG_BR_PROB_BASE - prob1;\n+}\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "62d3d50ab690022f73ea6a490d7dc88b4b9e7db8", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=e78410bf1198e3ce4a37678c991821359b0fde79", "patch": "@@ -1666,3 +1666,121 @@ loop_exits_from_bb_p (struct loop *loop, basic_block bb)\n \n   return false;\n }\n+\n+/* Scale the profile estiamte within loop by SCALE.\n+   If ITERATION_BOUND is non-zero, scale even further if loop is predicted\n+   to iterate too many times.  */\n+void\n+scale_loop_profile (struct loop *loop, int scale, int iteration_bound)\n+{\n+  gcov_type iterations = expected_loop_iterations_unbounded (loop);\n+  basic_block *bbs;\n+  unsigned int i;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \";; Scaling loop %i with scale %f, \"\n+\t     \"bounding iterations to %i from guessed %i\\n\",\n+\t     loop->num, (double)scale / REG_BR_PROB_BASE,\n+\t     iteration_bound, (int)iterations);\n+\n+  /* See if loop is predicted to iterate too many times.  */\n+  if (iteration_bound && iterations > 0\n+      && RDIV (iterations * scale, REG_BR_PROB_BASE) > iteration_bound)\n+    {\n+      /* Fixing loop profile for different trip count is not trivial; the exit\n+\t probabilities has to be updated to match and frequencies propagated down\n+\t to the loop body.\n+\n+\t We fully update only the simple case of loop with single exit that is\n+\t either from the latch or BB just before latch and leads from BB with\n+\t simple conditional jump.   This is OK for use in vectorizer.  */\n+      e = single_exit (loop);\n+      if (e)\n+\t{\n+\t  edge other_e;\n+\t  int freq_delta;\n+\t  gcov_type count_delta;\n+\n+          FOR_EACH_EDGE (other_e, ei, e->src->succs)\n+\t    if (!(other_e->flags & (EDGE_ABNORMAL | EDGE_FAKE))\n+\t\t&& e != other_e)\n+\t      break;\n+\n+\t  /* Probability of exit must be 1/iterations.  */\n+\t  freq_delta = EDGE_FREQUENCY (e);\n+\t  e->probability = REG_BR_PROB_BASE / iteration_bound;\n+\t  other_e->probability = inverse_probability (e->probability);\n+\t  freq_delta -= EDGE_FREQUENCY (e);\n+\n+\t  /* Adjust counts accordingly.  */\n+\t  count_delta = e->count;\n+\t  e->count = apply_probability (e->src->count, e->probability);\n+\t  other_e->count = apply_probability (e->src->count, other_e->probability);\n+\t  count_delta -= e->count;\n+\n+\t  /* If latch exists, change its frequency and count, since we changed\n+\t     probability of exit.  Theoretically we should update everything from\n+\t     source of exit edge to latch, but for vectorizer this is enough.  */\n+\t  if (loop->latch\n+\t      && loop->latch != e->src)\n+\t    {\n+\t      loop->latch->frequency += freq_delta;\n+\t      if (loop->latch->frequency < 0)\n+\t\tloop->latch->frequency = 0;\n+\t      loop->latch->count += count_delta;\n+\t      if (loop->latch->count < 0)\n+\t\tloop->latch->count = 0;\n+\t    }\n+\t}\n+\n+      /* Roughly speaking we want to reduce the loop body profile by the\n+\t the difference of loop iterations.  We however can do better if\n+\t we look at the actual profile, if it is available.  */\n+      scale = RDIV (iteration_bound * scale, iterations);\n+      if (loop->header->count)\n+\t{\n+\t  gcov_type count_in = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+\t    if (e->src != loop->latch)\n+\t      count_in += e->count;\n+\n+\t  if (count_in != 0)\n+\t    scale = RDIV (count_in * iteration_bound * REG_BR_PROB_BASE, loop->header->count);\n+\t}\n+      else if (loop->header->frequency)\n+\t{\n+\t  int freq_in = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+\t    if (e->src != loop->latch)\n+\t      freq_in += EDGE_FREQUENCY (e);\n+\n+\t  if (freq_in != 0)\n+\t    scale = RDIV (freq_in * iteration_bound * REG_BR_PROB_BASE, loop->header->frequency);\n+\t}\n+      if (!scale)\n+\tscale = 1;\n+    }\n+\n+  if (scale == REG_BR_PROB_BASE)\n+    return;\n+\n+  /* Scale the actual probabilities.  */\n+  bbs = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      bb->count = RDIV (bb->count * scale, REG_BR_PROB_BASE);\n+      bb->frequency = RDIV (bb->frequency * scale, REG_BR_PROB_BASE);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->count = RDIV (e->count * scale, REG_BR_PROB_BASE);\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \";; guessed iterations are now %i\\n\",\n+\t     (int)expected_loop_iterations_unbounded (loop));\n+  free (bbs);\n+}"}, {"sha": "e0a370f32bff9ec62327021eb8d6cd2649cb67ec", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=e78410bf1198e3ce4a37678c991821359b0fde79", "patch": "@@ -713,5 +713,6 @@ extern void unroll_and_peel_loops (int);\n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n extern bool finite_loop_p (struct loop *);\n+extern void scale_loop_profile (struct loop *loop, int scale, int iteration_bound);\n \n #endif /* GCC_CFGLOOP_H */"}, {"sha": "f480953440fc86f8347fd466eefc71bdfd226fc6", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78410bf1198e3ce4a37678c991821359b0fde79/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=e78410bf1198e3ce4a37678c991821359b0fde79", "patch": "@@ -931,7 +931,8 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n static edge\n slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n \t\t       gimple_seq cond_expr_stmt_list,\n-\t\t       basic_block exit_bb, basic_block dom_bb)\n+\t\t       basic_block exit_bb, basic_block dom_bb,\n+\t\t       int probability)\n {\n   gimple_stmt_iterator gsi;\n   edge new_e, enter_e;\n@@ -956,6 +957,12 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n \n   /* Add new edge to connect guard block to the merge/loop-exit block.  */\n   new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);\n+\n+  new_e->count = guard_bb->count;\n+  new_e->probability = probability;\n+  new_e->count = apply_probability (enter_e->count, probability);\n+  enter_e->count -= new_e->count;\n+  enter_e->probability = inverse_probability (probability);\n   set_immediate_dominator (CDI_DOMINATORS, exit_bb, dom_bb);\n   return new_e;\n }\n@@ -1038,7 +1045,8 @@ static void\n set_prologue_iterations (basic_block bb_before_first_loop,\n \t\t\t tree *first_niters,\n \t\t\t struct loop *loop,\n-\t\t\t unsigned int th)\n+\t\t\t unsigned int th,\n+\t\t\t int probability)\n {\n   edge e;\n   basic_block cond_bb, then_bb;\n@@ -1067,7 +1075,15 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n   e_true->flags &= ~EDGE_FALLTHRU;\n   e_true->flags |= EDGE_TRUE_VALUE;\n \n+  e_true->probability = probability;\n+  e_false->probability = inverse_probability (probability);\n+  e_true->count = apply_probability (cond_bb->count, probability);\n+  e_false->count = cond_bb->count - e_true->count;\n+  then_bb->frequency = EDGE_FREQUENCY (e_true);\n+  then_bb->count = e_true->count;\n+\n   e_fallthru = EDGE_SUCC (then_bb, 0);\n+  e_fallthru->count = then_bb->count;\n \n   gsi = gsi_last_bb (cond_bb);\n   cost_pre_condition =\n@@ -1126,6 +1142,8 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n \t\t\t  prologue generation or whether cost model check\n \t\t\t  has not occurred during prologue generation and hence\n \t\t\t  needs to occur during epilogue generation.\n+   - BOUND1 is the upper bound on number of iterations of the first loop (if known)\n+   - BOUND2 is the upper bound on number of iterations of the second loop (if known)\n \n \n    Output:\n@@ -1153,7 +1171,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n \t\t\t       edge e, tree *first_niters,\n \t\t\t       tree niters, bool update_first_loop_count,\n \t\t\t       unsigned int th, bool check_profitability,\n-\t\t\t       tree cond_expr, gimple_seq cond_expr_stmt_list)\n+\t\t\t       tree cond_expr, gimple_seq cond_expr_stmt_list,\n+\t\t\t       int bound1, int bound2)\n {\n   struct loop *new_loop = NULL, *first_loop, *second_loop;\n   edge skip_e;\n@@ -1166,6 +1185,13 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   edge exit_e = single_exit (loop);\n   LOC loop_loc;\n   tree cost_pre_condition = NULL_TREE;\n+  /* There are many aspects to how likely the first loop is going to be executed.\n+     Without histogram we can't really do good job.  Simply set it to\n+     2/3, so the first loop is not reordered to the end of function and\n+     the hot path through stays short.  */\n+  int first_guard_probability = 2 * REG_BR_PROB_BASE / 3;\n+  int second_guard_probability = 2 * REG_BR_PROB_BASE / 3;\n+  int probability_of_second_loop;\n \n   if (!slpeel_can_duplicate_loop_p (loop, e))\n     return NULL;\n@@ -1341,6 +1367,21 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n   bb_before_second_loop = split_edge (single_exit (first_loop));\n \n+  probability_of_second_loop = (inverse_probability (first_guard_probability)\n+\t\t\t        + combine_probabilities (second_guard_probability,\n+                                                         first_guard_probability));\n+  /* Theoretically preheader edge of first loop and exit edge should have\n+     same frequencies.  Loop exit probablities are however easy to get wrong.\n+     It is safer to copy value from original loop entry.  */\n+  bb_before_second_loop->frequency\n+     = apply_probability (bb_before_first_loop->frequency,\n+\t\t\t  probability_of_second_loop);\n+  bb_before_second_loop->count\n+     = apply_probability (bb_before_first_loop->count,\n+\t\t\t  probability_of_second_loop);\n+  single_succ_edge (bb_before_second_loop)->count\n+     = bb_before_second_loop->count;\n+\n   /* Epilogue peeling.  */\n   if (!update_first_loop_count)\n     {\n@@ -1374,7 +1415,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n     {\n       if (check_profitability)\n \tset_prologue_iterations (bb_before_first_loop, first_niters,\n-\t\t\t\t loop, th);\n+\t\t\t\t loop, th, first_guard_probability);\n \n       pre_condition =\n \tfold_build2 (LE_EXPR, boolean_type_node, *first_niters,\n@@ -1383,7 +1424,10 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n \n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n \t\t\t\t  cond_expr_stmt_list,\n-                                  bb_before_second_loop, bb_before_first_loop);\n+                                  bb_before_second_loop, bb_before_first_loop,\n+\t\t\t\t  inverse_probability (first_guard_probability));\n+  scale_loop_profile (first_loop, first_guard_probability,\n+\t\t      check_profitability && (int)th > bound1 ? th : bound1);\n   slpeel_update_phi_nodes_for_guard1 (skip_e, first_loop,\n \t\t\t\t      first_loop == new_loop,\n \t\t\t\t      &new_exit_bb);\n@@ -1421,7 +1465,9 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   pre_condition =\n \tfold_build2 (EQ_EXPR, boolean_type_node, *first_niters, niters);\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition, NULL,\n-                                  bb_after_second_loop, bb_before_first_loop);\n+                                  bb_after_second_loop, bb_before_first_loop,\n+\t\t\t\t  inverse_probability (second_guard_probability));\n+  scale_loop_profile (second_loop, probability_of_second_loop, bound2);\n   slpeel_update_phi_nodes_for_guard2 (skip_e, second_loop,\n                                      second_loop == new_loop, &new_exit_bb);\n \n@@ -1882,7 +1928,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n                                             &ratio_mult_vf_name, ni_name, false,\n                                             th, check_profitability,\n-\t\t\t\t\t    cond_expr, cond_expr_stmt_list);\n+\t\t\t\t\t    cond_expr, cond_expr_stmt_list,\n+\t\t\t\t\t    0, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n #ifdef ENABLE_CHECKING\n@@ -1951,7 +1998,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n    use TYPE_VECTOR_SUBPARTS.  */\n \n static tree\n-vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n+vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int *bound)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -1977,6 +2024,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n         fprintf (vect_dump, \"known peeling = %d.\", npeel);\n \n       iters = build_int_cst (niters_type, npeel);\n+      *bound = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n     }\n   else\n     {\n@@ -2015,6 +2063,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n \titers = fold_build2 (MINUS_EXPR, type, nelements_tree, elem_misalign);\n       iters = fold_build2 (BIT_AND_EXPR, type, iters, nelements_minus_1);\n       iters = fold_convert (niters_type, iters);\n+      *bound = nelements;\n     }\n \n   /* Create:  prolog_loop_niters = min (iters, loop_niters) */\n@@ -2107,6 +2156,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n   tree wide_prolog_niters;\n   struct loop *new_loop;\n   int max_iter;\n+  int bound = 0;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_alignment ===\");\n@@ -2115,13 +2165,16 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n \n   ni_name = vect_build_loop_niters (loop_vinfo, NULL);\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo,\n-\t\t\t\t\t\t\t   ni_name);\n+\t\t\t\t\t\t\t   ni_name,\n+\t\t\t\t\t\t\t   &bound);\n \n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n   new_loop =\n     slpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t   &niters_of_prolog_loop, ni_name, true,\n-\t\t\t\t   th, check_profitability, NULL_TREE, NULL);\n+\t\t\t\t   th, check_profitability, NULL_TREE, NULL,\n+\t\t\t\t   bound,\n+\t\t\t\t   0);\n \n   gcc_assert (new_loop);\n #ifdef ENABLE_CHECKING"}]}