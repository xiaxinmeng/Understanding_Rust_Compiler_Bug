{"sha": "befe199770ac909a81bd0f1d445e027cbd4eef50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmZTE5OTc3MGFjOTA5YTgxYmQwZjFkNDQ1ZTAyN2NiZDRlZWY1MA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-03-11T16:57:41Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-03-11T16:57:41Z"}, "message": "re PR target/65242 (ICE (in gen_add2_insn, at optabs.c:4761) on powerpc64le-linux-gnu)\n\n[gcc]\n2015-03-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/65242\n\t* config/rs6000/rs6000.c (rs6000_preferred_reload_class): Do not\n\tallow reloads of PLUS in floating point/VSX registers.\n\n[gcc/testsuite]\n2015-03-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/65242\n\t* g++.dg/pr65242.C: New test.\n\nFrom-SVN: r221350", "tree": {"sha": "e0be2abfbd6e024f818b02a61ff382b5007fbc6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0be2abfbd6e024f818b02a61ff382b5007fbc6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/befe199770ac909a81bd0f1d445e027cbd4eef50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befe199770ac909a81bd0f1d445e027cbd4eef50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befe199770ac909a81bd0f1d445e027cbd4eef50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befe199770ac909a81bd0f1d445e027cbd4eef50/comments", "author": null, "committer": null, "parents": [{"sha": "4c3e13dfa2da62c98f156360e63cdf62ebd3f7e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c3e13dfa2da62c98f156360e63cdf62ebd3f7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c3e13dfa2da62c98f156360e63cdf62ebd3f7e5"}], "stats": {"total": 114, "additions": 112, "deletions": 2}, "files": [{"sha": "144df6c81547628d1098199dd7a2ba93f2ef7764", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=befe199770ac909a81bd0f1d445e027cbd4eef50", "patch": "@@ -1,3 +1,9 @@\n+2015-03-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/65242\n+\t* config/rs6000/rs6000.c (rs6000_preferred_reload_class): Do not\n+\tallow reloads of PLUS in floating point/VSX registers.\n+\n 2015-03-11  Junmo Park  <junmoz.park@samsung.com>\n \n \t* config/arm/cortex-a57.md (cortex_a57_crypto_simple): Add crypto_sha256_fast."}, {"sha": "31b46ea4c82bfaa42c6d2006a523628bccab14be", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=befe199770ac909a81bd0f1d445e027cbd4eef50", "patch": "@@ -17645,8 +17645,10 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n   machine_mode mode = GET_MODE (x);\n   bool is_constant = CONSTANT_P (x);\n \n-  /* Do VSX tests before handling traditional floaitng point registers.  */\n-  if (TARGET_VSX && VSX_REG_CLASS_P (rclass))\n+  /* For VSX, see if we should prefer FLOAT_REGS or ALTIVEC_REGS.  Do not allow\n+     the reloading of address expressions using PLUS into floating point\n+     registers.  */\n+  if (TARGET_VSX && VSX_REG_CLASS_P (rclass) && GET_CODE (x) != PLUS)\n     {\n       if (is_constant)\n \t{"}, {"sha": "cd4c9a4003ac829c03b667d7a44307d43f2f2a9e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=befe199770ac909a81bd0f1d445e027cbd4eef50", "patch": "@@ -1,3 +1,8 @@\n+2015-03-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/65242\n+\t* g++.dg/pr65242.C: New test.\n+\n 2015-03-11  Marat Zakirov  <m.zakirov@samsung.com>\n \n \t* c-c++-common/asan/no-asan-check-glob.c: New test."}, {"sha": "c123056586135c3249bdc00c9b5afaf795e49c87", "filename": "gcc/testsuite/g++.dg/pr65242.C", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65242.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe199770ac909a81bd0f1d445e027cbd4eef50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65242.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr65242.C?ref=befe199770ac909a81bd0f1d445e027cbd4eef50", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+class A {\n+public:\n+  int m_fn1();\n+};\n+class B {\n+public:\n+  enum IOMode { reading };\n+};\n+class tn_file_buf_stream : B {\n+public:\n+  tn_file_buf_stream(IOMode);\n+  ~tn_file_buf_stream();\n+};\n+class C {\n+public:\n+  int &operator[](int);\n+};\n+class D {\n+public:\n+  bool m_fn2();\n+};\n+class F {\n+public:\n+  int m_fn3(D &);\n+};\n+class G {\n+public:\n+  D bdt;\n+};\n+class ObjectType {\n+public:\n+  int id;\n+  D weather;\n+  struct H {\n+    F terrainaccess;\n+  };\n+  H m_fn4();\n+  struct {\n+    A images;\n+  } weatherPicture[];\n+  ObjectType *m_fn5();\n+  int m_fn6();\n+} a;\n+#pragma pack(1)\n+class I {};\n+class J {\n+  J(I *);\n+  I translationTableTMISSPart;\n+  void m_fn8();\n+  tn_file_buf_stream *MissFile;\n+  void m_fn9();\n+  virtual G *m_fn7(int, int);\n+};\n+int b, c, d, g;\n+int e[5];\n+short f;\n+void J::m_fn9() {\n+  int h;\n+  C k;\n+  for (; b;) {\n+    int l = c, n = c & 1;\n+    for (int m; d;) {\n+      int o = 0;\n+      for (int p = 0; p < 2 && !o; p++)\n+        if (g)\n+          for (int i; i < a.m_fn6(); i++) {\n+            ObjectType *q = a.m_fn5();\n+            for (int r = 0; r < 6; r++)\n+              if (q->weather.m_fn2())\n+                for (int j; j < q->weatherPicture[r].images.m_fn1(); j++)\n+                  if (e[m]) {\n+                    G *s = m_fn7(l, n);\n+                    if (q->m_fn4().terrainaccess.m_fn3(s->bdt))\n+                      g = o = 1;\n+                  }\n+          }\n+      k[h++] = f;\n+    }\n+  }\n+}\n+\n+void J::m_fn8() try {\n+  tn_file_buf_stream t(B::reading);\n+  MissFile = &t;\n+  m_fn9();\n+  J u(0);\n+  u.m_fn8();\n+}\n+\n+catch (int) {\n+}"}]}