{"sha": "6a64964212c8e5e10e474803d06a07514c1069b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE2NDk2NDIxMmM4ZTVlMTBlNDc0ODAzZDA2YTA3NTE0YzEwNjliNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-23T15:56:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-23T15:56:51Z"}, "message": "Avoid redundant entries in modref access lists.\n\nIn PR101296 Richard noticed that modref is giving up on analysis in milc by\nhitting --param=modref-max-accesses limit.  While cleaning up original modref\npatch I removed code that tried to do smart things while merging accesses\nbecause it had bugs and wanted to reimplement it later which I later forgot.\n\nThis patch adds logic that avoids adding access and its subaccess to the list\nwhich is just waste of memory and compile time.  Incrementally I will add logic\nmerging the ranges.\n\ngcc/ChangeLog:\n\n2021-08-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.h (modref_access_node::range_info_useful_p):\n\tImprove range compare.\n\t(modref_access_node::contains): New member function.\n\t(modref_access_node::search): Remove.\n\t(modref_access_node::insert): Be smarter about subaccesses.\n\ngcc/testsuite/ChangeLog:\n\n2021-08-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/tree-ssa/modref-7.c: New test.", "tree": {"sha": "87898e739a74c441d898d839b961cd339d0dfe07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87898e739a74c441d898d839b961cd339d0dfe07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a64964212c8e5e10e474803d06a07514c1069b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a64964212c8e5e10e474803d06a07514c1069b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a64964212c8e5e10e474803d06a07514c1069b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a64964212c8e5e10e474803d06a07514c1069b7/comments", "author": null, "committer": null, "parents": [{"sha": "29c355f76ceeb4639c21acaf52c50d35c8472720", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29c355f76ceeb4639c21acaf52c50d35c8472720", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29c355f76ceeb4639c21acaf52c50d35c8472720"}], "stats": {"total": 90, "additions": 72, "deletions": 18}, "files": [{"sha": "2e26b75e21f453e6dcbf5c734a47ccd79575ce26", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 59, "deletions": 18, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a64964212c8e5e10e474803d06a07514c1069b7/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a64964212c8e5e10e474803d06a07514c1069b7/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=6a64964212c8e5e10e474803d06a07514c1069b7", "patch": "@@ -66,7 +66,10 @@ struct GTY(()) modref_access_node\n   /* Return true if range info is useful.  */\n   bool range_info_useful_p () const\n     {\n-      return parm_index != -1 && parm_offset_known;\n+      return parm_index != -1 && parm_offset_known\n+\t     && (known_size_p (size)\n+\t\t || known_size_p (max_size)\n+\t\t || known_ge (offset, 0));\n     }\n   /* Return true if both accesses are the same.  */\n   bool operator == (modref_access_node &a) const\n@@ -88,6 +91,35 @@ struct GTY(()) modref_access_node\n \treturn false;\n       return true;\n     }\n+  /* Return true A is a subaccess.  */\n+  bool contains (modref_access_node &a) const\n+    {\n+      if (parm_index != a.parm_index)\n+\treturn false;\n+      if (parm_index >= 0)\n+\t{\n+\t  if (parm_offset_known\n+\t      && (!a.parm_offset_known\n+\t\t  || !known_eq (parm_offset, a.parm_offset)))\n+\t    return false;\n+\t}\n+      if (range_info_useful_p ())\n+\t{\n+\t  if (!a.range_info_useful_p ())\n+\t    return false;\n+\t  /* Sizes of stores are used to check that object is big enough\n+\t     to fit the store, so smaller or unknown sotre is more general\n+\t     than large store.  */\n+\t  if (known_size_p (size)\n+\t      && !known_le (size, a.size))\n+\t    return false;\n+\t  if (known_size_p (max_size))\n+\t    return known_subrange_p (a.offset, a.max_size, offset, max_size);\n+\t  else\n+\t    return known_le (offset, a.offset);\n+\t}\n+      return true;\n+    }\n };\n \n /* Access node specifying no useful info.  */\n@@ -107,17 +139,6 @@ struct GTY((user)) modref_ref_node\n     accesses (NULL)\n   {}\n \n-  /* Search REF; return NULL if failed.  */\n-  modref_access_node *search (modref_access_node access)\n-  {\n-    size_t i;\n-    modref_access_node *a;\n-    FOR_EACH_VEC_SAFE_ELT (accesses, i, a)\n-      if (*a == access)\n-\treturn a;\n-    return NULL;\n-  }\n-\n   /* Collapse the tree.  */\n   void collapse ()\n   {\n@@ -136,16 +157,36 @@ struct GTY((user)) modref_ref_node\n       return false;\n \n     /* Otherwise, insert a node for the ref of the access under the base.  */\n-    modref_access_node *access_node = search (a);\n-    if (access_node)\n-      return false;\n+    size_t i;\n+    modref_access_node *a2;\n+\n+    if (!a.useful_p ())\n+      {\n+\tif (!every_access)\n+\t  {\n+\t    collapse ();\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+\n+    FOR_EACH_VEC_SAFE_ELT (accesses, i, a2)\n+      {\n+\tif (a2->contains (a))\n+\t  return false;\n+\tif (a.contains (*a2))\n+\t  {\n+\t    *a2 = a;\n+\t    return true;\n+\t  }\n+\tgcc_checking_assert (!(a == *a2));\n+      }\n \n     /* If this base->ref pair has too many accesses stored, we will clear\n        all accesses and bail out.  */\n-    if ((accesses && accesses->length () >= max_accesses)\n-\t|| !a.useful_p ())\n+    if (accesses && accesses->length () >= max_accesses)\n       {\n-\tif (dump_file && a.useful_p ())\n+\tif (dump_file)\n \t  fprintf (dump_file,\n \t\t   \"--param param=modref-max-accesses limit reached\\n\");\n \tcollapse ();"}, {"sha": "53ffa1c394c3f0dda78f93974083e4830aae5a1e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a64964212c8e5e10e474803d06a07514c1069b7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a64964212c8e5e10e474803d06a07514c1069b7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-7.c?ref=6a64964212c8e5e10e474803d06a07514c1069b7", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O2 --param modref-max-accesses=1 -fdump-tree-modref1\"  } */\n+/* { dg-do compile } */\n+struct a {\n+  int array[10];\n+  int tail;\n+};\n+int test(struct a *a, int p)\n+{\n+  a->array[p] = 0;\n+  a->array[0] = 1;\n+}\n+/* All three accesses combine to one bigger access.  */\n+/* { dg-final { scan-tree-dump-not \"param=modref-max-accesses\" \"modref1\" } } */"}]}