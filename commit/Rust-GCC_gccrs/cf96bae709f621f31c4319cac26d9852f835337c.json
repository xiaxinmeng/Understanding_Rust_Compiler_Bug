{"sha": "cf96bae709f621f31c4319cac26d9852f835337c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y5NmJhZTcwOWY2MjFmMzFjNDMxOWNhYzI2ZDk4NTJmODM1MzM3Yw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-05-18T15:11:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-18T15:11:01Z"}, "message": "re PR lto/44143 (-fdump-tree-all for lto does not work as expected)\n\n2010-05-18  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/44143\n\t* lto-wrapper.c (verbose): New variable.  Initialize from -v.\n\t(debug): Initialize from -save-temps.\n\t(collect_execute): Print command-line when verbose.\n\t(run_gcc): Always use COLLECT_GCC_OPTIONS.  Use fork_execute\n\tfor ltrans invocation.  Produce -dumpbase flag again.\n\t(process_args): Remove.\n\t(main): Simplify.\n\t* collect2.c (maybe_run_lto_and_relink): Only pass object\n\tfiles to lto-wrapper.\n\t* gcc.c (LINK_COMMAND_SPEC): Likewise.\n\nFrom-SVN: r159536", "tree": {"sha": "29fa0e79a40d95c675cb1520878165eae1fd1985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29fa0e79a40d95c675cb1520878165eae1fd1985"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf96bae709f621f31c4319cac26d9852f835337c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf96bae709f621f31c4319cac26d9852f835337c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf96bae709f621f31c4319cac26d9852f835337c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf96bae709f621f31c4319cac26d9852f835337c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80e2a014c8f9517884c069c7718faa5211c4f895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80e2a014c8f9517884c069c7718faa5211c4f895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80e2a014c8f9517884c069c7718faa5211c4f895"}], "stats": {"total": 431, "additions": 159, "deletions": 272}, "files": [{"sha": "1327cf95fa3320debafe9743adc0b58f74131684", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf96bae709f621f31c4319cac26d9852f835337c", "patch": "@@ -1,3 +1,17 @@\n+2010-05-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44143\n+\t* lto-wrapper.c (verbose): New variable.  Initialize from -v.\n+\t(debug): Initialize from -save-temps.\n+\t(collect_execute): Print command-line when verbose.\n+\t(run_gcc): Always use COLLECT_GCC_OPTIONS.  Use fork_execute\n+\tfor ltrans invocation.  Produce -dumpbase flag again.\n+\t(process_args): Remove.\n+\t(main): Simplify.\n+\t* collect2.c (maybe_run_lto_and_relink): Only pass object\n+\tfiles to lto-wrapper.\n+\t* gcc.c (LINK_COMMAND_SPEC): Likewise.\n+\n 2010-05-18  Jan Hubicka  <jh@suse.cz>\n \n \t* opts.c (decode_options): Do not disable whopr at ipa_cp."}, {"sha": "0669a4e55f198ef2e3981d9026e460a1d2fa1281", "filename": "gcc/collect2.c", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=cf96bae709f621f31c4319cac26d9852f835337c", "patch": "@@ -940,10 +940,8 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n \n   if (lto_objects.first)\n     {\n-      const char *opts;\n       char **lto_c_argv;\n       const char **lto_c_ptr;\n-      const char *cp;\n       const char **p, **q, **r;\n       const char **lto_o_ptr;\n       struct lto_object *list;\n@@ -954,52 +952,15 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       if (!lto_wrapper)\n \tfatal (\"COLLECT_LTO_WRAPPER must be set.\");\n \n+      num_lto_c_args++;\n+\n       /* There is at least one object file containing LTO info,\n          so we need to run the LTO back end and relink.  */\n \n-      /* Get compiler options passed down from the parent `gcc' command.\n-         These must be passed to the LTO back end.  */\n-      opts = getenv (\"COLLECT_GCC_OPTIONS\");\n-\n-      /* Increment the argument count by the number of inherited options.\n-         Some arguments may be filtered out later.  Again, an upper bound\n-         suffices.  */\n-\n-      cp = opts;\n-\n-      while (cp && *cp)\n-        {\n-          extract_string (&cp);\n-          num_lto_c_args++;\n-        }\n-      obstack_free (&temporary_obstack, temporary_firstobj);\n-\n-      if (debug)\n-\tnum_lto_c_args++;\n-\n-      /* Increment the argument count by the number of initial\n-\t arguments added below.  */\n-      num_lto_c_args += 9;\n-\n       lto_c_argv = (char **) xcalloc (sizeof (char *), num_lto_c_args);\n       lto_c_ptr = CONST_CAST2 (const char **, char **, lto_c_argv);\n \n       *lto_c_ptr++ = lto_wrapper;\n-      *lto_c_ptr++ = c_file_name;\n-\n-      cp = opts;\n-\n-      while (cp && *cp)\n-        {\n-          const char *s = extract_string (&cp);\n-\n-\t  /* Pass the option or argument to the wrapper.  */\n-\t  *lto_c_ptr++ = xstrdup (s);\n-        }\n-      obstack_free (&temporary_obstack, temporary_firstobj);\n-\n-      if (debug)\n-\t*lto_c_ptr++ = xstrdup (\"-debug\");\n \n       /* Add LTO objects to the wrapper command line.  */\n       for (list = lto_objects.first; list; list = list->next)"}, {"sha": "41569fc13fc6d2288e34bb5852c4136048ebe291", "filename": "gcc/gcc.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=cf96bae709f621f31c4319cac26d9852f835337c", "patch": "@@ -781,15 +781,9 @@ proper position among the other output files.  */\n     %{fuse-linker-plugin: \\\n     -plugin %(linker_plugin_file) \\\n     -plugin-opt=%(lto_wrapper) \\\n-    -plugin-opt=%(lto_gcc) \\\n     -plugin-opt=-fresolution=%u.res \\\n     %{static|static-libgcc:-plugin-opt=-pass-through=%(lto_libgcc)}\t\\\n     %{static:-plugin-opt=-pass-through=-lc}\t\\\n-    %{O*:-plugin-opt=-O%*} \\\n-    %{w:-plugin-opt=-w} \\\n-    %{f*:-plugin-opt=-f%*} \\\n-    %{m*:-plugin-opt=-m%*} \\\n-    %{v:-plugin-opt=-v} \\\n     } \\\n     %{flto} %{fwhopr} %l \" LINK_PIE_SPEC \\\n    \"%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\\"}, {"sha": "5c9650e49eba70a513ca180eee3e52bca1077042", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 143, "deletions": 225, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf96bae709f621f31c4319cac26d9852f835337c/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=cf96bae709f621f31c4319cac26d9852f835337c", "patch": "@@ -45,12 +45,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"libiberty.h\"\n #include \"obstack.h\"\n \n-int debug;\t\t\t\t/* true if -debug */\n+int debug;\t\t\t\t/* true if -save-temps.  */\n+int verbose;\t\t\t\t/* true if -v.  */\n \n enum lto_mode_d {\n-  LTO_MODE_NONE,\t\t\t/* Not doing LTO. */\n-  LTO_MODE_LTO,\t\t\t\t/* Normal LTO. */\n-  LTO_MODE_WHOPR\t\t\t/* WHOPR. */\n+  LTO_MODE_NONE,\t\t\t/* Not doing LTO.  */\n+  LTO_MODE_LTO,\t\t\t\t/* Normal LTO.  */\n+  LTO_MODE_WHOPR\t\t\t/* WHOPR.  */\n };\n \n /* Current LTO mode.  */\n@@ -129,7 +130,7 @@ collect_execute (char **argv)\n   const char *errmsg;\n   int err;\n \n-  if (debug)\n+  if (verbose)\n     {\n       char **p_argv;\n       const char *str;\n@@ -255,108 +256,157 @@ fork_execute (char **argv)\n static void\n run_gcc (unsigned argc, char *argv[])\n {\n-  unsigned i;\n-  unsigned new_argc = argc;\n+  unsigned i, j;\n   const char **new_argv;\n   const char **argv_ptr;\n   char *list_option_full = NULL;\n+  const char *linker_output = NULL;\n+  const char *collect_gcc_options, *collect_gcc;\n+  struct obstack env_obstack;\n+  bool seen_o = false;\n+\n+  /* Get the driver and options.  */\n+  collect_gcc = getenv (\"COLLECT_GCC\");\n+  if (!collect_gcc)\n+    fatal (\"environment variable COLLECT_GCC must be set\");\n+\n+  /* Set the CFLAGS environment variable.  */\n+  collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (!collect_gcc_options)\n+    fatal (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n+\n+  /* Count arguments.  */\n+  i = 0;\n+  for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n+    if (collect_gcc_options[j] == '\\'')\n+      ++i;\n+\n+  if (i % 2 != 0)\n+    fatal (\"malformed COLLECT_GCC_OPTIONS\");\n+\n+  /* Initalize the common arguments for the driver.  */\n+  new_argv = (const char **) xmalloc ((15 + i / 2 + argc) * sizeof (char *));\n+  argv_ptr = new_argv;\n+  *argv_ptr++ = collect_gcc;\n+  *argv_ptr++ = \"-xlto\";\n+  *argv_ptr++ = \"-c\";\n+  for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n+    if (collect_gcc_options[j] == '\\'')\n+      {\n+\tchar *option;\n+\n+\t++j;\n+\ti = j;\n+\twhile (collect_gcc_options[j] != '\\'')\n+\t  ++j;\n+\n+\tobstack_init (&env_obstack);\n+\tobstack_grow (&env_obstack, &collect_gcc_options[i], j - i);\n+\tobstack_1grow (&env_obstack, 0);\n+\toption = XOBFINISH (&env_obstack, char *);\n+\tif (seen_o)\n+\t  {\n+\t    linker_output = option;\n+\t    seen_o = false;\n+\t    continue;\n+\t  }\n+\n+\t/* If we see -o, skip it and skip and record its argument.  */\n+\tif (option[0] == '-' && option[1] == 'o')\n+\t  {\n+\t    if (option[2] == '\\0')\n+\t      seen_o = true;\n+\t    else\n+\t      linker_output = &option[2];\n+\t    continue;\n+\t  }\n \n-  new_argc += 12;\n-  new_argv = (const char **) xcalloc (sizeof (char *), new_argc);\n+\tif (strcmp (option, \"-save-temps\") == 0)\n+\t  debug = 1;\n+\tif (strcmp (option, \"-v\") == 0)\n+\t  verbose = 1;\n+\n+\t/* We've handled these LTO options, do not pass them on.  */\n+\tif (strcmp (option, \"-flto\") == 0)\n+\t  lto_mode = LTO_MODE_LTO;\n+\telse if (strcmp (option, \"-fwhopr\") == 0)\n+\t  lto_mode = LTO_MODE_WHOPR;\n+\telse\n+\t  *argv_ptr++ = option;\n+      }\n+\n+  if (linker_output)\n+    {\n+      char *output_dir, *base, *name;\n \n-  argv_ptr = new_argv;\n+      output_dir = xstrdup (linker_output);\n+      base = output_dir;\n+      for (name = base; *name; name++)\n+\tif (IS_DIR_SEPARATOR (*name))\n+\t  base = name + 1;\n+      *base = '\\0';\n+\n+      linker_output = &linker_output[base - output_dir];\n+      if (*output_dir == '\\0')\n+\t{\n+\t  static char current_dir[] = { '.', DIR_SEPARATOR, '\\0' };\n+\t  output_dir = current_dir;\n+\t}\n+      *argv_ptr++ = \"-dumpdir\";\n+      *argv_ptr++ = output_dir;\n+\n+      *argv_ptr++ = \"-dumpbase\";\n+    }\n+  else\n+    argv_ptr--;\n \n-  *argv_ptr++ = argv[0];\n-  *argv_ptr++ = \"-combine\";\n-  *argv_ptr++ = \"-x\";\n-  *argv_ptr++ = \"lto\";\n-  *argv_ptr++ = \"-c\";\n   if (lto_mode == LTO_MODE_LTO)\n     {\n       flto_out = make_temp_file (\".lto.o\");\n-      *argv_ptr++ = \"-o\";\n-      *argv_ptr++ = flto_out;\n+      if (linker_output)\n+\targv_ptr[0] = linker_output;\n+      argv_ptr[1] = \"-o\";\n+      argv_ptr[2] = flto_out;\n+      argv_ptr[3] = \"-combine\";\n     }\n   else if (lto_mode == LTO_MODE_WHOPR)\n     {\n       const char *list_option = \"-fltrans-output-list=\";\n       size_t list_option_len = strlen (list_option);\n       char *tmp;\n \n+      if (linker_output)\n+\t{\n+\t  char *dumpbase = (char *) xmalloc (strlen (linker_output)\n+\t\t\t\t\t     + sizeof(\".wpa\") + 1);\n+\t  strcpy (dumpbase, linker_output);\n+\t  strcat (dumpbase, \".wpa\");\n+\t  argv_ptr[0] = dumpbase;\n+\t}\n+\n       ltrans_output_file = make_temp_file (\".ltrans.out\");\n       list_option_full = (char *) xmalloc (sizeof (char) *\n \t\t         (strlen (ltrans_output_file) + list_option_len + 1));\n       tmp = list_option_full;\n \n-      *argv_ptr++ = tmp;\n+      argv_ptr[1] = tmp;\n       strcpy (tmp, list_option);\n       tmp += list_option_len;\n       strcpy (tmp, ltrans_output_file);\n \n-      *argv_ptr++ = \"-fwpa\";\n+      argv_ptr[2] = \"-fwpa\";\n+      argv_ptr[3] = \"-combine\";\n     }\n   else\n     fatal (\"invalid LTO mode\");\n \n-  /* Add inherited GCC options to the LTO back end command line.\n-     Filter out some obviously inappropriate options that will\n-     conflict with  the options that we force above.  We pass\n-     all of the remaining options on to LTO, and let it complain\n-     about any it doesn't like. Note that we invoke LTO via the\n-     `gcc' driver, so the usual option processing takes place.\n-     Except for `-flto' and `-fwhopr', we should only filter options that\n-     are meaningful to `ld', lest an option go silently unclaimed.  */\n-  for (i = 1; i < argc; i++)\n-    {\n-      const char *s = argv[i];\n-\n-      if (strcmp (s, \"-flto\") == 0 || strcmp (s, \"-fwhopr\") == 0)\n-\t/* We've handled this LTO option, don't pass it on.  */\n-\t;\n-      else if (*s == '-' && s[1] == 'o')\n-\t{\n-\t  /* Drop `-o' and its filename argument.  We will use a\n-\t     temporary file for the LTO output.  The `-o' option\n-\t     will be interpreted by the linker.  */\n-\t  if (s[2] == '\\0')\n-\t    {\n-\t      char *output_dir, *base, *name;\n-\n-\t      i++;\n-\t      output_dir = xstrdup (argv[i]);\n-\t      base = output_dir;\n-\t      for (name = base; *name; name++)\n-\t\tif (IS_DIR_SEPARATOR (*name))\n-\t\t  base = name + 1;\n-\t      *base = '\\0';\n-\n-\t      *argv_ptr++ = \"-dumpbase\";\n-\t      if (*output_dir == '\\0')\n-\t\t{\n-\t\t  static char current_dir[] =\n-\t\t    { '.', DIR_SEPARATOR, '\\0' };\n-\t\t  output_dir = current_dir;\n-\t\t  *argv_ptr++ = argv[i];\n-\t\t}\n-\t      else\n-\t\t*argv_ptr++ = &argv[i][base - output_dir];\n-\n-\t      *argv_ptr++ = \"-dumpdir\";\n-\t      *argv_ptr++ = output_dir;\n-\t    }\n-\t}\n-      else\n-\t/* Pass the option or argument to LTO.  */\n-\t*argv_ptr++ = s;\n-    }\n-\n-  *argv_ptr = NULL;\n+  /* Append the input objects and possible preceeding arguments.  */\n+  for (i = 1; i < argc; ++i)\n+    argv_ptr[3 + i] = argv[i];\n+  argv_ptr[3 + i] = NULL;\n \n   fork_execute (CONST_CAST (char **, new_argv));\n \n-  free (new_argv);\n-  new_argv = NULL;\n-\n   if (lto_mode == LTO_MODE_LTO)\n     {\n       printf(\"%s\\n\", flto_out);\n@@ -366,85 +416,12 @@ run_gcc (unsigned argc, char *argv[])\n   else if (lto_mode == LTO_MODE_WHOPR)\n     {\n       FILE *stream = fopen (ltrans_output_file, \"r\");\n-      const char *collect_gcc_options, *collect_gcc;\n-      struct obstack env_obstack;\n-      bool seen_dumpbase = false;\n-      bool seen_o = false;\n-      char *dumpbase_suffix = NULL;\n-      unsigned j;\n+      int nr = 0;\n \n       if (!stream)\n \tfatal_perror (\"fopen: %s\", ltrans_output_file);\n \n-      /* Get the driver and options.  */\n-      collect_gcc = getenv (\"COLLECT_GCC\");\n-      if (!collect_gcc)\n-\tfatal (\"environment variable COLLECT_GCC must be set\");\n-\n-      /* Set the CFLAGS environment variable.  */\n-      collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n-      if (!collect_gcc_options)\n-\tfatal (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n-\n-      /* Count arguments.  */\n-      i = 0;\n-      for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n-\tif (collect_gcc_options[j] == '\\'')\n-\t  ++i;\n-\n-      if (i % 2 != 0)\n-\tfatal (\"malformed COLLECT_GCC_OPTIONS\");\n-\n-      /* Initalize the arguments for the LTRANS driver.  */\n-      new_argv = (const char **) xmalloc ((8 + i / 2) * sizeof (char *));\n-      argv_ptr = new_argv;\n-      *argv_ptr++ = collect_gcc;\n-      *argv_ptr++ = \"-xlto\";\n-      *argv_ptr++ = \"-c\";\n-      for (j = 0; collect_gcc_options[j] != '\\0'; ++j)\n-\tif (collect_gcc_options[j] == '\\'')\n-\t  {\n-\t    char *option;\n-\n-\t    ++j;\n-\t    i = j;\n-\t    while (collect_gcc_options[j] != '\\'')\n-\t      ++j;\n-\t    obstack_init (&env_obstack);\n-\t    obstack_grow (&env_obstack, &collect_gcc_options[i], j - i);\n-\t    if (seen_dumpbase)\n-\t      obstack_grow (&env_obstack, DUMPBASE_SUFFIX,\n-\t\t\t    sizeof (DUMPBASE_SUFFIX));\n-\t    else\n-\t      obstack_1grow (&env_obstack, 0);\n-\t    option = XOBFINISH (&env_obstack, char *);\n-\t    if (seen_dumpbase)\n-\t      {\n-\t\tdumpbase_suffix = option + 7 + j - i;\n-\t\tseen_dumpbase = false;\n-\t      }\n-\t    if (seen_o)\n-\t      {\n-\t\tseen_o = false;\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* If we see -o, skip it and its argument.  */\n-\t    if (strncmp (option, \"-o\", 2) == 0)\n-\t      {\n-\t\tseen_o = true;\n-\t\tcontinue;\n-\t      }\n-\n-\t    /* LTRANS does not need -fwhopr.  */\n-\t    if (strncmp (option, \"-fwhopr\", 7) != 0)\n-\t      {\n-\t\tif (strncmp (option, \"-dumpbase\", 9) == 0)\n-\t\t  seen_dumpbase = true;\n-\t\t*argv_ptr++ = option;\n-\t      }\n-\t  }\n-      *argv_ptr++ = \"-fltrans\";\n+      argv_ptr[1] = \"-fltrans\";\n \n       for (;;)\n \t{\n@@ -473,11 +450,6 @@ run_gcc (unsigned argc, char *argv[])\n \t    }\n \t  else\n \t    {\n-\t      struct pex_obj *pex;\n-\t      const char *errmsg;\n-\t      int err;\n-\t      int status;\n-\n \t      /* Otherwise, add FILES[I] to lto_execute_ltrans command line\n \t\t and add the resulting file to LTRANS output list.  */\n \n@@ -488,44 +460,23 @@ run_gcc (unsigned argc, char *argv[])\n \t      obstack_grow (&env_obstack, \".ltrans.o\", sizeof (\".ltrans.o\"));\n \t      output_name = XOBFINISH (&env_obstack, char *);\n \n-\t      argv_ptr[0] = \"-o\";\n-\t      argv_ptr[1] = output_name;\n-\t      argv_ptr[2] = input_name;\n-\t      argv_ptr[3] = NULL;\n-\n-\t      /* Append a sequence number to -dumpbase for LTRANS.  */\n-\t      if (dumpbase_suffix)\n-\t\tsnprintf (dumpbase_suffix, sizeof (DUMPBASE_SUFFIX) - 7,\n-\t\t\t  \"%lu\", (unsigned long) i);\n-\n-\t      /* Execute the driver.  */\n-\t      pex = pex_init (0, \"lto1\", NULL);\n-\t      if (pex == NULL)\n-\t\tfatal (\"pex_init failed: %s\", xstrerror (errno));\n-\n-\t      errmsg = pex_run (pex, PEX_LAST | PEX_SEARCH, new_argv[0],\n-\t\t\t\tCONST_CAST (char **, new_argv),\n-\t\t\t\tNULL, NULL, &err);\n-\t      if (errmsg)\n-\t\tfatal (\"%s: %s\", errmsg, xstrerror (err));\n-\n-\t      if (!pex_get_status (pex, 1, &status))\n-\t\tfatal (\"can't get program status: %s\", xstrerror (errno));\n-\n-\t      if (status)\n+\t      if (linker_output)\n \t\t{\n-\t\t  if (WIFSIGNALED (status))\n-\t\t    {\n-\t\t      int sig = WTERMSIG (status);\n-\t\t      fatal (\"%s terminated with signal %d [%s]%s\",\n-\t\t\t     new_argv[0], sig, strsignal (sig),\n-\t\t\t     WCOREDUMP (status) ? \", core dumped\" : \"\");\n-\t\t    }\n-\t\t  else\n-\t\t    fatal (\"%s terminated with status %d\", new_argv[0], status);\n+\t\t  char *dumpbase\n+\t\t    = (char *) xmalloc (strlen (linker_output)\n+\t\t\t\t\t+ sizeof(DUMPBASE_SUFFIX) + 1);\n+\t\t  snprintf (dumpbase,\n+\t\t\t    strlen (linker_output) + sizeof(DUMPBASE_SUFFIX),\n+\t\t\t    \"%s.ltrans%d\", linker_output, nr++);\n+\t\t  argv_ptr[0] = dumpbase;\n \t\t}\n \n-\t      pex_free (pex);\n+\t      argv_ptr[2] = \"-o\";\n+\t      argv_ptr[3] = output_name;\n+\t      argv_ptr[4] = input_name;\n+\t      argv_ptr[5] = NULL;\n+\n+\t      fork_execute (CONST_CAST (char **, new_argv));\n \n \t      maybe_unlink_file (input_name);\n \t    }\n@@ -536,38 +487,11 @@ run_gcc (unsigned argc, char *argv[])\n       fclose (stream);\n       maybe_unlink_file (ltrans_output_file);\n       free (list_option_full);\n-      obstack_free (&env_obstack, NULL);\n     }\n   else\n     fatal (\"invalid LTO mode\");\n-}\n-\n-\n-/* Parse the command line. Copy any unused argument to GCC_ARGV. ARGC is the\n-   number of arguments. ARGV contains the arguments. */\n-\n-static int\n-process_args (int argc, char *argv[], char *gcc_argv[])\n-{\n-  int i;\n-  int j = 0;\n \n-  for (i = 1; i < argc; i ++)\n-    {\n-      if (! strcmp (argv[i], \"-debug\"))\n-\tdebug = 1;\n-      else if (! strcmp (argv[i], \"-flto\"))\n-\tlto_mode = LTO_MODE_LTO;\n-      else if (! strcmp (argv[i], \"-fwhopr\"))\n-\tlto_mode = LTO_MODE_WHOPR;\n-      else\n-\t{\n-\t  gcc_argv[j] = argv[i];\n-\t  j++;\n-\t}\n-    }\n-\n-  return j;\n+  obstack_free (&env_obstack, NULL);\n }\n \n \n@@ -576,18 +500,12 @@ process_args (int argc, char *argv[], char *gcc_argv[])\n int\n main (int argc, char *argv[])\n {\n-  char **gcc_argv;\n-  int gcc_argc;\n-\n   gcc_init_libintl ();\n \n   /* We may be called with all the arguments stored in some file and\n      passed with @file.  Expand them into argv before processing.  */\n   expandargv (&argc, &argv);\n-  gcc_argv = (char **) xcalloc (sizeof (char *), argc);\n-  gcc_argc = process_args (argc, argv, gcc_argv);\n-  run_gcc (gcc_argc, gcc_argv);\n-  free (gcc_argv);\n+  run_gcc (argc, argv);\n \n   return 0;\n }"}]}