{"sha": "65752c1f7c41c5641eef298454825910a57146e4", "node_id": "C_kwDOANBUbNoAKDY1NzUyYzFmN2M0MWM1NjQxZWVmMjk4NDU0ODI1OTEwYTU3MTQ2ZTQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-11T21:06:32Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-11T21:06:32Z"}, "message": "analyzer: split out checker_event classes to their own header\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.h: Split out checker_event and its subclasses to...\n\t* checker-event.h: ...this new header.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "82f14437cd1306fedff94396879be04a2451cd27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f14437cd1306fedff94396879be04a2451cd27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65752c1f7c41c5641eef298454825910a57146e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65752c1f7c41c5641eef298454825910a57146e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65752c1f7c41c5641eef298454825910a57146e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65752c1f7c41c5641eef298454825910a57146e4/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c583a2a3da798e82737c2d0e11fd686636cfeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c583a2a3da798e82737c2d0e11fd686636cfeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c583a2a3da798e82737c2d0e11fd686636cfeb"}], "stats": {"total": 1194, "additions": 612, "deletions": 582}, "files": [{"sha": "18c44e600c8702503842cd951ca1c77337ac3958", "filename": "gcc/analyzer/checker-event.h", "status": "added", "additions": 610, "deletions": 0, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65752c1f7c41c5641eef298454825910a57146e4/gcc%2Fanalyzer%2Fchecker-event.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65752c1f7c41c5641eef298454825910a57146e4/gcc%2Fanalyzer%2Fchecker-event.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-event.h?ref=65752c1f7c41c5641eef298454825910a57146e4", "patch": "@@ -0,0 +1,610 @@\n+/* Subclasses of diagnostic_event for analyzer diagnostics.\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CHECKER_EVENT_H\n+#define GCC_ANALYZER_CHECKER_EVENT_H\n+\n+#include \"tree-logical-location.h\"\n+\n+namespace ana {\n+\n+/* An enum for discriminating between the concrete subclasses of\n+   checker_event.  */\n+\n+enum event_kind\n+{\n+  EK_DEBUG,\n+  EK_CUSTOM,\n+  EK_STMT,\n+  EK_REGION_CREATION,\n+  EK_FUNCTION_ENTRY,\n+  EK_STATE_CHANGE,\n+  EK_START_CFG_EDGE,\n+  EK_END_CFG_EDGE,\n+  EK_CALL_EDGE,\n+  EK_RETURN_EDGE,\n+  EK_START_CONSOLIDATED_CFG_EDGES,\n+  EK_END_CONSOLIDATED_CFG_EDGES,\n+  EK_INLINED_CALL,\n+  EK_SETJMP,\n+  EK_REWIND_FROM_LONGJMP,\n+  EK_REWIND_TO_SETJMP,\n+  EK_WARNING\n+};\n+\n+extern const char *event_kind_to_string (enum event_kind ek);\n+\n+/* Event subclasses.\n+\n+   The class hierarchy looks like this (using indentation to show\n+   inheritance, and with event_kinds shown for the concrete subclasses):\n+\n+   diagnostic_event\n+     checker_event\n+       debug_event (EK_DEBUG)\n+       custom_event (EK_CUSTOM)\n+\t precanned_custom_event\n+       statement_event (EK_STMT)\n+       region_creation_event (EK_REGION_CREATION)\n+       function_entry_event (EK_FUNCTION_ENTRY)\n+       state_change_event (EK_STATE_CHANGE)\n+       superedge_event\n+         cfg_edge_event\n+\t   start_cfg_edge_event (EK_START_CFG_EDGE)\n+\t   end_cfg_edge_event (EK_END_CFG_EDGE)\n+         call_event (EK_CALL_EDGE)\n+         return_edge (EK_RETURN_EDGE)\n+       start_consolidated_cfg_edges_event (EK_START_CONSOLIDATED_CFG_EDGES)\n+       end_consolidated_cfg_edges_event (EK_END_CONSOLIDATED_CFG_EDGES)\n+       inlined_call_event (EK_INLINED_CALL)\n+       setjmp_event (EK_SETJMP)\n+       rewind_event\n+         rewind_from_longjmp_event (EK_REWIND_FROM_LONGJMP)\n+\t rewind_to_setjmp_event (EK_REWIND_TO_SETJMP)\n+       warning_event (EK_WARNING).  */\n+\n+/* Abstract subclass of diagnostic_event; the base class for use in\n+   checker_path (the analyzer's diagnostic_path subclass).  */\n+\n+class checker_event : public diagnostic_event\n+{\n+public:\n+  /* Implementation of diagnostic_event.  */\n+\n+  location_t get_location () const final override { return m_loc; }\n+  tree get_fndecl () const final override { return m_effective_fndecl; }\n+  int get_stack_depth () const final override { return m_effective_depth; }\n+  const logical_location *get_logical_location () const final override\n+  {\n+    if (m_effective_fndecl)\n+      return &m_logical_loc;\n+    else\n+      return NULL;\n+  }\n+  meaning get_meaning () const override;\n+\n+  /* Additional functionality.  */\n+\n+  int get_original_stack_depth () const { return m_original_depth; }\n+\n+  virtual void prepare_for_emission (checker_path *,\n+\t\t\t\t     pending_diagnostic *pd,\n+\t\t\t\t     diagnostic_event_id_t emission_id);\n+  virtual bool is_call_p () const { return false; }\n+  virtual bool is_function_entry_p () const  { return false; }\n+  virtual bool is_return_p () const  { return false; }\n+\n+  /* For use with %@.  */\n+  const diagnostic_event_id_t *get_id_ptr () const\n+  {\n+    return &m_emission_id;\n+  }\n+\n+  void dump (pretty_printer *pp) const;\n+  void debug () const;\n+\n+  void set_location (location_t loc) { m_loc = loc; }\n+\n+protected:\n+  checker_event (enum event_kind kind,\n+\t\t location_t loc, tree fndecl, int depth);\n+\n+ public:\n+  const enum event_kind m_kind;\n+ protected:\n+  location_t m_loc;\n+  tree m_original_fndecl;\n+  tree m_effective_fndecl;\n+  int m_original_depth;\n+  int m_effective_depth;\n+  pending_diagnostic *m_pending_diagnostic;\n+  diagnostic_event_id_t m_emission_id; // only set once all pruning has occurred\n+  tree_logical_location m_logical_loc;\n+};\n+\n+/* A concrete event subclass for a purely textual event, for use in\n+   debugging path creation and filtering.  */\n+\n+class debug_event : public checker_event\n+{\n+public:\n+  debug_event (location_t loc, tree fndecl, int depth,\n+\t      const char *desc)\n+  : checker_event (EK_DEBUG, loc, fndecl, depth),\n+    m_desc (xstrdup (desc))\n+  {\n+  }\n+  ~debug_event ()\n+  {\n+    free (m_desc);\n+  }\n+\n+  label_text get_desc (bool) const final override;\n+\n+private:\n+  char *m_desc;\n+};\n+\n+/* An abstract event subclass for custom events.  These are not filtered,\n+   as they are likely to be pertinent to the diagnostic.  */\n+\n+class custom_event : public checker_event\n+{\n+protected:\n+  custom_event (location_t loc, tree fndecl, int depth)\n+  : checker_event (EK_CUSTOM, loc, fndecl, depth)\n+  {\n+  }\n+};\n+\n+/* A concrete custom_event subclass with a precanned message.  */\n+\n+class precanned_custom_event : public custom_event\n+{\n+public:\n+  precanned_custom_event (location_t loc, tree fndecl, int depth,\n+\t\t\t  const char *desc)\n+  : custom_event (loc, fndecl, depth),\n+    m_desc (xstrdup (desc))\n+  {\n+  }\n+  ~precanned_custom_event ()\n+  {\n+    free (m_desc);\n+  }\n+\n+  label_text get_desc (bool) const final override;\n+\n+private:\n+  char *m_desc;\n+};\n+\n+/* A concrete event subclass describing the execution of a gimple statement,\n+   for use at high verbosity levels when debugging paths.  */\n+\n+class statement_event : public checker_event\n+{\n+public:\n+  statement_event (const gimple *stmt, tree fndecl, int depth,\n+\t\t   const program_state &dst_state);\n+\n+  label_text get_desc (bool) const final override;\n+\n+  const gimple * const m_stmt;\n+  const program_state m_dst_state;\n+};\n+\n+/* There are too many combinations to express region creation in one message,\n+   so we emit multiple region_creation_event instances when each pertinent\n+   region is created.\n+\n+   This enum distinguishes between the different messages.  */\n+\n+enum rce_kind\n+{\n+  /* Generate a message based on the memory space of the region\n+     e.g. \"region created on stack here\".  */\n+  RCE_MEM_SPACE,\n+\n+  /* Generate a message based on the capacity of the region\n+     e.g. \"capacity: 100 bytes\".  */\n+  RCE_CAPACITY,\n+\n+  /* Generate a debug message.  */\n+  RCE_DEBUG\n+};\n+\n+/* A concrete event subclass describing the creation of a region that\n+   is significant for a diagnostic.  */\n+\n+class region_creation_event : public checker_event\n+{\n+public:\n+  region_creation_event (const region *reg,\n+\t\t\t tree capacity,\n+\t\t\t enum rce_kind kind,\n+\t\t\t location_t loc, tree fndecl, int depth);\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+\n+private:\n+  const region *m_reg;\n+  tree m_capacity;\n+  enum rce_kind m_rce_kind;\n+};\n+\n+/* An event subclass describing the entry to a function.  */\n+\n+class function_entry_event : public checker_event\n+{\n+public:\n+  function_entry_event (location_t loc, tree fndecl, int depth)\n+  : checker_event (EK_FUNCTION_ENTRY, loc, fndecl, depth)\n+  {\n+  }\n+\n+  function_entry_event (const program_point &dst_point);\n+\n+  label_text get_desc (bool can_colorize) const override;\n+  meaning get_meaning () const override;\n+\n+  bool is_function_entry_p () const final override { return true; }\n+};\n+\n+/* Subclass of checker_event describing a state change.  */\n+\n+class state_change_event : public checker_event\n+{\n+public:\n+  state_change_event (const supernode *node, const gimple *stmt,\n+\t\t      int stack_depth,\n+\t\t      const state_machine &sm,\n+\t\t      const svalue *sval,\n+\t\t      state_machine::state_t from,\n+\t\t      state_machine::state_t to,\n+\t\t      const svalue *origin,\n+\t\t      const program_state &dst_state);\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n+\n+  function *get_dest_function () const\n+  {\n+    return m_dst_state.get_current_function ();\n+  }\n+\n+  const supernode *m_node;\n+  const gimple *m_stmt;\n+  const state_machine &m_sm;\n+  const svalue *m_sval;\n+  state_machine::state_t m_from;\n+  state_machine::state_t m_to;\n+  const svalue *m_origin;\n+  program_state m_dst_state;\n+};\n+\n+/* Subclass of checker_event; parent class for subclasses that relate to\n+   a superedge.  */\n+\n+class superedge_event : public checker_event\n+{\n+public:\n+  /* Mark this edge event as being either an interprocedural call or\n+     return in which VAR is in STATE, and that this is critical to the\n+     diagnostic (so that get_desc can attempt to get a better description\n+     from any pending_diagnostic).  */\n+  void record_critical_state (tree var, state_machine::state_t state)\n+  {\n+    m_var = var;\n+    m_critical_state = state;\n+  }\n+\n+  const callgraph_superedge& get_callgraph_superedge () const;\n+\n+  bool should_filter_p (int verbosity) const;\n+\n+ protected:\n+  superedge_event (enum event_kind kind, const exploded_edge &eedge,\n+\t\t   location_t loc, tree fndecl, int depth);\n+\n+ public:\n+  const exploded_edge &m_eedge;\n+  const superedge *m_sedge;\n+  tree m_var;\n+  state_machine::state_t m_critical_state;\n+};\n+\n+/* An abstract event subclass for when a CFG edge is followed; it has two\n+   subclasses, representing the start of the edge and the end of the\n+   edge, which come in pairs.  */\n+\n+class cfg_edge_event : public superedge_event\n+{\n+public:\n+  meaning get_meaning () const override;\n+\n+  const cfg_superedge& get_cfg_superedge () const;\n+\n+ protected:\n+  cfg_edge_event (enum event_kind kind, const exploded_edge &eedge,\n+\t\t  location_t loc, tree fndecl, int depth);\n+};\n+\n+/* A concrete event subclass for the start of a CFG edge\n+   e.g. \"following 'false' branch...'.  */\n+\n+class start_cfg_edge_event : public cfg_edge_event\n+{\n+public:\n+  start_cfg_edge_event (const exploded_edge &eedge,\n+\t\t\tlocation_t loc, tree fndecl, int depth)\n+  : cfg_edge_event (EK_START_CFG_EDGE, eedge, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+\n+ private:\n+  label_text maybe_describe_condition (bool can_colorize) const;\n+\n+  static label_text maybe_describe_condition (bool can_colorize,\n+\t\t\t\t\t      tree lhs,\n+\t\t\t\t\t      enum tree_code op,\n+\t\t\t\t\t      tree rhs);\n+  static bool should_print_expr_p (tree);\n+};\n+\n+/* A concrete event subclass for the end of a CFG edge\n+   e.g. \"...to here'.  */\n+\n+class end_cfg_edge_event : public cfg_edge_event\n+{\n+public:\n+  end_cfg_edge_event (const exploded_edge &eedge,\n+\t\t      location_t loc, tree fndecl, int depth)\n+  : cfg_edge_event (EK_END_CFG_EDGE, eedge, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const final override\n+  {\n+    return label_text::borrow (\"...to here\");\n+  }\n+};\n+\n+/* A concrete event subclass for an interprocedural call.  */\n+\n+class call_event : public superedge_event\n+{\n+public:\n+  call_event (const exploded_edge &eedge,\n+\t      location_t loc, tree fndecl, int depth);\n+\n+  label_text get_desc (bool can_colorize) const override;\n+  meaning get_meaning () const override;\n+\n+  bool is_call_p () const final override;\n+\n+protected:\n+  tree get_caller_fndecl () const;\n+  tree get_callee_fndecl () const;\n+\n+  const supernode *m_src_snode;\n+  const supernode *m_dest_snode;\n+};\n+\n+/* A concrete event subclass for an interprocedural return.  */\n+\n+class return_event : public superedge_event\n+{\n+public:\n+  return_event (const exploded_edge &eedge,\n+\t\tlocation_t loc, tree fndecl, int depth);\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n+\n+  bool is_return_p () const final override;\n+\n+  const supernode *m_src_snode;\n+  const supernode *m_dest_snode;\n+};\n+\n+/* A concrete event subclass for the start of a consolidated run of CFG\n+   edges all either TRUE or FALSE e.g. \"following 'false' branch...'.  */\n+\n+class start_consolidated_cfg_edges_event : public checker_event\n+{\n+public:\n+  start_consolidated_cfg_edges_event (location_t loc, tree fndecl, int depth,\n+\t\t\t\t      bool edge_sense)\n+  : checker_event (EK_START_CONSOLIDATED_CFG_EDGES, loc, fndecl, depth),\n+    m_edge_sense (edge_sense)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n+\n+ private:\n+  bool m_edge_sense;\n+};\n+\n+/* A concrete event subclass for the end of a consolidated run of\n+   CFG edges e.g. \"...to here'.  */\n+\n+class end_consolidated_cfg_edges_event : public checker_event\n+{\n+public:\n+  end_consolidated_cfg_edges_event (location_t loc, tree fndecl, int depth)\n+  : checker_event (EK_END_CONSOLIDATED_CFG_EDGES, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const final override\n+  {\n+    return label_text::borrow (\"...to here\");\n+  }\n+};\n+\n+/* A concrete event subclass for describing an inlined call event\n+   e.g. \"inlined call to 'callee' from 'caller'\".  */\n+\n+class inlined_call_event : public checker_event\n+{\n+public:\n+  inlined_call_event (location_t loc,\n+\t\t      tree apparent_callee_fndecl,\n+\t\t      tree apparent_caller_fndecl,\n+\t\t      int actual_depth,\n+\t\t      int stack_depth_adjustment)\n+  : checker_event (EK_INLINED_CALL, loc,\n+\t\t   apparent_caller_fndecl,\n+\t\t   actual_depth + stack_depth_adjustment),\n+    m_apparent_callee_fndecl (apparent_callee_fndecl),\n+    m_apparent_caller_fndecl (apparent_caller_fndecl)\n+  {\n+    gcc_assert (LOCATION_BLOCK (loc) == NULL);\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const final override;\n+  meaning get_meaning () const override;\n+\n+private:\n+  tree m_apparent_callee_fndecl;\n+  tree m_apparent_caller_fndecl;\n+};\n+\n+/* A concrete event subclass for a setjmp or sigsetjmp call.  */\n+\n+class setjmp_event : public checker_event\n+{\n+public:\n+  setjmp_event (location_t loc, const exploded_node *enode,\n+\t\ttree fndecl, int depth, const gcall *setjmp_call)\n+  : checker_event (EK_SETJMP, loc, fndecl, depth),\n+    m_enode (enode), m_setjmp_call (setjmp_call)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+\n+  void prepare_for_emission (checker_path *path,\n+\t\t\t     pending_diagnostic *pd,\n+\t\t\t     diagnostic_event_id_t emission_id) final override;\n+\n+private:\n+  const exploded_node *m_enode;\n+  const gcall *m_setjmp_call;\n+};\n+\n+/* An abstract event subclass for rewinding from a longjmp to a setjmp\n+   (or siglongjmp to sigsetjmp).\n+\n+   Base class for two from/to subclasses, showing the two halves of the\n+   rewind.  */\n+\n+class rewind_event : public checker_event\n+{\n+public:\n+  tree get_longjmp_caller () const;\n+  tree get_setjmp_caller () const;\n+  const exploded_edge *get_eedge () const { return m_eedge; }\n+\n+ protected:\n+  rewind_event (const exploded_edge *eedge,\n+\t\tenum event_kind kind,\n+\t\tlocation_t loc, tree fndecl, int depth,\n+\t\tconst rewind_info_t *rewind_info);\n+  const rewind_info_t *m_rewind_info;\n+\n+ private:\n+  const exploded_edge *m_eedge;\n+};\n+\n+/* A concrete event subclass for rewinding from a longjmp to a setjmp,\n+   showing the longjmp (or siglongjmp).  */\n+\n+class rewind_from_longjmp_event : public rewind_event\n+{\n+public:\n+  rewind_from_longjmp_event (const exploded_edge *eedge,\n+\t\t\t     location_t loc, tree fndecl, int depth,\n+\t\t\t     const rewind_info_t *rewind_info)\n+  : rewind_event (eedge, EK_REWIND_FROM_LONGJMP, loc, fndecl, depth,\n+\t\t  rewind_info)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+};\n+\n+/* A concrete event subclass for rewinding from a longjmp to a setjmp,\n+   showing the setjmp (or sigsetjmp).  */\n+\n+class rewind_to_setjmp_event : public rewind_event\n+{\n+public:\n+  rewind_to_setjmp_event (const exploded_edge *eedge,\n+\t\t\t  location_t loc, tree fndecl, int depth,\n+\t\t\t  const rewind_info_t *rewind_info)\n+  : rewind_event (eedge, EK_REWIND_TO_SETJMP, loc, fndecl, depth,\n+\t\t  rewind_info)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+\n+  void prepare_for_emission (checker_path *path,\n+\t\t\t     pending_diagnostic *pd,\n+\t\t\t     diagnostic_event_id_t emission_id) final override;\n+\n+private:\n+  diagnostic_event_id_t m_original_setjmp_event_id;\n+};\n+\n+/* Concrete subclass of checker_event for use at the end of a path:\n+   a repeat of the warning message at the end of the path (perhaps with\n+   references to pertinent events that occurred on the way), at the point\n+   where the problem occurs.  */\n+\n+class warning_event : public checker_event\n+{\n+public:\n+  warning_event (location_t loc, tree fndecl, int depth,\n+\t\t const state_machine *sm,\n+\t\t tree var, state_machine::state_t state)\n+  : checker_event (EK_WARNING, loc, fndecl, depth),\n+    m_sm (sm), m_var (var), m_state (state)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n+\n+private:\n+  const state_machine *m_sm;\n+  tree m_var;\n+  state_machine::state_t m_state;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_CHECKER_EVENT_H */"}, {"sha": "55bf1e3e3b58269b2c25e98384c5423b46440219", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 2, "deletions": 582, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65752c1f7c41c5641eef298454825910a57146e4/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65752c1f7c41c5641eef298454825910a57146e4/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=65752c1f7c41c5641eef298454825910a57146e4", "patch": "@@ -1,4 +1,4 @@\n-/* Subclasses of diagnostic_path and diagnostic_event for analyzer diagnostics.\n+/* Subclass of diagnostic_path for analyzer diagnostics.\n    Copyright (C) 2019-2022 Free Software Foundation, Inc.\n    Contributed by David Malcolm <dmalcolm@redhat.com>.\n \n@@ -21,590 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_CHECKER_PATH_H\n #define GCC_ANALYZER_CHECKER_PATH_H\n \n-#include \"tree-logical-location.h\"\n+#include \"analyzer/checker-event.h\"\n \n namespace ana {\n \n-/* An enum for discriminating between the concrete subclasses of\n-   checker_event.  */\n-\n-enum event_kind\n-{\n-  EK_DEBUG,\n-  EK_CUSTOM,\n-  EK_STMT,\n-  EK_REGION_CREATION,\n-  EK_FUNCTION_ENTRY,\n-  EK_STATE_CHANGE,\n-  EK_START_CFG_EDGE,\n-  EK_END_CFG_EDGE,\n-  EK_CALL_EDGE,\n-  EK_RETURN_EDGE,\n-  EK_START_CONSOLIDATED_CFG_EDGES,\n-  EK_END_CONSOLIDATED_CFG_EDGES,\n-  EK_INLINED_CALL,\n-  EK_SETJMP,\n-  EK_REWIND_FROM_LONGJMP,\n-  EK_REWIND_TO_SETJMP,\n-  EK_WARNING\n-};\n-\n-extern const char *event_kind_to_string (enum event_kind ek);\n-\n-/* Event subclasses.\n-\n-   The class hierarchy looks like this (using indentation to show\n-   inheritance, and with event_kinds shown for the concrete subclasses):\n-\n-   diagnostic_event\n-     checker_event\n-       debug_event (EK_DEBUG)\n-       custom_event (EK_CUSTOM)\n-\t precanned_custom_event\n-       statement_event (EK_STMT)\n-       region_creation_event (EK_REGION_CREATION)\n-       function_entry_event (EK_FUNCTION_ENTRY)\n-       state_change_event (EK_STATE_CHANGE)\n-       superedge_event\n-         cfg_edge_event\n-\t   start_cfg_edge_event (EK_START_CFG_EDGE)\n-\t   end_cfg_edge_event (EK_END_CFG_EDGE)\n-         call_event (EK_CALL_EDGE)\n-         return_edge (EK_RETURN_EDGE)\n-       start_consolidated_cfg_edges_event (EK_START_CONSOLIDATED_CFG_EDGES)\n-       end_consolidated_cfg_edges_event (EK_END_CONSOLIDATED_CFG_EDGES)\n-       inlined_call_event (EK_INLINED_CALL)\n-       setjmp_event (EK_SETJMP)\n-       rewind_event\n-         rewind_from_longjmp_event (EK_REWIND_FROM_LONGJMP)\n-\t rewind_to_setjmp_event (EK_REWIND_TO_SETJMP)\n-       warning_event (EK_WARNING).  */\n-\n-/* Abstract subclass of diagnostic_event; the base class for use in\n-   checker_path (the analyzer's diagnostic_path subclass).  */\n-\n-class checker_event : public diagnostic_event\n-{\n-public:\n-  /* Implementation of diagnostic_event.  */\n-\n-  location_t get_location () const final override { return m_loc; }\n-  tree get_fndecl () const final override { return m_effective_fndecl; }\n-  int get_stack_depth () const final override { return m_effective_depth; }\n-  const logical_location *get_logical_location () const final override\n-  {\n-    if (m_effective_fndecl)\n-      return &m_logical_loc;\n-    else\n-      return NULL;\n-  }\n-  meaning get_meaning () const override;\n-\n-  /* Additional functionality.  */\n-\n-  int get_original_stack_depth () const { return m_original_depth; }\n-\n-  virtual void prepare_for_emission (checker_path *,\n-\t\t\t\t     pending_diagnostic *pd,\n-\t\t\t\t     diagnostic_event_id_t emission_id);\n-  virtual bool is_call_p () const { return false; }\n-  virtual bool is_function_entry_p () const  { return false; }\n-  virtual bool is_return_p () const  { return false; }\n-\n-  /* For use with %@.  */\n-  const diagnostic_event_id_t *get_id_ptr () const\n-  {\n-    return &m_emission_id;\n-  }\n-\n-  void dump (pretty_printer *pp) const;\n-  void debug () const;\n-\n-  void set_location (location_t loc) { m_loc = loc; }\n-\n-protected:\n-  checker_event (enum event_kind kind,\n-\t\t location_t loc, tree fndecl, int depth);\n-\n- public:\n-  const enum event_kind m_kind;\n- protected:\n-  location_t m_loc;\n-  tree m_original_fndecl;\n-  tree m_effective_fndecl;\n-  int m_original_depth;\n-  int m_effective_depth;\n-  pending_diagnostic *m_pending_diagnostic;\n-  diagnostic_event_id_t m_emission_id; // only set once all pruning has occurred\n-  tree_logical_location m_logical_loc;\n-};\n-\n-/* A concrete event subclass for a purely textual event, for use in\n-   debugging path creation and filtering.  */\n-\n-class debug_event : public checker_event\n-{\n-public:\n-  debug_event (location_t loc, tree fndecl, int depth,\n-\t      const char *desc)\n-  : checker_event (EK_DEBUG, loc, fndecl, depth),\n-    m_desc (xstrdup (desc))\n-  {\n-  }\n-  ~debug_event ()\n-  {\n-    free (m_desc);\n-  }\n-\n-  label_text get_desc (bool) const final override;\n-\n-private:\n-  char *m_desc;\n-};\n-\n-/* An abstract event subclass for custom events.  These are not filtered,\n-   as they are likely to be pertinent to the diagnostic.  */\n-\n-class custom_event : public checker_event\n-{\n-protected:\n-  custom_event (location_t loc, tree fndecl, int depth)\n-  : checker_event (EK_CUSTOM, loc, fndecl, depth)\n-  {\n-  }\n-};\n-\n-/* A concrete custom_event subclass with a precanned message.  */\n-\n-class precanned_custom_event : public custom_event\n-{\n-public:\n-  precanned_custom_event (location_t loc, tree fndecl, int depth,\n-\t\t\t  const char *desc)\n-  : custom_event (loc, fndecl, depth),\n-    m_desc (xstrdup (desc))\n-  {\n-  }\n-  ~precanned_custom_event ()\n-  {\n-    free (m_desc);\n-  }\n-\n-  label_text get_desc (bool) const final override;\n-\n-private:\n-  char *m_desc;\n-};\n-\n-/* A concrete event subclass describing the execution of a gimple statement,\n-   for use at high verbosity levels when debugging paths.  */\n-\n-class statement_event : public checker_event\n-{\n-public:\n-  statement_event (const gimple *stmt, tree fndecl, int depth,\n-\t\t   const program_state &dst_state);\n-\n-  label_text get_desc (bool) const final override;\n-\n-  const gimple * const m_stmt;\n-  const program_state m_dst_state;\n-};\n-\n-/* There are too many combinations to express region creation in one message,\n-   so we emit multiple region_creation_event instances when each pertinent\n-   region is created.\n-\n-   This enum distinguishes between the different messages.  */\n-\n-enum rce_kind\n-{\n-  /* Generate a message based on the memory space of the region\n-     e.g. \"region created on stack here\".  */\n-  RCE_MEM_SPACE,\n-\n-  /* Generate a message based on the capacity of the region\n-     e.g. \"capacity: 100 bytes\".  */\n-  RCE_CAPACITY,\n-\n-  /* Generate a debug message.  */\n-  RCE_DEBUG\n-};\n-\n-/* A concrete event subclass describing the creation of a region that\n-   is significant for a diagnostic.  */\n-\n-class region_creation_event : public checker_event\n-{\n-public:\n-  region_creation_event (const region *reg,\n-\t\t\t tree capacity,\n-\t\t\t enum rce_kind kind,\n-\t\t\t location_t loc, tree fndecl, int depth);\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-\n-private:\n-  const region *m_reg;\n-  tree m_capacity;\n-  enum rce_kind m_rce_kind;\n-};\n-\n-/* An event subclass describing the entry to a function.  */\n-\n-class function_entry_event : public checker_event\n-{\n-public:\n-  function_entry_event (location_t loc, tree fndecl, int depth)\n-  : checker_event (EK_FUNCTION_ENTRY, loc, fndecl, depth)\n-  {\n-  }\n-\n-  function_entry_event (const program_point &dst_point);\n-\n-  label_text get_desc (bool can_colorize) const override;\n-  meaning get_meaning () const override;\n-\n-  bool is_function_entry_p () const final override { return true; }\n-};\n-\n-/* Subclass of checker_event describing a state change.  */\n-\n-class state_change_event : public checker_event\n-{\n-public:\n-  state_change_event (const supernode *node, const gimple *stmt,\n-\t\t      int stack_depth,\n-\t\t      const state_machine &sm,\n-\t\t      const svalue *sval,\n-\t\t      state_machine::state_t from,\n-\t\t      state_machine::state_t to,\n-\t\t      const svalue *origin,\n-\t\t      const program_state &dst_state);\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-  meaning get_meaning () const override;\n-\n-  function *get_dest_function () const\n-  {\n-    return m_dst_state.get_current_function ();\n-  }\n-\n-  const supernode *m_node;\n-  const gimple *m_stmt;\n-  const state_machine &m_sm;\n-  const svalue *m_sval;\n-  state_machine::state_t m_from;\n-  state_machine::state_t m_to;\n-  const svalue *m_origin;\n-  program_state m_dst_state;\n-};\n-\n-/* Subclass of checker_event; parent class for subclasses that relate to\n-   a superedge.  */\n-\n-class superedge_event : public checker_event\n-{\n-public:\n-  /* Mark this edge event as being either an interprocedural call or\n-     return in which VAR is in STATE, and that this is critical to the\n-     diagnostic (so that get_desc can attempt to get a better description\n-     from any pending_diagnostic).  */\n-  void record_critical_state (tree var, state_machine::state_t state)\n-  {\n-    m_var = var;\n-    m_critical_state = state;\n-  }\n-\n-  const callgraph_superedge& get_callgraph_superedge () const;\n-\n-  bool should_filter_p (int verbosity) const;\n-\n- protected:\n-  superedge_event (enum event_kind kind, const exploded_edge &eedge,\n-\t\t   location_t loc, tree fndecl, int depth);\n-\n- public:\n-  const exploded_edge &m_eedge;\n-  const superedge *m_sedge;\n-  tree m_var;\n-  state_machine::state_t m_critical_state;\n-};\n-\n-/* An abstract event subclass for when a CFG edge is followed; it has two\n-   subclasses, representing the start of the edge and the end of the\n-   edge, which come in pairs.  */\n-\n-class cfg_edge_event : public superedge_event\n-{\n-public:\n-  meaning get_meaning () const override;\n-\n-  const cfg_superedge& get_cfg_superedge () const;\n-\n- protected:\n-  cfg_edge_event (enum event_kind kind, const exploded_edge &eedge,\n-\t\t  location_t loc, tree fndecl, int depth);\n-};\n-\n-/* A concrete event subclass for the start of a CFG edge\n-   e.g. \"following 'false' branch...'.  */\n-\n-class start_cfg_edge_event : public cfg_edge_event\n-{\n-public:\n-  start_cfg_edge_event (const exploded_edge &eedge,\n-\t\t\tlocation_t loc, tree fndecl, int depth)\n-  : cfg_edge_event (EK_START_CFG_EDGE, eedge, loc, fndecl, depth)\n-  {\n-  }\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-\n- private:\n-  label_text maybe_describe_condition (bool can_colorize) const;\n-\n-  static label_text maybe_describe_condition (bool can_colorize,\n-\t\t\t\t\t      tree lhs,\n-\t\t\t\t\t      enum tree_code op,\n-\t\t\t\t\t      tree rhs);\n-  static bool should_print_expr_p (tree);\n-};\n-\n-/* A concrete event subclass for the end of a CFG edge\n-   e.g. \"...to here'.  */\n-\n-class end_cfg_edge_event : public cfg_edge_event\n-{\n-public:\n-  end_cfg_edge_event (const exploded_edge &eedge,\n-\t\t      location_t loc, tree fndecl, int depth)\n-  : cfg_edge_event (EK_END_CFG_EDGE, eedge, loc, fndecl, depth)\n-  {\n-  }\n-\n-  label_text get_desc (bool /*can_colorize*/) const final override\n-  {\n-    return label_text::borrow (\"...to here\");\n-  }\n-};\n-\n-/* A concrete event subclass for an interprocedural call.  */\n-\n-class call_event : public superedge_event\n-{\n-public:\n-  call_event (const exploded_edge &eedge,\n-\t      location_t loc, tree fndecl, int depth);\n-\n-  label_text get_desc (bool can_colorize) const override;\n-  meaning get_meaning () const override;\n-\n-  bool is_call_p () const final override;\n-\n-protected:\n-  tree get_caller_fndecl () const;\n-  tree get_callee_fndecl () const;\n-\n-  const supernode *m_src_snode;\n-  const supernode *m_dest_snode;\n-};\n-\n-/* A concrete event subclass for an interprocedural return.  */\n-\n-class return_event : public superedge_event\n-{\n-public:\n-  return_event (const exploded_edge &eedge,\n-\t\tlocation_t loc, tree fndecl, int depth);\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-  meaning get_meaning () const override;\n-\n-  bool is_return_p () const final override;\n-\n-  const supernode *m_src_snode;\n-  const supernode *m_dest_snode;\n-};\n-\n-/* A concrete event subclass for the start of a consolidated run of CFG\n-   edges all either TRUE or FALSE e.g. \"following 'false' branch...'.  */\n-\n-class start_consolidated_cfg_edges_event : public checker_event\n-{\n-public:\n-  start_consolidated_cfg_edges_event (location_t loc, tree fndecl, int depth,\n-\t\t\t\t      bool edge_sense)\n-  : checker_event (EK_START_CONSOLIDATED_CFG_EDGES, loc, fndecl, depth),\n-    m_edge_sense (edge_sense)\n-  {\n-  }\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-  meaning get_meaning () const override;\n-\n- private:\n-  bool m_edge_sense;\n-};\n-\n-/* A concrete event subclass for the end of a consolidated run of\n-   CFG edges e.g. \"...to here'.  */\n-\n-class end_consolidated_cfg_edges_event : public checker_event\n-{\n-public:\n-  end_consolidated_cfg_edges_event (location_t loc, tree fndecl, int depth)\n-  : checker_event (EK_END_CONSOLIDATED_CFG_EDGES, loc, fndecl, depth)\n-  {\n-  }\n-\n-  label_text get_desc (bool /*can_colorize*/) const final override\n-  {\n-    return label_text::borrow (\"...to here\");\n-  }\n-};\n-\n-/* A concrete event subclass for describing an inlined call event\n-   e.g. \"inlined call to 'callee' from 'caller'\".  */\n-\n-class inlined_call_event : public checker_event\n-{\n-public:\n-  inlined_call_event (location_t loc,\n-\t\t      tree apparent_callee_fndecl,\n-\t\t      tree apparent_caller_fndecl,\n-\t\t      int actual_depth,\n-\t\t      int stack_depth_adjustment)\n-  : checker_event (EK_INLINED_CALL, loc,\n-\t\t   apparent_caller_fndecl,\n-\t\t   actual_depth + stack_depth_adjustment),\n-    m_apparent_callee_fndecl (apparent_callee_fndecl),\n-    m_apparent_caller_fndecl (apparent_caller_fndecl)\n-  {\n-    gcc_assert (LOCATION_BLOCK (loc) == NULL);\n-  }\n-\n-  label_text get_desc (bool /*can_colorize*/) const final override;\n-  meaning get_meaning () const override;\n-\n-private:\n-  tree m_apparent_callee_fndecl;\n-  tree m_apparent_caller_fndecl;\n-};\n-\n-/* A concrete event subclass for a setjmp or sigsetjmp call.  */\n-\n-class setjmp_event : public checker_event\n-{\n-public:\n-  setjmp_event (location_t loc, const exploded_node *enode,\n-\t\ttree fndecl, int depth, const gcall *setjmp_call)\n-  : checker_event (EK_SETJMP, loc, fndecl, depth),\n-    m_enode (enode), m_setjmp_call (setjmp_call)\n-  {\n-  }\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-\n-  void prepare_for_emission (checker_path *path,\n-\t\t\t     pending_diagnostic *pd,\n-\t\t\t     diagnostic_event_id_t emission_id) final override;\n-\n-private:\n-  const exploded_node *m_enode;\n-  const gcall *m_setjmp_call;\n-};\n-\n-/* An abstract event subclass for rewinding from a longjmp to a setjmp\n-   (or siglongjmp to sigsetjmp).\n-\n-   Base class for two from/to subclasses, showing the two halves of the\n-   rewind.  */\n-\n-class rewind_event : public checker_event\n-{\n-public:\n-  tree get_longjmp_caller () const;\n-  tree get_setjmp_caller () const;\n-  const exploded_edge *get_eedge () const { return m_eedge; }\n-\n- protected:\n-  rewind_event (const exploded_edge *eedge,\n-\t\tenum event_kind kind,\n-\t\tlocation_t loc, tree fndecl, int depth,\n-\t\tconst rewind_info_t *rewind_info);\n-  const rewind_info_t *m_rewind_info;\n-\n- private:\n-  const exploded_edge *m_eedge;\n-};\n-\n-/* A concrete event subclass for rewinding from a longjmp to a setjmp,\n-   showing the longjmp (or siglongjmp).  */\n-\n-class rewind_from_longjmp_event : public rewind_event\n-{\n-public:\n-  rewind_from_longjmp_event (const exploded_edge *eedge,\n-\t\t\t     location_t loc, tree fndecl, int depth,\n-\t\t\t     const rewind_info_t *rewind_info)\n-  : rewind_event (eedge, EK_REWIND_FROM_LONGJMP, loc, fndecl, depth,\n-\t\t  rewind_info)\n-  {\n-  }\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-};\n-\n-/* A concrete event subclass for rewinding from a longjmp to a setjmp,\n-   showing the setjmp (or sigsetjmp).  */\n-\n-class rewind_to_setjmp_event : public rewind_event\n-{\n-public:\n-  rewind_to_setjmp_event (const exploded_edge *eedge,\n-\t\t\t  location_t loc, tree fndecl, int depth,\n-\t\t\t  const rewind_info_t *rewind_info)\n-  : rewind_event (eedge, EK_REWIND_TO_SETJMP, loc, fndecl, depth,\n-\t\t  rewind_info)\n-  {\n-  }\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-\n-  void prepare_for_emission (checker_path *path,\n-\t\t\t     pending_diagnostic *pd,\n-\t\t\t     diagnostic_event_id_t emission_id) final override;\n-\n-private:\n-  diagnostic_event_id_t m_original_setjmp_event_id;\n-};\n-\n-/* Concrete subclass of checker_event for use at the end of a path:\n-   a repeat of the warning message at the end of the path (perhaps with\n-   references to pertinent events that occurred on the way), at the point\n-   where the problem occurs.  */\n-\n-class warning_event : public checker_event\n-{\n-public:\n-  warning_event (location_t loc, tree fndecl, int depth,\n-\t\t const state_machine *sm,\n-\t\t tree var, state_machine::state_t state)\n-  : checker_event (EK_WARNING, loc, fndecl, depth),\n-    m_sm (sm), m_var (var), m_state (state)\n-  {\n-  }\n-\n-  label_text get_desc (bool can_colorize) const final override;\n-  meaning get_meaning () const override;\n-\n-private:\n-  const state_machine *m_sm;\n-  tree m_var;\n-  state_machine::state_t m_state;\n-};\n-\n /* Subclass of diagnostic_path for analyzer diagnostics.  */\n \n class checker_path : public diagnostic_path"}]}