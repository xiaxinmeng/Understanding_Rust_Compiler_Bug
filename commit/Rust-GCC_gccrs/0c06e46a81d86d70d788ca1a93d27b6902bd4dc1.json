{"sha": "0c06e46a81d86d70d788ca1a93d27b6902bd4dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMwNmU0NmE4MWQ4NmQ3MGQ3ODhjYTFhOTNkMjdiNjkwMmJkNGRjMQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2021-06-17T17:52:51Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2021-06-29T15:19:56Z"}, "message": "amdgcn: Add clrsbsi2/clrsbdi2 implementation\n\nThis patch adds an open-coded implementation of the clrsb<mode>2\n(count leading redundant sign bit) standard names using the GCN flbit_i*\ninstructions for SImode and DImode.  Those don't count exactly as we need,\nso we need a couple of other instructions to fix up the result afterwards.\n\nThese patterns are lost from libgcc if we build it for DImode/TImode\nrather than SImode/DImode, a change we make in a later patch in this\nseries.\n\n2021-06-18  Julian Brown  <julian@codesourcery.com>\n\ngcc/\n\t* config/gcn/gcn.md (UNSPEC_FLBIT_INT): New unspec constant.\n\t(s_mnemonic): Add clrsb.\n\t(gcn_flbit<mode>_int): Add insn pattern for SImode/DImode.\n\t(clrsb<mode>2): Add expander for SImode/DImode.", "tree": {"sha": "3a68b9668ab6107f690498ed1176fa3d31d65a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a68b9668ab6107f690498ed1176fa3d31d65a50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c06e46a81d86d70d788ca1a93d27b6902bd4dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c06e46a81d86d70d788ca1a93d27b6902bd4dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c06e46a81d86d70d788ca1a93d27b6902bd4dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c06e46a81d86d70d788ca1a93d27b6902bd4dc1/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f332122589f97b9c974b168ca5b0b186296f0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f332122589f97b9c974b168ca5b0b186296f0e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f332122589f97b9c974b168ca5b0b186296f0e4"}], "stats": {"total": 40, "additions": 38, "deletions": 2}, "files": [{"sha": "ae7249aac0e8837bcbd12ae9d174ca78a94cd359", "filename": "gcc/config/gcn/gcn.md", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c06e46a81d86d70d788ca1a93d27b6902bd4dc1/gcc%2Fconfig%2Fgcn%2Fgcn.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c06e46a81d86d70d788ca1a93d27b6902bd4dc1/gcc%2Fconfig%2Fgcn%2Fgcn.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.md?ref=0c06e46a81d86d70d788ca1a93d27b6902bd4dc1", "patch": "@@ -81,7 +81,8 @@\n   UNSPEC_MOV_FROM_LANE63\n   UNSPEC_GATHER\n   UNSPEC_SCATTER\n-  UNSPEC_RCP])\n+  UNSPEC_RCP\n+  UNSPEC_FLBIT_INT])\n \n ;; }}}\n ;; {{{ Attributes\n@@ -338,7 +339,8 @@\n   [(not \"not%b\")\n    (popcount \"bcnt1_i32%b\")\n    (clz \"flbit_i32%b\")\n-   (ctz \"ff1_i32%b\")])\n+   (ctz \"ff1_i32%b\")\n+   (clrsb \"flbit_i32%i\")])\n \n (define_code_attr revmnemonic\n   [(minus \"subrev%i\")\n@@ -1611,6 +1613,40 @@\n   [(set_attr \"type\" \"sop1\")\n    (set_attr \"length\" \"4,8\")])\n \n+(define_insn \"gcn_flbit<mode>_int\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=Sg,Sg\")\n+\t(unspec:SI [(match_operand:SIDI 1 \"gcn_alu_operand\" \"SgA, B\")]\n+\t\t   UNSPEC_FLBIT_INT))]\n+  \"\"\n+  {\n+    if (<MODE>mode == SImode)\n+      return \"s_flbit_i32\\t%0, %1\";\n+    else\n+      return \"s_flbit_i32_i64\\t%0, %1\";\n+  }\n+  [(set_attr \"type\" \"sop1\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_expand \"clrsb<mode>2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(clrsb:SI (match_operand:SIDI 1 \"gcn_alu_operand\" \"\")))]\n+  \"\"\n+  {\n+    rtx tmp = gen_reg_rtx (SImode);\n+    /* FLBIT_I* counts sign or zero bits at the most-significant end of the\n+       input register (and returns -1 for 0/-1 inputs).  We want the number of\n+       *redundant* bits (i.e. that value minus one), and an answer of 31/63 for\n+       0/-1 inputs.  We can do that in three instructions...  */\n+    emit_insn (gen_gcn_flbit<mode>_int (tmp, operands[1]));\n+    emit_insn (gen_uminsi3 (tmp, tmp,\n+\t\t\t    gen_int_mode (GET_MODE_BITSIZE (<MODE>mode),\n+\t\t\t\t\t  SImode)));\n+    /* If we put this last, it can potentially be folded into a subsequent\n+       arithmetic operation.  */\n+    emit_insn (gen_subsi3 (operands[0], tmp, const1_rtx));\n+    DONE;\n+  })\n+\n ;; }}}\n ;; {{{ ALU: generic 32-bit binop\n "}]}