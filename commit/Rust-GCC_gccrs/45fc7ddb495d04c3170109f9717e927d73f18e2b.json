{"sha": "45fc7ddb495d04c3170109f9717e927d73f18e2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmYzdkZGI0OTVkMDRjMzE3MDEwOWY5NzE3ZTkyN2Q3M2YxOGUyYg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-04-08T06:50:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:50:04Z"}, "message": "exp_ch2.adb: Minor reformatting.\n\n2008-04-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch2.adb: Minor reformatting.\n\t(Expand_Entry_Index_Parameter): Set the type of the identifier.\n\t(Expand_Entry_Reference): Add call to Expand_Protected_Component.\n\t(Expand_Protected_Component): New routine.\n\t(Expand_Protected_Private): Removed.\n\tAdd Sure parameter to Note_Possible_Modification calls\n\n\t* sem_ch12.ads, sem_ch12.adb (Analyze_Subprogram_Instantiation): The\n\tgenerated subprogram declaration must inherit the overriding indicator\n\tfrom the instantiation node.\n\t(Validate_Access_Type_Instance): If the designated type of the actual is\n\ta limited view, use the available view in all cases, not only if the\n\ttype is an incomplete type.\n\t(Instantiate_Object):  Actual is illegal if the formal is null-excluding\n\tand the actual subtype does not exclude null.\n\t(Process_Default): Handle properly abstract formal subprograms.\n\t(Check_Formal_Package_Instance): Handle properly defaulted formal\n\tsubprograms in a partially parameterized formal package.\n\tAdd Sure parameter to Note_Possible_Modification calls\n\t(Validate_Derived_Type_Instance): if the formal is non-limited, the\n\tactual cannot be limited.\n\t(Collect_Previous_Instances): Generate instance bodies for subprograms\n\tas well.\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause, case Small): Don't\n\ttry to set RM_Size.\n\tAdd Sure parameter to Note_Possible_Modification calls\n\t(Analyze_At_Clause): Preserve Comes_From_Source on Rewrite call\n\t(Analyze_Attribute_Definition_Clause, case Attribute_Address): Check for\n\tconstant overlaid by variable and issue warning.\n\tUse new Is_Standard_Character_Type predicate\n\t(Analyze_Record_Representation_Clause): Check that the specified\n\tLast_Bit is not less than First_Bit - 1.\n\t(Analyze_Attribute_Definition_Clause, case Address): Check for\n\tself-referential address clause\n\n\t* sem_ch5.ads, sem_ch5.adb (Diagnose_Non_Variable_Lhs): Rewrite the\n\tdetection mechanism when the lhs is a prival.\n\t(Analyze_Assignment): Call Check_Unprotected_Access to detect\n\tassignment of a pointer to protected data, to an object declared\n\toutside of the protected object.\n\t(Analyze_Loop_Statement): Check for unreachable code after loop\n\tAdd Sure parameter to Note_Possible_Modication calls\n\tProtect analysis from previous syntax error such as a scope mismatch\n\tor a missing begin.\n\t(Analyze_Assignment_Statement): The assignment is illegal if the\n\tleft-hand is an interface.\n\n\t* sem_res.adb (Resolve_Arithmetic_Op): For mod/rem check violation of\n\trestriction No_Implicit_Conditionals\n\tAdd Sure parameter to Note_Possible_Modication calls\n\tUse new Is_Standard_Character_Type predicate\n\t(Make_Call_Into_Operator): Preserve Comes_From_Source when rewriting\n\tcall as operator. Fixes problems (e.g. validity checking) which\n\tcome from the result looking as though it does not come from source).\n\t(Resolve_Call): Check case of name in named parameter if style checks\n\tare enabled.\n\t(Resolve_Call): Exclude calls to Current_Task as entry formal defaults\n\tfrom the checking that such calls should not occur from an entry body.\n\t(Resolve_Call): If the return type of an Inline_Always function\n\trequires the secondary stack, create a transient scope for the call\n\tif the body of the function is not available for inlining.\n\t(Resolve_Actuals): Apply Ada2005 checks to view conversions of arrays\n\tthat are actuals for in-out formals.\n\t(Try_Object_Operation): If prefix is a tagged protected object,retrieve\n\tprimitive operations from base type.\n\t(Analyze_Selected_Component): If the context is a call to a protected\n\toperation the parent may be an indexed component prior to expansion.\n\t(Resolve_Actuals): If an actual is of a protected subtype, use its\n\tbase type to determine whether a conversion to the corresponding record\n\tis needed.\n\t(Resolve_Short_Circuit): Handle pragma Check\n\n\t* sem_eval.adb: Minor code reorganization (usea Is_Constant_Object)\n\tUse new Is_Standard_Character_Type predicate\n\t(Eval_Relational_Op): Catch more cases of string comparison\n\nFrom-SVN: r134027", "tree": {"sha": "3eb987e31cbb9c471a969036173a7789787d3095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eb987e31cbb9c471a969036173a7789787d3095"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45fc7ddb495d04c3170109f9717e927d73f18e2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45fc7ddb495d04c3170109f9717e927d73f18e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45fc7ddb495d04c3170109f9717e927d73f18e2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45fc7ddb495d04c3170109f9717e927d73f18e2b/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b459216877b3af65054492a9827769e50c687a49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b459216877b3af65054492a9827769e50c687a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b459216877b3af65054492a9827769e50c687a49"}], "stats": {"total": 1299, "additions": 863, "deletions": 436}, "files": [{"sha": "82ac5eea7f41de3d8cca0c048ee9768ab7429f9c", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 59, "deletions": 102, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -80,12 +80,12 @@ package body Exp_Ch2 is\n    --  Dispatches to specific expansion procedures.\n \n    procedure Expand_Entry_Index_Parameter (N : Node_Id);\n-   --  A reference to the identifier in the entry index specification of\n-   --  protected entry body is modified to a reference to a constant definition\n-   --  equal to the index of the entry family member being called. This\n-   --  constant is calculated as part of the elaboration of the expanded code\n-   --  for the body, and is calculated from the object-wide entry index\n-   --  returned by Next_Entry_Call.\n+   --  A reference to the identifier in the entry index specification of an\n+   --  entry body is modified to a reference to a constant definition equal to\n+   --  the index of the entry family member being called. This constant is\n+   --  calculated as part of the elaboration of the expanded code for the body,\n+   --  and is calculated from the object-wide entry index returned by Next_\n+   --  Entry_Call.\n \n    procedure Expand_Entry_Parameter (N : Node_Id);\n    --  A reference to an entry parameter is modified to be a reference to the\n@@ -98,12 +98,10 @@ package body Exp_Ch2 is\n    --  represent the operation within the protected object. In other cases\n    --  Expand_Formal is a no-op.\n \n-   procedure Expand_Protected_Private (N : Node_Id);\n-   --  A reference to a private component of a protected type is expanded to a\n-   --  component selected from the record used to implement the protected\n-   --  object. Such a record is passed to all operations on a protected object\n-   --  in a parameter named _object. This object is a constant in the body of a\n-   --  function, and a variable within a procedure or entry body.\n+   procedure Expand_Protected_Component (N : Node_Id);\n+   --  A reference to a private component of a protected type is expanded into\n+   --  a reference to the corresponding prival in the current protected entry\n+   --  or subprogram.\n \n    procedure Expand_Renaming (N : Node_Id);\n    --  For renamings, just replace the identifier by the corresponding\n@@ -332,16 +330,12 @@ package body Exp_Ch2 is\n       elsif Is_Entry_Formal (E) then\n          Expand_Entry_Parameter (N);\n \n-      elsif Ekind (E) = E_Component\n-        and then Is_Protected_Private (E)\n-      then\n-         --  Protect against junk use of tasking in no run time mode\n-\n+      elsif Is_Protected_Component (E) then\n          if No_Run_Time_Mode then\n             return;\n          end if;\n \n-         Expand_Protected_Private (N);\n+         Expand_Protected_Component (N);\n \n       elsif Ekind (E) = E_Entry_Index_Parameter then\n          Expand_Entry_Index_Parameter (N);\n@@ -385,11 +379,7 @@ package body Exp_Ch2 is\n \n       --  Interpret possible Current_Value for constant case\n \n-      elsif (Ekind (E) = E_Constant\n-               or else\n-             Ekind (E) = E_In_Parameter\n-               or else\n-             Ekind (E) = E_Loop_Parameter)\n+      elsif Is_Constant_Object (E)\n         and then Present (Current_Value (E))\n       then\n          Expand_Current_Value (N);\n@@ -401,8 +391,10 @@ package body Exp_Ch2 is\n    ----------------------------------\n \n    procedure Expand_Entry_Index_Parameter (N : Node_Id) is\n+      Index_Con : constant Entity_Id := Entry_Index_Constant (Entity (N));\n    begin\n-      Set_Entity (N, Entry_Index_Constant (Entity (N)));\n+      Set_Entity (N, Index_Con);\n+      Set_Etype  (N, Etype (Index_Con));\n    end Expand_Entry_Index_Parameter;\n \n    ----------------------------\n@@ -477,10 +469,14 @@ package body Exp_Ch2 is\n          --  we also generate an extra parameter to hold the Constrained\n          --  attribute of the actual. No renaming is generated for this flag.\n \n+         --  Calling Node_Posssible_Modifications in the expander is dubious,\n+         --  because this generates a cross-reference entry, and should be\n+         --  done during semantic processing so it is called in -gnatc mode???\n+\n          if Ekind (Entity (N)) /= E_In_Parameter\n            and then In_Assignment_Context (N)\n          then\n-            Note_Possible_Modification (N);\n+            Note_Possible_Modification (N, Sure => True);\n          end if;\n \n          Rewrite (N, New_Occurrence_Of (Renamed_Object (Entity (N)), Loc));\n@@ -564,93 +560,54 @@ package body Exp_Ch2 is\n       end if;\n    end Expand_N_Real_Literal;\n \n-   ------------------------------\n-   -- Expand_Protected_Private --\n-   ------------------------------\n+   --------------------------------\n+   -- Expand_Protected_Component --\n+   --------------------------------\n \n-   procedure Expand_Protected_Private (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      E        : constant Entity_Id  := Entity (N);\n-      Op       : constant Node_Id    := Protected_Operation (E);\n-      Scop     : Entity_Id;\n-      Lo       : Node_Id;\n-      Hi       : Node_Id;\n-      D_Range  : Node_Id;\n-\n-   begin\n-      if Nkind (Op) /= N_Subprogram_Body\n-        or else Nkind (Specification (Op)) /= N_Function_Specification\n-      then\n-         Set_Ekind (Prival (E), E_Variable);\n-      else\n-         Set_Ekind (Prival (E), E_Constant);\n-      end if;\n+   procedure Expand_Protected_Component (N : Node_Id) is\n \n-      --  If the private component appears in an assignment (either lhs or\n-      --  rhs) and is a one-dimensional array constrained by a discriminant,\n-      --  rewrite as  P (Lo .. Hi) with an explicit range, so that discriminal\n-      --  is directly visible. This solves delicate visibility problems.\n+      function Inside_Eliminated_Body return Boolean;\n+      --  Determine whether the current entity is inside a subprogram or an\n+      --  entry which has been marked as eliminated.\n \n-      if Comes_From_Source (N)\n-        and then Is_Array_Type (Etype (E))\n-        and then Number_Dimensions (Etype (E)) = 1\n-        and then not Within_Init_Proc\n-      then\n-         Lo := Type_Low_Bound  (Etype (First_Index (Etype (E))));\n-         Hi := Type_High_Bound (Etype (First_Index (Etype (E))));\n-\n-         if Nkind (Parent (N)) = N_Assignment_Statement\n-           and then ((Is_Entity_Name (Lo)\n-                          and then Ekind (Entity (Lo)) = E_In_Parameter)\n-                       or else (Is_Entity_Name (Hi)\n-                                  and then\n-                                    Ekind (Entity (Hi)) = E_In_Parameter))\n-         then\n-            D_Range := New_Node (N_Range, Loc);\n+      ----------------------------\n+      -- Inside_Eliminated_Body --\n+      ----------------------------\n \n-            if Is_Entity_Name (Lo)\n-              and then Ekind (Entity (Lo)) = E_In_Parameter\n-            then\n-               Set_Low_Bound (D_Range,\n-                 Make_Identifier (Loc, Chars (Entity (Lo))));\n-            else\n-               Set_Low_Bound (D_Range, Duplicate_Subexpr (Lo));\n-            end if;\n+      function Inside_Eliminated_Body return Boolean is\n+         S : Entity_Id := Current_Scope;\n \n-            if Is_Entity_Name (Hi)\n-              and then Ekind (Entity (Hi)) = E_In_Parameter\n+      begin\n+         while Present (S) loop\n+            if (Ekind (S) = E_Entry\n+                  or else Ekind (S) = E_Entry_Family\n+                  or else Ekind (S) = E_Function\n+                  or else Ekind (S) = E_Procedure)\n+              and then Is_Eliminated (S)\n             then\n-               Set_High_Bound (D_Range,\n-                 Make_Identifier (Loc, Chars (Entity (Hi))));\n-            else\n-               Set_High_Bound (D_Range, Duplicate_Subexpr (Hi));\n+               return True;\n             end if;\n \n-            Rewrite (N,\n-              Make_Slice (Loc,\n-                Prefix => New_Occurrence_Of (E, Loc),\n-                Discrete_Range => D_Range));\n-\n-            Analyze_And_Resolve (N, Etype (E));\n-            return;\n-         end if;\n-      end if;\n-\n-      --  The type of the reference is the type of the prival, which may differ\n-      --  from that of the original component if it is an itype.\n-\n-      Set_Entity (N, Prival (E));\n-      Set_Etype  (N, Etype (Prival (E)));\n-      Scop := Current_Scope;\n+            S := Scope (S);\n+         end loop;\n \n-      --  Find entity for protected operation, which must be on scope stack\n+         return False;\n+      end Inside_Eliminated_Body;\n \n-      while not Is_Protected_Type (Scope (Scop)) loop\n-         Scop := Scope (Scop);\n-      end loop;\n+   --  Start of processing for Expand_Protected_Component\n \n-      Append_Elmt (N, Privals_Chain (Scop));\n-   end Expand_Protected_Private;\n+   begin\n+      --  Eliminated bodies are not expanded and thus do not need privals\n+\n+      if not Inside_Eliminated_Body then\n+         declare\n+            Priv : constant Entity_Id := Prival (Entity (N));\n+         begin\n+            Set_Entity (N, Priv);\n+            Set_Etype  (N, Etype (Priv));\n+         end;\n+      end if;\n+   end Expand_Protected_Component;\n \n    ---------------------\n    -- Expand_Renaming --"}, {"sha": "00c9f39ff21419cbb65de34327d30f359478de7b", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 114, "deletions": 52, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -488,11 +488,11 @@ package body Sem_Ch12 is\n    --  and has already been flipped during this phase of instantiation.\n \n    procedure Hide_Current_Scope;\n-   --  When compiling a generic child unit, the parent context must be\n+   --  When instantiating a generic child unit, the parent context must be\n    --  present, but the instance and all entities that may be generated\n    --  must be inserted in the current scope. We leave the current scope\n    --  on the stack, but make its entities invisible to avoid visibility\n-   --  problems. This is reversed at the end of instantiations. This is\n+   --  problems. This is reversed at the end of the instantiation. This is\n    --  not done for the instantiation of the bodies, which only require the\n    --  instances of the generic parents to be in scope.\n \n@@ -685,7 +685,7 @@ package body Sem_Ch12 is\n    --  at the end of the enclosing generic package, which is semantically\n    --  neutral.\n \n-   procedure Pre_Analyze_Actuals (N : Node_Id);\n+   procedure Preanalyze_Actuals (N : Node_Id);\n    --  Analyze actuals to perform name resolution. Full resolution is done\n    --  later, when the expected types are known, but names have to be captured\n    --  before installing parents of generics, that are not visible for the\n@@ -1027,6 +1027,8 @@ package body Sem_Ch12 is\n \n       procedure Process_Default (F : Entity_Id)  is\n          Loc     : constant Source_Ptr := Sloc (I_Node);\n+         F_Id    : constant Entity_Id  := Defining_Entity (F);\n+\n          Decl    : Node_Id;\n          Default : Node_Id;\n          Id      : Entity_Id;\n@@ -1036,17 +1038,12 @@ package body Sem_Ch12 is\n          --  new defining identifier for it.\n \n          Decl := New_Copy_Tree (F);\n+         Id := Make_Defining_Identifier (Sloc (F_Id), Chars => Chars (F_Id));\n \n-         if Nkind (F) = N_Formal_Concrete_Subprogram_Declaration then\n-            Id :=\n-               Make_Defining_Identifier (Sloc (Defining_Entity (F)),\n-                 Chars => Chars (Defining_Entity (F)));\n+         if Nkind (F) in N_Formal_Subprogram_Declaration then\n             Set_Defining_Unit_Name (Specification (Decl), Id);\n \n          else\n-            Id :=\n-              Make_Defining_Identifier (Sloc (Defining_Entity (F)),\n-                Chars => Chars (Defining_Identifier (F)));\n             Set_Defining_Identifier (Decl, Id);\n          end if;\n \n@@ -1652,7 +1649,6 @@ package body Sem_Ch12 is\n \n       Set_Size_Known_At_Compile_Time\n         (T, Size_Known_At_Compile_Time (Entity (Subtype_Mark (Def))));\n-\n    end Analyze_Formal_Derived_Type;\n \n    ----------------------------------\n@@ -1855,7 +1851,7 @@ package body Sem_Ch12 is\n          end if;\n \n          if Present (E) then\n-            Analyze_Per_Use_Expression (E, T);\n+            Preanalyze_Spec_Expression (E, T);\n \n             if Is_Limited_Type (T) and then not OK_For_Limited_Init (E) then\n                Error_Msg_N\n@@ -2910,7 +2906,7 @@ package body Sem_Ch12 is\n       end if;\n \n       Generate_Definition (Act_Decl_Id);\n-      Pre_Analyze_Actuals (N);\n+      Preanalyze_Actuals (N);\n \n       Init_Env;\n       Env_Installed := True;\n@@ -3888,9 +3884,7 @@ package body Sem_Ch12 is\n          --  subprogram will be frozen at the point the wrapper package is\n          --  frozen, so it does not need its own freeze node. In fact, if one\n          --  is created, it might conflict with the freezing actions from the\n-         --  wrapper package (see 7206-013).\n-\n-         --  Should not really reference non-public TN's in comments ???\n+         --  wrapper package.\n \n          Set_Has_Delayed_Freeze (Anon_Id, False);\n \n@@ -3946,7 +3940,7 @@ package body Sem_Ch12 is\n       --  Make node global for error reporting\n \n       Instantiation_Node := N;\n-      Pre_Analyze_Actuals (N);\n+      Preanalyze_Actuals (N);\n \n       Init_Env;\n       Env_Installed := True;\n@@ -4038,12 +4032,16 @@ package body Sem_Ch12 is\n          Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n \n          --  Copy original generic tree, to produce text for instantiation\n+         --  Inherit overriding indicator from instance node.\n \n          Act_Tree :=\n            Copy_Generic_Node\n              (Original_Node (Gen_Decl), Empty, Instantiating => True);\n \n          Act_Spec := Specification (Act_Tree);\n+         Set_Must_Override (Act_Spec, Must_Override (N));\n+         Set_Must_Not_Override (Act_Spec, Must_Not_Override (N));\n+\n          Renaming_List :=\n            Analyze_Associations\n              (N,\n@@ -4625,11 +4623,22 @@ package body Sem_Ch12 is\n \n          elsif Is_Overloadable (E1) then\n \n-            --  Verify that the names of the entities match. Note that actuals\n-            --  that are attributes are rewritten as subprograms.\n+            --  Verify that the actual subprograms match. Note that actuals\n+            --  that are attributes are rewritten as subprograms. If the\n+            --  subprogram in the formal package is defaulted, no check is\n+            --  needed. Note that this can only happen in Ada2005 when the\n+            --  formal package can be partially parametrized.\n \n-            Check_Mismatch\n-              (Ekind (E2) /= Ekind (E1) or else (Alias (E1)) /= Alias (E2));\n+            if Nkind (Unit_Declaration_Node (E1)) =\n+                                           N_Subprogram_Renaming_Declaration\n+              and then From_Default (Unit_Declaration_Node (E1))\n+            then\n+               null;\n+\n+            else\n+               Check_Mismatch\n+                 (Ekind (E2) /= Ekind (E1) or else (Alias (E1)) /= Alias (E2));\n+            end if;\n \n          else\n             raise Program_Error;\n@@ -8226,7 +8235,7 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n \n-         Note_Possible_Modification (Actual);\n+         Note_Possible_Modification (Actual, Sure => True);\n \n          --  Check for instantiation of atomic/volatile actual for\n          --  non-atomic/volatile formal (RM C.6 (12)).\n@@ -8280,7 +8289,7 @@ package body Sem_Ch12 is\n             Append (Decl_Node, List);\n \n             --  No need to repeat (pre-)analysis of some expression nodes\n-            --  already handled in Pre_Analyze_Actuals.\n+            --  already handled in Preanalyze_Actuals.\n \n             if Nkind (Actual) /= N_Allocator then\n                Analyze (Actual);\n@@ -8306,7 +8315,7 @@ package body Sem_Ch12 is\n                --  a child unit.\n \n                if Nkind (Actual) = N_Aggregate then\n-                  Pre_Analyze_And_Resolve (Actual, Typ);\n+                  Preanalyze_And_Resolve (Actual, Typ);\n                end if;\n \n                if Is_Limited_Type (Typ)\n@@ -8397,13 +8406,12 @@ package body Sem_Ch12 is\n           Nkind_In (Actual_Decl, N_Formal_Object_Declaration,\n                                  N_Object_Declaration)\n         and then Nkind (Analyzed_Formal) = N_Formal_Object_Declaration\n-        and then Has_Null_Exclusion (Actual_Decl)\n-        and then not Has_Null_Exclusion (Analyzed_Formal)\n+        and then not Has_Null_Exclusion (Actual_Decl)\n+        and then Has_Null_Exclusion (Analyzed_Formal)\n       then\n-         Error_Msg_Sloc := Sloc (Actual_Decl);\n+         Error_Msg_Sloc := Sloc (Analyzed_Formal);\n          Error_Msg_N\n-           (\"`NOT NULL` required in formal, to match actual #\",\n-            Analyzed_Formal);\n+           (\"actual must exclude null to match generic formal#\", Actual);\n       end if;\n \n       return List;\n@@ -8656,7 +8664,8 @@ package body Sem_Ch12 is\n    ---------------------------------\n \n    procedure Instantiate_Subprogram_Body\n-     (Body_Info : Pending_Body_Info)\n+     (Body_Info     : Pending_Body_Info;\n+      Body_Optional : Boolean := False)\n    is\n       Act_Decl      : constant Node_Id    := Body_Info.Act_Decl;\n       Inst_Node     : constant Node_Id    := Body_Info.Inst_Node;\n@@ -8709,7 +8718,8 @@ package body Sem_Ch12 is\n          --  For other cases, commpile the body\n \n          else\n-            Load_Parent_Of_Generic (Inst_Node, Specification (Gen_Decl));\n+            Load_Parent_Of_Generic\n+              (Inst_Node, Specification (Gen_Decl), Body_Optional);\n             Gen_Body_Id := Corresponding_Body (Gen_Decl);\n          end if;\n       end if;\n@@ -8875,7 +8885,10 @@ package body Sem_Ch12 is\n       elsif Serious_Errors_Detected = 0\n         and then Nkind (Parent (Inst_Node)) /= N_Compilation_Unit\n       then\n-         if Ekind (Anon_Id) = E_Procedure then\n+         if Body_Optional then\n+            return;\n+\n+         elsif Ekind (Anon_Id) = E_Procedure then\n             Act_Body :=\n               Make_Subprogram_Body (Loc,\n                  Specification              =>\n@@ -9074,11 +9087,10 @@ package body Sem_Ch12 is\n          Desig_Act := Designated_Type (Base_Type (Act_T));\n \n          --  The designated type may have been introduced through a limited_\n-         --  with clause, in which case retrieve the non-limited view.\n+         --  with clause, in which case retrieve the non-limited view. This\n+         --  applies to incomplete types as well as to class-wide types.\n \n-         if Ekind (Desig_Act) = E_Incomplete_Type\n-           and then From_With_Type (Desig_Act)\n-         then\n+         if From_With_Type (Desig_Act) then\n             Desig_Act := Available_View (Desig_Act);\n          end if;\n \n@@ -9760,6 +9772,22 @@ package body Sem_Ch12 is\n                end loop;\n             end Check_Abstract_Primitives;\n          end if;\n+\n+         --  Verify that limitedness matches. If parent is a limited\n+         --  interface then  the generic formal is not unless declared\n+         --  explicitly so. If not declared limited, the actual cannot be\n+         --  limited (see AI05-0087).\n+\n+         if Is_Limited_Type (Act_T)\n+           and then not Is_Limited_Type (A_Gen_T)\n+           and then False\n+         then\n+            Error_Msg_NE\n+              (\"actual for non-limited & cannot be a limited type\", Actual,\n+               Gen_T);\n+            Explain_Limited_Type (Act_T, Actual);\n+            Abandon_Instantiation (Actual);\n+         end if;\n       end Validate_Derived_Type_Instance;\n \n       --------------------------------------\n@@ -10256,7 +10284,8 @@ package body Sem_Ch12 is\n       --  instantiations are available, we must analyze them, to ensure that\n       --  the public symbols generated are the same when the unit is compiled\n       --  to generate code, and when it is compiled in the context of a unit\n-      --  that needs a particular nested instance.\n+      --  that needs a particular nested instance. This process is applied\n+      --  to both package and subprogram instances.\n \n       --------------------------------\n       -- Collect_Previous_Instances --\n@@ -10284,6 +10313,16 @@ package body Sem_Ch12 is\n             then\n                Append_Elmt (Decl, Previous_Instances);\n \n+            --  For a subprogram instantiation, omit instantiations of\n+            --  intrinsic operations (Unchecked_Conversions, etc.) that\n+            --  have no bodies.\n+\n+            elsif Nkind_In (Decl, N_Function_Instantiation,\n+                                  N_Procedure_Instantiation)\n+              and then not Is_Intrinsic_Subprogram (Entity (Name (Decl)))\n+            then\n+               Append_Elmt (Decl, Previous_Instances);\n+\n             elsif Nkind (Decl) = N_Package_Declaration then\n                Collect_Previous_Instances\n                  (Visible_Declarations (Specification (Decl)));\n@@ -10416,6 +10455,7 @@ package body Sem_Ch12 is\n                   then\n                      declare\n                         Decl : Elmt_Id;\n+                        Info : Pending_Body_Info;\n                         Par  : Node_Id;\n \n                      begin\n@@ -10446,18 +10486,40 @@ package body Sem_Ch12 is\n \n                         Decl := First_Elmt (Previous_Instances);\n                         while Present (Decl) loop\n-                           Instantiate_Package_Body\n-                             (Body_Info =>\n-                                ((Inst_Node                => Node (Decl),\n-                                  Act_Decl                 =>\n-                                    Instance_Spec (Node (Decl)),\n-                                  Expander_Status          => Exp_Status,\n-                                  Current_Sem_Unit         =>\n-                                    Get_Code_Unit (Sloc (Node (Decl))),\n-                                  Scope_Suppress           => Scope_Suppress,\n-                                  Local_Suppress_Stack_Top =>\n-                                    Local_Suppress_Stack_Top)),\n-                              Body_Optional => True);\n+                           Info :=\n+                             (Inst_Node                => Node (Decl),\n+                              Act_Decl                 =>\n+                                Instance_Spec (Node (Decl)),\n+                              Expander_Status          => Exp_Status,\n+                              Current_Sem_Unit         =>\n+                                Get_Code_Unit (Sloc (Node (Decl))),\n+                              Scope_Suppress           => Scope_Suppress,\n+                              Local_Suppress_Stack_Top =>\n+                                Local_Suppress_Stack_Top);\n+\n+                           --  Package instance\n+\n+                           if\n+                             Nkind (Node (Decl)) = N_Package_Instantiation\n+                           then\n+                              Instantiate_Package_Body\n+                                (Info, Body_Optional => True);\n+\n+                           --  Subprogram instance\n+\n+                           else\n+                              --  The instance_spec is the wrapper package,\n+                              --  and the subprogram declaration is the last\n+                              --  declaration in the wrapper.\n+\n+                              Info.Act_Decl :=\n+                                Last\n+                                  (Visible_Declarations\n+                                    (Specification (Info.Act_Decl)));\n+\n+                              Instantiate_Subprogram_Body\n+                                (Info, Body_Optional => True);\n+                           end if;\n \n                            Next_Elmt (Decl);\n                         end loop;\n@@ -10474,7 +10536,7 @@ package body Sem_Ch12 is\n                          Scope_Suppress           => Scope_Suppress,\n                          Local_Suppress_Stack_Top =>\n                            Local_Suppress_Stack_Top)),\n-                                 Body_Optional => Body_Optional);\n+                     Body_Optional => Body_Optional);\n                end;\n             end if;\n \n@@ -10634,7 +10696,7 @@ package body Sem_Ch12 is\n    -- Preanalyze_Actuals --\n    ------------------------\n \n-   procedure Pre_Analyze_Actuals (N : Node_Id) is\n+   procedure Preanalyze_Actuals (N : Node_Id) is\n       Assoc : Node_Id;\n       Act   : Node_Id;\n       Errs  : constant Int := Serious_Errors_Detected;\n@@ -10724,7 +10786,7 @@ package body Sem_Ch12 is\n \n          Next (Assoc);\n       end loop;\n-   end Pre_Analyze_Actuals;\n+   end Preanalyze_Actuals;\n \n    -------------------\n    -- Remove_Parent --"}, {"sha": "689e597b1cec18f2eae5f26769ef0d50a992addc", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -100,9 +100,11 @@ package Sem_Ch12 is\n    --  between the current procedure and Load_Parent_Of_Generic.\n \n    procedure Instantiate_Subprogram_Body\n-     (Body_Info : Pending_Body_Info);\n+     (Body_Info     : Pending_Body_Info;\n+      Body_Optional : Boolean := False);\n    --  Called after semantic analysis, to complete the instantiation of\n-   --  function and procedure instances.\n+   --  function and procedure instances. The flag Body_Optional has the\n+   --  same purpose as described for Instantiate_Package_Body.\n \n    procedure Save_Global_References (N : Node_Id);\n    --  Traverse the original generic unit, and capture all references to"}, {"sha": "1b6eece5782069a760d0abb311e78c6e38066239", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -29,7 +29,6 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Layout;   use Layout;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -485,7 +484,11 @@ package body Sem_Ch13 is\n    --  definition clause that is the preferred approach in Ada 95.\n \n    procedure Analyze_At_Clause (N : Node_Id) is\n+      CS : constant Boolean := Comes_From_Source (N);\n+\n    begin\n+      --  This is an obsolescent feature\n+\n       Check_Restriction (No_Obsolescent_Features, N);\n \n       if Warn_On_Obsolescent_Feature then\n@@ -495,11 +498,21 @@ package body Sem_Ch13 is\n            (\"\\use address attribute definition clause instead?\", N);\n       end if;\n \n+      --  Rewrite as address clause\n+\n       Rewrite (N,\n         Make_Attribute_Definition_Clause (Sloc (N),\n           Name  => Identifier (N),\n           Chars => Name_Address,\n           Expression => Expression (N)));\n+\n+      --  We preserve Comes_From_Source, since logically the clause still\n+      --  comes from the source program even though it is changed in form.\n+\n+      Set_Comes_From_Source (N, CS);\n+\n+      --  Analyze rewritten clause\n+\n       Analyze_Attribute_Definition_Clause (N);\n    end Analyze_At_Clause;\n \n@@ -529,6 +542,10 @@ package body Sem_Ch13 is\n       --  Common processing for 'Read, 'Write, 'Input and 'Output attribute\n       --  definition clauses.\n \n+      -----------------------------------\n+      -- Analyze_Stream_TSS_Definition --\n+      -----------------------------------\n+\n       procedure Analyze_Stream_TSS_Definition (TSS_Nam : TSS_Name_Type) is\n          Subp : Entity_Id := Empty;\n          I    : Interp_Index;\n@@ -588,7 +605,6 @@ package body Sem_Ch13 is\n \n             return Base_Type (Typ) = Base_Type (Ent)\n               and then No (Next_Formal (F));\n-\n          end Has_Good_Profile;\n \n       --  Start of processing for Analyze_Stream_TSS_Definition\n@@ -739,6 +755,22 @@ package body Sem_Ch13 is\n          --  Address attribute definition clause\n \n          when Attribute_Address => Address : begin\n+\n+            --  A little error check, catch for X'Address use X'Address;\n+\n+            if Nkind (Nam) = N_Identifier\n+              and then Nkind (Expr) = N_Attribute_Reference\n+              and then Attribute_Name (Expr) = Name_Address\n+              and then Nkind (Prefix (Expr)) = N_Identifier\n+              and then Chars (Nam) = Chars (Prefix (Expr))\n+            then\n+               Error_Msg_NE\n+                 (\"address for & is self-referencing\", Prefix (Expr), Ent);\n+               return;\n+            end if;\n+\n+            --  Not that special case, carry on with analysis of expression\n+\n             Analyze_And_Resolve (Expr, RTE (RE_Address));\n \n             if Present (Address_Clause (U_Ent)) then\n@@ -875,7 +907,7 @@ package body Sem_Ch13 is\n                   --  We mark a possible modification of a variable with an\n                   --  address clause, since it is likely aliasing is occurring.\n \n-                  Note_Possible_Modification (Nam);\n+                  Note_Possible_Modification (Nam, Sure => False);\n \n                   --  Here we are checking for explicit overlap of one variable\n                   --  by another, and if we find this then mark the overlapped\n@@ -920,22 +952,25 @@ package body Sem_Ch13 is\n \n                --  If the address clause is of the form:\n \n-               --    for X'Address use Y'Address\n+               --    for Y'Address use X'Address\n \n                --  or\n \n-               --    Const : constant Address := Y'Address;\n+               --    Const : constant Address := X'Address;\n                --    ...\n-               --    for X'Address use Const;\n+               --    for Y'Address use Const;\n \n                --  then we make an entry in the table for checking the size and\n                --  alignment of the overlaying variable. We defer this check\n                --  till after code generation to take full advantage of the\n                --  annotation done by the back end. This entry is only made if\n                --  we have not already posted a warning about size/alignment\n-               --  (some warnings of this type are posted in Checks).\n+               --  (some warnings of this type are posted in Checks), and if\n+               --  the address clause comes from source.\n \n-               if Address_Clause_Overlay_Warnings then\n+               if Address_Clause_Overlay_Warnings\n+                 and then Comes_From_Source (N)\n+               then\n                   declare\n                      Ent_X : Entity_Id := Empty;\n                      Ent_Y : Entity_Id := Empty;\n@@ -945,7 +980,18 @@ package body Sem_Ch13 is\n \n                      if Present (Ent_Y) and then Is_Entity_Name (Name (N)) then\n                         Ent_X := Entity (Name (N));\n-                           Address_Clause_Checks.Append ((N, Ent_X, Ent_Y));\n+                        Address_Clause_Checks.Append ((N, Ent_X, Ent_Y));\n+\n+                        --  If variable overlays a constant view, and we are\n+                        --  warning on overlays, then mark the variable as\n+                        --  overlaying a constant (we will give warnings later\n+                        --  if this variable is assigned).\n+\n+                        if Is_Constant_Object (Ent_Y)\n+                          and then Ekind (Ent_X) = E_Variable\n+                        then\n+                           Set_Overlays_Constant (Ent_X);\n+                        end if;\n                      end if;\n                   end;\n                end if;\n@@ -1391,10 +1437,6 @@ package body Sem_Ch13 is\n                Set_Has_Small_Clause (U_Ent);\n                Set_Has_Small_Clause (Implicit_Base);\n                Set_Has_Non_Standard_Rep (Implicit_Base);\n-\n-               --  Recompute RM_Size, but shouldn't this be done in Freeze???\n-\n-               Set_Discrete_RM_Size (U_Ent);\n             end if;\n          end Small;\n \n@@ -1857,10 +1899,7 @@ package body Sem_Ch13 is\n \n       --  Don't allow rep clause for standard [wide_[wide_]]character\n \n-      elsif Root_Type (Enumtype) = Standard_Character\n-        or else Root_Type (Enumtype) = Standard_Wide_Character\n-        or else Root_Type (Enumtype) = Standard_Wide_Wide_Character\n-      then\n+      elsif Is_Standard_Character_Type (Enumtype) then\n          Error_Msg_N (\"enumeration rep clause not allowed for this type\", N);\n          return;\n \n@@ -2310,6 +2349,14 @@ package body Sem_Ch13 is\n                   Error_Msg_N\n                     (\"first bit cannot be negative\", First_Bit (CC));\n \n+               --  The Last_Bit specified in a component clause must not be\n+               --  less than the First_Bit minus one (RM-13.5.1(10)).\n+\n+               elsif Lbit < Fbit - 1 then\n+                  Error_Msg_N\n+                    (\"last bit cannot be less than first bit minus one\",\n+                     Last_Bit (CC));\n+\n                --  Values look OK, so find the corresponding record component\n                --  Even though the syntax allows an attribute reference for\n                --  implementation-defined components, GNAT does not allow the"}, {"sha": "c569a281845fb55f376f645de8c0830a1b114e86", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 82, "deletions": 40, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -118,31 +118,40 @@ package body Sem_Ch5 is\n          --  Some special bad cases of entity names\n \n          elsif Is_Entity_Name (N) then\n-            if Ekind (Entity (N)) = E_In_Parameter then\n-               Error_Msg_N\n-                 (\"assignment to IN mode parameter not allowed\", N);\n-\n-            --  Private declarations in a protected object are turned into\n-            --  constants when compiling a protected function.\n+            declare\n+               Ent : constant Entity_Id := Entity (N);\n \n-            elsif Present (Scope (Entity (N)))\n-              and then Is_Protected_Type (Scope (Entity (N)))\n-              and then\n-                (Ekind (Current_Scope) = E_Function\n-                  or else\n-                 Ekind (Enclosing_Dynamic_Scope (Current_Scope)) = E_Function)\n-            then\n-               Error_Msg_N\n-                 (\"protected function cannot modify protected object\", N);\n+            begin\n+               if Ekind (Ent) = E_In_Parameter then\n+                  Error_Msg_N\n+                    (\"assignment to IN mode parameter not allowed\", N);\n+\n+               --  Renamings of protected private components are turned into\n+               --  constants when compiling a protected function. In the case\n+               --  of single protected types, the private component appears\n+               --  directly.\n+\n+               elsif (Is_Prival (Ent)\n+                        and then\n+                          (Ekind (Current_Scope) = E_Function\n+                             or else Ekind (Enclosing_Dynamic_Scope (\n+                                       Current_Scope)) = E_Function))\n+                   or else\n+                     (Ekind (Ent) = E_Component\n+                        and then Is_Protected_Type (Scope (Ent)))\n+               then\n+                  Error_Msg_N\n+                    (\"protected function cannot modify protected object\", N);\n \n-            elsif Ekind (Entity (N)) = E_Loop_Parameter then\n-               Error_Msg_N\n-                 (\"assignment to loop parameter not allowed\", N);\n+               elsif Ekind (Ent) = E_Loop_Parameter then\n+                  Error_Msg_N\n+                    (\"assignment to loop parameter not allowed\", N);\n \n-            else\n-               Error_Msg_N\n-                 (\"left hand side of assignment must be a variable\", N);\n-            end if;\n+               else\n+                  Error_Msg_N\n+                    (\"left hand side of assignment must be a variable\", N);\n+               end if;\n+            end;\n \n          --  For indexed components or selected components, test prefix\n \n@@ -430,6 +439,15 @@ package body Sem_Ch5 is\n            (\"left hand of assignment must not be limited type\", Lhs);\n          Explain_Limited_Type (T1, Lhs);\n          return;\n+\n+      --  Enforce RM 3.9.3 (8): left-hand side cannot be abstract\n+\n+      elsif Is_Interface (T1)\n+        and then not Is_Class_Wide_Type (T1)\n+      then\n+         Error_Msg_N\n+           (\"target of assignment operation may not be abstract\", Lhs);\n+         return;\n       end if;\n \n       --  Resolution may have updated the subtype, in case the left-hand\n@@ -469,6 +487,7 @@ package body Sem_Ch5 is\n       --  This is the point at which we check for an unset reference\n \n       Check_Unset_Reference (Rhs);\n+      Check_Unprotected_Access (Lhs, Rhs);\n \n       --  Remaining steps are skipped if Rhs was syntactically in error\n \n@@ -588,7 +607,7 @@ package body Sem_Ch5 is\n             --  We still mark this as a possible modification, that's necessary\n             --  to reset Is_True_Constant, and desirable for xref purposes.\n \n-            Note_Possible_Modification (Lhs);\n+            Note_Possible_Modification (Lhs, Sure => True);\n             return;\n \n          --  If we know the right hand side is non-null, then we convert to the\n@@ -635,7 +654,7 @@ package body Sem_Ch5 is\n       --  Note: modifications of the Lhs may only be recorded after\n       --  checks have been applied.\n \n-      Note_Possible_Modification (Lhs);\n+      Note_Possible_Modification (Lhs, Sure => True);\n \n       --  ??? a real accessibility check is needed when ???\n \n@@ -1901,20 +1920,36 @@ package body Sem_Ch5 is\n \n          Analyze (Id);\n          Ent := Entity (Id);\n-         Generate_Reference  (Ent, Loop_Statement, ' ');\n-         Generate_Definition (Ent);\n \n-         --  If we found a label, mark its type. If not, ignore it, since it\n-         --  means we have a conflicting declaration, which would already have\n-         --  been diagnosed at declaration time. Set Label_Construct of the\n-         --  implicit label declaration, which is not created by the parser\n-         --  for generic units.\n+         --  Guard against serious error (typically, a scope mismatch when\n+         --  semantic analysis is requested) by creating loop entity to\n+         --  continue analysis.\n \n-         if Ekind (Ent) = E_Label then\n-            Set_Ekind (Ent, E_Loop);\n+         if No (Ent) then\n+            if Total_Errors_Detected /= 0 then\n+               Ent :=\n+                 New_Internal_Entity\n+                   (E_Loop, Current_Scope, Sloc (Loop_Statement), 'L');\n+            else\n+               raise Program_Error;\n+            end if;\n+\n+         else\n+            Generate_Reference  (Ent, Loop_Statement, ' ');\n+            Generate_Definition (Ent);\n \n-            if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n-               Set_Label_Construct (Parent (Ent), Loop_Statement);\n+            --  If we found a label, mark its type. If not, ignore it, since it\n+            --  means we have a conflicting declaration, which would already\n+            --  have been diagnosed at declaration time. Set Label_Construct\n+            --  of the implicit label declaration, which is not created by the\n+            --  parser for generic units.\n+\n+            if Ekind (Ent) = E_Label then\n+               Set_Ekind (Ent, E_Loop);\n+\n+               if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n+                  Set_Label_Construct (Parent (Ent), Loop_Statement);\n+               end if;\n             end if;\n          end if;\n \n@@ -1928,10 +1963,10 @@ package body Sem_Ch5 is\n          Set_Parent (Ent, Loop_Statement);\n       end if;\n \n-      --  Kill current values on entry to loop, since statements in body\n-      --  of loop may have been executed before the loop is entered.\n-      --  Similarly we kill values after the loop, since we do not know\n-      --  that the body of the loop was executed.\n+      --  Kill current values on entry to loop, since statements in body of\n+      --  loop may have been executed before the loop is entered. Similarly we\n+      --  kill values after the loop, since we do not know that the body of the\n+      --  loop was executed.\n \n       Kill_Current_Values;\n       Push_Scope (Ent);\n@@ -1941,6 +1976,13 @@ package body Sem_Ch5 is\n       End_Scope;\n       Kill_Current_Values;\n       Check_Infinite_Loop_Warning (N);\n+\n+      --  Code after loop is unreachable if the loop has no WHILE or FOR\n+      --  and contains no EXIT statements within the body of the loop.\n+\n+      if No (Iter) and then not Has_Exit (Ent) then\n+         Check_Unreachable_Code (N);\n+      end if;\n    end Analyze_Loop_Statement;\n \n    ----------------------------"}, {"sha": "4fa2246bee91fafbc7bca21ccc67e33bb97c019f", "filename": "gcc/ada/sem_ch5.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,9 +47,9 @@ package Sem_Ch5 is\n    --  be assumed to be reachable.\n \n    procedure Check_Unreachable_Code (N : Node_Id);\n-   --  This procedure is called with N being the node for a statement that\n-   --  is an unconditional transfer of control. It checks to see if the\n-   --  statement is followed by some other statement, and if so generates\n-   --  an appropriate warning for unreachable code.\n+   --  This procedure is called with N being the node for a statement that is\n+   --  an unconditional transfer of control or an apparent infinite loop. It\n+   --  checks to see if the statement is followed by some other statement, and\n+   --  if so generates an appropriate warning for unreachable code.\n \n end Sem_Ch5;"}, {"sha": "7b38241006f6177b903a934d41c0607e39c71295", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 140, "deletions": 30, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -578,9 +578,7 @@ package body Sem_Eval is\n          if Nkind (Lf) = N_Identifier and then Nkind (Rf) = N_Identifier\n            and then Entity (Lf) = Entity (Rf)\n            and then not Is_Floating_Point_Type (Etype (L))\n-           and then (Ekind (Entity (Lf)) = E_Constant     or else\n-                     Ekind (Entity (Lf)) = E_In_Parameter or else\n-                     Ekind (Entity (Lf)) = E_Loop_Parameter)\n+           and then Is_Constant_Object (Entity (Lf))\n          then\n             return True;\n \n@@ -1432,9 +1430,7 @@ package body Sem_Eval is\n \n       Test_Expression_Is_Foldable (N, Left, Right, Stat, Fold);\n \n-      if (C_Typ = Standard_Character\n-            or else C_Typ = Standard_Wide_Character\n-            or else C_Typ = Standard_Wide_Wide_Character)\n+      if Is_Standard_Character_Type (C_Typ)\n         and then Fold\n       then\n          null;\n@@ -2269,14 +2265,13 @@ package body Sem_Eval is\n       Fold   : Boolean;\n \n    begin\n-      --  One special case to deal with first. If we can tell that\n-      --  the result will be false because the lengths of one or\n-      --  more index subtypes are compile time known and different,\n-      --  then we can replace the entire result by False. We only\n-      --  do this for one dimensional arrays, because the case of\n-      --  multi-dimensional arrays is rare and too much trouble!\n-      --  If one of the operands is an illegal aggregate, its type\n-      --  might still be an arbitrary composite type, so nothing to do.\n+      --  One special case to deal with first. If we can tell that the result\n+      --  will be false because the lengths of one or more index subtypes are\n+      --  compile time known and different, then we can replace the entire\n+      --  result by False. We only do this for one dimensional arrays, because\n+      --  the case of multi-dimensional arrays is rare and too much trouble! If\n+      --  one of the operands is an illegal aggregate, its type might still be\n+      --  an arbitrary composite type, so nothing to do.\n \n       if Is_Array_Type (Typ)\n         and then Typ /= Any_Composite\n@@ -2289,7 +2284,9 @@ package body Sem_Eval is\n             return;\n          end if;\n \n-         declare\n+         --  OK, we have the case where we may be able to do this fold\n+\n+         Length_Mismatch : declare\n             procedure Get_Static_Length (Op : Node_Id; Len : out Uint);\n             --  If Op is an expression for a constrained array with a known\n             --  at compile time length, then Len is set to this (non-negative\n@@ -2303,33 +2300,145 @@ package body Sem_Eval is\n                T : Entity_Id;\n \n             begin\n+               --  First easy case string literal\n+\n                if Nkind (Op) = N_String_Literal then\n                   Len := UI_From_Int (String_Length (Strval (Op)));\n+                  return;\n+               end if;\n+\n+               --  Second easy case, not constrained subtype, so no length\n \n-               elsif not Is_Constrained (Etype (Op)) then\n+               if not Is_Constrained (Etype (Op)) then\n                   Len := Uint_Minus_1;\n+                  return;\n+               end if;\n \n-               else\n-                  T := Etype (First_Index (Etype (Op)));\n+               --  General case\n \n-                  if Is_Discrete_Type (T)\n-                    and then\n-                      Compile_Time_Known_Value (Type_Low_Bound (T))\n-                    and then\n-                      Compile_Time_Known_Value (Type_High_Bound (T))\n+               T := Etype (First_Index (Etype (Op)));\n+\n+               --  The simple case, both bounds are known at compile time\n+\n+               if Is_Discrete_Type (T)\n+                 and then\n+                   Compile_Time_Known_Value (Type_Low_Bound (T))\n+                 and then\n+                   Compile_Time_Known_Value (Type_High_Bound (T))\n+               then\n+                  Len := UI_Max (Uint_0,\n+                                 Expr_Value (Type_High_Bound (T)) -\n+                                   Expr_Value (Type_Low_Bound  (T)) + 1);\n+                  return;\n+               end if;\n+\n+               --  A more complex case, where the bounds are of the form\n+               --  X [+/- K1] .. X [+/- K2]), where X is an expression that is\n+               --  either A'First or A'Last (with A an entity name), or X is an\n+               --  entity name, and the two X's are the same and K1 and K2 are\n+               --  known at compile time, in this case, the length can also be\n+               --  computed at compile time, even though the bounds are not\n+               --  known. A common case of this is e.g. (X'First..X'First+5).\n+\n+               Extract_Length : declare\n+                  procedure Decompose_Expr\n+                    (Expr : Node_Id;\n+                     Ent  : out Entity_Id;\n+                     Kind : out Character;\n+                     Cons : out Uint);\n+                  --  Given an expression, see if is of the form above,\n+                  --  X [+/- K]. If so Ent is set to the entity in X,\n+                  --  Kind is 'F','L','E' for 'First/'Last/simple entity,\n+                  --  and Cons is the value of K. If the expression is\n+                  --  not of the required form, Ent is set to Empty.\n+\n+                  --------------------\n+                  -- Decompose_Expr --\n+                  --------------------\n+\n+                  procedure Decompose_Expr\n+                    (Expr : Node_Id;\n+                     Ent  : out Entity_Id;\n+                     Kind : out Character;\n+                     Cons : out Uint)\n+                  is\n+                     Exp : Node_Id;\n+\n+                  begin\n+                     if Nkind (Expr) = N_Op_Add\n+                       and then Compile_Time_Known_Value (Right_Opnd (Expr))\n+                     then\n+                        Exp := Left_Opnd (Expr);\n+                        Cons := Expr_Value (Right_Opnd (Expr));\n+\n+                     elsif Nkind (Expr) = N_Op_Subtract\n+                       and then Compile_Time_Known_Value (Right_Opnd (Expr))\n+                     then\n+                        Exp := Left_Opnd (Expr);\n+                        Cons := -Expr_Value (Right_Opnd (Expr));\n+\n+                     else\n+                        Exp := Expr;\n+                        Cons := Uint_0;\n+                     end if;\n+\n+                     --  At this stage Exp is set to the potential X\n+\n+                     if Nkind (Exp) = N_Attribute_Reference then\n+                        if Attribute_Name (Exp) = Name_First then\n+                           Kind := 'F';\n+                        elsif Attribute_Name (Exp) = Name_Last then\n+                           Kind := 'L';\n+                        else\n+                           Ent := Empty;\n+                           return;\n+                        end if;\n+\n+                        Exp := Prefix (Exp);\n+\n+                     else\n+                        Kind := 'E';\n+                     end if;\n+\n+                     if Is_Entity_Name (Exp)\n+                       and then Present (Entity (Exp))\n+                     then\n+                        Ent := Entity (Exp);\n+                     else\n+                        Ent := Empty;\n+                     end if;\n+                  end Decompose_Expr;\n+\n+                  --  Local Variables\n+\n+                  Ent1,  Ent2  : Entity_Id;\n+                  Kind1, Kind2 : Character;\n+                  Cons1, Cons2 : Uint;\n+\n+               --  Start of processing for Extract_Length\n+\n+               begin\n+                  Decompose_Expr (Type_Low_Bound  (T), Ent1, Kind1, Cons1);\n+                  Decompose_Expr (Type_High_Bound (T), Ent2, Kind2, Cons2);\n+\n+                  if Present (Ent1)\n+                    and then Kind1 = Kind2\n+                    and then Ent1 = Ent2\n                   then\n-                     Len := UI_Max (Uint_0,\n-                                     Expr_Value (Type_High_Bound (T)) -\n-                                     Expr_Value (Type_Low_Bound  (T)) + 1);\n+                     Len := Cons2 - Cons1 + 1;\n                   else\n                      Len := Uint_Minus_1;\n                   end if;\n-               end if;\n+               end Extract_Length;\n             end Get_Static_Length;\n \n+            --  Local Variables\n+\n             Len_L : Uint;\n             Len_R : Uint;\n \n+         --  Start of processing for Length_Mismatch\n+\n          begin\n             Get_Static_Length (Left,  Len_L);\n             Get_Static_Length (Right, Len_R);\n@@ -2342,12 +2451,13 @@ package body Sem_Eval is\n                Warn_On_Known_Condition (N);\n                return;\n             end if;\n-         end;\n+         end Length_Mismatch;\n+      end if;\n \n       --  Another special case: comparisons of access types, where one or both\n       --  operands are known to be null, so the result can be determined.\n \n-      elsif Is_Access_Type (Typ) then\n+      if Is_Access_Type (Typ) then\n          if Known_Null (Left) then\n             if Known_Null (Right) then\n                Fold_Uint (N, Test (Nkind (N) = N_Op_Eq), False);"}, {"sha": "b9ef016a49888cc09b8033a0e424f7cfeb376214", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 394, "deletions": 187, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fc7ddb495d04c3170109f9717e927d73f18e2b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=45fc7ddb495d04c3170109f9717e927d73f18e2b", "patch": "@@ -68,6 +68,7 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Style;    use Style;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -395,9 +396,9 @@ package body Sem_Res is\n       D    : Node_Id;\n \n    begin\n-      --  Any use in a default expression is legal\n+      --  Any use in a a spec-expression is legal\n \n-      if In_Default_Expression then\n+      if In_Spec_Expression then\n          null;\n \n       elsif Nkind (PN) = N_Range then\n@@ -434,10 +435,9 @@ package body Sem_Res is\n               and then Scope (Disc) = Current_Scope\n               and then not\n                 (Nkind (Parent (P)) = N_Subtype_Indication\n-                   and then\n-                    (Nkind (Parent (Parent (P))) = N_Component_Definition\n-                       or else\n-                     Nkind (Parent (Parent (P))) = N_Subtype_Declaration)\n+                  and then\n+                    Nkind_In (Parent (Parent (P)), N_Component_Definition,\n+                                                   N_Subtype_Declaration)\n                   and then Paren_Count (N) = 0)\n             then\n                Error_Msg_N\n@@ -554,8 +554,8 @@ package body Sem_Res is\n \n       --  Legal case is in index or discriminant constraint\n \n-      elsif Nkind (PN) = N_Index_Or_Discriminant_Constraint\n-        or else Nkind (PN) = N_Discriminant_Association\n+      elsif Nkind_In (PN, N_Index_Or_Discriminant_Constraint,\n+                          N_Discriminant_Association)\n       then\n          if Paren_Count (N) > 0 then\n             Error_Msg_N\n@@ -576,9 +576,9 @@ package body Sem_Res is\n       else\n          D := PN;\n          P := Parent (PN);\n-         while Nkind (P) /= N_Component_Declaration\n-           and then Nkind (P) /= N_Subtype_Indication\n-           and then Nkind (P) /= N_Entry_Declaration\n+         while not Nkind_In (P, N_Component_Declaration,\n+                                N_Subtype_Indication,\n+                                N_Entry_Declaration)\n          loop\n             D := P;\n             P := Parent (P);\n@@ -591,10 +591,8 @@ package body Sem_Res is\n          --  is of course a double fault.\n \n          if (Nkind (P) = N_Subtype_Indication\n-              and then\n-                (Nkind (Parent (P)) = N_Component_Definition\n-                   or else\n-                 Nkind (Parent (P)) = N_Derived_Type_Definition)\n+              and then Nkind_In (Parent (P), N_Component_Definition,\n+                                             N_Derived_Type_Definition)\n               and then D = Constraint (P))\n \n          --  The constraint itself may be given by a subtype indication,\n@@ -753,11 +751,10 @@ package body Sem_Res is\n       loop\n          P := Parent (C);\n          exit when Nkind (P) = N_Subprogram_Body;\n-\n-         if Nkind (P) = N_Or_Else        or else\n-            Nkind (P) = N_And_Then       or else\n-            Nkind (P) = N_If_Statement   or else\n-            Nkind (P) = N_Case_Statement\n+         if Nkind_In (P, N_Or_Else,\n+                         N_And_Then,\n+                         N_If_Statement,\n+                         N_Case_Statement)\n          then\n             return False;\n \n@@ -963,25 +960,24 @@ package body Sem_Res is\n          Require_Entity (N);\n       end if;\n \n-      --  If the context expects a value, and the name is a procedure,\n-      --  this is most likely a missing 'Access. Do not try to resolve\n-      --  the parameterless call, error will be caught when the outer\n-      --  call is analyzed.\n+      --  If the context expects a value, and the name is a procedure, this is\n+      --  most likely a missing 'Access. Don't try to resolve the parameterless\n+      --  call, error will be caught when the outer call is analyzed.\n \n       if Is_Entity_Name (N)\n         and then Ekind (Entity (N)) = E_Procedure\n         and then not Is_Overloaded (N)\n         and then\n-         (Nkind (Parent (N)) = N_Parameter_Association\n-            or else Nkind (Parent (N)) = N_Function_Call\n-            or else Nkind (Parent (N)) = N_Procedure_Call_Statement)\n+         Nkind_In (Parent (N), N_Parameter_Association,\n+                               N_Function_Call,\n+                               N_Procedure_Call_Statement)\n       then\n          return;\n       end if;\n \n-      --  Rewrite as call if overloadable entity that is (or could be, in\n-      --  the overloaded case) a function call. If we know for sure that\n-      --  the entity is an enumeration literal, we do not rewrite it.\n+      --  Rewrite as call if overloadable entity that is (or could be, in the\n+      --  overloaded case) a function call. If we know for sure that the entity\n+      --  is an enumeration literal, we do not rewrite it.\n \n       if (Is_Entity_Name (N)\n             and then Is_Overloadable (Entity (N))\n@@ -1386,7 +1382,19 @@ package body Sem_Res is\n \n       Set_Entity (Op_Node, Op_Id);\n       Generate_Reference (Op_Id, N, ' ');\n-      Rewrite (N,  Op_Node);\n+\n+      --  Do rewrite setting Comes_From_Source on the result if the original\n+      --  call came from source. Although it is not strictly the case that the\n+      --  operator as such comes from the source, logically it corresponds\n+      --  exactly to the function call in the source, so it should be marked\n+      --  this way (e.g. to make sure that validity checks work fine).\n+\n+      declare\n+         CS : constant Boolean := Comes_From_Source (N);\n+      begin\n+         Rewrite (N, Op_Node);\n+         Set_Comes_From_Source (N, CS);\n+      end;\n \n       --  If this is an arithmetic operator and the result type is private,\n       --  the operands and the result must be wrapped in conversion to\n@@ -1487,11 +1495,11 @@ package body Sem_Res is\n       return Kind;\n    end Operator_Kind;\n \n-   -----------------------------\n-   -- Pre_Analyze_And_Resolve --\n-   -----------------------------\n+   ----------------------------\n+   -- Preanalyze_And_Resolve --\n+   ----------------------------\n \n-   procedure Pre_Analyze_And_Resolve (N : Node_Id; T : Entity_Id) is\n+   procedure Preanalyze_And_Resolve (N : Node_Id; T : Entity_Id) is\n       Save_Full_Analysis : constant Boolean := Full_Analysis;\n \n    begin\n@@ -1506,11 +1514,11 @@ package body Sem_Res is\n \n       Expander_Mode_Restore;\n       Full_Analysis := Save_Full_Analysis;\n-   end Pre_Analyze_And_Resolve;\n+   end Preanalyze_And_Resolve;\n \n    --  Version without context type\n \n-   procedure Pre_Analyze_And_Resolve (N : Node_Id) is\n+   procedure Preanalyze_And_Resolve (N : Node_Id) is\n       Save_Full_Analysis : constant Boolean := Full_Analysis;\n \n    begin\n@@ -1522,7 +1530,7 @@ package body Sem_Res is\n \n       Expander_Mode_Restore;\n       Full_Analysis := Save_Full_Analysis;\n-   end Pre_Analyze_And_Resolve;\n+   end Preanalyze_And_Resolve;\n \n    ----------------------------------\n    -- Replace_Actual_Discriminants --\n@@ -1647,6 +1655,7 @@ package body Sem_Res is\n                 Intval => UR_To_Uint (Realval (N))));\n             Set_Etype (N, Universal_Integer);\n             Set_Is_Static_Expression (N);\n+\n          elsif Nkind (N) = N_String_Literal\n            and then Is_Character_Type (Typ)\n          then\n@@ -1909,8 +1918,8 @@ package body Sem_Res is\n                      --  of the arguments is Any_Type, and if so, suppress\n                      --  the message, since it is a cascaded error.\n \n-                     if Nkind (N) = N_Function_Call\n-                       or else Nkind (N) = N_Procedure_Call_Statement\n+                     if Nkind_In (N, N_Function_Call,\n+                                     N_Procedure_Call_Statement)\n                      then\n                         declare\n                            A : Node_Id;\n@@ -2079,23 +2088,22 @@ package body Sem_Res is\n                --  with a name that is an explicit dereference, there is\n                --  nothing to be done at this point.\n \n-               elsif     Nkind (N) = N_Explicit_Dereference\n-                 or else Nkind (N) = N_Attribute_Reference\n-                 or else Nkind (N) = N_And_Then\n-                 or else Nkind (N) = N_Indexed_Component\n-                 or else Nkind (N) = N_Or_Else\n-                 or else Nkind (N) = N_Range\n-                 or else Nkind (N) = N_Selected_Component\n-                 or else Nkind (N) = N_Slice\n+               elsif Nkind_In (N, N_Explicit_Dereference,\n+                                  N_Attribute_Reference,\n+                                  N_And_Then,\n+                                  N_Indexed_Component,\n+                                  N_Or_Else,\n+                                  N_Range,\n+                                  N_Selected_Component,\n+                                  N_Slice)\n                  or else Nkind (Name (N)) = N_Explicit_Dereference\n                then\n                   null;\n \n                --  For procedure or function calls, set the type of the name,\n                --  and also the entity pointer for the prefix\n \n-               elsif (Nkind (N) = N_Procedure_Call_Statement\n-                       or else Nkind (N) = N_Function_Call)\n+               elsif Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call)\n                  and then (Is_Entity_Name (Name (N))\n                             or else Nkind (Name (N)) = N_Operator_Symbol)\n                then\n@@ -2398,8 +2406,8 @@ package body Sem_Res is\n \n             elsif Present (Alias (Entity (N)))\n               and then\n-                Nkind (Parent (Parent (Entity (N))))\n-                  = N_Subprogram_Renaming_Declaration\n+                Nkind (Parent (Parent (Entity (N)))) =\n+                                    N_Subprogram_Renaming_Declaration\n             then\n                Rewrite_Renamed_Operator (N, Alias (Entity (N)), Typ);\n \n@@ -2613,6 +2621,11 @@ package body Sem_Res is\n       Prev   : Node_Id := Empty;\n       Orig_A : Node_Id;\n \n+      procedure Check_Argument_Order;\n+      --  Performs a check for the case where the actuals are all simple\n+      --  identifiers that correspond to the formal names, but in the wrong\n+      --  order, which is considered suspicious and cause for a warning.\n+\n       procedure Check_Prefixed_Call;\n       --  If the original node is an overloaded call in prefix notation,\n       --  insert an 'Access or a dereference as needed over the first actual.\n@@ -2630,6 +2643,119 @@ package body Sem_Res is\n       --  common type. Used to enforce the restrictions on array conversions\n       --  of AI95-00246.\n \n+      --------------------------\n+      -- Check_Argument_Order --\n+      --------------------------\n+\n+      procedure Check_Argument_Order is\n+      begin\n+         --  Nothing to do if no parameters, or original node is neither a\n+         --  function call nor a procedure call statement (happens in the\n+         --  operator-transformed-to-function call case), or the call does\n+         --  not come from source, or this warning is off.\n+\n+         if not Warn_On_Parameter_Order\n+           or else\n+             No (Parameter_Associations (N))\n+           or else\n+             not Nkind_In (Original_Node (N), N_Procedure_Call_Statement,\n+                                              N_Function_Call)\n+           or else\n+             not Comes_From_Source (N)\n+         then\n+            return;\n+         end if;\n+\n+         declare\n+            Nargs : constant Nat := List_Length (Parameter_Associations (N));\n+\n+         begin\n+            --  Nothing to do if only one parameter\n+\n+            if Nargs < 2 then\n+               return;\n+            end if;\n+\n+            --  Here if at least two arguments\n+\n+            declare\n+               Actuals : array (1 .. Nargs) of Node_Id;\n+               Actual  : Node_Id;\n+               Formal  : Node_Id;\n+\n+               Wrong_Order : Boolean := False;\n+               --  Set True if an out of order case is found\n+\n+            begin\n+               --  Collect identifier names of actuals, fail if any actual is\n+               --  not a simple identifier, and record max length of name.\n+\n+               Actual := First (Parameter_Associations (N));\n+               for J in Actuals'Range loop\n+                  if Nkind (Actual) /= N_Identifier then\n+                     return;\n+                  else\n+                     Actuals (J) := Actual;\n+                     Next (Actual);\n+                  end if;\n+               end loop;\n+\n+               --  If we got this far, all actuals are identifiers and the list\n+               --  of their names is stored in the Actuals array.\n+\n+               Formal := First_Formal (Nam);\n+               for J in Actuals'Range loop\n+\n+                  --  If we ran out of formals, that's odd, probably an error\n+                  --  which will be detected elsewhere, but abandon the search.\n+\n+                  if No (Formal) then\n+                     return;\n+                  end if;\n+\n+                  --  If name matches and is in order OK\n+\n+                  if Chars (Formal) = Chars (Actuals (J)) then\n+                     null;\n+\n+                  else\n+                     --  If no match, see if it is elsewhere in list and if so\n+                     --  flag potential wrong order if type is compatible.\n+\n+                     for K in Actuals'Range loop\n+                        if Chars (Formal) = Chars (Actuals (K))\n+                          and then\n+                            Has_Compatible_Type (Actuals (K), Etype (Formal))\n+                        then\n+                           Wrong_Order := True;\n+                           goto Continue;\n+                        end if;\n+                     end loop;\n+\n+                     --  No match\n+\n+                     return;\n+                  end if;\n+\n+                  <<Continue>> Next_Formal (Formal);\n+               end loop;\n+\n+               --  If Formals left over, also probably an error, skip warning\n+\n+               if Present (Formal) then\n+                  return;\n+               end if;\n+\n+               --  Here we give the warning if something was out of order\n+\n+               if Wrong_Order then\n+                  Error_Msg_N\n+                    (\"actuals for this call may be in wrong order?\", N);\n+               end if;\n+            end;\n+         end;\n+      end Check_Argument_Order;\n+\n       -------------------------\n       -- Check_Prefixed_Call --\n       -------------------------\n@@ -2866,6 +2992,8 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Actuals\n \n    begin\n+      Check_Argument_Order;\n+\n       if Present (First_Actual (N)) then\n          Check_Prefixed_Call;\n       end if;\n@@ -2889,7 +3017,7 @@ package body Sem_Res is\n \n          --  Case where actual is present\n \n-         --  If the actual is an entity,  generate a reference to it now. We\n+         --  If the actual is an entity, generate a reference to it now. We\n          --  do this before the actual is resolved, because a formal of some\n          --  protected subprogram, or a task discriminant, will be rewritten\n          --  during expansion, and the reference to the source entity may\n@@ -2906,7 +3034,6 @@ package body Sem_Res is\n                  and then Ekind (F) /= E_In_Parameter\n                then\n                   Generate_Reference (Orig_A, A, 'm');\n-\n                elsif not Is_Overloaded (A) then\n                   Generate_Reference (Orig_A, A);\n                end if;\n@@ -2918,6 +3045,14 @@ package body Sem_Res is\n                        or else\n                      Chars (Selector_Name (Parent (A))) = Chars (F))\n          then\n+            --  If style checking mode on, check match of formal name\n+\n+            if Style_Check then\n+               if Nkind (Parent (A)) = N_Parameter_Association then\n+                  Check_Identifier (Selector_Name (Parent (A)), F);\n+               end if;\n+            end if;\n+\n             --  If the formal is Out or In_Out, do not resolve and expand the\n             --  conversion, because it is subsequently expanded into explicit\n             --  temporaries and assignments. However, the object of the\n@@ -2941,32 +3076,51 @@ package body Sem_Res is\n                   if Has_Aliased_Components (Etype (Expression (A)))\n                     /= Has_Aliased_Components (Etype (F))\n                   then\n-                     if Ada_Version < Ada_05 then\n-                        Error_Msg_N\n-                          (\"both component types in a view conversion must be\"\n-                            & \" aliased, or neither\", A);\n \n-                     --  Ada 2005: rule is relaxed (see AI-363)\n+                     --  In a view conversion, the conversion must be legal in\n+                     --  both directions, and thus both component types must be\n+                     --  aliased, or neither (4.6 (8)).\n \n-                     elsif Has_Aliased_Components (Etype (F))\n-                       and then\n-                         not Has_Aliased_Components (Etype (Expression (A)))\n+                     --  The additional rule 4.6 (24.9.2) seems unduly\n+                     --  restrictive: the privacy requirement should not\n+                     --  apply to generic types, and should be checked in\n+                     --  an instance. ARG query is in order.\n+\n+                     Error_Msg_N\n+                       (\"both component types in a view conversion must be\"\n+                         & \" aliased, or neither\", A);\n+\n+                  elsif\n+                     not Same_Ancestor (Etype (F), Etype (Expression (A)))\n+                  then\n+                     if Is_By_Reference_Type (Etype (F))\n+                        or else Is_By_Reference_Type (Etype (Expression (A)))\n                      then\n                         Error_Msg_N\n-                          (\"view conversion operand must have aliased \" &\n-                           \"components\", N);\n-                        Error_Msg_N\n-                          (\"\\since target type has aliased components\", N);\n+                          (\"view conversion between unrelated by reference \" &\n+                           \"array types not allowed (\\'A'I-00246)\", A);\n+                     else\n+                        declare\n+                           Comp_Type : constant Entity_Id :=\n+                                         Component_Type\n+                                           (Etype (Expression (A)));\n+                        begin\n+                           if Comes_From_Source (A)\n+                             and then Ada_Version >= Ada_05\n+                             and then\n+                               ((Is_Private_Type (Comp_Type)\n+                                   and then not Is_Generic_Type (Comp_Type))\n+                                 or else Is_Tagged_Type (Comp_Type)\n+                                 or else Is_Volatile (Comp_Type))\n+                           then\n+                              Error_Msg_N\n+                                (\"component type of a view conversion cannot\"\n+                                   & \" be private, tagged, or volatile\"\n+                                   & \" (RM 4.6 (24))\",\n+                                   Expression (A));\n+                           end if;\n+                        end;\n                      end if;\n-\n-                  elsif not Same_Ancestor (Etype (F), Etype (Expression (A)))\n-                    and then\n-                     (Is_By_Reference_Type (Etype (F))\n-                        or else Is_By_Reference_Type (Etype (Expression (A))))\n-                  then\n-                     Error_Msg_N\n-                       (\"view conversion between unrelated by reference \" &\n-                        \"array types not allowed (\\'A'I-00246)\", A);\n                   end if;\n                end if;\n \n@@ -3024,14 +3178,15 @@ package body Sem_Res is\n                   declare\n                      DDT : constant Entity_Id :=\n                              Directly_Designated_Type (Base_Type (Etype (F)));\n+\n                      New_Itype : Entity_Id;\n+\n                   begin\n                      if Is_Class_Wide_Type (DDT)\n                        and then Is_Interface (DDT)\n                      then\n                         New_Itype := Create_Itype (E_Anonymous_Access_Type, A);\n-                        Set_Etype       (New_Itype, Etype (A));\n-                        Init_Size_Align (New_Itype);\n+                        Set_Etype (New_Itype, Etype (A));\n                         Set_Directly_Designated_Type (New_Itype,\n                           Directly_Designated_Type (Etype (A)));\n                         Set_Etype (A, New_Itype);\n@@ -3043,8 +3198,7 @@ package body Sem_Res is\n                      --  enabled only, otherwise the transient scope will not\n                      --  be removed in the expansion of the wrapped construct.\n \n-                     if (Is_Controlled (DDT)\n-                          or else Has_Task (DDT))\n+                     if (Is_Controlled (DDT) or else Has_Task (DDT))\n                        and then Expander_Active\n                      then\n                         Establish_Transient_Scope (A, False);\n@@ -3056,9 +3210,13 @@ package body Sem_Res is\n                --   a tagged synchronized type, declared outside of the type.\n                --   In this case the controlling actual must be converted to\n                --   its corresponding record type, which is the formal type.\n+               --   The actual may be a subtype, either because of a constraint\n+               --   or because it is a generic actual, so use base type to\n+               --   locate concurrent type.\n \n                if Is_Concurrent_Type (Etype (A))\n-                 and then Etype (F) = Corresponding_Record_Type (Etype (A))\n+                 and then Etype (F) =\n+                            Corresponding_Record_Type (Base_Type (Etype (A)))\n                then\n                   Rewrite (A,\n                     Unchecked_Convert_To\n@@ -3130,14 +3288,14 @@ package body Sem_Res is\n             if Ekind (F) /= E_In_Parameter then\n \n                --  For an Out parameter, check for useless assignment. Note\n-               --  that we can't set Last_Assignment this early, because we\n-               --  may kill current values in Resolve_Call, and that call\n-               --  would clobber the Last_Assignment field.\n+               --  that we can't set Last_Assignment this early, because we may\n+               --  kill current values in Resolve_Call, and that call would\n+               --  clobber the Last_Assignment field.\n \n-               --  Note: call Warn_On_Useless_Assignment before doing the\n-               --  check below for Is_OK_Variable_For_Out_Formal so that the\n-               --  setting of Referenced_As_LHS/Referenced_As_Out_Formal\n-               --  properly reflects the last assignment, not this one!\n+               --  Note: call Warn_On_Useless_Assignment before doing the check\n+               --  below for Is_OK_Variable_For_Out_Formal so that the setting\n+               --  of Referenced_As_LHS/Referenced_As_Out_Formal properly\n+               --  reflects the last assignment, not this one!\n \n                if Ekind (F) = E_Out_Parameter then\n                   if Warn_On_Modified_As_Out_Parameter (F)\n@@ -3258,8 +3416,8 @@ package body Sem_Res is\n             end if;\n \n             --  An actual associated with an access parameter is implicitly\n-            --  converted to the anonymous access type of the formal and\n-            --  must satisfy the legality checks for access conversions.\n+            --  converted to the anonymous access type of the formal and must\n+            --  satisfy the legality checks for access conversions.\n \n             if Ekind (F_Typ) = E_Anonymous_Access_Type then\n                if not Valid_Conversion (A, F_Typ, A) then\n@@ -3500,8 +3658,7 @@ package body Sem_Res is\n       function In_Dispatching_Context return Boolean is\n          Par : constant Node_Id := Parent (N);\n       begin\n-         return (Nkind (Par) = N_Function_Call\n-                   or else Nkind (Par) = N_Procedure_Call_Statement)\n+         return Nkind_In (Par, N_Function_Call, N_Procedure_Call_Statement)\n            and then Is_Entity_Name (Name (Par))\n            and then Is_Dispatching_Operation (Entity (Name (Par)));\n       end In_Dispatching_Context;\n@@ -3691,10 +3848,7 @@ package body Sem_Res is\n             Aggr := Original_Node (Expression (E));\n \n             if Has_Discriminants (Subtyp)\n-              and then\n-                (Nkind (Aggr) = N_Aggregate\n-                   or else\n-                 Nkind (Aggr) = N_Extension_Aggregate)\n+              and then Nkind_In (Aggr, N_Aggregate, N_Extension_Aggregate)\n             then\n                Discrim := First_Discriminant (Base_Type (Subtyp));\n \n@@ -3938,18 +4092,18 @@ package body Sem_Res is\n          --  N is the expression after \"delta\" in a fixed_point_definition;\n          --  see RM-3.5.9(6):\n \n-         return    Nkind (Parent (N)) = N_Ordinary_Fixed_Point_Definition\n-           or else Nkind (Parent (N)) = N_Decimal_Fixed_Point_Definition\n+         return Nkind_In (Parent (N), N_Ordinary_Fixed_Point_Definition,\n+                                      N_Decimal_Fixed_Point_Definition,\n \n          --  N is one of the bounds in a real_range_specification;\n          --  see RM-3.5.7(5):\n \n-           or else Nkind (Parent (N)) = N_Real_Range_Specification\n+                                      N_Real_Range_Specification,\n \n          --  N is the expression of a delta_constraint;\n          --  see RM-J.3(3):\n \n-           or else Nkind (Parent (N)) = N_Delta_Constraint;\n+                                      N_Delta_Constraint);\n       end Expected_Type_Is_Any_Real;\n \n       -----------------------------\n@@ -4143,8 +4297,7 @@ package body Sem_Res is\n       --  conversion to a specific fixed-point type (instead the expander\n       --  takes care of the case).\n \n-      elsif (B_Typ = Universal_Integer\n-           or else B_Typ = Universal_Real)\n+      elsif (B_Typ = Universal_Integer or else B_Typ = Universal_Real)\n         and then Present (Universal_Interpretation (L))\n         and then Present (Universal_Interpretation (R))\n       then\n@@ -4153,15 +4306,14 @@ package body Sem_Res is\n          Set_Etype (N, B_Typ);\n \n       elsif (B_Typ = Universal_Real\n-           or else Etype (N) = Universal_Fixed\n-           or else (Etype (N) = Any_Fixed\n-                     and then Is_Fixed_Point_Type (B_Typ))\n-           or else (Is_Fixed_Point_Type (B_Typ)\n-                     and then (Is_Integer_Or_Universal (L)\n-                                 or else\n-                               Is_Integer_Or_Universal (R))))\n-        and then (Nkind (N) = N_Op_Multiply or else\n-                  Nkind (N) = N_Op_Divide)\n+              or else Etype (N) = Universal_Fixed\n+              or else (Etype (N) = Any_Fixed\n+                        and then Is_Fixed_Point_Type (B_Typ))\n+              or else (Is_Fixed_Point_Type (B_Typ)\n+                        and then (Is_Integer_Or_Universal (L)\n+                                   or else\n+                                  Is_Integer_Or_Universal (R))))\n+        and then Nkind_In (N, N_Op_Multiply, N_Op_Divide)\n       then\n          if TL = Universal_Integer or else TR = Universal_Integer then\n             Check_For_Visible_Operator (N, B_Typ);\n@@ -4189,38 +4341,36 @@ package body Sem_Res is\n             Set_Mixed_Mode_Operand (R, TL);\n          end if;\n \n-         --  Check the rule in RM05-4.5.5(19.1/2) disallowing the\n-         --  universal_fixed multiplying operators from being used when the\n-         --  expected type is also universal_fixed. Note that B_Typ will be\n-         --  Universal_Fixed in some cases where the expected type is actually\n-         --  Any_Real; Expected_Type_Is_Any_Real takes care of that case.\n+         --  Check the rule in RM05-4.5.5(19.1/2) disallowing universal_fixed\n+         --  multiplying operators from being used when the expected type is\n+         --  also universal_fixed. Note that B_Typ will be Universal_Fixed in\n+         --  some cases where the expected type is actually Any_Real;\n+         --  Expected_Type_Is_Any_Real takes care of that case.\n \n          if Etype (N) = Universal_Fixed\n            or else Etype (N) = Any_Fixed\n          then\n             if B_Typ = Universal_Fixed\n               and then not Expected_Type_Is_Any_Real (N)\n-              and then Nkind (Parent (N)) /= N_Type_Conversion\n-              and then Nkind (Parent (N)) /= N_Unchecked_Type_Conversion\n+              and then not Nkind_In (Parent (N), N_Type_Conversion,\n+                                                 N_Unchecked_Type_Conversion)\n             then\n-               Error_Msg_N\n-                 (\"type cannot be determined from context!\", N);\n-               Error_Msg_N\n-                 (\"\\explicit conversion to result type required\", N);\n+               Error_Msg_N (\"type cannot be determined from context!\", N);\n+               Error_Msg_N (\"\\explicit conversion to result type required\", N);\n \n                Set_Etype (L, Any_Type);\n                Set_Etype (R, Any_Type);\n \n             else\n                if Ada_Version = Ada_83\n-                  and then Etype (N) = Universal_Fixed\n-                  and then Nkind (Parent (N)) /= N_Type_Conversion\n-                  and then Nkind (Parent (N)) /= N_Unchecked_Type_Conversion\n+                 and then Etype (N) = Universal_Fixed\n+                 and then not\n+                   Nkind_In (Parent (N), N_Type_Conversion,\n+                                         N_Unchecked_Type_Conversion)\n                then\n                   Error_Msg_N\n-                    (\"(Ada 83) fixed-point operation \" &\n-                     \"needs explicit conversion\",\n-                     N);\n+                    (\"(Ada 83) fixed-point operation \"\n+                     & \"needs explicit conversion\", N);\n                end if;\n \n                --  The expected type is \"any real type\" in contexts like\n@@ -4239,8 +4389,7 @@ package body Sem_Res is\n            and then (Is_Integer_Or_Universal (L)\n                        or else Nkind (L) = N_Real_Literal\n                        or else Nkind (R) = N_Real_Literal\n-                       or else\n-                     Is_Integer_Or_Universal (R))\n+                       or else Is_Integer_Or_Universal (R))\n          then\n             Set_Etype (N, B_Typ);\n \n@@ -4254,7 +4403,8 @@ package body Sem_Res is\n \n       else\n          if (TL = Universal_Integer or else TL = Universal_Real)\n-           and then (TR = Universal_Integer or else TR = Universal_Real)\n+              and then\n+            (TR = Universal_Integer or else TR = Universal_Real)\n          then\n             Check_For_Visible_Operator (N, B_Typ);\n          end if;\n@@ -4263,9 +4413,7 @@ package body Sem_Res is\n          --  universal fixed, this is an error, unless there is only one\n          --  applicable fixed_point type (usually duration).\n \n-         if B_Typ = Universal_Fixed\n-           and then Etype (L) = Universal_Fixed\n-         then\n+         if B_Typ = Universal_Fixed and then Etype (L) = Universal_Fixed then\n             T := Unique_Fixed_Point_Type (N);\n \n             if T  = Any_Type then\n@@ -4306,19 +4454,17 @@ package body Sem_Res is\n \n          --  Give warning if explicit division by zero\n \n-         if (Nkind (N) = N_Op_Divide\n-             or else Nkind (N) = N_Op_Rem\n-             or else Nkind (N) = N_Op_Mod)\n+         if Nkind_In (N, N_Op_Divide, N_Op_Rem, N_Op_Mod)\n            and then not Division_Checks_Suppressed (Etype (N))\n          then\n             Rop := Right_Opnd (N);\n \n             if Compile_Time_Known_Value (Rop)\n               and then ((Is_Integer_Type (Etype (Rop))\n-                                and then Expr_Value (Rop) = Uint_0)\n+                           and then Expr_Value (Rop) = Uint_0)\n                           or else\n                         (Is_Real_Type (Etype (Rop))\n-                                and then Expr_Value_R (Rop) = Ureal_0))\n+                           and then Expr_Value_R (Rop) = Ureal_0))\n             then\n                --  Specialize the warning message according to the operation\n \n@@ -4351,6 +4497,38 @@ package body Sem_Res is\n                Activate_Division_Check (N);\n             end if;\n          end if;\n+\n+         --  If Restriction No_Implicit_Conditionals is active, then it is\n+         --  violated if either operand can be negative for mod, or for rem\n+         --  if both operands can be negative.\n+\n+         if Restrictions.Set (No_Implicit_Conditionals)\n+           and then Nkind_In (N, N_Op_Rem, N_Op_Mod)\n+         then\n+            declare\n+               Lo : Uint;\n+               Hi : Uint;\n+               OK : Boolean;\n+\n+               LNeg : Boolean;\n+               RNeg : Boolean;\n+               --  Set if corresponding operand might be negative\n+\n+            begin\n+               Determine_Range (Left_Opnd (N), OK, Lo, Hi);\n+               LNeg := (not OK) or else Lo < 0;\n+\n+               Determine_Range (Right_Opnd (N), OK, Lo, Hi);\n+               RNeg := (not OK) or else Lo < 0;\n+\n+               if (Nkind (N) = N_Op_Rem and then (LNeg and RNeg))\n+                    or else\n+                  (Nkind (N) = N_Op_Mod and then (LNeg or RNeg))\n+               then\n+                  Check_Restriction (No_Implicit_Conditionals, N);\n+               end if;\n+            end;\n+         end if;\n       end if;\n \n       Check_Unset_Reference (L);\n@@ -4426,8 +4604,7 @@ package body Sem_Res is\n       --  operations use the same circuitry because the name in the call\n       --  can be an arbitrary expression with special resolution rules.\n \n-      elsif Nkind (Subp) = N_Selected_Component\n-        or else Nkind (Subp) = N_Indexed_Component\n+      elsif Nkind_In (Subp, N_Selected_Component, N_Indexed_Component)\n         or else (Is_Entity_Name (Subp)\n                   and then Ekind (Entity (Subp)) = E_Entry)\n       then\n@@ -4474,11 +4651,16 @@ package body Sem_Res is\n             P := N;\n             loop\n                P := Parent (P);\n-               exit when No (P);\n+\n+               --  Exclude calls that occur within the default of a formal\n+               --  parameter of the entry, since those are evaluated outside\n+               --  of the body.\n+\n+               exit when No (P) or else Nkind (P) = N_Parameter_Specification;\n \n                if Nkind (P) = N_Entry_Body\n                  or else (Nkind (P) = N_Subprogram_Body\n-                            and then Is_Entry_Barrier_Function (P))\n+                           and then Is_Entry_Barrier_Function (P))\n                then\n                   Rtype := Etype (N);\n                   Error_Msg_NE\n@@ -4540,15 +4722,15 @@ package body Sem_Res is\n          Error_Msg_N (\"\\cannot call operation that may modify it\", N);\n       end if;\n \n-      --  Freeze the subprogram name if not in default expression. Note that we\n+      --  Freeze the subprogram name if not in a spec-expression. Note that we\n       --  freeze procedure calls as well as function calls. Procedure calls are\n       --  not frozen according to the rules (RM 13.14(14)) because it is\n       --  impossible to have a procedure call to a non-frozen procedure in pure\n       --  Ada, but in the code that we generate in the expander, this rule\n       --  needs extending because we can generate procedure calls that need\n       --  freezing.\n \n-      if Is_Entity_Name (Subp) and then not In_Default_Expression then\n+      if Is_Entity_Name (Subp) and then not In_Spec_Expression then\n          Freeze_Expression (Subp);\n       end if;\n \n@@ -4803,12 +4985,14 @@ package body Sem_Res is\n \n       --  If the subprogram is marked Inline_Always, then even if it returns\n       --  an unconstrained type the call does not require use of the secondary\n-      --  stack.\n+      --  stack. However, inlining will only take place if the body to inline\n+      --  is already present. It may not be available if e.g. the subprogram is\n+      --  declared in a child instance.\n \n       if Is_Inlined (Nam)\n-        and then Present (First_Rep_Item (Nam))\n-        and then Nkind (First_Rep_Item (Nam)) = N_Pragma\n-        and then Pragma_Name (First_Rep_Item (Nam)) = Name_Inline_Always\n+        and then Has_Pragma_Inline_Always (Nam)\n+        and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n+        and then Present (Body_To_Inline (Unit_Declaration_Node (Nam)))\n       then\n          null;\n \n@@ -4883,8 +5067,14 @@ package body Sem_Res is\n       --  way we still take advantage of the current value information while\n       --  scanning the actuals.\n \n-      if (not Is_Library_Level_Entity (Nam)\n-            or else Suppress_Value_Tracking_On_Call (Current_Scope))\n+      --  We suppress killing values if we are processing the nodes associated\n+      --  with N_Freeze_Entity nodes. Otherwise the declaration of a tagged\n+      --  type kills all the values as part of analyzing the code that\n+      --  initializes the dispatch tables.\n+\n+      if Inside_Freezing_Actions = 0\n+        and then (not Is_Library_Level_Entity (Nam)\n+                   or else Suppress_Value_Tracking_On_Call (Current_Scope))\n         and then (Comes_From_Source (Nam)\n                    or else (Present (Alias (Nam))\n                              and then Comes_From_Source (Alias (Nam))))\n@@ -5291,7 +5481,7 @@ package body Sem_Res is\n            and then Comes_From_Source (E)\n            and then No (Constant_Value (E))\n            and then Is_Frozen (Etype (E))\n-           and then not In_Default_Expression\n+           and then not In_Spec_Expression\n            and then not Is_Imported (E)\n          then\n \n@@ -5852,6 +6042,7 @@ package body Sem_Res is\n              (Corresponding_Equality (Entity (N)))\n          then\n             Eval_Relational_Op (N);\n+\n          elsif Nkind (N) = N_Op_Ne\n            and then Is_Abstract_Subprogram (Entity (N))\n          then\n@@ -6382,9 +6573,8 @@ package body Sem_Res is\n          --  In the common case of a call which uses an explicitly null\n          --  value for an access parameter, give specialized error msg\n \n-         if Nkind (Parent (N)) = N_Procedure_Call_Statement\n-              or else\n-            Nkind (Parent (N)) = N_Function_Call\n+         if Nkind_In (Parent (N), N_Procedure_Call_Statement,\n+                                  N_Function_Call)\n          then\n             Error_Msg_N\n               (\"null is not allowed as argument for an access parameter\", N);\n@@ -6999,7 +7189,7 @@ package body Sem_Res is\n       --  sequences that otherwise fail to notice the modification.\n \n       if Is_Entity_Name (P) and then Treat_As_Volatile (Entity (P)) then\n-         Note_Possible_Modification (P);\n+         Note_Possible_Modification (P, Sure => False);\n       end if;\n    end Resolve_Reference;\n \n@@ -7223,8 +7413,8 @@ package body Sem_Res is\n       Resolve (L, B_Typ);\n       Resolve (R, B_Typ);\n \n-      --  Check for issuing warning for always False assert, this happens\n-      --  when assertions are turned off, in which case the pragma Assert\n+      --  Check for issuing warning for always False assert/check, this happens\n+      --  when assertions are turned off, in which case the pragma Assert/Check\n       --  was transformed into:\n \n       --     if False and then <condition> then ...\n@@ -7241,6 +7431,7 @@ package body Sem_Res is\n       then\n          declare\n             Orig : constant Node_Id := Original_Node (Parent (N));\n+\n          begin\n             if Nkind (Orig) = N_Pragma\n               and then Pragma_Name (Orig) = Name_Assert\n@@ -7269,6 +7460,29 @@ package body Sem_Res is\n                      Error_Msg_N (\"?assertion would fail at run-time\", Orig);\n                   end if;\n                end;\n+\n+            --  Similar processing for Check pragma\n+\n+            elsif Nkind (Orig) = N_Pragma\n+              and then Pragma_Name (Orig) = Name_Check\n+            then\n+               --  Don't want to warn if original condition is explicit False\n+\n+               declare\n+                  Expr : constant Node_Id :=\n+                           Original_Node\n+                             (Expression\n+                                (Next (First\n+                                  (Pragma_Argument_Associations (Orig)))));\n+               begin\n+                  if Is_Entity_Name (Expr)\n+                    and then Entity (Expr) = Standard_False\n+                  then\n+                     null;\n+                  else\n+                     Error_Msg_N (\"?check would fail at run-time\", Orig);\n+                  end if;\n+               end;\n             end if;\n          end;\n       end if;\n@@ -7477,16 +7691,17 @@ package body Sem_Res is\n \n       elsif Nkind (Parent (N)) = N_Op_Concat\n         and then not Need_Check\n-        and then Nkind (Original_Node (N)) /= N_Character_Literal\n-        and then Nkind (Original_Node (N)) /= N_Attribute_Reference\n-        and then Nkind (Original_Node (N)) /= N_Qualified_Expression\n-        and then Nkind (Original_Node (N)) /= N_Type_Conversion\n+        and then not Nkind_In (Original_Node (N), N_Character_Literal,\n+                                                  N_Attribute_Reference,\n+                                                  N_Qualified_Expression,\n+                                                  N_Type_Conversion)\n       then\n          Subtype_Id := Typ;\n \n       --  Otherwise we must create a string literal subtype. Note that the\n       --  whole idea of string literal subtypes is simply to avoid the need\n       --  for building a full fledged array subtype for each literal.\n+\n       else\n          Set_String_Literal_Subtype (N, Typ);\n          Subtype_Id := Etype (N);\n@@ -7607,10 +7822,8 @@ package body Sem_Res is\n          --  corresponding character aggregate and let the aggregate\n          --  code do the checking.\n \n-         if R_Typ = Standard_Character\n-           or else R_Typ = Standard_Wide_Character\n-           or else R_Typ = Standard_Wide_Wide_Character\n-         then\n+         if Is_Standard_Character_Type (R_Typ) then\n+\n             --  Check for the case of full range, where we are definitely OK\n \n             if Component_Type (Typ) = Base_Type (Component_Type (Typ)) then\n@@ -7730,10 +7943,10 @@ package body Sem_Res is\n             Set_Etype (Operand, Universal_Real);\n \n          elsif Is_Numeric_Type (Typ)\n-           and then (Nkind (Operand) = N_Op_Multiply\n-                      or else Nkind (Operand) = N_Op_Divide)\n+           and then Nkind_In (Operand, N_Op_Multiply, N_Op_Divide)\n            and then (Etype (Right_Opnd (Operand)) = Universal_Real\n-                     or else Etype (Left_Opnd (Operand)) = Universal_Real)\n+                       or else\n+                     Etype (Left_Opnd  (Operand)) = Universal_Real)\n          then\n             --  Return if expression is ambiguous\n \n@@ -8043,11 +8256,7 @@ package body Sem_Res is\n             --  mod. These are the cases where the grouping can affect results.\n \n             if Paren_Count (Rorig) = 0\n-              and then (Nkind (Rorig) = N_Op_Mod\n-                          or else\n-                        Nkind (Rorig) = N_Op_Multiply\n-                          or else\n-                        Nkind (Rorig) = N_Op_Divide)\n+              and then Nkind_In (Rorig, N_Op_Mod, N_Op_Multiply, N_Op_Divide)\n             then\n                --  For mod, we always give the warning, since the value is\n                --  affected by the parenthesization (e.g. (-5) mod 315 /=\n@@ -8129,9 +8338,7 @@ package body Sem_Res is\n                --  overflow is impossible (divisor > 1) or we have a case of\n                --  division by zero in any case.\n \n-               if (Nkind (Rorig) = N_Op_Divide\n-                    or else\n-                   Nkind (Rorig) = N_Op_Rem)\n+               if Nkind_In (Rorig, N_Op_Divide, N_Op_Rem)\n                  and then Compile_Time_Known_Value (Right_Opnd (Rorig))\n                  and then UI_Abs (Expr_Value (Right_Opnd (Rorig))) /= 1\n                then\n@@ -8334,7 +8541,6 @@ package body Sem_Res is\n       Set_First_Index    (Slice_Subtype, Index);\n       Set_Etype          (Slice_Subtype, Base_Type (Etype (N)));\n       Set_Is_Constrained (Slice_Subtype, True);\n-      Init_Size_Align    (Slice_Subtype);\n \n       Check_Compile_Time_Size (Slice_Subtype);\n \n@@ -8349,7 +8555,9 @@ package body Sem_Res is\n       --  call to Check_Compile_Time_Size could be eliminated, which would\n       --  be nice, because then that routine could be made private to Freeze.\n \n-      if Is_Packed (Slice_Subtype) and not In_Default_Expression then\n+      --  Why the test for In_Spec_Expression here ???\n+\n+      if Is_Packed (Slice_Subtype) and not In_Spec_Expression then\n          Freeze_Itype (Slice_Subtype, N);\n       end if;\n \n@@ -8435,7 +8643,6 @@ package body Sem_Res is\n             Set_First_Index    (Array_Subtype, Index);\n             Set_Etype          (Array_Subtype, Base_Type (Typ));\n             Set_Is_Constrained (Array_Subtype, True);\n-            Init_Size_Align    (Array_Subtype);\n \n             Rewrite (N,\n               Make_Unchecked_Type_Conversion (Loc,\n@@ -8573,7 +8780,6 @@ package body Sem_Res is\n \n       if Nkind (N) = N_Real_Literal then\n          Error_Msg_NE (\"?real literal interpreted as }!\", N, T1);\n-\n       else\n          Error_Msg_NE (\"?universal_fixed expression interpreted as }!\", N, T1);\n       end if;\n@@ -8736,11 +8942,12 @@ package body Sem_Res is\n                return False;\n             end if;\n \n-            --  Check that component subtypes statically match\n+            --  Check that component subtypes statically match. For numeric\n+            --  types this means that both must be either constrained or\n+            --  unconstrained. For enumeration types the bounds must match.\n+            --  All of this is checked in Subtypes_Statically_Match.\n \n-            if Is_Constrained (Target_Comp_Type) /=\n-                 Is_Constrained (Opnd_Comp_Type)\n-              or else not Subtypes_Statically_Match\n+            if not Subtypes_Statically_Match\n                             (Target_Comp_Type, Opnd_Comp_Type)\n             then\n                Error_Msg_N\n@@ -8993,7 +9200,7 @@ package body Sem_Res is\n \n                if Nkind (Operand) = N_Selected_Component\n                  and then Object_Access_Level (Operand) >\n-                            Type_Access_Level (Target_Type)\n+                          Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we\n                   --  know will fail, so generate an appropriate warning.\n@@ -9102,8 +9309,8 @@ package body Sem_Res is\n                --  handles checking the prefix of the operand for this case.)\n \n                if Nkind (Operand) = N_Selected_Component\n-                 and then Object_Access_Level (Operand)\n-                   > Type_Access_Level (Target_Type)\n+                 and then Object_Access_Level (Operand) >\n+                          Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we\n                   --  know will fail, so generate an appropriate warning."}]}