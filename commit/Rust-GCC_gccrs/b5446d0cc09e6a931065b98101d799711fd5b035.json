{"sha": "b5446d0cc09e6a931065b98101d799711fd5b035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0NDZkMGNjMDllNmE5MzEwNjViOTgxMDFkNzk5NzExZmQ1YjAzNQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-03-20T16:26:29Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-03-20T16:26:29Z"}, "message": "d: Fix SEGV in hash_table<odr_name_hasher, false, xcallocator>::find_slot_with_hash\n\nThis patch fixes LTO bug with the D front-end.  As DECL_ASSEMBLER_NAME\nis set on the TYPE_DECL, so TYPE_CXX_ODR_P must also be set on the type.\n\nThe addition of merge_aggregate_types is not strictly needed now, but it\nfixes a problem introduced in newer versions of the dmd front-end where\ntemplated types could be sent more than once to the D code generator.\n\ngcc/d/ChangeLog:\n\n2020-03-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\tPR lto/91027\n\t* d-tree.h (struct GTY): Add daggregate field.\n\t(IDENTIFIER_DAGGREGATE): Define.\n\t(d_mangle_decl): Add declaration.\n\t* decl.cc (mangle_decl): Remove static linkage, rename to...\n\t(d_mangle_decl): ...this, update all callers.\n\t* types.cc (merge_aggregate_types): New function.\n\t(TypeVisitor::visit (TypeStruct *)): Call merge_aggregate_types, set\n\tIDENTIFIER_DAGGREGATE and TYPE_CXX_ODR_P.\n\t(TypeVisitor::visit (TypeClass *)): Likewise.", "tree": {"sha": "6079d101665fcbf8ab836872e1164e5f5b6ffa2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6079d101665fcbf8ab836872e1164e5f5b6ffa2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5446d0cc09e6a931065b98101d799711fd5b035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5446d0cc09e6a931065b98101d799711fd5b035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5446d0cc09e6a931065b98101d799711fd5b035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5446d0cc09e6a931065b98101d799711fd5b035/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aa22b1916a493ac46453d96e0c78ca47bcaeda3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa22b1916a493ac46453d96e0c78ca47bcaeda3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa22b1916a493ac46453d96e0c78ca47bcaeda3"}], "stats": {"total": 76, "additions": 71, "deletions": 5}, "files": [{"sha": "407dc148fc4107999c37e1f4da2adbabcb91ce6e", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=b5446d0cc09e6a931065b98101d799711fd5b035", "patch": "@@ -1,3 +1,16 @@\n+2020-03-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\tPR lto/91027\n+\t* d-tree.h (struct GTY): Add daggregate field.\n+\t(IDENTIFIER_DAGGREGATE): Define.\n+\t(d_mangle_decl): Add declaration.\n+\t* decl.cc (mangle_decl): Remove static linkage, rename to...\n+\t(d_mangle_decl): ...this, update all callers.\n+\t* types.cc (merge_aggregate_types): New function.\n+\t(TypeVisitor::visit (TypeStruct *)): Call merge_aggregate_types, set\n+\tIDENTIFIER_DAGGREGATE and TYPE_CXX_ODR_P.\n+\t(TypeVisitor::visit (TypeClass *)): Likewise.\n+\n 2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* expr.cc (ExprVisitor::visit (CatAssignExp *)): Fix up duplicated"}, {"sha": "0f831c754c042003932fef9d1ae79f3d281417e1", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=b5446d0cc09e6a931065b98101d799711fd5b035", "patch": "@@ -204,6 +204,7 @@ struct GTY(()) lang_identifier\n \n   /* The frontend Declaration associated with this identifier.  */\n   Declaration * GTY((skip)) dsymbol;\n+  AggregateDeclaration * GTY((skip)) daggregate;\n };\n \n #define IDENTIFIER_LANG_SPECIFIC(NODE) \\\n@@ -218,6 +219,9 @@ struct GTY(()) lang_identifier\n #define IDENTIFIER_DSYMBOL(NODE) \\\n   (IDENTIFIER_LANG_SPECIFIC (NODE)->dsymbol)\n \n+#define IDENTIFIER_DAGGREGATE(NODE) \\\n+  (IDENTIFIER_LANG_SPECIFIC (NODE)->daggregate)\n+\n /* Global state pertinent to the current function.  */\n \n struct GTY(()) language_function\n@@ -600,6 +604,7 @@ extern tree d_signed_type (tree);\n extern void d_keep (tree);\n \n /* In decl.cc.  */\n+extern const char *d_mangle_decl (Dsymbol *);\n extern tree mangle_internal_decl (Dsymbol *, const char *, const char *);\n extern void build_decl_tree (Dsymbol *);\n extern tree get_symbol_decl (Declaration *);"}, {"sha": "053d5537f4e6ce46e56f8e52c46b882f541b2abd", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=b5446d0cc09e6a931065b98101d799711fd5b035", "patch": "@@ -59,8 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Return identifier for the external mangled name of DECL.  */\n \n-static const char *\n-mangle_decl (Dsymbol *decl)\n+const char *\n+d_mangle_decl (Dsymbol *decl)\n {\n   if (decl->isFuncDeclaration ())\n     return mangleExact ((FuncDeclaration *)decl);\n@@ -78,7 +78,7 @@ mangle_decl (Dsymbol *decl)\n tree\n mangle_internal_decl (Dsymbol *decl, const char *name, const char *suffix)\n {\n-  const char *prefix = mangle_decl (decl);\n+  const char *prefix = d_mangle_decl (decl);\n   unsigned namelen = strlen (name);\n   unsigned buflen = (2 + strlen (prefix) + namelen + strlen (suffix)) * 2;\n   char *buf = (char *) alloca (buflen);\n@@ -1145,7 +1145,7 @@ get_symbol_decl (Declaration *decl)\n       if (decl->mangleOverride)\n \tmangled_name = get_identifier (decl->mangleOverride);\n       else\n-\tmangled_name = get_identifier (mangle_decl (decl));\n+\tmangled_name = get_identifier (d_mangle_decl (decl));\n \n       mangled_name = targetm.mangle_decl_assembler_name (decl->csym,\n \t\t\t\t\t\t\t mangled_name);\n@@ -2333,7 +2333,7 @@ build_type_decl (tree type, Dsymbol *dsym)\n \n   tree decl = build_decl (make_location_t (dsym->loc), TYPE_DECL,\n \t\t\t  get_identifier (name), type);\n-  SET_DECL_ASSEMBLER_NAME (decl, get_identifier (mangle_decl (dsym)));\n+  SET_DECL_ASSEMBLER_NAME (decl, get_identifier (d_mangle_decl (dsym)));\n   TREE_PUBLIC (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_CONTEXT (decl) = d_decl_context (dsym);"}, {"sha": "025285205ebfdce4aa9bdb5b00780de8d7c2f908", "filename": "gcc/d/types.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5446d0cc09e6a931065b98101d799711fd5b035/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=b5446d0cc09e6a931065b98101d799711fd5b035", "patch": "@@ -498,6 +498,40 @@ finish_aggregate_type (unsigned structsize, unsigned alignsize,\n     }\n }\n \n+/* Returns true if the class or struct type TYPE has already been layed out by\n+   the lowering of another front-end AST type.  In which case, there will either\n+   be a reuse of the back-end type, or a multiple definition error.\n+   DECO is the uniquely mangled decoration for the type.  */\n+\n+static bool\n+merge_aggregate_types (Type *type, tree deco)\n+{\n+  AggregateDeclaration *sym;\n+\n+  if (type->ty == Tstruct)\n+    sym = ((TypeStruct *) type)->sym;\n+  else if (type->ty == Tclass)\n+    sym = ((TypeClass *) type)->sym;\n+  else\n+    gcc_unreachable ();\n+\n+  if (IDENTIFIER_DAGGREGATE (deco))\n+    {\n+      AggregateDeclaration *ad = IDENTIFIER_DAGGREGATE (deco);\n+      /* There should never be a class/struct mismatch in mangled names.  */\n+      gcc_assert ((sym->isStructDeclaration () && ad->isStructDeclaration ())\n+\t\t  || (sym->isClassDeclaration () && ad->isClassDeclaration ()));\n+\n+      /* Non-templated variables shouldn't be defined twice.  */\n+      if (!sym->isInstantiated ())\n+\tScopeDsymbol::multiplyDefined (sym->loc, sym, ad);\n+\n+      type->ctype = build_ctype (ad->type);\n+      return true;\n+    }\n+\n+  return false;\n+}\n \n /* Implements the visitor interface to build the GCC trees of all\n    Type AST classes emitted from the D Front-end, where CTYPE holds\n@@ -857,12 +891,19 @@ class TypeVisitor : public Visitor\n \n   void visit (TypeStruct *t)\n   {\n+    /* Merge types in the back-end if the front-end did not itself do so.  */\n+    tree deco = get_identifier (d_mangle_decl (t->sym));\n+    if (merge_aggregate_types (t, deco))\n+      return;\n+\n     /* Need to set this right away in case of self-references.  */\n     t->ctype = make_node (t->sym->isUnionDeclaration ()\n \t\t\t  ? UNION_TYPE : RECORD_TYPE);\n     d_keep (t->ctype);\n+    IDENTIFIER_DAGGREGATE (deco) = t->sym;\n \n     TYPE_LANG_SPECIFIC (t->ctype) = build_lang_type (t);\n+    TYPE_CXX_ODR_P (t->ctype) = 1;\n \n     if (t->sym->members)\n       {\n@@ -903,17 +944,24 @@ class TypeVisitor : public Visitor\n \n   void visit (TypeClass *t)\n   {\n+    /* Merge types in the back-end if the front-end did not itself do so.  */\n+    tree deco = get_identifier (d_mangle_decl (t->sym));\n+    if (merge_aggregate_types (t, deco))\n+      return;\n+\n     /* Need to set ctype right away in case of self-references to\n        the type during this call.  */\n     tree basetype = make_node (RECORD_TYPE);\n     t->ctype = build_pointer_type (basetype);\n     d_keep (t->ctype);\n+    IDENTIFIER_DAGGREGATE (deco) = t->sym;\n \n     /* Note that lang_specific data is assigned to both the reference\n        and the underlying record type.  */\n     TYPE_LANG_SPECIFIC (t->ctype) = build_lang_type (t);\n     TYPE_LANG_SPECIFIC (basetype) = TYPE_LANG_SPECIFIC (t->ctype);\n     CLASS_TYPE_P (basetype) = 1;\n+    TYPE_CXX_ODR_P (basetype) = 1;\n \n     /* Put out all fields, including from each base class.  */\n     layout_aggregate_type (t->sym, basetype, t->sym);"}]}