{"sha": "1841081a8a306c1a220694a5ddb3a927cb4b2db3", "node_id": "C_kwDOANBUbNoAKDE4NDEwODFhOGEzMDZjMWEyMjA2OTRhNWRkYjNhOTI3Y2I0YjJkYjM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-23T15:15:22Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add expansion pass for the Rust front-end\n\nThe expansion pass is responsible for two actions on our AST:\n\n1. Expanding macro calls\n2. Performing conditional compilation\n\nCalls to macros should be checked and expanded into an AST fragment based on\nthe context they've been called in. This is similar to token substitution, with\na lot of intricacies and checks being performed. A single invocation can result\nin an AST fragment containing multiple statements or multiple expressions,\nwhich need to be handled as well. Furthermore, Rust macros can contain\nrepetitions relying on Kleine operators, similar to regular expression\npatterns, that also need to be expanded properly.\n\nFinally, Rust code can be hidden behind `cfg` directives, which allow the user\nto perform conditional compilation. If a `cfg` predicate is not met, the\nexpression or statement it refers to should be marked for strip and removed\nfrom the AST.\n\n\tgcc/rust/\n\t* expand/rust-attribute-visitor.cc: New.\n\t* expand/rust-attribute-visitor.h: New.\n\t* expand/rust-macro-builtins.cc: New.\n\t* expand/rust-macro-builtins.h: New.\n\t* expand/rust-macro-expand.cc: New.\n\t* expand/rust-macro-expand.h: New.\n\t* expand/rust-macro-invoc-lexer.cc: New.\n\t* expand/rust-macro-invoc-lexer.h: New.\n\t* expand/rust-macro-substitute-ctx.cc: New.\n\t* expand/rust-macro-substitute-ctx.h: New.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Joel Phillips <simplytheother@gmail.com>\nSigned-off-by: Joel Phillips <simplytheother@gmail.com>", "tree": {"sha": "5ed5a29b6188aa40af30a4ab469306e9a8b1bfc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ed5a29b6188aa40af30a4ab469306e9a8b1bfc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1841081a8a306c1a220694a5ddb3a927cb4b2db3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1841081a8a306c1a220694a5ddb3a927cb4b2db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1841081a8a306c1a220694a5ddb3a927cb4b2db3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1841081a8a306c1a220694a5ddb3a927cb4b2db3/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c8fb0eeafb1ec47f75242cb28171fcbdbf6e8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c8fb0eeafb1ec47f75242cb28171fcbdbf6e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c8fb0eeafb1ec47f75242cb28171fcbdbf6e8e"}], "stats": {"total": 6228, "additions": 6228, "deletions": 0}, "files": [{"sha": "8016f9430eb54ed5dc69abc42e2f55bc23645f35", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "added", "additions": 3445, "deletions": 0, "changes": 3445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3"}, {"sha": "0f9d1065334c858c1c67c4f24e6f5ac9ddc719f6", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,316 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-macro-expand.h\"\n+\n+namespace Rust {\n+// Visitor used to expand attributes.\n+class AttrVisitor : public AST::ASTVisitor\n+{\n+private:\n+  MacroExpander &expander;\n+  void maybe_expand_expr (std::unique_ptr<AST::Expr> &expr);\n+  void maybe_expand_type (std::unique_ptr<AST::Type> &expr);\n+\n+public:\n+  AttrVisitor (MacroExpander &expander) : expander (expander) {}\n+\n+  void expand_struct_fields (std::vector<AST::StructField> &fields);\n+  void expand_tuple_fields (std::vector<AST::TupleField> &fields);\n+  void expand_function_params (std::vector<AST::FunctionParam> &params);\n+  void expand_generic_args (AST::GenericArgs &args);\n+  void expand_qualified_path_type (AST::QualifiedPathType &path_type);\n+  void expand_closure_params (std::vector<AST::ClosureParam> &params);\n+  void expand_self_param (AST::SelfParam &self_param);\n+  void expand_where_clause (AST::WhereClause &where_clause);\n+  void expand_trait_function_decl (AST::TraitFunctionDecl &decl);\n+  void expand_trait_method_decl (AST::TraitMethodDecl &decl);\n+\n+  /**\n+   * Expand The current macro fragment recursively until it could not be\n+   * expanded further.\n+   *\n+   * The return value checking works because correctly\n+   * expanded fragment can never be an error (if the fragment can not be\n+   * expanded, a stand-in error fragment will be returned; for fragments that\n+   * could not be further expanded: the fragment prior to the expansion failure\n+   * will be returned).\n+   *\n+   * @return Either the expanded fragment or an empty errored-out fragment\n+   * indicating an expansion failure.\n+   */\n+  AST::ASTFragment expand_macro_fragment_recursive ()\n+  {\n+    auto fragment = expander.take_expanded_fragment (*this);\n+    unsigned int original_depth = expander.expansion_depth;\n+    auto final_fragment = AST::ASTFragment ({}, true);\n+\n+    while (fragment.should_expand ())\n+      {\n+\tfinal_fragment = std::move (fragment);\n+\texpander.expansion_depth++;\n+\t// further expand the previously expanded macro fragment\n+\tauto new_fragment = expander.take_expanded_fragment (*this);\n+\tif (new_fragment.is_error ())\n+\t  break;\n+\tfragment = std::move (new_fragment);\n+      }\n+    expander.expansion_depth = original_depth;\n+    return final_fragment;\n+  }\n+\n+  /**\n+   * Expand a set of values, erasing them if they are marked for strip, and\n+   * replacing them with expanded macro nodes if necessary.\n+   * This function is slightly different from `expand_pointer_allow_strip` as\n+   * it can only be called in certain expansion contexts - where macro\n+   * invocations are allowed.\n+   *\n+   * @param ctx Context to use for macro expansion\n+   * @param values Iterable reference over values to replace or erase\n+   * @param extractor Function to call when replacing values with the content\n+   * \t\tof an expanded AST node\n+   */\n+  template <typename T, typename U>\n+  void expand_macro_children (MacroExpander::ContextType ctx, T &values,\n+\t\t\t      std::function<U (AST::SingleASTNode)> extractor)\n+  {\n+    expander.push_context (ctx);\n+\n+    for (auto it = values.begin (); it != values.end ();)\n+      {\n+\tauto &value = *it;\n+\n+\t// mark for stripping if required\n+\tvalue->accept_vis (*this);\n+\n+\t// recursively expand the children\n+\tauto final_fragment = expand_macro_fragment_recursive ();\n+\n+\tif (final_fragment.should_expand ())\n+\t  {\n+\t    it = values.erase (it);\n+\t    for (auto &node : final_fragment.get_nodes ())\n+\t      {\n+\t\tauto new_node = extractor (node);\n+\t\tif (new_node != nullptr && !new_node->is_marked_for_strip ())\n+\t\t  {\n+\t\t    it = values.insert (it, std::move (new_node));\n+\t\t    it++;\n+\t\t  }\n+\t      }\n+\t  }\n+\telse if (value->is_marked_for_strip ())\n+\t  {\n+\t    it = values.erase (it);\n+\t  }\n+\telse\n+\t  {\n+\t    ++it;\n+\t  }\n+      }\n+\n+    expander.pop_context ();\n+  }\n+\n+  template <typename T> void expand_pointer_allow_strip (T &values)\n+  {\n+    for (auto it = values.begin (); it != values.end ();)\n+      {\n+\tauto &value = *it;\n+\n+\t// mark for stripping if required\n+\tvalue->accept_vis (*this);\n+\tif (value->is_marked_for_strip ())\n+\t  {\n+\t    it = values.erase (it);\n+\t  }\n+\telse\n+\t  {\n+\t    ++it;\n+\t  }\n+      }\n+  }\n+\n+  void visit (AST::Token &) override;\n+  void visit (AST::DelimTokenTree &) override;\n+  void visit (AST::AttrInputMetaItemContainer &) override;\n+  void visit (AST::IdentifierExpr &ident_expr) override;\n+  void visit (AST::Lifetime &) override;\n+  void visit (AST::LifetimeParam &) override;\n+  void visit (AST::ConstGenericParam &) override;\n+\n+  void visit (AST::MacroInvocation &macro_invoc) override;\n+\n+  void visit (AST::PathInExpression &path) override;\n+  void visit (AST::TypePathSegment &) override;\n+  void visit (AST::TypePathSegmentGeneric &segment) override;\n+  void visit (AST::TypePathSegmentFunction &segment) override;\n+  void visit (AST::TypePath &path) override;\n+  void visit (AST::QualifiedPathInExpression &path) override;\n+  void visit (AST::QualifiedPathInType &path) override;\n+\n+  void visit (AST::LiteralExpr &expr) override;\n+  void visit (AST::AttrInputLiteral &) override;\n+  void visit (AST::MetaItemLitExpr &) override;\n+  void visit (AST::MetaItemPathLit &) override;\n+  void visit (AST::BorrowExpr &expr) override;\n+  void visit (AST::DereferenceExpr &expr) override;\n+  void visit (AST::ErrorPropagationExpr &expr) override;\n+  void visit (AST::NegationExpr &expr) override;\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n+  void visit (AST::ComparisonExpr &expr) override;\n+  void visit (AST::LazyBooleanExpr &expr) override;\n+  void visit (AST::TypeCastExpr &expr) override;\n+  void visit (AST::AssignmentExpr &expr) override;\n+  void visit (AST::CompoundAssignmentExpr &expr) override;\n+  void visit (AST::GroupedExpr &expr) override;\n+  void visit (AST::ArrayElemsValues &elems) override;\n+  void visit (AST::ArrayElemsCopied &elems) override;\n+  void visit (AST::ArrayExpr &expr) override;\n+  void visit (AST::ArrayIndexExpr &expr) override;\n+  void visit (AST::TupleExpr &expr) override;\n+  void visit (AST::TupleIndexExpr &expr) override;\n+  void visit (AST::StructExprStruct &expr) override;\n+  void visit (AST::StructExprFieldIdentifier &) override;\n+  void visit (AST::StructExprFieldIdentifierValue &field) override;\n+\n+  void visit (AST::StructExprFieldIndexValue &field) override;\n+  void visit (AST::StructExprStructFields &expr) override;\n+  void visit (AST::StructExprStructBase &expr) override;\n+  void visit (AST::CallExpr &expr) override;\n+  void visit (AST::MethodCallExpr &expr) override;\n+  void visit (AST::FieldAccessExpr &expr) override;\n+  void visit (AST::ClosureExprInner &expr) override;\n+\n+  void visit (AST::BlockExpr &expr) override;\n+\n+  void visit (AST::ClosureExprInnerTyped &expr) override;\n+  void visit (AST::ContinueExpr &expr) override;\n+  void visit (AST::BreakExpr &expr) override;\n+  void visit (AST::RangeFromToExpr &expr) override;\n+  void visit (AST::RangeFromExpr &expr) override;\n+  void visit (AST::RangeToExpr &expr) override;\n+  void visit (AST::RangeFullExpr &) override;\n+  void visit (AST::RangeFromToInclExpr &expr) override;\n+  void visit (AST::RangeToInclExpr &expr) override;\n+  void visit (AST::ReturnExpr &expr) override;\n+  void visit (AST::UnsafeBlockExpr &expr) override;\n+  void visit (AST::LoopExpr &expr) override;\n+  void visit (AST::WhileLoopExpr &expr) override;\n+  void visit (AST::WhileLetLoopExpr &expr) override;\n+  void visit (AST::ForLoopExpr &expr) override;\n+  void visit (AST::IfExpr &expr) override;\n+  void visit (AST::IfExprConseqElse &expr) override;\n+  void visit (AST::IfExprConseqIf &expr) override;\n+  void visit (AST::IfExprConseqIfLet &expr) override;\n+  void visit (AST::IfLetExpr &expr) override;\n+  void visit (AST::IfLetExprConseqElse &expr) override;\n+  void visit (AST::IfLetExprConseqIf &expr) override;\n+  void visit (AST::IfLetExprConseqIfLet &expr) override;\n+  void visit (AST::MatchExpr &expr) override;\n+  void visit (AST::AwaitExpr &expr) override;\n+  void visit (AST::AsyncBlockExpr &expr) override;\n+  void visit (AST::TypeParam &param) override;\n+  void visit (AST::LifetimeWhereClauseItem &) override;\n+  void visit (AST::TypeBoundWhereClauseItem &item) override;\n+  void visit (AST::Method &method) override;\n+  void visit (AST::Module &module) override;\n+  void visit (AST::ExternCrate &crate) override;\n+  void visit (AST::UseTreeGlob &) override;\n+  void visit (AST::UseTreeList &) override;\n+  void visit (AST::UseTreeRebind &) override;\n+  void visit (AST::UseDeclaration &use_decl) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::TypeAlias &type_alias) override;\n+  void visit (AST::StructStruct &struct_item) override;\n+  void visit (AST::TupleStruct &tuple_struct) override;\n+  void visit (AST::EnumItem &item) override;\n+  void visit (AST::EnumItemTuple &item) override;\n+  void visit (AST::EnumItemStruct &item) override;\n+  void visit (AST::EnumItemDiscriminant &item) override;\n+  void visit (AST::Enum &enum_item) override;\n+  void visit (AST::Union &union_item) override;\n+  void visit (AST::ConstantItem &const_item) override;\n+  void visit (AST::StaticItem &static_item) override;\n+  void visit (AST::TraitItemFunc &item) override;\n+  void visit (AST::TraitItemMethod &item) override;\n+  void visit (AST::TraitItemConst &item) override;\n+  void visit (AST::TraitItemType &item) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::InherentImpl &impl) override;\n+  void visit (AST::TraitImpl &impl) override;\n+  void visit (AST::ExternalStaticItem &item) override;\n+  void visit (AST::ExternalFunctionItem &item) override;\n+  void visit (AST::ExternBlock &block) override;\n+\n+  // I don't think it would be possible to strip macros without expansion\n+  void visit (AST::MacroMatchFragment &) override;\n+  void visit (AST::MacroMatchRepetition &) override;\n+  void visit (AST::MacroMatcher &) override;\n+  void visit (AST::MacroRulesDefinition &rules_def) override;\n+  void visit (AST::MetaItemPath &) override;\n+  void visit (AST::MetaItemSeq &) override;\n+  void visit (AST::MetaWord &) override;\n+  void visit (AST::MetaNameValueStr &) override;\n+  void visit (AST::MetaListPaths &) override;\n+  void visit (AST::MetaListNameValueStr &) override;\n+  void visit (AST::LiteralPattern &) override;\n+  void visit (AST::IdentifierPattern &pattern) override;\n+  void visit (AST::WildcardPattern &) override;\n+  void visit (AST::RangePatternBoundLiteral &) override;\n+  void visit (AST::RangePatternBoundPath &bound) override;\n+  void visit (AST::RangePatternBoundQualPath &bound) override;\n+  void visit (AST::RangePattern &pattern) override;\n+  void visit (AST::ReferencePattern &pattern) override;\n+  void visit (AST::StructPatternFieldTuplePat &field) override;\n+  void visit (AST::StructPatternFieldIdentPat &field) override;\n+  void visit (AST::StructPatternFieldIdent &field) override;\n+  void visit (AST::StructPattern &pattern) override;\n+  void visit (AST::TupleStructItemsNoRange &tuple_items) override;\n+  void visit (AST::TupleStructItemsRange &tuple_items) override;\n+  void visit (AST::TupleStructPattern &pattern) override;\n+  void visit (AST::TuplePatternItemsMultiple &tuple_items) override;\n+  void visit (AST::TuplePatternItemsRanged &tuple_items) override;\n+  void visit (AST::TuplePattern &pattern) override;\n+  void visit (AST::GroupedPattern &pattern) override;\n+  void visit (AST::SlicePattern &pattern) override;\n+\n+  void visit (AST::EmptyStmt &) override;\n+  void visit (AST::LetStmt &stmt) override;\n+  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n+  void visit (AST::ExprStmtWithBlock &stmt) override;\n+\n+  void visit (AST::TraitBound &bound) override;\n+  void visit (AST::ImplTraitType &type) override;\n+  void visit (AST::TraitObjectType &type) override;\n+  void visit (AST::ParenthesisedType &type) override;\n+  void visit (AST::ImplTraitTypeOneBound &type) override;\n+  void visit (AST::TraitObjectTypeOneBound &type) override;\n+  void visit (AST::TupleType &type) override;\n+  void visit (AST::NeverType &) override;\n+  void visit (AST::RawPointerType &type) override;\n+  void visit (AST::ReferenceType &type) override;\n+  void visit (AST::ArrayType &type) override;\n+  void visit (AST::SliceType &type) override;\n+  void visit (AST::InferredType &) override;\n+  void visit (AST::BareFunctionType &type) override;\n+};\n+} // namespace Rust"}, {"sha": "5eace13d1974337a0cf56cdb9d8e1b7d9d3067e8", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "added", "additions": 484, "deletions": 0, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,484 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-macro-builtins.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-expr.h\"\n+#include \"rust-session-manager.h\"\n+#include \"rust-macro-invoc-lexer.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+\n+namespace Rust {\n+namespace {\n+std::unique_ptr<AST::Expr>\n+make_string (Location locus, std::string value)\n+{\n+  return std::unique_ptr<AST::Expr> (\n+    new AST::LiteralExpr (value, AST::Literal::STRING,\n+\t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n+}\n+\n+/* Match the end token of a macro given the start delimiter of the macro */\n+\n+static inline TokenId\n+macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n+\t\t Parser<MacroInvocLexer> &parser)\n+{\n+  auto last_token_id = TokenId::RIGHT_CURLY;\n+  switch (invoc_token_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      last_token_id = TokenId::RIGHT_PAREN;\n+      rust_assert (parser.skip_token (LEFT_PAREN));\n+      break;\n+\n+    case AST::DelimType::CURLY:\n+      rust_assert (parser.skip_token (LEFT_CURLY));\n+      break;\n+\n+    case AST::DelimType::SQUARE:\n+      last_token_id = TokenId::RIGHT_SQUARE;\n+      rust_assert (parser.skip_token (LEFT_SQUARE));\n+      break;\n+    }\n+\n+  return last_token_id;\n+}\n+\n+/* Parse a single string literal from the given delimited token tree,\n+   and return the LiteralExpr for it. Allow for an optional trailing comma,\n+   but otherwise enforce that these are the only tokens.  */\n+\n+std::unique_ptr<AST::LiteralExpr>\n+parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n+\t\t\t     Location invoc_locus)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (lex);\n+\n+  auto last_token_id = macro_end_token (invoc_token_tree, parser);\n+\n+  std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n+\n+  if (parser.peek_current_token ()->get_id () == STRING_LITERAL)\n+    {\n+      lit_expr = parser.parse_literal_expr ();\n+      parser.maybe_skip_token (COMMA);\n+      if (parser.peek_current_token ()->get_id () != last_token_id)\n+\t{\n+\t  lit_expr = nullptr;\n+\t  rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+\t}\n+    }\n+  else if (parser.peek_current_token ()->get_id () == last_token_id)\n+    rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+  else\n+    rust_error_at (invoc_locus, \"argument must be a string literal\");\n+\n+  parser.skip_token (last_token_id);\n+\n+  return lit_expr;\n+}\n+\n+/* Treat PATH as a path relative to the source file currently being\n+   compiled, and return the absolute path for it.  */\n+\n+std::string\n+source_relative_path (std::string path, Location locus)\n+{\n+  std::string compile_fname\n+    = Session::get_instance ().linemap->location_file (locus);\n+\n+  auto dir_separator_pos = compile_fname.rfind (file_separator);\n+\n+  /* If there is no file_separator in the path, use current dir ('.').  */\n+  std::string dirname;\n+  if (dir_separator_pos == std::string::npos)\n+    dirname = std::string (\".\") + file_separator;\n+  else\n+    dirname = compile_fname.substr (0, dir_separator_pos) + file_separator;\n+\n+  return dirname + path;\n+}\n+\n+/* Read the full contents of the file FILENAME and return them in a vector.\n+   FIXME: platform specific.  */\n+\n+std::vector<uint8_t>\n+load_file_bytes (const char *filename)\n+{\n+  RAIIFile file_wrap (filename);\n+  if (file_wrap.get_raw () == nullptr)\n+    {\n+      rust_error_at (Location (), \"cannot open filename %s: %m\", filename);\n+      return std::vector<uint8_t> ();\n+    }\n+\n+  FILE *f = file_wrap.get_raw ();\n+  fseek (f, 0L, SEEK_END);\n+  long fsize = ftell (f);\n+  fseek (f, 0L, SEEK_SET);\n+\n+  std::vector<uint8_t> buf (fsize);\n+\n+  if (fread (&buf[0], fsize, 1, f) != 1)\n+    {\n+      rust_error_at (Location (), \"error reading file %s: %m\", filename);\n+      return std::vector<uint8_t> ();\n+    }\n+\n+  return buf;\n+}\n+} // namespace\n+\n+AST::ASTFragment\n+MacroBuiltin::assert (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  rust_debug (\"assert!() called\");\n+\n+  return AST::ASTFragment::create_error ();\n+}\n+\n+AST::ASTFragment\n+MacroBuiltin::file (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto current_file\n+    = Session::get_instance ().linemap->location_file (invoc_locus);\n+  auto file_str = AST::SingleASTNode (make_string (invoc_locus, current_file));\n+\n+  return AST::ASTFragment ({file_str});\n+}\n+\n+AST::ASTFragment\n+MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto current_column\n+    = Session::get_instance ().linemap->location_to_column (invoc_locus);\n+\n+  auto column_no = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n+    new AST::LiteralExpr (std::to_string (current_column), AST::Literal::INT,\n+\t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n+\n+  return AST::ASTFragment ({column_no});\n+}\n+\n+/* Expand builtin macro include_bytes!(\"filename\"), which includes the contents\n+   of the given file as reference to a byte array. Yields an expression of type\n+   &'static [u8; N].  */\n+\n+AST::ASTFragment\n+MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string target_filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+\n+  std::vector<uint8_t> bytes = load_file_bytes (target_filename.c_str ());\n+\n+  /* Is there a more efficient way to do this?  */\n+  std::vector<std::unique_ptr<AST::Expr>> elts;\n+  for (uint8_t b : bytes)\n+    {\n+      elts.emplace_back (\n+\tnew AST::LiteralExpr (std::string (1, (char) b), AST::Literal::BYTE,\n+\t\t\t      PrimitiveCoreType::CORETYPE_U8,\n+\t\t\t      {} /* outer_attrs */, invoc_locus));\n+    }\n+\n+  auto elems = std::unique_ptr<AST::ArrayElems> (\n+    new AST::ArrayElemsValues (std::move (elts), invoc_locus));\n+\n+  auto array = std::unique_ptr<AST::Expr> (\n+    new AST::ArrayExpr (std::move (elems), {}, {}, invoc_locus));\n+\n+  auto borrow = std::unique_ptr<AST::Expr> (\n+    new AST::BorrowExpr (std::move (array), false, false, {}, invoc_locus));\n+\n+  auto node = AST::SingleASTNode (std::move (borrow));\n+  return AST::ASTFragment ({node});\n+}\n+\n+/* Expand builtin macro include_str!(\"filename\"), which includes the contents\n+   of the given file as a string. The file must be UTF-8 encoded. Yields an\n+   expression of type &'static str.  */\n+\n+AST::ASTFragment\n+MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string target_filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+\n+  std::vector<uint8_t> bytes = load_file_bytes (target_filename.c_str ());\n+\n+  /* FIXME: Enforce that the file contents are valid UTF-8.  */\n+  std::string str ((const char *) &bytes[0], bytes.size ());\n+\n+  auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n+  return AST::ASTFragment ({node});\n+}\n+\n+/* Expand builtin macro compile_error!(\"error\"), which forces a compile error\n+   during the compile time. */\n+AST::ASTFragment\n+MacroBuiltin::compile_error (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string error_string = lit_expr->as_string ();\n+  rust_error_at (invoc_locus, \"%s\", error_string.c_str ());\n+\n+  return AST::ASTFragment::create_error ();\n+}\n+\n+/* Expand builtin macro concat!(), which joins all the literal parameters\n+   into a string with no delimiter. */\n+\n+AST::ASTFragment\n+MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto invoc_token_tree = invoc.get_delim_tok_tree ();\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (lex);\n+\n+  auto str = std::string ();\n+  bool has_error = false;\n+\n+  auto last_token_id = macro_end_token (invoc_token_tree, parser);\n+\n+  /* NOTE: concat! could accept no argument, so we don't have any checks here */\n+  while (parser.peek_current_token ()->get_id () != last_token_id)\n+    {\n+      auto lit_expr = parser.parse_literal_expr ();\n+      if (lit_expr)\n+\t{\n+\t  str += lit_expr->as_string ();\n+\t}\n+      else\n+\t{\n+\t  auto current_token = parser.peek_current_token ();\n+\t  rust_error_at (current_token->get_locus (),\n+\t\t\t \"argument must be a constant literal\");\n+\t  has_error = true;\n+\t  // Just crash if the current token can't be skipped\n+\t  rust_assert (parser.skip_token (current_token->get_id ()));\n+\t}\n+      parser.maybe_skip_token (COMMA);\n+    }\n+\n+  parser.skip_token (last_token_id);\n+\n+  if (has_error)\n+    return AST::ASTFragment::create_error ();\n+\n+  auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n+  return AST::ASTFragment ({node});\n+}\n+\n+/* Expand builtin macro env!(), which inspects an environment variable at\n+   compile time. */\n+\n+AST::ASTFragment\n+MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto invoc_token_tree = invoc.get_delim_tok_tree ();\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (lex);\n+\n+  auto last_token_id = macro_end_token (invoc_token_tree, parser);\n+\n+  if (parser.peek_current_token ()->get_id () != STRING_LITERAL)\n+    {\n+      if (parser.peek_current_token ()->get_id () == last_token_id)\n+\trust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n+      else\n+\trust_error_at (parser.peek_current_token ()->get_locus (),\n+\t\t       \"argument must be a string literal\");\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  auto lit_expr = parser.parse_literal_expr ();\n+  auto comma_skipped = parser.maybe_skip_token (COMMA);\n+\n+  std::unique_ptr<AST::LiteralExpr> error_expr = nullptr;\n+\n+  if (parser.peek_current_token ()->get_id () != last_token_id)\n+    {\n+      if (!comma_skipped)\n+\t{\n+\t  rust_error_at (parser.peek_current_token ()->get_locus (),\n+\t\t\t \"expected token: %<,%>\");\n+\t  return AST::ASTFragment::create_error ();\n+\t}\n+      if (parser.peek_current_token ()->get_id () != STRING_LITERAL)\n+\t{\n+\t  rust_error_at (parser.peek_current_token ()->get_locus (),\n+\t\t\t \"argument must be a string literal\");\n+\t  return AST::ASTFragment::create_error ();\n+\t}\n+\n+      error_expr = parser.parse_literal_expr ();\n+      parser.maybe_skip_token (COMMA);\n+    }\n+\n+  if (parser.peek_current_token ()->get_id () != last_token_id)\n+    {\n+      rust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  parser.skip_token (last_token_id);\n+\n+  auto env_value = getenv (lit_expr->as_string ().c_str ());\n+\n+  if (env_value == nullptr)\n+    {\n+      if (error_expr == nullptr)\n+\trust_error_at (invoc_locus, \"environment variable %qs not defined\",\n+\t\t       lit_expr->as_string ().c_str ());\n+      else\n+\trust_error_at (invoc_locus, \"%s\", error_expr->as_string ().c_str ());\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  auto node = AST::SingleASTNode (make_string (invoc_locus, env_value));\n+  return AST::ASTFragment ({node});\n+}\n+\n+AST::ASTFragment\n+MacroBuiltin::cfg (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  // only parse if not already parsed\n+  if (!invoc.is_parsed ())\n+    {\n+      std::unique_ptr<AST::AttrInputMetaItemContainer> converted_input (\n+\tinvoc.get_delim_tok_tree ().parse_to_meta_item ());\n+\n+      if (converted_input == nullptr)\n+\t{\n+\t  rust_debug (\"DEBUG: failed to parse macro to meta item\");\n+\t  // TODO: do something now? is this an actual error?\n+\t}\n+      else\n+\t{\n+\t  std::vector<std::unique_ptr<AST::MetaItemInner>> meta_items (\n+\t    std::move (converted_input->get_items ()));\n+\t  invoc.set_meta_item_output (std::move (meta_items));\n+\t}\n+    }\n+\n+  /* TODO: assuming that cfg! macros can only have one meta item inner, like cfg\n+   * attributes */\n+  if (invoc.get_meta_items ().size () != 1)\n+    return AST::ASTFragment::create_error ();\n+\n+  bool result = invoc.get_meta_items ()[0]->check_cfg_predicate (\n+    Session::get_instance ());\n+  auto literal_exp = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n+    new AST::LiteralExpr (result ? \"true\" : \"false\", AST::Literal::BOOL,\n+\t\t\t  PrimitiveCoreType::CORETYPE_BOOL, {}, invoc_locus)));\n+\n+  return AST::ASTFragment ({literal_exp});\n+}\n+\n+/* Expand builtin macro include!(), which includes a source file at the current\n+ scope compile time. */\n+\n+AST::ASTFragment\n+MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+  auto target_filename\n+    = Rust::Session::get_instance ().include_extra_file (std::move (filename));\n+\n+  RAIIFile target_file (target_filename);\n+  Linemap *linemap = Session::get_instance ().linemap;\n+\n+  if (!target_file.ok ())\n+    {\n+      rust_error_at (lit_expr->get_locus (),\n+\t\t     \"cannot open included file %qs: %m\", target_filename);\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  rust_debug (\"Attempting to parse included file %s\", target_filename);\n+\n+  Lexer lex (target_filename, std::move (target_file), linemap);\n+  Parser<Lexer> parser (lex);\n+\n+  auto parsed_items = parser.parse_items ();\n+  bool has_error = !parser.get_errors ().empty ();\n+\n+  for (const auto &error : parser.get_errors ())\n+    error.emit_error ();\n+\n+  if (has_error)\n+    {\n+      // inform the user that the errors above are from a included file\n+      rust_inform (invoc_locus, \"included from here\");\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  std::vector<AST::SingleASTNode> nodes{};\n+  for (auto &item : parsed_items)\n+    {\n+      AST::SingleASTNode node (std::move (item));\n+      nodes.push_back (node);\n+    }\n+\n+  return AST::ASTFragment (nodes);\n+}\n+\n+AST::ASTFragment\n+MacroBuiltin::line (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  auto current_line\n+    = Session::get_instance ().linemap->location_to_line (invoc_locus);\n+\n+  auto line_no = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n+    new AST::LiteralExpr (std::to_string (current_line), AST::Literal::INT,\n+\t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n+\n+  return AST::ASTFragment ({line_no});\n+}\n+\n+} // namespace Rust"}, {"sha": "91f3727d450ce0de336860f8347bb49ee1f95ad4", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MACRO_BUILTINS_H\n+#define RUST_MACRO_BUILTINS_H\n+\n+#include \"rust-ast.h\"\n+#include \"rust-location.h\"\n+\n+/**\n+ * This class provides a list of builtin macros implemented by the compiler.\n+ * The functions defined are called \"builtin transcribers\" in that they replace\n+ * the transcribing part of a macro definition.\n+ *\n+ * Like regular macro transcribers, they are responsible for building and\n+ * returning an AST fragment: basically a vector of AST nodes put together.\n+ *\n+ * Unlike regular declarative macros where each match arm has its own associated\n+ * transcriber, builtin transcribers are responsible for handling all match arms\n+ * of the macro. This means that you should take extra care when implementing a\n+ * builtin containing multiple match arms: You will probably need to do some\n+ * lookahead in order to determine which match arm the user intended to use.\n+ *\n+ * An example of this is the `assert!()` macro:\n+ *\n+ * ```\n+ *  macro_rules! assert {\n+ *\t($cond:expr $(,)?) => {{ ... }};\n+ *\t($cond : expr, $ ($arg : tt) +) = > {{ ... }};\n+ * }\n+ * ```\n+ *\n+ * If more tokens exist beyond the optional comma, they need to be handled as\n+ * a token-tree for a custom panic message.\n+ *\n+ * These builtin macros with empty transcribers are defined in the standard\n+ * library. They are marked with a special attribute, `#[rustc_builtin_macro]`.\n+ * When this attribute is present on a macro definition, the compiler should\n+ * look for an associated transcriber in the mappings. Meaning that you must\n+ * remember to insert your transcriber in the `builtin_macros` map of the\n+ *`Mappings`.\n+ *\n+ * This map is built as a static variable in the `insert_macro_def()` method\n+ * of the `Mappings` class.\n+ */\n+\n+/* If assert is defined as a macro this file will not parse, so undefine this\n+   before continuing.  */\n+#ifdef assert\n+#undef assert\n+#endif\n+\n+namespace Rust {\n+class MacroBuiltin\n+{\n+public:\n+  static AST::ASTFragment assert (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment file (Location invoc_locus,\n+\t\t\t\tAST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment column (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include_bytes (Location invoc_locus,\n+\t\t\t\t\t AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include_str (Location invoc_locus,\n+\t\t\t\t       AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment compile_error (Location invoc_locus,\n+\t\t\t\t\t AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment concat (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment env (Location invoc_locus,\n+\t\t\t       AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment cfg (Location invoc_locus,\n+\t\t\t       AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include (Location invoc_locus,\n+\t\t\t\t   AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment line (Location invoc_locus,\n+\t\t\t\tAST::MacroInvocData &invoc);\n+};\n+} // namespace Rust\n+\n+#endif // RUST_MACRO_BUILTINS_H"}, {"sha": "1d57e3942202a8683f30c667934717268dd5a400", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "added", "additions": 1012, "deletions": 0, "changes": 1012, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,1012 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-macro-expand.h\"\n+#include \"rust-macro-substitute-ctx.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-attribute-visitor.h\"\n+\n+namespace Rust {\n+AST::ASTFragment\n+MacroExpander::expand_decl_macro (Location invoc_locus,\n+\t\t\t\t  AST::MacroInvocData &invoc,\n+\t\t\t\t  AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t  bool semicolon)\n+{\n+  // ensure that both invocation and rules are in a valid state\n+  rust_assert (!invoc.is_marked_for_strip ());\n+  rust_assert (!rules_def.is_marked_for_strip ());\n+  rust_assert (rules_def.get_macro_rules ().size () > 0);\n+\n+  /* probably something here about parsing invoc and rules def token trees to\n+   * token stream. if not, how would parser handle the captures of exprs and\n+   * stuff? on the other hand, token trees may be kind of useful in rules def as\n+   * creating a point where recursion can occur (like having\n+   * \"compare_macro_match\" and then it calling itself when it finds delimiters)\n+   */\n+\n+  /* find matching rule to invoc token tree, based on macro rule's matcher. if\n+   * none exist, error.\n+   * - specifically, check each matcher in order. if one fails to match, move\n+   * onto next. */\n+  /* TODO: does doing this require parsing expressions and whatever in the\n+   * invoc? if so, might as well save the results if referenced using $ or\n+   * whatever. If not, do another pass saving them. Except this is probably\n+   * useless as different rules could have different starting points for exprs\n+   * or whatever. Decision trees could avoid this, but they have their own\n+   * issues. */\n+  /* TODO: will need to modify the parser so that it can essentially \"catch\"\n+   * errors - maybe \"try_parse_expr\" or whatever methods. */\n+  // this technically creates a back-tracking parser - this will be the\n+  // implementation style\n+\n+  /* then, after results are saved, generate the macro output from the\n+   * transcriber token tree. if i understand this correctly, the macro\n+   * invocation gets replaced by the transcriber tokens, except with\n+   * substitutions made (e.g. for $i variables) */\n+\n+  /* TODO: it is probably better to modify AST::Token to store a pointer to a\n+   * Lexer::Token (rather than being converted) - i.e. not so much have\n+   * AST::Token as a Token but rather a TokenContainer (as it is another type of\n+   * TokenTree). This will prevent re-conversion of Tokens between each type\n+   * all the time, while still allowing the heterogenous storage of token trees.\n+   */\n+\n+  AST::DelimTokenTree &invoc_token_tree = invoc.get_delim_tok_tree ();\n+\n+  // find matching arm\n+  AST::MacroRule *matched_rule = nullptr;\n+  std::map<std::string, MatchedFragmentContainer> matched_fragments;\n+  for (auto &rule : rules_def.get_rules ())\n+    {\n+      sub_stack.push ();\n+      bool did_match_rule = try_match_rule (rule, invoc_token_tree);\n+      matched_fragments = sub_stack.pop ();\n+\n+      if (did_match_rule)\n+\t{\n+\t  //  // Debugging\n+\t  //  for (auto &kv : matched_fragments)\n+\t  //    rust_debug (\"[fragment]: %s (%ld - %s)\", kv.first.c_str (),\n+\t  //\t\tkv.second.get_fragments ().size (),\n+\t  //\t\tkv.second.get_kind ()\n+\t  //\t\t    == MatchedFragmentContainer::Kind::Repetition\n+\t  //\t\t  ? \"repetition\"\n+\t  //\t\t  : \"metavar\");\n+\n+\t  matched_rule = &rule;\n+\t  break;\n+\t}\n+    }\n+\n+  if (matched_rule == nullptr)\n+    {\n+      RichLocation r (invoc_locus);\n+      r.add_range (rules_def.get_locus ());\n+      rust_error_at (r, \"Failed to match any rule within macro\");\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments,\n+\t\t\t  semicolon, peek_context ());\n+}\n+\n+void\n+MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+      return;\n+    }\n+\n+  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+\n+  // ??\n+  // switch on type of macro:\n+  //  - '!' syntax macro (inner switch)\n+  //      - procedural macro - \"A token-based function-like macro\"\n+  //      - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n+  // AST-based function-like macro\"\n+  //      - else is unreachable\n+  //  - attribute syntax macro (inner switch)\n+  //  - procedural macro attribute syntax - \"A token-based attribute\n+  // macro\"\n+  //      - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+  //      - non-macro attribute: mark known\n+  //      - else is unreachable\n+  //  - derive macro (inner switch)\n+  //      - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+  //      - else is unreachable\n+  //  - derive container macro - unreachable\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  NodeId source_node = UNKNOWN_NODEID;\n+  if (has_semicolon)\n+    source_node = invoc.get_macro_node_id ();\n+  else\n+    source_node = invoc.get_pattern_node_id ();\n+  auto seg\n+    = Resolver::CanonicalPath::new_seg (source_node,\n+\t\t\t\t\tinvoc_data.get_path ().as_string ());\n+\n+  bool found = resolver->get_macro_scope ().lookup (seg, &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro: [%s]\",\n+\t\t     seg.get ().c_str ());\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  auto fragment = AST::ASTFragment::create_error ();\n+\n+  if (rules_def->is_builtin ())\n+    fragment\n+      = rules_def->get_builtin_transcriber () (invoc.get_locus (), invoc_data);\n+  else\n+    fragment = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def,\n+\t\t\t\t  has_semicolon);\n+\n+  set_expanded_fragment (std::move (fragment));\n+}\n+\n+/* Determines whether any cfg predicate is false and hence item with attributes\n+ * should be stripped. Note that attributes must be expanded before calling. */\n+bool\n+MacroExpander::fails_cfg (const AST::AttrVec &attrs) const\n+{\n+  for (const auto &attr : attrs)\n+    {\n+      if (attr.get_path () == \"cfg\" && !attr.check_cfg_predicate (session))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Determines whether any cfg predicate is false and hence item with attributes\n+ * should be stripped. Will expand attributes as well. */\n+bool\n+MacroExpander::fails_cfg_with_expand (AST::AttrVec &attrs) const\n+{\n+  // TODO: maybe have something that strips cfg attributes that evaluate true?\n+  for (auto &attr : attrs)\n+    {\n+      if (attr.get_path () == \"cfg\")\n+\t{\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    attr.parse_attr_to_meta_item ();\n+\n+\t  // DEBUG\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    rust_debug (\"failed to parse attr to meta item, right before \"\n+\t\t\t\"cfg predicate check\");\n+\t  else\n+\t    rust_debug (\"attr has been successfully parsed to meta item, \"\n+\t\t\t\"right before cfg predicate check\");\n+\n+\t  if (!attr.check_cfg_predicate (session))\n+\t    {\n+\t      // DEBUG\n+\t      rust_debug (\n+\t\t\"cfg predicate failed for attribute: \\033[0;31m'%s'\\033[0m\",\n+\t\tattr.as_string ().c_str ());\n+\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      // DEBUG\n+\t      rust_debug (\"cfg predicate succeeded for attribute: \"\n+\t\t\t  \"\\033[0;31m'%s'\\033[0m\",\n+\t\t\t  attr.as_string ().c_str ());\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+// Expands cfg_attr attributes.\n+void\n+MacroExpander::expand_cfg_attrs (AST::AttrVec &attrs)\n+{\n+  for (std::size_t i = 0; i < attrs.size (); i++)\n+    {\n+      auto &attr = attrs[i];\n+      if (attr.get_path () == \"cfg_attr\")\n+\t{\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    attr.parse_attr_to_meta_item ();\n+\n+\t  if (attr.check_cfg_predicate (session))\n+\t    {\n+\t      // split off cfg_attr\n+\t      AST::AttrVec new_attrs = attr.separate_cfg_attrs ();\n+\n+\t      // remove attr from vector\n+\t      attrs.erase (attrs.begin () + i);\n+\n+\t      // add new attrs to vector\n+\t      attrs.insert (attrs.begin () + i,\n+\t\t\t    std::make_move_iterator (new_attrs.begin ()),\n+\t\t\t    std::make_move_iterator (new_attrs.end ()));\n+\t    }\n+\n+\t  /* do something - if feature (first token in tree) is in fact enabled,\n+\t   * make tokens listed afterwards into attributes. i.e.: for\n+\t   * [cfg_attr(feature = \"wow\", wow1, wow2)], if \"wow\" is true, then add\n+\t   * attributes [wow1] and [wow2] to attribute list. This can also be\n+\t   * recursive, so check for expanded attributes being recursive and\n+\t   * possibly recursively call the expand_attrs? */\n+\t}\n+      else\n+\t{\n+\t  i++;\n+\t}\n+    }\n+  attrs.shrink_to_fit ();\n+}\n+\n+void\n+MacroExpander::expand_crate ()\n+{\n+  NodeId scope_node_id = crate.get_node_id ();\n+  resolver->get_macro_scope ().push (scope_node_id);\n+\n+  /* fill macro/decorator map from init list? not sure where init list comes\n+   * from? */\n+\n+  // TODO: does cfg apply for inner attributes? research.\n+  // the apparent answer (from playground test) is yes\n+\n+  // expand crate cfg_attr attributes\n+  expand_cfg_attrs (crate.inner_attrs);\n+\n+  if (fails_cfg_with_expand (crate.inner_attrs))\n+    {\n+      // basically, delete whole crate\n+      crate.strip_crate ();\n+      // TODO: maybe create warning here? probably not desired behaviour\n+    }\n+  // expand module attributes?\n+\n+  push_context (ITEM);\n+\n+  // expand attributes recursively and strip items if required\n+  AttrVisitor attr_visitor (*this);\n+  auto &items = crate.items;\n+  for (auto it = items.begin (); it != items.end ();)\n+    {\n+      auto &item = *it;\n+\n+      // mark for stripping if required\n+      item->accept_vis (attr_visitor);\n+\n+      auto fragment = take_expanded_fragment (attr_visitor);\n+      if (fragment.should_expand ())\n+\t{\n+\t  // Remove the current expanded invocation\n+\t  it = items.erase (it);\n+\t  for (auto &node : fragment.get_nodes ())\n+\t    {\n+\t      it = items.insert (it, node.take_item ());\n+\t      it++;\n+\t    }\n+\t}\n+      else if (item->is_marked_for_strip ())\n+\tit = items.erase (it);\n+      else\n+\tit++;\n+    }\n+\n+  pop_context ();\n+\n+  // TODO: should recursive attribute and macro expansion be done in the same\n+  // transversal? Or in separate ones like currently?\n+\n+  // expand module tree recursively\n+\n+  // post-process\n+\n+  // extract exported macros?\n+}\n+\n+bool\n+MacroExpander::depth_exceeds_recursion_limit () const\n+{\n+  return expansion_depth >= cfg.recursion_limit;\n+}\n+\n+bool\n+MacroExpander::try_match_rule (AST::MacroRule &match_rule,\n+\t\t\t       AST::DelimTokenTree &invoc_token_tree)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (lex);\n+\n+  AST::MacroMatcher &matcher = match_rule.get_matcher ();\n+\n+  expansion_depth++;\n+  if (!match_matcher (parser, matcher))\n+    {\n+      expansion_depth--;\n+      return false;\n+    }\n+  expansion_depth--;\n+\n+  bool used_all_input_tokens = parser.skip_token (END_OF_FILE);\n+  return used_all_input_tokens;\n+}\n+\n+bool\n+MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n+\t\t\t       AST::MacroMatchFragment &fragment)\n+{\n+  switch (fragment.get_frag_spec ().get_kind ())\n+    {\n+    case AST::MacroFragSpec::EXPR:\n+      parser.parse_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::BLOCK:\n+      parser.parse_block_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::IDENT:\n+      parser.parse_identifier_pattern ();\n+      break;\n+\n+    case AST::MacroFragSpec::LITERAL:\n+      parser.parse_literal_expr ();\n+      break;\n+\n+    case AST::MacroFragSpec::ITEM:\n+      parser.parse_item (false);\n+      break;\n+\n+    case AST::MacroFragSpec::TY:\n+      parser.parse_type ();\n+      break;\n+\n+    case AST::MacroFragSpec::PAT:\n+      parser.parse_pattern ();\n+      break;\n+\n+    case AST::MacroFragSpec::PATH:\n+      parser.parse_path_in_expression ();\n+      break;\n+\n+    case AST::MacroFragSpec::VIS:\n+      parser.parse_visibility ();\n+      break;\n+\n+      case AST::MacroFragSpec::STMT: {\n+\tauto restrictions = ParseRestrictions ();\n+\trestrictions.consume_semi = false;\n+\tparser.parse_stmt (restrictions);\n+\tbreak;\n+      }\n+\n+    case AST::MacroFragSpec::LIFETIME:\n+      parser.parse_lifetime_params ();\n+      break;\n+\n+      // is meta attributes?\n+    case AST::MacroFragSpec::META:\n+      parser.parse_attribute_body ();\n+      break;\n+\n+    case AST::MacroFragSpec::TT:\n+      parser.parse_token_tree ();\n+      break;\n+\n+      // i guess we just ignore invalid and just error out\n+    case AST::MacroFragSpec::INVALID:\n+      return false;\n+    }\n+\n+  // it matches if the parser did not produce errors trying to parse that type\n+  // of item\n+  return !parser.has_errors ();\n+}\n+\n+bool\n+MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n+\t\t\t      AST::MacroMatcher &matcher)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (matcher.get_match_locus (), \"reached recursion limit\");\n+      return false;\n+    }\n+\n+  auto delimiter = parser.peek_current_token ();\n+\n+  // this is used so we can check that we delimit the stream correctly.\n+  switch (delimiter->get_id ())\n+    {\n+      case LEFT_PAREN: {\n+\tif (!parser.skip_token (LEFT_PAREN))\n+\t  return false;\n+      }\n+      break;\n+\n+      case LEFT_SQUARE: {\n+\tif (!parser.skip_token (LEFT_SQUARE))\n+\t  return false;\n+      }\n+      break;\n+\n+      case LEFT_CURLY: {\n+\tif (!parser.skip_token (LEFT_CURLY))\n+\t  return false;\n+      }\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  const MacroInvocLexer &source = parser.get_token_source ();\n+\n+  for (auto &match : matcher.get_matches ())\n+    {\n+      size_t offs_begin = source.get_offs ();\n+\n+      switch (match->get_macro_match_type ())\n+\t{\n+\t  case AST::MacroMatch::MacroMatchType::Fragment: {\n+\t    AST::MacroMatchFragment *fragment\n+\t      = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t    if (!match_fragment (parser, *fragment))\n+\t      return false;\n+\n+\t    // matched fragment get the offset in the token stream\n+\t    size_t offs_end = source.get_offs ();\n+\t    sub_stack.insert_metavar (\n+\t      MatchedFragment (fragment->get_ident (), offs_begin, offs_end));\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Tok: {\n+\t    AST::Token *tok = static_cast<AST::Token *> (match.get ());\n+\t    if (!match_token (parser, *tok))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Repetition: {\n+\t    AST::MacroMatchRepetition *rep\n+\t      = static_cast<AST::MacroMatchRepetition *> (match.get ());\n+\t    if (!match_repetition (parser, *rep))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\t  case AST::MacroMatch::MacroMatchType::Matcher: {\n+\t    AST::MacroMatcher *m\n+\t      = static_cast<AST::MacroMatcher *> (match.get ());\n+\t    expansion_depth++;\n+\t    if (!match_matcher (parser, *m))\n+\t      {\n+\t\texpansion_depth--;\n+\t\treturn false;\n+\t      }\n+\t    expansion_depth--;\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  switch (delimiter->get_id ())\n+    {\n+      case LEFT_PAREN: {\n+\tif (!parser.skip_token (RIGHT_PAREN))\n+\t  return false;\n+      }\n+      break;\n+\n+      case LEFT_SQUARE: {\n+\tif (!parser.skip_token (RIGHT_SQUARE))\n+\t  return false;\n+      }\n+      break;\n+\n+      case LEFT_CURLY: {\n+\tif (!parser.skip_token (RIGHT_CURLY))\n+\t  return false;\n+      }\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return true;\n+}\n+\n+bool\n+MacroExpander::match_token (Parser<MacroInvocLexer> &parser, AST::Token &token)\n+{\n+  // FIXME this needs to actually match the content and the type\n+  return parser.skip_token (token.get_id ());\n+}\n+\n+bool\n+MacroExpander::match_n_matches (Parser<MacroInvocLexer> &parser,\n+\t\t\t\tAST::MacroMatchRepetition &rep,\n+\t\t\t\tsize_t &match_amount, size_t lo_bound,\n+\t\t\t\tsize_t hi_bound)\n+{\n+  match_amount = 0;\n+  auto &matches = rep.get_matches ();\n+\n+  const MacroInvocLexer &source = parser.get_token_source ();\n+  while (true)\n+    {\n+      // If the current token is a closing macro delimiter, break away.\n+      // TODO: Is this correct?\n+      auto t_id = parser.peek_current_token ()->get_id ();\n+      if (t_id == RIGHT_PAREN || t_id == RIGHT_SQUARE || t_id == RIGHT_CURLY)\n+\tbreak;\n+\n+      // Skip parsing a separator on the first match, otherwise consume it.\n+      // If it isn't present, this is an error\n+      if (rep.has_sep () && match_amount > 0)\n+\tif (!match_token (parser, *rep.get_sep ()))\n+\t  break;\n+\n+      bool valid_current_match = false;\n+      for (auto &match : matches)\n+\t{\n+\t  size_t offs_begin = source.get_offs ();\n+\t  switch (match->get_macro_match_type ())\n+\t    {\n+\t      case AST::MacroMatch::MacroMatchType::Fragment: {\n+\t\tAST::MacroMatchFragment *fragment\n+\t\t  = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t\tvalid_current_match = match_fragment (parser, *fragment);\n+\n+\t\t// matched fragment get the offset in the token stream\n+\t\tsize_t offs_end = source.get_offs ();\n+\n+\t\t// The main difference with match_matcher happens here: Instead\n+\t\t// of inserting a new fragment, we append to one. If that\n+\t\t// fragment does not exist, then the operation is similar to\n+\t\t// `insert_fragment` with the difference that we are not\n+\t\t// creating a metavariable, but a repetition of one, which is\n+\t\t// really different.\n+\t\tsub_stack.append_fragment (\n+\t\t  MatchedFragment (fragment->get_ident (), offs_begin,\n+\t\t\t\t   offs_end));\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Tok: {\n+\t\tAST::Token *tok = static_cast<AST::Token *> (match.get ());\n+\t\tvalid_current_match = match_token (parser, *tok);\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Repetition: {\n+\t\tAST::MacroMatchRepetition *rep\n+\t\t  = static_cast<AST::MacroMatchRepetition *> (match.get ());\n+\t\tvalid_current_match = match_repetition (parser, *rep);\n+\t      }\n+\t      break;\n+\n+\t      case AST::MacroMatch::MacroMatchType::Matcher: {\n+\t\tAST::MacroMatcher *m\n+\t\t  = static_cast<AST::MacroMatcher *> (match.get ());\n+\t\tvalid_current_match = match_matcher (parser, *m);\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+      // If we've encountered an error once, stop trying to match more\n+      // repetitions\n+      if (!valid_current_match)\n+\tbreak;\n+\n+      match_amount++;\n+\n+      // Break early if we notice there's too many expressions already\n+      if (hi_bound && match_amount > hi_bound)\n+\tbreak;\n+    }\n+\n+  // Check if the amount of matches we got is valid: Is it more than the lower\n+  // bound and less than the higher bound?\n+  bool did_meet_lo_bound = match_amount >= lo_bound;\n+  bool did_meet_hi_bound = hi_bound ? match_amount <= hi_bound : true;\n+\n+  // If the end-result is valid, then we can clear the parse errors: Since\n+  // repetitions are parsed eagerly, it is okay to fail in some cases\n+  auto res = did_meet_lo_bound && did_meet_hi_bound;\n+  if (res)\n+    parser.clear_errors ();\n+\n+  return res;\n+}\n+\n+bool\n+MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n+\t\t\t\t AST::MacroMatchRepetition &rep)\n+{\n+  size_t match_amount = 0;\n+  bool res = false;\n+\n+  std::string lo_str;\n+  std::string hi_str;\n+  switch (rep.get_op ())\n+    {\n+    case AST::MacroMatchRepetition::MacroRepOp::ANY:\n+      lo_str = \"0\";\n+      hi_str = \"+inf\";\n+      res = match_n_matches (parser, rep, match_amount);\n+      break;\n+    case AST::MacroMatchRepetition::MacroRepOp::ONE_OR_MORE:\n+      lo_str = \"1\";\n+      hi_str = \"+inf\";\n+      res = match_n_matches (parser, rep, match_amount, 1);\n+      break;\n+    case AST::MacroMatchRepetition::MacroRepOp::ZERO_OR_ONE:\n+      lo_str = \"0\";\n+      hi_str = \"1\";\n+      res = match_n_matches (parser, rep, match_amount, 0, 1);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!res)\n+    rust_error_at (rep.get_match_locus (),\n+\t\t   \"invalid amount of matches for macro invocation. Expected \"\n+\t\t   \"between %s and %s, got %lu\",\n+\t\t   lo_str.c_str (), hi_str.c_str (),\n+\t\t   (unsigned long) match_amount);\n+\n+  rust_debug_loc (rep.get_match_locus (), \"%s matched %lu times\",\n+\t\t  res ? \"successfully\" : \"unsuccessfully\",\n+\t\t  (unsigned long) match_amount);\n+\n+  // We have to handle zero fragments differently: They will not have been\n+  // \"matched\" but they are still valid and should be inserted as a special\n+  // case. So we go through the stack map, and for every fragment which doesn't\n+  // exist, insert a zero-matched fragment.\n+  auto &stack_map = sub_stack.peek ();\n+  for (auto &match : rep.get_matches ())\n+    {\n+      if (match->get_macro_match_type ()\n+\t  == AST::MacroMatch::MacroMatchType::Fragment)\n+\t{\n+\t  auto fragment = static_cast<AST::MacroMatchFragment *> (match.get ());\n+\t  auto it = stack_map.find (fragment->get_ident ());\n+\n+\t  if (it == stack_map.end ())\n+\t    sub_stack.insert_matches (fragment->get_ident (),\n+\t\t\t\t      MatchedFragmentContainer::zero ());\n+\t}\n+    }\n+\n+  return res;\n+}\n+\n+/**\n+ * Helper function to refactor calling a parsing function 0 or more times\n+ */\n+static AST::ASTFragment\n+parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n+\t    std::function<AST::SingleASTNode ()> parse_fn)\n+{\n+  std::vector<AST::SingleASTNode> nodes;\n+  while (true)\n+    {\n+      if (parser.peek_current_token ()->get_id () == delimiter)\n+\tbreak;\n+\n+      auto node = parse_fn ();\n+      nodes.emplace_back (std::move (node));\n+    }\n+\n+  return AST::ASTFragment (std::move (nodes));\n+}\n+\n+/**\n+ * Transcribe 0 or more items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static AST::ASTFragment\n+transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_item (true);\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more external items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static AST::ASTFragment\n+transcribe_many_ext (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_external_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more trait items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static AST::ASTFragment\n+transcribe_many_trait_items (Parser<MacroInvocLexer> &parser,\n+\t\t\t     TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_trait_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more impl items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static AST::ASTFragment\n+transcribe_many_impl_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_inherent_impl_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more trait impl items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static AST::ASTFragment\n+transcribe_many_trait_impl_items (Parser<MacroInvocLexer> &parser,\n+\t\t\t\t  TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_trait_impl_item ();\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more statements from a macro invocation\n+ *\n+ * @param parser Parser to extract statements from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static AST::ASTFragment\n+transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  auto restrictions = ParseRestrictions ();\n+  restrictions.consume_semi = false;\n+\n+  // FIXME: This is invalid! It needs to also handle cases where the macro\n+  // transcriber is an expression, but since the macro call is followed by\n+  // a semicolon, it's a valid ExprStmt\n+  return parse_many (parser, delimiter, [&parser, restrictions] () {\n+    auto stmt = parser.parse_stmt (restrictions);\n+    return AST::SingleASTNode (std::move (stmt));\n+  });\n+}\n+\n+/**\n+ * Transcribe one expression from a macro invocation\n+ *\n+ * @param parser Parser to extract statements from\n+ */\n+static AST::ASTFragment\n+transcribe_expression (Parser<MacroInvocLexer> &parser)\n+{\n+  auto expr = parser.parse_expr ();\n+\n+  return AST::ASTFragment ({std::move (expr)});\n+}\n+\n+/**\n+ * Transcribe one type from a macro invocation\n+ *\n+ * @param parser Parser to extract statements from\n+ */\n+static AST::ASTFragment\n+transcribe_type (Parser<MacroInvocLexer> &parser)\n+{\n+  auto type = parser.parse_type ();\n+\n+  return AST::ASTFragment ({std::move (type)});\n+}\n+\n+static AST::ASTFragment\n+transcribe_on_delimiter (Parser<MacroInvocLexer> &parser, bool semicolon,\n+\t\t\t AST::DelimType delimiter, TokenId last_token_id)\n+{\n+  if (semicolon || delimiter == AST::DelimType::CURLY)\n+    return transcribe_many_stmts (parser, last_token_id);\n+  else\n+    return transcribe_expression (parser);\n+} // namespace Rust\n+\n+static AST::ASTFragment\n+transcribe_context (MacroExpander::ContextType ctx,\n+\t\t    Parser<MacroInvocLexer> &parser, bool semicolon,\n+\t\t    AST::DelimType delimiter, TokenId last_token_id)\n+{\n+  // The flow-chart in order to choose a parsing function is as follows:\n+  //\n+  // [switch special context]\n+  //     -- Item --> parser.parse_item();\n+  //     -- Trait --> parser.parse_trait_item();\n+  //     -- Impl --> parser.parse_impl_item();\n+  //     -- Extern --> parser.parse_extern_item();\n+  //     -- None --> [has semicolon?]\n+  //                 -- Yes --> parser.parse_stmt();\n+  //                 -- No --> [switch invocation.delimiter()]\n+  //                             -- { } --> parser.parse_stmt();\n+  //                             -- _ --> parser.parse_expr(); // once!\n+\n+  // If there is a semicolon OR we are expanding a MacroInvocationSemi, then\n+  // we can parse multiple items. Otherwise, parse *one* expression\n+\n+  switch (ctx)\n+    {\n+    case MacroExpander::ContextType::ITEM:\n+      return transcribe_many_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::TRAIT:\n+      return transcribe_many_trait_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::IMPL:\n+      return transcribe_many_impl_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::TRAIT_IMPL:\n+      return transcribe_many_trait_impl_items (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::EXTERN:\n+      return transcribe_many_ext (parser, last_token_id);\n+      break;\n+    case MacroExpander::ContextType::TYPE:\n+      return transcribe_type (parser);\n+      break;\n+    default:\n+      return transcribe_on_delimiter (parser, semicolon, delimiter,\n+\t\t\t\t      last_token_id);\n+    }\n+}\n+\n+static std::string\n+tokens_to_str (std::vector<std::unique_ptr<AST::Token>> &tokens)\n+{\n+  std::string str;\n+  if (!tokens.empty ())\n+    {\n+      str += tokens[0]->as_string ();\n+      for (size_t i = 1; i < tokens.size (); i++)\n+\tstr += \" \" + tokens[i]->as_string ();\n+    }\n+\n+  return str;\n+}\n+\n+AST::ASTFragment\n+MacroExpander::transcribe_rule (\n+  AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n+  std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n+  bool semicolon, ContextType ctx)\n+{\n+  // we can manipulate the token tree to substitute the dollar identifiers so\n+  // that when we call parse its already substituted for us\n+  AST::MacroTranscriber &transcriber = match_rule.get_transcriber ();\n+  AST::DelimTokenTree &transcribe_tree = transcriber.get_token_tree ();\n+\n+  auto invoc_stream = invoc_token_tree.to_token_stream ();\n+  auto macro_rule_tokens = transcribe_tree.to_token_stream ();\n+\n+  auto substitute_context\n+    = SubstituteCtx (invoc_stream, macro_rule_tokens, matched_fragments);\n+  std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n+    = substitute_context.substitute_tokens ();\n+\n+  rust_debug (\"substituted tokens: %s\",\n+\t      tokens_to_str (substituted_tokens).c_str ());\n+\n+  // parse it to an ASTFragment\n+  MacroInvocLexer lex (std::move (substituted_tokens));\n+  Parser<MacroInvocLexer> parser (lex);\n+\n+  auto last_token_id = TokenId::RIGHT_CURLY;\n+\n+  // this is used so we can check that we delimit the stream correctly.\n+  switch (transcribe_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      last_token_id = TokenId::RIGHT_PAREN;\n+      rust_assert (parser.skip_token (LEFT_PAREN));\n+      break;\n+\n+    case AST::DelimType::CURLY:\n+      rust_assert (parser.skip_token (LEFT_CURLY));\n+      break;\n+\n+    case AST::DelimType::SQUARE:\n+      last_token_id = TokenId::RIGHT_SQUARE;\n+      rust_assert (parser.skip_token (LEFT_SQUARE));\n+      break;\n+    }\n+\n+  // see https://github.com/Rust-GCC/gccrs/issues/22\n+  // TL;DR:\n+  //   - Treat all macro invocations with parentheses, (), or square brackets,\n+  //   [], as expressions.\n+  //   - If the macro invocation has curly brackets, {}, it may be parsed as a\n+  //   statement depending on the context.\n+  //   - If the macro invocation has a semicolon at the end, it must be parsed\n+  //   as a statement (either via ExpressionStatement or\n+  //   MacroInvocationWithSemi)\n+\n+  auto fragment\n+    = transcribe_context (ctx, parser, semicolon,\n+\t\t\t  invoc_token_tree.get_delim_type (), last_token_id);\n+\n+  // emit any errors\n+  if (parser.has_errors ())\n+    {\n+      for (auto &err : parser.get_errors ())\n+\trust_error_at (err.locus, \"%s\", err.message.c_str ());\n+      return AST::ASTFragment::create_error ();\n+    }\n+\n+  // are all the tokens used?\n+  bool did_delimit = parser.skip_token (last_token_id);\n+\n+  bool reached_end_of_stream = did_delimit && parser.skip_token (END_OF_FILE);\n+  if (!reached_end_of_stream)\n+    {\n+      const_TokenPtr current_token = parser.peek_current_token ();\n+      rust_error_at (current_token->get_locus (),\n+\t\t     \"tokens here and after are unparsed\");\n+    }\n+\n+  return fragment;\n+}\n+} // namespace Rust"}, {"sha": "94d6702ecb8de14337304d513c5e54a6b1fc8202", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,366 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MACRO_EXPAND_H\n+#define RUST_MACRO_EXPAND_H\n+\n+#include \"rust-buffered-queue.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-token.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-macro.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-macro-invoc-lexer.h\"\n+\n+// Provides objects and method prototypes for macro expansion\n+\n+namespace Rust {\n+// forward decls for AST\n+namespace AST {\n+class MacroInvocation;\n+}\n+\n+// Object used to store configuration data for macro expansion.\n+// NOTE: Keep all these items complying with the latest rustc.\n+struct ExpansionCfg\n+{\n+  // features?\n+  // TODO: Add `features' when we have it.\n+  unsigned int recursion_limit = 1024;\n+  bool trace_mac = false;   // trace macro\n+  bool should_test = false; // strip #[test] nodes if false\n+  bool keep_macs = false;   // keep macro definitions\n+  std::string crate_name = \"\";\n+};\n+\n+struct MatchedFragment\n+{\n+  std::string fragment_ident;\n+  size_t token_offset_begin;\n+  size_t token_offset_end;\n+\n+  MatchedFragment (std::string identifier, size_t token_offset_begin,\n+\t\t   size_t token_offset_end)\n+    : fragment_ident (identifier), token_offset_begin (token_offset_begin),\n+      token_offset_end (token_offset_end)\n+  {}\n+\n+  /**\n+   * Empty constructor for uninitialized fragments\n+   */\n+  MatchedFragment () : MatchedFragment (\"\", 0, 0) {}\n+\n+  std::string as_string () const\n+  {\n+    return fragment_ident + \"=\" + std::to_string (token_offset_begin) + \":\"\n+\t   + std::to_string (token_offset_end);\n+  }\n+};\n+\n+class MatchedFragmentContainer\n+{\n+public:\n+  // Does the container refer to a simple metavariable, different from a\n+  // repetition repeated once\n+  enum class Kind\n+  {\n+    MetaVar,\n+    Repetition,\n+  };\n+\n+  MatchedFragmentContainer (std::vector<MatchedFragment> fragments,\n+\t\t\t    Kind kind = Kind::Repetition)\n+    : fragments (fragments), kind (kind)\n+  {}\n+\n+  /**\n+   * Create a valid fragment matched zero times. This is useful for repetitions\n+   * which allow the absence of a fragment, such as * and ?\n+   */\n+  static MatchedFragmentContainer zero ()\n+  {\n+    return MatchedFragmentContainer ({});\n+  }\n+\n+  /**\n+   * Create a valid fragment matched one time\n+   */\n+  static MatchedFragmentContainer metavar (MatchedFragment fragment)\n+  {\n+    return MatchedFragmentContainer ({fragment}, Kind::MetaVar);\n+  }\n+\n+  /**\n+   * Add a matched fragment to the container\n+   */\n+  void add_fragment (MatchedFragment fragment)\n+  {\n+    rust_assert (!is_single_fragment ());\n+\n+    fragments.emplace_back (fragment);\n+  }\n+\n+  size_t get_match_amount () const { return fragments.size (); }\n+  const std::vector<MatchedFragment> &get_fragments () const\n+  {\n+    return fragments;\n+  }\n+  // const std::string &get_fragment_name () const { return fragment_name; }\n+\n+  bool is_single_fragment () const\n+  {\n+    return get_match_amount () == 1 && kind == Kind::MetaVar;\n+  }\n+\n+  const MatchedFragment get_single_fragment () const\n+  {\n+    rust_assert (is_single_fragment ());\n+\n+    return fragments[0];\n+  }\n+\n+  const Kind &get_kind () const { return kind; }\n+\n+private:\n+  /**\n+   * Fragments matched `match_amount` times. This can be an empty vector\n+   * in case having zero matches is allowed (i.e ? or * operators)\n+   */\n+  std::vector<MatchedFragment> fragments;\n+  Kind kind;\n+};\n+\n+class SubstitutionScope\n+{\n+public:\n+  SubstitutionScope () : stack () {}\n+\n+  void push () { stack.push_back ({}); }\n+\n+  std::map<std::string, MatchedFragmentContainer> pop ()\n+  {\n+    auto top = stack.back ();\n+    stack.pop_back ();\n+    return top;\n+  }\n+\n+  std::map<std::string, MatchedFragmentContainer> &peek ()\n+  {\n+    return stack.back ();\n+  }\n+\n+  /**\n+   * Insert a new matched metavar into the current substitution map\n+   */\n+  void insert_metavar (MatchedFragment fragment)\n+  {\n+    auto &current_map = stack.back ();\n+    auto it = current_map.find (fragment.fragment_ident);\n+\n+    if (it == current_map.end ())\n+      current_map.insert ({fragment.fragment_ident,\n+\t\t\t   MatchedFragmentContainer::metavar (fragment)});\n+    else\n+      gcc_unreachable ();\n+  }\n+\n+  /**\n+   * Append a new matched fragment to a repetition into the current substitution\n+   * map\n+   */\n+  void append_fragment (MatchedFragment fragment)\n+  {\n+    auto &current_map = stack.back ();\n+    auto it = current_map.find (fragment.fragment_ident);\n+\n+    if (it == current_map.end ())\n+      current_map.insert (\n+\t{fragment.fragment_ident, MatchedFragmentContainer ({fragment})});\n+    else\n+      it->second.add_fragment (fragment);\n+  }\n+\n+  void insert_matches (std::string key, MatchedFragmentContainer matches)\n+  {\n+    auto &current_map = stack.back ();\n+    auto it = current_map.find (key);\n+    rust_assert (it == current_map.end ());\n+\n+    current_map.insert ({key, matches});\n+  }\n+\n+private:\n+  std::vector<std::map<std::string, MatchedFragmentContainer>> stack;\n+};\n+\n+// Object used to store shared data (between functions) for macro expansion.\n+struct MacroExpander\n+{\n+  enum ContextType\n+  {\n+    ITEM,\n+    BLOCK,\n+    EXTERN,\n+    TYPE,\n+    TRAIT,\n+    IMPL,\n+    TRAIT_IMPL,\n+  };\n+\n+  ExpansionCfg cfg;\n+  unsigned int expansion_depth = 0;\n+\n+  MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n+    : cfg (cfg), crate (crate), session (session),\n+      sub_stack (SubstitutionScope ()),\n+      expanded_fragment (AST::ASTFragment::create_error ()),\n+      resolver (Resolver::Resolver::get ()),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  ~MacroExpander () = default;\n+\n+  // Expands all macros in the crate passed in.\n+  void expand_crate ();\n+\n+  /* Expands a macro invocation - possibly make both\n+   * have similar duck-typed interface and use templates?*/\n+  // should this be public or private?\n+  void expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon);\n+\n+  // Expands a single declarative macro.\n+  AST::ASTFragment expand_decl_macro (Location locus,\n+\t\t\t\t      AST::MacroInvocData &invoc,\n+\t\t\t\t      AST::MacroRulesDefinition &rules_def,\n+\t\t\t\t      bool semicolon);\n+\n+  void expand_cfg_attrs (AST::AttrVec &attrs);\n+  bool fails_cfg (const AST::AttrVec &attr) const;\n+  bool fails_cfg_with_expand (AST::AttrVec &attrs) const;\n+\n+  bool depth_exceeds_recursion_limit () const;\n+\n+  bool try_match_rule (AST::MacroRule &match_rule,\n+\t\t       AST::DelimTokenTree &invoc_token_tree);\n+\n+  AST::ASTFragment transcribe_rule (\n+    AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n+    std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n+    bool semicolon, ContextType ctx);\n+\n+  bool match_fragment (Parser<MacroInvocLexer> &parser,\n+\t\t       AST::MacroMatchFragment &fragment);\n+\n+  bool match_token (Parser<MacroInvocLexer> &parser, AST::Token &token);\n+\n+  bool match_repetition (Parser<MacroInvocLexer> &parser,\n+\t\t\t AST::MacroMatchRepetition &rep);\n+\n+  bool match_matcher (Parser<MacroInvocLexer> &parser,\n+\t\t      AST::MacroMatcher &matcher);\n+\n+  /**\n+   * Match any amount of matches\n+   *\n+   * @param parser Parser to use for matching\n+   * @param rep Repetition to try and match\n+   * @param match_amount Reference in which to store the ammount of succesful\n+   * and valid matches\n+   *\n+   * @param lo_bound Lower bound of the matcher. When specified, the matcher\n+   * will only succeed if it parses at *least* `lo_bound` fragments. If\n+   * unspecified, the matcher could succeed when parsing 0 fragments.\n+   *\n+   * @param hi_bound Higher bound of the matcher. When specified, the matcher\n+   * will only succeed if it parses *less than* `hi_bound` fragments. If\n+   * unspecified, the matcher could succeed when parsing an infinity of\n+   * fragments.\n+   *\n+   * @return true if matching was successful and within the given limits, false\n+   * otherwise\n+   */\n+  bool match_n_matches (Parser<MacroInvocLexer> &parser,\n+\t\t\tAST::MacroMatchRepetition &rep, size_t &match_amount,\n+\t\t\tsize_t lo_bound = 0, size_t hi_bound = 0);\n+\n+  void push_context (ContextType t) { context.push_back (t); }\n+\n+  ContextType pop_context ()\n+  {\n+    rust_assert (!context.empty ());\n+\n+    ContextType t = context.back ();\n+    context.pop_back ();\n+\n+    return t;\n+  }\n+\n+  ContextType peek_context () { return context.back (); }\n+\n+  void set_expanded_fragment (AST::ASTFragment &&fragment)\n+  {\n+    expanded_fragment = std::move (fragment);\n+  }\n+\n+  AST::ASTFragment take_expanded_fragment (AST::ASTVisitor &vis)\n+  {\n+    AST::ASTFragment old_fragment = std::move (expanded_fragment);\n+    auto accumulator = std::vector<AST::SingleASTNode> ();\n+    expanded_fragment = AST::ASTFragment::create_error ();\n+\n+    for (auto &node : old_fragment.get_nodes ())\n+      {\n+\texpansion_depth++;\n+\tnode.accept_vis (vis);\n+\t// we'll decide the next move according to the outcome of the macro\n+\t// expansion\n+\tif (expanded_fragment.is_error ())\n+\t  accumulator.push_back (node); // if expansion fails, there might be a\n+\t\t\t\t\t// non-macro expression we need to keep\n+\telse\n+\t  {\n+\t    // if expansion succeeded, then we need to merge the fragment with\n+\t    // the contents in the accumulator, so that our final expansion\n+\t    // result will contain non-macro nodes as it should\n+\t    auto new_nodes = expanded_fragment.get_nodes ();\n+\t    std::move (new_nodes.begin (), new_nodes.end (),\n+\t\t       std::back_inserter (accumulator));\n+\t    expanded_fragment = AST::ASTFragment (accumulator);\n+\t  }\n+\texpansion_depth--;\n+      }\n+\n+    return old_fragment;\n+  }\n+\n+private:\n+  AST::Crate &crate;\n+  Session &session;\n+  SubstitutionScope sub_stack;\n+  std::vector<ContextType> context;\n+  AST::ASTFragment expanded_fragment;\n+\n+public:\n+  Resolver::Resolver *resolver;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Rust\n+\n+#endif"}, {"sha": "8a43d29e0d123440b4e9314d7030b278e6633fd6", "filename": "gcc/rust/expand/rust-macro-invoc-lexer.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-invoc-lexer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-invoc-lexer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-invoc-lexer.cc?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,29 @@\n+#include \"rust-macro-invoc-lexer.h\"\n+\n+namespace Rust {\n+\n+const_TokenPtr\n+MacroInvocLexer::peek_token (int n)\n+{\n+  if ((offs + n) >= token_stream.size ())\n+    return Token::make (END_OF_FILE, Location ());\n+\n+  return token_stream.at (offs + n)->get_tok_ptr ();\n+}\n+\n+// Advances current token to n + 1 tokens ahead of current position.\n+void\n+MacroInvocLexer::skip_token (int n)\n+{\n+  offs += (n + 1);\n+}\n+\n+void\n+MacroInvocLexer::split_current_token (TokenId new_left __attribute__ ((unused)),\n+\t\t\t\t      TokenId new_right\n+\t\t\t\t      __attribute__ ((unused)))\n+{\n+  // FIXME\n+  gcc_unreachable ();\n+}\n+} // namespace Rust"}, {"sha": "0fd4554d02f6d66eddac420c95636dcfe7289229", "filename": "gcc/rust/expand/rust-macro-invoc-lexer.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-invoc-lexer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-invoc-lexer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-invoc-lexer.h?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MACRO_INVOC_LEXER_H\n+#define RUST_MACRO_INVOC_LEXER_H\n+\n+#include \"rust-ast.h\"\n+\n+namespace Rust {\n+class MacroInvocLexer\n+{\n+public:\n+  MacroInvocLexer (std::vector<std::unique_ptr<AST::Token>> stream)\n+    : offs (0), token_stream (std::move (stream))\n+  {}\n+\n+  // Returns token n tokens ahead of current position.\n+  const_TokenPtr peek_token (int n);\n+\n+  // Peeks the current token.\n+  const_TokenPtr peek_token () { return peek_token (0); }\n+\n+  // Advances current token to n + 1 tokens ahead of current position.\n+  void skip_token (int n);\n+\n+  // Skips the current token.\n+  void skip_token () { skip_token (0); }\n+\n+  // Splits the current token into two. Intended for use with nested generics\n+  // closes (i.e. T<U<X>> where >> is wrongly lexed as one token). Note that\n+  // this will only work with \"simple\" tokens like punctuation.\n+  void split_current_token (TokenId new_left, TokenId new_right);\n+\n+  std::string get_filename () const\n+  {\n+    // FIXME\n+    gcc_unreachable ();\n+    return \"FIXME\";\n+  }\n+\n+  size_t get_offs () const { return offs; }\n+\n+private:\n+  size_t offs;\n+  std::vector<std::unique_ptr<AST::Token>> token_stream;\n+};\n+} // namespace Rust\n+\n+#endif // RUST_MACRO_INVOC_LEXER_H"}, {"sha": "9592d2d2a9e178469949dacede177c539e854567", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.cc", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,312 @@\n+#include \"rust-macro-substitute-ctx.h\"\n+\n+namespace Rust {\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+SubstituteCtx::substitute_metavar (std::unique_ptr<AST::Token> &metavar)\n+{\n+  auto metavar_name = metavar->get_str ();\n+\n+  std::vector<std::unique_ptr<AST::Token>> expanded;\n+  auto it = fragments.find (metavar_name);\n+  if (it == fragments.end ())\n+    {\n+      // Return a copy of the original token\n+      expanded.push_back (metavar->clone_token ());\n+    }\n+  else\n+    {\n+      // If we are expanding a metavar which has a lof of matches, we are\n+      // currently expanding a repetition metavar - not a simple metavar. We\n+      // need to error out and inform the user.\n+      // Associated test case for an example: compile/macro-issue1224.rs\n+      if (it->second.get_match_amount () != 1)\n+\t{\n+\t  rust_error_at (metavar->get_locus (),\n+\t\t\t \"metavariable is still repeating at this depth\");\n+\t  rust_inform (\n+\t    metavar->get_locus (),\n+\t    \"you probably forgot the repetition operator: %<%s%s%s%>\", \"$(\",\n+\t    metavar->as_string ().c_str (), \")*\");\n+\t  return expanded;\n+\t}\n+\n+      // We only care about the vector when expanding repetitions.\n+      // Just access the first element of the vector.\n+      auto &frag = it->second.get_single_fragment ();\n+      for (size_t offs = frag.token_offset_begin; offs < frag.token_offset_end;\n+\t   offs++)\n+\t{\n+\t  auto &tok = input.at (offs);\n+\t  expanded.push_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return expanded;\n+}\n+\n+bool\n+SubstituteCtx::check_repetition_amount (size_t pattern_start,\n+\t\t\t\t\tsize_t pattern_end,\n+\t\t\t\t\tsize_t &expected_repetition_amount)\n+{\n+  bool first_fragment_found = false;\n+  bool is_valid = true;\n+\n+  for (size_t i = pattern_start; i < pattern_end; i++)\n+    {\n+      if (macro.at (i)->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  auto &frag_token = macro.at (i + 1);\n+\t  if (frag_token->get_id () == IDENTIFIER)\n+\t    {\n+\t      auto it = fragments.find (frag_token->get_str ());\n+\t      if (it == fragments.end ())\n+\t\t{\n+\t\t  // If the repetition is not anything we know (ie no declared\n+\t\t  // metavars, or metavars which aren't present in the\n+\t\t  // fragment), we can just error out. No need to paste the\n+\t\t  // tokens as if nothing had happened.\n+\t\t  rust_error_at (frag_token->get_locus (),\n+\t\t\t\t \"metavar %s used in repetition does not exist\",\n+\t\t\t\t frag_token->get_str ().c_str ());\n+\n+\t\t  is_valid = false;\n+\t\t}\n+\n+\t      auto &fragment = it->second;\n+\n+\t      size_t repeat_amount = fragment.get_match_amount ();\n+\t      if (!first_fragment_found)\n+\t\t{\n+\t\t  first_fragment_found = true;\n+\t\t  expected_repetition_amount = repeat_amount;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (repeat_amount != expected_repetition_amount\n+\t\t      && !fragment.is_single_fragment ())\n+\t\t    {\n+\t\t      rust_error_at (\n+\t\t\tfrag_token->get_locus (),\n+\t\t\t\"different amount of matches used in merged \"\n+\t\t\t\"repetitions: expected %lu, got %lu\",\n+\t\t\t(unsigned long) expected_repetition_amount,\n+\t\t\t(unsigned long) repeat_amount);\n+\t\t      is_valid = false;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return is_valid;\n+}\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+SubstituteCtx::substitute_repetition (\n+  size_t pattern_start, size_t pattern_end,\n+  std::unique_ptr<AST::Token> separator_token)\n+{\n+  rust_assert (pattern_end < macro.size ());\n+\n+  size_t repeat_amount = 0;\n+  if (!check_repetition_amount (pattern_start, pattern_end, repeat_amount))\n+    return {};\n+\n+  rust_debug (\"repetition amount to use: %lu\", (unsigned long) repeat_amount);\n+  std::vector<std::unique_ptr<AST::Token>> expanded;\n+  std::vector<std::unique_ptr<AST::Token>> new_macro;\n+\n+  // We want to generate a \"new macro\" to substitute with. This new macro\n+  // should contain only the tokens inside the pattern\n+  for (size_t tok_idx = pattern_start; tok_idx < pattern_end; tok_idx++)\n+    new_macro.emplace_back (macro.at (tok_idx)->clone_token ());\n+\n+  // Then, we want to create a subset of the matches so that\n+  // `substitute_tokens()` can only see one fragment per metavar. Let's say we\n+  // have the following user input: (1 145 'h')\n+  // on the following match arm: ($($lit:literal)*)\n+  // which causes the following matches: { \"lit\": [1, 145, 'h'] }\n+  //\n+  // The pattern (new_macro) is `$lit:literal`\n+  // The first time we expand it, we want $lit to have the following token: 1\n+  // The second time, 145\n+  // The third and final time, 'h'\n+  //\n+  // In order to do so we must create \"sub maps\", which only contain parts of\n+  // the original matches\n+  // sub-maps: [ { \"lit\": 1 }, { \"lit\": 145 }, { \"lit\": 'h' } ]\n+  //\n+  // and give them to `substitute_tokens` one by one.\n+\n+  for (size_t i = 0; i < repeat_amount; i++)\n+    {\n+      std::map<std::string, MatchedFragmentContainer> sub_map;\n+      for (auto &kv_match : fragments)\n+\t{\n+\t  MatchedFragment sub_fragment;\n+\n+\t  // FIXME: Hack: If a fragment is not repeated, how does it fit in the\n+\t  // submap? Do we really want to expand it? Is this normal behavior?\n+\t  if (kv_match.second.is_single_fragment ())\n+\t    sub_fragment = kv_match.second.get_single_fragment ();\n+\t  else\n+\t    sub_fragment = kv_match.second.get_fragments ()[i];\n+\n+\t  sub_map.insert (\n+\t    {kv_match.first, MatchedFragmentContainer::metavar (sub_fragment)});\n+\t}\n+\n+      auto substitute_context = SubstituteCtx (input, new_macro, sub_map);\n+      auto new_tokens = substitute_context.substitute_tokens ();\n+\n+      // Skip the first repetition, but add the separator to the expanded\n+      // tokens if it is present\n+      if (i != 0 && separator_token)\n+\texpanded.emplace_back (separator_token->clone_token ());\n+\n+      for (auto &new_token : new_tokens)\n+\texpanded.emplace_back (new_token->clone_token ());\n+    }\n+\n+  // FIXME: We also need to make sure that all subsequent fragments\n+  // contain the same amount of repetitions as the first one\n+\n+  return expanded;\n+}\n+\n+static bool\n+is_rep_op (std::unique_ptr<AST::Token> &tok)\n+{\n+  auto id = tok->get_id ();\n+  return id == QUESTION_MARK || id == ASTERISK || id == PLUS;\n+}\n+\n+std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n+SubstituteCtx::substitute_token (size_t token_idx)\n+{\n+  auto &token = macro.at (token_idx);\n+  switch (token->get_id ())\n+    {\n+    case IDENTIFIER:\n+      rust_debug (\"expanding metavar: %s\", token->get_str ().c_str ());\n+      return {substitute_metavar (token), 1};\n+      case LEFT_PAREN: {\n+\t// We need to parse up until the closing delimiter and expand this\n+\t// fragment->n times.\n+\trust_debug (\"expanding repetition\");\n+\n+\t// We're in a context where macro repetitions have already been\n+\t// parsed and validated: This means that\n+\t// 1/ There will be no delimiters as that is an error\n+\t// 2/ There are no fragment specifiers anymore, which prevents us\n+\t// from reusing parser functions.\n+\t//\n+\t// Repetition patterns are also special in that they cannot contain\n+\t// \"rogue\" delimiters: For example, this is invalid, as they are\n+\t// parsed as MacroMatches and must contain a correct amount of\n+\t// delimiters.\n+\t// `$($e:expr ) )`\n+\t//            ^ rogue closing parenthesis\n+\t//\n+\t// With all of that in mind, we can simply skip ahead from one\n+\t// parenthesis to the other to find the pattern to expand. Of course,\n+\t// pairs of delimiters, including parentheses, are allowed.\n+\t// `$($e:expr ( ) )`\n+\t// Parentheses are the sole delimiter for which we need a special\n+\t// behavior since they delimit the repetition pattern\n+\n+\tsize_t pattern_start = token_idx + 1;\n+\tsize_t pattern_end = pattern_start;\n+\tauto parentheses_stack = 0;\n+\tfor (size_t idx = pattern_start; idx < macro.size (); idx++)\n+\t  {\n+\t    if (macro.at (idx)->get_id () == LEFT_PAREN)\n+\t      {\n+\t\tparentheses_stack++;\n+\t      }\n+\t    else if (macro.at (idx)->get_id () == RIGHT_PAREN)\n+\t      {\n+\t\tif (parentheses_stack == 0)\n+\t\t  {\n+\t\t    pattern_end = idx;\n+\t\t    break;\n+\t\t  }\n+\t\tparentheses_stack--;\n+\t      }\n+\t  }\n+\n+\t// Unreachable case, but let's make sure we don't ever run into it\n+\trust_assert (pattern_end != pattern_start);\n+\n+\tstd::unique_ptr<AST::Token> separator_token = nullptr;\n+\tif (pattern_end + 1 <= macro.size ())\n+\t  {\n+\t    auto &post_pattern_token = macro.at (pattern_end + 1);\n+\t    if (!is_rep_op (post_pattern_token))\n+\t      separator_token = post_pattern_token->clone_token ();\n+\t  }\n+\n+\t// Amount of tokens to skip\n+\tauto to_skip = 0;\n+\t// Parentheses\n+\tto_skip += 2;\n+\t// Repetition operator\n+\tto_skip += 1;\n+\t// Separator\n+\tif (separator_token)\n+\t  to_skip += 1;\n+\n+\treturn {substitute_repetition (pattern_start, pattern_end,\n+\t\t\t\t       std::move (separator_token)),\n+\t\tpattern_end - pattern_start + to_skip};\n+      }\n+      // TODO: We need to check if the $ was alone. In that case, do\n+      // not error out: Simply act as if there was an empty identifier\n+      // with no associated fragment and paste the dollar sign in the\n+      // transcription. Unsure how to do that since we always have at\n+      // least the closing curly brace after an empty $...\n+    default:\n+      rust_error_at (token->get_locus (),\n+\t\t     \"unexpected token in macro transcribe: expected \"\n+\t\t     \"%<(%> or identifier after %<$%>, got %<%s%>\",\n+\t\t     get_token_description (token->get_id ()));\n+    }\n+\n+  // FIXME: gcc_unreachable() error case?\n+  return {std::vector<std::unique_ptr<AST::Token>> (), 0};\n+}\n+\n+std::vector<std::unique_ptr<AST::Token>>\n+SubstituteCtx::substitute_tokens ()\n+{\n+  std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n+  rust_debug (\"expanding tokens\");\n+\n+  for (size_t i = 0; i < macro.size (); i++)\n+    {\n+      auto &tok = macro.at (i);\n+      if (tok->get_id () == DOLLAR_SIGN)\n+\t{\n+\t  // Aaaaah, if only we had C++17 :)\n+\t  // auto [expanded, tok_to_skip] = ...\n+\t  auto p = substitute_token (i + 1);\n+\t  auto expanded = std::move (p.first);\n+\t  auto tok_to_skip = p.second;\n+\n+\t  i += tok_to_skip;\n+\n+\t  for (auto &token : expanded)\n+\t    replaced_tokens.emplace_back (token->clone_token ());\n+\t}\n+      else\n+\t{\n+\t  replaced_tokens.emplace_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return replaced_tokens;\n+}\n+\n+} // namespace Rust"}, {"sha": "81dcab7643bee56df4b469e7966f24335d99afa2", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.h", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1841081a8a306c1a220694a5ddb3a927cb4b2db3/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h?ref=1841081a8a306c1a220694a5ddb3a927cb4b2db3", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast.h\"\n+#include \"rust-macro-expand.h\"\n+\n+namespace Rust {\n+class SubstituteCtx\n+{\n+  std::vector<std::unique_ptr<AST::Token>> &input;\n+  std::vector<std::unique_ptr<AST::Token>> &macro;\n+  std::map<std::string, MatchedFragmentContainer> &fragments;\n+\n+  /**\n+   * Find the repetition amount to use when expanding a repetition, and\n+   * check that all fragments used respect that repetition amount\n+   *\n+   * @param pattern_start Start of the repetition pattern\n+   * @param pattern_end End of the repetition pattern\n+   * @param repeat_amount Reference to fill with the matched repetition amount\n+   */\n+  bool check_repetition_amount (size_t pattern_start, size_t pattern_end,\n+\t\t\t\tsize_t &repeat_amount);\n+\n+public:\n+  SubstituteCtx (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t std::vector<std::unique_ptr<AST::Token>> &macro,\n+\t\t std::map<std::string, MatchedFragmentContainer> &fragments)\n+    : input (input), macro (macro), fragments (fragments)\n+  {}\n+\n+  /**\n+   * Substitute a metavariable by its given fragment in a transcribing context,\n+   * i.e. replacing $var with the associated fragment.\n+   *\n+   * @param metavar Metavariable to try and replace\n+   *\n+   * @return A token containing the associated fragment expanded into tokens if\n+   * any, or the cloned token if no fragment was associated\n+   */\n+  std::vector<std::unique_ptr<AST::Token>>\n+  substitute_metavar (std::unique_ptr<AST::Token> &metavar);\n+\n+  /**\n+   * Substitute a macro repetition by its given fragments\n+   *\n+   * @param pattern_start Start index of the pattern tokens\n+   * @param pattern_end End index of the patterns tokens\n+   * @param separator Optional separator to include when expanding tokens\n+   *\n+   * @return A vector containing the repeated pattern\n+   */\n+  std::vector<std::unique_ptr<AST::Token>>\n+  substitute_repetition (size_t pattern_start, size_t pattern_end,\n+\t\t\t std::unique_ptr<AST::Token> separator);\n+\n+  /**\n+   * Substitute a given token by its appropriate representation\n+   *\n+   * @param token_idx Current token to try and substitute\n+   *\n+   * @return A token containing the associated fragment expanded into tokens if\n+   * any, or the cloned token if no fragment was associated, as well as the\n+   * amount of tokens that should be skipped before the next invocation. Since\n+   * this function may consume more than just one token, it is important to skip\n+   * ahead of the input to avoid mis-substitutions\n+   */\n+  std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n+  substitute_token (size_t token_idx);\n+\n+  /**\n+   * Substitute all tokens by their appropriate representation\n+   *\n+   * @return A vector containing the substituted tokens\n+   */\n+  std::vector<std::unique_ptr<AST::Token>> substitute_tokens ();\n+};\n+} // namespace Rust"}]}