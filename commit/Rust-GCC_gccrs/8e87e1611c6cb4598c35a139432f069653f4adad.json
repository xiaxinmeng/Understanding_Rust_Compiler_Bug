{"sha": "8e87e1611c6cb4598c35a139432f069653f4adad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4N2UxNjExYzZjYjQ1OThjMzVhMTM5NDMyZjA2OTY1M2Y0YWRhZA==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-07-22T06:12:36Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-07-22T06:12:36Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r7790", "tree": {"sha": "cbb78b1f748750e605d5ef7a47adfc651d01d7e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbb78b1f748750e605d5ef7a47adfc651d01d7e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e87e1611c6cb4598c35a139432f069653f4adad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e87e1611c6cb4598c35a139432f069653f4adad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e87e1611c6cb4598c35a139432f069653f4adad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e87e1611c6cb4598c35a139432f069653f4adad/comments", "author": null, "committer": null, "parents": [{"sha": "b1cf6cee09c39a28dc9a48c8a9c75e87c8eb09fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cf6cee09c39a28dc9a48c8a9c75e87c8eb09fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1cf6cee09c39a28dc9a48c8a9c75e87c8eb09fb"}], "stats": {"total": 717, "additions": 454, "deletions": 263}, "files": [{"sha": "28d0d4b5e693d237ee290524e0ec162754b62fa6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 219, "deletions": 144, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e87e1611c6cb4598c35a139432f069653f4adad/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e87e1611c6cb4598c35a139432f069653f4adad/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8e87e1611c6cb4598c35a139432f069653f4adad", "patch": "@@ -65,12 +65,12 @@ rtx sh_compare_op1;\n \n int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n {\n-  R0_REGS,      GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  R0_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n-  GENERAL_REGS, PR_REGS,      T_REGS,       NO_REGS, \n-  MAC_REGS,     MAC_REGS,\n+  GENERAL_REGS, PR_REGS, T_REGS, NO_REGS,\n+  MAC_REGS, MAC_REGS,\n };\n \n /* Provide reg_class from a letter such as appears in the machine\n@@ -104,12 +104,12 @@ enum reg_class reg_class_from_letter[] =\n \n int hard_regno_mode_ok[] =\n {\n-  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n-  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n-  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n-  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n-  REG,         0,        SI_ONLY,    SI_ONLY,\n-  SI_ONLY,    SI_ONLY\n+  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n+  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n+  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n+  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n+  REG, 0, SI_ONLY, SI_ONLY,\n+  SI_ONLY, SI_ONLY\n };\n \n /* Local label counter, used for constants in the pool and inside\n@@ -120,9 +120,9 @@ static int lf = 100;\n /* Number of bytes pushed for anonymous args, used to pass information\n    between expand_prologue and expand_epilogue. */\n static int extra_push;\n-\n \f\n \n+\n void\n push (rn)\n      int rn;\n@@ -132,6 +132,7 @@ push (rn)\n \n void\n pop (rn)\n+     int rn;\n {\n   emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n }\n@@ -299,7 +300,6 @@ print_operand_address (stream, x)\n \n \t  default:\n \t    debug_rtx (x);\n-\n \t    abort ();\n \t  }\n       }\n@@ -354,9 +354,9 @@ print_operand (stream, x, code)\n       break;\n     case '@':\n       if (pragma_interrupt)\n-\tfprintf (stream,\"rte\");\n+\tfprintf (stream, \"rte\");\n       else\n-\tfprintf (stream,\"rts\");\n+\tfprintf (stream, \"rts\");\n       break;\n     case '#':\n       /* Output a nop if there's nothing in the delay slot */\n@@ -405,7 +405,9 @@ print_operand (stream, x, code)\n }\n \f\n \n+static int\n sextb (x)\n+  int x;\n {\n   x &= 0xff;\n   if (x > 127)\n@@ -420,7 +422,7 @@ sextb (x)\n /* Take a move with integer constant source in OPERANDS, see if it can be generated by\n    devious shifting.  If so, generate the instruction sequence and return 1, otherwise\n    return 0.\n-   \n+\n     OPERANDS[0] Destination register\n     OPERANDS[1] Source constant\n \n@@ -442,7 +444,7 @@ sextb (x)\n    00000000 00000000 11111111 1NNNNNNNN load and zero extend word\n \n \n-*/   \n+*/\n \n static int\n synth_constant (operands, mode)\n@@ -452,19 +454,19 @@ synth_constant (operands, mode)\n   rtx dst;\n   int i = INTVAL (operands[1]) & 0xffffffff;\n \n-  if (CONST_OK_FOR_I (i)) \n+  if (CONST_OK_FOR_I (i))\n     return 0;\n \n   if (TARGET_CLEN0 && mode != QImode)\n     return 0;\n \n   if (mode != SImode)\n     {\n-      if (reload_in_progress) \n+      if (reload_in_progress)\n \treturn 0;\n       dst = gen_reg_rtx (SImode);\n     }\n-  else \n+  else\n     {\n       dst = operands[0];\n     }\n@@ -592,10 +594,8 @@ expand_block_move (operands)\n     }\n   if (mode == SImode && constp && (bytes % 4 == 0))\n     {\n-      char entry[30];\n       tree entry_name;\n       rtx func_addr_rtx;\n-      int groups;\n       rtx r4 = gen_rtx (REG, SImode, 4);\n       rtx r5 = gen_rtx (REG, SImode, 5);\n       rtx r6 = gen_rtx (REG, SImode, 6);\n@@ -670,7 +670,7 @@ prepare_move_operands (operands, mode)\n       /* copy the source to a register */\n       operands[1] = copy_to_mode_reg (mode, operands[1]);\n     }\n-  if ((mode == DImode || mode == SImode || mode == HImode || mode == QImode) \n+  if ((mode == DImode || mode == SImode || mode == HImode || mode == QImode)\n       && GET_CODE (operands[1]) == CONST_INT)\n     {\n       return synth_constant (operands, mode);\n@@ -740,6 +740,7 @@ prepare_move_operands (operands, mode)\n    compare has been done.  */\n rtx\n prepare_scc_operands (code)\n+     int code;\n {\n   if (GET_CODE (sh_compare_op0) != REG\n       || REGNO (sh_compare_op0) != T_REG)\n@@ -863,6 +864,10 @@ output_movedouble (insn, operands, mode)\n \t{\n \t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%R0\";\n \t}\n+      else if (GET_CODE (inside) == POST_INC)\n+\t{\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%R0 !mdi\\n\";\n+\t}\n       else\n \tabort ();\n \n@@ -1022,11 +1027,6 @@ output_far_jump (insn, op)\n {\n   rtx thislab = gen_label_rtx ();\n \n-  /* See if we can grab a reg from the prev insn */\n-  rtx gotone = 0;\n-  rtx prev = PREV_INSN (insn);\n-  rtx link;\n-\n   if (dbr_sequence_length ())\n     {\n       /* Something to go in what would have been the delay\n@@ -1041,7 +1041,8 @@ output_far_jump (insn, op)\n       for (i = 0; i < 8; i++)\n \t{\n \t  vec[1] = gen_rtx (REG, SImode, i);\n-\t  if (!reg_referenced_p (vec[1], PATTERN (XVECEXP (final_sequence, 0, 1))))\n+\t  if (!reg_referenced_p (vec[1],\n+\t\t\t\t PATTERN (XVECEXP (final_sequence, 0, 1))))\n \t    break;\n \t}\n \n@@ -1072,9 +1073,8 @@ output_branch (logic, insn)\n {\n   extern rtx recog_operand[];\n   int label = lf++;\n-  int rn = -1;\n-  int need_save;\n-/*  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);*/\n+\n+  /*  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);*/\n \n   switch (get_attr_length (insn))\n     {\n@@ -1245,7 +1245,7 @@ add_constant (x, mode)\n \n /* Dump out interesting debug info */\n \n-rtx\n+void\n final_prescan_insn (insn, opvec, noperands)\n      rtx insn;\n      rtx *opvec;\n@@ -1258,9 +1258,9 @@ final_prescan_insn (insn, opvec, noperands)\n \t       insn_addresses[INSN_UID (insn)]);\n     }\n }\n+\f\n \n \n-\f\n \n /* Stuff taken from m88k.c */\n \n@@ -1365,7 +1365,7 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n   data_section ();\n \n \n-  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) (release D-1) arguments:\", version_string);\n+  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) (release E-2) arguments:\", version_string);\n   output_options (file, f_options, f_len, W_options, W_len,\n \t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n }\n@@ -1393,7 +1393,7 @@ shiftcosts (RTX)\n   return 1;\n }\n \n-int \n+int\n andcosts (RTX)\n      rtx RTX;\n {\n@@ -1410,28 +1410,33 @@ andcosts (RTX)\n   return 5;\n }\n \n-int howshift (i)\n-int i;\n+int \n+howshift (i)\n+     int i;\n {\n   int total = 0;\n   while (i > 0)\n     {\n-      if (i >= 16) {\n-\ttotal++;\n-\ti -= 16;\n-      }\n-      else if (i >= 8) {\n-\ttotal++;\n-\ti -= 8;\n-      }\n-      else if (i >= 2) {\n-\ttotal++;\n-\ti -= 2;\n-      }\n-      else if (i>=1) {\n-\ttotal++;\n-\ti--;\n-      }\n+      if (i >= 16)\n+\t{\n+\t  total++;\n+\t  i -= 16;\n+\t}\n+      else if (i >= 8)\n+\t{\n+\t  total++;\n+\t  i -= 8;\n+\t}\n+      else if (i >= 2)\n+\t{\n+\t  total++;\n+\t  i -= 2;\n+\t}\n+      else if (i >= 1)\n+\t{\n+\t  total++;\n+\t  i--;\n+\t}\n     }\n   return total;\n }\n@@ -1442,14 +1447,14 @@ multcosts (RTX)\n      rtx RTX;\n {\n   /* If mult by a power of 2 then work out how we'd shift to make it */\n-  int insn_cost;\n-  \n+  int insn_cost = 0;\n+\n   if (GET_CODE (XEXP (RTX, 1)) == CONST_INT)\n     {\n       int i = exact_log2 (INTVAL (XEXP (RTX, 1)));\n-      if (i >= 0) \n+      if (i >= 0)\n \tinsn_cost = howshift (i);\n-      else \n+      else\n \tinsn_cost = 100000;\n     }\n   if (TARGET_SH2)\n@@ -1458,7 +1463,7 @@ multcosts (RTX)\n \t read of the mac reg, but count more because of the latency and extra reg\n \t usage */\n       if (TARGET_SMALLCODE)\n-\t  return 2;\n+\treturn 2;\n       if (insn_cost > 5)\n \treturn 5;\n       return insn_cost;\n@@ -1467,7 +1472,7 @@ multcosts (RTX)\n   /* If we we're aiming at small code, then just count the number of\n      insns in a multiply call sequence */\n \n-  if (TARGET_SMALLCODE) \n+  if (TARGET_SMALLCODE)\n     {\n       if (insn_cost > 6)\n \treturn 6;\n@@ -1627,7 +1632,6 @@ dump_table (scan)\n      rtx scan;\n {\n   int i;\n-  int pass;\n   int need_align = 1;\n \n \n@@ -1706,6 +1710,10 @@ fixit (src, mode)\n     {\n       return 1;\n     }\n+  if (GET_CODE (src) == LABEL_REF)\n+    {\n+      return 1;\n+    }\n   if (GET_CODE (src) == CONST_INT)\n     {\n       /* All QI insns are ok */\n@@ -1740,17 +1748,18 @@ hi_const (src)\n /* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.\n    If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from that one. */\n \n+static rtx from;\n static\n rtx\n-find_barrier (from)\n-     rtx from;\n+find_barrier (from_)\n+     rtx from_;\n {\n   int count_si = 0;\n   int count_hi = 0;\n   int found_hi = 0;\n   int found_si = 0;\n   rtx found_barrier = 0;\n-\n+from = from_;\n   while (from\n \t && count_si < max_count_si\n \t && count_hi < max_count_hi)\n@@ -1786,11 +1795,14 @@ find_barrier (from)\n \n   if (!found_barrier)\n     {\n-      /* Insert a jump around the barrier here */\n+      /* We didn't find a barrier in time to \n+\t dump our stuff, so we'll make one */\n       rtx label = gen_label_rtx ();\n       /* Walk back to be just before any jump */\n+\t  from = PREV_INSN (from);\n       while (GET_CODE (from) == JUMP_INSN\n-\t     || GET_CODE (from) == NOTE)\n+\t     || GET_CODE (from) == NOTE\n+\t     || GET_CODE (from) == CODE_LABEL)\n \t{\n \t  from = PREV_INSN (from);\n \t}\n@@ -1836,7 +1848,6 @@ machine_dependent_reorg (first)\n      rtx first;\n {\n   rtx insn;\n-  int limit;\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (broken_move (insn))\n@@ -1895,7 +1906,7 @@ machine_dependent_reorg (first)\n \n /* Called from the md file, set up the operands of a compare instruction */\n \n-int\n+void\n from_compare (operands, code)\n      rtx *operands;\n      int code;\n@@ -1905,7 +1916,7 @@ from_compare (operands, code)\n       /* Force args into regs, since we can't use constants here */\n       sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n-\tsh_compare_op1 = force_reg (SImode, sh_compare_op1);\t\n+\tsh_compare_op1 = force_reg (SImode, sh_compare_op1);\n     }\n   operands[1] = sh_compare_op0;\n   operands[2] = sh_compare_op1;\n@@ -1923,41 +1934,75 @@ equality_operator (x, mode)\n }\n \n \n-/* Framefull frame looks like:\n-\n-   arg-5\n-   arg-4\n-   [ if current_function_anonymous_args\n-   arg-3\n-   arg-2\n-   arg-1\n-   arg-0 ]\n-   saved-fp\n-   saved-r10\n-   saved-r11\n-   saved-r12\n-   saved-pr\n-   local-n\n-   ..\n-   local-1\n-   local-0        <- fp points here\n+/* Add this function to the list of ones seen - temporary\n+   gross hack to try out bsrs. */\n+struct flist\n+{\n+  char *name;\n+  struct flist *next;\n+};\n+struct flist *head;\n \n+static void\n+add_function (name)\n+     char *name;\n+{\n+  struct flist *n = (struct flist *) xmalloc (sizeof (struct flist));\n+  int l = strlen (name) + 1;\n+  n->name = xmalloc (l);\n+  memcpy (n->name, name, l);\n+  n->next = head;\n+  head = n;\n+}\n \n-   If TARGET_SMALLCALL, then the preserved registers are pushed by a\n-   wrapper before the routine is entered, so the regs are always pushed\n-   and there are two pr's on the stack - the caller and the wrapper.\n- */\n+static int\n+seen_function (name)\n+     char *name;\n+{\n+  struct flist *p = head;\n+  for (p = head; p; p = p->next)\n+    {\n+      if (strcmp (p->name, name) == 0)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+ /* Framefull frame looks like:\n+\n+    arg-5\n+    arg-4\n+    [ if current_function_anonymous_args\n+    arg-3\n+    arg-2\n+    arg-1\n+    arg-0 ]\n+    saved-fp\n+    saved-r10\n+    saved-r11\n+    saved-r12\n+    saved-pr\n+    local-n\n+    ..\n+    local-1\n+    local-0        <- fp points here\n \n \n-/* Code to generate prologue and epilogue sequences */\n+    If TARGET_SMALLCALL, then the preserved registers are pushed by a\n+    wrapper before the routine is entered, so the regs are always pushed\n+    and there are two pr's on the stack - the caller and the wrapper.\n+  */\n+\n+\n+ /* Code to generate prologue and epilogue sequences */\n \n \n void\n sh_expand_prologue ()\n {\n   int live_regs_mask;\n   int d;\n-\n+  extern tree current_function_decl;\n   live_regs_mask = calc_live_regs (&d);\n \n   /* We have pretend args if we had an object sent partially in registers\n@@ -1984,6 +2029,12 @@ sh_expand_prologue ()\n     {\n       emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n     }\n+  if (TARGET_BSR)\n+    {\n+      add_function (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+    }\n+\n+\n }\n \n void\n@@ -2027,11 +2078,14 @@ sh_expand_epilogue ()\n \n int\n initial_elimination_offset (from, to)\n+     int from;\n+     int to;\n {\n   int regs_saved;\n-  int regs_saved_mask = calc_live_regs (&regs_saved);\n   int total_saved_regs_space;\n   int total_auto_space = get_frame_size ();\n+\n+  calc_live_regs (&regs_saved);\n   total_saved_regs_space = (regs_saved) * 4;\n \n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n@@ -2074,12 +2128,12 @@ handle_pragma (file)\n       if (psize == 9 && strncmp (pbuf, \"interrupt\", 9) == 0)\n \t{\n \t  pragma_interrupt = 1;\n-\t  return;\n+\t  return c;\n \t}\n       if (psize == 5 && strncmp (pbuf, \"trapa\", 5) == 0)\n \t{\n \t  pragma_interrupt = pragma_trapa = 1;\n-\t  return;\n+\t  return c;\n \t}\n       c = getc (file);\n     }\n@@ -2088,7 +2142,7 @@ handle_pragma (file)\n \f\n /* insn expand helpers */\n \n-/* Emit insns to perform a call. \n+/* Emit insns to perform a call.\n    If TARGET_SHORTADDR then use a bsr. If TARGET_SMALLCALL, then load the\n    target address into r1 and call __saveargs, otherwise\n    perform the standard call sequence */\n@@ -2103,29 +2157,29 @@ expand_acall (isa_retval, operands)\n   rtx call_target = operands[isa_retval + 0];\n   rtx numargs = operands[isa_retval + 1];\n \n-  if (TARGET_BSR)\n+  if (TARGET_BSR && bsr_operand (call_target, VOIDmode))\n     {\n       call = gen_rtx (CALL, VOIDmode, call_target, numargs);\n     }\n-  else {\n-\n-    if (GET_CODE (call_target) == MEM)\n-      {\n-\tcall_target = force_reg (Pmode,\n-\t\t\t\t XEXP (call_target, 0));\n-      }\n-    if (TARGET_SMALLCALL)\n-      {\n-\trtx tmp = gen_reg_rtx (SImode);\n-\trtx r1 = gen_rtx (REG, SImode, 1);\n-\temit_move_insn (tmp, gen_rtx (SYMBOL_REF, SImode, \"__saveargs\"));\n-\temit_move_insn (r1, call_target);\n-\temit_insn (gen_rtx (USE, VOIDmode, r1));\n-\tcall_target = tmp;\n-      }\n+  else\n+    {\n+      if (GET_CODE (call_target) == MEM)\n+\t{\n+\t  call_target = force_reg (Pmode,\n+\t\t\t\t   XEXP (call_target, 0));\n+\t}\n+      if (TARGET_SMALLCALL)\n+\t{\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\t  rtx r1 = gen_rtx (REG, SImode, 1);\n+\t  emit_move_insn (tmp, gen_rtx (SYMBOL_REF, SImode, \"__saveargs\"));\n+\t  emit_move_insn (r1, call_target);\n+\t  emit_insn (gen_rtx (USE, VOIDmode, r1));\n+\t  call_target = tmp;\n+\t}\n \n-    call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n-  }\n+      call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n+    }\n   if (isa_retval)\n     {\n       call = gen_rtx (SET, VOIDmode, ret, call);\n@@ -2134,7 +2188,7 @@ expand_acall (isa_retval, operands)\n   emit_call_insn (gen_rtx (PARALLEL, VOIDmode,\n \t\t\t   gen_rtvec (2,\n \t\t\t\t      call,\n-\t\t\t\t      gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 17)))));\n+\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 17)))));\n \n }\n \f\n@@ -2156,10 +2210,18 @@ general_movsrc_operand (op, mode)\n       GET_CODE (XEXP (op, 0)) == LABEL_REF)\n     return 1;\n \n-  /* No predec allowed */\n+  /* No post inc allowed */\n \n   if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+      && (GET_CODE (XEXP (op, 0)) == POST_DEC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC))\n+    return 0;\n+\n+  /* Can't do that with large modes */\n+  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == POST_INC\n+      && GET_MODE_SIZE (mode) > 4)\n     return 0;\n \n   if ((mode == QImode || mode == HImode)\n@@ -2185,12 +2247,18 @@ general_movdst_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  /* No pre dec allowed */\n   if (GET_CODE (op) == MEM\n       && (GET_CODE (XEXP (op, 0)) == PRE_INC\n \t  || GET_CODE (XEXP (op, 0)) == POST_INC\n \t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n     return 0;\n \n+  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == PRE_DEC\n+      && GET_MODE_SIZE (mode) > 4)\n+    return 0;\n+\n   return general_operand (op, mode);\n }\n \n@@ -2200,11 +2268,19 @@ general_movdst_operand (op, mode)\n \n int\n bsr_operand (op, mode)\n-rtx op;\n-enum machine_mode mode;\n+     rtx op;\n+     enum machine_mode mode;\n {\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    return 1;\n+  if (TARGET_BSR)\n+    {\n+      if (GET_CODE (op) == SYMBOL_REF)\n+\t{\n+\t  if (!strcmp (XSTR (op, 0),\n+\t\t      IDENTIFIER_POINTER (DECL_NAME (current_function_decl))))\n+\t    return 1;\n+\t  return (seen_function (XSTR (op, 0)));\n+\t}\n+    }\n   return 0;\n }\n \n@@ -2329,7 +2405,7 @@ mac_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n #if 0\n-  Turned off till mac is understood \n+  Turned off till mac is understood\n   if (GET_CODE (op) == MEM)\n     return 1;\n #endif\n@@ -2349,27 +2425,27 @@ mac_operand (op, mode)\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-rtx \n+rtx\n sh_function_arg (cum, mode, type, named)\n-CUMULATIVE_ARGS cum;\n-enum machine_mode mode;\n-tree type;\n-int named;\n+     CUMULATIVE_ARGS cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n {\n   if (named)\n     {\n-      int rr =  (ROUND_REG ((cum), (mode)));\n+      int rr = (ROUND_REG ((cum), (mode)));\n \n       if (rr < NPARM_REGS)\n \t{\n-\t  return ((((mode) != BLKmode \t\t\t\t\t\n-\t\t    && ((type)==0 || ! TREE_ADDRESSABLE ((tree)(type)))\t\n-\t\t    && ((type)==0 || (mode) != BLKmode\t\t\t\n-\t\t\t|| (TYPE_ALIGN ((type)) % PARM_BOUNDARY == 0))\t\n-\t\t    ? gen_rtx (REG, (mode),\t\t\t\t\n-\t\t\t       (FIRST_PARM_REG + rr)): 0)));\n+\t  return ((((mode) != BLKmode\n+\t\t    && ((type) == 0 || !TREE_ADDRESSABLE ((tree) (type)))\n+\t\t    && ((type) == 0 || (mode) != BLKmode\n+\t\t\t|| (TYPE_ALIGN ((type)) % PARM_BOUNDARY == 0))\n+\t\t    ? gen_rtx (REG, (mode),\n+\t\t\t       (FIRST_PARM_REG + rr)) : 0)));\n \n-\t}\t\t\n+\t}\n     }\n   return 0;\n }\n@@ -2387,18 +2463,17 @@ sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n      tree TYPE;\n      int NAMED;\n {\n-  if ((CUM) < NPARM_REGS)\t\t\t\t\t\t\t\n-    {\n-      if (((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\n-\t  && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\n-\t      || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\n-\t  && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\n-\t\t       ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\n-\t\t       : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0))\n+  if ((CUM) < NPARM_REGS)\n+    {\n+      if (((TYPE) == 0 || !TREE_ADDRESSABLE ((tree) (TYPE)))\n+\t  && ((TYPE) == 0 || (MODE) != BLKmode\n+\t      || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\n+\t  && ((CUM) + ((MODE) == BLKmode\n+\t\t       ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\n+\t\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0))\n \t{\n \t  return NPARM_REGS - CUM;\n \t}\n     }\n   return 0;\n }\n-"}, {"sha": "aafa931eeb4eada2f24c49ac95b51cb208dde513", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e87e1611c6cb4598c35a139432f069653f4adad/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e87e1611c6cb4598c35a139432f069653f4adad/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=8e87e1611c6cb4598c35a139432f069653f4adad", "patch": "@@ -1,4 +1,5 @@\n-/* Definitions of target machine for GNU compiler, for Hitachi Super-H.\n+/* Definitions of target machine for GNU compiler, \n+   for Hitachi Super-H.\n    Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n \n    Contributed by Steve Chamberlain (sac@cygnus.com)\n@@ -83,6 +84,7 @@ extern int target_flags;\n #define CONSTLEN_0_BIT  (1<<25)\n #define BSR_BIT   \t(1<<26)\n #define SHORTADDR_BIT   (1<<27)\n+#define PACKSTRUCT_BIT  (1<<28)\n \n /* Nonzero if we should generate code using type 0 insns */\n #define TARGET_SH0 (target_flags & SH0_BIT)\n@@ -141,11 +143,14 @@ extern int target_flags;\n \n /* Nonzero if using Hitachi's calling convention */\n #define TARGET_HITACHI \t\t(target_flags & HITACHI_BIT)\n+\n #define TARGET_PARANOID \t(target_flags & PARANOID_BIT)\n #define TARGET_RETR2 \t\t(target_flags & RETR2_BIT)\n #define TARGET_SHORTADDR\t(target_flags & SHORTADDR_BIT)\n #define TARGET_BSR\t\t(target_flags & BSR_BIT)\n \n+/* Nonzero if packing structures as small as they'll go (incompatible with Hitachi's compiler) */\n+#define TARGET_PACKSTRUCT       (target_flags & PACKSTRUCT_BIT)\n \n #define TARGET_SWITCHES  \t\t\\\n { {\"isize\", \t( ISIZE_BIT) },\t\t\\\n@@ -170,10 +175,11 @@ extern int target_flags;\n   {\"r2\",\t( RETR2_BIT) },\t\t\\\n   {\"shortaddr\", ( SHORTADDR_BIT) },     \\\n   {\"bsr\",       ( BSR_BIT) },    \t\\\n+  {\"packstruct\",( PACKSTRUCT_BIT) },    \\\n   {\"\",   \tTARGET_DEFAULT} \t\\\n }\n \n-#define TARGET_DEFAULT  (FAST_BIT)\n+#define TARGET_DEFAULT  (FAST_BIT | BIGTABLE_BIT)\n \n /* Macro to define table for command options with values.  */\n #define TARGET_OPTIONS \\\n@@ -206,7 +212,7 @@ do {\t\t\t\t\t\t\t\t\\\n   if (max_hi)\t\t\t\t\t\t\t\\\n     max_count_hi = atoi (max_hi);\t\t\t\t\\\n   else      \t\t\t\t\t\t\t\\\n-    max_count_hi = 505;\t\t\t\t                \\\n+    max_count_hi = 500;\t\t\t\t                \\\n   if (TARGET_BSR)                                               \\\n      flag_no_function_cse = 1;                                  \\\n } while (0)\n@@ -264,9 +270,6 @@ do {\t\t\t\t\t\t\t\t\\\n /* The best alignment to use in cases where we have a choice.  */\n #define FASTEST_ALIGNMENT 32\n \n-/* Every structures size must be a multiple of 32 bits.  */\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-\n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   ((TREE_CODE (EXP) == STRING_CST\t\\\n@@ -279,6 +282,11 @@ do {\t\t\t\t\t\t\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n \n+/* Number of bits which any structure or union's size must be a\n+   multiple of.  Each structure or union's size is rounded up to a\n+   multiple of this. */\n+#define STRUCTURE_SIZE_BOUNDARY (TARGET_PACKSTRUCT ? 8 : 32)\n+\n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n@@ -305,9 +313,7 @@ do {\t\t\t\t\t\t\t\t\\\n    The hardware registers are assigned numbers for the compiler\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n    All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-*/\n+   even those that are not normally considered general registers. */\n \n #define AP_REG   16  \n #define PR_REG   17\n@@ -867,7 +873,7 @@ extern int current_function_anonymous_args;\n /* Nonzero if the constant value X is a legitimate general operand. */\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE(X) != CONST_DOUBLE && GET_CODE(X) != LABEL_REF)\n+  (GET_CODE(X) != CONST_DOUBLE /*&& GET_CODE(X) != LABEL_REF*/)\n \n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -877,9 +883,9 @@ extern int current_function_anonymous_args;\n    them unless they have been allocated suitable hard regs.\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n \n-#define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64))\n-#define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60))\n-#define MODE_DISP_OK_2(X,MODE) ((GET_MODE_SIZE(MODE)==2) && ((unsigned)INTVAL(X)<32) && TARGET_TRYR0)\n+#define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64) && (!(INTVAL(X) &3)))\n+#define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60) && (!(INTVAL(X) &3)))\n+#define MODE_DISP_OK_2(X,MODE) ((GET_MODE_SIZE(MODE)==2) && ((unsigned)INTVAL(X)<32) && TARGET_TRYR0 && (!INTVAL(X) &1))\n #define MODE_DISP_OK_1(X,MODE) ((GET_MODE_SIZE(MODE)==1) && ((unsigned)INTVAL(X)<16) && TARGET_TRYR0)\n \n #ifndef REG_OK_STRICT\n@@ -896,7 +902,7 @@ extern int current_function_anonymous_args;\n   (REGNO (X) == 0 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n \n #define REG_OK_FOR_PRE_POST_P(X) \\\n-  \t(REG_OK_FOR_INDEX_P (X))\n+  \t(REG_OK_FOR_BASE_P (X))\n \n #else\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n@@ -908,7 +914,7 @@ extern int current_function_anonymous_args;\n   \tREGNO_OK_FOR_INDEX_P (REGNO (X))\n \n #define REG_OK_FOR_PRE_POST_P(X)  \\\n-\t(REGNO_OK_FOR_INDEX_P (REGNO (X)))\n+\t(REGNO_OK_FOR_BASE_P (REGNO (X)))\n #endif\n \n /* The Q is a pc relative load operand */\n@@ -1039,7 +1045,7 @@ extern int current_function_anonymous_args;\n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n    Do not define this if the table should contain absolute addresses.  */\n-#define CASE_VECTOR_PC_RELATIVE \n+/*#define CASE_VECTOR_PC_RELATIVE */\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n@@ -1053,6 +1059,9 @@ extern int current_function_anonymous_args;\n /* The type of size_t unsigned int.  */\n #define SIZE_TYPE \"unsigned int\"\n \n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n /* Don't cse the address of the function being compiled.  */\n /*#define NO_RECURSIVE_FUNCTION_CSE 1*/\n \n@@ -1195,13 +1204,14 @@ extern int current_function_anonymous_args;\n \n /* How to change between sections. */\n \n-#define TEXT_SECTION_ASM_OP  \t\"\\t.text\"\n-#define DATA_SECTION_ASM_OP  \t\"\\t.data\"\n-#define CTORS_SECTION_ASM_OP \t\"\\t.section\\t.ctors\\n\"\n-#define DTORS_SECTION_ASM_OP \t\"\\t.section\\t.dtors\\n\"\n-#define INIT_SECTION_ASM_OP  \t\"\\t.section\\t.init\\n\"\n-#define EXTRA_SECTIONS \t\tin_ctors, in_dtors\n-\n+#define TEXT_SECTION_ASM_OP  \t\t\"\\t.text\"\n+#define DATA_SECTION_ASM_OP  \t\t\"\\t.data\"\n+#define READONLY_DATA_SECTION_ASM_OP \t\"\\t.section\\t.rdata\\n\"\n+#define CTORS_SECTION_ASM_OP \t\t\"\\t.section\\t.ctors\\n\"\n+#define DTORS_SECTION_ASM_OP \t\t\"\\t.section\\t.dtors\\n\"\n+#define INIT_SECTION_ASM_OP  \t\t\"\\t.section\\t.init\\n\"\n+#define EXTRA_SECTIONS \t\t\tin_ctors, in_dtors, in_rdata\n+#define READONLY_DATA_SECTION   \trdata_section\n #define EXTRA_SECTION_FUNCTIONS                              \\\n void\t\t\t\t\t\t\t     \\\n ctors_section() \t\t\t\t\t     \\\n@@ -1220,6 +1230,15 @@ dtors_section() \t\t\t\t\t     \\\n       fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);  \\\n       in_section = in_dtors;\t\t\t\t     \\\n     }\t\t\t\t\t\t\t     \\\n+}                                                            \\\n+void\t\t\t\t\t\t\t     \\\n+rdata_section() \t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t     \\\n+  if (in_section != in_rdata)\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t     \\\n+      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_SECTION_ASM_OP);  \\\n+      in_section = in_rdata;\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t     \\\n }\t\t\t\t\t\t\t      \n \n /* Assemble generic sections.\n@@ -1462,7 +1481,7 @@ extern char *output_far_jump();\n \n #define TARGET_MEM_FUNCTIONS\n \n-#define HANDLE_PRAGMA(finput) handle_pragma (finput)\n+#define HANDLE_PRAGMA(finput) return handle_pragma (finput)\n \n /* Set when processing a function with pragma interrupt turned on. */\n "}, {"sha": "397fc0fb50712c6a44158300bac42d2316498b4a", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 192, "deletions": 95, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e87e1611c6cb4598c35a139432f069653f4adad/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e87e1611c6cb4598c35a139432f069653f4adad/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=8e87e1611c6cb4598c35a139432f069653f4adad", "patch": "@@ -158,11 +158,14 @@\n   (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n \t (eq_attr \"type\" \"jump\") (const_string \"no\")\n \t (eq_attr \"type\" \"pload\") (const_string \"no\")\n+\t (eq_attr \"type\" \"pcloadsi\") (const_string \"no\")\n+\t (eq_attr \"type\" \"pcloadhi\") (const_string \"no\")\n \t (eq_attr \"type\" \"return\") (const_string \"no\")\n \t (eq_attr \"length\" \"2\") (const_string \"yes\")\n \t (eq_attr \"length\" \"4,6,8,10,12\") (const_string \"no\")\n \t ] (const_string \"yes\")))\n \n+\n \f\n ;; -------------------------------------------------------------------------\n ;; SImode signed integer comparisons\n@@ -259,36 +262,42 @@\n ;; Addition instructions\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"addc\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(plus:SI (reg:SI 18)\n-\t\t (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n-\t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n-   (set (reg:SI 18) (gt:SI (match_dup 1) (match_dup 0)))]\n-  \"\"\n-  \"addc\t%2,%0\")\n \n \n ;; this should be a define split.\n \n+\n+\n+(define_insn \"addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(plus:SI (match_dup 0)\n+\t\t (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t\t\t  (reg:SI 18))))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"addc\t%1,%0\")\n+\n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  rtx low_a = gen_rtx (SUBREG, SImode, operands[1], 1);\n-  rtx low_b = gen_rtx (SUBREG, SImode, operands[2], 1);\n-  rtx low_s = gen_rtx (SUBREG, SImode, operands[0], 1);\n+  rtx low_a = operand_subword (operands[1], 1, 1, DImode);\n+  rtx low_b = operand_subword (operands[2], 1, 1, DImode);\n+  rtx low_s = operand_subword (operands[0], 1, 1, DImode);\n \n-  rtx high_a = gen_rtx (SUBREG, SImode, operands[1], 0);\n-  rtx high_b = gen_rtx (SUBREG, SImode, operands[2], 0);\n-  rtx high_s = gen_rtx (SUBREG, SImode, operands[0], 0);\n+  rtx high_a = operand_subword (operands[1], 0, 1, DImode);\n+  rtx high_b = operand_subword (operands[2], 0, 1, DImode);\n+  rtx high_s = operand_subword (operands[0], 0, 1, DImode);\n \n   emit_insn (gen_clrt ());\n-  emit_insn (gen_addc (low_s, low_a, low_b));\n-  emit_insn (gen_addc (high_s, high_a, high_b));\n+\n+  emit_move_insn (low_s, low_a);\n+  emit_insn (gen_addc (low_s, low_b));\n+  emit_move_insn (high_s, high_a);\n+  emit_insn (gen_addc (high_s, high_b));\n \n   DONE;\n }\")\n@@ -314,16 +323,37 @@\n ;; Subtraction instructions\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t  (match_operand:DI 2 \"arith_reg_operand\" \"r\")))\n+\n+(define_insn \"subc\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n+\t\t  (plus:SI  (match_operand:SI 2 \"arith_reg_operand\" \"r\")\n+\t\t\t    (reg:SI 18))))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"clrt\\;subc\t%R2,%R0\\;subc\t%2,%0\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"type\" \"arith\")])\n+  \"subc\t%2,%0\")\n+\n+(define_expand \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx low_a = operand_subword (operands[1], 1, 1, DImode);\n+  rtx low_b = operand_subword (operands[2], 1, 1, DImode);\n+  rtx low_s = operand_subword (operands[0], 1, 1, DImode);\n+\n+  rtx high_a = operand_subword (operands[1], 0, 1, DImode);\n+  rtx high_b = operand_subword (operands[2], 0, 1, DImode);\n+  rtx high_s = operand_subword (operands[0], 0, 1, DImode);\n+\n+  emit_insn (gen_clrt ());\n+  emit_insn (gen_subc (low_s, low_a, low_b));\n+  emit_insn (gen_subc (high_s, high_a, high_b));\n+\n+  DONE;\n+}\")\n \n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n@@ -504,14 +534,7 @@\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(reg:SI 21))]\n   \"TARGET_SH2\"\n-  \"\n-{\n-  if (!TARGET_SH2)\n-    {\n-      emit_insn (gen_mulsi3_call (operands[0], operands[1], operands[2])); \n-      DONE; \n-    } \n-}\")\n+  \"\")\n \n (define_insn \"\"\n   [(set (reg:DI 20)\n@@ -769,7 +792,7 @@\n (define_insn \"ashldi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t   (match_operand:DI 2 \"immediate_operand\" \"I\")))\n+\t\t   (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"shll\t%R0\\;rotcl\t%0\"\n@@ -788,7 +811,7 @@\n (define_insn \"lshrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:DI 2 \"immediate_operand\" \"I\")))\n+\t\t     (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"shlr\t%0\\;rotcr\t%R0\"\n@@ -806,7 +829,7 @@\n (define_insn \"ashrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t\t     (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"shar\t%0\\;rotcr\t%R0\"\n@@ -826,15 +849,35 @@\n ;; Unary arithmetic\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"negdi2\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=&r\")\n-\t(neg:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")))\n-   (clobber (reg:SI 18))]\n+\n+(define_insn \"negc\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(neg:SI (plus:SI (reg:SI 18) (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))]\n   \"\"\n-  \"clrt\\;negc\t%R1,%R0\\;negc\t%1,%0\"\n-  [(set_attr \"length\" \"6\")\n+  \"negc\t%1,%0\"\n+  [(set_attr \"length\" \"2\")\n    (set_attr \"type\" \"arith\")])\n \n+(define_expand \"negdi2\"\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"{\n+   rtx low_src = operand_subword (operands[1], 1, 0, DImode);\n+   rtx high_src = operand_subword (operands[1], 0, 0, DImode);\n+\n+   rtx low_dst = operand_subword (operands[0], 1, 1, DImode);\n+   rtx high_dst = operand_subword (operands[0], 0, 1, DImode);\n+\n+   emit_insn (gen_clrt ());\n+   emit_insn (gen_negc (low_dst, low_src));\n+   emit_insn (gen_negc (high_dst, high_src));\n+   DONE;\n+   }\n+   \")\n+\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n@@ -982,32 +1025,19 @@\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,r,<m,<,xl,xl,t,r\")\n \t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,>m,xl,t,r,xl,r,>,r,i\"))]\n   \"\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      switch (get_attr_length(insn)) \n-\t{\n-\tcase 2:\n-\t  return \\\"mov.l\t%1,%0\\\";\n-\tcase 12:\n-\t  return \\\"mov.l\tTA%*,%0\\;bra\tTB%*\\;mov.l\t@%0,%0\\;.align 2\\;TA%*: .long %1\\;TB%*:%^\\\";\n-\t}\n-    case 1: return \\\"mov\t%1,%0\\\";\n-    case 2: return \\\"mov.l\t%1,%0\\\";\n-    case 3: return \\\"sts\t%1,%0\\\";\n-    case 4: return \\\"movt\t%0\\\";\n-    case 5: return \\\"mov.l\t%1,%0\\\";\n-    case 6: return \\\"sts.l\t%1,%0\\\";\n-    case 7: return \\\"lds\t%1,%0\\\";\n-    case 8: return \\\"lds.l\t%1,%0\\\";\n-    case 9: return \\\"tst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\\\";\n-    case 10: return \\\"fake %1,%0\\\";\n-    }\n-}\"\n-  [(set_attr \"length\" \"*,2,2,2,2,2,2,2,2,6,2\")\n-   (set_attr \"type\" \"pcloadsi,move,load,move,store,store,move,load,move,move,move\")])\n+  \"@\n+\tmov.l\t%1,%0\n+\tmov\t%1,%0\n+\tmov.l\t%1,%0\n+\tsts\t%1,%0\n+\tmovt\t%0\n+\tmov.l\t%1,%0\n+\tsts.l\t%1,%0\n+\tlds\t%1,%0\n+\tlds.l\t%1,%0\n+\ttst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\n+\tfake %1,%0\"\n+  [(set_attr \"type\" \"pcloadsi,move,load,move,store,store,move,load,move,move,move\")])\n \t\t\t  \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n@@ -1042,27 +1072,15 @@\n   [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,<m,r,r,l\")\n \t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,>m,t,r,i,l,r\"))]\n   \"\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      switch (get_attr_length(insn)) \n-\t{\n-\tcase 2:\n-\t  return \\\"mov.w\t%1,%0\\\";\n-\tcase 12:\n-\t  return \\\"mov.l\tTA%*,%0\\;bra\tTB%*\\;mov.w\t@%0,%0\\;.align 2\\;TA%*: .long %1\\;TB%*:%^\\\";\n-\t}\n-    case 1: return \\\"mov\t%1,%0\\\";\n-    case 2: return \\\"mov.w\t%1,%0\\\";\n-    case 3: return \\\"movt\t%0\\\";\n-    case 4: return \\\"mov.w\t%1,%0\\\";\n-    case 5: return \\\"fake %1,%0\\\";\n-    case 6: return \\\"sts\t%1,%0\\\";\n-    case 7: return \\\"lds\t%1,%0\\\";\n-    }\n-}\"\n+  \"@\n+\tmov.w\t%1,%0\n+\tmov\t%1,%0\n+\tmov.w\t%1,%0\n+\tmovt\t%0\n+\tmov.w\t%1,%0\n+\tfake %1,%0\n+\tsts\t%1,%0\n+\tlds\t%1,%0\"\n   [(set_attr \"length\" \"*,2,2,2,2,2,2,2\")\n    (set_attr \"type\" \"pcloadhi,move,load,move,store,move,move,move\")])\n \n@@ -1089,6 +1107,43 @@\n   [(set_attr \"length\" \"*,4,4,4,4\")\n    (set_attr \"type\" \"pcloadsi,move,load,store,move\")])\n \n+;; If the output is a register and the input is memory, we have to be careful\n+;; and see which word needs to be loaded first.\n+;;\n+(define_split\n+  [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:DI 1 \"general_movsrc_operand\" \"\"))]\n+ \"!  (GET_CODE (operands[0]) == REG\n+\t         && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[1]) == REG\n+         && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n+   && ! reload_completed\n+   && reg_overlap_mentioned_p (operands[0], operands[1]))\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{ if (GET_CODE (operands[0]) != REG\n+      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t      operands[1], 0))\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 0, DImode);\n+      operands[3] = operand_subword (operands[1], 0, 0, DImode);\n+      operands[4] = operand_subword (operands[0], 1, 0, DImode);\n+      operands[5] = operand_subword (operands[1], 1, 0, DImode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 0, DImode);\n+      operands[3] = operand_subword (operands[1], 1, 0, DImode);\n+      operands[4] = operand_subword (operands[0], 0, 0, DImode);\n+      operands[5] = operand_subword (operands[1], 0, 0, DImode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+}\")\n \n \t\n (define_expand \"movdi\"\n@@ -1114,6 +1169,45 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"move,load,store\")])\n \n+;; If the output is a register and the input is memory, we have to be careful\n+;; and see which word needs to be loaded first.\n+;;\n+(define_split\n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n+ \"!  (GET_CODE (operands[0]) == REG\n+\t         && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[1]) == REG\n+         && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n+   && ! reload_completed\n+   && reg_overlap_mentioned_p (operands[0], operands[1]))\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{ if (GET_CODE (operands[0]) != REG\n+      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t      operands[1], 0))\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n+      operands[3] = operand_subword (operands[1], 0, 0, DFmode);\n+      operands[4] = operand_subword (operands[0], 1, 0, DFmode);\n+      operands[5] = operand_subword (operands[1], 1, 0, DFmode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n+      operands[3] = operand_subword (operands[1], 1, 0, DFmode);\n+      operands[4] = operand_subword (operands[0], 0, 0, DFmode);\n+      operands[5] = operand_subword (operands[1], 0, 0, DFmode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+}\")\n+\n+\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n@@ -1443,20 +1537,23 @@\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 4 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 5)))\n+   (parallel[(set (match_dup 5) (ashift:SI (match_dup 5) (const_int 2)))\n+\t\t(clobber (reg:SI 18))])\n    (set (reg:SI 0) (label_ref (match_operand 3 \"\" \"\")))\n-   (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n-\t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n-\t\t\t\t\t\t       (match_dup 6)))))\n-\t     (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n+   (set (reg:SI 0) (mem:SI (plus:SI (reg:SI 0) (match_dup 5))))\n+\n+;;   (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n+;;\t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n+;;\t\t\t\t\t\t       (match_dup 5)))))\n+;;\t     (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n    (set (pc) (reg:SI 0))]\n   \"\"\n   \"\n {\n   operands[1] = copy_to_mode_reg (SImode, operands[1]);\n   operands[2] = copy_to_mode_reg (SImode, operands[2]);\n   operands[5] = gen_reg_rtx (SImode);\n-  operands[6] = gen_reg_rtx (SImode);\n+\n }\")\n \n (define_insn \"casesi_worker\"\n@@ -1470,7 +1567,7 @@\n   \"mov.w\t@(r0,%0),%0\\;add\t%0,r0\"\n   [(set_attr \"needs_delay_slot\" \"no\")\n    (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"length\" \"6\")])\n+   (set_attr \"length\" \"4\")])\n \n \n (define_insn \"return\""}]}