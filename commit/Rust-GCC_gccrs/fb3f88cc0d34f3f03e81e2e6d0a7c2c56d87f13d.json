{"sha": "fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIzZjg4Y2MwZDM0ZjNmMDNlODFlMmU2ZDBhN2MyYzU2ZDg3ZjEzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-10-22T10:02:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-10-22T10:02:29Z"}, "message": "ipa-cp.c (ipcp_write_summary, [...]): New functions.\n\n\n\t* ipa-cp.c (ipcp_write_summary, ipcp_read_summary): New functions.\n\t(pass_ipa_cp): Register them.\n\t(ipcp_init_stage): Analyze all functions for whopr/lto.\n\t(ipcp_propagate_stage): Skip external calls.\n\t(ipcp_iterate_stage): Call ipa_update_after_lto_read if needed.\n\t* ipa-reference.c (write_node_summary_p): Fix thinko about availability.\n\t* cgraphunit.c (ipa_passes): When in lto, ne er produce new summaries;\n\twhen in ltrans, skip executing of ipa passes since everything should've\n\tbeen done.\n\t* ipa-inline.c (cgraph_decide_inlining): Remove FIXMEs.\n\t(inline_generate_summary): Likewise.\n\t(inline_read_summary): New function.\n\t(inline_write_summary): New function.\n\t(pass_ipa_inline): Register new hooks.\n\t* ipa-prop.c: Inlcude lto-streamer.h\n\t(ipa_edge_args_vector): Update declaration.\n\t(ipa_count_arguments, ipa_compute_jump_functions,\n\tipa_free_edge_args_substructures): Move ipa_edge_args_vector into ggc.\n\t(ipa_write_jump_function, ipa_read_jump_function, ipa_write_node_info,\n\tipa_read_node_info): New static functions.\n\t(ipa_prop_write_jump_functions, ipa_prop_read_jump_functions): Update.\n\t(duplicate_array): Use xmalloc.\n\t(duplicate_ggc_array): New.\n\t(ipa_edge_duplication_hook): Use it.\n\t(ipa_update_after_lto_read): New function.\n\t* ipa-prop.h (ipa_prop_write_jump_functions,\n\tipa_prop_read_jump_functions): Declare.\n\t(ipa_pass_through_data, ipa_ancestor_jf_data, ipa_member_ptr_cst,\n\tjump_func_value, ipa_member_ptr_cst, ipa_edge_args): Add GTY markers.\n\t(ipa_edge_args_vector): Move into GGC.\n\t(ipa_check_create_edge_args): Update.\n\t(ipa_update_after_lto_read): New.\n\t* passes.c (ipa_write_summaries_1): When in wpa, do not write summaries.\n\t(ipa_read_summaries): When in ltrans, so not read summaries.\n\t* lto-streamer.c (lto_get_section_name): Add LTO_section_jump_functions.\n\t* lto-streamer.h (LTO_section_jump_functions): New section.\n\t(produce_asm): Declare.\n\t* lto-cgraph.c (output_cgraph): Output edges in reverse order.\n\t* lto-streamer-out.c (produce_asm): Export.\n\t* lto-streamer-in.c: Include tree-pass.h\n\t(input_function): Free dominance info when done.\n\t(lto_read_body): Push ipa_inline in ltrans stage.\n\t* gengtype.c (open_base_files): Add ipa-prop.h into includes.\n\t* Makefile.in (GTFILES): Add ipa-prop.h\n\n\t* lto.c (lto_fixup_jump_functions): New function.\n\t(lto_fixup_decls): Use it.\n\nFrom-SVN: r153449", "tree": {"sha": "dc0c5b1f5b9348db2afad23ab409cf18702d1173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0c5b1f5b9348db2afad23ab409cf18702d1173"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/comments", "author": null, "committer": null, "parents": [{"sha": "34677bae651336700ad8a84f7218e080c435fafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34677bae651336700ad8a84f7218e080c435fafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34677bae651336700ad8a84f7218e080c435fafc"}], "stats": {"total": 589, "additions": 529, "deletions": 60}, "files": [{"sha": "d686d0db7be4ca3c73d0885002a7e07c9a378248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1,3 +1,50 @@\n+2009-10-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_write_summary, ipcp_read_summary): New functions.\n+\t(pass_ipa_cp): Register them.\n+\t(ipcp_init_stage): Analyze all functions for whopr/lto.\n+\t(ipcp_propagate_stage): Skip external calls.\n+\t(ipcp_iterate_stage): Call ipa_update_after_lto_read if needed.\n+\t* ipa-reference.c (write_node_summary_p): Fix thinko about availability.\n+\t* cgraphunit.c (ipa_passes): When in lto, ne er produce new summaries;\n+\twhen in ltrans, skip executing of ipa passes since everything should've\n+\tbeen done.\n+\t* ipa-inline.c (cgraph_decide_inlining): Remove FIXMEs.\n+\t(inline_generate_summary): Likewise.\n+\t(inline_read_summary): New function.\n+\t(inline_write_summary): New function.\n+\t(pass_ipa_inline): Register new hooks.\n+\t* ipa-prop.c: Inlcude lto-streamer.h\n+\t(ipa_edge_args_vector): Update declaration.\n+\t(ipa_count_arguments, ipa_compute_jump_functions,\n+\tipa_free_edge_args_substructures): Move ipa_edge_args_vector into ggc.\n+\t(ipa_write_jump_function, ipa_read_jump_function, ipa_write_node_info,\n+\tipa_read_node_info): New static functions.\n+\t(ipa_prop_write_jump_functions, ipa_prop_read_jump_functions): Update.\n+\t(duplicate_array): Use xmalloc.\n+\t(duplicate_ggc_array): New.\n+\t(ipa_edge_duplication_hook): Use it.\n+\t(ipa_update_after_lto_read): New function.\n+\t* ipa-prop.h (ipa_prop_write_jump_functions,\n+\tipa_prop_read_jump_functions): Declare.\n+\t(ipa_pass_through_data, ipa_ancestor_jf_data, ipa_member_ptr_cst,\n+\tjump_func_value, ipa_member_ptr_cst, ipa_edge_args): Add GTY markers.\n+\t(ipa_edge_args_vector): Move into GGC.\n+\t(ipa_check_create_edge_args): Update.\n+\t(ipa_update_after_lto_read): New.\n+\t* passes.c (ipa_write_summaries_1): When in wpa, do not write summaries.\n+\t(ipa_read_summaries): When in ltrans, so not read summaries.\n+\t* lto-streamer.c (lto_get_section_name): Add LTO_section_jump_functions.\n+\t* lto-streamer.h (LTO_section_jump_functions): New section.\n+\t(produce_asm): Declare.\n+\t* lto-cgraph.c (output_cgraph): Output edges in reverse order.\n+\t* lto-streamer-out.c (produce_asm): Export.\n+\t* lto-streamer-in.c: Include tree-pass.h\n+\t(input_function): Free dominance info when done.\n+\t(lto_read_body): Push ipa_inline in ltrans stage.\n+\t* gengtype.c (open_base_files): Add ipa-prop.h into includes.\n+\t* Makefile.in (GTFILES): Add ipa-prop.h\n+\n 2009-10-22  Matthias Klose  <doko@ubuntu.com>\n \n \t* doc/install.texi: Document --enable-browser-plugin."}, {"sha": "750da6b645ced80dd1d7d56a1f20fe71307538a3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -3585,6 +3585,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-ssa-structalias.c \\\n   $(srcdir)/lto-symtab.c \\\n   $(srcdir)/tree-ssa-alias.h \\\n+  $(srcdir)/ipa-prop.h \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "7b8b738ed1fafba3b403af3cadaf9725823c166a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1375,15 +1375,16 @@ ipa_passes (void)\n       set_cfun (NULL);\n       current_function_decl = NULL;\n       cgraph_process_new_functions ();\n-    }\n \n-  execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_regular_ipa_passes);\n+      execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_regular_ipa_passes);\n+    }\n   execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_lto_gen_passes);\n \n   if (!in_lto_p)\n     ipa_write_summaries ();\n \n-  execute_ipa_pass_list (all_regular_ipa_passes);\n+  if (!flag_ltrans)\n+    execute_ipa_pass_list (all_regular_ipa_passes);\n \n   bitmap_obstack_release (NULL);\n }"}, {"sha": "32abf6eff12b7f0c7d7b687d4038360932157bf9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1571,7 +1571,7 @@ open_base_files (void)\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n       \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n-      \"target.h\", NULL\n+      \"target.h\", \"ipa-prop.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "4166e78d61cda49fe4d98b996ae5a6049b1b4ced", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -614,7 +614,9 @@ ipcp_init_stage (void)\n       /* building jump functions  */\n       for (cs = node->callees; cs; cs = cs->next_callee)\n \t{\n-\t  if (!cs->callee->analyzed)\n+\t  /* We do not need to bother analyzing calls to unknown\n+\t     functions unless they may become known during lto/whopr.  */\n+\t  if (!cs->callee->analyzed && !flag_lto && !flag_whopr)\n \t    continue;\n \t  ipa_count_arguments (cs);\n \t  if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n@@ -696,7 +698,9 @@ ipcp_propagate_stage (void)\n \t  struct ipa_node_params *callee_info = IPA_NODE_REF (cs->callee);\n \t  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n \n-\t  if (ipa_is_called_with_var_arguments (callee_info))\n+\t  if (ipa_is_called_with_var_arguments (callee_info)\n+\t      || !cs->callee->analyzed\n+\t      || ipa_is_called_with_var_arguments (callee_info))\n \t    continue;\n \n \t  count = ipa_get_cs_argument_count (args);\n@@ -727,6 +731,10 @@ ipcp_iterate_stage (void)\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA iterate stage:\\n\\n\");\n+\n+  if (in_lto_p)\n+    ipa_update_after_lto_read ();\n+\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       ipcp_initialize_node_lattices (node);\n@@ -1276,6 +1284,20 @@ ipcp_generate_summary (void)\n   ipcp_init_stage ();\n }\n \n+/* Write ipcp summary for nodes in SET.  */\n+static void\n+ipcp_write_summary (cgraph_node_set set)\n+{\n+  ipa_prop_write_jump_functions (set);\n+}\n+\n+/* Read ipcp summary.  */\n+static void\n+ipcp_read_summary (void)\n+{\n+  ipa_prop_read_jump_functions ();\n+}\n+\n /* Gate for IPCP optimization.  */\n static bool\n cgraph_gate_cp (void)\n@@ -1308,8 +1330,8 @@ struct ipa_opt_pass_d pass_ipa_cp =\n   TODO_remove_functions /* todo_flags_finish */\n  },\n  ipcp_generate_summary,\t\t\t/* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n+ ipcp_write_summary,\t\t\t/* write_summary */\n+ ipcp_read_summary,\t\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* function_read_summary */\n  0,\t\t\t\t\t/* TODOs */\n  NULL,\t\t\t\t\t/* function_transform */"}, {"sha": "9e1bc9f48832de2204bb26a4c94cb9ba6fc12a18", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1113,13 +1113,9 @@ cgraph_decide_inlining (void)\n   bool redo_always_inline = true;\n   int initial_size = 0;\n \n-  /* FIXME lto.  We need to rethink how to coordinate different passes. */\n-  if (flag_ltrans)\n-    return 0;\n-\n-  /* FIXME lto.  We need to re-think about how the passes get invoked. */\n-  if (!flag_wpa)\n-    cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n+  if (in_lto_p && flag_indirect_inlining)\n+    ipa_update_after_lto_read ();\n \n   max_count = 0;\n   max_benefit = 0;\n@@ -1928,10 +1924,6 @@ inline_generate_summary (void)\n {\n   struct cgraph_node *node;\n \n-  /* FIXME lto.  We should not run any IPA-summary pass in LTRANS mode.  */\n-  if (flag_ltrans)\n-    return;\n-\n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n \n@@ -1976,6 +1968,34 @@ inline_transform (struct cgraph_node *node)\n   return todo | execute_fixup_cfg ();\n }\n \n+/* Read inline summary.  Jump functions are shared among ipa-cp\n+   and inliner, so when ipa-cp is active, we don't need to write them\n+   twice.  */\n+\n+static void \n+inline_read_summary (void)\n+{\n+  if (flag_indirect_inlining)\n+    {\n+      ipa_register_cgraph_hooks ();\n+      if (!flag_ipa_cp)\n+        ipa_prop_read_jump_functions ();\n+    }\n+  function_insertion_hook_holder =\n+      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+}\n+\n+/* Write inline summary for node in SET.\n+   Jump functions are shared among ipa-cp and inliner, so when ipa-cp is\n+   active, we don't need to write them twice.  */\n+\n+static void \n+inline_write_summary (cgraph_node_set set)\n+{\n+  if (flag_indirect_inlining && !flag_ipa_cp)\n+    ipa_prop_write_jump_functions (set);\n+}\n+\n struct ipa_opt_pass_d pass_ipa_inline =\n {\n  {\n@@ -1995,8 +2015,8 @@ struct ipa_opt_pass_d pass_ipa_inline =\n   | TODO_remove_functions\t\t/* todo_flags_finish */\n  },\n  inline_generate_summary,\t\t/* generate_summary */\n- NULL,\t\t\t\t\t/* write_summary */\n- NULL,\t\t\t\t\t/* read_summary */\n+ inline_write_summary,\t\t\t/* write_summary */\n+ inline_read_summary,\t\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* function_read_summary */\n  0,\t\t\t\t\t/* TODOs */\n  inline_transform,\t\t\t/* function_transform */"}, {"sha": "9956fbc53b74433333c10b0c495fe30d6eb7a08b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 305, "deletions": 9, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -33,11 +33,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"flags.h\"\n #include \"diagnostic.h\"\n+#include \"lto-streamer.h\"\n \n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n /* Vector where the parameter infos are actually stored. */\n-VEC (ipa_edge_args_t, heap) *ipa_edge_args_vector;\n+VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n@@ -248,7 +249,7 @@ ipa_count_arguments (struct cgraph_edge *cs)\n   arg_num = gimple_call_num_args (stmt);\n   if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n       <= (unsigned) cgraph_edge_max_uid)\n-    VEC_safe_grow_cleared (ipa_edge_args_t, heap,\n+    VEC_safe_grow_cleared (ipa_edge_args_t, gc,\n \t\t\t   ipa_edge_args_vector, cgraph_edge_max_uid + 1);\n   ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n@@ -661,8 +662,8 @@ ipa_compute_jump_functions (struct cgraph_edge *cs)\n \n   if (ipa_get_cs_argument_count (arguments) == 0 || arguments->jump_functions)\n     return;\n-  arguments->jump_functions = XCNEWVEC (struct ipa_jump_func,\n-\t\t\t\t\tipa_get_cs_argument_count (arguments));\n+  arguments->jump_functions = GGC_CNEWVEC (struct ipa_jump_func,\n+\t\t\t\t\t   ipa_get_cs_argument_count (arguments));\n \n   call = cs->call_stmt;\n   gcc_assert (is_gimple_call (call));\n@@ -1173,7 +1174,7 @@ void\n ipa_free_edge_args_substructures (struct ipa_edge_args *args)\n {\n   if (args->jump_functions)\n-    free (args->jump_functions);\n+    ggc_free (args->jump_functions);\n \n   memset (args, 0, sizeof (*args));\n }\n@@ -1191,7 +1192,7 @@ ipa_free_all_edge_args (void)\n        i++)\n     ipa_free_edge_args_substructures (args);\n \n-  VEC_free (ipa_edge_args_t, heap, ipa_edge_args_vector);\n+  VEC_free (ipa_edge_args_t, gc, ipa_edge_args_vector);\n   ipa_edge_args_vector = NULL;\n }\n \n@@ -1262,7 +1263,22 @@ duplicate_array (void *src, size_t n)\n   if (!src)\n     return NULL;\n \n-  p = xcalloc (1, n);\n+  p = xmalloc (n);\n+  memcpy (p, src, n);\n+  return p;\n+}\n+\n+/* Like duplicate_array byt in GGC memory.  */\n+\n+static void *\n+duplicate_ggc_array (void *src, size_t n)\n+{\n+  void *p;\n+\n+  if (!src)\n+    return NULL;\n+\n+  p = ggc_alloc (n);\n   memcpy (p, src, n);\n   return p;\n }\n@@ -1284,8 +1300,8 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n   arg_count = ipa_get_cs_argument_count (old_args);\n   ipa_set_cs_argument_count (new_args, arg_count);\n   new_args->jump_functions = (struct ipa_jump_func *)\n-    duplicate_array (old_args->jump_functions,\n-\t\t     sizeof (struct ipa_jump_func) * arg_count);\n+    duplicate_ggc_array (old_args->jump_functions,\n+\t\t         sizeof (struct ipa_jump_func) * arg_count);\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -1875,3 +1891,283 @@ ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n   VEC_free (tree, heap, parms);\n }\n \n+/* Stream out jump function JUMP_FUNC to OB.  */\n+\n+static void\n+ipa_write_jump_function (struct output_block *ob,\n+\t\t\t struct ipa_jump_func *jump_func)\n+{\n+  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t     jump_func->type);\n+\n+  switch (jump_func->type)\n+    {\n+    case IPA_JF_UNKNOWN:\n+      break;\n+    case IPA_JF_CONST:\n+      lto_output_tree (ob, jump_func->value.constant, true);\n+      break;\n+    case IPA_JF_PASS_THROUGH:\n+      lto_output_tree (ob, jump_func->value.pass_through.operand, true);\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t jump_func->value.pass_through.formal_id);\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t jump_func->value.pass_through.operation);\n+      break;\n+    case IPA_JF_ANCESTOR:\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t jump_func->value.ancestor.offset);\n+      lto_output_tree (ob, jump_func->value.ancestor.type, true);\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t jump_func->value.ancestor.formal_id);\n+      break;\n+    case IPA_JF_CONST_MEMBER_PTR:\n+      lto_output_tree (ob, jump_func->value.member_cst.pfn, true);\n+      lto_output_tree (ob, jump_func->value.member_cst.delta, false);\n+      break;\n+    }\n+}\n+\n+/* Read in jump function JUMP_FUNC from IB.  */\n+\n+static void\n+ipa_read_jump_function (struct lto_input_block *ib,\n+\t\t\tstruct ipa_jump_func *jump_func,\n+\t\t\tstruct data_in *data_in)\n+{\n+  jump_func->type = (enum jump_func_type) lto_input_uleb128 (ib);\n+\n+  switch (jump_func->type)\n+    {\n+    case IPA_JF_UNKNOWN:\n+      break;\n+    case IPA_JF_CONST:\n+      jump_func->value.constant = lto_input_tree (ib, data_in);\n+      break;\n+    case IPA_JF_PASS_THROUGH:\n+      jump_func->value.pass_through.operand = lto_input_tree (ib, data_in);\n+      jump_func->value.pass_through.formal_id = lto_input_uleb128 (ib);\n+      jump_func->value.pass_through.operation = (enum tree_code) lto_input_uleb128 (ib);\n+      break;\n+    case IPA_JF_ANCESTOR:\n+      jump_func->value.ancestor.offset = lto_input_uleb128 (ib);\n+      jump_func->value.ancestor.type = lto_input_tree (ib, data_in);\n+      jump_func->value.ancestor.formal_id = lto_input_uleb128 (ib);\n+      break;\n+    case IPA_JF_CONST_MEMBER_PTR:\n+      jump_func->value.member_cst.pfn = lto_input_tree (ib, data_in);\n+      jump_func->value.member_cst.delta = lto_input_tree (ib, data_in);\n+      break;\n+    }\n+}\n+\n+/* Stream out NODE info to OB.  */\n+\n+static void\n+ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n+{\n+  int node_ref;\n+  lto_cgraph_encoder_t encoder;\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  int j;\n+  struct cgraph_edge *e;\n+  struct bitpack_d *bp;\n+\n+  encoder = ob->decl_state->cgraph_node_encoder;\n+  node_ref = lto_cgraph_encoder_encode (encoder, node);\n+  lto_output_uleb128_stream (ob->main_stream, node_ref);\n+\n+  /* Note that flags will need to be read in the opposite\n+     order as we are pushing the bitflags into FLAGS.  */\n+  bp = bitpack_create ();\n+  bp_pack_value (bp, info->called_with_var_arguments, 1);\n+  gcc_assert (info->modification_analysis_done || ipa_get_param_count (info) == 0);\n+  gcc_assert (info->uses_analysis_done || ipa_get_param_count (info) == 0);\n+  gcc_assert (!info->node_enqueued);\n+  gcc_assert (!info->ipcp_orig_node);\n+  for (j = 0; j < ipa_get_param_count (info); j++)\n+    {\n+      bp_pack_value (bp, info->params[j].modified, 1);\n+      bp_pack_value (bp, info->params[j].called, 1);\n+    }\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+\n+      lto_output_uleb128_stream (ob->main_stream, ipa_get_cs_argument_count (args));\n+      for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n+\tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n+    }\n+}\n+\n+/* Srtream in NODE info from IB.  */\n+\n+static void\n+ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n+\t\t    struct data_in *data_in)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  int k;\n+  struct cgraph_edge *e;\n+  struct bitpack_d *bp;\n+\n+  ipa_initialize_node_params (node);\n+\n+  /* Note that the flags must be read in the opposite\n+     order in which they were written (the bitflags were\n+     pushed into FLAGS).  */\n+  bp = lto_input_bitpack (ib);\n+  info->called_with_var_arguments = bp_unpack_value (bp, 1);\n+  if (ipa_get_param_count (info) != 0)\n+    {\n+      info->modification_analysis_done = true;\n+      info->uses_analysis_done = true;\n+    }\n+  info->node_enqueued = false;\n+  for (k = 0; k < ipa_get_param_count (info); k++)\n+    {\n+      info->params[k].modified = bp_unpack_value (bp, 1);\n+      info->params[k].called = bp_unpack_value (bp, 1);\n+    }\n+  bitpack_delete (bp);\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      int count = lto_input_uleb128 (ib);\n+\n+      if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n+\t  <= (unsigned) cgraph_edge_max_uid)\n+\tVEC_safe_grow_cleared (ipa_edge_args_t, gc,\n+\t\t\t       ipa_edge_args_vector, cgraph_edge_max_uid + 1);\n+      ipa_set_cs_argument_count (args, count);\n+      if (!count)\n+\tcontinue;\n+\n+      args->jump_functions = GGC_CNEWVEC (struct ipa_jump_func,\n+\t\t\t\t          ipa_get_cs_argument_count (args));\n+      for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n+\tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n+    }\n+}\n+\n+/* Write jump functions for nodes in SET.  */\n+\n+void\n+ipa_prop_write_jump_functions (cgraph_node_set set)\n+{\n+  struct cgraph_node *node;\n+  struct output_block *ob = create_output_block (LTO_section_jump_functions);\n+  unsigned int count = 0;\n+  cgraph_node_set_iterator csi;\n+\n+  ob->cgraph_node = NULL;\n+\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      if (node->analyzed && IPA_NODE_REF (node) != NULL)\n+\tcount++;\n+    }\n+\n+  lto_output_uleb128_stream (ob->main_stream, count);\n+\n+  /* Process all of the functions.  */\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      node = csi_node (csi);\n+      if (node->analyzed && IPA_NODE_REF (node) != NULL)\n+        ipa_write_node_info (ob, node);\n+    }\n+  lto_output_1_stream (ob->main_stream, 0);\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+/* Read section in file FILE_DATA of length LEN with data DATA.  */\n+\n+static void\n+ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n+\t\t       size_t len)\n+{\n+  const struct lto_function_header *header =\n+    (const struct lto_function_header *) data;\n+  const int32_t cfg_offset = sizeof (struct lto_function_header);\n+  const int32_t main_offset = cfg_offset + header->cfg_size;\n+  const int32_t string_offset = main_offset + header->main_size;\n+  struct data_in *data_in;\n+  struct lto_input_block ib_main;\n+  unsigned int i;\n+  unsigned int count;\n+\n+  LTO_INIT_INPUT_BLOCK (ib_main, (const char *) data + main_offset, 0,\n+\t\t\theader->main_size);\n+\n+  data_in =\n+    lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\theader->string_size, NULL);\n+  count = lto_input_uleb128 (&ib_main);\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      unsigned int index;\n+      struct cgraph_node *node;\n+      lto_cgraph_encoder_t encoder;\n+\n+      index = lto_input_uleb128 (&ib_main);\n+      encoder = file_data->cgraph_node_encoder;\n+      node = lto_cgraph_encoder_deref (encoder, index);\n+      ipa_read_node_info (&ib_main, node, data_in);\n+    }\n+  lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Read ipcp jump functions.  */\n+\n+void\n+ipa_prop_read_jump_functions (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  ipa_check_create_node_params ();\n+  ipa_check_create_edge_args ();\n+  ipa_register_cgraph_hooks ();\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data = lto_get_section_data (file_data, LTO_section_jump_functions, NULL, &len);\n+\n+      if (data)\n+        ipa_prop_read_section (file_data, data, len);\n+    }\n+}\n+\n+/* After merging units, we can get mismatch in argument counts. \n+   Also decl merging might've rendered parameter lists obsolette.\n+   Also compute called_with_variable_arg info.  */\n+\n+void\n+ipa_update_after_lto_read (void)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!node->analyzed)\n+\tcontinue;\n+      ipa_populate_param_decls (node, IPA_NODE_REF (node));\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n+\t      != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n+\t    ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n+\t}\n+    }\n+}"}, {"sha": "35005954deb10fd7a53d56b19a00b3330c2de923", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -72,7 +72,7 @@ enum ipa_lattice_type\n \n /* Structure holding data required to describe a pass-through jump function.  */\n \n-struct ipa_pass_through_data\n+struct GTY(()) ipa_pass_through_data\n {\n   /* If an operation is to be performed on the original parameter, this is the\n      second (constant) operand.  */\n@@ -89,7 +89,7 @@ struct ipa_pass_through_data\n /* Structure holding data required to describe and ancestor pass throu\n    funkci.  */\n \n-struct ipa_ancestor_jf_data\n+struct GTY(()) ipa_ancestor_jf_data\n {\n   /* Offset of the field representing the ancestor.  */\n   HOST_WIDE_INT offset;\n@@ -101,30 +101,28 @@ struct ipa_ancestor_jf_data\n \n /* Structure holding a C++ member pointer constant.  Holds a pointer to the\n    method and delta offset.  */\n-struct ipa_member_ptr_cst\n+struct GTY(()) ipa_member_ptr_cst\n {\n   tree pfn;\n   tree delta;\n };\n \n-/* Represents a value of a jump function.  pass_through is used only in jump\n-   function context.  constant represents the actual constant in constant jump\n-   functions and member_cst holds constant c++ member functions.  */\n-union jump_func_value\n-{\n-  tree constant;\n-  struct ipa_pass_through_data pass_through;\n-  struct ipa_ancestor_jf_data ancestor;\n-  struct ipa_member_ptr_cst member_cst;\n-};\n-\n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n-struct ipa_jump_func\n+struct GTY (()) ipa_jump_func\n {\n   enum jump_func_type type;\n-  union jump_func_value value;\n+  /* Represents a value of a jump function.  pass_through is used only in jump\n+     function context.  constant represents the actual constant in constant jump\n+     functions and member_cst holds constant c++ member functions.  */\n+  union jump_func_value\n+  {\n+    tree GTY ((tag (\"IPA_JF_CONST\"))) constant;\n+    struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n+    struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n+    struct ipa_member_ptr_cst GTY ((tag (\"IPA_JF_CONST_MEMBER_PTR\"))) member_cst;\n+  } GTY ((desc (\"%1.type\"))) value;\n };\n \n /* All formal parameters in the program have a cval computed by\n@@ -280,15 +278,15 @@ ipa_is_called_with_var_arguments (struct ipa_node_params *info)\n /* ipa_edge_args stores information related to a callsite and particularly\n    its arguments. It is pointed to by a field in the\n    callsite's corresponding cgraph_edge.  */\n-struct ipa_edge_args\n+typedef struct GTY(()) ipa_edge_args\n {\n   /* Number of actual arguments in this callsite.  When set to 0,\n      this callsite's parameters would not be analyzed by the different\n      stages of IPA CP.  */\n   int argument_count;\n   /* Array of the callsite's jump function of each parameter.  */\n-  struct ipa_jump_func *jump_functions;\n-};\n+  struct ipa_jump_func GTY ((length (\"%h.argument_count\"))) *jump_functions;\n+} ipa_edge_args_t;\n \n /* ipa_edge_args access functions.  Please use these to access fields that\n    are or will be shared among various passes.  */\n@@ -321,18 +319,17 @@ ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n \n /* Vectors need to have typedefs of structures.  */\n typedef struct ipa_node_params ipa_node_params_t;\n-typedef struct ipa_edge_args ipa_edge_args_t;\n \n /* Types of vectors holding the infos.  */\n DEF_VEC_O (ipa_node_params_t);\n DEF_VEC_ALLOC_O (ipa_node_params_t, heap);\n DEF_VEC_O (ipa_edge_args_t);\n-DEF_VEC_ALLOC_O (ipa_edge_args_t, heap);\n+DEF_VEC_ALLOC_O (ipa_edge_args_t, gc);\n \n /* Vector where the parameter infos are actually stored. */\n extern VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n /* Vector where the parameter infos are actually stored. */\n-extern VEC (ipa_edge_args_t, heap) *ipa_edge_args_vector;\n+extern GTY(()) VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n /* Return the associated parameter/argument info corresponding to the given\n    node/edge.  */\n@@ -378,12 +375,12 @@ static inline void\n ipa_check_create_edge_args (void)\n {\n   if (!ipa_edge_args_vector)\n-    ipa_edge_args_vector = VEC_alloc (ipa_edge_args_t, heap,\n+    ipa_edge_args_vector = VEC_alloc (ipa_edge_args_t, gc,\n \t\t\t\t      cgraph_edge_max_uid);\n \n   if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n       <=  (unsigned) cgraph_edge_max_uid)\n-    VEC_safe_grow_cleared (ipa_edge_args_t, heap, ipa_edge_args_vector,\n+    VEC_safe_grow_cleared (ipa_edge_args_t, gc, ipa_edge_args_vector,\n \t\t\t   cgraph_edge_max_uid + 1);\n }\n \n@@ -508,6 +505,10 @@ ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n \t\t\t\t\t\t ipa_parm_adjustment_vec);\n void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n \n+void ipa_prop_write_jump_functions (cgraph_node_set set);\n+void ipa_prop_read_jump_functions (void);\n+void ipa_update_after_lto_read (void);\n+\n /* From tree-sra.c:  */\n bool build_ref_for_offset (tree *, tree, HOST_WIDE_INT, tree, bool);\n "}, {"sha": "2e062e45eaa1222495e1ff7d32fa4a970f13a59b", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1014,7 +1014,7 @@ write_node_summary_p (struct cgraph_node *node)\n {\n   return (node->analyzed \n \t  && node->global.inlined_to == NULL\n-\t  && cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE\n+\t  && cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE\n \t  && get_reference_vars_info (node) != NULL);\n }\n "}, {"sha": "6b340a37d583e65e507fa236b59aebe787f5964a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -372,8 +372,16 @@ output_cgraph (cgraph_node_set set)\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      for (edge = node->callees; edge; edge = edge->next_callee)\n-\tlto_output_edge (ob, edge, encoder);\n+      if (node->callees)\n+        {\n+\t  /* Output edges in backward direction, so the reconstructed callgraph\n+\t     match and it is easy to associate call sites in the IPA pass summaries.  */\n+\t  edge = node->callees;\n+\t  while (edge->next_callee)\n+\t    edge = edge->next_callee;\n+\t  for (; edge; edge = edge->prev_callee)\n+\t    lto_output_edge (ob, edge, encoder);\n+\t}\n     }\n \n   lto_output_uleb128_stream (ob->main_stream, 0);"}, {"sha": "f31b3195a7e9b3c17d17aa0af69194ab01c6da89", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"ipa-utils.h\"\n #include \"lto-streamer.h\"\n+#include \"tree-pass.h\"\n \n /* Data structure used to hash file names in the source_location field.  */\n struct string_slot\n@@ -1341,6 +1342,8 @@ input_function (tree fn_decl, struct data_in *data_in,\n   fixup_call_stmt_edges (cgraph_node (fn_decl), stmts);\n \n   update_ssa (TODO_update_ssa_only_virtuals); \n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n   free (stmts);\n }\n \n@@ -1455,6 +1458,15 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n       /* Restore decl state */\n       file_data->current_decl_state = file_data->global_decl_state;\n \n+      /* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n+         summaries computed and needs to apply changes.  At the moment WHOPR only\n+         supports inlining, so we can push it here by hand.  In future we need to stream\n+         this field into ltrans compilation.  This will also need to move the field\n+\t from struct function into cgraph node where it belongs.  */\n+      if (flag_ltrans && !cgraph_node (fn_decl)->global.inlined_to)\n+\t VEC_safe_push (ipa_opt_pass, heap,\n+\t\t\tcfun->ipa_transforms_to_apply,\n+\t\t\t(ipa_opt_pass)&pass_ipa_inline);\n       pop_cfun ();\n     }\n   else "}, {"sha": "40bba1e71211ed3d9e829b4a42431c8937771639", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1762,7 +1762,7 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n /* Create the header in the file using OB.  If the section type is for\n    a function, set FN to the decl for that function.  */\n \n-static void\n+void\n produce_asm (struct output_block *ob, tree fn)\n {\n   enum lto_section_type section_type = ob->section_type;"}, {"sha": "5b925db504e42c29680908e35e78ac017253a520", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -157,6 +157,9 @@ lto_get_section_name (int section_type, const char *name)\n     case LTO_section_cgraph:\n       return concat (LTO_SECTION_NAME_PREFIX, \".cgraph\", NULL);\n \n+    case LTO_section_jump_functions:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".jmpfuncs\", NULL);\n+\n     case LTO_section_ipa_pure_const:\n       return concat (LTO_SECTION_NAME_PREFIX, \".pureconst\", NULL);\n "}, {"sha": "260d773f3002abd3b22ab0e23e36864cddc66ed4", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -256,6 +256,7 @@ enum lto_section_type\n   LTO_section_function_body,\n   LTO_section_static_initializer,\n   LTO_section_cgraph,\n+  LTO_section_jump_functions,\n   LTO_section_ipa_pure_const,\n   LTO_section_ipa_reference,\n   LTO_section_symtab,\n@@ -827,6 +828,7 @@ extern struct output_block *create_output_block (enum lto_section_type);\n extern void destroy_output_block (struct output_block *);\n extern void lto_output_tree (struct output_block *, tree, bool);\n extern void lto_output_bitpack (struct lto_output_stream *, struct bitpack_d *);\n+extern void produce_asm (struct output_block *ob, tree fn);\n \n \n /* In lto-cgraph.c  */"}, {"sha": "a53a8c04e79a5c10ba8aabc96aa21f494e804057", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1,3 +1,8 @@\n+2009-10-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_fixup_jump_functions): New function.\n+\t(lto_fixup_decls): Use it.\n+\n 2009-10-16  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41715"}, {"sha": "a8ad9e369b9ccd92dd5f89040355878025b8f363", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1652,6 +1652,53 @@ free_decl (const void *p, void *data ATTRIBUTE_UNUSED)\n   return true;\n }\n \n+/* Fixup pointers in jump functions.\n+   TODO: We need some generic solution that will allow tree pointers in\n+   function summaries.  */\n+static void\n+lto_fixup_jump_functions (lto_fixup_data_t * data)\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *cs;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!node->analyzed)\n+\tcontinue;\n+      for (cs = node->callees; cs; cs = cs->next_callee)\n+\t{\n+\t  int i;\n+\t  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+\t  for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n+\t    {\n+\t      struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n+\t      switch (jf->type)\n+\t\t{\n+\t\tcase IPA_JF_UNKNOWN:\n+\t\t  break;\n+\t\tcase IPA_JF_CONST:\n+\t\t  walk_tree (&jf->value.constant, lto_fixup_tree, data, NULL);\n+\t\t  break;\n+\t\tcase IPA_JF_PASS_THROUGH:\n+\t\t  walk_tree (&jf->value.pass_through.operand, lto_fixup_tree,\n+\t\t\t     data, NULL);\n+\t\t  break;\n+\t\tcase IPA_JF_ANCESTOR:\n+\t\t  walk_tree (&jf->value.ancestor.type, lto_fixup_tree, data,\n+\t\t\t     NULL);\n+\t\t  break;\n+\t\tcase IPA_JF_CONST_MEMBER_PTR:\n+\t\t  walk_tree (&jf->value.member_cst.pfn, lto_fixup_tree, data,\n+\t\t\t     NULL);\n+\t\t  walk_tree (&jf->value.member_cst.delta, lto_fixup_tree,\n+\t\t\t     data, NULL);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Fix the decls from all FILES. Replaces each decl with the corresponding\n    prevailing one.  */\n \n@@ -1682,6 +1729,8 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n       if (decl != saved_decl)\n \tVEC_replace (tree, lto_global_var_decls, i, decl);\n     }\n+  if (ipa_edge_args_vector)\n+    lto_fixup_jump_functions (&data);\n \n   pointer_set_traverse (free_list, free_decl, NULL);\n   pointer_set_destroy (free_list);"}, {"sha": "db368f057db7922b240dd3984825cd288571d751", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=fb3f88cc0d34f3f03e81e2e6d0a7c2c56d87f13d", "patch": "@@ -1618,7 +1618,8 @@ ipa_write_summaries_1 (cgraph_node_set set)\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n   lto_push_out_decl_state (state);\n \n-  ipa_write_summaries_2 (all_regular_ipa_passes, set, state);\n+  if (!flag_wpa)\n+    ipa_write_summaries_2 (all_regular_ipa_passes, set, state);\n   ipa_write_summaries_2 (all_lto_gen_passes, set, state);\n \n   gcc_assert (lto_get_out_decl_state () == state);\n@@ -1712,7 +1713,8 @@ ipa_read_summaries_1 (struct opt_pass *pass)\n void\n ipa_read_summaries (void)\n {\n-  ipa_read_summaries_1 (all_regular_ipa_passes);\n+  if (!flag_ltrans)\n+    ipa_read_summaries_1 (all_regular_ipa_passes);\n   ipa_read_summaries_1 (all_lto_gen_passes);\n }\n "}]}