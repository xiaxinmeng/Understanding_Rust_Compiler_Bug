{"sha": "ae1669a98656cca594fcd2fef6bd2cd7308a361f", "node_id": "C_kwDOANBUbNoAKGFlMTY2OWE5ODY1NmNjYTU5NGZjZDJmZWY2YmQyY2Q3MzA4YTM2MWY", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-20T22:12:25Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:29Z"}, "message": "Convert CFN_CLZ builtins to range-ops.\n\n\t* gimple-range-fold.cc (range_of_builtin_int_call): Remove case\n\tfor CFN_CLZ.\n\t* gimple-range-op.cc (class cfn_clz): New.\n\t(gimple_range_op_handler::maybe_builtin_call): Set arguments.", "tree": {"sha": "29a15419f34f25247f8d019b903fa312164fa194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29a15419f34f25247f8d019b903fa312164fa194"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae1669a98656cca594fcd2fef6bd2cd7308a361f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1669a98656cca594fcd2fef6bd2cd7308a361f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1669a98656cca594fcd2fef6bd2cd7308a361f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1669a98656cca594fcd2fef6bd2cd7308a361f/comments", "author": null, "committer": null, "parents": [{"sha": "5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f730c650184d4c8bfad513a9e0e593f87a5bf0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f730c650184d4c8bfad513a9e0e593f87a5bf0c"}], "stats": {"total": 145, "additions": 84, "deletions": 61}, "files": [{"sha": "63eaa90be96b684ca4bfc6a79710932487121881", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1669a98656cca594fcd2fef6bd2cd7308a361f/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1669a98656cca594fcd2fef6bd2cd7308a361f/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=ae1669a98656cca594fcd2fef6bd2cd7308a361f", "patch": "@@ -926,67 +926,6 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n       r.set (build_zero_cst (type), build_one_cst (type));\n       return true;\n \n-    CASE_CFN_CLZ:\n-      // __builtin_c[lt]z* return [0, prec-1], except when the\n-      // argument is 0, but that is undefined behavior.\n-      //\n-      // For __builtin_c[lt]z* consider argument of 0 always undefined\n-      // behavior, for internal fns depending on C?Z_DEFINED_VALUE_AT_ZERO.\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (gimple_call_internal_p (call))\n-\t{\n-\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n-\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t    {\n-\t      // Only handle the single common value.\n-\t      if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      else\n-\t\t// Magic value to give up, unless we can prove arg is non-zero.\n-\t\tmini = -2;\n-\t    }\n-\t}\n-\n-      src.get_operand (r, arg);\n-      // From clz of minimum we can compute result maximum.\n-      if (!r.undefined_p ())\n-\t{\n-\t  // From clz of minimum we can compute result maximum.\n-\t  if (wi::gt_p (r.lower_bound (), 0, TYPE_SIGN (r.type ())))\n-\t    {\n-\t      maxi = prec - 1 - wi::floor_log2 (r.lower_bound ());\n-\t      if (mini == -2)\n-\t\tmini = 0;\n-\t    }\n-\t  else if (!range_includes_zero_p (&r))\n-\t    {\n-\t      mini = 0;\n-\t      maxi = prec - 1;\n-\t    }\n-\t  if (mini == -2)\n-\t    break;\n-\t  // From clz of maximum we can compute result minimum.\n-\t  wide_int max = r.upper_bound ();\n-\t  int newmini = prec - 1 - wi::floor_log2 (max);\n-\t  if (max == 0)\n-\t    {\n-\t      // If CLZ_DEFINED_VALUE_AT_ZERO is 2 with VALUE of prec,\n-\t      // return [prec, prec], otherwise ignore the range.\n-\t      if (maxi == prec)\n-\t\tmini = prec;\n-\t    }\n-\t  else\n-\t    mini = newmini;\n-\t}\n-      if (mini == -2)\n-\tbreak;\n-      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n-\n     CASE_CFN_CTZ:\n       // __builtin_ctz* return [0, prec-1], except for when the\n       // argument is 0, but that is undefined behavior."}, {"sha": "caba49309f922f6a0c4e4f0f19b27979641c9712", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1669a98656cca594fcd2fef6bd2cd7308a361f/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1669a98656cca594fcd2fef6bd2cd7308a361f/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=ae1669a98656cca594fcd2fef6bd2cd7308a361f", "patch": "@@ -414,6 +414,81 @@ class cfn_popcount : public range_operator\n   }\n } op_cfn_popcount;\n \n+// Implement range operator for CFN_BUILT_IN_CLZ\n+class cfn_clz : public range_operator\n+{\n+public:\n+  cfn_clz (bool internal) { m_gimple_call_internal_p = internal; }\n+  using range_operator::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const irange &lh,\n+\t\t\t   const irange &, relation_kind) const;\n+private:\n+  bool m_gimple_call_internal_p;\n+} op_cfn_clz (false), op_cfn_clz_internal (true);\n+\n+bool\n+cfn_clz::fold_range (irange &r, tree type, const irange &lh,\n+\t\t     const irange &, relation_kind) const\n+{\n+  // __builtin_c[lt]z* return [0, prec-1], except when the\n+  // argument is 0, but that is undefined behavior.\n+  //\n+  // For __builtin_c[lt]z* consider argument of 0 always undefined\n+  // behavior, for internal fns depending on C?Z_DEFINED_ALUE_AT_ZERO.\n+  if (lh.undefined_p ())\n+    return false;\n+  int prec = TYPE_PRECISION (lh.type ());\n+  int mini = 0;\n+  int maxi = prec - 1;\n+  int zerov = 0;\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (lh.type ());\n+  if (m_gimple_call_internal_p)\n+    {\n+      if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n+\t  && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t{\n+\t  // Only handle the single common value.\n+\t  if (zerov == prec)\n+\t    maxi = prec;\n+\t  else\n+\t    // Magic value to give up, unless we can prove arg is non-zero.\n+\t    mini = -2;\n+\t}\n+    }\n+\n+  // From clz of minimum we can compute result maximum.\n+  if (wi::gt_p (lh.lower_bound (), 0, TYPE_SIGN (lh.type ())))\n+    {\n+      maxi = prec - 1 - wi::floor_log2 (lh.lower_bound ());\n+      if (mini == -2)\n+\tmini = 0;\n+    }\n+  else if (!range_includes_zero_p (&lh))\n+    {\n+      mini = 0;\n+      maxi = prec - 1;\n+    }\n+  if (mini == -2)\n+    return false;\n+  // From clz of maximum we can compute result minimum.\n+  wide_int max = lh.upper_bound ();\n+  int newmini = prec - 1 - wi::floor_log2 (max);\n+  if (max == 0)\n+    {\n+      // If CLZ_DEFINED_VALUE_AT_ZERO is 2 with VALUE of prec,\n+      // return [prec, prec], otherwise ignore the range.\n+      if (maxi == prec)\n+\tmini = prec;\n+    }\n+  else\n+    mini = newmini;\n+\n+  if (mini == -2)\n+    return false;\n+  r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+  return true;\n+}\n+\n // Set up a gimple_range_op_handler for any built in function which can be\n // supported via range-ops.\n \n@@ -469,6 +544,15 @@ gimple_range_op_handler::maybe_builtin_call ()\n       m_valid = true;\n       break;\n \n+    CASE_CFN_CLZ:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_valid = true;\n+      if (gimple_call_internal_p (call))\n+\tm_int = &op_cfn_clz_internal;\n+      else\n+\tm_int = &op_cfn_clz;\n+      break;\n+\n     default:\n       break;\n     }"}]}