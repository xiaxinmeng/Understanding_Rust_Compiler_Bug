{"sha": "8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQxYWY1MTY4NDRmOTQ3ODRkOWEzYTdmZmM1OWY5YWIzZGFhMWY1ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-11-19T16:31:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-11-19T16:31:03Z"}, "message": "Eliminate global state from -fsave-optimization-record\n\nAs work towards fixing PR tree-optimization/87025, this patch\neliminates global state from optinfo-emit-json.cc in favor\nof adding an optional m_json_writer field to dump_context,\nreplacing the m_forcibly_enable_optinfo flag.\n\nThis allows for writing selftests for the interaction of the\nJSON-building code with the dumpfile.c code.\nIn particular, the existing selftest that created optinfo\ninstances now exercise the JSON-building code (although no\nJSON is actually written out).\n\nThe patch also simplifies the layering by replacing optinfo::emit ()\nwith dump_context::emit_optinfo, so that dump_context has\nresponsibility for keeping track of dump destinations.\n\ngcc/ChangeLog:\n\tPR tree-optimization/87025\n\t* dump-context.h: Include \"optinfo.h\".\n\t(class optrecord_json_writer): New forward decl.\n\t(dump_context::forcibly_enable_optinfo_p): Delete.\n\t(dump_context::optinfo_enabled_p): New member function.\n\t(dump_context::optimization_records_enabled_p): New member\n\tfunction.\n\t(dump_context::set_json_writer): New member function.\n\t(dump_context::emit_optinfo): New member function.\n\t(dump_context::m_forcibly_enable_optinfo): Delete.\n\t(dump_context::m_json_writer): New member data.\n\t* dumpfile.c (dump_context::set_json_writer): New member function.\n\t(dump_context::finish_any_json_writer): New member function.\n\t(dump_context::end_scope): Replace call to\n\toptimization_records_maybe_pop_dump_scope with call to\n\tm_json_writer->pop_scope.\n\t(dump_context::optinfo_enabled_p): New member function.\n\t(dump_context::end_any_optinfo): Replace call to optinfo::emit with call\n\tto dump_context::emit_optinfo.\n\t(dump_context::emit_optinfo): New member function.\n\t(temp_dump_context::temp_dump_context): Replace\n\tm_forcibly_enable_optinfo with call to set_json_writer.\n\t(temp_dump_context::~temp_dump_context): Clean up any json writer.\n\t* optinfo-emit-json.cc (class optrecord_json_writer): Move to\n\toptinfo-emit-json.h\n\t(the_json_writer): Delete.\n\t(optimization_records_start): Delete.\n\t(optimization_records_finish): Delete.\n\t(optimization_records_enabled_p): Delete, in favor of\n\tdump_context::optimization_records_enabled_p.\n\t(optimization_records_maybe_record_optinfo): Delete.\n\t(optimization_records_maybe_pop_dump_scope): Delete.\n\t* optinfo-emit-json.h: Include \"json.h\".  Delete forward\n\tdecl of opt_pass.\n\t(optimization_records_start): Delete.\n\t(optimization_records_finish): Delete.\n\t(optimization_records_enabled_p): Delete.\n\t(optimization_records_maybe_record_optinfo): Delete.\n\t(optimization_records_maybe_pop_dump_scope): Delete.\n\t(class optrecord_json_writer): Move here from\n\toptinfo-emit-json.cc.\n\t* optinfo.cc (optinfo::emit_for_opt_problem): Replace call\n\tto optinfo::emit with call to dump_context::emit_optinfo.\n\t(optinfo::emit): Delete, in favor of dump_context::emit_optinfo.\n\t(optinfo_enabled_p): Delete, in favor of\n\tdump_context::optinfo_enabled_p.\n\t(optinfo_wants_inlining_info_p): Update for conversion o\n\toptimization_records_enabled_p to a member function of\n\tdump_context.\n\t* optinfo.h (optinfo_enabled_p): Delete, in favor of\n\tdump_context::optinfo_enabled_p.\n\t(optinfo::emit): Delete, in favor of dump_context::emit_optinfo.\n\t* toplev.c: Include \"dump-context.h\".\n\t(compile_file): Replace call to optimization_records_finish with\n\tdump_context::finish_any_json_writer.\n\t(do_compile): Replace call to optimization_records_start with\n\tconditionally creating a optrecord_json_writer for the\n\tdump_context.\n\nFrom-SVN: r266279", "tree": {"sha": "c32e504ef3de3abf09e0126e75c2712a7de83e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c32e504ef3de3abf09e0126e75c2712a7de83e6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fea820523334138d7165f20333ef30ba8e01c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fea820523334138d7165f20333ef30ba8e01c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fea820523334138d7165f20333ef30ba8e01c1d"}], "stats": {"total": 322, "additions": 170, "deletions": 152}, "files": [{"sha": "28fb034ab56c24da83c979ae2ee0910a44926a1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -1,3 +1,64 @@\n+2018-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR tree-optimization/87025\n+\t* dump-context.h: Include \"optinfo.h\".\n+\t(class optrecord_json_writer): New forward decl.\n+\t(dump_context::forcibly_enable_optinfo_p): Delete.\n+\t(dump_context::optinfo_enabled_p): New member function.\n+\t(dump_context::optimization_records_enabled_p): New member\n+\tfunction.\n+\t(dump_context::set_json_writer): New member function.\n+\t(dump_context::emit_optinfo): New member function.\n+\t(dump_context::m_forcibly_enable_optinfo): Delete.\n+\t(dump_context::m_json_writer): New member data.\n+\t* dumpfile.c (dump_context::set_json_writer): New member function.\n+\t(dump_context::finish_any_json_writer): New member function.\n+\t(dump_context::end_scope): Replace call to\n+\toptimization_records_maybe_pop_dump_scope with call to\n+\tm_json_writer->pop_scope.\n+\t(dump_context::optinfo_enabled_p): New member function.\n+\t(dump_context::end_any_optinfo): Replace call to optinfo::emit with call\n+\tto dump_context::emit_optinfo.\n+\t(dump_context::emit_optinfo): New member function.\n+\t(temp_dump_context::temp_dump_context): Replace\n+\tm_forcibly_enable_optinfo with call to set_json_writer.\n+\t(temp_dump_context::~temp_dump_context): Clean up any json writer.\n+\t* optinfo-emit-json.cc (class optrecord_json_writer): Move to\n+\toptinfo-emit-json.h\n+\t(the_json_writer): Delete.\n+\t(optimization_records_start): Delete.\n+\t(optimization_records_finish): Delete.\n+\t(optimization_records_enabled_p): Delete, in favor of\n+\tdump_context::optimization_records_enabled_p.\n+\t(optimization_records_maybe_record_optinfo): Delete.\n+\t(optimization_records_maybe_pop_dump_scope): Delete.\n+\t* optinfo-emit-json.h: Include \"json.h\".  Delete forward\n+\tdecl of opt_pass.\n+\t(optimization_records_start): Delete.\n+\t(optimization_records_finish): Delete.\n+\t(optimization_records_enabled_p): Delete.\n+\t(optimization_records_maybe_record_optinfo): Delete.\n+\t(optimization_records_maybe_pop_dump_scope): Delete.\n+\t(class optrecord_json_writer): Move here from\n+\toptinfo-emit-json.cc.\n+\t* optinfo.cc (optinfo::emit_for_opt_problem): Replace call\n+\tto optinfo::emit with call to dump_context::emit_optinfo.\n+\t(optinfo::emit): Delete, in favor of dump_context::emit_optinfo.\n+\t(optinfo_enabled_p): Delete, in favor of\n+\tdump_context::optinfo_enabled_p.\n+\t(optinfo_wants_inlining_info_p): Update for conversion o\n+\toptimization_records_enabled_p to a member function of\n+\tdump_context.\n+\t* optinfo.h (optinfo_enabled_p): Delete, in favor of\n+\tdump_context::optinfo_enabled_p.\n+\t(optinfo::emit): Delete, in favor of dump_context::emit_optinfo.\n+\t* toplev.c: Include \"dump-context.h\".\n+\t(compile_file): Replace call to optimization_records_finish with\n+\tdump_context::finish_any_json_writer.\n+\t(do_compile): Replace call to optimization_records_start with\n+\tconditionally creating a optrecord_json_writer for the\n+\tdump_context.\n+\n 2018-11-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/88071"}, {"sha": "2016ce700d280ab1ae53cae667dfd592a74c7635", "filename": "gcc/dump-context.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -25,7 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"pretty-print.h\"\n #include \"selftest.h\"\n+#include \"optinfo.h\"\n \n+class optrecord_json_writer;\n namespace selftest { class temp_dump_context; }\n \n /* A class for handling the various dump_* calls.\n@@ -95,14 +97,21 @@ class dump_context\n   void begin_scope (const char *name, const dump_location_t &loc);\n   void end_scope ();\n \n-  /* For use in selftests; if true then optinfo_enabled_p is true.  */\n-  bool forcibly_enable_optinfo_p () const\n+  /* Should optinfo instances be created?\n+     All creation of optinfos should be guarded by this predicate.\n+     Return true if any optinfo destinations are active.  */\n+  bool optinfo_enabled_p () const;\n+\n+  bool optimization_records_enabled_p () const\n   {\n-    return m_forcibly_enable_optinfo;\n+    return m_json_writer != NULL;\n   }\n+  void set_json_writer (optrecord_json_writer *writer);\n+  void finish_any_json_writer ();\n \n   void end_any_optinfo ();\n \n+  void emit_optinfo (const optinfo *info);\n   void emit_item (optinfo_item *item, dump_flags_t dump_kind);\n \n   bool apply_dump_filter_p (dump_flags_t dump_kind, dump_flags_t filter) const;\n@@ -111,9 +120,6 @@ class dump_context\n   optinfo &ensure_pending_optinfo ();\n   optinfo &begin_next_optinfo (const dump_location_t &loc);\n \n-  /* For use in selftests; if true then optinfo_enabled_p is true.  */\n-  bool m_forcibly_enable_optinfo;\n-\n   /* The current nesting depth of dump scopes, for showing nesting\n      via indentation).  */\n   unsigned int m_scope_depth;\n@@ -122,6 +128,10 @@ class dump_context\n      if any.  */\n   optinfo *m_pending;\n \n+  /* If -fsave-optimization-record is enabled, the heap-allocated JSON writer\n+     instance, otherwise NULL.  */\n+  optrecord_json_writer *m_json_writer;\n+\n   /* For use in selftests: if non-NULL, then items are to be printed\n      to this, using the given flags.  */\n   pretty_printer *m_test_pp;"}, {"sha": "014acf102fc7446708b59f431b856d13606398ef", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -515,6 +515,28 @@ dump_context::~dump_context ()\n   delete m_pending;\n }\n \n+void\n+dump_context::set_json_writer (optrecord_json_writer *writer)\n+{\n+  delete m_json_writer;\n+  m_json_writer = writer;\n+}\n+\n+/* Perform cleanup activity for -fsave-optimization-record.\n+   Currently, the file is written out here in one go, before cleaning\n+   up.  */\n+\n+void\n+dump_context::finish_any_json_writer ()\n+{\n+  if (!m_json_writer)\n+    return;\n+\n+  m_json_writer->write ();\n+  delete m_json_writer;\n+  m_json_writer = NULL;\n+}\n+\n /* Update the \"dumps_are_enabled\" global; to be called whenever dump_file\n    or alt_dump_file change, or when changing dump_context in selftests.  */\n \n@@ -1121,7 +1143,19 @@ dump_context::end_scope ()\n {\n   end_any_optinfo ();\n   m_scope_depth--;\n-  optimization_records_maybe_pop_dump_scope ();\n+\n+  if (m_json_writer)\n+    m_json_writer->pop_scope ();\n+}\n+\n+/* Should optinfo instances be created?\n+   All creation of optinfos should be guarded by this predicate.\n+   Return true if any optinfo destinations are active.  */\n+\n+bool\n+dump_context::optinfo_enabled_p () const\n+{\n+  return (optimization_records_enabled_p ());\n }\n \n /* Return the optinfo currently being accumulated, creating one if\n@@ -1154,11 +1188,23 @@ void\n dump_context::end_any_optinfo ()\n {\n   if (m_pending)\n-    m_pending->emit ();\n+    emit_optinfo (m_pending);\n   delete m_pending;\n   m_pending = NULL;\n }\n \n+/* Emit the optinfo to all of the \"non-immediate\" destinations\n+   (emission to \"immediate\" destinations is done by\n+   dump_context::emit_item).  */\n+\n+void\n+dump_context::emit_optinfo (const optinfo *info)\n+{\n+  /* -fsave-optimization-record.  */\n+  if (m_json_writer)\n+    m_json_writer->add_record (info);\n+}\n+\n /* Emit ITEM to all item destinations (those that don't require\n    consolidation into optinfo instances).  */\n \n@@ -2004,7 +2050,8 @@ temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo,\n   m_saved (&dump_context ().get ())\n {\n   dump_context::s_current = &m_context;\n-  m_context.m_forcibly_enable_optinfo = forcibly_enable_optinfo;\n+  if (forcibly_enable_optinfo)\n+    m_context.set_json_writer (new optrecord_json_writer ());\n   /* Conditionally enable the test dump, so that we can verify both the\n      dump_enabled_p and the !dump_enabled_p cases in selftests.  */\n   if (forcibly_enable_dumping)\n@@ -2020,6 +2067,8 @@ temp_dump_context::temp_dump_context (bool forcibly_enable_optinfo,\n \n temp_dump_context::~temp_dump_context ()\n {\n+  m_context.set_json_writer (NULL);\n+\n   dump_context::s_current = m_saved;\n \n   dump_context::get ().refresh_dumps_are_enabled ();"}, {"sha": "4fa6708600a008453a39dda1dcc6db8fc64c672e", "filename": "gcc/optinfo-emit-json.cc", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo-emit-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo-emit-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.cc?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -47,38 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dump-context.h\"\n #include <zlib.h>\n \n-/* A class for writing out optimization records in JSON format.  */\n-\n-class optrecord_json_writer\n-{\n-public:\n-  optrecord_json_writer ();\n-  ~optrecord_json_writer ();\n-  void write () const;\n-  void add_record (const optinfo *optinfo);\n-  void pop_scope ();\n-\n-  void add_record (json::object *obj);\n-  json::object *impl_location_to_json (dump_impl_location_t loc);\n-  json::object *location_to_json (location_t loc);\n-  json::object *profile_count_to_json (profile_count count);\n-  json::string *get_id_value_for_pass (opt_pass *pass);\n-  json::object *pass_to_json (opt_pass *pass);\n-  json::value *inlining_chain_to_json (location_t loc);\n-  json::object *optinfo_to_json (const optinfo *optinfo);\n-  void add_pass_list (json::array *arr, opt_pass *pass);\n-\n-private:\n-  /* The root value for the JSON file.\n-     Currently the JSON values are stored in memory, and flushed when the\n-     compiler exits.  It would probably be better to simply write out\n-     the JSON as we go.  */\n-  json::array *m_root_tuple;\n-\n-  /* The currently open scopes, for expressing nested optimization records.  */\n-  auto_vec<json::array *> m_scopes;\n-};\n-\n /* optrecord_json_writer's ctor.  Populate the top-level parts of the\n    in-memory JSON representation.  */\n \n@@ -471,75 +439,6 @@ optrecord_json_writer::add_pass_list (json::array *arr, opt_pass *pass)\n   while (pass);\n }\n \n-/* File-level interface to rest of compiler (to avoid exposing\n-   class optrecord_json_writer outside of this file).  */\n-\n-static optrecord_json_writer *the_json_writer;\n-\n-/* Perform startup activity for -fsave-optimization-record.  */\n-\n-void\n-optimization_records_start ()\n-{\n-  /* Bail if recording not enabled.  */\n-  if (!flag_save_optimization_record)\n-    return;\n-\n-  the_json_writer = new optrecord_json_writer ();\n-}\n-\n-/* Perform cleanup activity for -fsave-optimization-record.\n-\n-   Currently, the file is written out here in one go, before cleaning\n-   up.  */\n-\n-void\n-optimization_records_finish ()\n-{\n-  /* Bail if recording not enabled.  */\n-  if (!the_json_writer)\n-    return;\n-\n-  the_json_writer->write ();\n-\n-  delete the_json_writer;\n-  the_json_writer = NULL;\n-}\n-\n-/* Did the user request optimization records to be written out?  */\n-\n-bool\n-optimization_records_enabled_p ()\n-{\n-  return the_json_writer != NULL;\n-}\n-\n-/* If optimization records were requested, then add a record for OPTINFO\n-   to the queue of records to be written.  */\n-\n-void\n-optimization_records_maybe_record_optinfo (const optinfo *optinfo)\n-{\n-  /* Bail if recording not enabled.  */\n-  if (!the_json_writer)\n-    return;\n-\n-  the_json_writer->add_record (optinfo);\n-}\n-\n-/* Handling for the end of a dump scope for the\n-   optimization records sink.  */\n-\n-void\n-optimization_records_maybe_pop_dump_scope ()\n-{\n-  /* Bail if recording not enabled.  */\n-  if (!the_json_writer)\n-    return;\n-\n-  the_json_writer->pop_scope ();\n-}\n-\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "2185c08c1e397f73db63663476f5f84b8726d491", "filename": "gcc/optinfo-emit-json.h", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo-emit-json.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo-emit-json.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.h?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -21,16 +21,40 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_OPTINFO_EMIT_JSON_H\n #define GCC_OPTINFO_EMIT_JSON_H\n \n-class optinfo;\n-struct opt_pass;\n-\n-extern void optimization_records_start ();\n-extern void optimization_records_finish ();\n+#include \"json.h\"\n \n-extern bool optimization_records_enabled_p ();\n-\n-extern void optimization_records_maybe_record_optinfo (const optinfo *);\n-extern void optimization_records_maybe_pop_dump_scope ();\n+class optinfo;\n \n+/* A class for writing out optimization records in JSON format.  */\n+\n+class optrecord_json_writer\n+{\n+public:\n+  optrecord_json_writer ();\n+  ~optrecord_json_writer ();\n+  void write () const;\n+  void add_record (const optinfo *optinfo);\n+  void pop_scope ();\n+\n+  void add_record (json::object *obj);\n+  json::object *impl_location_to_json (dump_impl_location_t loc);\n+  json::object *location_to_json (location_t loc);\n+  json::object *profile_count_to_json (profile_count count);\n+  json::string *get_id_value_for_pass (opt_pass *pass);\n+  json::object *pass_to_json (opt_pass *pass);\n+  json::value *inlining_chain_to_json (location_t loc);\n+  json::object *optinfo_to_json (const optinfo *optinfo);\n+  void add_pass_list (json::array *arr, opt_pass *pass);\n+\n+ private:\n+  /* The root value for the JSON file.\n+     Currently the JSON values are stored in memory, and flushed when the\n+     compiler exits.  It would probably be better to simply write out\n+     the JSON as we go.  */\n+  json::array *m_root_tuple;\n+\n+  /* The currently open scopes, for expressing nested optimization records.  */\n+  auto_vec<json::array *> m_scopes;\n+};\n \n #endif /* #ifndef GCC_OPTINFO_EMIT_JSON_H */"}, {"sha": "f8e08dee72f5e518dc1a05e78dfb1b6456e9f255", "filename": "gcc/optinfo.cc", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.cc?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -125,18 +125,7 @@ optinfo::emit_for_opt_problem () const\n     dump_context::get ().emit_item (item, dump_kind);\n \n   /* Re-emit to \"non-immediate\" destinations.  */\n-  emit ();\n-}\n-\n-/* Emit the optinfo to all of the \"non-immediate\" destinations\n-   (emission to \"immediate\" destinations is done by\n-   dump_context::emit_item).  */\n-\n-void\n-optinfo::emit () const\n-{\n-  /* -fsave-optimization-record.  */\n-  optimization_records_maybe_record_optinfo (this);\n+  dump_context::get ().emit_optinfo (this);\n }\n \n /* Update the optinfo's kind based on DUMP_KIND.  */\n@@ -152,21 +141,11 @@ optinfo::handle_dump_file_kind (dump_flags_t dump_kind)\n     m_kind = OPTINFO_KIND_NOTE;\n }\n \n-/* Should optinfo instances be created?\n-   All creation of optinfos should be guarded by this predicate.\n-   Return true if any optinfo destinations are active.  */\n-\n-bool optinfo_enabled_p ()\n-{\n-  return (dump_context::get ().forcibly_enable_optinfo_p ()\n-\t  || optimization_records_enabled_p ());\n-}\n-\n /* Return true if any of the active optinfo destinations make use\n    of inlining information.\n    (if true, then the information is preserved).  */\n \n bool optinfo_wants_inlining_info_p ()\n {\n-  return optimization_records_enabled_p ();\n+  return dump_context::get ().optimization_records_enabled_p ();\n }"}, {"sha": "4a678ff0aa67fd5a139dafb390e5b5792649439d", "filename": "gcc/optinfo.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Foptinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.h?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -68,12 +68,6 @@ along with GCC; see the file COPYING3.  If not see\n struct opt_pass;\n class optinfo_item;\n \n-/* Should optinfo instances be created?\n-   All creation of optinfos should be guarded by this predicate.\n-   Return true if any optinfo destinations are active.  */\n-\n-extern bool optinfo_enabled_p ();\n-\n /* Return true if any of the active optinfo destinations make use\n    of inlining information.\n    (if true, then the information is preserved).  */\n@@ -130,8 +124,6 @@ class optinfo\n   void emit_for_opt_problem () const;\n \n  private:\n-  void emit () const;\n-\n   /* Pre-canned ways of manipulating the optinfo, for use by friend class\n      dump_context.  */\n   void handle_dump_file_kind (dump_flags_t);"}, {"sha": "ab20cd98969f6de687a9d8bee5c253fc1c52c8de", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8d1af516844f94784d9a3a7ffc59f9ab3daa1f5d", "patch": "@@ -83,6 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dumpfile.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"dump-context.h\"\n #include \"optinfo-emit-json.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n@@ -488,7 +489,7 @@ compile_file (void)\n   if (lang_hooks.decls.post_compilation_parsing_cleanups)\n     lang_hooks.decls.post_compilation_parsing_cleanups ();\n \n-  optimization_records_finish ();\n+  dump_context::get ().finish_any_json_writer ();\n \n   if (seen_error ())\n     return;\n@@ -2131,7 +2132,10 @@ do_compile ()\n \n       timevar_start (TV_PHASE_SETUP);\n \n-      optimization_records_start ();\n+      if (flag_save_optimization_record)\n+\t{\n+\t  dump_context::get ().set_json_writer (new optrecord_json_writer ());\n+\t}\n \n       /* This must be run always, because it is needed to compute the FP\n \t predefined macros, such as __LDBL_MAX__, for targets using non"}]}