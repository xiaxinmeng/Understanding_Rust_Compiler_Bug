{"sha": "8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU4NDZjNjY3MGI4NWNkNjlhNTc2MGE2MDRkOGY5Y2UwZGJjMzczMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-05-25T11:11:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-05-25T11:11:12Z"}, "message": "tree-vect-data-refs.c (vect_find_stmt_data_reference): New function, combining stmt data ref gathering and fatal analysis parts.\n\n2018-05-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): New\n\tfunction, combining stmt data ref gathering and fatal analysis\n\tparts.\n\t(vect_analyze_data_refs): Remove now redudnant code and simplify.\n\t* tree-vect-loop.c (vect_get_datarefs_in_loop): Factor out from\n\tvect_analyze_loop_2 and use vect_find_stmt_data_reference.\n\t* tree-vect-slp.c (vect_slp_bb): Use vect_find_stmt_data_reference.\n\t* tree-vectorizer.h (vect_find_stmt_data_reference): Declare.\n\nFrom-SVN: r260754", "tree": {"sha": "4db30c2f8a4c9100b554917beeb46b515cf6af47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db30c2f8a4c9100b554917beeb46b515cf6af47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1623d9f346086582c49cb747c3dabd062e730c42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1623d9f346086582c49cb747c3dabd062e730c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1623d9f346086582c49cb747c3dabd062e730c42"}], "stats": {"total": 392, "additions": 193, "deletions": 199}, "files": [{"sha": "4d8410e9a037af43633ff520ddef890a50fa13f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "patch": "@@ -1,3 +1,14 @@\n+2018-05-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): New\n+\tfunction, combining stmt data ref gathering and fatal analysis\n+\tparts.\n+\t(vect_analyze_data_refs): Remove now redudnant code and simplify.\n+\t* tree-vect-loop.c (vect_get_datarefs_in_loop): Factor out from\n+\tvect_analyze_loop_2 and use vect_find_stmt_data_reference.\n+\t* tree-vect-slp.c (vect_slp_bb): Use vect_find_stmt_data_reference.\n+\t* tree-vectorizer.h (vect_find_stmt_data_reference): Declare.\n+\n 2018-05-25  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/85720"}, {"sha": "65b2366c86dab4c21e934dab345d6ec0ce654a88", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 127, "deletions": 158, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "patch": "@@ -3936,6 +3936,104 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n   return true;\n }\n \n+/* Find the data references in STMT, analyze them with respect to LOOP and\n+   append them to DATAREFS.  Return false if datarefs in this stmt cannot\n+   be handled.  */\n+\n+bool\n+vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n+\t\t\t       vec<data_reference_p> *datarefs)\n+{\n+  /* We can ignore clobbers for dataref analysis - they are removed during\n+     loop vectorization and BB vectorization checks dependences with a\n+     stmt walk.  */\n+  if (gimple_clobber_p (stmt))\n+    return true;\n+\n+  if (gimple_has_volatile_ops (stmt))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: volatile type \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t}\n+      return false;\n+    }\n+\n+  if (stmt_can_throw_internal (stmt))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: statement can throw an \"\n+\t\t\t   \"exception \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t}\n+      return false;\n+    }\n+\n+  auto_vec<data_reference_p, 2> refs;\n+  if (!find_data_references_in_stmt (loop, stmt, &refs))\n+    return false;\n+\n+  if (refs.is_empty ())\n+    return true;\n+\n+  if (refs.length () > 1)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: more than one data ref \"\n+\t\t\t   \"in stmt: \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t}\n+      return false;\n+    }\n+\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    if (!gimple_call_internal_p (call)\n+\t|| (gimple_call_internal_fn (call) != IFN_MASK_LOAD\n+\t    && gimple_call_internal_fn (call) != IFN_MASK_STORE))\n+      {\n+\tif (dump_enabled_p ())\n+\t  {\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n+\t\t\t     \"not vectorized: dr in a call \");\n+\t    dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t  }\n+\treturn false;\n+      }\n+\n+  data_reference_p dr = refs.pop ();\n+  if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"not vectorized: statement is bitfield \"\n+\t\t\t   \"access \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t}\n+      return false;\n+    }\n+\n+  if (DR_BASE_ADDRESS (dr)\n+      && TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: base addr of dr is a \"\n+\t\t\t \"constant\\n\");\n+      return false;\n+    }\n+\n+  datarefs->safe_push (dr);\n+  return true;\n+}\n+\n /* Function vect_analyze_data_refs.\n \n   Find all the data references in the loop or basic block.\n@@ -3974,38 +4072,14 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n     {\n       gimple *stmt;\n       stmt_vec_info stmt_info;\n-      tree base, offset, init;\n       enum { SG_NONE, GATHER, SCATTER } gatherscatter = SG_NONE;\n       bool simd_lane_access = false;\n       poly_uint64 vf;\n \n-again:\n-      if (!dr || !DR_REF (dr))\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                     \"not vectorized: unhandled data-ref\\n\");\n-          return false;\n-        }\n-\n+      gcc_assert (DR_REF (dr));\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n-      /* Discard clobbers from the dataref vector.  We will remove\n-         clobber stmts during vectorization.  */\n-      if (gimple_clobber_p (stmt))\n-\t{\n-\t  free_data_ref (dr);\n-\t  if (i == datarefs.length () - 1)\n-\t    {\n-\t      datarefs.pop ();\n-\t      break;\n-\t    }\n-\t  datarefs.ordered_remove (i);\n-\t  dr = datarefs[i];\n-\t  goto again;\n-\t}\n-\n       /* Check that analysis of the data-ref succeeded.  */\n       if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n \t  || !DR_STEP (dr))\n@@ -4117,95 +4191,42 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t    }\n         }\n \n-      if (TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n-        {\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"not vectorized: base addr of dr is a \"\n-                             \"constant\\n\");\n-\n-          if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n-\n-\t  if (gatherscatter != SG_NONE || simd_lane_access)\n-\t    free_data_ref (dr);\n-\t  return false;\n-        }\n-\n-      if (TREE_THIS_VOLATILE (DR_REF (dr)))\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: volatile type \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-            }\n-\n-          if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n-\n-          return false;\n-        }\n-\n-      if (stmt_can_throw_internal (stmt))\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: statement can throw an \"\n-                               \"exception \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-            }\n-\n-          if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n-\n-\t  if (gatherscatter != SG_NONE || simd_lane_access)\n-\t    free_data_ref (dr);\n-          return false;\n-        }\n-\n-      if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n-\t  && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n+      if (TREE_CODE (DR_BASE_ADDRESS (dr)) == ADDR_EXPR\n+\t  && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (dr), 0))\n+\t  && DECL_NONALIASED (TREE_OPERAND (DR_BASE_ADDRESS (dr), 0)))\n \t{\n           if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: statement is bitfield \"\n-                               \"access \");\n+                               \"not vectorized: base object not addressable \"\n+\t\t\t       \"for stmt: \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n             }\n-\n           if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n-\n-\t  if (gatherscatter != SG_NONE || simd_lane_access)\n-\t    free_data_ref (dr);\n-          return false;\n+\t    {\n+\t      /* In BB vectorization the ref can still participate\n+\t         in dependence analysis, we just can't vectorize it.  */\n+\t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n+\t      continue;\n+\t    }\n+\t  return false;\n \t}\n \n-      base = unshare_expr (DR_BASE_ADDRESS (dr));\n-      offset = unshare_expr (DR_OFFSET (dr));\n-      init = unshare_expr (DR_INIT (dr));\n-\n-      if (is_gimple_call (stmt)\n-\t  && (!gimple_call_internal_p (stmt)\n-\t      || (gimple_call_internal_fn (stmt) != IFN_MASK_LOAD\n-\t\t  && gimple_call_internal_fn (stmt) != IFN_MASK_STORE)))\n+      if (is_a <loop_vec_info> (vinfo)\n+\t  && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n \t{\n-\t  if (dump_enabled_p ())\n+\t  if (nested_in_vect_loop_p (loop, stmt))\n \t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n-\t                       \"not vectorized: dr in a call \");\n-\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                                   \"not vectorized: not suitable for strided \"\n+                                   \"load \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t\t}\n+\t      return false;\n \t    }\n-\n-\t  if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n-\n-\t  if (gatherscatter != SG_NONE || simd_lane_access)\n-\t    free_data_ref (dr);\n-\t  return false;\n+\t  STMT_VINFO_STRIDED_P (stmt_info) = true;\n \t}\n \n       /* Update DR field in stmt_vec_info struct.  */\n@@ -4222,6 +4243,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t     inner loop: *(BASE + INIT + OFFSET).  By construction,\n \t     this address must be invariant in the inner loop, so we\n \t     can consider it as being used in the outer loop.  */\n+\t  tree base = unshare_expr (DR_BASE_ADDRESS (dr));\n+\t  tree offset = unshare_expr (DR_OFFSET (dr));\n+\t  tree init = unshare_expr (DR_INIT (dr));\n \t  tree init_offset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset),\n \t\t\t\t\t  init, offset);\n \t  tree init_addr = fold_build_pointer_plus (base, init_offset);\n@@ -4267,24 +4291,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t    }\n \t}\n \n-      if (STMT_VINFO_DATA_REF (stmt_info))\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: more than one data ref \"\n-                               \"in stmt: \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-            }\n-\n-          if (is_a <bb_vec_info> (vinfo))\n-\t    break;\n-\n-\t  if (gatherscatter != SG_NONE || simd_lane_access)\n-\t    free_data_ref (dr);\n-          return false;\n-        }\n-\n+      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n       STMT_VINFO_DATA_REF (stmt_info) = dr;\n       if (simd_lane_access)\n \t{\n@@ -4293,27 +4300,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  datarefs[i] = dr;\n \t}\n \n-      if (TREE_CODE (DR_BASE_ADDRESS (dr)) == ADDR_EXPR\n-\t  && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (dr), 0))\n-\t  && DECL_NONALIASED (TREE_OPERAND (DR_BASE_ADDRESS (dr), 0)))\n-\t{\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                               \"not vectorized: base object not addressable \"\n-\t\t\t       \"for stmt: \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-            }\n-          if (is_a <bb_vec_info> (vinfo))\n-\t    {\n-\t      /* In BB vectorization the ref can still participate\n-\t         in dependence analysis, we just can't vectorize it.  */\n-\t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-\t      continue;\n-\t    }\n-\t  return false;\n-\t}\n-\n       /* Set vectype for STMT.  */\n       scalar_type = TREE_TYPE (DR_REF (dr));\n       STMT_VINFO_VECTYPE (stmt_info)\n@@ -4391,23 +4377,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  datarefs[i] = dr;\n \t  STMT_VINFO_GATHER_SCATTER_P (stmt_info) = gatherscatter;\n \t}\n-\n-      else if (is_a <loop_vec_info> (vinfo)\n-\t       && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n-\t{\n-\t  if (nested_in_vect_loop_p (loop, stmt))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                   \"not vectorized: not suitable for strided \"\n-                                   \"load \");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  STMT_VINFO_STRIDED_P (stmt_info) = true;\n-\t}\n     }\n \n   /* If we stopped analysis at the first dataref we could not analyze"}, {"sha": "c49e1c55102d4293fae4f31cf8b00efb333aa3a4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "patch": "@@ -1774,50 +1774,21 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n   return 1;\n }\n \n-\n-/* Function vect_analyze_loop_2.\n-\n-   Apply a set of analyses on LOOP, and create a loop_vec_info struct\n-   for it.  The different analyses will record information in the\n-   loop_vec_info struct.  */\n static bool\n-vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n+vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n+\t\t\t   vec<data_reference_p> *datarefs,\n+\t\t\t   unsigned int *n_stmts)\n {\n-  bool ok;\n-  int res;\n-  unsigned int max_vf = MAX_VECTORIZATION_FACTOR;\n-  poly_uint64 min_vf = 2;\n-  unsigned int n_stmts = 0;\n-\n-  /* The first group of checks is independent of the vector size.  */\n-  fatal = true;\n-\n-  /* Find all data references in the loop (which correspond to vdefs/vuses)\n-     and analyze their evolution in the loop.  */\n-\n-  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-\n-  loop_p loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: loop nest containing two \"\n-\t\t\t \"or more consecutive inner loops cannot be \"\n-\t\t\t \"vectorized\\n\");\n-      return false;\n-    }\n-\n+  *n_stmts = 0;\n   for (unsigned i = 0; i < loop->num_nodes; i++)\n     for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n \t !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n \tgimple *stmt = gsi_stmt (gsi);\n \tif (is_gimple_debug (stmt))\n \t  continue;\n-\t++n_stmts;\n-\tif (!find_data_references_in_stmt (loop, stmt,\n-\t\t\t\t\t   &LOOP_VINFO_DATAREFS (loop_vinfo)))\n+\t++(*n_stmts);\n+\tif (!vect_find_stmt_data_reference (loop, stmt, datarefs))\n \t  {\n \t    if (is_gimple_call (stmt) && loop->safelen)\n \t      {\n@@ -1849,14 +1820,55 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t\t      }\n \t\t  }\n \t      }\n-\t    if (dump_enabled_p ())\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"not vectorized: loop contains function \"\n-\t\t\t       \"calls or data references that cannot \"\n-\t\t\t       \"be analyzed\\n\");\n \t    return false;\n \t  }\n       }\n+  return true;\n+}\n+\n+/* Function vect_analyze_loop_2.\n+\n+   Apply a set of analyses on LOOP, and create a loop_vec_info struct\n+   for it.  The different analyses will record information in the\n+   loop_vec_info struct.  */\n+static bool\n+vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n+{\n+  bool ok;\n+  int res;\n+  unsigned int max_vf = MAX_VECTORIZATION_FACTOR;\n+  poly_uint64 min_vf = 2;\n+\n+  /* The first group of checks is independent of the vector size.  */\n+  fatal = true;\n+\n+  /* Find all data references in the loop (which correspond to vdefs/vuses)\n+     and analyze their evolution in the loop.  */\n+\n+  loop_p loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: loop nest containing two \"\n+\t\t\t \"or more consecutive inner loops cannot be \"\n+\t\t\t \"vectorized\\n\");\n+      return false;\n+    }\n+\n+  /* Gather the data references and count stmts in the loop.  */\n+  unsigned int n_stmts;\n+  if (!vect_get_datarefs_in_loop (loop, LOOP_VINFO_BBS (loop_vinfo),\n+\t\t\t\t  &LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t\t\t\t  &n_stmts))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: loop contains function \"\n+\t\t\t \"calls or data references that cannot \"\n+\t\t\t \"be analyzed\\n\");\n+      return false;\n+    }\n \n   /* Analyze the data references and also adjust the minimal\n      vectorization factor according to the loads and stores.  */"}, {"sha": "0a96a9379a26839e4feb16166744445d3cdb84b9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "patch": "@@ -3011,7 +3011,7 @@ vect_slp_bb (basic_block bb)\n \t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n \t    vect_location = gimple_location (stmt);\n \n-\t  if (!find_data_references_in_stmt (NULL, stmt, &datarefs))\n+\t  if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs))\n \t    break;\n \t}\n "}, {"sha": "ef8b69512179b2f26e99dfedb9bca1a360dd6d12", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e846c6670b85cd69a5760a604d8f9ce0dbc3730/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=8e846c6670b85cd69a5760a604d8f9ce0dbc3730", "patch": "@@ -1495,6 +1495,8 @@ extern bool vect_gather_scatter_fn_p (bool, bool, tree, tree, unsigned int,\n \t\t\t\t      signop, int, internal_fn *, tree *);\n extern bool vect_check_gather_scatter (gimple *, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n+extern bool vect_find_stmt_data_reference (loop_p, gimple *,\n+\t\t\t\t\t   vec<data_reference_p> *);\n extern bool vect_analyze_data_refs (vec_info *, poly_uint64 *);\n extern void vect_record_base_alignments (vec_info *);\n extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,"}]}