{"sha": "bb6a1ebb8585b85879735d0d6df9535885fad165", "node_id": "C_kwDOANBUbNoAKGJiNmExZWJiODU4NWI4NTg3OTczNWQwZDZkZjk1MzU4ODVmYWQxNjU", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2021-12-09T21:57:13Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2021-12-10T17:53:09Z"}, "message": "Fortran: fix check for pointer dummy arguments with INTENT(IN)\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/103418\n\t* check.c (variable_check): Replace previous check of procedure\n\tdummy arguments with INTENT(IN) attribute when passed to intrinsic\n\tprocedures by gfc_check_vardef_context.\n\t* expr.c (gfc_check_vardef_context): Correct check of INTENT(IN)\n\tdummy arguments for the case of sub-components of a CLASS pointer.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/103418\n\t* gfortran.dg/move_alloc_8.f90: Adjust error messages.\n\t* gfortran.dg/pointer_intent_9.f90: New test.", "tree": {"sha": "f9c186dabaacf7ae6f1f7693c2e1c5e06ab42971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9c186dabaacf7ae6f1f7693c2e1c5e06ab42971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb6a1ebb8585b85879735d0d6df9535885fad165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6a1ebb8585b85879735d0d6df9535885fad165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6a1ebb8585b85879735d0d6df9535885fad165", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6a1ebb8585b85879735d0d6df9535885fad165/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "982a2c9b7866558039df61b0596caad57c94c8c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/982a2c9b7866558039df61b0596caad57c94c8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/982a2c9b7866558039df61b0596caad57c94c8c4"}], "stats": {"total": 78, "additions": 47, "deletions": 31}, "files": [{"sha": "3934336df2e8251dffc65622fbd8b20d28fc2c73", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=bb6a1ebb8585b85879735d0d6df9535885fad165", "patch": "@@ -1011,33 +1011,13 @@ variable_check (gfc_expr *e, int n, bool allow_proc)\n   if (e->expr_type == EXPR_VARIABLE\n       && e->symtree->n.sym->attr.intent == INTENT_IN\n       && (gfc_current_intrinsic_arg[n]->intent == INTENT_OUT\n-\t  || gfc_current_intrinsic_arg[n]->intent == INTENT_INOUT))\n+\t  || gfc_current_intrinsic_arg[n]->intent == INTENT_INOUT)\n+      && !gfc_check_vardef_context (e, false, true, false, NULL))\n     {\n-      gfc_ref *ref;\n-      bool pointer = e->symtree->n.sym->ts.type == BT_CLASS\n-\t\t     && CLASS_DATA (e->symtree->n.sym)\n-\t\t     ? CLASS_DATA (e->symtree->n.sym)->attr.class_pointer\n-\t\t     : e->symtree->n.sym->attr.pointer;\n-\n-      for (ref = e->ref; ref; ref = ref->next)\n-\t{\n-\t  if (pointer && ref->type == REF_COMPONENT)\n-\t    break;\n-\t  if (ref->type == REF_COMPONENT\n-\t      && ((ref->u.c.component->ts.type == BT_CLASS\n-\t\t   && CLASS_DATA (ref->u.c.component)->attr.class_pointer)\n-\t\t  || (ref->u.c.component->ts.type != BT_CLASS\n-\t\t      && ref->u.c.component->attr.pointer)))\n-\t    break;\n-\t}\n-\n-      if (!ref)\n-\t{\n-\t  gfc_error (\"%qs argument of %qs intrinsic at %L cannot be \"\n-\t\t     \"INTENT(IN)\", gfc_current_intrinsic_arg[n]->name,\n-\t\t     gfc_current_intrinsic, &e->where);\n-\t  return false;\n-\t}\n+      gfc_error (\"%qs argument of %qs intrinsic at %L cannot be INTENT(IN)\",\n+\t\t gfc_current_intrinsic_arg[n]->name,\n+\t\t gfc_current_intrinsic, &e->where);\n+      return false;\n     }\n \n   if (e->expr_type == EXPR_VARIABLE"}, {"sha": "b874607db1d23ec0f513a9aa16abb96cb335fc32", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=bb6a1ebb8585b85879735d0d6df9535885fad165", "patch": "@@ -6254,10 +6254,13 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n     {\n       if (ptr_component && ref->type == REF_COMPONENT)\n \tcheck_intentin = false;\n-      if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n+      if (ref->type == REF_COMPONENT)\n \t{\n-\t  ptr_component = true;\n-\t  if (!pointer)\n+\t  gfc_component *comp = ref->u.c.component;\n+\t  ptr_component = (comp->ts.type == BT_CLASS && comp->attr.class_ok)\n+\t\t\t? CLASS_DATA (comp)->attr.class_pointer\n+\t\t\t: comp->attr.pointer;\n+\t  if (ptr_component && !pointer)\n \t    check_intentin = false;\n \t}\n       if (ref->type == REF_INQUIRY"}, {"sha": "d968ea0e5cd021be9cecef23c15f3ea6448ef922", "filename": "gcc/testsuite/gfortran.dg/move_alloc_8.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_8.f90?ref=bb6a1ebb8585b85879735d0d6df9535885fad165", "patch": "@@ -60,7 +60,7 @@ subroutine test2 (x, px)\n   integer, allocatable :: a\n   type(t2), pointer :: ta\n \n-  call move_alloc (px, ta)      ! { dg-error \"cannot be INTENT.IN.\" }\n+  call move_alloc (px, ta)      ! { dg-error \"must be ALLOCATABLE\" }\n   call move_alloc (x%a, a)      ! { dg-error \"cannot be INTENT.IN.\" }\n   call move_alloc (x%ptr%a, a)  ! OK (3)\n   call move_alloc (px%a, a)     ! OK (4)\n@@ -84,7 +84,7 @@ subroutine test3 (x, px)\n   integer, allocatable :: a\n   class(t2), pointer :: ta\n \n-  call move_alloc (px, ta)      ! { dg-error \"cannot be INTENT.IN.\" }\n+  call move_alloc (px, ta)      ! { dg-error \"must be ALLOCATABLE\" }\n   call move_alloc (x%a, a)      ! { dg-error \"cannot be INTENT.IN.\" }\n   call move_alloc (x%ptr%a, a)  ! OK (6)\n   call move_alloc (px%a, a)     ! OK (7)"}, {"sha": "30ddd0283597f4ca0dbf3ce087e08f81557e1d1e", "filename": "gcc/testsuite/gfortran.dg/pointer_intent_9.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6a1ebb8585b85879735d0d6df9535885fad165/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_9.f90?ref=bb6a1ebb8585b85879735d0d6df9535885fad165", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! PR fortran/103418\n+! Validate checks for dummy arguments with INTENT(IN), pointer attribute\n+\n+module m\n+  type t\n+     real, pointer :: a, b(:)\n+  end type t\n+contains\n+  subroutine s1 (a, b, c, d, e)\n+    real,    pointer, intent(in) :: a, b(:)\n+    type(t),          intent(in) :: c\n+    class(t),         intent(in) :: d\n+    type(t), pointer, intent(in) :: e\n+    real, pointer :: pa, pb(:)\n+    call random_number (a)    ! legal\n+    call random_number (b)\n+    call cpu_time      (a)\n+    call system_clock  (count_rate=a)\n+    call random_number (c% a)\n+    call random_number (c% b)\n+    call random_number (d% a)\n+    call random_number (d% b)\n+    call random_number (e% a)\n+    call random_number (e% b)\n+    call move_alloc (a, pa)   ! { dg-error \"must be ALLOCATABLE\" }\n+    call move_alloc (b, pb)   ! { dg-error \"must be ALLOCATABLE\" }\n+    allocate (a)              ! { dg-error \"pointer association context\" }\n+    allocate (b(10))          ! { dg-error \"pointer association context\" }\n+    allocate (c% a)           ! { dg-error \"pointer association context\" }\n+    allocate (c% b(10))       ! { dg-error \"pointer association context\" }\n+  end subroutine s1\n+end module"}]}