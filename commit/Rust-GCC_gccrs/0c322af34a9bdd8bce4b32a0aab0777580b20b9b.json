{"sha": "0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzMjJhZjM0YTliZGQ4YmNlNGIzMmEwYWFiMDc3NzU4MGIyMGI5Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-07-14T18:16:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-07-14T18:16:48Z"}, "message": "tree-gimple.c (is_gimple_reg_rhs, [...]): New fns.\n\n        * tree-gimple.c (is_gimple_reg_rhs, is_gimple_mem_rhs): New fns.\n        (rhs_test_for): New fn.\n        (is_gimple_tmp_rhs): Rename from is_gimple_rhs.\n        * tree-gimple.h: Declare them.\n        * gimplify.c (gimplify_modify_expr): Use the new fns.\n\nFrom-SVN: r84696", "tree": {"sha": "2cec016794db7f4edc897fa4b5d68c8d7bb1ec15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cec016794db7f4edc897fa4b5d68c8d7bb1ec15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ac5ea7c80dd6f688952560fc425c6b06d6c3c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac5ea7c80dd6f688952560fc425c6b06d6c3c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac5ea7c80dd6f688952560fc425c6b06d6c3c94"}], "stats": {"total": 113, "additions": 80, "deletions": 33}, "files": [{"sha": "1e179dddd30de4b2652a05c69023c4e8041b5447", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "patch": "@@ -1,3 +1,11 @@\n+2004-07-13  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree-gimple.c (is_gimple_reg_rhs, is_gimple_mem_rhs): New fns.\n+\t(rhs_test_for): New fn.\n+\t(is_gimple_tmp_rhs): Rename from is_gimple_rhs.\n+\t* tree-gimple.h: Declare them.\n+\t* gimplify.c (gimplify_modify_expr): Use the new fns.\n+\n 2004-07-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/arm/arm-protos.h (arm_va_arg): Remove."}, {"sha": "d1b9618f059526c4c1477aa5936bacb6867412b4", "filename": "gcc/gimplify.c", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "patch": "@@ -446,7 +446,7 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n   tree t, mod;\n   char class;\n \n-  gimplify_expr (&val, pre_p, post_p, is_gimple_rhs, fb_rvalue);\n+  gimplify_expr (&val, pre_p, post_p, is_gimple_tmp_rhs, fb_rvalue);\n \n   t = lookup_tmp_var (val, is_formal);\n \n@@ -2610,7 +2610,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    ctor = build (COMPLEX_EXPR, type, r, i);\n \t    TREE_OPERAND (*expr_p, 1) = ctor;\n \t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n-\t\t\t\t is_gimple_rhs, fb_rvalue);\n+\t\t\t\t is_gimple_tmp_rhs, fb_rvalue);\n \t  }\n       }\n       break;\n@@ -2780,7 +2780,8 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   if (ret == GS_ERROR)\n     return ret;\n \n-  ret = gimplify_expr (from_p, pre_p, post_p, is_gimple_rhs, fb_rvalue);\n+  ret = gimplify_expr (from_p, pre_p, post_p,\n+\t\t       rhs_predicate_for (*to_p), fb_rvalue);\n   if (ret == GS_ERROR)\n     return ret;\n \n@@ -2791,33 +2792,10 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n     return ret;\n \n   /* If the destination is already simple, nothing else needed.  */\n-  if (is_gimple_tmp_var (*to_p))\n+  if (is_gimple_tmp_var (*to_p) || !want_value)\n     ret = GS_ALL_DONE;\n   else\n-    {\n-      /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto and\n-\t the LHS is a user variable, then we need to introduce a temporary.\n-\t ie temp = RHS; LHS = temp.\n-\n-\t This way the optimizers can determine that the user variable is\n-\t only modified if evaluation of the RHS does not throw.\n-\n-\t FIXME this should be handled by the is_gimple_rhs predicate.  */\n-\n-      if (aggregate_value_p (TREE_TYPE (*from_p), NULL_TREE))\n-\t/* Don't force a temp of a large aggregate type; the copy could be\n-\t   arbitrarily expensive.  Instead we will generate a V_MAY_DEF for\n-\t   the assignment.  */;\n-      else if (TREE_CODE (*from_p) == CALL_EXPR\n-\t       || (flag_non_call_exceptions && tree_could_trap_p (*from_p))\n-\t       /* If we're dealing with a renamable type, either source or dest\n-\t\t  must be a renamed variable.  */\n-\t       || (is_gimple_reg_type (TREE_TYPE (*from_p))\n-\t\t   && !is_gimple_reg (*to_p)))\n-\tgimplify_expr (from_p, pre_p, post_p, is_gimple_val, fb_rvalue);\n-\n-      ret = want_value ? GS_OK : GS_ALL_DONE;\n-    }\n+    ret = GS_OK;\n \n   if (want_value)\n     {\n@@ -3975,7 +3953,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       gimplify_expr (&tmp, pre_p, post_p, is_gimple_reg, fb_rvalue);\n       *expr_p = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (tmp)), tmp);\n     }\n-  else if ((fallback & fb_rvalue) && is_gimple_rhs (*expr_p))\n+  else if ((fallback & fb_rvalue) && is_gimple_tmp_rhs (*expr_p))\n     {\n #if defined ENABLE_CHECKING\n       if (VOID_TYPE_P (TREE_TYPE (*expr_p)))"}, {"sha": "193f093a8e34d290144d58512d77cbac8b8c5342", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-flow.h\"\n #include \"output.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n@@ -172,10 +173,10 @@ static inline bool is_gimple_id (tree);\n \n /* Validation of GIMPLE expressions.  */\n \n-/* Return true if T is a GIMPLE RHS.  */\n+/* Return true if T is a GIMPLE RHS for an assignment to a temporary.  */\n \n bool\n-is_gimple_rhs (tree t)\n+is_gimple_tmp_rhs (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n \n@@ -217,6 +218,57 @@ is_gimple_rhs (tree t)\n   return is_gimple_lvalue (t) || is_gimple_val (t);\n }\n \n+/* Returns true iff T is a valid RHS for an assignment to a renamed user\n+   variable.  */\n+\n+bool\n+is_gimple_reg_rhs (tree t)\n+{\n+  /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto and\n+     the LHS is a user variable, then we need to introduce a temporary.\n+     ie temp = RHS; LHS = temp.\n+\n+     This way the optimizers can determine that the user variable is\n+     only modified if evaluation of the RHS does not throw.  */\n+  if (is_gimple_reg_type (TREE_TYPE (t))\n+      && TREE_SIDE_EFFECTS (t)\n+      && (TREE_CODE (t) == CALL_EXPR\n+\t  || (flag_non_call_exceptions && tree_could_trap_p (t))))\n+    return is_gimple_val (t);\n+  else\n+    /* Don't force a temp of a non-renamable type; the copy could be\n+       arbitrarily expensive.  Instead we will generate a V_MAY_DEF for\n+       the assignment.  */\n+    return is_gimple_tmp_rhs (t);\n+}\n+\n+/* Returns true iff T is a valid RHS for an assignment to an un-renamed\n+   LHS, or for a call argument.  */\n+\n+bool\n+is_gimple_mem_rhs (tree t)\n+{\n+  /* If we're dealing with a renamable type, either source or dest\n+     must be a renamed variable.  */\n+  if (is_gimple_reg_type (TREE_TYPE (t)))\n+    return is_gimple_val (t);\n+  else\n+    return is_gimple_tmp_rhs (t);\n+}\n+\n+/* Returns the appropriate RHS predicate for this LHS.  */\n+\n+gimple_predicate\n+rhs_predicate_for (tree lhs)\n+{\n+  if (is_gimple_tmp_var (lhs))\n+    return is_gimple_tmp_rhs;\n+  else if (is_gimple_reg (lhs))\n+    return is_gimple_reg_rhs;\n+  else\n+    return is_gimple_mem_rhs;\n+}\n+\n /* Returns true if T is a valid CONSTRUCTOR component in GIMPLE, either\n    a val or another CONSTRUCTOR.  */\n "}, {"sha": "32647a002b89d3020769810763e3368c73f8db8d", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c322af34a9bdd8bce4b32a0aab0777580b20b9b/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "patch": "@@ -39,6 +39,8 @@ extern void annotate_all_with_locus (tree *, location_t);\n    the basic form of the expression, they don't recurse to make sure that\n    underlying nodes are also of the right form.  */\n \n+typedef bool (*gimple_predicate)(tree);\n+\n /* Returns true iff T is a valid GIMPLE statement.  */\n extern bool is_gimple_stmt (tree);\n \n@@ -59,8 +61,15 @@ extern bool is_gimple_lvalue (tree);\n extern bool is_gimple_min_invariant (tree);\n /* Returns true iff T is a GIMPLE rvalue.  */\n extern bool is_gimple_val (tree);\n-/* Returns true iff T is a valid rhs for a MODIFY_EXPR.  */\n-extern bool is_gimple_rhs (tree);\n+/* Returns true iff T is a valid rhs for a MODIFY_EXPR where the LHS is a\n+   GIMPLE temporary, a renamed user variable, or something else,\n+   respectively.  */\n+extern bool is_gimple_tmp_rhs (tree);\n+extern bool is_gimple_reg_rhs (tree);\n+extern bool is_gimple_mem_rhs (tree);\n+/* Returns the appropriate one of the above three predicates for the LHS\n+   T.  */\n+extern gimple_predicate rhs_predicate_for (tree);\n \n /* Returns true iff T is a valid if-statement condition.  */\n extern bool is_gimple_condexpr (tree);"}]}