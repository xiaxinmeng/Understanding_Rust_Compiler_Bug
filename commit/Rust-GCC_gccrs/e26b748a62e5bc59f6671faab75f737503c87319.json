{"sha": "e26b748a62e5bc59f6671faab75f737503c87319", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI2Yjc0OGE2MmU1YmM1OWY2NjcxZmFhYjc1ZjczNzUwM2M4NzMxOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-28T17:18:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T10:41:20Z"}, "message": "Fix signedness issue in DWARF functions (1)\n\nThe compiler can synthesize DWARF functions to describe the location and\nsize of components in discriminated record types with variant part in Ada,\nbut a limitation is that most quantities must have DWARF2_ADDR_SIZE or\nelse be the result of a zero-extension to DWARF2_ADDR_SIZE of a smaller\nquantity, as documented in loc_list_from_tree_1:\n\n  /* ??? Most of the time we do not take proper care for sign/zero\n     extending the values properly.  Hopefully this won't be a real\n     problem...  */\n\nIn Ada discriminants may be either signed or unsigned, so this limitation\nis problematic.  Therefore the attached patch adds a strict_signedness\nfield to the loc_descr_context that is passed around in parts of the DWARF\nback-end and changes loc_list_from_tree_1 to act upon it being set to true.\nIt also contains an optimization to avoid emitting useless comparisons.\n\ngcc/\n\t* dwarf2out.c (scompare_loc_descriptor): Fix head comment.\n\t(is_handled_procedure_type): Likewise.\n\t(struct loc_descr_context): Add strict_signedness field.\n\t(resolve_args_picking_1): Deal with DW_OP_[GNU_]deref_type,\n\tDW_OP_[GNU_]convert and DW_OP_[GNU_]reinterpret.\n\t(resolve_args_picking): Minor tweak.\n\t(function_to_dwarf_procedure): Initialize strict_signedness field.\n\t(type_byte_size): Likewise.\n\t(field_byte_offset): Likewise.\n\t(gen_descr_array_type_die): Likewise.\n\t(gen_variant_part): Likewise.\n\t(loc_list_from_tree_1) <CALL_EXPR>: Tidy up and set strict_signedness\n\tto true when a context is present before evaluating the arguments.\n\t<COND_EXPR>: Do not generate a useless comparison with zero.\n\tWhen dereferencing an address, if strict_signedness is true and the\n\ttype is small and signed, use DW_OP_deref_type to do the dereference\n\tand then DW_OP_convert to convert back to the generic type.", "tree": {"sha": "608cb78d94fa4cfef5b80576636720c70edab601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/608cb78d94fa4cfef5b80576636720c70edab601"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e26b748a62e5bc59f6671faab75f737503c87319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26b748a62e5bc59f6671faab75f737503c87319", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e26b748a62e5bc59f6671faab75f737503c87319", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26b748a62e5bc59f6671faab75f737503c87319/comments", "author": null, "committer": null, "parents": [{"sha": "d9a83b99349071e1c6e78df7fea3424338390d5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a83b99349071e1c6e78df7fea3424338390d5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9a83b99349071e1c6e78df7fea3424338390d5e"}], "stats": {"total": 203, "additions": 124, "deletions": 79}, "files": [{"sha": "fbda47ec9773227e6497c072629d2f7b69f683e9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 124, "deletions": 79, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e26b748a62e5bc59f6671faab75f737503c87319/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e26b748a62e5bc59f6671faab75f737503c87319/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e26b748a62e5bc59f6671faab75f737503c87319", "patch": "@@ -15176,7 +15176,7 @@ scompare_loc_descriptor_narrow (enum dwarf_location_atom op, rtx rtl,\n   return compare_loc_descriptor (op, op0, op1);\n }\n \n-/* Return location descriptor for unsigned comparison OP RTL.  */\n+/* Return location descriptor for signed comparison OP RTL.  */\n \n static dw_loc_descr_ref\n scompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,\n@@ -17994,6 +17994,8 @@ struct loc_descr_context\n   bool placeholder_arg;\n   /* True if PLACEHOLDER_EXPR has been seen.  */\n   bool placeholder_seen;\n+  /* True if strict preservation of signedness has been requested.  */\n+  bool strict_signedness;\n };\n \n /* DWARF procedures generation\n@@ -18062,7 +18064,7 @@ new_dwarf_proc_die (dw_loc_descr_ref location, tree fndecl,\n \n /* Return whether TYPE is a supported type as a DWARF procedure argument\n    type or return type (we handle only scalar types and pointer types that\n-   aren't wider than the DWARF expression evaluation stack.  */\n+   aren't wider than the DWARF expression evaluation stack).  */\n \n static bool\n is_handled_procedure_type (tree type)\n@@ -18204,6 +18206,12 @@ resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n \tcase DW_OP_bit_piece:\n \tcase DW_OP_implicit_value:\n \tcase DW_OP_stack_value:\n+\tcase DW_OP_deref_type:\n+\tcase DW_OP_convert:\n+\tcase DW_OP_reinterpret:\n+\tcase DW_OP_GNU_deref_type:\n+\tcase DW_OP_GNU_convert:\n+\tcase DW_OP_GNU_reinterpret:\n \t  break;\n \n \tcase DW_OP_addr:\n@@ -18335,9 +18343,6 @@ resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n \tcase DW_OP_entry_value:\n \tcase DW_OP_const_type:\n \tcase DW_OP_regval_type:\n-\tcase DW_OP_deref_type:\n-\tcase DW_OP_convert:\n-\tcase DW_OP_reinterpret:\n \tcase DW_OP_form_tls_address:\n \tcase DW_OP_GNU_push_tls_address:\n \tcase DW_OP_GNU_uninit:\n@@ -18346,9 +18351,6 @@ resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n \tcase DW_OP_GNU_entry_value:\n \tcase DW_OP_GNU_const_type:\n \tcase DW_OP_GNU_regval_type:\n-\tcase DW_OP_GNU_deref_type:\n-\tcase DW_OP_GNU_convert:\n-\tcase DW_OP_GNU_reinterpret:\n \tcase DW_OP_GNU_parameter_ref:\n \t  /* loc_list_from_tree will probably not output these operations for\n \t     size functions, so assume they will not appear here.  */\n@@ -18397,8 +18399,8 @@ resolve_args_picking (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n      this operation.  */\n   hash_map<dw_loc_descr_ref, unsigned> frame_offsets;\n \n-  return resolve_args_picking_1 (loc, initial_frame_offset, dpi,\n-\t\t\t\t frame_offsets);\n+  return\n+    resolve_args_picking_1 (loc, initial_frame_offset, dpi, frame_offsets);\n }\n \n /* Try to generate a DWARF procedure that computes the same result as FNDECL.\n@@ -18407,8 +18409,15 @@ resolve_args_picking (dw_loc_descr_ref loc, unsigned initial_frame_offset,\n static dw_die_ref\n function_to_dwarf_procedure (tree fndecl)\n {\n-  struct loc_descr_context ctx;\n   struct dwarf_procedure_info dpi;\n+  struct loc_descr_context ctx = {\n+    NULL_TREE,\t/* context_type */\n+    NULL_TREE,\t/* base_decl */\n+    &dpi,\t/* dpi */\n+    false,      /* placeholder_arg */\n+    false,      /* placeholder_seen */\n+    true\t/* strict_signedness */\n+  };\n   dw_die_ref dwarf_proc_die;\n   tree tree_body = DECL_SAVED_TREE (fndecl);\n   dw_loc_descr_ref loc_body, epilogue;\n@@ -18453,11 +18462,6 @@ function_to_dwarf_procedure (tree fndecl)\n      cause an infinite recursion if its call graph has a cycle.  This is very\n      unlikely for size functions, however, so don't bother with such things at\n      the moment.  */\n-  ctx.context_type = NULL_TREE;\n-  ctx.base_decl = NULL_TREE;\n-  ctx.dpi = &dpi;\n-  ctx.placeholder_arg = false;\n-  ctx.placeholder_seen = false;\n   dpi.fndecl = fndecl;\n   dpi.args_count = list_length (DECL_ARGUMENTS (fndecl));\n   loc_body = loc_descriptor_from_tree (tree_body, 0, &ctx);\n@@ -18586,47 +18590,48 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \n     case CALL_EXPR:\n \t{\n-\t  const int nargs = call_expr_nargs (loc);\n \t  tree callee = get_callee_fndecl (loc);\n-\t  int i;\n \t  dw_die_ref dwarf_proc;\n \n-\t  if (callee == NULL_TREE)\n-\t    goto call_expansion_failed;\n-\n-\t  /* We handle only functions that return an integer.  */\n-\t  if (!is_handled_procedure_type (TREE_TYPE (TREE_TYPE (callee))))\n-\t    goto call_expansion_failed;\n-\n-\t  dwarf_proc = function_to_dwarf_procedure (callee);\n-\t  if (dwarf_proc == NULL)\n-\t    goto call_expansion_failed;\n-\n-\t  /* Evaluate arguments right-to-left so that the first argument will\n-\t     be the top-most one on the stack.  */\n-\t  for (i = nargs - 1; i >= 0; --i)\n+\t  if (callee\n+\t      && is_handled_procedure_type (TREE_TYPE (TREE_TYPE (callee)))\n+\t      && (dwarf_proc = function_to_dwarf_procedure (callee)))\n \t    {\n-\t      dw_loc_descr_ref loc_descr\n-\t        = loc_descriptor_from_tree (CALL_EXPR_ARG (loc, i), 0,\n-\t\t\t\t\t    context);\n+\t      /* DWARF procedures are used for size functions, which are built\n+\t\t when size expressions contain conditional constructs, so we\n+\t\t request strict preservation of signedness for comparisons.  */\n+\t      bool old_strict_signedness;\n+\t      if (context)\n+\t\t{\n+\t\t  old_strict_signedness = context->strict_signedness;\n+\t\t  context->strict_signedness = true;\n+\t\t}\n \n-\t      if (loc_descr == NULL)\n-\t\tgoto call_expansion_failed;\n+\t      /* Evaluate arguments right-to-left so that the first argument\n+\t\t will be the top-most one on the stack.  */\n+\t      for (int i = call_expr_nargs (loc) - 1; i >= 0; --i)\n+\t\t{\n+\t\t  tree arg = CALL_EXPR_ARG (loc, i);\n+\t\t  ret1 = loc_descriptor_from_tree (arg, 0, context);\n+\t\t  if (!ret1)\n+\t\t    {\n+\t\t      expansion_failed (arg, NULL_RTX, \"CALL_EXPR argument\");\n+\t\t      return NULL;\n+\t\t    }\n+\t\t  add_loc_descr (&ret, ret1);\n+\t\t}\n \n-\t      add_loc_descr (&ret, loc_descr);\n+\t      ret1 = new_loc_descr (DW_OP_call4, 0, 0);\n+\t      ret1->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      ret1->dw_loc_oprnd1.v.val_die_ref.die = dwarf_proc;\n+\t      ret1->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t      add_loc_descr (&ret, ret1);\n+\t      if (context)\n+\t\tcontext->strict_signedness = old_strict_signedness;\n \t    }\n-\n-\t  ret1 = new_loc_descr (DW_OP_call4, 0, 0);\n-\t  ret1->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n-\t  ret1->dw_loc_oprnd1.v.val_die_ref.die = dwarf_proc;\n-\t  ret1->dw_loc_oprnd1.v.val_die_ref.external = 0;\n-\t  add_loc_descr (&ret, ret1);\n+\t  else\n+\t    expansion_failed (loc, NULL_RTX, \"CALL_EXPR target\");\n \t  break;\n-\n-\tcall_expansion_failed:\n-\t  expansion_failed (loc, NULL_RTX, \"CALL_EXPR\");\n-\t  /* There are no opcodes for these operations.  */\n-\t  return 0;\n \t}\n \n     case PREINCREMENT_EXPR:\n@@ -19286,7 +19291,14 @@ loc_list_from_tree_1 (tree loc, int want_address,\n \t  = loc_list_from_tree_1 (TREE_OPERAND (loc, 2), 0, context);\n \tdw_loc_descr_ref bra_node, jump_node, tmp;\n \n-\tlist_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n+\t/* DW_OP_bra is branch-on-nonzero so avoid doing useless work.  */\n+\tif (TREE_CODE (TREE_OPERAND (loc, 0)) == NE_EXPR\n+\t    && integer_zerop (TREE_OPERAND (TREE_OPERAND (loc, 0), 1)))\n+\t  list_ret\n+\t    = loc_list_from_tree_1 (TREE_OPERAND (TREE_OPERAND (loc, 0), 0),\n+\t\t\t\t    0, context);\n+\telse\n+\t  list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);\n \tif (list_ret == 0 || lhs == 0 || rhs == 0)\n \t  return 0;\n \n@@ -19366,23 +19378,50 @@ loc_list_from_tree_1 (tree loc, int want_address,\n   if (!want_address && have_address)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));\n+      enum machine_mode mode = TYPE_MODE (TREE_TYPE (loc));\n+      scalar_int_mode int_mode;\n+      dw_die_ref type_die;\n+      dw_loc_descr_ref deref;\n \n+      /* If the size is greater than DWARF2_ADDR_SIZE, bail out.  */\n       if (size > DWARF2_ADDR_SIZE || size == -1)\n \t{\n \t  expansion_failed (loc, NULL_RTX,\n \t\t\t    \"DWARF address size mismatch\");\n \t  return 0;\n \t}\n+\n+      /* If it is equal to DWARF2_ADDR_SIZE, extension does not matter.  */\n       else if (size == DWARF2_ADDR_SIZE)\n-\top = DW_OP_deref;\n+\tderef = new_loc_descr (DW_OP_deref, size, 0);\n+\n+      /* If it is lower than DWARF2_ADDR_SIZE, DW_OP_deref_size will zero-\n+\t extend the value, which is really OK for unsigned types only.  */\n+      else if (!(context && context->strict_signedness)\n+\t       || TYPE_UNSIGNED (TREE_TYPE (loc))\n+\t       || (dwarf_strict && dwarf_version < 5)\n+\t       || !is_a <scalar_int_mode> (mode, &int_mode)\n+\t       || !(type_die = base_type_for_mode (mode, false)))\n+\tderef = new_loc_descr (DW_OP_deref_size, size, 0);\n+\n+      /* Use DW_OP_deref_type for signed integral types if possible, but\n+\t convert back to the generic type to avoid type mismatches later.  */\n       else\n-\top = DW_OP_deref_size;\n+\t{\n+\t  deref = new_loc_descr (dwarf_OP (DW_OP_deref_type), size, 0);\n+\t  deref->dw_loc_oprnd2.val_class = dw_val_class_die_ref;\n+\t  deref->dw_loc_oprnd2.v.val_die_ref.die = type_die;\n+\t  deref->dw_loc_oprnd2.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&deref,\n+\t\t\t new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0));\n+\t}\n \n       if (ret)\n-\tadd_loc_descr (&ret, new_loc_descr (op, size, 0));\n+\tadd_loc_descr (&ret, deref);\n       else\n-\tadd_loc_descr_to_each (list_ret, new_loc_descr (op, size, 0));\n+\tadd_loc_descr_to_each (list_ret, deref);\n     }\n+\n   if (ret)\n     list_ret = new_loc_list (ret, NULL, 0, NULL, 0, NULL);\n \n@@ -19473,25 +19512,22 @@ round_up_to_align (const offset_int &t, unsigned int align)\n static dw_loc_descr_ref\n type_byte_size (const_tree type, HOST_WIDE_INT *cst_size)\n {\n-  tree tree_size;\n-  struct loc_descr_context ctx;\n-\n   /* Return a constant integer in priority, if possible.  */\n   *cst_size = int_size_in_bytes (type);\n   if (*cst_size != -1)\n     return NULL;\n \n-  ctx.context_type = const_cast<tree> (type);\n-  ctx.base_decl = NULL_TREE;\n-  ctx.dpi = NULL;\n-  ctx.placeholder_arg = false;\n-  ctx.placeholder_seen = false;\n+  struct loc_descr_context ctx = {\n+    const_cast<tree> (type),\t/* context_type */\n+    NULL_TREE,\t      \t\t/* base_decl */\n+    NULL,\t      \t\t/* dpi */\n+    false,\t      \t\t/* placeholder_arg */\n+    false,\t      \t\t/* placeholder_seen */\n+    false\t      \t\t/* strict_signedness */\n+  };\n \n-  type = TYPE_MAIN_VARIANT (type);\n-  tree_size = TYPE_SIZE_UNIT (type);\n-  return ((tree_size != NULL_TREE)\n-\t  ? loc_descriptor_from_tree (tree_size, 0, &ctx)\n-\t  : NULL);\n+  tree tree_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type));\n+  return tree_size ? loc_descriptor_from_tree (tree_size, 0, &ctx) : NULL;\n }\n \n /* Helper structure for RECORD_TYPE processing.  */\n@@ -19668,12 +19704,14 @@ field_byte_offset (const_tree decl, struct vlr_context *ctx,\n       *cst_offset = wi::to_offset (tree_result).to_shwi ();\n       return NULL;\n     }\n+\n   struct loc_descr_context loc_ctx = {\n     ctx->struct_type, /* context_type */\n     NULL_TREE,\t      /* base_decl */\n     NULL,\t      /* dpi */\n     false,\t      /* placeholder_arg */\n-    false\t      /* placeholder_seen */\n+    false,\t      /* placeholder_seen */\n+    false\t      /* strict_signedness */\n   };\n   loc_result = loc_list_from_tree (tree_result, 0, &loc_ctx);\n \n@@ -22308,8 +22346,14 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n {\n   const dw_die_ref scope_die = scope_die_for (type, context_die);\n   const dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die, type);\n-  struct loc_descr_context context = { type, info->base_decl, NULL,\n-\t\t\t\t       false, false };\n+  struct loc_descr_context context = {\n+    type, \t\t/* context_type */\n+    info->base_decl,\t/* base_decl */\n+    NULL,\t\t/* dpi */\n+    false,\t\t/* placeholder_arg */\n+    false,\t\t/* placeholder_seen */\n+    false\t\t/* strict_signedness */\n+  };\n   enum dwarf_tag subrange_tag = DW_TAG_subrange_type;\n   int dim;\n \n@@ -25292,13 +25336,6 @@ gen_variant_part (tree variant_part_decl, struct vlr_context *vlr_ctx,\n {\n   const tree variant_part_type = TREE_TYPE (variant_part_decl);\n   tree variant_part_offset = vlr_ctx->variant_part_offset;\n-  struct loc_descr_context ctx = {\n-    vlr_ctx->struct_type, /* context_type */\n-    NULL_TREE,\t\t  /* base_decl */\n-    NULL,\t\t  /* dpi */\n-    false,\t\t  /* placeholder_arg */\n-    false\t\t  /* placeholder_seen */\n-  };\n \n   /* The FIELD_DECL node in STRUCT_TYPE that acts as the discriminant, or\n      NULL_TREE if there is no such field.  */\n@@ -25329,11 +25366,19 @@ gen_variant_part (tree variant_part_decl, struct vlr_context *vlr_ctx,\n     }\n \n   /* If the offset for this variant part is more complex than a constant,\n-     create a DWARF procedure for it so that we will not have to generate DWARF\n-     expressions for it for each member.  */\n+     create a DWARF procedure for it so that we will not have to generate\n+     DWARF expressions for it for each member.  */\n   if (TREE_CODE (variant_part_offset) != INTEGER_CST\n       && (dwarf_version >= 3 || !dwarf_strict))\n     {\n+      struct loc_descr_context ctx = {\n+\tvlr_ctx->struct_type,\t/* context_type */\n+\tNULL_TREE,\t\t/* base_decl */\n+\tNULL,\t\t  \t/* dpi */\n+\tfalse,\t\t  \t/* placeholder_arg */\n+\tfalse,\t\t  \t/* placeholder_seen */\n+\tfalse\t\t  \t/* strict_signedness */\n+      };\n       const tree dwarf_proc_fndecl\n         = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, NULL_TREE,\n \t\t      build_function_type (TREE_TYPE (variant_part_offset),"}]}