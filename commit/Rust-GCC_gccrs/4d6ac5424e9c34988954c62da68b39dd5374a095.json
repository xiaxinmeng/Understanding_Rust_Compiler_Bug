{"sha": "4d6ac5424e9c34988954c62da68b39dd5374a095", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2YWM1NDI0ZTljMzQ5ODg5NTRjNjJkYTY4YjM5ZGQ1Mzc0YTA5NQ==", "commit": {"author": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2002-03-29T22:52:13Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2002-03-29T22:52:13Z"}, "message": "linux_threads.c (return_free_lists): Clear fl[i] unconditionally.\n\n\t* linux_threads.c (return_free_lists): Clear fl[i] unconditionally.\n\t(GC_local_gcj_malloc): Add assertion.\n\t(start_mark_threads): Fix abort message.\n\t* mark.c (GC_mark_from): Generalize assertion.\n\t* reclaim.c (GC_clear_fl_links): New function.\n\t(GC_start_reclaim): Must clear some freelist links.\n\t* include/private/specific.h, specific.c: Add assertions.\n\tSafer definition for INVALID_QTID, quick_thread_id.  Fix/add comments.\n\tRearrange tse fields.\n\nFrom-SVN: r51582", "tree": {"sha": "4a0636ad329ed8fd9f9e42dd3c0ea29b3c5fb6b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a0636ad329ed8fd9f9e42dd3c0ea29b3c5fb6b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6ac5424e9c34988954c62da68b39dd5374a095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6ac5424e9c34988954c62da68b39dd5374a095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6ac5424e9c34988954c62da68b39dd5374a095", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6ac5424e9c34988954c62da68b39dd5374a095/comments", "author": null, "committer": null, "parents": [{"sha": "02a566dcf0d6b8055a34e7d771840c43fde3aba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a566dcf0d6b8055a34e7d771840c43fde3aba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02a566dcf0d6b8055a34e7d771840c43fde3aba5"}], "stats": {"total": 97, "additions": 78, "deletions": 19}, "files": [{"sha": "399f84f58d6ae25ca51edf4fc26c70743bde91bf", "filename": "boehm-gc/include/private/specific.h", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fspecific.h?ref=4d6ac5424e9c34988954c62da68b39dd5374a095", "patch": "@@ -27,16 +27,22 @@\n #define TS_HASH_SIZE 1024\n #define HASH(n) (((((long)n) >> 8) ^ (long)n) & (TS_HASH_SIZE - 1))\n \n+/* An entry describing a thread-specific value for a given thread.\t*/\n+/* All such accessible structures preserve the invariant that if either\t*/\n+/* thread is a valid pthread id or qtid is a valid \"quick tread id\"\t*/\n+/* for a thread, then value holds the corresponding thread specific\t*/\n+/* value.  This invariant must be preserved at ALL times, since\t\t*/\n+/* asynchronous reads are allowed.\t\t\t\t\t*/\n typedef struct thread_specific_entry {\n \tunsigned long qtid;\t/* quick thread id, only for cache */\n \tvoid * value;\n-\tpthread_t thread;\n \tstruct thread_specific_entry *next;\n+\tpthread_t thread;\n } tse;\n \n \n /* We represent each thread-specific datum as two tables.  The first is\t*/\n-/* a cache, index by a \"quick thread identifier\".  The \"quick\" thread\t*/\n+/* a cache, indexed by a \"quick thread identifier\".  The \"quick\" thread\t*/\n /* identifier is an easy to compute value, which is guaranteed to\t*/\n /* determine the thread, though a thread may correspond to more than\t*/\n /* one value.  We typically use the address of a page in the stack.\t*/\n@@ -45,12 +51,15 @@ typedef struct thread_specific_entry {\n \n /* Return the \"quick thread id\".  Default version.  Assumes page size,\t*/\n /* or at least thread stack separation, is at least 4K.\t\t\t*/\n-static __inline__ long quick_thread_id() {\n+/* Must be defined so that it never returns 0.  (Page 0 can't really\t*/\n+/* be part of any stack, since that would make 0 a valid stack pointer.)*/\n+static __inline__ unsigned long quick_thread_id() {\n     int dummy;\n-    return (long)(&dummy) >> 12;\n+    return (unsigned long)(&dummy) >> 12;\n }\n \n-#define INVALID_QTID ((unsigned long)(-1))\n+#define INVALID_QTID ((unsigned long)0)\n+#define INVALID_THREADID ((pthread_t)0)\n \n typedef struct thread_specific_data {\n     tse * volatile cache[TS_CACHE_SIZE];\n@@ -76,7 +85,10 @@ static __inline__ void * PREFIXED(getspecific) (tsd * key) {\n     unsigned hash_val = CACHE_HASH(qtid);\n     tse * volatile * entry_ptr = key -> cache + hash_val;\n     tse * entry = *entry_ptr;   /* Must be loaded only once.\t*/\n-    if (entry -> qtid == qtid) return entry -> value;\n+    if (entry -> qtid == qtid) {\n+      GC_ASSERT(entry -> thread == pthread_self());\n+      return entry -> value;\n+    }\n     return PREFIXED(slow_getspecific) (key, qtid, entry_ptr);\n }\n "}, {"sha": "c968e7cbfd4a934ff6010287ffce025932ae7f3c", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=4d6ac5424e9c34988954c62da68b39dd5374a095", "patch": "@@ -231,15 +231,16 @@ static void return_freelists(ptr_t *fl, ptr_t *gfl)\n \tnwords = i * (GRANULARITY/sizeof(word));\n         qptr = fl + i;\t\n \tq = *qptr;\n-\tif ((word)q < HBLKSIZE) continue;\n-\tif (gfl[nwords] == 0) {\n+\tif ((word)q >= HBLKSIZE) {\n+\t  if (gfl[nwords] == 0) {\n \t    gfl[nwords] = q;\n-\t} else {\n+\t  } else {\n \t    /* Concatenate: */\n \t    for (; (word)q >= HBLKSIZE; qptr = &(obj_link(q)), q = *qptr);\n \t    GC_ASSERT(0 == q);\n \t    *qptr = gfl[nwords];\n \t    gfl[nwords] = fl[i];\n+\t  }\n \t}\n \t/* Clear fl[i], since the thread structure may hang around.\t*/\n \t/* Do it in a way that is likely to trap if we access it.\t*/\n@@ -412,6 +413,7 @@ GC_PTR GC_local_gcj_malloc(size_t bytes,\n \t    /* A memory barrier is probably never needed, since the \t*/\n \t    /* action of stopping this thread will cause prior writes\t*/\n \t    /* to complete.\t\t\t\t\t\t*/\n+\t    GC_ASSERT(((void * volatile *)result)[1] == 0); \n \t    *(void * volatile *)result = ptr_to_struct_containing_descr; \n \t    return result;\n \t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n@@ -544,7 +546,7 @@ static void start_mark_threads()\n \t  ABORT(\"pthread_attr_getstacksize failed\\n\");\n \tif (old_size < MIN_STACK_SIZE) {\n \t  if (pthread_attr_setstacksize(&attr, MIN_STACK_SIZE) != 0)\n-\t    ABORT(\"pthread_attr_getstacksize failed\\n\");\n+\t\t  ABORT(\"pthread_attr_setstacksize failed\\n\");\n \t}\n       }\n #   endif /* HPUX */"}, {"sha": "eb5b9eeb34d9ae11bc6b5e7f75f8c1de3ec80f18", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=4d6ac5424e9c34988954c62da68b39dd5374a095", "patch": "@@ -546,13 +546,13 @@ mse * mark_stack_limit;\n           /* Large length.\t\t\t\t\t        */\n           /* Process part of the range to avoid pushing too much on the\t*/\n           /* stack.\t\t\t\t\t\t\t*/\n+\t  GC_ASSERT(descr < GC_greatest_plausible_heap_addr\n+\t\t\t    - GC_least_plausible_heap_addr);\n #\t  ifdef PARALLEL_MARK\n #\t    define SHARE_BYTES 2048\n \t    if (descr > SHARE_BYTES && GC_parallel\n \t\t&& mark_stack_top < mark_stack_limit - 1) {\n \t      int new_size = (descr/2) & ~(sizeof(word)-1);\n-\t      GC_ASSERT(descr < GC_greatest_plausible_heap_addr\n-\t\t\t        - GC_least_plausible_heap_addr);\n \t      mark_stack_top -> mse_start = current_p;\n \t      mark_stack_top -> mse_descr = new_size + sizeof(word);\n \t\t\t\t\t/* makes sure we handle \t*/"}, {"sha": "0418e9dea652ca04e8401022d98ebed492a3338a", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=4d6ac5424e9c34988954c62da68b39dd5374a095", "patch": "@@ -861,6 +861,25 @@ void GC_print_block_list()\n \n #endif /* NO_DEBUGGING */\n \n+/*\n+ * Clear all obj_link pointers in the list of free objects *flp.\n+ * Clear *flp.\n+ * This must be done before dropping a list of free gcj-style objects,\n+ * since may otherwise end up with dangling \"descriptor\" pointers.\n+ * It may help for other pointer-containg objects.\n+ */\n+void GC_clear_fl_links(flp)\n+ptr_t *flp;\n+{\n+    ptr_t next = *flp;\n+\n+    while (0 != next) {\n+       *flp = 0;\n+       flp = &(obj_link(next));\n+       next = *flp;\n+    }\n+}\n+\n /*\n  * Perform GC_reclaim_block on the entire heap, after first clearing\n  * small object free lists (if we are not just looking for leaks).\n@@ -875,17 +894,24 @@ int report_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n #   endif\n     /* Clear reclaim- and free-lists */\n       for (kind = 0; kind < GC_n_kinds; kind++) {\n-        register ptr_t *fop;\n-        register ptr_t *lim;\n-        register struct hblk ** rlp;\n-        register struct hblk ** rlim;\n-        register struct hblk ** rlist = GC_obj_kinds[kind].ok_reclaim_list;\n+        ptr_t *fop;\n+        ptr_t *lim;\n+        struct hblk ** rlp;\n+        struct hblk ** rlim;\n+        struct hblk ** rlist = GC_obj_kinds[kind].ok_reclaim_list;\n+\tGC_bool should_clobber = (GC_obj_kinds[kind].ok_descriptor != 0);\n         \n         if (rlist == 0) continue;\t/* This kind not used.\t*/\n         if (!report_if_found) {\n             lim = &(GC_obj_kinds[kind].ok_freelist[MAXOBJSZ+1]);\n \t    for( fop = GC_obj_kinds[kind].ok_freelist; fop < lim; fop++ ) {\n-\t      *fop = 0;\n+\t      if (*fop != 0) {\n+\t\tif (should_clobber) {\n+\t\t  GC_clear_fl_links(fop);\n+\t\t} else {\n+\t          *fop = 0;\n+\t\t}\n+\t      }\n \t    }\n \t} /* otherwise free list objects are marked, \t*/\n \t  /* and its safe to leave them\t\t\t*/"}, {"sha": "2c40c2b44a2623996d0a0fbfe34607e4bafb585e", "filename": "boehm-gc/specific.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Fspecific.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6ac5424e9c34988954c62da68b39dd5374a095/boehm-gc%2Fspecific.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fspecific.c?ref=4d6ac5424e9c34988954c62da68b39dd5374a095", "patch": "@@ -16,17 +16,27 @@\n #include \"private/gc_priv.h\" /* For GC_compare_and_exchange, GC_memory_barrier */\n #include \"private/specific.h\"\n \n-static tse invalid_tse; \t/* 0 qtid is guaranteed to be invalid\t*/\n+static tse invalid_tse = {INVALID_QTID, 0, 0, INVALID_THREADID};\n+\t\t\t/* A thread-specific data entry which will never\t*/\n+\t\t\t/* appear valid to a reader.  Used to fill in empty\t*/\n+\t\t\t/* cache entries to avoid a check for 0.\t\t*/\n \n int PREFIXED(key_create) (tsd ** key_ptr, void (* destructor)(void *)) {\n     int i;\n     tsd * result = (tsd *)MALLOC_CLEAR(sizeof (tsd));\n \n+    /* A quick alignment check, since we need atomic stores */\n+      GC_ASSERT((unsigned long)(&invalid_tse.next) % sizeof(tse *) == 0);\n     if (0 == result) return ENOMEM;\n     pthread_mutex_init(&(result -> lock), NULL);\n     for (i = 0; i < TS_CACHE_SIZE; ++i) {\n \tresult -> cache[i] = &invalid_tse;\n     }\n+#   ifdef GC_ASSERTIONS\n+      for (i = 0; i < TS_HASH_SIZE; ++i) {\n+\tGC_ASSERT(result -> hash[i] == 0);\n+      }\n+#   endif\n     *key_ptr = result;\n     return 0;\n }\n@@ -36,12 +46,14 @@ int PREFIXED(setspecific) (tsd * key, void * value) {\n     int hash_val = HASH(self);\n     volatile tse * entry = (volatile tse *)MALLOC_CLEAR(sizeof (tse));\n     \n+    GC_ASSERT(self != INVALID_THREADID);\n     if (0 == entry) return ENOMEM;\n     pthread_mutex_lock(&(key -> lock));\n     /* Could easily check for an existing entry here.\t*/\n     entry -> next = key -> hash[hash_val];\n     entry -> thread = self;\n     entry -> value = value;\n+    GC_ASSERT(entry -> qtid == INVALID_QTID);\n     /* There can only be one writer at a time, but this needs to be\t*/\n     /* atomic with respect to concurrent readers.\t\t\t*/ \n     *(volatile tse **)(key -> hash + hash_val) = entry;\n@@ -70,6 +82,10 @@ void PREFIXED(remove_specific) (tsd * key) {\n \t*link = entry -> next;\n \t/* Atomic! concurrent accesses still work.\t*/\n \t/* They must, since readers don't lock.\t\t*/\n+\t/* We shouldn't need a volatile access here,\t*/\n+\t/* since both this and the preceding write \t*/\n+\t/* should become visible no later than\t\t*/\n+\t/* the pthread_mutex_unlock() call.\t\t*/\n     }\n     /* If we wanted to deallocate the entry, we'd first have to clear \t*/\n     /* any cache entries pointing to it.  That probably requires\t*/\n@@ -91,6 +107,7 @@ void *  PREFIXED(slow_getspecific) (tsd * key, unsigned long qtid,\n     unsigned hash_val = HASH(self);\n     tse *entry = key -> hash[hash_val];\n \n+    GC_ASSERT(qtid != INVALID_QTID);\n     while (entry != NULL && entry -> thread != self) {\n \tentry = entry -> next;\n     } \n@@ -99,6 +116,8 @@ void *  PREFIXED(slow_getspecific) (tsd * key, unsigned long qtid,\n         entry -> qtid = qtid;\n \t\t/* It's safe to do this asynchronously.  Either value \t*/\n \t\t/* is safe, though may produce spurious misses.\t\t*/\n+\t\t/* We're replacing one qtid with another one for the\t*/\n+\t\t/* same thread.\t\t\t\t\t\t*/\n \t*cache_ptr = entry;\n \t\t/* Again this is safe since pointer assignments are \t*/\n \t\t/* presumed atomic, and either pointer is valid.\t*/"}]}