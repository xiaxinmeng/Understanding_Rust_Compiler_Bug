{"sha": "1ce634c39faa75856b8a0468b6f39943a6c8e687", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlNjM0YzM5ZmFhNzU4NTZiOGEwNDY4YjZmMzk5NDNhNmM4ZTY4Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-25T03:57:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-25T03:57:15Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1078", "tree": {"sha": "27f0242849d646f8dc9f7e1865a8560622a89956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27f0242849d646f8dc9f7e1865a8560622a89956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ce634c39faa75856b8a0468b6f39943a6c8e687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce634c39faa75856b8a0468b6f39943a6c8e687", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce634c39faa75856b8a0468b6f39943a6c8e687", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce634c39faa75856b8a0468b6f39943a6c8e687/comments", "author": null, "committer": null, "parents": [{"sha": "a56addeb6398c167db957eb54e7d64177442f69a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56addeb6398c167db957eb54e7d64177442f69a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56addeb6398c167db957eb54e7d64177442f69a"}], "stats": {"total": 52, "additions": 40, "deletions": 12}, "files": [{"sha": "cd4b79e6d804dae294cfd499e3a00708661667e2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce634c39faa75856b8a0468b6f39943a6c8e687/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce634c39faa75856b8a0468b6f39943a6c8e687/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=1ce634c39faa75856b8a0468b6f39943a6c8e687", "patch": "@@ -1568,16 +1568,45 @@ pushdecl (x)\n \t  return t;\n \t}\n \n-      /* If declaring a type as a typedef, and the type has no known\n-\t typedef name, install this TYPE_DECL as its typedef name.  If\n-         generating prototypes, *don't* assign the current name to the\n-         existing type node, but rather give the name its own associated\n-         type node.  This new type node is created as a type variant of\n-         the existing type node, but it is essentially identical to the\n-         existing one.  Obviously, we don't generate these type variants\n-         if the node that we are working on is a standard type and it has\n-         not yet been assigned a name.  In that case we must allow the\n-         standard type to given its standard name (by the compiler).\n+      /* If we are processing a typedef statement, generate a whole new\n+\t ..._TYPE node (which will be just an variant of the existing\n+\t ..._TYPE node with identical properties) and then install the\n+\t TYPE_DECL node generated to represent the typedef name as the\n+\t TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n+\n+\t The whole point here is to end up with a situation where each\n+\t and every ..._TYPE node the compiler creates will be uniquely\n+\t associated with AT MOST one node representing a typedef name.\n+\t This way, even though the compiler substitutes corresponding\n+\t ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n+\t early on, later parts of the compiler can always do the reverse\n+\t translation and get back the corresponding typedef name.  For\n+\t example, given:\n+\n+\t\ttypedef struct S MY_TYPE;\n+\t\tMY_TYPE object;\n+\n+\t Later parts of the compiler might only know that `object' was of\n+\t type `struct S' if if were not for code just below.  With this\n+\t code however, later parts of the compiler see something like:\n+\n+\t\tstruct S' == struct S\n+\t\ttypedef struct S' MY_TYPE;\n+\t\tstruct S' object;\n+\n+\t And they can then deduce (from the node for type struct S') that\n+\t the original object declaration was:\n+\n+\t\tMY_TYPE object;\n+\n+\t Being able to do this is important for proper support of protoize,\n+\t and also for generating precise symbolic debugging information\n+\t which takes full account of the programmer's (typedef) vocabulary.\n+\n+         Obviously, we don't want to generate a duplicate ..._TYPE node if\n+\t the TYPE_DECL node that we are now processing really represents a\n+\t standard built-in type.\n+\n          Since all standard types are effectively declared at line zero\n          in the source file, we can easily check to see if we are working\n          on a standard type by checking the current value of lineno.  */\n@@ -1593,8 +1622,7 @@ pushdecl (x)\n             {\n               tree tt = TREE_TYPE (x);\n \n-              tt = c_build_type_variant (tt,\n-\t\t\t\t\t TYPE_READONLY (tt), TYPE_VOLATILE (tt));\n+              tt = build_type_copy (tt);\n               TYPE_NAME (tt) = x;\n               TREE_TYPE (x) = tt;\n             }"}]}