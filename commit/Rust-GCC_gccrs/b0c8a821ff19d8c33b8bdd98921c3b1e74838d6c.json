{"sha": "b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjOGE4MjFmZjE5ZDhjMzNiOGJkZDk4OTIxYzNiMWU3NDgzOGQ2Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-18T15:51:07Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-18T15:51:07Z"}, "message": "h8300.md: Move movsf patterns into one section of the file.\n\n\t* config/h8300/h8300.md: Move movsf patterns into one section\n\tof the file.\n\nFrom-SVN: r78033", "tree": {"sha": "2089c00c94c3026225d04aca3cf4ce580e7253d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2089c00c94c3026225d04aca3cf4ce580e7253d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c/comments", "author": null, "committer": null, "parents": [{"sha": "aa335b7641d7a40f4d0ec62d25bd5b0c60619ed8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa335b7641d7a40f4d0ec62d25bd5b0c60619ed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa335b7641d7a40f4d0ec62d25bd5b0c60619ed8"}], "stats": {"total": 161, "additions": 83, "deletions": 78}, "files": [{"sha": "e09284cfbfcae2b0eb5af299e13d51729081befe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c", "patch": "@@ -1,3 +1,8 @@\n+2004-02-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.md: Move movsf patterns into one section\n+\tof the file.\n+\n 2004-02-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cfgloop.h, cfgloopanal.c, cpplex.c, except.h, loop-init.c,"}, {"sha": "3f231491a491511deb302efde7d89b8f2ea3219b", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=b0c8a821ff19d8c33b8bdd98921c3b1e74838d6c", "patch": "@@ -276,28 +276,6 @@\n     }\n }\")\n \n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand_dst\" \"\")\n-\t(match_operand:SF 1 \"general_operand_src\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_H8300)\n-    {\n-      if (h8300_expand_movsi (operands))\n-\tDONE;\n-    }\n-  else\n-    {\n-      /* One of the ops has to be in a register.  */\n-      if (!register_operand (operand1, SFmode)\n-\t  && !register_operand (operand0, SFmode))\n-\t{\n-\t  operands[1] = copy_to_mode_reg (SFmode, operand1);\n-\t}\n-    }\n-}\")\n-\n (define_insn \"*movsi_h8300\"\n   [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n \t(match_operand:SI 1 \"general_operand_src\" \"I,r,io,r,r,>\"))]\n@@ -369,62 +347,6 @@\n   [(set (attr \"length\")\n \t(symbol_ref \"compute_mov_length (operands)\"))])\n \n-(define_insn \"*movsf_h8300\"\n-  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n-\t(match_operand:SF 1 \"general_operand_src\" \"G,r,io,r,r,>\"))]\n-  \"TARGET_H8300\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"*\n-{\n-  /* Copy of the movsi stuff.  */\n-  unsigned int rn = -1;\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n-    case 1:\n-      if (REGNO (operands[0]) < REGNO (operands[1]))\n-\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n-      else\n-\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n-    case 2:\n-      /* Make sure we don't trample the register we index with.  */\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  rtx inside = XEXP (operands[1], 0);\n-\t  if (REG_P (inside))\n-\t    {\n-\t      rn = REGNO (inside);\n-\t    }\n-\t  else if (GET_CODE (inside) == PLUS)\n-\t    {\n-\t      rtx lhs = XEXP (inside, 0);\n-\t      rtx rhs = XEXP (inside, 1);\n-\t      if (REG_P (lhs)) rn = REGNO (lhs);\n-\t      if (REG_P (rhs)) rn = REGNO (rhs);\n-\t    }\n-\t}\n-      if (rn == REGNO (operands[0]))\n-\t/* Move the second word first.  */\n-\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n-      else\n-\t/* Move the first word first.  */\n-\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n-\n-    case 3:\n-      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n-    case 4:\n-      return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n-    case 5:\n-      return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n-    default:\n-      abort ();\n-    }\n-}\"\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_mov_length (operands)\"))])\n-\n (define_insn \"*movsi_h8300hs\"\n   [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,<,r,r,m,*a,*a,r\")\n \t(match_operand:SI 1 \"general_operand_src\" \"I,r,i,r,>,m,r,I,r,*a\"))]\n@@ -501,6 +423,84 @@\n \t(symbol_ref \"compute_mov_length (operands)\"))\n    (set_attr \"cc\" \"set_zn,set_znv,clobber,set_znv,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv\")])\n \n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_H8300)\n+    {\n+      if (h8300_expand_movsi (operands))\n+\tDONE;\n+    }\n+  else\n+    {\n+      /* One of the ops has to be in a register.  */\n+      if (!register_operand (operand1, SFmode)\n+\t  && !register_operand (operand0, SFmode))\n+\t{\n+\t  operands[1] = copy_to_mode_reg (SFmode, operand1);\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"*movsf_h8300\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"G,r,io,r,r,>\"))]\n+  \"TARGET_H8300\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"*\n+{\n+  /* Copy of the movsi stuff.  */\n+  unsigned int rn = -1;\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n+    case 1:\n+      if (REGNO (operands[0]) < REGNO (operands[1]))\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+      else\n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+    case 2:\n+      /* Make sure we don't trample the register we index with.  */\n+      if (GET_CODE (operands[1]) == MEM)\n+\t{\n+\t  rtx inside = XEXP (operands[1], 0);\n+\t  if (REG_P (inside))\n+\t    {\n+\t      rn = REGNO (inside);\n+\t    }\n+\t  else if (GET_CODE (inside) == PLUS)\n+\t    {\n+\t      rtx lhs = XEXP (inside, 0);\n+\t      rtx rhs = XEXP (inside, 1);\n+\t      if (REG_P (lhs)) rn = REGNO (lhs);\n+\t      if (REG_P (rhs)) rn = REGNO (rhs);\n+\t    }\n+\t}\n+      if (rn == REGNO (operands[0]))\n+\t/* Move the second word first.  */\n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+      else\n+\t/* Move the first word first.  */\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\n+    case 3:\n+      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    case 4:\n+      return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n+    case 5:\n+      return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"compute_mov_length (operands)\"))])\n+\n (define_insn \"*movsf_h8300hs\"\n   [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,m,<,r\")\n \t(match_operand:SF 1 \"general_operand_src\" \"G,r,im,r,r,>\"))]"}]}