{"sha": "8f9df7d80226bf3f70b311e407eea8b1f16ce355", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5ZGY3ZDgwMjI2YmYzZjcwYjMxMWU0MDdlZWE4YjFmMTZjZTM1NQ==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@gnat.com", "date": "2004-04-19T22:13:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-19T22:13:07Z"}, "message": "* makeutl.ads, makeutl.adb: New files.\n\nFrom-SVN: r80868", "tree": {"sha": "15ad88b6172c64fe653d01c91b38ed69525a3bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15ad88b6172c64fe653d01c91b38ed69525a3bc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f9df7d80226bf3f70b311e407eea8b1f16ce355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9df7d80226bf3f70b311e407eea8b1f16ce355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9df7d80226bf3f70b311e407eea8b1f16ce355", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9df7d80226bf3f70b311e407eea8b1f16ce355/comments", "author": null, "committer": null, "parents": [{"sha": "8e48104da7b58c9e2bf898c2ec9653145bd86a8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e48104da7b58c9e2bf898c2ec9653145bd86a8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e48104da7b58c9e2bf898c2ec9653145bd86a8d"}], "stats": {"total": 477, "additions": 477, "deletions": 0}, "files": [{"sha": "a3e839414a559f930e4b39c9704089daf4611bec", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9df7d80226bf3f70b311e407eea8b1f16ce355/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9df7d80226bf3f70b311e407eea8b1f16ce355/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8f9df7d80226bf3f70b311e407eea8b1f16ce355", "patch": "@@ -91,6 +91,8 @@\n \t(Gnatmake): Move sorting of linker options to function\n \tMakeutl.Linker_Options_Switches.\n \n+\t* makeutl.ads, makeutl.adb: New files.\n+\n \t* Makefile.in: Add makeutl.o to the object files for gnatmake\n \n \t* makeusg.adb: Add line for new switch -eL."}, {"sha": "f5cd39338fdfdb41839273ee5f3f3bb0b05aa647", "filename": "gcc/ada/makeutl.adb", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9df7d80226bf3f70b311e407eea8b1f16ce355/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9df7d80226bf3f70b311e407eea8b1f16ce355/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=8f9df7d80226bf3f70b311e407eea8b1f16ce355", "patch": "@@ -0,0 +1,387 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              M A K E U T L                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Namet;       use Namet;\n+with Prj;         use Prj;\n+with Prj.Ext;\n+with Prj.Util;\n+with Snames;      use Snames;\n+with Table;\n+with Types;       use Types;\n+\n+package body Makeutl is\n+\n+   type Linker_Options_Data is record\n+      Project : Project_Id;\n+      Options : String_List_Id;\n+   end record;\n+\n+   Linker_Option_Initial_Count : constant := 20;\n+\n+   Linker_Options_Buffer : String_List_Access :=\n+     new String_List (1 .. Linker_Option_Initial_Count);\n+\n+   Last_Linker_Option : Natural := 0;\n+\n+   package Linker_Opts is new Table.Table (\n+     Table_Component_Type => Linker_Options_Data,\n+     Table_Index_Type     => Integer,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 10,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Make.Linker_Opts\");\n+\n+   procedure Add_Linker_Option (Option : String);\n+\n+   -----------------------\n+   -- Add_Linker_Option --\n+   -----------------------\n+\n+   procedure Add_Linker_Option (Option : String) is\n+   begin\n+      if Option'Length > 0 then\n+         if Last_Linker_Option = Linker_Options_Buffer'Last then\n+            declare\n+               New_Buffer : constant String_List_Access :=\n+                 new String_List\n+                   (1 .. Linker_Options_Buffer'Last +\n+                         Linker_Option_Initial_Count);\n+            begin\n+               New_Buffer (Linker_Options_Buffer'Range) :=\n+                 Linker_Options_Buffer.all;\n+               Linker_Options_Buffer.all := (others => null);\n+               Free (Linker_Options_Buffer);\n+               Linker_Options_Buffer := New_Buffer;\n+            end;\n+         end if;\n+\n+         Last_Linker_Option := Last_Linker_Option + 1;\n+         Linker_Options_Buffer (Last_Linker_Option) := new String'(Option);\n+      end if;\n+   end Add_Linker_Option;\n+\n+   ----------------------------\n+   -- Is_External_Assignment --\n+   ----------------------------\n+\n+   function Is_External_Assignment (Argv : String) return Boolean is\n+      Start     : Positive := 3;\n+      Finish    : Natural := Argv'Last;\n+      Equal_Pos : Natural;\n+\n+   begin\n+      if Argv'Last < 5 then\n+         return False;\n+\n+      elsif Argv (3) = '\"' then\n+         if Argv (Argv'Last) /= '\"' or else Argv'Last < 7 then\n+            return False;\n+         else\n+            Start := 4;\n+            Finish := Argv'Last - 1;\n+         end if;\n+      end if;\n+\n+      Equal_Pos := Start;\n+\n+      while Equal_Pos <= Finish and then Argv (Equal_Pos) /= '=' loop\n+         Equal_Pos := Equal_Pos + 1;\n+      end loop;\n+\n+      if Equal_Pos = Start\n+        or else Equal_Pos >= Finish\n+      then\n+         return False;\n+\n+      else\n+         Prj.Ext.Add\n+           (External_Name => Argv (Start .. Equal_Pos - 1),\n+            Value         => Argv (Equal_Pos + 1 .. Finish));\n+         return True;\n+      end if;\n+   end Is_External_Assignment;\n+\n+   -----------------------------\n+   -- Linker_Options_Switches --\n+   -----------------------------\n+\n+   function Linker_Options_Switches\n+     (Project  : Project_Id)\n+      return String_List\n+   is\n+\n+      ----------------------------------\n+      -- Recursive_Add_Linker_Options --\n+      ----------------------------------\n+\n+      procedure Recursive_Add_Linker_Options (Proj : Project_Id);\n+\n+      procedure Recursive_Add_Linker_Options (Proj : Project_Id) is\n+         Data : Project_Data;\n+         Linker_Package : Package_Id;\n+         Options : Variable_Value;\n+         Imported : Project_List;\n+      begin\n+         if Proj /= No_Project then\n+            Data := Projects.Table (Proj);\n+\n+            if not Data.Seen then\n+               Projects.Table (Proj).Seen := True;\n+               Imported := Data.Imported_Projects;\n+\n+               while Imported /= Empty_Project_List loop\n+                  Recursive_Add_Linker_Options\n+                    (Project_Lists.Table (Imported).Project);\n+                  Imported := Project_Lists.Table (Imported).Next;\n+               end loop;\n+\n+               if Proj /= Project then\n+                  Linker_Package :=\n+                    Prj.Util.Value_Of\n+                      (Name => Name_Linker,\n+                       In_Packages => Data.Decl.Packages);\n+                  Options :=\n+                    Prj.Util.Value_Of\n+                      (Name => Name_Ada,\n+                       Attribute_Or_Array_Name => Name_Linker_Options,\n+                       In_Package => Linker_Package);\n+\n+                  --  If attribute is present, add the project with\n+                  --  the attribute to table Linker_Opts.\n+\n+                  if Options /= Nil_Variable_Value then\n+                     Linker_Opts.Increment_Last;\n+                     Linker_Opts.Table (Linker_Opts.Last) :=\n+                       (Project => Proj, Options => Options.Values);\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+      end Recursive_Add_Linker_Options;\n+\n+   begin\n+      Linker_Opts.Init;\n+\n+      for Index in 1 .. Projects.Last loop\n+         Projects.Table (Index).Seen := False;\n+      end loop;\n+\n+      Recursive_Add_Linker_Options (Project);\n+\n+      Last_Linker_Option := 0;\n+\n+      for Index in reverse 1 .. Linker_Opts.Last loop\n+         declare\n+            Options : String_List_Id := Linker_Opts.Table (Index).Options;\n+            Proj    : constant Project_Id :=\n+              Linker_Opts.Table (Index).Project;\n+            Option  : Name_Id;\n+\n+         begin\n+            --  If Dir_Path has not been computed for this project, do it now\n+\n+            if Projects.Table (Proj).Dir_Path = null then\n+               Projects.Table (Proj).Dir_Path :=\n+                 new String'\n+                   (Get_Name_String (Projects.Table (Proj). Directory));\n+            end if;\n+\n+            while Options /= Nil_String loop\n+               Option := String_Elements.Table (Options).Value;\n+               Options := String_Elements.Table (Options).Next;\n+               Add_Linker_Option (Get_Name_String (Option));\n+\n+               --  Object files and -L switches specified with\n+               --  relative paths and must be converted to\n+               --  absolute paths.\n+\n+               Test_If_Relative_Path\n+                 (Switch =>\n+                    Linker_Options_Buffer (Last_Linker_Option),\n+                  Parent => Projects.Table (Proj).Dir_Path,\n+                  Including_L_Switch => True);\n+            end loop;\n+         end;\n+      end loop;\n+\n+      return Linker_Options_Buffer (1 .. Last_Linker_Option);\n+   end Linker_Options_Switches;\n+\n+   -----------\n+   -- Mains --\n+   -----------\n+\n+   package body Mains is\n+\n+      package Names is new Table.Table\n+        (Table_Component_Type => File_Name_Type,\n+         Table_Index_Type     => Integer,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 10,\n+         Table_Increment      => 100,\n+         Table_Name           => \"Makeutl.Mains.Names\");\n+      --  The table that stores the mains\n+\n+      Current : Natural := 0;\n+      --  The index of the last main retrieved from the table\n+\n+      --------------\n+      -- Add_Main --\n+      --------------\n+\n+      procedure Add_Main (Name : String) is\n+      begin\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (Name);\n+         Names.Increment_Last;\n+         Names.Table (Names.Last) := Name_Find;\n+      end Add_Main;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete is\n+      begin\n+         Names.Set_Last (0);\n+         Reset;\n+      end Delete;\n+\n+      ---------------\n+      -- Next_Main --\n+      ---------------\n+\n+      function Next_Main return String is\n+      begin\n+         if Current >= Names.Last then\n+            return \"\";\n+\n+         else\n+            Current := Current + 1;\n+            return Get_Name_String (Names.Table (Current));\n+         end if;\n+      end Next_Main;\n+\n+      ---------------------\n+      -- Number_Of_Mains --\n+      ---------------------\n+\n+      function Number_Of_Mains return Natural is\n+      begin\n+         return Names.Last;\n+      end Number_Of_Mains;\n+\n+      -----------\n+      -- Reset --\n+      -----------\n+\n+      procedure Reset is\n+      begin\n+         Current := 0;\n+      end Reset;\n+\n+   end Mains;\n+\n+   ---------------------------\n+   -- Test_If_Relative_Path --\n+   ---------------------------\n+\n+   procedure Test_If_Relative_Path\n+     (Switch             : in out String_Access;\n+      Parent             : String_Access;\n+      Including_L_Switch : Boolean := True)\n+   is\n+   begin\n+      if Switch /= null then\n+\n+         declare\n+            Sw : String (1 .. Switch'Length);\n+            Start : Positive;\n+\n+         begin\n+            Sw := Switch.all;\n+\n+            if Sw (1) = '-' then\n+               if Sw'Length >= 3\n+                 and then (Sw (2) = 'A'\n+                           or else Sw (2) = 'I'\n+                           or else (Including_L_Switch and then Sw (2) = 'L'))\n+               then\n+                  Start := 3;\n+\n+                  if Sw = \"-I-\" then\n+                     return;\n+                  end if;\n+\n+               elsif Sw'Length >= 4\n+                 and then (Sw (2 .. 3) = \"aL\"\n+                           or else Sw (2 .. 3) = \"aO\"\n+                           or else Sw (2 .. 3) = \"aI\")\n+               then\n+                  Start := 4;\n+\n+               else\n+                  return;\n+               end if;\n+\n+               --  Because relative path arguments to --RTS= may be relative\n+               --  to the search directory prefix, those relative path\n+               --  arguments are not converted.\n+\n+               if not Is_Absolute_Path (Sw (Start .. Sw'Last)) then\n+                  if Parent = null or else Parent'Length = 0 then\n+                     Do_Fail\n+                       (\"relative search path switches (\"\"\",\n+                        Sw,\n+                        \"\"\") are not allowed\");\n+\n+                  else\n+                     Switch :=\n+                       new String'\n+                         (Sw (1 .. Start - 1) &\n+                          Parent.all &\n+                          Directory_Separator &\n+                          Sw (Start .. Sw'Last));\n+                  end if;\n+               end if;\n+\n+            else\n+               if not Is_Absolute_Path (Sw) then\n+                  if Parent = null or else Parent'Length = 0 then\n+                     Do_Fail\n+                       (\"relative paths (\"\"\", Sw, \"\"\") are not allowed\");\n+\n+                  else\n+                     Switch :=\n+                       new String'(Parent.all & Directory_Separator & Sw);\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end Test_If_Relative_Path;\n+\n+end Makeutl;"}, {"sha": "3e82e0d010a08591e26b2d5b98afd0aca1d3a5d2", "filename": "gcc/ada/makeutl.ads", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9df7d80226bf3f70b311e407eea8b1f16ce355/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9df7d80226bf3f70b311e407eea8b1f16ce355/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=8f9df7d80226bf3f70b311e407eea8b1f16ce355", "patch": "@@ -0,0 +1,88 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              M A K E U T L                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with Osint;\n+with Prj;         use Prj;\n+\n+package Makeutl is\n+\n+   type Fail_Proc is access procedure\n+     (S1 : String; S2 : String := \"\"; S3 : String := \"\");\n+   Do_Fail : Fail_Proc := Osint.Fail'Access;\n+\n+\n+   function Is_External_Assignment (Argv : String) return Boolean;\n+   --  Verify that an external assignment switch is syntactically correct.\n+   --  Correct forms are\n+   --      -Xname=value\n+   --      -X\"name=other value\"\n+   --  Assumptions: 'First = 1, Argv (1 .. 2) = \"-X\"\n+   --  When this function returns True, the external assignment has\n+   --  been entered by a call to Prj.Ext.Add, so that in a project\n+   --  file, External (\"name\") will return \"value\".\n+\n+   --  Package Mains is used to store the mains specified on the command line\n+   --  and to retrieve them when a project file is used, to verify that the\n+   --  files exist and that they belong to a project file.\n+\n+   function Linker_Options_Switches (Project  : Project_Id) return String_List;\n+\n+   package Mains is\n+\n+      --  Mains are stored in a table. An index is used to retrieve the mains\n+      --  from the table.\n+\n+      procedure Add_Main (Name : String);\n+      --  Add one main to the table\n+\n+      procedure Delete;\n+      --  Empty the table\n+\n+      procedure Reset;\n+      --  Reset the index to the beginning of the table\n+\n+      function Next_Main return String;\n+      --  Increase the index and return the next main.\n+      --  If table is exhausted, return an empty string.\n+\n+      function Number_Of_Mains return Natural;\n+      --  Returns the number of mains added with Add_Main since the last call\n+      --  to Delete.\n+\n+   end Mains;\n+\n+   procedure Test_If_Relative_Path\n+     (Switch             : in out String_Access;\n+      Parent             : String_Access;\n+      Including_L_Switch : Boolean := True);\n+   --  Test if Switch is a relative search path switch.\n+   --  If it is, fail if Parent is null, otherwise prepend the path with\n+   --  Parent. This subprogram is only called when using project files.\n+   --  For gnatbind switches, Including_L_Switch is False, because the\n+   --  argument of the -L switch is not a path.\n+\n+end Makeutl;"}]}